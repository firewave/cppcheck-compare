

##file cppcheck-2.8/lib/config.h

1:
|
78:
79: static const std :: string emptyString@var1 ;

##file cppcheck-2.8/lib/mathlib.h

1:
|
33:
34: class MathLib {
35: friend class TestMathLib ;
36:
37: public:
38:
39: class value {
40: private:
41: long long mIntValue@var2 ;
42: double mDoubleValue@var3 ;
43: enum class Type { INT , LONG , LONGLONG , FLOAT } ; enum Type mType@var4 ;
44: bool mIsUnsigned@var5 ;
45:
46: void promote ( const value & v@var6 ) ;
47:
48: public:
49: explicit value ( const std :: string & s@var7 ) ;
50: std :: string str ( ) const ;
51: bool isInt ( ) const {
52: return mType@var4 !=@expr1073745621 Type ::@expr1073745622 FLOAT ;
53: }
54: bool isFloat ( ) const {
55: return mType@var4 ==@expr1073745623 Type ::@expr1073745624 FLOAT ;
56: }
57:
58: double getDoubleValue ( ) const {
59: return isFloat (@expr1073745625 ) ?@expr1073745626 mDoubleValue@var3 :@expr1073745627 (@expr1073745628 double ) mIntValue@var2 ;
60: }
61:
62: static value calc ( char op@var8 , const value & v1@var9 , const value & v2@var10 ) ;
63: int compare ( const value & v@var11 ) const ;
64: value add ( int v@var12 ) const ;
65: value shiftLeft ( const value & v@var13 ) const ;
66: value shiftRight ( const value & v@var14 ) const ;
67: } ;
68:
69:
70:
71: static const int bigint_bits@var15 ;
72:
73: static long long toLongNumber ( const std :: string & str@var16 ) ;
74: static unsigned long long toULongNumber ( const std :: string & str@var17 ) ;
75:
76: template < class T > static std :: string toString ( T value@var18 ) {
77: std ::@expr1073745629 ostringstream result@var19 ;
78: result@var19 <<@expr1073745630 value@var18 ;
79: return result@var19 .@expr1073745631 str (@expr1073745632 ) ;
80: }
81: static double toDoubleNumber ( const std :: string & str@var20 ) ;
82:
83: static bool isInt ( const std :: string & str@var21 ) ;
84: static bool isFloat ( const std :: string & str@var22 ) ;
85: static bool isDecimalFloat ( const std :: string & str@var23 ) ;
86: static bool isNegative ( const std :: string & str@var24 ) ;
87: static bool isPositive ( const std :: string & str@var25 ) ;
88: static bool isDec ( const std :: string & str@var26 ) ;
89: static bool isFloatHex ( const std :: string & str@var27 ) ;
90: static bool isIntHex ( const std :: string & str@var28 ) ;
91: static bool isOct ( const std :: string & str@var29 ) ;
92: static bool isBin ( const std :: string & str@var30 ) ;
93:
94: static std :: string getSuffix ( const std :: string & value@var31 ) ;
95:
|
101:
102: static bool isValidIntegerSuffix ( const std :: string & str@var32 , bool supportMicrosoftExtensions@var33 = true ) ;
103:
104: static std :: string add ( const std :: string & first@var34 , const std :: string & second@var35 ) ;
105: static std :: string subtract ( const std :: string & first@var36 , const std :: string & second@var37 ) ;
106: static std :: string multiply ( const std :: string & first@var38 , const std :: string & second@var39 ) ;
107: static std :: string divide ( const std :: string & first@var40 , const std :: string & second@var41 ) ;
108: static std :: string mod ( const std :: string & first@var42 , const std :: string & second@var43 ) ;
109: static std :: string incdec ( const std :: string & var@var44 , const std :: string & op@var45 ) ;
110: static std :: string calculate ( const std :: string & first@var46 , const std :: string & second@var47 , char action@var48 ) ;
111:
112: static std :: string sin ( const std :: string & tok@var49 ) ;
113: static std :: string cos ( const std :: string & tok@var50 ) ;
114: static std :: string tan ( const std :: string & tok@var51 ) ;
115: static std :: string abs ( const std :: string & tok@var52 ) ;
116: static bool isEqual ( const std :: string & first@var53 , const std :: string & second@var54 ) ;
117: static bool isNotEqual ( const std :: string & first@var55 , const std :: string & second@var56 ) ;
118: static bool isGreater ( const std :: string & first@var57 , const std :: string & second@var58 ) ;
119: static bool isGreaterEqual ( const std :: string & first@var59 , const std :: string & second@var60 ) ;
120: static bool isLess ( const std :: string & first@var61 , const std :: string & second@var62 ) ;
121: static bool isLessEqual ( const std :: string & first@var63 , const std :: string & second@var64 ) ;
122: static bool isNullValue ( const std :: string & str@var65 ) ;
123:
|
127:
128: static bool isOctalDigit ( char c@var66 ) ;
129:
130: static unsigned int encodeMultiChar ( const std :: string & str@var67 ) ;
131:
|
136:
137: static bool isDigitSeparator ( const std :: string & iCode@var68 , std :: string :: size_type iPos@var69 ) ;
138: } ;
139:
140: MathLib :: value operator+ ( const MathLib :: value & v1@var70 , const MathLib :: value & v2@var71 ) ;
141: MathLib :: value operator- ( const MathLib :: value & v1@var72 , const MathLib :: value & v2@var73 ) ;
142: MathLib :: value operator* ( const MathLib :: value & v1@var74 , const MathLib :: value & v2@var75 ) ;
143: MathLib :: value operator/ ( const MathLib :: value & v1@var76 , const MathLib :: value & v2@var77 ) ;
144: MathLib :: value operator% ( const MathLib :: value & v1@var78 , const MathLib :: value & v2@var79 ) ;
145: MathLib :: value operator& ( const MathLib :: value & v1@var80 , const MathLib :: value & v2@var81 ) ;
146: MathLib :: value operator| ( const MathLib :: value & v1@var82 , const MathLib :: value & v2@var83 ) ;
147: MathLib :: value operator^ ( const MathLib :: value & v1@var84 , const MathLib :: value & v2@var85 ) ;
148: MathLib :: value operator<< ( const MathLib :: value & v1@var86 , const MathLib :: value & v2@var87 ) ;
149: MathLib :: value operator>> ( const MathLib :: value & v1@var88 , const MathLib :: value & v2@var89 ) ;
150:
151: template < > std :: string MathLib :: toString < double > ( double value@var90 ) ;

##file cppcheck-2.8/lib/errortypes.h

1:
|
31:
32: class Token ;
33:
34:
35: struct InternalError {
36: enum Type { AST , SYNTAX , UNKNOWN_MACRO , INTERNAL , LIMIT , INSTANTIATION } ;
37: InternalError ( const Token * tok@var91 , const std :: string & errorMsg@var92 , Type type@var93 = INTERNAL ) ;
38: const Token * token@var94 ;
39: std :: string errorMessage@var95 ;
40: Type type@var96 ;
41: std :: string id@var97 ;
42: } ;
43:
44: class Certainty {
45: public:
46: enum CertaintyLevel {
47: normal , inconclusive , safe , experimental
48: } ;
49: } ;
50:
51: class Checks {
52: public:
53: enum CheckList {
54: unusedFunction , missingInclude , internalCheck
55: } ;
56: } ;
57:
58:
59: class Severity {
60: public:
61:
62:
63:
64: enum SeverityType {
65:
66:
67:
68: none ,
69:
|
73:
74: error ,
75:
|
79:
80: warning ,
81:
|
86:
87: style ,
88:
|
92:
93: performance ,
94:
|
100:
101: portability ,
102:
|
107:
108: information ,
109:
|
112:
113: debug
114: } ;
115:
116: static std :: string toString ( SeverityType severity@var98 ) ;
117: static SeverityType fromString ( const std :: string & severity@var99 ) ;
118: } ;
119:
120: struct CWE {
121: explicit CWE ( unsigned short cweId@var100 ) : id@var101 ( cweId@var100 ) { }
122: unsigned short id@var101 ;
123: } ;

##file cppcheck-2.8/lib/utils.h

1:
|
31:
32: struct SelectMapKeys {
33: template < class Pair >
34: Pair :: first_type operator() ( const Pair & p@var102 ) const {
35: return p@var102 .@expr1073745633 first@var103 ;
36: }
37: } ;
38:
39: struct SelectMapValues {
40: template < class Pair >
41: Pair :: second_type operator() ( const Pair & p@var104 ) const {
42: return p@var104 .@expr1073745634 second@var105 ;
43: }
44: } ;
45:
46: template < class Range , class T >
47: bool contains ( const Range & r@var106 , const T & x@var107 )
48: {
49: return std ::@expr1073745635 find (@expr1073745636 r@var106 .@expr1073745637 begin (@expr1073745638 ) , r@var106 .@expr3815 end (@expr3816 ) , x@var107 ) !=@expr1073745641 r@var106 .@expr3815 end (@expr3816 ) ;
50: }
51:
52: template < class T >
53: bool contains ( const std :: initializer_list < T > & r@var108 , const T & x@var109 )
54: {
55: return std ::@expr1073745644 find (@expr1073745645 r@var108 .@expr1073745646 begin (@expr1073745647 ) , r@var108 .@expr3824 end (@expr3825 ) , x@var109 ) !=@expr1073745650 r@var108 .@expr3824 end (@expr3825 ) ;
56: }
57:
58: template < class T , class U >
59: bool contains ( const std :: initializer_list < T > & r@var110 , const U & x@var111 )
60: {
61: return std ::@expr1073745653 find (@expr1073745654 r@var110 .@expr1073745655 begin (@expr1073745656 ) , r@var110 .@expr3833 end (@expr3834 ) , x@var111 ) !=@expr1073745659 r@var110 .@expr3833 end (@expr3834 ) ;
62: }
63:
64:
65: struct EnumClassHash {
66: template < typename T >
67: unsigned long operator() ( T t@var112 ) const
68: {
69: return static_cast < unsigned long > (@expr1073745662 t@var112 ) ;
70: }
71: } ;
72:
73: bool endsWith ( const std :: string & str@var113 , char c@var114 )
74: {
75: return !@expr1073745663 str@var113 .@expr1073745664 empty (@expr1073745665 ) &&@expr1073745666 str@var113 .@expr1073745667 back (@expr1073745668 ) ==@expr1073745669 c@var114 ;
76: }
77:
78: bool endsWith ( const std :: string & str@var115 , const char end@var116 [ ] , unsigned long endlen@var117 )
79: {
80: return (@expr3846 str@var115 .@expr3847 size (@expr3848 ) >=@expr1073745673 endlen@var117 ) &&@expr1073745674 (@expr3846 str@var115 .@expr1073745676 compare (@expr1073745677 str@var115 .@expr3847 size (@expr3848 ) -@expr1073745680 endlen@var117 , endlen@var117 , end@var116 ) ==@expr1073745681 0 ) ;
81: }
82:
83: template < unsigned long N >
84: bool endsWith ( const std :: string & str@var118 , const char ( & end@var119 ) [ N ] )
85: {
86: return endsWith (@expr1073745683 str@var118 , end@var119 , N@expr1073745682 -@expr1073745684 1 ) ;
87: }
88:
89: static bool isPrefixStringCharLiteral ( const std :: string & str@var120 , char q@var121 , const std :: string & p@var122 )
90: {
91: if (@expr1073745685 !@expr1073745686 endsWith (@expr1073745687 str@var120 , q@var121 ) ) {
92: return false ; }
93: if (@expr1073745688 (@expr1073745689 str@var120 .@expr1073745690 length (@expr1073745691 ) +@expr1073745692 1 ) >@expr1073745693 p@var122 .@expr1073745694 length (@expr1073745695 ) &&@expr1073745696 (@expr1073745697 str@var120 .@expr1073745698 compare (@expr1073745699 0 , p@var122 .@expr1073745700 size (@expr1073745701 ) +@expr1073745702 1 , p@var122 +@expr1073745703 q@var121 ) ==@expr1073745704 0 ) ) {
94: return true ; }
95: return false ;
96: }
97:
98: static bool isStringCharLiteral ( const std :: string & str@var123 , char q@var124 )
99: {
100: static const std ::@expr3881 vector < std ::@expr3881 string > suffixes@var125 {@expr1073745707 "" , "u8" , "u" , "U" , "L" } ;
101: for (@expr1073745708 const std ::@expr3881 string &@expr1073745710 p@var126 :@expr1073745711 suffixes@var125 ) {
102: if (@expr1073745712 isPrefixStringCharLiteral (@expr1073745713 str@var123 , q@var124 , p@var126 ) ) {
103: return true ; }
104: }
105: return false ;
106: }
107:
108: static bool isStringLiteral ( const std :: string & str@var127 )
109: {
110: return isStringCharLiteral (@expr1073745714 str@var127 , '"' ) ;
111: }
112:
113: static bool isCharLiteral ( const std :: string & str@var128 )
114: {
115: return isStringCharLiteral (@expr1073745715 str@var128 , '\'' ) ;
116: }
117:
118: static std :: string getStringCharLiteral ( const std :: string & str@var129 , char q@var130 )
119: {
120: const unsigned long quotePos@var131 =@expr1073745716 str@var129 .@expr1073745717 find (@expr1073745718 q@var130 ) ;
121: return str@var129 .@expr1073745719 substr (@expr1073745720 quotePos@var131 +@expr1073745721 1U , str@var129 .@expr1073745722 size (@expr1073745723 ) -@expr1073745724 quotePos@var131 -@expr1073745725 2U ) ;
122: }
123:
124: static std :: string getStringLiteral ( const std :: string & str@var132 )
125: {
126: if (@expr1073745726 isStringLiteral (@expr1073745727 str@var132 ) ) {
127: return getStringCharLiteral (@expr1073745728 str@var132 , '"' ) ; }
128: return "" ;
129: }
130:
131: static std :: string getCharLiteral ( const std :: string & str@var133 )
132: {
133: if (@expr1073745729 isCharLiteral (@expr1073745730 str@var133 ) ) {
134: return getStringCharLiteral (@expr1073745731 str@var133 , '\'' ) ; }
135: return "" ;
136: }
137:
138: static const char * getOrdinalText ( int i@var134 )
139: {
140: if (@expr1073745732 i@var134 ==@expr1073745733 1 ) {
141: return "st" ; }
142: if (@expr1073745734 i@var134 ==@expr1073745735 2 ) {
143: return "nd" ; }
144: if (@expr1073745736 i@var134 ==@expr1073745737 3 ) {
145: return "rd" ; }
146: return "th" ;
147: }
148:
149: int caseInsensitiveStringCompare ( const std :: string & lhs@var135 , const std :: string & rhs@var136 ) ;
150:
151: bool isValidGlobPattern ( const std :: string & pattern@var137 ) ;
152:
153: bool matchglob ( const std :: string & pattern@var138 , const std :: string & name@var139 ) ;
154:
155: bool matchglobs ( const std :: vector < std :: string > & patterns@var140 , const std :: string & name@var141 ) ;
156:
157: void strTolower ( std :: string & str@var142 ) ;

##file cppcheck-2.8/lib/standards.h

1:
|
35:
36: struct Standards {
37:
38: enum cstd_t { C89 , C99 , C11 , CLatest = C11 } ; enum cstd_t c@var143 ;
39:
40:
41: enum cppstd_t { CPP03 , CPP11 , CPP14 , CPP17 , CPP20 , CPP23 , CPPLatest = CPP23 } ; enum cppstd_t cpp@var144 ;
42:
43:
44: std :: string stdValue@var145 ;
45:
46:
47: Standards ( ) : c@var143 ( CLatest ) , cpp@var144 ( CPPLatest ) { }
48:
49: bool setC ( const std :: string & str@var146 ) {
50: stdValue@var145 =@expr1073745738 str@var146 ;
51: if (@expr1073745739 str@var146 ==@expr1073745740 "c89" ||@expr1073745741 str@var146 ==@expr1073745742 "C89" ) {
52: c@var143 =@expr1073745743 C89 ;
53: return true ;
54: }
55: if (@expr1073745744 str@var146 ==@expr1073745745 "c99" ||@expr1073745746 str@var146 ==@expr1073745747 "C99" ) {
56: c@var143 =@expr1073745748 C99 ;
57: return true ;
58: }
59: if (@expr1073745749 str@var146 ==@expr1073745750 "c11" ||@expr1073745751 str@var146 ==@expr1073745752 "C11" ) {
60: c@var143 =@expr1073745753 C11 ;
61: return true ;
62: }
63: return false ;
64: }
65: const std :: string getC ( ) const {
66: switch (@expr1073745754 c@var143 ) {
67: case C89 :@expr3931 ;
68: return "c89" ;
69: case C99 :@expr3931 ;
70: return "c99" ;
71: case C11 :@expr3931 ;
72: return "c11" ;
73: }
74: return "" ;
75: }
76: static cstd_t getC ( const std :: string & std@var147 ) {
77: if (@expr1073745758 std@var147 ==@expr1073745759 "c89" ) {
78: return Standards ::@expr1073745760 C89 ;
79: }
80: if (@expr1073745761 std@var147 ==@expr1073745762 "c99" ) {
81: return Standards ::@expr1073745763 C99 ;
82: }
83: if (@expr1073745764 std@var147 ==@expr1073745765 "c11" ) {
84: return Standards ::@expr1073745766 C11 ;
85: }
86: return Standards ::@expr1073745767 CLatest ;
87: }
88: bool setCPP ( std :: string str@var148 ) {
89: stdValue@var145 =@expr1073745768 str@var148 ;
90: strTolower (@expr1073745769 str@var148 ) ;
91: cpp@var144 =@expr1073745770 getCPP (@expr1073745771 str@var148 ) ;
92: return !@expr1073745772 stdValue@var145 .@expr1073745773 empty (@expr1073745774 ) &&@expr1073745775 str@var148 ==@expr1073745776 getCPP (@expr1073745777 ) ;
93: }
94: std :: string getCPP ( ) const {
95: return getCPP (@expr1073745778 cpp@var144 ) ;
96: }
97: static std :: string getCPP ( cppstd_t std@var149 ) {
98: switch (@expr1073745779 std@var149 ) {
99: case CPP03 :@expr3956 ;
100: return "c++03" ;
101: case CPP11 :@expr3956 ;
102: return "c++11" ;
103: case CPP14 :@expr3956 ;
104: return "c++14" ;
105: case CPP17 :@expr3956 ;
106: return "c++17" ;
107: case CPP20 :@expr3956 ;
108: return "c++20" ;
109: case CPP23 :@expr3956 ;
110: return "c++23" ;
111: }
112: return "" ;
113: }
114: static cppstd_t getCPP ( const std :: string & std@var150 ) {
115: if (@expr1073745786 std@var150 ==@expr1073745787 "c++03" ) {
116: return Standards ::@expr1073745788 CPP03 ;
117: }
118: if (@expr1073745789 std@var150 ==@expr1073745790 "c++11" ) {
119: return Standards ::@expr1073745791 CPP11 ;
120: }
121: if (@expr1073745792 std@var150 ==@expr1073745793 "c++14" ) {
122: return Standards ::@expr1073745794 CPP14 ;
123: }
124: if (@expr1073745795 std@var150 ==@expr1073745796 "c++17" ) {
125: return Standards ::@expr1073745797 CPP17 ;
126: }
127: if (@expr1073745798 std@var150 ==@expr1073745799 "c++20" ) {
128: return Standards ::@expr1073745800 CPP20 ;
129: }
130: if (@expr1073745801 std@var150 ==@expr1073745802 "c++23" ) {
131: return Standards ::@expr1073745803 CPP23 ;
132: }
133: return Standards ::@expr1073745804 CPPLatest ;
134: }
135: } ;

##file cppcheck-2.8/lib/library.h

1:
|
37:
38: class Token ;
39: class Settings ;
40:
41: namespace tinyxml2 {
42: class XMLDocument ;
43: class XMLElement ;
44: }
45:
|
51:
52: class Library {
53: friend class TestSymbolDatabase ;
54:
55: public:
56: Library ( ) ;
57:
58: enum class ErrorCode { OK , FILE_NOT_FOUND , BAD_XML , UNKNOWN_ELEMENT , MISSING_ATTRIBUTE , BAD_ATTRIBUTE_VALUE , UNSUPPORTED_FORMAT , DUPLICATE_PLATFORM_TYPE , PLATFORM_TYPE_REDEFINED } ;
59:
60: class Error {
61: public:
62: Error ( ) : errorcode@var154 ( ErrorCode :: OK ) { }
63: explicit Error ( ErrorCode e@var151 ) : errorcode@var154 ( e@var151 ) { }
64: template < typename T >
65: Error ( ErrorCode e@var152 , T && r@var153 ) : errorcode@var154 ( e@var152 ) , reason@var155 ( r@var153 ) { }
66: ErrorCode errorcode@var154 ;
67: std :: string reason@var155 ;
68: } ;
69:
70: Error load ( const char exename@var156 [ ] , const char path@var157 [ ] ) ;
71: Error load ( const tinyxml2 :: XMLDocument & doc@var158 ) ;
72:
73:
74: bool loadxmldata ( const char xmldata@var159 [ ] , unsigned long len@var160 ) ;
75:
76: struct AllocFunc {
77: int groupId@var161 ;
78: int arg@var162 ;
79: enum class BufferSize { none , malloc , calloc , strdup } ;
80: BufferSize bufferSize@var163 ;
81: int bufferSizeArg1@var164 ;
82: int bufferSizeArg2@var165 ;
83: int reallocArg@var166 ;
84: bool initData@var167 ;
85: } ;
86:
87:
88: const AllocFunc * getAllocFuncInfo ( const Token * tok@var168 ) const ;
89:
90:
91: const AllocFunc * getDeallocFuncInfo ( const Token * tok@var169 ) const ;
92:
93:
94: const AllocFunc * getReallocFuncInfo ( const Token * tok@var170 ) const ;
95:
96:
97: int getAllocId ( const Token * tok@var171 , int arg@var172 ) const ;
98:
99:
100: int getDeallocId ( const Token * tok@var173 , int arg@var174 ) const ;
101:
102:
103: int getReallocId ( const Token * tok@var175 , int arg@var176 ) const ;
104:
105:
106: const AllocFunc * getAllocFuncInfo ( const char name@var177 [ ] ) const {
107: return getAllocDealloc (@expr1073745805 mAlloc@var443 , name@var177 ) ;
108: }
109:
110:
111: const AllocFunc * getDeallocFuncInfo ( const char name@var178 [ ] ) const {
112: return getAllocDealloc (@expr1073745806 mDealloc@var444 , name@var178 ) ;
113: }
114:
115:
116: int allocId ( const char name@var179 [ ] ) const {
117: const AllocFunc * af@var180 ; af@var180 =@expr1073745807 getAllocDealloc (@expr1073745808 mAlloc@var443 , name@var179 ) ;
118: return af@var180 ?@expr1073745809 af@var180 .@expr1073745810 groupId@var181 :@expr1073745811 0 ;
119: }
120:
121:
122: int deallocId ( const char name@var182 [ ] ) const {
123: const AllocFunc * af@var183 ; af@var183 =@expr1073745812 getAllocDealloc (@expr1073745813 mDealloc@var444 , name@var182 ) ;
124: return af@var183 ?@expr1073745814 af@var183 .@expr1073745815 groupId@var184 :@expr1073745816 0 ;
125: }
126:
127:
128: void setalloc ( const std :: string & functionname@var185 , int id@var186 , int arg@var187 ) {
129: mAlloc@var443 [@expr3993 functionname@var185 ] .@expr1073745818 groupId@var3833 =@expr1073745819 id@var186 ;
130: mAlloc@var443 [@expr3993 functionname@var185 ] .@expr1073745821 arg@var3834 =@expr1073745822 arg@var187 ;
131: }
132:
133: void setdealloc ( const std :: string & functionname@var188 , int id@var189 , int arg@var190 ) {
134: mDealloc@var444 [@expr3999 functionname@var188 ] .@expr1073745824 groupId@var3835 =@expr1073745825 id@var189 ;
135: mDealloc@var444 [@expr3999 functionname@var188 ] .@expr1073745827 arg@var3836 =@expr1073745828 arg@var190 ;
136: }
137:
138: void setrealloc ( const std :: string & functionname@var191 , int id@var192 , int arg@var193 , int reallocArg@var194 = 1 ) {
139: mRealloc@var445 [@expr4005 functionname@var191 ] .@expr1073745830 groupId@var3837 =@expr1073745831 id@var192 ;
140: mRealloc@var445 [@expr4005 functionname@var191 ] .@expr1073745833 arg@var3838 =@expr1073745834 arg@var193 ;
141: mRealloc@var445 [@expr4005 functionname@var191 ] .@expr1073745836 reallocArg@var3839 =@expr1073745837 reallocArg@var194 ;
142: }
143:
144:
145: void setnoreturn ( const std :: string & funcname@var195 , bool noreturn@var196 ) {
146: mNoReturn@var446 [@expr1073745838 funcname@var195 ] =@expr1073745839 noreturn@var196 ?@expr1073745840 FalseTrueMaybe ::@expr1073745841 True :@expr1073745842 FalseTrueMaybe ::@expr1073745843 False ;
147: }
148:
149: static bool isCompliantValidationExpression ( const char * p@var197 ) ;
150:
151:
152: static bool ismemory ( const int id@var198 ) {
153: return (@expr4020 (@expr4020 id@var198 >@expr1073745846 0 ) &&@expr1073745847 (@expr4020 (@expr4020 id@var198 &@expr1073745850 1 ) ==@expr1073745851 0 ) ) ;
154: }
155: static bool ismemory ( const AllocFunc * const func@var199 ) {
156: return (@expr4028 (@expr4028 func@var199 .@expr4030 groupId@var200 >@expr1073745855 0 ) &&@expr1073745856 (@expr4028 (@expr4028 func@var199 .@expr4030 groupId@var200 &@expr1073745860 1 ) ==@expr1073745861 0 ) ) ;
157: }
158:
159:
160: static bool isresource ( const int id@var201 ) {
161: return (@expr4038 (@expr4038 id@var201 >@expr1073745864 0 ) &&@expr1073745865 (@expr4038 (@expr4038 id@var201 &@expr1073745868 1 ) ==@expr1073745869 1 ) ) ;
162: }
163: static bool isresource ( const AllocFunc * const func@var202 ) {
164: return (@expr4046 (@expr4046 func@var202 .@expr4048 groupId@var203 >@expr1073745873 0 ) &&@expr1073745874 (@expr4046 (@expr4046 func@var202 .@expr4048 groupId@var203 &@expr1073745878 1 ) ==@expr1073745879 1 ) ) ;
165: }
166:
167: bool formatstr_function ( const Token * ftok@var204 ) const ;
168: int formatstr_argno ( const Token * ftok@var205 ) const ;
169: bool formatstr_scan ( const Token * ftok@var206 ) const ;
170: bool formatstr_secure ( const Token * ftok@var207 ) const ;
171:
172: struct NonOverlappingData {
173: int ptr1Arg@var208 ;
174: int ptr2Arg@var209 ;
175: int sizeArg@var210 ;
176: int strlenArg@var211 ;
177: } ;
178: const NonOverlappingData * getNonOverlappingData ( const Token * ftok@var212 ) const ;
179:
180: struct WarnInfo {
181: std :: string message@var213 ;
182: Standards standards@var214 ;
183: Severity :: SeverityType severity@var215 ;
184: } ;
185: std :: map < std :: string , WarnInfo > functionwarn@var216 ;
186:
187: const WarnInfo * getWarnInfo ( const Token * ftok@var217 ) const ;
188:
189:
190: bool isNotLibraryFunction ( const Token * ftok@var218 ) const ;
191: bool matchArguments ( const Token * ftok@var219 , const std :: string & functionName@var220 ) const ;
192:
193: enum class UseRetValType { NONE , DEFAULT , ERROR_CODE } ;
194: UseRetValType getUseRetValType ( const Token * ftok@var221 ) const ;
195:
196: const std :: string & returnValue ( const Token * ftok@var222 ) const ;
197: const std :: string & returnValueType ( const Token * ftok@var223 ) const ;
198: int returnValueContainer ( const Token * ftok@var224 ) const ;
199: std :: vector < long long > unknownReturnValues ( const Token * ftok@var225 ) const ;
200:
201: bool isnoreturn ( const Token * ftok@var226 ) const ;
202: bool isnotnoreturn ( const Token * ftok@var227 ) const ;
203:
204: bool isScopeNoReturn ( const Token * end@var228 , std :: string * unknownFunc@var229 ) const ;
205:
206: class Container {
207: public:
208: Container ( )
209: : type_templateArgNo@var239 ( -1 ) ,
210: size_templateArgNo@var241 ( -1 ) ,
211: arrayLike_indexOp@var242 ( false ) ,
212: stdStringLike@var243 ( false ) ,
213: stdAssociativeLike@var244 ( false ) ,
214: opLessAllowed@var245 ( true ) ,
215: hasInitializerListConstructor@var246 ( false ) ,
216: unstableErase@var247 ( false ) ,
217: unstableInsert@var248 ( false ) ,
218: view@var249 ( false )
219: { }
220:
221: enum class Action {
222: RESIZE ,
223: CLEAR ,
224: PUSH ,
225: POP ,
226: FIND ,
227: INSERT ,
228: ERASE ,
229: CHANGE_CONTENT ,
230: CHANGE ,
231: CHANGE_INTERNAL ,
232: NO_ACTION
233: } ;
234: enum class Yield {
235: AT_INDEX ,
236: ITEM ,
237: BUFFER ,
238: BUFFER_NT ,
239: START_ITERATOR ,
240: END_ITERATOR ,
241: ITERATOR ,
242: SIZE ,
243: EMPTY ,
244: NO_YIELD
245: } ;
246: struct Function {
247: Action action@var230 ;
248: Yield yield@var231 ;
249: } ;
250: struct RangeItemRecordTypeItem {
251: std :: string name@var232 ;
252: int templateParameter@var233 ;
253: } ;
254: std :: string startPattern@var234 ; std :: string startPattern2@var235 ; std :: string endPattern@var236 ; std :: string itEndPattern@var237 ;
255: std :: map < std :: string , Function > functions@var238 ;
256: int type_templateArgNo@var239 ;
257: std :: vector < RangeItemRecordTypeItem > rangeItemRecordType@var240 ;
258: int size_templateArgNo@var241 ;
259: bool arrayLike_indexOp@var242 ;
260: bool stdStringLike@var243 ;
261: bool stdAssociativeLike@var244 ;
262: bool opLessAllowed@var245 ;
263: bool hasInitializerListConstructor@var246 ;
264: bool unstableErase@var247 ;
265: bool unstableInsert@var248 ;
266: bool view@var249 ;
267:
268: Action getAction ( const std :: string & function@var250 ) const {
269: const std ::@expr1073745880 map < std ::@expr1073745881 string , Function > ::@expr1073745882 const_iterator i@var251 =@expr1073745883 functions@var238 .@expr1073745884 find (@expr1073745885 function@var250 ) ;
270: if (@expr1073745886 i@var251 !=@expr1073745887 functions@var238 .@expr1073745888 end (@expr1073745889 ) ) {
271: return i@var251 .@expr1073745890 second@var252 .@expr1073745891 action@var253 ; }
272: return Action ::@expr1073745892 NO_ACTION ;
273: }
274:
275: Yield getYield ( const std :: string & function@var254 ) const {
276: const std ::@expr1073745893 map < std ::@expr1073745894 string , Function > ::@expr1073745895 const_iterator i@var255 =@expr1073745896 functions@var238 .@expr1073745897 find (@expr1073745898 function@var254 ) ;
277: if (@expr1073745899 i@var255 !=@expr1073745900 functions@var238 .@expr1073745901 end (@expr1073745902 ) ) {
278: return i@var255 .@expr1073745903 second@var256 .@expr1073745904 yield@var257 ; }
279: return Yield ::@expr1073745905 NO_YIELD ;
280: }
281:
282: static Yield yieldFrom ( const std :: string & yieldName@var258 ) ;
283: static Action actionFrom ( const std :: string & actionName@var259 ) ;
284: } ;
285: std :: map < std :: string , Container > containers@var260 ;
286: const Container * detectContainer ( const Token * typeStart@var261 , bool iterator@var262 = false ) const ;
287: const Container * detectContainerOrIterator ( const Token * typeStart@var263 , bool * isIterator@var264 = nullptr ) const ;
288:
289: class ArgumentChecks {
290: public:
291: ArgumentChecks ( ) :
292: notbool@var265 ( false ) ,
293: notnull@var266 ( false ) ,
294: notuninit@var267 ( -1 ) ,
295: formatstr@var268 ( false ) ,
296: strz@var269 ( false ) ,
297: optional@var270 ( false ) ,
298: variadic@var271 ( false ) ,
299: iteratorInfo@var277 ( ) ,
300: direction@var285 ( Direction :: DIR_UNKNOWN ) { }
301:
302: bool notbool@var265 ;
303: bool notnull@var266 ;
304: int notuninit@var267 ;
305: bool formatstr@var268 ;
306: bool strz@var269 ;
307: bool optional@var270 ;
308: bool variadic@var271 ;
309: std :: string valid@var272 ;
310:
311: class IteratorInfo {
312: public:
313: IteratorInfo ( ) : container@var273 ( 0 ) , it@var274 ( false ) , first@var275 ( false ) , last@var276 ( false ) { }
314:
315: int container@var273 ;
316: bool it@var274 ;
317: bool first@var275 ;
318: bool last@var276 ;
319: } ;
320: IteratorInfo iteratorInfo@var277 ;
321:
322: class MinSize {
323: public:
324: enum class Type { NONE , STRLEN , ARGVALUE , SIZEOF , MUL , VALUE } ;
325: MinSize ( Type t@var278 , int a@var279 ) : type@var280 ( t@var278 ) , arg@var281 ( a@var279 ) , arg2@var282 ( 0 ) , value@var283 ( 0 ) { }
326: Type type@var280 ;
327: int arg@var281 ;
328: int arg2@var282 ;
329: long long value@var283 ;
330: } ;
331: std :: vector < MinSize > minsizes@var284 ;
332:
333: enum class Direction {
334: DIR_IN ,
335: DIR_OUT ,
336: DIR_INOUT ,
337: DIR_UNKNOWN
338: } ;
339: Direction direction@var285 ;
340: } ;
341:
342: struct Function {
343: std :: map < int , ArgumentChecks > argumentChecks@var286 ;
344: bool use@var287 ;
345: bool leakignore@var288 ;
346: bool isconst@var289 ;
347: bool ispure@var290 ;
348: UseRetValType useretval@var291 ;
349: bool ignore@var292 ;
350: bool formatstr@var293 ;
351: bool formatstr_scan@var294 ;
352: bool formatstr_secure@var295 ;
353: Container :: Action containerAction@var296 ;
354: Container :: Yield containerYield@var297 ;
355: Function ( )
356: : use@var287 ( false ) ,
357: leakignore@var288 ( false ) ,
358: isconst@var289 ( false ) ,
359: ispure@var290 ( false ) ,
360: useretval@var291 ( UseRetValType :: NONE ) ,
361: ignore@var292 ( false ) ,
362: formatstr@var293 ( false ) ,
363: formatstr_scan@var294 ( false ) ,
364: formatstr_secure@var295 ( false ) ,
365: containerAction@var296 ( Container :: Action :: NO_ACTION ) ,
366: containerYield@var297 ( Container :: Yield :: NO_YIELD )
367: { }
368: } ;
369:
370: const Function * getFunction ( const Token * ftok@var298 ) const ;
371: std :: unordered_map < std :: string , Function > functions@var299 ;
372: bool isUse ( const std :: string & functionName@var300 ) const ;
373: bool isLeakIgnore ( const std :: string & functionName@var301 ) const ;
374: bool isFunctionConst ( const std :: string & functionName@var302 , bool pure@var303 ) const ;
375: bool isFunctionConst ( const Token * ftok@var304 ) const ;
376:
377: bool isboolargbad ( const Token * ftok@var305 , int argnr@var306 ) const {
378: const ArgumentChecks * arg@var307 ; arg@var307 =@expr1073745906 getarg (@expr1073745907 ftok@var305 , argnr@var306 ) ;
379: return arg@var307 &&@expr1073745908 arg@var307 .@expr1073745909 notbool@var308 ;
380: }
381:
382: bool isnullargbad ( const Token * ftok@var309 , int argnr@var310 ) const ;
383: bool isuninitargbad ( const Token * ftok@var311 , int argnr@var312 , int indirect@var313 = 0 , bool * hasIndirect@var314 = nullptr ) const ;
384:
385: bool isargformatstr ( const Token * ftok@var315 , int argnr@var316 ) const {
386: const ArgumentChecks * arg@var317 ; arg@var317 =@expr1073745910 getarg (@expr1073745911 ftok@var315 , argnr@var316 ) ;
387: return arg@var317 &&@expr1073745912 arg@var317 .@expr1073745913 formatstr@var318 ;
388: }
389:
390: bool isargstrz ( const Token * ftok@var319 , int argnr@var320 ) const {
391: const ArgumentChecks * arg@var321 ; arg@var321 =@expr1073745914 getarg (@expr1073745915 ftok@var319 , argnr@var320 ) ;
392: return arg@var321 &&@expr1073745916 arg@var321 .@expr1073745917 strz@var322 ;
393: }
394:
395: bool isIntArgValid ( const Token * ftok@var323 , int argnr@var324 , const long long argvalue@var325 ) const ;
396: bool isFloatArgValid ( const Token * ftok@var326 , int argnr@var327 , double argvalue@var328 ) const ;
397:
398: const std :: string & validarg ( const Token * ftok@var329 , int argnr@var330 ) const {
399: const ArgumentChecks * arg@var331 ; arg@var331 =@expr1073745918 getarg (@expr1073745919 ftok@var329 , argnr@var330 ) ;
400: return arg@var331 ?@expr1073745920 arg@var331 .@expr1073745921 valid@var332 :@expr1073745922 emptyString@var1 ;
401: }
402:
403: struct InvalidArgValue {
404: enum class Type { le , lt , eq , ge , gt , range } ; enum Type type@var333 ;
405: std :: string op1@var334 ;
406: std :: string op2@var335 ;
407: bool isInt ( ) const {
408: return MathLib ::@expr1073745923 isInt (@expr1073745924 op1@var334 ) ;
409: }
410: } ;
411:
412: const ArgumentChecks :: IteratorInfo * getArgIteratorInfo ( const Token * ftok@var336 , int argnr@var337 ) const {
413: const ArgumentChecks * arg@var338 ; arg@var338 =@expr1073745925 getarg (@expr1073745926 ftok@var336 , argnr@var337 ) ;
414: return arg@var338 &&@expr1073745927 arg@var338 .@expr4104 iteratorInfo@var339 .@expr1073745929 it@var340 ?@expr1073745930 &@expr1073745931 arg@var338 .@expr4104 iteratorInfo@var339 :@expr1073745933 nullptr ;
415: }
416:
417: bool hasminsize ( const Token * ftok@var341 ) const ;
418:
419: const std :: vector < ArgumentChecks :: MinSize > * argminsizes ( const Token * ftok@var342 , int argnr@var343 ) const {
420: const ArgumentChecks * arg@var344 ; arg@var344 =@expr1073745934 getarg (@expr1073745935 ftok@var342 , argnr@var343 ) ;
421: return arg@var344 ?@expr1073745936 &@expr1073745937 arg@var344 .@expr1073745938 minsizes@var345 :@expr1073745939 nullptr ;
422: }
423:
424: ArgumentChecks :: Direction getArgDirection ( const Token * ftok@var346 , int argnr@var347 ) const ;
425:
426: bool markupFile ( const std :: string & path@var348 ) const ;
427:
428: bool processMarkupAfterCode ( const std :: string & path@var349 ) const ;
429:
430: const std :: set < std :: string > & markupExtensions ( ) const {
431: return mMarkupExtensions@var453 ;
432: }
433:
434: bool reportErrors ( const std :: string & path@var350 ) const ;
435:
436: bool ignorefunction ( const std :: string & functionName@var351 ) const ;
437:
438: bool isexecutableblock ( const std :: string & file@var352 , const std :: string & token@var353 ) const ;
439:
440: int blockstartoffset ( const std :: string & file@var354 ) const ;
441:
442: const std :: string & blockstart ( const std :: string & file@var355 ) const ;
443: const std :: string & blockend ( const std :: string & file@var356 ) const ;
444:
445: bool iskeyword ( const std :: string & file@var357 , const std :: string & keyword@var358 ) const ;
446:
447: bool isexporter ( const std :: string & prefix@var359 ) const {
448: return mExporters@var456 .@expr1073745940 find (@expr1073745941 prefix@var359 ) !=@expr1073745942 mExporters@var456 .@expr1073745943 end (@expr1073745944 ) ;
449: }
450:
451: bool isexportedprefix ( const std :: string & prefix@var360 , const std :: string & token@var361 ) const {
452: const std ::@expr1073745945 map < std ::@expr1073745946 string , ExportedFunctions > ::@expr1073745947 const_iterator it@var362 =@expr1073745948 mExporters@var456 .@expr1073745949 find (@expr1073745950 prefix@var360 ) ;
453: return (@expr1073745951 it@var362 !=@expr1073745952 mExporters@var456 .@expr1073745953 end (@expr1073745954 ) &&@expr1073745955 it@var362 .@expr1073745956 second@var363 .@expr1073745957 isPrefix (@expr1073745958 token@var361 ) ) ;
454: }
455:
456: bool isexportedsuffix ( const std :: string & prefix@var364 , const std :: string & token@var365 ) const {
457: const std ::@expr1073745959 map < std ::@expr1073745960 string , ExportedFunctions > ::@expr1073745961 const_iterator it@var366 =@expr1073745962 mExporters@var456 .@expr1073745963 find (@expr1073745964 prefix@var364 ) ;
458: return (@expr1073745965 it@var366 !=@expr1073745966 mExporters@var456 .@expr1073745967 end (@expr1073745968 ) &&@expr1073745969 it@var366 .@expr1073745970 second@var367 .@expr1073745971 isSuffix (@expr1073745972 token@var365 ) ) ;
459: }
460:
461: bool isimporter ( const std :: string & file@var368 , const std :: string & importer@var369 ) const ;
462:
463: const Token * getContainerFromYield ( const Token * tok@var370 , Container :: Yield yield@var371 ) const ;
464: const Token * getContainerFromAction ( const Token * tok@var372 , Container :: Action action@var373 ) const ;
465:
466: bool isreflection ( const std :: string & token@var374 ) const {
467: return mReflection@var458 .@expr1073745973 find (@expr1073745974 token@var374 ) !=@expr1073745975 mReflection@var458 .@expr1073745976 end (@expr1073745977 ) ;
468: }
469:
470: int reflectionArgument ( const std :: string & token@var375 ) const {
471: const std ::@expr1073745978 map < std ::@expr1073745979 string , int > ::@expr1073745980 const_iterator it@var376 =@expr1073745981 mReflection@var458 .@expr1073745982 find (@expr1073745983 token@var375 ) ;
472: if (@expr1073745984 it@var376 !=@expr1073745985 mReflection@var458 .@expr1073745986 end (@expr1073745987 ) ) {
473: return it@var376 .@expr1073745988 second@var377 ; }
474: return -1 ;
475: }
476:
477: std :: vector < std :: string > defines@var378 ;
478:
479: struct SmartPointer {
480: std :: string name@var379 ; name@var379 = "" ;
481: bool unique@var380 ; unique@var380 = false ;
482: } ;
483:
484: std :: map < std :: string , SmartPointer > smartPointers@var381 ;
485: bool isSmartPointer ( const Token * tok@var382 ) const ;
486: const SmartPointer * detectSmartPointer ( const Token * tok@var383 ) const ;
487:
488: struct PodType {
489: unsigned int size@var384 ;
490: char sign@var385 ;
491: enum class Type { NO , BOOL , CHAR , SHORT , INT , LONG , LONGLONG } ; enum Type stdtype@var386 ;
492: } ;
493: const struct PodType * podtype ( const std :: string & name@var387 ) const {
494: const std ::@expr1073745989 unordered_map < std ::@expr1073745990 string , PodType > ::@expr1073745991 const_iterator it@var388 =@expr1073745992 mPodTypes@var459 .@expr1073745993 find (@expr1073745994 name@var387 ) ;
495: return (@expr4171 it@var388 !=@expr1073745996 mPodTypes@var459 .@expr1073745997 end (@expr1073745998 ) ) ?@expr1073745999 &@expr1073746000 (@expr4171 it@var388 .@expr1073746002 second@var389 ) :@expr1073746003 nullptr ;
496: }
497:
498: struct PlatformType {
499: PlatformType ( )
500: : mSigned@var400 ( false )
501: , mUnsigned@var401 ( false )
502: , mLong@var402 ( false )
503: , mPointer@var403 ( false )
504: , mPtrPtr@var404 ( false )
505: , mConstPtr@var405 ( false ) { }
506: bool operator== ( const PlatformType & type@var390 ) const {
507: return (@expr1073746004 mSigned@var400 ==@expr1073746005 type@var390 .@expr1073746006 mSigned@var391 &&@expr1073746007
508: mUnsigned@var401 ==@expr1073746008 type@var390 .@expr1073746009 mUnsigned@var392 &&@expr1073746010
509: mLong@var402 ==@expr1073746011 type@var390 .@expr1073746012 mLong@var393 &&@expr1073746013
510: mPointer@var403 ==@expr1073746014 type@var390 .@expr1073746015 mPointer@var394 &&@expr1073746016
511: mPtrPtr@var404 ==@expr1073746017 type@var390 .@expr1073746018 mPtrPtr@var395 &&@expr1073746019
512: mConstPtr@var405 ==@expr1073746020 type@var390 .@expr1073746021 mConstPtr@var396 &&@expr1073746022
513: mType@var399 ==@expr1073746023 type@var390 .@expr1073746024 mType@var397 ) ;
514: }
515: bool operator!= ( const PlatformType & type@var398 ) const {
516: return !@expr1073746025 (@expr1073746026 *@expr1073746027 this@expr1073746028 ==@expr1073746029 type@var398 ) ;
517: }
518: std :: string mType@var399 ;
519: bool mSigned@var400 ;
520: bool mUnsigned@var401 ;
521: bool mLong@var402 ;
522: bool mPointer@var403 ;
523: bool mPtrPtr@var404 ;
524: bool mConstPtr@var405 ;
525: } ;
526:
527: struct Platform {
528: const PlatformType * platform_type ( const std :: string & name@var406 ) const {
529: const std ::@expr1073746030 map < std ::@expr1073746031 string , PlatformType > ::@expr1073746032 const_iterator it@var407 =@expr1073746033 mPlatformTypes@var409 .@expr1073746034 find (@expr1073746035 name@var406 ) ;
530: return (@expr4212 it@var407 !=@expr1073746037 mPlatformTypes@var409 .@expr1073746038 end (@expr1073746039 ) ) ?@expr1073746040 &@expr1073746041 (@expr4212 it@var407 .@expr1073746043 second@var408 ) :@expr1073746044 nullptr ;
531: }
532: std :: map < std :: string , PlatformType > mPlatformTypes@var409 ;
533: } ;
534:
535: const PlatformType * platform_type ( const std :: string & name@var410 , const std :: string & platform@var411 ) const {
536: const std ::@expr1073746045 map < std ::@expr4222 string , Platform > ::@expr1073746047 const_iterator it@var412 =@expr1073746048 mPlatforms@var461 .@expr1073746049 find (@expr1073746050 platform@var411 ) ;
537: if (@expr1073746051 it@var412 !=@expr1073746052 mPlatforms@var461 .@expr1073746053 end (@expr1073746054 ) ) {
538: const PlatformType * const type@var413 ; type@var413 =@expr1073746055 it@var412 .@expr1073746056 second@var414 .@expr1073746057 platform_type (@expr1073746058 name@var410 ) ;
539: if (@expr1073746059 type@var413 ) {
540: return type@var413 ; }
541: }
542:
543: const std ::@expr1073746060 map < std ::@expr4222 string , PlatformType > ::@expr1073746062 const_iterator it2@var415 =@expr1073746063 mPlatformTypes@var460 .@expr1073746064 find (@expr1073746065 name@var410 ) ;
544: return (@expr4242 it2@var415 !=@expr1073746067 mPlatformTypes@var460 .@expr1073746068 end (@expr1073746069 ) ) ?@expr1073746070 &@expr1073746071 (@expr4242 it2@var415 .@expr1073746073 second@var416 ) :@expr1073746074 nullptr ;
545: }
546:
|
549:
550: std :: string getFunctionName ( const Token * ftok@var417 ) const ;
551:
552: static bool isContainerYield ( const Token * const cond@var418 , Library :: Container :: Yield y@var419 , const std :: string & fallback@var420 = "" ) ;
553:
554:
555: enum class TypeCheck { def , check , suppress } ;
556: TypeCheck getTypeCheck ( const std :: string & check@var421 , const std :: string & typeName@var422 ) const ;
557:
558: private:
559:
560: Error loadFunction ( const tinyxml2 :: XMLElement * const node@var423 , const std :: string & name@var424 , std :: set < std :: string > & unknown_elements@var425 ) ;
561:
562: class ExportedFunctions {
563: public:
564: void addPrefix ( const std :: string & prefix@var426 ) {
565: mPrefixes@var430 .@expr1073746075 insert (@expr1073746076 prefix@var426 ) ;
566: }
567: void addSuffix ( const std :: string & suffix@var427 ) {
568: mSuffixes@var431 .@expr1073746077 insert (@expr1073746078 suffix@var427 ) ;
569: }
570: bool isPrefix ( const std :: string & prefix@var428 ) const {
571: return (@expr1073746079 mPrefixes@var430 .@expr1073746080 find (@expr1073746081 prefix@var428 ) !=@expr1073746082 mPrefixes@var430 .@expr1073746083 end (@expr1073746084 ) ) ;
572: }
573: bool isSuffix ( const std :: string & suffix@var429 ) const {
574: return (@expr1073746085 mSuffixes@var431 .@expr1073746086 find (@expr1073746087 suffix@var429 ) !=@expr1073746088 mSuffixes@var431 .@expr1073746089 end (@expr1073746090 ) ) ;
575: }
576:
577: private:
578: std :: set < std :: string > mPrefixes@var430 ;
579: std :: set < std :: string > mSuffixes@var431 ;
580: } ;
581: class CodeBlock {
582: public:
583: CodeBlock ( ) : mOffset@var439 ( 0 ) { }
584:
585: void setStart ( const char * s@var432 ) {
586: mStart@var437 =@expr1073746091 s@var432 ;
587: }
588: void setEnd ( const char * e@var433 ) {
589: mEnd@var438 =@expr1073746092 e@var433 ;
590: }
591: void setOffset ( const int o@var434 ) {
592: mOffset@var439 =@expr1073746093 o@var434 ;
593: }
594: void addBlock ( const char * blockName@var435 ) {
595: mBlocks@var440 .@expr1073746094 insert (@expr1073746095 blockName@var435 ) ;
596: }
597: const std :: string & start ( ) const {
598: return mStart@var437 ;
599: }
600: const std :: string & end ( ) const {
601: return mEnd@var438 ;
602: }
603: int offset ( ) const {
604: return mOffset@var439 ;
605: }
606: bool isBlock ( const std :: string & blockName@var436 ) const {
607: return mBlocks@var440 .@expr1073746096 find (@expr1073746097 blockName@var436 ) !=@expr1073746098 mBlocks@var440 .@expr1073746099 end (@expr1073746100 ) ;
608: }
609:
610: private:
611: std :: string mStart@var437 ;
612: std :: string mEnd@var438 ;
613: int mOffset@var439 ;
614: std :: set < std :: string > mBlocks@var440 ;
615: } ;
616: enum class FalseTrueMaybe { False , True , Maybe } ;
617: int mAllocId@var441 ;
618: std :: set < std :: string > mFiles@var442 ;
619: std :: map < std :: string , AllocFunc > mAlloc@var443 ;
620: std :: map < std :: string , AllocFunc > mDealloc@var444 ;
621: std :: map < std :: string , AllocFunc > mRealloc@var445 ;
622: std :: unordered_map < std :: string , FalseTrueMaybe > mNoReturn@var446 ;
623: std :: map < std :: string , std :: string > mReturnValue@var447 ;
624: std :: map < std :: string , std :: string > mReturnValueType@var448 ;
625: std :: map < std :: string , int > mReturnValueContainer@var449 ;
626: std :: map < std :: string , std :: vector < long long > > mUnknownReturnValues@var450 ;
627: std :: map < std :: string , bool > mReportErrors@var451 ;
628: std :: map < std :: string , bool > mProcessAfterCode@var452 ;
629: std :: set < std :: string > mMarkupExtensions@var453 ;
630: std :: map < std :: string , std :: set < std :: string > > mKeywords@var454 ;
631: std :: map < std :: string , CodeBlock > mExecutableBlocks@var455 ;
632: std :: map < std :: string , ExportedFunctions > mExporters@var456 ;
633: std :: map < std :: string , std :: set < std :: string > > mImporters@var457 ;
634: std :: map < std :: string , int > mReflection@var458 ;
635: std :: unordered_map < std :: string , PodType > mPodTypes@var459 ;
636: std :: map < std :: string , PlatformType > mPlatformTypes@var460 ;
637: std :: map < std :: string , Platform > mPlatforms@var461 ;
638: std :: map < std :: pair < std :: string , std :: string > , TypeCheck > mTypeChecks@var462 ;
639: std :: unordered_map < std :: string , NonOverlappingData > mNonOverlappingData@var463 ;
640:
641: const ArgumentChecks * getarg ( const Token * ftok@var464 , int argnr@var465 ) const ;
642:
643: std :: string getFunctionName ( const Token * ftok@var466 , bool * error@var467 ) const ;
644:
645: static const AllocFunc * getAllocDealloc ( const std :: map < std :: string , AllocFunc > & data@var468 , const std :: string & name@var469 ) {
646: const std ::@expr1073746101 map < std ::@expr1073746102 string , AllocFunc > ::@expr1073746103 const_iterator it@var470 =@expr1073746104 data@var468 .@expr1073746105 find (@expr1073746106 name@var469 ) ;
647: return (@expr1073746107 it@var470 ==@expr1073746108 data@var468 .@expr1073746109 end (@expr1073746110 ) ) ?@expr1073746111 nullptr :@expr1073746112 &@expr1073746113 it@var470 .@expr1073746114 second@var471 ;
648: }
649: } ;
650:
651: const Library :: Container * getLibraryContainer ( const Token * tok@var472 ) ;
652:
653: std :: shared_ptr < Token > createTokenFromExpression ( const std :: string & returnValue@var473 ,
654: const Settings * settings@var474 ,
655: std :: unordered_map < int , const Token * > * lookupVarId@var475 = nullptr ) ;

##file cppcheck-2.8/lib/valueflow.h

1:
|
36:
37: class ErrorLogger ;
38: struct InferModel ;
39: class Settings ;
40: class SymbolDatabase ;
41: class Token ;
42: class TokenList ;
43: class ValueType ;
44: class Variable ;
45: class Scope ;
46:
47: template < class T >
48: class ValuePtr ;
49:
50: namespace ValueFlow {
51: struct increment {
52: template < class T >
53: void operator() ( T & x@var476 ) const {
54: x@var476 ++@expr1073746115 ;
55: }
56: } ;
57: struct decrement {
58: template < class T >
59: void operator() ( T & x@var477 ) const {
60: x@var477 --@expr1073746116 ;
61: }
62: } ;
63:
64: struct less {
65: template < class T , class U >
66: bool operator() ( const T & x@var478 , const U & y@var479 ) const {
67: return x@var478 <@expr1073746117 y@var479 ;
68: }
69: } ;
70:
71: struct adjacent {
72: template < class T , class U >
73: bool operator() ( const T & x@var480 , const U & y@var481 ) const {
74: return std ::@expr1073746118 abs (@expr1073746119 x@var480 -@expr1073746120 y@var481 ) ==@expr1073746121 1 ;
75: }
76: } ;
77:
78: struct equalVisitor {
79: template < class T , class U >
80: void operator() ( bool & result@var482 , T x@var483 , U y@var484 ) const {
81: result@var482 =@expr1073746122 !@expr1073746123 (@expr1073746124 x@var483 >@expr1073746125 y@var484 ||@expr1073746126 x@var483 <@expr1073746127 y@var484 ) ;
82: }
83: } ;
84: class Value {
85: public:
86:
87:
88: enum class Bound { Upper , Lower , Point } ;
89:
90: explicit Value ( long long val@var485 = 0 , Bound b@var486 = Bound :: Point )
91: : valueType@var526 ( ValueType :: INT ) ,
92: bound@var527 ( b@var486 ) ,
93: intvalue@var528 ( val@var485 ) ,
94: tokvalue@var529 ( nullptr ) ,
95: floatValue@var530 ( 0.0 ) ,
96: moveKind@var531 ( MoveKind :: NonMovedVariable ) ,
97: varvalue@var532 ( val@var485 ) ,
98: condition@var533 ( nullptr ) ,
99: varId@var535 ( 0U ) ,
100: safe@var536 ( false ) ,
101: conditional@var537 ( false ) ,
102: macro@var538 ( false ) ,
103: defaultArg@var539 ( false ) ,
104: indirect@var540 ( 0 ) ,
105: path@var541 ( 0 ) ,
106: wideintvalue@var542 ( val@var485 ) ,
107: subexpressions@var543 ( ) ,
108: capturetok@var544 ( nullptr ) ,
109: lifetimeKind@var545 ( LifetimeKind :: Object ) ,
110: lifetimeScope@var546 ( LifetimeScope :: Local ) ,
111: valueKind@var551 ( ValueKind :: Possible )
112: { }
113: Value ( const Token * c@var487 , long long val@var488 , Bound b@var489 = Bound :: Point ) ;
114:
115: static Value unknown ( ) ;
116:
117: bool equalValue ( const ValueFlow :: Value & rhs@var490 ) const {
118: if (@expr1073746128 valueType@var526 !=@expr1073746129 rhs@var490 .@expr1073746130 valueType@var491 ) {
119: return false ; }
120: switch (@expr1073746131 valueType@var526 ) {
121: case ValueType ::@expr1073746132 INT :@expr4309
122: case ValueType ::@expr1073746134 CONTAINER_SIZE :@expr4309
123: case ValueType ::@expr1073746136 BUFFER_SIZE :@expr4309
124: case ValueType ::@expr1073746138 ITERATOR_START :@expr4309
125: case ValueType ::@expr1073746140 ITERATOR_END :@expr4309 ;
126: if (@expr4318 intvalue@var528 !=@expr4319 rhs@var490 .@expr4320 intvalue@var492 ) {
127: return false ; }
128: break ;
129: case ValueType ::@expr1073746145 TOK :@expr4309 ;
130: if (@expr4323 tokvalue@var529 !=@expr4324 rhs@var490 .@expr4325 tokvalue@var493 ) {
131: return false ; }
132: break ;
133: case ValueType ::@expr1073746150 FLOAT :@expr4309 ;
134:
135: if (@expr1073746152 floatValue@var530 >@expr1073746153 rhs@var490 .@expr4330 floatValue@var494 ||@expr1073746155 floatValue@var530 <@expr1073746156 rhs@var490 .@expr4330 floatValue@var494 ) {
136: return false ; }
137: break ;
138: case ValueType ::@expr1073746158 MOVED :@expr4309 ;
139: if (@expr1073746160 moveKind@var531 !=@expr1073746161 rhs@var490 .@expr1073746162 moveKind@var495 ) {
140: return false ; }
141: break ;
142: case ValueType ::@expr1073746163 UNINIT :@expr4309 ;
143: break ;
144: case ValueType ::@expr1073746165 LIFETIME :@expr4309 ;
145: if (@expr4323 tokvalue@var529 !=@expr4324 rhs@var490 .@expr4325 tokvalue@var493 ) {
146: return false ; }
147: break ;
148: case ValueType ::@expr1073746170 SYMBOLIC :@expr4309 ;
149: if (@expr1073746172 !@expr1073746173 sameToken (@expr1073746174 tokvalue@var529 , rhs@var490 .@expr4325 tokvalue@var493 ) ) {
150: return false ; }
151: if (@expr4318 intvalue@var528 !=@expr4319 rhs@var490 .@expr4320 intvalue@var492 ) {
152: return false ; }
153: break ;
154: }
155: return true ;
156: }
157:
158: template < class T , class F >
159: static void visitValue ( T & self@var496 , F f@var497 ) {
160: switch (@expr1073746179 self@var496 .@expr1073746180 valueType@var498 ) {
161: case ValueType ::@expr1073746181 INT :@expr4358
162: case ValueType ::@expr1073746183 SYMBOLIC :@expr4358
163: case ValueType ::@expr1073746185 BUFFER_SIZE :@expr4358
164: case ValueType ::@expr1073746187 CONTAINER_SIZE :@expr4358
165: case ValueType ::@expr1073746189 ITERATOR_START :@expr4358
166: case ValueType ::@expr1073746191 ITERATOR_END :@expr4358 ; {
167: f@var497 (@expr1073746193 self@var496 .@expr1073746194 intvalue@var499 ) ;
168: break ;
169: }
170: case ValueType ::@expr1073746195 FLOAT :@expr4358 ; {
171: f@var497 (@expr1073746197 self@var496 .@expr1073746198 floatValue@var500 ) ;
172: break ;
173: }
174: case ValueType ::@expr1073746199 UNINIT :@expr4358
175: case ValueType ::@expr1073746201 TOK :@expr4358
176: case ValueType ::@expr1073746203 LIFETIME :@expr4358
177: case ValueType ::@expr1073746205 MOVED :@expr4358 ;
178: break ;
179: }
180: }
181:
182: struct compareVisitor {
183: struct innerVisitor {
184: template < class Compare , class T , class U >
185: void operator() ( bool & result@var501 , Compare compare@var502 , T x@var503 , U y@var504 ) const {
186: result@var501 =@expr1073746207 compare@var502 (@expr1073746208 x@var503 , y@var504 ) ;
187: }
188: } ;
189: template < class Compare , class T >
190: void operator() ( bool & result@var505 , const Value & rhs@var506 , Compare compare@var507 , T x@var508 ) const {
191: visitValue (@expr1073746210 rhs@var506 ,
192: std ::@expr1073746211 bind (@expr1073746212 innerVisitor {@expr1073746213 } , std ::@expr1073746214 ref (@expr1073746215 result@var505 ) , std ::@expr1073746216 move (@expr1073746217 compare@var507 ) , x@var508 , std ::@expr1073746218 placeholders ::@expr1073746219 _1@expr1073746209 ) ) ;
193: }
194: } ;
195:
196: template < class Compare >
197: bool compareValue ( const Value & rhs@var509 , Compare compare@var510 ) const {
198: assert (@expr1073746221 (@expr1073746222 !@expr1073746223 this@expr4400 .@expr1073746225 isSymbolicValue (@expr1073746226 ) &&@expr1073746227 !@expr1073746228 rhs@var509 .@expr1073746229 isSymbolicValue (@expr1073746230 ) ) ||@expr1073746231
199: (@expr1073746232 this@expr4400 .@expr1073746233 valueType@var526 ==@expr1073746234 rhs@var509 .@expr1073746235 valueType@var511 &&@expr1073746236 sameToken (@expr1073746237 this@expr4400 .@expr1073746238 tokvalue@var529 , rhs@var509 .@expr1073746239 tokvalue@var512 ) ) ) ;
200: bool result@var513 ; result@var513 =@expr1073746240 false ;
201: visitValue (@expr1073746241
202: *@expr1073746242 this@expr4400 ,
203: std ::@expr1073746243 bind (@expr1073746244 compareVisitor {@expr1073746245 } , std ::@expr4422 ref (@expr1073746247 result@var513 ) , std ::@expr4422 ref (@expr1073746249 rhs@var509 ) , std ::@expr1073746250 move (@expr1073746251 compare@var510 ) , std ::@expr1073746252 placeholders ::@expr1073746253 _1@expr1073746220 ) ) ;
204: return result@var513 ;
205: }
206:
207: bool operator== ( const Value & rhs@var514 ) const {
208: if (@expr1073746254 !@expr1073746255 equalValue (@expr1073746256 rhs@var514 ) ) {
209: return false ; }
210:
211: return varvalue@var532 ==@expr1073746257 rhs@var514 .@expr1073746258 varvalue@var515 &&@expr1073746259
212: condition@var533 ==@expr1073746260 rhs@var514 .@expr1073746261 condition@var516 &&@expr1073746262
213: varId@var535 ==@expr1073746263 rhs@var514 .@expr1073746264 varId@var517 &&@expr1073746265
214: conditional@var537 ==@expr1073746266 rhs@var514 .@expr1073746267 conditional@var518 &&@expr1073746268
215: defaultArg@var539 ==@expr1073746269 rhs@var514 .@expr1073746270 defaultArg@var519 &&@expr1073746271
216: indirect@var540 ==@expr1073746272 rhs@var514 .@expr1073746273 indirect@var520 &&@expr1073746274
217: valueKind@var551 ==@expr1073746275 rhs@var514 .@expr1073746276 valueKind@var521 ;
218: }
219:
220: bool operator!= ( const Value & rhs@var522 ) const {
221: return !@expr1073746277 (@expr1073746278 *@expr1073746279 this@expr1073746280 ==@expr1073746281 rhs@var522 ) ;
222: }
223:
224: template < class T , $class $= $typename $std $:: $enable_if $< std :: is_arithmetic < T > $:: $value $> $:: $type >
225: bool equalTo ( const T & x@var523 ) const {
226: bool result@var524 ; result@var524 =@expr1073746283 false ;
227: visitValue (@expr1073746284 *@expr1073746285 this@expr1073746286 , std ::@expr1073746287 bind (@expr1073746288 equalVisitor {@expr1073746289 } , std ::@expr1073746290 ref (@expr1073746291 result@var524 ) , x@var523 , std ::@expr1073746292 placeholders ::@expr1073746293 _1@expr1073746282 ) ) ;
228: return result@var524 ;
229: }
230:
231: void decreaseRange ( ) {
232: if (@expr1073746294 bound@var527 ==@expr1073746295 Bound ::@expr1073746296 Lower ) {
233: visitValue (@expr1073746297 *@expr4474 this@expr4475 , increment {@expr1073746300 } ) ; }
234: else { if (@expr1073746301 bound@var527 ==@expr1073746302 Bound ::@expr1073746303 Upper ) {
235: visitValue (@expr1073746304 *@expr4474 this@expr4475 , decrement {@expr1073746306 } ) ; } }
236: }
237:
238: void invertBound ( ) {
239: if (@expr1073746307 bound@var527 ==@expr1073746308 Bound ::@expr4485 Lower ) {
240: bound@var527 =@expr1073746310 Bound ::@expr4487 Upper ; }
241: else { if (@expr1073746312 bound@var527 ==@expr1073746313 Bound ::@expr4487 Upper ) {
242: bound@var527 =@expr1073746315 Bound ::@expr4485 Lower ; } }
243: }
244:
245: void invertRange ( ) {
246: invertBound (@expr1073746317 ) ;
247: decreaseRange (@expr1073746318 ) ;
248: }
249:
250: void assumeCondition ( const Token * tok@var525 ) ;
251:
252: std :: string infoString ( ) const ;
253:
254: enum class ValueType {
255: INT ,
256: TOK ,
257: FLOAT ,
258: MOVED ,
259: UNINIT ,
260: CONTAINER_SIZE ,
261: LIFETIME ,
262: BUFFER_SIZE ,
263: ITERATOR_START ,
264: ITERATOR_END ,
265: SYMBOLIC
266: } ; enum ValueType valueType@var526 ;
267: bool isIntValue ( ) const {
268: return valueType@var526 ==@expr1073746319 ValueType ::@expr1073746320 INT ;
269: }
270: bool isTokValue ( ) const {
271: return valueType@var526 ==@expr1073746321 ValueType ::@expr1073746322 TOK ;
272: }
273: bool isFloatValue ( ) const {
274: return valueType@var526 ==@expr1073746323 ValueType ::@expr1073746324 FLOAT ;
275: }
276: bool isMovedValue ( ) const {
277: return valueType@var526 ==@expr1073746325 ValueType ::@expr1073746326 MOVED ;
278: }
279: bool isUninitValue ( ) const {
280: return valueType@var526 ==@expr1073746327 ValueType ::@expr1073746328 UNINIT ;
281: }
282: bool isContainerSizeValue ( ) const {
283: return valueType@var526 ==@expr1073746329 ValueType ::@expr1073746330 CONTAINER_SIZE ;
284: }
285: bool isLifetimeValue ( ) const {
286: return valueType@var526 ==@expr1073746331 ValueType ::@expr1073746332 LIFETIME ;
287: }
288: bool isBufferSizeValue ( ) const {
289: return valueType@var526 ==@expr1073746333 ValueType ::@expr1073746334 BUFFER_SIZE ;
290: }
291: bool isIteratorValue ( ) const {
292: return valueType@var526 ==@expr1073746335 ValueType ::@expr1073746336 ITERATOR_START ||@expr1073746337 valueType@var526 ==@expr1073746338 ValueType ::@expr1073746339 ITERATOR_END ;
293: }
294: bool isIteratorStartValue ( ) const {
295: return valueType@var526 ==@expr1073746340 ValueType ::@expr1073746341 ITERATOR_START ;
296: }
297: bool isIteratorEndValue ( ) const {
298: return valueType@var526 ==@expr1073746342 ValueType ::@expr1073746343 ITERATOR_END ;
299: }
300: bool isSymbolicValue ( ) const {
301: return valueType@var526 ==@expr1073746344 ValueType ::@expr1073746345 SYMBOLIC ;
302: }
303:
304: bool isLocalLifetimeValue ( ) const {
305: return valueType@var526 ==@expr1073746347 ValueType ::@expr1073746348 LIFETIME &&@expr1073746349 lifetimeScope@var546 ==@expr1073746350 LifetimeScope ::@expr1073746351 Local@expr1073746346 ;
306: }
307:
308: bool isArgumentLifetimeValue ( ) const {
309: return valueType@var526 ==@expr1073746352 ValueType ::@expr1073746353 LIFETIME &&@expr1073746354 lifetimeScope@var546 ==@expr1073746355 LifetimeScope ::@expr1073746356 Argument ;
310: }
311:
312: bool isSubFunctionLifetimeValue ( ) const {
313: return valueType@var526 ==@expr1073746357 ValueType ::@expr1073746358 LIFETIME &&@expr1073746359 lifetimeScope@var546 ==@expr1073746360 LifetimeScope ::@expr1073746361 SubFunction ;
314: }
315:
316: bool isNonValue ( ) const {
317: return isMovedValue (@expr1073746362 ) ||@expr1073746363 isUninitValue (@expr1073746364 ) ||@expr1073746365 isLifetimeValue (@expr1073746366 ) ;
318: }
319:
320:
321: Bound bound@var527 ;
322:
323:
324: long long intvalue@var528 ;
325:
326:
327: const Token * tokvalue@var529 ;
328:
329:
330: double floatValue@var530 ;
331:
332:
333: enum class MoveKind { NonMovedVariable , MovedVariable , ForwardedVariable } ; enum MoveKind moveKind@var531 ;
334:
335:
336: long long varvalue@var532 ;
337:
338:
339: const Token * condition@var533 ;
340:
341: std :: list < std :: pair < const Token * , std :: string > > errorPath@var534 ;
342:
343:
344: int varId@var535 ;
345:
346:
347: bool safe@var536 ;
348:
349:
350: bool conditional@var537 ;
351:
352:
353: bool macro@var538 ;
354:
355:
356: bool defaultArg@var539 ;
357:
358: int indirect@var540 ;
359:
360:
361: long long path@var541 ;
362:
363:
364: long long wideintvalue@var542 ;
365:
366: std :: vector < std :: string > subexpressions@var543 ;
367:
368:
369: const Token * capturetok@var544 ;
370:
371: enum class LifetimeKind {
372:
373: Object ,
374:
375: SubObject ,
376:
377: Lambda ,
378:
379: Iterator ,
380:
381: Address
382: } ; enum LifetimeKind lifetimeKind@var545 ;
383:
384: enum class LifetimeScope { Local , Argument , SubFunction , ThisPointer , ThisValue } ; enum LifetimeScope lifetimeScope@var546 ;
385:
386: static const char * toString ( MoveKind moveKind@var547 ) ;
387: static const char * toString ( LifetimeKind lifetimeKind@var548 ) ;
388: static const char * toString ( LifetimeScope lifetimeScope@var549 ) ;
389: static const char * toString ( Bound bound@var550 ) ;
390:
391:
392: enum class ValueKind {
393:
394: Possible ,
395:
396: Known ,
397:
398: Inconclusive ,
399:
400: Impossible
401: } ; enum ValueKind valueKind@var551 ;
402:
403: void setKnown ( ) {
404: valueKind@var551 =@expr1073746367 ValueKind ::@expr1073746368 Known ;
405: }
406:
407: bool isKnown ( ) const {
408: return valueKind@var551 ==@expr1073746369 ValueKind ::@expr1073746370 Known ;
409: }
410:
411: void setPossible ( ) {
412: valueKind@var551 =@expr1073746372 ValueKind ::@expr1073746373 Possible@expr1073746371 ;
413: }
414:
415: bool isPossible ( ) const {
416: return valueKind@var551 ==@expr1073746375 ValueKind ::@expr1073746376 Possible@expr1073746374 ;
417: }
418:
419: bool isImpossible ( ) const {
420: return valueKind@var551 ==@expr1073746377 ValueKind ::@expr1073746378 Impossible ;
421: }
422:
423: void setImpossible ( ) {
424: valueKind@var551 =@expr1073746379 ValueKind ::@expr1073746380 Impossible ;
425: }
426:
427: void setInconclusive ( bool inconclusive@var552 = true ) {
428: if (@expr1073746381 inconclusive@var552 ) {
429: valueKind@var551 =@expr1073746382 ValueKind ::@expr1073746383 Inconclusive ; }
430: }
431:
432: bool isInconclusive ( ) const {
433: return valueKind@var551 ==@expr1073746384 ValueKind ::@expr1073746385 Inconclusive ;
434: }
435:
436: void changeKnownToPossible ( ) {
437: if (@expr1073746387 isKnown (@expr1073746388 ) ) {
438: valueKind@var551 =@expr1073746389 ValueKind ::@expr1073746390 Possible@expr1073746386 ; }
439: }
440:
441: bool errorSeverity ( ) const {
442: return !@expr1073746391 condition@var533 &&@expr1073746392 !@expr1073746393 defaultArg@var539 ;
443: }
444:
445: static bool sameToken ( const Token * tok1@var553 , const Token * tok2@var554 ) ;
446: } ;
447:
448:
449: const ValueFlow :: Value * valueFlowConstantFoldAST ( Token * expr@var555 , const Settings * settings@var556 ) ;
450:
451:
452: void setValues ( TokenList * tokenlist@var557 , SymbolDatabase * symboldatabase@var558 , ErrorLogger * errorLogger@var559 , const Settings * settings@var560 ) ;
453:
454: std :: string eitherTheConditionIsRedundant ( const Token * condition@var561 ) ;
455:
456: unsigned long getSizeOf ( const ValueType & vt@var562 , const Settings * settings@var563 ) ;
457:
458: const ValueFlow :: Value * findValue ( const std :: list < ValueFlow :: Value > & values@var564 ,
459: const Settings * settings@var565 ,
460: std :: function < bool ( const ValueFlow :: Value & ) > pred@var566 ) ;
461:
462: std :: vector < ValueFlow :: Value > isOutOfBounds ( const Value & size@var567 , const Token * indexTok@var568 , bool possible@var569 = true ) ;
463: }
464:
465: ValueFlow :: Value asImpossible ( ValueFlow :: Value v@var570 ) ;
466:
467: bool isContainerSizeChanged ( const Token * tok@var571 , const Settings * settings@var572 = nullptr , int depth@var573 = 20 ) ;
468:
469: struct LifetimeToken {
470: const Token * token@var574 ;
471: bool addressOf@var575 ;
472: ValueFlow :: Value :: ErrorPath errorPath@var576 ;
473: bool inconclusive@var577 ;
474:
475: LifetimeToken ( ) : token@var574 ( nullptr ) , addressOf@var575 ( false ) , errorPath@var576 ( ) , inconclusive@var577 ( false ) { }
476:
477: LifetimeToken ( const Token * token@var578 , ValueFlow :: Value :: ErrorPath errorPath@var579 )
478: : token@var574 ( token@var578 ) , addressOf@var575 ( false ) , errorPath@var576 ( std :: move ( errorPath@var579 ) ) , inconclusive@var577 ( false )
479: { }
480:
481: LifetimeToken ( const Token * token@var580 , bool addressOf@var581 , ValueFlow :: Value :: ErrorPath errorPath@var582 )
482: : token@var574 ( token@var580 ) , addressOf@var575 ( addressOf@var581 ) , errorPath@var576 ( std :: move ( errorPath@var582 ) ) , inconclusive@var577 ( false )
483: { }
484:
485: static std :: vector < LifetimeToken > setAddressOf ( std :: vector < LifetimeToken > v@var583 , bool b@var584 ) {
486: for (@expr1073746394 LifetimeToken &@expr1073746395 x@var585 :@expr1073746396 v@var583 ) {
487: x@var585 .@expr1073746397 addressOf@var586 =@expr1073746398 b@var584 ; }
488: return v@var583 ;
489: }
490:
491: static std :: vector < LifetimeToken > setInconclusive ( std :: vector < LifetimeToken > v@var587 , bool b@var588 ) {
492: for (@expr1073746399 LifetimeToken &@expr1073746400 x@var589 :@expr1073746401 v@var587 ) {
493: x@var589 .@expr1073746402 inconclusive@var590 =@expr1073746403 b@var588 ; }
494: return v@var587 ;
495: }
496: } ;
497:
498: const Token * parseCompareInt ( const Token * tok@var591 , ValueFlow :: Value & true_value@var592 , ValueFlow :: Value & false_value@var593 , const std :: function < std :: vector < long long > ( const Token * ) > & evaluate@var594 ) ;
499: const Token * parseCompareInt ( const Token * tok@var595 , ValueFlow :: Value & true_value@var596 , ValueFlow :: Value & false_value@var597 ) ;
500:
501: ValueFlow :: Value inferCondition ( std :: string op@var598 , long long val@var599 , const Token * varTok@var600 ) ;
502: ValueFlow :: Value inferCondition ( const std :: string & op@var601 , const Token * varTok@var602 , long long val@var603 ) ;
503:
504: ValuePtr < InferModel > makeIntegralInferModel ( ) ;
505:
506: const Token * solveExprValue ( const Token * expr@var604 ,
507: const std :: function < std :: vector < long long > ( const Token * ) > & eval@var605 ,
508: ValueFlow :: Value & value@var606 ) ;
509:
510: std :: vector < LifetimeToken > getLifetimeTokens ( const Token * tok@var607 ,
511: bool escape@var608 = false ,
512: ValueFlow :: Value :: ErrorPath errorPath@var609 = ValueFlow :: Value :: ErrorPath { } ) ;
513:
514: bool hasLifetimeToken ( const Token * tok@var610 , const Token * lifetime@var611 ) ;
515:
516: const Variable * getLifetimeVariable ( const Token * tok@var612 , ValueFlow :: Value :: ErrorPath & errorPath@var613 , bool * addressOf@var614 = nullptr ) ;
517:
518: const Variable * getLifetimeVariable ( const Token * tok@var615 ) ;
519:
520: bool isLifetimeBorrowed ( const Token * tok@var616 , const Settings * settings@var617 ) ;
521:
522: std :: string lifetimeType ( const Token * tok@var618 , const ValueFlow :: Value * val@var619 ) ;
523:
524: std :: string lifetimeMessage ( const Token * tok@var620 , const ValueFlow :: Value * val@var621 , ValueFlow :: Value :: ErrorPath & errorPath@var622 ) ;
525:
526: ValueFlow :: Value getLifetimeObjValue ( const Token * tok@var623 , bool inconclusive@var624 = false ) ;
527:
528: std :: vector < ValueFlow :: Value > getLifetimeObjValues ( const Token * tok@var625 ,
529: bool inconclusive@var626 = false ,
530: long long path@var627 = 0 ) ;
531:
532: const Token * getEndOfExprScope ( const Token * tok@var628 , const Scope * defaultScope@var629 = nullptr , bool smallest@var630 = true ) ;

##file cppcheck-2.8/lib/templatesimplifier.h

1:
|
34:
35: class ErrorLogger ;
36: class Settings ;
37: class Token ;
38: class Tokenizer ;
39: class TokenList ;
40:
|
44:
45: class TemplateSimplifier {
46: friend class TestSimplifyTemplate ;
47:
48: public:
49: explicit TemplateSimplifier ( Tokenizer * tokenizer@var631 ) ;
50: ~ TemplateSimplifier ( ) ;
51:
52:
53:
54: void checkComplicatedSyntaxErrorsInTemplates ( ) ;
55:
|
61:
62: static unsigned int templateParameters ( const Token * tok@var632 ) ;
63:
|
66:
67: class TokenAndName {
68: Token * mToken@var633 ;
69: std :: string mScope@var634 ;
70: std :: string mName@var635 ;
71: std :: string mFullName@var636 ;
72: const Token * mNameToken@var637 ;
73: const Token * mParamEnd@var638 ;
74: unsigned int mFlags@var639 ;
75:
76: enum Anonymous0 {
77: fIsClass = ( 1 << 0 ) ,
78: fIsFunction = ( 1 << 1 ) ,
79: fIsVariable = ( 1 << 2 ) ,
80: fIsAlias = ( 1 << 3 ) ,
81: fIsSpecialization = ( 1 << 4 ) ,
82: fIsPartialSpecialization = ( 1 << 5 ) ,
83: fIsForwardDeclaration = ( 1 << 6 ) ,
84: fIsVariadic = ( 1 << 7 ) ,
85: fIsFriend = ( 1 << 8 ) ,
86: fFamilyMask = ( fIsClass | fIsFunction | fIsVariable )
87: } ;
88:
89: void isClass ( bool state@var640 ) {
90: setFlag (@expr1073746404 fIsClass , state@var640 ) ;
91: }
92: void isFunction ( bool state@var641 ) {
93: setFlag (@expr1073746405 fIsFunction , state@var641 ) ;
94: }
95: void isVariable ( bool state@var642 ) {
96: setFlag (@expr1073746406 fIsVariable , state@var642 ) ;
97: }
98: void isAlias ( bool state@var643 ) {
99: setFlag (@expr1073746407 fIsAlias , state@var643 ) ;
100: }
101: void isSpecialization ( bool state@var644 ) {
102: setFlag (@expr1073746408 fIsSpecialization , state@var644 ) ;
103: }
104: void isPartialSpecialization ( bool state@var645 ) {
105: setFlag (@expr1073746409 fIsPartialSpecialization , state@var645 ) ;
106: }
107: void isForwardDeclaration ( bool state@var646 ) {
108: setFlag (@expr1073746410 fIsForwardDeclaration , state@var646 ) ;
109: }
110: void isVariadic ( bool state@var647 ) {
111: setFlag (@expr1073746411 fIsVariadic , state@var647 ) ;
112: }
113: void isFriend ( bool state@var648 ) {
114: setFlag (@expr1073746412 fIsFriend , state@var648 ) ;
115: }
116:
|
121:
122: bool getFlag ( unsigned int flag@var649 ) const {
123: return (@expr4589 (@expr4589 mFlags@var639 &@expr1073746415 flag@var649 ) !=@expr1073746416 0 ) ;
124: }
125:
|
130:
131: void setFlag ( unsigned int flag@var650 , bool state@var651 ) {
132: mFlags@var639 =@expr1073746417 state@var651 ?@expr1073746418 mFlags@var639 |@expr1073746419 flag@var650 :@expr1073746420 mFlags@var639 &@expr1073746421 ~@expr1073746422 flag@var650 ;
133: }
134:
135: public:
136:
|
140:
141: TokenAndName ( Token * token@var652 , const std :: string & scope@var653 ) ;
142:
|
148:
149: TokenAndName ( Token * token@var654 , const std :: string & scope@var655 , const Token * nameToken@var656 , const Token * paramEnd@var657 ) ;
150: TokenAndName ( const TokenAndName & other@var658 ) ;
151: ~ TokenAndName ( ) ;
152:
153: bool operator== ( const TokenAndName & rhs@var659 ) const {
154: return mToken@var633 ==@expr1073746423 rhs@var659 .@expr1073746424 mToken@var660 &&@expr1073746425 mScope@var634 ==@expr1073746426 rhs@var659 .@expr1073746427 mScope@var661 &&@expr1073746428 mName@var635 ==@expr1073746429 rhs@var659 .@expr1073746430 mName@var662 &&@expr1073746431 mFullName@var636 ==@expr1073746432 rhs@var659 .@expr1073746433 mFullName@var663 &&@expr1073746434
155: mNameToken@var637 ==@expr1073746435 rhs@var659 .@expr1073746436 mNameToken@var664 &&@expr1073746437 mParamEnd@var638 ==@expr1073746438 rhs@var659 .@expr1073746439 mParamEnd@var665 &&@expr1073746440 mFlags@var639 ==@expr1073746441 rhs@var659 .@expr1073746442 mFlags@var666 ;
156: }
157:
158: Token * token ( ) const {
159: return mToken@var633 ;
160: }
161: void token ( Token * token@var667 ) {
162: mToken@var633 =@expr1073746443 token@var667 ;
163: }
164: const std :: string & scope ( ) const {
165: return mScope@var634 ;
166: }
167: const std :: string & name ( ) const {
168: return mName@var635 ;
169: }
170: const std :: string & fullName ( ) const {
171: return mFullName@var636 ;
172: }
173: const Token * nameToken ( ) const {
174: return mNameToken@var637 ;
175: }
176: const Token * paramEnd ( ) const {
177: return mParamEnd@var638 ;
178: }
179: void paramEnd ( const Token * end@var668 ) {
180: mParamEnd@var638 =@expr1073746444 end@var668 ;
181: }
182:
183: bool isClass ( ) const {
184: return getFlag (@expr1073746445 fIsClass ) ;
185: }
186: bool isFunction ( ) const {
187: return getFlag (@expr1073746446 fIsFunction ) ;
188: }
189: bool isVariable ( ) const {
190: return getFlag (@expr1073746447 fIsVariable ) ;
191: }
192: bool isAlias ( ) const {
193: return getFlag (@expr1073746448 fIsAlias ) ;
194: }
195: bool isSpecialization ( ) const {
196: return getFlag (@expr1073746449 fIsSpecialization ) ;
197: }
198: bool isPartialSpecialization ( ) const {
199: return getFlag (@expr1073746450 fIsPartialSpecialization ) ;
200: }
201: bool isForwardDeclaration ( ) const {
202: return getFlag (@expr1073746451 fIsForwardDeclaration ) ;
203: }
204: bool isVariadic ( ) const {
205: return getFlag (@expr1073746452 fIsVariadic ) ;
206: }
207: bool isFriend ( ) const {
208: return getFlag (@expr1073746453 fIsFriend ) ;
209: }
210:
|
216:
217: const Token * aliasStartToken ( ) const ;
218:
|
224:
225: const Token * aliasEndToken ( ) const ;
226:
|
233:
234: bool isAliasToken ( const Token * tok@var669 ) const ;
235:
|
241:
242: bool isSameFamily ( const TemplateSimplifier :: TokenAndName & decl@var670 ) const {
243:
244:
245: return (@expr4630 (@expr4630 mFlags@var639 &@expr1073746456 fFamilyMask ) &@expr1073746457 (@expr4630 decl@var670 .@expr1073746459 mFlags@var671 &@expr1073746460 fFamilyMask ) ) !=@expr1073746461 0 ;
246: }
247: } ;
248:
|
253:
254: static Token * findTemplateDeclarationEnd ( Token * tok@var672 ) ;
255: static const Token * findTemplateDeclarationEnd ( const Token * tok@var673 ) ;
256:
|
264:
265: static bool instantiateMatch ( const Token * instance@var674 , const unsigned long numberOfArguments@var675 , bool variadic@var676 , const char patternAfter@var677 [ ] ) ;
266:
|
272:
273: int getTemplateNamePosition ( const Token * tok@var678 ) ;
274:
|
280:
281: static bool getTemplateNamePositionTemplateClass ( const Token * tok@var679 , int & namepos@var680 ) ;
282:
|
288:
289: static bool getTemplateNamePositionTemplateFunction ( const Token * tok@var681 , int & namepos@var682 ) ;
290:
|
296:
297: static bool getTemplateNamePositionTemplateVariable ( const Token * tok@var683 , int & namepos@var684 ) ;
298:
|
303:
304: void simplifyTemplates (
305: const std :: time_t maxtime@var685 ,
306: bool & codeWithTemplates@var686 ) ;
307:
|
313:
314: static bool simplifyNumericCalculations ( Token * tok@var687 , bool isTemplate@var688 = true ) ;
315:
|
321:
322: bool simplifyCalculations ( Token * frontToken@var689 = nullptr , Token * backToken@var690 = nullptr , bool isTemplate@var691 = true ) ;
323:
|
327:
328: void simplifyTemplateArgs ( Token * start@var692 , Token * end@var693 ) ;
329:
330: private:
331:
|
334:
335: bool getTemplateDeclarations ( ) ;
336:
|
340:
341: void addInstantiation ( Token * token@var694 , const std :: string & scope@var695 ) ;
342:
|
345:
346: void getTemplateInstantiations ( ) ;
347:
|
351:
352: void fixForwardDeclaredDefaultArgumentValues ( ) ;
353:
|
356:
357: void useDefaultArgumentValues ( ) ;
358:
|
362:
363: void useDefaultArgumentValues ( TokenAndName & declaration@var696 ) ;
364:
|
368:
369: void getSpecializations ( ) ;
370:
|
374:
375: void getPartialSpecializations ( ) ;
376:
|
379:
380: void simplifyTemplateAliases ( ) ;
381:
|
390:
391: bool simplifyTemplateInstantiations (
392: const TokenAndName & templateDeclaration@var697 ,
393: const std :: list < const Token * > & specializations@var698 ,
394: const std :: time_t maxtime@var699 ,
395: std :: set < std :: string > & expandedtemplates@var700 ) ;
396:
|
401:
402: void addNamespace ( const TokenAndName & templateDeclaration@var701 , const Token * tok@var702 ) ;
403:
|
409:
410: static bool alreadyHasNamespace ( const TokenAndName & templateDeclaration@var703 , const Token * tok@var704 ) ;
411:
|
419:
420: void expandTemplate (
421: const TokenAndName & templateDeclaration@var705 ,
422: const TokenAndName & templateInstantiation@var706 ,
423: const std :: vector < const Token * > & typeParametersInDeclaration@var707 ,
424: const std :: string & newName@var708 ,
425: bool copy@var709 ) ;
426:
|
432:
433: void replaceTemplateUsage ( const TokenAndName & instantiation@var710 ,
434: const std :: list < std :: string > & typeStringsUsedInTemplateInstantiation@var711 ,
435: const std :: string & newName@var712 ) ;
436:
|
443:
444: static void getTemplateParametersInDeclaration (
445: const Token * tok@var713 ,
446: std :: vector < const Token * > & typeParametersInDeclaration@var714 ) ;
447:
|
450:
451: static bool removeTemplate ( Token * tok@var715 ) ;
452:
453:
454: static void syntaxError ( const Token * tok@var716 ) ;
455:
456: static bool matchSpecialization (
457: const Token * templateDeclarationNameToken@var717 ,
458: const Token * templateInstantiationNameToken@var718 ,
459: const std :: list < const Token * > & specializations@var719 ) ;
460:
|
465:
466: static void eraseTokens ( Token * begin@var720 , const Token * end@var721 ) ;
467:
|
472:
473: static void deleteToken ( Token * tok@var722 ) ;
474:
|
480:
481: std :: string getNewName (
482: Token * tok2@var723 ,
483: std :: list < std :: string > & typeStringsUsedInTemplateInstantiation@var724 ) ;
484:
485: void printOut (
486: const TokenAndName & tokenAndName@var725 ,
487: const std :: string & indent@var726 = "    " ) const ;
488: void printOut ( const std :: string & text@var727 = "" ) const ;
489:
490: Tokenizer * mTokenizer@var728 ;
491: TokenList & mTokenList@var729 ;
492: const Settings * mSettings@var730 ;
493: ErrorLogger * mErrorLogger@var731 ;
494: bool mChanged@var732 ;
495:
496: std :: list < TokenAndName > mTemplateDeclarations@var733 ;
497: std :: list < TokenAndName > mTemplateForwardDeclarations@var734 ;
498: std :: map < Token * , Token * > mTemplateForwardDeclarationsMap@var735 ;
499: std :: map < Token * , Token * > mTemplateSpecializationMap@var736 ;
500: std :: map < Token * , Token * > mTemplatePartialSpecializationMap@var737 ;
501: std :: list < TokenAndName > mTemplateInstantiations@var738 ;
502: std :: list < TokenAndName > mInstantiatedTemplates@var739 ;
503: std :: list < TokenAndName > mMemberFunctionsToDelete@var740 ;
504: std :: vector < TokenAndName > mExplicitInstantiationsToDelete@var741 ;
505: std :: vector < TokenAndName > mTypesUsedInTemplateInstantiation@var742 ;
506: std :: unordered_map < const Token * , int > mTemplateNamePos@var743 ;
507: } ;

##file cppcheck-2.8/lib/token.h

1:
|
40:
41: class Enumerator ;
42: class Function ;
43: class Scope ;
44: class Settings ;
45: class Type ;
46: class ValueType ;
47: class Variable ;
48: class TokenList ;
49: class ConstTokenRange ;
50: class Token ;
51:
|
54:
55: struct TokensFrontBack {
56: Token * front@var744 ;
57: Token * back@var745 ;
58: const TokenList * list@var746 ;
59: } ;
60:
61: struct ScopeInfo2 {
62: ScopeInfo2 ( const std :: string & name_@var747 , const Token * bodyEnd_@var748 , const std :: set < std :: string > & usingNamespaces_@var749 = std :: set < std :: string > ( ) ) : name@var750 ( name_@var747 ) , bodyEnd@var751 ( bodyEnd_@var748 ) , usingNamespaces@var752 ( usingNamespaces_@var749 ) { }
63: std :: string name@var750 ;
64: const Token * const bodyEnd@var751 ;
65: std :: set < std :: string > usingNamespaces@var752 ;
66: } ;
67:
68: struct TokenImpl {
69: int mVarId@var753 ;
70: int mFileIndex@var754 ;
71: int mLineNumber@var755 ;
72: int mColumn@var756 ;
73: int mExprId@var757 ;
74:
75:
76: Token * mAstOperand1@var758 ;
77: Token * mAstOperand2@var759 ;
78: Token * mAstParent@var760 ;
79:
80:
81: const Scope * mScope@var761 ;
82: union {
83: const Function * mFunction@var762 ;
84: const Variable * mVariable@var763 ;
85: const :: Type * mType@var764 ;
86: const Enumerator * mEnumerator@var765 ;
87: } ;
88:
|
92:
93: int mProgressValue@var766 ;
94:
|
97:
98: int mIndex@var767 ;
99:
100:
101: std :: string * mOriginalName@var768 ;
102:
103:
104: ValueType * mValueType@var769 ;
105:
106:
107: std :: list < ValueFlow :: Value > * mValues@var770 ;
108: static const std :: list < ValueFlow :: Value > mEmptyValueList@var771 ;
109:
110:
111: std :: set < TemplateSimplifier :: TokenAndName * > * mTemplateSimplifierPointers@var772 ;
112:
113:
114: std :: shared_ptr < ScopeInfo2 > mScopeInfo@var773 ;
115:
116:
117: struct CppcheckAttributes {
118: enum Type { LOW , HIGH } ; enum Type type@var774 ;
119: long long value@var775 ;
120: struct CppcheckAttributes * next@var776 ;
121: } ;
122: struct CppcheckAttributes * mCppcheckAttributes@var777 ;
123:
124:
125: enum class Cpp11init { UNKNOWN , CPP11INIT , NOINIT } ; enum Cpp11init mCpp11init@var778 ;
126:
127:
128: unsigned char mBits@var779 ;
129:
130: void setCppcheckAttribute ( CppcheckAttributes :: Type type@var780 , long long value@var781 ) ;
131: bool getCppcheckAttribute ( CppcheckAttributes :: Type type@var782 , long long * value@var783 ) const ;
132:
133: TokenImpl ( )
134: : mVarId@var753 ( 0 )
135: , mFileIndex@var754 ( 0 )
136: , mLineNumber@var755 ( 0 )
137: , mColumn@var756 ( 0 )
138: , mExprId@var757 ( 0 )
139: , mAstOperand1@var758 ( nullptr )
140: , mAstOperand2@var759 ( nullptr )
141: , mAstParent@var760 ( nullptr )
142: , mScope@var761 ( nullptr )
143: , mFunction@var762 ( nullptr )
144: , mProgressValue@var766 ( 0 )
145: , mIndex@var767 ( 0 )
146: , mOriginalName@var768 ( nullptr )
147: , mValueType@var769 ( nullptr )
148: , mValues@var770 ( nullptr )
149: , mTemplateSimplifierPointers@var772 ( nullptr )
150: , mScopeInfo@var773 ( nullptr )
151: , mCppcheckAttributes@var777 ( nullptr )
152: , mCpp11init@var778 ( Cpp11init :: UNKNOWN )
153: , mBits@var779 ( 0 )
154: { }
155:
156: ~ TokenImpl ( ) ;
157: } ;
158:
|
171:
172: class Token {
173: private:
174: TokensFrontBack * mTokensFrontBack@var784 ;
175:
176:
177: Token ( const Token & ) ;
178: Token operator= ( const Token & ) ;
179:
180: public:
181: enum Type {
182: eVariable , eType , eFunction , eKeyword , eName ,
183: eNumber , eString , eChar , eBoolean , eLiteral , eEnumerator ,
184: eArithmeticalOp , eComparisonOp , eAssignmentOp , eLogicalOp , eBitOp , eIncDecOp , eExtendedOp ,
185: eBracket ,
186: eLambda ,
187: eEllipsis ,
188: eOther ,
189: eNone
190: } ;
191:
192: explicit Token ( TokensFrontBack * tokensFrontBack@var785 = nullptr ) ;
193: ~ Token ( ) ;
194:
195: ConstTokenRange until ( const Token * t@var786 ) const ;
196:
197: template < typename T >
198: void str ( T && s@var787 ) {
199: mStr@var999 =@expr1073746462 s@var787 ;
200: mImpl@var1005 .@expr1073746463 mVarId@var1036 =@expr1073746464 0 ;
201:
202: update_property_info (@expr1073746465 ) ;
203: }
204:
|
208:
209: void concatStr ( const std :: string & b@var788 ) ;
210:
211: const std :: string & str ( ) const {
212: return mStr@var999 ;
213: }
214:
|
217:
218: void deleteNext ( int count@var789 = 1 ) ;
219:
|
222:
223: void deletePrevious ( int count@var790 = 1 ) ;
224:
|
227:
228: void swapWithNext ( ) ;
229:
|
234:
235: const Token * tokAt ( int index@var791 ) const ;
236: Token * tokAt ( int index@var792 ) {
237: return const_cast < Token *@expr4642 > (@expr1073746467 const_cast < const Token *@expr4642 > (@expr1073746469 this@expr1073746470 ) .@expr1073746471 tokAt (@expr1073746472 index@var792 ) ) ;
238: }
239:
|
243:
244: const Token * linkAt ( int index@var793 ) const ;
245: Token * linkAt ( int index@var794 ) {
246: return const_cast < Token *@expr4649 > (@expr1073746474 const_cast < const Token *@expr4649 > (@expr1073746476 this@expr1073746477 ) .@expr1073746478 linkAt (@expr1073746479 index@var794 ) ) ;
247: }
248:
|
252:
253: const std :: string & strAt ( int index@var795 ) const ;
254:
|
273:
274: template < unsigned long count >
275: static bool simpleMatch ( const Token * tok@var796 , const char ( & pattern@var797 ) [ count ] ) {
276: return simpleMatch (@expr1073746481 tok@var796 , pattern@var797 , count@expr1073746480 -@expr1073746482 1 ) ;
277: }
278:
279: static bool simpleMatch ( const Token * tok@var798 , const char pattern@var799 [ ] , unsigned long pattern_len@var800 ) ;
280:
|
323:
324: static bool Match ( const Token * tok@var801 , const char pattern@var802 [ ] , int varid@var803 = 0 ) ;
325:
|
332:
333: static int getStrLength ( const Token * tok@var804 ) ;
334:
|
341:
342: static int getStrArraySize ( const Token * tok@var805 ) ;
343:
|
351:
352: static int getStrSize ( const Token * tok@var806 , const Settings * const settings@var807 ) ;
353:
|
361:
362: static std :: string getCharAt ( const Token * tok@var808 , long long index@var809 ) ;
363:
364: const ValueType * valueType ( ) const {
365: return mImpl@var1005 .@expr1073746483 mValueType@var1037 ;
366: }
367: void setValueType ( ValueType * vt@var810 ) ;
368:
369: const ValueType * argumentType ( ) const {
370: const Token * top@var811 ; top@var811 =@expr1073746484 this@expr1073746485 ;
371: while (@expr1073746486 top@var811 &&@expr1073746487 !@expr1073746488 Token ::@expr1073746489 Match (@expr1073746490 top@var811 .@expr4667 astParent (@expr4668 ) , ",|(" ) ) {
372: top@var811 =@expr1073746493 top@var811 .@expr4667 astParent (@expr4668 ) ; }
373: return top@var811 ?@expr1073746496 top@var811 .@expr1073746497 mImpl@var812 .@expr1073746498 mValueType@var813 :@expr1073746499 nullptr ;
374: }
375:
376: Token :: Type tokType ( ) const {
377: return mTokType@var1003 ;
378: }
379: void tokType ( Token :: Type t@var814 ) {
380: mTokType@var1003 =@expr1073746500 t@var814 ;
381:
382: const bool memoizedIsName@var815 =@expr1073746501 mTokType@var1003 ==@expr1073746502 eName ||@expr1073746503 mTokType@var1003 ==@expr1073746504 eType ||@expr1073746505 mTokType@var1003 ==@expr1073746506 eVariable ||@expr1073746507
383: mTokType@var1003 ==@expr1073746508 eFunction ||@expr1073746509 mTokType@var1003 ==@expr1073746510 eKeyword ||@expr1073746511 mTokType@var1003 ==@expr4688 eBoolean ||@expr1073746513
384: mTokType@var1003 ==@expr4690 eEnumerator ;
385: setFlag (@expr1073746515 fIsName , memoizedIsName@var815 ) ;
386:
387: const bool memoizedIsLiteral@var816 =@expr1073746516 mTokType@var1003 ==@expr1073746517 eNumber ||@expr1073746518 mTokType@var1003 ==@expr1073746519 eString ||@expr1073746520 mTokType@var1003 ==@expr1073746521 eChar ||@expr1073746522
388: mTokType@var1003 ==@expr4688 eBoolean ||@expr1073746524 mTokType@var1003 ==@expr1073746525 eLiteral ||@expr1073746526 mTokType@var1003 ==@expr4690 eEnumerator ;
389: setFlag (@expr1073746528 fIsLiteral , memoizedIsLiteral@var816 ) ;
390: }
391: bool isKeyword ( ) const {
392: return mTokType@var1003 ==@expr1073746529 eKeyword ;
393: }
394: bool isName ( ) const {
395: return getFlag (@expr1073746530 fIsName ) ;
396: }
397: bool isNameOnly ( ) const {
398: return mFlags@var1004 ==@expr1073746531 fIsName &&@expr1073746532 mTokType@var1003 ==@expr1073746533 eName ;
399: }
400: bool isUpperCaseName ( ) const ;
401: bool isLiteral ( ) const {
402: return getFlag (@expr1073746534 fIsLiteral ) ;
403: }
404: bool isNumber ( ) const {
405: return mTokType@var1003 ==@expr1073746535 eNumber ;
406: }
407: bool isEnumerator ( ) const {
408: return mTokType@var1003 ==@expr1073746536 eEnumerator ;
409: }
410: bool isOp ( ) const {
411: return (@expr1073746537 isConstOp (@expr1073746538 ) ||@expr1073746539
412: isAssignmentOp (@expr1073746540 ) ||@expr1073746541
413: mTokType@var1003 ==@expr1073746542 eIncDecOp ) ;
414: }
415: bool isConstOp ( ) const {
416: return (@expr1073746543 isArithmeticalOp (@expr1073746544 ) ||@expr1073746545
417: mTokType@var1003 ==@expr1073746546 eLogicalOp ||@expr1073746547
418: mTokType@var1003 ==@expr1073746548 eComparisonOp ||@expr1073746549
419: mTokType@var1003 ==@expr1073746550 eBitOp ) ;
420: }
421: bool isExtendedOp ( ) const {
422: return isConstOp (@expr1073746551 ) ||@expr1073746552
423: mTokType@var1003 ==@expr1073746553 eExtendedOp ;
424: }
425: bool isArithmeticalOp ( ) const {
426: return mTokType@var1003 ==@expr1073746554 eArithmeticalOp ;
427: }
428: bool isComparisonOp ( ) const {
429: return mTokType@var1003 ==@expr1073746555 eComparisonOp ;
430: }
431: bool isAssignmentOp ( ) const {
432: return mTokType@var1003 ==@expr1073746556 eAssignmentOp ;
433: }
434: bool isBoolean ( ) const {
435: return mTokType@var1003 ==@expr1073746557 eBoolean ;
436: }
437: bool isIncDecOp ( ) const {
438: return mTokType@var1003 ==@expr1073746558 eIncDecOp ;
439: }
440: bool isBinaryOp ( ) const {
441: return astOperand1 (@expr1073746559 ) !=@expr1073746560 nullptr &&@expr1073746561 astOperand2 (@expr1073746562 ) !=@expr1073746563 nullptr ;
442: }
443: bool isUnaryOp ( const std :: string & s@var817 ) const {
444: return s@var817 ==@expr1073746564 mStr@var999 &&@expr1073746565 astOperand1 (@expr1073746566 ) !=@expr1073746567 nullptr &&@expr1073746568 astOperand2 (@expr1073746569 ) ==@expr1073746570 nullptr ;
445: }
446: bool isUnaryPreOp ( ) const ;
447:
448: unsigned int flags ( ) const {
449: return mFlags@var1004 ;
450: }
451: void flags ( const unsigned int flags_@var818 ) {
452: mFlags@var1004 =@expr1073746571 flags_@var818 ;
453: }
454: bool isUnsigned ( ) const {
455: return getFlag (@expr1073746572 fIsUnsigned ) ;
456: }
457: void isUnsigned ( const bool sign@var819 ) {
458: setFlag (@expr1073746573 fIsUnsigned , sign@var819 ) ;
459: }
460: bool isSigned ( ) const {
461: return getFlag (@expr1073746574 fIsSigned ) ;
462: }
463: void isSigned ( const bool sign@var820 ) {
464: setFlag (@expr1073746575 fIsSigned , sign@var820 ) ;
465: }
466: bool isPointerCompare ( ) const {
467: return getFlag (@expr1073746576 fIsPointerCompare ) ;
468: }
469: void isPointerCompare ( const bool b@var821 ) {
470: setFlag (@expr1073746577 fIsPointerCompare , b@var821 ) ;
471: }
472: bool isLong ( ) const {
473: return getFlag (@expr1073746578 fIsLong ) ;
474: }
475: void isLong ( bool size@var822 ) {
476: setFlag (@expr1073746579 fIsLong , size@var822 ) ;
477: }
478: bool isStandardType ( ) const {
479: return getFlag (@expr1073746580 fIsStandardType ) ;
480: }
481: void isStandardType ( const bool b@var823 ) {
482: setFlag (@expr1073746581 fIsStandardType , b@var823 ) ;
483: }
484: bool isExpandedMacro ( ) const {
485: return getFlag (@expr1073746582 fIsExpandedMacro ) ;
486: }
487: void isExpandedMacro ( const bool m@var824 ) {
488: setFlag (@expr1073746583 fIsExpandedMacro , m@var824 ) ;
489: }
490: bool isCast ( ) const {
491: return getFlag (@expr1073746584 fIsCast ) ;
492: }
493: void isCast ( bool c@var825 ) {
494: setFlag (@expr1073746585 fIsCast , c@var825 ) ;
495: }
496: bool isAttributeConstructor ( ) const {
497: return getFlag (@expr1073746586 fIsAttributeConstructor ) ;
498: }
499: void isAttributeConstructor ( const bool ac@var826 ) {
500: setFlag (@expr1073746587 fIsAttributeConstructor , ac@var826 ) ;
501: }
502: bool isAttributeDestructor ( ) const {
503: return getFlag (@expr1073746588 fIsAttributeDestructor ) ;
504: }
505: void isAttributeDestructor ( const bool value@var827 ) {
506: setFlag (@expr1073746589 fIsAttributeDestructor , value@var827 ) ;
507: }
508: bool isAttributeUnused ( ) const {
509: return getFlag (@expr1073746590 fIsAttributeUnused ) ;
510: }
511: void isAttributeUnused ( bool unused@var828 ) {
512: setFlag (@expr1073746591 fIsAttributeUnused , unused@var828 ) ;
513: }
514: bool isAttributeUsed ( ) const {
515: return getFlag (@expr1073746592 fIsAttributeUsed ) ;
516: }
517: void isAttributeUsed ( const bool unused@var829 ) {
518: setFlag (@expr1073746593 fIsAttributeUsed , unused@var829 ) ;
519: }
520: bool isAttributePure ( ) const {
521: return getFlag (@expr1073746594 fIsAttributePure ) ;
522: }
523: void isAttributePure ( const bool value@var830 ) {
524: setFlag (@expr1073746595 fIsAttributePure , value@var830 ) ;
525: }
526: bool isAttributeConst ( ) const {
527: return getFlag (@expr1073746596 fIsAttributeConst ) ;
528: }
529: void isAttributeConst ( bool value@var831 ) {
530: setFlag (@expr1073746597 fIsAttributeConst , value@var831 ) ;
531: }
532: bool isAttributeNoreturn ( ) const {
533: return getFlag (@expr1073746598 fIsAttributeNoreturn ) ;
534: }
535: void isAttributeNoreturn ( const bool value@var832 ) {
536: setFlag (@expr1073746599 fIsAttributeNoreturn , value@var832 ) ;
537: }
538: bool isAttributeNothrow ( ) const {
539: return getFlag (@expr1073746600 fIsAttributeNothrow ) ;
540: }
541: void isAttributeNothrow ( const bool value@var833 ) {
542: setFlag (@expr1073746601 fIsAttributeNothrow , value@var833 ) ;
543: }
544: bool isAttributePacked ( ) const {
545: return getFlag (@expr1073746602 fIsAttributePacked ) ;
546: }
547: void isAttributePacked ( const bool value@var834 ) {
548: setFlag (@expr1073746603 fIsAttributePacked , value@var834 ) ;
549: }
550: bool isAttributeNodiscard ( ) const {
551: return getFlag (@expr1073746604 fIsAttributeNodiscard ) ;
552: }
553: void isAttributeNodiscard ( const bool value@var835 ) {
554: setFlag (@expr1073746605 fIsAttributeNodiscard , value@var835 ) ;
555: }
556: bool isAttributeMaybeUnused ( ) const {
557: return getFlag (@expr1073746606 fIsAttributeMaybeUnused ) ;
558: }
559: void isAttributeMaybeUnused ( const bool value@var836 ) {
560: setFlag (@expr1073746607 fIsAttributeMaybeUnused , value@var836 ) ;
561: }
562: void setCppcheckAttribute ( TokenImpl :: CppcheckAttributes :: Type type@var837 , long long value@var838 ) {
563: mImpl@var1005 .@expr1073746608 setCppcheckAttribute (@expr1073746609 type@var837 , value@var838 ) ;
564: }
565: bool getCppcheckAttribute ( TokenImpl :: CppcheckAttributes :: Type type@var839 , long long * value@var840 ) const {
566: return mImpl@var1005 .@expr1073746610 getCppcheckAttribute (@expr1073746611 type@var839 , value@var840 ) ;
567: }
568: bool hasCppcheckAttributes ( ) const {
569: return nullptr !=@expr1073746612 mImpl@var1005 .@expr1073746613 mCppcheckAttributes@var1038 ;
570: }
571: bool isControlFlowKeyword ( ) const {
572: return getFlag (@expr1073746614 fIsControlFlowKeyword ) ;
573: }
574: bool isOperatorKeyword ( ) const {
575: return getFlag (@expr1073746615 fIsOperatorKeyword ) ;
576: }
577: void isOperatorKeyword ( const bool value@var841 ) {
578: setFlag (@expr1073746616 fIsOperatorKeyword , value@var841 ) ;
579: }
580: bool isComplex ( ) const {
581: return getFlag (@expr1073746617 fIsComplex ) ;
582: }
583: void isComplex ( const bool value@var842 ) {
584: setFlag (@expr1073746618 fIsComplex , value@var842 ) ;
585: }
586: bool isEnumType ( ) const {
587: return getFlag (@expr1073746619 fIsEnumType ) ;
588: }
589: void isEnumType ( const bool value@var843 ) {
590: setFlag (@expr1073746620 fIsEnumType , value@var843 ) ;
591: }
592: bool isAtAddress ( ) const {
593: return getFlag (@expr1073746621 fAtAddress ) ;
594: }
595: void isAtAddress ( bool b@var844 ) {
596: setFlag (@expr1073746622 fAtAddress , b@var844 ) ;
597: }
598: bool isIncompleteVar ( ) const {
599: return getFlag (@expr1073746623 fIncompleteVar ) ;
600: }
601: void isIncompleteVar ( bool b@var845 ) {
602: setFlag (@expr1073746624 fIncompleteVar , b@var845 ) ;
603: }
604:
605: bool isIncompleteConstant ( ) const {
606: return getFlag (@expr1073746625 fIsIncompleteConstant ) ;
607: }
608: void isIncompleteConstant ( bool b@var846 ) {
609: setFlag (@expr1073746626 fIsIncompleteConstant , b@var846 ) ;
610: }
611:
612: bool isConstexpr ( ) const {
613: return getFlag (@expr1073746627 fConstexpr ) ;
614: }
615: void isConstexpr ( bool b@var847 ) {
616: setFlag (@expr1073746628 fConstexpr , b@var847 ) ;
617: }
618:
619: bool isExternC ( ) const {
620: return getFlag (@expr1073746629 fExternC ) ;
621: }
622: void isExternC ( bool b@var848 ) {
623: setFlag (@expr1073746630 fExternC , b@var848 ) ;
624: }
625:
626: bool isSplittedVarDeclComma ( ) const {
627: return getFlag (@expr1073746631 fIsSplitVarDeclComma ) ;
628: }
629: void isSplittedVarDeclComma ( bool b@var849 ) {
630: setFlag (@expr1073746632 fIsSplitVarDeclComma , b@var849 ) ;
631: }
632:
633: bool isSplittedVarDeclEq ( ) const {
634: return getFlag (@expr1073746633 fIsSplitVarDeclEq ) ;
635: }
636: void isSplittedVarDeclEq ( bool b@var850 ) {
637: setFlag (@expr1073746634 fIsSplitVarDeclEq , b@var850 ) ;
638: }
639:
640: bool isImplicitInt ( ) const {
641: return getFlag (@expr1073746635 fIsImplicitInt ) ;
642: }
643: void isImplicitInt ( bool b@var851 ) {
644: setFlag (@expr1073746636 fIsImplicitInt , b@var851 ) ;
645: }
646:
647: bool isInline ( ) const {
648: return getFlag (@expr1073746637 fIsInline ) ;
649: }
650: void isInline ( bool b@var852 ) {
651: setFlag (@expr1073746638 fIsInline , b@var852 ) ;
652: }
653:
654: bool isRemovedVoidParameter ( ) const {
655: return getFlag (@expr1073746639 fIsRemovedVoidParameter ) ;
656: }
657: void setRemovedVoidParameter ( bool b@var853 ) {
658: setFlag (@expr1073746640 fIsRemovedVoidParameter , b@var853 ) ;
659: }
660:
661: bool isTemplate ( ) const {
662: return getFlag (@expr1073746641 fIsTemplate ) ;
663: }
664: void isTemplate ( bool b@var854 ) {
665: setFlag (@expr1073746642 fIsTemplate , b@var854 ) ;
666: }
667:
668: bool isSimplifiedScope ( ) const {
669: return getFlag (@expr1073746643 fIsSimplifedScope ) ;
670: }
671: void isSimplifiedScope ( bool b@var855 ) {
672: setFlag (@expr1073746644 fIsSimplifedScope , b@var855 ) ;
673: }
674:
675: bool isBitfield ( ) const {
676: return mImpl@var1005 .@expr1073746645 mBits@var1039 >@expr1073746646 0 ;
677: }
678: unsigned char bits ( ) const {
679: return mImpl@var1005 .@expr1073746647 mBits@var1039 ;
680: }
681: std :: set < TemplateSimplifier :: TokenAndName * > * templateSimplifierPointers ( ) const {
682: return mImpl@var1005 .@expr1073746648 mTemplateSimplifierPointers@var1040 ;
683: }
684: void templateSimplifierPointer ( TemplateSimplifier :: TokenAndName * tokenAndName@var856 ) {
685: if (@expr1073746649 !@expr1073746650 mImpl@var1005 .@expr4827 mTemplateSimplifierPointers@var1040 ) {
686: mImpl@var1005 .@expr4827 mTemplateSimplifierPointers@var1040 =@expr1073746653 new std ::@expr1073746654 set < TemplateSimplifier ::@expr1073746655 TokenAndName *@expr1073746656 > ; }
687: mImpl@var1005 .@expr4827 mTemplateSimplifierPointers@var1040 .@expr1073746658 insert (@expr1073746659 tokenAndName@var856 ) ;
688: }
689: void setBits ( const unsigned char b@var857 ) {
690: mImpl@var1005 .@expr1073746660 mBits@var1039 =@expr1073746661 b@var857 ;
691: }
692:
693: bool isUtf8 ( ) const {
694: return (@expr4838 (@expr4838 (@expr4838 mTokType@var1003 ==@expr1073746665 eString ) &&@expr1073746666 isPrefixStringCharLiteral (@expr1073746667 mStr@var999 , '"' , "u8" ) ) ||@expr1073746668
695: (@expr4838 (@expr4838 mTokType@var1003 ==@expr1073746671 eChar ) &&@expr1073746672 isPrefixStringCharLiteral (@expr1073746673 mStr@var999 , '\'' , "u8" ) ) ) ;
696: }
697:
698: bool isUtf16 ( ) const {
699: return (@expr4850 (@expr4850 (@expr4850 mTokType@var1003 ==@expr1073746677 eString ) &&@expr1073746678 isPrefixStringCharLiteral (@expr1073746679 mStr@var999 , '"' , "u" ) ) ||@expr1073746680
700: (@expr4850 (@expr4850 mTokType@var1003 ==@expr1073746683 eChar ) &&@expr1073746684 isPrefixStringCharLiteral (@expr1073746685 mStr@var999 , '\'' , "u" ) ) ) ;
701: }
702:
703: bool isUtf32 ( ) const {
704: return (@expr4862 (@expr4862 (@expr4862 mTokType@var1003 ==@expr1073746689 eString ) &&@expr1073746690 isPrefixStringCharLiteral (@expr1073746691 mStr@var999 , '"' , "U" ) ) ||@expr1073746692
705: (@expr4862 (@expr4862 mTokType@var1003 ==@expr1073746695 eChar ) &&@expr1073746696 isPrefixStringCharLiteral (@expr1073746697 mStr@var999 , '\'' , "U" ) ) ) ;
706: }
707:
708: bool isCChar ( ) const {
709: return (@expr4874 (@expr4874 (@expr4874 mTokType@var1003 ==@expr1073746701 eString ) &&@expr1073746702 isPrefixStringCharLiteral (@expr1073746703 mStr@var999 , '"' , "" ) ) ||@expr1073746704
710: (@expr4874 (@expr4874 mTokType@var1003 ==@expr1073746707 eChar ) &&@expr1073746708 isPrefixStringCharLiteral (@expr1073746709 mStr@var999 , '\'' , "" ) &&@expr1073746710 mStr@var999 .@expr1073746711 length (@expr1073746712 ) ==@expr1073746713 3 ) ) ;
711: }
712:
713: bool isCMultiChar ( ) const {
714: return (@expr4890 (@expr4890 (@expr4890 mTokType@var1003 ==@expr1073746717 eChar ) &&@expr1073746718 isPrefixStringCharLiteral (@expr1073746719 mStr@var999 , '\'' , "" ) ) &&@expr1073746720
715: (@expr4890 mStr@var999 .@expr1073746722 length (@expr1073746723 ) >@expr1073746724 3 ) ) ;
716: }
717:
|
733:
734: bool isTemplateArg ( ) const {
735: return getFlag (@expr1073746725 fIsTemplateArg ) ;
736: }
737: void isTemplateArg ( const bool value@var858 ) {
738: setFlag (@expr1073746726 fIsTemplateArg , value@var858 ) ;
739: }
740:
741: template < unsigned long count >
742: static const Token * findsimplematch ( const Token * const startTok@var859 , const char ( & pattern@var860 ) [ count ] ) {
743: return findsimplematch (@expr1073746728 startTok@var859 , pattern@var860 , count@expr1073746727 -@expr1073746729 1 ) ;
744: }
745: static const Token * findsimplematch ( const Token * const startTok@var861 , const char pattern@var862 [ ] , unsigned long pattern_len@var863 ) ;
746:
747: template < unsigned long count >
748: static const Token * findsimplematch ( const Token * const startTok@var864 , const char ( & pattern@var865 ) [ count ] , const Token * const end@var866 ) {
749: return findsimplematch (@expr1073746731 startTok@var864 , pattern@var865 , count@expr1073746730 -@expr1073746732 1 , end@var866 ) ;
750: }
751: static const Token * findsimplematch ( const Token * const startTok@var867 , const char pattern@var868 [ ] , unsigned long pattern_len@var869 , const Token * const end@var870 ) ;
752:
753: static const Token * findmatch ( const Token * const startTok@var871 , const char pattern@var872 [ ] , const int varId@var873 = 0 ) ;
754: static const Token * findmatch ( const Token * const startTok@var874 , const char pattern@var875 [ ] , const Token * const end@var876 , const int varId@var877 = 0 ) ;
755:
756: template < unsigned long count >
757: static Token * findsimplematch ( Token * const startTok@var878 , const char ( & pattern@var879 ) [ count ] ) {
758: return findsimplematch (@expr1073746734 startTok@var878 , pattern@var879 , count@expr1073746733 -@expr1073746735 1 ) ;
759: }
760: static Token * findsimplematch ( Token * const startTok@var880 , const char pattern@var881 [ ] , unsigned long pattern_len@var882 ) {
761: return const_cast < Token *@expr4912 > (@expr1073746737 findsimplematch (@expr1073746738 const_cast < const Token *@expr4912 > (@expr1073746740 startTok@var880 ) , pattern@var881 , pattern_len@var882 ) ) ;
762: }
763: template < unsigned long count >
764: static Token * findsimplematch ( Token * const startTok@var883 , const char ( & pattern@var884 ) [ count ] , const Token * const end@var885 ) {
765: return findsimplematch (@expr1073746742 startTok@var883 , pattern@var884 , count@expr1073746741 -@expr1073746743 1 , end@var885 ) ;
766: }
767: static Token * findsimplematch ( Token * const startTok@var886 , const char pattern@var887 [ ] , unsigned long pattern_len@var888 , const Token * const end@var889 ) {
768: return const_cast < Token *@expr4920 > (@expr1073746745 findsimplematch (@expr1073746746 const_cast < const Token *@expr4920 > (@expr1073746748 startTok@var886 ) , pattern@var887 , pattern_len@var888 , end@var889 ) ) ;
769: }
770:
771: static Token * findmatch ( Token * const startTok@var890 , const char pattern@var891 [ ] , const int varId@var892 = 0 ) {
772: return const_cast < Token *@expr4925 > (@expr1073746750 findmatch (@expr1073746751 const_cast < const Token *@expr4925 > (@expr1073746753 startTok@var890 ) , pattern@var891 , varId@var892 ) ) ;
773: }
774: static Token * findmatch ( Token * const startTok@var893 , const char pattern@var894 [ ] , const Token * const end@var895 , const int varId@var896 = 0 ) {
775: return const_cast < Token *@expr4930 > (@expr1073746755 findmatch (@expr1073746756 const_cast < const Token *@expr4930 > (@expr1073746758 startTok@var893 ) , pattern@var894 , end@var895 , varId@var896 ) ) ;
776: }
777:
|
791:
792: static int multiCompare ( const Token * tok@var897 , const char * haystack@var898 , int varid@var899 ) ;
793:
794: int fileIndex ( ) const {
795: return mImpl@var1005 .@expr1073746759 mFileIndex@var1041 ;
796: }
797: void fileIndex ( int indexOfFile@var900 ) {
798: mImpl@var1005 .@expr1073746760 mFileIndex@var1041 =@expr1073746761 indexOfFile@var900 ;
799: }
800:
801: int linenr ( ) const {
802: return mImpl@var1005 .@expr1073746762 mLineNumber@var1042 ;
803: }
804: void linenr ( int lineNumber@var901 ) {
805: mImpl@var1005 .@expr1073746763 mLineNumber@var1042 =@expr1073746764 lineNumber@var901 ;
806: }
807:
808: int column ( ) const {
809: return mImpl@var1005 .@expr1073746765 mColumn@var1043 ;
810: }
811: void column ( int c@var902 ) {
812: mImpl@var1005 .@expr1073746766 mColumn@var1043 =@expr1073746767 c@var902 ;
813: }
814:
815: Token * next ( ) const {
816: return mNext@var1000 ;
817: }
818:
|
826:
827: static void eraseTokens ( Token * begin@var903 , const Token * end@var904 ) ;
828:
|
836:
837: Token * insertToken ( const std :: string & tokenStr@var905 , const std :: string & originalNameStr@var906 = emptyString@var1 , bool prepend@var907 = false ) ;
838:
839: Token * insertTokenBefore ( const std :: string & tokenStr@var908 , const std :: string & originalNameStr@var909 = emptyString@var1 )
840: {
841: return insertToken (@expr1073746768 tokenStr@var908 , originalNameStr@var909 , true ) ;
842: }
843:
844: Token * previous ( ) const {
845: return mPrevious@var1001 ;
846: }
847:
848:
849: int varId ( ) const {
850: return mImpl@var1005 .@expr1073746769 mVarId@var1036 ;
851: }
852: void varId ( int id@var910 ) {
853: mImpl@var1005 .@expr1073746770 mVarId@var1036 =@expr1073746771 id@var910 ;
854: if (@expr1073746772 id@var910 !=@expr1073746773 0 ) {
855: tokType (@expr1073746774 eVariable ) ;
856: isStandardType (@expr1073746775 false ) ;
857: } else {
858: update_property_info (@expr1073746776 ) ;
859: }
860: }
861:
862: int exprId ( ) const {
863: if (@expr1073746777 mImpl@var1005 .@expr4954 mExprId@var1044 ) {
864: return mImpl@var1005 .@expr4954 mExprId@var1044 ; }
865: return mImpl@var1005 .@expr1073746780 mVarId@var1036 ;
866: }
867: void exprId ( int id@var911 ) {
868: mImpl@var1005 .@expr1073746781 mExprId@var1044 =@expr1073746782 id@var911 ;
869: }
870:
|
876:
877: void printOut ( const char * title@var912 = nullptr ) const ;
878:
|
886:
887: void printOut ( const char * title@var913 , const std :: vector < std :: string > & fileNames@var914 ) const ;
888:
|
891:
892: void printLines ( int lines@var915 = 5 ) const ;
893:
|
900:
901: static void replace ( Token * replaceThis@var916 , Token * start@var917 , Token * end@var918 ) ;
902:
903: struct stringifyOptions {
904: bool varid@var919 ; varid@var919 = false ;
905: bool exprid@var920 ; exprid@var920 = false ;
906: bool idtype@var921 ; idtype@var921 = false ;
907: bool attributes@var922 ; attributes@var922 = false ;
908: bool macro@var923 ; macro@var923 = false ;
909: bool linenumbers@var924 ; linenumbers@var924 = false ;
910: bool linebreaks@var925 ; linebreaks@var925 = false ;
911: bool files@var926 ; files@var926 = false ;
912: static stringifyOptions forDebug ( ) {
913: stringifyOptions options@var927 ;
914: options@var927 .@expr1073746783 attributes@var928 =@expr1073746784 true ;
915: options@var927 .@expr1073746785 macro@var929 =@expr1073746786 true ;
916: options@var927 .@expr1073746787 linenumbers@var930 =@expr1073746788 true ;
917: options@var927 .@expr1073746789 linebreaks@var931 =@expr1073746790 true ;
918: options@var927 .@expr1073746791 files@var932 =@expr1073746792 true ;
919: return options@var927 ;
920: }
921: static stringifyOptions forDebugVarId ( ) {
922: stringifyOptions options@var933 ; options@var933 =@expr1073746793 forDebug (@expr1073746794 ) ;
923: options@var933 .@expr1073746795 varid@var934 =@expr1073746796 true ;
924: return options@var933 ;
925: }
926: static stringifyOptions forDebugExprId ( ) {
927: stringifyOptions options@var935 ; options@var935 =@expr1073746797 forDebug (@expr1073746798 ) ;
928: options@var935 .@expr1073746799 exprid@var936 =@expr1073746800 true ;
929: return options@var935 ;
930: }
931: static stringifyOptions forPrintOut ( ) {
932: stringifyOptions options@var937 ; options@var937 =@expr1073746801 forDebug (@expr1073746802 ) ;
933: options@var937 .@expr1073746803 exprid@var938 =@expr1073746804 true ;
934: options@var937 .@expr1073746805 varid@var939 =@expr1073746806 true ;
935: options@var937 .@expr1073746807 idtype@var940 =@expr1073746808 true ;
936: return options@var937 ;
937: }
938: } ;
939:
940: std :: string stringify ( const stringifyOptions & options@var941 ) const ;
941:
|
947:
948: std :: string stringify ( bool varid@var942 , bool attributes@var943 , bool macro@var944 ) const ;
949:
950: std :: string stringifyList ( const stringifyOptions & options@var945 , const std :: vector < std :: string > * fileNames@var946 = nullptr , const Token * end@var947 = nullptr ) const ;
951: std :: string stringifyList ( const Token * end@var948 , bool attributes@var949 = true ) const ;
952: std :: string stringifyList ( bool varid@var950 = false ) const ;
953:
|
964:
965: std :: string stringifyList ( bool varid@var951 , bool attributes@var952 , bool linenumbers@var953 , bool linebreaks@var954 , bool files@var955 , const std :: vector < std :: string > * fileNames@var956 = nullptr , const Token * end@var957 = nullptr ) const ;
966:
|
974:
975: void deleteThis ( ) ;
976:
|
981:
982: void link ( Token * linkToToken@var958 ) {
983: mLink@var1002 =@expr1073746809 linkToToken@var958 ;
984: if (@expr1073746810 mStr@var999 ==@expr1073746811 "<" ||@expr1073746812 mStr@var999 ==@expr1073746813 ">" ) {
985: update_property_info (@expr1073746814 ) ; }
986: }
987:
|
996:
997: Token * link ( ) const {
998: return mLink@var1002 ;
999: }
1000:
|
1004:
1005: void scope ( const Scope * s@var959 ) {
1006: mImpl@var1005 .@expr1073746815 mScope@var1045 =@expr1073746816 s@var959 ;
1007: }
1008:
|
1011:
1012: const Scope * scope ( ) const {
1013: return mImpl@var1005 .@expr1073746817 mScope@var1045 ;
1014: }
1015:
|
1019:
1020: void function ( const Function * f@var960 ) ;
1021:
|
1024:
1025: const Function * function ( ) const {
1026: return mTokType@var1003 ==@expr1073746818 eFunction ||@expr1073746819 mTokType@var1003 ==@expr1073746820 eLambda ?@expr1073746821 mImpl@var1005 .@expr1073746822 mFunction@var1046 :@expr1073746823 nullptr ;
1027: }
1028:
|
1032:
1033: void variable ( const Variable * v@var961 ) {
1034: mImpl@var1005 .@expr1073746824 mVariable@var1047 =@expr1073746825 v@var961 ;
1035: if (@expr1073746826 v@var961 ||@expr1073746827 mImpl@var1005 .@expr1073746828 mVarId@var1036 ) {
1036: tokType (@expr1073746829 eVariable ) ; }
1037: else { if (@expr1073746830 mTokType@var1003 ==@expr1073746831 eVariable ) {
1038: tokType (@expr1073746832 eName ) ; } }
1039: }
1040:
|
1043:
1044: const Variable * variable ( ) const {
1045: return mTokType@var1003 ==@expr1073746833 eVariable ?@expr1073746834 mImpl@var1005 .@expr1073746835 mVariable@var1047 :@expr1073746836 nullptr ;
1046: }
1047:
|
1051:
1052: void type ( const :: Type * t@var962 ) ;
1053:
|
1056:
1057: const :: Type * type ( ) const {
1058: return mTokType@var1003 ==@expr1073746837 eType ?@expr1073746838 mImpl@var1005 .@expr1073746839 mType@var1048 :@expr1073746840 nullptr ;
1059: }
1060:
1061: static const :: Type * typeOf ( const Token * tok@var963 , const Token * * typeTok@var964 = nullptr ) ;
1062:
1063: static std :: pair < const Token * , const Token * > typeDecl ( const Token * tok@var965 ) ;
1064:
1065: static std :: string typeStr ( const Token * tok@var966 ) ;
1066:
|
1069:
1070: const Enumerator * enumerator ( ) const {
1071: return mTokType@var1003 ==@expr1073746841 eEnumerator ?@expr1073746842 mImpl@var1005 .@expr1073746843 mEnumerator@var1049 :@expr1073746844 nullptr ;
1072: }
1073:
|
1077:
1078: void enumerator ( const Enumerator * e@var967 ) {
1079: mImpl@var1005 .@expr1073746845 mEnumerator@var1049 =@expr1073746846 e@var967 ;
1080: if (@expr1073746847 e@var967 ) {
1081: tokType (@expr1073746848 eEnumerator ) ; }
1082: else { if (@expr1073746849 mTokType@var1003 ==@expr1073746850 eEnumerator ) {
1083: tokType (@expr1073746851 eName ) ; } }
1084: }
1085:
|
1088:
1089: static void createMutualLinks ( Token * begin@var968 , Token * end@var969 ) ;
1090:
|
1096:
1097: std :: string strValue ( ) const ;
1098:
|
1105:
1106: static void move ( Token * srcStart@var970 , Token * srcEnd@var971 , Token * newLocation@var972 ) ;
1107:
1108:
1109: int progressValue ( ) const {
1110: return mImpl@var1005 .@expr1073746852 mProgressValue@var1050 ;
1111: }
1112:
1113:
1114: static void assignProgressValues ( Token * tok@var973 ) ;
1115:
|
1120:
1121: Token * nextArgument ( ) const ;
1122:
|
1127:
1128: Token * nextArgumentBeforeCreateLinks2 ( ) const ;
1129:
|
1134:
1135: Token * nextTemplateArgument ( ) const ;
1136:
|
1141:
1142: const Token * findClosingBracket ( ) const ;
1143: Token * findClosingBracket ( ) ;
1144:
1145: const Token * findOpeningBracket ( ) const ;
1146: Token * findOpeningBracket ( ) ;
1147:
|
1150:
1151: const std :: string & originalName ( ) const {
1152: return mImpl@var1005 .@expr5029 mOriginalName@var1051 ?@expr1073746854 *@expr1073746855 mImpl@var1005 .@expr5029 mOriginalName@var1051 :@expr1073746857 emptyString@var1 ;
1153: }
1154:
1155: const std :: list < ValueFlow :: Value > & values ( ) const {
1156: return mImpl@var1005 .@expr5034 mValues@var1024 ?@expr1073746859 *@expr1073746860 mImpl@var1005 .@expr5034 mValues@var1024 :@expr1073746862 TokenImpl ::@expr1073746863 mEmptyValueList@var771 ;
1157: }
1158:
|
1161:
1162: template < typename T >
1163: void originalName ( T && name@var974 ) {
1164: if (@expr1073746864 !@expr1073746865 mImpl@var1005 .@expr5042 mOriginalName@var1051 ) {
1165: mImpl@var1005 .@expr5042 mOriginalName@var1051 =@expr1073746868 new std ::@expr1073746869 string (@expr1073746870 name@var974 ) ; }
1166: else {
1167: *@expr1073746871 mImpl@var1005 .@expr5042 mOriginalName@var1051 =@expr1073746873 name@var974 ; }
1168: }
1169:
1170: bool hasKnownIntValue ( ) const ;
1171: bool hasKnownValue ( ) const ;
1172: bool hasKnownValue ( ValueFlow :: Value :: ValueType t@var975 ) const ;
1173: bool hasKnownSymbolicValue ( const Token * tok@var976 ) const ;
1174:
1175: const ValueFlow :: Value * getKnownValue ( ValueFlow :: Value :: ValueType t@var977 ) const ;
1176: long long getKnownIntValue ( ) const {
1177: return mImpl@var1005 .@expr1073746875 mValues@var1024 .@expr1073746876 front (@expr1073746877 ) .@expr1073746878 intvalue@expr1073746874 ;
1178: }
1179:
1180: const ValueFlow :: Value * getValue ( const long long val@var978 ) const ;
1181:
1182: const ValueFlow :: Value * getMaxValue ( bool condition@var979 , long long path@var980 = 0 ) const ;
1183:
1184: const ValueFlow :: Value * getMovedValue ( ) const ;
1185:
1186: const ValueFlow :: Value * getValueLE ( const long long val@var981 , const Settings * settings@var982 ) const ;
1187: const ValueFlow :: Value * getValueGE ( const long long val@var983 , const Settings * settings@var984 ) const ;
1188:
1189: const ValueFlow :: Value * getInvalidValue ( const Token * ftok@var985 , int argnr@var986 , const Settings * settings@var987 ) const ;
1190:
1191: const ValueFlow :: Value * getContainerSizeValue ( const long long val@var988 ) const ;
1192:
1193: const Token * getValueTokenMaxStrLength ( ) const ;
1194: const Token * getValueTokenMinStrSize ( const Settings * settings@var989 ) const ;
1195:
1196:
1197: bool addValue ( const ValueFlow :: Value & value@var990 ) ;
1198:
1199: void removeValues ( std :: function < bool ( const ValueFlow :: Value & ) > pred@var991 ) {
1200: if (@expr1073746879 mImpl@var1005 .@expr5056 mValues@var1024 ) {
1201: mImpl@var1005 .@expr5056 mValues@var1024 .@expr1073746882 remove_if (@expr1073746883 pred@var991 ) ; }
1202: }
1203:
1204: int index ( ) const {
1205: return mImpl@var1005 .@expr1073746884 mIndex@var1052 ;
1206: }
1207:
1208: void assignIndexes ( ) ;
1209:
1210: private:
1211:
1212: void next ( Token * nextToken@var992 ) {
1213: mNext@var1000 =@expr1073746885 nextToken@var992 ;
1214: }
1215: void previous ( Token * previousToken@var993 ) {
1216: mPrevious@var1001 =@expr1073746886 previousToken@var993 ;
1217: }
1218:
1219:
1220: void takeData ( Token * fromToken@var994 ) ;
1221:
|
1226:
1227: static bool firstWordEquals ( const char * str@var995 , const char * word@var996 ) ;
1228:
|
1233:
1234: static const char * chrInFirstWord ( const char * str@var997 , char c@var998 ) ;
1235:
1236: std :: string mStr@var999 ;
1237:
1238: Token * mNext@var1000 ;
1239: Token * mPrevious@var1001 ;
1240: Token * mLink@var1002 ;
1241:
1242: enum Anonymous1 : uint64_t {
1243: fIsUnsigned = ( 1 << 0 ) ,
1244: fIsSigned = ( 1 << 1 ) ,
1245: fIsPointerCompare = ( 1 << 2 ) ,
1246: fIsLong = ( 1 << 3 ) ,
1247: fIsStandardType = ( 1 << 4 ) ,
1248: fIsExpandedMacro = ( 1 << 5 ) ,
1249: fIsCast = ( 1 << 6 ) ,
1250: fIsAttributeConstructor = ( 1 << 7 ) ,
1251: fIsAttributeDestructor = ( 1 << 8 ) ,
1252: fIsAttributeUnused = ( 1 << 9 ) ,
1253: fIsAttributePure = ( 1 << 10 ) ,
1254: fIsAttributeConst = ( 1 << 11 ) ,
1255: fIsAttributeNoreturn = ( 1 << 12 ) ,
1256: fIsAttributeNothrow = ( 1 << 13 ) ,
1257: fIsAttributeUsed = ( 1 << 14 ) ,
1258: fIsAttributePacked = ( 1 << 15 ) ,
1259: fIsAttributeMaybeUnused = ( 1 << 16 ) ,
1260: fIsControlFlowKeyword = ( 1 << 17 ) ,
1261: fIsOperatorKeyword = ( 1 << 18 ) ,
1262: fIsComplex = ( 1 << 19 ) ,
1263: fIsEnumType = ( 1 << 20 ) ,
1264: fIsName = ( 1 << 21 ) ,
1265: fIsLiteral = ( 1 << 22 ) ,
1266: fIsTemplateArg = ( 1 << 23 ) ,
1267: fIsAttributeNodiscard = ( 1 << 24 ) ,
1268: fAtAddress = ( 1 << 25 ) ,
1269: fIncompleteVar = ( 1 << 26 ) ,
1270: fConstexpr = ( 1 << 27 ) ,
1271: fExternC = ( 1 << 28 ) ,
1272: fIsSplitVarDeclComma = ( 1 << 29 ) ,
1273: fIsSplitVarDeclEq = ( 1 << 30 ) ,
1274: fIsImplicitInt = ( 1U << 31 ) ,
1275: fIsInline = ( 1ULL << 32 ) ,
1276: fIsTemplate = ( 1ULL << 33 ) ,
1277: fIsSimplifedScope = ( 1ULL << 34 ) ,
1278: fIsRemovedVoidParameter = ( 1ULL << 35 ) ,
1279: fIsIncompleteConstant = ( 1ULL << 36 ) ,
1280: } ;
1281:
1282: Token :: Type mTokType@var1003 ;
1283:
1284: uint64_t mFlags@var1004 ;
1285:
1286: TokenImpl * mImpl@var1005 ;
1287:
|
1292:
1293: bool getFlag ( uint64_t flag_@var1006 ) const {
1294: return (@expr5063 (@expr5063 mFlags@var1004 &@expr1073746889 flag_@var1006 ) !=@expr1073746890 0 ) ;
1295: }
1296:
|
1301:
1302: void setFlag ( uint64_t flag_@var1007 , bool state_@var1008 ) {
1303: mFlags@var1004 =@expr1073746891 state_@var1008 ?@expr1073746892 mFlags@var1004 |@expr1073746893 flag_@var1007 :@expr1073746894 mFlags@var1004 &@expr1073746895 ~@expr1073746896 flag_@var1007 ;
1304: }
1305:
1306:
1307:
1308: void update_property_info ( ) ;
1309:
1310:
1311: void update_property_isStandardType ( ) ;
1312:
1313:
1314: void update_property_char_string_literal ( ) ;
1315:
1316:
1317: void astStringVerboseRecursive ( std :: string & ret@var1009 , const int indent1@var1010 = 0 , const int indent2@var1011 = 0 ) const ;
1318:
1319: public:
1320: void astOperand1 ( Token * tok@var1012 ) ;
1321: void astOperand2 ( Token * tok@var1013 ) ;
1322: void astParent ( Token * tok@var1014 ) ;
1323:
1324: Token * astOperand1 ( ) {
1325: return mImpl@var1005 .@expr1073746897 mAstOperand1@var1015 ;
1326: }
1327: const Token * astOperand1 ( ) const {
1328: return mImpl@var1005 .@expr1073746898 mAstOperand1@var1015 ;
1329: }
1330: Token * astOperand2 ( ) {
1331: return mImpl@var1005 .@expr1073746899 mAstOperand2@var1016 ;
1332: }
1333: const Token * astOperand2 ( ) const {
1334: return mImpl@var1005 .@expr1073746900 mAstOperand2@var1016 ;
1335: }
1336: Token * astParent ( ) {
1337: return mImpl@var1005 .@expr1073746901 mAstParent@var1017 ;
1338: }
1339: const Token * astParent ( ) const {
1340: return mImpl@var1005 .@expr1073746902 mAstParent@var1017 ;
1341: }
1342: Token * astSibling ( ) {
1343: if (@expr1073746903 !@expr1073746904 astParent (@expr5081 ) ) {
1344: return nullptr ; }
1345: if (@expr1073746906 this@expr5083 ==@expr1073746908 astParent (@expr5081 ) .@expr5086 astOperand1 (@expr5087 ) ) {
1346: return astParent (@expr5081 ) .@expr5089 astOperand2 (@expr5090 ) ; }
1347: else { if (@expr1073746915 this@expr5083 ==@expr1073746916 astParent (@expr5081 ) .@expr5089 astOperand2 (@expr5090 ) ) {
1348: return astParent (@expr5081 ) .@expr5086 astOperand1 (@expr5087 ) ; } }
1349: return nullptr ;
1350:
1351: }
1352: const Token * astSibling ( ) const {
1353: if (@expr1073746923 !@expr1073746924 astParent (@expr5101 ) ) {
1354: return nullptr ; }
1355: if (@expr1073746926 this@expr5103 ==@expr1073746928 astParent (@expr5101 ) .@expr5106 astOperand1 (@expr5107 ) ) {
1356: return astParent (@expr5101 ) .@expr5109 astOperand2 (@expr5110 ) ; }
1357: else { if (@expr1073746935 this@expr5103 ==@expr1073746936 astParent (@expr5101 ) .@expr5109 astOperand2 (@expr5110 ) ) {
1358: return astParent (@expr5101 ) .@expr5106 astOperand1 (@expr5107 ) ; } }
1359: return nullptr ;
1360:
1361: }
1362: Token * astTop ( ) {
1363: Token * ret@var1018 ; ret@var1018 =@expr1073746943 this@expr1073746944 ;
1364: while (@expr1073746945 ret@var1018 .@expr5122 mImpl@var1019 .@expr5123 mAstParent@var1020 ) {
1365: ret@var1018 =@expr1073746948 ret@var1018 .@expr5122 mImpl@var1019 .@expr5123 mAstParent@var1020 ; }
1366: return ret@var1018 ;
1367: }
1368:
1369: const Token * astTop ( ) const {
1370: const Token * ret@var1021 ; ret@var1021 =@expr1073746951 this@expr1073746952 ;
1371: while (@expr1073746953 ret@var1021 .@expr5130 mImpl@var1022 .@expr5131 mAstParent@var1023 ) {
1372: ret@var1021 =@expr1073746956 ret@var1021 .@expr5130 mImpl@var1022 .@expr5131 mAstParent@var1023 ; }
1373: return ret@var1021 ;
1374: }
1375:
1376: std :: pair < const Token * , const Token * > findExpressionStartEndTokens ( ) const ;
1377:
|
1384:
1385: bool isCalculation ( ) const ;
1386:
1387: void clearAst ( ) {
1388: mImpl@var1005 .@expr1073746959 mAstOperand1@var1015 =@expr1073746960 mImpl@var1005 .@expr1073746961 mAstOperand2@var1016 =@expr1073746962 mImpl@var1005 .@expr1073746963 mAstParent@var1017 =@expr1073746964 nullptr ;
1389: }
1390:
1391: void clearValueFlow ( ) {
1392: delete mImpl@var1005 .@expr5141 mValues@var1024 ;
1393: mImpl@var1005 .@expr5141 mValues@var1024 =@expr1073746967 nullptr ;
1394: }
1395:
1396: std :: string astString ( const char * sep@var1025 = "" ) const {
1397: std ::@expr1073746968 string ret@var1026 ;
1398: if (@expr1073746969 mImpl@var1005 .@expr5146 mAstOperand1@var1015 ) {
1399: ret@var1026 =@expr1073746971 mImpl@var1005 .@expr5146 mAstOperand1@var1015 .@expr1073746973 astString (@expr1073746974 sep@var1025 ) ; }
1400: if (@expr1073746975 mImpl@var1005 .@expr5152 mAstOperand2@var1016 ) {
1401: ret@var1026 +=@expr1073746977 mImpl@var1005 .@expr5152 mAstOperand2@var1016 .@expr1073746979 astString (@expr1073746980 sep@var1025 ) ; }
1402: return ret@var1026 +@expr1073746981 sep@var1025 +@expr1073746982 mStr@var999 ;
1403: }
1404:
1405: std :: string astStringVerbose ( ) const ;
1406:
1407: std :: string astStringZ3 ( ) const ;
1408:
1409: std :: string expressionString ( ) const ;
1410:
1411: void printAst ( bool verbose@var1027 , bool xml@var1028 , const std :: vector < std :: string > & fileNames@var1029 , std :: ostream & out@var1030 ) const ;
1412:
1413: void printValueFlow ( bool xml@var1031 , std :: ostream & out@var1032 ) const ;
1414:
1415: void scopeInfo ( std :: shared_ptr < ScopeInfo2 > newScopeInfo@var1033 ) ;
1416: std :: shared_ptr < ScopeInfo2 > scopeInfo ( ) const ;
1417:
1418: void setCpp11init ( bool cpp11init@var1034 ) const {
1419: mImpl@var1005 .@expr1073746983 mCpp11init@var1035 =@expr1073746984 cpp11init@var1034 ?@expr1073746985 TokenImpl ::@expr5162 Cpp11init ::@expr1073746987 CPP11INIT :@expr1073746988 TokenImpl ::@expr5162 Cpp11init ::@expr1073746990 NOINIT ;
1420: }
1421: TokenImpl :: Cpp11init isCpp11init ( ) const {
1422: return mImpl@var1005 .@expr1073746991 mCpp11init@var1035 ;
1423: }
1424: } ;
1425:
1426: Token * findTypeEnd ( Token * tok@var1053 ) ;
1427: const Token * findTypeEnd ( const Token * tok@var1054 ) ;
1428: Token * findLambdaEndScope ( Token * tok@var1055 ) ;
1429: const Token * findLambdaEndScope ( const Token * tok@var1056 ) ;

##file cppcheck-2.8/lib/symboldatabase.h

1:
|
39:
40: namespace cppcheck {
41: class Platform ;
42: }
43:
44: class ErrorLogger ;
45: class Function ;
46: class Scope ;
47: class Settings ;
48: class SymbolDatabase ;
49: class Tokenizer ;
50: class ValueType ;
51:
|
54:
55: enum class AccessControl { Public , Protected , Private , Global , Namespace , Argument , Local , Throw } ;
56:
|
59:
60: struct Dimension {
61: Dimension ( ) : tok@var1057 ( nullptr ) , num@var1058 ( 0 ) , known@var1059 ( true ) { }
62:
63: const Token * tok@var1057 ;
64: long long num@var1058 ;
65: bool known@var1059 ;
66: } ;
67:
68:
69: class Type {
70: public:
71: const Token * classDef@var1060 ;
72: const Scope * classScope@var1061 ;
73: const Scope * enclosingScope@var1062 ;
74: enum class NeedInitialization {
75: Unknown , True , False
76: } ; enum NeedInitialization needInitialization@var1063 ;
77:
78: class BaseInfo {
79: public:
80: BaseInfo ( ) :
81: type@var1065 ( nullptr ) , nameTok@var1066 ( nullptr ) , access@var1067 ( AccessControl :: Public ) , isVirtual@var1068 ( false ) { }
82:
83: std :: string name@var1064 ;
84: const Type * type@var1065 ;
85: const Token * nameTok@var1066 ;
86: AccessControl access@var1067 ;
87: bool isVirtual@var1068 ;
88:
89: bool operator< ( const BaseInfo & rhs@var1069 ) const {
90: return this@expr1073746992 .@expr1073746993 type@var1065 <@expr1073746994 rhs@var1069 .@expr1073746995 type@var1070 ;
91: }
92: } ;
93:
94: struct FriendInfo {
95: FriendInfo ( ) :
96: nameStart@var1071 ( nullptr ) , nameEnd@var1072 ( nullptr ) , type@var1073 ( nullptr ) { }
97:
98: const Token * nameStart@var1071 ;
99: const Token * nameEnd@var1072 ;
100: const Type * type@var1073 ;
101: } ;
102:
103: std :: vector < BaseInfo > derivedFrom@var1074 ;
104: std :: vector < FriendInfo > friendList@var1075 ;
105:
106: const Token * typeStart@var1076 ;
107: const Token * typeEnd@var1077 ;
108: long long sizeOf@var1078 ;
109:
110: Type ( const Token * classDef_@var1079 = nullptr , const Scope * classScope_@var1080 = nullptr , const Scope * enclosingScope_@var1081 = nullptr ) :
111: classDef@var1060 ( classDef_@var1079 ) ,
112: classScope@var1061 ( classScope_@var1080 ) ,
113: enclosingScope@var1062 ( enclosingScope_@var1081 ) ,
114: needInitialization@var1063 ( NeedInitialization :: Unknown ) ,
115: typeStart@var1076 ( nullptr ) ,
116: typeEnd@var1077 ( nullptr ) ,
117: sizeOf@var1078 ( 0 ) {
118: if (@expr1073746996 classDef_@var1079 &&@expr1073746997 classDef_@var1079 .@expr5174 str (@expr5175 ) ==@expr1073747000 "enum" ) {
119: needInitialization@var1063 =@expr1073747001 NeedInitialization ::@expr1073747002 True ; }
120: else { if (@expr1073747003 classDef_@var1079 &&@expr1073747004 classDef_@var1079 .@expr5174 str (@expr5175 ) ==@expr1073747007 "using" ) {
121: typeStart@var1076 =@expr1073747008 classDef@var1060 .@expr1073747009 tokAt (@expr1073747010 3 ) ;
122: typeEnd@var1077 =@expr1073747011 typeStart@var1076 ;
123: while (@expr1073747012 typeEnd@var1077 .@expr5189 next (@expr5190 ) &&@expr1073747015 typeEnd@var1077 .@expr5189 next (@expr5190 ) .@expr1073747018 str (@expr1073747019 ) !=@expr1073747020 ";" ) {
124: typeEnd@var1077 =@expr1073747021 typeEnd@var1077 .@expr5189 next (@expr5190 ) ; }
125: } }
126: }
127:
128: const std :: string & name ( ) const ;
129:
130: const std :: string & type ( ) const {
131: return classDef@var1060 ?@expr1073747024 classDef@var1060 .@expr1073747025 str (@expr1073747026 ) :@expr1073747027 emptyString@var1 ;
132: }
133:
134: bool isClassType ( ) const ;
135: bool isEnumType ( ) const ;
136: bool isStructType ( ) const ;
137: bool isUnionType ( ) const ;
138:
139: bool isTypeAlias ( ) const {
140: return classDef@var1060 &&@expr1073747028 classDef@var1060 .@expr1073747029 str (@expr1073747030 ) ==@expr1073747031 "using" ;
141: }
142:
143: const Token * initBaseInfo ( const Token * tok@var1082 , const Token * tok1@var1083 ) ;
144:
145: const Function * getFunction ( const std :: string & funcName@var1084 ) const ;
146:
|
151:
152: bool hasCircularDependencies ( std :: set < BaseInfo > * ancestors@var1085 = nullptr ) const ;
153:
|
158:
159: bool findDependency ( const Type * ancestor@var1086 ) const ;
160:
161: bool isDerivedFrom ( const std :: string & ancestor@var1087 ) const ;
162: } ;
163:
164: class Enumerator {
165: public:
166: explicit Enumerator ( const Scope * scope_@var1088 ) : scope@var1089 ( scope_@var1088 ) , name@var1090 ( nullptr ) , value@var1091 ( 0 ) , start@var1092 ( nullptr ) , end@var1093 ( nullptr ) , value_known@var1094 ( false ) { }
167: const Scope * scope@var1089 ;
168: const Token * name@var1090 ;
169: long long value@var1091 ;
170: const Token * start@var1092 ;
171: const Token * end@var1093 ;
172: bool value_known@var1094 ;
173: } ;
174:
175:
176: class Variable {
177:
178: enum Anonymous2 {
179: fIsMutable = ( 1 << 0 ) ,
180: fIsStatic = ( 1 << 1 ) ,
181: fIsConst = ( 1 << 2 ) ,
182: fIsExtern = ( 1 << 3 ) ,
183: fIsClass = ( 1 << 4 ) ,
184: fIsArray = ( 1 << 5 ) ,
185: fIsPointer = ( 1 << 6 ) ,
186: fIsReference = ( 1 << 7 ) ,
187: fIsRValueRef = ( 1 << 8 ) ,
188: fHasDefault = ( 1 << 9 ) ,
189: fIsStlType = ( 1 << 10 ) ,
190: fIsStlString = ( 1 << 11 ) ,
191: fIsFloatType = ( 1 << 12 ) ,
192: fIsVolatile = ( 1 << 13 ) ,
193: fIsSmartPointer = ( 1 << 14 ) ,
194: fIsMaybeUnused = ( 1 << 15 ) ,
195: fIsInit = ( 1 << 16 ) ,
196: } ;
197:
|
202:
203: bool getFlag ( unsigned int flag_@var1095 ) const {
204: return (@expr5208 (@expr5208 mFlags@var1131 &@expr1073747034 flag_@var1095 ) !=@expr1073747035 0 ) ;
205: }
206:
|
211:
212: void setFlag ( unsigned int flag_@var1096 , bool state_@var1097 ) {
213: mFlags@var1131 =@expr1073747036 state_@var1097 ?@expr1073747037 mFlags@var1131 |@expr1073747038 flag_@var1096 :@expr1073747039 mFlags@var1131 &@expr1073747040 ~@expr1073747041 flag_@var1096 ;
214: }
215:
|
221:
222: bool arrayDimensions ( const Settings * settings@var1098 , bool * isContainer@var1099 ) ;
223:
224: public:
225: Variable ( const Token * name_@var1100 , const Token * start_@var1101 , const Token * end_@var1102 ,
226: int index_@var1103 , AccessControl access_@var1104 , const Type * type_@var1105 ,
227: const Scope * scope_@var1106 , const Settings * settings@var1107 )
228: : mNameToken@var1126 ( name_@var1100 ) ,
229: mTypeStartToken@var1127 ( start_@var1101 ) ,
230: mTypeEndToken@var1128 ( end_@var1102 ) ,
231: mIndex@var1129 ( index_@var1103 ) ,
232: mAccess@var1130 ( access_@var1104 ) ,
233: mFlags@var1131 ( 0 ) ,
234: mType@var1132 ( type_@var1105 ) ,
235: mScope@var1133 ( scope_@var1106 ) ,
236: mValueType@var1134 ( nullptr ) {
237: evaluate (@expr1073747042 settings@var1107 ) ;
238: }
239:
240: Variable ( const Token * name_@var1108 , const std :: string & clangType@var1109 , const Token * typeStart@var1110 ,
241: const Token * typeEnd@var1111 , int index_@var1112 , AccessControl access_@var1113 ,
242: const Type * type_@var1114 , const Scope * scope_@var1115 ) ;
243:
244: Variable ( const Variable & var@var1116 , const Scope * scope@var1117 ) ;
245:
246: Variable ( const Variable & var@var1118 ) ;
247:
248: ~ Variable ( ) ;
249:
250: Variable & operator= ( const Variable & var@var1119 ) ;
251:
|
255:
256: const Token * nameToken ( ) const {
257: return mNameToken@var1126 ;
258: }
259:
|
267:
268: const Token * typeStartToken ( ) const {
269: return mTypeStartToken@var1127 ;
270: }
271:
|
279:
280: const Token * typeEndToken ( ) const {
281: return mTypeEndToken@var1128 ;
282: }
283:
|
290:
291: const Token * declEndToken ( ) const ;
292:
|
296:
297: const std :: string & name ( ) const {
298:
299: if (@expr1073747043 mNameToken@var1126 ) {
300: return mNameToken@var1126 .@expr1073747044 str (@expr1073747045 ) ; }
301:
302: return emptyString@var1 ;
303: }
304:
|
308:
309: int declarationId ( ) const {
310:
311: if (@expr1073747046 mNameToken@var1126 ) {
312: return mNameToken@var1126 .@expr1073747047 varId (@expr1073747048 ) ; }
313:
314: return 0 ;
315: }
316:
|
320:
321: int index ( ) const {
322: return mIndex@var1129 ;
323: }
324:
|
328:
329: bool isPublic ( ) const {
330: return mAccess@var1130 ==@expr1073747049 AccessControl ::@expr1073747050 Public ;
331: }
332:
|
336:
337: bool isProtected ( ) const {
338: return mAccess@var1130 ==@expr1073747051 AccessControl ::@expr1073747052 Protected ;
339: }
340:
|
344:
345: bool isPrivate ( ) const {
346: return mAccess@var1130 ==@expr1073747053 AccessControl ::@expr1073747054 Private ;
347: }
348:
|
352:
353: bool isGlobal ( ) const {
354: return mAccess@var1130 ==@expr1073747055 AccessControl ::@expr1073747056 Global ;
355: }
356:
|
360:
361: bool isNamespace ( ) const {
362: return mAccess@var1130 ==@expr1073747057 AccessControl ::@expr1073747058 Namespace ;
363: }
364:
|
368:
369: bool isArgument ( ) const {
370: return mAccess@var1130 ==@expr1073747059 AccessControl ::@expr1073747060 Argument ;
371: }
372:
|
376:
377: bool isLocal ( ) const {
378: return (@expr1073747062 mAccess@var1130 ==@expr1073747063 AccessControl ::@expr1073747064 Local@expr1073747061 ) &&@expr1073747065 !@expr1073747066 isExtern (@expr1073747067 ) ;
379: }
380:
|
384:
385: bool isMutable ( ) const {
386: return getFlag (@expr1073747068 fIsMutable ) ;
387: }
388:
|
392:
393: bool isVolatile ( ) const {
394: return getFlag (@expr1073747069 fIsVolatile ) ;
395: }
396:
|
400:
401: bool isStatic ( ) const {
402: return getFlag (@expr1073747070 fIsStatic ) ;
403: }
404:
|
408:
409: bool isExtern ( ) const {
410: return getFlag (@expr1073747071 fIsExtern ) ;
411: }
412:
|
416:
417: bool isConst ( ) const {
418: return getFlag (@expr1073747072 fIsConst ) ;
419: }
420:
|
424:
425: bool isThrow ( ) const {
426: return mAccess@var1130 ==@expr1073747073 AccessControl ::@expr1073747074 Throw ;
427: }
428:
|
432:
433: bool isClass ( ) const {
434: return getFlag (@expr1073747075 fIsClass ) ;
435: }
436:
|
440:
441: bool isArray ( ) const {
442: return getFlag (@expr1073747076 fIsArray ) &&@expr1073747077 !@expr1073747078 getFlag (@expr1073747079 fIsPointer ) ;
443: }
444:
|
448:
449: bool isPointer ( ) const {
450: return getFlag (@expr1073747080 fIsPointer ) ;
451: }
452:
|
456:
457: bool isPointerToArray ( ) const {
458: return isPointer (@expr1073747081 ) &&@expr1073747082 getFlag (@expr1073747083 fIsArray ) ;
459: }
460:
|
464:
465: bool isPointerArray ( ) const ;
466:
|
470:
471: bool isArrayOrPointer ( ) const {
472: return getFlag (@expr1073747084 fIsArray ) ||@expr1073747085 getFlag (@expr1073747086 fIsPointer ) ;
473: }
474:
|
478:
479: bool isReference ( ) const {
480: return getFlag (@expr1073747087 fIsReference ) ;
481: }
482:
|
486:
487: bool isRValueReference ( ) const {
488: return getFlag (@expr1073747088 fIsRValueRef ) ;
489: }
490:
|
494:
495: bool isUnsigned ( ) const ;
496:
|
500:
501: bool hasDefault ( ) const {
502: return getFlag (@expr1073747089 fHasDefault ) ;
503: }
504:
|
508:
509: bool isInit ( ) const {
510: return getFlag (@expr1073747090 fIsInit ) ;
511: }
512:
|
516:
517: const Type * type ( ) const {
518: return mType@var1132 ;
519: }
520:
|
524:
525: const Scope * typeScope ( ) const {
526: return mType@var1132 ?@expr1073747091 mType@var1132 .@expr1073747092 classScope@var1137 :@expr1073747093 nullptr ;
527: }
528:
|
532:
533: const Scope * scope ( ) const {
534: return mScope@var1133 ;
535: }
536:
|
540:
541: const std :: vector < Dimension > & dimensions ( ) const {
542: return mDimensions@var1135 ;
543: }
544:
|
548:
549: long long dimension ( int index_@var1120 ) const {
550: return mDimensions@var1135 [@expr1073747094 index_@var1120 ] .@expr1073747095 num@var3840 ;
551: }
552:
|
556:
557: bool dimensionKnown ( int index_@var1121 ) const {
558: return mDimensions@var1135 [@expr1073747096 index_@var1121 ] .@expr1073747097 known@var3841 ;
559: }
560:
|
568:
569: bool isStlType ( ) const {
570: return getFlag (@expr1073747098 fIsStlType ) ;
571: }
572:
|
580:
581: bool isStlStringType ( ) const {
582: return getFlag (@expr1073747099 fIsStlString ) ;
583: }
584:
585: bool isSmartPointer ( ) const {
586: return getFlag (@expr1073747100 fIsSmartPointer ) ;
587: }
588:
589: const Type * smartPointerType ( ) const ;
590:
|
600:
601: bool isStlType ( const std :: string & stlType@var1122 ) const {
602: return isStlType (@expr1073747101 ) &&@expr1073747102 stlType@var1122 ==@expr1073747103 mTypeStartToken@var1127 .@expr1073747104 strAt (@expr1073747105 2 ) ;
603: }
604:
|
614:
615: bool isStlType ( const std :: set < std :: string > & stlTypes@var1123 ) const {
616: return isStlType (@expr1073747106 ) &&@expr1073747107 stlTypes@var1123 .@expr1073747108 find (@expr1073747109 mTypeStartToken@var1127 .@expr1073747110 strAt (@expr1073747111 2 ) ) !=@expr1073747112 stlTypes@var1123 .@expr1073747113 end (@expr1073747114 ) ;
617: }
618:
|
622:
623: bool isFloatingType ( ) const {
624: return getFlag (@expr1073747115 fIsFloatType ) ;
625: }
626:
|
630:
631: bool isEnumType ( ) const {
632: return type (@expr5292 ) &&@expr1073747117 type (@expr5292 ) .@expr1073747119 isEnumType (@expr1073747120 ) ;
633: }
634:
635: bool isMaybeUnused ( ) const {
636: return getFlag (@expr1073747121 fIsMaybeUnused ) ;
637: }
638:
639: const ValueType * valueType ( ) const {
640: return mValueType@var1134 ;
641: }
642:
643: void setValueType ( const ValueType & valueType@var1124 ) ;
644:
645: AccessControl accessControl ( ) const {
646: return mAccess@var1130 ;
647: }
648:
649: std :: string getTypeName ( ) const ;
650:
651: private:
652:
653: friend class SymbolDatabase ;
654:
|
658:
659: void type ( const Type * t@var1125 ) {
660: mType@var1132 =@expr1073747122 t@var1125 ;
661: }
662:
663:
664: const Token * mNameToken@var1126 ;
665:
666:
667: const Token * mTypeStartToken@var1127 ;
668:
669:
670: const Token * mTypeEndToken@var1128 ;
671:
672:
673: int mIndex@var1129 ;
674:
675:
676: AccessControl mAccess@var1130 ;
677:
678:
679: unsigned int mFlags@var1131 ;
680:
681:
682: const Type * mType@var1132 ;
683:
684:
685: const Scope * mScope@var1133 ;
686:
687: ValueType * mValueType@var1134 ;
688:
689:
690: std :: vector < Dimension > mDimensions@var1135 ;
691:
692:
693: void evaluate ( const Settings * settings@var1136 ) ;
694: } ;
695:
696: class Function {
697:
698: friend class SymbolDatabase ;
699:
700:
701: enum Anonymous3 {
702: fHasBody = ( 1 << 0 ) ,
703: fIsInline = ( 1 << 1 ) ,
704: fIsConst = ( 1 << 2 ) ,
705: fHasVirtualSpecifier = ( 1 << 3 ) ,
706: fIsPure = ( 1 << 4 ) ,
707: fIsStatic = ( 1 << 5 ) ,
708: fIsStaticLocal = ( 1 << 6 ) ,
709: fIsExtern = ( 1 << 7 ) ,
710: fIsFriend = ( 1 << 8 ) ,
711: fIsExplicit = ( 1 << 9 ) ,
712: fIsDefault = ( 1 << 10 ) ,
713: fIsDelete = ( 1 << 11 ) ,
714: fHasOverrideSpecifier = ( 1 << 12 ) ,
715: fHasFinalSpecifier = ( 1 << 13 ) ,
716: fIsNoExcept = ( 1 << 14 ) ,
717: fIsThrow = ( 1 << 15 ) ,
718: fIsOperator = ( 1 << 16 ) ,
719: fHasLvalRefQual = ( 1 << 17 ) ,
720: fHasRvalRefQual = ( 1 << 18 ) ,
721: fIsVariadic = ( 1 << 19 ) ,
722: fIsVolatile = ( 1 << 20 ) ,
723: fHasTrailingReturnType = ( 1 << 21 ) ,
724: fIsEscapeFunction = ( 1 << 22 ) ,
725: fIsInlineKeyword = ( 1 << 23 ) ,
726: fIsConstexpr = ( 1 << 24 ) ,
727: } ;
728:
|
733:
734: bool getFlag ( unsigned int flag@var1138 ) const {
735: return (@expr5299 (@expr5299 mFlags@var1187 &@expr1073747125 flag@var1138 ) !=@expr1073747126 0 ) ;
736: }
737:
|
742:
743: void setFlag ( unsigned int flag@var1139 , bool state@var1140 ) {
744: mFlags@var1187 =@expr1073747127 state@var1140 ?@expr1073747128 mFlags@var1187 |@expr1073747129 flag@var1139 :@expr1073747130 mFlags@var1187 &@expr1073747131 ~@expr1073747132 flag@var1139 ;
745: }
746:
747: public:
748: enum Type { eConstructor , eCopyConstructor , eMoveConstructor , eOperatorEqual , eDestructor , eFunction , eLambda } ;
749:
750: Function ( const Tokenizer * mTokenizer@var1141 , const Token * tok@var1142 , const Scope * scope@var1143 , const Token * tokDef@var1144 , const Token * tokArgDef@var1145 ) ;
751: Function ( const Token * tokenDef@var1146 , const std :: string & clangType@var1147 ) ;
752:
753: const std :: string & name ( ) const {
754: return tokenDef@var1157 .@expr1073747133 str (@expr1073747134 ) ;
755: }
756:
757: std :: string fullName ( ) const ;
758:
759: int argCount ( ) const {
760: return argumentList@var1165 .@expr1073747135 size (@expr1073747136 ) ;
761: }
762: int minArgCount ( ) const {
763: return argumentList@var1165 .@expr1073747137 size (@expr1073747138 ) -@expr1073747139 initArgCount@var1166 ;
764: }
765: const Variable * getArgumentVar ( int num@var1148 ) const ;
766: int initializedArgCount ( ) const {
767: return initArgCount@var1166 ;
768: }
769: void addArguments ( const SymbolDatabase * symbolDatabase@var1149 , const Scope * scope@var1150 ) ;
770:
771:
772: bool isImplicitlyVirtual ( bool defaultVal@var1151 = false ) const ;
773:
774: std :: vector < const Function * > getOverloadedFunctions ( ) const ;
775:
776:
777: const Function * getOverriddenFunction ( bool * foundAllBaseClasses@var1152 = nullptr ) const ;
778:
779: bool isLambda ( ) const {
780: return type@var1167 ==@expr1073747140 eLambda ;
781: }
782:
783: bool isConstructor ( ) const {
784: return type@var1167 ==@expr1073747141 eConstructor ||@expr1073747142
785: type@var1167 ==@expr1073747143 eCopyConstructor ||@expr1073747144
786: type@var1167 ==@expr1073747145 eMoveConstructor ;
787: }
788:
789: bool isDestructor ( ) const {
790: return type@var1167 ==@expr1073747146 eDestructor ;
791: }
792: bool isAttributeConstructor ( ) const {
793: return tokenDef@var1157 .@expr1073747147 isAttributeConstructor (@expr1073747148 ) ;
794: }
795: bool isAttributeDestructor ( ) const {
796: return tokenDef@var1157 .@expr1073747149 isAttributeDestructor (@expr1073747150 ) ;
797: }
798: bool isAttributePure ( ) const {
799: return tokenDef@var1157 .@expr1073747151 isAttributePure (@expr1073747152 ) ;
800: }
801: bool isAttributeConst ( ) const {
802: return tokenDef@var1157 .@expr1073747153 isAttributeConst (@expr1073747154 ) ;
803: }
804: bool isAttributeNoreturn ( ) const {
805: return tokenDef@var1157 .@expr1073747155 isAttributeNoreturn (@expr1073747156 ) ;
806: }
807: bool isAttributeNothrow ( ) const {
808: return tokenDef@var1157 .@expr1073747157 isAttributeNothrow (@expr1073747158 ) ;
809: }
810: bool isAttributeNodiscard ( ) const {
811: return tokenDef@var1157 .@expr1073747159 isAttributeNodiscard (@expr1073747160 ) ;
812: }
813:
814: bool hasBody ( ) const {
815: return getFlag (@expr1073747161 fHasBody ) ;
816: }
817: bool isInline ( ) const {
818: return getFlag (@expr1073747162 fIsInline ) ;
819: }
820: bool isConst ( ) const {
821: return getFlag (@expr1073747163 fIsConst ) ;
822: }
823: bool hasVirtualSpecifier ( ) const {
824: return getFlag (@expr1073747164 fHasVirtualSpecifier ) ;
825: }
826: bool isPure ( ) const {
827: return getFlag (@expr1073747165 fIsPure ) ;
828: }
829: bool isStatic ( ) const {
830: return getFlag (@expr1073747166 fIsStatic ) ;
831: }
832: bool isStaticLocal ( ) const {
833: return getFlag (@expr1073747167 fIsStaticLocal ) ;
834: }
835: bool isExtern ( ) const {
836: return getFlag (@expr1073747168 fIsExtern ) ;
837: }
838: bool isFriend ( ) const {
839: return getFlag (@expr1073747169 fIsFriend ) ;
840: }
841: bool isExplicit ( ) const {
842: return getFlag (@expr1073747170 fIsExplicit ) ;
843: }
844: bool isDefault ( ) const {
845: return getFlag (@expr1073747171 fIsDefault ) ;
846: }
847: bool isDelete ( ) const {
848: return getFlag (@expr1073747172 fIsDelete ) ;
849: }
850: bool isNoExcept ( ) const {
851: return getFlag (@expr1073747173 fIsNoExcept ) ;
852: }
853: bool isThrow ( ) const {
854: return getFlag (@expr1073747174 fIsThrow ) ;
855: }
856: bool hasOverrideSpecifier ( ) const {
857: return getFlag (@expr1073747175 fHasOverrideSpecifier ) ;
858: }
859: bool hasFinalSpecifier ( ) const {
860: return getFlag (@expr1073747176 fHasFinalSpecifier ) ;
861: }
862: bool isOperator ( ) const {
863: return getFlag (@expr1073747177 fIsOperator ) ;
864: }
865: bool hasLvalRefQualifier ( ) const {
866: return getFlag (@expr1073747178 fHasLvalRefQual ) ;
867: }
868: bool hasRvalRefQualifier ( ) const {
869: return getFlag (@expr1073747179 fHasRvalRefQual ) ;
870: }
871: bool isVariadic ( ) const {
872: return getFlag (@expr1073747180 fIsVariadic ) ;
873: }
874: bool isVolatile ( ) const {
875: return getFlag (@expr1073747181 fIsVolatile ) ;
876: }
877: bool hasTrailingReturnType ( ) const {
878: return getFlag (@expr1073747182 fHasTrailingReturnType ) ;
879: }
880: void hasBody ( bool state@var1153 ) {
881: setFlag (@expr1073747183 fHasBody , state@var1153 ) ;
882: }
883: bool isInlineKeyword ( ) const {
884: return getFlag (@expr1073747184 fIsInlineKeyword ) ;
885: }
886:
887: bool isEscapeFunction ( ) const {
888: return getFlag (@expr1073747185 fIsEscapeFunction ) ;
889: }
890: void isEscapeFunction ( bool state@var1154 ) {
891: setFlag (@expr1073747186 fIsEscapeFunction , state@var1154 ) ;
892: }
893:
894: bool isConstexpr ( ) const {
895: return getFlag (@expr1073747187 fIsConstexpr ) ;
896: }
897: void isConstexpr ( bool state@var1155 ) {
898: setFlag (@expr1073747188 fIsConstexpr , state@var1155 ) ;
899: }
900: bool isSafe ( const Settings * settings@var1156 ) const ;
901:
902: const Token * tokenDef@var1157 ;
903: const Token * argDef@var1158 ;
904: const Token * token@var1159 ;
905: const Token * arg@var1160 ;
906: const Token * retDef@var1161 ;
907: const :: Type * retType@var1162 ;
908: const Scope * functionScope@var1163 ;
909: const Scope * nestedIn@var1164 ;
910: std :: list < Variable > argumentList@var1165 ;
911: int initArgCount@var1166 ;
912: Type type@var1167 ;
913: AccessControl access@var1168 ;
914: const Token * noexceptArg@var1169 ;
915: const Token * throwArg@var1170 ;
916: const Token * templateDef@var1171 ;
917: const Token * functionPointerUsage@var1172 ;
918:
919: bool argsMatch ( const Scope * scope@var1173 , const Token * first@var1174 , const Token * second@var1175 , const std :: string & path@var1176 , int path_length@var1177 ) const ;
920:
921: static bool returnsConst ( const Function * function@var1178 , bool unknown@var1179 = false ) ;
922:
923: static bool returnsReference ( const Function * function@var1180 , bool unknown@var1181 = false ) ;
924:
925: static bool returnsVoid ( const Function * function@var1182 , bool unknown@var1183 = false ) ;
926:
927: static std :: vector < const Token * > findReturns ( const Function * f@var1184 ) ;
928:
929: const Token * returnDefEnd ( ) const {
930: if (@expr1073747189 this@expr1073747190 .@expr1073747191 hasTrailingReturnType (@expr1073747192 ) ) {
931: return Token ::@expr1073747193 findmatch (@expr1073747194 retDef@var1161 , "{|;" ) ;
932: } else {
933: return tokenDef@var1157 ;
934: }
935: }
936:
|
940:
941: const Token * constructorMemberInitialization ( ) const ;
942:
943: private:
944:
945: const Function * getOverriddenFunctionRecursive ( const :: Type * baseType@var1185 , bool * foundAllBaseClasses@var1186 ) const ;
946:
947: unsigned int mFlags@var1187 ;
948:
949: void isInline ( bool state@var1188 ) {
950: setFlag (@expr1073747195 fIsInline , state@var1188 ) ;
951: }
952: void isConst ( bool state@var1189 ) {
953: setFlag (@expr1073747196 fIsConst , state@var1189 ) ;
954: }
955: void hasVirtualSpecifier ( bool state@var1190 ) {
956: setFlag (@expr1073747197 fHasVirtualSpecifier , state@var1190 ) ;
957: }
958: void isPure ( bool state@var1191 ) {
959: setFlag (@expr1073747198 fIsPure , state@var1191 ) ;
960: }
961: void isStatic ( bool state@var1192 ) {
962: setFlag (@expr1073747199 fIsStatic , state@var1192 ) ;
963: }
964: void isStaticLocal ( bool state@var1193 ) {
965: setFlag (@expr1073747200 fIsStaticLocal , state@var1193 ) ;
966: }
967: void isExtern ( bool state@var1194 ) {
968: setFlag (@expr1073747201 fIsExtern , state@var1194 ) ;
969: }
970: void isFriend ( bool state@var1195 ) {
971: setFlag (@expr1073747202 fIsFriend , state@var1195 ) ;
972: }
973: void isExplicit ( bool state@var1196 ) {
974: setFlag (@expr1073747203 fIsExplicit , state@var1196 ) ;
975: }
976: void isDefault ( bool state@var1197 ) {
977: setFlag (@expr1073747204 fIsDefault , state@var1197 ) ;
978: }
979: void isDelete ( bool state@var1198 ) {
980: setFlag (@expr1073747205 fIsDelete , state@var1198 ) ;
981: }
982: void isNoExcept ( bool state@var1199 ) {
983: setFlag (@expr1073747206 fIsNoExcept , state@var1199 ) ;
984: }
985: void isThrow ( bool state@var1200 ) {
986: setFlag (@expr1073747207 fIsThrow , state@var1200 ) ;
987: }
988: void isOperator ( bool state@var1201 ) {
989: setFlag (@expr1073747208 fIsOperator , state@var1201 ) ;
990: }
991: void hasLvalRefQualifier ( bool state@var1202 ) {
992: setFlag (@expr1073747209 fHasLvalRefQual , state@var1202 ) ;
993: }
994: void hasRvalRefQualifier ( bool state@var1203 ) {
995: setFlag (@expr1073747210 fHasRvalRefQual , state@var1203 ) ;
996: }
997: void isVariadic ( bool state@var1204 ) {
998: setFlag (@expr1073747211 fIsVariadic , state@var1204 ) ;
999: }
1000: void isVolatile ( bool state@var1205 ) {
1001: setFlag (@expr1073747212 fIsVolatile , state@var1205 ) ;
1002: }
1003: void hasTrailingReturnType ( bool state@var1206 ) {
1004: return setFlag (@expr1073747213 fHasTrailingReturnType , state@var1206 ) ;
1005: }
1006: void isInlineKeyword ( bool state@var1207 ) {
1007: setFlag (@expr1073747214 fIsInlineKeyword , state@var1207 ) ;
1008: }
1009: const Token * setFlags ( const Token * tok1@var1208 , const Scope * scope@var1209 ) ;
1010: } ;
1011:
1012: class Scope {
1013:
1014: friend class TestSymbolDatabase ;
1015:
1016: public:
1017: struct UsingInfo {
1018: const Token * start@var1210 ;
1019: const Scope * scope@var1211 ;
1020: } ;
1021:
1022: enum ScopeType { eGlobal , eClass , eStruct , eUnion , eNamespace , eFunction , eIf , eElse , eFor , eWhile , eDo , eSwitch , eUnconditional , eTry , eCatch , eLambda , eEnum } ;
1023:
1024: Scope ( const SymbolDatabase * check_@var1212 , const Token * classDef_@var1213 , const Scope * nestedIn_@var1214 ) ;
1025: Scope ( const SymbolDatabase * check_@var1215 , const Token * classDef_@var1216 , const Scope * nestedIn_@var1217 , ScopeType type_@var1218 , const Token * start_@var1219 ) ;
1026:
1027: const SymbolDatabase * check@var1220 ;
1028: std :: string className@var1221 ;
1029: const Token * classDef@var1222 ;
1030: const Token * bodyStart@var1223 ;
1031: const Token * bodyEnd@var1224 ;
1032: std :: list < Function > functionList@var1225 ;
1033: std :: multimap < std :: string , const Function * > functionMap@var1226 ;
1034: std :: list < Variable > varlist@var1227 ;
1035: const Scope * nestedIn@var1228 ;
1036: std :: list < Scope * > nestedList@var1229 ;
1037: int numConstructors@var1230 ;
1038: int numCopyOrMoveConstructors@var1231 ;
1039: std :: list < UsingInfo > usingList@var1232 ;
1040: ScopeType type@var1233 ;
1041: Type * definedType@var1234 ;
1042: std :: map < std :: string , Type * > definedTypesMap@var1235 ;
1043: std :: vector < const Token * > bodyStartList@var1236 ;
1044:
1045:
1046: const Scope * functionOf@var1237 ;
1047: Function * function@var1238 ;
1048:
1049:
1050: const Token * enumType@var1239 ;
1051: bool enumClass@var1240 ;
1052:
1053: std :: vector < Enumerator > enumeratorList@var1241 ;
1054:
1055: void setBodyStartEnd ( const Token * start@var1242 ) {
1056: bodyStart@var1223 =@expr1073747215 start@var1242 ;
1057: bodyEnd@var1224 =@expr1073747216 start@var1242 ?@expr1073747217 start@var1242 .@expr1073747218 link (@expr1073747219 ) :@expr1073747220 nullptr ;
1058: if (@expr1073747221 start@var1242 ) {
1059: bodyStartList@var1236 .@expr1073747222 push_back (@expr1073747223 start@var1242 ) ; }
1060: }
1061:
1062: bool isAnonymous ( ) const {
1063:
1064: return className@var1221 .@expr1073747224 size (@expr1073747225 ) >@expr1073747226 9 &&@expr1073747227 className@var1221 .@expr1073747228 compare (@expr1073747229 0 , 9 , "Anonymous" ) ==@expr1073747230 0 &&@expr1073747231 std ::@expr1073747232 isdigit (@expr1073747233 className@var1221 [@expr1073747234 9 ] ) ;
1065: }
1066:
1067: const Enumerator * findEnumerator ( const std :: string & name@var1243 ) const {
1068: for (@expr1073747235 const Enumerator &@expr1073747236 i@var1244 :@expr1073747237 enumeratorList@var1241 ) {
1069: if (@expr1073747238 i@var1244 .@expr1073747239 name@var1245 .@expr1073747240 str (@expr1073747241 ) ==@expr1073747242 name@var1243 ) {
1070: return &@expr1073747243 i@var1244 ; }
1071: }
1072: return nullptr ;
1073: }
1074:
1075: bool isNestedIn ( const Scope * outer@var1246 ) const {
1076: if (@expr1073747244 !@expr1073747245 outer@var1246 ) {
1077: return false ; }
1078: if (@expr1073747246 outer@var1246 ==@expr1073747247 this@expr1073747248 ) {
1079: return true ; }
1080: const Scope * parent@var1247 ; parent@var1247 =@expr1073747249 nestedIn@var1228 ;
1081: while (@expr1073747250 outer@var1246 !=@expr1073747251 parent@var1247 &&@expr1073747252 parent@var1247 ) {
1082: parent@var1247 =@expr1073747253 parent@var1247 .@expr1073747254 nestedIn@var1248 ; }
1083: if (@expr1073747255 parent@var1247 &&@expr1073747256 parent@var1247 ==@expr1073747257 outer@var1246 ) {
1084: return true ; }
1085: return false ;
1086: }
1087:
1088: static Function * nestedInFunction ( const Scope * scope@var1249 ) {
1089: while (@expr1073747258 scope@var1249 ) {
1090: if (@expr1073747259 scope@var1249 .@expr1073747260 type@var1250 ==@expr1073747261 Scope ::@expr1073747262 eFunction ) {
1091: break ; }
1092: scope@var1249 =@expr1073747263 scope@var1249 .@expr1073747264 nestedIn@var1251 ;
1093: }
1094: if (@expr1073747265 !@expr1073747266 scope@var1249 ) {
1095: return nullptr ; }
1096: return scope@var1249 .@expr1073747267 function@var1252 ;
1097: }
1098:
1099: bool isClassOrStruct ( ) const {
1100: return (@expr1073747268 type@var1233 ==@expr1073747269 eClass ||@expr1073747270 type@var1233 ==@expr1073747271 eStruct ) ;
1101: }
1102:
1103: bool isClassOrStructOrUnion ( ) const {
1104: return (@expr1073747272 type@var1233 ==@expr1073747273 eClass ||@expr1073747274 type@var1233 ==@expr1073747275 eStruct ||@expr1073747276 type@var1233 ==@expr1073747277 eUnion ) ;
1105: }
1106:
1107: bool isExecutable ( ) const {
1108: return type@var1233 !=@expr1073747278 eClass &&@expr1073747279 type@var1233 !=@expr1073747280 eStruct &&@expr1073747281 type@var1233 !=@expr1073747282 eUnion &&@expr1073747283 type@var1233 !=@expr1073747284 eGlobal &&@expr1073747285 type@var1233 !=@expr1073747286 eNamespace &&@expr1073747287 type@var1233 !=@expr1073747288 eEnum ;
1109: }
1110:
1111: bool isLoopScope ( ) const {
1112: return type@var1233 ==@expr1073747289 Scope ::@expr5466 ScopeType ::@expr1073747291 eFor ||@expr1073747292 type@var1233 ==@expr1073747293 Scope ::@expr5466 ScopeType ::@expr1073747295 eWhile ||@expr1073747296 type@var1233 ==@expr1073747297 Scope ::@expr5466 ScopeType ::@expr1073747299 eDo ;
1113: }
1114:
1115: bool isLocal ( ) const {
1116: return (@expr1073747300 type@var1233 ==@expr1073747301 eIf ||@expr1073747302 type@var1233 ==@expr1073747303 eElse ||@expr1073747304
1117: type@var1233 ==@expr1073747305 eFor ||@expr1073747306 type@var1233 ==@expr1073747307 eWhile ||@expr1073747308 type@var1233 ==@expr1073747309 eDo ||@expr1073747310
1118: type@var1233 ==@expr1073747311 eSwitch ||@expr1073747312 type@var1233 ==@expr1073747313 eUnconditional ||@expr1073747314
1119: type@var1233 ==@expr1073747315 eTry ||@expr1073747316 type@var1233 ==@expr1073747317 eCatch ) ;
1120: }
1121:
1122:
1123: bool hasInlineOrLambdaFunction ( ) const ;
1124:
|
1130:
1131: const Function * findFunction ( const Token * tok@var1253 , bool requireConst@var1254 = false ) const ;
1132:
1133: const Scope * findRecordInNestedList ( const std :: string & name@var1255 , bool isC@var1256 = false ) const ;
1134: Scope * findRecordInNestedList ( const std :: string & name@var1257 ) {
1135: return const_cast < Scope *@expr5494 > (@expr1073747319 const_cast < const Scope *@expr5494 > (@expr1073747321 this@expr1073747322 ) .@expr1073747323 findRecordInNestedList (@expr1073747324 name@var1257 ) ) ;
1136: }
1137:
1138: const Type * findType ( const std :: string & name@var1258 ) const ;
1139: Type * findType ( const std :: string & name@var1259 ) {
1140: return const_cast < Type *@expr5501 > (@expr1073747326 const_cast < const Scope *@expr5501 > (@expr1073747328 this@expr1073747329 ) .@expr1073747330 findType (@expr1073747331 name@var1259 ) ) ;
1141: }
1142:
|
1146:
1147: Scope * findInNestedListRecursive ( const std :: string & name@var1260 ) ;
1148:
1149: void addVariable ( const Token * token_@var1261 , const Token * start_@var1262 ,
1150: const Token * end_@var1263 , AccessControl access_@var1264 , const Type * type_@var1265 ,
1151: const Scope * scope_@var1266 , const Settings * settings@var1267 ) ;
1152:
1153:
1154: void getVariableList ( const Settings * settings@var1268 ) ;
1155:
1156: const Function * getDestructor ( ) const ;
1157:
1158: void addFunction ( const Function & func@var1269 ) {
1159: functionList@var1225 .@expr1073747332 push_back (@expr1073747333 func@var1269 ) ;
1160:
1161: const Function * back@var1270 ; back@var1270 =@expr1073747334 &@expr1073747335 functionList@var1225 .@expr1073747336 back (@expr1073747337 ) ;
1162:
1163: functionMap@var1226 .@expr1073747338 insert (@expr1073747339 make_pair (@expr1073747340 back@var1270 .@expr1073747341 tokenDef@var1271 .@expr1073747342 str (@expr1073747343 ) , back@var1270 ) ) ;
1164: }
1165:
1166: bool hasDefaultConstructor ( ) const ;
1167:
1168: AccessControl defaultAccess ( ) const ;
1169:
|
1176:
1177: const Token * checkVariable ( const Token * tok@var1272 , AccessControl varaccess@var1273 , const Settings * settings@var1274 ) ;
1178:
|
1183:
1184: const Variable * getVariable ( const std :: string & varname@var1275 ) const ;
1185:
1186: const Token * addEnum ( const Token * tok@var1276 , bool isCpp@var1277 ) ;
1187:
1188: const Scope * findRecordInBase ( const std :: string & name@var1278 ) const ;
1189:
1190: std :: vector < const Scope * > findAssociatedScopes ( ) const ;
1191:
1192: private:
1193:
|
1199:
1200: bool isVariableDeclaration ( const Token * const tok@var1279 , const Token * & vartok@var1280 , const Token * & typetok@var1281 ) const ;
1201:
1202: void findFunctionInBase ( const std :: string & name@var1282 , int args@var1283 , std :: vector < const Function * > & matches@var1284 ) const ;
1203:
1204:
1205: void getVariableList ( const Settings * settings@var1285 , const Token * start@var1286 , const Token * end@var1287 ) ;
1206: } ;
1207:
1208: enum class Reference {
1209: None ,
1210: LValue ,
1211: RValue
1212: } ;
1213:
1214:
1215: class ValueType {
1216:
1217: enum Sign { UNKNOWN_SIGN , SIGNED , UNSIGNED } ; public: enum Sign sign@var1288 ;
1218: enum Type {
1219: UNKNOWN_TYPE ,
1220: POD ,
1221: NONSTD ,
1222: RECORD ,
1223: SMART_POINTER ,
1224: CONTAINER ,
1225: ITERATOR ,
1226: VOID ,
1227: BOOL ,
1228: CHAR ,
1229: SHORT ,
1230: WCHAR_T ,
1231: INT ,
1232: LONG ,
1233: LONGLONG ,
1234: UNKNOWN_INT ,
1235: FLOAT ,
1236: DOUBLE ,
1237: LONGDOUBLE
1238: } ; enum Type type@var1289 ;
1239: int bits@var1290 ;
1240: int pointer@var1291 ;
1241: int constness@var1292 ;
1242: Reference reference@var1293 ; reference@var1293 = Reference :: None ;
1243:
1244: const Scope * typeScope@var1294 ;
1245: const :: Type * smartPointerType@var1295 ;
1246: const Token * smartPointerTypeToken@var1296 ;
1247: const Library :: SmartPointer * smartPointer@var1297 ;
1248: const Library :: Container * container@var1298 ;
1249:
1250: const Token * containerTypeToken@var1299 ;
1251:
1252: std :: string originalTypeName@var1300 ;
1253:
1254:
1255: ValueType ( )
1256: : sign@var1288 ( UNKNOWN_SIGN ) ,
1257: type@var1289 ( UNKNOWN_TYPE ) ,
1258: bits@var1290 ( 0 ) ,
1259: pointer@var1291 ( 0U ) ,
1260: constness@var1292 ( 0U ) ,
1261: typeScope@var1294 ( nullptr ) ,
1262: smartPointerType@var1295 ( nullptr ) ,
1263: smartPointerTypeToken@var1296 ( nullptr ) ,
1264: smartPointer@var1297 ( nullptr ) ,
1265: container@var1298 ( nullptr ) ,
1266: containerTypeToken@var1299 ( nullptr )
1267: { }
1268: ValueType ( enum Sign s@var1301 , enum Type t@var1302 , int p@var1303 )
1269: : sign@var1288 ( s@var1301 ) ,
1270: type@var1289 ( t@var1302 ) ,
1271: bits@var1290 ( 0 ) ,
1272: pointer@var1291 ( p@var1303 ) ,
1273: constness@var1292 ( 0U ) ,
1274: typeScope@var1294 ( nullptr ) ,
1275: smartPointerType@var1295 ( nullptr ) ,
1276: smartPointerTypeToken@var1296 ( nullptr ) ,
1277: smartPointer@var1297 ( nullptr ) ,
1278: container@var1298 ( nullptr ) ,
1279: containerTypeToken@var1299 ( nullptr )
1280: { }
1281: ValueType ( enum Sign s@var1304 , enum Type t@var1305 , int p@var1306 , int c@var1307 )
1282: : sign@var1288 ( s@var1304 ) ,
1283: type@var1289 ( t@var1305 ) ,
1284: bits@var1290 ( 0 ) ,
1285: pointer@var1291 ( p@var1306 ) ,
1286: constness@var1292 ( c@var1307 ) ,
1287: typeScope@var1294 ( nullptr ) ,
1288: smartPointerType@var1295 ( nullptr ) ,
1289: smartPointerTypeToken@var1296 ( nullptr ) ,
1290: smartPointer@var1297 ( nullptr ) ,
1291: container@var1298 ( nullptr ) ,
1292: containerTypeToken@var1299 ( nullptr )
1293: { }
1294: ValueType ( enum Sign s@var1308 , enum Type t@var1309 , int p@var1310 , int c@var1311 , const std :: string & otn@var1312 )
1295: : sign@var1288 ( s@var1308 ) ,
1296: type@var1289 ( t@var1309 ) ,
1297: bits@var1290 ( 0 ) ,
1298: pointer@var1291 ( p@var1310 ) ,
1299: constness@var1292 ( c@var1311 ) ,
1300: typeScope@var1294 ( nullptr ) ,
1301: smartPointerType@var1295 ( nullptr ) ,
1302: smartPointerTypeToken@var1296 ( nullptr ) ,
1303: smartPointer@var1297 ( nullptr ) ,
1304: container@var1298 ( nullptr ) ,
1305: containerTypeToken@var1299 ( nullptr ) ,
1306: originalTypeName@var1300 ( otn@var1312 )
1307: { }
1308:
1309: static ValueType parseDecl ( const Token * type@var1313 , const Settings * settings@var1314 ) ;
1310:
1311: static Type typeFromString ( const std :: string & typestr@var1315 , bool longType@var1316 ) ;
1312:
1313: enum class MatchResult { UNKNOWN , SAME , FALLBACK1 , FALLBACK2 , NOMATCH } ;
1314: static MatchResult matchParameter ( const ValueType * call@var1317 , const ValueType * func@var1318 ) ;
1315: static MatchResult matchParameter ( const ValueType * call@var1319 , const Variable * callVar@var1320 , const Variable * funcVar@var1321 ) ;
1316:
1317: bool isPrimitive ( ) const {
1318: return (@expr1073747344 type@var1289 >=@expr1073747345 ValueType ::@expr1073747346 Type ::@expr1073747347 BOOL ) ;
1319: }
1320:
1321: bool isIntegral ( ) const {
1322: return (@expr1073747348 type@var1289 >=@expr1073747349 ValueType ::@expr5526 Type ::@expr1073747351 BOOL &&@expr1073747352 type@var1289 <=@expr1073747353 ValueType ::@expr5526 Type ::@expr1073747355 UNKNOWN_INT ) ;
1323: }
1324:
1325: bool isFloat ( ) const {
1326: return (@expr1073747356 type@var1289 >=@expr1073747357 ValueType ::@expr5534 Type ::@expr1073747359 FLOAT &&@expr1073747360 type@var1289 <=@expr1073747361 ValueType ::@expr5534 Type ::@expr1073747363 LONGDOUBLE ) ;
1327: }
1328:
1329: bool fromLibraryType ( const std :: string & typestr@var1322 , const Settings * settings@var1323 ) ;
1330:
1331: bool isEnum ( ) const {
1332: return typeScope@var1294 &&@expr1073747364 typeScope@var1294 .@expr1073747365 type@var1324 ==@expr1073747366 Scope ::@expr1073747367 eEnum ;
1333: }
1334:
1335: long long typeSize ( const cppcheck :: Platform & platform@var1325 , bool p@var1326 = false ) const ;
1336:
1337:
1338: bool isTypeEqual ( const ValueType * that@var1327 ) const ;
1339:
1340: std :: string str ( ) const ;
1341: std :: string dump ( ) const ;
1342: } ;
1343:
1344:
1345: class SymbolDatabase {
1346: friend class TestSymbolDatabase ;
1347: public:
1348: SymbolDatabase ( const Tokenizer * tokenizer@var1328 , const Settings * settings@var1329 , ErrorLogger * errorLogger@var1330 ) ;
1349: ~ SymbolDatabase ( ) ;
1350:
1351:
1352: std :: list < Scope > scopeList@var1331 ;
1353:
1354:
1355: std :: vector < const Scope * > functionScopes@var1332 ;
1356:
1357:
1358: std :: vector < const Scope * > classAndStructScopes@var1333 ;
1359:
1360:
1361: std :: list < Type > typeList@var1334 ;
1362:
|
1368:
1369: const Type * findVariableType ( const Scope * start@var1335 , const Token * typeTok@var1336 ) const ;
1370:
|
1375:
1376: const Function * findFunction ( const Token * tok@var1337 ) const ;
1377:
1378:
1379: const Scope * findScopeByName ( const std :: string & name@var1338 ) const ;
1380:
1381: const Type * findType ( const Token * startTok@var1339 , const Scope * startScope@var1340 , bool lookOutside@var1341 = false ) const ;
1382: Type * findType ( const Token * startTok@var1342 , Scope * startScope@var1343 , bool lookOutside@var1344 = false ) const {
1383: return const_cast < Type *@expr5544 > (@expr1073747369 this@expr1073747370 .@expr1073747371 findType (@expr1073747372 startTok@var1342 , const_cast < const Scope *@expr5544 > (@expr1073747374 startScope@var1343 ) , lookOutside@var1344 ) ) ;
1384: }
1385:
1386: const Scope * findScope ( const Token * tok@var1345 , const Scope * startScope@var1346 ) const ;
1387: Scope * findScope ( const Token * tok@var1347 , Scope * startScope@var1348 ) const {
1388: return const_cast < Scope *@expr5551 > (@expr1073747376 this@expr1073747377 .@expr1073747378 findScope (@expr1073747379 tok@var1347 , const_cast < const Scope *@expr5551 > (@expr1073747381 startScope@var1348 ) ) ) ;
1389: }
1390:
1391: bool isVarId ( int varid@var1349 ) const {
1392: return varid@var1349 <@expr1073747382 mVariableList@var1406 .@expr1073747383 size (@expr1073747384 ) ;
1393: }
1394:
1395: const Variable * getVariableFromVarId ( int varId@var1350 ) const {
1396: return mVariableList@var1406 .@expr1073747385 at (@expr1073747386 varId@var1350 ) ;
1397: }
1398:
1399: const std :: vector < const Variable * > & variableList ( ) const {
1400: return mVariableList@var1406 ;
1401: }
1402:
|
1405:
1406: void debugMessage ( const Token * tok@var1351 , const std :: string & type@var1352 , const std :: string & msg@var1353 ) const ;
1407:
1408: void printOut ( const char * title@var1354 = nullptr ) const ;
1409: void printVariable ( const Variable * var@var1355 , const char * indent@var1356 ) const ;
1410: void printXml ( std :: ostream & out@var1357 ) const ;
1411:
1412: bool isCPP ( ) const ;
1413:
|
1416:
1417: void validate ( ) const ;
1418:
1419: void validateExecutableScopes ( ) const ;
1420:
1421:
1422:
1423: void validateVariables ( ) const ;
1424:
1425:
1426: void setValueTypeInTokenList ( bool reportDebugWarnings@var1358 , Token * tokens@var1359 = nullptr ) ;
1427:
|
1432:
1433: int sizeOfType ( const Token * type@var1360 ) const ;
1434:
1435:
1436: void setArrayDimensionsUsingValueFlow ( ) ;
1437:
1438: void clangSetVariables ( const std :: vector < const Variable * > & variableList@var1361 ) ;
1439: void createSymbolDatabaseExprIds ( ) ;
1440:
1441: private:
1442: friend class Scope ;
1443: friend class Function ;
1444:
1445:
1446: void createSymbolDatabaseFindAllScopes ( ) ;
1447: void createSymbolDatabaseClassInfo ( ) ;
1448: void createSymbolDatabaseVariableInfo ( ) ;
1449: void createSymbolDatabaseCopyAndMoveConstructors ( ) ;
1450: void createSymbolDatabaseFunctionScopes ( ) ;
1451: void createSymbolDatabaseClassAndStructScopes ( ) ;
1452: void createSymbolDatabaseFunctionReturnTypes ( ) ;
1453: void createSymbolDatabaseNeedInitialization ( ) ;
1454: void createSymbolDatabaseVariableSymbolTable ( ) ;
1455: void createSymbolDatabaseSetScopePointers ( ) ;
1456: void createSymbolDatabaseSetFunctionPointers ( bool firstPass@var1362 ) ;
1457: void createSymbolDatabaseSetVariablePointers ( ) ;
1458:
1459: void createSymbolDatabaseSetTypePointers ( ) ;
1460: void createSymbolDatabaseSetSmartPointerType ( ) ;
1461: void createSymbolDatabaseEnums ( ) ;
1462: void createSymbolDatabaseEscapeFunctions ( ) ;
1463:
1464: void createSymbolDatabaseIncompleteVars ( ) ;
1465:
1466: void addClassFunction ( Scope * * scope@var1363 , const Token * * tok@var1364 , const Token * argStart@var1365 ) ;
1467: Function * addGlobalFunctionDecl ( Scope * & scope@var1366 , const Token * tok@var1367 , const Token * argStart@var1368 , const Token * funcStart@var1369 ) ;
1468: Function * addGlobalFunction ( Scope * & scope@var1370 , const Token * & tok@var1371 , const Token * argStart@var1372 , const Token * funcStart@var1373 ) ;
1469: void addNewFunction ( Scope * * scope@var1374 , const Token * * tok@var1375 ) ;
1470: bool isFunction ( const Token * tok@var1376 , const Scope * outerScope@var1377 , const Token * * funcStart@var1378 , const Token * * argStart@var1379 , const Token * * declEnd@var1380 ) const ;
1471: const Type * findTypeInNested ( const Token * startTok@var1381 , const Scope * startScope@var1382 ) const ;
1472: const Scope * findNamespace ( const Token * tok@var1383 , const Scope * scope@var1384 ) const ;
1473: Function * findFunctionInScope ( const Token * func@var1385 , const Scope * ns@var1386 , const std :: string & path@var1387 , int path_length@var1388 ) ;
1474: const Type * findVariableTypeInBase ( const Scope * scope@var1389 , const Token * typeTok@var1390 ) const ;
1475:
|
1478:
1479: void fixVarId ( std :: map < unsigned int , std :: map < unsigned int , unsigned int > > & varIds@var1391 , const Token * vartok@var1392 , Token * membertok@var1393 , const Variable * membervar@var1394 ) ;
1480:
1481:
1482: bool isReservedName ( const std :: string & iName@var1395 ) const ;
1483:
1484: const Enumerator * findEnumerator ( const Token * tok@var1396 ) const ;
1485:
1486: void setValueType ( Token * tok@var1397 , const ValueType & valuetype@var1398 ) ;
1487: void setValueType ( Token * tok@var1399 , const Variable & var@var1400 ) ;
1488: void setValueType ( Token * tok@var1401 , const Enumerator & enumerator@var1402 ) ;
1489:
1490: const Tokenizer * mTokenizer@var1403 ;
1491: const Settings * mSettings@var1404 ;
1492: ErrorLogger * mErrorLogger@var1405 ;
1493:
1494:
1495: std :: vector < const Variable * > mVariableList@var1406 ;
1496:
1497:
1498: std :: list < Type > mBlankTypes@var1407 ;
1499:
1500: bool mIsCpp@var1408 ;
1501: ValueType :: Sign mDefaultSignedness@var1409 ;
1502:
1503:
1504: mutable std :: set < std :: string > mTokensThatAreNotEnumeratorValues@var1410 ;
1505: } ;

##file cppcheck-2.8/lib/astutils.h

1:
|
34:
35: class Library ;
36: class Settings ;
37: class Token ;
38:
39: enum class ChildrenToVisit {
40: none ,
41: op1 ,
42: op2 ,
43: op1_and_op2 ,
44: done
45: } ;
46:
|
49:
50: template < class T , class TFunc , $class $= $typename $std $:: $enable_if $< std :: is_convertible < T * , const Token * > $:: $value $> $:: $type >
51: void visitAstNodes ( T * ast@var1411 , const TFunc & visitor@var1412 )
52: {
53: if (@expr1073747387 !@expr1073747388 ast@var1411 ) {
54: return ; }
55:
56: std ::@expr1073747389 stack < T *@expr5566 , std ::@expr1073747391 vector < T *@expr5566 > > tokens@var1413 ;
57: T * tok@var1414 ; tok@var1414 =@expr1073747393 ast@var1411 ;
58: do {
59: ChildrenToVisit c@var1415 ; c@var1415 =@expr1073747394 visitor@var1412 (@expr1073747395 tok@var1414 ) ;
60:
61: if (@expr1073747396 c@var1415 ==@expr1073747397 ChildrenToVisit ::@expr1073747398 done ) {
62: break ; }
63: if (@expr1073747399 c@var1415 ==@expr1073747400 ChildrenToVisit ::@expr1073747401 op2 ||@expr1073747402 c@var1415 ==@expr5579 ChildrenToVisit ::@expr5580 op1_and_op2 ) {
64: T * t2@var1416 ; t2@var1416 =@expr1073747405 tok@var1414 .@expr1073747406 astOperand2 (@expr1073747407 ) ;
65: if (@expr1073747408 t2@var1416 ) {
66: tokens@var1413 .@expr5585 push (@expr1073747410 t2@var1416 ) ; }
67: }
68: if (@expr1073747411 c@var1415 ==@expr1073747412 ChildrenToVisit ::@expr1073747413 op1 ||@expr1073747414 c@var1415 ==@expr5579 ChildrenToVisit ::@expr5580 op1_and_op2 ) {
69: T * t1@var1417 ; t1@var1417 =@expr1073747417 tok@var1414 .@expr1073747418 astOperand1 (@expr1073747419 ) ;
70: if (@expr1073747420 t1@var1417 ) {
71: tokens@var1413 .@expr5585 push (@expr1073747422 t1@var1417 ) ; }
72: }
73:
74: if (@expr1073747423 tokens@var1413 .@expr1073747424 empty (@expr1073747425 ) ) {
75: break ; }
76:
77: tok@var1414 =@expr1073747426 tokens@var1413 .@expr1073747427 top (@expr1073747428 ) ;
78: tokens@var1413 .@expr1073747429 pop (@expr1073747430 ) ;
79: } while (@expr1073747431 true ) ;
80: }
81:
82: const Token * findAstNode ( const Token * ast@var1418 , const std :: function < bool ( const Token * ) > & pred@var1419 ) ;
83: const Token * findExpression ( const int exprid@var1420 ,
84: const Token * start@var1421 ,
85: const Token * end@var1422 ,
86: const std :: function < bool ( const Token * ) > & pred@var1423 ) ;
87: const Token * findExpression ( const Token * start@var1424 , const int exprid@var1425 ) ;
88:
89: std :: vector < const Token * > astFlatten ( const Token * tok@var1426 , const char * op@var1427 ) ;
90: std :: vector < Token * > astFlatten ( Token * tok@var1428 , const char * op@var1429 ) ;
91:
92: int astCount ( const Token * tok@var1430 , const char * op@var1431 , int depth@var1432 = 100 ) ;
93:
94: bool astHasToken ( const Token * root@var1433 , const Token * tok@var1434 ) ;
95:
96: bool astHasVar ( const Token * tok@var1435 , int varid@var1436 ) ;
97:
98: bool astIsPrimitive ( const Token * tok@var1437 ) ;
99:
100: bool astIsSignedChar ( const Token * tok@var1438 ) ;
101:
102: bool astIsUnknownSignChar ( const Token * tok@var1439 ) ;
103:
104: bool astIsGenericChar ( const Token * tok@var1440 ) ;
105:
106: bool astIsIntegral ( const Token * tok@var1441 , bool unknown@var1442 ) ;
107: bool astIsUnsigned ( const Token * tok@var1443 ) ;
108:
109: bool astIsFloat ( const Token * tok@var1444 , bool unknown@var1445 ) ;
110:
111: bool astIsBool ( const Token * tok@var1446 ) ;
112:
113: bool astIsPointer ( const Token * tok@var1447 ) ;
114:
115: bool astIsSmartPointer ( const Token * tok@var1448 ) ;
116: bool astIsUniqueSmartPointer ( const Token * tok@var1449 ) ;
117:
118: bool astIsIterator ( const Token * tok@var1450 ) ;
119:
120: bool astIsContainer ( const Token * tok@var1451 ) ;
121:
122: bool astIsContainerView ( const Token * tok@var1452 ) ;
123: bool astIsContainerOwned ( const Token * tok@var1453 ) ;
124:
|
133:
134: std :: string astCanonicalType ( const Token * expr@var1454 ) ;
135:
136:
137: const Token * astIsVariableComparison ( const Token * tok@var1455 , const std :: string & comp@var1456 , const std :: string & rhs@var1457 , const Token * * vartok@var1458 = nullptr ) ;
138:
139: bool isVariableDecl ( const Token * tok@var1459 ) ;
140:
141: bool isTemporary ( bool cpp@var1460 , const Token * tok@var1461 , const Library * library@var1462 , bool unknown@var1463 = false ) ;
142:
143: const Token * previousBeforeAstLeftmostLeaf ( const Token * tok@var1464 ) ;
144: Token * previousBeforeAstLeftmostLeaf ( Token * tok@var1465 ) ;
145:
146: const Token * nextAfterAstRightmostLeaf ( const Token * tok@var1466 ) ;
147: Token * nextAfterAstRightmostLeaf ( Token * tok@var1467 ) ;
148:
149: Token * astParentSkipParens ( Token * tok@var1468 ) ;
150: const Token * astParentSkipParens ( const Token * tok@var1469 ) ;
151:
152: const Token * getParentMember ( const Token * tok@var1470 ) ;
153:
154: const Token * getParentLifetime ( const Token * tok@var1471 ) ;
155: const Token * getParentLifetime ( bool cpp@var1472 , const Token * tok@var1473 , const Library * library@var1474 ) ;
156:
157: bool astIsLHS ( const Token * tok@var1475 ) ;
158: bool astIsRHS ( const Token * tok@var1476 ) ;
159:
160: Token * getCondTok ( Token * tok@var1477 ) ;
161: const Token * getCondTok ( const Token * tok@var1478 ) ;
162:
163: Token * getInitTok ( Token * tok@var1479 ) ;
164: const Token * getInitTok ( const Token * tok@var1480 ) ;
165:
166: Token * getStepTok ( Token * tok@var1481 ) ;
167: const Token * getStepTok ( const Token * tok@var1482 ) ;
168:
169: Token * getCondTokFromEnd ( Token * endBlock@var1483 ) ;
170: const Token * getCondTokFromEnd ( const Token * endBlock@var1484 ) ;
171:
172:
173:
174: const Token * findNextTokenFromBreak ( const Token * breakToken@var1485 ) ;
175:
|
178:
179: bool extractForLoopValues ( const Token * forToken@var1486 ,
180: int * const varid@var1487 ,
181: bool * const knownInitValue@var1488 ,
182: long long * const initValue@var1489 ,
183: bool * const partialCond@var1490 ,
184: long long * const stepValue@var1491 ,
185: long long * const lastValue@var1492 ) ;
186:
187: bool precedes ( const Token * tok1@var1493 , const Token * tok2@var1494 ) ;
188: bool succeeds ( const Token * tok1@var1495 , const Token * tok2@var1496 ) ;
189:
190: bool exprDependsOnThis ( const Token * expr@var1497 , bool onVar@var1498 = true , int depth@var1499 = 0 ) ;
191:
192: struct ReferenceToken {
193: const Token * token@var1500 ;
194: std :: list < std :: pair < const Token * , std :: string > > errors@var1501 ;
195: } ;
196:
197: std :: vector < ReferenceToken > followAllReferences ( const Token * tok@var1502 ,
198: bool temporary@var1503 = true ,
199: bool inconclusive@var1504 = true ,
200: std :: list < std :: pair < const Token * , std :: string > > errors@var1505 = std :: list < std :: pair < const Token * , std :: string > > { } ,
201: int depth@var1506 = 20 ) ;
202: const Token * followReferences ( const Token * tok@var1507 , std :: list < std :: pair < const Token * , std :: string > > * errors@var1508 = nullptr ) ;
203:
204: bool isSameExpression ( bool cpp@var1509 , bool macro@var1510 , const Token * tok1@var1511 , const Token * tok2@var1512 , const Library & library@var1513 , bool pure@var1514 , bool followVar@var1515 , std :: list < std :: pair < const Token * , std :: string > > * errors@var1516 = nullptr ) ;
205:
206: bool isEqualKnownValue ( const Token * const tok1@var1517 , const Token * const tok2@var1518 ) ;
207:
|
210:
211: bool isUsedAsBool ( const Token * const tok@var1519 ) ;
212:
|
221:
222: bool isOppositeCond ( bool isNot@var1520 , bool cpp@var1521 , const Token * const cond1@var1522 , const Token * const cond2@var1523 , const Library & library@var1524 , bool pure@var1525 , bool followVar@var1526 , std :: list < std :: pair < const Token * , std :: string > > * errors@var1527 = nullptr ) ;
223:
224: bool isOppositeExpression ( bool cpp@var1528 , const Token * const tok1@var1529 , const Token * const tok2@var1530 , const Library & library@var1531 , bool pure@var1532 , bool followVar@var1533 , std :: list < std :: pair < const Token * , std :: string > > * errors@var1534 = nullptr ) ;
225:
226: bool isConstFunctionCall ( const Token * ftok@var1535 , const Library & library@var1536 ) ;
227:
228: bool isConstExpression ( const Token * tok@var1537 , const Library & library@var1538 , bool pure@var1539 , bool cpp@var1540 ) ;
229:
230: bool isWithoutSideEffects ( bool cpp@var1541 , const Token * tok@var1542 , bool checkArrayAccess@var1543 = false , bool checkReference@var1544 = true ) ;
231:
232: bool isUniqueExpression ( const Token * tok@var1545 ) ;
233:
234: bool isEscapeFunction ( const Token * ftok@var1546 , const Library * library@var1547 ) ;
235:
236:
237: bool isReturnScope ( const Token * const endToken@var1548 ,
238: const Library * library@var1549 = nullptr ,
239: const Token * * unknownFunc@var1550 = nullptr ,
240: bool functionScope@var1551 = false ) ;
241:
242:
243: bool isWithinScope ( const Token * tok@var1552 ,
244: const Variable * var@var1553 ,
245: Scope :: ScopeType type@var1554 ) ;
246:
247:
248: const Token * getTokenArgumentFunction ( const Token * tok@var1555 , int & argn@var1556 ) ;
249: Token * getTokenArgumentFunction ( Token * tok@var1557 , int & argn@var1558 ) ;
250:
251: std :: vector < const Variable * > getArgumentVars ( const Token * tok@var1559 , int argnr@var1560 ) ;
252:
|
261:
262: bool isVariableChangedByFunctionCall ( const Token * tok@var1561 , int indirect@var1562 , int varid@var1563 , const Settings * settings@var1564 , bool * inconclusive@var1565 ) ;
263:
|
271:
272: bool isVariableChangedByFunctionCall ( const Token * tok@var1566 , int indirect@var1567 , const Settings * settings@var1568 , bool * inconclusive@var1569 ) ;
273:
274:
275: bool isVariableChanged ( const Token * start@var1570 , const Token * end@var1571 , const int exprid@var1572 , bool globalvar@var1573 , const Settings * settings@var1574 , bool cpp@var1575 , int depth@var1576 = 20 ) ;
276: bool isVariableChanged ( const Token * start@var1577 , const Token * end@var1578 , int indirect@var1579 , const int exprid@var1580 , bool globalvar@var1581 , const Settings * settings@var1582 , bool cpp@var1583 , int depth@var1584 = 20 ) ;
277:
278: bool isVariableChanged ( const Token * tok@var1585 , int indirect@var1586 , const Settings * settings@var1587 , bool cpp@var1588 , int depth@var1589 = 20 ) ;
279:
280: bool isVariableChanged ( const Variable * var@var1590 , const Settings * settings@var1591 , bool cpp@var1592 , int depth@var1593 = 20 ) ;
281:
282: bool isVariablesChanged ( const Token * start@var1594 ,
283: const Token * end@var1595 ,
284: int indirect@var1596 ,
285: std :: vector < const Variable * > vars@var1597 ,
286: const Settings * settings@var1598 ,
287: bool cpp@var1599 ) ;
288:
289: bool isThisChanged ( const Token * tok@var1600 , int indirect@var1601 , const Settings * settings@var1602 , bool cpp@var1603 ) ;
290: bool isThisChanged ( const Token * start@var1604 , const Token * end@var1605 , int indirect@var1606 , const Settings * settings@var1607 , bool cpp@var1608 ) ;
291:
292: const Token * findVariableChanged ( const Token * start@var1609 , const Token * end@var1610 , int indirect@var1611 , const int exprid@var1612 , bool globalvar@var1613 , const Settings * settings@var1614 , bool cpp@var1615 , int depth@var1616 = 20 ) ;
293: Token * findVariableChanged ( Token * start@var1617 , const Token * end@var1618 , int indirect@var1619 , const int exprid@var1620 , bool globalvar@var1621 , const Settings * settings@var1622 , bool cpp@var1623 , int depth@var1624 = 20 ) ;
294:
295: bool isExpressionChanged ( const Token * expr@var1625 ,
296: const Token * start@var1626 ,
297: const Token * end@var1627 ,
298: const Settings * settings@var1628 ,
299: bool cpp@var1629 ,
300: int depth@var1630 = 20 ) ;
301:
302: bool isExpressionChangedAt ( const Token * expr@var1631 ,
303: const Token * tok@var1632 ,
304: int indirect@var1633 ,
305: bool globalvar@var1634 ,
306: const Settings * settings@var1635 ,
307: bool cpp@var1636 ,
308: int depth@var1637 = 20 ) ;
309:
310:
311: bool isAliasOf ( const Token * tok@var1638 , int varid@var1639 , bool * inconclusive@var1640 = nullptr ) ;
312:
313: bool isAliased ( const Variable * var@var1641 ) ;
314:
315: const Token * getArgumentStart ( const Token * ftok@var1642 ) ;
316:
|
320:
321: int numberOfArguments ( const Token * ftok@var1643 ) ;
322:
323:
324: int numberOfArgumentsWithoutAst ( const Token * start@var1644 ) ;
325:
|
328:
329: std :: vector < const Token * > getArguments ( const Token * ftok@var1645 ) ;
330:
331: int getArgumentPos ( const Variable * var@var1646 , const Function * f@var1647 ) ;
332:
|
335:
336: bool isIteratorPair ( std :: vector < const Token * > args@var1648 ) ;
337:
338: const Token * findLambdaStartToken ( const Token * last@var1649 ) ;
339:
|
344:
345: const Token * findLambdaEndToken ( const Token * first@var1650 ) ;
346: Token * findLambdaEndToken ( Token * first@var1651 ) ;
347:
348: bool isLikelyStream ( bool cpp@var1652 , const Token * stream@var1653 ) ;
349:
|
354:
355: bool isLikelyStreamRead ( bool cpp@var1654 , const Token * op@var1655 ) ;
356:
357: bool isCPPCast ( const Token * tok@var1656 ) ;
358:
359: bool isConstVarExpression ( const Token * tok@var1657 , const char * skipMatch@var1658 = nullptr ) ;
360:
361: const Variable * getLHSVariable ( const Token * tok@var1659 ) ;
362:
363: const Token * getLHSVariableToken ( const Token * tok@var1660 ) ;
364:
365: std :: vector < const Variable * > getLHSVariables ( const Token * tok@var1661 ) ;
366:
367:
368: const Token * findAllocFuncCallToken ( const Token * expr@var1662 , const Library & library@var1663 ) ;
369:
370: bool isScopeBracket ( const Token * tok@var1664 ) ;
371:
372: bool isNullOperand ( const Token * expr@var1665 ) ;
373:
374: bool isGlobalData ( const Token * expr@var1666 , bool cpp@var1667 ) ;
375:
|
380:
381: class FwdAnalysis {
382: public:
383: FwdAnalysis ( bool cpp@var1668 , const Library & library@var1669 ) : mCpp@var1702 ( cpp@var1668 ) , mLibrary@var1703 ( library@var1669 ) , mWhat@var1704 ( What :: Reassign ) , mValueFlowKnown@var1706 ( true ) { }
384:
385: bool hasOperand ( const Token * tok@var1670 , const Token * lhs@var1671 ) const ;
386:
|
393:
394: const Token * reassign ( const Token * expr@var1672 , const Token * startToken@var1673 , const Token * endToken@var1674 ) ;
395:
|
402:
403: bool unusedValue ( const Token * expr@var1675 , const Token * startToken@var1676 , const Token * endToken@var1677 ) ;
404:
405: struct KnownAndToken {
406: bool known@var1678 ;
407: const Token * token@var1679 ;
408: } ;
409:
410:
411: bool possiblyAliased ( const Token * expr@var1680 , const Token * startToken@var1681 ) const ;
412:
413: std :: set < int > getExprVarIds ( const Token * expr@var1682 , bool * localOut@var1683 = nullptr , bool * unknownVarIdOut@var1684 = nullptr ) const ;
414: private:
415: static bool isEscapedAlias ( const Token * expr@var1685 ) ;
416:
417:
418: struct Result {
419: enum class Type { NONE , READ , WRITE , BREAK , RETURN , BAILOUT } ; enum Type type@var1686 ;
420: explicit Result ( Type type@var1687 ) : type@var1686 ( type@var1687 ) , token@var1690 ( nullptr ) { }
421: Result ( Type type@var1688 , const Token * token@var1689 ) : type@var1686 ( type@var1688 ) , token@var1690 ( token@var1689 ) { }
422: const Token * token@var1690 ;
423: } ;
424:
425: struct Result check ( const Token * expr@var1691 , const Token * startToken@var1692 , const Token * endToken@var1693 ) ;
426: struct Result checkRecursive ( const Token * expr@var1694 , const Token * startToken@var1695 , const Token * endToken@var1696 , const std :: set < int > & exprVarIds@var1697 , bool local@var1698 , bool inInnerClass@var1699 , int depth@var1700 = 0 ) ;
427:
428:
429: bool isGlobalData ( const Token * expr@var1701 ) const ;
430:
431: const bool mCpp@var1702 ;
432: const Library & mLibrary@var1703 ;
433: enum class What { Reassign , UnusedValue , ValueFlow } ; enum What mWhat@var1704 ;
434: std :: vector < KnownAndToken > mValueFlow@var1705 ;
435: bool mValueFlowKnown@var1706 ;
436: } ;
437:
438: bool isSizeOfEtc ( const Token * tok@var1707 ) ;

##file cppcheck-2.8/lib/suppressions.h

1:
|
34:
35: class Tokenizer ;
36:
37:
38: class Suppressions {
39: public:
40:
41: struct ErrorMessage {
42: unsigned long hash@var1708 ;
43: std :: string errorId@var1709 ;
44: void setFileName ( const std :: string & s@var1710 ) ;
45: const std :: string & getFileName ( ) const {
46: return mFileName@var1714 ;
47: }
48: int lineNumber@var1711 ;
49: Certainty :: CertaintyLevel certainty@var1712 ;
50: std :: string symbolNames@var1713 ;
51: private:
52: std :: string mFileName@var1714 ;
53: } ;
54:
55: struct Suppression {
56: Suppression ( ) : lineNumber@var1748 ( NO_LINE ) , hash@var1750 ( 0 ) , thisAndNextLine@var1751 ( false ) , matched@var1752 ( false ) , checked@var1753 ( false ) { }
57: Suppression ( const Suppression & other@var1715 ) {
58: *@expr1073747432 this@expr1073747433 =@expr1073747434 other@var1715 ;
59: }
60: Suppression ( const std :: string & id@var1716 , const std :: string & file@var1717 , int line@var1718 = NO_LINE ) : errorId@var1746 ( id@var1716 ) , fileName@var1747 ( file@var1717 ) , lineNumber@var1748 ( line@var1718 ) , hash@var1750 ( 0 ) , thisAndNextLine@var1751 ( false ) , matched@var1752 ( false ) , checked@var1753 ( false ) { }
61:
62: Suppression & operator= ( const Suppression & other@var1719 ) {
63: errorId@var1746 =@expr1073747435 other@var1719 .@expr1073747436 errorId@var1720 ;
64: fileName@var1747 =@expr1073747437 other@var1719 .@expr1073747438 fileName@var1721 ;
65: lineNumber@var1748 =@expr1073747439 other@var1719 .@expr1073747440 lineNumber@var1722 ;
66: symbolName@var1749 =@expr1073747441 other@var1719 .@expr1073747442 symbolName@var1723 ;
67: hash@var1750 =@expr1073747443 other@var1719 .@expr1073747444 hash@var1724 ;
68: thisAndNextLine@var1751 =@expr1073747445 other@var1719 .@expr1073747446 thisAndNextLine@var1725 ;
69: matched@var1752 =@expr1073747447 other@var1719 .@expr1073747448 matched@var1726 ;
70: checked@var1753 =@expr1073747449 other@var1719 .@expr1073747450 checked@var1727 ;
71: return *@expr1073747451 this@expr1073747452 ;
72: }
73:
74: bool operator< ( const Suppression & other@var1728 ) const {
75: if (@expr1073747453 errorId@var1746 !=@expr1073747454 other@var1728 .@expr5631 errorId@var1729 ) {
76: return errorId@var1746 <@expr1073747456 other@var1728 .@expr5631 errorId@var1729 ; }
77: if (@expr1073747458 lineNumber@var1748 <@expr1073747459 other@var1728 .@expr1073747460 lineNumber@var1730 ) {
78: return true ; }
79: if (@expr1073747461 fileName@var1747 !=@expr1073747462 other@var1728 .@expr5639 fileName@var1731 ) {
80: return fileName@var1747 <@expr1073747464 other@var1728 .@expr5639 fileName@var1731 ; }
81: if (@expr1073747466 symbolName@var1749 !=@expr1073747467 other@var1728 .@expr5644 symbolName@var1732 ) {
82: return symbolName@var1749 <@expr1073747469 other@var1728 .@expr5644 symbolName@var1732 ; }
83: if (@expr1073747471 hash@var1750 !=@expr1073747472 other@var1728 .@expr5649 hash@var1733 ) {
84: return hash@var1750 <@expr1073747474 other@var1728 .@expr5649 hash@var1733 ; }
85: if (@expr1073747476 thisAndNextLine@var1751 !=@expr1073747477 other@var1728 .@expr1073747478 thisAndNextLine@var1734 ) {
86: return thisAndNextLine@var1751 ; }
87: return false ;
88: }
89:
|
95:
96: bool parseComment ( std :: string comment@var1735 , std :: string * errorMessage@var1736 ) ;
97:
98: bool isSuppressed ( const ErrorMessage & errmsg@var1737 ) const ;
99:
100: bool isMatch ( const ErrorMessage & errmsg@var1738 ) ;
101:
102: std :: string getText ( ) const ;
103:
104: bool isLocal ( ) const {
105: return !@expr1073747480 fileName@var1747 .@expr1073747481 empty (@expr1073747482 ) &&@expr1073747483 fileName@var1747 .@expr1073747484 find_first_of (@expr1073747485 "?*" ) ==@expr1073747486 std ::@expr1073747487 string ::@expr1073747488 npos@expr1073747479 ;
106: }
107:
108: bool isSameParameters ( const Suppression & other@var1739 ) const {
109: return errorId@var1746 ==@expr1073747489 other@var1739 .@expr1073747490 errorId@var1740 &&@expr1073747491
110: fileName@var1747 ==@expr1073747492 other@var1739 .@expr1073747493 fileName@var1741 &&@expr1073747494
111: lineNumber@var1748 ==@expr1073747495 other@var1739 .@expr1073747496 lineNumber@var1742 &&@expr1073747497
112: symbolName@var1749 ==@expr1073747498 other@var1739 .@expr1073747499 symbolName@var1743 &&@expr1073747500
113: hash@var1750 ==@expr1073747501 other@var1739 .@expr1073747502 hash@var1744 &&@expr1073747503
114: thisAndNextLine@var1751 ==@expr1073747504 other@var1739 .@expr1073747505 thisAndNextLine@var1745 ;
115: }
116:
117: std :: string errorId@var1746 ;
118: std :: string fileName@var1747 ;
119: int lineNumber@var1748 ;
120: std :: string symbolName@var1749 ;
121: unsigned long hash@var1750 ;
122: bool thisAndNextLine@var1751 ;
123: bool matched@var1752 ;
124: bool checked@var1753 ;
125:
126: enum Anonymous4 { NO_LINE = -1 } ;
127: } ;
128:
|
133:
134: std :: string parseFile ( std :: istream & istr@var1754 ) ;
135:
|
140:
141: std :: string parseXmlFile ( const char * filename@var1755 ) ;
142:
|
148:
149: static std :: vector < Suppression > parseMultiSuppressComment ( const std :: string & comment@var1756 , std :: string * errorMessage@var1757 ) ;
150:
|
155:
156: std :: string addSuppressionLine ( const std :: string & line@var1758 ) ;
157:
|
163:
164: std :: string addSuppression ( const Suppression & suppression@var1759 ) ;
165:
|
170:
171: std :: string addSuppressions ( const std :: list < Suppression > & suppressions@var1760 ) ;
172:
|
177:
178: bool isSuppressed ( const ErrorMessage & errmsg@var1761 ) ;
179:
|
184:
185: bool isSuppressedLocal ( const ErrorMessage & errmsg@var1762 ) ;
186:
|
190:
191: void dump ( std :: ostream & out@var1763 ) const ;
192:
|
196:
197: std :: list < Suppression > getUnmatchedLocalSuppressions ( const std :: string & file@var1764 , const bool unusedFunctionChecking@var1765 ) const ;
198:
|
202:
203: std :: list < Suppression > getUnmatchedGlobalSuppressions ( const bool unusedFunctionChecking@var1766 ) const ;
204:
|
208:
209: const std :: list < Suppression > & getSuppressions ( ) const ;
210:
|
213:
214: void markUnmatchedInlineSuppressionsAsChecked ( const Tokenizer & tokenizer@var1767 ) ;
215:
216: private:
217:
218: std :: list < Suppression > mSuppressions@var1768 ;
219: } ;

##file cppcheck-2.8/lib/color.h

1:
|
26:
27: enum class Color {
28: Reset = 0 ,
29: Bold = 1 ,
30: Dim = 2 ,
31: FgRed = 31 ,
32: FgGreen = 32 ,
33: FgBlue = 34 ,
34: FgMagenta = 35 ,
35: FgDefault = 39 ,
36: BgRed = 41 ,
37: BgGreen = 42 ,
38: BgBlue = 44 ,
39: BgDefault = 49
40: } ;
41: std :: ostream & operator<< ( std :: ostream & os@var1769 , const Color & c@var1770 ) ;
42:
43: std :: string toString ( const Color & c@var1771 ) ;

##file cppcheck-2.8/lib/errorlogger.h

1:
|
39:
40: static const struct CWE CWE_USE_OF_UNINITIALIZED_VARIABLE@var1772 ( 457U ) ;
41: static const struct CWE CWE_NULL_POINTER_DEREFERENCE@var1773 ( 476U ) ;
42: static const struct CWE CWE_USE_OF_POTENTIALLY_DANGEROUS_FUNCTION@var1774 ( 676U ) ;
43: static const struct CWE CWE_INCORRECT_CALCULATION@var1775 ( 682U ) ;
44: static const struct CWE CWE_EXPIRED_POINTER_DEREFERENCE@var1776 ( 825U ) ;
45:
46:
47: class Token ;
48: class TokenList ;
49:
50: namespace tinyxml2 {
51: class XMLElement ;
52: }
53:
|
59:
60: class ErrorMessage {
61: public:
62:
|
66:
67: class FileLocation {
68: public:
69: FileLocation ( )
70: : fileIndex@var1792 ( 0 ) , line@var1793 ( 0 ) , column@var1794 ( 0 ) { }
71:
72: FileLocation ( const std :: string & file@var1777 , int line@var1778 , unsigned int column@var1779 )
73: : fileIndex@var1792 ( 0 ) , line@var1793 ( line@var1778 ) , column@var1794 ( column@var1779 ) , mOrigFileName@var1796 ( file@var1777 ) , mFileName@var1797 ( file@var1777 ) { }
74:
75: FileLocation ( const std :: string & file@var1780 , const std :: string & info@var1781 , int line@var1782 , unsigned int column@var1783 )
76: : fileIndex@var1792 ( 0 ) , line@var1793 ( line@var1782 ) , column@var1794 ( column@var1783 ) , mOrigFileName@var1796 ( file@var1780 ) , mFileName@var1797 ( file@var1780 ) , mInfo@var1798 ( info@var1781 ) { }
77:
78: FileLocation ( const Token * tok@var1784 , const TokenList * tokenList@var1785 ) ;
79: FileLocation ( const Token * tok@var1786 , const std :: string & info@var1787 , const TokenList * tokenList@var1788 ) ;
80:
|
85:
86: std :: string getfile ( bool convert@var1789 = true ) const ;
87:
|
92:
93: std :: string getOrigFile ( bool convert@var1790 = true ) const ;
94:
|
98:
99: void setfile ( const std :: string & file@var1791 ) ;
100:
|
103:
104: std :: string stringify ( ) const ;
105:
106: unsigned int fileIndex@var1792 ;
107: int line@var1793 ;
108: unsigned int column@var1794 ;
109:
110: std :: string getinfo ( ) const {
111: return mInfo@var1798 ;
112: }
113: void setinfo ( const std :: string & i@var1795 ) {
114: mInfo@var1798 =@expr1073747506 i@var1795 ;
115: }
116:
117: private:
118: std :: string mOrigFileName@var1796 ;
119: std :: string mFileName@var1797 ;
120: std :: string mInfo@var1798 ;
121: } ;
122:
123: ErrorMessage ( const std :: list < FileLocation > & callStack@var1799 ,
124: const std :: string & file1@var1800 ,
125: Severity :: SeverityType severity@var1801 ,
126: const std :: string & msg@var1802 ,
127: const std :: string & id@var1803 , Certainty :: CertaintyLevel certainty@var1804 ) ;
128: ErrorMessage ( const std :: list < FileLocation > & callStack@var1805 ,
129: const std :: string & file1@var1806 ,
130: Severity :: SeverityType severity@var1807 ,
131: const std :: string & msg@var1808 ,
132: const std :: string & id@var1809 ,
133: const CWE & cwe@var1810 ,
134: Certainty :: CertaintyLevel certainty@var1811 ) ;
135: ErrorMessage ( const std :: list < const Token * > & callstack@var1812 ,
136: const TokenList * list@var1813 ,
137: Severity :: SeverityType severity@var1814 ,
138: const std :: string & id@var1815 ,
139: const std :: string & msg@var1816 ,
140: Certainty :: CertaintyLevel certainty@var1817 ) ;
141: ErrorMessage ( const std :: list < const Token * > & callstack@var1818 ,
142: const TokenList * list@var1819 ,
143: Severity :: SeverityType severity@var1820 ,
144: const std :: string & id@var1821 ,
145: const std :: string & msg@var1822 ,
146: const CWE & cwe@var1823 ,
147: Certainty :: CertaintyLevel certainty@var1824 ) ;
148: ErrorMessage ( const std :: list < std :: pair < const Token * , std :: string > > & errorPath@var1825 ,
149: const TokenList * tokenList@var1826 ,
150: Severity :: SeverityType severity@var1827 ,
151: const char id@var1828 [ ] ,
152: const std :: string & msg@var1829 ,
153: const CWE & cwe@var1830 ,
154: Certainty :: CertaintyLevel certainty@var1831 ) ;
155: ErrorMessage ( ) ;
156: explicit ErrorMessage ( const tinyxml2 :: XMLElement * const errmsg@var1832 ) ;
157:
|
160:
161: std :: string toXML ( ) const ;
162:
163: static std :: string getXMLHeader ( ) ;
164: static std :: string getXMLFooter ( ) ;
165:
|
174:
175: std :: string toString ( bool verbose@var1833 ,
176: const std :: string & templateFormat@var1834 = emptyString@var1 ,
177: const std :: string & templateLocation@var1835 = emptyString@var1 ) const ;
178:
179: std :: string serialize ( ) const ;
180: bool deserialize ( const std :: string & data@var1836 ) ;
181:
182: std :: list < FileLocation > callStack@var1837 ;
183: std :: string id@var1838 ;
184:
185:
186: std :: string file0@var1839 ;
187:
188: std :: string function@var1840 ;
189:
190: bool incomplete@var1841 ;
191:
192: Severity :: SeverityType severity@var1842 ;
193: CWE cwe@var1843 ;
194: Certainty :: CertaintyLevel certainty@var1844 ;
195:
196:
197: unsigned long hash@var1845 ;
198:
199:
200: void setmsg ( const std :: string & msg@var1846 ) ;
201:
202:
203: const std :: string & shortMessage ( ) const {
204: return mShortMessage@var1848 ;
205: }
206:
207:
208: const std :: string & verboseMessage ( ) const {
209: return mVerboseMessage@var1849 ;
210: }
211:
212:
213: const std :: string & symbolNames ( ) const {
214: return mSymbolNames@var1850 ;
215: }
216:
217: Suppressions :: ErrorMessage toSuppressionsErrorMessage ( ) const ;
218:
219: private:
220: static std :: string fixInvalidChars ( const std :: string & raw@var1847 ) ;
221:
222:
223: std :: string mShortMessage@var1848 ;
224:
225:
226: std :: string mVerboseMessage@var1849 ;
227:
228:
229: std :: string mSymbolNames@var1850 ;
230: } ;
231:
|
235:
236: class ErrorLogger {
237: protected:
238: std :: ofstream plistFile@var1851 ;
239: public:
240: ErrorLogger ( ) { }
241: virtual ~ ErrorLogger ( ) {
242: if (@expr1073747507 plistFile@var1851 .@expr1073747508 is_open (@expr1073747509 ) ) {
243: plistFile@var1851 <<@expr1073747510 ErrorLogger ::@expr1073747511 plistFooter (@expr1073747512 ) ;
244: plistFile@var1851 .@expr1073747513 close (@expr1073747514 ) ;
245: }
246: }
247:
|
253:
254: virtual void reportOut ( const std :: string & outmsg@var1852 , Color c@var1853 = Color :: Reset ) = 0 ;
255:
|
261:
262: virtual void reportErr ( const ErrorMessage & msg@var1854 ) = 0 ;
263:
|
269:
270: virtual void reportProgress ( const std :: string & filename@var1855 , const char stage@var1856 [ ] , const unsigned long value@var1857 ) {
271: (@expr1073747515 void ) filename@var1855 ;
272: (@expr1073747516 void ) stage@var1856 ;
273: (@expr1073747517 void ) value@var1857 ;
274: }
275:
|
279:
280: virtual void reportInfo ( const ErrorMessage & msg@var1858 ) {
281: reportErr (@expr1073747518 msg@var1858 ) ;
282: }
283:
|
288:
289: bool reportUnmatchedSuppressions ( const std :: list < Suppressions :: Suppression > & unmatched@var1859 ) ;
290:
291: static std :: string callStackToString ( const std :: list < ErrorMessage :: FileLocation > & callStack@var1860 ) ;
292:
|
297:
298: static std :: string toxml ( const std :: string & str@var1861 ) ;
299:
300: static std :: string plistHeader ( const std :: string & version@var1862 , const std :: vector < std :: string > & files@var1863 ) ;
301: static std :: string plistData ( const ErrorMessage & msg@var1864 ) ;
302: static const char * plistFooter ( ) {
303: return " </array>\r\n</dict>\r\n</plist>"
304:
305: ;
306: }
307: } ;
308:
309:
310: std :: string replaceStr ( std :: string s@var1865 , const std :: string & from@var1866 , const std :: string & to@var1867 ) ;

##file cppcheck-2.8/lib/platform.h

1:
|
31:
32: namespace tinyxml2 {
33: class XMLDocument ;
34: }
35:
36: namespace cppcheck {
37:
|
40:
41: class Platform {
42: private:
43: static long long min_value ( int bit@var1868 ) {
44: if (@expr1073747519 bit@var1868 >=@expr1073747520 64 ) {
45: return LLONG_MIN ; }
46: return -@expr1073747521 (@expr1073747522 1LL <<@expr1073747523 (@expr1073747524 bit@var1868 -@expr1073747525 1 ) ) ;
47: }
48:
49: static long long max_value ( int bit@var1869 ) {
50: if (@expr1073747526 bit@var1869 >=@expr1073747527 64 ) {
51: return (@expr5704 ~@expr1073747529 0ULL ) >>@expr1073747530 1 ; }
52: return (@expr5704 1LL <<@expr1073747532 (@expr5704 bit@var1869 -@expr1073747534 1 ) ) -@expr1073747535 1LL ;
53: }
54: public:
55: Platform ( ) ;
56: virtual ~ Platform ( ) { }
57:
58: bool isIntValue ( long long value@var1870 ) const {
59: return value@var1870 >=@expr1073747536 min_value (@expr1073747537 int_bit@var1880 ) &&@expr1073747538 value@var1870 <=@expr1073747539 max_value (@expr1073747540 int_bit@var1880 ) ;
60: }
61:
62: bool isIntValue ( unsigned long long value@var1871 ) const {
63: unsigned long long intMax@var1872 ; intMax@var1872 =@expr1073747541 max_value (@expr1073747542 int_bit@var1880 ) ;
64: return value@var1871 <=@expr1073747543 intMax@var1872 ;
65: }
66:
67: bool isLongValue ( long long value@var1873 ) const {
68: return value@var1873 >=@expr1073747544 min_value (@expr1073747545 long_bit@var1881 ) &&@expr1073747546 value@var1873 <=@expr1073747547 max_value (@expr1073747548 long_bit@var1881 ) ;
69: }
70:
71: bool isLongValue ( unsigned long long value@var1874 ) const {
72: unsigned long long longMax@var1875 ; longMax@var1875 =@expr1073747549 max_value (@expr1073747550 long_bit@var1881 ) ;
73: return value@var1874 <=@expr1073747551 longMax@var1875 ;
74: }
75:
76: bool isLongLongValue ( unsigned long long value@var1876 ) const {
77: unsigned long long longLongMax@var1877 ; longLongMax@var1877 =@expr1073747552 max_value (@expr1073747553 long_long_bit@var1882 ) ;
78: return value@var1876 <=@expr1073747554 longLongMax@var1877 ;
79: }
80:
81: int char_bit@var1878 ;
82: int short_bit@var1879 ;
83: int int_bit@var1880 ;
84: int long_bit@var1881 ;
85: int long_long_bit@var1882 ;
86:
87:
88: int sizeof_bool@var1883 ;
89: int sizeof_short@var1884 ;
90: int sizeof_int@var1885 ;
91: int sizeof_long@var1886 ;
92: int sizeof_long_long@var1887 ;
93: int sizeof_float@var1888 ;
94: int sizeof_double@var1889 ;
95: int sizeof_long_double@var1890 ;
96: int sizeof_wchar_t@var1891 ;
97: int sizeof_size_t@var1892 ;
98: int sizeof_pointer@var1893 ;
99:
100: char defaultSign@var1894 ;
101:
102: enum PlatformType {
103: Unspecified ,
104: Native ,
105: Win32A ,
106: Win32W ,
107: Win64 ,
108: Unix32 ,
109: Unix64 ,
110: PlatformFile
111: } ;
112:
113:
114: PlatformType platformType@var1895 ;
115:
116:
117: bool platform ( PlatformType type@var1896 ) ;
118:
|
124:
125: bool loadPlatformFile ( const char exename@var1897 [ ] , const std :: string & filename@var1898 ) ;
126:
127:
128: bool loadFromXmlDocument ( const tinyxml2 :: XMLDocument * doc@var1899 ) ;
129:
|
133:
134: bool isWindowsPlatform ( ) const {
135: return platformType@var1895 ==@expr1073747555 Win32A ||@expr1073747556
136: platformType@var1895 ==@expr1073747557 Win32W ||@expr1073747558
137: platformType@var1895 ==@expr1073747559 Win64 ;
138: }
139:
140: const char * platformString ( ) const {
141: return platformString (@expr1073747560 platformType@var1895 ) ;
142: }
143:
144: static const char * platformString ( PlatformType pt@var1900 ) {
145: switch (@expr1073747561 pt@var1900 ) {
146: case Unspecified :@expr5738 ;
147: return "Unspecified" ;
148: case Native :@expr5738 ;
149: return "Native" ;
150: case Win32A :@expr5738 ;
151: return "win32A" ;
152: case Win32W :@expr5738 ;
153: return "win32W" ;
154: case Win64 :@expr5738 ;
155: return "win64" ;
156: case Unix32 :@expr5738 ;
157: return "unix32" ;
158: case Unix64 :@expr5738 ;
159: return "unix64" ;
160: case PlatformFile :@expr5738 ;
161: return "platformFile" ;
162: default :@expr5738 ;
163: return "unknown" ;
164: }
165: }
166:
167: long long unsignedCharMax ( ) const {
168: return max_value (@expr1073747571 char_bit@var1878 +@expr1073747572 1 ) ;
169: }
170:
171: long long signedCharMax ( ) const {
172: return max_value (@expr1073747573 char_bit@var1878 ) ;
173: }
174:
175: long long signedCharMin ( ) const {
176: return min_value (@expr1073747574 char_bit@var1878 ) ;
177: }
178: } ;
179:
180: }

##file cppcheck-2.8/lib/importproject.h

1:
|
37:
38: namespace cppcheck {
39: struct stricmp {
40: bool operator() ( const std :: string & lhs@var1901 , const std :: string & rhs@var1902 ) const {
41: return caseInsensitiveStringCompare (@expr1073747575 lhs@var1901 , rhs@var1902 ) <@expr1073747576 0 ;
42: }
43: } ;
44: }
45:
46: class Settings ;
47:
|
50:
51: class ImportProject {
52: public:
53: enum class Type {
54: UNKNOWN ,
55: MISSING ,
56: FAILURE ,
57: COMPILE_DB ,
58: VS_SLN ,
59: VS_VCXPROJ ,
60: BORLAND ,
61: CPPCHECK_GUI
62: } ;
63:
64:
65: struct FileSettings {
66: FileSettings ( ) : platformType@var1910 ( cppcheck :: Platform :: Unspecified ) , msc@var1911 ( false ) , useMfc@var1912 ( false ) { }
67: std :: string cfg@var1903 ;
68: std :: string filename@var1904 ;
69: std :: string defines@var1905 ;
70: std :: string cppcheckDefines ( ) const {
71: return defines@var1905 +@expr1073747577 (@expr1073747578 msc@var1911 ?@expr1073747579 ";_MSC_VER=1900" :@expr1073747580 "" ) +@expr1073747581 (@expr1073747582 useMfc@var1912 ?@expr1073747583 ";__AFXWIN_H__=1" :@expr1073747584 "" ) ;
72: }
73: std :: set < std :: string > undefs@var1906 ;
74: std :: list < std :: string > includePaths@var1907 ;
75: std :: list < std :: string > systemIncludePaths@var1908 ;
76: std :: string standard@var1909 ;
77: cppcheck :: Platform :: PlatformType platformType@var1910 ;
78: bool msc@var1911 ;
79: bool useMfc@var1912 ;
80:
81: void parseCommand ( std :: string command@var1913 ) ;
82: void setDefines ( std :: string defs@var1914 ) ;
83: void setIncludePaths ( const std :: string & basepath@var1915 , const std :: list < std :: string > & in@var1916 , std :: map < std :: string , std :: string , cppcheck :: stricmp > & variables@var1917 ) ;
84: } ;
85: std :: list < FileSettings > fileSettings@var1918 ;
86: Type projectType@var1919 ;
87:
88: ImportProject ( ) ;
89:
90: void selectOneVsConfig ( cppcheck :: Platform :: PlatformType platform@var1920 ) ;
91:
92: std :: list < std :: string > getVSConfigs ( ) ;
93:
94:
95: struct Anonymous5 {
96: std :: string analyzeAllVsConfigs@var1921 ;
97: std :: vector < std :: string > pathNames@var1922 ;
98: std :: list < std :: string > libraries@var1923 ;
99: std :: list < std :: string > excludedPaths@var1924 ;
100: std :: list < std :: string > checkVsConfigs@var1925 ;
101: std :: string projectFile@var1926 ;
102: std :: string platform@var1927 ;
103: } ; struct Anonymous5 guiProject@var1928 ;
104:
105: void ignorePaths ( const std :: vector < std :: string > & ipaths@var1929 ) ;
106: void ignoreOtherConfigs ( const std :: string & cfg@var1930 ) ;
107:
108: Type import ( const std :: string & filename@var1931 , Settings * settings@var1932 = nullptr ) ;
109: protected:
110: bool importCompileCommands ( std :: istream & istr@var1933 ) ;
111: bool importCppcheckGuiProject ( std :: istream & istr@var1934 , Settings * settings@var1935 ) ;
112: virtual bool sourceFileExists ( const std :: string & file@var1936 ) ;
113: private:
114: bool importSln ( std :: istream & istr@var1937 , const std :: string & path@var1938 , const std :: vector < std :: string > & fileFilters@var1939 ) ;
115: bool importVcxproj ( const std :: string & filename@var1940 , std :: map < std :: string , std :: string , cppcheck :: stricmp > & variables@var1941 , const std :: string & additionalIncludeDirectories@var1942 , const std :: vector < std :: string > & fileFilters@var1943 ) ;
116: bool importBcb6Prj ( const std :: string & projectFilename@var1944 ) ;
117:
118: static void printError ( const std :: string & message@var1945 ) ;
119:
120: void setRelativePaths ( const std :: string & filename@var1946 ) ;
121:
122: std :: string mPath@var1947 ;
123: std :: set < std :: string > mAllVSConfigs@var1948 ;
124: } ;
125:
126:
127: namespace CppcheckXml {
128: const char ProjectElementName@var1949 [ 8 ] = "project" ;
129: const char ProjectVersionAttrib@var1950 [ 8 ] = "version" ;
130: const char ProjectFileVersion@var1951 [ 2 ] = "1" ;
131: const char BuildDirElementName@var1952 [ 9 ] = "builddir" ;
132: const char ImportProjectElementName@var1953 [ 14 ] = "importproject" ;
133: const char AnalyzeAllVsConfigsElementName@var1954 [ 23 ] = "analyze-all-vs-configs" ;
134: const char Parser@var1955 [ 7 ] = "parser" ;
135: const char BugHunting@var1956 [ 12 ] = "bug-hunting" ;
136: const char IncludeDirElementName@var1957 [ 11 ] = "includedir" ;
137: const char DirElementName@var1958 [ 4 ] = "dir" ;
138: const char DirNameAttrib@var1959 [ 5 ] = "name" ;
139: const char DefinesElementName@var1960 [ 8 ] = "defines" ;
140: const char DefineName@var1961 [ 7 ] = "define" ;
141: const char DefineNameAttrib@var1962 [ 5 ] = "name" ;
142: const char UndefinesElementName@var1963 [ 10 ] = "undefines" ;
143: const char UndefineName@var1964 [ 9 ] = "undefine" ;
144: const char PathsElementName@var1965 [ 6 ] = "paths" ;
145: const char PathName@var1966 [ 4 ] = "dir" ;
146: const char PathNameAttrib@var1967 [ 5 ] = "name" ;
147: const char RootPathName@var1968 [ 5 ] = "root" ;
148: const char RootPathNameAttrib@var1969 [ 5 ] = "name" ;
149: const char IgnoreElementName@var1970 [ 7 ] = "ignore" ;
150: const char IgnorePathName@var1971 [ 5 ] = "path" ;
151: const char IgnorePathNameAttrib@var1972 [ 5 ] = "name" ;
152: const char ExcludeElementName@var1973 [ 8 ] = "exclude" ;
153: const char ExcludePathName@var1974 [ 5 ] = "path" ;
154: const char ExcludePathNameAttrib@var1975 [ 5 ] = "name" ;
155: const char FunctionContracts@var1976 [ 19 ] = "function-contracts" ;
156: const char VariableContractsElementName@var1977 [ 19 ] = "variable-contracts" ;
157: const char LibrariesElementName@var1978 [ 10 ] = "libraries" ;
158: const char LibraryElementName@var1979 [ 8 ] = "library" ;
159: const char PlatformElementName@var1980 [ 9 ] = "platform" ;
160: const char SuppressionsElementName@var1981 [ 13 ] = "suppressions" ;
161: const char SuppressionElementName@var1982 [ 12 ] = "suppression" ;
162: const char AddonElementName@var1983 [ 6 ] = "addon" ;
163: const char AddonsElementName@var1984 [ 7 ] = "addons" ;
164: const char ToolElementName@var1985 [ 5 ] = "tool" ;
165: const char ToolsElementName@var1986 [ 6 ] = "tools" ;
166: const char TagsElementName@var1987 [ 5 ] = "tags" ;
167: const char TagElementName@var1988 [ 4 ] = "tag" ;
168: const char TagWarningsElementName@var1989 [ 13 ] = "tag-warnings" ;
169: const char TagAttributeName@var1990 [ 4 ] = "tag" ;
170: const char WarningElementName@var1991 [ 8 ] = "warning" ;
171: const char HashAttributeName@var1992 [ 5 ] = "hash" ;
172: const char CheckHeadersElementName@var1993 [ 14 ] = "check-headers" ;
173: const char CheckUnusedTemplatesElementName@var1994 [ 23 ] = "check-unused-templates" ;
174: const char MaxCtuDepthElementName@var1995 [ 14 ] = "max-ctu-depth" ;
175: const char MaxTemplateRecursionElementName@var1996 [ 23 ] = "max-template-recursion" ;
176: const char CheckUnknownFunctionReturn@var1997 [ 37 ] = "check-unknown-function-return-values" ;
177: const char ClangTidy@var1998 [ 11 ] = "clang-tidy" ;
178: const char Name@var1999 [ 5 ] = "name" ;
179: const char VSConfigurationElementName@var2000 [ 18 ] = "vs-configurations" ;
180: const char VSConfigurationName@var2001 [ 7 ] = "config" ;
181: }

##file cppcheck-2.8/lib/timer.h

1:
|
28:
29: enum class SHOWTIME_MODES {
30: SHOWTIME_NONE = 0 ,
31: SHOWTIME_FILE ,
32: SHOWTIME_SUMMARY ,
33: SHOWTIME_TOP5
34: } ;
35:
36: class TimerResultsIntf {
37: public:
38: virtual ~ TimerResultsIntf ( ) { }
39:
40: virtual void addResults ( const std :: string & str@var2002 , std :: clock_t clocks@var2003 ) = 0 ;
41: } ;
42:
43: struct TimerResultsData {
44: std :: clock_t mClocks@var2004 ;
45: long mNumberOfResults@var2005 ;
46:
47: TimerResultsData ( )
48: : mClocks@var2004 ( 0 )
49: , mNumberOfResults@var2005 ( 0 ) { }
50:
51: double seconds ( ) const {
52: const double ret@var2006 =@expr1073747586 (@expr1073747587 double ) (@expr1073747588 (@expr1073747589 unsigned long ) mClocks@var2004 ) /@expr1073747590 (@expr1073747591 double ) CLOCKS_PER_SEC@expr1073747585 ;
53: return ret@var2006 ;
54: }
55: } ;
56:
57: class TimerResults : public TimerResultsIntf {
58: public:
59: TimerResults ( ) { }
60:
61: void showResults ( SHOWTIME_MODES mode@var2007 ) const ;
62: void addResults ( const std :: string & str@var2008 , std :: clock_t clocks@var2009 ) override ;
63:
64: private:
65: std :: map < std :: string , TimerResultsData > mResults@var2010 ;
66: } ;
67:
68: class Timer {
69: public:
70: Timer ( const std :: string & str@var2011 , SHOWTIME_MODES showtimeMode@var2012 , TimerResultsIntf * timerResults@var2013 = nullptr ) ;
71: ~ Timer ( ) ;
72: void stop ( ) ;
73:
74: private:
75: Timer ( const Timer & other@var2014 ) ;
76: Timer & operator= ( const Timer & ) ;
77:
78: const std :: string mStr@var2015 ;
79: TimerResultsIntf * mTimerResults@var2016 ;
80: std :: clock_t mStart@var2017 ;
81: const SHOWTIME_MODES mShowTimeMode@var2018 ;
82: bool mStopped@var2019 ;
83: } ;

##file cppcheck-2.8/lib/settings.h

1:
|
40:
41: namespace ValueFlow {
42: class Value ;
43: }
44:
|
47:
48: class SimpleEnableGroup<Severity::SeverityType> ; class SimpleEnableGroup<Certainty::CertaintyLevel> ; class SimpleEnableGroup<Checks::CheckList> ;
49:
|
89:
90: class Settings : public cppcheck :: Platform {
91: private:
92:
93:
94: static std :: atomic < bool > mTerminated@var2020 ;
95:
96: public:
97: Settings ( ) ;
98:
99: void loadCppcheckCfg ( ) ;
100:
101:
102: std :: list < std :: string > addons@var2021 ;
103:
104:
105: std :: string addonPython@var2022 ;
106:
107:
108: std :: vector < std :: string > basePaths@var2023 ;
109:
110:
111: std :: string buildDir@var2024 ;
112:
113:
114: bool checkAllConfigurations@var2025 ;
115:
116:
117: bool checkConfiguration@var2026 ;
118:
|
121:
122: bool checkHeaders@var2027 ;
123:
124:
125: bool checkLibrary@var2028 ;
126:
127:
128: std :: set < std :: string > checkUnknownFunctionReturn@var2029 ;
129:
130:
131: bool checkUnusedTemplates@var2030 ;
132:
133:
134: bool clang@var2031 ;
135:
136:
137: std :: string clangExecutable@var2032 ;
138:
139:
140: bool clangTidy@var2033 ;
141:
142:
143: std :: set < std :: string > configExcludePaths@var2034 ;
144:
145:
146: std :: string cppcheckCfgProductName@var2035 ;
147:
148:
149: std :: string cppcheckCfgAbout@var2036 ;
150:
151:
152: bool daca@var2037 ;
153:
154:
155: bool debugnormal@var2038 ;
156:
157:
158: bool debugSimplified@var2039 ;
159:
160:
161: bool debugtemplate@var2040 ;
162:
163:
164: bool debugwarnings@var2041 ;
165:
166:
167: bool dump@var2042 ;
168: std :: string dumpFile@var2043 ;
169:
170: enum Language {
171: None , C , CPP
172: } ;
173:
174:
175: Language enforcedLang@var2044 ;
176:
177:
178: bool exceptionHandling@var2045 ;
179:
180:
181: std :: string exename@var2046 ;
182:
183:
184:
185: int exitCode@var2047 ;
186:
187:
188: std :: vector < std :: string > fileFilters@var2048 ;
189:
190:
191: bool force@var2049 ;
192:
193:
194:
195: std :: list < std :: string > includePaths@var2050 ;
196:
197:
198: bool inlineSuppressions@var2051 ;
199:
200:
201:
202: unsigned int jobs@var2052 ;
203:
|
206:
207: bool jointSuppressionReport@var2053 ;
208:
209:
210: std :: list < std :: string > libraries@var2054 ;
211:
212:
213: Library library@var2055 ;
214:
215:
216:
217: int loadAverage@var2056 ;
218:
|
221:
222: int maxConfigs@var2057 ;
223:
224:
225: int maxCtuDepth@var2058 ;
226:
227:
228: int maxTemplateRecursion@var2059 ;
229:
230:
231: Suppressions nofail@var2060 ;
232:
233:
234: Suppressions nomsg@var2061 ;
235:
236:
237: std :: string outputFile@var2062 ;
238:
239:
240: std :: string plistOutput@var2063 ;
241:
242:
243: bool preprocessOnly@var2064 ;
244:
245: ImportProject project@var2065 ;
246:
247:
248: bool quiet@var2066 ;
249:
250:
251: bool relativePaths@var2067 ;
252:
253:
254: bool reportProgress@var2068 ;
255:
256:
257: class Rule {
258: public:
259: Rule ( )
260: : tokenlist@var2069 ( "simple" )
261: , id@var2071 ( "rule" )
262: , severity@var2073 ( Severity :: style ) {
263: }
264:
265: std :: string tokenlist@var2069 ;
266: std :: string pattern@var2070 ;
267: std :: string id@var2071 ;
268: std :: string summary@var2072 ;
269: Severity :: SeverityType severity@var2073 ;
270: } ;
271:
|
274:
275: std :: list < Rule > rules@var2074 ;
276:
277:
278: class SafeChecks {
279: public:
280: SafeChecks ( ) : classes@var2080 ( false ) , externalFunctions@var2081 ( false ) , internalFunctions@var2082 ( false ) , externalVariables@var2083 ( false ) { }
281:
282: static const char XmlRootName@var2075 [ ] ;
283: static const char XmlClasses@var2076 [ ] ;
284: static const char XmlExternalFunctions@var2077 [ ] ;
285: static const char XmlInternalFunctions@var2078 [ ] ;
286: static const char XmlExternalVariables@var2079 [ ] ;
287:
288: void clear ( ) {
289: classes@var2080 =@expr1073747592 externalFunctions@var2081 =@expr1073747593 internalFunctions@var2082 =@expr1073747594 externalVariables@var2083 =@expr1073747595 false ;
290: }
291:
|
297:
298: bool classes@var2080 ;
299:
|
304:
305: bool externalFunctions@var2081 ;
306:
|
310:
311: bool internalFunctions@var2082 ;
312:
|
316:
317: bool externalVariables@var2083 ;
318: } ;
319:
320: SafeChecks safeChecks@var2084 ;
321:
322: SimpleEnableGroup<Severity::SeverityType> severity@var2085 ;
323: SimpleEnableGroup<Certainty::CertaintyLevel> certainty@var2086 ;
324: SimpleEnableGroup<Checks::CheckList> checks@var2087 ;
325:
326:
327: SHOWTIME_MODES showtime@var2088 ;
328:
329:
330: Standards standards@var2089 ;
331:
332:
333:
334: std :: string templateFormat@var2090 ;
335:
336:
337:
338: std :: string templateLocation@var2091 ;
339:
340:
341: std :: string userDefines@var2092 ;
342:
343:
344: std :: set < std :: string > userUndefs@var2093 ;
345:
346:
347: std :: list < std :: string > userIncludes@var2094 ;
348:
349:
350: bool verbose@var2095 ;
351:
352:
353: bool xml@var2096 ;
354:
355:
356: int xml_version@var2097 ;
357:
|
361:
362: bool configurationExcluded ( const std :: string & file@var2098 ) const {
363: for (@expr1073747596 const std ::@expr1073747597 string &@expr1073747598 configExcludePath@var2099 :@expr1073747599 configExcludePaths@var2034 ) {
364: if (@expr1073747600 file@var2098 .@expr1073747601 length (@expr1073747602 ) >=@expr1073747603 configExcludePath@var2099 .@expr5780 length (@expr5781 ) &&@expr1073747606 file@var2098 .@expr1073747607 compare (@expr1073747608 0 , configExcludePath@var2099 .@expr5780 length (@expr5781 ) , configExcludePath@var2099 ) ==@expr1073747611 0 ) {
365: return true ;
366: }
367: }
368: return false ;
369: }
370:
|
376:
377: std :: string addEnabled ( const std :: string & str@var2100 ) ;
378:
|
382:
383: bool isEnabled ( const ValueFlow :: Value * value@var2101 , bool inconclusiveCheck@var2102 = false ) const ;
384:
385:
386: bool posix ( ) const {
387: return std ::@expr1073747612 find (@expr1073747613 libraries@var2054 .@expr1073747614 begin (@expr1073747615 ) , libraries@var2054 .@expr5792 end (@expr5793 ) , "posix" ) !=@expr1073747618 libraries@var2054 .@expr5792 end (@expr5793 ) ;
388: }
389:
390:
391: static void terminate ( bool t@var2103 = true ) {
392: Settings ::@expr1073747621 mTerminated@var2020 =@expr1073747622 t@var2103 ;
393: }
394:
395:
396: static bool terminated ( ) {
397: return Settings ::@expr1073747623 mTerminated@var2020 ;
398: }
399:
400: std :: set < std :: string > summaryReturn@var2104 ;
401:
402: void loadSummaries ( ) ;
403: } ;

##file cppcheck-2.8/lib/tokenlist.h

1:
|
31:
32: class Settings ;
33:
34: namespace simplecpp {
35: class TokenList ;
36: }
37:
|
40:
41: class TokenList {
42: public:
43: explicit TokenList ( const Settings * settings@var2105 ) ;
44: ~ TokenList ( ) ;
45:
46: void setSettings ( const Settings * settings@var2106 ) {
47: mSettings@var2141 =@expr1073747624 settings@var2106 ;
48: }
49:
50: const Settings * getSettings ( ) const {
51: return mSettings@var2141 ;
52: }
53:
54:
55: const std :: string & getSourceFilePath ( ) const ;
56:
57:
58: bool isC ( ) const {
59: return mIsC@var2143 ;
60: }
61:
62:
63: bool isCPP ( ) const {
64: return mIsCpp@var2144 ;
65: }
66:
|
70:
71: static void deleteTokens ( Token * tok@var2107 ) ;
72:
73: void addtoken ( const std :: string & str@var2108 , const int lineno@var2109 , const int column@var2110 , const int fileno@var2111 , bool split@var2112 = false ) ;
74: void addtoken ( const std :: string & str@var2113 , const Token * locationTok@var2114 ) ;
75:
76: void addtoken ( const Token * tok@var2115 , const int lineno@var2116 , const int column@var2117 , const int fileno@var2118 ) ;
77: void addtoken ( const Token * tok@var2119 , const Token * locationTok@var2120 ) ;
78: void addtoken ( const Token * tok@var2121 ) ;
79:
80: static void insertTokens ( Token * dest@var2122 , const Token * src@var2123 , int n@var2124 ) ;
81:
|
89:
90: static Token * copyTokens ( Token * dest@var2125 , const Token * first@var2126 , const Token * last@var2127 , bool one_line@var2128 = true ) ;
91:
|
100:
101: bool createTokens ( std :: istream & code@var2129 , const std :: string & file0@var2130 = emptyString@var1 ) ;
102:
103: void createTokens ( simplecpp :: TokenList && tokenList@var2131 ) ;
104:
105:
106: void deallocateTokens ( ) ;
107:
108:
109: int appendFileIfNew ( const std :: string & fileName@var2132 ) ;
110:
111:
112: const Token * front ( ) const {
113: return mTokensFrontBack@var2138 .@expr1073747625 front@var2145 ;
114: }
115: Token * front ( ) {
116: return mTokensFrontBack@var2138 .@expr1073747626 front@var2145 ;
117: }
118:
119:
120: const Token * back ( ) const {
121: return mTokensFrontBack@var2138 .@expr1073747627 back@var2146 ;
122: }
123: Token * back ( ) {
124: return mTokensFrontBack@var2138 .@expr1073747628 back@var2146 ;
125: }
126:
|
131:
132: const std :: vector < std :: string > & getFiles ( ) const {
133: return mFiles@var2139 ;
134: }
135:
136: std :: string getOrigFile ( const Token * tok@var2133 ) const ;
137:
|
142:
143: const std :: string & file ( const Token * tok@var2134 ) const ;
144:
|
149:
150: std :: string fileLine ( const Token * tok@var2135 ) const ;
151:
|
155:
156: unsigned long long calculateChecksum ( ) const ;
157:
|
160:
161: void createAst ( ) const ;
162:
|
166:
167: void validateAst ( ) const ;
168:
|
174:
175: bool validateToken ( const Token * tok@var2136 ) const ;
176:
|
181:
182: void simplifyPlatformTypes ( ) ;
183:
|
187:
188: void simplifyStdType ( ) ;
189:
190: void clangSetOrigFiles ( ) ;
191:
192: bool isKeyword ( const std :: string & str@var2137 ) const ;
193:
194: private:
195:
196:
197: TokenList ( const TokenList & ) ;
198:
199:
200: TokenList & operator= ( const TokenList & ) ;
201:
202: void determineCppC ( ) ;
203:
204:
205: TokensFrontBack mTokensFrontBack@var2138 ;
206:
207:
208: std :: vector < std :: string > mFiles@var2139 ;
209:
210:
211: std :: vector < std :: string > mOrigFiles@var2140 ;
212:
213:
214: const Settings * mSettings@var2141 ;
215:
216: std :: unordered_set < std :: string > mKeywords@var2142 ;
217:
218:
219: bool mIsC@var2143 ;
220: bool mIsCpp@var2144 ;
221: } ;

##file cppcheck-2.8/lib/tokenize.h

1:
|
35:
36: class Settings ;
37: class SymbolDatabase ;
38: class TimerResults ;
39: class Token ;
40: class TemplateSimplifier ;
41: class ErrorLogger ;
42: class Preprocessor ;
43:
44: namespace simplecpp {
45: class TokenList ;
46: }
47:
|
51:
52: class Tokenizer {
53:
54: friend class TestSimplifyTokens ;
55: friend class TestSimplifyTypedef ;
56: friend class TestSimplifyUsing ;
57: friend class TestTokenizer ;
58: friend class SymbolDatabase ;
59: friend class TestSimplifyTemplate ;
60: friend class TemplateSimplifier ;
61:
62:
63: class VariableMap {
64: private:
65: std :: map < std :: string , int > mVariableId@var2147 ;
66: std :: stack < std :: list < std :: pair < std :: string , int > > > mScopeInfo@var2148 ;
67: mutable int mVarId@var2149 ;
68: public:
69: VariableMap ( ) ;
70: void enterScope ( ) ;
71: bool leaveScope ( ) ;
72: void addVariable ( const std :: string & varname@var2150 ) ;
73: bool hasVariable ( const std :: string & varname@var2151 ) const ;
74: std :: map < std :: string , int > :: const_iterator find ( const std :: string & varname@var2152 ) const {
75: return mVariableId@var2147 .@expr1073747629 find (@expr1073747630 varname@var2152 ) ;
76: }
77: std :: map < std :: string , int > :: const_iterator end ( ) const {
78: return mVariableId@var2147 .@expr1073747631 end (@expr1073747632 ) ;
79: }
80: const std :: map < std :: string , int > & map ( ) const {
81: return mVariableId@var2147 ;
82: }
83: int * getVarId ( ) const {
84: return &@expr1073747633 mVarId@var2149 ;
85: }
86: } ;
87:
88:
89: public:
90: Tokenizer ( ) ;
91: Tokenizer ( const Settings * settings@var2153 , ErrorLogger * errorLogger@var2154 ) ;
92: ~ Tokenizer ( ) ;
93:
94: void setTimerResults ( TimerResults * tr@var2155 ) {
95: mTimerResults@var2275 =@expr1073747634 tr@var2155 ;
96: }
97:
98:
99: bool isC ( ) const {
100: return list@var2253 .@expr1073747635 isC (@expr1073747636 ) ;
101: }
102:
103:
104: bool isCPP ( ) const {
105: return list@var2253 .@expr1073747637 isCPP (@expr1073747638 ) ;
106: }
107:
|
113:
114: bool isScopeNoReturn ( const Token * endScopeToken@var2156 , bool * unknown@var2157 = nullptr ) const ;
115:
116: bool createTokens ( std :: istream & code@var2158 , const std :: string & FileName@var2159 ) ;
117: void createTokens ( simplecpp :: TokenList && tokenList@var2160 ) ;
118:
119: bool simplifyTokens1 ( const std :: string & configuration@var2161 ) ;
120:
|
140:
141: bool tokenize ( std :: istream & code@var2162 ,
142: const char FileName@var2163 [ ] ,
143: const std :: string & configuration@var2164 = emptyString@var1 ) ;
144:
145:
146: void setVarId ( ) ;
147: void setVarIdPass1 ( ) ;
148: void setVarIdPass2 ( ) ;
149:
|
158:
159: bool simplifyTokenList1 ( const char FileName@var2165 [ ] ) ;
160:
|
166:
167: bool simplifyTokenList2 ( ) ;
168:
|
173:
174: void simplifyHeadersAndUnusedTemplates ( ) ;
175:
|
178:
179: void removeExtraTemplateKeywords ( ) ;
180:
|
184:
185: void splitTemplateRightAngleBrackets ( bool check@var2166 ) ;
186:
|
202:
203: static void eraseDeadCode ( Token * begin@var2167 , const Token * end@var2168 ) ;
204:
|
209:
210: int sizeOfType ( const Token * type@var2169 ) const ;
211:
|
217:
218: bool isFunctionParameterPassedByValue ( const Token * fpar@var2170 ) const ;
219:
220:
221:
222: void simplifyAssignmentInFunctionCall ( ) ;
223:
224:
225: void simplifyAssignmentBlock ( ) ;
226:
|
231:
232: bool simplifyCalculations ( ) ;
233:
|
238:
239: void simplifyOffsetPointerDereference ( ) ;
240:
|
244:
245: void simplifyOffsetPointerReference ( ) ;
246:
247:
248: void arraySize ( ) ;
249:
250:
251:
252: void simplifyLabelsCaseDefault ( ) ;
253:
254:
255:
256: void simplifyCaseRange ( ) ;
257:
258:
259: void removeMacrosInGlobalScope ( ) ;
260:
261: void addSemicolonAfterUnknownMacro ( ) ;
262:
263:
264: void removePragma ( ) ;
265:
|
269:
270: void removeMacroInClassDef ( ) ;
271:
272:
273: void removeMacroInVarDecl ( ) ;
274:
275:
276: void removeRedundantAssignment ( ) ;
277:
|
281:
282: void simplifyRealloc ( ) ;
283:
284:
285: void sizeofAddParentheses ( ) ;
286:
|
291:
292: bool simplifySizeof ( ) ;
293:
|
297:
298: void simplifyVarDecl ( const bool only_k_r_fpar@var2171 ) ;
299: void simplifyVarDecl ( Token * tokBegin@var2172 , const Token * const tokEnd@var2173 , const bool only_k_r_fpar@var2174 ) ;
300:
|
304:
305: void simplifyInitVar ( ) ;
306: static Token * initVar ( Token * tok@var2175 ) ;
307:
|
313:
314: bool simplifyConstTernaryOp ( ) ;
315:
|
319:
320: void simplifyCompoundAssignment ( ) ;
321:
|
327:
328: void simplifyStaticConst ( ) ;
329:
|
335:
336: void simplifyIfAndWhileAssign ( ) ;
337:
|
341:
342: void simplifyVariableMultipleAssign ( ) ;
343:
|
350:
351: bool simplifyCAlternativeTokens ( ) ;
352:
|
358:
359: void simplifyComma ( ) ;
360:
|
363:
364: bool simplifyAddBraces ( ) ;
365:
|
371:
372: Token * simplifyAddBracesToCommand ( Token * tok@var2176 ) ;
373:
|
379:
380: Token * simplifyAddBracesPair ( Token * tok@var2177 , bool commandWithCondition@var2178 ) ;
381:
382:
383: void simplifyUsingToTypedef ( ) ;
384:
|
392:
393: void simplifyTypedef ( ) ;
394:
395:
396:
397: bool isMemberFunction ( const Token * openParen@var2179 ) const ;
398:
399:
400:
401: bool simplifyUsing ( ) ;
402:
|
405:
406: void simplifyCasts ( ) ;
407:
|
410:
411: void simplifyUndefinedSizeArray ( ) ;
412:
|
419:
420: bool simplifyKnownVariables ( ) ;
421:
|
425:
426: static bool simplifyKnownVariablesGetData ( int varid@var2180 , Token * * _tok2@var2181 , Token * * _tok3@var2182 , std :: string & value@var2183 , int & valueVarId@var2184 , bool & valueIsPointer@var2185 , bool floatvar@var2186 ) ;
427:
|
431:
432: bool simplifyKnownVariablesSimplify ( Token * * tok2@var2187 , Token * tok3@var2188 , int varid@var2189 , const std :: string & structname@var2190 , std :: string & value@var2191 , int valueVarId@var2192 , bool valueIsPointer@var2193 , const Token * const valueToken@var2194 , int indentlevel@var2195 ) const ;
433:
434:
435: void simplifyEmptyNamespaces ( ) ;
436:
|
439:
440: void simplifyFlowControl ( ) ;
441:
442:
443: void simplifyNestedStrcat ( ) ;
444:
445:
446: void elseif ( ) ;
447:
448:
449: void simplifyIfSwitchForInit ( ) ;
450:
|
454:
455: bool simplifyConditions ( ) ;
456:
|
461:
462: bool removeRedundantConditions ( ) ;
463:
|
467:
468: void removeRedundantFor ( ) ;
469:
|
473:
474: void removeRedundantSemicolons ( ) ;
475:
|
479:
480: bool simplifyFunctionReturn ( ) ;
481:
|
485:
486: void simplifyStructDecl ( ) ;
487:
|
496:
497: bool simplifyRedundantParentheses ( ) ;
498:
499: void simplifyCharAt ( ) ;
500:
501:
502: void simplifyReference ( ) ;
503:
|
507:
508: void simplifyFunctionParameters ( ) ;
509:
|
513:
514: void simplifyFunctionTryCatch ( ) ;
515:
|
518:
519: void simplifyTemplates ( ) ;
520:
521: void simplifyDoublePlusAndDoubleMinus ( ) ;
522:
523: void simplifyRedundantConsecutiveBraces ( ) ;
524:
525: void simplifyArrayAccessSyntax ( ) ;
526:
527: void simplifyParameterVoid ( ) ;
528:
529: void fillTypeSizes ( ) ;
530:
531: void combineOperators ( ) ;
532:
533: void combineStringAndCharLiterals ( ) ;
534:
535: void concatenateNegativeNumberAndAnyPositive ( ) ;
536:
537: void simplifyExternC ( ) ;
538:
539: void simplifyRoundCurlyParentheses ( ) ;
540:
541: void simplifyTypeIntrinsics ( ) ;
542:
543: void simplifySQL ( ) ;
544:
545: void checkForEnumsWithTypedef ( ) ;
546:
547: void findComplicatedSyntaxErrorsInTemplates ( ) ;
548:
|
551:
552: void simplifyMathFunctions ( ) ;
553:
|
556:
557: void simplifyMathExpressions ( ) ;
558:
|
564:
565: static std :: string simplifyString ( const std :: string & source@var2196 ) ;
566:
|
572:
573: const Token * isFunctionHead ( const Token * tok@var2197 , const std :: string & endsWith@var2198 ) const ;
574:
|
581:
582: static const Token * isFunctionHead ( const Token * tok@var2199 , const std :: string & endsWith@var2200 , bool cpp@var2201 ) ;
583:
584: void setPreprocessor ( const Preprocessor * preprocessor@var2202 ) {
585: mPreprocessor@var2276 =@expr1073747639 preprocessor@var2202 ;
586: }
587: const Preprocessor * getPreprocessor ( ) const {
588: return mPreprocessor@var2276 ;
589: }
590:
591: bool hasIfdef ( const Token * start@var2203 , const Token * end@var2204 ) const ;
592:
593: private:
594:
|
597:
598: void simplifyWhile0 ( ) ;
599:
|
602:
603: void simplifyErrNoInWhile ( ) ;
604:
|
607:
608: void simplifyFuncInWhile ( ) ;
609:
|
612:
613: void simplifyStd ( ) ;
614:
615:
616: void simplifyPointerToStandardType ( ) ;
617:
618:
619: void simplifyFunctionPointers ( ) ;
620:
|
624:
625: void cppcheckError ( const Token * tok@var2205 ) const ;
626:
|
629:
630: void createLinks ( ) ;
631:
|
634:
635: void createLinks2 ( ) ;
636:
637: public:
638:
639:
640: void syntaxError ( const Token * tok@var2206 , const std :: string & code@var2207 = "" ) const ;
641:
642:
643: void unmatchedToken ( const Token * tok@var2208 ) const ;
644:
645:
646: void syntaxErrorC ( const Token * tok@var2209 , const std :: string & what@var2210 ) const ;
647:
648:
649: void unknownMacroError ( const Token * tok1@var2211 ) const ;
650:
651: void unhandledCharLiteral ( const Token * tok@var2212 , const std :: string & msg@var2213 ) const ;
652:
653: private:
654:
655:
656: void unhandled_macro_class_x_y ( const Token * tok@var2214 ) const ;
657:
658:
659: void checkConfiguration ( ) const ;
660: void macroWithSemicolonError ( const Token * tok@var2215 , const std :: string & macroName@var2216 ) const ;
661:
|
664:
665: void validateC ( ) const ;
666:
|
670:
671: void validate ( ) const ;
672:
673:
674: void reportUnknownMacros ( ) const ;
675:
676:
677: void findGarbageCode ( ) const ;
678:
679:
680: static bool isGarbageExpr ( const Token * start@var2217 , const Token * end@var2218 , bool allowSemicolon@var2219 ) ;
681:
|
684:
685: void simplifyDeclspec ( ) ;
686:
|
689:
690: void simplifyCallingConvention ( ) ;
691:
|
694:
695: void simplifyAttribute ( ) ;
696:
|
699:
700: void simplifyCppcheckAttribute ( ) ;
701:
702:
703: void removeAlignas ( ) ;
704:
705:
706: void simplifySpaceshipOperator ( ) ;
707:
|
710:
711: void simplifyKeyword ( ) ;
712:
|
715:
716: void simplifyAsm ( ) ;
717:
|
720:
721: void simplifyAsm2 ( ) ;
722:
|
725:
726: void simplifyAt ( ) ;
727:
|
730:
731: void simplifyBitfields ( ) ;
732:
|
735:
736: void removeUnnecessaryQualification ( ) ;
737:
|
740:
741: void simplifyNamespaceStd ( ) ;
742:
|
749:
750: void simplifyMicrosoftMemoryFunctions ( ) ;
751:
|
755:
756: void simplifyMicrosoftStringFunctions ( ) ;
757:
|
760:
761: void simplifyBorland ( ) ;
762:
|
765:
766: void simplifyQtSignalsSlots ( ) ;
767:
|
771:
772: void simplifyOperatorName ( ) ;
773:
774:
775: void simplifyOverloadedOperators ( ) ;
776:
|
779:
780: void simplifyCPPAttribute ( ) ;
781:
|
785:
786: bool simplifyStrlen ( ) ;
787:
|
790:
791: void simplifyNamespaceAliases ( ) ;
792:
|
795:
796: void simplifyNestedNamespace ( ) ;
797:
|
802:
803: void simplifyCoroutines ( ) ;
804:
|
807:
808: void prepareTernaryOpForAST ( ) ;
809:
|
812:
813: void reportError ( const Token * tok@var2220 , const Severity :: SeverityType severity@var2221 , const std :: string & id@var2222 , const std :: string & msg@var2223 , bool inconclusive@var2224 = false ) const ;
814: void reportError ( const std :: list < const Token * > & callstack@var2225 , Severity :: SeverityType severity@var2226 , const std :: string & id@var2227 , const std :: string & msg@var2228 , bool inconclusive@var2229 = false ) const ;
815:
816: bool duplicateTypedef ( Token * * tokPtr@var2230 , const Token * name@var2231 , const Token * typeDef@var2232 ) const ;
817:
818: void unsupportedTypedef ( const Token * tok@var2233 ) const ;
819:
820: void setVarIdClassDeclaration ( const Token * const startToken@var2234 ,
821: const VariableMap & variableMap@var2235 ,
822: const int scopeStartVarId@var2236 ,
823: std :: map < int , std :: map < std :: string , int > > & structMembers@var2237 ) ;
824:
825: void setVarIdStructMembers ( Token * * tok1@var2238 ,
826: std :: map < int , std :: map < std :: string , int > > & structMembers@var2239 ,
827: int * varId@var2240 ) const ;
828:
829: void setVarIdClassFunction ( const std :: string & classname@var2241 ,
830: Token * const startToken@var2242 ,
831: const Token * const endToken@var2243 ,
832: const std :: map < std :: string , int > & varlist@var2244 ,
833: std :: map < int , std :: map < std :: string , int > > & structMembers@var2245 ,
834: int * varId_@var2246 ) ;
835:
|
839:
840: void simplifyReturnStrncat ( ) ;
841:
|
844:
845: void printUnknownTypes ( ) const ;
846:
847:
848: static const Token * findSQLBlockEnd ( const Token * tokSQLStart@var2247 ) ;
849:
850: bool operatorEnd ( const Token * tok@var2248 ) const ;
851:
852: public:
853:
854:
855: bool codeWithTemplates ( ) const {
856: return mCodeWithTemplates@var2274 ;
857: }
858:
859:
860: void setSettings ( const Settings * settings@var2249 ) {
861: mSettings@var2260 =@expr1073747640 settings@var2249 ;
862: list@var2253 .@expr1073747641 setSettings (@expr1073747642 settings@var2249 ) ;
863: }
864:
865: const SymbolDatabase * getSymbolDatabase ( ) const {
866: return mSymbolDatabase@var2262 ;
867: }
868: void createSymbolDatabase ( ) ;
869: void deleteSymbolDatabase ( ) ;
870:
|
875:
876: void printDebugOutput ( int simplification@var2250 ) const ;
877:
878: void dump ( std :: ostream & out@var2251 ) const ;
879:
880: Token * deleteInvalidTypedef ( Token * typeDef@var2252 ) ;
881:
|
885:
886: int varIdCount ( ) const {
887: return mVarId@var2272 ;
888: }
889:
|
892:
893: TokenList list@var2253 ;
894:
895: const Token * tokens ( ) const {
896: return list@var2253 .@expr1073747643 front (@expr1073747644 ) ;
897: }
898:
|
903:
904: static bool isZeroNumber ( const std :: string & s@var2254 ) ;
905:
|
910:
911: static bool isOneNumber ( const std :: string & s@var2255 ) ;
912:
|
917:
918: static bool isTwoNumber ( const std :: string & s@var2256 ) ;
919:
|
925:
926: static const Token * startOfExecutableScope ( const Token * tok@var2257 ) ;
927:
|
931:
932: static bool isMaxTime ( ) {
933: return false ;
934:
935: }
936:
937: const Settings * getSettings ( ) const {
938: return mSettings@var2260 ;
939: }
940:
941: void calculateScopes ( ) ;
942:
943:
944: Tokenizer ( const Tokenizer & ) = delete ;
945:
946:
947: Tokenizer & operator= ( const Tokenizer & ) = delete ;
948:
949: private:
950: Token * processFunc ( Token * tok2@var2258 , bool inOperator@var2259 ) const ;
951:
|
955:
956: int newVarId ( ) {
957: return ++@expr1073747645 mVarId@var2272 ;
958: }
959:
960:
961: void setPodTypes ( ) ;
962:
963:
964: const Settings * mSettings@var2260 ;
965:
966:
967: ErrorLogger * const mErrorLogger@var2261 ;
968:
969:
970: SymbolDatabase * mSymbolDatabase@var2262 ;
971:
972: TemplateSimplifier * mTemplateSimplifier@var2263 ;
973:
974:
975:
976: std :: string mConfiguration@var2264 ;
977:
978:
979: std :: map < std :: string , int > mTypeSize@var2265 ;
980:
981: struct TypedefInfo {
982: std :: string name@var2266 ;
983: std :: string filename@var2267 ;
984: int lineNumber@var2268 ;
985: int column@var2269 ;
986: bool used@var2270 ;
987: } ;
988: std :: vector < TypedefInfo > mTypedefInfo@var2271 ;
989:
990:
991: int mVarId@var2272 ;
992:
993:
994: int mUnnamedCount@var2273 ;
995:
|
999:
1000: bool mCodeWithTemplates@var2274 ;
1001:
|
1004:
1005: TimerResults * mTimerResults@var2275 ;
1006:
|
1011:
1012: const Preprocessor * mPreprocessor@var2276 ;
1013: } ;

##file cppcheck-2.8/lib/symboldatabase.cpp

1:
|
49:
50: SymbolDatabase :: SymbolDatabase ( const Tokenizer * tokenizer@var2277 , const Settings * settings@var2278 , ErrorLogger * errorLogger@var2279 )
51: : mTokenizer@var1403 ( tokenizer@var2277 ) , mSettings@var1404 ( settings@var2278 ) , mErrorLogger@var1405 ( errorLogger@var2279 )
52: {
53: if (@expr1073747646 !@expr1073747647 tokenizer@var2277 ||@expr1073747648 !@expr1073747649 tokenizer@var2277 .@expr1073747650 tokens (@expr1073747651 ) ) {
54: return ; }
55:
56: mIsCpp@var1408 =@expr1073747652 isCPP (@expr1073747653 ) ;
57:
58: if (@expr1073747654 mSettings@var1404 .@expr5831 defaultSign@var3819 ==@expr1073747656 's' ||@expr1073747657 mSettings@var1404 .@expr5831 defaultSign@var3819 ==@expr1073747659 'S' ) {
59: mDefaultSignedness@var1409 =@expr1073747660 ValueType ::@expr1073747661 SIGNED ; }
60: else { if (@expr1073747662 mSettings@var1404 .@expr5831 defaultSign@var3819 ==@expr1073747664 'u' ||@expr1073747665 mSettings@var1404 .@expr5831 defaultSign@var3819 ==@expr1073747667 'U' ) {
61: mDefaultSignedness@var1409 =@expr1073747668 ValueType ::@expr1073747669 UNSIGNED ; }
62: else {
63: mDefaultSignedness@var1409 =@expr1073747670 ValueType ::@expr1073747671 UNKNOWN_SIGN ; } }
64:
65: createSymbolDatabaseFindAllScopes (@expr1073747672 ) ;
66: createSymbolDatabaseClassInfo (@expr1073747673 ) ;
67: createSymbolDatabaseVariableInfo (@expr1073747674 ) ;
68: createSymbolDatabaseCopyAndMoveConstructors (@expr1073747675 ) ;
69: createSymbolDatabaseFunctionScopes (@expr1073747676 ) ;
70: createSymbolDatabaseClassAndStructScopes (@expr1073747677 ) ;
71: createSymbolDatabaseFunctionReturnTypes (@expr1073747678 ) ;
72: createSymbolDatabaseNeedInitialization (@expr1073747679 ) ;
73: createSymbolDatabaseVariableSymbolTable (@expr1073747680 ) ;
74: createSymbolDatabaseSetScopePointers (@expr1073747681 ) ;
75: createSymbolDatabaseSetVariablePointers (@expr1073747682 ) ;
76: setValueTypeInTokenList (@expr5859 false ) ;
77: createSymbolDatabaseSetTypePointers (@expr1073747684 ) ;
78: createSymbolDatabaseSetFunctionPointers (@expr1073747685 true ) ;
79: createSymbolDatabaseSetSmartPointerType (@expr1073747686 ) ;
80: setValueTypeInTokenList (@expr5859 false ) ;
81: createSymbolDatabaseEnums (@expr1073747688 ) ;
82: createSymbolDatabaseEscapeFunctions (@expr1073747689 ) ;
83: createSymbolDatabaseIncompleteVars (@expr1073747690 ) ;
84: createSymbolDatabaseExprIds (@expr1073747691 ) ;
85: }
86:
87: static const Token * skipScopeIdentifiers ( const Token * tok@var2280 )
88: {
89: if (@expr1073747692 Token ::@expr5869 Match (@expr1073747694 tok@var2280 , ":: %name%" ) ) {
90: tok@var2280 =@expr1073747695 tok@var2280 .@expr1073747696 next (@expr1073747697 ) ; }
91: while (@expr1073747698 Token ::@expr5869 Match (@expr1073747700 tok@var2280 , "%name% ::" ) ||@expr1073747701
92: (@expr1073747702 Token ::@expr5869 Match (@expr1073747704 tok@var2280 , "%name% <" ) &&@expr1073747705 Token ::@expr5869 Match (@expr1073747707 tok@var2280 .@expr5884 linkAt (@expr5885 1 ) , ">|>> ::" ) ) ) {
93: if (@expr1073747710 tok@var2280 .@expr1073747711 strAt (@expr1073747712 1 ) ==@expr1073747713 "::" ) {
94: tok@var2280 =@expr1073747714 tok@var2280 .@expr1073747715 tokAt (@expr1073747716 2 ) ; }
95: else {
96: tok@var2280 =@expr1073747717 tok@var2280 .@expr5884 linkAt (@expr5885 1 ) .@expr1073747720 tokAt (@expr1073747721 2 ) ; }
97: }
98:
99: return tok@var2280 ;
100: }
101:
102: static bool isExecutableScope ( const Token * tok@var2281 )
103: {
104: if (@expr1073747722 !@expr1073747723 Token ::@expr5900 simpleMatch (@expr1073747725 tok@var2281 , "{" ) ) {
105: return false ; }
106: const Token * tok2@var2282 ; tok2@var2282 =@expr1073747726 tok@var2281 .@expr1073747727 link (@expr1073747728 ) .@expr1073747729 previous (@expr1073747730 ) ;
107: if (@expr1073747731 Token ::@expr5900 simpleMatch (@expr1073747733 tok2@var2282 , "; }" ) ) {
108: return true ; }
109: if (@expr1073747734 tok2@var2282 ==@expr1073747735 tok@var2281 ) {
110: return false ; }
111: if (@expr1073747736 Token ::@expr5900 simpleMatch (@expr1073747738 tok2@var2282 , "} }" ) ) {
112: const Token * startTok@var2283 ; startTok@var2283 =@expr1073747739 tok2@var2282 .@expr1073747740 link (@expr1073747741 ) ;
113: if (@expr1073747742 Token ::@expr5919 Match (@expr1073747744 startTok@var2283 .@expr5921 previous (@expr5922 ) , "do|try|else {" ) ) {
114: return true ; }
115: if (@expr1073747747 Token ::@expr5919 Match (@expr1073747749 startTok@var2283 .@expr5921 previous (@expr5922 ) , ")|] {" ) ) {
116: return !@expr1073747752 findLambdaStartToken (@expr1073747753 tok2@var2282 ) ; }
117: return isExecutableScope (@expr1073747754 startTok@var2283 ) ;
118: }
119: return false ;
120: }
121:
122: void SymbolDatabase :: createSymbolDatabaseFindAllScopes ( )
123: {
124:
125: scopeList@var1331 .@expr5934 emplace_back (@expr1073747759 this@expr5936 , nullptr , nullptr ) ;
126:
127:
128: Scope * scope@var2284 ; scope@var2284 =@expr1073747761 &@expr5938 scopeList@var1331 .@expr5939 back (@expr5940 ) ;
129:
130:
131: std ::@expr1073747765 stack < std ::@expr5942 pair < const Token *@expr5943 , const Scope *@expr5943 > > endInitList@var2285 ;
132: auto inInitList@var2286 ; inInitList@var2286 =@expr1073747769 [@expr1073747770 &@expr1073747771 ] {
133: if (@expr1073747772 endInitList@var2285 .@expr1073747773 empty (@expr1073747774 ) ) {
134: return false ; }
135: return endInitList@var2285 .@expr5951 top (@expr5952 ) .@expr1073747777 second@expr1073747755 ==@expr1073747778 scope@var2284 ;
136: } ;
137:
138:
139: std ::@expr1073747779 map < const Scope *@expr5943 , AccessControl > access@var2287 ;
140:
141:
142: for (@expr1073747781 const Token *@expr5943 tok@var2288 =@expr1073747783 mTokenizer@var1403 .@expr1073747784 tokens (@expr1073747785 ) ; tok@var2288 ; tok@var2288 =@expr1073747786 tok@var2288 ?@expr1073747787 tok@var2288 .@expr5964 next (@expr5965 ) :@expr1073747790 nullptr ) {
143:
144: if (@expr1073747791 mErrorLogger@var1405 ) {
145: mErrorLogger@var1405 .@expr1073747792 reportProgress (@expr1073747793 mTokenizer@var1403 .@expr1073747794 list@var3820 .@expr1073747795 getSourceFilePath (@expr1073747796 ) ,
146: "SymbolDatabase" ,
147: tok@var2288 .@expr1073747797 progressValue (@expr1073747798 ) ) ; }
148:
149: if (@expr1073747799 (@expr1073747800 mTokenizer@var1403 .@expr5977 isCPP (@expr5978 ) &&@expr5979 tok@var2288 .@expr5980 isKeyword (@expr5981 ) &&@expr1073747806
150: (@expr1073747807 (@expr1073747808 Token ::@expr5985 Match (@expr1073747810 tok@var2288 , "class|struct|union|namespace ::| %name% final| {|:|::|<" ) &&@expr1073747811
151: !@expr1073747812 Token ::@expr5985 Match (@expr1073747814 tok@var2288 .@expr5991 previous (@expr5992 ) , "new|friend|const|enum|typedef|mutable|volatile|using|)|(|<" ) ) ||@expr1073747817
152: (@expr1073747818 Token ::@expr5985 Match (@expr1073747820 tok@var2288 , "enum class| %name% {" ) ||@expr1073747821
153: Token ::@expr5985 Match (@expr1073747823 tok@var2288 , "enum class| %name% : %name% {" ) ) ) )
154: ||@expr1073747824 (@expr1073747825 mTokenizer@var1403 .@expr1073747826 isC (@expr1073747827 ) &&@expr1073747828 tok@var2288 .@expr5980 isKeyword (@expr5981 ) &&@expr1073747831 Token ::@expr5985 Match (@expr1073747833 tok@var2288 , "struct|union|enum %name% {" ) ) ) {
155: const Token * tok2@var2289 ; tok2@var2289 =@expr1073747834 tok@var2288 .@expr6011 tokAt (@expr6012 2 ) ;
156:
157: if (@expr1073747837 tok@var2288 .@expr6014 strAt (@expr6015 1 ) ==@expr1073747840 "::" ) {
158: tok2@var2289 =@expr1073747841 tok2@var2289 .@expr6018 next (@expr6019 ) ; }
159: else { if (@expr1073747844 mTokenizer@var1403 .@expr5977 isCPP (@expr5978 ) &&@expr1073747847 tok@var2288 .@expr6014 strAt (@expr6015 1 ) ==@expr6026 "class" ) {
160: tok2@var2289 =@expr1073747851 tok2@var2289 .@expr6018 next (@expr6019 ) ; } }
161:
162: while (@expr6030 Token ::@expr5985 Match (@expr6032 tok2@var2289 , ":: %name%" ) ) {
163: tok2@var2289 =@expr1073747857 tok2@var2289 .@expr6034 tokAt (@expr6035 2 ) ; }
164: while (@expr1073747860 Token ::@expr5985 Match (@expr1073747862 tok2@var2289 , "%name% :: %name%" ) ) {
165: tok2@var2289 =@expr1073747863 tok2@var2289 .@expr6034 tokAt (@expr6035 2 ) ; }
166:
167:
168: while (@expr1073747866 tok2@var2289 &&@expr1073747867 tok2@var2289 .@expr6044 str (@expr6045 ) ==@expr1073747870 "<" &&@expr1073747871 tok2@var2289 .@expr6048 link (@expr6049 ) ) {
169: tok2@var2289 =@expr1073747874 tok2@var2289 .@expr6048 link (@expr6049 ) .@expr6053 next (@expr6054 ) ;
170: while (@expr6030 Token ::@expr5985 Match (@expr6032 tok2@var2289 , ":: %name%" ) ) {
171: tok2@var2289 =@expr1073747882 tok2@var2289 .@expr6034 tokAt (@expr6035 2 ) ; }
172: }
173:
174:
175: if (@expr1073747885 mTokenizer@var1403 .@expr5977 isCPP (@expr5978 ) &&@expr1073747888 Token ::@expr6065 simpleMatch (@expr1073747890 tok2@var2289 , "final" ) ) {
176: tok2@var2289 =@expr1073747891 tok2@var2289 .@expr6018 next (@expr6019 ) ; }
177:
178:
179: if (@expr1073747894 !@expr1073747895 Token ::@expr5985 Match (@expr1073747897 tok2@var2289 , "{|:" ) ) {
180:
181: if (@expr1073747898 tok2@var2289 &&@expr1073747899 tok2@var2289 .@expr6018 next (@expr6019 ) ) {
182: if (@expr1073747902 tok2@var2289 .@expr6018 next (@expr6019 ) .@expr1073747905 str (@expr1073747906 ) ==@expr1073747907 ";" ) {
183: tok@var2288 =@expr1073747908 tok2@var2289 .@expr6018 next (@expr6019 ) ; }
184: else { if (@expr1073747911 Token ::@expr6065 simpleMatch (@expr1073747913 tok2@var2289 .@expr6018 next (@expr6019 ) , "= {" ) &&@expr1073747916
185: Token ::@expr6065 simpleMatch (@expr1073747918 tok2@var2289 .@expr6095 linkAt (@expr6096 2 ) , "} ;" ) ) {
186: tok@var2288 =@expr1073747921 tok2@var2289 .@expr6095 linkAt (@expr6096 2 ) .@expr1073747924 next (@expr1073747925 ) ; }
187: else { if (@expr1073747926 Token ::@expr5985 Match (@expr1073747928 tok2@var2289 .@expr6018 next (@expr6019 ) , "(|{" ) &&@expr1073747931
188: tok2@var2289 .@expr6018 next (@expr6019 ) .@expr6110 link (@expr6111 ) .@expr1073747936 strAt (@expr1073747937 1 ) ==@expr1073747938 ";" ) {
189: tok@var2288 =@expr1073747939 tok2@var2289 .@expr6018 next (@expr6019 ) .@expr6110 link (@expr6111 ) .@expr1073747944 next (@expr1073747945 ) ; }
190:
191: else { if (@expr1073747946 Token ::@expr5985 Match (@expr1073747948 tok2@var2289 , "*|&|>" ) ) {
192: continue ; }
193: else { if (@expr1073747949 Token ::@expr5985 Match (@expr1073747951 tok2@var2289 , "%name% (" ) &&@expr1073747952 mTokenizer@var1403 .@expr6129 isFunctionHead (@expr1073747954 tok2@var2289 .@expr6018 next (@expr6019 ) , "{;" ) ) {
194: continue ; }
195: else { if (@expr1073747957 Token ::@expr5985 Match (@expr1073747959 tok2@var2289 , "%name% [|=" ) ) {
196: continue ; }
197:
198: else { if (@expr1073747960 Token ::@expr6065 simpleMatch (@expr6138 tok2@var2289 , ";" ) &&@expr1073747963
199: Token ::@expr5985 Match (@expr1073747965 tok@var2288 .@expr5991 previous (@expr5992 ) , "template|> class|struct" ) ) {
200: tok@var2288 =@expr1073747968 tok2@var2289 ;
201: continue ;
202: }
203:
204: else { if (@expr1073747969 Token ::@expr6065 simpleMatch (@expr6138 tok2@var2289 , ";" ) &&@expr1073747972
205: Token ::@expr5985 Match (@expr1073747974 tok@var2288 , "class|struct|union" ) ) {
206:
207: tok@var2288 =@expr1073747975 tok2@var2289 ;
208: continue ;
209: }
210:
211: else { if (@expr1073747976 Token ::@expr6065 simpleMatch (@expr1073747978 tok2@var2289 , "(" ) &&@expr1073747979
212: Token ::@expr6065 simpleMatch (@expr1073747981 tok2@var2289 .@expr6048 link (@expr6049 ) , ") ;" ) ) {
213: tok@var2288 =@expr1073747984 tok2@var2289 .@expr6048 link (@expr6049 ) .@expr6053 next (@expr6054 ) ;
214: continue ;
215: } else {
216: throw InternalError (@expr1073747989 tok2@var2289 , "SymbolDatabase bailout; unhandled code" , InternalError ::@expr1073747990 SYNTAX ) ; } } } } } } } } }
217: continue ;
218: }
219: break ;
220: }
221:
222: const Token * name@var2290 ; name@var2290 =@expr1073747991 tok@var2288 .@expr5964 next (@expr5965 ) ;
223:
224: if (@expr1073747994 name@var2290 .@expr1073747995 str (@expr1073747996 ) ==@expr1073747997 "class" &&@expr1073747998 name@var2290 .@expr1073747999 strAt (@expr1073748000 -1 ) ==@expr1073748001 "enum" ) {
225: name@var2290 =@expr1073748002 name@var2290 .@expr1073748003 next (@expr1073748004 ) ; }
226:
227: Scope * new_scope@var2291 ; new_scope@var2291 =@expr1073748005 findScope (@expr1073748006 name@var2290 , scope@var2284 ) ;
228:
229: if (@expr1073748007 new_scope@var2291 ) {
230:
231: if (@expr6184 new_scope@var2291 .@expr6185 isClassOrStruct (@expr6186 ) ) {
232:
233: if (@expr1073748011 !@expr1073748012 new_scope@var2291 .@expr6189 definedType@var2292 ) {
234: mTokenizer@var1403 .@expr6190 syntaxError (@expr1073748015 nullptr ) ; }
235: tok2@var2289 =@expr1073748016 new_scope@var2291 .@expr6189 definedType@var2292 .@expr6194 initBaseInfo (@expr6195 tok@var2288 , tok2@var2289 ) ;
236:
237: if (@expr6196 !@expr6197 tok2@var2289 ) {
238: break ;
239: }
240: }
241:
242:
243: if (@expr1073748022 mTokenizer@var1403 .@expr5977 isCPP (@expr5978 ) &&@expr1073748025 tok@var2288 .@expr6202 str (@expr6203 ) ==@expr6204 "class" ) {
244: access@var2287 [@expr6205 new_scope@var2291 ] =@expr1073748030 AccessControl ::@expr6207 Private ;
245: new_scope@var2291 .@expr6208 type@var2293 =@expr1073748033 Scope ::@expr1073748034 eClass ;
246: } else { if (@expr1073748035 tok@var2288 .@expr6202 str (@expr6203 ) ==@expr6214 "struct" ) {
247: access@var2287 [@expr6205 new_scope@var2291 ] =@expr1073748040 AccessControl ::@expr6217 Public ;
248: new_scope@var2291 .@expr6208 type@var2293 =@expr1073748043 Scope ::@expr1073748044 eStruct ;
249: } }
250:
251: new_scope@var2291 .@expr6221 classDef@var2294 =@expr1073748046 tok@var2288 ;
252: new_scope@var2291 .@expr6223 setBodyStartEnd (@expr6224 tok2@var2289 ) ;
253:
254: if (@expr6225 !@expr6226 new_scope@var2291 .@expr6227 bodyEnd@var2295 ) {
255: mTokenizer@var1403 .@expr6190 syntaxError (@expr6229 tok@var2288 ) ;
256: }
257: scope@var2284 =@expr1073748054 new_scope@var2291 ;
258: tok@var2288 =@expr1073748055 tok2@var2289 ;
259: } else {
260: scopeList@var1331 .@expr5934 emplace_back (@expr6233 this@expr5936 , tok@var2288 , scope@var2284 ) ;
261: new_scope@var2291 =@expr1073748058 &@expr5938 scopeList@var1331 .@expr5939 back (@expr5940 ) ;
262:
263: if (@expr1073748062 tok@var2288 .@expr6202 str (@expr6203 ) ==@expr6204 "class" ) {
264: access@var2287 [@expr6205 new_scope@var2291 ] =@expr1073748067 AccessControl ::@expr6207 Private ; }
265: else { if (@expr1073748069 tok@var2288 .@expr6202 str (@expr6203 ) ==@expr6214 "struct" ||@expr1073748073 tok@var2288 .@expr6202 str (@expr6203 ) ==@expr1073748076 "union" ) {
266: access@var2287 [@expr6205 new_scope@var2291 ] =@expr1073748078 AccessControl ::@expr6217 Public ; } }
267:
268:
269: if (@expr1073748080 new_scope@var2291 .@expr1073748081 isClassOrStructOrUnion (@expr1073748082 ) ||@expr1073748083 new_scope@var2291 .@expr6208 type@var2293 ==@expr6261 Scope ::@expr6262 eEnum ) {
270: Type * new_type@var2296 ; new_type@var2296 =@expr1073748087 findType (@expr1073748088 name@var2290 , scope@var2284 ) ;
271: if (@expr1073748089 !@expr1073748090 new_type@var2296 ) {
272: typeList@var1334 .@expr6267 emplace_back (@expr1073748092 new_scope@var2291 .@expr6221 classDef@var2294 , new_scope@var2291 , scope@var2284 ) ;
273: new_type@var2296 =@expr1073748094 &@expr6271 typeList@var1334 .@expr6272 back (@expr6273 ) ;
274: scope@var2284 .@expr6274 definedTypesMap@var2297 [@expr1073748099 new_type@var2296 .@expr1073748100 name (@expr1073748101 ) ] =@expr1073748102 new_type@var2296 ;
275: } else {
276: new_type@var2296 .@expr1073748103 classScope@var2298 =@expr1073748104 new_scope@var2291 ; }
277: new_scope@var2291 .@expr6189 definedType@var2292 =@expr1073748106 new_type@var2296 ;
278: }
279:
280:
281: if (@expr6184 new_scope@var2291 .@expr6185 isClassOrStruct (@expr6186 ) ) {
282:
283: tok2@var2289 =@expr1073748110 new_scope@var2291 .@expr6189 definedType@var2292 .@expr6194 initBaseInfo (@expr6195 tok@var2288 , tok2@var2289 ) ;
284:
285:
286: if (@expr6196 !@expr6197 tok2@var2289 ) {
287: mTokenizer@var1403 .@expr6190 syntaxError (@expr6229 tok@var2288 ) ;
288: }
289: } else { if (@expr6294 new_scope@var2291 .@expr6208 type@var2293 ==@expr6261 Scope ::@expr6262 eEnum ) {
290: if (@expr1073748122 tok2@var2289 .@expr6044 str (@expr6045 ) ==@expr1073748125 ":" ) {
291: tok2@var2289 =@expr1073748126 tok2@var2289 .@expr6034 tokAt (@expr6035 2 ) ; }
292: } }
293:
294: new_scope@var2291 .@expr6223 setBodyStartEnd (@expr6224 tok2@var2289 ) ;
295:
296:
297: if (@expr6225 !@expr6226 new_scope@var2291 .@expr6227 bodyEnd@var2295 ) {
298: mTokenizer@var1403 .@expr6190 syntaxError (@expr6229 tok@var2288 ) ;
299: }
300:
301: if (@expr6294 new_scope@var2291 .@expr6208 type@var2293 ==@expr6261 Scope ::@expr6262 eEnum ) {
302: tok2@var2289 =@expr1073748140 new_scope@var2291 .@expr1073748141 addEnum (@expr1073748142 tok@var2288 , mTokenizer@var1403 .@expr5977 isCPP (@expr5978 ) ) ;
303: scope@var2284 .@expr6321 nestedList@var2299 .@expr6322 push_back (@expr6323 new_scope@var2291 ) ;
304:
305: if (@expr6196 !@expr6197 tok2@var2289 ) {
306: mTokenizer@var1403 .@expr6190 syntaxError (@expr6229 tok@var2288 ) ; }
307: } else {
308:
309: scope@var2284 .@expr6321 nestedList@var2299 .@expr6322 push_back (@expr6323 new_scope@var2291 ) ;
310: scope@var2284 =@expr1073748155 new_scope@var2291 ;
311: }
312:
313: tok@var2288 =@expr1073748156 tok2@var2289 ;
314: }
315: }
316:
317:
318: else { if (@expr1073748157 mTokenizer@var1403 .@expr5977 isCPP (@expr5978 ) &&@expr5979 tok@var2288 .@expr5980 isKeyword (@expr5981 ) &&@expr1073748163
319: Token ::@expr5985 Match (@expr1073748165 tok@var2288 , "namespace %name% %type% (" ) &&@expr1073748166
320: tok@var2288 .@expr6011 tokAt (@expr6012 2 ) .@expr1073748169 isUpperCaseName (@expr1073748170 ) &&@expr1073748171
321: Token ::@expr6065 simpleMatch (@expr1073748173 tok@var2288 .@expr6350 linkAt (@expr6351 3 ) , ") {" ) ) {
322: scopeList@var1331 .@expr5934 emplace_back (@expr6233 this@expr5936 , tok@var2288 , scope@var2284 ) ;
323:
324: Scope * new_scope@var2300 ; new_scope@var2300 =@expr1073748178 &@expr5938 scopeList@var1331 .@expr5939 back (@expr5940 ) ;
325: access@var2287 [@expr1073748182 new_scope@var2300 ] =@expr1073748183 AccessControl ::@expr6217 Public ;
326:
327: const Token * tok2@var2301 ; tok2@var2301 =@expr1073748185 tok@var2288 .@expr6350 linkAt (@expr6351 3 ) .@expr1073748188 next (@expr1073748189 ) ;
328:
329: new_scope@var2300 .@expr1073748190 setBodyStartEnd (@expr1073748191 tok2@var2301 ) ;
330:
331:
332: if (@expr1073748192 !@expr1073748193 new_scope@var2300 .@expr1073748194 bodyEnd@var2302 ) {
333: scopeList@var1331 .@expr6371 pop_back (@expr6372 ) ;
334: break ;
335: }
336:
337:
338: scope@var2284 .@expr6321 nestedList@var2299 .@expr6322 push_back (@expr1073748199 new_scope@var2300 ) ;
339: scope@var2284 =@expr1073748200 &@expr5938 scopeList@var1331 .@expr5939 back (@expr5940 ) ;
340:
341: tok@var2288 =@expr1073748204 tok2@var2301 ;
342: }
343:
344:
345: else { if (@expr1073748205 tok@var2288 .@expr5980 isKeyword (@expr5981 ) &&@expr1073748208 Token ::@expr5985 Match (@expr1073748210 tok@var2288 , "class|struct|union %name% ;" ) &&@expr1073748211
346: tok@var2288 .@expr6014 strAt (@expr6389 -1 ) !=@expr1073748214 "friend" ) {
347: if (@expr1073748215 !@expr6392 findType (@expr6393 tok@var2288 .@expr5964 next (@expr5965 ) , scope@var2284 ) ) {
348:
349: typeList@var1334 .@expr6267 emplace_back (@expr6397 tok@var2288 , nullptr , scope@var2284 ) ;
350: Type * new_type@var2303 ; new_type@var2303 =@expr1073748222 &@expr6271 typeList@var1334 .@expr6272 back (@expr6273 ) ;
351: scope@var2284 .@expr6274 definedTypesMap@var2297 [@expr1073748227 new_type@var2303 .@expr1073748228 name (@expr1073748229 ) ] =@expr1073748230 new_type@var2303 ;
352: }
353: tok@var2288 =@expr1073748231 tok@var2288 .@expr6011 tokAt (@expr6012 2 ) ;
354: }
355:
356:
357: else { if (@expr1073748234 mTokenizer@var1403 .@expr5977 isCPP (@expr5978 ) &&@expr5979 tok@var2288 .@expr5980 isKeyword (@expr5981 ) &&@expr1073748240 Token ::@expr5985 Match (@expr1073748242 tok@var2288 , "using namespace ::| %type% ;|::" ) ) {
358: Scope ::@expr1073748243 UsingInfo using_info@var2304 ;
359:
360: using_info@var2304 .@expr1073748244 start@var2305 =@expr1073748245 tok@var2288 ;
361: using_info@var2304 .@expr1073748246 scope@var2306 =@expr1073748247 findNamespace (@expr1073748248 tok@var2288 .@expr6011 tokAt (@expr6012 2 ) , scope@var2284 ) ;
362:
363: scope@var2284 .@expr1073748251 usingList@var2307 .@expr1073748252 push_back (@expr1073748253 using_info@var2304 ) ;
364:
365:
366: if (@expr1073748254 tok@var2288 .@expr6014 strAt (@expr1073748256 2 ) ==@expr1073748257 "::" ) {
367: tok@var2288 =@expr1073748258 tok@var2288 .@expr6011 tokAt (@expr1073748260 4 ) ; }
368: else {
369: tok@var2288 =@expr1073748261 tok@var2288 .@expr6011 tokAt (@expr6439 3 ) ; }
370:
371:
372: while (@expr1073748264 Token ::@expr5985 Match (@expr1073748266 tok@var2288 , "%type% ::" ) ) {
373: tok@var2288 =@expr1073748267 tok@var2288 .@expr6011 tokAt (@expr6012 2 ) ; }
374: }
375:
376:
377: else { if (@expr1073748270 mTokenizer@var1403 .@expr5977 isCPP (@expr5978 ) &&@expr5979 tok@var2288 .@expr5980 isKeyword (@expr5981 ) &&@expr1073748276 Token ::@expr5985 Match (@expr1073748278 tok@var2288 , "using %name% =" ) ) {
378: if (@expr1073748279 tok@var2288 .@expr6014 strAt (@expr6389 -1 ) !=@expr1073748282 ">" &&@expr1073748283 !@expr6392 findType (@expr6393 tok@var2288 .@expr5964 next (@expr5965 ) , scope@var2284 ) ) {
379:
380: typeList@var1334 .@expr6267 emplace_back (@expr6397 tok@var2288 , nullptr , scope@var2284 ) ;
381: Type * new_type@var2308 ; new_type@var2308 =@expr1073748290 &@expr6271 typeList@var1334 .@expr6272 back (@expr6273 ) ;
382: scope@var2284 .@expr6274 definedTypesMap@var2297 [@expr1073748295 new_type@var2308 .@expr1073748296 name (@expr1073748297 ) ] =@expr1073748298 new_type@var2308 ;
383: }
384:
385: tok@var2288 =@expr1073748299 tok@var2288 .@expr6011 tokAt (@expr6439 3 ) ;
386:
387: while (@expr1073748302 tok@var2288 &&@expr1073748303 tok@var2288 .@expr6202 str (@expr6203 ) !=@expr1073748306 ";" ) {
388: tok@var2288 =@expr1073748307 tok@var2288 .@expr5964 next (@expr5965 ) ; }
389: }
390:
391:
392: else { if (@expr1073748310 tok@var2288 .@expr5980 isKeyword (@expr5981 ) &&@expr1073748313 Token ::@expr5985 Match (@expr6491 tok@var2288 , "struct|union {" ) &&@expr1073748316
393: Token ::@expr5985 Match (@expr1073748318 tok@var2288 .@expr5964 next (@expr5965 ) .@expr6497 link (@expr6498 ) , "} *|&| %name% ;|[|=" ) ) {
394: scopeList@var1331 .@expr5934 emplace_back (@expr6233 this@expr5936 , tok@var2288 , scope@var2284 ) ;
395:
396: Scope * new_scope@var2309 ; new_scope@var2309 =@expr1073748325 &@expr5938 scopeList@var1331 .@expr5939 back (@expr5940 ) ;
397: access@var2287 [@expr1073748329 new_scope@var2309 ] =@expr1073748330 AccessControl ::@expr6217 Public ;
398:
399: const Token * varNameTok@var2310 ; varNameTok@var2310 =@expr1073748332 tok@var2288 .@expr5964 next (@expr5965 ) .@expr6497 link (@expr6498 ) .@expr6513 next (@expr6514 ) ;
400: if (@expr1073748339 varNameTok@var2310 .@expr6516 str (@expr6517 ) ==@expr1073748342 "*" ) {
401: varNameTok@var2310 =@expr1073748343 varNameTok@var2310 .@expr6520 next (@expr6521 ) ;
402: } else { if (@expr1073748346 varNameTok@var2310 .@expr6516 str (@expr6517 ) ==@expr1073748349 "&" ) {
403: varNameTok@var2310 =@expr1073748350 varNameTok@var2310 .@expr6520 next (@expr6521 ) ;
404: } }
405:
406: typeList@var1334 .@expr6267 emplace_back (@expr1073748354 tok@var2288 , new_scope@var2309 , scope@var2284 ) ;
407: {
408: Type * new_type@var2311 ; new_type@var2311 =@expr1073748355 &@expr6271 typeList@var1334 .@expr6272 back (@expr6273 ) ;
409: new_scope@var2309 .@expr6535 definedType@var2312 =@expr1073748360 new_type@var2311 ;
410: scope@var2284 .@expr6274 definedTypesMap@var2297 [@expr1073748362 new_type@var2311 .@expr1073748363 name (@expr1073748364 ) ] =@expr1073748365 new_type@var2311 ;
411: }
412:
413: scope@var2284 .@expr1073748366 addVariable (@expr1073748367 varNameTok@var2310 , tok@var2288 , tok@var2288 , access@var2287 [@expr6544 scope@var2284 ] , new_scope@var2309 .@expr6535 definedType@var2312 , scope@var2284 , mSettings@var1404 ) ;
414:
415: const Token * tok2@var2313 ; tok2@var2313 =@expr1073748370 tok@var2288 .@expr5964 next (@expr5965 ) ;
416:
417: new_scope@var2309 .@expr1073748373 setBodyStartEnd (@expr1073748374 tok2@var2313 ) ;
418:
419:
420: if (@expr1073748375 !@expr1073748376 new_scope@var2309 .@expr1073748377 bodyEnd@var2314 ) {
421: scopeList@var1331 .@expr6371 pop_back (@expr6372 ) ;
422: break ;
423: }
424:
425:
426: scope@var2284 .@expr6321 nestedList@var2299 .@expr6322 push_back (@expr1073748382 new_scope@var2309 ) ;
427: scope@var2284 =@expr1073748383 new_scope@var2309 ;
428:
429: tok@var2288 =@expr1073748384 tok2@var2313 ;
430: }
431:
432:
433: else { if (@expr1073748385 tok@var2288 .@expr5980 isKeyword (@expr5981 ) &&@expr1073748388 (@expr1073748389 (@expr1073748390 Token ::@expr5985 Match (@expr6491 tok@var2288 , "struct|union {" ) &&@expr1073748393
434: Token ::@expr6065 simpleMatch (@expr1073748395 tok@var2288 .@expr5964 next (@expr5965 ) .@expr6497 link (@expr6498 ) , "} ;" ) ) ||@expr1073748400
435: Token ::@expr6065 simpleMatch (@expr1073748402 tok@var2288 , "namespace {" ) ) ) {
436: scopeList@var1331 .@expr5934 emplace_back (@expr6233 this@expr5936 , tok@var2288 , scope@var2284 ) ;
437:
438: Scope * new_scope@var2315 ; new_scope@var2315 =@expr1073748405 &@expr5938 scopeList@var1331 .@expr5939 back (@expr5940 ) ;
439: access@var2287 [@expr1073748409 new_scope@var2315 ] =@expr1073748410 AccessControl ::@expr6217 Public ;
440:
441: const Token * tok2@var2316 ; tok2@var2316 =@expr1073748412 tok@var2288 .@expr5964 next (@expr5965 ) ;
442:
443: new_scope@var2315 .@expr1073748415 setBodyStartEnd (@expr1073748416 tok2@var2316 ) ;
444:
445: typeList@var1334 .@expr6267 emplace_back (@expr1073748418 tok@var2288 , new_scope@var2315 , scope@var2284 ) ;
446: {
447: Type * new_type@var2317 ; new_type@var2317 =@expr1073748419 &@expr6271 typeList@var1334 .@expr6272 back (@expr6273 ) ;
448: new_scope@var2315 .@expr1073748423 definedType@var2318 =@expr1073748424 new_type@var2317 ;
449: scope@var2284 .@expr6274 definedTypesMap@var2297 [@expr1073748426 new_type@var2317 .@expr1073748427 name (@expr1073748428 ) ] =@expr1073748429 new_type@var2317 ;
450: }
451:
452:
453: if (@expr1073748430 !@expr1073748431 new_scope@var2315 .@expr1073748432 bodyEnd@var2319 ) {
454: scopeList@var1331 .@expr6371 pop_back (@expr6372 ) ;
455: break ;
456: }
457:
458:
459: scope@var2284 .@expr6321 nestedList@var2299 .@expr6322 push_back (@expr1073748437 new_scope@var2315 ) ;
460: scope@var2284 =@expr1073748438 new_scope@var2315 ;
461:
462: tok@var2288 =@expr1073748439 tok2@var2316 ;
463: }
464:
465:
466: else { if (@expr1073748440 tok@var2288 .@expr5980 isKeyword (@expr5981 ) &&@expr1073748443 (@expr1073748444 Token ::@expr5985 Match (@expr1073748446 tok@var2288 , "enum class| %name% ;" ) ||@expr1073748447 Token ::@expr5985 Match (@expr1073748449 tok@var2288 , "enum class| %name% : %name% ;" ) ) ) {
467: typeList@var1334 .@expr6267 emplace_back (@expr6397 tok@var2288 , nullptr , scope@var2284 ) ;
468: Type * new_type@var2320 ; new_type@var2320 =@expr1073748452 &@expr6271 typeList@var1334 .@expr6272 back (@expr6273 ) ;
469: scope@var2284 .@expr6274 definedTypesMap@var2297 [@expr1073748457 new_type@var2320 .@expr1073748458 name (@expr1073748459 ) ] =@expr1073748460 new_type@var2320 ;
470: tok@var2288 =@expr1073748461 tok@var2288 .@expr6011 tokAt (@expr6012 2 ) ;
471: }
472:
473:
474: else { if (@expr1073748464 tok@var2288 ==@expr1073748465 scope@var2284 .@expr1073748466 bodyEnd@var2321 ) {
475: access@var2287 .@expr1073748467 erase (@expr1073748468 scope@var2284 ) ;
476: scope@var2284 =@expr1073748469 const_cast < Scope *@expr5943 > (@expr1073748471 scope@var2284 .@expr1073748472 nestedIn@var2322 ) ;
477: continue ;
478: }
479:
480: else { if (@expr1073748473 inInitList@var2286 (@expr6650 ) &&@expr1073748475 tok@var2288 ==@expr1073748476 endInitList@var2285 .@expr5951 top (@expr5952 ) .@expr1073748479 first@expr1073747756 ) {
481: endInitList@var2285 .@expr1073748480 pop (@expr1073748481 ) ;
482: continue ;
483: }
484:
485:
486: else { if (@expr1073748482 scope@var2284 .@expr1073748483 isClassOrStructOrUnion (@expr1073748484 ) ) {
487: const Token * funcStart@var2323 ; funcStart@var2323 =@expr1073748485 nullptr ;
488: const Token * argStart@var2324 ; argStart@var2324 =@expr1073748486 nullptr ;
489: const Token * declEnd@var2325 ; declEnd@var2325 =@expr1073748487 nullptr ;
490:
491:
492: if (@expr1073748488 tok@var2288 .@expr6202 str (@expr6203 ) ==@expr1073748491 "private:" ) {
493: access@var2287 [@expr6544 scope@var2284 ] =@expr1073748493 AccessControl ::@expr6207 Private ; }
494: else { if (@expr1073748495 tok@var2288 .@expr6202 str (@expr6203 ) ==@expr1073748498 "protected:" ) {
495: access@var2287 [@expr6544 scope@var2284 ] =@expr1073748500 AccessControl ::@expr6677 Protected ; }
496: else { if (@expr1073748502 tok@var2288 .@expr6202 str (@expr6203 ) ==@expr1073748505 "public:" ||@expr1073748506 tok@var2288 .@expr6202 str (@expr6203 ) ==@expr1073748509 "__published:" ) {
497: access@var2287 [@expr6544 scope@var2284 ] =@expr1073748511 AccessControl ::@expr6217 Public ; }
498: else { if (@expr1073748513 Token ::@expr5985 Match (@expr1073748515 tok@var2288 , "public|protected|private %name% :" ) ) {
499: if (@expr1073748516 tok@var2288 .@expr6202 str (@expr6203 ) ==@expr1073748519 "private" ) {
500: access@var2287 [@expr6544 scope@var2284 ] =@expr1073748521 AccessControl ::@expr6207 Private ; }
501: else { if (@expr1073748523 tok@var2288 .@expr6202 str (@expr6203 ) ==@expr1073748526 "protected" ) {
502: access@var2287 [@expr6544 scope@var2284 ] =@expr1073748528 AccessControl ::@expr6677 Protected ; }
503: else {
504: access@var2287 [@expr6544 scope@var2284 ] =@expr1073748531 AccessControl ::@expr6217 Public ; } }
505:
506: tok@var2288 =@expr1073748533 tok@var2288 .@expr6011 tokAt (@expr6012 2 ) ;
507: }
508:
509:
510: else { if (@expr1073748536 isFunction (@expr1073748537 tok@var2288 , scope@var2284 , &@expr1073748538 funcStart@var2323 , &@expr1073748539 argStart@var2324 , &@expr1073748540 declEnd@var2325 ) ) {
511: if (@expr1073748541 tok@var2288 .@expr5991 previous (@expr5992 ) .@expr6720 str (@expr6721 ) !=@expr1073748546 "::" ||@expr1073748547 tok@var2288 .@expr6014 strAt (@expr6725 -2 ) ==@expr1073748550 scope@var2284 .@expr1073748551 className@var2326 ) {
512: Function function@var2327 (@expr1073748552 mTokenizer@var1403 , tok@var2288 , scope@var2284 , funcStart@var2323 , argStart@var2324 ) ;
513:
514:
515: function@var2327 .@expr1073748553 access@var2328 =@expr1073748554 access@var2287 [@expr6544 scope@var2284 ] ;
516:
517: const Token * end@var2329 ; end@var2329 =@expr1073748556 function@var2327 .@expr6733 argDef@var2330 .@expr1073748558 link (@expr1073748559 ) ;
518:
519:
520: if (@expr1073748560 function@var2327 .@expr1073748561 isConstructor (@expr1073748562 ) ) {
521: scope@var2284 .@expr1073748563 numConstructors@var2331 ++@expr1073748564 ; }
522:
523:
524: function@var2327 .@expr1073748565 token@var2332 =@expr1073748566 function@var2327 .@expr1073748567 tokenDef@var2333 ;
525: function@var2327 .@expr1073748568 arg@var2334 =@expr1073748569 function@var2327 .@expr6733 argDef@var2330 ;
526:
527:
528: if (@expr1073748571 const Token *@expr5943 endTok@var2335 =@expr1073748573 mTokenizer@var1403 .@expr6129 isFunctionHead (@expr1073748575 end@var2329 , ";" ) ) {
529: tok@var2288 =@expr1073748576 endTok@var2335 ;
530: scope@var2284 .@expr6753 addFunction (@expr6754 function@var2327 ) ;
531: }
532:
533:
534: else {
535:
536: bool foundInitList@var2336 ; foundInitList@var2336 =@expr1073748579 false ;
537: while (@expr1073748580 end@var2329 &&@expr1073748581 end@var2329 .@expr6758 str (@expr6759 ) !=@expr1073748584 "{" &&@expr1073748585 end@var2329 .@expr6758 str (@expr6759 ) !=@expr1073748588 ";" ) {
538: if (@expr1073748589 end@var2329 .@expr6766 link (@expr6767 ) &&@expr1073748592 Token ::@expr5985 Match (@expr1073748594 end@var2329 , "(|<" ) ) {
539: end@var2329 =@expr1073748595 end@var2329 .@expr6766 link (@expr6767 ) ;
540: } else { if (@expr1073748598 foundInitList@var2336 &&@expr1073748599
541: Token ::@expr5985 Match (@expr1073748601 end@var2329 , "%name%|> {" ) &&@expr1073748602
542: Token ::@expr5985 Match (@expr1073748604 end@var2329 .@expr6781 linkAt (@expr6782 1 ) , "} ,|{" ) ) {
543: end@var2329 =@expr1073748607 end@var2329 .@expr6781 linkAt (@expr6782 1 ) ;
544: } else {
545: if (@expr1073748610 end@var2329 .@expr6758 str (@expr6759 ) ==@expr1073748613 ":" ) {
546: foundInitList@var2336 =@expr1073748614 true ; }
547: end@var2329 =@expr1073748615 end@var2329 .@expr1073748616 next (@expr1073748617 ) ;
548: } }
549: }
550:
551: if (@expr1073748618 !@expr1073748619 end@var2329 ||@expr1073748620 end@var2329 .@expr6758 str (@expr6759 ) ==@expr1073748623 ";" ) {
552: continue ; }
553:
554: scope@var2284 .@expr6753 addFunction (@expr6754 function@var2327 ) ;
555:
556: Function * funcptr@var2337 ; funcptr@var2337 =@expr1073748626 &@expr1073748627 scope@var2284 .@expr1073748628 functionList@var2338 .@expr1073748629 back (@expr1073748630 ) ;
557: const Token * tok2@var2339 ; tok2@var2339 =@expr1073748631 funcStart@var2323 ;
558:
559: addNewFunction (@expr1073748632 &@expr6809 scope@var2284 , &@expr1073748634 tok2@var2339 ) ;
560: if (@expr1073748635 scope@var2284 ) {
561: scope@var2284 .@expr1073748636 functionOf@var2340 =@expr1073748637 function@var2327 .@expr1073748638 nestedIn@var2341 ;
562: scope@var2284 .@expr6815 function@var2342 =@expr1073748640 funcptr@var2337 ;
563: scope@var2284 .@expr6815 function@var2342 .@expr1073748642 functionScope@var2343 =@expr1073748643 scope@var2284 ;
564: }
565:
566: tok@var2288 =@expr1073748644 tok2@var2339 ;
567: }
568: }
569:
570:
571: else {
572:
573: const Scope * const nested@var2344 ; nested@var2344 =@expr1073748645 scope@var2284 .@expr1073748646 findInNestedListRecursive (@expr1073748647 tok@var2288 .@expr6014 strAt (@expr6725 -2 ) ) ;
574:
575: if (@expr1073748650 nested@var2344 ) {
576: addClassFunction (@expr1073748651 &@expr6809 scope@var2284 , &@expr6829 tok@var2288 , argStart@var2324 ) ; }
577: else {
578:
579: }
580: }
581: }
582:
583:
584: else { if (@expr1073748654 mTokenizer@var1403 .@expr5977 isCPP (@expr5978 ) &&@expr5979 tok@var2288 .@expr5980 isKeyword (@expr5981 ) &&@expr1073748660 Token ::@expr5985 Match (@expr1073748662 tok@var2288 , "friend class|struct| ::| %any% ;|::" ) ) {
585: Type ::@expr1073748663 FriendInfo friendInfo@var2345 ;
586:
587:
588: friendInfo@var2345 .@expr6840 nameStart@var2346 =@expr1073748665 tok@var2288 .@expr6014 strAt (@expr6015 1 ) ==@expr6026 "class" ?@expr1073748669 tok@var2288 .@expr6011 tokAt (@expr6012 2 ) :@expr1073748672 tok@var2288 .@expr5964 next (@expr5965 ) ;
589: friendInfo@var2345 .@expr6851 nameEnd@var2347 =@expr1073748676 friendInfo@var2345 .@expr6840 nameStart@var2346 ;
590:
591:
592: if (@expr1073748678 friendInfo@var2345 .@expr6851 nameEnd@var2347 .@expr1073748680 str (@expr1073748681 ) ==@expr1073748682 "::" ) {
593: friendInfo@var2345 .@expr6851 nameEnd@var2347 =@expr1073748684 friendInfo@var2345 .@expr6851 nameEnd@var2347 .@expr1073748686 next (@expr1073748687 ) ; }
594:
595:
596: while (@expr1073748688 friendInfo@var2345 .@expr6851 nameEnd@var2347 &&@expr1073748690 friendInfo@var2345 .@expr6851 nameEnd@var2347 .@expr1073748692 strAt (@expr1073748693 1 ) ==@expr1073748694 "::" ) {
597: friendInfo@var2345 .@expr6851 nameEnd@var2347 =@expr1073748696 friendInfo@var2345 .@expr6851 nameEnd@var2347 .@expr1073748698 tokAt (@expr1073748699 2 ) ; }
598:
599:
600: friendInfo@var2345 .@expr1073748700 type@var2348 =@expr1073748701 nullptr ;
601:
602: if (@expr1073748702 !@expr1073748703 scope@var2284 .@expr6880 definedType@var2349 ) {
603: mTokenizer@var1403 .@expr6190 syntaxError (@expr6229 tok@var2288 ) ; }
604:
605: scope@var2284 .@expr6880 definedType@var2349 .@expr1073748708 friendList@var2350 .@expr1073748709 push_back (@expr1073748710 friendInfo@var2345 ) ;
606: } } } } } }
607: } else { if (@expr1073748711 scope@var2284 .@expr6888 type@var2351 ==@expr1073748713 Scope ::@expr1073748714 eNamespace ||@expr1073748715 scope@var2284 .@expr6888 type@var2351 ==@expr1073748717 Scope ::@expr1073748718 eGlobal ) {
608: const Token * funcStart@var2352 ; funcStart@var2352 =@expr1073748719 nullptr ;
609: const Token * argStart@var2353 ; argStart@var2353 =@expr1073748720 nullptr ;
610: const Token * declEnd@var2354 ; declEnd@var2354 =@expr1073748721 nullptr ;
611:
612:
613: if (@expr1073748722 isFunction (@expr1073748723 tok@var2288 , scope@var2284 , &@expr1073748724 funcStart@var2352 , &@expr1073748725 argStart@var2353 , &@expr1073748726 declEnd@var2354 ) ) {
614:
615: if (@expr1073748727 declEnd@var2354 &&@expr1073748728 declEnd@var2354 .@expr6905 str (@expr6906 ) ==@expr1073748731 "{" ) {
616: tok@var2288 =@expr1073748732 funcStart@var2352 ;
617:
618:
619: if (@expr1073748733 tok@var2288 .@expr5991 previous (@expr5992 ) &&@expr1073748736 tok@var2288 .@expr5991 previous (@expr5992 ) .@expr6720 str (@expr6721 ) ==@expr1073748741 "::" ) {
620: addClassFunction (@expr6918 &@expr6809 scope@var2284 , &@expr6829 tok@var2288 , argStart@var2353 ) ; }
621:
622:
623: else { if (@expr1073748745 tok@var2288 .@expr5991 previous (@expr5992 ) &&@expr1073748748
624: tok@var2288 .@expr5991 previous (@expr5992 ) .@expr6720 str (@expr6721 ) ==@expr1073748753 "~" &&@expr1073748754
625: tok@var2288 .@expr6014 strAt (@expr6725 -2 ) ==@expr1073748757 "::" ) {
626: addClassFunction (@expr6918 &@expr6809 scope@var2284 , &@expr6829 tok@var2288 , argStart@var2353 ) ; }
627:
628:
629: else {
630: const Function * const function@var2355 ; function@var2355 =@expr1073748761 addGlobalFunction (@expr1073748762 scope@var2284 , tok@var2288 , argStart@var2353 , funcStart@var2352 ) ;
631:
632: if (@expr1073748763 !@expr1073748764 function@var2355 ) {
633: mTokenizer@var1403 .@expr6190 syntaxError (@expr6229 tok@var2288 ) ; }
634: } }
635:
636:
637: if (@expr6943 !@expr6944 scope@var2284 ) {
638: mTokenizer@var1403 .@expr6190 syntaxError (@expr6229 tok@var2288 ) ; }
639: }
640:
641: else { if (@expr1073748771 declEnd@var2354 &&@expr1073748772 declEnd@var2354 .@expr6905 str (@expr6906 ) ==@expr1073748775 ";" ) {
642: if (@expr1073748776 tok@var2288 .@expr6953 astParent (@expr6954 ) &&@expr1073748779 tok@var2288 .@expr6953 astParent (@expr6954 ) .@expr1073748782 str (@expr1073748783 ) ==@expr1073748784 "::" &&@expr1073748785
643: Token ::@expr5985 Match (@expr1073748787 declEnd@var2354 .@expr1073748788 previous (@expr1073748789 ) , "default|delete" ) ) {
644: addClassFunction (@expr6918 &@expr6809 scope@var2284 , &@expr6829 tok@var2288 , argStart@var2353 ) ;
645: continue ;
646: }
647:
648: bool newFunc@var2356 ; newFunc@var2356 =@expr1073748793 true ;
649: for (@expr1073748794 std ::@expr5942 multimap < std ::@expr5942 string , const Function *@expr5943 > ::@expr5942 const_iterator i@var2357 =@expr1073748799 scope@var2284 .@expr6976 functionMap@var2358 .@expr1073748801 find (@expr1073748802 tok@var2288 .@expr6202 str (@expr6203 ) ) ; i@var2357 !=@expr1073748805 scope@var2284 .@expr6976 functionMap@var2358 .@expr1073748807 end (@expr1073748808 ) &&@expr1073748809 i@var2357 .@expr1073748810 first@var2359 ==@expr1073748811 tok@var2288 .@expr6202 str (@expr6203 ) ; ++@expr1073748814 i@var2357 ) {
650: if (@expr1073748815 i@var2357 .@expr6992 second@var2360 .@expr1073748817 argsMatch (@expr1073748818 scope@var2284 , i@var2357 .@expr6992 second@var2360 .@expr1073748820 argDef@var2361 , argStart@var2353 , emptyString@var1 , 0 ) ) {
651: newFunc@var2356 =@expr1073748821 false ;
652: break ;
653: }
654: }
655:
656:
657: if (@expr1073748822 newFunc@var2356 ) {
658: addGlobalFunctionDecl (@expr1073748823 scope@var2284 , tok@var2288 , argStart@var2353 , funcStart@var2352 ) ;
659: }
660:
661: tok@var2288 =@expr1073748824 declEnd@var2354 ;
662: continue ;
663: } }
664: }
665: } else { if (@expr7001 scope@var2284 .@expr7002 isExecutable (@expr7003 ) ) {
666: if (@expr1073748828 tok@var2288 .@expr5980 isKeyword (@expr5981 ) &&@expr1073748831 Token ::@expr5985 Match (@expr1073748833 tok@var2288 , "else|try|do {" ) ) {
667: const Token * tok1@var2362 ; tok1@var2362 =@expr1073748834 tok@var2288 .@expr5964 next (@expr5965 ) ;
668: if (@expr1073748837 tok@var2288 .@expr6202 str (@expr6203 ) ==@expr1073748840 "else" ) {
669: scopeList@var1331 .@expr5934 emplace_back (@expr1073748842 this@expr5936 , tok@var2288 , scope@var2284 , Scope ::@expr1073748843 eElse , tok1@var2362 ) ; }
670: else { if (@expr1073748844 tok@var2288 .@expr6202 str (@expr6203 ) ==@expr1073748847 "do" ) {
671: scopeList@var1331 .@expr5934 emplace_back (@expr1073748849 this@expr5936 , tok@var2288 , scope@var2284 , Scope ::@expr1073748850 eDo , tok1@var2362 ) ; }
672: else {
673: scopeList@var1331 .@expr5934 emplace_back (@expr1073748852 this@expr5936 , tok@var2288 , scope@var2284 , Scope ::@expr1073748853 eTry , tok1@var2362 ) ; } }
674:
675: tok@var2288 =@expr1073748854 tok1@var2362 ;
676: scope@var2284 .@expr6321 nestedList@var2299 .@expr6322 push_back (@expr7033 &@expr5938 scopeList@var1331 .@expr5939 back (@expr5940 ) ) ;
677: scope@var2284 =@expr1073748861 &@expr5938 scopeList@var1331 .@expr5939 back (@expr5940 ) ;
678: } else { if (@expr1073748865 tok@var2288 .@expr5980 isKeyword (@expr5981 ) &&@expr1073748868 Token ::@expr5985 Match (@expr1073748870 tok@var2288 , "if|for|while|catch|switch (" ) &&@expr1073748871 Token ::@expr6065 simpleMatch (@expr1073748873 tok@var2288 .@expr5964 next (@expr5965 ) .@expr6497 link (@expr6498 ) , ") {" ) ) {
679: const Token * scopeStartTok@var2363 ; scopeStartTok@var2363 =@expr1073748878 tok@var2288 .@expr5964 next (@expr5965 ) .@expr6497 link (@expr6498 ) .@expr6513 next (@expr6514 ) ;
680: if (@expr1073748885 tok@var2288 .@expr6202 str (@expr6203 ) ==@expr1073748888 "if" ) {
681: scopeList@var1331 .@expr5934 emplace_back (@expr1073748890 this@expr5936 , tok@var2288 , scope@var2284 , Scope ::@expr1073748891 eIf , scopeStartTok@var2363 ) ; }
682: else { if (@expr1073748892 tok@var2288 .@expr6202 str (@expr6203 ) ==@expr1073748895 "for" ) {
683: scopeList@var1331 .@expr5934 emplace_back (@expr1073748897 this@expr5936 , tok@var2288 , scope@var2284 , Scope ::@expr7074 eFor , scopeStartTok@var2363 ) ;
684: } else { if (@expr1073748899 tok@var2288 .@expr6202 str (@expr6203 ) ==@expr1073748902 "while" ) {
685: scopeList@var1331 .@expr5934 emplace_back (@expr1073748904 this@expr5936 , tok@var2288 , scope@var2284 , Scope ::@expr1073748905 eWhile , scopeStartTok@var2363 ) ; }
686: else { if (@expr1073748906 tok@var2288 .@expr6202 str (@expr6203 ) ==@expr1073748909 "catch" ) {
687: scopeList@var1331 .@expr5934 emplace_back (@expr1073748911 this@expr5936 , tok@var2288 , scope@var2284 , Scope ::@expr7088 eCatch , scopeStartTok@var2363 ) ;
688: } else {
689: scopeList@var1331 .@expr5934 emplace_back (@expr1073748914 this@expr5936 , tok@var2288 , scope@var2284 , Scope ::@expr1073748915 eSwitch , scopeStartTok@var2363 ) ; } } } }
690:
691: scope@var2284 .@expr6321 nestedList@var2299 .@expr6322 push_back (@expr7033 &@expr5938 scopeList@var1331 .@expr5939 back (@expr5940 ) ) ;
692: scope@var2284 =@expr1073748922 &@expr5938 scopeList@var1331 .@expr5939 back (@expr5940 ) ;
693: if (@expr1073748926 scope@var2284 .@expr6888 type@var2351 ==@expr1073748928 Scope ::@expr7074 eFor ) {
694: scope@var2284 .@expr7106 checkVariable (@expr1073748931 tok@var2288 .@expr6011 tokAt (@expr6012 2 ) , AccessControl ::@expr1073748934 Local@expr1073747757 , mSettings@var1404 ) ; }
695: else { if (@expr1073748935 scope@var2284 .@expr6888 type@var2351 ==@expr1073748937 Scope ::@expr7088 eCatch ) {
696: scope@var2284 .@expr7106 checkVariable (@expr1073748940 tok@var2288 .@expr6011 tokAt (@expr6012 2 ) , AccessControl ::@expr1073748943 Throw , mSettings@var1404 ) ; } }
697: tok@var2288 =@expr1073748944 scopeStartTok@var2363 ;
698: } else { if (@expr1073748945 Token ::@expr5985 Match (@expr1073748947 tok@var2288 , "%var% {" ) ) {
699: endInitList@var2285 .@expr7124 push (@expr1073748949 std ::@expr7126 make_pair (@expr1073748951 tok@var2288 .@expr5964 next (@expr5965 ) .@expr6497 link (@expr6498 ) , scope@var2284 ) ) ;
700: tok@var2288 =@expr1073748956 tok@var2288 .@expr5964 next (@expr5965 ) ;
701: } else { if (@expr1073748959 const Token *@expr5943 lambdaEndToken@var2364 =@expr1073748961 findLambdaEndToken (@expr1073748962 tok@var2288 ) ) {
702: const Token * lambdaStartToken@var2365 ; lambdaStartToken@var2365 =@expr1073748963 lambdaEndToken@var2364 .@expr1073748964 link (@expr1073748965 ) ;
703: const Token * argStart@var2366 ; argStart@var2366 =@expr1073748966 lambdaStartToken@var2365 .@expr1073748967 astParent (@expr1073748968 ) ;
704: const Token * funcStart@var2367 ; funcStart@var2367 =@expr1073748969 Token ::@expr6065 simpleMatch (@expr1073748971 argStart@var2366 , "[" ) ?@expr1073748972 argStart@var2366 :@expr1073748973 argStart@var2366 .@expr1073748974 astParent (@expr1073748975 ) ;
705: const Function * function@var2368 ; function@var2368 =@expr1073748976 addGlobalFunction (@expr1073748977 scope@var2284 , tok@var2288 , argStart@var2366 , funcStart@var2367 ) ;
706: if (@expr1073748978 !@expr1073748979 function@var2368 ) {
707: mTokenizer@var1403 .@expr6190 syntaxError (@expr6229 tok@var2288 ) ; }
708: tok@var2288 =@expr1073748982 lambdaStartToken@var2365 ;
709: } else { if (@expr1073748983 tok@var2288 .@expr6202 str (@expr6203 ) ==@expr1073748986 "{" ) {
710: if (@expr1073748987 inInitList@var2286 (@expr6650 ) ) {
711: endInitList@var2285 .@expr7124 push (@expr7166 std ::@expr7126 make_pair (@expr7168 tok@var2288 .@expr7169 link (@expr7170 ) , scope@var2284 ) ) ;
712: } else { if (@expr1073748995 isExecutableScope (@expr1073748996 tok@var2288 ) ) {
713: scopeList@var1331 .@expr5934 emplace_back (@expr1073748998 this@expr5936 , tok@var2288 , scope@var2284 , Scope ::@expr1073748999 eUnconditional , tok@var2288 ) ;
714: scope@var2284 .@expr6321 nestedList@var2299 .@expr6322 push_back (@expr7033 &@expr5938 scopeList@var1331 .@expr5939 back (@expr5940 ) ) ;
715: scope@var2284 =@expr1073749006 &@expr5938 scopeList@var1331 .@expr5939 back (@expr5940 ) ;
716: } else { if (@expr7001 scope@var2284 .@expr7002 isExecutable (@expr7003 ) ) {
717: endInitList@var2285 .@expr7124 push (@expr7166 std ::@expr7126 make_pair (@expr7168 tok@var2288 .@expr7169 link (@expr7170 ) , scope@var2284 ) ) ;
718: } else {
719: tok@var2288 =@expr1073749019 tok@var2288 .@expr7169 link (@expr7170 ) ;
720: } } }
721: } } } } }
722:
723: if (@expr6943 !@expr6944 scope@var2284 ) {
724: mTokenizer@var1403 .@expr6190 syntaxError (@expr6229 tok@var2288 ) ; }
725:
726: if (@expr1073749026 tok@var2288 .@expr6202 str (@expr6203 ) ==@expr1073749029 "}" ) {
727: mTokenizer@var1403 .@expr6190 syntaxError (@expr6229 tok@var2288 ) ; }
728: } } } } } } } } } } } } }
729: }
730: }
731:
732: void SymbolDatabase :: createSymbolDatabaseClassInfo ( )
733: {
734: if (@expr1073749032 mTokenizer@var1403 .@expr1073749033 isC (@expr1073749034 ) ) {
735: return ; }
736:
737:
738: for (@expr1073749035 Scope &@expr7212 scope@var2369 :@expr1073749037 scopeList@var1331 ) {
739: for (@expr1073749038 Scope ::@expr7215 UsingInfo &@expr7212 usingInfo@var2370 :@expr1073749041 scope@var2369 .@expr1073749042 usingList@var2371 ) {
740:
741: if (@expr1073749043 usingInfo@var2370 .@expr7220 scope@var2372 ==@expr1073749045 nullptr ) {
742:
743: const Scope * const found@var2373 ; found@var2373 =@expr1073749046 findScope (@expr1073749047 usingInfo@var2370 .@expr1073749048 start@var2374 .@expr1073749049 tokAt (@expr1073749050 2 ) , &@expr1073749051 scope@var2369 ) ;
744: if (@expr1073749052 found@var2373 ) {
745:
746: usingInfo@var2370 .@expr7220 scope@var2372 =@expr1073749054 found@var2373 ;
747: break ;
748: }
749: }
750: }
751: }
752:
753:
754: for (@expr1073749055 Type &@expr7212 type@var2375 :@expr1073749057 typeList@var1334 ) {
755:
756: for (@expr1073749058 Type ::@expr7215 BaseInfo &@expr7212 i@var2376 :@expr1073749061 type@var2375 .@expr1073749062 derivedFrom@var2377 ) {
757: const Type * found@var2378 ; found@var2378 =@expr1073749063 findType (@expr1073749064 i@var2376 .@expr1073749065 nameTok@var2379 , type@var2375 .@expr1073749066 enclosingScope@var2380 , true ) ;
758: if (@expr1073749067 found@var2378 &&@expr1073749068 found@var2378 .@expr1073749069 findDependency (@expr1073749070 &@expr1073749071 type@var2375 ) ) {
759:
760:
761: } else {
762: i@var2376 .@expr1073749072 type@var2381 =@expr1073749073 found@var2378 ;
763: }
764: }
765: }
766:
767:
768: for (@expr1073749074 Type &@expr7212 type@var2382 :@expr1073749076 typeList@var1334 ) {
769: for (@expr1073749077 Type ::@expr7215 FriendInfo &@expr7212 friendInfo@var2383 :@expr1073749080 type@var2382 .@expr1073749081 friendList@var2384 ) {
770: friendInfo@var2383 .@expr1073749082 type@var2385 =@expr1073749083 findType (@expr1073749084 friendInfo@var2383 .@expr1073749085 nameStart@var2386 , type@var2382 .@expr1073749086 enclosingScope@var2387 ) ;
771: }
772: }
773: }
774:
775:
776: void SymbolDatabase :: createSymbolDatabaseVariableInfo ( )
777: {
778:
779: for (@expr1073749087 Scope &@expr7264 scope@var2388 :@expr1073749089 scopeList@var1331 ) {
780:
781: scope@var2388 .@expr1073749090 getVariableList (@expr1073749091 mSettings@var1404 ) ;
782: }
783:
784:
785: for (@expr1073749092 Scope &@expr7264 scope@var2389 :@expr1073749094 scopeList@var1331 ) {
786: std ::@expr1073749095 list < Function > ::@expr1073749096 iterator func@var2390 ;
787:
788: for (@expr1073749097 func@var2390 =@expr1073749098 scope@var2389 .@expr7275 functionList@var2391 .@expr1073749100 begin (@expr1073749101 ) ; func@var2390 !=@expr1073749102 scope@var2389 .@expr7275 functionList@var2391 .@expr1073749104 end (@expr1073749105 ) ; ++@expr1073749106 func@var2390 ) {
789:
790: func@var2390 .@expr1073749107 addArguments (@expr1073749108 this@expr1073749109 , &@expr1073749110 scope@var2389 ) ;
791: }
792: }
793: }
794:
795: void SymbolDatabase :: createSymbolDatabaseCopyAndMoveConstructors ( )
796: {
797:
798: for (@expr1073749111 Scope &@expr1073749112 scope@var2392 :@expr1073749113 scopeList@var1331 ) {
799: if (@expr1073749114 !@expr1073749115 scope@var2392 .@expr1073749116 isClassOrStruct (@expr1073749117 ) ) {
800: continue ; }
801:
802: std ::@expr1073749118 list < Function > ::@expr1073749119 iterator func@var2393 ;
803: for (@expr1073749120 func@var2393 =@expr1073749121 scope@var2392 .@expr7298 functionList@var2394 .@expr1073749123 begin (@expr1073749124 ) ; func@var2393 !=@expr1073749125 scope@var2392 .@expr7298 functionList@var2394 .@expr1073749127 end (@expr1073749128 ) ; ++@expr1073749129 func@var2393 ) {
804: if (@expr1073749130 !@expr1073749131 func@var2393 .@expr1073749132 isConstructor (@expr1073749133 ) ||@expr1073749134 func@var2393 .@expr1073749135 minArgCount (@expr1073749136 ) !=@expr1073749137 1 ) {
805: continue ; }
806:
807: const Variable * firstArg@var2395 ; firstArg@var2395 =@expr1073749138 func@var2393 .@expr1073749139 getArgumentVar (@expr1073749140 0 ) ;
808: if (@expr1073749141 firstArg@var2395 .@expr1073749142 type (@expr1073749143 ) ==@expr1073749144 scope@var2392 .@expr1073749145 definedType@var2396 ) {
809: if (@expr1073749146 firstArg@var2395 .@expr1073749147 isRValueReference (@expr1073749148 ) ) {
810: func@var2393 .@expr7325 type@var2397 =@expr1073749150 Function ::@expr7327 eMoveConstructor ; }
811: else { if (@expr1073749152 firstArg@var2395 .@expr1073749153 isReference (@expr1073749154 ) &&@expr1073749155 !@expr1073749156 firstArg@var2395 .@expr1073749157 isPointer (@expr1073749158 ) ) {
812: func@var2393 .@expr7325 type@var2397 =@expr1073749160 Function ::@expr7337 eCopyConstructor ; } }
813: }
814:
815: if (@expr1073749162 func@var2393 .@expr7325 type@var2397 ==@expr1073749164 Function ::@expr7337 eCopyConstructor ||@expr1073749166
816: func@var2393 .@expr7325 type@var2397 ==@expr1073749168 Function ::@expr7327 eMoveConstructor ) {
817: scope@var2392 .@expr1073749170 numCopyOrMoveConstructors@var2398 ++@expr1073749171 ; }
818: }
819: }
820: }
821:
822: void SymbolDatabase :: createSymbolDatabaseFunctionScopes ( )
823: {
824:
825: for (@expr1073749172 Scope &@expr1073749173 scope@var2399 :@expr1073749174 scopeList@var1331 ) {
826: if (@expr1073749175 scope@var2399 .@expr1073749176 type@var2400 ==@expr1073749177 Scope ::@expr1073749178 eFunction ) {
827: functionScopes@var1332 .@expr1073749179 push_back (@expr1073749180 &@expr1073749181 scope@var2399 ) ; }
828: }
829: }
830:
831: void SymbolDatabase :: createSymbolDatabaseClassAndStructScopes ( )
832: {
833:
834: for (@expr1073749182 Scope &@expr1073749183 scope@var2401 :@expr1073749184 scopeList@var1331 ) {
835: if (@expr1073749185 scope@var2401 .@expr1073749186 isClassOrStruct (@expr1073749187 ) ) {
836: classAndStructScopes@var1333 .@expr1073749188 push_back (@expr1073749189 &@expr1073749190 scope@var2401 ) ; }
837: }
838: }
839:
840: void SymbolDatabase :: createSymbolDatabaseFunctionReturnTypes ( )
841: {
842:
843: for (@expr1073749191 Scope &@expr1073749192 scope@var2402 :@expr1073749193 scopeList@var1331 ) {
844: std ::@expr1073749194 list < Function > ::@expr1073749195 iterator func@var2403 ;
845:
846: for (@expr1073749196 func@var2403 =@expr1073749197 scope@var2402 .@expr7374 functionList@var2404 .@expr1073749199 begin (@expr1073749200 ) ; func@var2403 !=@expr1073749201 scope@var2402 .@expr7374 functionList@var2404 .@expr1073749203 end (@expr1073749204 ) ; ++@expr1073749205 func@var2403 ) {
847:
848: if (@expr1073749206 func@var2403 .@expr7383 retDef@var2405 ) {
849: const Token * type@var2406 ; type@var2406 =@expr1073749208 func@var2403 .@expr7383 retDef@var2405 ;
850: while (@expr1073749210 Token ::@expr1073749211 Match (@expr1073749212 type@var2406 , "static|const|struct|union|enum" ) ) {
851: type@var2406 =@expr1073749213 type@var2406 .@expr1073749214 next (@expr1073749215 ) ; }
852: if (@expr1073749216 type@var2406 ) {
853: func@var2403 .@expr7393 retType@var2407 =@expr1073749218 findVariableTypeInBase (@expr1073749219 &@expr1073749220 scope@var2402 , type@var2406 ) ;
854: if (@expr1073749221 !@expr1073749222 func@var2403 .@expr7393 retType@var2407 ) {
855: func@var2403 .@expr7393 retType@var2407 =@expr1073749225 findTypeInNested (@expr1073749226 type@var2406 , func@var2403 .@expr1073749227 nestedIn@var2408 ) ; }
856: }
857: }
858: }
859: }
860: }
861:
862: void SymbolDatabase :: createSymbolDatabaseNeedInitialization ( )
863: {
864: if (@expr1073749229 mTokenizer@var1403 .@expr1073749230 isC (@expr1073749231 ) ) {
865:
866: for (@expr1073749232 Scope &@expr7409 scope@var2409 :@expr1073749234 scopeList@var1331 ) {
867: if (@expr1073749235 scope@var2409 .@expr7412 definedType@var2410 ) {
868: scope@var2409 .@expr7412 definedType@var2410 .@expr1073749238 needInitialization@var2411 =@expr1073749239 Type ::@expr7416 NeedInitialization ::@expr7417 True ; }
869: }
870: } else {
871:
872: unsigned int unknowns@var2412 ; unknowns@var2412 =@expr1073749242 0 ;
873: unsigned int retry@var2413 ; retry@var2413 =@expr1073749243 0 ;
874:
875: do {
876: unknowns@var2412 =@expr1073749244 0 ;
877:
878: for (@expr1073749245 Scope &@expr7409 scope@var2414 :@expr1073749247 scopeList@var1331 ) {
879: if (@expr1073749248 !@expr1073749249 scope@var2414 .@expr1073749250 isClassOrStructOrUnion (@expr1073749251 ) ) {
880: continue ; }
881:
882: if (@expr1073749252 !@expr1073749253 scope@var2414 .@expr7430 definedType@var2415 ) {
883: mBlankTypes@var1407 .@expr1073749255 emplace_back (@expr1073749256 ) ;
884: scope@var2414 .@expr7430 definedType@var2415 =@expr1073749258 &@expr1073749259 mBlankTypes@var1407 .@expr1073749260 back (@expr1073749261 ) ;
885: }
886:
887: if (@expr1073749262 scope@var2414 .@expr1073749263 isClassOrStruct (@expr1073749264 ) &&@expr1073749265 scope@var2414 .@expr7430 definedType@var2415 .@expr7443 needInitialization@var2416 ==@expr7444 Type ::@expr7416 NeedInitialization ::@expr7446 Unknown@expr7404 ) {
888:
889: bool hasDefaultConstructor@var2417 ; hasDefaultConstructor@var2417 =@expr1073749271 false ;
890:
891: for (@expr1073749272 Function &@expr7409 func@var2418 :@expr1073749274 scope@var2414 .@expr1073749275 functionList@var2419 ) {
892: if (@expr1073749276 func@var2418 .@expr1073749277 type@var2420 ==@expr1073749278 Function ::@expr1073749279 eConstructor ) {
893:
894: if (@expr1073749280 func@var2418 .@expr7457 argCount (@expr7458 ) ==@expr1073749283 0 ) {
895: hasDefaultConstructor@var2417 =@expr1073749284 true ;
896: break ;
897: }
898:
899:
900: else { if (@expr1073749285 func@var2418 .@expr7457 argCount (@expr7458 ) ==@expr1073749288 func@var2418 .@expr1073749289 initializedArgCount (@expr1073749290 ) ) {
901: hasDefaultConstructor@var2417 =@expr1073749291 true ;
902: break ;
903: } }
904: }
905: }
906:
|
909:
910: if (@expr1073749292 hasDefaultConstructor@var2417 ) {
911: scope@var2414 .@expr7430 definedType@var2415 .@expr7443 needInitialization@var2416 =@expr1073749295 Type ::@expr7416 NeedInitialization ::@expr7473 False ; }
912:
913:
914: else {
915: bool needInitialization@var2421 ; needInitialization@var2421 =@expr1073749298 false ;
916: bool unknown@var2422 ; unknown@var2422 =@expr1073749299 false ;
917:
918: for (@expr1073749300 const Variable &@expr7409 var@var2423 :@expr1073749302 scope@var2414 .@expr1073749303 varlist@var2424 ) {
919: if (@expr1073749304 var@var2423 .@expr1073749305 isClass (@expr1073749306 ) ) {
920: if (@expr1073749307 var@var2423 .@expr7484 type (@expr7485 ) ) {
921:
922: if (@expr1073749310 var@var2423 .@expr7484 type (@expr7485 ) .@expr7489 needInitialization@var3842 ==@expr1073749314 Type ::@expr7416 NeedInitialization ::@expr7417 True &&@expr1073749317 !@expr7494 var@var2423 .@expr7495 hasDefault (@expr7496 ) ) {
923: needInitialization@var2421 =@expr1073749321 true ; }
924: else { if (@expr1073749322 var@var2423 .@expr7484 type (@expr7485 ) .@expr7489 needInitialization@var3842 ==@expr1073749326 Type ::@expr7416 NeedInitialization ::@expr7446 Unknown@expr7404 ) {
925: if (@expr1073749329 !@expr1073749330 (@expr1073749331 var@var2423 .@expr7508 valueType (@expr7509 ) &&@expr1073749334 var@var2423 .@expr7508 valueType (@expr7509 ) .@expr1073749337 type@var3843 ==@expr1073749338 ValueType ::@expr1073749339 CONTAINER ) ) {
926: unknown@var2422 =@expr1073749340 true ; }
927: } }
928: }
929: } else { if (@expr1073749341 !@expr7494 var@var2423 .@expr7495 hasDefault (@expr7496 ) &&@expr1073749345 !@expr1073749346 var@var2423 .@expr1073749347 isStatic (@expr1073749348 ) ) {
930: needInitialization@var2421 =@expr1073749349 true ;
931: break ;
932: } }
933: }
934:
935: if (@expr1073749350 needInitialization@var2421 ) {
936: scope@var2414 .@expr7430 definedType@var2415 .@expr7443 needInitialization@var2416 =@expr1073749353 Type ::@expr7416 NeedInitialization ::@expr7417 True ; }
937: else { if (@expr1073749356 !@expr1073749357 unknown@var2422 ) {
938: scope@var2414 .@expr7430 definedType@var2415 .@expr7443 needInitialization@var2416 =@expr1073749360 Type ::@expr7416 NeedInitialization ::@expr7473 False ; }
939: else {
940: if (@expr1073749363 scope@var2414 .@expr7430 definedType@var2415 .@expr7443 needInitialization@var2416 ==@expr7444 Type ::@expr7416 NeedInitialization ::@expr7446 Unknown@expr7404 ) {
941: unknowns@var2412 ++@expr1073749369 ; }
942: } }
943: }
944: } else { if (@expr1073749370 scope@var2414 .@expr1073749371 type@var2425 ==@expr1073749372 Scope ::@expr1073749373 eUnion &&@expr1073749374 scope@var2414 .@expr7430 definedType@var2415 .@expr7443 needInitialization@var2416 ==@expr7444 Type ::@expr7416 NeedInitialization ::@expr7446 Unknown@expr7404 ) {
945: scope@var2414 .@expr7430 definedType@var2415 .@expr7443 needInitialization@var2416 =@expr1073749382 Type ::@expr7416 NeedInitialization ::@expr7417 True ; } }
946: }
947:
948: retry@var2413 ++@expr1073749385 ;
949: } while (@expr1073749386 unknowns@var2412 &&@expr1073749387 retry@var2413 <@expr1073749388 100 ) ;
950:
951:
952: if (@expr1073749389 retry@var2413 ==@expr1073749390 100 &&@expr1073749391 mSettings@var1404 .@expr1073749392 debugwarnings@var3821 ) {
953: for (@expr1073749393 const Scope &@expr7409 scope@var2426 :@expr1073749395 scopeList@var1331 ) {
954: if (@expr1073749396 scope@var2426 .@expr1073749397 isClassOrStruct (@expr1073749398 ) &&@expr1073749399 scope@var2426 .@expr1073749400 definedType@var2427 .@expr1073749401 needInitialization@var2428 ==@expr1073749402 Type ::@expr7416 NeedInitialization ::@expr7446 Unknown@expr7404 ) {
955: debugMessage (@expr1073749405 scope@var2426 .@expr1073749406 classDef@var2429 , "debug" , "SymbolDatabase couldn't resolve all user defined types." ) ; }
956: }
957: }
958: }
959: }
960:
961: void SymbolDatabase :: createSymbolDatabaseVariableSymbolTable ( )
962: {
963:
964: mVariableList@var1406 .@expr1073749407 resize (@expr1073749408 mTokenizer@var1403 .@expr1073749409 varIdCount (@expr1073749410 ) +@expr1073749411 1 ) ;
965: std ::@expr1073749412 fill_n (@expr1073749413 mVariableList@var1406 .@expr1073749414 begin (@expr1073749415 ) , mVariableList@var1406 .@expr1073749416 size (@expr1073749417 ) , (@expr1073749418 const Variable *@expr7595 ) nullptr ) ;
966:
967:
968: for (@expr1073749420 Scope &@expr7597 scope@var2430 :@expr1073749422 scopeList@var1331 ) {
969:
970: for (@expr1073749423 Variable &@expr7597 var@var2431 :@expr1073749425 scope@var2430 .@expr1073749426 varlist@var2432 ) {
971: const unsigned int varId@var2433 =@expr1073749427 var@var2431 .@expr1073749428 declarationId (@expr1073749429 ) ;
972: if (@expr1073749430 varId@var2433 ) {
973: mVariableList@var1406 [@expr1073749431 varId@var2433 ] =@expr1073749432 &@expr1073749433 var@var2431 ; }
974:
975: if (@expr1073749434 !@expr1073749435 var@var2431 .@expr7612 type (@expr1073749437 ) &&@expr1073749438 !@expr1073749439 var@var2431 .@expr7616 typeStartToken (@expr7617 ) .@expr1073749442 isStandardType (@expr1073749443 ) ) {
976: const Type * type@var2434 ; type@var2434 =@expr1073749444 findType (@expr1073749445 var@var2431 .@expr7616 typeStartToken (@expr7617 ) , &@expr7624 scope@var2430 ) ;
977: if (@expr1073749449 type@var2434 ) {
978: var@var2431 .@expr7612 type (@expr1073749451 type@var2434 ) ; }
979: }
980: }
981:
982:
983: for (@expr1073749452 Function &@expr7597 func@var2435 :@expr1073749454 scope@var2430 .@expr1073749455 functionList@var2436 ) {
984: for (@expr1073749456 Variable &@expr7597 arg@var2437 :@expr1073749458 func@var2435 .@expr1073749459 argumentList@var2438 ) {
985:
986: if (@expr1073749460 arg@var2437 .@expr1073749461 nameToken (@expr1073749462 ) &&@expr1073749463 arg@var2437 .@expr7640 declarationId (@expr7641 ) ) {
987: const unsigned int declarationId@var2439 =@expr1073749466 arg@var2437 .@expr7640 declarationId (@expr7641 ) ;
988: mVariableList@var1406 [@expr1073749469 declarationId@var2439 ] =@expr1073749470 &@expr1073749471 arg@var2437 ;
989:
990: if (@expr1073749472 !@expr1073749473 arg@var2437 .@expr7650 type (@expr1073749475 ) &&@expr1073749476 !@expr1073749477 arg@var2437 .@expr7654 typeStartToken (@expr7655 ) .@expr1073749480 isStandardType (@expr1073749481 ) ) {
991: const Type * type@var2440 ; type@var2440 =@expr1073749482 findTypeInNested (@expr1073749483 arg@var2437 .@expr7654 typeStartToken (@expr7655 ) , &@expr7624 scope@var2430 ) ;
992: if (@expr1073749487 type@var2440 ) {
993: arg@var2437 .@expr7650 type (@expr1073749489 type@var2440 ) ; }
994: }
995: }
996: }
997: }
998: }
999:
1000:
1001: const unsigned long functions@var2441 =@expr1073749490 functionScopes@var1332 .@expr1073749491 size (@expr1073749492 ) ;
1002: for (@expr1073749493 unsigned long i@var2442 =@expr1073749494 0 ; i@var2442 <@expr1073749495 functions@var2441 ; ++@expr1073749496 i@var2442 ) {
1003: const Scope * func@var2443 ; func@var2443 =@expr1073749497 functionScopes@var1332 [@expr1073749498 i@var2442 ] ;
1004: for (@expr1073749499 const Token *@expr7595 tok@var2444 =@expr1073749501 func@var2443 .@expr1073749502 bodyStart@var2445 .@expr1073749503 next (@expr1073749504 ) ; tok@var2444 &&@expr1073749505 tok@var2444 !=@expr1073749506 func@var2443 .@expr1073749507 bodyEnd@var2446 ; tok@var2444 =@expr1073749508 tok@var2444 .@expr7685 next (@expr7686 ) ) {
1005:
1006: if (@expr1073749511 tok@var2444 .@expr7688 varId (@expr7689 ) &&@expr1073749514 tok@var2444 .@expr7685 next (@expr7686 ) &&@expr1073749517
1007: (@expr1073749518 tok@var2444 .@expr7685 next (@expr7686 ) .@expr7697 str (@expr7698 ) ==@expr7699 "." ||@expr1073749524
1008: (@expr1073749525 tok@var2444 .@expr7685 next (@expr7686 ) .@expr7697 str (@expr7698 ) ==@expr1073749530 "[" &&@expr1073749531 tok@var2444 .@expr7708 linkAt (@expr7709 1 ) .@expr1073749534 strAt (@expr1073749535 1 ) ==@expr1073749536 "." ) ) ) {
1009: const Token * tok1@var2447 ; tok1@var2447 =@expr1073749537 tok@var2444 .@expr7685 next (@expr7686 ) .@expr7697 str (@expr7698 ) ==@expr7699 "." ?@expr1073749543 tok@var2444 .@expr1073749544 tokAt (@expr1073749545 2 ) :@expr1073749546 tok@var2444 .@expr7708 linkAt (@expr7709 1 ) .@expr1073749549 tokAt (@expr1073749550 2 ) ;
1010: if (@expr1073749551 tok1@var2447 &&@expr1073749552 tok1@var2447 .@expr7729 varId (@expr7730 ) &&@expr1073749555 mVariableList@var1406 [@expr7732 tok1@var2447 .@expr7729 varId (@expr7730 ) ] ==@expr1073749559 nullptr ) {
1011: const Variable * var@var2448 ; var@var2448 =@expr1073749560 mVariableList@var1406 [@expr1073749561 tok@var2444 .@expr7688 varId (@expr7689 ) ] ;
1012: if (@expr1073749564 var@var2448 &&@expr1073749565 var@var2448 .@expr7742 typeScope (@expr7743 ) ) {
1013:
1014: const Variable * var1@var2449 ; var1@var2449 =@expr1073749568 var@var2448 .@expr7742 typeScope (@expr7743 ) .@expr1073749571 getVariable (@expr1073749572 tok1@var2447 .@expr1073749573 str (@expr1073749574 ) ) ;
1015: if (@expr1073749575 var1@var2449 ) {
1016:
1017: mVariableList@var1406 [@expr7732 tok1@var2447 .@expr7729 varId (@expr7730 ) ] =@expr1073749579 var1@var2449 ;
1018: }
1019: }
1020: }
1021: }
1022: }
1023: }
1024: }
1025:
1026: void SymbolDatabase :: createSymbolDatabaseSetScopePointers ( )
1027: {
1028: auto setScopePointers@var2450 ; setScopePointers@var2450 =@expr1073749580 [@expr1073749581 ] (@expr1073749582 const Scope &@expr7759 scope@var2451 , const Token *@expr7760 bodyStart@var2452 , const Token *@expr7760 bodyEnd@var2453 ) {
1029: assert (@expr1073749586 bodyStart@var2452 ) ;
1030: assert (@expr1073749587 bodyEnd@var2453 ) ;
1031:
1032: const_cast < Token *@expr7760 > (@expr1073749589 bodyEnd@var2453 ) .@expr1073749590 scope (@expr1073749591 &@expr7768 scope@var2451 ) ;
1033:
1034: for (@expr1073749593 Token *@expr7760 tok@var2454 =@expr1073749595 const_cast < Token *@expr7760 > (@expr1073749597 bodyStart@var2452 ) ; tok@var2454 !=@expr1073749598 bodyEnd@var2453 ; tok@var2454 =@expr1073749599 tok@var2454 .@expr7776 next (@expr7777 ) ) {
1035: if (@expr1073749602 bodyStart@var2452 !=@expr1073749603 bodyEnd@var2453 &&@expr1073749604 tok@var2454 .@expr1073749605 str (@expr1073749606 ) ==@expr1073749607 "{" ) {
1036: bool isEndOfScope@var2455 ; isEndOfScope@var2455 =@expr1073749608 false ;
1037: for (@expr1073749609 Scope *@expr7760 innerScope@var2456 :@expr1073749611 scope@var2451 .@expr1073749612 nestedList@var2457 ) {
1038: const auto &@expr7759 list@var2458 =@expr1073749614 innerScope@var2456 .@expr1073749615 bodyStartList@var2459 ;
1039: if (@expr1073749616 std ::@expr1073749617 find (@expr1073749618 list@var2458 .@expr1073749619 begin (@expr1073749620 ) , list@var2458 .@expr7797 end (@expr7798 ) , tok@var2454 ) !=@expr1073749623 list@var2458 .@expr7797 end (@expr7798 ) ) {
1040: tok@var2454 =@expr1073749626 tok@var2454 .@expr1073749627 link (@expr1073749628 ) ;
1041: if (@expr1073749629 tok@var2454 .@expr7776 next (@expr7777 ) ==@expr1073749632 bodyEnd@var2453 ||@expr1073749633 !@expr1073749634 tok@var2454 .@expr7776 next (@expr7777 ) ) {
1042: isEndOfScope@var2455 =@expr1073749637 true ;
1043: break ;
1044: }
1045: tok@var2454 =@expr1073749638 tok@var2454 .@expr7776 next (@expr7777 ) ;
1046: break ;
1047: }
1048: }
1049: if (@expr1073749641 isEndOfScope@var2455 ) {
1050: break ; }
1051: }
1052: tok@var2454 .@expr1073749642 scope (@expr1073749643 &@expr7768 scope@var2451 ) ;
1053: }
1054: } ;
1055:
1056:
1057: for (@expr1073749645 Scope &@expr7759 scope@var2460 :@expr1073749647 scopeList@var1331 ) {
1058: if (@expr1073749648 scope@var2460 .@expr1073749649 type@var2461 ==@expr1073749650 Scope ::@expr1073749651 eGlobal ) {
1059: setScopePointers@var2450 (@expr1073749652 scope@var2460 , mTokenizer@var1403 .@expr7829 list@var3820 .@expr1073749654 front (@expr1073749655 ) , mTokenizer@var1403 .@expr7829 list@var3820 .@expr1073749657 back (@expr1073749658 ) ) ; }
1060: else {
1061: for (@expr1073749659 const Token *@expr7760 bodyStart@var2462 :@expr1073749661 scope@var2460 .@expr1073749662 bodyStartList@var2463 ) {
1062: setScopePointers@var2450 (@expr1073749663 scope@var2460 , bodyStart@var2462 , bodyStart@var2462 .@expr1073749664 link (@expr1073749665 ) ) ; }
1063: }
1064: }
1065: }
1066:
1067: void SymbolDatabase :: createSymbolDatabaseSetFunctionPointers ( bool firstPass@var2464 )
1068: {
1069: if (@expr1073749666 firstPass@var2464 ) {
1070:
1071: for (@expr1073749667 const Scope &@expr7844 scope@var2465 :@expr1073749669 scopeList@var1331 ) {
1072: for (@expr1073749670 const Function &@expr7844 func@var2466 :@expr1073749672 scope@var2465 .@expr1073749673 functionList@var2467 ) {
1073: if (@expr1073749674 func@var2466 .@expr7851 tokenDef@var2468 ) {
1074: const_cast < Token *@expr7852 > (@expr1073749677 func@var2466 .@expr7851 tokenDef@var2468 ) .@expr1073749679 function (@expr1073749680 &@expr7857 func@var2466 ) ; }
1075:
1076: if (@expr1073749682 func@var2466 .@expr7859 token@var2469 ) {
1077: const_cast < Token *@expr7852 > (@expr1073749685 func@var2466 .@expr7859 token@var2469 ) .@expr1073749687 function (@expr1073749688 &@expr7857 func@var2466 ) ; }
1078: }
1079: }
1080: }
1081:
1082:
1083: for (@expr1073749690 const Token *@expr7852 tok@var2470 =@expr1073749692 mTokenizer@var1403 .@expr7869 list@var3820 .@expr1073749694 front (@expr1073749695 ) ; tok@var2470 !=@expr1073749696 mTokenizer@var1403 .@expr7869 list@var3820 .@expr1073749698 back (@expr1073749699 ) ; tok@var2470 =@expr1073749700 tok@var2470 .@expr7877 next (@expr7878 ) ) {
1084: if (@expr1073749703 tok@var2470 .@expr1073749704 isName (@expr1073749705 ) &&@expr1073749706 !@expr1073749707 tok@var2470 .@expr1073749708 function (@expr1073749709 ) &&@expr1073749710 tok@var2470 .@expr1073749711 varId (@expr1073749712 ) ==@expr1073749713 0 &&@expr1073749714 Token ::@expr7891 Match (@expr1073749716 tok@var2470 , "%name% [(,)>;]" ) &&@expr1073749717 !@expr1073749718 isReservedName (@expr1073749719 tok@var2470 .@expr1073749720 str (@expr1073749721 ) ) ) {
1085: if (@expr1073749722 tok@var2470 .@expr7877 next (@expr7878 ) .@expr7901 str (@expr7902 ) ==@expr1073749727 ">" &&@expr1073749728 !@expr1073749729 tok@var2470 .@expr7877 next (@expr7878 ) .@expr1073749732 link (@expr1073749733 ) ) {
1086: continue ; }
1087:
1088: if (@expr7910 tok@var2470 .@expr7877 next (@expr7878 ) .@expr7901 str (@expr7902 ) !=@expr7915 "(" ) {
1089: const Token * start@var2471 ; start@var2471 =@expr1073749740 tok@var2470 ;
1090: while (@expr1073749741 Token ::@expr7891 Match (@expr1073749743 start@var2471 .@expr7920 tokAt (@expr7921 -2 ) , "%name% ::" ) ) {
1091: start@var2471 =@expr1073749746 start@var2471 .@expr7920 tokAt (@expr7921 -2 ) ; }
1092: if (@expr1073749749 !@expr1073749750 Token ::@expr7891 Match (@expr1073749752 start@var2471 .@expr1073749753 previous (@expr1073749754 ) , "[(,<=]" ) &&@expr1073749755 !@expr1073749756 Token ::@expr7891 Match (@expr1073749758 start@var2471 .@expr7920 tokAt (@expr7921 -2 ) , "[(,<=] &" ) &&@expr1073749761 !@expr1073749762 Token ::@expr7891 Match (@expr1073749764 start@var2471 , "%name% ;" ) ) {
1093: continue ; }
1094: }
1095:
1096: const Function * function@var2472 ; function@var2472 =@expr1073749765 findFunction (@expr1073749766 tok@var2470 ) ;
1097: if (@expr1073749767 !@expr1073749768 function@var2472 ) {
1098: continue ; }
1099:
1100: const_cast < Token *@expr7852 > (@expr1073749770 tok@var2470 ) .@expr1073749771 function (@expr1073749772 function@var2472 ) ;
1101:
1102: if (@expr7910 tok@var2470 .@expr7877 next (@expr7878 ) .@expr7901 str (@expr7902 ) !=@expr7915 "(" ) {
1103: const_cast < Function *@expr7852 > (@expr1073749780 function@var2472 ) .@expr1073749781 functionPointerUsage@var2473 =@expr1073749782 tok@var2470 ; }
1104: }
1105: }
1106:
1107:
1108: for (@expr1073749783 const Scope &@expr7844 scope@var2474 :@expr1073749785 scopeList@var1331 ) {
1109: for (@expr1073749786 const Function &@expr7844 func@var2475 :@expr1073749788 scope@var2474 .@expr1073749789 functionList@var2476 ) {
1110:
1111: if (@expr1073749790 func@var2475 .@expr1073749791 isConstructor (@expr1073749792 ) &&@expr1073749793 func@var2475 .@expr7970 functionScope@var2477 &&@expr1073749795 func@var2475 .@expr7970 functionScope@var2477 .@expr7973 functionOf@var2478 &&@expr1073749798 func@var2475 .@expr7975 arg@var2479 ) {
1112: const Token * tok@var2480 ; tok@var2480 =@expr1073749800 func@var2475 .@expr7975 arg@var2479 .@expr1073749802 link (@expr1073749803 ) .@expr1073749804 next (@expr1073749805 ) ;
1113: if (@expr1073749806 tok@var2480 .@expr7983 str (@expr7984 ) ==@expr1073749809 "noexcept" ) {
1114: const Token * closingParenTok@var2481 ; closingParenTok@var2481 =@expr1073749810 tok@var2480 .@expr7987 linkAt (@expr7988 1 ) ;
1115: if (@expr1073749813 !@expr1073749814 closingParenTok@var2481 ||@expr1073749815 !@expr1073749816 closingParenTok@var2481 .@expr7993 next (@expr7994 ) ) {
1116: continue ;
1117: }
1118: tok@var2480 =@expr1073749819 closingParenTok@var2481 .@expr7993 next (@expr7994 ) ;
1119: }
1120: if (@expr1073749822 tok@var2480 .@expr7983 str (@expr7984 ) !=@expr1073749825 ":" ) {
1121: continue ;
1122: }
1123: tok@var2480 =@expr1073749826 tok@var2480 .@expr8003 next (@expr8004 ) ;
1124: while (@expr1073749829 tok@var2480 &&@expr1073749830 tok@var2480 !=@expr1073749831 func@var2475 .@expr7970 functionScope@var2477 .@expr1073749833 bodyStart@var2482 ) {
1125: if (@expr1073749834 Token ::@expr7891 Match (@expr1073749836 tok@var2480 , "%name% {|(" ) ) {
1126: if (@expr1073749837 tok@var2480 .@expr7983 str (@expr7984 ) ==@expr1073749840 func@var2475 .@expr1073749841 tokenDef@var2483 .@expr1073749842 str (@expr1073749843 ) ) {
1127: const Function * function@var2484 ; function@var2484 =@expr1073749844 func@var2475 .@expr7970 functionScope@var2477 .@expr7973 functionOf@var2478 .@expr1073749847 findFunction (@expr1073749848 tok@var2480 ) ;
1128: if (@expr1073749849 function@var2484 ) {
1129: const_cast < Token *@expr7852 > (@expr1073749851 tok@var2480 ) .@expr1073749852 function (@expr1073749853 function@var2484 ) ; }
1130: break ;
1131: }
1132: tok@var2480 =@expr1073749854 tok@var2480 .@expr7987 linkAt (@expr7988 1 ) ;
1133: }
1134: tok@var2480 =@expr1073749857 tok@var2480 .@expr8003 next (@expr8004 ) ;
1135: }
1136: }
1137: }
1138: }
1139: }
1140:
1141: void SymbolDatabase :: createSymbolDatabaseSetTypePointers ( )
1142: {
1143: std ::@expr1073749860 set < std ::@expr1073749861 string > typenames@var2485 ;
1144: for (@expr1073749862 const Type &@expr1073749863 t@var2486 :@expr1073749864 typeList@var1334 ) {
1145: typenames@var2485 .@expr1073749865 insert (@expr1073749866 t@var2486 .@expr1073749867 name (@expr1073749868 ) ) ;
1146: }
1147:
1148:
1149: for (@expr1073749869 const Token *@expr8046 tok@var2487 =@expr1073749871 mTokenizer@var1403 .@expr8048 list@var3820 .@expr1073749873 front (@expr1073749874 ) ; tok@var2487 !=@expr1073749875 mTokenizer@var1403 .@expr8048 list@var3820 .@expr1073749877 back (@expr1073749878 ) ; tok@var2487 =@expr1073749879 tok@var2487 .@expr1073749880 next (@expr1073749881 ) ) {
1150: if (@expr1073749882 !@expr1073749883 tok@var2487 .@expr1073749884 isName (@expr1073749885 ) ||@expr1073749886 tok@var2487 .@expr1073749887 varId (@expr1073749888 ) ||@expr1073749889 tok@var2487 .@expr1073749890 function (@expr1073749891 ) ||@expr1073749892 tok@var2487 .@expr1073749893 type (@expr1073749894 ) ||@expr1073749895 tok@var2487 .@expr1073749896 enumerator (@expr1073749897 ) ) {
1151: continue ; }
1152:
1153: if (@expr1073749898 typenames@var2485 .@expr1073749899 find (@expr1073749900 tok@var2487 .@expr1073749901 str (@expr1073749902 ) ) ==@expr1073749903 typenames@var2485 .@expr1073749904 end (@expr1073749905 ) ) {
1154: continue ; }
1155:
1156: const Type * type@var2488 ; type@var2488 =@expr1073749906 findVariableType (@expr1073749907 tok@var2487 .@expr1073749908 scope (@expr1073749909 ) , tok@var2487 ) ;
1157: if (@expr1073749910 type@var2488 ) {
1158: const_cast < Token *@expr8046 > (@expr1073749912 tok@var2487 ) .@expr1073749913 type (@expr1073749914 type@var2488 ) ; }
1159: }
1160: }
1161:
1162: void SymbolDatabase :: createSymbolDatabaseSetSmartPointerType ( )
1163: {
1164: for (@expr1073749915 Scope &@expr8092 scope@var2489 :@expr1073749917 scopeList@var1331 ) {
1165: for (@expr1073749918 Variable &@expr8092 var@var2490 :@expr1073749920 scope@var2489 .@expr1073749921 varlist@var2491 ) {
1166: if (@expr1073749922 var@var2490 .@expr8099 valueType (@expr8100 ) &&@expr1073749925 var@var2490 .@expr8099 valueType (@expr8100 ) .@expr1073749928 smartPointerTypeToken@var3844 &&@expr1073749929 !@expr1073749930 var@var2490 .@expr8099 valueType (@expr8100 ) .@expr1073749933 smartPointerType@var3845 ) {
1167: ValueType vt@var2492 (@expr1073749934 *@expr1073749935 var@var2490 .@expr8099 valueType (@expr8100 ) ) ;
1168: vt@var2492 .@expr1073749938 smartPointerType@var2493 =@expr1073749939 vt@var2492 .@expr1073749940 smartPointerTypeToken@var2494 .@expr1073749941 type (@expr1073749942 ) ;
1169: var@var2490 .@expr1073749943 setValueType (@expr1073749944 vt@var2492 ) ;
1170: }
1171: }
1172: }
1173: }
1174:
1175: void SymbolDatabase :: fixVarId ( std :: map < unsigned int , std :: map < unsigned int , unsigned int > > & varIds@var2495 , const Token * vartok@var2496 , Token * membertok@var2497 , const Variable * membervar@var2498 )
1176: {
1177: std ::@expr1073749945 map < unsigned int , std ::@expr1073749946 map < unsigned int , unsigned int > > ::@expr1073749947 iterator varId@var2499 ; varId@var2499 =@expr1073749948 varIds@var2495 .@expr8125 find (@expr8126 vartok@var2496 .@expr8127 varId (@expr8128 ) ) ;
1178: if (@expr1073749953 varId@var2499 ==@expr1073749954 varIds@var2495 .@expr1073749955 end (@expr1073749956 ) ) {
1179: std ::@expr1073749957 map < unsigned int , unsigned int > memberId@var2500 ;
1180: if (@expr8134 membertok@var2497 .@expr8135 varId (@expr8136 ) ==@expr8137 0 ) {
1181: memberId@var2500 [@expr1073749962 membervar@var2498 .@expr8139 nameToken (@expr8140 ) .@expr8141 varId (@expr8142 ) ] =@expr1073749967 const_cast < Tokenizer *@expr8144 > (@expr8145 mTokenizer@var1403 ) .@expr8146 newVarId (@expr8147 ) ;
1182: mVariableList@var1406 .@expr8148 push_back (@expr8149 membervar@var2498 ) ;
1183: } else {
1184: mVariableList@var1406 [@expr8150 membertok@var2497 .@expr8135 varId (@expr8136 ) ] =@expr1073749977 membervar@var2498 ; }
1185: varIds@var2495 .@expr1073749978 insert (@expr1073749979 std ::@expr8156 make_pair (@expr1073749981 vartok@var2496 .@expr8127 varId (@expr8128 ) , memberId@var2500 ) ) ;
1186: varId@var2499 =@expr1073749984 varIds@var2495 .@expr8125 find (@expr8126 vartok@var2496 .@expr8127 varId (@expr8128 ) ) ;
1187: }
1188: std ::@expr1073749989 map < unsigned int , unsigned int > ::@expr1073749990 iterator memberId@var2501 ; memberId@var2501 =@expr1073749991 varId@var2499 .@expr8168 second@var2502 .@expr8169 find (@expr8170 membervar@var2498 .@expr8139 nameToken (@expr8140 ) .@expr8141 varId (@expr8142 ) ) ;
1189: if (@expr1073749999 memberId@var2501 ==@expr1073750000 varId@var2499 .@expr8168 second@var2502 .@expr1073750002 end (@expr1073750003 ) ) {
1190: if (@expr8134 membertok@var2497 .@expr8135 varId (@expr8136 ) ==@expr8137 0 ) {
1191: varId@var2499 .@expr8168 second@var2502 .@expr1073750009 insert (@expr1073750010 std ::@expr8156 make_pair (@expr1073750012 membervar@var2498 .@expr8139 nameToken (@expr8140 ) .@expr8141 varId (@expr8142 ) , const_cast < Tokenizer *@expr8144 > (@expr8145 mTokenizer@var1403 ) .@expr8146 newVarId (@expr8147 ) ) ) ;
1192: mVariableList@var1406 .@expr8148 push_back (@expr8149 membervar@var2498 ) ;
1193: memberId@var2501 =@expr1073750023 varId@var2499 .@expr8168 second@var2502 .@expr8169 find (@expr8170 membervar@var2498 .@expr8139 nameToken (@expr8140 ) .@expr8141 varId (@expr8142 ) ) ;
1194: } else {
1195: mVariableList@var1406 [@expr8150 membertok@var2497 .@expr8135 varId (@expr8136 ) ] =@expr1073750034 membervar@var2498 ; }
1196: }
1197: if (@expr8134 membertok@var2497 .@expr8135 varId (@expr8136 ) ==@expr8137 0 ) {
1198: membertok@var2497 .@expr8135 varId (@expr1073750040 memberId@var2501 .@expr1073750041 second@var2503 ) ; }
1199: }
1200:
1201: void SymbolDatabase :: createSymbolDatabaseSetVariablePointers ( )
1202: {
1203: std ::@expr1073750042 map < unsigned int , std ::@expr8219 map < unsigned int , unsigned int > > varIds@var2504 ;
1204:
1205:
1206: for (@expr1073750044 const Token *@expr8221 tok@var2505 =@expr1073750046 mTokenizer@var1403 .@expr8223 list@var3820 .@expr1073750048 front (@expr1073750049 ) ; tok@var2505 !=@expr1073750050 mTokenizer@var1403 .@expr8223 list@var3820 .@expr1073750052 back (@expr1073750053 ) ; tok@var2505 =@expr1073750054 tok@var2505 .@expr8231 next (@expr8232 ) ) {
1207: if (@expr1073750057 tok@var2505 .@expr8234 varId (@expr8235 ) ) {
1208: const_cast < Token *@expr8221 > (@expr1073750061 tok@var2505 ) .@expr1073750062 variable (@expr1073750063 getVariableFromVarId (@expr1073750064 tok@var2505 .@expr8234 varId (@expr8235 ) ) ) ; }
1209:
1210:
1211:
1212: const bool isVar@var2506 =@expr1073750067 tok@var2505 .@expr8244 variable (@expr8245 ) &&@expr1073750070 (@expr1073750071 tok@var2505 .@expr8244 variable (@expr8245 ) .@expr1073750074 typeScope (@expr1073750075 ) ||@expr1073750076 tok@var2505 .@expr8244 variable (@expr8245 ) .@expr1073750079 isSmartPointer (@expr1073750080 ) ||@expr1073750081 (@expr1073750082 tok@var2505 .@expr8259 valueType (@expr8260 ) &&@expr8261 tok@var2505 .@expr8259 valueType (@expr8260 ) .@expr8264 type@var3843 ==@expr8265 ValueType ::@expr8266 CONTAINER ) ) ;
1213: const bool isArrayAccess@var2507 =@expr1073750091 isVar@var2506 &&@expr1073750092 Token ::@expr8269 simpleMatch (@expr1073750094 tok@var2505 .@expr8271 astParent (@expr8272 ) , "[" ) ;
1214: const bool isDirectAccess@var2508 =@expr1073750097 isVar@var2506 &&@expr1073750098 !@expr1073750099 isArrayAccess@var2507 &&@expr1073750100 Token ::@expr8269 simpleMatch (@expr1073750102 tok@var2505 .@expr8271 astParent (@expr8272 ) , "." ) ;
1215: const bool isDerefAccess@var2509 =@expr1073750105 isVar@var2506 &&@expr1073750106 !@expr1073750107 isDirectAccess@var2508 &&@expr1073750108 Token ::@expr8269 simpleMatch (@expr1073750110 tok@var2505 .@expr8271 astParent (@expr8272 ) , "*" ) &&@expr1073750113 Token ::@expr8269 simpleMatch (@expr1073750115 tok@var2505 .@expr8271 astParent (@expr8272 ) .@expr8294 astParent (@expr8295 ) , "." ) ;
1216: if (@expr1073750120 isVar@var2506 &&@expr1073750121 (@expr1073750122 isArrayAccess@var2507 ||@expr1073750123 isDirectAccess@var2508 ||@expr1073750124 isDerefAccess@var2509 ) ) {
1217: Token * membertok@var2510 {@expr1073750125 } ;
1218: if (@expr1073750126 isArrayAccess@var2507 ) {
1219: membertok@var2510 =@expr1073750127 const_cast < Token *@expr8221 > (@expr8305 tok@var2505 .@expr8271 astParent (@expr8272 ) ) ;
1220: while (@expr1073750132 Token ::@expr8269 simpleMatch (@expr1073750134 membertok@var2510 , "[" ) ) {
1221: membertok@var2510 =@expr1073750135 membertok@var2510 .@expr8312 astParent (@expr8313 ) ; }
1222: if (@expr8314 membertok@var2510 ) {
1223: membertok@var2510 =@expr1073750139 membertok@var2510 .@expr8316 astOperand2 (@expr8317 ) ; }
1224: }
1225: else { if (@expr1073750142 isDirectAccess@var2508 ) {
1226: membertok@var2510 =@expr1073750143 const_cast < Token *@expr8221 > (@expr1073750145 tok@var2505 .@expr8271 astParent (@expr8272 ) .@expr1073750148 astOperand2 (@expr1073750149 ) ) ;
1227: if (@expr1073750150 membertok@var2510 ==@expr1073750151 tok@var2505 ) {
1228: Token * gptok@var2511 ; gptok@var2511 =@expr1073750152 const_cast < Token *@expr8221 > (@expr1073750154 tok@var2505 .@expr8271 astParent (@expr8272 ) .@expr8294 astParent (@expr8295 ) ) ;
1229: if (@expr1073750159 Token ::@expr8269 simpleMatch (@expr1073750161 gptok@var2511 , "." ) ) {
1230: membertok@var2510 =@expr1073750162 gptok@var2511 .@expr1073750163 astOperand2 (@expr1073750164 ) ; }
1231: else { if (@expr1073750165 Token ::@expr8269 simpleMatch (@expr1073750167 gptok@var2511 , "[" ) &&@expr1073750168 Token ::@expr8269 simpleMatch (@expr1073750170 gptok@var2511 .@expr8347 astParent (@expr8348 ) , "." ) ) {
1232: membertok@var2510 =@expr1073750173 gptok@var2511 .@expr8347 astParent (@expr8348 ) .@expr1073750176 astOperand2 (@expr1073750177 ) ; } }
1233: }
1234: }
1235: else {
1236: membertok@var2510 =@expr1073750178 const_cast < Token *@expr8221 > (@expr8305 tok@var2505 .@expr8271 astParent (@expr8272 ) ) ;
1237: while (@expr1073750183 Token ::@expr8269 simpleMatch (@expr1073750185 membertok@var2510 , "*" ) ) {
1238: membertok@var2510 =@expr1073750186 membertok@var2510 .@expr8312 astParent (@expr8313 ) ; }
1239: if (@expr8314 membertok@var2510 ) {
1240: membertok@var2510 =@expr1073750190 membertok@var2510 .@expr8316 astOperand2 (@expr8317 ) ; }
1241: } }
1242:
1243: if (@expr1073750193 membertok@var2510 &&@expr1073750194 membertok@var2510 !=@expr1073750195 tok@var2505 ) {
1244: const Variable * var@var2512 ; var@var2512 =@expr1073750196 tok@var2505 .@expr8244 variable (@expr8245 ) ;
1245: if (@expr1073750199 var@var2512 .@expr8376 typeScope (@expr8377 ) ) {
1246: const Variable * membervar@var2513 ; membervar@var2513 =@expr1073750202 var@var2512 .@expr8376 typeScope (@expr8377 ) .@expr1073750205 getVariable (@expr1073750206 membertok@var2510 .@expr8383 str (@expr8384 ) ) ;
1247: if (@expr1073750209 membervar@var2513 ) {
1248: membertok@var2510 .@expr8386 variable (@expr1073750211 membervar@var2513 ) ;
1249: if (@expr8388 membertok@var2510 .@expr8389 varId (@expr8390 ) ==@expr8391 0 ||@expr8392 mVariableList@var1406 [@expr8393 membertok@var2510 .@expr8389 varId (@expr8390 ) ] ==@expr8396 nullptr ) {
1250: fixVarId (@expr1073750221 varIds@var2504 , tok@var2505 , const_cast < Token *@expr8221 > (@expr8399 membertok@var2510 ) , membervar@var2513 ) ; }
1251: }
1252: } else { if (@expr1073750224 const ::@expr8219 Type *@expr8221 type@var2514 =@expr1073750227 var@var2512 .@expr1073750228 smartPointerType (@expr1073750229 ) ) {
1253: const Scope * classScope@var2515 ; classScope@var2515 =@expr1073750230 type@var2514 .@expr1073750231 classScope@var2516 ;
1254: const Variable * membervar@var2517 ; membervar@var2517 =@expr1073750232 classScope@var2515 ?@expr1073750233 classScope@var2515 .@expr1073750234 getVariable (@expr1073750235 membertok@var2510 .@expr8383 str (@expr8384 ) ) :@expr1073750238 nullptr ;
1255: if (@expr1073750239 membervar@var2517 ) {
1256: membertok@var2510 .@expr8386 variable (@expr1073750241 membervar@var2517 ) ;
1257: if (@expr8388 membertok@var2510 .@expr8389 varId (@expr8390 ) ==@expr8391 0 ||@expr8392 mVariableList@var1406 [@expr8393 membertok@var2510 .@expr8389 varId (@expr8390 ) ] ==@expr8396 nullptr ) {
1258: fixVarId (@expr1073750251 varIds@var2504 , tok@var2505 , const_cast < Token *@expr8221 > (@expr8399 membertok@var2510 ) , membervar@var2517 ) ; }
1259: }
1260: } else { if (@expr1073750254 tok@var2505 .@expr8259 valueType (@expr8260 ) &&@expr8261 tok@var2505 .@expr8259 valueType (@expr8260 ) .@expr8264 type@var3843 ==@expr8265 ValueType ::@expr8266 CONTAINER ) {
1261: if (@expr1073750263 Token ::@expr8440 Match (@expr1073750265 var@var2512 .@expr8442 typeStartToken (@expr8443 ) , "std :: %type% < %name%" ) ) {
1262: const Token * type2tok@var2518 ; type2tok@var2518 =@expr1073750268 var@var2512 .@expr8442 typeStartToken (@expr8443 ) .@expr1073750271 tokAt (@expr1073750272 4 ) ;
1263: while (@expr1073750273 type2tok@var2518 &&@expr1073750274 type2tok@var2518 .@expr1073750275 isKeyword (@expr1073750276 ) ) {
1264: type2tok@var2518 =@expr1073750277 type2tok@var2518 .@expr1073750278 next (@expr1073750279 ) ; }
1265: const Type * type2@var2519 ; type2@var2519 =@expr1073750280 type2tok@var2518 ?@expr1073750281 type2tok@var2518 .@expr1073750282 type (@expr1073750283 ) :@expr1073750284 nullptr ;
1266: if (@expr1073750285 type2@var2519 &&@expr1073750286 type2@var2519 .@expr8463 classScope@var2520 &&@expr1073750288 type2@var2519 .@expr8463 classScope@var2520 .@expr1073750290 definedType@var2521 ) {
1267: const Variable * membervar@var2522 ; membervar@var2522 =@expr1073750291 type2@var2519 .@expr8463 classScope@var2520 .@expr1073750293 getVariable (@expr1073750294 membertok@var2510 .@expr8383 str (@expr8384 ) ) ;
1268: if (@expr1073750297 membervar@var2522 ) {
1269: membertok@var2510 .@expr8386 variable (@expr1073750299 membervar@var2522 ) ;
1270: if (@expr8388 membertok@var2510 .@expr8389 varId (@expr8390 ) ==@expr8391 0 ||@expr8392 mVariableList@var1406 [@expr8393 membertok@var2510 .@expr8389 varId (@expr8390 ) ] ==@expr8396 nullptr ) {
1271: fixVarId (@expr1073750309 varIds@var2504 , tok@var2505 , const_cast < Token *@expr8221 > (@expr8399 membertok@var2510 ) , membervar@var2522 ) ; }
1272: }
1273: }
1274: }
1275: } } }
1276: }
1277: }
1278:
|
1281:
1282: else { if (@expr1073750312 tok@var2505 .@expr8489 function (@expr8490 ) &&@expr1073750315 tok@var2505 .@expr8231 next (@expr8232 ) .@expr1073750318 str (@expr1073750319 ) ==@expr1073750320 "(" &&@expr1073750321
1283: (@expr1073750322 Token ::@expr8440 Match (@expr1073750324 tok@var2505 .@expr8231 next (@expr8232 ) .@expr8503 link (@expr8504 ) , ") . %name% !!(" ) ||@expr1073750329
1284: (@expr1073750330 Token ::@expr8440 Match (@expr1073750332 tok@var2505 .@expr8231 next (@expr8232 ) .@expr8503 link (@expr8504 ) , ") [" ) &&@expr1073750337 Token ::@expr8440 Match (@expr1073750339 tok@var2505 .@expr8231 next (@expr8232 ) .@expr8503 link (@expr8504 ) .@expr8520 next (@expr8521 ) .@expr8522 link (@expr8523 ) , "] . %name% !!(" ) ) ) ) {
1285: const Type * type@var2523 ; type@var2523 =@expr1073750348 tok@var2505 .@expr8489 function (@expr8490 ) .@expr1073750351 retType@var3846 ;
1286: if (@expr1073750352 type@var2523 ) {
1287: Token * membertok@var2524 ;
1288: if (@expr1073750353 tok@var2505 .@expr8231 next (@expr8232 ) .@expr8503 link (@expr8504 ) .@expr8520 next (@expr8521 ) .@expr1073750360 str (@expr1073750361 ) ==@expr1073750362 "." ) {
1289: membertok@var2524 =@expr1073750363 tok@var2505 .@expr8231 next (@expr8232 ) .@expr8503 link (@expr8504 ) .@expr8520 next (@expr8521 ) .@expr1073750370 next (@expr1073750371 ) ; }
1290: else {
1291: membertok@var2524 =@expr1073750372 tok@var2505 .@expr8231 next (@expr8232 ) .@expr8503 link (@expr8504 ) .@expr8520 next (@expr8521 ) .@expr8522 link (@expr8523 ) .@expr1073750381 next (@expr1073750382 ) .@expr1073750383 next (@expr1073750384 ) ; }
1292: const Variable * membervar@var2525 ; membervar@var2525 =@expr1073750385 membertok@var2524 .@expr8562 variable (@expr1073750387 ) ;
1293: if (@expr1073750388 !@expr1073750389 membervar@var2525 ) {
1294: if (@expr1073750390 type@var2523 .@expr8567 classScope@var2526 ) {
1295: membervar@var2525 =@expr1073750392 type@var2523 .@expr8567 classScope@var2526 .@expr1073750394 getVariable (@expr1073750395 membertok@var2524 .@expr1073750396 str (@expr1073750397 ) ) ;
1296: if (@expr1073750398 membervar@var2525 ) {
1297: membertok@var2524 .@expr8562 variable (@expr1073750400 membervar@var2525 ) ;
1298: if (@expr1073750401 membertok@var2524 .@expr8578 varId (@expr8579 ) ==@expr1073750404 0 ||@expr1073750405 mVariableList@var1406 [@expr1073750406 membertok@var2524 .@expr8578 varId (@expr8579 ) ] ==@expr1073750409 nullptr ) {
1299: if (@expr1073750410 tok@var2505 .@expr8489 function (@expr8490 ) .@expr8589 retDef@var3847 ) {
1300: fixVarId (@expr1073750414 varIds@var2504 , tok@var2505 .@expr8489 function (@expr8490 ) .@expr8589 retDef@var3847 , const_cast < Token *@expr8221 > (@expr1073750419 membertok@var2524 ) , membervar@var2525 ) ; }
1301: }
1302: }
1303: }
1304: }
1305: }
1306: } }
1307: }
1308: }
1309:
1310: void SymbolDatabase :: createSymbolDatabaseEnums ( )
1311: {
1312:
1313: for (@expr1073750420 Scope &@expr8597 scope@var2527 :@expr1073750422 scopeList@var1331 ) {
1314: if (@expr1073750423 scope@var2527 .@expr1073750424 type@var2528 !=@expr1073750425 Scope ::@expr8602 eEnum ) {
1315: continue ; }
1316:
1317:
1318: for (@expr1073750427 Enumerator &@expr8597 i@var2529 :@expr1073750429 scope@var2527 .@expr1073750430 enumeratorList@var2530 ) {
1319: const_cast < Token *@expr8607 > (@expr1073750432 i@var2529 .@expr1073750433 name@var2531 ) .@expr1073750434 enumerator (@expr1073750435 &@expr1073750436 i@var2529 ) ; }
1320: }
1321:
1322: for (@expr1073750437 Scope &@expr8597 scope@var2532 :@expr1073750439 scopeList@var1331 ) {
1323: if (@expr1073750440 scope@var2532 .@expr1073750441 type@var2533 !=@expr1073750442 Scope ::@expr8602 eEnum ) {
1324: continue ; }
1325:
1326: for (@expr1073750444 Enumerator &@expr8597 enumerator@var2534 :@expr1073750446 scope@var2532 .@expr1073750447 enumeratorList@var2535 ) {
1327:
1328: if (@expr1073750448 enumerator@var2534 .@expr8625 start@var2536 ) {
1329: if (@expr1073750450 !@expr1073750451 enumerator@var2534 .@expr8628 end@var2537 ) {
1330: mTokenizer@var1403 .@expr1073750453 syntaxError (@expr1073750454 enumerator@var2534 .@expr8625 start@var2536 ) ; }
1331: for (@expr1073750456 const Token *@expr8607 tok3@var2538 =@expr1073750458 enumerator@var2534 .@expr8625 start@var2536 ; tok3@var2538 &&@expr1073750460 tok3@var2538 !=@expr1073750461 enumerator@var2534 .@expr8628 end@var2537 .@expr1073750463 next (@expr1073750464 ) ; tok3@var2538 =@expr1073750465 tok3@var2538 .@expr1073750466 next (@expr1073750467 ) ) {
1332: if (@expr1073750468 tok3@var2538 .@expr1073750469 tokType (@expr1073750470 ) ==@expr1073750471 Token ::@expr8648 eName ) {
1333: const Enumerator * e@var2539 ; e@var2539 =@expr1073750473 findEnumerator (@expr1073750474 tok3@var2538 ) ;
1334: if (@expr1073750475 e@var2539 ) {
1335: const_cast < Token *@expr8607 > (@expr1073750477 tok3@var2538 ) .@expr1073750478 enumerator (@expr1073750479 e@var2539 ) ; }
1336: }
1337: }
1338: }
1339: }
1340: }
1341:
1342:
1343: for (@expr1073750480 const Token *@expr8607 tok@var2540 =@expr1073750482 mTokenizer@var1403 .@expr8659 list@var3820 .@expr1073750484 front (@expr1073750485 ) ; tok@var2540 !=@expr1073750486 mTokenizer@var1403 .@expr8659 list@var3820 .@expr1073750488 back (@expr1073750489 ) ; tok@var2540 =@expr1073750490 tok@var2540 .@expr1073750491 next (@expr1073750492 ) ) {
1344: if (@expr1073750493 tok@var2540 .@expr1073750494 tokType (@expr1073750495 ) !=@expr1073750496 Token ::@expr8648 eName ) {
1345: continue ; }
1346: const Enumerator * enumerator@var2541 ; enumerator@var2541 =@expr1073750498 findEnumerator (@expr1073750499 tok@var2540 ) ;
1347: if (@expr1073750500 enumerator@var2541 ) {
1348: const_cast < Token *@expr8607 > (@expr1073750502 tok@var2540 ) .@expr1073750503 enumerator (@expr1073750504 enumerator@var2541 ) ; }
1349: }
1350: }
1351:
1352: void SymbolDatabase :: createSymbolDatabaseIncompleteVars ( )
1353: {
1354: static const std ::@expr1073750505 unordered_set < std ::@expr8682 string > cpp20keywords@var2542 =@expr1073750507 {@expr1073750508
1355: "alignas" ,
1356: "alignof" ,
1357: "axiom" ,
1358: "co_await" ,
1359: "co_return" ,
1360: "co_yield" ,
1361: "concept" ,
1362: "synchronized" ,
1363: "consteval" ,
1364: "reflexpr" ,
1365: "requires" ,
1366: } ;
1367: static const std ::@expr1073750509 unordered_set < std ::@expr8682 string > cppkeywords@var2543 =@expr1073750511 {@expr1073750512
1368: "asm" ,
1369: "auto" ,
1370: "catch" ,
1371: "char" ,
1372: "class" ,
1373: "const" ,
1374: "constexpr" ,
1375: "decltype" ,
1376: "default" ,
1377: "do" ,
1378: "enum" ,
1379: "explicit" ,
1380: "export" ,
1381: "extern" ,
1382: "final" ,
1383: "friend" ,
1384: "inline" ,
1385: "mutable" ,
1386: "namespace" ,
1387: "new" ,
1388: "noexcept" ,
1389: "nullptr" ,
1390: "override" ,
1391: "private" ,
1392: "protected" ,
1393: "public" ,
1394: "register" ,
1395: "sizeof" ,
1396: "static" ,
1397: "static_assert" ,
1398: "struct" ,
1399: "template" ,
1400: "this" ,
1401: "thread_local" ,
1402: "throw" ,
1403: "try" ,
1404: "typedef" ,
1405: "typeid" ,
1406: "typename" ,
1407: "union" ,
1408: "using" ,
1409: "virtual" ,
1410: "void" ,
1411: "volatile" ,
1412: "NULL" ,
1413: } ;
1414: for (@expr1073750513 const Token *@expr8690 tok@var2544 =@expr1073750515 mTokenizer@var1403 .@expr8692 list@var3820 .@expr1073750517 front (@expr1073750518 ) ; tok@var2544 !=@expr1073750519 mTokenizer@var1403 .@expr8692 list@var3820 .@expr1073750521 back (@expr1073750522 ) ; tok@var2544 =@expr1073750523 tok@var2544 .@expr8700 next (@expr8701 ) ) {
1415: const Scope * scope@var2545 ; scope@var2545 =@expr1073750526 tok@var2544 .@expr1073750527 scope (@expr1073750528 ) ;
1416: if (@expr1073750529 !@expr1073750530 scope@var2545 ) {
1417: continue ; }
1418: if (@expr1073750531 !@expr1073750532 scope@var2545 .@expr1073750533 isExecutable (@expr1073750534 ) ) {
1419: continue ; }
1420: if (@expr1073750535 !@expr1073750536 Token ::@expr8713 Match (@expr1073750538 tok@var2544 , "%name%" ) ) {
1421: continue ; }
1422: if (@expr1073750539 !@expr1073750540 tok@var2544 .@expr1073750541 isNameOnly (@expr1073750542 ) ) {
1423: continue ; }
1424: if (@expr1073750543 Token ::@expr8713 Match (@expr1073750545 tok@var2544 , "%var%" ) ) {
1425: continue ; }
1426: if (@expr1073750546 tok@var2544 .@expr1073750547 type (@expr1073750548 ) ) {
1427: continue ; }
1428: if (@expr1073750549 Token ::@expr8713 Match (@expr1073750551 tok@var2544 .@expr8700 next (@expr8701 ) , "::|.|(|:|%var%" ) ) {
1429: continue ; }
1430: if (@expr1073750554 Token ::@expr8713 Match (@expr1073750556 tok@var2544 .@expr8700 next (@expr8701 ) , "&|&&|* )|%var%" ) ) {
1431: continue ; }
1432: if (@expr1073750559 Token ::@expr8736 simpleMatch (@expr1073750561 tok@var2544 .@expr8700 next (@expr8701 ) , ")" ) &&@expr1073750564 Token ::@expr8736 simpleMatch (@expr1073750566 tok@var2544 .@expr8700 next (@expr8701 ) .@expr8745 link (@expr8746 ) .@expr1073750571 previous (@expr1073750572 ) , "catch (" ) ) {
1433: continue ; }
1434:
1435: if (@expr1073750573 Token ::@expr8713 Match (@expr1073750575 tok@var2544 .@expr1073750576 tokAt (@expr1073750577 -2 ) , "%type% ," ) ||@expr1073750578 Token ::@expr8713 Match (@expr1073750580 tok@var2544 .@expr8700 next (@expr8701 ) , ", %type%" ) ) {
1436: continue ; }
1437:
1438: if (@expr1073750583 Token ::@expr8713 Match (@expr1073750585 tok@var2544 .@expr8700 next (@expr8701 ) , "<|>" ) &&@expr1073750588 tok@var2544 .@expr8700 next (@expr8701 ) .@expr8745 link (@expr8746 ) ) {
1439: continue ; }
1440: if (@expr1073750593 Token ::@expr8736 simpleMatch (@expr1073750595 tok@var2544 .@expr8772 previous (@expr8773 ) , "<" ) &&@expr1073750598 tok@var2544 .@expr8772 previous (@expr8773 ) .@expr1073750601 link (@expr1073750602 ) ) {
1441: continue ; }
1442:
1443: if (@expr1073750603 Token ::@expr8736 simpleMatch (@expr1073750605 tok@var2544 .@expr8772 previous (@expr8773 ) , "goto" ) ) {
1444: continue ; }
1445: if (@expr1073750608 cppkeywords@var2543 .@expr1073750609 count (@expr1073750610 tok@var2544 .@expr8787 str (@expr8788 ) ) >@expr1073750613 0 ) {
1446: continue ; }
1447: if (@expr1073750614 mSettings@var1404 .@expr1073750615 standards@var3822 .@expr1073750616 cpp@var3823 >=@expr1073750617 Standards ::@expr1073750618 CPP20 &&@expr1073750619 cpp20keywords@var2542 .@expr1073750620 count (@expr1073750621 tok@var2544 .@expr8787 str (@expr8788 ) ) >@expr1073750624 0 ) {
1448: continue ; }
1449: const_cast < Token *@expr8690 > (@expr1073750626 tok@var2544 ) .@expr1073750627 isIncompleteVar (@expr1073750628 true ) ;
1450: }
1451: }
1452:
1453: void SymbolDatabase :: createSymbolDatabaseEscapeFunctions ( )
1454: {
1455: for (@expr1073750629 Scope &@expr1073750630 scope@var2546 :@expr1073750631 scopeList@var1331 ) {
1456: if (@expr1073750632 scope@var2546 .@expr1073750633 type@var2547 !=@expr1073750634 Scope ::@expr1073750635 eFunction ) {
1457: continue ; }
1458: Function * function@var2548 ; function@var2548 =@expr1073750636 scope@var2546 .@expr1073750637 function@var2549 ;
1459: if (@expr1073750638 !@expr1073750639 function@var2548 ) {
1460: continue ; }
1461: if (@expr1073750640 Token ::@expr1073750641 findsimplematch (@expr1073750642 scope@var2546 .@expr1073750643 bodyStart@var2550 , "return" , scope@var2546 .@expr8820 bodyEnd@var2551 ) ) {
1462: continue ; }
1463: function@var2548 .@expr1073750645 isEscapeFunction (@expr1073750646 isReturnScope (@expr1073750647 scope@var2546 .@expr8820 bodyEnd@var2551 , &@expr1073750649 mSettings@var1404 .@expr1073750650 library@var3824 , nullptr , true ) ) ;
1464: }
1465: }
1466:
1467: static bool isExpression ( const Token * tok@var2552 )
1468: {
1469: if (@expr1073750651 !@expr1073750652 tok@var2552 ) {
1470: return false ; }
1471: if (@expr1073750653 Token ::@expr1073750654 simpleMatch (@expr1073750655 tok@var2552 , "{" ) &&@expr1073750656 tok@var2552 .@expr8833 scope (@expr8834 ) &&@expr1073750659 tok@var2552 .@expr8833 scope (@expr8834 ) .@expr1073750662 bodyStart@var3848 !=@expr1073750663 tok@var2552 &&@expr1073750664
1472: (@expr1073750665 tok@var2552 .@expr1073750666 astOperand1 (@expr1073750667 ) ||@expr1073750668 tok@var2552 .@expr1073750669 astOperand2 (@expr1073750670 ) ) ) {
1473: return true ; }
1474: if (@expr1073750671 !@expr1073750672 Token ::@expr8849 Match (@expr1073750674 tok@var2552 , "(|.|[|::|?|:|++|--|%cop%|%assign%" ) ) {
1475: return false ; }
1476: if (@expr1073750675 Token ::@expr8849 Match (@expr1073750677 tok@var2552 , "*|&|&&" ) ) {
1477: const Token * vartok@var2553 ; vartok@var2553 =@expr1073750678 findAstNode (@expr1073750679 tok@var2552 , [@expr1073750680 &@expr1073750681 ] (@expr1073750682 const Token *@expr1073750683 tok2@var2554 ) {
1478: const Variable * var@var2555 ; var@var2555 =@expr1073750684 tok2@var2554 .@expr1073750685 variable (@expr1073750686 ) ;
1479: if (@expr1073750687 !@expr1073750688 var@var2555 ) {
1480: return false ; }
1481: return var@var2555 .@expr1073750689 nameToken (@expr1073750690 ) ==@expr1073750691 tok2@var2554 ;
1482: } ) ;
1483: if (@expr1073750692 vartok@var2553 ) {
1484: return false ; }
1485: }
1486: return true ;
1487: }
1488:
1489: static std :: string getIncompleteNameID ( const Token * tok@var2556 )
1490: {
1491: std ::@expr1073750693 string result@var2557 ; result@var2557 =@expr1073750694 tok@var2556 .@expr1073750695 str (@expr1073750696 ) +@expr1073750697 "@" ;
1492: while (@expr1073750698 Token ::@expr1073750699 Match (@expr1073750700 tok@var2556 .@expr8877 astParent (@expr8878 ) , ".|::" ) ) {
1493: tok@var2556 =@expr1073750703 tok@var2556 .@expr8877 astParent (@expr8878 ) ; }
1494: return result@var2557 +@expr1073750706 tok@var2556 .@expr1073750707 expressionString (@expr1073750708 ) ;
1495: }
1496:
1497: void SymbolDatabase :: createSymbolDatabaseExprIds ( )
1498: {
1499: int base@var2558 ; base@var2558 =@expr1073750709 0 ;
1500:
1501: for (@expr1073750710 const Variable *@expr8887 var@var2559 :@expr1073750712 mVariableList@var1406 ) {
1502: if (@expr1073750713 !@expr1073750714 var@var2559 ) {
1503: continue ; }
1504: base@var2558 =@expr1073750715 std ::@expr1073750716 max < long long > (@expr1073750717 base@var2558 , var@var2559 .@expr1073750718 declarationId (@expr1073750719 ) ) ;
1505: }
1506: int id@var2560 ; id@var2560 =@expr1073750720 base@var2558 +@expr1073750721 1 ;
1507:
1508: std ::@expr1073750722 unordered_map < std ::@expr8899 string , int > unknownConstantIds@var2561 ;
1509: const Token * inConstExpr@var2562 ; inConstExpr@var2562 =@expr1073750724 nullptr ;
1510: for (@expr1073750725 const Token *@expr8887 tok@var2563 =@expr1073750727 mTokenizer@var1403 .@expr8904 list@var3820 .@expr1073750729 front (@expr1073750730 ) ; tok@var2563 !=@expr1073750731 mTokenizer@var1403 .@expr8904 list@var3820 .@expr1073750733 back (@expr1073750734 ) ; tok@var2563 =@expr1073750735 tok@var2563 .@expr8912 next (@expr8913 ) ) {
1511: if (@expr1073750738 Token ::@expr8915 Match (@expr1073750740 tok@var2563 , "decltype|sizeof|typeof (" ) &&@expr1073750741 tok@var2563 .@expr8912 next (@expr8913 ) .@expr8920 link (@expr8921 ) ) {
1512: tok@var2563 =@expr1073750746 tok@var2563 .@expr8912 next (@expr8913 ) .@expr8920 link (@expr8921 ) .@expr1073750751 previous (@expr1073750752 ) ;
1513: } else { if (@expr1073750753 tok@var2563 ==@expr1073750754 inConstExpr@var2562 ) {
1514: inConstExpr@var2562 =@expr1073750755 nullptr ;
1515: } else { if (@expr1073750756 inConstExpr@var2562 ) {
1516: if (@expr1073750757 !@expr1073750758 tok@var2563 .@expr1073750759 isIncompleteVar (@expr1073750760 ) ) {
1517: continue ; }
1518: if (@expr1073750761 !@expr1073750762 isExpression (@expr1073750763 tok@var2563 .@expr1073750764 astParent (@expr1073750765 ) ) ) {
1519: continue ; }
1520: const std ::@expr8899 string &@expr8943 name@var2564 =@expr1073750768 getIncompleteNameID (@expr1073750769 tok@var2563 ) ;
1521: if (@expr1073750770 unknownConstantIds@var2561 .@expr8947 count (@expr1073750772 name@var2564 ) >@expr1073750773 0 ) {
1522: continue ; }
1523: unknownConstantIds@var2561 [@expr1073750774 name@var2564 ] =@expr1073750775 id@var2560 ++@expr1073750776 ;
1524: } else { if (@expr1073750777 tok@var2563 .@expr8954 link (@expr8955 ) &&@expr1073750780 tok@var2563 .@expr1073750781 str (@expr1073750782 ) ==@expr1073750783 "<" ) {
1525: inConstExpr@var2562 =@expr1073750784 tok@var2563 .@expr8954 link (@expr8955 ) ;
1526: } else { if (@expr1073750787 Token ::@expr8915 Match (@expr1073750789 tok@var2563 , "%var% [" ) &&@expr1073750790 tok@var2563 .@expr8967 variable (@expr8968 ) &&@expr1073750793 tok@var2563 .@expr8967 variable (@expr8968 ) .@expr1073750796 nameToken (@expr1073750797 ) ==@expr1073750798 tok@var2563 ) {
1527: inConstExpr@var2562 =@expr1073750799 tok@var2563 .@expr8912 next (@expr8913 ) .@expr8920 link (@expr8921 ) ;
1528: } } } } }
1529: }
1530: for (@expr1073750804 const Scope *@expr8887 scope@var2565 :@expr1073750806 functionScopes@var1332 ) {
1531: int thisId@var2566 ; thisId@var2566 =@expr1073750807 0 ;
1532: std ::@expr1073750808 unordered_map < std ::@expr8899 string , std ::@expr8899 vector < Token *@expr8887 > > exprs@var2567 ;
1533:
1534: std ::@expr1073750812 unordered_map < std ::@expr8899 string , int > unknownIds@var2568 ;
1535:
1536:
1537: for (@expr1073750814 Token *@expr8887 tok@var2569 =@expr1073750816 const_cast < Token *@expr8887 > (@expr8994 scope@var2565 .@expr8995 bodyStart@var2570 ) ; tok@var2569 !=@expr1073750820 scope@var2565 .@expr8997 bodyEnd@var2571 ; tok@var2569 =@expr1073750822 tok@var2569 .@expr1073750823 next (@expr1073750824 ) ) {
1538: if (@expr1073750825 !@expr1073750826 tok@var2569 .@expr1073750827 isIncompleteVar (@expr1073750828 ) ) {
1539: continue ; }
1540: if (@expr1073750829 !@expr1073750830 isExpression (@expr1073750831 tok@var2569 .@expr1073750832 astParent (@expr1073750833 ) ) ) {
1541: continue ; }
1542: const std ::@expr8899 string &@expr8943 name@var2572 =@expr1073750836 getIncompleteNameID (@expr1073750837 tok@var2569 ) ;
1543: int sid@var2573 ; sid@var2573 =@expr1073750838 0 ;
1544: if (@expr1073750839 unknownConstantIds@var2561 .@expr8947 count (@expr1073750841 name@var2572 ) >@expr1073750842 0 ) {
1545: sid@var2573 =@expr1073750843 unknownConstantIds@var2561 .@expr1073750844 at (@expr1073750845 name@var2572 ) ;
1546: tok@var2569 .@expr1073750846 isIncompleteConstant (@expr1073750847 true ) ;
1547: } else { if (@expr1073750848 unknownIds@var2568 .@expr1073750849 count (@expr1073750850 name@var2572 ) ==@expr1073750851 0 ) {
1548: sid@var2573 =@expr1073750852 id@var2560 ++@expr1073750853 ;
1549: unknownIds@var2568 [@expr1073750854 name@var2572 ] =@expr1073750855 sid@var2573 ;
1550: } else {
1551: sid@var2573 =@expr1073750856 unknownIds@var2568 .@expr1073750857 at (@expr1073750858 name@var2572 ) ;
1552: } }
1553: assert (@expr1073750859 sid@var2573 >@expr1073750860 0 ) ;
1554: tok@var2569 .@expr1073750861 exprId (@expr1073750862 sid@var2573 ) ;
1555: }
1556:
1557:
1558: for (@expr1073750863 Token *@expr8887 tok@var2574 =@expr1073750865 const_cast < Token *@expr8887 > (@expr8994 scope@var2565 .@expr8995 bodyStart@var2570 ) ; tok@var2574 !=@expr1073750869 scope@var2565 .@expr8997 bodyEnd@var2571 ; tok@var2574 =@expr1073750871 tok@var2574 .@expr1073750872 next (@expr1073750873 ) ) {
1559: if (@expr1073750874 tok@var2574 .@expr9051 varId (@expr9052 ) >@expr1073750877 0 ) {
1560: tok@var2574 .@expr9054 exprId (@expr1073750879 tok@var2574 .@expr9051 varId (@expr9052 ) ) ;
1561: } else { if (@expr1073750882 isExpression (@expr1073750883 tok@var2574 ) ) {
1562: exprs@var2567 [@expr1073750884 tok@var2574 .@expr1073750885 str (@expr1073750886 ) ] .@expr1073750887 push_back (@expr1073750888 tok@var2574 ) ;
1563: tok@var2574 .@expr9054 exprId (@expr1073750890 id@var2560 ++@expr1073750891 ) ;
1564:
1565: if (@expr1073750892 id@var2560 ==@expr1073750893 std ::@expr1073750894 numeric_limits < int > ::@expr1073750895 max (@expr1073750896 ) ) {
1566: throw InternalError (@expr1073750897 nullptr , "Ran out of expression ids." , InternalError ::@expr1073750898 INTERNAL ) ;
1567: }
1568: } else { if (@expr1073750899 isCPP (@expr9076 ) &&@expr1073750901 Token ::@expr1073750902 simpleMatch (@expr1073750903 tok@var2574 , "this" ) ) {
1569: if (@expr1073750904 thisId@var2566 ==@expr1073750905 0 ) {
1570: thisId@var2566 =@expr1073750906 id@var2560 ++@expr1073750907 ; }
1571: tok@var2574 .@expr9054 exprId (@expr1073750909 thisId@var2566 ) ;
1572: } } }
1573: }
1574:
1575:
1576: for (@expr1073750910 const auto &@expr8943 p@var2575 :@expr1073750912 exprs@var2567 ) {
1577: const std ::@expr1073750913 vector < Token *@expr8887 > & tokens@var2576 =@expr1073750915 p@var2575 .@expr1073750916 second@var2577 ;
1578: for (@expr1073750917 Token *@expr8887 tok1@var2578 :@expr1073750919 tokens@var2576 ) {
1579: for (@expr1073750920 Token *@expr8887 tok2@var2579 :@expr1073750922 tokens@var2576 ) {
1580: if (@expr1073750923 tok1@var2578 ==@expr1073750924 tok2@var2579 ) {
1581: continue ; }
1582: if (@expr1073750925 tok1@var2578 .@expr9102 exprId (@expr9103 ) ==@expr1073750928 tok2@var2579 .@expr9105 exprId (@expr9106 ) ) {
1583: continue ; }
1584: if (@expr1073750931 !@expr1073750932 isSameExpression (@expr1073750933 isCPP (@expr9076 ) , true , tok1@var2578 , tok2@var2579 , mSettings@var1404 .@expr1073750935 library@var3824 , false , false ) ) {
1585: continue ; }
1586: int cid@var2580 ; cid@var2580 =@expr1073750936 std ::@expr1073750937 min (@expr1073750938 tok1@var2578 .@expr9102 exprId (@expr9103 ) , tok2@var2579 .@expr9105 exprId (@expr9106 ) ) ;
1587: tok1@var2578 .@expr9102 exprId (@expr1073750944 cid@var2580 ) ;
1588: tok2@var2579 .@expr9105 exprId (@expr1073750946 cid@var2580 ) ;
1589: }
1590: }
1591: }
1592: }
1593: }
1594:
1595: void SymbolDatabase :: setArrayDimensionsUsingValueFlow ( )
1596: {
1597:
1598: for (@expr1073750947 const Variable *@expr9124 var@var2581 :@expr1073750949 mVariableList@var1406 ) {
1599:
1600: if (@expr1073750950 !@expr1073750951 var@var2581 ||@expr1073750952 !@expr1073750953 var@var2581 .@expr1073750954 isArray (@expr1073750955 ) ) {
1601: continue ; }
1602:
1603: for (@expr1073750956 const Dimension &@expr9133 const_dimension@var2582 :@expr1073750958 var@var2581 .@expr1073750959 dimensions (@expr1073750960 ) ) {
1604: Dimension &@expr9133 dimension@var2583 =@expr1073750962 const_cast < Dimension &@expr9133 > (@expr1073750964 const_dimension@var2582 ) ;
1605: if (@expr1073750965 dimension@var2583 .@expr9142 num@var2584 !=@expr1073750967 0 ||@expr1073750968 !@expr1073750969 dimension@var2583 .@expr9146 tok@var2585 ) {
1606: continue ; }
1607:
1608: if (@expr1073750971 Token ::@expr9148 Match (@expr9149 dimension@var2583 .@expr9146 tok@var2585 .@expr9151 previous (@expr9152 ) , "[<,]" ) ) {
1609: if (@expr1073750977 dimension@var2583 .@expr9154 known@var2586 ) {
1610: continue ; }
1611: if (@expr1073750979 !@expr1073750980 Token ::@expr9148 Match (@expr9149 dimension@var2583 .@expr9146 tok@var2585 .@expr9151 previous (@expr9152 ) , "[<,]" ) ) {
1612: continue ; }
1613:
1614:
1615:
1616: TokenList tokenList@var2587 (@expr1073750986 mSettings@var1404 ) ;
1617: tokenList@var2587 .@expr9163 addtoken (@expr9164 ";" , 0 , 0 , 0 , false ) ;
1618: bool fail@var2588 ; fail@var2588 =@expr1073750989 false ;
1619: for (@expr1073750990 const Token *@expr9124 tok@var2589 =@expr1073750992 dimension@var2583 .@expr9146 tok@var2585 ; tok@var2589 &&@expr1073750994 !@expr1073750995 Token ::@expr9148 Match (@expr1073750997 tok@var2589 , "[,>]" ) ; tok@var2589 =@expr1073750998 tok@var2589 .@expr1073750999 next (@expr1073751000 ) ) {
1620: if (@expr1073751001 !@expr1073751002 tok@var2589 .@expr1073751003 isName (@expr1073751004 ) ) {
1621: tokenList@var2587 .@expr9163 addtoken (@expr1073751006 tok@var2589 .@expr1073751007 str (@expr1073751008 ) , 0 , 0 , 0 , false ) ; }
1622:
1623: else { if (@expr1073751009 tok@var2589 .@expr1073751010 hasKnownIntValue (@expr1073751011 ) ) {
1624: tokenList@var2587 .@expr9163 addtoken (@expr1073751013 std ::@expr1073751014 to_string (@expr1073751015 tok@var2589 .@expr1073751016 getKnownIntValue (@expr1073751017 ) ) , 0 , 0 , 0 , false ) ; }
1625:
1626: else {
1627: fail@var2588 =@expr1073751018 true ;
1628: break ;
1629: } }
1630: }
1631:
1632: if (@expr1073751019 fail@var2588 ) {
1633: continue ; }
1634:
1635: tokenList@var2587 .@expr9163 addtoken (@expr9164 ";" , 0 , 0 , 0 , false ) ;
1636:
1637: for (@expr1073751022 Token *@expr9124 tok@var2590 =@expr1073751024 tokenList@var2587 .@expr9201 front (@expr9202 ) ; tok@var2590 ; ) {
1638: if (@expr1073751027 TemplateSimplifier ::@expr1073751028 simplifyNumericCalculations (@expr1073751029 tok@var2590 , false ) ) {
1639: tok@var2590 =@expr1073751030 tokenList@var2587 .@expr9201 front (@expr9202 ) ; }
1640: else {
1641: tok@var2590 =@expr1073751033 tok@var2590 .@expr1073751034 next (@expr1073751035 ) ; }
1642: }
1643:
1644: if (@expr1073751036 Token ::@expr9148 Match (@expr1073751038 tokenList@var2587 .@expr9201 front (@expr9202 ) , "; %num% ;" ) ) {
1645: dimension@var2583 .@expr9154 known@var2586 =@expr1073751042 true ;
1646: dimension@var2583 .@expr9142 num@var2584 =@expr1073751044 MathLib ::@expr1073751045 toLongNumber (@expr1073751046 tokenList@var2587 .@expr9201 front (@expr9202 ) .@expr1073751049 next (@expr1073751050 ) .@expr1073751051 str (@expr1073751052 ) ) ;
1647: }
1648:
1649: continue ;
1650: }
1651:
1652:
1653: dimension@var2583 .@expr9154 known@var2586 =@expr1073751054 false ;
1654:
1655:
1656: if (@expr1073751055 dimension@var2583 .@expr9146 tok@var2585 .@expr1073751057 hasKnownIntValue (@expr1073751058 ) ) {
1657: dimension@var2583 .@expr9154 known@var2586 =@expr1073751060 true ;
1658: dimension@var2583 .@expr9142 num@var2584 =@expr1073751062 dimension@var2583 .@expr9146 tok@var2585 .@expr1073751064 getKnownIntValue (@expr1073751065 ) ;
1659: continue ;
1660: }
1661:
1662: else { if (@expr1073751066 dimension@var2583 .@expr9146 tok@var2585 .@expr9244 valueType (@expr9245 ) &&@expr1073751070 dimension@var2583 .@expr9146 tok@var2585 .@expr9244 valueType (@expr9245 ) .@expr1073751074 pointer@var3849 ==@expr1073751075 0 ) {
1663: int bits@var2591 ; bits@var2591 =@expr1073751076 0 ;
1664: switch (@expr1073751077 dimension@var2583 .@expr9146 tok@var2585 .@expr9244 valueType (@expr9245 ) .@expr1073751081 type@var3843 ) {
1665: case ValueType ::@expr9258 Type ::@expr1073751083 CHAR :@expr9260 ;
1666: bits@var2591 =@expr1073751085 mSettings@var1404 .@expr1073751086 char_bit@var3825 ;
1667: break ;
1668: case ValueType ::@expr9258 Type ::@expr1073751088 SHORT :@expr9260 ;
1669: bits@var2591 =@expr1073751090 mSettings@var1404 .@expr1073751091 short_bit@var3826 ;
1670: break ;
1671: case ValueType ::@expr9258 Type ::@expr1073751093 INT :@expr9260 ;
1672: bits@var2591 =@expr1073751095 mSettings@var1404 .@expr1073751096 int_bit@var3827 ;
1673: break ;
1674: case ValueType ::@expr9258 Type ::@expr1073751098 LONG :@expr9260 ;
1675: bits@var2591 =@expr1073751100 mSettings@var1404 .@expr1073751101 long_bit@var3828 ;
1676: break ;
1677: case ValueType ::@expr9258 Type ::@expr1073751103 LONGLONG :@expr9260 ;
1678: bits@var2591 =@expr1073751105 mSettings@var1404 .@expr1073751106 long_long_bit@var3829 ;
1679: break ;
1680: default :@expr9260 ;
1681: break ;
1682: }
1683:
1684: if (@expr1073751108 bits@var2591 >@expr1073751109 0 &&@expr1073751110 bits@var2591 <=@expr1073751111 62 ) {
1685: if (@expr1073751112 dimension@var2583 .@expr9146 tok@var2585 .@expr9244 valueType (@expr9245 ) .@expr1073751116 sign@var3850 ==@expr1073751117 ValueType ::@expr1073751118 Sign ::@expr1073751119 UNSIGNED ) {
1686: dimension@var2583 .@expr9142 num@var2584 =@expr1073751121 1LL <<@expr1073751122 bits@var2591 ; }
1687: else {
1688: dimension@var2583 .@expr9142 num@var2584 =@expr1073751124 1LL <<@expr1073751125 (@expr1073751126 bits@var2591 -@expr1073751127 1 ) ; }
1689: }
1690: } }
1691: }
1692: }
1693: }
1694:
1695: SymbolDatabase :: ~ SymbolDatabase ( )
1696: {
1697:
1698: for (@expr1073751128 const Token *@expr9305 tok@var2592 =@expr1073751130 mTokenizer@var1403 .@expr1073751131 list@var3820 .@expr1073751132 front (@expr1073751133 ) ; tok@var2592 ; tok@var2592 =@expr1073751134 tok@var2592 .@expr1073751135 next (@expr1073751136 ) ) {
1699: const_cast < Token *@expr9305 > (@expr9314 tok@var2592 ) .@expr1073751139 scope (@expr1073751140 nullptr ) ;
1700: const_cast < Token *@expr9305 > (@expr9314 tok@var2592 ) .@expr1073751143 type (@expr1073751144 nullptr ) ;
1701: const_cast < Token *@expr9305 > (@expr9314 tok@var2592 ) .@expr1073751147 function (@expr1073751148 nullptr ) ;
1702: const_cast < Token *@expr9305 > (@expr9314 tok@var2592 ) .@expr1073751151 variable (@expr1073751152 nullptr ) ;
1703: const_cast < Token *@expr9305 > (@expr9314 tok@var2592 ) .@expr1073751155 enumerator (@expr1073751156 nullptr ) ;
1704: const_cast < Token *@expr9305 > (@expr9314 tok@var2592 ) .@expr1073751159 setValueType (@expr1073751160 nullptr ) ;
1705: }
1706: }
1707:
1708: bool SymbolDatabase :: isFunction ( const Token * tok@var2593 , const Scope * outerScope@var2594 , const Token * * funcStart@var2595 , const Token * * argStart@var2596 , const Token * * declEnd@var2597 ) const
1709: {
1710: if (@expr1073751161 tok@var2593 .@expr1073751162 varId (@expr1073751163 ) ) {
1711: return false ; }
1712:
|
1715:
1716: if (@expr1073751164 false &&@expr1073751165 tok@var2593 .@expr9342 str (@expr9343 ) ==@expr1073751168 "(" &&@expr1073751169 tok@var2593 .@expr1073751170 strAt (@expr1073751171 1 ) !=@expr1073751172 "*" &&@expr1073751173
1717: (@expr1073751174 tok@var2593 .@expr9351 link (@expr9352 ) .@expr9353 previous (@expr9354 ) .@expr9355 str (@expr9356 ) ==@expr1073751181 ")" ||@expr1073751182 Token ::@expr9359 simpleMatch (@expr1073751184 tok@var2593 .@expr9351 link (@expr9352 ) .@expr1073751187 tokAt (@expr1073751188 -2 ) , ") const" ) ) ) {
1718: const Token * tok2@var2598 ; tok2@var2598 =@expr1073751189 tok@var2593 .@expr9351 link (@expr9352 ) .@expr1073751192 next (@expr1073751193 ) ;
1719: if (@expr1073751194 tok2@var2598 &&@expr1073751195 tok2@var2598 .@expr9372 str (@expr9373 ) ==@expr1073751198 "(" &&@expr1073751199 Token ::@expr9376 Match (@expr1073751201 tok2@var2598 .@expr9378 link (@expr9379 ) .@expr9380 next (@expr9381 ) , "{|;|const|=" ) ) {
1720: const Token * argStartTok@var2599 ;
1721: if (@expr9382 tok@var2593 .@expr9351 link (@expr9352 ) .@expr9353 previous (@expr9354 ) .@expr9355 str (@expr9356 ) ==@expr9389 "const" ) {
1722: argStartTok@var2599 =@expr1073751214 tok@var2593 .@expr9351 link (@expr9352 ) .@expr9393 linkAt (@expr9394 -2 ) ; }
1723: else {
1724: argStartTok@var2599 =@expr1073751219 tok@var2593 .@expr9351 link (@expr9352 ) .@expr9393 linkAt (@expr9399 -1 ) ; }
1725: *@expr9400 funcStart@var2595 =@expr1073751225 argStartTok@var2599 .@expr1073751226 previous (@expr1073751227 ) ;
1726: *@expr9404 argStart@var2596 =@expr1073751229 argStartTok@var2599 ;
1727: *@expr9406 declEnd@var2597 =@expr1073751231 Token ::@expr9408 findmatch (@expr1073751233 tok2@var2598 .@expr9378 link (@expr9379 ) .@expr9380 next (@expr9381 ) , "{|;" ) ;
1728: return true ;
1729: } else { if (@expr1073751238 tok2@var2598 &&@expr9415 tok2@var2598 .@expr9372 str (@expr9373 ) ==@expr9418 "[" ) {
1730: while (@expr1073751243 tok2@var2598 &&@expr9415 tok2@var2598 .@expr9372 str (@expr9373 ) ==@expr9418 "[" ) {
1731: tok2@var2598 =@expr1073751248 tok2@var2598 .@expr9378 link (@expr9379 ) .@expr9380 next (@expr9381 ) ; }
1732: if (@expr1073751253 Token ::@expr9376 Match (@expr1073751255 tok2@var2598 , "{|;|const|=" ) ) {
1733: const Token * argStartTok@var2600 ;
1734: if (@expr9382 tok@var2593 .@expr9351 link (@expr9352 ) .@expr9353 previous (@expr9354 ) .@expr9355 str (@expr9356 ) ==@expr9389 "const" ) {
1735: argStartTok@var2600 =@expr1073751264 tok@var2593 .@expr9351 link (@expr9352 ) .@expr9393 linkAt (@expr9394 -2 ) ; }
1736: else {
1737: argStartTok@var2600 =@expr1073751269 tok@var2593 .@expr9351 link (@expr9352 ) .@expr9393 linkAt (@expr9399 -1 ) ; }
1738: *@expr9400 funcStart@var2595 =@expr1073751275 argStartTok@var2600 .@expr1073751276 previous (@expr1073751277 ) ;
1739: *@expr9404 argStart@var2596 =@expr1073751279 argStartTok@var2600 ;
1740: *@expr9406 declEnd@var2597 =@expr1073751281 Token ::@expr9408 findmatch (@expr1073751283 tok2@var2598 , "{|;" ) ;
1741: return true ;
1742: }
1743: } }
1744: }
1745:
1746: else { if (@expr1073751284 !@expr1073751285 tok@var2593 .@expr1073751286 isName (@expr1073751287 ) ||@expr1073751288 !@expr1073751289 tok@var2593 .@expr9466 next (@expr9467 ) ||@expr1073751292 !@expr1073751293 tok@var2593 .@expr9466 next (@expr9467 ) .@expr9472 link (@expr9473 ) ) {
1747: return false ; }
1748:
1749:
1750: else { if (@expr1073751298 Token ::@expr9376 Match (@expr9476 tok@var2593 , "%name% (" ) &&@expr9477 !@expr9478 isReservedName (@expr9479 tok@var2593 .@expr9342 str (@expr9343 ) ) &&@expr1073751306 tok@var2593 .@expr9483 previous (@expr9484 ) &&@expr1073751309
1751: (@expr1073751310 Token ::@expr9376 Match (@expr1073751312 tok@var2593 .@expr9483 previous (@expr9484 ) , "%name%|>|&|*|::|~" ) ||@expr1073751315
1752: outerScope@var2594 .@expr1073751316 isClassOrStructOrUnion (@expr1073751317 ) ) ) {
1753: const Token * tok1@var2601 ; tok1@var2601 =@expr1073751318 tok@var2593 .@expr9483 previous (@expr9484 ) ;
1754: const Token * tok2@var2602 ; tok2@var2602 =@expr1073751321 tok@var2593 .@expr9466 next (@expr9467 ) .@expr9472 link (@expr9473 ) .@expr9502 next (@expr9503 ) ;
1755:
1756: if (@expr1073751328 !@expr1073751329 mTokenizer@var1403 .@expr1073751330 isFunctionHead (@expr1073751331 tok@var2593 .@expr9466 next (@expr9467 ) , ";:{" ) ) {
1757: return false ; }
1758:
1759:
1760: if (@expr1073751334 tok1@var2601 .@expr9511 str (@expr9512 ) ==@expr1073751337 "~" ) {
1761: tok1@var2601 =@expr1073751338 tok1@var2601 .@expr9515 previous (@expr9516 ) ; }
1762:
1763:
1764: while (@expr9517 Token ::@expr9359 simpleMatch (@expr9519 tok1@var2601 , "::" ) ) {
1765: tok1@var2601 =@expr1073751344 tok1@var2601 .@expr9515 previous (@expr9516 ) ;
1766: if (@expr9523 Token ::@expr9376 Match (@expr9525 tok1@var2601 , "%name%" ) ) {
1767: tok1@var2601 =@expr1073751350 tok1@var2601 .@expr9515 previous (@expr9516 ) ; }
1768: else { if (@expr9529 tok1@var2601 &&@expr9530 tok1@var2601 .@expr9511 str (@expr9512 ) ==@expr9533 ">" &&@expr9534 tok1@var2601 .@expr9535 link (@expr9536 ) &&@expr9537 Token ::@expr9376 Match (@expr9539 tok1@var2601 .@expr9535 link (@expr9536 ) .@expr9542 previous (@expr9543 ) , "%name%" ) ) {
1769: tok1@var2601 =@expr1073751368 tok1@var2601 .@expr9535 link (@expr9536 ) .@expr9547 tokAt (@expr9548 -2 ) ; } }
1770: }
1771:
1772:
1773: while (@expr1073751373 Token ::@expr9376 Match (@expr1073751375 tok2@var2602 , "const|noexcept|throw|override|final|volatile|&|&&" ) ) {
1774: tok2@var2602 =@expr1073751376 tok2@var2602 .@expr9553 next (@expr9554 ) ;
1775: if (@expr1073751379 tok2@var2602 &&@expr1073751380 tok2@var2602 .@expr9557 str (@expr9558 ) ==@expr1073751383 "(" ) {
1776: tok2@var2602 =@expr1073751384 tok2@var2602 .@expr9561 link (@expr9562 ) .@expr1073751387 next (@expr1073751388 ) ; }
1777: }
1778:
1779:
1780: if (@expr1073751389 tok2@var2602 &&@expr1073751390 tok2@var2602 .@expr9557 str (@expr9558 ) ==@expr1073751393 "." ) {
1781: for (@expr1073751394 tok2@var2602 =@expr1073751395 tok2@var2602 .@expr9553 next (@expr9554 ) ; tok2@var2602 ; tok2@var2602 =@expr1073751398 tok2@var2602 .@expr9553 next (@expr9554 ) ) {
1782: if (@expr1073751401 Token ::@expr9376 Match (@expr1073751403 tok2@var2602 , ";|{|=|override|final" ) ) {
1783: break ; }
1784: if (@expr1073751404 tok2@var2602 .@expr9561 link (@expr9562 ) &&@expr1073751407 Token ::@expr9376 Match (@expr1073751409 tok2@var2602 , "<|[|(" ) ) {
1785: tok2@var2602 =@expr1073751410 tok2@var2602 .@expr9561 link (@expr9562 ) ; }
1786: }
1787: }
1788:
1789:
1790: if (@expr1073751413 !@expr1073751414 Token ::@expr9376 Match (@expr1073751416 tok1@var2601 , "{|}|;|public:|protected:|private:" ) &&@expr1073751417 tok1@var2601 ) {
1791:
1792: while (@expr1073751418 Token ::@expr9376 Match (@expr1073751420 tok1@var2601 , "%type%|*|&" ) &&@expr1073751421 !@expr1073751422 endsWith (@expr1073751423 tok1@var2601 .@expr9511 str (@expr9512 ) , ':' ) &&@expr1073751426 (@expr1073751427 !@expr1073751428 isReservedName (@expr1073751429 tok1@var2601 .@expr9511 str (@expr9512 ) ) ||@expr1073751432 tok1@var2601 .@expr9511 str (@expr9512 ) ==@expr1073751435 "const" ) ) {
1793: tok1@var2601 =@expr1073751436 tok1@var2601 .@expr9515 previous (@expr9516 ) ; }
1794:
1795:
1796: if (@expr9615 Token ::@expr9359 simpleMatch (@expr9617 tok1@var2601 , ")" ) &&@expr9618 tok1@var2601 .@expr9535 link (@expr9536 ) &&@expr9621
1797: Token ::@expr9359 simpleMatch (@expr9623 tok1@var2601 .@expr9535 link (@expr9536 ) .@expr9542 previous (@expr9543 ) , "decltype (" ) ) {
1798: tok1@var2601 =@expr1073751452 tok1@var2601 .@expr9535 link (@expr9536 ) .@expr9547 tokAt (@expr9548 -2 ) ; }
1799:
1800:
1801: if (@expr1073751457 tok1@var2601 &&@expr9530 tok1@var2601 .@expr9511 str (@expr9512 ) ==@expr9533 ">" ) {
1802: if (@expr1073751462 tok1@var2601 .@expr9535 link (@expr9536 ) ) {
1803: tok1@var2601 =@expr1073751465 tok1@var2601 .@expr9535 link (@expr9536 ) .@expr9542 previous (@expr9543 ) ; }
1804: else {
1805: return false ; }
1806: }
1807:
1808:
1809: if (@expr1073751470 tok1@var2601 &&@expr1073751471 (@expr1073751472 tok1@var2601 .@expr1073751473 isNumber (@expr1073751474 ) ||@expr1073751475 tok1@var2601 .@expr1073751476 varId (@expr1073751477 ) ) ) {
1810: return false ; }
1811:
1812:
1813: if (@expr9523 Token ::@expr9376 Match (@expr9525 tok1@var2601 , "%name%" ) ) {
1814: if (@expr1073751481 tok1@var2601 .@expr9511 str (@expr9512 ) ==@expr1073751484 "return" ) {
1815: return false ; }
1816: if (@expr1073751485 tok1@var2601 .@expr9511 str (@expr9512 ) !=@expr1073751488 "friend" ) {
1817: tok1@var2601 =@expr1073751489 tok1@var2601 .@expr9515 previous (@expr9516 ) ; }
1818: }
1819:
1820:
1821: while (@expr9517 Token ::@expr9359 simpleMatch (@expr9519 tok1@var2601 , "::" ) ) {
1822: tok1@var2601 =@expr1073751495 tok1@var2601 .@expr9515 previous (@expr9516 ) ;
1823: if (@expr9523 Token ::@expr9376 Match (@expr9525 tok1@var2601 , "%name%" ) ) {
1824: tok1@var2601 =@expr1073751501 tok1@var2601 .@expr9515 previous (@expr9516 ) ; }
1825: else { if (@expr9529 tok1@var2601 &&@expr9530 tok1@var2601 .@expr9511 str (@expr9512 ) ==@expr9533 ">" &&@expr9534 tok1@var2601 .@expr9535 link (@expr9536 ) &&@expr9537 Token ::@expr9376 Match (@expr9539 tok1@var2601 .@expr9535 link (@expr9536 ) .@expr9542 previous (@expr9543 ) , "%name%" ) ) {
1826: tok1@var2601 =@expr1073751519 tok1@var2601 .@expr9535 link (@expr9536 ) .@expr9547 tokAt (@expr9548 -2 ) ; }
1827: else { if (@expr9615 Token ::@expr9359 simpleMatch (@expr9617 tok1@var2601 , ")" ) &&@expr9618 tok1@var2601 .@expr9535 link (@expr9536 ) &&@expr9621
1828: Token ::@expr9359 simpleMatch (@expr9623 tok1@var2601 .@expr9535 link (@expr9536 ) .@expr9542 previous (@expr9543 ) , "decltype (" ) ) {
1829: tok1@var2601 =@expr1073751537 tok1@var2601 .@expr9535 link (@expr9536 ) .@expr9547 tokAt (@expr9548 -2 ) ; } } }
1830: }
1831:
1832:
1833: while (@expr1073751542 Token ::@expr9376 Match (@expr1073751544 tok1@var2601 , "const|static|extern|template|virtual|struct|class|enum|%name%" ) ) {
1834:
1835: if (@expr1073751545 isCPP (@expr1073751546 ) &&@expr1073751547 tok1@var2601 .@expr9511 str (@expr9512 ) ==@expr1073751550 "friend" &&@expr1073751551 tok2@var2602 .@expr9557 str (@expr9558 ) ==@expr1073751554 ";" ) {
1836: return false ; }
1837: tok1@var2601 =@expr1073751555 tok1@var2601 .@expr9515 previous (@expr9516 ) ;
1838: }
1839:
1840:
1841: if (@expr1073751558 !@expr1073751559 Token ::@expr9376 Match (@expr1073751561 tok1@var2601 , ">|{|}|;|public:|protected:|private:" ) &&@expr1073751562 tok1@var2601 ) {
1842: return false ; }
1843: }
1844:
1845: if (@expr1073751563 tok2@var2602 &&@expr1073751564
1846: (@expr1073751565 Token ::@expr9376 Match (@expr1073751567 tok2@var2602 , ";|{|=" ) ||@expr1073751568
1847: (@expr1073751569 tok2@var2602 .@expr9746 isUpperCaseName (@expr9747 ) &&@expr1073751572 Token ::@expr9376 Match (@expr1073751574 tok2@var2602 , "%name% ;|{" ) ) ||@expr1073751575
1848: (@expr1073751576 tok2@var2602 .@expr9746 isUpperCaseName (@expr9747 ) &&@expr1073751579 Token ::@expr9376 Match (@expr1073751581 tok2@var2602 , "%name% (" ) &&@expr1073751582 tok2@var2602 .@expr9553 next (@expr9554 ) .@expr1073751585 link (@expr1073751586 ) .@expr1073751587 strAt (@expr1073751588 1 ) ==@expr1073751589 "{" ) ||@expr1073751590
1849: Token ::@expr9376 Match (@expr1073751592 tok2@var2602 , ": ::| %name% (|::|<|{" ) ||@expr1073751593
1850: Token ::@expr9376 Match (@expr1073751595 tok2@var2602 , "&|&&| ;|{" ) ||@expr1073751596
1851: Token ::@expr9376 Match (@expr1073751598 tok2@var2602 , "= delete|default ;" ) ) ) {
1852: *@expr9400 funcStart@var2595 =@expr1073751600 tok@var2593 ;
1853: *@expr9404 argStart@var2596 =@expr1073751602 tok@var2593 .@expr9466 next (@expr9467 ) ;
1854: *@expr9406 declEnd@var2597 =@expr1073751606 Token ::@expr9408 findmatch (@expr1073751608 tok2@var2602 , "{|;" ) ;
1855: return true ;
1856: }
1857: }
1858:
1859:
1860: else { if (@expr1073751609 outerScope@var2594 .@expr1073751610 type@var2603 ==@expr1073751611 Scope ::@expr1073751612 eGlobal &&@expr1073751613
1861: Token ::@expr9376 Match (@expr9476 tok@var2593 , "%name% (" ) &&@expr1073751616
1862: tok@var2593 .@expr1073751617 isUpperCaseName (@expr1073751618 ) &&@expr1073751619
1863: Token ::@expr9359 simpleMatch (@expr9797 tok@var2593 .@expr9798 linkAt (@expr9799 1 ) , ") {" ) &&@expr1073751624
1864: (@expr1073751625 !@expr9802 tok@var2593 .@expr9483 previous (@expr9484 ) ||@expr1073751629 Token ::@expr9376 Match (@expr1073751631 tok@var2593 .@expr9483 previous (@expr9484 ) , "[;{}]" ) ) ) {
1865: *@expr9400 funcStart@var2595 =@expr1073751635 tok@var2593 ;
1866: *@expr9404 argStart@var2596 =@expr1073751637 tok@var2593 .@expr9466 next (@expr9467 ) ;
1867: *@expr9406 declEnd@var2597 =@expr1073751641 tok@var2593 .@expr9798 linkAt (@expr9799 1 ) .@expr9820 next (@expr9821 ) ;
1868: return true ;
1869: }
1870:
1871:
1872: else { if (@expr1073751646 Token ::@expr9376 Match (@expr1073751648 tok@var2593 , "%name% <" ) &&@expr1073751649 Token ::@expr9359 simpleMatch (@expr1073751651 tok@var2593 .@expr9466 next (@expr9467 ) .@expr9472 link (@expr9473 ) , "> (" ) ) {
1873: const Token * tok2@var2604 ; tok2@var2604 =@expr1073751656 tok@var2593 .@expr9466 next (@expr9467 ) .@expr9472 link (@expr9473 ) .@expr9502 next (@expr9503 ) .@expr1073751663 link (@expr1073751664 ) ;
1874: if (@expr1073751665 Token ::@expr9376 Match (@expr1073751667 tok2@var2604 , ") const| ;|{|=" ) ||@expr1073751668
1875: Token ::@expr9376 Match (@expr1073751670 tok2@var2604 , ") : ::| %name% (|::|<|{" ) ||@expr1073751671
1876: Token ::@expr9376 Match (@expr1073751673 tok2@var2604 , ") const| noexcept {|;|(" ) ) {
1877: *@expr9400 funcStart@var2595 =@expr1073751675 tok@var2593 ;
1878: *@expr9404 argStart@var2596 =@expr1073751677 tok2@var2604 .@expr1073751678 link (@expr1073751679 ) ;
1879: *@expr9406 declEnd@var2597 =@expr1073751681 Token ::@expr9408 findmatch (@expr1073751683 tok2@var2604 .@expr1073751684 next (@expr1073751685 ) , "{|;" ) ;
1880: return true ;
1881: }
1882: }
1883:
1884:
1885: else { if (@expr1073751686 Token ::@expr9376 Match (@expr9476 tok@var2593 , "%name% (" ) &&@expr9477 !@expr9478 isReservedName (@expr9479 tok@var2593 .@expr9342 str (@expr9343 ) ) &&@expr1073751694
1886: Token ::@expr9359 simpleMatch (@expr9797 tok@var2593 .@expr9798 linkAt (@expr9799 1 ) , ") {" ) &&@expr1073751699
1887: (@expr1073751700 !@expr9802 tok@var2593 .@expr9483 previous (@expr9484 ) ||@expr1073751704 Token ::@expr9376 Match (@expr1073751706 tok@var2593 .@expr9483 previous (@expr9484 ) , ";|}" ) ) ) {
1888: if (@expr1073751709 mTokenizer@var1403 .@expr1073751710 isC (@expr1073751711 ) ) {
1889: debugMessage (@expr1073751712 tok@var2593 , "debug" , "SymbolDatabase::isFunction found C function '" +@expr1073751713 tok@var2593 .@expr9342 str (@expr9343 ) +@expr1073751716 "' without a return type." ) ;
1890: *@expr9400 funcStart@var2595 =@expr1073751718 tok@var2593 ;
1891: *@expr9404 argStart@var2596 =@expr1073751720 tok@var2593 .@expr9466 next (@expr9467 ) ;
1892: *@expr9406 declEnd@var2597 =@expr1073751724 tok@var2593 .@expr9798 linkAt (@expr9799 1 ) .@expr9820 next (@expr9821 ) ;
1893: return true ;
1894: }
1895: mTokenizer@var1403 .@expr1073751729 syntaxError (@expr1073751730 tok@var2593 ) ;
1896: } } } } } }
1897:
1898: return false ;
1899: }
1900:
1901: void SymbolDatabase :: validateExecutableScopes ( ) const
1902: {
1903: const unsigned long functions@var2605 =@expr1073751731 functionScopes@var1332 .@expr1073751732 size (@expr1073751733 ) ;
1904: for (@expr1073751734 unsigned long i@var2606 =@expr1073751735 0 ; i@var2606 <@expr1073751736 functions@var2605 ; ++@expr1073751737 i@var2606 ) {
1905: const Scope * const scope@var2607 ; scope@var2607 =@expr1073751738 functionScopes@var1332 [@expr1073751739 i@var2606 ] ;
1906: const Function * const function@var2608 ; function@var2608 =@expr1073751740 scope@var2607 .@expr1073751741 function@var2609 ;
1907: if (@expr1073751742 scope@var2607 .@expr1073751743 isExecutable (@expr1073751744 ) &&@expr1073751745 !@expr1073751746 function@var2608 ) {
1908: const std ::@expr1073751747 list < const Token *@expr1073751748 > callstack@var2610 (@expr1073751749 1 , scope@var2607 .@expr9926 classDef@var2611 ) ;
1909: const std ::@expr1073751751 string msg@var2612 =@expr1073751752 std ::@expr1073751753 string (@expr1073751754 "Executable scope '" ) +@expr1073751755 scope@var2607 .@expr9926 classDef@var2611 .@expr1073751757 str (@expr1073751758 ) +@expr1073751759 "' with unknown function." ;
1910: const ErrorMessage errmsg@var2613 (@expr1073751760 callstack@var2610 , &@expr1073751761 mTokenizer@var1403 .@expr1073751762 list@var3820 , Severity ::@expr1073751763 debug ,
1911: "symbolDatabaseWarning" ,
1912: msg@var2612 ,
1913: Certainty ::@expr1073751764 normal ) ;
1914: mErrorLogger@var1405 .@expr1073751765 reportErr (@expr1073751766 errmsg@var2613 ) ;
1915: }
1916: }
1917: }
1918:
1919: namespace {
1920: const Function * getFunctionForArgumentvariable ( const Variable * const var@var2614 , const std :: vector < const Scope * > & functionScopes@var2615 )
1921: {
1922: const unsigned long functions@var2616 =@expr1073751767 functionScopes@var2615 .@expr1073751768 size (@expr1073751769 ) ;
1923: for (@expr1073751770 unsigned long i@var2617 =@expr1073751771 0 ; i@var2617 <@expr1073751772 functions@var2616 ; ++@expr1073751773 i@var2617 ) {
1924: const Scope * const scope@var2618 ; scope@var2618 =@expr1073751774 functionScopes@var2615 [@expr1073751775 i@var2617 ] ;
1925: const Function * const function@var2619 ; function@var2619 =@expr1073751776 scope@var2618 .@expr1073751777 function@var2620 ;
1926: if (@expr1073751778 function@var2619 ) {
1927: for (@expr1073751779 unsigned long arg@var2621 =@expr1073751780 0 ; arg@var2621 <@expr1073751781 function@var2619 .@expr1073751782 argCount (@expr1073751783 ) ; ++@expr1073751784 arg@var2621 ) {
1928: if (@expr1073751785 var@var2614 ==@expr1073751786 function@var2619 .@expr1073751787 getArgumentVar (@expr1073751788 arg@var2621 ) ) {
1929: return function@var2619 ; }
1930: }
1931: }
1932: }
1933: return nullptr ;
1934: }
1935: }
1936:
1937: void SymbolDatabase :: validateVariables ( ) const
1938: {
1939: for (@expr1073751789 std ::@expr9966 vector < const Variable *@expr1073751791 > ::@expr9966 const_iterator iter@var2622 =@expr1073751793 mVariableList@var1406 .@expr1073751794 begin (@expr1073751795 ) ; iter@var2622 !=@expr1073751796 mVariableList@var1406 .@expr1073751797 end (@expr1073751798 ) ; ++@expr1073751799 iter@var2622 ) {
1940: const Variable * const var@var2623 ; var@var2623 =@expr1073751800 *@expr1073751801 iter@var2622 ;
1941: if (@expr1073751802 var@var2623 ) {
1942: if (@expr1073751803 !@expr1073751804 var@var2623 .@expr1073751805 scope (@expr1073751806 ) ) {
1943: const Function * function@var2624 ; function@var2624 =@expr1073751807 getFunctionForArgumentvariable (@expr1073751808 var@var2623 , functionScopes@var1332 ) ;
1944: if (@expr1073751809 !@expr1073751810 var@var2623 .@expr1073751811 isArgument (@expr1073751812 ) ||@expr1073751813 (@expr1073751814 function@var2624 &&@expr1073751815 function@var2624 .@expr1073751816 hasBody (@expr1073751817 ) ) ) {
1945: throw InternalError (@expr1073751818 var@var2623 .@expr1073751819 nameToken (@expr1073751820 ) , "Analysis failed (variable without scope). If the code is valid then please report this failure." , InternalError ::@expr1073751821 INTERNAL ) ;
1946:
1947: }
1948: }
1949: }
1950: }
1951: }
1952:
1953: void SymbolDatabase :: validate ( ) const
1954: {
1955: if (@expr1073751822 mSettings@var1404 .@expr1073751823 debugwarnings@var3821 ) {
1956: validateExecutableScopes (@expr1073751824 ) ;
1957: }
1958:
1959:
1960: }
1961:
1962: void SymbolDatabase :: clangSetVariables ( const std :: vector < const Variable * > & variableList@var2625 )
1963: {
1964: mVariableList@var1406 =@expr1073751825 variableList@var2625 ;
1965: }
1966:
1967: Variable :: Variable ( const Token * name_@var2626 , const std :: string & clangType@var2627 , const Token * typeStart@var2628 ,
1968: const Token * typeEnd@var2629 , int index_@var2630 , AccessControl access_@var2631 ,
1969: const Type * type_@var2632 , const Scope * scope_@var2633 )
1970: : mNameToken@var1126 ( name_@var2626 ) ,
1971: mTypeStartToken@var1127 ( typeStart@var2628 ) ,
1972: mTypeEndToken@var1128 ( typeEnd@var2629 ) ,
1973: mIndex@var1129 ( index_@var2630 ) ,
1974: mAccess@var1130 ( access_@var2631 ) ,
1975: mFlags@var1131 ( 0 ) ,
1976: mType@var1132 ( type_@var2632 ) ,
1977: mScope@var1133 ( scope_@var2633 ) ,
1978: mValueType@var1134 ( nullptr )
1979: {
1980: if (@expr1073751827 !@expr1073751828 mTypeStartToken@var1127 &&@expr1073751829 mTypeEndToken@var1128 ) {
1981: mTypeStartToken@var1127 =@expr1073751830 mTypeEndToken@var1128 ;
1982: while (@expr1073751831 Token ::@expr10008 Match (@expr1073751833 mTypeStartToken@var1127 .@expr10010 previous (@expr10011 ) , "%type%|*|&" ) ) {
1983: mTypeStartToken@var1127 =@expr1073751836 mTypeStartToken@var1127 .@expr10010 previous (@expr10011 ) ; }
1984: }
1985:
1986: while (@expr1073751839 Token ::@expr10008 Match (@expr1073751841 mTypeStartToken@var1127 , "const|struct|static" ) ) {
1987: if (@expr1073751842 mTypeStartToken@var1127 .@expr1073751843 str (@expr1073751844 ) ==@expr1073751845 "static" ) {
1988: setFlag (@expr1073751846 fIsStatic , true ) ; }
1989: mTypeStartToken@var1127 =@expr1073751847 mTypeStartToken@var1127 .@expr1073751848 next (@expr1073751849 ) ;
1990: }
1991:
1992: if (@expr1073751850 Token ::@expr10027 simpleMatch (@expr1073751852 mTypeEndToken@var1128 , "&" ) ) {
1993: setFlag (@expr10029 fIsReference , true ) ; }
1994: else { if (@expr1073751854 Token ::@expr10027 simpleMatch (@expr1073751856 mTypeEndToken@var1128 , "&&" ) ) {
1995: setFlag (@expr10029 fIsReference , true ) ;
1996: setFlag (@expr1073751858 fIsRValueRef , true ) ;
1997: } }
1998:
1999: std ::@expr10035 string ::@expr1073751860 size_type pos@var2634 ; pos@var2634 =@expr1073751861 clangType@var2627 .@expr10038 find (@expr1073751863 "[" ) ;
2000: if (@expr1073751864 pos@var2634 !=@expr1073751865 std ::@expr10035 string ::@expr1073751867 npos@expr1073751826 ) {
2001: setFlag (@expr1073751868 fIsArray , true ) ;
2002: do {
2003: const std ::@expr10045 string ::@expr10045 size_type pos1@var2635 =@expr1073751871 pos@var2634 +@expr1073751872 1 ;
2004: pos@var2634 =@expr1073751873 clangType@var2627 .@expr10038 find (@expr1073751875 "]" , pos1@var2635 ) ;
2005: Dimension dim@var2636 ;
2006: dim@var2636 .@expr1073751876 tok@var2637 =@expr1073751877 nullptr ;
2007: dim@var2636 .@expr1073751878 known@var2638 =@expr1073751879 pos@var2634 >@expr10056 pos1@var2635 ;
2008: if (@expr1073751881 pos@var2634 >@expr10056 pos1@var2635 ) {
2009: dim@var2636 .@expr10059 num@var2639 =@expr1073751884 MathLib ::@expr1073751885 toLongNumber (@expr1073751886 clangType@var2627 .@expr1073751887 substr (@expr1073751888 pos1@var2635 , pos@var2634 -@expr1073751889 pos1@var2635 ) ) ; }
2010: else {
2011: dim@var2636 .@expr10059 num@var2639 =@expr1073751891 0 ; }
2012: mDimensions@var1135 .@expr1073751892 push_back (@expr1073751893 dim@var2636 ) ;
2013: ++@expr1073751894 pos@var2634 ;
2014: } while (@expr1073751895 pos@var2634 <@expr1073751896 clangType@var2627 .@expr1073751897 size (@expr1073751898 ) &&@expr1073751899 clangType@var2627 [@expr1073751900 pos@var2634 ] ==@expr1073751901 '[' ) ;
2015: }
2016:
2017:
2018: const Token * initTok@var2640 ; initTok@var2640 =@expr1073751902 mNameToken@var1126 ?@expr1073751903 mNameToken@var1126 .@expr1073751904 next (@expr1073751905 ) :@expr1073751906 nullptr ;
2019: while (@expr1073751907 initTok@var2640 &&@expr1073751908 initTok@var2640 .@expr1073751909 str (@expr1073751910 ) ==@expr1073751911 "[" ) {
2020: initTok@var2640 =@expr1073751912 initTok@var2640 .@expr1073751913 link (@expr1073751914 ) .@expr1073751915 next (@expr1073751916 ) ; }
2021: if (@expr1073751917 Token ::@expr10008 Match (@expr1073751919 initTok@var2640 , "=|{" ) ||@expr1073751920 (@expr1073751921 initTok@var2640 &&@expr1073751922 initTok@var2640 .@expr1073751923 isSplittedVarDeclEq (@expr1073751924 ) ) ) {
2022: setFlag (@expr1073751925 fIsInit , true ) ; }
2023: }
2024:
2025: Variable :: Variable ( const Variable & var@var2641 , const Scope * scope@var2642 )
2026: : mValueType@var1134 ( nullptr )
2027: {
2028: *@expr1073751926 this@expr1073751927 =@expr1073751928 var@var2641 ;
2029: mScope@var1133 =@expr1073751929 scope@var2642 ;
2030: }
2031:
2032: Variable :: Variable ( const Variable & var@var2643 )
2033: : mValueType@var1134 ( nullptr )
2034: {
2035: *@expr1073751930 this@expr1073751931 =@expr1073751932 var@var2643 ;
2036: }
2037:
2038: Variable :: ~ Variable ( )
2039: {
2040: delete mValueType@var1134 ;
2041: }
2042:
2043: Variable & Variable :: operator= ( const Variable & var@var2644 )
2044: {
2045: if (@expr1073751933 this@expr10110 ==@expr1073751935 &@expr1073751936 var@var2644 ) {
2046: return *@expr10113 this@expr10110 ; }
2047:
2048: mNameToken@var1126 =@expr1073751938 var@var2644 .@expr1073751939 mNameToken@var2645 ;
2049: mTypeStartToken@var1127 =@expr1073751940 var@var2644 .@expr1073751941 mTypeStartToken@var2646 ;
2050: mTypeEndToken@var1128 =@expr1073751942 var@var2644 .@expr1073751943 mTypeEndToken@var2647 ;
2051: mIndex@var1129 =@expr1073751944 var@var2644 .@expr1073751945 mIndex@var2648 ;
2052: mAccess@var1130 =@expr1073751946 var@var2644 .@expr1073751947 mAccess@var2649 ;
2053: mFlags@var1131 =@expr1073751948 var@var2644 .@expr1073751949 mFlags@var2650 ;
2054: mType@var1132 =@expr1073751950 var@var2644 .@expr1073751951 mType@var2651 ;
2055: mScope@var1133 =@expr1073751952 var@var2644 .@expr1073751953 mScope@var2652 ;
2056: mDimensions@var1135 =@expr1073751954 var@var2644 .@expr1073751955 mDimensions@var2653 ;
2057: delete mValueType@var1134 ;
2058: if (@expr1073751956 var@var2644 .@expr10133 mValueType@var2654 ) {
2059: mValueType@var1134 =@expr1073751958 new ValueType (@expr1073751959 *@expr1073751960 var@var2644 .@expr10133 mValueType@var2654 ) ; }
2060: else {
2061: mValueType@var1134 =@expr1073751962 nullptr ; }
2062:
2063: return *@expr10113 this@expr10110 ;
2064: }
2065:
2066: bool Variable :: isPointerArray ( ) const
2067: {
2068: return isArray (@expr1073751964 ) &&@expr1073751965 nameToken (@expr10142 ) &&@expr1073751967 nameToken (@expr10142 ) .@expr10145 previous (@expr10146 ) &&@expr1073751971 (@expr1073751972 nameToken (@expr10142 ) .@expr10145 previous (@expr10146 ) .@expr1073751976 str (@expr1073751977 ) ==@expr1073751978 "*" ) ;
2069: }
2070:
2071: bool Variable :: isUnsigned ( ) const
2072: {
2073: return mValueType@var1134 ?@expr1073751979 (@expr1073751980 mValueType@var1134 .@expr1073751981 sign@var3801 ==@expr1073751982 ValueType ::@expr1073751983 Sign ::@expr1073751984 UNSIGNED ) :@expr1073751985 mTypeStartToken@var1127 .@expr1073751986 isUnsigned (@expr1073751987 ) ;
2074: }
2075:
2076: const Token * Variable :: declEndToken ( ) const
2077: {
2078: const Token * declEnd@var2655 ; declEnd@var2655 =@expr1073751988 typeStartToken (@expr1073751989 ) ;
2079: while (@expr1073751990 declEnd@var2655 &&@expr1073751991 !@expr1073751992 Token ::@expr10169 Match (@expr1073751994 declEnd@var2655 , "[;,)={]" ) ) {
2080: if (@expr1073751995 declEnd@var2655 .@expr10172 link (@expr10173 ) &&@expr1073751998 Token ::@expr10169 Match (@expr1073752000 declEnd@var2655 , "(|[|<" ) ) {
2081: declEnd@var2655 =@expr1073752001 declEnd@var2655 .@expr10172 link (@expr10173 ) ; }
2082: declEnd@var2655 =@expr1073752004 declEnd@var2655 .@expr1073752005 next (@expr1073752006 ) ;
2083: }
2084: return declEnd@var2655 ;
2085: }
2086:
2087: void Variable :: evaluate ( const Settings * settings@var2656 )
2088: {
2089:
2090: const Token * initTok@var2657 ; initTok@var2657 =@expr1073752007 mNameToken@var1126 ?@expr1073752008 mNameToken@var1126 .@expr1073752009 next (@expr1073752010 ) :@expr1073752011 nullptr ;
2091: while (@expr1073752012 initTok@var2657 &&@expr1073752013 initTok@var2657 .@expr1073752014 str (@expr1073752015 ) ==@expr1073752016 "[" ) {
2092: initTok@var2657 =@expr1073752017 initTok@var2657 .@expr1073752018 link (@expr1073752019 ) .@expr1073752020 next (@expr1073752021 ) ; }
2093: if (@expr1073752022 Token ::@expr10199 Match (@expr1073752024 initTok@var2657 , "=|{" ) ||@expr1073752025 (@expr1073752026 initTok@var2657 &&@expr1073752027 initTok@var2657 .@expr1073752028 isSplittedVarDeclEq (@expr1073752029 ) ) ) {
2094: setFlag (@expr1073752030 fIsInit , true ) ; }
2095:
2096: if (@expr1073752031 !@expr1073752032 settings@var2656 ) {
2097: return ; }
2098:
2099: const Library * const lib@var2658 ; lib@var2658 =@expr1073752033 &@expr1073752034 settings@var2656 .@expr1073752035 library@var2659 ;
2100:
2101: bool isContainer@var2660 ; isContainer@var2660 =@expr1073752036 false ;
2102: if (@expr1073752037 mNameToken@var1126 ) {
2103: setFlag (@expr10214 fIsArray , arrayDimensions (@expr10215 settings@var2656 , &@expr10216 isContainer@var2660 ) ) ; }
2104:
2105: if (@expr10217 mTypeStartToken@var1127 ) {
2106: setValueType (@expr1073752042 ValueType ::@expr1073752043 parseDecl (@expr1073752044 mTypeStartToken@var1127 , settings@var2656 ) ) ; }
2107:
2108: const Token * tok@var2661 ; tok@var2661 =@expr1073752045 mTypeStartToken@var1127 ;
2109: while (@expr1073752046 tok@var2661 &&@expr1073752047 tok@var2661 .@expr10224 previous (@expr10225 ) &&@expr1073752050 tok@var2661 .@expr10224 previous (@expr10225 ) .@expr1073752053 isName (@expr1073752054 ) ) {
2110: tok@var2661 =@expr1073752055 tok@var2661 .@expr10224 previous (@expr10225 ) ; }
2111: const Token * end@var2662 ; end@var2662 =@expr1073752058 mTypeEndToken@var1128 ;
2112: if (@expr1073752059 end@var2662 ) {
2113: end@var2662 =@expr1073752060 end@var2662 .@expr1073752061 next (@expr1073752062 ) ; }
2114: while (@expr1073752063 tok@var2661 !=@expr1073752064 end@var2662 ) {
2115: if (@expr1073752065 tok@var2661 .@expr10242 str (@expr10243 ) ==@expr1073752068 "static" ) {
2116: setFlag (@expr10245 fIsStatic , true ) ; }
2117: else { if (@expr1073752070 tok@var2661 .@expr10242 str (@expr10243 ) ==@expr1073752073 "extern" ) {
2118: setFlag (@expr1073752074 fIsExtern , true ) ; }
2119: else { if (@expr1073752075 tok@var2661 .@expr10242 str (@expr10243 ) ==@expr1073752078 "volatile" ||@expr1073752079 Token ::@expr10256 simpleMatch (@expr1073752081 tok@var2661 , "std :: atomic <" ) ) {
2120: setFlag (@expr1073752082 fIsVolatile , true ) ; }
2121: else { if (@expr1073752083 tok@var2661 .@expr10242 str (@expr10243 ) ==@expr1073752086 "mutable" ) {
2122: setFlag (@expr1073752087 fIsMutable , true ) ; }
2123: else { if (@expr1073752088 tok@var2661 .@expr10242 str (@expr10243 ) ==@expr1073752091 "const" ) {
2124: setFlag (@expr10268 fIsConst , true ) ; }
2125: else { if (@expr1073752093 tok@var2661 .@expr10242 str (@expr10243 ) ==@expr1073752096 "constexpr" ) {
2126: setFlag (@expr10268 fIsConst , true ) ;
2127: setFlag (@expr10245 fIsStatic , true ) ;
2128: } else { if (@expr1073752099 tok@var2661 .@expr10242 str (@expr10243 ) ==@expr1073752102 "*" ) {
2129: setFlag (@expr1073752103 fIsPointer , !@expr1073752104 isArray (@expr1073752105 ) ||@expr1073752106 (@expr1073752107 isContainer@var2660 &&@expr1073752108 !@expr1073752109 Token ::@expr10199 Match (@expr1073752111 tok@var2661 .@expr10288 next (@expr10289 ) , "%name% [" ) ) ||@expr1073752114 Token ::@expr10199 Match (@expr1073752116 tok@var2661 .@expr10224 previous (@expr10225 ) , "( * %name% )" ) ) ;
2130: setFlag (@expr1073752119 fIsConst , false ) ;
2131: } else { if (@expr1073752120 tok@var2661 .@expr10242 str (@expr10243 ) ==@expr1073752123 "&" ) {
2132: if (@expr1073752124 isReference (@expr10301 ) ) {
2133: setFlag (@expr10302 fIsRValueRef , true ) ; }
2134: setFlag (@expr10303 fIsReference , true ) ;
2135: } else { if (@expr1073752128 tok@var2661 .@expr10242 str (@expr10243 ) ==@expr1073752131 "&&" ) {
2136: setFlag (@expr10302 fIsRValueRef , true ) ;
2137: setFlag (@expr10303 fIsReference , true ) ;
2138: } } } } } } } } }
2139:
2140: if (@expr1073752134 tok@var2661 .@expr1073752135 isAttributeMaybeUnused (@expr1073752136 ) ) {
2141: setFlag (@expr1073752137 fIsMaybeUnused , true ) ;
2142: }
2143:
2144: if (@expr1073752138 tok@var2661 .@expr10242 str (@expr10243 ) ==@expr1073752141 "<" &&@expr1073752142 tok@var2661 .@expr10319 link (@expr10320 ) ) {
2145: tok@var2661 =@expr1073752145 tok@var2661 .@expr10319 link (@expr10320 ) ; }
2146: else {
2147: tok@var2661 =@expr1073752148 tok@var2661 .@expr10288 next (@expr10289 ) ; }
2148: }
2149:
2150: while (@expr1073752151 Token ::@expr10199 Match (@expr1073752153 mTypeStartToken@var1127 , "static|const|constexpr|volatile %any%" ) ) {
2151: mTypeStartToken@var1127 =@expr1073752154 mTypeStartToken@var1127 .@expr1073752155 next (@expr1073752156 ) ; }
2152: while (@expr1073752157 mTypeEndToken@var1128 &&@expr1073752158 mTypeEndToken@var1128 .@expr10335 previous (@expr10336 ) &&@expr1073752161 Token ::@expr10199 Match (@expr1073752163 mTypeEndToken@var1128 , "const|volatile" ) ) {
2153: mTypeEndToken@var1128 =@expr1073752164 mTypeEndToken@var1128 .@expr10335 previous (@expr10336 ) ; }
2154:
2155: if (@expr10217 mTypeStartToken@var1127 ) {
2156: std ::@expr1073752168 string strtype@var2663 ; strtype@var2663 =@expr1073752169 mTypeStartToken@var1127 .@expr1073752170 str (@expr1073752171 ) ;
2157: for (@expr1073752172 const Token *@expr1073752173 typeToken@var2664 =@expr1073752174 mTypeStartToken@var1127 ; Token ::@expr10199 Match (@expr1073752176 typeToken@var2664 , "%type% :: %type%" ) ; typeToken@var2664 =@expr1073752177 typeToken@var2664 .@expr1073752178 tokAt (@expr1073752179 2 ) ) {
2158: strtype@var2663 +=@expr1073752180 "::" +@expr1073752181 typeToken@var2664 .@expr1073752182 strAt (@expr1073752183 2 ) ; }
2159: setFlag (@expr1073752184 fIsClass , !@expr1073752185 lib@var2658 .@expr1073752186 podtype (@expr1073752187 strtype@var2663 ) &&@expr1073752188 !@expr1073752189 mTypeStartToken@var1127 .@expr1073752190 isStandardType (@expr1073752191 ) &&@expr1073752192 !@expr1073752193 isEnumType (@expr1073752194 ) &&@expr1073752195 !@expr1073752196 isPointer (@expr1073752197 ) &&@expr1073752198 !@expr1073752199 isReference (@expr10301 ) &&@expr1073752201 strtype@var2663 !=@expr1073752202 "..." ) ;
2160: setFlag (@expr1073752203 fIsStlType , Token ::@expr10256 simpleMatch (@expr1073752205 mTypeStartToken@var1127 , "std ::" ) ) ;
2161: setFlag (@expr1073752206 fIsStlString , isStlType (@expr1073752207 ) &&@expr1073752208 (@expr1073752209 Token ::@expr10199 Match (@expr1073752211 mTypeStartToken@var1127 .@expr10388 tokAt (@expr10389 2 ) , "string|wstring|u16string|u32string !!::" ) ||@expr1073752214 (@expr1073752215 Token ::@expr10256 simpleMatch (@expr1073752217 mTypeStartToken@var1127 .@expr10388 tokAt (@expr10389 2 ) , "basic_string <" ) &&@expr1073752220 !@expr1073752221 Token ::@expr10256 simpleMatch (@expr1073752223 mTypeStartToken@var1127 .@expr1073752224 linkAt (@expr1073752225 3 ) , "> ::" ) ) ) ) ;
2162: setFlag (@expr1073752226 fIsSmartPointer , lib@var2658 .@expr1073752227 isSmartPointer (@expr1073752228 mTypeStartToken@var1127 ) ) ;
2163: }
2164: if (@expr1073752229 mAccess@var1130 ==@expr1073752230 AccessControl ::@expr1073752231 Argument ) {
2165: tok@var2661 =@expr1073752232 mNameToken@var1126 ;
2166: if (@expr10409 !@expr10410 tok@var2661 ) {
2167:
2168: tok@var2661 =@expr1073752235 mTypeEndToken@var1128 ;
2169:
2170: while (@expr1073752236 tok@var2661 &&@expr1073752237 tok@var2661 .@expr10242 str (@expr10243 ) ==@expr1073752240 "]" ) {
2171: tok@var2661 =@expr1073752241 tok@var2661 .@expr10319 link (@expr10320 ) .@expr1073752244 previous (@expr1073752245 ) ; }
2172:
2173: if (@expr1073752246 tok@var2661 &&@expr1073752247 tok@var2661 .@expr10288 next (@expr10289 ) .@expr1073752250 str (@expr1073752251 ) ==@expr1073752252 "[" ) {
2174: setFlag (@expr10214 fIsArray , arrayDimensions (@expr10215 settings@var2656 , &@expr10216 isContainer@var2660 ) ) ; }
2175: }
2176: if (@expr10409 !@expr10410 tok@var2661 ) {
2177: return ; }
2178: tok@var2661 =@expr1073752258 tok@var2661 .@expr10288 next (@expr10289 ) ;
2179: while (@expr1073752261 tok@var2661 .@expr10242 str (@expr10243 ) ==@expr1073752264 "[" ) {
2180: tok@var2661 =@expr1073752265 tok@var2661 .@expr10319 link (@expr10320 ) ; }
2181: setFlag (@expr1073752268 fHasDefault , tok@var2661 .@expr10242 str (@expr10243 ) ==@expr1073752271 "=" ) ;
2182: }
2183:
2184: if (@expr1073752272 mScope@var1133 &&@expr1073752273 mScope@var1133 .@expr1073752274 isClassOrStruct (@expr1073752275 ) ) {
2185:
2186:
2187:
2188: const Token * declEnd@var2665 ; declEnd@var2665 =@expr1073752276 declEndToken (@expr1073752277 ) ;
2189: if (@expr1073752278 (@expr1073752279 Token ::@expr10199 Match (@expr1073752281 declEnd@var2665 , "; %name% =" ) &&@expr1073752282 declEnd@var2665 .@expr1073752283 strAt (@expr1073752284 1 ) ==@expr1073752285 mNameToken@var1126 .@expr1073752286 str (@expr1073752287 ) ) ||@expr1073752288
2190: Token ::@expr10199 Match (@expr1073752290 declEnd@var2665 , "=|{" ) ) {
2191: setFlag (@expr1073752291 fHasDefault , true ) ; }
2192: }
2193:
2194: if (@expr10217 mTypeStartToken@var1127 ) {
2195: if (@expr1073752293 Token ::@expr10199 Match (@expr1073752295 mTypeStartToken@var1127 , "float|double" ) ) {
2196: setFlag (@expr1073752296 fIsFloatType , true ) ; }
2197: }
2198: }
2199:
2200: void Variable :: setValueType ( const ValueType & valueType@var2666 )
2201: {
2202: if (@expr1073752297 valueType@var2666 .@expr1073752298 type@var2667 ==@expr1073752299 ValueType ::@expr1073752300 Type ::@expr1073752301 UNKNOWN_TYPE ) {
2203: const Token * declType@var2668 ; declType@var2668 =@expr1073752302 Token ::@expr1073752303 findsimplematch (@expr1073752304 mTypeStartToken@var1127 , "decltype (" , mTypeEndToken@var1128 ) ;
2204: if (@expr1073752305 declType@var2668 &&@expr1073752306 !@expr1073752307 declType@var2668 .@expr1073752308 next (@expr1073752309 ) .@expr1073752310 valueType (@expr1073752311 ) ) {
2205: return ; }
2206: }
2207: delete mValueType@var1134 ;
2208: mValueType@var1134 =@expr1073752312 new ValueType (@expr1073752313 valueType@var2666 ) ;
2209: if (@expr1073752314 (@expr1073752315 mValueType@var1134 .@expr10492 pointer@var3802 >@expr1073752317 0 ) &&@expr1073752318 (@expr1073752319 !@expr1073752320 isArray (@expr1073752321 ) ||@expr1073752322 Token ::@expr1073752323 Match (@expr1073752324 mNameToken@var1126 .@expr1073752325 previous (@expr1073752326 ) , "( * %name% )" ) ) ) {
2210: setFlag (@expr1073752327 fIsPointer , true ) ; }
2211: setFlag (@expr1073752328 fIsConst , mValueType@var1134 .@expr1073752329 constness@var3803 &@expr1073752330 (@expr1073752331 1U <<@expr1073752332 mValueType@var1134 .@expr10492 pointer@var3802 ) ) ;
2212: if (@expr1073752334 mValueType@var1134 .@expr1073752335 smartPointerType@var3804 ) {
2213: setFlag (@expr1073752336 fIsSmartPointer , true ) ; }
2214: }
2215:
2216: const Type * Variable :: smartPointerType ( ) const
2217: {
2218: if (@expr1073752337 !@expr1073752338 isSmartPointer (@expr1073752339 ) ) {
2219: return nullptr ; }
2220:
2221: if (@expr1073752340 mValueType@var1134 .@expr10517 smartPointerType@var3804 ) {
2222: return mValueType@var1134 .@expr10517 smartPointerType@var3804 ; }
2223:
2224:
2225: const Token * ptrType@var2669 ; ptrType@var2669 =@expr1073752343 typeStartToken (@expr1073752344 ) ;
2226: while (@expr1073752345 Token ::@expr10522 Match (@expr1073752347 ptrType@var2669 , "%name%|::" ) ) {
2227: ptrType@var2669 =@expr1073752348 ptrType@var2669 .@expr10525 next (@expr10526 ) ; }
2228: if (@expr1073752351 Token ::@expr10522 Match (@expr1073752353 ptrType@var2669 , "< %name% >" ) ) {
2229: return ptrType@var2669 .@expr1073752354 scope (@expr1073752355 ) .@expr1073752356 findType (@expr1073752357 ptrType@var2669 .@expr10525 next (@expr10526 ) .@expr1073752360 str (@expr1073752361 ) ) ; }
2230: return nullptr ;
2231: }
2232:
2233: std :: string Variable :: getTypeName ( ) const
2234: {
2235: std ::@expr1073752362 string ret@var2670 ;
2236:
2237: for (@expr1073752363 const Token *@expr1073752364 typeTok@var2671 =@expr1073752365 mTypeStartToken@var1127 ; Token ::@expr1073752366 Match (@expr1073752367 typeTok@var2671 , "%name%|::" ) &&@expr1073752368 typeTok@var2671 .@expr1073752369 varId (@expr1073752370 ) ==@expr1073752371 0 ; typeTok@var2671 =@expr1073752372 typeTok@var2671 .@expr1073752373 next (@expr1073752374 ) ) {
2238: ret@var2670 +=@expr1073752375 typeTok@var2671 .@expr1073752376 str (@expr1073752377 ) ; }
2239: return ret@var2670 ;
2240: }
2241:
2242: static bool isOperator ( const Token * tokenDef@var2672 )
2243: {
2244: if (@expr1073752378 !@expr1073752379 tokenDef@var2672 ) {
2245: return false ; }
2246: if (@expr1073752380 tokenDef@var2672 .@expr1073752381 isOperatorKeyword (@expr1073752382 ) ) {
2247: return true ; }
2248: const std ::@expr1073752383 string &@expr1073752384 name@var2673 =@expr1073752385 tokenDef@var2672 .@expr1073752386 str (@expr1073752387 ) ;
2249: return name@var2673 .@expr1073752388 size (@expr1073752389 ) >@expr1073752390 8 &&@expr1073752391 name@var2673 .@expr1073752392 compare (@expr1073752393 0 , 8 , "operator" ) ==@expr1073752394 0 &&@expr1073752395 std ::@expr1073752396 strchr (@expr1073752397 "+-*/%&|~^<>!=[(" , name@var2673 [@expr1073752398 8 ] ) ;
2250: }
2251:
2252: Function :: Function ( const Tokenizer * mTokenizer@var2674 ,
2253: const Token * tok@var2675 ,
2254: const Scope * scope@var2676 ,
2255: const Token * tokDef@var2677 ,
2256: const Token * tokArgDef@var2678 )
2257: : tokenDef@var1157 ( tokDef@var2677 ) ,
2258: argDef@var1158 ( tokArgDef@var2678 ) ,
2259: token@var1159 ( nullptr ) ,
2260: arg@var1160 ( nullptr ) ,
2261: retDef@var1161 ( nullptr ) ,
2262: retType@var1162 ( nullptr ) ,
2263: functionScope@var1163 ( nullptr ) ,
2264: nestedIn@var1164 ( scope@var2676 ) ,
2265: initArgCount@var1166 ( 0 ) ,
2266: type@var1167 ( eFunction ) ,
2267: access@var1168 ( AccessControl :: Public ) ,
2268: noexceptArg@var1169 ( nullptr ) ,
2269: throwArg@var1170 ( nullptr ) ,
2270: templateDef@var1171 ( nullptr ) ,
2271: functionPointerUsage@var1172 ( nullptr ) ,
2272: mFlags@var1187 ( 0 )
2273: {
2274:
2275: if (@expr1073752399 ::@expr1073752400 isOperator (@expr1073752401 tokenDef@var1157 ) ) {
2276: isOperator (@expr1073752402 true ) ;
2277:
2278:
2279: if (@expr1073752403 tokenDef@var1157 .@expr10580 str (@expr10581 ) ==@expr1073752406 "operator=" ) {
2280: type@var1167 =@expr1073752407 Function ::@expr1073752408 eOperatorEqual ; }
2281: }
2282:
2283: else { if (@expr1073752409 tokenDef@var1157 .@expr10580 str (@expr10581 ) ==@expr1073752412 "[" ) {
2284: type@var1167 =@expr1073752413 Function ::@expr1073752414 eLambda ;
2285: }
2286:
2287:
2288: else { if (@expr1073752415 (@expr1073752416 (@expr1073752417 tokenDef@var1157 .@expr10580 str (@expr10581 ) ==@expr1073752420 scope@var2676 .@expr10597 className@var2679 ) ||@expr1073752422
2289: (@expr1073752423 tokenDef@var1157 .@expr10580 str (@expr10581 ) .@expr1073752426 substr (@expr1073752427 0 , scope@var2676 .@expr10597 className@var2679 .@expr10605 size (@expr10606 ) ) ==@expr1073752431 scope@var2676 .@expr10597 className@var2679 &&@expr1073752433
2290: tokenDef@var1157 .@expr10580 str (@expr10581 ) .@expr1073752436 size (@expr1073752437 ) >@expr1073752438 scope@var2676 .@expr10597 className@var2679 .@expr10605 size (@expr10606 ) +@expr10618 1 &&@expr1073752443
2291: tokenDef@var1157 .@expr10580 str (@expr10581 ) [@expr1073752446 scope@var2676 .@expr10597 className@var2679 .@expr10605 size (@expr10606 ) +@expr10618 1 ] ==@expr1073752451 '<' ) ) &&@expr1073752452
2292: scope@var2676 .@expr1073752453 type@var2680 !=@expr1073752454 Scope ::@expr1073752455 ScopeType ::@expr1073752456 eNamespace ) {
2293:
2294: if (@expr1073752457 tokenDef@var1157 .@expr1073752458 previous (@expr1073752459 ) .@expr1073752460 str (@expr1073752461 ) ==@expr1073752462 "~" ) {
2295: type@var1167 =@expr1073752463 Function ::@expr1073752464 eDestructor ; }
2296:
2297: else {
2298: type@var1167 =@expr1073752465 Function ::@expr1073752466 eConstructor ; }
2299:
2300: isExplicit (@expr1073752467 tokenDef@var1157 .@expr10644 strAt (@expr1073752469 -1 ) ==@expr1073752470 "explicit" ||@expr1073752471 tokenDef@var1157 .@expr10644 strAt (@expr1073752473 -2 ) ==@expr1073752474 "explicit" ) ;
2301: } } }
2302:
2303: const Token * tok1@var2681 ; tok1@var2681 =@expr1073752475 setFlags (@expr1073752476 tok@var2675 , scope@var2676 ) ;
2304:
2305:
2306: if (@expr1073752477 !@expr1073752478 isConstructor (@expr1073752479 ) &&@expr1073752480 !@expr1073752481 isDestructor (@expr1073752482 ) &&@expr1073752483 !@expr1073752484 isLambda (@expr1073752485 ) ) {
2307:
2308:
2309: if (@expr1073752486 Token ::@expr10663 Match (@expr1073752488 argDef@var1158 .@expr10665 link (@expr10666 ) .@expr1073752491 next (@expr1073752492 ) , "const|volatile| &|&&| ." ) ) {
2310: hasTrailingReturnType (@expr1073752493 true ) ;
2311: if (@expr1073752494 argDef@var1158 .@expr10665 link (@expr10666 ) .@expr10673 strAt (@expr1073752498 1 ) ==@expr1073752499 "." ) {
2312: retDef@var1161 =@expr1073752500 argDef@var1158 .@expr10665 link (@expr10666 ) .@expr10679 tokAt (@expr1073752504 2 ) ; }
2313: else { if (@expr1073752505 argDef@var1158 .@expr10665 link (@expr10666 ) .@expr10673 strAt (@expr1073752509 2 ) ==@expr1073752510 "." ) {
2314: retDef@var1161 =@expr1073752511 argDef@var1158 .@expr10665 link (@expr10666 ) .@expr10679 tokAt (@expr1073752515 3 ) ; }
2315: else { if (@expr1073752516 argDef@var1158 .@expr10665 link (@expr10666 ) .@expr10673 strAt (@expr1073752520 3 ) ==@expr1073752521 "." ) {
2316: retDef@var1161 =@expr1073752522 argDef@var1158 .@expr10665 link (@expr10666 ) .@expr10679 tokAt (@expr1073752526 4 ) ; } } }
2317: } else {
2318: if (@expr1073752527 tok1@var2681 .@expr1073752528 str (@expr1073752529 ) ==@expr1073752530 ">" ) {
2319: tok1@var2681 =@expr1073752531 tok1@var2681 .@expr10708 next (@expr10709 ) ; }
2320: while (@expr1073752534 Token ::@expr10663 Match (@expr1073752536 tok1@var2681 , "extern|virtual|static|friend|struct|union|enum" ) ) {
2321: tok1@var2681 =@expr1073752537 tok1@var2681 .@expr10708 next (@expr10709 ) ; }
2322: retDef@var1161 =@expr1073752540 tok1@var2681 ;
2323: }
2324: }
2325:
2326: const Token * end@var2682 ; end@var2682 =@expr1073752541 argDef@var1158 .@expr10665 link (@expr10666 ) ;
2327:
2328:
2329: tok@var2675 =@expr1073752544 end@var2682 .@expr1073752545 next (@expr1073752546 ) ;
2330: while (@expr1073752547 tok@var2675 ) {
2331: if (@expr1073752548 tok@var2675 .@expr10725 str (@expr10726 ) ==@expr1073752551 "const" ) {
2332: isConst (@expr1073752552 true ) ; }
2333: else { if (@expr1073752553 tok@var2675 .@expr10725 str (@expr10726 ) ==@expr1073752556 "&" ) {
2334: hasLvalRefQualifier (@expr1073752557 true ) ; }
2335: else { if (@expr1073752558 tok@var2675 .@expr10725 str (@expr10726 ) ==@expr1073752561 "&&" ) {
2336: hasRvalRefQualifier (@expr1073752562 true ) ; }
2337: else { if (@expr1073752563 tok@var2675 .@expr10725 str (@expr10726 ) ==@expr1073752566 "override" ) {
2338: setFlag (@expr1073752567 fHasOverrideSpecifier , true ) ; }
2339: else { if (@expr1073752568 tok@var2675 .@expr10725 str (@expr10726 ) ==@expr1073752571 "final" ) {
2340: setFlag (@expr1073752572 fHasFinalSpecifier , true ) ; }
2341: else { if (@expr1073752573 tok@var2675 .@expr10725 str (@expr10726 ) ==@expr1073752576 "volatile" ) {
2342: isVolatile (@expr1073752577 true ) ; }
2343: else { if (@expr1073752578 tok@var2675 .@expr10725 str (@expr10726 ) ==@expr1073752581 "noexcept" ) {
2344: isNoExcept (@expr1073752582 !@expr1073752583 Token ::@expr10760 simpleMatch (@expr1073752585 tok@var2675 .@expr10762 next (@expr10763 ) , "( false )" ) ) ;
2345: if (@expr1073752588 tok@var2675 .@expr10762 next (@expr10763 ) .@expr1073752591 str (@expr1073752592 ) ==@expr1073752593 "(" ) {
2346: tok@var2675 =@expr1073752594 tok@var2675 .@expr10771 linkAt (@expr10772 1 ) ; }
2347: } else { if (@expr1073752597 Token ::@expr10760 simpleMatch (@expr1073752599 tok@var2675 , "throw (" ) ) {
2348: isThrow (@expr1073752600 true ) ;
2349: if (@expr1073752601 tok@var2675 .@expr10778 strAt (@expr1073752603 2 ) !=@expr1073752604 ")" ) {
2350: throwArg@var1170 =@expr1073752605 tok@var2675 .@expr10762 next (@expr10763 ) ; }
2351: tok@var2675 =@expr1073752608 tok@var2675 .@expr10771 linkAt (@expr10772 1 ) ;
2352: } else { if (@expr1073752611 Token ::@expr10663 Match (@expr1073752613 tok@var2675 , "= 0|default|delete ;" ) ) {
2353: const std ::@expr1073752614 string &@expr1073752615 modifier@var2683 =@expr1073752616 tok@var2675 .@expr10778 strAt (@expr1073752618 1 ) ;
2354: isPure (@expr1073752619 modifier@var2683 ==@expr1073752620 "0" ) ;
2355: isDefault (@expr1073752621 modifier@var2683 ==@expr1073752622 "default" ) ;
2356: isDelete (@expr1073752623 modifier@var2683 ==@expr1073752624 "delete" ) ;
2357: } else { if (@expr1073752625 tok@var2675 .@expr10725 str (@expr10726 ) ==@expr1073752628 "." ) {
2358:
2359: while (@expr1073752629 tok@var2675 &&@expr1073752630 !@expr1073752631 Token ::@expr10663 Match (@expr1073752633 tok@var2675 .@expr10762 next (@expr10763 ) , ";|{|override|final" ) ) {
2360: tok@var2675 =@expr1073752636 tok@var2675 .@expr10762 next (@expr10763 ) ; }
2361: } else {
2362: break ; } } } } } } } } } }
2363: if (@expr1073752639 tok@var2675 ) {
2364: tok@var2675 =@expr1073752640 tok@var2675 .@expr10762 next (@expr10763 ) ; }
2365: }
2366:
2367: if (@expr1073752643 mTokenizer@var2674 .@expr1073752644 isFunctionHead (@expr1073752645 end@var2682 , ":{" ) ) {
2368:
2369: token@var1159 =@expr1073752646 tokenDef@var1157 ;
2370: arg@var1160 =@expr1073752647 argDef@var1158 ;
2371: isInline (@expr1073752648 true ) ;
2372: hasBody (@expr1073752649 true ) ;
2373: }
2374: }
2375:
2376: Function :: Function ( const Token * tokenDef@var2684 , const std :: string & clangType@var2685 )
2377: : tokenDef@var1157 ( tokenDef@var2684 ) ,
2378: argDef@var1158 ( nullptr ) ,
2379: token@var1159 ( nullptr ) ,
2380: arg@var1160 ( nullptr ) ,
2381: retDef@var1161 ( nullptr ) ,
2382: retType@var1162 ( nullptr ) ,
2383: functionScope@var1163 ( nullptr ) ,
2384: nestedIn@var1164 ( nullptr ) ,
2385: initArgCount@var1166 ( 0 ) ,
2386: type@var1167 ( eFunction ) ,
2387: access@var1168 ( AccessControl :: Public ) ,
2388: noexceptArg@var1169 ( nullptr ) ,
2389: throwArg@var1170 ( nullptr ) ,
2390: templateDef@var1171 ( nullptr ) ,
2391: functionPointerUsage@var1172 ( nullptr ) ,
2392: mFlags@var1187 ( 0 )
2393: {
2394:
2395: if (@expr1073752650 ::@expr1073752651 isOperator (@expr1073752652 tokenDef@var2684 ) ) {
2396: isOperator (@expr1073752653 true ) ;
2397:
2398:
2399: if (@expr1073752654 tokenDef@var2684 .@expr1073752655 str (@expr1073752656 ) ==@expr1073752657 "operator=" ) {
2400: type@var1167 =@expr1073752658 Function ::@expr1073752659 eOperatorEqual ; }
2401: }
2402:
2403: setFlags (@expr1073752660 tokenDef@var2684 , tokenDef@var2684 .@expr1073752661 scope (@expr1073752662 ) ) ;
2404:
2405: if (@expr1073752663 endsWith (@expr1073752664 clangType@var2685 , " const" ) ) {
2406: isConst (@expr1073752665 true ) ; }
2407: }
2408:
2409: const Token * Function :: setFlags ( const Token * tok1@var2686 , const Scope * scope@var2687 )
2410: {
2411: if (@expr10842 tok1@var2686 .@expr10843 isInline (@expr10844 ) ) {
2412: isInlineKeyword (@expr10845 true ) ; }
2413:
2414:
2415: while (@expr1073752670 tok1@var2686 .@expr10847 previous (@expr10848 ) &&@expr1073752673 !@expr1073752674 Token ::@expr1073752675 Match (@expr1073752676 tok1@var2686 .@expr10847 previous (@expr10848 ) , ";|}|{|public:|protected:|private:" ) ) {
2416: tok1@var2686 =@expr1073752679 tok1@var2686 .@expr10847 previous (@expr10848 ) ;
2417:
2418: if (@expr10842 tok1@var2686 .@expr10843 isInline (@expr10844 ) ) {
2419: isInlineKeyword (@expr10845 true ) ; }
2420:
2421:
2422: if (@expr1073752686 tok1@var2686 .@expr10863 str (@expr10864 ) ==@expr1073752689 "extern" ) {
2423: isExtern (@expr1073752690 true ) ;
2424: }
2425:
2426:
2427: else { if (@expr1073752691 tok1@var2686 .@expr10863 str (@expr10864 ) ==@expr1073752694 "virtual" ) {
2428: hasVirtualSpecifier (@expr1073752695 true ) ;
2429: }
2430:
2431:
2432: else { if (@expr1073752696 tok1@var2686 .@expr10863 str (@expr10864 ) ==@expr1073752699 "static" ) {
2433: isStatic (@expr1073752700 true ) ;
2434: if (@expr1073752701 scope@var2687 .@expr10878 type@var2688 ==@expr1073752703 Scope ::@expr1073752704 eNamespace ||@expr1073752705 scope@var2687 .@expr10878 type@var2688 ==@expr1073752707 Scope ::@expr1073752708 eGlobal ) {
2435: isStaticLocal (@expr1073752709 true ) ; }
2436: }
2437:
2438:
2439: else { if (@expr1073752710 tok1@var2686 .@expr10863 str (@expr10864 ) ==@expr1073752713 "friend" ) {
2440: isFriend (@expr1073752714 true ) ;
2441: }
2442:
2443:
2444: else { if (@expr1073752715 tok1@var2686 .@expr10863 str (@expr10864 ) ==@expr1073752718 "constexpr" ) {
2445: isConstexpr (@expr1073752719 true ) ;
2446: }
2447:
2448:
2449: else { if (@expr1073752720 tok1@var2686 .@expr10863 str (@expr10864 ) ==@expr1073752723 ")" &&@expr1073752724 Token ::@expr10901 simpleMatch (@expr1073752726 tok1@var2686 .@expr10903 link (@expr10904 ) .@expr10905 previous (@expr10906 ) , "decltype (" ) ) {
2450: tok1@var2686 =@expr1073752731 tok1@var2686 .@expr10903 link (@expr10904 ) .@expr10905 previous (@expr10906 ) ;
2451: }
2452:
2453:
2454: else { if (@expr1073752736 tok1@var2686 .@expr10903 link (@expr10904 ) &&@expr1073752739 tok1@var2686 .@expr10863 str (@expr10864 ) ==@expr1073752742 ">" &&@expr1073752743 Token ::@expr10901 simpleMatch (@expr1073752745 tok1@var2686 .@expr10903 link (@expr10904 ) .@expr10905 previous (@expr10906 ) , "template <" ) ) {
2455: templateDef@var1171 =@expr1073752750 tok1@var2686 .@expr10903 link (@expr10904 ) .@expr10905 previous (@expr10906 ) ;
2456: break ;
2457: } } } } } } }
2458: }
2459: return tok1@var2686 ;
2460: }
2461:
2462: std :: string Function :: fullName ( ) const
2463: {
2464: std ::@expr1073752755 string ret@var2689 ; ret@var2689 =@expr1073752756 name (@expr1073752757 ) ;
2465: for (@expr1073752758 const Scope *@expr1073752759 s@var2690 =@expr1073752760 nestedIn@var1164 ; s@var2690 ; s@var2690 =@expr1073752761 s@var2690 .@expr1073752762 nestedIn@var2691 ) {
2466: if (@expr1073752763 !@expr1073752764 s@var2690 .@expr10941 className@var2692 .@expr1073752766 empty (@expr1073752767 ) ) {
2467: ret@var2689 =@expr1073752768 s@var2690 .@expr10941 className@var2692 +@expr1073752770 "::" +@expr1073752771 ret@var2689 ; }
2468: }
2469: ret@var2689 +=@expr1073752772 "(" ;
2470: for (@expr1073752773 const Variable &@expr1073752774 a@var2693 :@expr1073752775 argumentList@var1165 ) {
2471: ret@var2689 +=@expr1073752776 (@expr1073752777 a@var2693 .@expr1073752778 index (@expr1073752779 ) ==@expr1073752780 0 ?@expr1073752781 "" :@expr1073752782 "," ) +@expr1073752783 a@var2693 .@expr1073752784 name (@expr1073752785 ) ; }
2472: return ret@var2689 +@expr1073752786 ")" ;
2473: }
2474:
2475: static std :: string qualifiedName ( const Scope * scope@var2694 )
2476: {
2477: std ::@expr1073752787 string name@var2695 ; name@var2695 =@expr1073752788 scope@var2694 .@expr1073752789 className@var2696 ;
2478: while (@expr1073752790 scope@var2694 .@expr10967 nestedIn@var2697 ) {
2479: if (@expr1073752792 !@expr1073752793 scope@var2694 .@expr10967 nestedIn@var2697 .@expr10971 className@var2698 .@expr1073752796 empty (@expr1073752797 ) ) {
2480: name@var2695 =@expr1073752798 (@expr1073752799 scope@var2694 .@expr10967 nestedIn@var2697 .@expr10971 className@var2698 +@expr1073752802 " :: " ) +@expr1073752803 name@var2695 ; }
2481: scope@var2694 =@expr1073752804 scope@var2694 .@expr10967 nestedIn@var2697 ;
2482: }
2483: return name@var2695 ;
2484: }
2485:
2486: static bool usingNamespace ( const Scope * scope@var2699 , const Token * first@var2700 , const Token * second@var2701 , int & offset@var2702 )
2487: {
2488:
2489: const Token * tok1@var2703 ; tok1@var2703 =@expr1073752806 first@var2700 ;
2490: const Token * tok2@var2704 ; tok2@var2704 =@expr1073752807 second@var2701 ;
2491: bool match@var2705 ; match@var2705 =@expr1073752808 false ;
2492: while (@expr1073752809 Token ::@expr10986 Match (@expr1073752811 tok1@var2703 , "%type% :: %type%" ) &&@expr1073752812 Token ::@expr10986 Match (@expr1073752814 tok2@var2704 , "%type% :: %type%" ) ) {
2493: if (@expr1073752815 tok1@var2703 .@expr1073752816 str (@expr1073752817 ) ==@expr1073752818 tok2@var2704 .@expr1073752819 str (@expr1073752820 ) ) {
2494: tok1@var2703 =@expr1073752821 tok1@var2703 .@expr1073752822 tokAt (@expr1073752823 2 ) ;
2495: tok2@var2704 =@expr1073752824 tok2@var2704 .@expr1073752825 tokAt (@expr1073752826 2 ) ;
2496: match@var2705 =@expr1073752827 true ;
2497: } else {
2498: match@var2705 =@expr1073752828 false ;
2499: break ;
2500: }
2501: }
2502:
2503: if (@expr1073752829 match@var2705 ) {
2504: return false ; }
2505:
2506: offset@var2702 =@expr1073752830 0 ;
2507: std ::@expr1073752831 string name@var2706 ; name@var2706 =@expr1073752832 first@var2700 .@expr11009 str (@expr11010 ) ;
2508:
2509: while (@expr1073752835 Token ::@expr10986 Match (@expr1073752837 first@var2700 , "%type% :: %type%" ) ) {
2510: if (@expr11014 offset@var2702 ) {
2511: name@var2706 +=@expr1073752839 (@expr1073752840 " :: " +@expr1073752841 first@var2700 .@expr11009 str (@expr11010 ) ) ; }
2512: offset@var2702 +=@expr1073752844 2 ;
2513: first@var2700 =@expr1073752845 first@var2700 .@expr1073752846 tokAt (@expr1073752847 2 ) ;
2514: if (@expr1073752848 first@var2700 .@expr11009 str (@expr11010 ) ==@expr1073752851 second@var2701 .@expr1073752852 str (@expr1073752853 ) ) {
2515: break ;
2516: }
2517: }
2518:
2519: if (@expr11014 offset@var2702 ) {
2520: while (@expr1073752855 scope@var2699 ) {
2521: for (@expr1073752856 const auto &@expr1073752857 info@var2707 :@expr1073752858 scope@var2699 .@expr1073752859 usingList@var2708 ) {
2522: if (@expr1073752860 info@var2707 .@expr11037 scope@var2709 ) {
2523: if (@expr1073752862 name@var2706 ==@expr1073752863 qualifiedName (@expr1073752864 info@var2707 .@expr11037 scope@var2709 ) ) {
2524: return true ; }
2525: }
2526:
2527: else {
2528: const Token * start@var2710 ; start@var2710 =@expr1073752866 info@var2707 .@expr1073752867 start@var2711 .@expr1073752868 tokAt (@expr1073752869 2 ) ;
2529: std ::@expr1073752870 string nsName@var2712 ;
2530: while (@expr1073752871 start@var2710 &&@expr1073752872 start@var2710 .@expr11049 str (@expr11050 ) !=@expr1073752875 ";" ) {
2531: if (@expr1073752876 !@expr1073752877 nsName@var2712 .@expr1073752878 empty (@expr1073752879 ) ) {
2532: nsName@var2712 +=@expr1073752880 " " ; }
2533: nsName@var2712 +=@expr1073752881 start@var2710 .@expr11049 str (@expr11050 ) ;
2534: start@var2710 =@expr1073752884 start@var2710 .@expr1073752885 next (@expr1073752886 ) ;
2535: }
2536: if (@expr1073752887 nsName@var2712 ==@expr1073752888 name@var2706 ) {
2537: return true ; }
2538: }
2539: }
2540: scope@var2699 =@expr1073752889 scope@var2699 .@expr1073752890 nestedIn@var2713 ;
2541: }
2542: }
2543:
2544: return false ;
2545: }
2546:
2547: static bool typesMatch (
2548: const Scope * first_scope@var2714 ,
2549: const Token * first_token@var2715 ,
2550: const Scope * second_scope@var2716 ,
2551: const Token * second_token@var2717 ,
2552: const Token * * new_first@var2718 ,
2553: const Token * * new_second@var2719 )
2554: {
2555:
2556: const Type * first_type@var2720 ; first_type@var2720 =@expr1073752891 first_scope@var2714 .@expr1073752892 check@var2721 .@expr1073752893 findType (@expr1073752894 first_token@var2715 , first_scope@var2714 ) ;
2557: if (@expr1073752895 first_type@var2720 ) {
2558:
2559: const Type * second_type@var2722 ; second_type@var2722 =@expr1073752896 second_scope@var2716 .@expr1073752897 check@var2723 .@expr1073752898 findType (@expr1073752899 second_token@var2717 , second_scope@var2716 ) ;
2560:
2561: if (@expr1073752900 first_type@var2720 ==@expr1073752901 second_type@var2722 ) {
2562: const Token * tok1@var2724 ; tok1@var2724 =@expr1073752902 first_token@var2715 ;
2563: while (@expr1073752903 tok1@var2724 &&@expr1073752904 tok1@var2724 .@expr1073752905 str (@expr1073752906 ) !=@expr1073752907 first_type@var2720 .@expr1073752908 name (@expr1073752909 ) ) {
2564: tok1@var2724 =@expr1073752910 tok1@var2724 .@expr1073752911 next (@expr1073752912 ) ; }
2565: const Token * tok2@var2725 ; tok2@var2725 =@expr1073752913 second_token@var2717 ;
2566: while (@expr1073752914 tok2@var2725 &&@expr1073752915 tok2@var2725 .@expr1073752916 str (@expr1073752917 ) !=@expr1073752918 second_type@var2722 .@expr1073752919 name (@expr1073752920 ) ) {
2567: tok2@var2725 =@expr1073752921 tok2@var2725 .@expr1073752922 next (@expr1073752923 ) ; }
2568:
2569: if (@expr1073752924 tok1@var2724 &&@expr1073752925 tok2@var2725 ) {
2570: *@expr1073752926 new_first@var2718 =@expr1073752927 tok1@var2724 .@expr1073752928 previous (@expr1073752929 ) ;
2571: *@expr1073752930 new_second@var2719 =@expr1073752931 tok2@var2725 .@expr1073752932 previous (@expr1073752933 ) ;
2572: return true ;
2573: }
2574: }
2575: }
2576: return false ;
2577: }
2578:
2579: bool Function :: argsMatch ( const Scope * scope@var2726 , const Token * first@var2727 , const Token * second@var2728 , const std :: string & path@var2729 , int path_length@var2730 ) const
2580: {
2581: const bool isCPP@var2731 =@expr1073752935 scope@var2726 .@expr1073752936 check@var2732 .@expr1073752937 isCPP (@expr1073752938 ) ;
2582: if (@expr1073752939 !@expr1073752940 isCPP@var2731 ) {
2583: return true ; }
2584:
2585: int arg_path_length@var2733 ; arg_path_length@var2733 =@expr1073752941 path_length@var2730 ;
2586: int offset@var2734 ; offset@var2734 =@expr1073752942 0 ;
2587: int openParen@var2735 ; openParen@var2735 =@expr1073752943 0 ;
2588:
2589:
2590: if (@expr1073752944 (@expr1073752945 Token ::@expr11122 simpleMatch (@expr1073752947 first@var2727 , "( )" ) &&@expr1073752948 Token ::@expr11122 simpleMatch (@expr1073752950 second@var2728 , "( void )" ) ) ||@expr1073752951
2591: (@expr1073752952 Token ::@expr11122 simpleMatch (@expr1073752954 first@var2727 , "( void )" ) &&@expr1073752955 Token ::@expr11122 simpleMatch (@expr1073752957 second@var2728 , "( )" ) ) ) {
2592: return true ; }
2593:
2594: while (@expr1073752958 first@var2727 .@expr11135 str (@expr11136 ) ==@expr1073752961 second@var2728 .@expr11138 str (@expr11139 ) &&@expr1073752964
2595: first@var2727 .@expr1073752965 isLong (@expr1073752966 ) ==@expr1073752967 second@var2728 .@expr1073752968 isLong (@expr1073752969 ) &&@expr1073752970
2596: first@var2727 .@expr1073752971 isUnsigned (@expr1073752972 ) ==@expr1073752973 second@var2728 .@expr1073752974 isUnsigned (@expr1073752975 ) ) {
2597: if (@expr1073752976 first@var2727 .@expr11135 str (@expr11136 ) ==@expr1073752979 "(" ) {
2598: openParen@var2735 ++@expr1073752980 ; }
2599:
2600:
2601: else { if (@expr1073752981 first@var2727 .@expr11135 str (@expr11136 ) ==@expr1073752984 ")" ) {
2602: if (@expr1073752985 openParen@var2735 ==@expr11162 1 ) {
2603: return true ; }
2604: else {
2605: --@expr1073752987 openParen@var2735 ; }
2606: } }
2607:
2608:
2609: if (@expr1073752988 Token ::@expr11165 Match (@expr1073752990 first@var2727 .@expr11167 next (@expr11168 ) , "struct|enum|union|class" ) ) {
2610: first@var2727 =@expr1073752993 first@var2727 .@expr11167 next (@expr11168 ) ; }
2611: if (@expr1073752996 Token ::@expr11165 Match (@expr1073752998 second@var2728 .@expr11175 next (@expr11176 ) , "struct|enum|union|class" ) ) {
2612: second@var2728 =@expr1073753001 second@var2728 .@expr11175 next (@expr11176 ) ; }
2613:
2614:
2615: if (@expr1073753004 Token ::@expr11165 Match (@expr1073753006 first@var2727 .@expr11167 next (@expr11168 ) , "const %type% %name%|,|)" ) &&@expr1073753009
2616: !@expr1073753010 Token ::@expr11165 Match (@expr1073753012 first@var2727 .@expr11167 next (@expr11168 ) , "const %type% %name%| [" ) ) {
2617: first@var2727 =@expr1073753015 first@var2727 .@expr11167 next (@expr11168 ) ; }
2618: if (@expr1073753018 Token ::@expr11165 Match (@expr1073753020 second@var2728 .@expr11175 next (@expr11176 ) , "const %type% %name%|,|)" ) &&@expr1073753023
2619: !@expr1073753024 Token ::@expr11165 Match (@expr1073753026 second@var2728 .@expr11175 next (@expr11176 ) , "const %type% %name%| [" ) ) {
2620: second@var2728 =@expr1073753029 second@var2728 .@expr11175 next (@expr11176 ) ; }
2621:
2622:
2623: else { if (@expr11208 first@var2727 .@expr11167 next (@expr11168 ) .@expr11211 str (@expr11212 ) ==@expr11213 "=" ) {
2624: first@var2727 =@expr1073753038 first@var2727 .@expr1073753039 nextArgument (@expr1073753040 ) ;
2625: if (@expr1073753041 first@var2727 ) {
2626: first@var2727 =@expr1073753042 first@var2727 .@expr11219 tokAt (@expr1073753044 -2 ) ; }
2627: if (@expr11221 second@var2728 .@expr11175 next (@expr11176 ) .@expr11224 str (@expr11225 ) ==@expr11226 "=" ) {
2628: second@var2728 =@expr1073753051 second@var2728 .@expr11228 nextArgument (@expr11229 ) ;
2629: if (@expr11230 second@var2728 ) {
2630: second@var2728 =@expr1073753055 second@var2728 .@expr11232 tokAt (@expr11233 -2 ) ; }
2631: if (@expr1073753058 !@expr11235 first@var2727 ||@expr1073753060 !@expr11237 second@var2728 ) {
2632: return !@expr11235 first@var2727 &&@expr1073753063 !@expr11237 second@var2728 ;
2633: }
2634: } else { if (@expr1073753065 !@expr11235 first@var2727 ) {
2635: return !@expr1073753067 second@var2728 .@expr11228 nextArgument (@expr11229 ) ;
2636: } }
2637: } else { if (@expr11221 second@var2728 .@expr11175 next (@expr11176 ) .@expr11224 str (@expr11225 ) ==@expr11226 "=" ) {
2638: second@var2728 =@expr1073753076 second@var2728 .@expr11228 nextArgument (@expr11229 ) ;
2639: if (@expr11230 second@var2728 ) {
2640: second@var2728 =@expr1073753080 second@var2728 .@expr11232 tokAt (@expr11233 -2 ) ; }
2641: if (@expr1073753083 !@expr11237 second@var2728 ) {
2642: return false ;
2643: }
2644: }
2645:
2646:
2647: else { if (@expr1073753085 (@expr1073753086 first@var2727 .@expr11167 next (@expr11168 ) .@expr11211 str (@expr11212 ) ==@expr1073753091 "," &&@expr1073753092 second@var2728 .@expr11175 next (@expr11176 ) .@expr11224 str (@expr11225 ) !=@expr1073753097 "," ) ||@expr1073753098
2648: (@expr1073753099 Token ::@expr11165 Match (@expr1073753101 first@var2727 , "!!( )" ) &&@expr1073753102 second@var2728 .@expr11175 next (@expr11176 ) .@expr11224 str (@expr11225 ) !=@expr1073753107 ")" ) ) {
2649: second@var2728 =@expr1073753108 second@var2728 .@expr11175 next (@expr11176 ) ;
2650:
2651: if (@expr11221 second@var2728 .@expr11175 next (@expr11176 ) .@expr11224 str (@expr11225 ) ==@expr11226 "=" ) {
2652: do {
2653: second@var2728 =@expr1073753117 second@var2728 .@expr11175 next (@expr11176 ) ;
2654: } while (@expr11296 !@expr11297 Token ::@expr11165 Match (@expr11299 second@var2728 .@expr11175 next (@expr11176 ) , ",|)" ) ) ;
2655: }
2656: } else { if (@expr1073753126 first@var2727 .@expr11167 next (@expr11168 ) .@expr11211 str (@expr11212 ) ==@expr1073753131 "[" &&@expr1073753132 second@var2728 .@expr11175 next (@expr11176 ) .@expr11224 str (@expr11225 ) !=@expr1073753137 "[" ) {
2657: second@var2728 =@expr1073753138 second@var2728 .@expr11175 next (@expr11176 ) ; }
2658:
2659:
2660: else { if (@expr1073753141 (@expr1073753142 second@var2728 .@expr11175 next (@expr11176 ) .@expr11224 str (@expr11225 ) ==@expr1073753147 "," &&@expr1073753148 first@var2727 .@expr11167 next (@expr11168 ) .@expr11211 str (@expr11212 ) !=@expr1073753153 "," ) ||@expr1073753154
2661: (@expr1073753155 Token ::@expr11165 Match (@expr1073753157 second@var2728 , "!!( )" ) &&@expr1073753158 first@var2727 .@expr11167 next (@expr11168 ) .@expr11211 str (@expr11212 ) !=@expr1073753163 ")" ) ) {
2662: first@var2727 =@expr1073753164 first@var2727 .@expr11167 next (@expr11168 ) ;
2663:
2664: if (@expr11208 first@var2727 .@expr11167 next (@expr11168 ) .@expr11211 str (@expr11212 ) ==@expr11213 "=" ) {
2665: do {
2666: first@var2727 =@expr1073753173 first@var2727 .@expr11167 next (@expr11168 ) ;
2667: } while (@expr11352 !@expr11353 Token ::@expr11165 Match (@expr11355 first@var2727 .@expr11167 next (@expr11168 ) , ",|)" ) ) ;
2668: }
2669: } else { if (@expr1073753182 second@var2728 .@expr11175 next (@expr11176 ) .@expr11224 str (@expr11225 ) ==@expr1073753187 "[" &&@expr1073753188 first@var2727 .@expr11167 next (@expr11168 ) .@expr11211 str (@expr11212 ) !=@expr1073753193 "[" ) {
2670: first@var2727 =@expr1073753194 first@var2727 .@expr11167 next (@expr11168 ) ; }
2671:
2672:
2673: else { if (@expr1073753197 Token ::@expr11165 Match (@expr1073753199 first@var2727 , "(|, %type% ,|)" ) &&@expr1073753200 Token ::@expr11165 Match (@expr1073753202 second@var2728 , "(|, %type% ,|)" ) ) {
2674: if (@expr1073753203 first@var2727 .@expr11167 next (@expr11168 ) .@expr1073753206 expressionString (@expr1073753207 ) !=@expr1073753208 second@var2728 .@expr11175 next (@expr11176 ) .@expr1073753211 expressionString (@expr1073753212 ) ) {
2675: break ; }
2676: first@var2727 =@expr1073753213 first@var2727 .@expr11167 next (@expr11168 ) ;
2677: second@var2728 =@expr1073753216 second@var2728 .@expr11175 next (@expr11176 ) ;
2678: continue ;
2679: }
2680:
2681:
2682: else { if (@expr1073753219 openParen@var2735 ==@expr11162 1 &&@expr1073753221 second@var2728 .@expr11138 str (@expr11139 ) ==@expr1073753224 ")" &&@expr1073753225 first@var2727 .@expr11135 str (@expr11136 ) !=@expr1073753228 ")" ) {
2683: break ; }
2684:
2685:
2686: else { if (@expr1073753229 Token ::@expr11165 Match (@expr1073753231 first@var2727 .@expr11167 next (@expr11168 ) , "* %name%| ,|)|=" ) &&@expr1073753234
2687: Token ::@expr11165 Match (@expr1073753236 second@var2728 .@expr11175 next (@expr11176 ) , "%name%| [ ] ,|)" ) ) {
2688: do {
2689: first@var2727 =@expr1073753239 first@var2727 .@expr11167 next (@expr11168 ) ;
2690: } while (@expr11352 !@expr11353 Token ::@expr11165 Match (@expr11355 first@var2727 .@expr11167 next (@expr11168 ) , ",|)" ) ) ;
2691: do {
2692: second@var2728 =@expr1073753248 second@var2728 .@expr11175 next (@expr11176 ) ;
2693: } while (@expr11296 !@expr11297 Token ::@expr11165 Match (@expr11299 second@var2728 .@expr11175 next (@expr11176 ) , ",|)" ) ) ;
2694: }
2695:
2696:
2697: else { if (@expr1073753257 first@var2727 .@expr11167 next (@expr11168 ) .@expr11211 str (@expr11212 ) ==@expr1073753262 "*" &&@expr1073753263 second@var2728 .@expr11175 next (@expr11176 ) .@expr11224 str (@expr11225 ) ==@expr1073753268 "*" &&@expr1073753269
2698: (@expr1073753270 (@expr1073753271 first@var2727 .@expr11448 strAt (@expr11449 2 ) !=@expr11450 "const" &&@expr1073753275 second@var2728 .@expr11452 strAt (@expr11453 2 ) ==@expr1073753278 "const" ) ||@expr1073753279
2699: (@expr1073753280 first@var2727 .@expr11448 strAt (@expr11449 2 ) ==@expr1073753283 "const" &&@expr1073753284 second@var2728 .@expr11452 strAt (@expr11453 2 ) !=@expr1073753287 "const" ) ) ) {
2700: if (@expr1073753288 first@var2727 .@expr11448 strAt (@expr11449 2 ) !=@expr11450 "const" ) {
2701: first@var2727 =@expr1073753292 first@var2727 .@expr11167 next (@expr11168 ) ;
2702: second@var2728 =@expr1073753295 second@var2728 .@expr11232 tokAt (@expr11473 2 ) ;
2703: } else {
2704: first@var2727 =@expr1073753298 first@var2727 .@expr11219 tokAt (@expr1073753300 2 ) ;
2705: second@var2728 =@expr1073753301 second@var2728 .@expr11175 next (@expr11176 ) ;
2706: }
2707: }
2708:
2709:
2710: else { if (@expr1073753304 (@expr1073753305 Token ::@expr11165 Match (@expr1073753307 first@var2727 .@expr11167 next (@expr11168 ) , "%name% ,|)|=|[" ) &&@expr1073753310
2711: Token ::@expr11165 Match (@expr1073753312 second@var2728 .@expr11175 next (@expr11176 ) , "%name% ,|)|[" ) ) &&@expr1073753315
2712: (@expr1073753316 first@var2727 .@expr11167 next (@expr11168 ) .@expr11211 str (@expr11212 ) !=@expr1073753321 second@var2728 .@expr11175 next (@expr11176 ) .@expr11224 str (@expr11225 ) ) ) {
2713:
2714: first@var2727 =@expr1073753326 first@var2727 .@expr11167 next (@expr11168 ) ;
2715: second@var2728 =@expr1073753329 second@var2728 .@expr11175 next (@expr11176 ) ;
2716:
2717:
2718: if (@expr11208 first@var2727 .@expr11167 next (@expr11168 ) .@expr11211 str (@expr11212 ) ==@expr11213 "=" ) {
2719: do {
2720: first@var2727 =@expr1073753338 first@var2727 .@expr11167 next (@expr11168 ) ;
2721: } while (@expr11352 !@expr11353 Token ::@expr11165 Match (@expr11355 first@var2727 .@expr11167 next (@expr11168 ) , ",|)" ) ) ;
2722: }
2723: }
2724:
2725:
2726: else { if (@expr1073753347 usingNamespace (@expr1073753348 scope@var2726 , first@var2727 .@expr11167 next (@expr11168 ) , second@var2728 .@expr11175 next (@expr11176 ) , offset@var2734 ) ) {
2727: first@var2727 =@expr1073753353 first@var2727 .@expr11219 tokAt (@expr1073753355 offset@var2734 ) ; }
2728:
2729:
2730: else { if (@expr1073753356 typesMatch (@expr1073753357 scope@var2726 , first@var2727 .@expr11167 next (@expr11168 ) , nestedIn@var1164 , second@var2728 .@expr11175 next (@expr11176 ) , &@expr1073753362 first@var2727 , &@expr1073753363 second@var2728 ) ) {
2731: ; }
2732:
2733:
2734: else { if (@expr1073753364 arg_path_length@var2733 &&@expr1073753365 Token ::@expr11165 Match (@expr11543 first@var2727 .@expr11167 next (@expr11168 ) , "%name%" ) &&@expr1073753370 first@var2727 .@expr11448 strAt (@expr11548 1 ) !=@expr1073753373 "const" ) {
2735: std ::@expr1073753374 string param@var2736 ; param@var2736 =@expr1073753375 path@var2729 ;
2736:
2737: if (@expr11552 Token ::@expr11122 simpleMatch (@expr11554 second@var2728 .@expr11175 next (@expr11176 ) , param@var2736 .@expr11557 c_str (@expr11558 ) , param@var2736 .@expr11559 size (@expr11560 ) ) ) {
2738:
2739: if (@expr1073753385 !@expr1073753386 Token ::@expr11122 simpleMatch (@expr1073753388 first@var2727 .@expr11167 next (@expr11168 ) , param@var2736 .@expr11557 c_str (@expr11558 ) , param@var2736 .@expr11559 size (@expr11560 ) ) ) {
2740: second@var2728 =@expr1073753395 second@var2728 .@expr11232 tokAt (@expr1073753397 int (@expr1073753398 arg_path_length@var2733 ) ) ;
2741: arg_path_length@var2733 =@expr1073753399 0 ;
2742: }
2743: }
2744:
2745:
2746: else { if (@expr1073753400 arg_path_length@var2733 <=@expr1073753401 2 &&@expr1073753402 Token ::@expr11165 Match (@expr11543 first@var2727 .@expr11167 next (@expr11168 ) , "%name%" ) &&@expr1073753407
2747: (@expr1073753408 Token ::@expr11165 Match (@expr1073753410 second@var2728 .@expr11175 next (@expr11176 ) , "%name% :: %name%" ) ||@expr1073753413
2748: (@expr1073753414 Token ::@expr11165 Match (@expr11592 second@var2728 .@expr11175 next (@expr11176 ) , "%name% <" ) &&@expr1073753419
2749: Token ::@expr11165 Match (@expr1073753421 second@var2728 .@expr11598 linkAt (@expr11599 1 ) , "> :: %name%" ) ) ) &&@expr1073753424
2750: (@expr1073753425 (@expr1073753426 second@var2728 .@expr11175 next (@expr11176 ) .@expr11224 str (@expr11225 ) ==@expr1073753431 scope@var2726 .@expr1073753432 className@var2737 ) ||@expr1073753433
2751: (@expr1073753434 scope@var2726 .@expr11611 nestedIn@var2738 &&@expr1073753436 second@var2728 .@expr11175 next (@expr11176 ) .@expr11224 str (@expr11225 ) ==@expr1073753441 scope@var2726 .@expr11611 nestedIn@var2738 .@expr1073753443 className@var2739 ) ||@expr1073753444
2752: (@expr1073753445 scope@var2726 .@expr11622 definedType@var2740 &&@expr1073753447 scope@var2726 .@expr11622 definedType@var2740 .@expr1073753449 isDerivedFrom (@expr1073753450 second@var2728 .@expr11175 next (@expr11176 ) .@expr11224 str (@expr11225 ) ) ) ) &&@expr1073753455
2753: (@expr1073753456 first@var2727 .@expr11167 next (@expr11168 ) .@expr11211 str (@expr11212 ) ==@expr1073753461 second@var2728 .@expr11452 strAt (@expr1073753463 3 ) ) ) {
2754: if (@expr1073753464 Token ::@expr11165 Match (@expr11592 second@var2728 .@expr11175 next (@expr11176 ) , "%name% <" ) ) {
2755: second@var2728 =@expr1073753469 second@var2728 .@expr11598 linkAt (@expr11599 1 ) .@expr1073753472 next (@expr1073753473 ) ; }
2756: else {
2757: second@var2728 =@expr1073753474 second@var2728 .@expr11232 tokAt (@expr11473 2 ) ; }
2758: }
2759:
2760:
2761: else { if (@expr1073753477 arg_path_length@var2733 >@expr1073753478 2 &&@expr1073753479 first@var2727 .@expr11448 strAt (@expr11548 1 ) !=@expr1073753482 second@var2728 .@expr11452 strAt (@expr1073753484 1 ) ) {
2762: std ::@expr1073753485 string short_path@var2741 ; short_path@var2741 =@expr1073753486 path@var2729 ;
2763: unsigned int short_path_length@var2742 ; short_path_length@var2742 =@expr1073753487 arg_path_length@var2733 ;
2764:
2765:
2766: short_path@var2741 .@expr11664 resize (@expr1073753489 short_path@var2741 .@expr11666 size (@expr11667 ) -@expr1073753492 4 ) ;
2767: short_path_length@var2742 --@expr1073753493 ;
2768:
2769:
2770: std ::@expr11670 string ::@expr1073753495 size_type lastSpace@var2743 ; lastSpace@var2743 =@expr1073753496 short_path@var2741 .@expr11673 find_last_of (@expr11674 ' ' ) ;
2771: if (@expr1073753499 lastSpace@var2743 !=@expr1073753500 std ::@expr11670 string ::@expr1073753502 npos@expr1073752934 ) {
2772: short_path@var2741 .@expr11664 resize (@expr11680 lastSpace@var2743 +@expr11681 1 ) ;
2773: short_path_length@var2742 --@expr1073753506 ;
2774: if (@expr1073753507 short_path@var2741 [@expr11684 short_path@var2741 .@expr11666 size (@expr11667 ) -@expr11687 1 ] ==@expr1073753512 '>' ) {
2775: short_path@var2741 .@expr11664 resize (@expr1073753514 short_path@var2741 .@expr11666 size (@expr11667 ) -@expr1073753517 3 ) ;
2776: while (@expr1073753518 short_path@var2741 [@expr11684 short_path@var2741 .@expr11666 size (@expr11667 ) -@expr11687 1 ] ==@expr1073753523 '<' ) {
2777: lastSpace@var2743 =@expr1073753524 short_path@var2741 .@expr11673 find_last_of (@expr11674 ' ' ) ;
2778: short_path@var2741 .@expr11664 resize (@expr11680 lastSpace@var2743 +@expr11681 1 ) ;
2779: short_path_length@var2742 --@expr1073753530 ;
2780: }
2781: }
2782: }
2783:
2784: param@var2736 =@expr1073753531 short_path@var2741 ;
2785: if (@expr11552 Token ::@expr11122 simpleMatch (@expr11554 second@var2728 .@expr11175 next (@expr11176 ) , param@var2736 .@expr11557 c_str (@expr11558 ) , param@var2736 .@expr11559 size (@expr11560 ) ) ) {
2786: second@var2728 =@expr1073753541 second@var2728 .@expr11232 tokAt (@expr1073753543 int (@expr1073753544 short_path_length@var2742 ) ) ;
2787: arg_path_length@var2733 =@expr1073753545 0 ;
2788: }
2789: } } }
2790: } } } } } } } } } } } } } } }
2791:
2792: first@var2727 =@expr1073753546 first@var2727 .@expr11167 next (@expr11168 ) ;
2793: second@var2728 =@expr1073753549 second@var2728 .@expr11175 next (@expr11176 ) ;
2794:
2795:
2796: if (@expr1073753552 first@var2727 .@expr11135 str (@expr11136 ) ==@expr1073753555 "," ||@expr1073753556 second@var2728 .@expr11138 str (@expr11139 ) ==@expr1073753559 "," ) {
2797: arg_path_length@var2733 =@expr1073753560 path_length@var2730 ; }
2798: }
2799:
2800: return false ;
2801: }
2802:
2803: static bool isUnknownType ( const Token * start@var2744 , const Token * end@var2745 )
2804: {
2805: while (@expr1073753561 Token ::@expr11738 Match (@expr1073753563 start@var2744 , "const|volatile" ) ) {
2806: start@var2744 =@expr1073753564 start@var2744 .@expr1073753565 next (@expr1073753566 ) ; }
2807: start@var2744 =@expr1073753567 skipScopeIdentifiers (@expr1073753568 start@var2744 ) ;
2808: if (@expr1073753569 start@var2744 .@expr1073753570 tokAt (@expr1073753571 1 ) ==@expr1073753572 end@var2745 &&@expr1073753573 !@expr1073753574 start@var2744 .@expr1073753575 type (@expr1073753576 ) &&@expr1073753577 !@expr1073753578 start@var2744 .@expr1073753579 isStandardType (@expr1073753580 ) ) {
2809: return true ; }
2810:
2811: if (@expr1073753581 Token ::@expr11738 Match (@expr1073753583 start@var2744 , "decltype|typeof" ) ) {
2812: return true ; }
2813: return false ;
2814: }
2815:
2816: bool Function :: returnsConst ( const Function * function@var2746 , bool unknown@var2747 )
2817: {
2818: if (@expr1073753585 !@expr1073753586 function@var2746 ) {
2819: return false ; }
2820: if (@expr1073753587 function@var2746 .@expr1073753588 type@var2748 !=@expr1073753589 Function ::@expr1073753590 eFunction@expr1073753584 ) {
2821: return false ; }
2822: const Token * defEnd@var2749 ; defEnd@var2749 =@expr1073753591 function@var2746 .@expr1073753592 returnDefEnd (@expr1073753593 ) ;
2823: if (@expr1073753594 Token ::@expr1073753595 findsimplematch (@expr1073753596 function@var2746 .@expr11773 retDef@var2750 , "const" , defEnd@var2749 ) ) {
2824: return true ; }
2825:
2826: if (@expr1073753598 isUnknownType (@expr1073753599 function@var2746 .@expr11773 retDef@var2750 , defEnd@var2749 ) ) {
2827: return unknown@var2747 ; }
2828: return false ;
2829: }
2830:
2831: bool Function :: returnsReference ( const Function * function@var2751 , bool unknown@var2752 )
2832: {
2833: if (@expr1073753602 !@expr1073753603 function@var2751 ) {
2834: return false ; }
2835: if (@expr1073753604 function@var2751 .@expr1073753605 type@var2753 !=@expr1073753606 Function ::@expr1073753607 eFunction@expr1073753601 ) {
2836: return false ; }
2837: const Token * defEnd@var2754 ; defEnd@var2754 =@expr1073753608 function@var2751 .@expr1073753609 returnDefEnd (@expr1073753610 ) ;
2838: if (@expr1073753611 defEnd@var2754 .@expr1073753612 strAt (@expr1073753613 -1 ) ==@expr1073753614 "&" ) {
2839: return true ; }
2840:
2841: if (@expr1073753615 isUnknownType (@expr1073753616 function@var2751 .@expr1073753617 retDef@var2755 , defEnd@var2754 ) ) {
2842: return unknown@var2752 ; }
2843: return false ;
2844: }
2845:
2846: bool Function :: returnsVoid ( const Function * function@var2756 , bool unknown@var2757 )
2847: {
2848: if (@expr1073753618 !@expr1073753619 function@var2756 ) {
2849: return false ; }
2850: if (@expr1073753620 function@var2756 .@expr11797 type@var2758 !=@expr1073753622 Function ::@expr1073753623 eFunction &&@expr1073753624 function@var2756 .@expr11797 type@var2758 !=@expr1073753626 Function ::@expr1073753627 eOperatorEqual ) {
2851: return false ; }
2852: const Token * defEnd@var2759 ; defEnd@var2759 =@expr1073753628 function@var2756 .@expr1073753629 returnDefEnd (@expr1073753630 ) ;
2853: if (@expr1073753631 defEnd@var2759 .@expr1073753632 strAt (@expr1073753633 -1 ) ==@expr1073753634 "void" ) {
2854: return true ; }
2855:
2856: if (@expr1073753635 isUnknownType (@expr1073753636 function@var2756 .@expr11813 retDef@var2760 , defEnd@var2759 ) ) {
2857: return unknown@var2757 ; }
2858: if (@expr1073753638 unknown@var2757 ) {
2859:
2860: const Token * def@var2761 ;
2861: bool isVoid@var2762 ; isVoid@var2762 =@expr1073753639 false ;
2862: for (@expr1073753640 def@var2761 =@expr1073753641 function@var2756 .@expr11813 retDef@var2760 ; def@var2761 &&@expr1073753643 def@var2761 .@expr1073753644 isName (@expr1073753645 ) ; def@var2761 =@expr1073753646 def@var2761 .@expr1073753647 next (@expr1073753648 ) ) {
2863: isVoid@var2762 |=@expr1073753649 (@expr1073753650 def@var2761 .@expr1073753651 str (@expr1073753652 ) ==@expr1073753653 "void" ) ; }
2864: if (@expr1073753654 isVoid@var2762 &&@expr1073753655 def@var2761 &&@expr1073753656 !@expr1073753657 Token ::@expr1073753658 Match (@expr1073753659 def@var2761 , "*|&|&&" ) ) {
2865: return true ; }
2866: }
2867: return false ;
2868: }
2869:
2870: std :: vector < const Token * > Function :: findReturns ( const Function * f@var2763 )
2871: {
2872: std ::@expr1073753660 vector < const Token *@expr11837 > result@var2764 ;
2873: if (@expr1073753662 !@expr1073753663 f@var2763 ) {
2874: return result@var2764 ; }
2875: const Scope * scope@var2765 ; scope@var2765 =@expr1073753664 f@var2763 .@expr1073753665 functionScope@var2766 ;
2876: if (@expr1073753666 !@expr1073753667 scope@var2765 ) {
2877: return result@var2764 ; }
2878: for (@expr1073753668 const Token *@expr11837 tok@var2767 =@expr1073753670 scope@var2765 .@expr1073753671 bodyStart@var2768 .@expr1073753672 next (@expr1073753673 ) ; tok@var2767 &&@expr1073753674 tok@var2767 !=@expr1073753675 scope@var2765 .@expr1073753676 bodyEnd@var2769 ; tok@var2767 =@expr1073753677 tok@var2767 .@expr1073753678 next (@expr1073753679 ) ) {
2879: if (@expr1073753680 tok@var2767 .@expr1073753681 str (@expr1073753682 ) ==@expr1073753683 "{" &&@expr1073753684 tok@var2767 .@expr11861 scope (@expr11862 ) &&@expr1073753687
2880: (@expr1073753688 tok@var2767 .@expr11861 scope (@expr11862 ) .@expr11867 type@var3851 ==@expr1073753692 Scope ::@expr1073753693 eLambda ||@expr1073753694 tok@var2767 .@expr11861 scope (@expr11862 ) .@expr11867 type@var3851 ==@expr1073753698 Scope ::@expr1073753699 eClass ) ) {
2881: tok@var2767 =@expr1073753700 tok@var2767 .@expr1073753701 link (@expr1073753702 ) ;
2882: continue ;
2883: }
2884: if (@expr1073753703 Token ::@expr1073753704 simpleMatch (@expr1073753705 tok@var2767 .@expr1073753706 astParent (@expr1073753707 ) , "return" ) ) {
2885: result@var2764 .@expr1073753708 push_back (@expr1073753709 tok@var2767 ) ;
2886: }
2887:
2888: const Token * lambdaEndToken@var2770 ; lambdaEndToken@var2770 =@expr1073753710 findLambdaEndToken (@expr1073753711 tok@var2767 ) ;
2889: if (@expr1073753712 lambdaEndToken@var2770 ) {
2890: tok@var2767 =@expr1073753713 lambdaEndToken@var2770 ;
2891: }
2892: }
2893: return result@var2764 ;
2894: }
2895:
2896: const Token * Function :: constructorMemberInitialization ( ) const
2897: {
2898: if (@expr1073753714 !@expr1073753715 isConstructor (@expr1073753716 ) ||@expr1073753717 !@expr1073753718 arg@var1160 ) {
2899: return nullptr ; }
2900: if (@expr1073753719 Token ::@expr11896 simpleMatch (@expr1073753721 arg@var1160 .@expr11898 link (@expr11899 ) , ") :" ) ) {
2901: return arg@var1160 .@expr11898 link (@expr11899 ) .@expr1073753726 next (@expr1073753727 ) ; }
2902: if (@expr1073753728 Token ::@expr11896 simpleMatch (@expr1073753730 arg@var1160 .@expr11898 link (@expr11899 ) , ") noexcept (" ) &&@expr1073753733 arg@var1160 .@expr11898 link (@expr11899 ) .@expr11912 linkAt (@expr11913 2 ) .@expr1073753738 strAt (@expr1073753739 1 ) ==@expr1073753740 ":" ) {
2903: return arg@var1160 .@expr11898 link (@expr11899 ) .@expr11912 linkAt (@expr11913 2 ) .@expr1073753745 next (@expr1073753746 ) ; }
2904: return nullptr ;
2905: }
2906:
2907: bool Function :: isSafe ( const Settings * settings@var2771 ) const
2908: {
2909: if (@expr1073753748 settings@var2771 .@expr11925 safeChecks@var2772 .@expr1073753750 externalFunctions@var2773 ) {
2910: if (@expr1073753751 nestedIn@var1164 .@expr11928 type@var3805 ==@expr11929 Scope ::@expr11930 ScopeType ::@expr11931 eNamespace &&@expr1073753756 token@var1159 .@expr11933 fileIndex (@expr11934 ) !=@expr11935 0 ) {
2911: return true ; }
2912: if (@expr1073753760 nestedIn@var1164 .@expr11928 type@var3805 ==@expr11938 Scope ::@expr11930 ScopeType ::@expr11940 eGlobal &&@expr1073753765 (@expr1073753766 token@var1159 .@expr11933 fileIndex (@expr11934 ) !=@expr11935 0 ||@expr1073753770 !@expr1073753771 isStatic (@expr11948 ) ) ) {
2913: return true ; }
2914: }
2915:
2916: if (@expr1073753773 settings@var2771 .@expr11925 safeChecks@var2772 .@expr1073753775 internalFunctions@var2774 ) {
2917: if (@expr1073753776 nestedIn@var1164 .@expr11928 type@var3805 ==@expr11929 Scope ::@expr11930 ScopeType ::@expr11931 eNamespace &&@expr1073753781 token@var1159 .@expr11933 fileIndex (@expr11934 ) ==@expr11960 0 ) {
2918: return true ; }
2919: if (@expr1073753785 nestedIn@var1164 .@expr11928 type@var3805 ==@expr11938 Scope ::@expr11930 ScopeType ::@expr11940 eGlobal &&@expr1073753790 (@expr1073753791 token@var1159 .@expr11933 fileIndex (@expr11934 ) ==@expr11960 0 ||@expr1073753795 isStatic (@expr11948 ) ) ) {
2920: return true ; }
2921: }
2922:
2923: if (@expr1073753797 settings@var2771 .@expr11925 safeChecks@var2772 .@expr1073753799 classes@var2775 &&@expr1073753800 access@var1168 ==@expr1073753801 AccessControl ::@expr1073753802 Public@expr1073753747 &&@expr1073753803 (@expr1073753804 nestedIn@var1164 .@expr11928 type@var3805 ==@expr1073753806 Scope ::@expr11930 ScopeType ::@expr1073753808 eClass ||@expr1073753809 nestedIn@var1164 .@expr11928 type@var3805 ==@expr1073753811 Scope ::@expr11930 ScopeType ::@expr1073753813 eStruct ) ) {
2924: return true ; }
2925:
2926: return false ;
2927: }
2928:
2929: Function * SymbolDatabase :: addGlobalFunction ( Scope * & scope@var2776 , const Token * & tok@var2777 , const Token * argStart@var2778 , const Token * funcStart@var2779 )
2930: {
2931: Function * function@var2780 ; function@var2780 =@expr1073753814 nullptr ;
2932:
2933: if (@expr1073753815 tok@var2777 .@expr11992 str (@expr11993 ) !=@expr1073753818 "[" ) {
2934: for (@expr1073753819 std ::@expr11996 multimap < std ::@expr11996 string , const Function *@expr11998 > ::@expr11996 iterator i@var2781 =@expr1073753824 scope@var2776 .@expr12001 functionMap@var2782 .@expr1073753826 find (@expr1073753827 tok@var2777 .@expr11992 str (@expr11993 ) ) ; i@var2781 !=@expr1073753830 scope@var2776 .@expr12001 functionMap@var2782 .@expr1073753832 end (@expr1073753833 ) &&@expr1073753834 i@var2781 .@expr1073753835 first@var2783 ==@expr1073753836 tok@var2777 .@expr11992 str (@expr11993 ) ; ++@expr1073753839 i@var2781 ) {
2935: const Function * f@var2784 ; f@var2784 =@expr1073753840 i@var2781 .@expr12017 second@var2785 ;
2936: if (@expr1073753842 f@var2784 .@expr1073753843 hasBody (@expr1073753844 ) ) {
2937: continue ; }
2938: if (@expr1073753845 f@var2784 .@expr1073753846 argsMatch (@expr1073753847 scope@var2776 , f@var2784 .@expr1073753848 argDef@var2786 , argStart@var2778 , emptyString@var1 , 0 ) ) {
2939: function@var2780 =@expr1073753849 const_cast < Function *@expr11998 > (@expr1073753851 i@var2781 .@expr12017 second@var2785 ) ;
2940: break ;
2941: }
2942: }
2943: }
2944:
2945: if (@expr1073753853 !@expr1073753854 function@var2780 ) {
2946: function@var2780 =@expr1073753855 addGlobalFunctionDecl (@expr1073753856 scope@var2776 , tok@var2777 , argStart@var2778 , funcStart@var2779 ) ; }
2947:
2948: function@var2780 .@expr1073753857 arg@var2787 =@expr1073753858 argStart@var2778 ;
2949: function@var2780 .@expr1073753859 token@var2788 =@expr1073753860 funcStart@var2779 ;
2950: function@var2780 .@expr1073753861 hasBody (@expr1073753862 true ) ;
2951:
2952: addNewFunction (@expr1073753863 &@expr1073753864 scope@var2776 , &@expr1073753865 tok@var2777 ) ;
2953:
2954: if (@expr1073753866 scope@var2776 ) {
2955: scope@var2776 .@expr1073753867 function@var2789 =@expr1073753868 function@var2780 ;
2956: function@var2780 .@expr1073753869 functionScope@var2790 =@expr1073753870 scope@var2776 ;
2957: return function@var2780 ;
2958: }
2959: return nullptr ;
2960: }
2961:
2962: Function * SymbolDatabase :: addGlobalFunctionDecl ( Scope * & scope@var2791 , const Token * tok@var2792 , const Token * argStart@var2793 , const Token * funcStart@var2794 )
2963: {
2964: Function function@var2795 (@expr1073753871 mTokenizer@var1403 , tok@var2792 , scope@var2791 , funcStart@var2794 , argStart@var2793 ) ;
2965: scope@var2791 .@expr1073753872 addFunction (@expr1073753873 function@var2795 ) ;
2966: return &@expr1073753874 scope@var2791 .@expr1073753875 functionList@var2796 .@expr1073753876 back (@expr1073753877 ) ;
2967: }
2968:
2969: void SymbolDatabase :: addClassFunction ( Scope * * scope@var2797 , const Token * * tok@var2798 , const Token * argStart@var2799 )
2970: {
2971: const bool destructor@var2800 (@expr1073753879 (@expr12056 *@expr12057 tok@var2798 ) .@expr1073753882 previous (@expr1073753883 ) .@expr1073753884 str (@expr1073753885 ) ==@expr1073753886 "~" ) ;
2972: const bool has_const@var2801 (@expr1073753887 argStart@var2799 .@expr12064 link (@expr12065 ) .@expr12066 strAt (@expr1073753891 1 ) ==@expr1073753892 "const" ) ;
2973: const bool lval@var2802 (@expr1073753893 argStart@var2799 .@expr12064 link (@expr12065 ) .@expr12066 strAt (@expr12073 has_const@var2801 ?@expr12074 2 :@expr12075 1 ) ==@expr1073753900 "&" ) ;
2974: const bool rval@var2803 (@expr1073753901 argStart@var2799 .@expr12064 link (@expr12065 ) .@expr12066 strAt (@expr12073 has_const@var2801 ?@expr12074 2 :@expr12075 1 ) ==@expr1073753908 "&&" ) ;
2975: int count@var2804 ; count@var2804 =@expr1073753909 0 ;
2976: std ::@expr1073753910 string path@var2805 ;
2977: unsigned int path_length@var2806 ; path_length@var2806 =@expr1073753911 0 ;
2978: const Token * tok1@var2807 ; tok1@var2807 =@expr1073753912 *@expr12057 tok@var2798 ;
2979:
2980: if (@expr1073753914 destructor@var2800 ) {
2981: tok1@var2807 =@expr1073753915 tok1@var2807 .@expr12092 previous (@expr12093 ) ; }
2982:
2983:
2984: while (@expr1073753918 tok1@var2807 &&@expr1073753919 tok1@var2807 .@expr12092 previous (@expr12093 ) &&@expr1073753922 tok1@var2807 .@expr12092 previous (@expr12093 ) .@expr12101 str (@expr12102 ) ==@expr1073753927 "::" &&@expr1073753928 tok1@var2807 .@expr12105 tokAt (@expr12106 -2 ) &&@expr1073753931
2985: (@expr1073753932 (@expr1073753933 tok1@var2807 .@expr12105 tokAt (@expr12106 -2 ) .@expr1073753936 isName (@expr1073753937 ) &&@expr1073753938 !@expr1073753939 tok1@var2807 .@expr12105 tokAt (@expr12106 -2 ) .@expr1073753942 isStandardType (@expr1073753943 ) ) ||@expr1073753944
2986: (@expr1073753945 tok1@var2807 .@expr12122 strAt (@expr1073753947 -2 ) ==@expr1073753948 ">" &&@expr1073753949 tok1@var2807 .@expr12126 linkAt (@expr12127 -2 ) &&@expr1073753952 Token ::@expr1073753953 Match (@expr1073753954 tok1@var2807 .@expr12126 linkAt (@expr12127 -2 ) .@expr1073753957 previous (@expr1073753958 ) , "%name%" ) ) ) ) {
2987: count@var2804 ++@expr1073753959 ;
2988: const Token * tok2@var2808 ; tok2@var2808 =@expr1073753960 tok1@var2807 .@expr12105 tokAt (@expr12106 -2 ) ;
2989: if (@expr1073753963 tok2@var2808 .@expr1073753964 str (@expr1073753965 ) ==@expr1073753966 ">" ) {
2990: tok2@var2808 =@expr1073753967 tok2@var2808 .@expr1073753968 link (@expr1073753969 ) .@expr1073753970 previous (@expr1073753971 ) ; }
2991:
2992: if (@expr1073753972 tok2@var2808 ) {
2993: do {
2994: path@var2805 =@expr1073753973 tok1@var2807 .@expr12092 previous (@expr12093 ) .@expr12101 str (@expr12102 ) +@expr1073753978 " " +@expr1073753979 path@var2805 ;
2995: tok1@var2807 =@expr1073753980 tok1@var2807 .@expr12092 previous (@expr12093 ) ;
2996: path_length@var2806 ++@expr1073753983 ;
2997: } while (@expr1073753984 tok1@var2807 !=@expr1073753985 tok2@var2808 ) ;
2998: } else {
2999: return ; }
3000: }
3001:
3002:
3003: if (@expr1073753986 !@expr1073753987 tok1@var2807 ) {
3004: return ; }
3005:
3006:
3007: if (@expr1073753988 tok1@var2807 .@expr12122 strAt (@expr1073753990 -1 ) ==@expr1073753991 "::" ) {
3008: path_length@var2806 ++@expr1073753992 ;
3009: path@var2805 .@expr1073753993 insert (@expr1073753994 0 , ":: " ) ;
3010: }
3011:
3012: std ::@expr1073753995 list < Scope > ::@expr1073753996 iterator it1@var2809 ;
3013:
3014:
3015: for (@expr1073753997 it1@var2809 =@expr1073753998 scopeList@var1331 .@expr1073753999 begin (@expr1073754000 ) ; it1@var2809 !=@expr1073754001 scopeList@var1331 .@expr1073754002 end (@expr1073754003 ) ; ++@expr1073754004 it1@var2809 ) {
3016: Scope * scope1@var2810 ; scope1@var2810 =@expr1073754005 &@expr1073754006 (@expr1073754007 *@expr1073754008 it1@var2809 ) ;
3017:
3018: bool match@var2811 ; match@var2811 =@expr1073754009 false ;
3019:
3020:
3021: if (@expr1073754010 *@expr12187 scope@var2797 ==@expr1073754012 scope1@var2810 &&@expr1073754013 !@expr1073754014 scope1@var2810 .@expr12191 usingList@var2812 .@expr1073754016 empty (@expr1073754017 ) ) {
3022: std ::@expr1073754018 list < Scope ::@expr12195 UsingInfo > ::@expr1073754020 const_iterator it2@var2813 ;
3023: for (@expr1073754021 it2@var2813 =@expr1073754022 scope1@var2810 .@expr12191 usingList@var2812 .@expr1073754024 begin (@expr1073754025 ) ; it2@var2813 !=@expr1073754026 scope1@var2810 .@expr12191 usingList@var2812 .@expr1073754028 end (@expr1073754029 ) ; ++@expr1073754030 it2@var2813 ) {
3024: if (@expr1073754031 it2@var2813 .@expr12208 scope@var2814 ) {
3025: Function * func@var2815 ; func@var2815 =@expr1073754033 findFunctionInScope (@expr1073754034 tok1@var2807 , it2@var2813 .@expr12208 scope@var2814 , path@var2805 , path_length@var2806 ) ;
3026: if (@expr1073754036 func@var2815 ) {
3027: if (@expr1073754037 !@expr1073754038 func@var2815 .@expr12215 hasBody (@expr1073754040 ) ) {
3028: const Token * closeParen@var2816 ; closeParen@var2816 =@expr1073754041 (@expr12056 *@expr12057 tok@var2798 ) .@expr12220 next (@expr12221 ) .@expr12222 link (@expr12223 ) ;
3029: if (@expr1073754048 closeParen@var2816 ) {
3030: const Token * eq@var2817 ; eq@var2817 =@expr1073754049 mTokenizer@var1403 .@expr12226 isFunctionHead (@expr1073754051 closeParen@var2816 , ";" ) ;
3031: if (@expr1073754052 eq@var2817 &&@expr1073754053 Token ::@expr12230 simpleMatch (@expr1073754055 eq@var2817 .@expr1073754056 tokAt (@expr1073754057 -2 ) , "= default ;" ) ) {
3032: func@var2815 .@expr1073754058 isDefault (@expr1073754059 true ) ;
3033: return ;
3034: }
3035: }
3036: func@var2815 .@expr12215 hasBody (@expr1073754061 true ) ;
3037: func@var2815 .@expr1073754062 token@var2818 =@expr1073754063 *@expr12057 tok@var2798 ;
3038: func@var2815 .@expr1073754065 arg@var2819 =@expr1073754066 argStart@var2799 ;
3039: addNewFunction (@expr12243 scope@var2797 , tok@var2798 ) ;
3040: if (@expr12244 *@expr12187 scope@var2797 ) {
3041: (@expr12246 *@expr12187 scope@var2797 ) .@expr12248 functionOf@var2820 =@expr1073754073 func@var2815 .@expr1073754074 nestedIn@var2821 ;
3042: (@expr12246 *@expr12187 scope@var2797 ) .@expr12253 function@var2822 =@expr1073754078 func@var2815 ;
3043: (@expr12246 *@expr12187 scope@var2797 ) .@expr12253 function@var2822 .@expr12258 functionScope@var2823 =@expr1073754083 *@expr12187 scope@var2797 ;
3044: }
3045: return ;
3046: }
3047: }
3048: }
3049: }
3050: }
3051:
3052: if (@expr1073754085 scope1@var2810 .@expr1073754086 className@var2824 ==@expr1073754087 tok1@var2807 .@expr12264 str (@expr12265 ) &&@expr1073754090 (@expr1073754091 scope1@var2810 .@expr1073754092 type@var2825 !=@expr1073754093 Scope ::@expr1073754094 eFunction@expr1073753878 ) ) {
3053:
3054: if (@expr1073754095 (@expr1073754096 *@expr12187 scope@var2797 ==@expr1073754098 scope1@var2810 .@expr12275 nestedIn@var2826 ) ||@expr1073754100 (@expr1073754101 *@expr12187 scope@var2797 &&@expr1073754103
3055: (@expr12246 *@expr12187 scope@var2797 ) .@expr12282 className@var2827 ==@expr1073754107 scope1@var2810 .@expr12275 nestedIn@var2826 .@expr1073754109 className@var2828 &&@expr1073754110
3056: !@expr1073754111 (@expr12246 *@expr12187 scope@var2797 ) .@expr12282 className@var2827 .@expr1073754115 empty (@expr1073754116 ) &&@expr1073754117
3057: (@expr12246 *@expr12187 scope@var2797 ) .@expr1073754120 type@var2829 ==@expr1073754121 scope1@var2810 .@expr12275 nestedIn@var2826 .@expr1073754123 type@var2830 ) ) {
3058:
3059:
3060: {
3061: const Scope * s1@var2831 ; s1@var2831 =@expr1073754124 *@expr12187 scope@var2797 ;
3062: const Scope * s2@var2832 ; s2@var2832 =@expr1073754126 scope1@var2810 .@expr12275 nestedIn@var2826 ;
3063: while (@expr1073754128 s1@var2831 &&@expr1073754129 s2@var2832 ) {
3064: if (@expr1073754130 s1@var2831 .@expr1073754131 className@var2833 !=@expr1073754132 s2@var2832 .@expr1073754133 className@var2834 ) {
3065: break ; }
3066: s1@var2831 =@expr1073754134 s1@var2831 .@expr1073754135 nestedIn@var2835 ;
3067: s2@var2832 =@expr1073754136 s2@var2832 .@expr1073754137 nestedIn@var2836 ;
3068: }
3069:
3070: if (@expr1073754138 s1@var2831 ||@expr1073754139 s2@var2832 ) {
3071: continue ; }
3072: }
3073:
3074: Scope * scope2@var2837 ; scope2@var2837 =@expr1073754140 scope1@var2810 ;
3075:
3076: while (@expr1073754141 scope2@var2837 &&@expr1073754142 count@var2804 >@expr1073754143 1 ) {
3077: count@var2804 --@expr1073754144 ;
3078: if (@expr1073754145 tok1@var2807 .@expr12122 strAt (@expr1073754147 1 ) ==@expr1073754148 "<" ) {
3079: tok1@var2807 =@expr1073754149 tok1@var2807 .@expr12126 linkAt (@expr1073754151 1 ) .@expr1073754152 tokAt (@expr1073754153 2 ) ; }
3080: else {
3081: tok1@var2807 =@expr1073754154 tok1@var2807 .@expr12105 tokAt (@expr1073754156 2 ) ; }
3082: scope2@var2837 =@expr1073754157 scope2@var2837 .@expr1073754158 findRecordInNestedList (@expr1073754159 tok1@var2807 .@expr12264 str (@expr12265 ) ) ;
3083: }
3084:
3085: if (@expr1073754162 count@var2804 ==@expr1073754163 1 &&@expr1073754164 scope2@var2837 ) {
3086: match@var2811 =@expr1073754165 true ;
3087: scope1@var2810 =@expr1073754166 scope2@var2837 ;
3088: }
3089: }
3090: }
3091:
3092: if (@expr1073754167 match@var2811 ) {
3093: for (@expr1073754168 std ::@expr12195 multimap < std ::@expr12195 string , const Function *@expr12347 > ::@expr12195 iterator it@var2838 =@expr1073754173 scope1@var2810 .@expr12350 functionMap@var2839 .@expr1073754175 find (@expr1073754176 (@expr12056 *@expr12057 tok@var2798 ) .@expr12355 str (@expr12356 ) ) ; it@var2838 !=@expr1073754181 scope1@var2810 .@expr12350 functionMap@var2839 .@expr1073754183 end (@expr1073754184 ) &&@expr1073754185 it@var2838 .@expr1073754186 first@var2840 ==@expr1073754187 (@expr12056 *@expr12057 tok@var2798 ) .@expr12355 str (@expr12356 ) ; ++@expr1073754192 it@var2838 ) {
3094: Function * func@var2841 ; func@var2841 =@expr1073754193 const_cast < Function *@expr12347 > (@expr1073754195 it@var2838 .@expr1073754196 second@var2842 ) ;
3095: if (@expr1073754197 !@expr1073754198 func@var2841 .@expr12375 hasBody (@expr12376 ) ) {
3096: if (@expr1073754201 func@var2841 .@expr1073754202 argsMatch (@expr1073754203 scope1@var2810 , func@var2841 .@expr1073754204 argDef@var2843 , (@expr12056 *@expr12057 tok@var2798 ) .@expr12220 next (@expr12221 ) , path@var2805 , path_length@var2806 ) ) {
3097: if (@expr1073754209 func@var2841 .@expr12386 type@var2844 ==@expr1073754211 Function ::@expr12388 eDestructor &&@expr1073754213 destructor@var2800 ) {
3098: func@var2841 .@expr12375 hasBody (@expr12391 true ) ;
3099: } else { if (@expr1073754216 func@var2841 .@expr12386 type@var2844 !=@expr1073754218 Function ::@expr12388 eDestructor &&@expr1073754220 !@expr1073754221 destructor@var2800 ) {
3100:
3101: const Token * closeParen@var2845 ; closeParen@var2845 =@expr1073754222 (@expr12056 *@expr12057 tok@var2798 ) .@expr12220 next (@expr12221 ) .@expr12222 link (@expr12223 ) ;
3102: if (@expr1073754229 closeParen@var2845 ) {
3103: const Token * eq@var2846 ; eq@var2846 =@expr1073754230 mTokenizer@var1403 .@expr12226 isFunctionHead (@expr1073754232 closeParen@var2845 , ";" ) ;
3104: if (@expr1073754233 eq@var2846 &&@expr1073754234 Token ::@expr12230 simpleMatch (@expr1073754236 eq@var2846 .@expr1073754237 tokAt (@expr1073754238 -2 ) , "= default ;" ) ) {
3105: func@var2841 .@expr1073754239 isDefault (@expr1073754240 true ) ;
3106: return ;
3107: }
3108:
3109: const bool hasConstKeyword@var2847 =@expr1073754241 closeParen@var2845 .@expr1073754242 next (@expr1073754243 ) .@expr1073754244 str (@expr1073754245 ) ==@expr1073754246 "const" ;
3110: if (@expr1073754247 (@expr1073754248 func@var2841 .@expr1073754249 isConst (@expr1073754250 ) ==@expr1073754251 hasConstKeyword@var2847 ) &&@expr1073754252
3111: (@expr1073754253 func@var2841 .@expr1073754254 hasLvalRefQualifier (@expr1073754255 ) ==@expr1073754256 lval@var2802 ) &&@expr1073754257
3112: (@expr1073754258 func@var2841 .@expr1073754259 hasRvalRefQualifier (@expr1073754260 ) ==@expr1073754261 rval@var2803 ) ) {
3113: func@var2841 .@expr12375 hasBody (@expr12391 true ) ;
3114: }
3115: }
3116: } }
3117:
3118: if (@expr1073754264 func@var2841 .@expr12375 hasBody (@expr12376 ) ) {
3119: func@var2841 .@expr1073754267 token@var2848 =@expr1073754268 *@expr12057 tok@var2798 ;
3120: func@var2841 .@expr1073754270 arg@var2849 =@expr1073754271 argStart@var2799 ;
3121: addNewFunction (@expr12243 scope@var2797 , tok@var2798 ) ;
3122: if (@expr12244 *@expr12187 scope@var2797 ) {
3123: (@expr12246 *@expr12187 scope@var2797 ) .@expr12248 functionOf@var2820 =@expr1073754278 scope1@var2810 ;
3124: (@expr12246 *@expr12187 scope@var2797 ) .@expr12253 function@var2822 =@expr1073754282 func@var2841 ;
3125: (@expr12246 *@expr12187 scope@var2797 ) .@expr12253 function@var2822 .@expr12258 functionScope@var2823 =@expr1073754287 *@expr12187 scope@var2797 ;
3126: }
3127: return ;
3128: }
3129: }
3130: }
3131: }
3132: }
3133: }
3134:
3135:
3136: addNewFunction (@expr12243 scope@var2797 , tok@var2798 ) ;
3137: }
3138:
3139: void SymbolDatabase :: addNewFunction ( Scope * * scope@var2850 , const Token * * tok@var2851 )
3140: {
3141: const Token * tok1@var2852 ; tok1@var2852 =@expr1073754290 *@expr12467 tok@var2851 ;
3142: scopeList@var1331 .@expr1073754292 emplace_back (@expr1073754293 this@expr1073754294 , tok1@var2852 , *@expr12471 scope@var2850 ) ;
3143: Scope * newScope@var2853 ; newScope@var2853 =@expr1073754296 &@expr1073754297 scopeList@var1331 .@expr1073754298 back (@expr1073754299 ) ;
3144:
3145:
3146: bool foundInitList@var2854 ; foundInitList@var2854 =@expr1073754300 false ;
3147: while (@expr1073754301 tok1@var2852 &&@expr1073754302 tok1@var2852 .@expr12479 str (@expr12480 ) !=@expr1073754305 "{" &&@expr1073754306 tok1@var2852 .@expr12479 str (@expr12480 ) !=@expr1073754309 ";" ) {
3148: if (@expr1073754310 tok1@var2852 .@expr12487 link (@expr12488 ) &&@expr1073754313 Token ::@expr12490 Match (@expr1073754315 tok1@var2852 , "(|[|<" ) ) {
3149: tok1@var2852 =@expr1073754316 tok1@var2852 .@expr12487 link (@expr12488 ) ;
3150: } else { if (@expr1073754319 foundInitList@var2854 &&@expr1073754320 Token ::@expr12490 Match (@expr1073754322 tok1@var2852 , "%name%|> {" ) &&@expr1073754323 Token ::@expr12490 Match (@expr1073754325 tok1@var2852 .@expr12502 linkAt (@expr12503 1 ) , "} ,|{" ) ) {
3151: tok1@var2852 =@expr1073754328 tok1@var2852 .@expr12502 linkAt (@expr12503 1 ) ;
3152: } else {
3153: if (@expr1073754331 tok1@var2852 .@expr12479 str (@expr12480 ) ==@expr1073754334 ":" ) {
3154: foundInitList@var2854 =@expr1073754335 true ; }
3155: tok1@var2852 =@expr1073754336 tok1@var2852 .@expr12513 next (@expr12514 ) ;
3156: } }
3157: }
3158:
3159: if (@expr1073754339 tok1@var2852 &&@expr1073754340 tok1@var2852 .@expr12479 str (@expr12480 ) ==@expr1073754343 "{" ) {
3160: newScope@var2853 .@expr1073754344 setBodyStartEnd (@expr1073754345 tok1@var2852 ) ;
3161:
3162:
3163: if (@expr1073754346 !@expr1073754347 newScope@var2853 .@expr1073754348 bodyEnd@var2855 ) {
3164: scopeList@var1331 .@expr12525 pop_back (@expr12526 ) ;
3165: while (@expr1073754351 tok1@var2852 .@expr12513 next (@expr12514 ) ) {
3166: tok1@var2852 =@expr1073754354 tok1@var2852 .@expr12513 next (@expr12514 ) ; }
3167: *@expr12471 scope@var2850 =@expr1073754358 nullptr ;
3168: *@expr12467 tok@var2851 =@expr1073754360 tok1@var2852 ;
3169: return ;
3170: }
3171:
3172: (@expr1073754361 *@expr12471 scope@var2850 ) .@expr1073754363 nestedList@var2856 .@expr1073754364 push_back (@expr1073754365 newScope@var2853 ) ;
3173: *@expr12471 scope@var2850 =@expr1073754367 newScope@var2853 ;
3174: *@expr12467 tok@var2851 =@expr1073754369 tok1@var2852 ;
3175: } else {
3176: scopeList@var1331 .@expr12525 pop_back (@expr12526 ) ;
3177: *@expr12471 scope@var2850 =@expr1073754373 nullptr ;
3178: *@expr12467 tok@var2851 =@expr1073754375 nullptr ;
3179: }
3180: }
3181:
3182: bool Type :: isClassType ( ) const
3183: {
3184: return classScope@var1061 &&@expr1073754376 classScope@var1061 .@expr1073754377 type@var3797 ==@expr1073754378 Scope ::@expr1073754379 ScopeType ::@expr1073754380 eClass ;
3185: }
3186:
3187: bool Type :: isEnumType ( ) const
3188: {
3189:
3190: return (@expr12557 classDef@var1060 &&@expr1073754382 classDef@var1060 .@expr1073754383 str (@expr1073754384 ) ==@expr1073754385 "enum" ) ||@expr1073754386
3191: (@expr12557 classScope@var1061 &&@expr1073754388 classScope@var1061 .@expr1073754389 type@var3797 ==@expr1073754390 Scope ::@expr1073754391 ScopeType ::@expr1073754392 eEnum ) ;
3192: }
3193:
3194: bool Type :: isStructType ( ) const
3195: {
3196: return classScope@var1061 &&@expr1073754393 classScope@var1061 .@expr1073754394 type@var3797 ==@expr1073754395 Scope ::@expr1073754396 ScopeType ::@expr1073754397 eStruct ;
3197: }
3198:
3199: bool Type :: isUnionType ( ) const
3200: {
3201: return classScope@var1061 &&@expr1073754398 classScope@var1061 .@expr1073754399 type@var3797 ==@expr1073754400 Scope ::@expr1073754401 ScopeType ::@expr1073754402 eUnion ;
3202: }
3203:
3204: const Token * Type :: initBaseInfo ( const Token * tok@var2857 , const Token * tok1@var2858 )
3205: {
3206:
3207: const Token * tok2@var2859 ; tok2@var2859 =@expr1073754404 tok1@var2858 ;
3208: while (@expr1073754405 tok2@var2859 &&@expr1073754406 tok2@var2859 .@expr12583 str (@expr12584 ) !=@expr1073754409 "{" ) {
3209:
3210: if (@expr1073754410 tok2@var2859 .@expr12583 str (@expr12584 ) ==@expr12589 "<" ) {
3211: tok2@var2859 =@expr1073754414 tok2@var2859 .@expr12591 link (@expr12592 ) ; }
3212:
3213:
3214: else { if (@expr1073754417 Token ::@expr12594 Match (@expr1073754419 tok2@var2859 , ":|," ) ) {
3215: tok2@var2859 =@expr1073754420 tok2@var2859 .@expr12597 next (@expr12598 ) ;
3216:
3217:
3218: if (@expr1073754423 !@expr12600 tok2@var2859 ||@expr1073754425 !@expr1073754426 tok2@var2859 .@expr12597 next (@expr12598 ) ) {
3219: return nullptr ; }
3220:
3221: Type ::@expr1073754429 BaseInfo base@var2860 ;
3222:
3223: if (@expr12606 tok2@var2859 .@expr12583 str (@expr12584 ) ==@expr12609 "virtual" ) {
3224: base@var2860 .@expr12610 isVirtual@var2861 =@expr1073754435 true ;
3225: tok2@var2859 =@expr1073754436 tok2@var2859 .@expr12597 next (@expr12598 ) ;
3226: }
3227:
3228: if (@expr1073754439 tok2@var2859 .@expr12583 str (@expr12584 ) ==@expr1073754442 "public" ) {
3229: base@var2860 .@expr12619 access@var2862 =@expr1073754444 AccessControl ::@expr12621 Public@expr12579 ;
3230: tok2@var2859 =@expr1073754446 tok2@var2859 .@expr12597 next (@expr12598 ) ;
3231: } else { if (@expr1073754449 tok2@var2859 .@expr12583 str (@expr12584 ) ==@expr1073754452 "protected" ) {
3232: base@var2860 .@expr12619 access@var2862 =@expr1073754454 AccessControl ::@expr1073754455 Protected ;
3233: tok2@var2859 =@expr1073754456 tok2@var2859 .@expr12597 next (@expr12598 ) ;
3234: } else { if (@expr1073754459 tok2@var2859 .@expr12583 str (@expr12584 ) ==@expr1073754462 "private" ) {
3235: base@var2860 .@expr12619 access@var2862 =@expr1073754464 AccessControl ::@expr12641 Private ;
3236: tok2@var2859 =@expr1073754466 tok2@var2859 .@expr12597 next (@expr12598 ) ;
3237: } else {
3238: if (@expr1073754469 tok@var2857 .@expr12646 str (@expr12647 ) ==@expr1073754472 "class" ) {
3239: base@var2860 .@expr12619 access@var2862 =@expr1073754474 AccessControl ::@expr12641 Private ; }
3240: else { if (@expr1073754476 tok@var2857 .@expr12646 str (@expr12647 ) ==@expr1073754479 "struct" ) {
3241: base@var2860 .@expr12619 access@var2862 =@expr1073754481 AccessControl ::@expr12621 Public@expr12579 ; } }
3242: } } }
3243: if (@expr12659 !@expr12600 tok2@var2859 ) {
3244: return nullptr ; }
3245: if (@expr12606 tok2@var2859 .@expr12583 str (@expr12584 ) ==@expr12609 "virtual" ) {
3246: base@var2860 .@expr12610 isVirtual@var2861 =@expr1073754490 true ;
3247: tok2@var2859 =@expr1073754491 tok2@var2859 .@expr12597 next (@expr12598 ) ;
3248: }
3249: if (@expr12659 !@expr12600 tok2@var2859 ) {
3250: return nullptr ; }
3251:
3252: base@var2860 .@expr12672 nameTok@var2863 =@expr1073754497 tok2@var2859 ;
3253:
3254: if (@expr1073754498 tok2@var2859 .@expr12583 str (@expr12584 ) ==@expr1073754501 "::" ) {
3255: tok2@var2859 =@expr1073754502 tok2@var2859 .@expr12597 next (@expr12598 ) ;
3256: }
3257:
3258:
3259: while (@expr1073754505 Token ::@expr12594 Match (@expr1073754507 tok2@var2859 , "%name% ::" ) ) {
3260: tok2@var2859 =@expr1073754508 tok2@var2859 .@expr1073754509 tokAt (@expr1073754510 2 ) ;
3261: }
3262: if (@expr12659 !@expr12600 tok2@var2859 ) {
3263: return nullptr ; }
3264:
3265: base@var2860 .@expr12689 name@var2864 =@expr1073754514 tok2@var2859 .@expr12583 str (@expr12584 ) ;
3266:
3267: tok2@var2859 =@expr1073754517 tok2@var2859 .@expr12597 next (@expr12598 ) ;
3268:
3269: if (@expr1073754520 tok2@var2859 &&@expr1073754521 tok2@var2859 .@expr12591 link (@expr12592 ) &&@expr1073754524 tok2@var2859 .@expr12583 str (@expr12584 ) ==@expr12589 "<" ) {
3270: for (@expr1073754528 const Token *@expr1073754529 const end@var2865 =@expr1073754530 tok2@var2859 .@expr12591 link (@expr12592 ) .@expr1073754533 next (@expr1073754534 ) ; tok2@var2859 !=@expr1073754535 end@var2865 ; tok2@var2859 =@expr1073754536 tok2@var2859 .@expr12597 next (@expr12598 ) ) {
3271: base@var2860 .@expr12689 name@var2864 +=@expr1073754540 tok2@var2859 .@expr12583 str (@expr12584 ) ;
3272: }
3273: }
3274:
3275: const Type * baseType@var2866 ; baseType@var2866 =@expr1073754543 classScope@var1061 .@expr1073754544 check@var3798 .@expr1073754545 findType (@expr1073754546 base@var2860 .@expr12672 nameTok@var2863 , enclosingScope@var1062 ) ;
3276: if (@expr1073754548 baseType@var2866 &&@expr1073754549 !@expr1073754550 baseType@var2866 .@expr1073754551 findDependency (@expr1073754552 this@expr1073754553 ) ) {
3277: base@var2860 .@expr1073754554 type@var2867 =@expr1073754555 baseType@var2866 ; }
3278:
3279:
3280: derivedFrom@var1074 .@expr1073754556 push_back (@expr1073754557 base@var2860 ) ;
3281: } else {
3282: tok2@var2859 =@expr1073754558 tok2@var2859 .@expr12597 next (@expr12598 ) ; } }
3283: }
3284:
3285: return tok2@var2859 ;
3286: }
3287:
3288: const std :: string & Type :: name ( ) const
3289: {
3290: const Token * next@var2868 ; next@var2868 =@expr1073754561 classDef@var1060 .@expr1073754562 next (@expr1073754563 ) ;
3291: if (@expr1073754564 classScope@var1061 &&@expr1073754565 classScope@var1061 .@expr1073754566 enumClass@var3799 &&@expr1073754567 isEnumType (@expr1073754568 ) ) {
3292: return next@var2868 .@expr12745 strAt (@expr12746 1 ) ; }
3293: else { if (@expr1073754571 next@var2868 .@expr12748 str (@expr12749 ) ==@expr1073754574 "class" ) {
3294: return next@var2868 .@expr12745 strAt (@expr12746 1 ) ; }
3295: else { if (@expr1073754577 next@var2868 .@expr1073754578 isName (@expr1073754579 ) ) {
3296: return next@var2868 .@expr12748 str (@expr12749 ) ; } } }
3297: return emptyString@var1 ;
3298: }
3299:
3300: void SymbolDatabase :: debugMessage ( const Token * tok@var2869 , const std :: string & type@var2870 , const std :: string & msg@var2871 ) const
3301: {
3302: if (@expr1073754582 tok@var2869 &&@expr1073754583 mSettings@var1404 .@expr1073754584 debugwarnings@var3821 ) {
3303: const std ::@expr1073754585 list < const Token *@expr1073754586 > locationList@var2872 (@expr1073754587 1 , tok@var2869 ) ;
3304: const ErrorMessage errmsg@var2873 (@expr1073754588 locationList@var2872 , &@expr1073754589 mTokenizer@var1403 .@expr1073754590 list@var3820 ,
3305: Severity ::@expr1073754591 debug ,
3306: type@var2870 ,
3307: msg@var2871 ,
3308: Certainty ::@expr1073754592 normal ) ;
3309: if (@expr1073754593 mErrorLogger@var1405 ) {
3310: mErrorLogger@var1405 .@expr1073754594 reportErr (@expr1073754595 errmsg@var2873 ) ; }
3311: }
3312: }
3313:
3314: const Function * Type :: getFunction ( const std :: string & funcName@var2874 ) const
3315: {
3316: if (@expr1073754596 classScope@var1061 ) {
3317: const std ::@expr1073754597 multimap < std ::@expr12774 string , const Function *@expr1073754599 > ::@expr1073754600 const_iterator it@var2875 =@expr1073754601 classScope@var1061 .@expr12778 functionMap@var3800 .@expr1073754603 find (@expr1073754604 funcName@var2874 ) ;
3318:
3319: if (@expr1073754605 it@var2875 !=@expr1073754606 classScope@var1061 .@expr12778 functionMap@var3800 .@expr1073754608 end (@expr1073754609 ) ) {
3320: return it@var2875 .@expr1073754610 second@var2876 ; }
3321: }
3322:
3323: for (@expr1073754611 const Type ::@expr12774 BaseInfo &@expr1073754613 i@var2877 :@expr1073754614 derivedFrom@var1074 ) {
3324: if (@expr1073754615 i@var2877 .@expr12792 type@var2878 ) {
3325: const Function * const func@var2879 ; func@var2879 =@expr1073754617 i@var2877 .@expr12792 type@var2878 .@expr1073754619 getFunction (@expr1073754620 funcName@var2874 ) ;
3326: if (@expr1073754621 func@var2879 ) {
3327: return func@var2879 ; }
3328: }
3329: }
3330: return nullptr ;
3331: }
3332:
3333: bool Type :: hasCircularDependencies ( std :: set < BaseInfo > * ancestors@var2880 ) const
3334: {
3335: std ::@expr1073754622 set < BaseInfo > knownAncestors@var2881 ;
3336: if (@expr1073754623 !@expr1073754624 ancestors@var2880 ) {
3337: ancestors@var2880 =@expr1073754625 &@expr1073754626 knownAncestors@var2881 ;
3338: }
3339: for (@expr1073754627 std ::@expr12804 vector < BaseInfo > ::@expr12804 const_iterator parent@var2882 =@expr1073754630 derivedFrom@var1074 .@expr1073754631 begin (@expr1073754632 ) ; parent@var2882 !=@expr1073754633 derivedFrom@var1074 .@expr1073754634 end (@expr1073754635 ) ; ++@expr1073754636 parent@var2882 ) {
3340: if (@expr1073754637 !@expr1073754638 parent@var2882 .@expr12815 type@var2883 ) {
3341: continue ; }
3342: else { if (@expr1073754640 this@expr1073754641 ==@expr1073754642 parent@var2882 .@expr12815 type@var2883 ) {
3343: return true ; }
3344: else { if (@expr1073754644 ancestors@var2880 .@expr1073754645 find (@expr1073754646 *@expr12823 parent@var2882 ) !=@expr1073754648 ancestors@var2880 .@expr1073754649 end (@expr1073754650 ) ) {
3345: return true ; }
3346: else {
3347: ancestors@var2880 .@expr1073754651 insert (@expr1073754652 *@expr12823 parent@var2882 ) ;
3348: if (@expr1073754654 parent@var2882 .@expr12815 type@var2883 .@expr1073754656 hasCircularDependencies (@expr1073754657 ancestors@var2880 ) ) {
3349: return true ; }
3350: } } }
3351: }
3352: return false ;
3353: }
3354:
3355: bool Type :: findDependency ( const Type * ancestor@var2884 ) const
3356: {
3357: if (@expr1073754658 this@expr12835 ==@expr1073754660 ancestor@var2884 ) {
3358: return true ; }
3359: for (@expr1073754661 std ::@expr12838 vector < BaseInfo > ::@expr12838 const_iterator parent@var2885 =@expr1073754664 derivedFrom@var1074 .@expr1073754665 begin (@expr1073754666 ) ; parent@var2885 !=@expr1073754667 derivedFrom@var1074 .@expr1073754668 end (@expr1073754669 ) ; ++@expr1073754670 parent@var2885 ) {
3360: if (@expr1073754671 parent@var2885 .@expr12848 type@var2886 &&@expr1073754673 (@expr1073754674 parent@var2885 .@expr12848 type@var2886 ==@expr1073754676 this@expr12835 ||@expr1073754677 parent@var2885 .@expr12848 type@var2886 .@expr1073754679 findDependency (@expr1073754680 ancestor@var2884 ) ) ) {
3361: return true ; }
3362: }
3363: return false ;
3364: }
3365:
3366: bool Type :: isDerivedFrom ( const std :: string & ancestor@var2887 ) const
3367: {
3368: for (@expr1073754681 std ::@expr12858 vector < BaseInfo > ::@expr12858 const_iterator parent@var2888 =@expr1073754684 derivedFrom@var1074 .@expr1073754685 begin (@expr1073754686 ) ; parent@var2888 !=@expr1073754687 derivedFrom@var1074 .@expr1073754688 end (@expr1073754689 ) ; ++@expr1073754690 parent@var2888 ) {
3369: if (@expr1073754691 parent@var2888 .@expr1073754692 name@var2889 ==@expr1073754693 ancestor@var2887 ) {
3370: return true ; }
3371: if (@expr1073754694 parent@var2888 .@expr12871 type@var2890 &&@expr1073754696 parent@var2888 .@expr12871 type@var2890 .@expr1073754698 isDerivedFrom (@expr1073754699 ancestor@var2887 ) ) {
3372: return true ; }
3373: }
3374: return false ;
3375: }
3376:
3377: bool Variable :: arrayDimensions ( const Settings * settings@var2891 , bool * isContainer@var2892 )
3378: {
3379: *@expr12876 isContainer@var2892 =@expr1073754701 false ;
3380: const Library ::@expr1073754702 Container * container@var2893 ; container@var2893 =@expr1073754703 settings@var2891 .@expr1073754704 library@var2894 .@expr1073754705 detectContainer (@expr1073754706 mTypeStartToken@var1127 ) ;
3381: if (@expr1073754707 container@var2893 &&@expr1073754708 container@var2893 .@expr1073754709 arrayLike_indexOp@var2895 &&@expr1073754710 container@var2893 .@expr12887 size_templateArgNo@var2896 >@expr1073754712 0 ) {
3382: const Token * tok@var2897 ; tok@var2897 =@expr1073754713 Token ::@expr1073754714 findsimplematch (@expr1073754715 mTypeStartToken@var1127 , "<" ) ;
3383: if (@expr12892 tok@var2897 ) {
3384: *@expr12876 isContainer@var2892 =@expr1073754718 true ;
3385: Dimension dimension_@var2898 ;
3386: tok@var2897 =@expr1073754719 tok@var2897 .@expr1073754720 next (@expr1073754721 ) ;
3387: for (@expr1073754722 int i@var2899 =@expr1073754723 0 ; i@var2899 <@expr1073754724 container@var2893 .@expr12887 size_templateArgNo@var2896 &&@expr1073754726 tok@var2897 ; i@var2899 ++@expr1073754727 ) {
3388: tok@var2897 =@expr1073754728 tok@var2897 .@expr1073754729 nextTemplateArgument (@expr1073754730 ) ;
3389: }
3390: if (@expr1073754731 Token ::@expr1073754732 Match (@expr1073754733 tok@var2897 , "%num% [,>]" ) ) {
3391: dimension_@var2898 .@expr12910 tok@var2900 =@expr1073754735 tok@var2897 ;
3392: dimension_@var2898 .@expr12912 known@var2901 =@expr1073754737 true ;
3393: dimension_@var2898 .@expr1073754738 num@var2902 =@expr1073754739 MathLib ::@expr1073754740 toLongNumber (@expr1073754741 tok@var2897 .@expr1073754742 str (@expr1073754743 ) ) ;
3394: } else { if (@expr12892 tok@var2897 ) {
3395: dimension_@var2898 .@expr12910 tok@var2900 =@expr1073754746 tok@var2897 ;
3396: dimension_@var2898 .@expr12912 known@var2901 =@expr1073754748 false ;
3397: } }
3398: mDimensions@var1135 .@expr12925 push_back (@expr1073754750 dimension_@var2898 ) ;
3399: return true ;
3400: }
3401: }
3402:
3403: const Token * dim@var2903 ; dim@var2903 =@expr1073754751 mNameToken@var1126 ;
3404: if (@expr1073754752 !@expr1073754753 dim@var2903 ) {
3405:
3406: dim@var2903 =@expr1073754754 mTypeEndToken@var1128 ;
3407:
3408: while (@expr1073754755 dim@var2903 &&@expr1073754756 dim@var2903 .@expr12933 str (@expr12934 ) ==@expr1073754759 "]" ) {
3409: dim@var2903 =@expr1073754760 dim@var2903 .@expr12937 link (@expr12938 ) .@expr1073754763 previous (@expr1073754764 ) ; }
3410: }
3411: if (@expr1073754765 dim@var2903 ) {
3412: dim@var2903 =@expr1073754766 dim@var2903 .@expr12943 next (@expr12944 ) ; }
3413: if (@expr1073754769 dim@var2903 &&@expr1073754770 dim@var2903 .@expr12933 str (@expr12934 ) ==@expr1073754773 ")" ) {
3414: dim@var2903 =@expr1073754774 dim@var2903 .@expr12943 next (@expr12944 ) ; }
3415:
3416: bool arr@var2904 ; arr@var2904 =@expr1073754777 false ;
3417: while (@expr1073754778 dim@var2903 &&@expr1073754779 dim@var2903 .@expr12943 next (@expr12944 ) &&@expr1073754782 dim@var2903 .@expr12933 str (@expr12934 ) ==@expr1073754785 "[" ) {
3418: Dimension dimension_@var2905 ;
3419: dimension_@var2905 .@expr12962 known@var2906 =@expr1073754787 false ;
3420:
3421: if (@expr1073754788 dim@var2903 .@expr12943 next (@expr12944 ) .@expr1073754791 str (@expr1073754792 ) !=@expr1073754793 "]" ) {
3422: dimension_@var2905 .@expr12970 tok@var2907 =@expr1073754795 dim@var2903 .@expr1073754796 astOperand2 (@expr1073754797 ) ;
3423: ValueFlow ::@expr1073754798 valueFlowConstantFoldAST (@expr1073754799 const_cast < Token *@expr1073754800 > (@expr1073754801 dimension_@var2905 .@expr12970 tok@var2907 ) , settings@var2891 ) ;
3424: if (@expr1073754803 dimension_@var2905 .@expr12970 tok@var2907 &&@expr1073754805 dimension_@var2905 .@expr12970 tok@var2907 .@expr1073754807 hasKnownIntValue (@expr1073754808 ) ) {
3425: dimension_@var2905 .@expr1073754809 num@var2908 =@expr1073754810 dimension_@var2905 .@expr12970 tok@var2907 .@expr1073754812 getKnownIntValue (@expr1073754813 ) ;
3426: dimension_@var2905 .@expr12962 known@var2906 =@expr1073754815 true ;
3427: }
3428: }
3429: mDimensions@var1135 .@expr12925 push_back (@expr1073754817 dimension_@var2905 ) ;
3430: dim@var2903 =@expr1073754818 dim@var2903 .@expr12937 link (@expr12938 ) .@expr1073754821 next (@expr1073754822 ) ;
3431: arr@var2904 =@expr1073754823 true ;
3432: }
3433: return arr@var2904 ;
3434: }
3435:
3436: static std :: ostream & operator<< ( std :: ostream & s@var2909 , Scope :: ScopeType type@var2910 )
3437: {
3438: s@var2909 <<@expr1073754825 (@expr1073754826 type@var2910 ==@expr1073754827 Scope ::@expr1073754828 eGlobal ?@expr1073754829 "Global" :@expr1073754830
3439: type@var2910 ==@expr1073754831 Scope ::@expr1073754832 eClass ?@expr1073754833 "Class" :@expr1073754834
3440: type@var2910 ==@expr1073754835 Scope ::@expr1073754836 eStruct ?@expr1073754837 "Struct" :@expr1073754838
3441: type@var2910 ==@expr1073754839 Scope ::@expr1073754840 eUnion ?@expr1073754841 "Union" :@expr1073754842
3442: type@var2910 ==@expr1073754843 Scope ::@expr1073754844 eNamespace ?@expr1073754845 "Namespace" :@expr1073754846
3443: type@var2910 ==@expr1073754847 Scope ::@expr1073754848 eFunction@expr1073754824 ?@expr1073754849 "Function" :@expr1073754850
3444: type@var2910 ==@expr1073754851 Scope ::@expr1073754852 eIf ?@expr1073754853 "If" :@expr1073754854
3445: type@var2910 ==@expr1073754855 Scope ::@expr1073754856 eElse ?@expr1073754857 "Else" :@expr1073754858
3446: type@var2910 ==@expr1073754859 Scope ::@expr1073754860 eFor ?@expr1073754861 "For" :@expr1073754862
3447: type@var2910 ==@expr1073754863 Scope ::@expr1073754864 eWhile ?@expr1073754865 "While" :@expr1073754866
3448: type@var2910 ==@expr1073754867 Scope ::@expr1073754868 eDo ?@expr1073754869 "Do" :@expr1073754870
3449: type@var2910 ==@expr1073754871 Scope ::@expr1073754872 eSwitch ?@expr1073754873 "Switch" :@expr1073754874
3450: type@var2910 ==@expr1073754875 Scope ::@expr1073754876 eTry ?@expr1073754877 "Try" :@expr1073754878
3451: type@var2910 ==@expr1073754879 Scope ::@expr1073754880 eCatch ?@expr1073754881 "Catch" :@expr1073754882
3452: type@var2910 ==@expr1073754883 Scope ::@expr1073754884 eUnconditional ?@expr1073754885 "Unconditional" :@expr1073754886
3453: type@var2910 ==@expr1073754887 Scope ::@expr1073754888 eLambda ?@expr1073754889 "Lambda" :@expr1073754890
3454: type@var2910 ==@expr1073754891 Scope ::@expr1073754892 eEnum ?@expr1073754893 "Enum" :@expr1073754894
3455: "Unknown" ) ;
3456: return s@var2909 ;
3457: }
3458:
3459: static std :: string accessControlToString ( const AccessControl & access@var2911 )
3460: {
3461: switch (@expr1073754895 access@var2911 ) {
3462: case AccessControl ::@expr1073754896 Public :@expr13073 ;
3463: return "Public" ;
3464: case AccessControl ::@expr1073754898 Protected :@expr13073 ;
3465: return "Protected" ;
3466: case AccessControl ::@expr1073754900 Private :@expr13073 ;
3467: return "Private" ;
3468: case AccessControl ::@expr1073754902 Global :@expr13073 ;
3469: return "Global" ;
3470: case AccessControl ::@expr1073754904 Namespace :@expr13073 ;
3471: return "Namespace" ;
3472: case AccessControl ::@expr1073754906 Argument :@expr13073 ;
3473: return "Argument" ;
3474: case AccessControl ::@expr1073754908 Local :@expr13073 ;
3475: return "Local" ;
3476: case AccessControl ::@expr1073754910 Throw :@expr13073 ;
3477: return "Throw" ;
3478: }
3479: return "Unknown" ;
3480: }
3481:
3482: static std :: string tokenToString ( const Token * tok@var2912 , const Tokenizer * tokenizer@var2913 )
3483: {
3484: std ::@expr1073754912 ostringstream oss@var2914 ;
3485: if (@expr1073754913 tok@var2912 ) {
3486: oss@var2914 <<@expr1073754914 tok@var2912 .@expr1073754915 str (@expr1073754916 ) <<@expr1073754917 " " ;
3487: oss@var2914 <<@expr1073754918 tokenizer@var2913 .@expr1073754919 list@var2915 .@expr1073754920 fileLine (@expr1073754921 tok@var2912 ) <<@expr1073754922 " " ;
3488: }
3489: oss@var2914 <<@expr1073754923 tok@var2912 ;
3490: return oss@var2914 .@expr1073754924 str (@expr1073754925 ) ;
3491: }
3492:
3493: static std :: string scopeToString ( const Scope * scope@var2916 , const Tokenizer * tokenizer@var2917 )
3494: {
3495: std ::@expr1073754926 ostringstream oss@var2918 ;
3496: if (@expr1073754927 scope@var2916 ) {
3497: oss@var2918 <<@expr1073754928 scope@var2916 .@expr1073754929 type@var2919 <<@expr1073754930 " " ;
3498: if (@expr1073754931 !@expr1073754932 scope@var2916 .@expr13109 className@var2920 .@expr1073754934 empty (@expr1073754935 ) ) {
3499: oss@var2918 <<@expr1073754936 scope@var2916 .@expr13109 className@var2920 <<@expr1073754938 " " ; }
3500: if (@expr1073754939 scope@var2916 .@expr13116 classDef@var2921 ) {
3501: oss@var2918 <<@expr1073754941 tokenizer@var2917 .@expr1073754942 list@var2922 .@expr1073754943 fileLine (@expr1073754944 scope@var2916 .@expr13116 classDef@var2921 ) <<@expr1073754946 " " ; }
3502: }
3503: oss@var2918 <<@expr1073754947 scope@var2916 ;
3504: return oss@var2918 .@expr1073754948 str (@expr1073754949 ) ;
3505: }
3506:
3507: static std :: string tokenType ( const Token * tok@var2923 )
3508: {
3509: std ::@expr1073754950 ostringstream oss@var2924 ;
3510: if (@expr1073754951 tok@var2923 ) {
3511: if (@expr1073754952 tok@var2923 .@expr1073754953 isUnsigned (@expr1073754954 ) ) {
3512: oss@var2924 <<@expr1073754955 "unsigned " ; }
3513: else { if (@expr1073754956 tok@var2923 .@expr1073754957 isSigned (@expr1073754958 ) ) {
3514: oss@var2924 <<@expr1073754959 "signed " ; } }
3515: if (@expr1073754960 tok@var2923 .@expr1073754961 isComplex (@expr1073754962 ) ) {
3516: oss@var2924 <<@expr1073754963 "_Complex " ; }
3517: if (@expr1073754964 tok@var2923 .@expr1073754965 isLong (@expr1073754966 ) ) {
3518: oss@var2924 <<@expr1073754967 "long " ; }
3519: oss@var2924 <<@expr1073754968 tok@var2923 .@expr1073754969 str (@expr1073754970 ) ;
3520: }
3521: return oss@var2924 .@expr1073754971 str (@expr1073754972 ) ;
3522: }
3523:
3524: void SymbolDatabase :: printVariable ( const Variable * var@var2925 , const char * indent@var2926 ) const
3525: {
3526: std ::@expr13152 cout@expr13149 <<@expr13153 indent@var2926 <<@expr1073754978 "mNameToken: " <<@expr1073754979 tokenToString (@expr1073754980 var@var2925 .@expr13157 nameToken (@expr13158 ) , mTokenizer@var1403 ) <<@expr1073754983 std ::@expr13160 endl@expr13150 ;
3527: if (@expr13161 var@var2925 .@expr13157 nameToken (@expr13158 ) ) {
3528: std ::@expr13152 cout@expr13149 <<@expr13153 indent@var2926 <<@expr1073754990 "    declarationId: " <<@expr1073754991 var@var2925 .@expr1073754992 declarationId (@expr1073754993 ) <<@expr1073754994 std ::@expr13160 endl@expr13150 ;
3529: }
3530: std ::@expr13152 cout@expr13149 <<@expr13153 indent@var2926 <<@expr1073754998 "mTypeStartToken: " <<@expr1073754999 tokenToString (@expr1073755000 var@var2925 .@expr13177 typeStartToken (@expr13178 ) , mTokenizer@var1403 ) <<@expr1073755003 std ::@expr13160 endl@expr13150 ;
3531: std ::@expr13152 cout@expr13149 <<@expr13153 indent@var2926 <<@expr1073755007 "mTypeEndToken: " <<@expr1073755008 tokenToString (@expr1073755009 var@var2925 .@expr13186 typeEndToken (@expr13187 ) , mTokenizer@var1403 ) <<@expr1073755012 std ::@expr13160 endl@expr13150 ;
3532:
3533: if (@expr1073755014 var@var2925 .@expr13177 typeStartToken (@expr13178 ) ) {
3534: const Token * autoTok@var2927 ; autoTok@var2927 =@expr1073755017 nullptr ;
3535: std ::@expr13152 cout@expr13149 <<@expr13153 indent@var2926 <<@expr13196 "   " ;
3536: for (@expr1073755021 const Token *@expr1073755022 tok@var2928 =@expr1073755023 var@var2925 .@expr13177 typeStartToken (@expr13178 ) ; tok@var2928 !=@expr1073755026 var@var2925 .@expr13186 typeEndToken (@expr13187 ) .@expr1073755029 next (@expr1073755030 ) ; tok@var2928 =@expr1073755031 tok@var2928 .@expr1073755032 next (@expr1073755033 ) ) {
3537: std ::@expr13152 cout@expr13149 <<@expr13211 " " <<@expr1073755036 tokenType (@expr1073755037 tok@var2928 ) ;
3538: if (@expr1073755038 tok@var2928 .@expr1073755039 str (@expr1073755040 ) ==@expr1073755041 "auto" ) {
3539: autoTok@var2927 =@expr1073755042 tok@var2928 ; }
3540: }
3541: std ::@expr13152 cout@expr13149 <<@expr13220 std ::@expr13160 endl@expr13150 ;
3542: if (@expr1073755046 autoTok@var2927 ) {
3543: const ValueType * valueType@var2929 ; valueType@var2929 =@expr1073755047 autoTok@var2927 .@expr1073755048 valueType (@expr1073755049 ) ;
3544: std ::@expr13152 cout@expr13149 <<@expr13153 indent@var2926 <<@expr1073755052 "    auto valueType: " <<@expr1073755053 valueType@var2929 <<@expr1073755054 std ::@expr13160 endl@expr13150 ;
3545: if (@expr1073755056 var@var2925 .@expr13177 typeStartToken (@expr13178 ) .@expr1073755059 valueType (@expr1073755060 ) ) {
3546: std ::@expr13152 cout@expr13149 <<@expr13153 indent@var2926 <<@expr1073755063 "        " <<@expr1073755064 valueType@var2929 .@expr1073755065 str (@expr1073755066 ) <<@expr1073755067 std ::@expr13160 endl@expr13150 ;
3547: }
3548: }
3549: } else { if (@expr1073755069 var@var2925 .@expr13246 valueType (@expr13247 ) ) {
3550: std ::@expr13152 cout@expr13149 <<@expr13153 indent@var2926 <<@expr13196 "   " <<@expr1073755075 var@var2925 .@expr13246 valueType (@expr13247 ) .@expr1073755078 str (@expr1073755079 ) <<@expr1073755080 std ::@expr13160 endl@expr13150 ;
3551: } }
3552: std ::@expr13152 cout@expr13149 <<@expr13153 indent@var2926 <<@expr1073755084 "mIndex: " <<@expr1073755085 var@var2925 .@expr1073755086 index (@expr1073755087 ) <<@expr1073755088 std ::@expr13160 endl@expr13150 ;
3553: std ::@expr13152 cout@expr13149 <<@expr13153 indent@var2926 <<@expr1073755092 "mAccess: " <<@expr1073755093 accessControlToString (@expr1073755094 var@var2925 .@expr1073755095 accessControl (@expr1073755096 ) ) <<@expr1073755097 std ::@expr13160 endl@expr13150 ;
3554: std ::@expr13152 cout@expr13149 <<@expr13153 indent@var2926 <<@expr1073755101 "mFlags: " <<@expr1073755102 std ::@expr13160 endl@expr13150 ;
3555: std ::@expr13152 cout@expr13149 <<@expr13153 indent@var2926 <<@expr1073755106 "    isMutable: " <<@expr1073755107 var@var2925 .@expr1073755108 isMutable (@expr1073755109 ) <<@expr1073755110 std ::@expr13160 endl@expr13150 ;
3556: std ::@expr13152 cout@expr13149 <<@expr13153 indent@var2926 <<@expr1073755114 "    isStatic: " <<@expr1073755115 var@var2925 .@expr1073755116 isStatic (@expr1073755117 ) <<@expr1073755118 std ::@expr13160 endl@expr13150 ;
3557: std ::@expr13152 cout@expr13149 <<@expr13153 indent@var2926 <<@expr1073755122 "    isExtern: " <<@expr1073755123 var@var2925 .@expr1073755124 isExtern (@expr1073755125 ) <<@expr1073755126 std ::@expr13160 endl@expr13150 ;
3558: std ::@expr13152 cout@expr13149 <<@expr13153 indent@var2926 <<@expr1073755130 "    isLocal: " <<@expr1073755131 var@var2925 .@expr1073755132 isLocal (@expr1073755133 ) <<@expr1073755134 std ::@expr13160 endl@expr13150 ;
3559: std ::@expr13152 cout@expr13149 <<@expr13153 indent@var2926 <<@expr1073755138 "    isConst: " <<@expr1073755139 var@var2925 .@expr1073755140 isConst (@expr1073755141 ) <<@expr1073755142 std ::@expr13160 endl@expr13150 ;
3560: std ::@expr13152 cout@expr13149 <<@expr13153 indent@var2926 <<@expr1073755146 "    isClass: " <<@expr1073755147 var@var2925 .@expr1073755148 isClass (@expr1073755149 ) <<@expr1073755150 std ::@expr13160 endl@expr13150 ;
3561: std ::@expr13152 cout@expr13149 <<@expr13153 indent@var2926 <<@expr1073755154 "    isArray: " <<@expr1073755155 var@var2925 .@expr1073755156 isArray (@expr1073755157 ) <<@expr1073755158 std ::@expr13160 endl@expr13150 ;
3562: std ::@expr13152 cout@expr13149 <<@expr13153 indent@var2926 <<@expr1073755162 "    isPointer: " <<@expr1073755163 var@var2925 .@expr1073755164 isPointer (@expr1073755165 ) <<@expr1073755166 std ::@expr13160 endl@expr13150 ;
3563: std ::@expr13152 cout@expr13149 <<@expr13153 indent@var2926 <<@expr1073755170 "    isReference: " <<@expr1073755171 var@var2925 .@expr1073755172 isReference (@expr1073755173 ) <<@expr1073755174 std ::@expr13160 endl@expr13150 ;
3564: std ::@expr13152 cout@expr13149 <<@expr13153 indent@var2926 <<@expr1073755178 "    isRValueRef: " <<@expr1073755179 var@var2925 .@expr1073755180 isRValueReference (@expr1073755181 ) <<@expr1073755182 std ::@expr13160 endl@expr13150 ;
3565: std ::@expr13152 cout@expr13149 <<@expr13153 indent@var2926 <<@expr1073755186 "    hasDefault: " <<@expr1073755187 var@var2925 .@expr1073755188 hasDefault (@expr1073755189 ) <<@expr1073755190 std ::@expr13160 endl@expr13150 ;
3566: std ::@expr13152 cout@expr13149 <<@expr13153 indent@var2926 <<@expr1073755194 "    isStlType: " <<@expr1073755195 var@var2925 .@expr1073755196 isStlType (@expr1073755197 ) <<@expr1073755198 std ::@expr13160 endl@expr13150 ;
3567: std ::@expr13152 cout@expr13149 <<@expr13153 indent@var2926 <<@expr1073755202 "mType: " ;
3568: if (@expr1073755203 var@var2925 .@expr13380 type (@expr13381 ) ) {
3569: std ::@expr13152 cout@expr13149 <<@expr1073755207 var@var2925 .@expr13380 type (@expr13381 ) .@expr1073755210 type (@expr1073755211 ) <<@expr1073755212 " " <<@expr1073755213 var@var2925 .@expr13380 type (@expr13381 ) .@expr1073755216 name (@expr1073755217 ) ;
3570: std ::@expr13152 cout@expr13149 <<@expr13211 " " <<@expr1073755220 mTokenizer@var1403 .@expr1073755221 list@var3820 .@expr1073755222 fileLine (@expr1073755223 var@var2925 .@expr13380 type (@expr13381 ) .@expr1073755226 classDef@var3852 ) ;
3571: std ::@expr13152 cout@expr13149 <<@expr13211 " " <<@expr1073755229 var@var2925 .@expr13380 type (@expr13381 ) <<@expr1073755232 std ::@expr13160 endl@expr13150 ;
3572: } else {
3573: std ::@expr13152 cout@expr13149 <<@expr1073755235 "none" <<@expr1073755236 std ::@expr13160 endl@expr13150 ; }
3574:
3575: if (@expr13161 var@var2925 .@expr13157 nameToken (@expr13158 ) ) {
3576: const ValueType * valueType@var2930 ; valueType@var2930 =@expr1073755241 var@var2925 .@expr13157 nameToken (@expr13158 ) .@expr1073755244 valueType (@expr1073755245 ) ;
3577: std ::@expr13152 cout@expr13149 <<@expr13153 indent@var2926 <<@expr1073755248 "valueType: " <<@expr1073755249 valueType@var2930 <<@expr1073755250 std ::@expr13160 endl@expr13150 ;
3578: if (@expr1073755252 valueType@var2930 ) {
3579: std ::@expr13152 cout@expr13149 <<@expr13153 indent@var2926 <<@expr1073755255 "    " <<@expr1073755256 valueType@var2930 .@expr1073755257 str (@expr1073755258 ) <<@expr1073755259 std ::@expr13160 endl@expr13150 ;
3580: }
3581: }
3582:
3583: std ::@expr13152 cout@expr13149 <<@expr13153 indent@var2926 <<@expr1073755263 "mScope: " <<@expr1073755264 scopeToString (@expr1073755265 var@var2925 .@expr1073755266 scope (@expr1073755267 ) , mTokenizer@var1403 ) <<@expr1073755268 std ::@expr13160 endl@expr13150 ;
3584:
3585: std ::@expr13152 cout@expr13149 <<@expr13153 indent@var2926 <<@expr1073755272 "mDimensions:" ;
3586: for (@expr1073755273 unsigned long i@var2931 =@expr1073755274 0 ; i@var2931 <@expr1073755275 var@var2925 .@expr13452 dimensions (@expr13453 ) .@expr1073755278 size (@expr1073755279 ) ; i@var2931 ++@expr1073755280 ) {
3587: std ::@expr13152 cout@expr13149 <<@expr13211 " " <<@expr1073755283 var@var2925 .@expr1073755284 dimension (@expr1073755285 i@var2931 ) ;
3588: if (@expr1073755286 !@expr1073755287 var@var2925 .@expr13452 dimensions (@expr13453 ) [@expr1073755290 i@var2931 ] .@expr1073755291 known@expr1073754975 ) {
3589: std ::@expr13152 cout@expr13149 <<@expr1073755293 "?" ; }
3590: }
3591: std ::@expr13152 cout@expr13149 <<@expr13220 std ::@expr13160 endl@expr13150 ;
3592: }
3593:
3594: void SymbolDatabase :: printOut ( const char * title@var2932 ) const
3595: {
3596: std ::@expr13481 cout@expr13473 <<@expr1073755306 std ::@expr1073755307 setiosflags (@expr1073755308 std ::@expr13485 ios ::@expr13486 boolalpha@expr13474 ) ;
3597: if (@expr1073755311 title@var2932 ) {
3598: std ::@expr13481 cout@expr13473 <<@expr1073755313 "\n### " <<@expr1073755314 title@var2932 <<@expr1073755315 " ###\n" ; }
3599:
3600: for (@expr1073755316 std ::@expr13493 list < Scope > ::@expr13493 const_iterator scope@var2933 =@expr1073755319 scopeList@var1331 .@expr1073755320 begin (@expr1073755321 ) ; scope@var2933 !=@expr1073755322 scopeList@var1331 .@expr1073755323 end (@expr1073755324 ) ; ++@expr1073755325 scope@var2933 ) {
3601: std ::@expr13481 cout@expr13473 <<@expr1073755327 "Scope: " <<@expr1073755328 &@expr1073755329 *@expr1073755330 scope@var2933 <<@expr1073755331 " " <<@expr1073755332 scope@var2933 .@expr13509 type@var2934 <<@expr1073755334 std ::@expr13511 endl@expr13475 ;
3602: std ::@expr13481 cout@expr13473 <<@expr1073755337 "    className: " <<@expr1073755338 scope@var2933 .@expr1073755339 className@var2935 <<@expr1073755340 std ::@expr13511 endl@expr13475 ;
3603: std ::@expr13481 cout@expr13473 <<@expr13519 "    classDef: " <<@expr1073755344 tokenToString (@expr1073755345 scope@var2933 .@expr1073755346 classDef@var2936 , mTokenizer@var1403 ) <<@expr1073755347 std ::@expr13511 endl@expr13475 ;
3604: std ::@expr13481 cout@expr13473 <<@expr1073755350 "    bodyStart: " <<@expr1073755351 tokenToString (@expr1073755352 scope@var2933 .@expr1073755353 bodyStart@var2937 , mTokenizer@var1403 ) <<@expr1073755354 std ::@expr13511 endl@expr13475 ;
3605: std ::@expr13481 cout@expr13473 <<@expr1073755357 "    bodyEnd: " <<@expr1073755358 tokenToString (@expr1073755359 scope@var2933 .@expr1073755360 bodyEnd@var2938 , mTokenizer@var1403 ) <<@expr1073755361 std ::@expr13511 endl@expr13475 ;
3606:
3607: std ::@expr1073755363 list < Function > ::@expr1073755364 const_iterator func@var2939 ;
3608:
3609:
3610: for (@expr1073755365 func@var2939 =@expr1073755366 scope@var2933 .@expr13543 functionList@var2940 .@expr1073755368 begin (@expr1073755369 ) ; func@var2939 !=@expr1073755370 scope@var2933 .@expr13543 functionList@var2940 .@expr1073755372 end (@expr1073755373 ) ; ++@expr1073755374 func@var2939 ) {
3611: std ::@expr13481 cout@expr13473 <<@expr1073755376 "    Function: " <<@expr1073755377 &@expr1073755378 *@expr1073755379 func@var2939 <<@expr1073755380 std ::@expr13511 endl@expr13475 ;
3612: std ::@expr13481 cout@expr13473 <<@expr1073755383 "        name: " <<@expr1073755384 tokenToString (@expr13561 func@var2939 .@expr13562 tokenDef@var2941 , mTokenizer@var1403 ) <<@expr1073755387 std ::@expr13511 endl@expr13475 ;
3613: std ::@expr13481 cout@expr13473 <<@expr1073755390 "        type: " <<@expr1073755391 (@expr1073755392 func@var2939 .@expr13569 type@var2942 ==@expr1073755394 Function ::@expr1073755395 eConstructor ?@expr1073755396 "Constructor" :@expr1073755397
3614: func@var2939 .@expr13569 type@var2942 ==@expr1073755399 Function ::@expr1073755400 eCopyConstructor ?@expr1073755401 "CopyConstructor" :@expr1073755402
3615: func@var2939 .@expr13569 type@var2942 ==@expr1073755404 Function ::@expr1073755405 eMoveConstructor ?@expr1073755406 "MoveConstructor" :@expr1073755407
3616: func@var2939 .@expr13569 type@var2942 ==@expr1073755409 Function ::@expr1073755410 eOperatorEqual ?@expr1073755411 "OperatorEqual" :@expr1073755412
3617: func@var2939 .@expr13569 type@var2942 ==@expr1073755414 Function ::@expr1073755415 eDestructor ?@expr1073755416 "Destructor" :@expr1073755417
3618: func@var2939 .@expr13569 type@var2942 ==@expr1073755419 Function ::@expr1073755420 eFunction@expr1073755300 ?@expr1073755421 "Function" :@expr1073755422
3619: func@var2939 .@expr13569 type@var2942 ==@expr1073755424 Function ::@expr1073755425 eLambda ?@expr1073755426 "Lambda" :@expr1073755427
3620: "Unknown" ) <<@expr1073755428 std ::@expr13511 endl@expr13475 ;
3621: std ::@expr13481 cout@expr13473 <<@expr1073755431 "        access: " <<@expr1073755432 accessControlToString (@expr1073755433 func@var2939 .@expr1073755434 access@var2943 ) <<@expr1073755435 std ::@expr13511 endl@expr13475 ;
3622: std ::@expr13481 cout@expr13473 <<@expr1073755438 "        hasBody: " <<@expr1073755439 func@var2939 .@expr13616 hasBody (@expr13617 ) <<@expr1073755442 std ::@expr13511 endl@expr13475 ;
3623: std ::@expr13481 cout@expr13473 <<@expr1073755445 "        isInline: " <<@expr1073755446 func@var2939 .@expr1073755447 isInline (@expr1073755448 ) <<@expr1073755449 std ::@expr13511 endl@expr13475 ;
3624: std ::@expr13481 cout@expr13473 <<@expr1073755452 "        isConst: " <<@expr1073755453 func@var2939 .@expr1073755454 isConst (@expr1073755455 ) <<@expr1073755456 std ::@expr13511 endl@expr13475 ;
3625: std ::@expr13481 cout@expr13473 <<@expr1073755459 "        hasVirtualSpecifier: " <<@expr1073755460 func@var2939 .@expr1073755461 hasVirtualSpecifier (@expr1073755462 ) <<@expr1073755463 std ::@expr13511 endl@expr13475 ;
3626: std ::@expr13481 cout@expr13473 <<@expr1073755466 "        isPure: " <<@expr1073755467 func@var2939 .@expr1073755468 isPure (@expr1073755469 ) <<@expr1073755470 std ::@expr13511 endl@expr13475 ;
3627: std ::@expr13481 cout@expr13473 <<@expr1073755473 "        isStatic: " <<@expr1073755474 func@var2939 .@expr1073755475 isStatic (@expr1073755476 ) <<@expr1073755477 std ::@expr13511 endl@expr13475 ;
3628: std ::@expr13481 cout@expr13473 <<@expr1073755480 "        isStaticLocal: " <<@expr1073755481 func@var2939 .@expr1073755482 isStaticLocal (@expr1073755483 ) <<@expr1073755484 std ::@expr13511 endl@expr13475 ;
3629: std ::@expr13481 cout@expr13473 <<@expr1073755487 "        isExtern: " <<@expr1073755488 func@var2939 .@expr1073755489 isExtern (@expr1073755490 ) <<@expr1073755491 std ::@expr13511 endl@expr13475 ;
3630: std ::@expr13481 cout@expr13473 <<@expr1073755494 "        isFriend: " <<@expr1073755495 func@var2939 .@expr1073755496 isFriend (@expr1073755497 ) <<@expr1073755498 std ::@expr13511 endl@expr13475 ;
3631: std ::@expr13481 cout@expr13473 <<@expr1073755501 "        isExplicit: " <<@expr1073755502 func@var2939 .@expr1073755503 isExplicit (@expr1073755504 ) <<@expr1073755505 std ::@expr13511 endl@expr13475 ;
3632: std ::@expr13481 cout@expr13473 <<@expr1073755508 "        isDefault: " <<@expr1073755509 func@var2939 .@expr1073755510 isDefault (@expr1073755511 ) <<@expr1073755512 std ::@expr13511 endl@expr13475 ;
3633: std ::@expr13481 cout@expr13473 <<@expr1073755515 "        isDelete: " <<@expr1073755516 func@var2939 .@expr1073755517 isDelete (@expr1073755518 ) <<@expr1073755519 std ::@expr13511 endl@expr13475 ;
3634: std ::@expr13481 cout@expr13473 <<@expr1073755522 "        hasOverrideSpecifier: " <<@expr1073755523 func@var2939 .@expr1073755524 hasOverrideSpecifier (@expr1073755525 ) <<@expr1073755526 std ::@expr13511 endl@expr13475 ;
3635: std ::@expr13481 cout@expr13473 <<@expr1073755529 "        hasFinalSpecifier: " <<@expr1073755530 func@var2939 .@expr1073755531 hasFinalSpecifier (@expr1073755532 ) <<@expr1073755533 std ::@expr13511 endl@expr13475 ;
3636: std ::@expr13481 cout@expr13473 <<@expr1073755536 "        isNoExcept: " <<@expr1073755537 func@var2939 .@expr1073755538 isNoExcept (@expr1073755539 ) <<@expr1073755540 std ::@expr13511 endl@expr13475 ;
3637: std ::@expr13481 cout@expr13473 <<@expr1073755543 "        isThrow: " <<@expr1073755544 func@var2939 .@expr1073755545 isThrow (@expr1073755546 ) <<@expr1073755547 std ::@expr13511 endl@expr13475 ;
3638: std ::@expr13481 cout@expr13473 <<@expr1073755550 "        isOperator: " <<@expr1073755551 func@var2939 .@expr1073755552 isOperator (@expr1073755553 ) <<@expr1073755554 std ::@expr13511 endl@expr13475 ;
3639: std ::@expr13481 cout@expr13473 <<@expr1073755557 "        hasLvalRefQual: " <<@expr1073755558 func@var2939 .@expr1073755559 hasLvalRefQualifier (@expr1073755560 ) <<@expr1073755561 std ::@expr13511 endl@expr13475 ;
3640: std ::@expr13481 cout@expr13473 <<@expr1073755564 "        hasRvalRefQual: " <<@expr1073755565 func@var2939 .@expr1073755566 hasRvalRefQualifier (@expr1073755567 ) <<@expr1073755568 std ::@expr13511 endl@expr13475 ;
3641: std ::@expr13481 cout@expr13473 <<@expr1073755571 "        isVariadic: " <<@expr1073755572 func@var2939 .@expr1073755573 isVariadic (@expr1073755574 ) <<@expr1073755575 std ::@expr13511 endl@expr13475 ;
3642: std ::@expr13481 cout@expr13473 <<@expr1073755578 "        isVolatile: " <<@expr1073755579 func@var2939 .@expr1073755580 isVolatile (@expr1073755581 ) <<@expr1073755582 std ::@expr13511 endl@expr13475 ;
3643: std ::@expr13481 cout@expr13473 <<@expr1073755585 "        hasTrailingReturnType: " <<@expr1073755586 func@var2939 .@expr1073755587 hasTrailingReturnType (@expr1073755588 ) <<@expr1073755589 std ::@expr13511 endl@expr13475 ;
3644: std ::@expr13481 cout@expr13473 <<@expr1073755592 "        attributes:" ;
3645: if (@expr1073755593 func@var2939 .@expr1073755594 isAttributeConst (@expr1073755595 ) ) {
3646: std ::@expr13481 cout@expr13473 <<@expr1073755597 " const " ; }
3647: if (@expr1073755598 func@var2939 .@expr1073755599 isAttributePure (@expr1073755600 ) ) {
3648: std ::@expr13481 cout@expr13473 <<@expr1073755602 " pure " ; }
3649: if (@expr1073755603 func@var2939 .@expr1073755604 isAttributeNoreturn (@expr1073755605 ) ) {
3650: std ::@expr13481 cout@expr13473 <<@expr1073755607 " noreturn " ; }
3651: if (@expr1073755608 func@var2939 .@expr1073755609 isAttributeNothrow (@expr1073755610 ) ) {
3652: std ::@expr13481 cout@expr13473 <<@expr1073755612 " nothrow " ; }
3653: if (@expr1073755613 func@var2939 .@expr1073755614 isAttributeConstructor (@expr1073755615 ) ) {
3654: std ::@expr13481 cout@expr13473 <<@expr1073755617 " constructor " ; }
3655: if (@expr1073755618 func@var2939 .@expr1073755619 isAttributeDestructor (@expr1073755620 ) ) {
3656: std ::@expr13481 cout@expr13473 <<@expr1073755622 " destructor " ; }
3657: if (@expr1073755623 func@var2939 .@expr1073755624 isAttributeNodiscard (@expr1073755625 ) ) {
3658: std ::@expr13481 cout@expr13473 <<@expr1073755627 " nodiscard " ; }
3659: std ::@expr13481 cout@expr13473 <<@expr13805 std ::@expr13511 endl@expr13475 ;
3660: std ::@expr13481 cout@expr13473 <<@expr1073755632 "        noexceptArg: " <<@expr1073755633 (@expr1073755634 func@var2939 .@expr13811 noexceptArg@var2944 ?@expr1073755636 func@var2939 .@expr13811 noexceptArg@var2944 .@expr1073755638 str (@expr1073755639 ) :@expr1073755640 "none" ) <<@expr1073755641 std ::@expr13511 endl@expr13475 ;
3661: std ::@expr13481 cout@expr13473 <<@expr1073755644 "        throwArg: " <<@expr1073755645 (@expr1073755646 func@var2939 .@expr13823 throwArg@var2945 ?@expr1073755648 func@var2939 .@expr13823 throwArg@var2945 .@expr1073755650 str (@expr1073755651 ) :@expr1073755652 "none" ) <<@expr1073755653 std ::@expr13511 endl@expr13475 ;
3662: std ::@expr13481 cout@expr13473 <<@expr1073755656 "        tokenDef: " <<@expr1073755657 tokenToString (@expr13561 func@var2939 .@expr13562 tokenDef@var2941 , mTokenizer@var1403 ) <<@expr1073755660 std ::@expr13511 endl@expr13475 ;
3663: std ::@expr13481 cout@expr13473 <<@expr1073755663 "        argDef: " <<@expr1073755664 tokenToString (@expr1073755665 func@var2939 .@expr1073755666 argDef@var2946 , mTokenizer@var1403 ) <<@expr1073755667 std ::@expr13511 endl@expr13475 ;
3664: if (@expr1073755669 !@expr1073755670 func@var2939 .@expr1073755671 isConstructor (@expr1073755672 ) &&@expr1073755673 !@expr1073755674 func@var2939 .@expr1073755675 isDestructor (@expr1073755676 ) ) {
3665: std ::@expr13481 cout@expr13473 <<@expr1073755678 "        retDef: " <<@expr1073755679 tokenToString (@expr1073755680 func@var2939 .@expr13857 retDef@var2947 , mTokenizer@var1403 ) <<@expr1073755682 std ::@expr13511 endl@expr13475 ; }
3666: if (@expr1073755684 func@var2939 .@expr13857 retDef@var2947 ) {
3667: std ::@expr13481 cout@expr13473 <<@expr1073755687 "           " ;
3668: for (@expr1073755688 const Token *@expr13865 tok@var2948 =@expr1073755690 func@var2939 .@expr13857 retDef@var2947 ; tok@var2948 &&@expr1073755692 tok@var2948 !=@expr1073755693 func@var2939 .@expr13562 tokenDef@var2941 &&@expr1073755695 !@expr1073755696 Token ::@expr1073755697 Match (@expr1073755698 tok@var2948 , "{|;|override|final" ) ; tok@var2948 =@expr1073755699 tok@var2948 .@expr1073755700 next (@expr1073755701 ) ) {
3669: std ::@expr13481 cout@expr13473 <<@expr13879 " " <<@expr1073755704 tokenType (@expr1073755705 tok@var2948 ) ; }
3670: std ::@expr13481 cout@expr13473 <<@expr13805 std ::@expr13511 endl@expr13475 ;
3671: }
3672: std ::@expr13481 cout@expr13473 <<@expr1073755710 "        retType: " <<@expr1073755711 func@var2939 .@expr1073755712 retType@var2949 <<@expr1073755713 std ::@expr13511 endl@expr13475 ;
3673:
3674: if (@expr1073755715 func@var2939 .@expr13562 tokenDef@var2941 .@expr13893 next (@expr13894 ) .@expr13895 valueType (@expr13896 ) ) {
3675: const ValueType * valueType@var2950 ; valueType@var2950 =@expr1073755721 func@var2939 .@expr13562 tokenDef@var2941 .@expr13893 next (@expr13894 ) .@expr13895 valueType (@expr13896 ) ;
3676: std ::@expr13481 cout@expr13473 <<@expr1073755728 "        valueType: " <<@expr1073755729 valueType@var2950 <<@expr1073755730 std ::@expr13511 endl@expr13475 ;
3677: if (@expr1073755732 valueType@var2950 ) {
3678: std ::@expr13481 cout@expr13473 <<@expr1073755734 "            " <<@expr1073755735 valueType@var2950 .@expr1073755736 str (@expr1073755737 ) <<@expr1073755738 std ::@expr13511 endl@expr13475 ;
3679: }
3680: }
3681:
3682: if (@expr1073755740 func@var2939 .@expr13616 hasBody (@expr13617 ) ) {
3683: std ::@expr13481 cout@expr13473 <<@expr1073755744 "        token: " <<@expr1073755745 tokenToString (@expr1073755746 func@var2939 .@expr1073755747 token@var2951 , mTokenizer@var1403 ) <<@expr1073755748 std ::@expr13511 endl@expr13475 ;
3684: std ::@expr13481 cout@expr13473 <<@expr1073755751 "        arg: " <<@expr1073755752 tokenToString (@expr1073755753 func@var2939 .@expr1073755754 arg@var2952 , mTokenizer@var1403 ) <<@expr1073755755 std ::@expr13511 endl@expr13475 ;
3685: }
3686: std ::@expr13481 cout@expr13473 <<@expr1073755758 "        nestedIn: " <<@expr1073755759 scopeToString (@expr1073755760 func@var2939 .@expr1073755761 nestedIn@var2953 , mTokenizer@var1403 ) <<@expr1073755762 std ::@expr13511 endl@expr13475 ;
3687: std ::@expr13481 cout@expr13473 <<@expr1073755765 "        functionScope: " <<@expr1073755766 scopeToString (@expr1073755767 func@var2939 .@expr1073755768 functionScope@var2954 , mTokenizer@var1403 ) <<@expr1073755769 std ::@expr13511 endl@expr13475 ;
3688:
3689: std ::@expr13947 list < Variable > ::@expr1073755772 const_iterator var@var2955 ;
3690:
3691: for (@expr1073755773 var@var2955 =@expr1073755774 func@var2939 .@expr13951 argumentList@var2956 .@expr1073755776 begin (@expr1073755777 ) ; var@var2955 !=@expr1073755778 func@var2939 .@expr13951 argumentList@var2956 .@expr1073755780 end (@expr1073755781 ) ; ++@expr1073755782 var@var2955 ) {
3692: std ::@expr13481 cout@expr13473 <<@expr1073755784 "        Variable: " <<@expr1073755785 &@expr13962 *@expr13963 var@var2955 <<@expr1073755788 std ::@expr13511 endl@expr13475 ;
3693: printVariable (@expr1073755790 &@expr13962 *@expr13963 var@var2955 , "            " ) ;
3694: }
3695: }
3696:
3697: std ::@expr13947 list < Variable > ::@expr1073755794 const_iterator var@var2957 ;
3698:
3699: for (@expr1073755795 var@var2957 =@expr1073755796 scope@var2933 .@expr13973 varlist@var2958 .@expr1073755798 begin (@expr1073755799 ) ; var@var2957 !=@expr1073755800 scope@var2933 .@expr13973 varlist@var2958 .@expr1073755802 end (@expr1073755803 ) ; ++@expr1073755804 var@var2957 ) {
3700: std ::@expr13481 cout@expr13473 <<@expr1073755806 "    Variable: " <<@expr1073755807 &@expr13984 *@expr13985 var@var2957 <<@expr1073755810 std ::@expr13511 endl@expr13475 ;
3701: printVariable (@expr1073755812 &@expr13984 *@expr13985 var@var2957 , "        " ) ;
3702: }
3703:
3704: if (@expr1073755815 scope@var2933 .@expr13509 type@var2934 ==@expr1073755817 Scope ::@expr1073755818 eEnum ) {
3705: std ::@expr13481 cout@expr13473 <<@expr1073755820 "    enumType: " ;
3706: if (@expr1073755821 scope@var2933 .@expr13998 enumType@var2959 ) {
3707: std ::@expr13481 cout@expr13473 <<@expr1073755824 scope@var2933 .@expr13998 enumType@var2959 .@expr1073755826 stringify (@expr1073755827 false , true , false ) ;
3708: } else {
3709: std ::@expr13481 cout@expr13473 <<@expr1073755829 "int" ; }
3710: std ::@expr13481 cout@expr13473 <<@expr13805 std ::@expr13511 endl@expr13475 ;
3711: std ::@expr13481 cout@expr13473 <<@expr1073755834 "    enumClass: " <<@expr1073755835 scope@var2933 .@expr1073755836 enumClass@var2960 <<@expr1073755837 std ::@expr13511 endl@expr13475 ;
3712: for (@expr1073755839 const Enumerator &@expr14016 enumerator@var2961 :@expr1073755841 scope@var2933 .@expr1073755842 enumeratorList@var2962 ) {
3713: std ::@expr13481 cout@expr13473 <<@expr1073755844 "        Enumerator: " <<@expr1073755845 enumerator@var2961 .@expr1073755846 name@var2963 .@expr1073755847 str (@expr1073755848 ) <<@expr1073755849 " = " ;
3714: if (@expr1073755850 enumerator@var2961 .@expr14027 value_known@var2964 ) {
3715: std ::@expr13481 cout@expr13473 <<@expr1073755853 enumerator@var2961 .@expr1073755854 value@var2965 ; }
3716:
3717: if (@expr1073755855 enumerator@var2961 .@expr14032 start@var2966 ) {
3718: const Token * tok@var2967 ; tok@var2967 =@expr1073755857 enumerator@var2961 .@expr14032 start@var2966 ;
3719: std ::@expr13481 cout@expr13473 <<@expr1073755860 (@expr1073755861 enumerator@var2961 .@expr14027 value_known@var2964 ?@expr1073755863 " " :@expr1073755864 "" ) <<@expr1073755865 "[" <<@expr1073755866 tok@var2967 .@expr1073755867 str (@expr1073755868 ) ;
3720: while (@expr1073755869 tok@var2967 &&@expr1073755870 tok@var2967 !=@expr1073755871 enumerator@var2961 .@expr1073755872 end@var2968 ) {
3721: if (@expr1073755873 tok@var2967 .@expr14050 next (@expr14051 ) ) {
3722: std ::@expr13481 cout@expr13473 <<@expr13879 " " <<@expr1073755878 tok@var2967 .@expr14050 next (@expr14051 ) .@expr1073755881 str (@expr1073755882 ) ; }
3723: tok@var2967 =@expr1073755883 tok@var2967 .@expr14050 next (@expr14051 ) ;
3724: }
3725:
3726: std ::@expr13481 cout@expr13473 <<@expr1073755887 "]" ;
3727: }
3728:
3729: std ::@expr13481 cout@expr13473 <<@expr13805 std ::@expr13511 endl@expr13475 ;
3730: }
3731: }
3732:
3733: std ::@expr13481 cout@expr13473 <<@expr1073755892 "    nestedIn: " <<@expr1073755893 scope@var2933 .@expr14070 nestedIn@var2969 ;
3734: if (@expr1073755895 scope@var2933 .@expr14070 nestedIn@var2969 ) {
3735: std ::@expr13481 cout@expr13473 <<@expr13879 " " <<@expr1073755899 scope@var2933 .@expr14070 nestedIn@var2969 .@expr1073755901 type@var2970 <<@expr1073755902 " "
3736: <<@expr1073755903 scope@var2933 .@expr14070 nestedIn@var2969 .@expr1073755905 className@var2971 ;
3737: }
3738: std ::@expr13481 cout@expr13473 <<@expr13805 std ::@expr13511 endl@expr13475 ;
3739:
3740: std ::@expr13481 cout@expr13473 <<@expr1073755910 "    definedType: " <<@expr1073755911 scope@var2933 .@expr1073755912 definedType@var2972 <<@expr1073755913 std ::@expr13511 endl@expr13475 ;
3741:
3742: std ::@expr13481 cout@expr13473 <<@expr1073755916 "    nestedList[" <<@expr1073755917 scope@var2933 .@expr14094 nestedList@var2973 .@expr14095 size (@expr14096 ) <<@expr1073755921 "] = (" ;
3743:
3744: std ::@expr1073755922 list < Scope *@expr13865 > ::@expr1073755924 const_iterator nsi@var2974 ;
3745:
3746: unsigned long count@var2975 ; count@var2975 =@expr1073755925 scope@var2933 .@expr14094 nestedList@var2973 .@expr14095 size (@expr14096 ) ;
3747: for (@expr1073755929 nsi@var2974 =@expr1073755930 scope@var2933 .@expr14094 nestedList@var2973 .@expr1073755932 begin (@expr1073755933 ) ; nsi@var2974 !=@expr1073755934 scope@var2933 .@expr14094 nestedList@var2973 .@expr1073755936 end (@expr1073755937 ) ; ++@expr1073755938 nsi@var2974 ) {
3748: std ::@expr13481 cout@expr13473 <<@expr13879 " " <<@expr1073755941 (@expr14118 *@expr14119 nsi@var2974 ) <<@expr1073755944 " " <<@expr1073755945 (@expr14118 *@expr14119 nsi@var2974 ) .@expr1073755948 type@var2976 <<@expr1073755949 " " <<@expr1073755950 (@expr14118 *@expr14119 nsi@var2974 ) .@expr1073755953 className@var2977 ;
3749: if (@expr1073755954 count@var2975 --@expr1073755955 >@expr1073755956 1 ) {
3750: std ::@expr13481 cout@expr13473 <<@expr14134 "," ; }
3751: }
3752:
3753: std ::@expr13481 cout@expr13473 <<@expr14136 " )" <<@expr14137 std ::@expr13511 endl@expr13475 ;
3754:
3755: std ::@expr1073755963 list < Scope ::@expr13493 UsingInfo > ::@expr1073755965 const_iterator use@var2978 ;
3756:
3757: for (@expr1073755966 use@var2978 =@expr1073755967 scope@var2933 .@expr14144 usingList@var2979 .@expr1073755969 begin (@expr1073755970 ) ; use@var2978 !=@expr1073755971 scope@var2933 .@expr14144 usingList@var2979 .@expr1073755973 end (@expr1073755974 ) ; ++@expr1073755975 use@var2978 ) {
3758: std ::@expr13481 cout@expr13473 <<@expr1073755977 "    using: " <<@expr1073755978 use@var2978 .@expr1073755979 scope@var2980 <<@expr1073755980 " " <<@expr1073755981 use@var2978 .@expr14158 start@var2981 .@expr1073755983 strAt (@expr1073755984 2 ) ;
3759: const Token * tok1@var2982 ; tok1@var2982 =@expr1073755985 use@var2978 .@expr14158 start@var2981 .@expr1073755987 tokAt (@expr1073755988 3 ) ;
3760: while (@expr1073755989 tok1@var2982 &&@expr1073755990 tok1@var2982 .@expr1073755991 str (@expr1073755992 ) ==@expr1073755993 "::" ) {
3761: std ::@expr13481 cout@expr13473 <<@expr1073755995 "::" <<@expr1073755996 tok1@var2982 .@expr1073755997 strAt (@expr1073755998 1 ) ;
3762: tok1@var2982 =@expr1073755999 tok1@var2982 .@expr1073756000 tokAt (@expr1073756001 2 ) ;
3763: }
3764: std ::@expr13481 cout@expr13473 <<@expr13879 " " <<@expr1073756004 mTokenizer@var1403 .@expr14181 list@var3820 .@expr14182 fileLine (@expr1073756007 use@var2978 .@expr14158 start@var2981 ) <<@expr1073756009 std ::@expr13511 endl@expr13475 ;
3765: }
3766:
3767: std ::@expr13481 cout@expr13473 <<@expr1073756012 "    functionOf: " <<@expr1073756013 scopeToString (@expr1073756014 scope@var2933 .@expr1073756015 functionOf@var2983 , mTokenizer@var1403 ) <<@expr1073756016 std ::@expr13511 endl@expr13475 ;
3768:
3769: std ::@expr13481 cout@expr13473 <<@expr1073756019 "    function: " <<@expr1073756020 scope@var2933 .@expr14197 function@var2984 ;
3770: if (@expr1073756022 scope@var2933 .@expr14197 function@var2984 ) {
3771: std ::@expr13481 cout@expr13473 <<@expr13879 " " <<@expr1073756026 scope@var2933 .@expr14197 function@var2984 .@expr1073756028 name (@expr1073756029 ) ; }
3772: std ::@expr13481 cout@expr13473 <<@expr13805 std ::@expr13511 endl@expr13475 ;
3773: }
3774:
3775: for (@expr1073756033 std ::@expr13493 list < Type > ::@expr13493 const_iterator type@var2985 =@expr1073756036 typeList@var1334 .@expr1073756037 begin (@expr1073756038 ) ; type@var2985 !=@expr1073756039 typeList@var1334 .@expr1073756040 end (@expr1073756041 ) ; ++@expr1073756042 type@var2985 ) {
3776: std ::@expr13481 cout@expr13473 <<@expr1073756044 "Type: " <<@expr1073756045 &@expr1073756046 (@expr1073756047 *@expr1073756048 type@var2985 ) <<@expr1073756049 std ::@expr13511 endl@expr13475 ;
3777: std ::@expr13481 cout@expr13473 <<@expr1073756052 "    name: " <<@expr1073756053 type@var2985 .@expr1073756054 name (@expr1073756055 ) <<@expr1073756056 std ::@expr13511 endl@expr13475 ;
3778: std ::@expr13481 cout@expr13473 <<@expr13519 "    classDef: " <<@expr1073756060 tokenToString (@expr1073756061 type@var2985 .@expr1073756062 classDef@var2986 , mTokenizer@var1403 ) <<@expr1073756063 std ::@expr13511 endl@expr13475 ;
3779: std ::@expr13481 cout@expr13473 <<@expr1073756066 "    classScope: " <<@expr1073756067 type@var2985 .@expr1073756068 classScope@var2987 <<@expr1073756069 std ::@expr13511 endl@expr13475 ;
3780: std ::@expr13481 cout@expr13473 <<@expr1073756072 "    enclosingScope: " <<@expr1073756073 type@var2985 .@expr14250 enclosingScope@var2988 ;
3781: if (@expr1073756075 type@var2985 .@expr14250 enclosingScope@var2988 ) {
3782: std ::@expr13481 cout@expr13473 <<@expr13879 " " <<@expr1073756079 type@var2985 .@expr14250 enclosingScope@var2988 .@expr1073756081 type@var2989 <<@expr1073756082 " "
3783: <<@expr1073756083 type@var2985 .@expr14250 enclosingScope@var2988 .@expr1073756085 className@var2990 ;
3784: }
3785: std ::@expr13481 cout@expr13473 <<@expr13805 std ::@expr13511 endl@expr13475 ;
3786: std ::@expr13481 cout@expr13473 <<@expr1073756090 "    needInitialization: " <<@expr1073756091 (@expr1073756092 type@var2985 .@expr14269 needInitialization@var2991 ==@expr1073756094 Type ::@expr14271 NeedInitialization ::@expr1073756096 Unknown@expr1073755301 ?@expr1073756097 "Unknown" :@expr1073756098
3787: type@var2985 .@expr14269 needInitialization@var2991 ==@expr1073756100 Type ::@expr14271 NeedInitialization ::@expr1073756102 True ?@expr1073756103 "True" :@expr1073756104
3788: type@var2985 .@expr14269 needInitialization@var2991 ==@expr1073756106 Type ::@expr14271 NeedInitialization ::@expr1073756108 False ?@expr1073756109 "False" :@expr1073756110
3789: "Invalid" ) <<@expr1073756111 std ::@expr13511 endl@expr13475 ;
3790:
3791: std ::@expr13481 cout@expr13473 <<@expr1073756114 "    derivedFrom[" <<@expr1073756115 type@var2985 .@expr14292 derivedFrom@var2992 .@expr14293 size (@expr14294 ) <<@expr1073756119 "] = (" ;
3792: unsigned long count@var2993 ; count@var2993 =@expr1073756120 type@var2985 .@expr14292 derivedFrom@var2992 .@expr14293 size (@expr14294 ) ;
3793: for (@expr1073756124 const Type ::@expr13493 BaseInfo &@expr14016 i@var2994 :@expr1073756127 type@var2985 .@expr14292 derivedFrom@var2992 ) {
3794: if (@expr1073756129 i@var2994 .@expr1073756130 isVirtual@var2995 ) {
3795: std ::@expr13481 cout@expr13473 <<@expr1073756132 "Virtual " ; }
3796:
3797: std ::@expr13481 cout@expr13473 <<@expr1073756134 (@expr1073756135 i@var2994 .@expr14312 access@var2996 ==@expr1073756137 AccessControl ::@expr1073756138 Public@expr1073755302 ?@expr1073756139 " Public" :@expr1073756140
3798: i@var2994 .@expr14312 access@var2996 ==@expr1073756142 AccessControl ::@expr1073756143 Protected ?@expr1073756144 " Protected" :@expr1073756145
3799: i@var2994 .@expr14312 access@var2996 ==@expr1073756147 AccessControl ::@expr1073756148 Private ?@expr1073756149 " Private" :@expr1073756150
3800: " Unknown" ) ;
3801:
3802: if (@expr1073756151 i@var2994 .@expr14328 type@var2997 ) {
3803: std ::@expr13481 cout@expr13473 <<@expr13879 " " <<@expr1073756155 i@var2994 .@expr14328 type@var2997 ; }
3804: else {
3805: std ::@expr13481 cout@expr13473 <<@expr14334 " Unknown" ; }
3806:
3807: std ::@expr13481 cout@expr13473 <<@expr13879 " " <<@expr1073756161 i@var2994 .@expr1073756162 name@var2998 ;
3808: if (@expr1073756163 count@var2993 --@expr1073756164 >@expr1073756165 1 ) {
3809: std ::@expr13481 cout@expr13473 <<@expr14134 "," ; }
3810: }
3811:
3812: std ::@expr13481 cout@expr13473 <<@expr14136 " )" <<@expr14137 std ::@expr13511 endl@expr13475 ;
3813:
3814: std ::@expr13481 cout@expr13473 <<@expr1073756173 "    friendList[" <<@expr1073756174 type@var2985 .@expr14351 friendList@var2999 .@expr14352 size (@expr14353 ) <<@expr1073756178 "] = (" ;
3815: for (@expr1073756179 unsigned long i@var3000 =@expr1073756180 0 ; i@var3000 <@expr1073756181 type@var2985 .@expr14351 friendList@var2999 .@expr14352 size (@expr14353 ) ; i@var3000 ++@expr1073756185 ) {
3816: if (@expr1073756186 type@var2985 .@expr14351 friendList@var2999 [@expr14364 i@var3000 ] .@expr14365 type@expr13479 ) {
3817: std ::@expr13481 cout@expr13473 <<@expr1073756191 type@var2985 .@expr14351 friendList@var2999 [@expr14364 i@var3000 ] .@expr14365 type@expr13479 ; }
3818: else {
3819: std ::@expr13481 cout@expr13473 <<@expr14334 " Unknown" ; }
3820:
3821: std ::@expr13481 cout@expr13473 <<@expr1073756198 ' ' ;
3822: if (@expr1073756199 type@var2985 .@expr14351 friendList@var2999 [@expr14364 i@var3000 ] .@expr14378 nameEnd@expr1073755304 ) {
3823: std ::@expr13481 cout@expr13473 <<@expr1073756204 type@var2985 .@expr14351 friendList@var2999 [@expr14364 i@var3000 ] .@expr14378 nameEnd .@expr1073756208 str (@expr1073756209 ) ; }
3824: if (@expr1073756210 i@var3000 +@expr1073756211 1 <@expr1073756212 type@var2985 .@expr14351 friendList@var2999 .@expr14352 size (@expr14353 ) ) {
3825: std ::@expr13481 cout@expr13473 <<@expr1073756217 ',' ; }
3826: }
3827:
3828: std ::@expr13481 cout@expr13473 <<@expr14136 " )" <<@expr14137 std ::@expr13511 endl@expr13475 ;
3829: }
3830:
3831: for (@expr1073756222 unsigned long i@var3001 =@expr1073756223 1 ; i@var3001 <@expr1073756224 mVariableList@var1406 .@expr1073756225 size (@expr1073756226 ) ; i@var3001 ++@expr1073756227 ) {
3832: std ::@expr13481 cout@expr13473 <<@expr1073756229 "mVariableList[" <<@expr1073756230 i@var3001 <<@expr1073756231 "]: " <<@expr1073756232 mVariableList@var1406 [@expr14409 i@var3001 ] ;
3833: if (@expr1073756234 mVariableList@var1406 [@expr14409 i@var3001 ] ) {
3834: std ::@expr13481 cout@expr13473 <<@expr13879 " " <<@expr1073756238 mVariableList@var1406 [@expr14409 i@var3001 ] .@expr1073756240 name (@expr1073756241 ) <<@expr1073756242 " "
3835: <<@expr1073756243 mTokenizer@var1403 .@expr14181 list@var3820 .@expr14182 fileLine (@expr1073756246 mVariableList@var1406 [@expr14409 i@var3001 ] .@expr1073756248 nameToken (@expr1073756249 ) ) ;
3836: }
3837: std ::@expr13481 cout@expr13473 <<@expr13805 std ::@expr13511 endl@expr13475 ;
3838: }
3839: std ::@expr13481 cout@expr13473 <<@expr1073756254 std ::@expr1073756255 resetiosflags (@expr1073756256 std ::@expr13485 ios ::@expr13486 boolalpha@expr13474 ) ;
3840: }
3841:
3842: void SymbolDatabase :: printXml ( std :: ostream & out@var3002 ) const
3843: {
3844: out@var3002 <<@expr1073756262 std ::@expr1073756263 setiosflags (@expr1073756264 std ::@expr14441 ios ::@expr14442 boolalpha@expr14435 ) ;
3845:
3846: std ::@expr1073756267 set < const Variable *@expr14444 > variables@var3003 ;
3847:
3848:
3849: out@var3002 <<@expr1073756269 "  <scopes>" <<@expr1073756270 std ::@expr14447 endl@expr14436 ;
3850: for (@expr1073756272 std ::@expr14449 list < Scope > ::@expr14449 const_iterator scope@var3004 =@expr1073756275 scopeList@var1331 .@expr1073756276 begin (@expr1073756277 ) ; scope@var3004 !=@expr1073756278 scopeList@var1331 .@expr1073756279 end (@expr1073756280 ) ; ++@expr1073756281 scope@var3004 ) {
3851: out@var3002 <<@expr1073756282 "    <scope" ;
3852: out@var3002 <<@expr1073756283 " id=\"" <<@expr1073756284 &@expr1073756285 *@expr1073756286 scope@var3004 <<@expr1073756287 "\"" ;
3853: out@var3002 <<@expr14464 " type=\"" <<@expr1073756289 scope@var3004 .@expr1073756290 type@var3005 <<@expr1073756291 "\"" ;
3854: if (@expr1073756292 !@expr1073756293 scope@var3004 .@expr14470 className@var3006 .@expr1073756295 empty (@expr1073756296 ) ) {
3855: out@var3002 <<@expr1073756297 " className=\"" <<@expr1073756298 ErrorLogger ::@expr14475 toxml (@expr1073756300 scope@var3004 .@expr14470 className@var3006 ) <<@expr1073756302 "\"" ; }
3856: if (@expr1073756303 scope@var3004 .@expr14480 bodyStart@var3007 ) {
3857: out@var3002 <<@expr1073756305 " bodyStart=\"" <<@expr1073756306 scope@var3004 .@expr14480 bodyStart@var3007 <<@expr1073756308 '\"' ; }
3858: if (@expr1073756309 scope@var3004 .@expr14486 bodyEnd@var3008 ) {
3859: out@var3002 <<@expr1073756311 " bodyEnd=\"" <<@expr1073756312 scope@var3004 .@expr14486 bodyEnd@var3008 <<@expr1073756314 '\"' ; }
3860: if (@expr1073756315 scope@var3004 .@expr14492 nestedIn@var3009 ) {
3861: out@var3002 <<@expr1073756317 " nestedIn=\"" <<@expr1073756318 scope@var3004 .@expr14492 nestedIn@var3009 <<@expr1073756320 "\"" ; }
3862: if (@expr1073756321 scope@var3004 .@expr14498 function@var3010 ) {
3863: out@var3002 <<@expr1073756323 " function=\"" <<@expr1073756324 scope@var3004 .@expr14498 function@var3010 <<@expr1073756326 "\"" ; }
3864: if (@expr1073756327 scope@var3004 .@expr14504 functionList@var3011 .@expr14505 empty (@expr14506 ) &&@expr1073756331 scope@var3004 .@expr14508 varlist@var3012 .@expr14509 empty (@expr14510 ) ) {
3865: out@var3002 <<@expr14511 "/>" <<@expr14512 std ::@expr14447 endl@expr14436 ; }
3866: else {
3867: out@var3002 <<@expr1073756338 '>' <<@expr1073756339 std ::@expr14447 endl@expr14436 ;
3868: if (@expr1073756341 !@expr1073756342 scope@var3004 .@expr14504 functionList@var3011 .@expr14505 empty (@expr14506 ) ) {
3869: out@var3002 <<@expr1073756346 "      <functionList>" <<@expr1073756347 std ::@expr14447 endl@expr14436 ;
3870: for (@expr1073756349 std ::@expr14449 list < Function > ::@expr14449 const_iterator function@var3013 =@expr1073756352 scope@var3004 .@expr14504 functionList@var3011 .@expr1073756354 begin (@expr1073756355 ) ; function@var3013 !=@expr1073756356 scope@var3004 .@expr14504 functionList@var3011 .@expr1073756358 end (@expr1073756359 ) ; ++@expr1073756360 function@var3013 ) {
3871: out@var3002 <<@expr1073756361 "        <function id=\"" <<@expr1073756362 &@expr1073756363 *@expr1073756364 function@var3013
3872: <<@expr1073756365 "\" token=\"" <<@expr1073756366 function@var3013 .@expr1073756367 token@var3014
3873: <<@expr1073756368 "\" tokenDef=\"" <<@expr1073756369 function@var3013 .@expr1073756370 tokenDef@var3015
3874: <<@expr1073756371 "\" name=\"" <<@expr1073756372 ErrorLogger ::@expr14475 toxml (@expr1073756374 function@var3013 .@expr1073756375 name (@expr1073756376 ) ) <<@expr1073756377 '\"' ;
3875: out@var3002 <<@expr14464 " type=\"" <<@expr1073756379 (@expr1073756380 function@var3013 .@expr14557 type@var3016 ==@expr1073756382 Function ::@expr1073756383 eConstructor ?@expr1073756384 "Constructor" :@expr1073756385
3876: function@var3013 .@expr14557 type@var3016 ==@expr1073756387 Function ::@expr1073756388 eCopyConstructor ?@expr1073756389 "CopyConstructor" :@expr1073756390
3877: function@var3013 .@expr14557 type@var3016 ==@expr1073756392 Function ::@expr1073756393 eMoveConstructor ?@expr1073756394 "MoveConstructor" :@expr1073756395
3878: function@var3013 .@expr14557 type@var3016 ==@expr1073756397 Function ::@expr1073756398 eOperatorEqual ?@expr1073756399 "OperatorEqual" :@expr1073756400
3879: function@var3013 .@expr14557 type@var3016 ==@expr1073756402 Function ::@expr1073756403 eDestructor ?@expr1073756404 "Destructor" :@expr1073756405
3880: function@var3013 .@expr14557 type@var3016 ==@expr1073756407 Function ::@expr1073756408 eFunction@expr1073756261 ?@expr1073756409 "Function" :@expr1073756410
3881: function@var3013 .@expr14557 type@var3016 ==@expr1073756412 Function ::@expr1073756413 eLambda ?@expr1073756414 "Lambda" :@expr1073756415
3882: "Unknown" ) <<@expr1073756416 '\"' ;
3883: if (@expr1073756417 function@var3013 .@expr1073756418 nestedIn@var3017 .@expr1073756419 definedType@var3018 ) {
3884: if (@expr1073756420 function@var3013 .@expr1073756421 hasVirtualSpecifier (@expr1073756422 ) ) {
3885: out@var3002 <<@expr1073756423 " hasVirtualSpecifier=\"true\"" ; }
3886: else { if (@expr1073756424 function@var3013 .@expr1073756425 isImplicitlyVirtual (@expr1073756426 ) ) {
3887: out@var3002 <<@expr1073756427 " isImplicitlyVirtual=\"true\"" ; } }
3888: }
3889: if (@expr1073756428 function@var3013 .@expr1073756429 isInlineKeyword (@expr1073756430 ) ) {
3890: out@var3002 <<@expr1073756431 " isInlineKeyword=\"true\"" ; }
3891: if (@expr1073756432 function@var3013 .@expr1073756433 isStatic (@expr1073756434 ) ) {
3892: out@var3002 <<@expr1073756435 " isStatic=\"true\"" ; }
3893: if (@expr1073756436 function@var3013 .@expr14613 argCount (@expr14614 ) ==@expr1073756439 0U ) {
3894: out@var3002 <<@expr14511 "/>" <<@expr14512 std ::@expr14447 endl@expr14436 ; }
3895: else {
3896: out@var3002 <<@expr1073756443 ">" <<@expr1073756444 std ::@expr14447 endl@expr14436 ;
3897: for (@expr1073756446 unsigned int argnr@var3019 =@expr1073756447 0 ; argnr@var3019 <@expr1073756448 function@var3013 .@expr14613 argCount (@expr14614 ) ; ++@expr1073756451 argnr@var3019 ) {
3898: const Variable * arg@var3020 ; arg@var3020 =@expr1073756452 function@var3013 .@expr1073756453 getArgumentVar (@expr1073756454 argnr@var3019 ) ;
3899: out@var3002 <<@expr1073756455 "          <arg nr=\"" <<@expr1073756456 argnr@var3019 +@expr1073756457 1 <<@expr1073756458 "\" variable=\"" <<@expr1073756459 arg@var3020 <<@expr1073756460 "\"/>" <<@expr1073756461 std ::@expr14447 endl@expr14436 ;
3900: variables@var3003 .@expr14639 insert (@expr1073756464 arg@var3020 ) ;
3901: }
3902: out@var3002 <<@expr1073756465 "        </function>" <<@expr1073756466 std ::@expr14447 endl@expr14436 ;
3903: }
3904: }
3905: out@var3002 <<@expr1073756468 "      </functionList>" <<@expr1073756469 std ::@expr14447 endl@expr14436 ;
3906: }
3907: if (@expr1073756471 !@expr1073756472 scope@var3004 .@expr14508 varlist@var3012 .@expr14509 empty (@expr14510 ) ) {
3908: out@var3002 <<@expr1073756476 "      <varlist>" <<@expr1073756477 std ::@expr14447 endl@expr14436 ;
3909: for (@expr1073756479 std ::@expr14449 list < Variable > ::@expr14449 const_iterator var@var3021 =@expr1073756482 scope@var3004 .@expr14508 varlist@var3012 .@expr1073756484 begin (@expr1073756485 ) ; var@var3021 !=@expr1073756486 scope@var3004 .@expr14508 varlist@var3012 .@expr1073756488 end (@expr1073756489 ) ; ++@expr1073756490 var@var3021 ) {
3910: out@var3002 <<@expr1073756491 "        <var id=\"" <<@expr1073756492 &@expr1073756493 *@expr1073756494 var@var3021 <<@expr1073756495 "\"/>" <<@expr1073756496 std ::@expr14447 endl@expr14436 ; }
3911: out@var3002 <<@expr1073756498 "      </varlist>" <<@expr1073756499 std ::@expr14447 endl@expr14436 ;
3912: }
3913: out@var3002 <<@expr1073756501 "    </scope>" <<@expr1073756502 std ::@expr14447 endl@expr14436 ;
3914: }
3915: }
3916: out@var3002 <<@expr1073756504 "  </scopes>" <<@expr1073756505 std ::@expr14447 endl@expr14436 ;
3917:
3918:
3919: for (@expr1073756507 const Variable *@expr14444 var@var3022 :@expr1073756509 mVariableList@var1406 ) {
3920: variables@var3003 .@expr14639 insert (@expr1073756511 var@var3022 ) ; }
3921: out@var3002 <<@expr1073756512 "  <variables>" <<@expr1073756513 std ::@expr14447 endl@expr14436 ;
3922: for (@expr1073756515 const Variable *@expr14444 var@var3023 :@expr1073756517 variables@var3003 ) {
3923: if (@expr1073756518 !@expr1073756519 var@var3023 ) {
3924: continue ; }
3925: out@var3002 <<@expr1073756520 "    <var id=\"" <<@expr1073756521 var@var3023 <<@expr1073756522 '\"' ;
3926: out@var3002 <<@expr1073756523 " nameToken=\"" <<@expr1073756524 var@var3023 .@expr1073756525 nameToken (@expr1073756526 ) <<@expr1073756527 '\"' ;
3927: out@var3002 <<@expr1073756528 " typeStartToken=\"" <<@expr1073756529 var@var3023 .@expr1073756530 typeStartToken (@expr1073756531 ) <<@expr1073756532 '\"' ;
3928: out@var3002 <<@expr1073756533 " typeEndToken=\"" <<@expr1073756534 var@var3023 .@expr1073756535 typeEndToken (@expr1073756536 ) <<@expr1073756537 '\"' ;
3929: out@var3002 <<@expr1073756538 " access=\"" <<@expr1073756539 accessControlToString (@expr1073756540 var@var3023 .@expr1073756541 mAccess@var3024 ) <<@expr1073756542 '\"' ;
3930: out@var3002 <<@expr1073756543 " scope=\"" <<@expr1073756544 var@var3023 .@expr1073756545 scope (@expr1073756546 ) <<@expr1073756547 '\"' ;
3931: if (@expr1073756548 var@var3023 .@expr14725 valueType (@expr14726 ) ) {
3932: out@var3002 <<@expr1073756551 " constness=\"" <<@expr1073756552 var@var3023 .@expr14725 valueType (@expr14726 ) .@expr1073756555 constness@var3853 <<@expr1073756556 '\"' ; }
3933: out@var3002 <<@expr1073756557 " isArray=\"" <<@expr1073756558 var@var3023 .@expr1073756559 isArray (@expr1073756560 ) <<@expr1073756561 '\"' ;
3934: out@var3002 <<@expr1073756562 " isClass=\"" <<@expr1073756563 var@var3023 .@expr1073756564 isClass (@expr1073756565 ) <<@expr1073756566 '\"' ;
3935: out@var3002 <<@expr1073756567 " isConst=\"" <<@expr1073756568 var@var3023 .@expr1073756569 isConst (@expr1073756570 ) <<@expr1073756571 '\"' ;
3936: out@var3002 <<@expr1073756572 " isExtern=\"" <<@expr1073756573 var@var3023 .@expr1073756574 isExtern (@expr1073756575 ) <<@expr1073756576 '\"' ;
3937: out@var3002 <<@expr1073756577 " isPointer=\"" <<@expr1073756578 var@var3023 .@expr1073756579 isPointer (@expr1073756580 ) <<@expr1073756581 '\"' ;
3938: out@var3002 <<@expr1073756582 " isReference=\"" <<@expr1073756583 var@var3023 .@expr1073756584 isReference (@expr1073756585 ) <<@expr1073756586 '\"' ;
3939: out@var3002 <<@expr1073756587 " isStatic=\"" <<@expr1073756588 var@var3023 .@expr1073756589 isStatic (@expr1073756590 ) <<@expr1073756591 '\"' ;
3940: out@var3002 <<@expr1073756592 " isVolatile=\"" <<@expr1073756593 var@var3023 .@expr1073756594 isVolatile (@expr1073756595 ) <<@expr1073756596 '\"' ;
3941: out@var3002 <<@expr14511 "/>" <<@expr14512 std ::@expr14447 endl@expr14436 ;
3942: }
3943: out@var3002 <<@expr1073756600 "  </variables>" <<@expr1073756601 std ::@expr14447 endl@expr14436 ;
3944: out@var3002 <<@expr1073756603 std ::@expr1073756604 resetiosflags (@expr1073756605 std ::@expr14441 ios ::@expr14442 boolalpha@expr14435 ) ;
3945: }
3946:
3947:
3948:
3949: static const Type * findVariableTypeIncludingUsedNamespaces ( const SymbolDatabase * symbolDatabase@var3025 , const Scope * scope@var3026 , const Token * typeTok@var3027 )
3950: {
3951: const Type * argType@var3028 ; argType@var3028 =@expr1073756608 symbolDatabase@var3025 .@expr14785 findVariableType (@expr1073756610 scope@var3026 , typeTok@var3027 ) ;
3952: if (@expr14787 argType@var3028 ) {
3953: return argType@var3028 ; }
3954:
3955:
3956: while (@expr1073756612 scope@var3026 ) {
3957: for (@expr1073756613 const Scope ::@expr1073756614 UsingInfo &@expr1073756615 ui@var3029 :@expr1073756616 scope@var3026 .@expr1073756617 usingList@var3030 ) {
3958: if (@expr1073756618 ui@var3029 .@expr14795 scope@var3031 ) {
3959: argType@var3028 =@expr1073756620 symbolDatabase@var3025 .@expr14785 findVariableType (@expr1073756622 ui@var3029 .@expr14795 scope@var3031 , typeTok@var3027 ) ;
3960: if (@expr14787 argType@var3028 ) {
3961: return argType@var3028 ; }
3962: }
3963: }
3964: scope@var3026 =@expr1073756625 scope@var3026 .@expr1073756626 nestedIn@var3032 ;
3965: }
3966: return nullptr ;
3967: }
3968:
3969:
3970:
3971: void Function :: addArguments ( const SymbolDatabase * symbolDatabase@var3033 , const Scope * scope@var3034 )
3972: {
3973:
3974: const Token * start@var3035 ; start@var3035 =@expr1073756627 arg@var1160 ?@expr1073756628 arg@var1160 :@expr1073756629 argDef@var1158 ;
3975: if (@expr1073756630 !@expr1073756631 Token ::@expr14808 simpleMatch (@expr1073756633 start@var3035 , "(" ) ) {
3976: return ; }
3977: if (@expr1073756634 !@expr1073756635 (@expr1073756636 start@var3035 &&@expr1073756637 start@var3035 .@expr1073756638 link (@expr1073756639 ) !=@expr1073756640 start@var3035 .@expr14817 next (@expr14818 ) &&@expr1073756643 !@expr1073756644 Token ::@expr14808 simpleMatch (@expr1073756646 start@var3035 , "( void )" ) ) ) {
3978: return ; }
3979:
3980: unsigned int count@var3036 ; count@var3036 =@expr1073756647 0 ;
3981:
3982: for (@expr1073756648 const Token *@expr14825 tok@var3037 =@expr1073756650 start@var3035 .@expr14817 next (@expr14818 ) ; tok@var3037 ; tok@var3037 =@expr1073756653 tok@var3037 .@expr14830 next (@expr14831 ) ) {
3983: if (@expr1073756656 Token ::@expr14833 Match (@expr1073756658 tok@var3037 , ",|)" ) ) {
3984: return ; }
3985:
3986: const Token * startTok@var3038 ; startTok@var3038 =@expr1073756659 tok@var3037 ;
3987: const Token * endTok@var3039 ; endTok@var3039 =@expr1073756660 nullptr ;
3988: const Token * nameTok@var3040 ; nameTok@var3040 =@expr1073756661 nullptr ;
3989:
3990: do {
3991: if (@expr1073756662 Token ::@expr14808 simpleMatch (@expr1073756664 tok@var3037 , "decltype (" ) ) {
3992: tok@var3037 =@expr1073756665 tok@var3037 .@expr1073756666 linkAt (@expr1073756667 1 ) .@expr1073756668 next (@expr1073756669 ) ;
3993: continue ;
3994: }
3995: if (@expr1073756670 tok@var3037 !=@expr14847 startTok@var3038 &&@expr14848 !@expr14849 nameTok@var3040 &&@expr1073756674 Token ::@expr14833 Match (@expr1073756676 tok@var3037 , "( & %var% ) [" ) ) {
3996: nameTok@var3040 =@expr1073756677 tok@var3037 .@expr14854 tokAt (@expr14855 2 ) ;
3997: endTok@var3039 =@expr1073756680 nameTok@var3040 .@expr14857 previous (@expr14858 ) ;
3998: tok@var3037 =@expr1073756683 tok@var3037 .@expr14860 link (@expr14861 ) ;
3999: } else { if (@expr1073756686 tok@var3037 !=@expr14847 startTok@var3038 &&@expr14848 !@expr14849 nameTok@var3040 &&@expr1073756690 Token ::@expr14833 Match (@expr1073756692 tok@var3037 , "( * %var% ) ( ) [,)]" ) ) {
4000: nameTok@var3040 =@expr1073756693 tok@var3037 .@expr14854 tokAt (@expr14855 2 ) ;
4001: endTok@var3039 =@expr1073756696 nameTok@var3040 .@expr14857 previous (@expr14858 ) ;
4002: tok@var3037 =@expr1073756699 tok@var3037 .@expr14860 link (@expr14861 ) .@expr1073756702 tokAt (@expr1073756703 2 ) ;
4003: } else { if (@expr1073756704 tok@var3037 !=@expr14847 startTok@var3038 &&@expr14848 !@expr14849 nameTok@var3040 &&@expr1073756708 Token ::@expr14833 Match (@expr1073756710 tok@var3037 , "( * %var% ) [" ) ) {
4004: nameTok@var3040 =@expr1073756711 tok@var3037 .@expr14854 tokAt (@expr14855 2 ) ;
4005: endTok@var3039 =@expr1073756714 nameTok@var3040 .@expr14857 previous (@expr14858 ) ;
4006: tok@var3037 =@expr1073756717 tok@var3037 .@expr14860 link (@expr14861 ) ;
4007: } else { if (@expr1073756720 tok@var3037 .@expr1073756721 varId (@expr1073756722 ) !=@expr1073756723 0 ) {
4008: nameTok@var3040 =@expr1073756724 tok@var3037 ;
4009: endTok@var3039 =@expr1073756725 tok@var3037 .@expr14902 previous (@expr14903 ) ;
4010: } else { if (@expr1073756728 tok@var3037 .@expr14905 str (@expr14906 ) ==@expr1073756731 "[" ) {
4011:
4012: tok@var3037 =@expr1073756732 tok@var3037 .@expr14860 link (@expr14861 ) ;
4013: while (@expr1073756735 tok@var3037 .@expr14830 next (@expr14831 ) .@expr1073756738 str (@expr1073756739 ) ==@expr1073756740 "[" ) {
4014: tok@var3037 =@expr1073756741 tok@var3037 .@expr14830 next (@expr14831 ) .@expr1073756744 link (@expr1073756745 ) ; }
4015: } else { if (@expr1073756746 tok@var3037 .@expr14905 str (@expr14906 ) ==@expr1073756749 "<" ) {
4016: tok@var3037 =@expr1073756750 tok@var3037 .@expr14860 link (@expr14861 ) ;
4017: if (@expr14929 !@expr14930 tok@var3037 ) {
4018: return ; }
4019: } } } } } }
4020:
4021: tok@var3037 =@expr1073756755 tok@var3037 .@expr14830 next (@expr14831 ) ;
4022:
4023: if (@expr14929 !@expr14930 tok@var3037 ) {
4024: return ; }
4025: } while (@expr1073756760 tok@var3037 .@expr14905 str (@expr14906 ) !=@expr14939 "," &&@expr14940 tok@var3037 .@expr14905 str (@expr14906 ) !=@expr14943 ")" &&@expr1073756768 tok@var3037 .@expr14905 str (@expr14906 ) !=@expr1073756771 "=" ) ;
4026:
4027: const Token * typeTok@var3041 ; typeTok@var3041 =@expr1073756772 startTok@var3038 ;
4028:
4029: while (@expr1073756773 Token ::@expr14833 Match (@expr1073756775 typeTok@var3041 , "const|volatile|enum|struct|::" ) ) {
4030: typeTok@var3041 =@expr1073756776 typeTok@var3041 .@expr1073756777 next (@expr1073756778 ) ; }
4031: if (@expr1073756779 Token ::@expr14833 Match (@expr1073756781 typeTok@var3041 , ",|)" ) ) {
4032: symbolDatabase@var3033 .@expr1073756782 mTokenizer@var3042 .@expr1073756783 syntaxError (@expr1073756784 typeTok@var3041 ) ;
4033: }
4034:
4035: while (@expr1073756785 Token ::@expr14833 Match (@expr1073756787 typeTok@var3041 , "%type% ::" ) ) {
4036: typeTok@var3041 =@expr1073756788 typeTok@var3041 .@expr1073756789 tokAt (@expr1073756790 2 ) ; }
4037:
4038:
4039: if (@expr1073756791 !@expr1073756792 endTok@var3039 ) {
4040: if (@expr1073756793 tok@var3037 .@expr14902 previous (@expr14903 ) .@expr1073756796 isName (@expr1073756797 ) &&@expr1073756798 !@expr1073756799 Token ::@expr14833 Match (@expr1073756801 tok@var3037 .@expr14854 tokAt (@expr1073756803 -1 ) , "const|volatile" ) ) {
4041: if (@expr1073756804 tok@var3037 .@expr14902 previous (@expr14903 ) !=@expr1073756807 typeTok@var3041 ) {
4042: nameTok@var3040 =@expr1073756808 tok@var3037 .@expr14902 previous (@expr14903 ) ;
4043: endTok@var3039 =@expr1073756811 nameTok@var3040 .@expr14857 previous (@expr14858 ) ;
4044:
4045: if (@expr1073756814 hasBody (@expr1073756815 ) ) {
4046: symbolDatabase@var3033 .@expr1073756816 debugMessage (@expr1073756817 nameTok@var3040 , "varid0" , "Function::addArguments found argument \'" +@expr1073756818 nameTok@var3040 .@expr1073756819 str (@expr1073756820 ) +@expr1073756821 "\' with varid 0." ) ; }
4047: } else {
4048: endTok@var3039 =@expr1073756822 typeTok@var3041 ; }
4049: } else {
4050: endTok@var3039 =@expr1073756823 tok@var3037 .@expr14902 previous (@expr14903 ) ; }
4051: }
4052:
4053: const ::@expr1073756826 Type * argType@var3043 ; argType@var3043 =@expr1073756827 nullptr ;
4054: if (@expr1073756828 !@expr1073756829 typeTok@var3041 .@expr1073756830 isStandardType (@expr1073756831 ) ) {
4055: argType@var3043 =@expr1073756832 findVariableTypeIncludingUsedNamespaces (@expr1073756833 symbolDatabase@var3033 , scope@var3034 , typeTok@var3041 ) ;
4056:
4057:
4058: const_cast < Token *@expr14825 > (@expr1073756835 typeTok@var3041 ) .@expr1073756836 type (@expr1073756837 argType@var3043 ) ;
4059: }
4060:
4061:
4062: if (@expr1073756838 tok@var3037 .@expr14905 str (@expr14906 ) ==@expr1073756841 "=" ) {
4063: do {
4064: if (@expr1073756842 tok@var3037 .@expr14860 link (@expr14861 ) &&@expr1073756845 Token ::@expr14833 Match (@expr1073756847 tok@var3037 , "[{[(<]" ) ) {
4065: tok@var3037 =@expr1073756848 tok@var3037 .@expr14860 link (@expr14861 ) ; }
4066: tok@var3037 =@expr1073756851 tok@var3037 .@expr14830 next (@expr14831 ) ;
4067: } while (@expr1073756854 tok@var3037 .@expr14905 str (@expr14906 ) !=@expr14939 "," &&@expr14940 tok@var3037 .@expr14905 str (@expr14906 ) !=@expr14943 ")" ) ;
4068: }
4069:
4070:
4071: while (@expr1073756862 Token ::@expr14833 Match (@expr1073756864 startTok@var3038 , "enum|struct|const|volatile" ) ) {
4072: startTok@var3038 =@expr1073756865 startTok@var3038 .@expr1073756866 next (@expr1073756867 ) ; }
4073:
4074: if (@expr1073756868 startTok@var3038 ==@expr1073756869 nameTok@var3040 ) {
4075: break ; }
4076:
4077: argumentList@var1165 .@expr1073756870 emplace_back (@expr1073756871 nameTok@var3040 , startTok@var3038 , endTok@var3039 , count@var3036 ++@expr1073756872 , AccessControl ::@expr1073756873 Argument , argType@var3043 , functionScope@var1163 , symbolDatabase@var3033 .@expr1073756874 mSettings@var3044 ) ;
4078:
4079: if (@expr1073756875 tok@var3037 .@expr14905 str (@expr14906 ) ==@expr1073756878 ")" ) {
4080:
4081: if (@expr1073756879 Token ::@expr14808 simpleMatch (@expr1073756881 endTok@var3039 , "..." ) ) {
4082: isVariadic (@expr1073756882 true ) ; }
4083:
4084: break ;
4085: }
4086: }
4087:
4088:
4089: for (@expr1073756883 const Token *@expr14825 tok@var3045 =@expr1073756885 argDef@var1158 .@expr1073756886 next (@expr1073756887 ) ; tok@var3045 &&@expr1073756888 tok@var3045 !=@expr1073756889 argDef@var1158 .@expr1073756890 link (@expr1073756891 ) ; tok@var3045 =@expr1073756892 tok@var3045 .@expr15069 next (@expr15070 ) ) {
4090: if (@expr1073756895 tok@var3045 .@expr1073756896 str (@expr1073756897 ) ==@expr1073756898 "=" ) {
4091: initArgCount@var1166 ++@expr1073756899 ;
4092: if (@expr1073756900 tok@var3045 .@expr1073756901 strAt (@expr1073756902 1 ) ==@expr1073756903 "[" ) {
4093: const Token * lambdaStart@var3046 ; lambdaStart@var3046 =@expr1073756904 tok@var3045 .@expr15069 next (@expr15070 ) ;
4094: tok@var3045 =@expr1073756907 findLambdaEndToken (@expr1073756908 lambdaStart@var3046 ) ;
4095: if (@expr1073756909 !@expr1073756910 tok@var3045 ) {
4096: throw InternalError (@expr1073756911 lambdaStart@var3046 , "Analysis failed (lambda not recognized). If the code is valid then please report this failure." , InternalError ::@expr1073756912 INTERNAL ) ; }
4097: }
4098: }
4099: }
4100: }
4101:
4102: bool Function :: isImplicitlyVirtual ( bool defaultVal@var3047 ) const
4103: {
4104: if (@expr1073756913 hasVirtualSpecifier (@expr1073756914 ) ) {
4105: return true ; }
4106: if (@expr1073756915 hasOverrideSpecifier (@expr1073756916 ) ) {
4107: return true ; }
4108: bool foundAllBaseClasses@var3048 ; foundAllBaseClasses@var3048 =@expr1073756917 true ;
4109: if (@expr1073756918 getOverriddenFunction (@expr1073756919 &@expr1073756920 foundAllBaseClasses@var3048 ) ) {
4110: return true ; }
4111: if (@expr1073756921 foundAllBaseClasses@var3048 ) {
4112: return false ; }
4113: return defaultVal@var3047 ;
4114: }
4115:
4116: std :: vector < const Function * > Function :: getOverloadedFunctions ( ) const
4117: {
4118: std ::@expr1073756922 vector < const Function *@expr15099 > result@var3049 ;
4119: const Scope * scope@var3050 ; scope@var3050 =@expr1073756924 nestedIn@var1164 ;
4120:
4121: while (@expr1073756925 scope@var3050 ) {
4122: const bool isMemberFunction@var3051 =@expr1073756926 scope@var3050 .@expr1073756927 isClassOrStruct (@expr1073756928 ) &&@expr1073756929 !@expr1073756930 isStatic (@expr1073756931 ) ;
4123: for (@expr1073756932 std ::@expr15109 multimap < std ::@expr15109 string , const Function *@expr15099 > ::@expr15109 const_iterator it@var3052 =@expr1073756937 scope@var3050 .@expr15114 functionMap@var3053 .@expr1073756939 find (@expr1073756940 tokenDef@var1157 .@expr15117 str (@expr15118 ) ) ;
4124: it@var3052 !=@expr1073756943 scope@var3050 .@expr15114 functionMap@var3053 .@expr1073756945 end (@expr1073756946 ) &&@expr1073756947 it@var3052 .@expr1073756948 first@var3054 ==@expr1073756949 tokenDef@var1157 .@expr15117 str (@expr15118 ) ;
4125: ++@expr1073756952 it@var3052 ) {
4126: const Function * func@var3055 ; func@var3055 =@expr1073756953 it@var3052 .@expr1073756954 second@var3056 ;
4127: if (@expr1073756955 isMemberFunction@var3051 ==@expr1073756956 func@var3055 .@expr1073756957 isStatic (@expr1073756958 ) ) {
4128: continue ; }
4129: result@var3049 .@expr1073756959 push_back (@expr1073756960 func@var3055 ) ;
4130: }
4131: if (@expr1073756961 isMemberFunction@var3051 ) {
4132: break ; }
4133: scope@var3050 =@expr1073756962 scope@var3050 .@expr1073756963 nestedIn@var3057 ;
4134: }
4135:
4136: return result@var3049 ;
4137: }
4138:
4139: const Function * Function :: getOverriddenFunction ( bool * foundAllBaseClasses@var3058 ) const
4140: {
4141: if (@expr1073756964 foundAllBaseClasses@var3058 ) {
4142: *@expr1073756965 foundAllBaseClasses@var3058 =@expr1073756966 true ; }
4143: if (@expr1073756967 !@expr1073756968 nestedIn@var1164 .@expr1073756969 isClassOrStruct (@expr1073756970 ) ) {
4144: return nullptr ; }
4145: return getOverriddenFunctionRecursive (@expr1073756971 nestedIn@var1164 .@expr1073756972 definedType@var3806 , foundAllBaseClasses@var3058 ) ;
4146: }
4147:
4148: const Function * Function :: getOverriddenFunctionRecursive ( const :: Type * baseType@var3059 , bool * foundAllBaseClasses@var3060 ) const
4149: {
4150:
4151: for (@expr1073756973 const ::@expr15150 Type ::@expr15150 BaseInfo &@expr1073756976 i@var3061 :@expr1073756977 baseType@var3059 .@expr1073756978 derivedFrom@var3062 ) {
4152: const ::@expr1073756979 Type * derivedFromType@var3063 ; derivedFromType@var3063 =@expr1073756980 i@var3061 .@expr1073756981 type@var3064 ;
4153:
4154: if (@expr1073756982 !@expr1073756983 derivedFromType@var3063 ||@expr1073756984 !@expr1073756985 derivedFromType@var3063 .@expr15162 classScope@var3065 ) {
4155: if (@expr1073756987 foundAllBaseClasses@var3060 ) {
4156: *@expr1073756988 foundAllBaseClasses@var3060 =@expr1073756989 false ; }
4157: continue ;
4158: }
4159:
4160: const Scope * parent@var3066 ; parent@var3066 =@expr1073756990 derivedFromType@var3063 .@expr15162 classScope@var3065 ;
4161:
4162:
4163: for (@expr1073756992 std ::@expr15150 multimap < std ::@expr15150 string , const Function *@expr1073756995 > ::@expr15150 const_iterator it@var3067 =@expr1073756997 parent@var3066 .@expr15174 functionMap@var3068 .@expr1073756999 find (@expr1073757000 tokenDef@var1157 .@expr15177 str (@expr15178 ) ) ; it@var3067 !=@expr1073757003 parent@var3066 .@expr15174 functionMap@var3068 .@expr1073757005 end (@expr1073757006 ) &&@expr1073757007 it@var3067 .@expr1073757008 first@var3069 ==@expr1073757009 tokenDef@var1157 .@expr15177 str (@expr15178 ) ; ++@expr1073757012 it@var3067 ) {
4164: const Function * func@var3070 ; func@var3070 =@expr1073757013 it@var3067 .@expr1073757014 second@var3071 ;
4165: if (@expr1073757015 func@var3070 .@expr1073757016 hasVirtualSpecifier (@expr1073757017 ) ) {
4166: const Token * temp1@var3072 ; temp1@var3072 =@expr1073757018 func@var3070 .@expr1073757019 tokenDef@var3073 .@expr1073757020 previous (@expr1073757021 ) ;
4167: const Token * temp2@var3074 ; temp2@var3074 =@expr1073757022 tokenDef@var1157 .@expr1073757023 previous (@expr1073757024 ) ;
4168: bool match@var3075 ; match@var3075 =@expr1073757025 true ;
4169:
4170:
4171: while (@expr1073757026 temp1@var3072 .@expr15203 str (@expr15204 ) !=@expr1073757029 "virtual" ) {
4172: if (@expr1073757030 temp1@var3072 .@expr15203 str (@expr15204 ) !=@expr1073757033 temp2@var3074 .@expr15210 str (@expr15211 ) &&@expr1073757036
4173: !@expr1073757037 (@expr1073757038 temp1@var3072 .@expr15203 str (@expr15204 ) ==@expr1073757041 derivedFromType@var3063 .@expr1073757042 name (@expr1073757043 ) &&@expr1073757044
4174: temp2@var3074 .@expr15210 str (@expr15211 ) ==@expr1073757047 baseType@var3059 .@expr1073757048 name (@expr1073757049 ) ) ) {
4175: match@var3075 =@expr1073757050 false ;
4176: break ;
4177: }
4178:
4179: temp1@var3072 =@expr1073757051 temp1@var3072 .@expr1073757052 previous (@expr1073757053 ) ;
4180: temp2@var3074 =@expr1073757054 temp2@var3074 .@expr1073757055 previous (@expr1073757056 ) ;
4181: }
4182:
4183:
4184: match@var3075 =@expr1073757057 match@var3075 &&@expr1073757058 argsMatch (@expr1073757059 baseType@var3059 .@expr1073757060 classScope@var3076 , func@var3070 .@expr1073757061 argDef@var3077 , argDef@var1158 , emptyString@var1 , 0 ) ;
4185:
4186:
4187: match@var3075 =@expr1073757062 match@var3075
4188: &&@expr1073757063 isConst (@expr1073757064 ) ==@expr1073757065 func@var3070 .@expr1073757066 isConst (@expr1073757067 )
4189: &&@expr1073757068 isVolatile (@expr1073757069 ) ==@expr1073757070 func@var3070 .@expr1073757071 isVolatile (@expr1073757072 )
4190: &&@expr1073757073 hasRvalRefQualifier (@expr1073757074 ) ==@expr1073757075 func@var3070 .@expr1073757076 hasRvalRefQualifier (@expr1073757077 )
4191: &&@expr1073757078 hasLvalRefQualifier (@expr1073757079 ) ==@expr1073757080 func@var3070 .@expr1073757081 hasLvalRefQualifier (@expr1073757082 ) ;
4192:
4193:
4194: if (@expr1073757083 match@var3075 ) {
4195: return func@var3070 ;
4196: }
4197: }
4198: }
4199:
4200: if (@expr1073757084 !@expr1073757085 derivedFromType@var3063 .@expr1073757086 derivedFrom@var3078 .@expr1073757087 empty (@expr1073757088 ) &&@expr1073757089 !@expr1073757090 derivedFromType@var3063 .@expr1073757091 hasCircularDependencies (@expr1073757092 ) ) {
4201:
4202:
4203: const Function * func@var3079 ; func@var3079 =@expr1073757093 getOverriddenFunctionRecursive (@expr1073757094 derivedFromType@var3063 , foundAllBaseClasses@var3060 ) ;
4204: if (@expr1073757095 func@var3079 ) {
4205: return func@var3079 ;
4206: }
4207: }
4208: }
4209: return nullptr ;
4210: }
4211:
4212: const Variable * Function :: getArgumentVar ( int num@var3080 ) const
4213: {
4214: for (@expr1073757096 std ::@expr15273 list < Variable > ::@expr15273 const_iterator i@var3081 =@expr1073757099 argumentList@var1165 .@expr1073757100 begin (@expr1073757101 ) ; i@var3081 !=@expr1073757102 argumentList@var1165 .@expr1073757103 end (@expr1073757104 ) ; ++@expr1073757105 i@var3081 ) {
4215: if (@expr1073757106 i@var3081 .@expr15283 index (@expr15284 ) ==@expr1073757109 num@var3080 ) {
4216: return (@expr1073757110 &@expr1073757111 *@expr1073757112 i@var3081 ) ; }
4217: else { if (@expr1073757113 i@var3081 .@expr15283 index (@expr15284 ) >@expr1073757116 num@var3080 ) {
4218: return nullptr ; } }
4219: }
4220: return nullptr ;
4221: }
4222:
|
4225:
4226: Scope :: Scope ( const SymbolDatabase * check_@var3082 , const Token * classDef_@var3083 , const Scope * nestedIn_@var3084 , ScopeType type_@var3085 , const Token * start_@var3086 ) :
4227: check@var1220 ( check_@var3082 ) ,
4228: classDef@var1222 ( classDef_@var3083 ) ,
4229: nestedIn@var1228 ( nestedIn_@var3084 ) ,
4230: numConstructors@var1230 ( 0 ) ,
4231: numCopyOrMoveConstructors@var1231 ( 0 ) ,
4232: type@var1233 ( type_@var3085 ) ,
4233: definedType@var1234 ( nullptr ) ,
4234: functionOf@var1237 ( nullptr ) ,
4235: function@var1238 ( nullptr ) ,
4236: enumType@var1239 ( nullptr ) ,
4237: enumClass@var1240 ( false )
4238: {
4239: setBodyStartEnd (@expr1073757117 start_@var3086 ) ;
4240: }
4241:
4242: Scope :: Scope ( const SymbolDatabase * check_@var3087 , const Token * classDef_@var3088 , const Scope * nestedIn_@var3089 ) :
4243: check@var1220 ( check_@var3087 ) ,
4244: classDef@var1222 ( classDef_@var3088 ) ,
4245: bodyStart@var1223 ( nullptr ) ,
4246: bodyEnd@var1224 ( nullptr ) ,
4247: nestedIn@var1228 ( nestedIn_@var3089 ) ,
4248: numConstructors@var1230 ( 0 ) ,
4249: numCopyOrMoveConstructors@var1231 ( 0 ) ,
4250: definedType@var1234 ( nullptr ) ,
4251: functionOf@var1237 ( nullptr ) ,
4252: function@var1238 ( nullptr ) ,
4253: enumType@var1239 ( nullptr ) ,
4254: enumClass@var1240 ( false )
4255: {
4256: const Token * nameTok@var3090 ; nameTok@var3090 =@expr1073757119 classDef@var1222 ;
4257: if (@expr1073757120 !@expr1073757121 classDef@var1222 ) {
4258: type@var1233 =@expr1073757122 Scope ::@expr1073757123 eGlobal ;
4259: } else { if (@expr1073757124 classDef@var1222 .@expr15301 str (@expr15302 ) ==@expr1073757127 "class" &&@expr1073757128 check@var1220 &&@expr1073757129 check@var1220 .@expr1073757130 isCPP (@expr1073757131 ) ) {
4260: type@var1233 =@expr1073757132 Scope ::@expr1073757133 eClass ;
4261: nameTok@var3090 =@expr1073757134 nameTok@var3090 .@expr15311 next (@expr15312 ) ;
4262: } else { if (@expr1073757137 classDef@var1222 .@expr15301 str (@expr15302 ) ==@expr1073757140 "struct" ) {
4263: type@var1233 =@expr1073757141 Scope ::@expr1073757142 eStruct ;
4264: nameTok@var3090 =@expr1073757143 nameTok@var3090 .@expr15311 next (@expr15312 ) ;
4265: } else { if (@expr1073757146 classDef@var1222 .@expr15301 str (@expr15302 ) ==@expr1073757149 "union" ) {
4266: type@var1233 =@expr1073757150 Scope ::@expr1073757151 eUnion ;
4267: nameTok@var3090 =@expr1073757152 nameTok@var3090 .@expr15311 next (@expr15312 ) ;
4268: } else { if (@expr1073757155 classDef@var1222 .@expr15301 str (@expr15302 ) ==@expr1073757158 "namespace" ) {
4269: type@var1233 =@expr1073757159 Scope ::@expr1073757160 eNamespace ;
4270: nameTok@var3090 =@expr1073757161 nameTok@var3090 .@expr15311 next (@expr15312 ) ;
4271: } else { if (@expr1073757164 classDef@var1222 .@expr15301 str (@expr15302 ) ==@expr1073757167 "enum" ) {
4272: type@var1233 =@expr1073757168 Scope ::@expr15345 eEnum ;
4273: nameTok@var3090 =@expr1073757170 nameTok@var3090 .@expr15311 next (@expr15312 ) ;
4274: if (@expr1073757173 nameTok@var3090 .@expr15350 str (@expr15351 ) ==@expr1073757176 "class" ) {
4275: enumClass@var1240 =@expr1073757177 true ;
4276: nameTok@var3090 =@expr1073757178 nameTok@var3090 .@expr15311 next (@expr15312 ) ;
4277: }
4278: } else { if (@expr1073757181 classDef@var1222 .@expr15301 str (@expr15302 ) ==@expr1073757184 "[" ) {
4279: type@var1233 =@expr1073757185 Scope ::@expr1073757186 eLambda ;
4280: } else {
4281: type@var1233 =@expr1073757187 Scope ::@expr1073757188 eFunction@expr1073757118 ;
4282: } } } } } } }
4283:
4284: nameTok@var3090 =@expr1073757189 skipScopeIdentifiers (@expr1073757190 nameTok@var3090 ) ;
4285: if (@expr1073757191 nameTok@var3090 &&@expr1073757192 (@expr1073757193 (@expr1073757194 type@var1233 ==@expr1073757195 Scope ::@expr15345 eEnum &&@expr1073757197 Token ::@expr1073757198 Match (@expr1073757199 nameTok@var3090 , ":|{" ) ) ||@expr1073757200 nameTok@var3090 .@expr15350 str (@expr15351 ) !=@expr1073757203 "{" ) ) {
4286: className@var1221 =@expr1073757204 nameTok@var3090 .@expr15350 str (@expr15351 ) ; }
4287: }
4288:
4289: bool Scope :: hasDefaultConstructor ( ) const
4290: {
4291: if (@expr1073757207 numConstructors@var1230 ) {
4292: std ::@expr1073757208 list < Function > ::@expr1073757209 const_iterator func@var3091 ;
4293:
4294: for (@expr1073757210 func@var3091 =@expr1073757211 functionList@var1225 .@expr1073757212 begin (@expr1073757213 ) ; func@var3091 !=@expr1073757214 functionList@var1225 .@expr1073757215 end (@expr1073757216 ) ; ++@expr1073757217 func@var3091 ) {
4295: if (@expr1073757218 func@var3091 .@expr1073757219 type@var3092 ==@expr1073757220 Function ::@expr1073757221 eConstructor &&@expr1073757222 func@var3091 .@expr1073757223 argCount (@expr1073757224 ) ==@expr1073757225 0 ) {
4296: return true ; }
4297: }
4298: }
4299: return false ;
4300: }
4301:
4302: AccessControl Scope :: defaultAccess ( ) const
4303: {
4304: switch (@expr1073757228 type@var1233 ) {
4305: case eGlobal :@expr15405 ;
4306: return AccessControl ::@expr1073757230 Global ;
4307: case eClass :@expr15405 ;
4308: return AccessControl ::@expr1073757232 Private ;
4309: case eStruct :@expr15405 ;
4310: return AccessControl ::@expr15410 Public@expr15402 ;
4311: case eUnion :@expr15405 ;
4312: return AccessControl ::@expr15410 Public@expr15402 ;
4313: case eNamespace :@expr15405 ;
4314: return AccessControl ::@expr1073757238 Namespace ;
4315: default :@expr15405 ;
4316: return AccessControl ::@expr1073757240 Local@expr1073757227 ;
4317: }
4318: }
4319:
4320: void Scope :: addVariable ( const Token * token_@var3093 , const Token * start_@var3094 , const Token * end_@var3095 ,
4321: AccessControl access_@var3096 , const Type * type_@var3097 , const Scope * scope_@var3098 , const Settings * settings@var3099 )
4322: {
4323:
4324:
4325: const int varIndex@var3100 =@expr1073757241 varlist@var1227 .@expr1073757242 size (@expr1073757243 ) ;
4326: varlist@var1227 .@expr1073757244 emplace_back (@expr1073757245 token_@var3093 , start_@var3094 , end_@var3095 , varIndex@var3100 , access_@var3096 , type_@var3097 , scope_@var3098 , settings@var3099 ) ;
4327: }
4328:
4329:
4330: void Scope :: getVariableList ( const Settings * settings@var3101 )
4331: {
4332: if (@expr1073757246 !@expr1073757247 bodyStartList@var1236 .@expr1073757248 empty (@expr1073757249 ) ) {
4333: for (@expr1073757250 const Token *@expr1073757251 bs@var3102 :@expr1073757252 bodyStartList@var1236 ) {
4334: getVariableList (@expr1073757253 settings@var3101 , bs@var3102 .@expr1073757254 next (@expr1073757255 ) , bs@var3102 .@expr1073757256 link (@expr1073757257 ) ) ; }
4335: }
4336:
4337:
4338: else { if (@expr1073757258 type@var1233 ==@expr1073757259 Scope ::@expr1073757260 eGlobal ) {
4339: getVariableList (@expr1073757261 settings@var3101 , check@var1220 .@expr1073757262 mTokenizer@var3807 .@expr1073757263 tokens (@expr1073757264 ) , nullptr ) ; }
4340:
4341:
4342: else {
4343: return ; } }
4344: }
4345:
4346: void Scope :: getVariableList ( const Settings * settings@var3103 , const Token * start@var3104 , const Token * end@var3105 )
4347: {
4348:
4349: if (@expr1073757266 Token ::@expr15443 Match (@expr1073757268 classDef@var1222 , "if|while ( %type%" ) &&@expr1073757269 Token ::@expr15446 simpleMatch (@expr1073757271 classDef@var1222 .@expr1073757272 next (@expr1073757273 ) .@expr1073757274 astOperand2 (@expr1073757275 ) , "=" ) ) {
4350: checkVariable (@expr1073757276 classDef@var1222 .@expr1073757277 tokAt (@expr1073757278 2 ) , defaultAccess (@expr15455 ) , settings@var3103 ) ;
4351: }
4352:
4353: AccessControl varaccess@var3106 ; varaccess@var3106 =@expr1073757280 defaultAccess (@expr15455 ) ;
4354: for (@expr1073757282 const Token *@expr1073757283 tok@var3107 =@expr1073757284 start@var3104 ; tok@var3107 &&@expr1073757285 tok@var3107 !=@expr1073757286 end@var3105 ; tok@var3107 =@expr1073757287 tok@var3107 .@expr15464 next (@expr15465 ) ) {
4355:
4356: if (@expr1073757290 tok@var3107 .@expr15464 next (@expr15465 ) ==@expr1073757293 nullptr ) {
4357: break ; }
4358:
4359:
4360: else { if (@expr15470 tok@var3107 .@expr15471 str (@expr15472 ) ==@expr15473 "{" ) {
4361:
4362: tok@var3107 =@expr1073757298 tok@var3107 .@expr15475 link (@expr15476 ) ;
4363: continue ;
4364: }
4365:
4366:
4367: else { if (@expr1073757301 tok@var3107 .@expr15478 isKeyword (@expr15479 ) &&@expr1073757304 Token ::@expr15443 Match (@expr1073757306 tok@var3107 , "class|struct|union|namespace %type% :|{" ) ) {
4368: tok@var3107 =@expr1073757307 tok@var3107 .@expr15484 tokAt (@expr15485 2 ) ;
4369: while (@expr1073757310 tok@var3107 &&@expr1073757311 tok@var3107 .@expr15471 str (@expr15472 ) !=@expr1073757314 "{" ) {
4370: tok@var3107 =@expr1073757315 tok@var3107 .@expr15464 next (@expr15465 ) ; }
4371: if (@expr15494 tok@var3107 ) {
4372:
4373: tok@var3107 =@expr1073757319 tok@var3107 .@expr15475 link (@expr15476 ) ;
4374: continue ;
4375: } else {
4376: break ; }
4377: } else { if (@expr1073757322 tok@var3107 .@expr15478 isKeyword (@expr15479 ) &&@expr1073757325 Token ::@expr15443 Match (@expr1073757327 tok@var3107 , "struct|union {" ) ) {
4378: if (@expr1073757328 Token ::@expr15443 Match (@expr1073757330 tok@var3107 .@expr15464 next (@expr15465 ) .@expr15509 link (@expr15510 ) , "} %name% ;|[" ) ) {
4379: tok@var3107 =@expr1073757335 tok@var3107 .@expr15464 next (@expr15465 ) .@expr15509 link (@expr15510 ) .@expr1073757340 tokAt (@expr1073757341 2 ) ;
4380: continue ;
4381: } else { if (@expr1073757342 Token ::@expr15446 simpleMatch (@expr1073757344 tok@var3107 .@expr15464 next (@expr15465 ) .@expr15509 link (@expr15510 ) , "} ;" ) ) {
4382: tok@var3107 =@expr1073757349 tok@var3107 .@expr15464 next (@expr15465 ) ;
4383: continue ;
4384: } }
4385: }
4386:
4387:
4388:
4389: else { if (@expr1073757352 tok@var3107 .@expr15471 str (@expr15472 ) ==@expr1073757355 "__published:" ) {
4390: for (@expr1073757356 ; tok@var3107 ; tok@var3107 =@expr1073757357 tok@var3107 .@expr15464 next (@expr15465 ) ) {
4391: if (@expr15470 tok@var3107 .@expr15471 str (@expr15472 ) ==@expr15473 "{" ) {
4392: tok@var3107 =@expr1073757364 tok@var3107 .@expr15475 link (@expr15476 ) ; }
4393: if (@expr1073757367 Token ::@expr15443 Match (@expr1073757369 tok@var3107 .@expr15464 next (@expr15465 ) , "private:|protected:|public:" ) ) {
4394: break ; }
4395: }
4396: if (@expr15494 tok@var3107 ) {
4397: continue ; }
4398: else {
4399: break ; }
4400: }
4401:
4402:
4403: else { if (@expr1073757373 tok@var3107 .@expr15471 str (@expr15472 ) ==@expr1073757376 "public:" ) {
4404: varaccess@var3106 =@expr1073757377 AccessControl ::@expr1073757378 Public@expr1073757265 ;
4405: continue ;
4406: } else { if (@expr1073757379 tok@var3107 .@expr15471 str (@expr15472 ) ==@expr1073757382 "protected:" ) {
4407: varaccess@var3106 =@expr1073757383 AccessControl ::@expr1073757384 Protected ;
4408: continue ;
4409: } else { if (@expr1073757385 tok@var3107 .@expr15471 str (@expr15472 ) ==@expr1073757388 "private:" ) {
4410: varaccess@var3106 =@expr1073757389 AccessControl ::@expr1073757390 Private ;
4411: continue ;
4412: }
4413:
4414:
4415: else { if (@expr1073757391 tok@var3107 .@expr15478 isKeyword (@expr15479 ) &&@expr1073757394 Token ::@expr15443 Match (@expr1073757396 tok@var3107 , "class|struct|union %name% ;" ) ) {
4416: tok@var3107 =@expr1073757397 tok@var3107 .@expr15484 tokAt (@expr15485 2 ) ;
4417: continue ;
4418: }
4419:
4420:
4421: else { if (@expr1073757400 tok@var3107 .@expr15471 str (@expr15472 ) ==@expr1073757403 "__property" ) {
4422: continue ; }
4423:
4424:
4425: else { if (@expr1073757404 tok@var3107 .@expr15478 isKeyword (@expr15479 ) &&@expr1073757407 Token ::@expr15443 Match (@expr1073757409 tok@var3107 , "return|delete|goto" ) ) {
4426: while (@expr1073757410 tok@var3107 .@expr15464 next (@expr15465 ) &&@expr1073757413
4427: tok@var3107 .@expr15464 next (@expr15465 ) .@expr15592 str (@expr15593 ) !=@expr1073757418 ";" &&@expr1073757419
4428: tok@var3107 .@expr15464 next (@expr15465 ) .@expr15592 str (@expr15593 ) !=@expr1073757424 "}" ) {
4429: tok@var3107 =@expr1073757425 tok@var3107 .@expr15464 next (@expr15465 ) ;
4430: }
4431: continue ;
4432: } } } } } } } } } } }
4433:
4434:
4435: if (@expr1073757428 tok@var3107 .@expr15478 isKeyword (@expr15479 ) &&@expr1073757431 Token ::@expr15443 Match (@expr1073757433 tok@var3107 , "case|default" ) ) {
4436: while (@expr1073757434 tok@var3107 .@expr15464 next (@expr15465 ) &&@expr1073757437 !@expr1073757438 Token ::@expr15443 Match (@expr1073757440 tok@var3107 .@expr15464 next (@expr15465 ) , "[:;{}]" ) ) {
4437: tok@var3107 =@expr1073757443 tok@var3107 .@expr15464 next (@expr15465 ) ; }
4438: continue ;
4439: }
4440:
4441:
4442: else { if (@expr1073757446 tok@var3107 .@expr15623 previous (@expr15624 ) &&@expr1073757449 !@expr1073757450 Token ::@expr15443 Match (@expr1073757452 tok@var3107 .@expr15623 previous (@expr15624 ) , ";|{|}|public:|protected:|private:" ) ) {
4443: continue ; }
4444: else { if (@expr1073757455 tok@var3107 .@expr15471 str (@expr15472 ) ==@expr1073757458 ";" ) {
4445: continue ; } } }
4446:
4447: tok@var3107 =@expr1073757459 checkVariable (@expr1073757460 tok@var3107 , varaccess@var3106 , settings@var3103 ) ;
4448:
4449: if (@expr1073757461 !@expr1073757462 tok@var3107 ) {
4450: break ; }
4451: }
4452: }
4453:
4454: const Token * Scope :: checkVariable ( const Token * tok@var3108 , AccessControl varaccess@var3109 , const Settings * settings@var3110 )
4455: {
4456:
4457: if (@expr1073757463 tok@var3108 .@expr15640 isKeyword (@expr15641 ) &&@expr1073757466 Token ::@expr15643 Match (@expr1073757468 tok@var3108 , "throw %any% (" ) &&@expr1073757469
4458: Token ::@expr15646 simpleMatch (@expr1073757471 tok@var3108 .@expr15648 linkAt (@expr15649 2 ) , ") ;" ) ) {
4459: return tok@var3108 .@expr15648 linkAt (@expr15649 2 ) ;
4460: }
4461:
4462: if (@expr1073757476 tok@var3108 .@expr15640 isKeyword (@expr15641 ) &&@expr1073757479 Token ::@expr15643 Match (@expr1073757481 tok@var3108 , "throw %any% :: %any% (" ) &&@expr1073757482
4463: Token ::@expr15646 simpleMatch (@expr1073757484 tok@var3108 .@expr15648 linkAt (@expr15662 4 ) , ") ;" ) ) {
4464: return tok@var3108 .@expr15648 linkAt (@expr15662 4 ) ;
4465: }
4466:
4467:
4468: if (@expr1073757489 tok@var3108 .@expr15640 isKeyword (@expr15641 ) &&@expr1073757492 Token ::@expr15643 Match (@expr1073757494 tok@var3108 , "friend %type%" ) &&@expr1073757495 tok@var3108 .@expr15672 next (@expr15673 ) .@expr1073757498 varId (@expr1073757499 ) ==@expr1073757500 0 ) {
4469: const Token * next@var3111 ; next@var3111 =@expr1073757501 Token ::@expr1073757502 findmatch (@expr1073757503 tok@var3108 .@expr1073757504 tokAt (@expr1073757505 2 ) , ";|{" ) ;
4470: if (@expr1073757506 next@var3111 &&@expr1073757507 next@var3111 .@expr1073757508 str (@expr1073757509 ) ==@expr1073757510 "{" ) {
4471: next@var3111 =@expr1073757511 next@var3111 .@expr1073757512 link (@expr1073757513 ) ; }
4472: return next@var3111 ;
4473: }
4474:
4475:
4476: while (@expr1073757514 tok@var3108 .@expr15640 isKeyword (@expr15641 ) &&@expr1073757517 Token ::@expr15643 Match (@expr1073757519 tok@var3108 , "const|constexpr|volatile|static|mutable|extern" ) ) {
4477: tok@var3108 =@expr1073757520 tok@var3108 .@expr15672 next (@expr15673 ) ;
4478: }
4479:
4480:
4481: const Token * typestart@var3112 ; typestart@var3112 =@expr1073757523 tok@var3108 ;
4482:
4483:
4484: if (@expr1073757524 settings@var3110 .@expr1073757525 standards@var3113 .@expr1073757526 cpp@var3114 >=@expr1073757527 Standards ::@expr1073757528 CPP17 &&@expr1073757529 Token ::@expr15643 Match (@expr1073757531 tok@var3108 , "auto &|&&| [" ) ) {
4485: const Token * typeend@var3115 ; typeend@var3115 =@expr1073757532 Token ::@expr1073757533 findsimplematch (@expr1073757534 typestart@var3112 , "[" ) .@expr1073757535 previous (@expr1073757536 ) ;
4486: for (@expr1073757537 tok@var3108 =@expr1073757538 typeend@var3115 .@expr1073757539 tokAt (@expr1073757540 2 ) ; Token ::@expr15643 Match (@expr1073757542 tok@var3108 , "%name%|," ) ; tok@var3108 =@expr1073757543 tok@var3108 .@expr15672 next (@expr15673 ) ) {
4487: if (@expr1073757546 tok@var3108 .@expr1073757547 varId (@expr1073757548 ) ) {
4488: addVariable (@expr1073757549 tok@var3108 , typestart@var3112 , typeend@var3115 , varaccess@var3109 , nullptr , this@expr15726 , settings@var3110 ) ; }
4489: }
4490: return typeend@var3115 .@expr1073757551 linkAt (@expr1073757552 1 ) ;
4491: }
4492:
4493: if (@expr1073757553 tok@var3108 .@expr15640 isKeyword (@expr15641 ) &&@expr1073757556 Token ::@expr15643 Match (@expr1073757558 tok@var3108 , "class|struct|union|enum" ) ) {
4494: tok@var3108 =@expr1073757559 tok@var3108 .@expr15672 next (@expr15673 ) ;
4495: }
4496:
4497:
4498: const Token * vartok@var3116 ; vartok@var3116 =@expr1073757562 nullptr ;
4499: const Token * typetok@var3117 ; typetok@var3117 =@expr1073757563 nullptr ;
4500:
4501: if (@expr1073757564 tok@var3108 &&@expr1073757565 isVariableDeclaration (@expr1073757566 tok@var3108 , vartok@var3116 , typetok@var3117 ) ) {
4502:
4503: tok@var3108 =@expr1073757567 vartok@var3116 .@expr1073757568 next (@expr1073757569 ) ;
4504: while (@expr1073757570 Token ::@expr15643 Match (@expr1073757572 tok@var3108 , "[|{" ) ) {
4505: tok@var3108 =@expr1073757573 tok@var3108 .@expr1073757574 link (@expr1073757575 ) .@expr1073757576 next (@expr1073757577 ) ; }
4506:
4507: if (@expr1073757578 vartok@var3116 .@expr1073757579 varId (@expr1073757580 ) ==@expr1073757581 0 ) {
4508: if (@expr1073757582 !@expr1073757583 vartok@var3116 .@expr1073757584 isBoolean (@expr1073757585 ) ) {
4509: check@var1220 .@expr1073757586 debugMessage (@expr1073757587 vartok@var3116 , "varid0" , "Scope::checkVariable found variable \'" +@expr1073757588 vartok@var3116 .@expr1073757589 str (@expr1073757590 ) +@expr1073757591 "\' with varid 0." ) ; }
4510: return tok@var3108 ;
4511: }
4512:
4513: const Type * vType@var3118 ; vType@var3118 =@expr1073757592 nullptr ;
4514:
4515: if (@expr1073757593 typetok@var3117 ) {
4516: vType@var3118 =@expr1073757594 findVariableTypeIncludingUsedNamespaces (@expr1073757595 check@var1220 , this@expr15726 , typetok@var3117 ) ;
4517:
4518: const_cast < Token *@expr1073757596 > (@expr1073757597 typetok@var3117 ) .@expr1073757598 type (@expr1073757599 vType@var3118 ) ;
4519: }
4520:
4521:
4522: if (@expr1073757600 Token ::@expr15643 Match (@expr1073757602 typestart@var3112 , "enum|struct" ) ) {
4523: typestart@var3112 =@expr1073757603 typestart@var3112 .@expr1073757604 next (@expr1073757605 ) ; }
4524:
4525: addVariable (@expr1073757606 vartok@var3116 , typestart@var3112 , vartok@var3116 .@expr1073757607 previous (@expr1073757608 ) , varaccess@var3109 , vType@var3118 , this@expr15726 , settings@var3110 ) ;
4526: }
4527:
4528: return tok@var3108 ;
4529: }
4530:
4531: const Variable * Scope :: getVariable ( const std :: string & varname@var3119 ) const
4532: {
4533: std ::@expr1073757609 list < Variable > ::@expr1073757610 const_iterator iter@var3120 ;
4534:
4535: for (@expr1073757611 iter@var3120 =@expr1073757612 varlist@var1227 .@expr1073757613 begin (@expr1073757614 ) ; iter@var3120 !=@expr1073757615 varlist@var1227 .@expr1073757616 end (@expr1073757617 ) ; ++@expr1073757618 iter@var3120 ) {
4536: if (@expr1073757619 iter@var3120 .@expr1073757620 name (@expr1073757621 ) ==@expr1073757622 varname@var3119 ) {
4537: return &@expr1073757623 *@expr1073757624 iter@var3120 ; }
4538: }
4539:
4540: return nullptr ;
4541: }
4542:
4543: static const Token * skipPointers ( const Token * tok@var3121 )
4544: {
4545: while (@expr1073757625 Token ::@expr15802 Match (@expr1073757627 tok@var3121 , "*|&|&&" ) ||@expr1073757628 (@expr1073757629 Token ::@expr15802 Match (@expr1073757631 tok@var3121 , "( [*&]" ) &&@expr1073757632 Token ::@expr15802 Match (@expr1073757634 tok@var3121 .@expr15811 link (@expr15812 ) .@expr1073757637 next (@expr1073757638 ) , "(|[" ) ) ) {
4546: tok@var3121 =@expr1073757639 tok@var3121 .@expr15816 next (@expr15817 ) ;
4547: if (@expr1073757642 tok@var3121 .@expr1073757643 strAt (@expr1073757644 -1 ) ==@expr1073757645 "(" &&@expr1073757646 Token ::@expr15802 Match (@expr1073757648 tok@var3121 , "%type% ::" ) ) {
4548: tok@var3121 =@expr1073757649 tok@var3121 .@expr1073757650 tokAt (@expr1073757651 2 ) ; }
4549: }
4550:
4551: if (@expr1073757652 Token ::@expr15829 simpleMatch (@expr1073757654 tok@var3121 , "( *" ) &&@expr1073757655 Token ::@expr15829 simpleMatch (@expr1073757657 tok@var3121 .@expr15811 link (@expr15812 ) .@expr1073757660 previous (@expr1073757661 ) , "] ) ;" ) ) {
4552: const Token * tok2@var3122 ; tok2@var3122 =@expr1073757662 skipPointers (@expr1073757663 tok@var3121 .@expr15816 next (@expr15817 ) ) ;
4553: if (@expr1073757666 Token ::@expr15802 Match (@expr1073757668 tok2@var3122 , "%name% [" ) &&@expr1073757669 Token ::@expr15829 simpleMatch (@expr1073757671 tok2@var3122 .@expr1073757672 linkAt (@expr1073757673 1 ) , "] ) ;" ) ) {
4554: return tok2@var3122 ; }
4555: }
4556:
4557: return tok@var3121 ;
4558: }
4559:
4560: static const Token * skipPointersAndQualifiers ( const Token * tok@var3123 )
4561: {
4562: tok@var3123 =@expr1073757674 skipPointers (@expr15851 tok@var3123 ) ;
4563: while (@expr1073757676 Token ::@expr1073757677 Match (@expr1073757678 tok@var3123 , "const|static|volatile" ) ) {
4564: tok@var3123 =@expr1073757679 tok@var3123 .@expr1073757680 next (@expr1073757681 ) ;
4565: tok@var3123 =@expr1073757682 skipPointers (@expr15851 tok@var3123 ) ;
4566: }
4567:
4568: return tok@var3123 ;
4569: }
4570:
4571: bool Scope :: isVariableDeclaration ( const Token * const tok@var3124 , const Token * & vartok@var3125 , const Token * & typetok@var3126 ) const
4572: {
4573: if (@expr1073757684 !@expr1073757685 tok@var3124 ) {
4574: return false ; }
4575:
4576: const bool isCPP@var3127 =@expr1073757686 check@var1220 &&@expr1073757687 check@var1220 .@expr1073757688 mTokenizer@var3807 .@expr1073757689 isCPP (@expr1073757690 ) ;
4577:
4578: if (@expr1073757691 isCPP@var3127 &&@expr1073757692 Token ::@expr15869 Match (@expr1073757694 tok@var3124 , "throw|new" ) ) {
4579: return false ; }
4580:
4581: const bool isCPP11@var3128 =@expr1073757695 isCPP@var3127 &&@expr1073757696 check@var1220 .@expr1073757697 mSettings@var3808 .@expr1073757698 standards@var3809 .@expr1073757699 cpp@var3810 >=@expr1073757700 Standards ::@expr1073757701 CPP11 ;
4582:
4583: if (@expr1073757702 isCPP11@var3128 &&@expr1073757703 tok@var3124 .@expr1073757704 str (@expr1073757705 ) ==@expr1073757706 "using" ) {
4584: return false ; }
4585:
4586: const Token * localTypeTok@var3129 ; localTypeTok@var3129 =@expr1073757707 skipScopeIdentifiers (@expr1073757708 tok@var3124 ) ;
4587: const Token * localVarTok@var3130 ; localVarTok@var3130 =@expr1073757709 nullptr ;
4588:
4589: if (@expr1073757710 Token ::@expr15869 Match (@expr1073757712 localTypeTok@var3129 , "%type% <" ) ) {
4590: if (@expr1073757713 Token ::@expr15869 Match (@expr1073757715 tok@var3124 , "const_cast|dynamic_cast|reinterpret_cast|static_cast <" ) ) {
4591: return false ; }
4592:
4593: const Token * closeTok@var3131 ; closeTok@var3131 =@expr1073757716 localTypeTok@var3129 .@expr15893 next (@expr15894 ) .@expr1073757719 link (@expr1073757720 ) ;
4594: if (@expr1073757721 closeTok@var3131 ) {
4595: localVarTok@var3130 =@expr1073757722 skipPointers (@expr1073757723 closeTok@var3131 .@expr1073757724 next (@expr1073757725 ) ) ;
4596:
4597: if (@expr1073757726 Token ::@expr15869 Match (@expr1073757728 localVarTok@var3130 , ":: %type% %name% [;=({]" ) ) {
4598: if (@expr1073757729 localVarTok@var3130 .@expr15906 strAt (@expr1073757731 3 ) !=@expr1073757732 "(" ||@expr1073757733
4599: Token ::@expr15869 Match (@expr1073757735 localVarTok@var3130 .@expr15912 linkAt (@expr1073757737 3 ) , "[)}] ;" ) ) {
4600: localTypeTok@var3129 =@expr1073757738 localVarTok@var3130 .@expr15915 next (@expr15916 ) ;
4601: localVarTok@var3130 =@expr1073757741 localVarTok@var3130 .@expr1073757742 tokAt (@expr1073757743 2 ) ;
4602: }
4603: }
4604: }
4605: } else { if (@expr1073757744 Token ::@expr15869 Match (@expr1073757746 localTypeTok@var3129 , "%type%" ) ) {
4606:
4607: if (@expr1073757747 isCPP11@var3128 &&@expr1073757748 Token ::@expr15925 simpleMatch (@expr1073757750 localTypeTok@var3129 , "decltype (" ) &&@expr1073757751 Token ::@expr15869 Match (@expr1073757753 localTypeTok@var3129 .@expr15930 linkAt (@expr15931 1 ) , ") %name%|*|&|&&" ) ) {
4608: localVarTok@var3130 =@expr1073757756 skipPointersAndQualifiers (@expr1073757757 localTypeTok@var3129 .@expr15930 linkAt (@expr15931 1 ) .@expr1073757760 next (@expr1073757761 ) ) ; }
4609: else {
4610: localVarTok@var3130 =@expr1073757762 skipPointersAndQualifiers (@expr1073757763 localTypeTok@var3129 .@expr15893 next (@expr15894 ) ) ;
4611: if (@expr1073757766 isCPP11@var3128 &&@expr1073757767 Token ::@expr15925 simpleMatch (@expr1073757769 localVarTok@var3130 , "decltype (" ) &&@expr1073757770 Token ::@expr15869 Match (@expr1073757772 localVarTok@var3130 .@expr15912 linkAt (@expr15950 1 ) , ") %name%|*|&|&&" ) ) {
4612: localVarTok@var3130 =@expr1073757775 skipPointersAndQualifiers (@expr1073757776 localVarTok@var3130 .@expr15912 linkAt (@expr15950 1 ) .@expr1073757779 next (@expr1073757780 ) ) ; }
4613: }
4614: } }
4615:
4616: if (@expr1073757781 !@expr1073757782 localVarTok@var3130 ) {
4617: return false ; }
4618:
4619: while (@expr1073757783 Token ::@expr15869 Match (@expr1073757785 localVarTok@var3130 , "const|*|&" ) ) {
4620: localVarTok@var3130 =@expr1073757786 localVarTok@var3130 .@expr15915 next (@expr15916 ) ; }
4621:
4622: if (@expr1073757789 Token ::@expr15869 Match (@expr1073757791 localVarTok@var3130 , "%name% ;|=" ) ||@expr1073757792 (@expr1073757793 localVarTok@var3130 &&@expr15970 localVarTok@var3130 .@expr15971 varId (@expr15972 ) &&@expr1073757797 localVarTok@var3130 .@expr15906 strAt (@expr1073757799 1 ) ==@expr1073757800 ":" ) ) {
4623: vartok@var3125 =@expr1073757801 localVarTok@var3130 ;
4624: typetok@var3126 =@expr1073757802 localTypeTok@var3129 ;
4625: } else { if (@expr1073757803 Token ::@expr15869 Match (@expr1073757805 localVarTok@var3130 , "%name% )|[" ) &&@expr1073757806 localVarTok@var3130 .@expr1073757807 str (@expr1073757808 ) !=@expr1073757809 "operator" ) {
4626: vartok@var3125 =@expr1073757810 localVarTok@var3130 ;
4627: typetok@var3126 =@expr1073757811 localTypeTok@var3129 ;
4628: } else { if (@expr1073757812 localVarTok@var3130 &&@expr15970 localVarTok@var3130 .@expr15971 varId (@expr15972 ) &&@expr1073757816 Token ::@expr15869 Match (@expr1073757818 localVarTok@var3130 , "%name% (|{" ) &&@expr1073757819
4629: Token ::@expr15869 Match (@expr1073757821 localVarTok@var3130 .@expr15915 next (@expr15916 ) .@expr1073757824 link (@expr1073757825 ) , ")|} ;" ) ) {
4630: vartok@var3125 =@expr1073757826 localVarTok@var3130 ;
4631: typetok@var3126 =@expr1073757827 localTypeTok@var3129 ;
4632: } else { if (@expr1073757828 type@var1233 ==@expr1073757829 eCatch &&@expr1073757830
4633: Token ::@expr15869 Match (@expr1073757832 localVarTok@var3130 , "%name% )" ) ) {
4634: vartok@var3125 =@expr1073757833 localVarTok@var3130 ;
4635: typetok@var3126 =@expr1073757834 localTypeTok@var3129 ;
4636: } } } }
4637:
4638: return nullptr !=@expr1073757835 vartok@var3125 ;
4639: }
4640:
4641: const Token * Scope :: addEnum ( const Token * tok@var3132 , bool isCpp@var3133 )
4642: {
4643: const Token * tok2@var3134 ; tok2@var3134 =@expr1073757836 tok@var3132 .@expr1073757837 next (@expr1073757838 ) ;
4644:
4645:
4646: if (@expr1073757839 isCpp@var3133 &&@expr1073757840 tok2@var3134 .@expr16017 str (@expr16018 ) ==@expr1073757843 "class" ) {
4647: tok2@var3134 =@expr1073757844 tok2@var3134 .@expr16021 next (@expr16022 ) ; }
4648:
4649:
4650: tok2@var3134 =@expr1073757847 tok2@var3134 .@expr16021 next (@expr16022 ) ;
4651:
4652:
4653: if (@expr1073757850 tok2@var3134 .@expr16017 str (@expr16018 ) ==@expr1073757853 ":" ) {
4654: tok2@var3134 =@expr1073757854 tok2@var3134 .@expr16021 next (@expr16022 ) ;
4655:
4656: enumType@var1239 =@expr1073757857 tok2@var3134 ;
4657: tok2@var3134 =@expr1073757858 tok2@var3134 .@expr16021 next (@expr16022 ) ;
4658: }
4659:
4660:
4661: if (@expr1073757861 tok2@var3134 .@expr16017 str (@expr16018 ) ==@expr1073757864 "{" ) {
4662: const Token * end@var3135 ; end@var3135 =@expr1073757865 tok2@var3134 .@expr16042 link (@expr16043 ) ;
4663: tok2@var3134 =@expr1073757868 tok2@var3134 .@expr16021 next (@expr16022 ) ;
4664:
4665: while (@expr1073757871 Token ::@expr16048 Match (@expr1073757873 tok2@var3134 , "%name% =|,|}" ) ||@expr1073757874
4666: (@expr1073757875 Token ::@expr16048 Match (@expr1073757877 tok2@var3134 , "%name% (" ) &&@expr1073757878 Token ::@expr16048 Match (@expr1073757880 tok2@var3134 .@expr1073757881 linkAt (@expr1073757882 1 ) , ") ,|}" ) ) ) {
4667: Enumerator enumerator@var3136 (@expr1073757883 this@expr1073757884 ) ;
4668:
4669:
4670: enumerator@var3136 .@expr1073757885 name@var3137 =@expr1073757886 tok2@var3134 ;
4671:
4672:
4673: tok2@var3134 =@expr1073757887 tok2@var3134 .@expr16021 next (@expr16022 ) ;
4674:
4675: if (@expr1073757890 tok2@var3134 .@expr16017 str (@expr16018 ) ==@expr1073757893 "=" ) {
4676:
4677: tok2@var3134 =@expr1073757894 tok2@var3134 .@expr16021 next (@expr16022 ) ;
4678:
4679: if (@expr16073 tok2@var3134 .@expr16017 str (@expr16018 ) ==@expr16076 "}" ) {
4680: return nullptr ; }
4681:
4682: enumerator@var3136 .@expr1073757901 start@var3138 =@expr1073757902 tok2@var3134 ;
4683:
4684: while (@expr1073757903 !@expr1073757904 Token ::@expr16048 Match (@expr1073757906 tok2@var3134 , ",|}" ) ) {
4685: if (@expr1073757907 tok2@var3134 .@expr16042 link (@expr16043 ) ) {
4686: tok2@var3134 =@expr1073757910 tok2@var3134 .@expr16042 link (@expr16043 ) ; }
4687: enumerator@var3136 .@expr1073757913 end@var3139 =@expr1073757914 tok2@var3134 ;
4688: tok2@var3134 =@expr1073757915 tok2@var3134 .@expr16021 next (@expr16022 ) ;
4689: }
4690: } else { if (@expr1073757918 tok2@var3134 .@expr16017 str (@expr16018 ) ==@expr1073757921 "(" ) {
4691:
4692: tok2@var3134 =@expr1073757922 tok2@var3134 .@expr16042 link (@expr16043 ) .@expr1073757925 next (@expr1073757926 ) ;
4693: } }
4694:
4695: if (@expr1073757927 tok2@var3134 .@expr16017 str (@expr16018 ) ==@expr1073757930 "," ) {
4696: enumeratorList@var1241 .@expr16107 push_back (@expr16108 enumerator@var3136 ) ;
4697: tok2@var3134 =@expr1073757933 tok2@var3134 .@expr16021 next (@expr16022 ) ;
4698: } else { if (@expr16073 tok2@var3134 .@expr16017 str (@expr16018 ) ==@expr16076 "}" ) {
4699: enumeratorList@var1241 .@expr16107 push_back (@expr16108 enumerator@var3136 ) ;
4700: break ;
4701: } }
4702: }
4703:
4704: if (@expr1073757942 tok2@var3134 ==@expr1073757943 end@var3135 ) {
4705: tok2@var3134 =@expr1073757944 tok2@var3134 .@expr16021 next (@expr16022 ) ;
4706:
4707: if (@expr1073757947 tok2@var3134 &&@expr1073757948 tok2@var3134 .@expr16017 str (@expr16018 ) !=@expr1073757951 ";" &&@expr1073757952 (@expr1073757953 isCpp@var3133 ||@expr1073757954 tok2@var3134 .@expr16017 str (@expr16018 ) !=@expr1073757957 ")" ) ) {
4708: tok2@var3134 =@expr1073757958 nullptr ; }
4709: } else {
4710: tok2@var3134 =@expr1073757959 nullptr ; }
4711: } else {
4712: tok2@var3134 =@expr1073757960 nullptr ; }
4713:
4714: return tok2@var3134 ;
4715: }
4716:
4717: const Enumerator * SymbolDatabase :: findEnumerator ( const Token * tok@var3140 ) const
4718: {
4719: const Scope * scope@var3141 ; scope@var3141 =@expr1073757961 tok@var3140 .@expr1073757962 scope (@expr1073757963 ) ;
4720:
4721: const std ::@expr16140 string &@expr16141 tokStr@var3142 =@expr1073757966 tok@var3140 .@expr1073757967 str (@expr1073757968 ) ;
4722:
4723: if (@expr1073757969 mTokensThatAreNotEnumeratorValues@var1410 .@expr1073757970 find (@expr1073757971 tokStr@var3142 ) !=@expr1073757972 mTokensThatAreNotEnumeratorValues@var1410 .@expr1073757973 end (@expr1073757974 ) ) {
4724: return nullptr ;
4725: }
4726:
4727:
4728: if (@expr1073757975 tok@var3140 .@expr1073757976 strAt (@expr1073757977 -1 ) ==@expr1073757978 "::" ) {
4729:
4730: const Token * tok1@var3143 ; tok1@var3143 =@expr1073757979 tok@var3140 ;
4731: while (@expr1073757980 Token ::@expr16157 Match (@expr1073757982 tok1@var3143 .@expr16159 tokAt (@expr16160 -2 ) , "%name% ::" ) ) {
4732: tok1@var3143 =@expr1073757985 tok1@var3143 .@expr16159 tokAt (@expr16160 -2 ) ; }
4733:
4734: if (@expr1073757988 tok1@var3143 .@expr1073757989 strAt (@expr1073757990 -1 ) ==@expr1073757991 "::" ) {
4735: scope@var3141 =@expr1073757992 &@expr1073757993 scopeList@var1331 .@expr1073757994 front (@expr1073757995 ) ; }
4736: else {
4737:
4738:
4739:
4740: while (@expr1073757996 scope@var3141 &&@expr1073757997 scope@var3141 .@expr16174 nestedIn@var3144 ) {
4741: const Scope * temp@var3145 ; temp@var3145 =@expr1073757999 scope@var3141 .@expr16174 nestedIn@var3144 .@expr1073758001 findRecordInNestedList (@expr1073758002 tok1@var3143 .@expr16179 str (@expr16180 ) ) ;
4742: if (@expr1073758005 temp@var3145 ) {
4743: scope@var3141 =@expr1073758006 temp@var3145 ;
4744: break ;
4745: }
4746: scope@var3141 =@expr1073758007 scope@var3141 .@expr16174 nestedIn@var3144 ;
4747: }
4748: }
4749:
4750: if (@expr16185 scope@var3141 ) {
4751: tok1@var3143 =@expr1073758010 tok1@var3143 .@expr16159 tokAt (@expr16188 2 ) ;
4752: while (@expr1073758013 scope@var3141 &&@expr1073758014 Token ::@expr16157 Match (@expr1073758016 tok1@var3143 , "%name% ::" ) ) {
4753: scope@var3141 =@expr1073758017 scope@var3141 .@expr1073758018 findRecordInNestedList (@expr1073758019 tok1@var3143 .@expr16179 str (@expr16180 ) ) ;
4754: tok1@var3143 =@expr1073758022 tok1@var3143 .@expr16159 tokAt (@expr16188 2 ) ;
4755: }
4756:
4757: if (@expr16185 scope@var3141 ) {
4758: const Enumerator * enumerator@var3146 ; enumerator@var3146 =@expr1073758026 scope@var3141 .@expr16203 findEnumerator (@expr16204 tokStr@var3142 ) ;
4759:
4760: if (@expr16205 enumerator@var3146 ) {
4761: return enumerator@var3146 ; }
4762:
4763: else {
4764: for (@expr1073758030 std ::@expr16140 list < Scope *@expr16208 > ::@expr16140 const_iterator it@var3147 =@expr1073758034 scope@var3141 .@expr16211 nestedList@var3149 .@expr16212 begin (@expr16213 ) , end@var3148 =@expr1073758038 scope@var3141 .@expr16211 nestedList@var3149 .@expr16216 end (@expr16217 ) ; it@var3147 !=@expr1073758042 end@var3148 ; ++@expr1073758043 it@var3147 ) {
4765: enumerator@var3146 =@expr1073758044 (@expr1073758045 *@expr1073758046 it@var3147 ) .@expr1073758047 findEnumerator (@expr1073758048 tokStr@var3142 ) ;
4766:
4767: if (@expr16205 enumerator@var3146 ) {
4768: return enumerator@var3146 ; }
4769: }
4770: }
4771: }
4772: }
4773: } else {
4774: const Enumerator * enumerator@var3150 ; enumerator@var3150 =@expr1073758050 scope@var3141 .@expr16203 findEnumerator (@expr16204 tokStr@var3142 ) ;
4775:
4776: if (@expr16229 enumerator@var3150 ) {
4777: return enumerator@var3150 ; }
4778:
4779: for (@expr1073758054 std ::@expr16140 list < Scope *@expr16208 > ::@expr16140 const_iterator s@var3151 =@expr1073758058 scope@var3141 .@expr16211 nestedList@var3149 .@expr16212 begin (@expr16213 ) ; s@var3151 !=@expr1073758062 scope@var3141 .@expr16211 nestedList@var3149 .@expr16216 end (@expr16217 ) ; ++@expr1073758066 s@var3151 ) {
4780: enumerator@var3150 =@expr1073758067 (@expr16244 *@expr1073758069 s@var3151 ) .@expr1073758070 findEnumerator (@expr1073758071 tokStr@var3142 ) ;
4781:
4782: if (@expr16229 enumerator@var3150 ) {
4783: return enumerator@var3150 ; }
4784: }
4785:
4786: if (@expr1073758073 scope@var3141 .@expr16250 definedType@var3152 ) {
4787: const std ::@expr1073758075 vector < Type ::@expr16140 BaseInfo > & derivedFrom@var3153 =@expr1073758077 scope@var3141 .@expr16250 definedType@var3152 .@expr1073758079 derivedFrom@var3154 ;
4788: for (@expr1073758080 const Type ::@expr16140 BaseInfo &@expr16141 i@var3155 :@expr1073758083 derivedFrom@var3153 ) {
4789: const Type * derivedFromType@var3156 ; derivedFromType@var3156 =@expr1073758084 i@var3155 .@expr1073758085 type@var3157 ;
4790: if (@expr1073758086 derivedFromType@var3156 &&@expr1073758087 derivedFromType@var3156 .@expr16264 classScope@var3158 ) {
4791: enumerator@var3150 =@expr1073758089 derivedFromType@var3156 .@expr16264 classScope@var3158 .@expr1073758091 findEnumerator (@expr1073758092 tokStr@var3142 ) ;
4792:
4793: if (@expr16229 enumerator@var3150 ) {
4794: return enumerator@var3150 ; }
4795: }
4796: }
4797: }
4798:
4799: while (@expr1073758094 scope@var3141 .@expr16174 nestedIn@var3144 ) {
4800: if (@expr1073758096 scope@var3141 .@expr1073758097 type@var3159 ==@expr1073758098 Scope ::@expr1073758099 eFunction &&@expr1073758100 scope@var3141 .@expr16277 functionOf@var3160 ) {
4801: scope@var3141 =@expr1073758102 scope@var3141 .@expr16277 functionOf@var3160 ; }
4802: else {
4803: scope@var3141 =@expr1073758104 scope@var3141 .@expr16174 nestedIn@var3144 ; }
4804:
4805: enumerator@var3150 =@expr1073758106 scope@var3141 .@expr16203 findEnumerator (@expr16204 tokStr@var3142 ) ;
4806:
4807: if (@expr16229 enumerator@var3150 ) {
4808: return enumerator@var3150 ; }
4809:
4810: for (@expr1073758110 std ::@expr16140 list < Scope *@expr16208 > ::@expr16140 const_iterator s@var3161 =@expr1073758114 scope@var3141 .@expr16211 nestedList@var3149 .@expr16212 begin (@expr16213 ) ; s@var3161 !=@expr1073758118 scope@var3141 .@expr16211 nestedList@var3149 .@expr16216 end (@expr16217 ) ; ++@expr1073758122 s@var3161 ) {
4811: enumerator@var3150 =@expr1073758123 (@expr16244 *@expr1073758125 s@var3161 ) .@expr1073758126 findEnumerator (@expr1073758127 tokStr@var3142 ) ;
4812:
4813: if (@expr16229 enumerator@var3150 ) {
4814: return enumerator@var3150 ; }
4815: }
4816: }
4817: }
4818:
4819: mTokensThatAreNotEnumeratorValues@var1410 .@expr1073758129 insert (@expr1073758130 tokStr@var3142 ) ;
4820:
4821: return nullptr ;
4822: }
4823:
4824:
4825:
4826: const Type * SymbolDatabase :: findVariableTypeInBase ( const Scope * scope@var3162 , const Token * typeTok@var3163 ) const
4827: {
4828: if (@expr1073758131 scope@var3162 &&@expr1073758132 scope@var3162 .@expr16309 definedType@var3164 &&@expr1073758134 !@expr1073758135 scope@var3162 .@expr16309 definedType@var3164 .@expr16313 derivedFrom@var3165 .@expr1073758138 empty (@expr1073758139 ) ) {
4829: const std ::@expr1073758140 vector < Type ::@expr16317 BaseInfo > & derivedFrom@var3166 =@expr1073758142 scope@var3162 .@expr16309 definedType@var3164 .@expr16313 derivedFrom@var3165 ;
4830: for (@expr1073758145 const Type ::@expr16317 BaseInfo &@expr1073758147 i@var3167 :@expr1073758148 derivedFrom@var3166 ) {
4831: const Type * base@var3168 ; base@var3168 =@expr1073758149 i@var3167 .@expr1073758150 type@var3169 ;
4832: if (@expr1073758151 base@var3168 &&@expr1073758152 base@var3168 .@expr16329 classScope@var3170 ) {
4833: if (@expr1073758154 base@var3168 .@expr16329 classScope@var3170 ==@expr1073758156 scope@var3162 ) {
4834: return nullptr ; }
4835: const Type * type@var3171 ; type@var3171 =@expr1073758157 base@var3168 .@expr16329 classScope@var3170 .@expr1073758159 findType (@expr1073758160 typeTok@var3163 .@expr1073758161 str (@expr1073758162 ) ) ;
4836: if (@expr16339 type@var3171 ) {
4837: return type@var3171 ; }
4838: type@var3171 =@expr1073758164 findVariableTypeInBase (@expr1073758165 base@var3168 .@expr16329 classScope@var3170 , typeTok@var3163 ) ;
4839: if (@expr16339 type@var3171 ) {
4840: return type@var3171 ; }
4841: }
4842: }
4843: }
4844:
4845: return nullptr ;
4846: }
4847:
4848:
4849:
4850: const Type * SymbolDatabase :: findVariableType ( const Scope * start@var3172 , const Token * typeTok@var3173 ) const
4851: {
4852: const Scope * scope@var3174 ; scope@var3174 =@expr1073758168 start@var3172 ;
4853:
4854:
4855: if (@expr1073758169 typeTok@var3173 .@expr16346 strAt (@expr16347 -1 ) !=@expr1073758172 "::" &&@expr1073758173 typeTok@var3173 .@expr16346 strAt (@expr16351 1 ) !=@expr1073758176 "::" ) {
4856:
4857: if (@expr1073758177 start@var3172 .@expr1073758178 isClassOrStruct (@expr1073758179 ) &&@expr1073758180 typeTok@var3173 .@expr16357 str (@expr16358 ) ==@expr1073758183 start@var3172 .@expr1073758184 className@var3175 ) {
4858: return start@var3172 .@expr1073758185 definedType@var3176 ; }
4859:
4860: while (@expr16362 scope@var3174 ) {
4861:
4862: const Type * type@var3177 ; type@var3177 =@expr1073758187 scope@var3174 .@expr1073758188 findType (@expr1073758189 typeTok@var3173 .@expr16357 str (@expr16358 ) ) ;
4863:
4864: if (@expr16368 type@var3177 ) {
4865: return type@var3177 ; }
4866:
4867:
4868: if (@expr1073758193 scope@var3174 .@expr1073758194 isClassOrStruct (@expr1073758195 ) ) {
4869: type@var3177 =@expr1073758196 findVariableTypeInBase (@expr1073758197 scope@var3174 , typeTok@var3173 ) ;
4870:
4871: if (@expr16368 type@var3177 ) {
4872: return type@var3177 ; }
4873: }
4874:
4875:
4876: if (@expr16375 scope@var3174 .@expr16376 type@var3178 ==@expr16377 Scope ::@expr16378 eFunction &&@expr16379 scope@var3174 .@expr16380 functionOf@var3179 ) {
4877: const Scope * scope1@var3180 ; scope1@var3180 =@expr1073758205 scope@var3174 .@expr16380 functionOf@var3179 ;
4878:
4879: type@var3177 =@expr1073758207 scope1@var3180 .@expr1073758208 findType (@expr1073758209 typeTok@var3173 .@expr16357 str (@expr16358 ) ) ;
4880:
4881: if (@expr16368 type@var3177 ) {
4882: return type@var3177 ; }
4883:
4884: type@var3177 =@expr1073758213 findVariableTypeInBase (@expr1073758214 scope1@var3180 , typeTok@var3173 ) ;
4885:
4886: if (@expr16368 type@var3177 ) {
4887: return type@var3177 ; }
4888: }
4889:
4890: scope@var3174 =@expr1073758216 scope@var3174 .@expr16393 nestedIn@var3181 ;
4891: }
4892: }
4893:
4894:
4895: else { if (@expr1073758218 typeTok@var3173 .@expr16346 strAt (@expr16347 -1 ) ==@expr1073758221 "::" ) {
4896:
4897: if (@expr1073758222 typeTok@var3173 .@expr16346 strAt (@expr16351 1 ) ==@expr1073758225 "::" ) {
4898: return nullptr ; }
4899:
4900:
4901: const Token * tok1@var3182 ; tok1@var3182 =@expr1073758226 typeTok@var3173 ;
4902:
4903: while (@expr1073758227 Token ::@expr16404 Match (@expr1073758229 tok1@var3182 .@expr16406 tokAt (@expr16407 -2 ) , "%type% ::" ) ||@expr1073758232
4904: (@expr1073758233 Token ::@expr16410 simpleMatch (@expr1073758235 tok1@var3182 .@expr16406 tokAt (@expr16407 -2 ) , "> ::" ) &&@expr1073758238 tok1@var3182 .@expr16415 linkAt (@expr16416 -2 ) &&@expr1073758241 Token ::@expr16404 Match (@expr1073758243 tok1@var3182 .@expr16415 linkAt (@expr16416 -2 ) .@expr16422 tokAt (@expr16423 -1 ) , "%type%" ) ) ) {
4905: if (@expr16424 tok1@var3182 .@expr16425 strAt (@expr16426 -1 ) ==@expr16427 "::" ) {
4906: tok1@var3182 =@expr1073758252 tok1@var3182 .@expr16406 tokAt (@expr16407 -2 ) ; }
4907: else {
4908: tok1@var3182 =@expr1073758255 tok1@var3182 .@expr16415 linkAt (@expr16416 -2 ) .@expr16422 tokAt (@expr16423 -1 ) ; }
4909: }
4910:
4911:
4912: if (@expr16424 tok1@var3182 .@expr16425 strAt (@expr16426 -1 ) ==@expr16427 "::" ) {
4913: scope@var3174 =@expr1073758264 &@expr1073758265 scopeList@var1331 .@expr1073758266 front (@expr1073758267 ) ;
4914:
4915: scope@var3174 =@expr1073758268 scope@var3174 .@expr16445 findRecordInNestedList (@expr16446 tok1@var3182 .@expr16447 str (@expr16448 ) ) ;
4916: }
4917:
4918:
4919: else {
4920: while (@expr16362 scope@var3174 ) {
4921: if (@expr1073758274 scope@var3174 .@expr1073758275 className@var3183 ==@expr1073758276 tok1@var3182 .@expr16447 str (@expr16448 ) ) {
4922: break ; }
4923: else {
4924: const Scope * scope1@var3184 ; scope1@var3184 =@expr1073758279 scope@var3174 .@expr16445 findRecordInNestedList (@expr16446 tok1@var3182 .@expr16447 str (@expr16448 ) ) ;
4925:
4926: if (@expr1073758284 scope1@var3184 ) {
4927: scope@var3174 =@expr1073758285 scope1@var3184 ;
4928: break ;
4929: } else { if (@expr16375 scope@var3174 .@expr16376 type@var3178 ==@expr16377 Scope ::@expr16378 eFunction &&@expr16379 scope@var3174 .@expr16380 functionOf@var3179 ) {
4930: scope@var3174 =@expr1073758292 scope@var3174 .@expr16380 functionOf@var3179 ; }
4931: else {
4932: scope@var3174 =@expr1073758294 scope@var3174 .@expr16393 nestedIn@var3181 ; } }
4933: }
4934: }
4935: }
4936:
4937: if (@expr1073758296 scope@var3174 ) {
4938:
4939: while (@expr1073758297 scope@var3174 &&@expr1073758298 (@expr1073758299 Token ::@expr16404 Match (@expr1073758301 tok1@var3182 , "%type% ::" ) ||@expr1073758302
4940: (@expr1073758303 Token ::@expr16404 Match (@expr1073758305 tok1@var3182 , "%type% <" ) &&@expr1073758306 Token ::@expr16410 simpleMatch (@expr1073758308 tok1@var3182 .@expr16415 linkAt (@expr16486 1 ) , "> ::" ) ) ) ) {
4941: if (@expr1073758311 tok1@var3182 .@expr16425 strAt (@expr1073758313 1 ) ==@expr1073758314 "::" ) {
4942: tok1@var3182 =@expr1073758315 tok1@var3182 .@expr16406 tokAt (@expr1073758317 2 ) ; }
4943: else {
4944: tok1@var3182 =@expr1073758318 tok1@var3182 .@expr16415 linkAt (@expr16486 1 ) .@expr1073758321 tokAt (@expr1073758322 2 ) ; }
4945: const Scope * temp@var3185 ; temp@var3185 =@expr1073758323 scope@var3174 .@expr16445 findRecordInNestedList (@expr16446 tok1@var3182 .@expr16447 str (@expr16448 ) ) ;
4946: if (@expr1073758328 !@expr1073758329 temp@var3185 ) {
4947:
4948: const Type * type@var3186 ; type@var3186 =@expr1073758330 findVariableTypeInBase (@expr1073758331 scope@var3174 , tok1@var3182 ) ;
4949:
4950: if (@expr1073758332 type@var3186 ) {
4951: return type@var3186 ; }
4952: }
4953: scope@var3174 =@expr1073758333 temp@var3185 ;
4954: }
4955:
4956: if (@expr1073758334 scope@var3174 &&@expr1073758335 scope@var3174 .@expr16512 definedType@var3187 ) {
4957: return scope@var3174 .@expr16512 definedType@var3187 ; }
4958: }
4959: } }
4960:
4961: return nullptr ;
4962: }
4963:
4964: bool Scope :: hasInlineOrLambdaFunction ( ) const
4965: {
4966: for (@expr1073758338 const Scope *@expr1073758339 s@var3188 :@expr1073758340 nestedList@var1229 ) {
4967:
4968: if (@expr1073758341 s@var3188 .@expr16518 type@var3189 ==@expr1073758343 Scope ::@expr1073758344 eUnconditional &&@expr1073758345 Token ::@expr1073758346 simpleMatch (@expr1073758347 s@var3188 .@expr1073758348 bodyStart@var3190 .@expr1073758349 previous (@expr1073758350 ) , ") {" ) ) {
4969: return true ; }
4970:
4971: if (@expr1073758351 s@var3188 .@expr16518 type@var3189 ==@expr1073758353 Scope ::@expr1073758354 eLambda ) {
4972: return true ; }
4973: if (@expr1073758355 s@var3188 .@expr1073758356 hasInlineOrLambdaFunction (@expr1073758357 ) ) {
4974: return true ; }
4975: }
4976: return false ;
4977: }
4978:
4979: void Scope :: findFunctionInBase ( const std :: string & name@var3191 , int args@var3192 , std :: vector < const Function * > & matches@var3193 ) const
4980: {
4981: if (@expr1073758358 isClassOrStruct (@expr1073758359 ) &&@expr1073758360 definedType@var1234 &&@expr1073758361 !@expr1073758362 definedType@var1234 .@expr16539 derivedFrom@var3811 .@expr1073758364 empty (@expr1073758365 ) ) {
4982: const std ::@expr1073758366 vector < Type ::@expr16543 BaseInfo > & derivedFrom@var3194 =@expr1073758368 definedType@var1234 .@expr16539 derivedFrom@var3811 ;
4983: for (@expr1073758370 const Type ::@expr16543 BaseInfo &@expr1073758372 i@var3195 :@expr1073758373 derivedFrom@var3194 ) {
4984: const Type * base@var3196 ; base@var3196 =@expr1073758374 i@var3195 .@expr1073758375 type@var3197 ;
4985: if (@expr1073758376 base@var3196 &&@expr1073758377 base@var3196 .@expr16554 classScope@var3198 ) {
4986: if (@expr1073758379 base@var3196 .@expr16554 classScope@var3198 ==@expr1073758381 this@expr1073758382 ) {
4987: continue ; }
4988:
4989: for (@expr1073758383 std ::@expr16543 multimap < std ::@expr16543 string , const Function *@expr1073758386 > ::@expr16543 const_iterator it@var3199 =@expr1073758388 base@var3196 .@expr16554 classScope@var3198 .@expr16566 functionMap@var3200 .@expr1073758391 find (@expr1073758392 name@var3191 ) ; it@var3199 !=@expr1073758393 base@var3196 .@expr16554 classScope@var3198 .@expr16566 functionMap@var3200 .@expr1073758396 end (@expr1073758397 ) &&@expr1073758398 it@var3199 .@expr1073758399 first@var3201 ==@expr1073758400 name@var3191 ; ++@expr1073758401 it@var3199 ) {
4990: const Function * func@var3202 ; func@var3202 =@expr1073758402 it@var3199 .@expr1073758403 second@var3203 ;
4991: if (@expr1073758404 (@expr1073758405 func@var3202 .@expr1073758406 isVariadic (@expr1073758407 ) &&@expr1073758408 args@var3192 >=@expr1073758409 (@expr1073758410 func@var3202 .@expr16587 argCount (@expr16588 ) -@expr1073758413 1 ) ) ||@expr1073758414
4992: (@expr1073758415 args@var3192 ==@expr1073758416 func@var3202 .@expr16587 argCount (@expr16588 ) ||@expr1073758419 (@expr1073758420 args@var3192 <@expr1073758421 func@var3202 .@expr16587 argCount (@expr16588 ) &&@expr1073758424 args@var3192 >=@expr1073758425 func@var3202 .@expr1073758426 minArgCount (@expr1073758427 ) ) ) ) {
4993: matches@var3193 .@expr1073758428 push_back (@expr1073758429 func@var3202 ) ;
4994: }
4995: }
4996:
4997: base@var3196 .@expr16554 classScope@var3198 .@expr1073758431 findFunctionInBase (@expr1073758432 name@var3191 , args@var3192 , matches@var3193 ) ;
4998: }
4999: }
5000: }
5001: }
5002:
5003: const Scope * Scope :: findRecordInBase ( const std :: string & name@var3204 ) const
5004: {
5005: if (@expr1073758433 isClassOrStruct (@expr1073758434 ) &&@expr1073758435 definedType@var1234 &&@expr1073758436 !@expr1073758437 definedType@var1234 .@expr16614 derivedFrom@var3811 .@expr1073758439 empty (@expr1073758440 ) ) {
5006: const std ::@expr1073758441 vector < Type ::@expr16618 BaseInfo > & derivedFrom@var3205 =@expr1073758443 definedType@var1234 .@expr16614 derivedFrom@var3811 ;
5007: for (@expr1073758445 const Type ::@expr16618 BaseInfo &@expr1073758447 i@var3206 :@expr1073758448 derivedFrom@var3205 ) {
5008: const Type * base@var3207 ; base@var3207 =@expr1073758449 i@var3206 .@expr1073758450 type@var3208 ;
5009: if (@expr1073758451 base@var3207 &&@expr1073758452 base@var3207 .@expr16629 classScope@var3209 ) {
5010: if (@expr1073758454 base@var3207 .@expr16629 classScope@var3209 ==@expr1073758456 this@expr1073758457 ) {
5011: continue ; }
5012:
5013: if (@expr1073758458 base@var3207 .@expr1073758459 name (@expr1073758460 ) ==@expr1073758461 name@var3204 ) {
5014: return base@var3207 .@expr16629 classScope@var3209 ;
5015: }
5016:
5017: const ::@expr1073758463 Type * t@var3210 ; t@var3210 =@expr1073758464 base@var3207 .@expr16629 classScope@var3209 .@expr1073758466 findType (@expr1073758467 name@var3204 ) ;
5018: if (@expr1073758468 t@var3210 ) {
5019: return t@var3210 .@expr1073758469 classScope@var3211 ; }
5020: }
5021: }
5022: }
5023:
5024: return nullptr ;
5025: }
5026:
5027: std :: vector < const Scope * > Scope :: findAssociatedScopes ( ) const
5028: {
5029: std ::@expr1073758470 vector < const Scope *@expr16647 > result@var3212 ; result@var3212 =@expr1073758472 {@expr1073758473 this@expr1073758474 } ;
5030: if (@expr1073758475 isClassOrStruct (@expr1073758476 ) &&@expr1073758477 definedType@var1234 &&@expr1073758478 !@expr1073758479 definedType@var1234 .@expr16656 derivedFrom@var3811 .@expr1073758481 empty (@expr1073758482 ) ) {
5031: const std ::@expr1073758483 vector < Type ::@expr16660 BaseInfo > & derivedFrom@var3213 =@expr1073758485 definedType@var1234 .@expr16656 derivedFrom@var3811 ;
5032: for (@expr1073758487 const Type ::@expr16660 BaseInfo &@expr1073758489 i@var3214 :@expr1073758490 derivedFrom@var3213 ) {
5033: const Type * base@var3215 ; base@var3215 =@expr1073758491 i@var3214 .@expr1073758492 type@var3216 ;
5034: if (@expr1073758493 base@var3215 &&@expr1073758494 base@var3215 .@expr16671 classScope@var3217 ) {
5035: if (@expr1073758496 contains (@expr1073758497 result@var3212 , base@var3215 .@expr16671 classScope@var3217 ) ) {
5036: continue ; }
5037: std ::@expr1073758499 vector < const Scope *@expr16647 > baseScopes@var3218 ; baseScopes@var3218 =@expr1073758501 base@var3215 .@expr16671 classScope@var3217 .@expr1073758503 findAssociatedScopes (@expr1073758504 ) ;
5038: result@var3212 .@expr1073758505 insert (@expr1073758506 result@var3212 .@expr1073758507 end (@expr1073758508 ) , baseScopes@var3218 .@expr1073758509 begin (@expr1073758510 ) , baseScopes@var3218 .@expr1073758511 end (@expr1073758512 ) ) ;
5039: }
5040: }
5041: }
5042: return result@var3212 ;
5043: }
5044:
5045:
5046:
5047: static void checkVariableCallMatch ( const Variable * callarg@var3219 , const Variable * funcarg@var3220 , unsigned long & same@var3221 , unsigned long & fallback1@var3222 , unsigned long & fallback2@var3223 )
5048: {
5049: if (@expr1073758513 callarg@var3219 ) {
5050: ValueType ::@expr1073758514 MatchResult res@var3224 ; res@var3224 =@expr1073758515 ValueType ::@expr1073758516 matchParameter (@expr1073758517 callarg@var3219 .@expr1073758518 valueType (@expr1073758519 ) , callarg@var3219 , funcarg@var3220 ) ;
5051: if (@expr1073758520 res@var3224 ==@expr1073758521 ValueType ::@expr16698 MatchResult ::@expr1073758523 SAME ) {
5052: same@var3221 ++@expr1073758524 ;
5053: return ;
5054: }
5055: if (@expr1073758525 res@var3224 ==@expr1073758526 ValueType ::@expr16698 MatchResult ::@expr1073758528 FALLBACK1 ) {
5056: fallback1@var3222 ++@expr1073758529 ;
5057: return ;
5058: }
5059: if (@expr1073758530 res@var3224 ==@expr1073758531 ValueType ::@expr16698 MatchResult ::@expr1073758533 FALLBACK2 ) {
5060: fallback2@var3223 ++@expr1073758534 ;
5061: return ;
5062: }
5063: if (@expr1073758535 res@var3224 ==@expr1073758536 ValueType ::@expr16698 MatchResult ::@expr1073758538 NOMATCH ) {
5064: return ; }
5065:
5066: bool ptrequals@var3225 ; ptrequals@var3225 =@expr1073758539 callarg@var3219 .@expr16716 isArrayOrPointer (@expr16717 ) ==@expr1073758542 funcarg@var3220 .@expr1073758543 isArrayOrPointer (@expr1073758544 ) ;
5067: bool constEquals@var3226 ; constEquals@var3226 =@expr1073758545 !@expr1073758546 callarg@var3219 .@expr16716 isArrayOrPointer (@expr16717 ) ||@expr1073758549 (@expr1073758550 (@expr1073758551 callarg@var3219 .@expr16728 typeStartToken (@expr16729 ) .@expr1073758554 strAt (@expr1073758555 -1 ) ==@expr1073758556 "const" ) ==@expr1073758557 (@expr1073758558 funcarg@var3220 .@expr16735 typeStartToken (@expr16736 ) .@expr1073758561 strAt (@expr1073758562 -1 ) ==@expr1073758563 "const" ) ) ;
5068: if (@expr1073758564 ptrequals@var3225 &&@expr16741 constEquals@var3226 &&@expr1073758566
5069: callarg@var3219 .@expr16728 typeStartToken (@expr16729 ) .@expr1073758569 str (@expr1073758570 ) ==@expr1073758571 funcarg@var3220 .@expr16735 typeStartToken (@expr16736 ) .@expr16750 str (@expr16751 ) &&@expr1073758576
5070: callarg@var3219 .@expr16728 typeStartToken (@expr16729 ) .@expr1073758579 isUnsigned (@expr1073758580 ) ==@expr1073758581 funcarg@var3220 .@expr16735 typeStartToken (@expr16736 ) .@expr1073758584 isUnsigned (@expr1073758585 ) &&@expr1073758586
5071: callarg@var3219 .@expr16728 typeStartToken (@expr16729 ) .@expr1073758589 isLong (@expr1073758590 ) ==@expr1073758591 funcarg@var3220 .@expr16735 typeStartToken (@expr16736 ) .@expr1073758594 isLong (@expr1073758595 ) ) {
5072: same@var3221 ++@expr1073758596 ;
5073: } else { if (@expr1073758597 callarg@var3219 .@expr16716 isArrayOrPointer (@expr16717 ) ) {
5074: if (@expr1073758600 ptrequals@var3225 &&@expr16741 constEquals@var3226 &&@expr1073758602 funcarg@var3220 .@expr16735 typeStartToken (@expr16736 ) .@expr16750 str (@expr16751 ) ==@expr1073758607 "void" ) {
5075: fallback1@var3222 ++@expr1073758608 ; }
5076: else { if (@expr1073758609 constEquals@var3226 &&@expr1073758610 funcarg@var3220 .@expr1073758611 isStlStringType (@expr1073758612 ) &&@expr1073758613 Token ::@expr16790 Match (@expr1073758615 callarg@var3219 .@expr16728 typeStartToken (@expr16729 ) , "char|wchar_t" ) ) {
5077: fallback2@var3223 ++@expr1073758618 ; } }
5078: } else { if (@expr1073758619 ptrequals@var3225 ) {
5079: const bool takesInt@var3227 =@expr1073758620 Token ::@expr16790 Match (@expr1073758622 funcarg@var3220 .@expr16735 typeStartToken (@expr16736 ) , "char|short|int|long" ) ;
5080: const bool takesFloat@var3228 =@expr1073758625 Token ::@expr16790 Match (@expr1073758627 funcarg@var3220 .@expr16735 typeStartToken (@expr16736 ) , "float|double" ) ;
5081: const bool passesInt@var3229 =@expr1073758630 Token ::@expr16790 Match (@expr1073758632 callarg@var3219 .@expr16728 typeStartToken (@expr16729 ) , "char|short|int|long" ) ;
5082: const bool passesFloat@var3230 =@expr1073758635 Token ::@expr16790 Match (@expr1073758637 callarg@var3219 .@expr16728 typeStartToken (@expr16729 ) , "float|double" ) ;
5083: if (@expr1073758640 (@expr1073758641 takesInt@var3227 &&@expr1073758642 passesInt@var3229 ) ||@expr1073758643 (@expr1073758644 takesFloat@var3228 &&@expr1073758645 passesFloat@var3230 ) ) {
5084: fallback1@var3222 ++@expr1073758646 ; }
5085: else { if (@expr1073758647 (@expr1073758648 takesInt@var3227 &&@expr1073758649 passesFloat@var3230 ) ||@expr1073758650 (@expr1073758651 takesFloat@var3228 &&@expr1073758652 passesInt@var3229 ) ) {
5086: fallback2@var3223 ++@expr1073758653 ; } }
5087: } } }
5088: }
5089: }
5090:
5091: static std :: string getTypeString ( const Token * typeToken@var3231 )
5092: {
5093: if (@expr1073758654 !@expr1073758655 typeToken@var3231 ) {
5094: return "" ; }
5095: while (@expr1073758656 Token ::@expr16833 Match (@expr1073758658 typeToken@var3231 , "%name%|*|&|::" ) ) {
5096: if (@expr1073758659 typeToken@var3231 .@expr16836 str (@expr16837 ) ==@expr1073758662 "::" ) {
5097: std ::@expr1073758663 string ret@var3232 ;
5098: while (@expr1073758664 Token ::@expr16833 Match (@expr1073758666 typeToken@var3231 , ":: %name%" ) ) {
5099: ret@var3232 +=@expr1073758667 "::" +@expr1073758668 typeToken@var3231 .@expr1073758669 strAt (@expr1073758670 1 ) ;
5100: typeToken@var3231 =@expr1073758671 typeToken@var3231 .@expr1073758672 tokAt (@expr1073758673 2 ) ;
5101: if (@expr1073758674 typeToken@var3231 .@expr16836 str (@expr16837 ) ==@expr1073758677 "<" ) {
5102: for (@expr1073758678 const Token *@expr1073758679 tok@var3233 =@expr1073758680 typeToken@var3231 ; tok@var3233 !=@expr1073758681 typeToken@var3231 .@expr16858 link (@expr16859 ) ; tok@var3233 =@expr1073758684 tok@var3233 .@expr1073758685 next (@expr1073758686 ) ) {
5103: ret@var3232 +=@expr1073758687 tok@var3233 .@expr1073758688 str (@expr1073758689 ) ; }
5104: ret@var3232 +=@expr1073758690 ">" ;
5105: typeToken@var3231 =@expr1073758691 typeToken@var3231 .@expr16858 link (@expr16859 ) .@expr1073758694 next (@expr1073758695 ) ;
5106: }
5107: }
5108: return ret@var3232 ;
5109: }
5110: if (@expr1073758696 Token ::@expr16833 Match (@expr1073758698 typeToken@var3231 , "%name% const| %var%|*|&" ) ) {
5111: return typeToken@var3231 .@expr16836 str (@expr16837 ) ;
5112: }
5113: typeToken@var3231 =@expr1073758701 typeToken@var3231 .@expr1073758702 next (@expr1073758703 ) ;
5114: }
5115: return "" ;
5116: }
5117:
5118: const Function * Scope :: findFunction ( const Token * tok@var3234 , bool requireConst@var3235 ) const
5119: {
5120: const bool isCall@var3236 =@expr1073758704 Token ::@expr16881 Match (@expr1073758706 tok@var3234 .@expr1073758707 next (@expr1073758708 ) , "(|{" ) ;
5121:
5122: const std ::@expr1073758709 vector < const Token *@expr16886 > arguments@var3237 =@expr1073758711 getArguments (@expr1073758712 tok@var3234 ) ;
5123:
5124: std ::@expr1073758713 vector < const Function *@expr16886 > matches@var3238 ;
5125:
5126:
5127: const unsigned long args@var3239 =@expr1073758715 arguments@var3237 .@expr1073758716 size (@expr1073758717 ) ;
5128:
5129: auto addMatchingFunctions@var3240 ; addMatchingFunctions@var3240 =@expr1073758718 [@expr1073758719 &@expr1073758720 ] (@expr1073758721 const Scope *@expr16886 scope@var3241 ) {
5130: for (@expr1073758723 std ::@expr16900 multimap < std ::@expr16900 string , const Function *@expr16886 > ::@expr16900 const_iterator it@var3242 =@expr1073758728 scope@var3241 .@expr16905 functionMap@var3243 .@expr1073758730 find (@expr1073758731 tok@var3234 .@expr16908 str (@expr16909 ) ) ; it@var3242 !=@expr1073758734 scope@var3241 .@expr16905 functionMap@var3243 .@expr1073758736 cend (@expr1073758737 ) &&@expr1073758738 it@var3242 .@expr1073758739 first@var3244 ==@expr1073758740 tok@var3234 .@expr16908 str (@expr16909 ) ; ++@expr1073758743 it@var3242 ) {
5131: const Function * func@var3245 ; func@var3245 =@expr1073758744 it@var3242 .@expr1073758745 second@var3246 ;
5132: if (@expr1073758746 !@expr16923 isCall@var3236 ||@expr1073758748 args@var3239 ==@expr1073758749 func@var3245 .@expr16926 argCount (@expr16927 ) ||@expr1073758752
5133: (@expr1073758753 func@var3245 .@expr1073758754 isVariadic (@expr1073758755 ) &&@expr1073758756 args@var3239 >=@expr1073758757 (@expr1073758758 func@var3245 .@expr16935 minArgCount (@expr16936 ) -@expr1073758761 1 ) ) ||@expr1073758762
5134: (@expr1073758763 args@var3239 <@expr1073758764 func@var3245 .@expr16926 argCount (@expr16927 ) &&@expr1073758767 args@var3239 >=@expr1073758768 func@var3245 .@expr16935 minArgCount (@expr16936 ) ) ) {
5135: matches@var3238 .@expr1073758771 push_back (@expr1073758772 func@var3245 ) ;
5136: }
5137: }
5138: } ;
5139:
5140: addMatchingFunctions@var3240 (@expr1073758773 this@expr1073758774 ) ;
5141:
5142:
5143: for (@expr1073758775 const Scope *@expr16886 nestedScope@var3247 :@expr1073758777 nestedList@var1229 ) {
5144: if (@expr1073758778 nestedScope@var3247 .@expr1073758779 type@var3248 ==@expr1073758780 eNamespace &&@expr1073758781 nestedScope@var3247 .@expr1073758782 className@var3249 .@expr1073758783 empty (@expr1073758784 ) ) {
5145: addMatchingFunctions@var3240 (@expr1073758785 nestedScope@var3247 ) ; }
5146: }
5147:
5148:
5149: findFunctionInBase (@expr1073758786 tok@var3234 .@expr16908 str (@expr16909 ) , args@var3239 , matches@var3238 ) ;
5150:
5151:
5152: if (@expr1073758789 !@expr16923 isCall@var3236 ) {
5153: return matches@var3238 .@expr1073758791 empty (@expr1073758792 ) ?@expr1073758793 nullptr :@expr1073758794 matches@var3238 [@expr16971 0 ] ;
5154: }
5155:
5156: const Function * fallback1Func@var3250 ; fallback1Func@var3250 =@expr1073758796 nullptr ;
5157: const Function * fallback2Func@var3251 ; fallback2Func@var3251 =@expr1073758797 nullptr ;
5158:
5159:
5160: for (@expr1073758798 unsigned long i@var3252 =@expr1073758799 0 ; i@var3252 <@expr1073758800 matches@var3238 .@expr16977 size (@expr16978 ) ; ) {
5161: bool constFallback@var3253 ; constFallback@var3253 =@expr1073758803 false ;
5162: const Function * func@var3254 ; func@var3254 =@expr1073758804 matches@var3238 [@expr1073758805 i@var3252 ] ;
5163: unsigned long same@var3255 ; same@var3255 =@expr1073758806 0 ;
5164:
5165: if (@expr1073758807 requireConst@var3235 &&@expr1073758808 !@expr16985 func@var3254 .@expr16986 isConst (@expr16987 ) ) {
5166: i@var3252 ++@expr1073758812 ;
5167: continue ;
5168: }
5169:
5170: if (@expr1073758813 !@expr16990 requireConst@var3235 ||@expr1073758815 !@expr16985 func@var3254 .@expr16986 isConst (@expr16987 ) ) {
5171:
5172: const Scope * scope@var3256 ; scope@var3256 =@expr1073758819 tok@var3234 .@expr1073758820 scope (@expr1073758821 ) ;
5173:
5174:
5175: if (@expr1073758822 scope@var3256 &&@expr1073758823 scope@var3256 .@expr17000 functionOf@var3257 &&@expr1073758825 scope@var3256 .@expr17000 functionOf@var3257 .@expr1073758827 isClassOrStruct (@expr1073758828 ) &&@expr1073758829 scope@var3256 .@expr17006 function@var3258 ) {
5176:
5177: if (@expr1073758831 scope@var3256 .@expr17006 function@var3258 .@expr17009 isConst (@expr17010 ) !=@expr1073758835 func@var3254 .@expr16986 isConst (@expr16987 ) ) {
5178: if (@expr1073758838 scope@var3256 .@expr17006 function@var3258 .@expr17009 isConst (@expr17010 ) ) {
5179: ++@expr1073758842 i@var3252 ;
5180: continue ;
5181: }
5182: constFallback@var3253 =@expr1073758843 true ;
5183: }
5184: }
5185: }
5186:
5187: unsigned long fallback1@var3259 ; fallback1@var3259 =@expr1073758844 0 ;
5188: unsigned long fallback2@var3260 ; fallback2@var3260 =@expr1073758845 0 ;
5189: bool erased@var3261 ; erased@var3261 =@expr1073758846 false ;
5190: for (@expr1073758847 unsigned long j@var3262 =@expr1073758848 0 ; j@var3262 <@expr1073758849 args@var3239 ; ++@expr1073758850 j@var3262 ) {
5191:
5192:
5193: if (@expr1073758851 func@var3254 .@expr17028 isVariadic (@expr17029 ) &&@expr1073758854 j@var3262 >@expr1073758855 (@expr1073758856 func@var3254 .@expr17033 argCount (@expr17034 ) -@expr17035 1 ) ) {
5194: break ;
5195: }
5196: const Variable * funcarg@var3263 ; funcarg@var3263 =@expr1073758860 func@var3254 .@expr1073758861 getArgumentVar (@expr1073758862 j@var3262 ) ;
5197:
5198: if (@expr1073758863 !@expr1073758864 arguments@var3237 [@expr17041 j@var3262 ] .@expr17042 valueType (@expr17043 ) ) {
5199: const Token * vartok@var3264 ; vartok@var3264 =@expr1073758868 arguments@var3237 [@expr17041 j@var3262 ] ;
5200: int pointer@var3265 ; pointer@var3265 =@expr1073758870 0 ;
5201: while (@expr1073758871 vartok@var3264 &&@expr1073758872 (@expr1073758873 vartok@var3264 .@expr17050 isUnaryOp (@expr17051 "&" ) ||@expr1073758876 vartok@var3264 .@expr17050 isUnaryOp (@expr1073758878 "*" ) ) ) {
5202: pointer@var3265 +=@expr1073758879 vartok@var3264 .@expr17050 isUnaryOp (@expr17051 "&" ) ?@expr1073758882 1 :@expr1073758883 -1 ;
5203: vartok@var3264 =@expr1073758884 vartok@var3264 .@expr1073758885 astOperand1 (@expr1073758886 ) ;
5204: }
5205: if (@expr1073758887 vartok@var3264 &&@expr1073758888 vartok@var3264 .@expr17065 variable (@expr17066 ) ) {
5206: const Token * callArgTypeToken@var3266 ; callArgTypeToken@var3266 =@expr1073758891 vartok@var3264 .@expr17065 variable (@expr17066 ) .@expr1073758894 typeStartToken (@expr1073758895 ) ;
5207: const Token * funcArgTypeToken@var3267 ; funcArgTypeToken@var3267 =@expr1073758896 funcarg@var3263 .@expr1073758897 typeStartToken (@expr1073758898 ) ;
5208:
5209: auto parseDecl@var3268 ; parseDecl@var3268 =@expr1073758899 [@expr1073758900 ] (@expr1073758901 const Token *@expr16886 typeToken@var3269 ) .@expr1073758903 ValueType {
5210: ValueType ret@var3270 ;
5211: while (@expr1073758904 Token ::@expr16881 Match (@expr1073758906 typeToken@var3269 .@expr17083 previous (@expr17084 ) , "%name%" ) ) {
5212: typeToken@var3269 =@expr1073758909 typeToken@var3269 .@expr17083 previous (@expr17084 ) ; }
5213: while (@expr1073758912 Token ::@expr16881 Match (@expr1073758914 typeToken@var3269 , "%name%|*|&|::|<" ) )
5214: {
5215: if (@expr1073758915 typeToken@var3269 .@expr17092 str (@expr17093 ) ==@expr1073758918 "const" ) {
5216: ret@var3270 .@expr1073758919 constness@var3271 |=@expr1073758920 (@expr1073758921 1 <<@expr1073758922 ret@var3270 .@expr17099 pointer@var3272 ) ; }
5217: else { if (@expr1073758924 typeToken@var3269 .@expr17092 str (@expr17093 ) ==@expr1073758927 "*" ) {
5218: ret@var3270 .@expr17099 pointer@var3272 ++@expr1073758929 ; }
5219: else { if (@expr1073758930 typeToken@var3269 .@expr17092 str (@expr17093 ) ==@expr1073758933 "<" ) {
5220: if (@expr1073758934 !@expr1073758935 typeToken@var3269 .@expr17112 link (@expr17113 ) ) {
5221: break ; }
5222: typeToken@var3269 =@expr1073758938 typeToken@var3269 .@expr17112 link (@expr17113 ) ;
5223: } } }
5224: typeToken@var3269 =@expr1073758941 typeToken@var3269 .@expr1073758942 next (@expr1073758943 ) ;
5225: }
5226: return ret@var3270 ;
5227: } ;
5228:
5229: const std ::@expr16900 string type1@var3273 =@expr1073758945 getTypeString (@expr1073758946 callArgTypeToken@var3266 ) ;
5230: const std ::@expr16900 string type2@var3274 =@expr1073758948 getTypeString (@expr1073758949 funcArgTypeToken@var3267 ) ;
5231: if (@expr1073758950 !@expr1073758951 type1@var3273 .@expr1073758952 empty (@expr1073758953 ) &&@expr1073758954 type1@var3273 ==@expr1073758955 type2@var3274 ) {
5232: ValueType callArgType@var3275 ; callArgType@var3275 =@expr1073758956 parseDecl@var3268 (@expr1073758957 callArgTypeToken@var3266 ) ;
5233: callArgType@var3275 .@expr1073758958 pointer@var3276 +=@expr1073758959 pointer@var3265 ;
5234: ValueType funcArgType@var3277 ; funcArgType@var3277 =@expr1073758960 parseDecl@var3268 (@expr1073758961 funcArgTypeToken@var3267 ) ;
5235:
5236: callArgType@var3275 .@expr1073758962 sign@var3278 =@expr1073758963 funcArgType@var3277 .@expr1073758964 sign@var3279 =@expr1073758965 ValueType ::@expr1073758966 Sign ::@expr1073758967 SIGNED ;
5237: callArgType@var3275 .@expr1073758968 type@var3280 =@expr1073758969 funcArgType@var3277 .@expr1073758970 type@var3281 =@expr1073758971 ValueType ::@expr17148 Type ::@expr1073758973 INT ;
5238:
5239: ValueType ::@expr1073758974 MatchResult res@var3282 ; res@var3282 =@expr1073758975 ValueType ::@expr17152 matchParameter (@expr1073758977 &@expr1073758978 callArgType@var3275 , &@expr1073758979 funcArgType@var3277 ) ;
5240: if (@expr1073758980 res@var3282 ==@expr1073758981 ValueType ::@expr17158 MatchResult ::@expr17159 SAME ) {
5241: ++@expr1073758984 same@var3255 ; }
5242: else { if (@expr1073758985 res@var3282 ==@expr1073758986 ValueType ::@expr17158 MatchResult ::@expr17164 FALLBACK1 ) {
5243: ++@expr1073758989 fallback1@var3259 ; }
5244: else { if (@expr1073758990 res@var3282 ==@expr1073758991 ValueType ::@expr17158 MatchResult ::@expr17169 FALLBACK2 ) {
5245: ++@expr1073758994 fallback2@var3260 ; } } }
5246: continue ;
5247: }
5248: }
5249: }
5250:
5251:
5252: if (@expr1073758995 Token ::@expr16881 Match (@expr1073758997 arguments@var3237 [@expr17041 j@var3262 ] , "%var% ,|)" ) ) {
5253: const Variable * callarg@var3283 ; callarg@var3283 =@expr1073758999 arguments@var3237 [@expr17041 j@var3262 ] .@expr1073759001 variable (@expr1073759002 ) ;
5254: checkVariableCallMatch (@expr1073759003 callarg@var3283 , funcarg@var3263 , same@var3255 , fallback1@var3259 , fallback2@var3260 ) ;
5255: }
5256:
5257: else { if (@expr1073759004 funcarg@var3263 .@expr1073759005 isStlStringType (@expr1073759006 ) &&@expr1073759007 arguments@var3237 [@expr17041 j@var3262 ] .@expr17042 valueType (@expr17043 ) &&@expr1073759011 arguments@var3237 [@expr17041 j@var3262 ] .@expr17042 valueType (@expr17043 ) .@expr1073759015 pointer@var3863 ==@expr1073759016 1 &&@expr1073759017 arguments@var3237 [@expr17041 j@var3262 ] .@expr17042 valueType (@expr17043 ) .@expr1073759021 type@var3864 ==@expr1073759022 ValueType ::@expr17148 Type ::@expr1073759024 CHAR ) {
5258: fallback2@var3260 ++@expr1073759025 ; }
5259:
5260:
5261: else { if (@expr1073759026 funcarg@var3263 .@expr17203 isPointer (@expr17204 ) &&@expr1073759029 Token ::@expr16881 Match (@expr1073759031 arguments@var3237 [@expr17041 j@var3262 ] , "nullptr|NULL ,|)" ) ) {
5262: same@var3255 ++@expr1073759033 ; }
5263:
5264: else { if (@expr1073759034 funcarg@var3263 .@expr17203 isPointer (@expr17204 ) &&@expr1073759037 MathLib ::@expr1073759038 isNullValue (@expr1073759039 arguments@var3237 [@expr17041 j@var3262 ] .@expr1073759041 str (@expr1073759042 ) ) ) {
5265: fallback1@var3259 ++@expr1073759043 ; }
5266:
5267:
5268: else { if (@expr1073759044 check@var1220 .@expr1073759045 isCPP (@expr1073759046 ) ) {
5269: const Token * vartok@var3284 ; vartok@var3284 =@expr1073759047 arguments@var3237 [@expr17041 j@var3262 ] ;
5270: if (@expr1073759049 vartok@var3284 .@expr1073759050 str (@expr1073759051 ) ==@expr1073759052 "." ) {
5271: const Token * rml@var3285 ; rml@var3285 =@expr1073759053 nextAfterAstRightmostLeaf (@expr1073759054 vartok@var3284 ) ;
5272: if (@expr1073759055 rml@var3285 ) {
5273: vartok@var3284 =@expr1073759056 rml@var3285 .@expr1073759057 previous (@expr1073759058 ) ; }
5274: }
5275: while (@expr1073759059 vartok@var3284 .@expr17236 isUnaryOp (@expr1073759061 "&" ) ||@expr1073759062 vartok@var3284 .@expr17236 isUnaryOp (@expr1073759064 "*" ) ) {
5276: vartok@var3284 =@expr1073759065 vartok@var3284 .@expr1073759066 astOperand1 (@expr1073759067 ) ; }
5277: const Variable * var@var3286 ; var@var3286 =@expr1073759068 vartok@var3284 .@expr1073759069 variable (@expr1073759070 ) ;
5278:
5279: bool unknownDeref@var3287 ; unknownDeref@var3287 =@expr1073759071 false ;
5280: if (@expr1073759072 var@var3286 &&@expr1073759073 vartok@var3284 .@expr17250 astParent (@expr17251 ) &&@expr1073759076 vartok@var3284 .@expr17250 astParent (@expr17251 ) .@expr1073759079 str (@expr1073759080 ) ==@expr1073759081 "*" ) {
5281: if (@expr1073759082 var@var3286 .@expr1073759083 isSmartPointer (@expr1073759084 ) &&@expr1073759085 var@var3286 .@expr17262 valueType (@expr17263 ) &&@expr1073759088 var@var3286 .@expr17262 valueType (@expr17263 ) .@expr17267 smartPointerTypeToken@var3844 ) {
5282: var@var3286 =@expr1073759092 var@var3286 .@expr17262 valueType (@expr17263 ) .@expr17267 smartPointerTypeToken@var3844 .@expr1073759096 variable (@expr1073759097 ) ; }
5283: else {
5284: unknownDeref@var3287 =@expr1073759098 true ; }
5285: }
5286: ValueType ::@expr1073759099 MatchResult res@var3288 ; res@var3288 =@expr1073759100 ValueType ::@expr17152 matchParameter (@expr1073759102 arguments@var3237 [@expr17041 j@var3262 ] .@expr17042 valueType (@expr17043 ) , var@var3286 , funcarg@var3263 ) ;
5287: if (@expr1073759106 res@var3288 ==@expr1073759107 ValueType ::@expr17158 MatchResult ::@expr17159 SAME ) {
5288: ++@expr1073759110 same@var3255 ; }
5289: else { if (@expr1073759111 res@var3288 ==@expr1073759112 ValueType ::@expr17158 MatchResult ::@expr17164 FALLBACK1 ) {
5290: ++@expr1073759115 fallback1@var3259 ; }
5291: else { if (@expr1073759116 res@var3288 ==@expr1073759117 ValueType ::@expr17158 MatchResult ::@expr17169 FALLBACK2 ) {
5292: ++@expr1073759120 fallback2@var3260 ; }
5293: else { if (@expr1073759121 res@var3288 ==@expr1073759122 ValueType ::@expr17158 MatchResult ::@expr1073759124 NOMATCH ) {
5294: if (@expr1073759125 unknownDeref@var3287 ) {
5295: continue ; }
5296:
5297: matches@var3238 .@expr17302 erase (@expr1073759127 matches@var3238 .@expr17304 begin (@expr17305 ) +@expr1073759130 i@var3252 ) ;
5298: erased@var3261 =@expr1073759131 true ;
5299: break ;
5300: } } } }
5301: }
5302:
5303: else {
5304:
5305: fallback1@var3259 ++@expr1073759132 ; } } } } }
5306: }
5307:
5308: const unsigned long hasToBe@var3289 =@expr1073759133 func@var3254 .@expr17028 isVariadic (@expr17029 ) ?@expr1073759136 (@expr1073759137 func@var3254 .@expr17033 argCount (@expr17034 ) -@expr17035 1 ) :@expr1073759141 args@var3239 ;
5309:
5310:
5311: if (@expr1073759142 same@var3255 ==@expr1073759143 hasToBe@var3289 ) {
5312: if (@expr1073759144 constFallback@var3253 ||@expr1073759145 (@expr1073759146 !@expr16990 requireConst@var3235 &&@expr1073759148 func@var3254 .@expr16986 isConst (@expr16987 ) ) ) {
5313: fallback1Func@var3250 =@expr1073759151 func@var3254 ; }
5314: else {
5315: return func@var3254 ; }
5316: }
5317:
5318: else { if (@expr1073759152 !@expr1073759153 fallback1Func@var3250 ) {
5319: if (@expr1073759154 same@var3255 +@expr1073759155 fallback1@var3259 ==@expr1073759156 hasToBe@var3289 ) {
5320: fallback1Func@var3250 =@expr1073759157 func@var3254 ; }
5321: else { if (@expr1073759158 !@expr1073759159 fallback2Func@var3251 &&@expr1073759160 same@var3255 +@expr1073759161 fallback2@var3260 +@expr1073759162 fallback1@var3259 ==@expr1073759163 hasToBe@var3289 ) {
5322: fallback2Func@var3251 =@expr1073759164 func@var3254 ; } }
5323: } }
5324:
5325: if (@expr1073759165 !@expr1073759166 erased@var3261 ) {
5326: ++@expr1073759167 i@var3252 ; }
5327: }
5328:
5329:
5330: if (@expr1073759168 fallback1Func@var3250 ) {
5331: return fallback1Func@var3250 ; }
5332:
5333: if (@expr1073759169 fallback2Func@var3251 ) {
5334: return fallback2Func@var3251 ; }
5335:
5336:
5337: matches@var3238 .@expr17302 erase (@expr1073759171 std ::@expr1073759172 remove_if (@expr1073759173 matches@var3238 .@expr17304 begin (@expr17305 ) , matches@var3238 .@expr17352 end (@expr17353 ) , [@expr1073759178 ] (@expr1073759179 const Function *@expr16886 m@var3290 ) {
5338: return m@var3290 .@expr1073759181 isPure (@expr1073759182 ) ;
5339: } ) , matches@var3238 .@expr17352 end (@expr17353 ) ) ;
5340:
5341:
5342: if (@expr1073759185 matches@var3238 .@expr16977 size (@expr16978 ) ==@expr1073759188 1 ) {
5343: return matches@var3238 [@expr16971 0 ] ; }
5344:
5345: return nullptr ;
5346: }
5347:
5348:
5349:
5350: const Function * SymbolDatabase :: findFunction ( const Token * tok@var3291 ) const
5351: {
5352:
5353: const Scope * currScope@var3292 ; currScope@var3292 =@expr1073759190 tok@var3291 .@expr1073759191 scope (@expr1073759192 ) ;
5354: while (@expr1073759193 currScope@var3292 &&@expr1073759194 currScope@var3292 .@expr1073759195 isExecutable (@expr1073759196 ) ) {
5355: if (@expr1073759197 currScope@var3292 .@expr17374 functionOf@var3293 ) {
5356: currScope@var3292 =@expr1073759199 currScope@var3292 .@expr17374 functionOf@var3293 ; }
5357: else {
5358: currScope@var3292 =@expr1073759201 currScope@var3292 .@expr17378 nestedIn@var3294 ; }
5359: }
5360:
5361:
5362: if (@expr1073759203 tok@var3291 .@expr1073759204 strAt (@expr1073759205 -1 ) ==@expr1073759206 "::" ) {
5363:
5364: const Token * tok1@var3295 ; tok1@var3295 =@expr1073759207 tok@var3291 ;
5365:
5366: while (@expr1073759208 Token ::@expr17385 Match (@expr1073759210 tok1@var3295 .@expr17387 tokAt (@expr17388 -2 ) , ">|%type% ::" ) ) {
5367: if (@expr1073759213 tok1@var3295 .@expr17390 strAt (@expr1073759215 -2 ) ==@expr1073759216 ">" ) {
5368: if (@expr1073759217 tok1@var3295 .@expr17394 linkAt (@expr17395 -2 ) ) {
5369: tok1@var3295 =@expr1073759220 tok1@var3295 .@expr17394 linkAt (@expr17395 -2 ) .@expr1073759223 tokAt (@expr1073759224 -1 ) ; }
5370: else {
5371: if (@expr1073759225 mSettings@var1404 .@expr1073759226 debugwarnings@var3821 ) {
5372: debugMessage (@expr1073759227 tok1@var3295 .@expr17387 tokAt (@expr17388 -2 ) , "debug" , "SymbolDatabase::findFunction found '>' without link." ) ; }
5373: return nullptr ;
5374: }
5375: } else {
5376: tok1@var3295 =@expr1073759230 tok1@var3295 .@expr17387 tokAt (@expr17388 -2 ) ; }
5377: }
5378:
5379:
5380: if (@expr1073759233 tok1@var3295 .@expr17390 strAt (@expr1073759235 -1 ) ==@expr1073759236 "::" ) {
5381: currScope@var3292 =@expr1073759237 &@expr1073759238 scopeList@var1331 .@expr1073759239 front (@expr1073759240 ) ;
5382:
5383: if (@expr1073759241 Token ::@expr17385 Match (@expr1073759243 tok1@var3295 , "%name% (" ) ) {
5384: return currScope@var3292 .@expr17420 findFunction (@expr17421 tok@var3291 ) ; }
5385:
5386: currScope@var3292 =@expr1073759246 currScope@var3292 .@expr17423 findRecordInNestedList (@expr17424 tok1@var3295 .@expr17425 str (@expr17426 ) ) ;
5387: }
5388:
5389:
5390: else {
5391: while (@expr17427 currScope@var3292 ) {
5392: if (@expr1073759252 currScope@var3292 .@expr1073759253 className@var3296 ==@expr1073759254 tok1@var3295 .@expr17425 str (@expr17426 ) ) {
5393: break ; }
5394: else {
5395: const Scope * scope@var3297 ; scope@var3297 =@expr1073759257 currScope@var3292 .@expr17423 findRecordInNestedList (@expr17424 tok1@var3295 .@expr17425 str (@expr17426 ) ) ;
5396:
5397: if (@expr1073759262 scope@var3297 ) {
5398: currScope@var3292 =@expr1073759263 scope@var3297 ;
5399: break ;
5400: } else {
5401: currScope@var3292 =@expr1073759264 currScope@var3292 .@expr17378 nestedIn@var3294 ; }
5402: }
5403: }
5404: }
5405:
5406: if (@expr1073759266 currScope@var3292 ) {
5407: while (@expr1073759267 currScope@var3292 &&@expr17444 tok1@var3295 &&@expr1073759269 !@expr1073759270 (@expr1073759271 Token ::@expr17385 Match (@expr1073759273 tok1@var3295 , "%type% :: %name% [(),>]" ) ||@expr1073759274
5408: (@expr1073759275 Token ::@expr17385 Match (@expr1073759277 tok1@var3295 , "%type% <" ) &&@expr1073759278 Token ::@expr17385 Match (@expr1073759280 tok1@var3295 .@expr17394 linkAt (@expr17458 1 ) , "> :: %name% (" ) ) ) ) {
5409: if (@expr1073759283 tok1@var3295 .@expr17390 strAt (@expr17461 1 ) ==@expr1073759286 "::" ) {
5410: tok1@var3295 =@expr1073759287 tok1@var3295 .@expr17387 tokAt (@expr17465 2 ) ; }
5411: else { if (@expr1073759290 tok1@var3295 .@expr17390 strAt (@expr17461 1 ) ==@expr1073759293 "<" ) {
5412: tok1@var3295 =@expr1073759294 tok1@var3295 .@expr17394 linkAt (@expr17458 1 ) .@expr1073759297 tokAt (@expr1073759298 2 ) ; }
5413: else {
5414: tok1@var3295 =@expr1073759299 nullptr ; } }
5415:
5416: if (@expr17476 tok1@var3295 ) {
5417: const Function * func@var3298 ; func@var3298 =@expr1073759301 currScope@var3292 .@expr17420 findFunction (@expr17479 tok1@var3295 ) ;
5418: if (@expr1073759304 func@var3298 ) {
5419: return func@var3298 ; }
5420:
5421: currScope@var3292 =@expr1073759305 currScope@var3292 .@expr17423 findRecordInNestedList (@expr17424 tok1@var3295 .@expr17425 str (@expr17426 ) ) ;
5422: }
5423: }
5424:
5425: if (@expr17476 tok1@var3295 ) {
5426: tok1@var3295 =@expr1073759311 tok1@var3295 .@expr17387 tokAt (@expr17465 2 ) ; }
5427:
5428: if (@expr1073759314 currScope@var3292 &&@expr17444 tok1@var3295 ) {
5429: return currScope@var3292 .@expr17420 findFunction (@expr17479 tok1@var3295 ) ; }
5430: }
5431: }
5432:
5433:
5434: else { if (@expr1073759318 Token ::@expr17385 Match (@expr1073759320 tok@var3291 .@expr1073759321 tokAt (@expr1073759322 -2 ) , "!!this ." ) ) {
5435: const Token * tok1@var3299 ; tok1@var3299 =@expr1073759323 tok@var3291 .@expr17500 previous (@expr17501 ) .@expr17502 astOperand1 (@expr17503 ) ;
5436: if (@expr1073759328 tok1@var3299 &&@expr1073759329 tok1@var3299 .@expr17506 valueType (@expr17507 ) &&@expr1073759332 tok1@var3299 .@expr17506 valueType (@expr17507 ) .@expr17511 typeScope@var3854 ) {
5437: return tok1@var3299 .@expr17506 valueType (@expr17507 ) .@expr17511 typeScope@var3854 .@expr1073759339 findFunction (@expr1073759340 tok@var3291 , tok1@var3299 .@expr17506 valueType (@expr17507 ) .@expr1073759343 constness@var3853 ==@expr1073759344 1 ) ;
5438: } else { if (@expr1073759345 tok1@var3299 &&@expr1073759346 Token ::@expr17385 Match (@expr1073759348 tok1@var3299 .@expr17525 previous (@expr17526 ) , "%name% (" ) &&@expr1073759351 tok1@var3299 .@expr17525 previous (@expr17526 ) .@expr17530 function (@expr17531 ) &&@expr1073759356
5439: tok1@var3299 .@expr17525 previous (@expr17526 ) .@expr17530 function (@expr17531 ) .@expr17537 retDef@var3865 ) {
5440: ValueType vt@var3300 ; vt@var3300 =@expr1073759362 ValueType ::@expr17539 parseDecl (@expr1073759364 tok1@var3299 .@expr17525 previous (@expr17526 ) .@expr17530 function (@expr17531 ) .@expr17537 retDef@var3865 , mSettings@var1404 ) ;
5441: if (@expr1073759370 vt@var3300 .@expr17547 typeScope@var3301 ) {
5442: return vt@var3300 .@expr17547 typeScope@var3301 .@expr1073759373 findFunction (@expr1073759374 tok@var3291 , vt@var3300 .@expr1073759375 constness@var3302 ==@expr1073759376 1 ) ; }
5443: } else { if (@expr1073759377 Token ::@expr17385 Match (@expr1073759379 tok1@var3299 , "%var% ." ) ) {
5444: const Variable * var@var3303 ; var@var3303 =@expr1073759380 getVariableFromVarId (@expr1073759381 tok1@var3299 .@expr1073759382 varId (@expr1073759383 ) ) ;
5445: if (@expr1073759384 var@var3303 &&@expr1073759385 var@var3303 .@expr17562 typeScope (@expr17563 ) ) {
5446: return var@var3303 .@expr17562 typeScope (@expr17563 ) .@expr1073759390 findFunction (@expr1073759391 tok@var3291 , var@var3303 .@expr17568 valueType (@expr17569 ) .@expr17570 constness@var3853 ==@expr17571 1 ) ; }
5447: if (@expr1073759396 var@var3303 &&@expr1073759397 var@var3303 .@expr17574 smartPointerType (@expr17575 ) &&@expr1073759400 var@var3303 .@expr17574 smartPointerType (@expr17575 ) .@expr17579 classScope@var3855 &&@expr1073759404 tok1@var3299 .@expr1073759405 next (@expr1073759406 ) .@expr1073759407 originalName (@expr1073759408 ) ==@expr1073759409 "->" ) {
5448: return var@var3303 .@expr17574 smartPointerType (@expr17575 ) .@expr17579 classScope@var3855 .@expr1073759413 findFunction (@expr1073759414 tok@var3291 , var@var3303 .@expr17568 valueType (@expr17569 ) .@expr17570 constness@var3853 ==@expr17571 1 ) ; }
5449: } else { if (@expr1073759419 Token ::@expr1073759420 simpleMatch (@expr1073759421 tok@var3291 .@expr17500 previous (@expr17501 ) .@expr17502 astOperand1 (@expr17503 ) , "(" ) ) {
5450: const Token * castTok@var3304 ; castTok@var3304 =@expr1073759426 tok@var3291 .@expr17500 previous (@expr17501 ) .@expr17502 astOperand1 (@expr17503 ) ;
5451: if (@expr1073759431 castTok@var3304 .@expr1073759432 isCast (@expr1073759433 ) ) {
5452: ValueType vt@var3305 ; vt@var3305 =@expr1073759434 ValueType ::@expr17539 parseDecl (@expr1073759436 castTok@var3304 .@expr1073759437 next (@expr1073759438 ) , mSettings@var1404 ) ;
5453: if (@expr1073759439 vt@var3305 .@expr17616 typeScope@var3306 ) {
5454: return vt@var3305 .@expr17616 typeScope@var3306 .@expr1073759442 findFunction (@expr1073759443 tok@var3291 , vt@var3305 .@expr1073759444 constness@var3307 ==@expr1073759445 1 ) ; }
5455: }
5456: } } } }
5457: }
5458:
5459:
5460: else {
5461: while (@expr17427 currScope@var3292 ) {
5462: const Function * func@var3308 ; func@var3308 =@expr1073759447 currScope@var3292 .@expr17420 findFunction (@expr17421 tok@var3291 ) ;
5463: if (@expr1073759450 func@var3308 ) {
5464: return func@var3308 ; }
5465: currScope@var3292 =@expr1073759451 currScope@var3292 .@expr17378 nestedIn@var3294 ;
5466: }
5467: } }
5468:
5469: if (@expr1073759453 Token ::@expr17385 Match (@expr1073759455 tok@var3291 , "%name% (|{" ) ) {
5470: ValueType vt@var3309 ; vt@var3309 =@expr1073759456 ValueType ::@expr17539 parseDecl (@expr1073759458 tok@var3291 , mSettings@var1404 ) ;
5471: if (@expr1073759459 vt@var3309 .@expr17636 typeScope@var3310 ) {
5472: return vt@var3309 .@expr17636 typeScope@var3310 .@expr1073759462 findFunction (@expr1073759463 tok@var3291 , false ) ; }
5473: }
5474: return nullptr ;
5475: }
5476:
5477:
5478:
5479: const Scope * SymbolDatabase :: findScopeByName ( const std :: string & name@var3311 ) const
5480: {
5481: for (@expr1073759464 const Scope &@expr1073759465 scope@var3312 :@expr1073759466 scopeList@var1331 ) {
5482: if (@expr1073759467 scope@var3312 .@expr1073759468 className@var3313 ==@expr1073759469 name@var3311 ) {
5483: return &@expr1073759470 scope@var3312 ; }
5484: }
5485: return nullptr ;
5486: }
5487:
5488:
5489:
5490: const Scope * Scope :: findRecordInNestedList ( const std :: string & name@var3314 , bool isC@var3315 ) const
5491: {
5492: for (@expr1073759472 const Scope *@expr1073759473 scope@var3316 :@expr1073759474 nestedList@var1229 ) {
5493: if (@expr1073759475 scope@var3316 .@expr1073759476 className@var3317 ==@expr1073759477 name@var3314 &&@expr1073759478 scope@var3316 .@expr1073759479 type@var3318 !=@expr1073759480 eFunction@expr1073759471 ) {
5494: return scope@var3316 ; }
5495: if (@expr1073759481 isC@var3315 ) {
5496: const Scope * nestedScope@var3319 ; nestedScope@var3319 =@expr1073759482 scope@var3316 .@expr1073759483 findRecordInNestedList (@expr1073759484 name@var3314 , isC@var3315 ) ;
5497: if (@expr1073759485 nestedScope@var3319 ) {
5498: return nestedScope@var3319 ; }
5499: }
5500: }
5501:
5502: const Type * nested_type@var3320 ; nested_type@var3320 =@expr1073759486 findType (@expr1073759487 name@var3314 ) ;
5503:
5504: if (@expr1073759488 nested_type@var3320 ) {
5505: if (@expr1073759489 nested_type@var3320 .@expr1073759490 isTypeAlias (@expr1073759491 ) ) {
5506: if (@expr1073759492 nested_type@var3320 .@expr17669 typeStart@var3321 ==@expr1073759494 nested_type@var3320 .@expr1073759495 typeEnd@var3322 ) {
5507: return findRecordInNestedList (@expr1073759496 nested_type@var3320 .@expr17669 typeStart@var3321 .@expr1073759498 str (@expr1073759499 ) ) ; }
5508: } else {
5509: return nested_type@var3320 .@expr1073759500 classScope@var3323 ; }
5510: }
5511:
5512: return nullptr ;
5513: }
5514:
5515:
5516:
5517: const Type * Scope :: findType ( const std :: string & name@var3324 ) const
5518: {
5519: auto it@var3325 ; it@var3325 =@expr1073759501 definedTypesMap@var1235 .@expr17678 find (@expr1073759503 name@var3324 ) ;
5520:
5521:
5522: if (@expr17680 definedTypesMap@var1235 .@expr17681 end (@expr17682 ) !=@expr17683 it@var3325 ) {
5523: return (@expr17684 *@expr1073759509 it@var3325 ) .@expr1073759510 second@var3326 ; }
5524:
5525:
5526: it@var3325 =@expr1073759511 definedTypesMap@var1235 .@expr17678 find (@expr1073759513 "" ) ;
5527: if (@expr17680 it@var3325 !=@expr17683 definedTypesMap@var1235 .@expr17681 end (@expr17682 ) ) {
5528: for (@expr1073759518 const Scope *@expr1073759519 scope@var3327 :@expr1073759520 nestedList@var1229 ) {
5529: if (@expr1073759521 scope@var3327 .@expr1073759522 className@var3328 .@expr1073759523 empty (@expr1073759524 ) &&@expr1073759525 (@expr17684 scope@var3327 .@expr1073759527 type@var3329 ==@expr1073759528 eNamespace ||@expr1073759529 scope@var3327 .@expr1073759530 isClassOrStructOrUnion (@expr1073759531 ) ) ) {
5530: const Type * t@var3330 ; t@var3330 =@expr1073759532 scope@var3327 .@expr1073759533 findType (@expr1073759534 name@var3324 ) ;
5531: if (@expr1073759535 t@var3330 ) {
5532: return t@var3330 ; }
5533: }
5534: }
5535: }
5536:
5537:
5538: return nullptr ;
5539: }
5540:
5541:
5542:
5543: Scope * Scope :: findInNestedListRecursive ( const std :: string & name@var3331 )
5544: {
5545: for (@expr1073759536 Scope *@expr17713 scope@var3332 :@expr1073759538 nestedList@var1229 ) {
5546: if (@expr1073759539 scope@var3332 .@expr1073759540 className@var3333 ==@expr1073759541 name@var3331 ) {
5547: return scope@var3332 ; }
5548: }
5549:
5550: for (@expr1073759542 Scope *@expr17713 scope@var3334 :@expr1073759544 nestedList@var1229 ) {
5551: Scope * child@var3335 ; child@var3335 =@expr1073759545 scope@var3334 .@expr1073759546 findInNestedListRecursive (@expr1073759547 name@var3331 ) ;
5552: if (@expr1073759548 child@var3335 ) {
5553: return child@var3335 ; }
5554: }
5555: return nullptr ;
5556: }
5557:
5558:
5559:
5560: const Function * Scope :: getDestructor ( ) const
5561: {
5562: for (@expr1073759549 const Function &@expr1073759550 f@var3336 :@expr1073759551 functionList@var1225 ) {
5563: if (@expr1073759552 f@var3336 .@expr1073759553 type@var3337 ==@expr1073759554 Function ::@expr1073759555 eDestructor ) {
5564: return &@expr1073759556 f@var3336 ; }
5565: }
5566: return nullptr ;
5567: }
5568:
5569:
5570:
5571: bool SymbolDatabase :: isCPP ( ) const
5572: {
5573: return mTokenizer@var1403 .@expr1073759557 isCPP (@expr1073759558 ) ;
5574: }
5575:
5576:
5577:
5578: const Scope * SymbolDatabase :: findScope ( const Token * tok@var3338 , const Scope * startScope@var3339 ) const
5579: {
5580: const Scope * scope@var3340 ; scope@var3340 =@expr1073759559 nullptr ;
5581:
5582: if (@expr1073759560 tok@var3338 .@expr17737 str (@expr17738 ) ==@expr1073759563 "::" ) {
5583: tok@var3338 =@expr1073759564 tok@var3338 .@expr1073759565 next (@expr1073759566 ) ;
5584: scope@var3340 =@expr1073759567 &@expr1073759568 scopeList@var1331 .@expr1073759569 front (@expr1073759570 ) ;
5585: }
5586:
5587: else { if (@expr1073759571 tok@var3338 .@expr17748 isName (@expr17749 ) ) {
5588: scope@var3340 =@expr1073759574 startScope@var3339 ;
5589: } }
5590:
5591: while (@expr1073759575 scope@var3340 &&@expr1073759576 tok@var3338 &&@expr1073759577 tok@var3338 .@expr17748 isName (@expr17749 ) ) {
5592: if (@expr1073759580 tok@var3338 .@expr17757 strAt (@expr17758 1 ) ==@expr1073759583 "::" ) {
5593: scope@var3340 =@expr1073759584 scope@var3340 .@expr17761 findRecordInNestedList (@expr17762 tok@var3338 .@expr17737 str (@expr17738 ) ) ;
5594: tok@var3338 =@expr1073759589 tok@var3338 .@expr1073759590 tokAt (@expr1073759591 2 ) ;
5595: } else { if (@expr1073759592 tok@var3338 .@expr17757 strAt (@expr17758 1 ) ==@expr1073759595 "<" &&@expr1073759596 Token ::@expr1073759597 simpleMatch (@expr1073759598 tok@var3338 .@expr17775 linkAt (@expr17776 1 ) , "> ::" ) ) {
5596: scope@var3340 =@expr1073759601 scope@var3340 .@expr17761 findRecordInNestedList (@expr17762 tok@var3338 .@expr17737 str (@expr17738 ) ) ;
5597: tok@var3338 =@expr1073759606 tok@var3338 .@expr17775 linkAt (@expr17776 1 ) .@expr1073759609 tokAt (@expr1073759610 2 ) ;
5598: } else {
5599: return scope@var3340 .@expr17761 findRecordInNestedList (@expr17762 tok@var3338 .@expr17737 str (@expr17738 ) ) ; } }
5600: }
5601:
5602:
5603: return nullptr ;
5604: }
5605:
5606:
5607:
5608: const Type * SymbolDatabase :: findType ( const Token * startTok@var3341 , const Scope * startScope@var3342 , bool lookOutside@var3343 ) const
5609: {
5610:
5611: if (@expr1073759615 Token ::@expr1073759616 Match (@expr1073759617 startTok@var3341 , "struct|union" ) ) {
5612: startTok@var3341 =@expr1073759618 startTok@var3341 .@expr17795 next (@expr17796 ) ; }
5613:
5614:
5615: if (@expr1073759621 startTok@var3341 .@expr17798 str (@expr17799 ) ==@expr1073759624 startScope@var3342 .@expr1073759625 className@var3344 &&@expr1073759626 startScope@var3342 .@expr1073759627 isClassOrStruct (@expr1073759628 ) &&@expr1073759629 startTok@var3341 .@expr1073759630 strAt (@expr1073759631 1 ) !=@expr1073759632 "::" ) {
5616: return startScope@var3342 .@expr1073759633 definedType@var3345 ; }
5617:
5618: if (@expr1073759634 mTokenizer@var1403 .@expr1073759635 isC (@expr1073759636 ) ) {
5619: const Scope * scope@var3346 ; scope@var3346 =@expr1073759637 startScope@var3342 ;
5620: while (@expr1073759638 scope@var3346 ) {
5621: if (@expr1073759639 startTok@var3341 .@expr17798 str (@expr17799 ) ==@expr1073759642 scope@var3346 .@expr1073759643 className@var3347 &&@expr1073759644 scope@var3346 .@expr1073759645 isClassOrStruct (@expr1073759646 ) ) {
5622: return scope@var3346 .@expr1073759647 definedType@var3348 ; }
5623: const Scope * typeScope@var3349 ; typeScope@var3349 =@expr1073759648 scope@var3346 .@expr1073759649 findRecordInNestedList (@expr1073759650 startTok@var3341 .@expr17798 str (@expr17799 ) , true ) ;
5624: if (@expr1073759653 typeScope@var3349 ) {
5625: if (@expr1073759654 startTok@var3341 .@expr17798 str (@expr17799 ) ==@expr1073759657 typeScope@var3349 .@expr1073759658 className@var3350 &&@expr1073759659 typeScope@var3349 .@expr1073759660 isClassOrStruct (@expr1073759661 ) ) {
5626: if (@expr1073759662 const Type *@expr1073759663 type@var3351 =@expr1073759664 typeScope@var3349 .@expr1073759665 definedType@var3352 ) {
5627: return type@var3351 ; }
5628: }
5629: }
5630: scope@var3346 =@expr1073759666 scope@var3346 .@expr1073759667 nestedIn@var3353 ;
5631: }
5632: return nullptr ;
5633: }
5634:
5635: const Scope * start_scope@var3354 ; start_scope@var3354 =@expr1073759668 startScope@var3342 ;
5636:
5637:
5638: if (@expr1073759669 startTok@var3341 .@expr17798 str (@expr17799 ) ==@expr1073759672 "::" ) {
5639: startTok@var3341 =@expr1073759673 startTok@var3341 .@expr17795 next (@expr17796 ) ;
5640: start_scope@var3354 =@expr1073759676 &@expr1073759677 scopeList@var1331 .@expr1073759678 front (@expr1073759679 ) ;
5641: }
5642:
5643: const Token * tok@var3355 ; tok@var3355 =@expr1073759680 startTok@var3341 ;
5644: const Scope * scope@var3356 ; scope@var3356 =@expr1073759681 start_scope@var3354 ;
5645:
5646: while (@expr17858 scope@var3356 &&@expr17859 tok@var3355 &&@expr17860 tok@var3355 .@expr17861 isName (@expr17862 ) ) {
5647: if (@expr17863 tok@var3355 .@expr17864 strAt (@expr17865 1 ) ==@expr17866 "::" ||@expr17867 (@expr1073759692 tok@var3355 .@expr17864 strAt (@expr17865 1 ) ==@expr17871 "<" &&@expr17872 Token ::@expr17873 simpleMatch (@expr17874 tok@var3355 .@expr17875 linkAt (@expr17876 1 ) , "> ::" ) ) ) {
5648: scope@var3356 =@expr1073759701 scope@var3356 .@expr17878 findRecordInNestedList (@expr17879 tok@var3355 .@expr17880 str (@expr17881 ) ) ;
5649: if (@expr17882 scope@var3356 ) {
5650: if (@expr17883 tok@var3355 .@expr17864 strAt (@expr17865 1 ) ==@expr17866 "::" ) {
5651: tok@var3355 =@expr1073759711 tok@var3355 .@expr17888 tokAt (@expr17889 2 ) ; }
5652: else {
5653: tok@var3355 =@expr1073759714 tok@var3355 .@expr17875 linkAt (@expr17876 1 ) .@expr17893 tokAt (@expr17894 2 ) ; }
5654: } else {
5655: start_scope@var3354 =@expr1073759719 start_scope@var3354 .@expr17896 nestedIn@var3357 ;
5656: if (@expr17897 !@expr17898 start_scope@var3354 ) {
5657: break ; }
5658: scope@var3356 =@expr1073759723 start_scope@var3354 ;
5659: tok@var3355 =@expr1073759724 startTok@var3341 ;
5660: }
5661: } else {
5662: const Type * type@var3358 ; type@var3358 =@expr1073759725 scope@var3356 .@expr17902 findType (@expr17903 tok@var3355 .@expr17880 str (@expr17881 ) ) ;
5663: const Scope * scope1@var3359 ;
5664: if (@expr17906 type@var3358 ) {
5665: return type@var3358 ; }
5666: else { if (@expr1073759731 scope1@var3359 =@expr1073759732 scope@var3356 .@expr17909 findRecordInBase (@expr17910 tok@var3355 .@expr17880 str (@expr17881 ) ) ) {
5667: type@var3358 =@expr1073759737 scope1@var3359 .@expr1073759738 definedType@var3360 ;
5668: if (@expr17906 type@var3358 ) {
5669: return type@var3358 ; }
5670: } else { if (@expr1073759740 scope@var3356 .@expr1073759741 type@var3361 ==@expr1073759742 Scope ::@expr1073759743 ScopeType ::@expr1073759744 eNamespace &&@expr1073759745 lookOutside@var3343 ) {
5671: scope@var3356 =@expr1073759746 scope@var3356 .@expr1073759747 nestedIn@var3362 ;
5672: continue ;
5673: } else {
5674: break ; } } }
5675: }
5676: }
5677:
5678:
5679: while (@expr1073759748 startScope@var3342 ) {
5680: for (@expr1073759749 std ::@expr17926 list < Scope ::@expr17926 UsingInfo > ::@expr17926 const_iterator it@var3363 =@expr1073759753 startScope@var3342 .@expr17930 usingList@var3364 .@expr1073759755 begin (@expr1073759756 ) ;
5681: it@var3363 !=@expr1073759757 startScope@var3342 .@expr17930 usingList@var3364 .@expr1073759759 end (@expr1073759760 ) ; ++@expr1073759761 it@var3363 ) {
5682: tok@var3355 =@expr1073759762 startTok@var3341 ;
5683: scope@var3356 =@expr1073759763 it@var3363 .@expr1073759764 scope@var3365 ;
5684: start_scope@var3354 =@expr1073759765 startScope@var3342 ;
5685:
5686: while (@expr17858 scope@var3356 &&@expr17859 tok@var3355 &&@expr17860 tok@var3355 .@expr17861 isName (@expr17862 ) ) {
5687: if (@expr17863 tok@var3355 .@expr17864 strAt (@expr17865 1 ) ==@expr17866 "::" ||@expr17867 (@expr1073759776 tok@var3355 .@expr17864 strAt (@expr17865 1 ) ==@expr17871 "<" &&@expr17872 Token ::@expr17873 simpleMatch (@expr17874 tok@var3355 .@expr17875 linkAt (@expr17876 1 ) , "> ::" ) ) ) {
5688: scope@var3356 =@expr1073759785 scope@var3356 .@expr17878 findRecordInNestedList (@expr17879 tok@var3355 .@expr17880 str (@expr17881 ) ) ;
5689: if (@expr17882 scope@var3356 ) {
5690: if (@expr17883 tok@var3355 .@expr17864 strAt (@expr17865 1 ) ==@expr17866 "::" ) {
5691: tok@var3355 =@expr1073759795 tok@var3355 .@expr17888 tokAt (@expr17889 2 ) ; }
5692: else {
5693: tok@var3355 =@expr1073759798 tok@var3355 .@expr17875 linkAt (@expr17876 1 ) .@expr17893 tokAt (@expr17894 2 ) ; }
5694: } else {
5695: start_scope@var3354 =@expr1073759803 start_scope@var3354 .@expr17896 nestedIn@var3357 ;
5696: if (@expr17897 !@expr17898 start_scope@var3354 ) {
5697: break ; }
5698: scope@var3356 =@expr1073759807 start_scope@var3354 ;
5699: tok@var3355 =@expr1073759808 startTok@var3341 ;
5700: }
5701: } else {
5702: const Type * type@var3366 ; type@var3366 =@expr1073759809 scope@var3356 .@expr17902 findType (@expr17903 tok@var3355 .@expr17880 str (@expr17881 ) ) ;
5703: const Scope * scope1@var3367 ;
5704: if (@expr17990 type@var3366 ) {
5705: return type@var3366 ; }
5706: else { if (@expr1073759815 scope1@var3367 =@expr1073759816 scope@var3356 .@expr17909 findRecordInBase (@expr17910 tok@var3355 .@expr17880 str (@expr17881 ) ) ) {
5707: type@var3366 =@expr1073759821 scope1@var3367 .@expr1073759822 definedType@var3368 ;
5708: if (@expr17990 type@var3366 ) {
5709: return type@var3366 ; }
5710: } else {
5711: break ; } }
5712: }
5713: }
5714: }
5715: startScope@var3342 =@expr1073759824 startScope@var3342 .@expr1073759825 nestedIn@var3369 ;
5716: }
5717:
5718:
5719: return nullptr ;
5720: }
5721:
5722:
5723:
5724: const Type * SymbolDatabase :: findTypeInNested ( const Token * startTok@var3370 , const Scope * startScope@var3371 ) const
5725: {
5726:
5727: if (@expr1073759826 Token ::@expr1073759827 Match (@expr1073759828 startTok@var3370 , "struct|union|enum" ) ) {
5728: startTok@var3370 =@expr1073759829 startTok@var3370 .@expr18006 next (@expr18007 ) ; }
5729:
5730:
5731: if (@expr1073759832 startTok@var3370 .@expr18009 str (@expr18010 ) ==@expr1073759835 startScope@var3371 .@expr1073759836 className@var3372 &&@expr1073759837 startScope@var3371 .@expr1073759838 isClassOrStruct (@expr1073759839 ) ) {
5732: return startScope@var3371 .@expr1073759840 definedType@var3373 ; }
5733:
5734: bool hasPath@var3374 ; hasPath@var3374 =@expr1073759841 false ;
5735:
5736:
5737: if (@expr1073759842 startTok@var3370 .@expr18009 str (@expr18010 ) ==@expr1073759845 "::" ) {
5738: hasPath@var3374 =@expr1073759846 true ;
5739: startTok@var3370 =@expr1073759847 startTok@var3370 .@expr18006 next (@expr18007 ) ;
5740: startScope@var3371 =@expr1073759850 &@expr1073759851 scopeList@var1331 .@expr1073759852 front (@expr1073759853 ) ;
5741: }
5742:
5743: const Token * tok@var3375 ; tok@var3375 =@expr1073759854 startTok@var3370 ;
5744: const Scope * scope@var3376 ; scope@var3376 =@expr1073759855 startScope@var3371 ;
5745:
5746: while (@expr1073759856 scope@var3376 &&@expr1073759857 tok@var3375 &&@expr1073759858 tok@var3375 .@expr1073759859 isName (@expr1073759860 ) ) {
5747: if (@expr1073759861 tok@var3375 .@expr18038 strAt (@expr18039 1 ) ==@expr18040 "::" ||@expr1073759865 (@expr1073759866 tok@var3375 .@expr18038 strAt (@expr18039 1 ) ==@expr1073759869 "<" &&@expr1073759870 Token ::@expr1073759871 simpleMatch (@expr1073759872 tok@var3375 .@expr18049 linkAt (@expr18050 1 ) , "> ::" ) ) ) {
5748: hasPath@var3374 =@expr1073759875 true ;
5749: scope@var3376 =@expr1073759876 scope@var3376 .@expr1073759877 findRecordInNestedList (@expr1073759878 tok@var3375 .@expr18055 str (@expr18056 ) ) ;
5750: if (@expr1073759881 scope@var3376 ) {
5751: if (@expr1073759882 tok@var3375 .@expr18038 strAt (@expr18039 1 ) ==@expr18040 "::" ) {
5752: tok@var3375 =@expr1073759886 tok@var3375 .@expr1073759887 tokAt (@expr1073759888 2 ) ; }
5753: else {
5754: tok@var3375 =@expr1073759889 tok@var3375 .@expr18049 linkAt (@expr18050 1 ) .@expr1073759892 tokAt (@expr1073759893 2 ) ; }
5755: } else {
5756: startScope@var3371 =@expr1073759894 startScope@var3371 .@expr1073759895 nestedIn@var3377 ;
5757: if (@expr1073759896 !@expr1073759897 startScope@var3371 ) {
5758: break ; }
5759: scope@var3376 =@expr1073759898 startScope@var3371 ;
5760: tok@var3375 =@expr1073759899 startTok@var3370 ;
5761: }
5762: } else {
5763: const Type * type@var3378 ; type@var3378 =@expr1073759900 scope@var3376 .@expr1073759901 findType (@expr1073759902 tok@var3375 .@expr18055 str (@expr18056 ) ) ;
5764: if (@expr1073759905 hasPath@var3374 ||@expr1073759906 type@var3378 ) {
5765: return type@var3378 ; }
5766: else {
5767: scope@var3376 =@expr1073759907 scope@var3376 .@expr1073759908 nestedIn@var3379 ;
5768: if (@expr1073759909 !@expr1073759910 scope@var3376 ) {
5769: break ; }
5770: }
5771: }
5772: }
5773:
5774:
5775: return nullptr ;
5776: }
5777:
5778:
5779:
5780: const Scope * SymbolDatabase :: findNamespace ( const Token * tok@var3380 , const Scope * scope@var3381 ) const
5781: {
5782: const Scope * s@var3382 ; s@var3382 =@expr1073759911 findScope (@expr1073759912 tok@var3380 , scope@var3381 ) ;
5783:
5784: if (@expr1073759913 s@var3382 ) {
5785: return s@var3382 ; }
5786: else { if (@expr1073759914 scope@var3381 .@expr18091 nestedIn@var3383 ) {
5787: return findNamespace (@expr1073759916 tok@var3380 , scope@var3381 .@expr18091 nestedIn@var3383 ) ; } }
5788:
5789: return nullptr ;
5790: }
5791:
5792:
5793:
5794: Function * SymbolDatabase :: findFunctionInScope ( const Token * func@var3384 , const Scope * ns@var3385 , const std :: string & path@var3386 , int path_length@var3387 )
5795: {
5796: const Function * function@var3388 ; function@var3388 =@expr1073759918 nullptr ;
5797: const bool destructor@var3389 =@expr1073759919 func@var3384 .@expr18096 strAt (@expr1073759921 -1 ) ==@expr1073759922 "~" ;
5798:
5799: for (@expr1073759923 std ::@expr18100 multimap < std ::@expr18100 string , const Function *@expr18102 > ::@expr18100 const_iterator it@var3390 =@expr1073759928 ns@var3385 .@expr18105 functionMap@var3391 .@expr1073759930 find (@expr1073759931 func@var3384 .@expr18108 str (@expr18109 ) ) ;
5800: it@var3390 !=@expr1073759934 ns@var3385 .@expr18105 functionMap@var3391 .@expr1073759936 end (@expr1073759937 ) &&@expr1073759938 it@var3390 .@expr1073759939 first@var3392 ==@expr1073759940 func@var3384 .@expr18108 str (@expr18109 ) ; ++@expr1073759943 it@var3390 ) {
5801:
5802: if (@expr1073759944 it@var3390 .@expr18121 second@var3393 .@expr1073759946 argsMatch (@expr1073759947 ns@var3385 , it@var3390 .@expr18121 second@var3393 .@expr1073759949 argDef@var3394 , func@var3384 .@expr18126 next (@expr18127 ) , path@var3386 , path_length@var3387 ) &&@expr1073759952
5803: it@var3390 .@expr18121 second@var3393 .@expr1073759954 isDestructor (@expr1073759955 ) ==@expr1073759956 destructor@var3389 ) {
5804: function@var3388 =@expr1073759957 it@var3390 .@expr18121 second@var3393 ;
5805: break ;
5806: }
5807: }
5808:
5809: if (@expr1073759959 !@expr1073759960 function@var3388 ) {
5810: const Scope * scope@var3395 ; scope@var3395 =@expr1073759961 ns@var3385 .@expr1073759962 findRecordInNestedList (@expr1073759963 func@var3384 .@expr18108 str (@expr18109 ) ) ;
5811: if (@expr1073759966 scope@var3395 &&@expr1073759967 Token ::@expr1073759968 Match (@expr1073759969 func@var3384 .@expr18146 tokAt (@expr1073759971 1 ) , "::|<" ) ) {
5812: if (@expr1073759972 func@var3384 .@expr18096 strAt (@expr1073759974 1 ) ==@expr1073759975 "::" ) {
5813: func@var3384 =@expr1073759976 func@var3384 .@expr18146 tokAt (@expr1073759978 2 ) ; }
5814: else { if (@expr1073759979 func@var3384 .@expr18156 linkAt (@expr18157 1 ) ) {
5815: func@var3384 =@expr1073759982 func@var3384 .@expr18156 linkAt (@expr18157 1 ) .@expr1073759985 tokAt (@expr1073759986 2 ) ; }
5816: else {
5817: return nullptr ; } }
5818: if (@expr1073759987 func@var3384 .@expr18108 str (@expr18109 ) ==@expr1073759990 "~" ) {
5819: func@var3384 =@expr1073759991 func@var3384 .@expr18126 next (@expr18127 ) ; }
5820: function@var3388 =@expr1073759994 findFunctionInScope (@expr1073759995 func@var3384 , scope@var3395 , path@var3386 , path_length@var3387 ) ;
5821: }
5822: }
5823:
5824: return const_cast < Function *@expr18102 > (@expr1073759997 function@var3388 ) ;
5825: }
5826:
5827:
5828:
5829: namespace {
5830:
|
5837:
5838: const std :: unordered_set < std :: string > c_keywords@var3396 = { $"_Alignas" $, $"_Alignof" $, $"_Atomic" $, $"_Bool" $, $"_Complex" $, $"_Generic" $, $"_Imaginary" $, $"_Noreturn" $, $"_Static_assert" $, $"_Thread_local" $, $"auto" $, $"break" $, $"case" $, $"char" $, $"const" $, $"continue" $, $"default" $, $"do" $, $"double" $, $"else" $, $"enum" $, $"extern" $, $"float" $, $"for" $, $"goto" $, $"if" $, $"inline" $, $"int" $, $"long" $, $"register" $, $"return" $, $"short" $, $"signed" $, $"sizeof" $, $"static" $, $"struct" $, $"switch" $, $"typedef" $, $"union" $, $"unsigned" $, $"void" $, $"volatile" $, $"while" , "restrict" } ;
5839: const std :: unordered_set < std :: string > cpp_keywords@var3397 = {
5840: $"_Alignas" $, $"_Alignof" $, $"_Atomic" $, $"_Bool" $, $"_Complex" $, $"_Generic" $, $"_Imaginary" $, $"_Noreturn" $, $"_Static_assert" $, $"_Thread_local" $, $"auto" $, $"break" $, $"case" $, $"char" $, $"const" $, $"continue" $, $"default" $, $"do" $, $"double" $, $"else" $, $"enum" $, $"extern" $, $"float" $, $"for" $, $"goto" $, $"if" $, $"inline" $, $"int" $, $"long" $, $"register" $, $"return" $, $"short" $, $"signed" $, $"sizeof" $, $"static" $, $"struct" $, $"switch" $, $"typedef" $, $"union" $, $"unsigned" $, $"void" $, $"volatile" $, $"while" ,
5841: "alignas" , "alignof" , "and" , "and_eq" , "asm" , "bitand" , "bitor" , "bool" , "catch" , "char8_t" , "char16_t" ,
5842: "char32_t" , "class" , "compl" , "concept" , "consteval" , "constexpr" , "constinit" , "const_cast" , "co_await" ,
5843: "co_return" , "co_yield" , "decltype" ,
5844: "delete" , "dynamic_cast" , "explicit" , "export" , "false" , "friend" ,
5845: "mutable" , "namespace" , "new" , "noexcept" , "not" , "not_eq" , "nullptr" , "operator" ,
5846: "or" , "or_eq" , "private" , "protected" , "public" , "reinterpret_cast" ,
5847: "requires" , "static_assert" ,
5848: "static_cast" , "template" , "this" , "thread_local" , "throw" ,
5849: "true" , "try" , "typeid" , "typename" , "using" ,
5850: "virtual" , "wchar_t" , "xor" , "xor_eq"
5851: } ;
5852: }
5853:
5854: bool SymbolDatabase :: isReservedName ( const std :: string & iName@var3398 ) const
5855: {
5856: if (@expr1073759998 isCPP (@expr1073759999 ) ) {
5857: return cpp_keywords@var3397 .@expr1073760000 find (@expr1073760001 iName@var3398 ) !=@expr1073760002 cpp_keywords@var3397 .@expr1073760003 cend (@expr1073760004 ) ; }
5858: else {
5859: return c_keywords@var3396 .@expr1073760005 find (@expr1073760006 iName@var3398 ) !=@expr1073760007 c_keywords@var3396 .@expr1073760008 cend (@expr1073760009 ) ; }
5860: }
5861:
5862: int SymbolDatabase :: sizeOfType ( const Token * type@var3399 ) const
5863: {
5864: int size@var3400 ; size@var3400 =@expr1073760010 mTokenizer@var1403 .@expr18187 sizeOfType (@expr1073760012 type@var3399 ) ;
5865:
5866: if (@expr1073760013 size@var3400 ==@expr1073760014 0 &&@expr1073760015 type@var3399 .@expr18192 type (@expr18193 ) &&@expr1073760018 type@var3399 .@expr18192 type (@expr18193 ) .@expr1073760021 isEnumType (@expr1073760022 ) &&@expr1073760023 type@var3399 .@expr18192 type (@expr18193 ) .@expr18202 classScope@var3855 ) {
5867: size@var3400 =@expr1073760027 mSettings@var1404 .@expr1073760028 sizeof_int@var3830 ;
5868: const Token * enum_type@var3401 ; enum_type@var3401 =@expr1073760029 type@var3399 .@expr18192 type (@expr18193 ) .@expr18202 classScope@var3855 .@expr1073760033 enumType@var3856 ;
5869: if (@expr1073760034 enum_type@var3401 ) {
5870: size@var3400 =@expr1073760035 mTokenizer@var1403 .@expr18187 sizeOfType (@expr1073760037 enum_type@var3401 ) ; }
5871: }
5872:
5873: return size@var3400 ;
5874: }
5875:
5876: static const Token * parsedecl ( const Token * type@var3402 , ValueType * const valuetype@var3403 , ValueType :: Sign defaultSignedness@var3404 , const Settings * settings@var3405 ) ;
5877:
5878: void SymbolDatabase :: setValueType ( Token * tok@var3406 , const Variable & var@var3407 )
5879: {
5880: ValueType valuetype@var3408 ;
5881: if (@expr1073760038 var@var3407 .@expr18215 nameToken (@expr18216 ) ) {
5882: valuetype@var3408 .@expr1073760041 bits@var3409 =@expr1073760042 var@var3407 .@expr18215 nameToken (@expr18216 ) .@expr1073760045 bits (@expr1073760046 ) ; }
5883: valuetype@var3408 .@expr1073760047 pointer@var3410 =@expr1073760048 var@var3407 .@expr1073760049 dimensions (@expr1073760050 ) .@expr1073760051 size (@expr1073760052 ) ;
5884: valuetype@var3408 .@expr1073760053 typeScope@var3411 =@expr1073760054 var@var3407 .@expr1073760055 typeScope (@expr1073760056 ) ;
5885: if (@expr1073760057 var@var3407 .@expr18234 valueType (@expr18235 ) ) {
5886: valuetype@var3408 .@expr1073760060 container@var3412 =@expr1073760061 var@var3407 .@expr18234 valueType (@expr18235 ) .@expr1073760064 container@var3857 ;
5887: valuetype@var3408 .@expr1073760065 containerTypeToken@var3413 =@expr1073760066 var@var3407 .@expr18234 valueType (@expr18235 ) .@expr1073760069 containerTypeToken@var3858 ;
5888: }
5889: valuetype@var3408 .@expr1073760070 smartPointerType@var3414 =@expr1073760071 var@var3407 .@expr1073760072 smartPointerType (@expr1073760073 ) ;
5890: if (@expr1073760074 parsedecl (@expr1073760075 var@var3407 .@expr1073760076 typeStartToken (@expr1073760077 ) , &@expr1073760078 valuetype@var3408 , mDefaultSignedness@var1409 , mSettings@var1404 ) ) {
5891: if (@expr1073760079 tok@var3406 .@expr1073760080 str (@expr1073760081 ) ==@expr1073760082 "." &&@expr1073760083 tok@var3406 .@expr18260 astOperand1 (@expr18261 ) ) {
5892: const ValueType * const vt@var3415 ; vt@var3415 =@expr1073760086 tok@var3406 .@expr18260 astOperand1 (@expr18261 ) .@expr1073760089 valueType (@expr1073760090 ) ;
5893: if (@expr1073760091 vt@var3415 &&@expr1073760092 (@expr1073760093 vt@var3415 .@expr1073760094 constness@var3416 &@expr1073760095 1 ) !=@expr1073760096 0 ) {
5894: valuetype@var3408 .@expr1073760097 constness@var3417 |=@expr1073760098 1 ; }
5895: }
5896: setValueType (@expr1073760099 tok@var3406 , valuetype@var3408 ) ;
5897: }
5898: }
5899:
5900: void SymbolDatabase :: setValueType ( Token * tok@var3418 , const Enumerator & enumerator@var3419 )
5901: {
5902: ValueType valuetype@var3420 ;
5903: valuetype@var3420 .@expr1073760100 typeScope@var3421 =@expr1073760101 enumerator@var3419 .@expr18278 scope@var3422 ;
5904: const Token * type@var3423 ; type@var3423 =@expr1073760103 enumerator@var3419 .@expr18278 scope@var3422 .@expr1073760105 enumType@var3424 ;
5905: if (@expr1073760106 type@var3423 ) {
5906: valuetype@var3420 .@expr18283 type@var3425 =@expr1073760108 ValueType ::@expr1073760109 typeFromString (@expr1073760110 type@var3423 .@expr18287 str (@expr18288 ) , type@var3423 .@expr1073760113 isLong (@expr1073760114 ) ) ;
5907: if (@expr1073760115 valuetype@var3420 .@expr18283 type@var3425 ==@expr1073760117 ValueType ::@expr18294 Type ::@expr1073760119 UNKNOWN_TYPE &&@expr1073760120 type@var3423 .@expr1073760121 isStandardType (@expr1073760122 ) ) {
5908: valuetype@var3420 .@expr1073760123 fromLibraryType (@expr1073760124 type@var3423 .@expr18287 str (@expr18288 ) , mSettings@var1404 ) ; }
5909:
5910: if (@expr1073760127 valuetype@var3420 .@expr1073760128 isIntegral (@expr1073760129 ) ) {
5911: if (@expr1073760130 type@var3423 .@expr1073760131 isSigned (@expr1073760132 ) ) {
5912: valuetype@var3420 .@expr18309 sign@var3426 =@expr1073760134 ValueType ::@expr18311 Sign ::@expr18312 SIGNED ; }
5913: else { if (@expr1073760137 type@var3423 .@expr1073760138 isUnsigned (@expr1073760139 ) ) {
5914: valuetype@var3420 .@expr18309 sign@var3426 =@expr1073760141 ValueType ::@expr18311 Sign ::@expr1073760143 UNSIGNED ; }
5915: else { if (@expr1073760144 valuetype@var3420 .@expr18283 type@var3425 ==@expr1073760146 ValueType ::@expr18294 Type ::@expr1073760148 CHAR ) {
5916: valuetype@var3420 .@expr18309 sign@var3426 =@expr1073760150 mDefaultSignedness@var1409 ; }
5917: else {
5918: valuetype@var3420 .@expr18309 sign@var3426 =@expr1073760152 ValueType ::@expr18311 Sign ::@expr18312 SIGNED ; } } }
5919: }
5920:
5921: setValueType (@expr18331 tok@var3418 , valuetype@var3420 ) ;
5922: } else {
5923: valuetype@var3420 .@expr18309 sign@var3426 =@expr1073760157 ValueType ::@expr1073760158 SIGNED ;
5924: valuetype@var3420 .@expr18283 type@var3425 =@expr1073760160 ValueType ::@expr1073760161 INT ;
5925: setValueType (@expr18331 tok@var3418 , valuetype@var3420 ) ;
5926: }
5927: }
5928:
5929: static void setAutoTokenProperties ( Token * const autoTok@var3427 )
5930: {
5931: const ValueType * valuetype@var3428 ; valuetype@var3428 =@expr1073760163 autoTok@var3427 .@expr1073760164 valueType (@expr1073760165 ) ;
5932: if (@expr1073760166 valuetype@var3428 .@expr1073760167 isIntegral (@expr1073760168 ) ||@expr1073760169 valuetype@var3428 .@expr1073760170 isFloat (@expr1073760171 ) ) {
5933: autoTok@var3427 .@expr1073760172 isStandardType (@expr1073760173 true ) ; }
5934: }
5935:
5936: static bool isContainerYieldElement ( Library :: Container :: Yield yield@var3429 )
5937: {
5938: return yield@var3429 ==@expr1073760174 Library ::@expr18351 Container ::@expr18352 Yield ::@expr1073760177 ITEM ||@expr1073760178 yield@var3429 ==@expr1073760179 Library ::@expr18351 Container ::@expr18352 Yield ::@expr1073760182 AT_INDEX ||@expr1073760183
5939: yield@var3429 ==@expr1073760184 Library ::@expr18351 Container ::@expr18352 Yield ::@expr1073760187 BUFFER ||@expr1073760188 yield@var3429 ==@expr1073760189 Library ::@expr18351 Container ::@expr18352 Yield ::@expr1073760192 BUFFER_NT ;
5940: }
5941:
5942: static bool isContainerYieldPointer ( Library :: Container :: Yield yield@var3430 )
5943: {
5944: return yield@var3430 ==@expr1073760193 Library ::@expr18370 Container ::@expr18371 Yield ::@expr1073760196 BUFFER ||@expr1073760197 yield@var3430 ==@expr1073760198 Library ::@expr18370 Container ::@expr18371 Yield ::@expr1073760201 BUFFER_NT ;
5945: }
5946:
5947: void SymbolDatabase :: setValueType ( Token * tok@var3431 , const ValueType & valuetype@var3432 )
5948: {
5949: tok@var3431 .@expr1073760202 setValueType (@expr1073760203 new ValueType (@expr1073760204 valuetype@var3432 ) ) ;
5950: Token * parent@var3433 ; parent@var3433 =@expr1073760205 tok@var3431 .@expr1073760206 astParent (@expr1073760207 ) ;
5951: if (@expr1073760208 !@expr1073760209 parent@var3433 ||@expr1073760210 parent@var3433 .@expr1073760211 valueType (@expr1073760212 ) ) {
5952: return ; }
5953: if (@expr1073760213 !@expr1073760214 parent@var3433 .@expr18391 astOperand1 (@expr18392 ) ) {
5954: return ; }
5955:
5956: const ValueType * vt1@var3434 ; vt1@var3434 =@expr1073760217 parent@var3433 .@expr18391 astOperand1 (@expr18392 ) ?@expr1073760220 parent@var3433 .@expr18391 astOperand1 (@expr18392 ) .@expr1073760223 valueType (@expr1073760224 ) :@expr1073760225 nullptr ;
5957: const ValueType * vt2@var3435 ; vt2@var3435 =@expr1073760226 parent@var3433 .@expr18403 astOperand2 (@expr18404 ) ?@expr1073760229 parent@var3433 .@expr18403 astOperand2 (@expr18404 ) .@expr1073760232 valueType (@expr1073760233 ) :@expr1073760234 nullptr ;
5958:
5959: if (@expr1073760235 vt1@var3434 &&@expr1073760236 Token ::@expr18413 Match (@expr1073760238 parent@var3433 , "<<|>>" ) ) {
5960: if (@expr1073760239 !@expr18416 mIsCpp@var1408 ||@expr1073760241 (@expr1073760242 vt2@var3435 &&@expr1073760243 vt2@var3435 .@expr18420 isIntegral (@expr18421 ) ) ) {
5961: if (@expr1073760246 vt1@var3434 .@expr18423 type@var3436 <@expr1073760248 ValueType ::@expr18425 Type ::@expr18426 BOOL ||@expr1073760251 vt1@var3434 .@expr18423 type@var3436 >=@expr1073760253 ValueType ::@expr18425 Type ::@expr18431 INT ) {
5962: ValueType vt@var3437 (@expr1073760256 *@expr18433 vt1@var3434 ) ;
5963: vt@var3437 .@expr1073760258 reference@var3438 =@expr1073760259 Reference ::@expr18436 None ;
5964: setValueType (@expr1073760261 parent@var3433 , vt@var3437 ) ;
5965: } else {
5966: ValueType vt@var3439 (@expr1073760262 *@expr18433 vt1@var3434 ) ;
5967: vt@var3439 .@expr1073760264 type@var3440 =@expr1073760265 ValueType ::@expr18425 Type ::@expr18431 INT ;
5968: vt@var3439 .@expr1073760268 sign@var3441 =@expr1073760269 ValueType ::@expr18446 Sign ::@expr18447 SIGNED ;
5969: vt@var3439 .@expr1073760272 reference@var3442 =@expr1073760273 Reference ::@expr18436 None ;
5970: setValueType (@expr1073760275 parent@var3433 , vt@var3439 ) ;
5971: }
5972:
5973: }
5974: return ;
5975: }
5976:
5977: if (@expr1073760276 vt1@var3434 &&@expr1073760277 vt1@var3434 .@expr18454 container@var3443 &&@expr1073760279 vt1@var3434 .@expr18456 containerTypeToken@var3444 &&@expr1073760281 Token ::@expr18413 Match (@expr18459 parent@var3433 , ". %name% (" ) &&@expr1073760284
5978: isContainerYieldElement (@expr1073760285 vt1@var3434 .@expr18454 container@var3443 .@expr18463 getYield (@expr18464 parent@var3433 .@expr18465 next (@expr18466 ) .@expr18467 str (@expr18468 ) ) ) ) {
5979: ValueType item@var3445 ;
5980: if (@expr1073760293 parsedecl (@expr1073760294 vt1@var3434 .@expr18456 containerTypeToken@var3444 , &@expr1073760296 item@var3445 , mDefaultSignedness@var1409 , mSettings@var1404 ) ) {
5981: if (@expr1073760297 item@var3445 .@expr18474 constness@var3446 ==@expr1073760299 0 ) {
5982: item@var3445 .@expr18474 constness@var3446 =@expr1073760301 vt1@var3434 .@expr1073760302 constness@var3447 ; }
5983: if (@expr1073760303 isContainerYieldPointer (@expr1073760304 vt1@var3434 .@expr18454 container@var3443 .@expr18463 getYield (@expr18464 parent@var3433 .@expr18465 next (@expr18466 ) .@expr18467 str (@expr18468 ) ) ) ) {
5984: item@var3445 .@expr1073760312 pointer@var3448 +=@expr1073760313 1 ; }
5985: else {
5986: item@var3445 .@expr1073760314 reference@var3449 =@expr1073760315 Reference ::@expr18492 LValue ; }
5987: setValueType (@expr1073760317 parent@var3433 .@expr18494 tokAt (@expr1073760319 2 ) , item@var3445 ) ;
5988: }
5989: }
5990:
5991: if (@expr1073760320 vt1@var3434 &&@expr1073760321 vt1@var3434 .@expr18498 smartPointerType@var3450 &&@expr1073760323 Token ::@expr18413 Match (@expr18459 parent@var3433 , ". %name% (" ) &&@expr1073760326 parent@var3433 .@expr1073760327 originalName (@expr1073760328 ) ==@expr1073760329 "->" &&@expr1073760330 !@expr1073760331 parent@var3433 .@expr18465 next (@expr18466 ) .@expr18510 function (@expr1073760335 ) ) {
5992: const Scope * scope@var3451 ; scope@var3451 =@expr1073760336 vt1@var3434 .@expr18498 smartPointerType@var3450 .@expr1073760338 classScope@var3452 ;
5993: const Function * f@var3453 ; f@var3453 =@expr1073760339 scope@var3451 ?@expr1073760340 scope@var3451 .@expr1073760341 findFunction (@expr1073760342 parent@var3433 .@expr18465 next (@expr18466 ) , false ) :@expr1073760345 nullptr ;
5994: if (@expr1073760346 f@var3453 ) {
5995: parent@var3433 .@expr18465 next (@expr18466 ) .@expr18510 function (@expr1073760350 f@var3453 ) ; }
5996: }
5997:
5998: if (@expr1073760351 parent@var3433 .@expr18528 isAssignmentOp (@expr18529 ) ) {
5999: if (@expr1073760354 vt1@var3434 ) {
6000: auto vt@var3454 ; vt@var3454 =@expr1073760355 *@expr18433 vt1@var3434 ;
6001: vt@var3454 .@expr1073760357 reference@var3455 =@expr1073760358 Reference ::@expr18436 None ;
6002: setValueType (@expr1073760360 parent@var3433 , vt@var3454 ) ;
6003: } else { if (@expr1073760361 mIsCpp@var1408 &&@expr1073760362 (@expr1073760363 (@expr1073760364 Token ::@expr18413 Match (@expr1073760366 parent@var3433 .@expr18494 tokAt (@expr18544 -3 ) , "%var% ; %var% =" ) &&@expr1073760369 parent@var3433 .@expr18546 strAt (@expr1073760371 -3 ) ==@expr1073760372 parent@var3433 .@expr18546 strAt (@expr1073760374 -1 ) ) ||@expr1073760375
6004: Token ::@expr18413 Match (@expr1073760377 parent@var3433 .@expr18494 tokAt (@expr18555 -1 ) , "%var% =" ) ) ) {
6005: Token * var1Tok@var3456 ; var1Tok@var3456 =@expr1073760380 parent@var3433 .@expr18546 strAt (@expr1073760382 -2 ) ==@expr1073760383 ";" ?@expr1073760384 parent@var3433 .@expr18494 tokAt (@expr18544 -3 ) :@expr1073760387 parent@var3433 .@expr18494 tokAt (@expr18555 -1 ) ;
6006: Token * autoTok@var3457 ; autoTok@var3457 =@expr1073760390 nullptr ;
6007: if (@expr1073760391 Token ::@expr18413 Match (@expr1073760393 var1Tok@var3456 .@expr18570 tokAt (@expr18571 -2 ) , ";|{|}|(|const|constexpr auto" ) ) {
6008: autoTok@var3457 =@expr1073760396 var1Tok@var3456 .@expr1073760397 previous (@expr1073760398 ) ; }
6009: else { if (@expr1073760399 Token ::@expr18413 Match (@expr1073760401 var1Tok@var3456 .@expr18570 tokAt (@expr1073760403 -3 ) , ";|{|}|(|const|constexpr auto *|&|&&" ) ) {
6010: autoTok@var3457 =@expr1073760404 var1Tok@var3456 .@expr18570 tokAt (@expr18571 -2 ) ; } }
6011: if (@expr1073760407 autoTok@var3457 ) {
6012: ValueType vt@var3458 (@expr1073760408 *@expr18585 vt2@var3435 ) ;
6013: if (@expr1073760410 vt@var3458 .@expr18587 constness@var3459 &@expr1073760412 (@expr1073760413 1 <<@expr18590 vt@var3458 .@expr18591 pointer@var3460 ) ) {
6014: vt@var3458 .@expr18587 constness@var3459 &=@expr1073760417 ~@expr1073760418 (@expr1073760419 1 <<@expr18590 vt@var3458 .@expr18591 pointer@var3460 ) ; }
6015: if (@expr1073760422 autoTok@var3457 .@expr18599 strAt (@expr18600 1 ) ==@expr18601 "*" &&@expr1073760426 vt@var3458 .@expr18591 pointer@var3460 ) {
6016: vt@var3458 .@expr18591 pointer@var3460 --@expr1073760429 ; }
6017: if (@expr1073760430 Token ::@expr18413 Match (@expr1073760432 autoTok@var3457 .@expr18609 tokAt (@expr1073760434 -1 ) , "const|constexpr" ) ) {
6018: vt@var3458 .@expr18587 constness@var3459 |=@expr1073760436 1 ; }
6019: setValueType (@expr1073760437 autoTok@var3457 , vt@var3458 ) ;
6020: setAutoTokenProperties (@expr1073760438 autoTok@var3457 ) ;
6021: if (@expr1073760439 vt2@var3435 .@expr18616 pointer@var3461 >@expr1073760441 vt@var3458 .@expr18591 pointer@var3460 ) {
6022: vt@var3458 .@expr18591 pointer@var3460 ++@expr1073760444 ; }
6023: setValueType (@expr1073760445 var1Tok@var3456 , vt@var3458 ) ;
6024: if (@expr1073760446 var1Tok@var3456 !=@expr1073760447 parent@var3433 .@expr18624 previous (@expr18625 ) ) {
6025: setValueType (@expr1073760450 parent@var3433 .@expr18624 previous (@expr18625 ) , vt@var3458 ) ; }
6026: Variable * var@var3462 ; var@var3462 =@expr1073760453 const_cast < Variable *@expr18630 > (@expr18631 parent@var3433 .@expr18624 previous (@expr18625 ) .@expr18634 variable (@expr18635 ) ) ;
6027: if (@expr1073760460 var@var3462 ) {
6028: ValueType vt2_@var3463 (@expr1073760461 *@expr18585 vt2@var3435 ) ;
6029: if (@expr1073760463 vt2_@var3463 .@expr18640 pointer@var3464 ==@expr1073760465 0 &&@expr1073760466 autoTok@var3457 .@expr18599 strAt (@expr18600 1 ) ==@expr18601 "*" ) {
6030: vt2_@var3463 .@expr18640 pointer@var3464 =@expr1073760471 1 ; }
6031: if (@expr1073760472 (@expr1073760473 vt@var3458 .@expr18587 constness@var3459 &@expr1073760475 (@expr1073760476 1 <<@expr18653 vt2@var3435 .@expr18616 pointer@var3461 ) ) !=@expr1073760479 0 ) {
6032: vt2_@var3463 .@expr18656 constness@var3465 |=@expr1073760481 (@expr1073760482 1 <<@expr18653 vt2@var3435 .@expr18616 pointer@var3461 ) ; }
6033: if (@expr1073760485 !@expr1073760486 Token ::@expr18413 Match (@expr1073760488 autoTok@var3457 .@expr18609 tokAt (@expr1073760490 1 ) , "*|&" ) ) {
6034: vt2_@var3463 .@expr18656 constness@var3465 =@expr1073760492 vt@var3458 .@expr18587 constness@var3459 ; }
6035: var@var3462 .@expr1073760494 setValueType (@expr1073760495 vt2_@var3463 ) ;
6036: if (@expr18672 vt2@var3435 .@expr18673 typeScope@var3466 &&@expr18674 vt2@var3435 .@expr18673 typeScope@var3466 .@expr18676 definedType@var3467 ) {
6037: var@var3462 .@expr1073760501 type (@expr1073760502 vt2@var3435 .@expr18673 typeScope@var3466 .@expr18676 definedType@var3467 ) ;
6038: if (@expr1073760505 autoTok@var3457 .@expr1073760506 valueType (@expr1073760507 ) .@expr1073760508 pointer@var3849 ==@expr1073760509 0 ) {
6039: autoTok@var3457 .@expr1073760510 type (@expr1073760511 vt2@var3435 .@expr18673 typeScope@var3466 .@expr18676 definedType@var3467 ) ; }
6040: }
6041: }
6042: }
6043: } }
6044: return ;
6045: }
6046:
6047: if (@expr1073760514 parent@var3433 .@expr18691 str (@expr18692 ) ==@expr18693 "[" &&@expr1073760518 (@expr1073760519 !@expr18416 mIsCpp@var1408 ||@expr1073760521 parent@var3433 .@expr18391 astOperand1 (@expr18392 ) ==@expr18700 tok@var3431 ) &&@expr1073760525 valuetype@var3432 .@expr18702 pointer@var3468 >@expr18703 0U &&@expr1073760528 !@expr1073760529 Token ::@expr18413 Match (@expr1073760531 parent@var3433 .@expr18624 previous (@expr18625 ) , "[{,]" ) ) {
6048: const Token * op1@var3469 ; op1@var3469 =@expr1073760534 parent@var3433 .@expr18391 astOperand1 (@expr18392 ) ;
6049: while (@expr1073760537 op1@var3469 &&@expr1073760538 op1@var3469 .@expr1073760539 str (@expr1073760540 ) ==@expr1073760541 "[" ) {
6050: op1@var3469 =@expr1073760542 op1@var3469 .@expr1073760543 astOperand1 (@expr1073760544 ) ; }
6051:
6052: ValueType vt@var3470 (@expr1073760545 valuetype@var3432 ) ;
6053:
6054: if (@expr1073760546 !@expr1073760547 (@expr1073760548 op1@var3469 &&@expr1073760549 op1@var3469 .@expr18726 variable (@expr18727 ) &&@expr1073760552 op1@var3469 .@expr18726 variable (@expr18727 ) .@expr1073760555 nameToken (@expr1073760556 ) ==@expr1073760557 op1@var3469 ) ) {
6055: vt@var3470 .@expr1073760558 pointer@var3471 -=@expr1073760559 1U ; }
6056: setValueType (@expr1073760560 parent@var3433 , vt@var3470 ) ;
6057: return ;
6058: }
6059: if (@expr1073760561 Token ::@expr18413 Match (@expr1073760563 parent@var3433 .@expr18624 previous (@expr18625 ) , "%name% (" ) &&@expr1073760566 parent@var3433 .@expr18391 astOperand1 (@expr18392 ) ==@expr18700 tok@var3431 &&@expr1073760570 valuetype@var3432 .@expr18702 pointer@var3468 >@expr18703 0U ) {
6060: ValueType vt@var3472 (@expr1073760573 valuetype@var3432 ) ;
6061: vt@var3472 .@expr1073760574 pointer@var3473 -=@expr1073760575 1U ;
6062: setValueType (@expr1073760576 parent@var3433 , vt@var3472 ) ;
6063: return ;
6064: }
6065:
6066: if (@expr1073760577 vt2@var3435 &&@expr1073760578 parent@var3433 .@expr18691 str (@expr18692 ) ==@expr1073760581 "(" &&@expr1073760582 Token ::@expr18759 simpleMatch (@expr1073760584 parent@var3433 .@expr18494 tokAt (@expr18544 -3 ) , "std :: move (" ) ) {
6067: ValueType vt@var3474 ; vt@var3474 =@expr1073760587 valuetype@var3432 ;
6068: vt@var3474 .@expr1073760588 reference@var3475 =@expr1073760589 Reference ::@expr1073760590 RValue ;
6069: setValueType (@expr1073760591 parent@var3433 , vt@var3474 ) ;
6070: return ;
6071: }
6072: if (@expr1073760592 parent@var3433 .@expr18691 str (@expr18692 ) ==@expr18771 "*" &&@expr18772 !@expr18773 parent@var3433 .@expr18403 astOperand2 (@expr18404 ) &&@expr1073760600 valuetype@var3432 .@expr18702 pointer@var3468 >@expr18703 0U ) {
6073: ValueType vt@var3476 (@expr1073760603 valuetype@var3432 ) ;
6074: vt@var3476 .@expr1073760604 pointer@var3477 -=@expr1073760605 1U ;
6075: setValueType (@expr1073760606 parent@var3433 , vt@var3476 ) ;
6076: return ;
6077: }
6078:
6079: if (@expr1073760607 parent@var3433 .@expr18691 str (@expr18692 ) ==@expr18771 "*" &&@expr18772 !@expr18773 parent@var3433 .@expr18403 astOperand2 (@expr18404 ) &&@expr1073760615 valuetype@var3432 .@expr18792 type@var3478 ==@expr1073760617 ValueType ::@expr18425 Type ::@expr18795 ITERATOR &&@expr1073760620
6080: valuetype@var3432 .@expr18797 containerTypeToken@var3479 ) {
6081: ValueType vt@var3480 ;
6082: if (@expr1073760622 parsedecl (@expr1073760623 valuetype@var3432 .@expr18797 containerTypeToken@var3479 , &@expr1073760625 vt@var3480 , mDefaultSignedness@var1409 , mSettings@var1404 ) ) {
6083: if (@expr1073760626 vt@var3480 .@expr18803 constness@var3481 ==@expr1073760628 0 ) {
6084: vt@var3480 .@expr18803 constness@var3481 =@expr1073760630 valuetype@var3432 .@expr18807 constness@var3482 ; }
6085: vt@var3480 .@expr1073760632 reference@var3483 =@expr1073760633 Reference ::@expr18492 LValue ;
6086: setValueType (@expr1073760635 parent@var3433 , vt@var3480 ) ;
6087: return ;
6088: }
6089: }
6090:
6091: if (@expr1073760636 parent@var3433 .@expr18691 str (@expr18692 ) ==@expr18771 "*" &&@expr18772 !@expr18773 parent@var3433 .@expr18403 astOperand2 (@expr18404 ) &&@expr1073760644 valuetype@var3432 .@expr18792 type@var3478 ==@expr1073760646 ValueType ::@expr18425 Type ::@expr1073760648 SMART_POINTER &&@expr1073760649
6092: valuetype@var3432 .@expr18826 smartPointerTypeToken@var3484 ) {
6093: ValueType vt@var3485 ;
6094: if (@expr1073760651 parsedecl (@expr1073760652 valuetype@var3432 .@expr18826 smartPointerTypeToken@var3484 , &@expr1073760654 vt@var3485 , mDefaultSignedness@var1409 , mSettings@var1404 ) ) {
6095: if (@expr1073760655 vt@var3485 .@expr18832 constness@var3486 ==@expr1073760657 0 ) {
6096: vt@var3485 .@expr18832 constness@var3486 =@expr1073760659 valuetype@var3432 .@expr18807 constness@var3482 ; }
6097: setValueType (@expr1073760661 parent@var3433 , vt@var3485 ) ;
6098: return ;
6099: }
6100: }
6101: if (@expr1073760662 parent@var3433 .@expr18691 str (@expr18692 ) ==@expr18771 "*" &&@expr1073760666 Token ::@expr18759 simpleMatch (@expr1073760668 parent@var3433 .@expr18403 astOperand2 (@expr18404 ) , "[" ) &&@expr1073760671 valuetype@var3432 .@expr18702 pointer@var3468 >@expr18703 0U ) {
6102: const Token * op1@var3487 ; op1@var3487 =@expr1073760674 parent@var3433 .@expr18403 astOperand2 (@expr18404 ) .@expr1073760677 astOperand1 (@expr1073760678 ) ;
6103: while (@expr1073760679 op1@var3487 &&@expr1073760680 op1@var3487 .@expr1073760681 str (@expr1073760682 ) ==@expr1073760683 "[" ) {
6104: op1@var3487 =@expr1073760684 op1@var3487 .@expr1073760685 astOperand1 (@expr1073760686 ) ; }
6105: const ValueType & vt@var3488 (@expr1073760687 valuetype@var3432 ) ;
6106: if (@expr1073760688 op1@var3487 &&@expr1073760689 op1@var3487 .@expr18866 variable (@expr18867 ) &&@expr1073760692 op1@var3487 .@expr18866 variable (@expr18867 ) .@expr1073760695 nameToken (@expr1073760696 ) ==@expr1073760697 op1@var3487 ) {
6107: setValueType (@expr1073760698 parent@var3433 , vt@var3488 ) ;
6108: return ;
6109: }
6110: }
6111: if (@expr1073760699 parent@var3433 .@expr18691 str (@expr18692 ) ==@expr1073760702 "&" &&@expr1073760703 !@expr18773 parent@var3433 .@expr18403 astOperand2 (@expr18404 ) ) {
6112: ValueType vt@var3489 (@expr1073760707 valuetype@var3432 ) ;
6113: vt@var3489 .@expr1073760708 reference@var3490 =@expr1073760709 Reference ::@expr18436 None ;
6114: vt@var3489 .@expr1073760711 pointer@var3491 +=@expr1073760712 1U ;
6115: setValueType (@expr1073760713 parent@var3433 , vt@var3489 ) ;
6116: return ;
6117: }
6118:
6119: if (@expr1073760714 (@expr1073760715 parent@var3433 .@expr18691 str (@expr18692 ) ==@expr1073760718 "." ||@expr1073760719 parent@var3433 .@expr18691 str (@expr18692 ) ==@expr1073760722 "::" ) &&@expr1073760723
6120: parent@var3433 .@expr18403 astOperand2 (@expr18404 ) &&@expr1073760726 parent@var3433 .@expr18403 astOperand2 (@expr18404 ) .@expr1073760729 isName (@expr1073760730 ) ) {
6121: const Variable * var@var3492 ; var@var3492 =@expr1073760731 parent@var3433 .@expr18403 astOperand2 (@expr18404 ) .@expr1073760734 variable (@expr1073760735 ) ;
6122: if (@expr1073760736 !@expr1073760737 var@var3492 &&@expr1073760738 valuetype@var3432 .@expr1073760739 typeScope@var3493 &&@expr1073760740 vt1@var3434 ) {
6123: const std ::@expr18917 string &@expr1073760742 name@var3494 =@expr1073760743 parent@var3433 .@expr18403 astOperand2 (@expr18404 ) .@expr1073760746 str (@expr1073760747 ) ;
6124: const Scope * typeScope@var3495 ; typeScope@var3495 =@expr1073760748 vt1@var3434 .@expr1073760749 typeScope@var3496 ;
6125: if (@expr1073760750 !@expr1073760751 typeScope@var3495 ) {
6126: return ; }
6127: for (@expr1073760752 std ::@expr18917 list < Variable > ::@expr18917 const_iterator it@var3497 =@expr1073760755 typeScope@var3495 .@expr18932 varlist@var3498 .@expr1073760757 begin (@expr1073760758 ) ; it@var3497 !=@expr1073760759 typeScope@var3495 .@expr18932 varlist@var3498 .@expr1073760761 end (@expr1073760762 ) ; ++@expr1073760763 it@var3497 ) {
6128: if (@expr1073760764 it@var3497 .@expr1073760765 nameToken (@expr1073760766 ) .@expr1073760767 str (@expr1073760768 ) ==@expr1073760769 name@var3494 ) {
6129: var@var3492 =@expr1073760770 &@expr1073760771 *@expr1073760772 it@var3497 ;
6130: break ;
6131: }
6132: }
6133: }
6134: if (@expr1073760773 var@var3492 ) {
6135: setValueType (@expr1073760774 parent@var3433 , *@expr1073760775 var@var3492 ) ; }
6136: return ;
6137: }
6138:
6139:
6140: if (@expr1073760776 vt2@var3435 &&@expr1073760777
6141: parent@var3433 .@expr18691 str (@expr18692 ) ==@expr18956 ":" &&@expr1073760781
6142: Token ::@expr18413 Match (@expr1073760783 parent@var3433 .@expr18960 astParent (@expr18961 ) , "( const| auto *|&| %var% :" ) &&@expr1073760786
6143: !@expr1073760787 parent@var3433 .@expr18624 previous (@expr18625 ) .@expr1073760790 valueType (@expr1073760791 ) &&@expr1073760792
6144: Token ::@expr18759 simpleMatch (@expr1073760794 parent@var3433 .@expr18960 astParent (@expr18961 ) .@expr1073760797 astOperand1 (@expr1073760798 ) , "for" ) ) {
6145: const bool isconst@var3499 =@expr1073760799 Token ::@expr18759 simpleMatch (@expr1073760801 parent@var3433 .@expr18960 astParent (@expr18961 ) .@expr1073760804 next (@expr1073760805 ) , "const" ) ;
6146: Token * const autoToken@var3500 ; autoToken@var3500 =@expr1073760806 parent@var3433 .@expr18960 astParent (@expr18961 ) .@expr1073760809 tokAt (@expr1073760810 isconst@var3499 ?@expr1073760811 2 :@expr1073760812 1 ) ;
6147: if (@expr1073760813 vt2@var3435 .@expr18616 pointer@var3461 ) {
6148: ValueType autovt@var3501 (@expr1073760815 *@expr18585 vt2@var3435 ) ;
6149: autovt@var3501 .@expr1073760817 pointer@var3502 --@expr1073760818 ;
6150: autovt@var3501 .@expr1073760819 constness@var3503 =@expr1073760820 0 ;
6151: setValueType (@expr1073760821 autoToken@var3500 , autovt@var3501 ) ;
6152: setAutoTokenProperties (@expr18998 autoToken@var3500 ) ;
6153: ValueType varvt@var3504 (@expr1073760823 *@expr18585 vt2@var3435 ) ;
6154: varvt@var3504 .@expr19001 pointer@var3505 --@expr1073760826 ;
6155: if (@expr1073760827 Token ::@expr18759 simpleMatch (@expr1073760829 autoToken@var3500 .@expr1073760830 next (@expr1073760831 ) , "&" ) ) {
6156: varvt@var3504 .@expr19008 reference@var3506 =@expr1073760833 Reference ::@expr18492 LValue ; }
6157: if (@expr19011 isconst@var3499 ) {
6158: if (@expr1073760836 varvt@var3504 .@expr19001 pointer@var3505 &&@expr1073760838 varvt@var3504 .@expr19008 reference@var3506 !=@expr1073760840 Reference ::@expr18436 None ) {
6159: varvt@var3504 .@expr19018 constness@var3507 |=@expr1073760843 2 ; }
6160: else {
6161: varvt@var3504 .@expr19018 constness@var3507 |=@expr1073760845 1 ; }
6162: }
6163: setValueType (@expr1073760846 parent@var3433 .@expr18624 previous (@expr18625 ) , varvt@var3504 ) ;
6164: Variable * var@var3508 ; var@var3508 =@expr1073760849 const_cast < Variable *@expr18630 > (@expr18631 parent@var3433 .@expr18624 previous (@expr18625 ) .@expr18634 variable (@expr18635 ) ) ;
6165: if (@expr1073760856 var@var3508 ) {
6166: var@var3508 .@expr1073760857 setValueType (@expr1073760858 varvt@var3504 ) ;
6167: if (@expr18672 vt2@var3435 .@expr18673 typeScope@var3466 &&@expr18674 vt2@var3435 .@expr18673 typeScope@var3466 .@expr18676 definedType@var3467 ) {
6168: var@var3508 .@expr1073760864 type (@expr1073760865 vt2@var3435 .@expr18673 typeScope@var3466 .@expr18676 definedType@var3467 ) ;
6169: autoToken@var3500 .@expr19044 type (@expr1073760869 vt2@var3435 .@expr18673 typeScope@var3466 .@expr18676 definedType@var3467 ) ;
6170: }
6171: }
6172: } else { if (@expr1073760872 vt2@var3435 .@expr19049 container@var3509 ) {
6173:
6174: const Token * typeStart@var3510 ; typeStart@var3510 =@expr1073760874 parent@var3433 .@expr18403 astOperand2 (@expr18404 ) ;
6175: while (@expr1073760877 typeStart@var3510 ) {
6176: if (@expr1073760878 typeStart@var3510 .@expr19055 variable (@expr19056 ) ) {
6177: typeStart@var3510 =@expr1073760881 typeStart@var3510 .@expr19055 variable (@expr19056 ) .@expr1073760884 typeStartToken (@expr1073760885 ) ; }
6178: else { if (@expr1073760886 typeStart@var3510 .@expr1073760887 str (@expr1073760888 ) ==@expr1073760889 "(" &&@expr1073760890 typeStart@var3510 .@expr19067 previous (@expr19068 ) &&@expr1073760893 typeStart@var3510 .@expr19067 previous (@expr19068 ) .@expr19072 function (@expr19073 ) ) {
6179: typeStart@var3510 =@expr1073760898 typeStart@var3510 .@expr19067 previous (@expr19068 ) .@expr19072 function (@expr19073 ) .@expr1073760903 retDef@var3865 ; }
6180: else {
6181: break ; } }
6182: }
6183:
6184:
6185:
6186: bool setType@var3511 ; setType@var3511 =@expr1073760904 false ;
6187: ValueType autovt@var3512 ;
6188: const Type * templateArgType@var3513 ; templateArgType@var3513 =@expr1073760905 nullptr ;
6189: if (@expr1073760906 !@expr1073760907 vt2@var3435 .@expr19049 container@var3509 .@expr1073760909 rangeItemRecordType@var3514 .@expr1073760910 empty (@expr1073760911 ) ) {
6190: setType@var3511 =@expr1073760912 true ;
6191: autovt@var3512 .@expr19089 type@var3515 =@expr1073760914 ValueType ::@expr18425 Type ::@expr1073760916 RECORD ;
6192: } else { if (@expr1073760917 vt2@var3435 .@expr19094 containerTypeToken@var3516 ) {
6193: if (@expr1073760919 mSettings@var1404 .@expr1073760920 library@var3824 .@expr1073760921 isSmartPointer (@expr1073760922 vt2@var3435 .@expr19094 containerTypeToken@var3516 ) ) {
6194: const Token * smartPointerTypeTok@var3517 ; smartPointerTypeTok@var3517 =@expr1073760924 vt2@var3435 .@expr19094 containerTypeToken@var3516 ;
6195: while (@expr1073760926 Token ::@expr18413 Match (@expr1073760928 smartPointerTypeTok@var3517 , "%name%|::" ) ) {
6196: smartPointerTypeTok@var3517 =@expr1073760929 smartPointerTypeTok@var3517 .@expr19106 next (@expr19107 ) ; }
6197: if (@expr1073760932 Token ::@expr18413 Match (@expr1073760934 smartPointerTypeTok@var3517 , "< %name% > >" ) &&@expr1073760935 smartPointerTypeTok@var3517 .@expr19106 next (@expr19107 ) .@expr19114 type (@expr19115 ) ) {
6198: setType@var3511 =@expr1073760940 true ;
6199: templateArgType@var3513 =@expr1073760941 smartPointerTypeTok@var3517 .@expr19106 next (@expr19107 ) .@expr19114 type (@expr19115 ) ;
6200: autovt@var3512 .@expr1073760946 smartPointerType@var3518 =@expr1073760947 templateArgType@var3513 ;
6201: autovt@var3512 .@expr19089 type@var3515 =@expr1073760949 ValueType ::@expr18425 Type ::@expr1073760951 NONSTD ;
6202: }
6203: } else { if (@expr1073760952 parsedecl (@expr1073760953 vt2@var3435 .@expr19094 containerTypeToken@var3516 , &@expr1073760955 autovt@var3512 , mDefaultSignedness@var1409 , mSettings@var1404 ) ) {
6204: setType@var3511 =@expr1073760956 true ;
6205: templateArgType@var3513 =@expr1073760957 vt2@var3435 .@expr19094 containerTypeToken@var3516 .@expr1073760959 type (@expr1073760960 ) ;
6206: } }
6207: } }
6208:
6209: if (@expr1073760961 setType@var3511 ) {
6210:
6211: setValueType (@expr1073760962 autoToken@var3500 , autovt@var3512 ) ;
6212: setAutoTokenProperties (@expr18998 autoToken@var3500 ) ;
6213: ValueType varvt@var3519 (@expr1073760964 autovt@var3512 ) ;
6214: if (@expr19011 isconst@var3499 ) {
6215: varvt@var3519 .@expr1073760966 constness@var3520 |=@expr1073760967 (@expr1073760968 1 <<@expr1073760969 varvt@var3519 .@expr1073760970 pointer@var3521 ) ; }
6216: setValueType (@expr1073760971 parent@var3433 .@expr18624 previous (@expr18625 ) , varvt@var3519 ) ;
6217: Variable * var@var3522 ; var@var3522 =@expr1073760974 const_cast < Variable *@expr18630 > (@expr18631 parent@var3433 .@expr18624 previous (@expr18625 ) .@expr18634 variable (@expr18635 ) ) ;
6218: if (@expr1073760981 var@var3522 ) {
6219: var@var3522 .@expr1073760982 setValueType (@expr1073760983 varvt@var3519 ) ;
6220: if (@expr1073760984 templateArgType@var3513 &&@expr1073760985 templateArgType@var3513 .@expr19162 classScope@var3523 &&@expr1073760987 templateArgType@var3513 .@expr19162 classScope@var3523 .@expr19165 definedType@var3524 ) {
6221: autoToken@var3500 .@expr19044 type (@expr1073760991 templateArgType@var3513 .@expr19162 classScope@var3523 .@expr19165 definedType@var3524 ) ;
6222: var@var3522 .@expr1073760994 type (@expr1073760995 templateArgType@var3513 .@expr19162 classScope@var3523 .@expr19165 definedType@var3524 ) ;
6223: }
6224: }
6225: }
6226: } }
6227: }
6228:
6229: if (@expr1073760998 vt1@var3434 &&@expr1073760999 vt1@var3434 .@expr18456 containerTypeToken@var3444 &&@expr1073761001 parent@var3433 .@expr18691 str (@expr18692 ) ==@expr18693 "[" ) {
6230: ValueType vtParent@var3525 ;
6231: if (@expr1073761005 parsedecl (@expr1073761006 vt1@var3434 .@expr18456 containerTypeToken@var3444 , &@expr1073761008 vtParent@var3525 , mDefaultSignedness@var1409 , mSettings@var1404 ) ) {
6232: setValueType (@expr1073761009 parent@var3433 , vtParent@var3525 ) ;
6233: return ;
6234: }
6235: }
6236:
6237: if (@expr1073761010 mIsCpp@var1408 &&@expr1073761011 vt2@var3435 &&@expr1073761012 Token ::@expr18759 simpleMatch (@expr1073761014 parent@var3433 .@expr18624 previous (@expr18625 ) , "decltype (" ) ) {
6238: setValueType (@expr19193 parent@var3433 , *@expr18585 vt2@var3435 ) ;
6239: return ;
6240: }
6241:
6242:
6243: if (@expr1073761019 mIsCpp@var1408 &&@expr1073761020 mSettings@var1404 .@expr1073761021 standards@var3822 .@expr1073761022 cpp@var3823 >=@expr1073761023 Standards ::@expr1073761024 CPP17 &&@expr1073761025 vt2@var3435 &&@expr1073761026 Token ::@expr18413 Match (@expr1073761028 parent@var3433 .@expr18494 tokAt (@expr19206 -2 ) , "auto %var% {" ) ) {
6244: Token * autoTok@var3526 ; autoTok@var3526 =@expr1073761031 parent@var3433 .@expr18494 tokAt (@expr19206 -2 ) ;
6245: setValueType (@expr1073761034 autoTok@var3526 , *@expr18585 vt2@var3435 ) ;
6246: setAutoTokenProperties (@expr1073761036 autoTok@var3526 ) ;
6247: if (@expr1073761037 parent@var3433 .@expr18624 previous (@expr18625 ) .@expr18634 variable (@expr18635 ) ) {
6248: const_cast < Variable *@expr18630 > (@expr18631 parent@var3433 .@expr18624 previous (@expr18625 ) .@expr18634 variable (@expr18635 ) ) .@expr1073761048 setValueType (@expr1073761049 *@expr18585 vt2@var3435 ) ; }
6249: else {
6250: debugMessage (@expr1073761051 parent@var3433 .@expr18624 previous (@expr18625 ) , "debug" , "Missing variable class for variable with varid" ) ; }
6251: return ;
6252: }
6253:
6254: if (@expr1073761054 !@expr1073761055 vt1@var3434 ) {
6255: return ; }
6256: if (@expr1073761056 parent@var3433 .@expr18403 astOperand2 (@expr18404 ) &&@expr1073761059 !@expr19236 vt2@var3435 ) {
6257: return ; }
6258:
6259: const bool ternary@var3527 =@expr1073761061 parent@var3433 .@expr18691 str (@expr18692 ) ==@expr18956 ":" &&@expr1073761065 parent@var3433 .@expr18960 astParent (@expr18961 ) &&@expr1073761068 parent@var3433 .@expr18960 astParent (@expr18961 ) .@expr1073761071 str (@expr1073761072 ) ==@expr1073761073 "?" ;
6260: if (@expr1073761074 ternary@var3527 ) {
6261: if (@expr1073761075 vt2@var3435 &&@expr1073761076 vt1@var3434 .@expr19253 pointer@var3528 ==@expr1073761078 vt2@var3435 .@expr18616 pointer@var3461 &&@expr1073761080 vt1@var3434 .@expr18423 type@var3436 ==@expr19258 vt2@var3435 .@expr19259 type@var3529 &&@expr1073761084 vt1@var3434 .@expr19261 sign@var3530 ==@expr1073761086 vt2@var3435 .@expr19263 sign@var3531 ) {
6262: setValueType (@expr19193 parent@var3433 , *@expr18585 vt2@var3435 ) ; }
6263: parent@var3433 =@expr1073761090 parent@var3433 .@expr18960 astParent (@expr18961 ) ;
6264: }
6265:
6266: if (@expr1073761093 ternary@var3527 ||@expr19270 parent@var3433 .@expr19271 isArithmeticalOp (@expr19272 ) ||@expr1073761097 parent@var3433 .@expr19274 tokType (@expr19275 ) ==@expr19276 Token ::@expr19277 eIncDecOp ) {
6267:
6268:
6269: if (@expr1073761102 parent@var3433 .@expr18691 str (@expr18692 ) ==@expr19281 "+" &&@expr19282 vt1@var3434 .@expr18423 type@var3436 ==@expr19284 ValueType ::@expr18425 Type ::@expr19286 CONTAINER &&@expr19287 vt2@var3435 &&@expr1073761112 vt2@var3435 .@expr18420 isIntegral (@expr18421 ) ) {
6270: setValueType (@expr19291 parent@var3433 , *@expr18433 vt1@var3434 ) ;
6271: return ;
6272: }
6273:
6274: if (@expr1073761117 parent@var3433 .@expr18691 str (@expr18692 ) ==@expr19281 "+" &&@expr1073761121 vt1@var3434 .@expr19298 isIntegral (@expr19299 ) &&@expr1073761124 vt2@var3435 &&@expr1073761125 vt2@var3435 .@expr19259 type@var3529 ==@expr19303 ValueType ::@expr18425 Type ::@expr19286 CONTAINER ) {
6275: setValueType (@expr19193 parent@var3433 , *@expr18585 vt2@var3435 ) ;
6276: return ;
6277: }
6278:
6279: if (@expr1073761132 vt1@var3434 .@expr19253 pointer@var3528 !=@expr19310 0U &&@expr1073761135 vt2@var3435 &&@expr1073761136 vt2@var3435 .@expr18616 pointer@var3461 ==@expr19314 0U ) {
6280: setValueType (@expr19291 parent@var3433 , *@expr18433 vt1@var3434 ) ;
6281: return ;
6282: }
6283:
6284: if (@expr1073761141 vt1@var3434 .@expr19253 pointer@var3528 ==@expr19319 0U &&@expr1073761144 vt2@var3435 &&@expr1073761145 vt2@var3435 .@expr18616 pointer@var3461 !=@expr1073761147 0U ) {
6285: setValueType (@expr19193 parent@var3433 , *@expr18585 vt2@var3435 ) ;
6286: return ;
6287: }
6288:
6289: if (@expr1073761150 vt1@var3434 .@expr19253 pointer@var3528 !=@expr19310 0U ) {
6290: if (@expr1073761153 ternary@var3527 ||@expr1073761154 parent@var3433 .@expr19274 tokType (@expr19275 ) ==@expr19276 Token ::@expr19277 eIncDecOp ) {
6291: setValueType (@expr19291 parent@var3433 , *@expr18433 vt1@var3434 ) ; }
6292: else {
6293: setValueType (@expr1073761161 parent@var3433 , ValueType (@expr1073761162 ValueType ::@expr18446 Sign ::@expr18447 SIGNED , ValueType ::@expr18425 Type ::@expr18431 INT , 0U , 0U , "ptrdiff_t" ) ) ; }
6294: return ;
6295: }
6296:
6297: if (@expr1073761167 vt1@var3434 .@expr18423 type@var3436 ==@expr1073761169 ValueType ::@expr18425 Type ::@expr19347 LONGDOUBLE ||@expr1073761172 (@expr1073761173 vt2@var3435 &&@expr1073761174 vt2@var3435 .@expr19259 type@var3529 ==@expr1073761176 ValueType ::@expr18425 Type ::@expr19347 LONGDOUBLE ) ) {
6298: setValueType (@expr1073761179 parent@var3433 , ValueType (@expr1073761180 ValueType ::@expr18446 Sign ::@expr19358 UNKNOWN_SIGN , ValueType ::@expr18425 Type ::@expr19347 LONGDOUBLE , 0U ) ) ;
6299: return ;
6300: }
6301: if (@expr1073761185 vt1@var3434 .@expr18423 type@var3436 ==@expr1073761187 ValueType ::@expr18425 Type ::@expr19365 DOUBLE ||@expr1073761190 (@expr1073761191 vt2@var3435 &&@expr1073761192 vt2@var3435 .@expr19259 type@var3529 ==@expr1073761194 ValueType ::@expr18425 Type ::@expr19365 DOUBLE ) ) {
6302: setValueType (@expr1073761197 parent@var3433 , ValueType (@expr1073761198 ValueType ::@expr18446 Sign ::@expr19358 UNKNOWN_SIGN , ValueType ::@expr18425 Type ::@expr19365 DOUBLE , 0U ) ) ;
6303: return ;
6304: }
6305: if (@expr1073761203 vt1@var3434 .@expr18423 type@var3436 ==@expr1073761205 ValueType ::@expr18425 Type ::@expr19383 FLOAT ||@expr1073761208 (@expr1073761209 vt2@var3435 &&@expr1073761210 vt2@var3435 .@expr19259 type@var3529 ==@expr1073761212 ValueType ::@expr18425 Type ::@expr19383 FLOAT ) ) {
6306: setValueType (@expr1073761215 parent@var3433 , ValueType (@expr1073761216 ValueType ::@expr18446 Sign ::@expr19358 UNKNOWN_SIGN , ValueType ::@expr18425 Type ::@expr19383 FLOAT , 0U ) ) ;
6307: return ;
6308: }
6309:
6310:
6311: if (@expr1073761221 vt1@var3434 .@expr18423 type@var3436 ==@expr1073761223 ValueType ::@expr18425 Type ::@expr18795 ITERATOR &&@expr1073761226 vt2@var3435 &&@expr1073761227 vt2@var3435 .@expr18420 isIntegral (@expr18421 ) &&@expr1073761230
6312: (@expr1073761231 parent@var3433 .@expr18691 str (@expr18692 ) ==@expr19281 "+" ||@expr1073761235 parent@var3433 .@expr18691 str (@expr18692 ) ==@expr1073761238 "-" ) ) {
6313: setValueType (@expr19291 parent@var3433 , *@expr18433 vt1@var3434 ) ;
6314: return ;
6315: }
6316:
6317: if (@expr1073761241 parent@var3433 .@expr18691 str (@expr18692 ) ==@expr19281 "+" &&@expr19282 vt1@var3434 .@expr18423 type@var3436 ==@expr19284 ValueType ::@expr18425 Type ::@expr19286 CONTAINER &&@expr19287 vt2@var3435 &&@expr1073761251 vt2@var3435 .@expr19259 type@var3529 ==@expr19303 ValueType ::@expr18425 Type ::@expr19286 CONTAINER &&@expr1073761256 vt1@var3434 .@expr18454 container@var3443 ==@expr1073761258 vt2@var3435 .@expr19049 container@var3509 ) {
6318: setValueType (@expr19291 parent@var3433 , *@expr18433 vt1@var3434 ) ;
6319: return ;
6320: }
6321: }
6322:
6323: if (@expr1073761262 vt1@var3434 .@expr19298 isIntegral (@expr19299 ) &&@expr1073761265 vt1@var3434 .@expr19253 pointer@var3528 ==@expr19319 0U &&@expr1073761268
6324: (@expr1073761269 !@expr19236 vt2@var3435 ||@expr1073761271 (@expr1073761272 vt2@var3435 .@expr18420 isIntegral (@expr18421 ) &&@expr1073761275 vt2@var3435 .@expr18616 pointer@var3461 ==@expr19314 0U ) ) &&@expr1073761278
6325: (@expr1073761279 ternary@var3527 ||@expr19270 parent@var3433 .@expr19271 isArithmeticalOp (@expr19272 ) ||@expr1073761283 parent@var3433 .@expr19274 tokType (@expr19275 ) ==@expr1073761286 Token ::@expr1073761287 eBitOp ||@expr1073761288 parent@var3433 .@expr19274 tokType (@expr19275 ) ==@expr19276 Token ::@expr19277 eIncDecOp ||@expr1073761293 parent@var3433 .@expr18528 isAssignmentOp (@expr18529 ) ) ) {
6326:
6327: ValueType vt@var3532 ;
6328: if (@expr1073761296 !@expr19236 vt2@var3435 ||@expr1073761298 vt1@var3434 .@expr18423 type@var3436 >@expr1073761300 vt2@var3435 .@expr19259 type@var3529 ) {
6329: vt@var3532 .@expr19478 type@var3533 =@expr1073761303 vt1@var3434 .@expr18423 type@var3436 ;
6330: vt@var3532 .@expr19481 sign@var3534 =@expr1073761306 vt1@var3434 .@expr19261 sign@var3530 ;
6331: vt@var3532 .@expr19484 originalTypeName@var3535 =@expr1073761309 vt1@var3434 .@expr19486 originalTypeName@var3536 ;
6332: } else { if (@expr1073761311 vt1@var3434 .@expr18423 type@var3436 ==@expr19258 vt2@var3435 .@expr19259 type@var3529 ) {
6333: vt@var3532 .@expr19478 type@var3533 =@expr1073761316 vt1@var3434 .@expr18423 type@var3436 ;
6334: if (@expr1073761318 vt1@var3434 .@expr19261 sign@var3530 ==@expr1073761320 ValueType ::@expr18446 Sign ::@expr19498 UNSIGNED ||@expr1073761323 vt2@var3435 .@expr19263 sign@var3531 ==@expr1073761325 ValueType ::@expr18446 Sign ::@expr19498 UNSIGNED ) {
6335: vt@var3532 .@expr19481 sign@var3534 =@expr1073761329 ValueType ::@expr18446 Sign ::@expr19498 UNSIGNED ; }
6336: else { if (@expr1073761332 vt1@var3434 .@expr19261 sign@var3530 ==@expr1073761334 ValueType ::@expr18446 Sign ::@expr19358 UNKNOWN_SIGN ||@expr1073761337 vt2@var3435 .@expr19263 sign@var3531 ==@expr1073761339 ValueType ::@expr18446 Sign ::@expr19358 UNKNOWN_SIGN ) {
6337: vt@var3532 .@expr19481 sign@var3534 =@expr1073761343 ValueType ::@expr18446 Sign ::@expr19358 UNKNOWN_SIGN ; }
6338: else {
6339: vt@var3532 .@expr19481 sign@var3534 =@expr1073761347 ValueType ::@expr18446 Sign ::@expr18447 SIGNED ; } }
6340: vt@var3532 .@expr19484 originalTypeName@var3535 =@expr1073761351 (@expr1073761352 vt1@var3434 .@expr19486 originalTypeName@var3536 .@expr1073761354 empty (@expr1073761355 ) ?@expr1073761356 vt2@var3435 :@expr1073761357 vt1@var3434 ) .@expr1073761358 originalTypeName@var3536 ;
6341: } else {
6342: vt@var3532 .@expr19478 type@var3533 =@expr1073761360 vt2@var3435 .@expr19259 type@var3529 ;
6343: vt@var3532 .@expr19481 sign@var3534 =@expr1073761363 vt2@var3435 .@expr19263 sign@var3531 ;
6344: vt@var3532 .@expr19484 originalTypeName@var3535 =@expr1073761366 vt2@var3435 .@expr1073761367 originalTypeName@var3537 ;
6345: } }
6346: if (@expr1073761368 vt@var3532 .@expr19478 type@var3533 <@expr1073761370 ValueType ::@expr18425 Type ::@expr18431 INT &&@expr1073761373 !@expr1073761374 (@expr1073761375 ternary@var3527 &&@expr1073761376 vt@var3532 .@expr19478 type@var3533 ==@expr1073761378 ValueType ::@expr18425 Type ::@expr18426 BOOL ) ) {
6347: vt@var3532 .@expr19478 type@var3533 =@expr1073761382 ValueType ::@expr18425 Type ::@expr18431 INT ;
6348: vt@var3532 .@expr19481 sign@var3534 =@expr1073761386 ValueType ::@expr18446 Sign ::@expr18447 SIGNED ;
6349: vt@var3532 .@expr19484 originalTypeName@var3535 .@expr1073761390 clear (@expr1073761391 ) ;
6350: }
6351:
6352: setValueType (@expr1073761392 parent@var3433 , vt@var3532 ) ;
6353: return ;
6354: }
6355: }
6356:
6357: static const Token * parsedecl ( const Token * type@var3538 , ValueType * const valuetype@var3539 , ValueType :: Sign defaultSignedness@var3540 , const Settings * settings@var3541 )
6358: {
6359: const Token * const previousType@var3542 ; previousType@var3542 =@expr1073761394 type@var3538 ;
6360: const unsigned int pointer0@var3543 =@expr1073761395 valuetype@var3539 .@expr19572 pointer@var3544 ;
6361: while (@expr1073761397 Token ::@expr19574 Match (@expr1073761399 type@var3538 .@expr19576 previous (@expr19577 ) , "%name%" ) &&@expr1073761402 !@expr1073761403 endsWith (@expr1073761404 type@var3538 .@expr19576 previous (@expr19577 ) .@expr1073761407 str (@expr1073761408 ) , ':' ) ) {
6362: type@var3538 =@expr1073761409 type@var3538 .@expr19576 previous (@expr19577 ) ; }
6363: valuetype@var3539 .@expr19588 sign@var3545 =@expr1073761413 ValueType ::@expr19590 Sign ::@expr19591 UNKNOWN_SIGN ;
6364: if (@expr1073761416 !@expr19593 valuetype@var3539 .@expr19594 typeScope@var3546 &&@expr1073761419 !@expr1073761420 valuetype@var3539 .@expr19597 smartPointerType@var3547 ) {
6365: valuetype@var3539 .@expr19598 type@var3548 =@expr1073761423 ValueType ::@expr19600 Type ::@expr19601 UNKNOWN_TYPE ; }
6366: else { if (@expr1073761426 valuetype@var3539 .@expr19597 smartPointerType@var3547 ) {
6367: valuetype@var3539 .@expr19598 type@var3548 =@expr1073761429 ValueType ::@expr19600 Type ::@expr19607 SMART_POINTER ; }
6368: else { if (@expr1073761432 valuetype@var3539 .@expr19594 typeScope@var3546 .@expr1073761434 type@var3549 ==@expr1073761435 Scope ::@expr1073761436 eEnum ) {
6369: const Token * enum_type@var3550 ; enum_type@var3550 =@expr1073761437 valuetype@var3539 .@expr19594 typeScope@var3546 .@expr1073761439 enumType@var3551 ;
6370: if (@expr1073761440 enum_type@var3550 ) {
6371: if (@expr1073761441 enum_type@var3550 .@expr1073761442 isSigned (@expr1073761443 ) ) {
6372: valuetype@var3539 .@expr19588 sign@var3545 =@expr1073761445 ValueType ::@expr19590 Sign ::@expr19623 SIGNED ; }
6373: else { if (@expr1073761448 enum_type@var3550 .@expr1073761449 isUnsigned (@expr1073761450 ) ) {
6374: valuetype@var3539 .@expr19588 sign@var3545 =@expr1073761452 ValueType ::@expr19590 Sign ::@expr19630 UNSIGNED ; }
6375: else {
6376: valuetype@var3539 .@expr19588 sign@var3545 =@expr1073761456 defaultSignedness@var3540 ; } }
6377: const ValueType ::@expr19633 Type t@var3552 =@expr1073761458 ValueType ::@expr19635 typeFromString (@expr1073761460 enum_type@var3550 .@expr19637 str (@expr19638 ) , enum_type@var3550 .@expr1073761463 isLong (@expr1073761464 ) ) ;
6378: if (@expr1073761465 t@var3552 !=@expr1073761466 ValueType ::@expr19600 Type ::@expr19601 UNKNOWN_TYPE ) {
6379: valuetype@var3539 .@expr19598 type@var3548 =@expr1073761470 t@var3552 ; }
6380: else { if (@expr1073761471 enum_type@var3550 .@expr1073761472 isStandardType (@expr1073761473 ) ) {
6381: valuetype@var3539 .@expr19650 fromLibraryType (@expr1073761475 enum_type@var3550 .@expr19637 str (@expr19638 ) , settings@var3541 ) ; } }
6382: } else {
6383: valuetype@var3539 .@expr19598 type@var3548 =@expr1073761479 ValueType ::@expr19600 Type ::@expr19657 INT ; }
6384: } else {
6385: valuetype@var3539 .@expr19598 type@var3548 =@expr1073761483 ValueType ::@expr19600 Type ::@expr19661 RECORD ; } } }
6386: bool par@var3553 ; par@var3553 =@expr1073761486 false ;
6387: while (@expr1073761487 Token ::@expr19574 Match (@expr1073761489 type@var3538 , "%name%|*|&|&&|::|(" ) &&@expr1073761490 !@expr1073761491 Token ::@expr19574 Match (@expr1073761493 type@var3538 , "typename|template" ) &&@expr1073761494 type@var3538 .@expr1073761495 varId (@expr1073761496 ) ==@expr1073761497 0 &&@expr1073761498
6388: !@expr19675 type@var3538 .@expr19676 variable (@expr19677 ) &&@expr1073761502 !@expr1073761503 type@var3538 .@expr1073761504 function (@expr1073761505 ) ) {
6389: bool isIterator@var3554 ; isIterator@var3554 =@expr1073761506 false ;
6390: if (@expr1073761507 type@var3538 .@expr19684 str (@expr19685 ) ==@expr19686 "(" ) {
6391: if (@expr1073761511 Token ::@expr19574 Match (@expr1073761513 type@var3538 .@expr19690 link (@expr19691 ) , ") const| {" ) ) {
6392: break ; }
6393: if (@expr1073761516 par@var3553 ) {
6394: break ; }
6395: par@var3553 =@expr1073761517 true ;
6396: }
6397: if (@expr1073761518 Token ::@expr1073761519 simpleMatch (@expr1073761520 type@var3538 , "decltype (" ) &&@expr1073761521 type@var3538 .@expr19698 next (@expr19699 ) .@expr19700 valueType (@expr19701 ) ) {
6398: const ValueType * vt2@var3555 ; vt2@var3555 =@expr1073761526 type@var3538 .@expr19698 next (@expr19699 ) .@expr19700 valueType (@expr19701 ) ;
6399: if (@expr1073761531 valuetype@var3539 .@expr19588 sign@var3545 ==@expr19709 ValueType ::@expr19590 Sign ::@expr19591 UNKNOWN_SIGN ) {
6400: valuetype@var3539 .@expr19588 sign@var3545 =@expr1073761537 vt2@var3555 .@expr1073761538 sign@var3556 ; }
6401: if (@expr1073761539 valuetype@var3539 .@expr19598 type@var3548 ==@expr19717 ValueType ::@expr19600 Type ::@expr19601 UNKNOWN_TYPE ) {
6402: valuetype@var3539 .@expr19598 type@var3548 =@expr1073761545 vt2@var3555 .@expr1073761546 type@var3557 ; }
6403: valuetype@var3539 .@expr19723 constness@var3558 +=@expr1073761548 vt2@var3555 .@expr1073761549 constness@var3559 ;
6404: valuetype@var3539 .@expr19572 pointer@var3544 +=@expr1073761551 vt2@var3555 .@expr1073761552 pointer@var3560 ;
6405: valuetype@var3539 .@expr19729 reference@var3561 =@expr1073761554 vt2@var3555 .@expr1073761555 reference@var3562 ;
6406: type@var3538 =@expr1073761556 type@var3538 .@expr1073761557 linkAt (@expr1073761558 1 ) .@expr1073761559 next (@expr1073761560 ) ;
6407: continue ;
6408: } else { if (@expr1073761561 type@var3538 .@expr1073761562 isSigned (@expr1073761563 ) ) {
6409: valuetype@var3539 .@expr19588 sign@var3545 =@expr1073761565 ValueType ::@expr19590 Sign ::@expr19623 SIGNED ; }
6410: else { if (@expr1073761568 type@var3538 .@expr1073761569 isUnsigned (@expr1073761570 ) ) {
6411: valuetype@var3539 .@expr19588 sign@var3545 =@expr1073761572 ValueType ::@expr19590 Sign ::@expr19630 UNSIGNED ; } } }
6412: if (@expr1073761575 valuetype@var3539 .@expr19598 type@var3548 ==@expr19717 ValueType ::@expr19600 Type ::@expr19601 UNKNOWN_TYPE &&@expr1073761580
6413: type@var3538 .@expr19757 type (@expr19758 ) &&@expr1073761583 type@var3538 .@expr19757 type (@expr19758 ) .@expr1073761586 isTypeAlias (@expr1073761587 ) &&@expr1073761588 type@var3538 .@expr19757 type (@expr19758 ) .@expr19767 typeStart@var3859 &&@expr1073761592
6414: type@var3538 .@expr19757 type (@expr19758 ) .@expr19767 typeStart@var3859 .@expr1073761596 str (@expr1073761597 ) !=@expr1073761598 type@var3538 .@expr19684 str (@expr19685 ) &&@expr1073761601 type@var3538 .@expr19757 type (@expr19758 ) .@expr19767 typeStart@var3859 !=@expr1073761605 previousType@var3542 ) {
6415: parsedecl (@expr1073761606 type@var3538 .@expr19757 type (@expr19758 ) .@expr19767 typeStart@var3859 , valuetype@var3539 , defaultSignedness@var3540 , settings@var3541 ) ; }
6416: else { if (@expr1073761610 Token ::@expr19574 Match (@expr1073761612 type@var3538 , "const|constexpr" ) ) {
6417: valuetype@var3539 .@expr19723 constness@var3558 |=@expr1073761614 (@expr1073761615 1 <<@expr1073761616 (@expr1073761617 valuetype@var3539 .@expr19572 pointer@var3544 -@expr1073761619 pointer0@var3543 ) ) ; }
6418: else { if (@expr1073761620 settings@var3541 .@expr1073761621 clang@var3563 &&@expr1073761622 type@var3538 .@expr19684 str (@expr19685 ) .@expr19801 size (@expr19802 ) >@expr1073761627 2 &&@expr1073761628 type@var3538 .@expr19684 str (@expr19685 ) .@expr19807 find (@expr1073761632 "::" ) <@expr1073761633 type@var3538 .@expr19684 str (@expr19685 ) .@expr19807 find (@expr1073761637 "<" ) ) {
6419: TokenList typeTokens@var3564 (@expr1073761638 settings@var3541 ) ;
6420: std ::@expr19815 string ::@expr1073761640 size_type pos1@var3565 ; pos1@var3565 =@expr1073761641 0 ;
6421: do {
6422: std ::@expr19815 string ::@expr1073761643 size_type pos2@var3566 ; pos2@var3566 =@expr1073761644 type@var3538 .@expr19684 str (@expr19685 ) .@expr19807 find (@expr1073761648 "::" , pos1@var3565 ) ;
6423: if (@expr1073761649 pos2@var3566 ==@expr1073761650 std ::@expr19815 string ::@expr1073761652 npos@expr1073761393 ) {
6424: typeTokens@var3564 .@expr19829 addtoken (@expr1073761654 type@var3538 .@expr19684 str (@expr19685 ) .@expr19833 substr (@expr1073761658 pos1@var3565 ) , 0 , 0 , 0 , false ) ;
6425: break ;
6426: }
6427: typeTokens@var3564 .@expr19829 addtoken (@expr1073761660 type@var3538 .@expr19684 str (@expr19685 ) .@expr19833 substr (@expr1073761664 pos1@var3565 , pos2@var3566 -@expr1073761665 pos1@var3565 ) , 0 , 0 , 0 , false ) ;
6428: typeTokens@var3564 .@expr19829 addtoken (@expr1073761667 "::" , 0 , 0 , 0 , false ) ;
6429: pos1@var3565 =@expr1073761668 pos2@var3566 +@expr1073761669 2 ;
6430: } while (@expr1073761670 pos1@var3565 <@expr1073761671 type@var3538 .@expr19684 str (@expr19685 ) .@expr19801 size (@expr19802 ) ) ;
6431: const Library ::@expr1073761676 Container * container@var3567 ; container@var3567 =@expr1073761677
6432: settings@var3541 .@expr19854 library@var3568 .@expr19855 detectContainerOrIterator (@expr1073761680 typeTokens@var3564 .@expr19857 front (@expr19858 ) , &@expr19859 isIterator@var3554 ) ;
6433: if (@expr1073761684 container@var3567 ) {
6434: if (@expr19861 isIterator@var3554 ) {
6435: valuetype@var3539 .@expr19598 type@var3548 =@expr1073761687 ValueType ::@expr19600 Type ::@expr19865 ITERATOR ; }
6436: else {
6437: valuetype@var3539 .@expr19598 type@var3548 =@expr1073761691 ValueType ::@expr19600 Type ::@expr19869 CONTAINER ; }
6438: valuetype@var3539 .@expr19870 container@var3569 =@expr1073761695 container@var3567 ;
6439: } else {
6440: const Scope * scope@var3570 ; scope@var3570 =@expr1073761696 type@var3538 .@expr1073761697 scope (@expr1073761698 ) ;
6441: valuetype@var3539 .@expr19594 typeScope@var3546 =@expr1073761700 scope@var3570 .@expr1073761701 check@var3571 .@expr1073761702 findScope (@expr1073761703 typeTokens@var3564 .@expr19857 front (@expr19858 ) , scope@var3570 ) ;
6442: if (@expr1073761706 valuetype@var3539 .@expr19594 typeScope@var3546 ) {
6443: valuetype@var3539 .@expr19598 type@var3548 =@expr1073761709 (@expr1073761710 scope@var3570 .@expr1073761711 type@var3572 ==@expr1073761712 Scope ::@expr19889 ScopeType ::@expr1073761714 eClass ) ?@expr1073761715 ValueType ::@expr19600 Type ::@expr19661 RECORD :@expr19894 ValueType ::@expr19600 Type ::@expr19896 NONSTD ; }
6444: }
6445: } else { if (@expr1073761721 const Library ::@expr19633 Container *@expr19899 container@var3573 =@expr1073761724 settings@var3541 .@expr19854 library@var3568 .@expr19855 detectContainerOrIterator (@expr1073761727 type@var3538 , &@expr19859 isIterator@var3554 ) ) {
6446: if (@expr19861 isIterator@var3554 ) {
6447: valuetype@var3539 .@expr19598 type@var3548 =@expr1073761731 ValueType ::@expr19600 Type ::@expr19865 ITERATOR ; }
6448: else {
6449: valuetype@var3539 .@expr19598 type@var3548 =@expr1073761735 ValueType ::@expr19600 Type ::@expr19869 CONTAINER ; }
6450: valuetype@var3539 .@expr19870 container@var3569 =@expr1073761739 container@var3573 ;
6451: while (@expr1073761740 Token ::@expr19574 Match (@expr1073761742 type@var3538 , "%type%|::|<" ) &&@expr1073761743 type@var3538 .@expr19684 str (@expr19685 ) !=@expr1073761746 "const" ) {
6452: if (@expr1073761747 type@var3538 .@expr19684 str (@expr19685 ) ==@expr1073761750 "<" &&@expr1073761751 type@var3538 .@expr19690 link (@expr19691 ) ) {
6453: if (@expr1073761754 container@var3573 .@expr19931 type_templateArgNo@var3574 >=@expr1073761756 0 ) {
6454: const Token * templateType@var3575 ; templateType@var3575 =@expr1073761757 type@var3538 .@expr19698 next (@expr19699 ) ;
6455: for (@expr1073761760 int j@var3576 =@expr1073761761 0 ; templateType@var3575 &&@expr1073761762 j@var3576 <@expr1073761763 container@var3573 .@expr19931 type_templateArgNo@var3574 ; j@var3576 ++@expr1073761765 ) {
6456: templateType@var3575 =@expr1073761766 templateType@var3575 .@expr1073761767 nextTemplateArgument (@expr1073761768 ) ; }
6457: valuetype@var3539 .@expr1073761769 containerTypeToken@var3577 =@expr1073761770 templateType@var3575 ;
6458: }
6459: type@var3538 =@expr1073761771 type@var3538 .@expr19690 link (@expr19691 ) ;
6460: }
6461: type@var3538 =@expr1073761774 type@var3538 .@expr19698 next (@expr19699 ) ;
6462: }
6463: if (@expr1073761777 type@var3538 &&@expr1073761778 type@var3538 .@expr19684 str (@expr19685 ) ==@expr19686 "(" &&@expr1073761782 type@var3538 .@expr19576 previous (@expr19577 ) .@expr1073761785 function (@expr1073761786 ) ) {
6464:
6465: type@var3538 =@expr1073761787 type@var3538 .@expr19576 previous (@expr19577 ) ; }
6466: continue ;
6467: } else { if (@expr1073761790 const Library ::@expr19633 SmartPointer *@expr19899 smartPointer@var3578 =@expr1073761793 settings@var3541 .@expr19854 library@var3568 .@expr1073761795 detectSmartPointer (@expr1073761796 type@var3538 ) ) {
6468: const Token * argTok@var3579 ; argTok@var3579 =@expr1073761797 Token ::@expr1073761798 findsimplematch (@expr1073761799 type@var3538 , "<" ) ;
6469: if (@expr1073761800 !@expr1073761801 argTok@var3579 ) {
6470: continue ; }
6471: valuetype@var3539 .@expr1073761802 smartPointer@var3580 =@expr1073761803 smartPointer@var3578 ;
6472: valuetype@var3539 .@expr1073761804 smartPointerTypeToken@var3581 =@expr1073761805 argTok@var3579 .@expr19982 next (@expr19983 ) ;
6473: valuetype@var3539 .@expr19597 smartPointerType@var3547 =@expr1073761809 argTok@var3579 .@expr19982 next (@expr19983 ) .@expr1073761812 type (@expr1073761813 ) ;
6474: valuetype@var3539 .@expr19598 type@var3548 =@expr1073761815 ValueType ::@expr19600 Type ::@expr19607 SMART_POINTER ;
6475: type@var3538 =@expr1073761818 argTok@var3579 .@expr1073761819 link (@expr1073761820 ) ;
6476: if (@expr1073761821 type@var3538 ) {
6477: type@var3538 =@expr1073761822 type@var3538 .@expr19698 next (@expr19699 ) ; }
6478: continue ;
6479: } else { if (@expr1073761825 Token ::@expr19574 Match (@expr1073761827 type@var3538 , "%name% :: %name%" ) ) {
6480: std ::@expr1073761828 string typestr@var3582 ;
6481: const Token * end@var3583 ; end@var3583 =@expr1073761829 type@var3538 ;
6482: while (@expr1073761830 Token ::@expr19574 Match (@expr1073761832 end@var3583 , "%name% :: %name%" ) ) {
6483: typestr@var3582 +=@expr1073761833 end@var3583 .@expr20010 str (@expr20011 ) +@expr1073761836 "::" ;
6484: end@var3583 =@expr1073761837 end@var3583 .@expr1073761838 tokAt (@expr1073761839 2 ) ;
6485: }
6486: typestr@var3582 +=@expr1073761840 end@var3583 .@expr20010 str (@expr20011 ) ;
6487: if (@expr1073761843 valuetype@var3539 .@expr19650 fromLibraryType (@expr1073761845 typestr@var3582 , settings@var3541 ) ) {
6488: type@var3538 =@expr1073761846 end@var3583 ; }
6489: } else { if (@expr1073761847 ValueType ::@expr19600 Type ::@expr19601 UNKNOWN_TYPE !=@expr1073761850 ValueType ::@expr19635 typeFromString (@expr20028 type@var3538 .@expr19684 str (@expr19685 ) , type@var3538 .@expr20031 isLong (@expr20032 ) ) ) {
6490: ValueType ::@expr1073761857 Type t0@var3584 ; t0@var3584 =@expr1073761858 valuetype@var3539 .@expr19598 type@var3548 ;
6491: valuetype@var3539 .@expr19598 type@var3548 =@expr1073761861 ValueType ::@expr19635 typeFromString (@expr20028 type@var3538 .@expr19684 str (@expr19685 ) , type@var3538 .@expr20031 isLong (@expr20032 ) ) ;
6492: if (@expr1073761868 t0@var3584 ==@expr1073761869 ValueType ::@expr19600 Type ::@expr20047 LONG ) {
6493: if (@expr1073761872 valuetype@var3539 .@expr19598 type@var3548 ==@expr1073761874 ValueType ::@expr19600 Type ::@expr20047 LONG ) {
6494: valuetype@var3539 .@expr19598 type@var3548 =@expr1073761878 ValueType ::@expr19600 Type ::@expr1073761880 LONGLONG ; }
6495: else { if (@expr1073761881 valuetype@var3539 .@expr19598 type@var3548 ==@expr1073761883 ValueType ::@expr19600 Type ::@expr1073761885 DOUBLE ) {
6496: valuetype@var3539 .@expr19598 type@var3548 =@expr1073761887 ValueType ::@expr19600 Type ::@expr1073761889 LONGDOUBLE ; } }
6497: }
6498: } else { if (@expr1073761890 type@var3538 .@expr19684 str (@expr19685 ) ==@expr1073761893 "auto" ) {
6499: const ValueType * vt@var3585 ; vt@var3585 =@expr1073761894 type@var3538 .@expr1073761895 valueType (@expr1073761896 ) ;
6500: if (@expr1073761897 !@expr1073761898 vt@var3585 ) {
6501: return nullptr ; }
6502: valuetype@var3539 .@expr19598 type@var3548 =@expr1073761900 vt@var3585 .@expr1073761901 type@var3586 ;
6503: valuetype@var3539 .@expr19572 pointer@var3544 =@expr1073761903 vt@var3585 .@expr1073761904 pointer@var3587 ;
6504: if (@expr1073761905 vt@var3585 .@expr20082 sign@var3588 !=@expr1073761907 ValueType ::@expr19590 Sign ::@expr19591 UNKNOWN_SIGN ) {
6505: valuetype@var3539 .@expr19588 sign@var3545 =@expr1073761911 vt@var3585 .@expr20082 sign@var3588 ; }
6506: valuetype@var3539 .@expr19723 constness@var3558 =@expr1073761914 vt@var3585 .@expr1073761915 constness@var3589 ;
6507: valuetype@var3539 .@expr20092 originalTypeName@var3590 =@expr1073761917 vt@var3585 .@expr1073761918 originalTypeName@var3591 ;
6508: while (@expr1073761919 Token ::@expr19574 Match (@expr1073761921 type@var3538 , "%name%|*|&|::" ) &&@expr1073761922 !@expr19675 type@var3538 .@expr19676 variable (@expr19677 ) ) {
6509: if (@expr20102 type@var3538 .@expr19684 str (@expr19685 ) ==@expr20105 "*" ) {
6510: valuetype@var3539 .@expr19572 pointer@var3544 ++@expr1073761931 ; }
6511: if (@expr1073761932 type@var3538 .@expr19684 str (@expr19685 ) ==@expr1073761935 "const" ) {
6512: valuetype@var3539 .@expr19723 constness@var3558 |=@expr1073761937 (@expr1073761938 1 <<@expr1073761939 valuetype@var3539 .@expr19572 pointer@var3544 ) ; }
6513: type@var3538 =@expr1073761941 type@var3538 .@expr19698 next (@expr19699 ) ;
6514: }
6515: break ;
6516: } else { if (@expr1073761944 !@expr19593 valuetype@var3539 .@expr19594 typeScope@var3546 &&@expr1073761947 (@expr1073761948 type@var3538 .@expr19684 str (@expr19685 ) ==@expr20127 "struct" ||@expr1073761952 type@var3538 .@expr19684 str (@expr19685 ) ==@expr1073761955 "enum" ) ) {
6517: valuetype@var3539 .@expr19598 type@var3548 =@expr1073761957 type@var3538 .@expr19684 str (@expr19685 ) ==@expr20127 "struct" ?@expr1073761961 ValueType ::@expr19600 Type ::@expr19661 RECORD :@expr19894 ValueType ::@expr19600 Type ::@expr19896 NONSTD ; }
6518: else { if (@expr1073761967 !@expr19593 valuetype@var3539 .@expr19594 typeScope@var3546 &&@expr1073761970 type@var3538 .@expr19757 type (@expr19758 ) &&@expr1073761973 type@var3538 .@expr19757 type (@expr19758 ) .@expr20152 classScope@var3855 ) {
6519: if (@expr1073761977 type@var3538 .@expr19757 type (@expr19758 ) .@expr20152 classScope@var3855 .@expr1073761981 type@var3860 ==@expr1073761982 Scope ::@expr19889 ScopeType ::@expr1073761984 eEnum ) {
6520: valuetype@var3539 .@expr19598 type@var3548 =@expr1073761986 ValueType ::@expr19600 Type ::@expr19657 INT ;
6521: valuetype@var3539 .@expr19588 sign@var3545 =@expr1073761990 ValueType ::@expr19590 Sign ::@expr19623 SIGNED ;
6522: } else {
6523: valuetype@var3539 .@expr19598 type@var3548 =@expr1073761994 ValueType ::@expr19600 Type ::@expr19661 RECORD ;
6524: }
6525: valuetype@var3539 .@expr19594 typeScope@var3546 =@expr1073761998 type@var3538 .@expr19757 type (@expr19758 ) .@expr20152 classScope@var3855 ;
6526: } else { if (@expr1073762002 type@var3538 .@expr1073762003 isName (@expr1073762004 ) &&@expr1073762005 valuetype@var3539 .@expr19588 sign@var3545 !=@expr1073762007 ValueType ::@expr19590 Sign ::@expr19591 UNKNOWN_SIGN &&@expr1073762010 valuetype@var3539 .@expr19572 pointer@var3544 ==@expr1073762012 0U ) {
6527: return nullptr ; }
6528: else { if (@expr20102 type@var3538 .@expr19684 str (@expr19685 ) ==@expr20105 "*" ) {
6529: valuetype@var3539 .@expr19572 pointer@var3544 ++@expr1073762018 ; }
6530: else { if (@expr1073762019 type@var3538 .@expr19684 str (@expr19685 ) ==@expr1073762022 "&" ) {
6531: valuetype@var3539 .@expr19729 reference@var3561 =@expr1073762024 Reference ::@expr1073762025 LValue ; }
6532: else { if (@expr1073762026 type@var3538 .@expr19684 str (@expr19685 ) ==@expr1073762029 "&&" ) {
6533: valuetype@var3539 .@expr19729 reference@var3561 =@expr1073762031 Reference ::@expr1073762032 RValue ; }
6534: else { if (@expr1073762033 type@var3538 .@expr1073762034 isStandardType (@expr1073762035 ) ) {
6535: valuetype@var3539 .@expr19650 fromLibraryType (@expr20213 type@var3538 .@expr19684 str (@expr19685 ) , settings@var3541 ) ; }
6536: else { if (@expr1073762040 Token ::@expr19574 Match (@expr1073762042 type@var3538 .@expr19576 previous (@expr19577 ) , "!!:: %name% !!::" ) ) {
6537: valuetype@var3539 .@expr19650 fromLibraryType (@expr20213 type@var3538 .@expr19684 str (@expr19685 ) , settings@var3541 ) ; } } } } } } } } } } } } } } } }
6538: if (@expr1073762049 !@expr1073762050 type@var3538 .@expr20227 originalName (@expr20228 ) .@expr1073762053 empty (@expr1073762054 ) ) {
6539: valuetype@var3539 .@expr20092 originalTypeName@var3590 =@expr1073762056 type@var3538 .@expr20227 originalName (@expr20228 ) ; }
6540: type@var3538 =@expr1073762059 type@var3538 .@expr19698 next (@expr19699 ) ;
6541: }
6542:
6543:
6544: if (@expr1073762062 valuetype@var3539 .@expr1073762063 isIntegral (@expr1073762064 ) &&@expr1073762065 valuetype@var3539 .@expr19588 sign@var3545 ==@expr19709 ValueType ::@expr19590 Sign ::@expr19591 UNKNOWN_SIGN ) {
6545: if (@expr1073762070 valuetype@var3539 .@expr19598 type@var3548 ==@expr1073762072 ValueType ::@expr19600 Type ::@expr1073762074 CHAR ) {
6546: valuetype@var3539 .@expr19588 sign@var3545 =@expr1073762076 defaultSignedness@var3540 ; }
6547: else { if (@expr1073762077 valuetype@var3539 .@expr19598 type@var3548 >=@expr1073762079 ValueType ::@expr19600 Type ::@expr1073762081 SHORT ) {
6548: valuetype@var3539 .@expr19588 sign@var3545 =@expr1073762083 ValueType ::@expr19590 Sign ::@expr19623 SIGNED ; } }
6549: }
6550:
6551: return (@expr20262 type@var3538 &&@expr1073762087 (@expr20262 valuetype@var3539 .@expr19598 type@var3548 !=@expr1073762090 ValueType ::@expr19600 Type ::@expr19601 UNKNOWN_TYPE ||@expr1073762093 valuetype@var3539 .@expr19572 pointer@var3544 >@expr1073762095 0 ||@expr1073762096 valuetype@var3539 .@expr19729 reference@var3561 !=@expr1073762098 Reference ::@expr1073762099 None ) ) ?@expr1073762100 type@var3538 :@expr1073762101 nullptr ;
6552: }
6553:
6554: static const Scope * getClassScope ( const Token * tok@var3592 )
6555: {
6556: return tok@var3592 &&@expr1073762102 tok@var3592 .@expr20279 valueType (@expr20280 ) &&@expr1073762105 tok@var3592 .@expr20279 valueType (@expr20280 ) .@expr20284 typeScope@var3854 &&@expr1073762109 tok@var3592 .@expr20279 valueType (@expr20280 ) .@expr20284 typeScope@var3854 .@expr1073762113 isClassOrStruct (@expr1073762114 ) ?@expr1073762115
6557: tok@var3592 .@expr20279 valueType (@expr20280 ) .@expr20284 typeScope@var3854 :@expr1073762119
6558: nullptr ;
6559: }
6560:
6561: static const Function * getOperatorFunction ( const Token * const tok@var3593 )
6562: {
6563: const std ::@expr1073762120 string functionName@var3594 (@expr1073762121 "operator" +@expr1073762122 tok@var3593 .@expr1073762123 str (@expr1073762124 ) ) ;
6564: std ::@expr1073762125 multimap < std ::@expr1073762126 string , const Function *@expr1073762127 > ::@expr1073762128 const_iterator it@var3595 ;
6565:
6566: const Scope * classScope@var3596 ; classScope@var3596 =@expr1073762129 getClassScope (@expr1073762130 tok@var3593 .@expr1073762131 astOperand1 (@expr1073762132 ) ) ;
6567: if (@expr20309 classScope@var3596 ) {
6568: it@var3595 =@expr1073762134 classScope@var3596 .@expr20311 functionMap@var3597 .@expr20312 find (@expr20313 functionName@var3594 ) ;
6569: if (@expr20314 it@var3595 !=@expr20315 classScope@var3596 .@expr20311 functionMap@var3597 .@expr20317 end (@expr20318 ) ) {
6570: return it@var3595 .@expr20319 second@var3598 ; }
6571: }
6572:
6573: classScope@var3596 =@expr1073762144 getClassScope (@expr1073762145 tok@var3593 .@expr1073762146 astOperand2 (@expr1073762147 ) ) ;
6574: if (@expr20309 classScope@var3596 ) {
6575: it@var3595 =@expr1073762149 classScope@var3596 .@expr20311 functionMap@var3597 .@expr20312 find (@expr20313 functionName@var3594 ) ;
6576: if (@expr20314 it@var3595 !=@expr20315 classScope@var3596 .@expr20311 functionMap@var3597 .@expr20317 end (@expr20318 ) ) {
6577: return it@var3595 .@expr20319 second@var3598 ; }
6578: }
6579:
6580: return nullptr ;
6581: }
6582:
6583: void SymbolDatabase :: setValueTypeInTokenList ( bool reportDebugWarnings@var3599 , Token * tokens@var3600 )
6584: {
6585: if (@expr1073762161 !@expr1073762162 tokens@var3600 ) {
6586: tokens@var3600 =@expr1073762163 const_cast < Tokenizer *@expr20340 > (@expr1073762165 mTokenizer@var1403 ) .@expr1073762166 list@var3820 .@expr1073762167 front (@expr1073762168 ) ; }
6587:
6588: for (@expr1073762169 Token *@expr20340 tok@var3601 =@expr1073762171 tokens@var3600 ; tok@var3601 ; tok@var3601 =@expr1073762172 tok@var3601 .@expr1073762173 next (@expr1073762174 ) ) {
6589: tok@var3601 .@expr1073762175 setValueType (@expr1073762176 nullptr ) ; }
6590:
6591: for (@expr1073762177 Token *@expr20340 tok@var3602 =@expr1073762179 tokens@var3600 ; tok@var3602 ; tok@var3602 =@expr1073762180 tok@var3602 .@expr20357 next (@expr20358 ) ) {
6592: if (@expr1073762183 tok@var3602 .@expr1073762184 isNumber (@expr1073762185 ) ) {
6593: if (@expr1073762186 MathLib ::@expr1073762187 isFloat (@expr1073762188 tok@var3602 .@expr20365 str (@expr20366 ) ) ) {
6594: ValueType ::@expr1073762191 Type type@var3603 ; type@var3603 =@expr1073762192 ValueType ::@expr20369 Type ::@expr1073762194 DOUBLE ;
6595: const char suffix@var3604 =@expr1073762195 tok@var3602 .@expr20365 str (@expr20366 ) [@expr1073762198 tok@var3602 .@expr20365 str (@expr20366 ) .@expr1073762201 size (@expr1073762202 ) -@expr1073762203 1 ] ;
6596: if (@expr1073762204 suffix@var3604 ==@expr1073762205 'f' ||@expr1073762206 suffix@var3604 ==@expr1073762207 'F' ) {
6597: type@var3603 =@expr1073762208 ValueType ::@expr20369 Type ::@expr1073762210 FLOAT ; }
6598: else { if (@expr1073762211 suffix@var3604 ==@expr1073762212 'L' ||@expr1073762213 suffix@var3604 ==@expr1073762214 'l' ) {
6599: type@var3603 =@expr1073762215 ValueType ::@expr20369 Type ::@expr1073762217 LONGDOUBLE ; } }
6600: setValueType (@expr1073762218 tok@var3602 , ValueType (@expr1073762219 ValueType ::@expr20396 Sign ::@expr20397 UNKNOWN_SIGN , type@var3603 , 0U ) ) ;
6601: } else { if (@expr1073762222 MathLib ::@expr1073762223 isInt (@expr1073762224 tok@var3602 .@expr20365 str (@expr20366 ) ) ) {
6602: const std ::@expr20403 string tokStr@var3605 =@expr1073762228 MathLib ::@expr1073762229 abs (@expr1073762230 tok@var3602 .@expr20365 str (@expr20366 ) ) ;
6603: const bool unsignedSuffix@var3606 =@expr1073762233 tokStr@var3605 .@expr1073762234 find_last_of (@expr1073762235 "uU" ) !=@expr1073762236 std ::@expr20413 string ::@expr1073762238 npos@expr1073762159 ;
6604: ValueType ::@expr1073762239 Sign sign@var3607 ; sign@var3607 =@expr1073762240 unsignedSuffix@var3606 ?@expr1073762241 ValueType ::@expr20396 Sign ::@expr20419 UNSIGNED :@expr1073762244 ValueType ::@expr20396 Sign ::@expr20422 SIGNED ;
6605: ValueType ::@expr1073762247 Type type@var3608 ; type@var3608 =@expr1073762248 ValueType ::@expr20369 Type ::@expr20426 INT ;
6606: const unsigned long long value@var3609 =@expr1073762251 MathLib ::@expr1073762252 toULongNumber (@expr1073762253 tokStr@var3605 ) ;
6607: for (@expr1073762254 unsigned long pos@var3610 =@expr1073762255 tokStr@var3605 .@expr1073762256 size (@expr1073762257 ) -@expr1073762258 1U ; pos@var3610 >@expr1073762259 0U ; --@expr1073762260 pos@var3610 ) {
6608: const char suffix@var3611 =@expr1073762261 tokStr@var3605 [@expr1073762262 pos@var3610 ] ;
6609: if (@expr1073762263 suffix@var3611 ==@expr1073762264 'u' ||@expr1073762265 suffix@var3611 ==@expr1073762266 'U' ) {
6610: sign@var3607 =@expr1073762267 ValueType ::@expr20396 Sign ::@expr20419 UNSIGNED ; }
6611: else { if (@expr1073762270 suffix@var3611 ==@expr1073762271 'l' ||@expr1073762272 suffix@var3611 ==@expr1073762273 'L' ) {
6612: type@var3608 =@expr1073762274 (@expr1073762275 type@var3608 ==@expr1073762276 ValueType ::@expr20369 Type ::@expr20426 INT ) ?@expr1073762279 ValueType ::@expr20369 Type ::@expr20457 LONG :@expr1073762282 ValueType ::@expr20369 Type ::@expr20460 LONGLONG ; }
6613: else { if (@expr1073762285 pos@var3610 >@expr1073762286 2U &&@expr1073762287 suffix@var3611 ==@expr1073762288 '4' &&@expr1073762289 tokStr@var3605 [@expr1073762290 pos@var3610 -@expr1073762291 1 ] ==@expr1073762292 '6' &&@expr1073762293 tokStr@var3605 [@expr1073762294 pos@var3610 -@expr1073762295 2 ] ==@expr1073762296 'i' ) {
6614: type@var3608 =@expr1073762297 ValueType ::@expr20369 Type ::@expr20460 LONGLONG ;
6615: pos@var3610 -=@expr1073762300 2 ;
6616: } else { break ; } } }
6617: }
6618: if (@expr1073762301 mSettings@var1404 .@expr20478 platformType@var3831 !=@expr1073762303 cppcheck ::@expr20480 Platform ::@expr1073762305 Unspecified ) {
6619: if (@expr1073762306 type@var3608 <=@expr20483 ValueType ::@expr20369 Type ::@expr20426 INT &&@expr1073762310 mSettings@var1404 .@expr20487 isIntValue (@expr1073762312 unsignedSuffix@var3606 ?@expr20489 value@var3609 >>@expr20490 1 :@expr20491 value@var3609 ) ) {
6620: type@var3608 =@expr1073762316 ValueType ::@expr20369 Type ::@expr20426 INT ; }
6621: else { if (@expr1073762319 type@var3608 <=@expr20483 ValueType ::@expr20369 Type ::@expr20426 INT &&@expr1073762323 !@expr20500 MathLib ::@expr20501 isDec (@expr20502 tokStr@var3605 ) &&@expr1073762327 mSettings@var1404 .@expr20487 isIntValue (@expr1073762329 value@var3609 >>@expr20506 2 ) ) {
6622: type@var3608 =@expr1073762331 ValueType ::@expr20369 Type ::@expr20426 INT ;
6623: sign@var3607 =@expr1073762334 ValueType ::@expr20396 Sign ::@expr20419 UNSIGNED ;
6624: } else { if (@expr1073762337 type@var3608 <=@expr20514 ValueType ::@expr20369 Type ::@expr20457 LONG &&@expr1073762341 mSettings@var1404 .@expr20518 isLongValue (@expr1073762343 unsignedSuffix@var3606 ?@expr20489 value@var3609 >>@expr20490 1 :@expr20491 value@var3609 ) ) {
6625: type@var3608 =@expr1073762347 ValueType ::@expr20369 Type ::@expr20457 LONG ; }
6626: else { if (@expr1073762350 type@var3608 <=@expr20514 ValueType ::@expr20369 Type ::@expr20457 LONG &&@expr1073762354 !@expr20500 MathLib ::@expr20501 isDec (@expr20502 tokStr@var3605 ) &&@expr1073762358 mSettings@var1404 .@expr20518 isLongValue (@expr1073762360 value@var3609 >>@expr20506 2 ) ) {
6627: type@var3608 =@expr1073762362 ValueType ::@expr20369 Type ::@expr20457 LONG ;
6628: sign@var3607 =@expr1073762365 ValueType ::@expr20396 Sign ::@expr20419 UNSIGNED ;
6629: } else { if (@expr1073762368 mSettings@var1404 .@expr1073762369 isLongLongValue (@expr1073762370 unsignedSuffix@var3606 ?@expr20489 value@var3609 >>@expr20490 1 :@expr20491 value@var3609 ) ) {
6630: type@var3608 =@expr1073762374 ValueType ::@expr20369 Type ::@expr20460 LONGLONG ; }
6631: else {
6632: type@var3608 =@expr1073762377 ValueType ::@expr20369 Type ::@expr20460 LONGLONG ;
6633: sign@var3607 =@expr1073762380 ValueType ::@expr20396 Sign ::@expr20419 UNSIGNED ;
6634: } } } } }
6635: }
6636:
6637: setValueType (@expr1073762383 tok@var3602 , ValueType (@expr1073762384 sign@var3607 , type@var3608 , 0U ) ) ;
6638: } }
6639: } else { if (@expr1073762385 tok@var3602 .@expr20562 isComparisonOp (@expr20563 ) ||@expr1073762388 tok@var3602 .@expr20565 tokType (@expr20566 ) ==@expr1073762391 Token ::@expr1073762392 eLogicalOp ) {
6640: if (@expr1073762393 mIsCpp@var1408 &&@expr1073762394 tok@var3602 .@expr20562 isComparisonOp (@expr20563 ) &&@expr1073762397 (@expr1073762398 getClassScope (@expr1073762399 tok@var3602 .@expr20576 astOperand1 (@expr20577 ) ) ||@expr1073762402 getClassScope (@expr1073762403 tok@var3602 .@expr20580 astOperand2 (@expr20581 ) ) ) ) {
6641: const Function * function@var3612 ; function@var3612 =@expr1073762406 getOperatorFunction (@expr1073762407 tok@var3602 ) ;
6642: if (@expr1073762408 function@var3612 ) {
6643: ValueType vt@var3613 ;
6644: parsedecl (@expr1073762409 function@var3612 .@expr1073762410 retDef@var3614 , &@expr1073762411 vt@var3613 , mDefaultSignedness@var1409 , mSettings@var1404 ) ;
6645: setValueType (@expr1073762412 tok@var3602 , vt@var3613 ) ;
6646: continue ;
6647: }
6648: }
6649: setValueType (@expr20589 tok@var3602 , ValueType (@expr20590 ValueType ::@expr20396 Sign ::@expr20397 UNKNOWN_SIGN , ValueType ::@expr20369 Type ::@expr20594 BOOL , 0U ) ) ;
6650: } else { if (@expr1073762419 tok@var3602 .@expr1073762420 isBoolean (@expr1073762421 ) ) {
6651: setValueType (@expr20589 tok@var3602 , ValueType (@expr20590 ValueType ::@expr20396 Sign ::@expr20397 UNKNOWN_SIGN , ValueType ::@expr20369 Type ::@expr20594 BOOL , 0U ) ) ;
6652: } else { if (@expr1073762428 tok@var3602 .@expr20565 tokType (@expr20566 ) ==@expr20607 Token ::@expr20608 eChar ||@expr1073762433 tok@var3602 .@expr20565 tokType (@expr20566 ) ==@expr1073762436 Token ::@expr1073762437 eString ) {
6653: int pointer@var3615 ; pointer@var3615 =@expr1073762438 tok@var3602 .@expr20565 tokType (@expr20566 ) ==@expr20607 Token ::@expr20608 eChar ?@expr20619 0U :@expr20620 1U ;
6654: int constness@var3616 ; constness@var3616 =@expr1073762445 tok@var3602 .@expr20565 tokType (@expr20566 ) ==@expr20607 Token ::@expr20608 eChar ?@expr20619 0U :@expr20620 1U ;
6655: ValueType valuetype@var3617 (@expr1073762452 ValueType ::@expr20396 Sign ::@expr20397 UNKNOWN_SIGN , ValueType ::@expr20369 Type ::@expr20632 CHAR , pointer@var3615 , constness@var3616 ) ;
6656:
6657: if (@expr1073762457 mIsCpp@var1408 &&@expr1073762458 mSettings@var1404 .@expr1073762459 standards@var3822 .@expr1073762460 cpp@var3823 >=@expr1073762461 Standards ::@expr1073762462 CPP20 &&@expr1073762463 tok@var3602 .@expr1073762464 isUtf8 (@expr1073762465 ) ) {
6658: valuetype@var3617 .@expr20642 originalTypeName@var3618 =@expr1073762467 "char8_t" ;
6659: valuetype@var3617 .@expr20644 fromLibraryType (@expr20645 valuetype@var3617 .@expr20642 originalTypeName@var3618 , mSettings@var1404 ) ;
6660: } else { if (@expr1073762471 tok@var3602 .@expr1073762472 isUtf16 (@expr1073762473 ) ) {
6661: valuetype@var3617 .@expr20642 originalTypeName@var3618 =@expr1073762475 "char16_t" ;
6662: valuetype@var3617 .@expr20644 fromLibraryType (@expr20645 valuetype@var3617 .@expr20642 originalTypeName@var3618 , mSettings@var1404 ) ;
6663: } else { if (@expr1073762479 tok@var3602 .@expr1073762480 isUtf32 (@expr1073762481 ) ) {
6664: valuetype@var3617 .@expr20642 originalTypeName@var3618 =@expr1073762483 "char32_t" ;
6665: valuetype@var3617 .@expr20644 fromLibraryType (@expr20645 valuetype@var3617 .@expr20642 originalTypeName@var3618 , mSettings@var1404 ) ;
6666: } else { if (@expr1073762487 tok@var3602 .@expr1073762488 isLong (@expr1073762489 ) ) {
6667: valuetype@var3617 .@expr20642 originalTypeName@var3618 =@expr1073762491 "wchar_t" ;
6668: valuetype@var3617 .@expr20668 type@var3619 =@expr1073762493 ValueType ::@expr20369 Type ::@expr1073762495 WCHAR_T ;
6669: } else { if (@expr1073762496 (@expr1073762497 tok@var3602 .@expr20565 tokType (@expr20566 ) ==@expr20607 Token ::@expr20608 eChar ) &&@expr1073762502 (@expr1073762503 (@expr1073762504 tok@var3602 .@expr1073762505 isCChar (@expr1073762506 ) &&@expr1073762507 !@expr1073762508 mIsCpp@var1408 ) ||@expr1073762509 (@expr1073762510 tok@var3602 .@expr1073762511 isCMultiChar (@expr1073762512 ) ) ) ) {
6670: valuetype@var3617 .@expr20668 type@var3619 =@expr1073762514 ValueType ::@expr20369 Type ::@expr20426 INT ;
6671: valuetype@var3617 .@expr1073762517 sign@var3620 =@expr1073762518 ValueType ::@expr20396 Sign ::@expr20422 SIGNED ;
6672: } } } } }
6673: setValueType (@expr1073762521 tok@var3602 , valuetype@var3617 ) ;
6674: } else { if (@expr1073762522 tok@var3602 .@expr1073762523 link (@expr1073762524 ) &&@expr1073762525 Token ::@expr20702 Match (@expr1073762527 tok@var3602 , "(|{" ) ) {
6675: const Token * start@var3621 ; start@var3621 =@expr1073762528 tok@var3602 .@expr20576 astOperand1 (@expr20577 ) ?@expr1073762531 tok@var3602 .@expr20576 astOperand1 (@expr20577 ) .@expr1073762534 findExpressionStartEndTokens (@expr1073762535 ) .@expr1073762536 first :@expr1073762537 nullptr ;
6676:
6677: if (@expr1073762538 tok@var3602 .@expr1073762539 isCast (@expr1073762540 ) &&@expr1073762541 !@expr1073762542 tok@var3602 .@expr20580 astOperand2 (@expr20581 ) &&@expr1073762545 Token ::@expr20702 Match (@expr1073762547 tok@var3602 , "( %name%" ) ) {
6678: ValueType valuetype@var3622 ;
6679: if (@expr1073762548 Token ::@expr20725 simpleMatch (@expr1073762550 parsedecl (@expr1073762551 tok@var3602 .@expr20357 next (@expr20358 ) , &@expr1073762554 valuetype@var3622 , mDefaultSignedness@var1409 , mSettings@var1404 ) , ")" ) ) {
6680: setValueType (@expr1073762555 tok@var3602 , valuetype@var3622 ) ; }
6681: }
6682:
6683:
6684: else { if (@expr1073762556 tok@var3602 .@expr20580 astOperand2 (@expr20581 ) &&@expr1073762559 Token ::@expr20702 Match (@expr1073762561 tok@var3602 .@expr20576 astOperand1 (@expr20577 ) , "static_cast|const_cast|dynamic_cast|reinterpret_cast < %name%" ) &&@expr1073762564 tok@var3602 .@expr20576 astOperand1 (@expr20577 ) .@expr1073762567 linkAt (@expr1073762568 1 ) ) {
6685: ValueType valuetype@var3623 ;
6686: if (@expr1073762569 Token ::@expr20725 simpleMatch (@expr1073762571 parsedecl (@expr1073762572 tok@var3602 .@expr20576 astOperand1 (@expr20577 ) .@expr20751 tokAt (@expr1073762576 2 ) , &@expr1073762577 valuetype@var3623 , mDefaultSignedness@var1409 , mSettings@var1404 ) , ">" ) ) {
6687: setValueType (@expr1073762578 tok@var3602 , valuetype@var3623 ) ; }
6688: }
6689:
6690:
6691: else { if (@expr1073762579 mSettings@var1404 .@expr20756 library@var3824 .@expr1073762581 isSmartPointer (@expr1073762582 start@var3621 ) ) {
6692: ValueType valuetype@var3624 ;
6693: if (@expr1073762583 parsedecl (@expr1073762584 start@var3621 , &@expr1073762585 valuetype@var3624 , mDefaultSignedness@var1409 , mSettings@var1404 ) ) {
6694: setValueType (@expr1073762586 tok@var3602 , valuetype@var3624 ) ;
6695: setValueType (@expr1073762587 tok@var3602 .@expr20576 astOperand1 (@expr20577 ) , valuetype@var3624 ) ;
6696: }
6697:
6698: }
6699:
6700:
6701: else { if (@expr1073762590 tok@var3602 .@expr20767 previous (@expr20768 ) &&@expr20769 tok@var3602 .@expr20767 previous (@expr20768 ) .@expr20772 function (@expr20773 ) &&@expr1073762598 tok@var3602 .@expr20767 previous (@expr20768 ) .@expr20772 function (@expr20773 ) .@expr20779 retDef@var3865 ) {
6702: ValueType valuetype@var3625 ;
6703: if (@expr1073762604 parsedecl (@expr1073762605 tok@var3602 .@expr20767 previous (@expr20768 ) .@expr20772 function (@expr20773 ) .@expr20779 retDef@var3865 , &@expr1073762611 valuetype@var3625 , mDefaultSignedness@var1409 , mSettings@var1404 ) ) {
6704: setValueType (@expr1073762612 tok@var3602 , valuetype@var3625 ) ; }
6705: }
6706:
6707: else { if (@expr1073762613 Token ::@expr20725 simpleMatch (@expr1073762615 tok@var3602 .@expr20767 previous (@expr20768 ) , "sizeof (" ) ) {
6708: ValueType valuetype@var3626 (@expr1073762618 ValueType ::@expr20396 Sign ::@expr20419 UNSIGNED , ValueType ::@expr20369 Type ::@expr20457 LONG , 0U ) ;
6709: if (@expr1073762623 mSettings@var1404 .@expr20478 platformType@var3831 ==@expr1073762625 cppcheck ::@expr20480 Platform ::@expr1073762627 Win64 ) {
6710: valuetype@var3626 .@expr1073762628 type@var3627 =@expr1073762629 ValueType ::@expr20369 Type ::@expr20460 LONGLONG ; }
6711:
6712: valuetype@var3626 .@expr1073762632 originalTypeName@var3628 =@expr1073762633 "size_t" ;
6713: setValueType (@expr1073762634 tok@var3602 , valuetype@var3626 ) ;
6714:
6715: if (@expr1073762635 Token ::@expr20702 Match (@expr1073762637 tok@var3602 , "( %type% %type%| *| *| )" ) ) {
6716: ValueType vt@var3629 ;
6717: if (@expr1073762638 parsedecl (@expr1073762639 tok@var3602 .@expr20357 next (@expr20358 ) , &@expr1073762642 vt@var3629 , mDefaultSignedness@var1409 , mSettings@var1404 ) ) {
6718: setValueType (@expr1073762643 tok@var3602 .@expr20357 next (@expr20358 ) , vt@var3629 ) ;
6719: }
6720: }
6721: }
6722:
6723:
6724: else { if (@expr1073762646 tok@var3602 .@expr20767 previous (@expr20768 ) &&@expr1073762649 tok@var3602 .@expr20767 previous (@expr20768 ) .@expr1073762652 isStandardType (@expr1073762653 ) ) {
6725: ValueType valuetype@var3630 ;
6726: if (@expr1073762654 tok@var3602 .@expr20576 astOperand1 (@expr20577 ) &&@expr1073762657 valuetype@var3630 .@expr1073762658 fromLibraryType (@expr1073762659 tok@var3602 .@expr20576 astOperand1 (@expr20577 ) .@expr20838 expressionString (@expr20839 ) , mSettings@var1404 ) ) {
6727: setValueType (@expr20840 tok@var3602 , valuetype@var3630 ) ;
6728: continue ;
6729: }
6730:
6731: valuetype@var3630 .@expr20841 type@var3631 =@expr1073762666 ValueType ::@expr20843 typeFromString (@expr1073762668 tok@var3602 .@expr20767 previous (@expr20768 ) .@expr1073762671 str (@expr1073762672 ) , tok@var3602 .@expr20767 previous (@expr20768 ) .@expr1073762675 isLong (@expr1073762676 ) ) ;
6732: if (@expr1073762677 tok@var3602 .@expr20767 previous (@expr20768 ) .@expr1073762680 isUnsigned (@expr1073762681 ) ) {
6733: valuetype@var3630 .@expr20858 sign@var3632 =@expr1073762683 ValueType ::@expr20396 Sign ::@expr20419 UNSIGNED ; }
6734: else { if (@expr1073762686 tok@var3602 .@expr20767 previous (@expr20768 ) .@expr1073762689 isSigned (@expr1073762690 ) ) {
6735: valuetype@var3630 .@expr20858 sign@var3632 =@expr1073762692 ValueType ::@expr20396 Sign ::@expr20422 SIGNED ; }
6736: else { if (@expr1073762695 valuetype@var3630 .@expr1073762696 isIntegral (@expr1073762697 ) &&@expr1073762698 valuetype@var3630 .@expr20841 type@var3631 !=@expr1073762700 ValueType ::@expr1073762701 UNKNOWN_INT ) {
6737: valuetype@var3630 .@expr20858 sign@var3632 =@expr1073762703 mDefaultSignedness@var1409 ; } } }
6738: setValueType (@expr20840 tok@var3602 , valuetype@var3630 ) ;
6739: }
6740:
6741:
6742: else { if (@expr1073762705 tok@var3602 .@expr20767 previous (@expr20768 ) &&@expr20769 tok@var3602 .@expr20767 previous (@expr20768 ) .@expr20772 function (@expr20773 ) &&@expr1073762713 tok@var3602 .@expr20767 previous (@expr20768 ) .@expr20772 function (@expr20773 ) .@expr1073762718 isConstructor (@expr1073762719 ) ) {
6743: ValueType valuetype@var3633 ;
6744: valuetype@var3633 .@expr1073762720 type@var3634 =@expr1073762721 ValueType ::@expr1073762722 RECORD ;
6745: valuetype@var3633 .@expr1073762723 typeScope@var3635 =@expr1073762724 tok@var3602 .@expr20767 previous (@expr20768 ) .@expr20772 function (@expr20773 ) .@expr1073762729 token@var3866 .@expr1073762730 scope (@expr1073762731 ) ;
6746: setValueType (@expr1073762732 tok@var3602 , valuetype@var3633 ) ;
6747: }
6748:
6749: else { if (@expr1073762733 Token ::@expr20725 simpleMatch (@expr1073762735 tok@var3602 .@expr20767 previous (@expr20768 ) , "= {" ) &&@expr1073762738 tok@var3602 .@expr20915 tokAt (@expr20916 -2 ) &&@expr1073762741 tok@var3602 .@expr20915 tokAt (@expr20916 -2 ) .@expr20920 valueType (@expr20921 ) ) {
6750: ValueType vt@var3636 ; vt@var3636 =@expr1073762746 *@expr1073762747 tok@var3602 .@expr20915 tokAt (@expr20916 -2 ) .@expr20920 valueType (@expr20921 ) ;
6751: setValueType (@expr1073762752 tok@var3602 , vt@var3636 ) ;
6752: }
6753:
6754:
6755: else { if (@expr1073762753 tok@var3602 .@expr20767 previous (@expr20768 ) ) {
6756:
6757: if (@expr1073762756 Token ::@expr20702 Match (@expr1073762758 tok@var3602 .@expr20767 previous (@expr20768 ) , "%name%" ) ) {
6758: ValueType valuetype@var3637 ;
6759: if (@expr1073762761 parsedecl (@expr1073762762 tok@var3602 .@expr20767 previous (@expr20768 ) , &@expr1073762765 valuetype@var3637 , mDefaultSignedness@var1409 , mSettings@var1404 ) ) {
6760: if (@expr1073762766 valuetype@var3637 .@expr1073762767 typeScope@var3638 ) {
6761: setValueType (@expr1073762768 tok@var3602 , valuetype@var3637 ) ;
6762: continue ;
6763: }
6764: }
6765: }
6766: if (@expr1073762769 tok@var3602 .@expr1073762770 astParent (@expr1073762771 ) &&@expr1073762772 Token ::@expr20702 Match (@expr1073762774 tok@var3602 .@expr20576 astOperand1 (@expr20577 ) , "%name%|::" ) ) {
6767: const Token * typeStartToken@var3639 ; typeStartToken@var3639 =@expr1073762777 tok@var3602 .@expr20576 astOperand1 (@expr20577 ) ;
6768: while (@expr1073762780 typeStartToken@var3639 &&@expr1073762781 typeStartToken@var3639 .@expr1073762782 str (@expr1073762783 ) ==@expr1073762784 "::" ) {
6769: typeStartToken@var3639 =@expr1073762785 typeStartToken@var3639 .@expr1073762786 astOperand1 (@expr1073762787 ) ; }
6770: if (@expr1073762788 mSettings@var1404 .@expr20756 library@var3824 .@expr20966 detectContainerOrIterator (@expr1073762791 typeStartToken@var3639 ) ||@expr1073762792
6771: mSettings@var1404 .@expr20756 library@var3824 .@expr1073762794 detectSmartPointer (@expr1073762795 typeStartToken@var3639 ) ) {
6772: ValueType vt@var3640 ;
6773: if (@expr1073762796 parsedecl (@expr1073762797 typeStartToken@var3639 , &@expr1073762798 vt@var3640 , mDefaultSignedness@var1409 , mSettings@var1404 ) ) {
6774: setValueType (@expr1073762799 tok@var3602 , vt@var3640 ) ;
6775: continue ;
6776: }
6777: }
6778:
6779: const std ::@expr20403 string e@var3641 =@expr1073762801 tok@var3602 .@expr20576 astOperand1 (@expr20577 ) .@expr20838 expressionString (@expr20839 ) ;
6780:
6781: if (@expr1073762806 (@expr1073762807 e@var3641 ==@expr20984 "std::make_shared" ||@expr1073762809 e@var3641 ==@expr20986 "std::make_unique" ) &&@expr1073762811 Token ::@expr20702 Match (@expr1073762813 tok@var3602 .@expr20576 astOperand1 (@expr20577 ) , ":: %name% < %name%" ) ) {
6782: ValueType vt@var3642 ;
6783: parsedecl (@expr1073762816 tok@var3602 .@expr20576 astOperand1 (@expr20577 ) .@expr20751 tokAt (@expr20996 3 ) , &@expr1073762821 vt@var3642 , mDefaultSignedness@var1409 , mSettings@var1404 ) ;
6784: if (@expr1073762822 vt@var3642 .@expr20999 typeScope@var3643 ) {
6785: vt@var3642 .@expr1073762824 smartPointerType@var3644 =@expr1073762825 vt@var3642 .@expr20999 typeScope@var3643 .@expr1073762827 definedType@var3645 ;
6786: vt@var3642 .@expr20999 typeScope@var3643 =@expr1073762829 nullptr ;
6787: }
6788: if (@expr1073762830 e@var3641 ==@expr20984 "std::make_shared" &&@expr1073762832 mSettings@var1404 .@expr20756 library@var3824 .@expr21010 smartPointers@var3832 .@expr21011 count (@expr1073762836 "std::shared_ptr" ) >@expr1073762837 0 ) {
6789: vt@var3642 .@expr21014 smartPointer@var3646 =@expr1073762839 &@expr1073762840 mSettings@var1404 .@expr20756 library@var3824 .@expr21010 smartPointers@var3832 .@expr21019 at (@expr1073762844 "std::shared_ptr" ) ; }
6790: if (@expr1073762845 e@var3641 ==@expr20986 "std::make_unique" &&@expr1073762847 mSettings@var1404 .@expr20756 library@var3824 .@expr21010 smartPointers@var3832 .@expr21011 count (@expr1073762851 "std::unique_ptr" ) >@expr1073762852 0 ) {
6791: vt@var3642 .@expr21014 smartPointer@var3646 =@expr1073762854 &@expr1073762855 mSettings@var1404 .@expr20756 library@var3824 .@expr21010 smartPointers@var3832 .@expr21019 at (@expr1073762859 "std::unique_ptr" ) ; }
6792: vt@var3642 .@expr1073762860 type@var3647 =@expr1073762861 ValueType ::@expr20369 Type ::@expr1073762863 SMART_POINTER ;
6793: vt@var3642 .@expr1073762864 smartPointerTypeToken@var3648 =@expr1073762865 tok@var3602 .@expr20576 astOperand1 (@expr20577 ) .@expr20751 tokAt (@expr20996 3 ) ;
6794: setValueType (@expr1073762870 tok@var3602 , vt@var3642 ) ;
6795: continue ;
6796: }
6797:
6798: ValueType podtype@var3649 ;
6799: if (@expr1073762871 podtype@var3649 .@expr1073762872 fromLibraryType (@expr1073762873 e@var3641 , mSettings@var1404 ) ) {
6800: setValueType (@expr1073762874 tok@var3602 , podtype@var3649 ) ;
6801: continue ;
6802: }
6803: }
6804:
6805: const std ::@expr20413 string & typestr@var3650 (@expr1073762876 mSettings@var1404 .@expr20756 library@var3824 .@expr1073762878 returnValueType (@expr1073762879 tok@var3602 .@expr20767 previous (@expr20768 ) ) ) ;
6806: if (@expr1073762882 !@expr1073762883 typestr@var3650 .@expr21060 empty (@expr21061 ) ) {
6807: ValueType valuetype@var3651 ;
6808: TokenList tokenList@var3652 (@expr1073762886 mSettings@var1404 ) ;
6809: std ::@expr1073762887 istringstream istr@var3653 (@expr1073762888 typestr@var3650 +@expr21065 ";" ) ;
6810: tokenList@var3652 .@expr1073762890 createTokens (@expr1073762891 istr@var3653 ) ;
6811: tokenList@var3652 .@expr1073762892 simplifyStdType (@expr1073762893 ) ;
6812: if (@expr1073762894 parsedecl (@expr1073762895 tokenList@var3652 .@expr1073762896 front (@expr1073762897 ) , &@expr1073762898 valuetype@var3651 , mDefaultSignedness@var1409 , mSettings@var1404 ) ) {
6813: valuetype@var3651 .@expr1073762899 originalTypeName@var3654 =@expr1073762900 typestr@var3650 ;
6814: setValueType (@expr1073762901 tok@var3602 , valuetype@var3651 ) ;
6815: }
6816: }
6817:
6818: if (@expr1073762902 typestr@var3650 .@expr21060 empty (@expr21061 ) ||@expr1073762905 typestr@var3650 ==@expr1073762906 "iterator" ) {
6819: if (@expr1073762907 Token ::@expr20725 simpleMatch (@expr1073762909 tok@var3602 .@expr20576 astOperand1 (@expr20577 ) , "." ) &&@expr1073762912
6820: tok@var3602 .@expr20576 astOperand1 (@expr20577 ) .@expr21091 astOperand1 (@expr21092 ) &&@expr1073762917
6821: tok@var3602 .@expr20576 astOperand1 (@expr20577 ) .@expr21096 astOperand2 (@expr21097 ) &&@expr1073762922
6822: tok@var3602 .@expr20576 astOperand1 (@expr20577 ) .@expr21091 astOperand1 (@expr21092 ) .@expr21103 valueType (@expr21104 ) &&@expr1073762929
6823: tok@var3602 .@expr20576 astOperand1 (@expr20577 ) .@expr21091 astOperand1 (@expr21092 ) .@expr21103 valueType (@expr21104 ) .@expr21112 container@var3867 ) {
6824: const Library ::@expr21113 Container * cont@var3655 ; cont@var3655 =@expr1073762938 tok@var3602 .@expr20576 astOperand1 (@expr20577 ) .@expr21091 astOperand1 (@expr21092 ) .@expr21103 valueType (@expr21104 ) .@expr21112 container@var3867 ;
6825: const std ::@expr1073762946 map < std ::@expr20403 string , Library ::@expr20403 Container ::@expr20403 Function > ::@expr1073762950 const_iterator it@var3656 =@expr1073762951 cont@var3655 .@expr21128 functions@var3657 .@expr1073762953 find (@expr1073762954 tok@var3602 .@expr20576 astOperand1 (@expr20577 ) .@expr21096 astOperand2 (@expr21097 ) .@expr1073762959 str (@expr1073762960 ) ) ;
6826: if (@expr1073762961 it@var3656 !=@expr1073762962 cont@var3655 .@expr21128 functions@var3657 .@expr1073762964 end (@expr1073762965 ) ) {
6827: if (@expr1073762966 it@var3656 .@expr21143 second@var3658 .@expr21144 yield@var3659 ==@expr1073762969 Library ::@expr21113 Container ::@expr21147 Yield ::@expr1073762972 START_ITERATOR ||@expr1073762973
6828: it@var3656 .@expr21143 second@var3658 .@expr21144 yield@var3659 ==@expr1073762976 Library ::@expr21113 Container ::@expr21147 Yield ::@expr1073762979 END_ITERATOR ||@expr1073762980
6829: it@var3656 .@expr21143 second@var3658 .@expr21144 yield@var3659 ==@expr1073762983 Library ::@expr21113 Container ::@expr21147 Yield ::@expr1073762986 ITERATOR ) {
6830: ValueType vt@var3660 ;
6831: vt@var3660 .@expr1073762987 type@var3661 =@expr1073762988 ValueType ::@expr20369 Type ::@expr21166 ITERATOR ;
6832: vt@var3660 .@expr1073762991 container@var3662 =@expr1073762992 cont@var3655 ;
6833: vt@var3660 .@expr1073762993 containerTypeToken@var3663 =@expr1073762994
6834: tok@var3602 .@expr20576 astOperand1 (@expr20577 ) .@expr21091 astOperand1 (@expr21092 ) .@expr21103 valueType (@expr21104 ) .@expr1073763001 containerTypeToken@var3868 ;
6835: setValueType (@expr1073763002 tok@var3602 , vt@var3660 ) ;
6836: }
6837: }
6838: }
6839: continue ;
6840: }
6841: TokenList tokenList@var3664 (@expr1073763003 mSettings@var1404 ) ;
6842: std ::@expr1073763004 istringstream istr@var3665 (@expr1073763005 typestr@var3650 +@expr21065 ";" ) ;
6843: if (@expr1073763007 tokenList@var3664 .@expr1073763008 createTokens (@expr1073763009 istr@var3665 ) ) {
6844: ValueType vt@var3666 ;
6845: tokenList@var3664 .@expr1073763010 simplifyPlatformTypes (@expr1073763011 ) ;
6846: tokenList@var3664 .@expr1073763012 simplifyStdType (@expr1073763013 ) ;
6847: if (@expr1073763014 parsedecl (@expr1073763015 tokenList@var3664 .@expr1073763016 front (@expr1073763017 ) , &@expr1073763018 vt@var3666 , mDefaultSignedness@var1409 , mSettings@var1404 ) ) {
6848: vt@var3666 .@expr1073763019 originalTypeName@var3667 =@expr1073763020 typestr@var3650 ;
6849: setValueType (@expr1073763021 tok@var3602 , vt@var3666 ) ;
6850: }
6851: }
6852: } } } } } } } } }
6853: } else { if (@expr1073763022 tok@var3602 .@expr20365 str (@expr20366 ) ==@expr21201 "return" ) {
6854: const Scope * functionScope@var3668 ; functionScope@var3668 =@expr1073763026 tok@var3602 .@expr21203 scope (@expr21204 ) ;
6855: while (@expr1073763029 functionScope@var3668 &&@expr1073763030 functionScope@var3668 .@expr1073763031 isExecutable (@expr1073763032 ) &&@expr1073763033 functionScope@var3668 .@expr21210 type@var3669 !=@expr1073763035 Scope ::@expr1073763036 eLambda &&@expr1073763037 functionScope@var3668 .@expr21210 type@var3669 !=@expr1073763039 Scope ::@expr21216 eFunction@expr1073762160 ) {
6856: functionScope@var3668 =@expr1073763041 functionScope@var3668 .@expr1073763042 nestedIn@var3670 ; }
6857: if (@expr1073763043 functionScope@var3668 &&@expr1073763044 functionScope@var3668 .@expr21210 type@var3669 ==@expr1073763046 Scope ::@expr21216 eFunction &&@expr1073763048 functionScope@var3668 .@expr21225 function@var3671 &&@expr1073763050
6858: functionScope@var3668 .@expr21225 function@var3671 .@expr21228 retDef@var3672 ) {
6859: ValueType vt@var3673 ; vt@var3673 =@expr1073763053 ValueType ::@expr1073763054 parseDecl (@expr1073763055 functionScope@var3668 .@expr21225 function@var3671 .@expr21228 retDef@var3672 , mSettings@var1404 ) ;
6860: setValueType (@expr1073763058 tok@var3602 , vt@var3673 ) ;
6861: if (@expr1073763059 Token ::@expr20725 simpleMatch (@expr1073763061 tok@var3602 , "return {" ) ) {
6862: setValueType (@expr1073763062 tok@var3602 .@expr20357 next (@expr20358 ) , vt@var3673 ) ; }
6863: }
6864: } else { if (@expr1073763065 tok@var3602 .@expr21242 variable (@expr21243 ) ) {
6865: setValueType (@expr1073763068 tok@var3602 , *@expr1073763069 tok@var3602 .@expr21242 variable (@expr21243 ) ) ;
6866: if (@expr1073763072 !@expr1073763073 tok@var3602 .@expr21242 variable (@expr21243 ) .@expr1073763076 valueType (@expr1073763077 ) &&@expr1073763078 tok@var3602 .@expr21255 valueType (@expr21256 ) ) {
6867: const_cast < Variable *@expr20340 > (@expr1073763082 tok@var3602 .@expr21242 variable (@expr21243 ) ) .@expr1073763085 setValueType (@expr1073763086 *@expr1073763087 tok@var3602 .@expr21255 valueType (@expr21256 ) ) ; }
6868: } else { if (@expr1073763090 tok@var3602 .@expr21267 enumerator (@expr21268 ) ) {
6869: setValueType (@expr1073763093 tok@var3602 , *@expr1073763094 tok@var3602 .@expr21267 enumerator (@expr21268 ) ) ;
6870: } else { if (@expr1073763097 tok@var3602 .@expr21274 isKeyword (@expr21275 ) &&@expr1073763100 tok@var3602 .@expr20365 str (@expr20366 ) ==@expr1073763103 "new" ) {
6871: const Token * typeTok@var3674 ; typeTok@var3674 =@expr1073763104 tok@var3602 .@expr20357 next (@expr20358 ) ;
6872: if (@expr1073763107 Token ::@expr20702 Match (@expr1073763109 typeTok@var3674 , "( std| ::| nothrow )" ) ) {
6873: typeTok@var3674 =@expr1073763110 typeTok@var3674 .@expr1073763111 link (@expr1073763112 ) .@expr1073763113 next (@expr1073763114 ) ; }
6874: bool isIterator@var3675 ; isIterator@var3675 =@expr1073763115 false ;
6875: if (@expr1073763116 const Library ::@expr20403 Container *@expr20340 c@var3676 =@expr1073763119 mSettings@var1404 .@expr20756 library@var3824 .@expr20966 detectContainerOrIterator (@expr1073763122 typeTok@var3674 , &@expr1073763123 isIterator@var3675 ) ) {
6876: ValueType vt@var3677 ;
6877: vt@var3677 .@expr1073763124 pointer@var3678 =@expr1073763125 1 ;
6878: vt@var3677 .@expr1073763126 container@var3679 =@expr1073763127 c@var3676 ;
6879: vt@var3677 .@expr1073763128 type@var3680 =@expr1073763129 isIterator@var3675 ?@expr1073763130 ValueType ::@expr20369 Type ::@expr21166 ITERATOR :@expr1073763133 ValueType ::@expr20369 Type ::@expr1073763135 CONTAINER ;
6880: setValueType (@expr1073763136 tok@var3602 , vt@var3677 ) ;
6881: continue ;
6882: }
6883: std ::@expr1073763137 string typestr@var3681 ;
6884: while (@expr1073763138 Token ::@expr20702 Match (@expr1073763140 typeTok@var3674 , "%name% :: %name%" ) ) {
6885: typestr@var3681 +=@expr1073763141 typeTok@var3674 .@expr21318 str (@expr21319 ) +@expr1073763144 "::" ;
6886: typeTok@var3674 =@expr1073763145 typeTok@var3674 .@expr1073763146 tokAt (@expr1073763147 2 ) ;
6887: }
6888: if (@expr1073763148 !@expr1073763149 Token ::@expr20702 Match (@expr1073763151 typeTok@var3674 , "%type% ;|[|(" ) ) {
6889: continue ; }
6890: typestr@var3681 +=@expr1073763152 typeTok@var3674 .@expr21318 str (@expr21319 ) ;
6891: ValueType vt@var3682 ;
6892: vt@var3682 .@expr21331 pointer@var3683 =@expr1073763156 1 ;
6893: if (@expr1073763157 typeTok@var3674 .@expr21334 type (@expr21335 ) &&@expr1073763160 typeTok@var3674 .@expr21334 type (@expr21335 ) .@expr21339 classScope@var3855 ) {
6894: vt@var3682 .@expr21340 type@var3684 =@expr1073763165 ValueType ::@expr20369 Type ::@expr1073763167 RECORD ;
6895: vt@var3682 .@expr1073763168 typeScope@var3685 =@expr1073763169 typeTok@var3674 .@expr21334 type (@expr21335 ) .@expr21339 classScope@var3855 ;
6896: } else {
6897: vt@var3682 .@expr21340 type@var3684 =@expr1073763174 ValueType ::@expr20843 typeFromString (@expr1073763176 typestr@var3681 , typeTok@var3674 .@expr1073763177 isLong (@expr1073763178 ) ) ;
6898: if (@expr21355 vt@var3682 .@expr21340 type@var3684 ==@expr21357 ValueType ::@expr20369 Type ::@expr21359 UNKNOWN_TYPE ) {
6899: vt@var3682 .@expr1073763184 fromLibraryType (@expr1073763185 typestr@var3681 , mSettings@var1404 ) ; }
6900: if (@expr21355 vt@var3682 .@expr21340 type@var3684 ==@expr21357 ValueType ::@expr20369 Type ::@expr21359 UNKNOWN_TYPE ) {
6901: continue ; }
6902: if (@expr1073763191 typeTok@var3674 .@expr1073763192 isUnsigned (@expr1073763193 ) ) {
6903: vt@var3682 .@expr21370 sign@var3686 =@expr1073763195 ValueType ::@expr20396 Sign ::@expr20419 UNSIGNED ; }
6904: else { if (@expr1073763198 typeTok@var3674 .@expr1073763199 isSigned (@expr1073763200 ) ) {
6905: vt@var3682 .@expr21370 sign@var3686 =@expr1073763202 ValueType ::@expr20396 Sign ::@expr20422 SIGNED ; } }
6906: if (@expr1073763205 vt@var3682 .@expr21370 sign@var3686 ==@expr1073763207 ValueType ::@expr20396 Sign ::@expr20397 UNKNOWN_SIGN &&@expr1073763210 vt@var3682 .@expr1073763211 isIntegral (@expr1073763212 ) ) {
6907: vt@var3682 .@expr21370 sign@var3686 =@expr1073763214 (@expr1073763215 vt@var3682 .@expr21340 type@var3684 ==@expr1073763217 ValueType ::@expr20369 Type ::@expr20632 CHAR ) ?@expr1073763220 mDefaultSignedness@var1409 :@expr1073763221 ValueType ::@expr20396 Sign ::@expr20422 SIGNED ; }
6908: }
6909: setValueType (@expr1073763224 tok@var3602 , vt@var3682 ) ;
6910: if (@expr1073763225 Token ::@expr20725 simpleMatch (@expr1073763227 tok@var3602 .@expr20576 astOperand1 (@expr20577 ) , "(" ) ) {
6911: vt@var3682 .@expr21331 pointer@var3683 --@expr1073763231 ;
6912: setValueType (@expr1073763232 tok@var3602 .@expr20576 astOperand1 (@expr20577 ) , vt@var3682 ) ;
6913: }
6914: } else { if (@expr1073763235 tok@var3602 .@expr21274 isKeyword (@expr21275 ) &&@expr1073763238 tok@var3602 .@expr20365 str (@expr20366 ) ==@expr21201 "return" &&@expr1073763242 tok@var3602 .@expr21203 scope (@expr21204 ) ) {
6915: const Scope * fscope@var3687 ; fscope@var3687 =@expr1073763245 tok@var3602 .@expr21203 scope (@expr21204 ) ;
6916: while (@expr1073763248 fscope@var3687 &&@expr1073763249 !@expr1073763250 fscope@var3687 .@expr21427 function@var3688 ) {
6917: fscope@var3687 =@expr1073763252 fscope@var3687 .@expr1073763253 nestedIn@var3689 ; }
6918: if (@expr1073763254 fscope@var3687 &&@expr1073763255 fscope@var3687 .@expr21427 function@var3688 &&@expr1073763257 fscope@var3687 .@expr21427 function@var3688 .@expr21435 retDef@var3690 ) {
6919: ValueType vt@var3691 ;
6920: parsedecl (@expr1073763260 fscope@var3687 .@expr21427 function@var3688 .@expr21435 retDef@var3690 , &@expr1073763263 vt@var3691 , mDefaultSignedness@var1409 , mSettings@var1404 ) ;
6921: setValueType (@expr1073763264 tok@var3602 , vt@var3691 ) ;
6922: }
6923: } } } } } } } } } }
6924: }
6925:
6926: if (@expr1073763265 reportDebugWarnings@var3599 &&@expr1073763266 mSettings@var1404 .@expr1073763267 debugwarnings@var3821 ) {
6927: for (@expr1073763268 Token *@expr20340 tok@var3692 =@expr1073763270 tokens@var3600 ; tok@var3692 ; tok@var3692 =@expr1073763271 tok@var3692 .@expr1073763272 next (@expr1073763273 ) ) {
6928: if (@expr1073763274 tok@var3692 .@expr1073763275 str (@expr1073763276 ) ==@expr1073763277 "auto" &&@expr1073763278 !@expr1073763279 tok@var3692 .@expr1073763280 valueType (@expr1073763281 ) ) {
6929: debugMessage (@expr1073763282 tok@var3692 , "autoNoType" , "auto token with no type." ) ; }
6930: }
6931: }
6932:
6933:
6934: createSymbolDatabaseSetFunctionPointers (@expr1073763283 false ) ;
6935:
6936:
6937: createSymbolDatabaseSetVariablePointers (@expr1073763284 ) ;
6938: }
6939:
6940: ValueType ValueType :: parseDecl ( const Token * type@var3693 , const Settings * settings@var3694 )
6941: {
6942: ValueType vt@var3695 ;
6943: parsedecl (@expr1073763286 type@var3693 , &@expr1073763287 vt@var3695 , settings@var3694 .@expr1073763288 defaultSign@var3696 ==@expr1073763289 'u' ?@expr1073763290 Sign ::@expr1073763291 UNSIGNED :@expr1073763292 Sign ::@expr1073763293 SIGNED@expr1073763285 , settings@var3694 ) ;
6944: return vt@var3695 ;
6945: }
6946:
6947: ValueType :: Type ValueType :: typeFromString ( const std :: string & typestr@var3697 , bool longType@var3698 )
6948: {
6949: if (@expr1073763294 typestr@var3697 ==@expr1073763295 "void" ) {
6950: return ValueType ::@expr21472 Type ::@expr1073763297 VOID ; }
6951: if (@expr1073763298 typestr@var3697 ==@expr1073763299 "bool" ||@expr1073763300 typestr@var3697 ==@expr1073763301 "_Bool" ) {
6952: return ValueType ::@expr21472 Type ::@expr1073763303 BOOL ; }
6953: if (@expr1073763304 typestr@var3697 ==@expr1073763305 "char" ) {
6954: return ValueType ::@expr21472 Type ::@expr1073763307 CHAR ; }
6955: if (@expr1073763308 typestr@var3697 ==@expr1073763309 "short" ) {
6956: return ValueType ::@expr21472 Type ::@expr1073763311 SHORT ; }
6957: if (@expr1073763312 typestr@var3697 ==@expr1073763313 "wchar_t" ) {
6958: return ValueType ::@expr21472 Type ::@expr1073763315 WCHAR_T ; }
6959: if (@expr1073763316 typestr@var3697 ==@expr1073763317 "int" ) {
6960: return ValueType ::@expr21472 Type ::@expr1073763319 INT ; }
6961: if (@expr1073763320 typestr@var3697 ==@expr1073763321 "long" ) {
6962: return longType@var3698 ?@expr1073763322 ValueType ::@expr21472 Type ::@expr1073763324 LONGLONG :@expr1073763325 ValueType ::@expr21472 Type ::@expr1073763327 LONG ; }
6963: if (@expr1073763328 typestr@var3697 ==@expr1073763329 "float" ) {
6964: return ValueType ::@expr21472 Type ::@expr1073763331 FLOAT ; }
6965: if (@expr1073763332 typestr@var3697 ==@expr1073763333 "double" ) {
6966: return longType@var3698 ?@expr1073763334 ValueType ::@expr21472 Type ::@expr1073763336 LONGDOUBLE :@expr1073763337 ValueType ::@expr21472 Type ::@expr1073763339 DOUBLE ; }
6967: return ValueType ::@expr21472 Type ::@expr1073763341 UNKNOWN_TYPE ;
6968: }
6969:
6970: bool ValueType :: fromLibraryType ( const std :: string & typestr@var3699 , const Settings * settings@var3700 )
6971: {
6972: const Library ::@expr21520 PodType * podtype@var3701 ; podtype@var3701 =@expr1073763345 settings@var3700 .@expr21522 library@var3702 .@expr1073763347 podtype (@expr1073763348 typestr@var3699 ) ;
6973: if (@expr1073763349 podtype@var3701 &&@expr1073763350 (@expr1073763351 podtype@var3701 .@expr21528 sign@var3703 ==@expr1073763353 's' ||@expr1073763354 podtype@var3701 .@expr21528 sign@var3703 ==@expr21532 'u' ) ) {
6974: if (@expr1073763357 podtype@var3701 .@expr21534 size@var3704 ==@expr1073763359 1 ) {
6975: type@var1289 =@expr1073763360 ValueType ::@expr21537 Type ::@expr21538 CHAR ; }
6976: else { if (@expr1073763363 podtype@var3701 .@expr21534 size@var3704 ==@expr1073763365 settings@var3700 .@expr21542 sizeof_int@var3705 ) {
6977: type@var1289 =@expr1073763367 ValueType ::@expr21537 Type ::@expr21545 INT ; }
6978: else { if (@expr1073763370 podtype@var3701 .@expr21534 size@var3704 ==@expr1073763372 settings@var3700 .@expr1073763373 sizeof_short@var3706 ) {
6979: type@var1289 =@expr1073763374 ValueType ::@expr21537 Type ::@expr21552 SHORT ; }
6980: else { if (@expr1073763377 podtype@var3701 .@expr21534 size@var3704 ==@expr1073763379 settings@var3700 .@expr21556 sizeof_long@var3707 ) {
6981: type@var1289 =@expr1073763381 ValueType ::@expr21537 Type ::@expr21559 LONG ; }
6982: else { if (@expr1073763384 podtype@var3701 .@expr21534 size@var3704 ==@expr1073763386 settings@var3700 .@expr21563 sizeof_long_long@var3708 ) {
6983: type@var1289 =@expr1073763388 ValueType ::@expr21537 Type ::@expr21566 LONGLONG ; }
6984: else { if (@expr1073763391 podtype@var3701 .@expr21568 stdtype@var3709 ==@expr1073763393 Library ::@expr21520 PodType ::@expr21571 Type ::@expr1073763396 BOOL ) {
6985: type@var1289 =@expr1073763397 ValueType ::@expr21537 Type ::@expr1073763399 BOOL ; }
6986: else { if (@expr1073763400 podtype@var3701 .@expr21568 stdtype@var3709 ==@expr1073763402 Library ::@expr21520 PodType ::@expr21571 Type ::@expr1073763405 CHAR ) {
6987: type@var1289 =@expr1073763406 ValueType ::@expr21537 Type ::@expr21538 CHAR ; }
6988: else { if (@expr1073763409 podtype@var3701 .@expr21568 stdtype@var3709 ==@expr1073763411 Library ::@expr21520 PodType ::@expr21571 Type ::@expr1073763414 SHORT ) {
6989: type@var1289 =@expr1073763415 ValueType ::@expr21537 Type ::@expr21552 SHORT ; }
6990: else { if (@expr1073763418 podtype@var3701 .@expr21568 stdtype@var3709 ==@expr1073763420 Library ::@expr21520 PodType ::@expr21571 Type ::@expr1073763423 INT ) {
6991: type@var1289 =@expr1073763424 ValueType ::@expr21537 Type ::@expr21545 INT ; }
6992: else { if (@expr1073763427 podtype@var3701 .@expr21568 stdtype@var3709 ==@expr1073763429 Library ::@expr21520 PodType ::@expr21571 Type ::@expr1073763432 LONG ) {
6993: type@var1289 =@expr1073763433 ValueType ::@expr21537 Type ::@expr21559 LONG ; }
6994: else { if (@expr1073763436 podtype@var3701 .@expr21568 stdtype@var3709 ==@expr1073763438 Library ::@expr21520 PodType ::@expr21571 Type ::@expr1073763441 LONGLONG ) {
6995: type@var1289 =@expr1073763442 ValueType ::@expr21537 Type ::@expr21566 LONGLONG ; }
6996: else {
6997: type@var1289 =@expr1073763445 ValueType ::@expr21537 Type ::@expr21623 UNKNOWN_INT ; } } } } } } } } } } }
6998: sign@var1288 =@expr1073763448 (@expr1073763449 podtype@var3701 .@expr21528 sign@var3703 ==@expr21532 'u' ) ?@expr1073763452 ValueType ::@expr21629 UNSIGNED :@expr1073763454 ValueType ::@expr21631 SIGNED@expr21518 ;
6999: return true ;
7000: } else { if (@expr1073763456 podtype@var3701 &&@expr1073763457 podtype@var3701 .@expr21568 stdtype@var3709 ==@expr1073763459 Library ::@expr21520 PodType ::@expr21571 Type ::@expr1073763462 NO ) {
7001: type@var1289 =@expr1073763463 ValueType ::@expr21537 Type ::@expr1073763465 POD ;
7002: sign@var1288 =@expr1073763466 ValueType ::@expr1073763467 UNKNOWN_SIGN ;
7003: return true ;
7004: } }
7005:
7006: const Library ::@expr1073763468 PlatformType * platformType@var3710 ; platformType@var3710 =@expr1073763469 settings@var3700 .@expr21522 library@var3702 .@expr1073763471 platform_type (@expr1073763472 typestr@var3699 , settings@var3700 .@expr1073763473 platformString (@expr1073763474 ) ) ;
7007: if (@expr1073763475 platformType@var3710 ) {
7008: if (@expr1073763476 platformType@var3710 .@expr21653 mType@var3711 ==@expr1073763478 "char" ) {
7009: type@var1289 =@expr1073763479 ValueType ::@expr21537 Type ::@expr21538 CHAR ; }
7010: else { if (@expr1073763482 platformType@var3710 .@expr21653 mType@var3711 ==@expr1073763484 "short" ) {
7011: type@var1289 =@expr1073763485 ValueType ::@expr21537 Type ::@expr21552 SHORT ; }
7012: else { if (@expr1073763488 platformType@var3710 .@expr21653 mType@var3711 ==@expr1073763490 "wchar_t" ) {
7013: type@var1289 =@expr1073763491 ValueType ::@expr21537 Type ::@expr1073763493 WCHAR_T ; }
7014: else { if (@expr1073763494 platformType@var3710 .@expr21653 mType@var3711 ==@expr1073763496 "int" ) {
7015: type@var1289 =@expr1073763497 platformType@var3710 .@expr21674 mLong@var3712 ?@expr1073763499 ValueType ::@expr21537 Type ::@expr21559 LONG :@expr1073763502 ValueType ::@expr21537 Type ::@expr21545 INT ; }
7016: else { if (@expr1073763505 platformType@var3710 .@expr21653 mType@var3711 ==@expr1073763507 "long" ) {
7017: type@var1289 =@expr1073763508 platformType@var3710 .@expr21674 mLong@var3712 ?@expr1073763510 ValueType ::@expr21537 Type ::@expr21566 LONGLONG :@expr1073763513 ValueType ::@expr21537 Type ::@expr21559 LONG ; } } } } }
7018: if (@expr1073763516 platformType@var3710 .@expr1073763517 mSigned@var3713 ) {
7019: sign@var1288 =@expr1073763518 ValueType ::@expr21631 SIGNED@expr21518 ; }
7020: else { if (@expr1073763520 platformType@var3710 .@expr1073763521 mUnsigned@var3714 ) {
7021: sign@var1288 =@expr1073763522 ValueType ::@expr21629 UNSIGNED@expr21519 ; } }
7022: if (@expr1073763524 platformType@var3710 .@expr1073763525 mPointer@var3715 ) {
7023: pointer@var1291 =@expr1073763526 1 ; }
7024: if (@expr1073763527 platformType@var3710 .@expr1073763528 mPtrPtr@var3716 ) {
7025: pointer@var1291 =@expr1073763529 2 ; }
7026: if (@expr1073763530 platformType@var3710 .@expr1073763531 mConstPtr@var3717 ) {
7027: constness@var1292 =@expr1073763532 1 ; }
7028: return true ;
7029: } else { if (@expr1073763533 !@expr1073763534 podtype@var3701 &&@expr1073763535 (@expr1073763536 typestr@var3699 ==@expr1073763537 "size_t" ||@expr1073763538 typestr@var3699 ==@expr1073763539 "std::size_t" ) ) {
7030: originalTypeName@var1300 =@expr1073763540 "size_t" ;
7031: sign@var1288 =@expr1073763541 ValueType ::@expr21629 UNSIGNED@expr21519 ;
7032: if (@expr1073763543 settings@var3700 .@expr21720 sizeof_size_t@var3718 ==@expr1073763545 settings@var3700 .@expr21556 sizeof_long@var3707 ) {
7033: type@var1289 =@expr1073763547 ValueType ::@expr21537 Type ::@expr21559 LONG ; }
7034: else { if (@expr1073763550 settings@var3700 .@expr21720 sizeof_size_t@var3718 ==@expr1073763552 settings@var3700 .@expr21563 sizeof_long_long@var3708 ) {
7035: type@var1289 =@expr1073763554 ValueType ::@expr21537 Type ::@expr21566 LONGLONG ; }
7036: else { if (@expr1073763557 settings@var3700 .@expr21720 sizeof_size_t@var3718 ==@expr1073763559 settings@var3700 .@expr21542 sizeof_int@var3705 ) {
7037: type@var1289 =@expr1073763561 ValueType ::@expr21537 Type ::@expr21545 INT ; }
7038: else {
7039: type@var1289 =@expr1073763564 ValueType ::@expr21537 Type ::@expr21623 UNKNOWN_INT ; } } }
7040: return true ;
7041: } }
7042:
7043: return false ;
7044: }
7045:
7046: std :: string ValueType :: dump ( ) const
7047: {
7048: std ::@expr1073763567 ostringstream ret@var3719 ;
7049: switch (@expr1073763568 type@var1289 ) {
7050: case UNKNOWN_TYPE :@expr21745 ;
7051: return "" ;
7052: case NONSTD :@expr21745 ;
7053: ret@var3719 <<@expr1073763571 "valueType-type=\"nonstd\"" ;
7054: break ;
7055: case POD :@expr21745 ;
7056: ret@var3719 <<@expr1073763573 "valueType-type=\"pod\"" ;
7057: break ;
7058: case RECORD :@expr21745 ;
7059: ret@var3719 <<@expr1073763575 "valueType-type=\"record\"" ;
7060: break ;
7061: case SMART_POINTER :@expr21745 ;
7062: ret@var3719 <<@expr1073763577 "valueType-type=\"smart-pointer\"" ;
7063: break ;
7064: case CONTAINER :@expr21745 ;
7065: ret@var3719 <<@expr1073763579 "valueType-type=\"container\"" ;
7066: break ;
7067: case ITERATOR :@expr21745 ;
7068: ret@var3719 <<@expr1073763581 "valueType-type=\"iterator\"" ;
7069: break ;
7070: case VOID :@expr21745 ;
7071: ret@var3719 <<@expr1073763583 "valueType-type=\"void\"" ;
7072: break ;
7073: case BOOL :@expr21745 ;
7074: ret@var3719 <<@expr1073763585 "valueType-type=\"bool\"" ;
7075: break ;
7076: case CHAR :@expr21745 ;
7077: ret@var3719 <<@expr1073763587 "valueType-type=\"char\"" ;
7078: break ;
7079: case SHORT :@expr21745 ;
7080: ret@var3719 <<@expr1073763589 "valueType-type=\"short\"" ;
7081: break ;
7082: case WCHAR_T :@expr21745 ;
7083: ret@var3719 <<@expr1073763591 "valueType-type=\"wchar_t\"" ;
7084: break ;
7085: case INT :@expr21745 ;
7086: ret@var3719 <<@expr1073763593 "valueType-type=\"int\"" ;
7087: break ;
7088: case LONG :@expr21745 ;
7089: ret@var3719 <<@expr1073763595 "valueType-type=\"long\"" ;
7090: break ;
7091: case LONGLONG :@expr21745 ;
7092: ret@var3719 <<@expr1073763597 "valueType-type=\"long long\"" ;
7093: break ;
7094: case UNKNOWN_INT :@expr21745 ;
7095: ret@var3719 <<@expr1073763599 "valueType-type=\"unknown int\"" ;
7096: break ;
7097: case FLOAT :@expr21745 ;
7098: ret@var3719 <<@expr1073763601 "valueType-type=\"float\"" ;
7099: break ;
7100: case DOUBLE :@expr21745 ;
7101: ret@var3719 <<@expr1073763603 "valueType-type=\"double\"" ;
7102: break ;
7103: case LONGDOUBLE :@expr21745 ;
7104: ret@var3719 <<@expr1073763605 "valueType-type=\"long double\"" ;
7105: break ;
7106: }
7107:
7108: switch (@expr1073763606 sign@var1288 ) {
7109: case Sign ::@expr1073763607 UNKNOWN_SIGN :@expr21745 ;
7110: break ;
7111: case Sign ::@expr1073763609 SIGNED :@expr21745 ;
7112: ret@var3719 <<@expr1073763611 " valueType-sign=\"signed\"" ;
7113: break ;
7114: case Sign ::@expr1073763612 UNSIGNED :@expr21745 ;
7115: ret@var3719 <<@expr1073763614 " valueType-sign=\"unsigned\"" ;
7116: break ;
7117: }
7118:
7119: if (@expr1073763615 bits@var1290 >@expr1073763616 0 ) {
7120: ret@var3719 <<@expr1073763617 " valueType-bits=\"" <<@expr1073763618 bits@var1290 <<@expr1073763619 '\"' ; }
7121:
7122: if (@expr1073763620 pointer@var1291 >@expr1073763621 0 ) {
7123: ret@var3719 <<@expr1073763622 " valueType-pointer=\"" <<@expr1073763623 pointer@var1291 <<@expr1073763624 '\"' ; }
7124:
7125: if (@expr1073763625 constness@var1292 >@expr1073763626 0 ) {
7126: ret@var3719 <<@expr1073763627 " valueType-constness=\"" <<@expr1073763628 constness@var1292 <<@expr1073763629 '\"' ; }
7127:
7128: if (@expr1073763630 reference@var1293 ==@expr1073763631 Reference ::@expr1073763632 None ) {
7129: ret@var3719 <<@expr1073763633 " valueType-reference=\"None\"" ; }
7130: else { if (@expr1073763634 reference@var1293 ==@expr1073763635 Reference ::@expr1073763636 LValue ) {
7131: ret@var3719 <<@expr1073763637 " valueType-reference=\"LValue\"" ; }
7132: else { if (@expr1073763638 reference@var1293 ==@expr1073763639 Reference ::@expr1073763640 RValue ) {
7133: ret@var3719 <<@expr1073763641 " valueType-reference=\"RValue\"" ; } } }
7134:
7135: if (@expr1073763642 typeScope@var1294 ) {
7136: ret@var3719 <<@expr1073763643 " valueType-typeScope=\"" <<@expr1073763644 typeScope@var1294 <<@expr1073763645 '\"' ; }
7137:
7138: if (@expr1073763646 !@expr1073763647 originalTypeName@var1300 .@expr1073763648 empty (@expr1073763649 ) ) {
7139: ret@var3719 <<@expr1073763650 " valueType-originalTypeName=\"" <<@expr1073763651 ErrorLogger ::@expr1073763652 toxml (@expr1073763653 originalTypeName@var1300 ) <<@expr1073763654 '\"' ; }
7140:
7141: return ret@var3719 .@expr1073763655 str (@expr1073763656 ) ;
7142: }
7143:
7144: long long ValueType :: typeSize ( const cppcheck :: Platform & platform@var3720 , bool p@var3721 ) const
7145: {
7146: if (@expr1073763657 p@var3721 &&@expr1073763658 pointer@var1291 ) {
7147: return platform@var3720 .@expr1073763659 sizeof_pointer@var3722 ; }
7148:
7149: if (@expr1073763660 typeScope@var1294 &&@expr1073763661 typeScope@var1294 .@expr21838 definedType@var3812 &&@expr1073763663 typeScope@var1294 .@expr21838 definedType@var3812 .@expr21841 sizeOf@var3813 ) {
7150: return typeScope@var1294 .@expr21838 definedType@var3812 .@expr21841 sizeOf@var3813 ; }
7151:
7152: switch (@expr1073763668 type@var1289 ) {
7153: case ValueType ::@expr21845 Type ::@expr1073763670 BOOL :@expr21847 ;
7154: return platform@var3720 .@expr1073763672 sizeof_bool@var3723 ;
7155: case ValueType ::@expr21845 Type ::@expr1073763674 CHAR :@expr21847 ;
7156: return 1 ;
7157: case ValueType ::@expr21845 Type ::@expr1073763677 SHORT :@expr21847 ;
7158: return platform@var3720 .@expr1073763679 sizeof_short@var3724 ;
7159: case ValueType ::@expr21845 Type ::@expr1073763681 WCHAR_T :@expr21847 ;
7160: return platform@var3720 .@expr1073763683 sizeof_wchar_t@var3725 ;
7161: case ValueType ::@expr21845 Type ::@expr1073763685 INT :@expr21847 ;
7162: return platform@var3720 .@expr1073763687 sizeof_int@var3726 ;
7163: case ValueType ::@expr21845 Type ::@expr1073763689 LONG :@expr21847 ;
7164: return platform@var3720 .@expr1073763691 sizeof_long@var3727 ;
7165: case ValueType ::@expr21845 Type ::@expr1073763693 LONGLONG :@expr21847 ;
7166: return platform@var3720 .@expr1073763695 sizeof_long_long@var3728 ;
7167: case ValueType ::@expr21845 Type ::@expr1073763697 FLOAT :@expr21847 ;
7168: return platform@var3720 .@expr1073763699 sizeof_float@var3729 ;
7169: case ValueType ::@expr21845 Type ::@expr1073763701 DOUBLE :@expr21847 ;
7170: return platform@var3720 .@expr1073763703 sizeof_double@var3730 ;
7171: case ValueType ::@expr21845 Type ::@expr1073763705 LONGDOUBLE :@expr21847 ;
7172: return platform@var3720 .@expr1073763707 sizeof_long_double@var3731 ;
7173: default :@expr21847 ;
7174: break ;
7175: }
7176:
7177:
7178: return 0 ;
7179: }
7180:
7181: bool ValueType :: isTypeEqual ( const ValueType * that@var3732 ) const
7182: {
7183: auto tie@var3733 ; tie@var3733 =@expr1073763709 [@expr1073763710 ] (@expr1073763711 const ValueType *@expr1073763712 vt@var3734 ) {
7184: return std ::@expr1073763713 tie (@expr1073763714 vt@var3734 .@expr1073763715 type@var3735 , vt@var3734 .@expr1073763716 container@var3736 , vt@var3734 .@expr1073763717 pointer@var3737 , vt@var3734 .@expr1073763718 typeScope@var3738 , vt@var3734 .@expr1073763719 smartPointer@var3739 ) ;
7185: } ;
7186: return tie@var3733 (@expr1073763720 this@expr1073763721 ) ==@expr1073763722 tie@var3733 (@expr1073763723 that@var3732 ) ;
7187: }
7188:
7189: std :: string ValueType :: str ( ) const
7190: {
7191: std ::@expr1073763726 string ret@var3740 ;
7192: if (@expr1073763727 constness@var1292 &@expr1073763728 1 ) {
7193: ret@var3740 =@expr1073763729 " const" ; }
7194: if (@expr1073763730 type@var1289 ==@expr1073763731 VOID ) {
7195: ret@var3740 +=@expr1073763732 " void" ; }
7196: else { if (@expr1073763733 isIntegral (@expr1073763734 ) ) {
7197: if (@expr1073763735 sign@var1288 ==@expr1073763736 SIGNED@expr1073763724 ) {
7198: ret@var3740 +=@expr1073763737 " signed" ; }
7199: else { if (@expr1073763738 sign@var1288 ==@expr1073763739 UNSIGNED@expr1073763725 ) {
7200: ret@var3740 +=@expr1073763740 " unsigned" ; } }
7201: if (@expr1073763741 type@var1289 ==@expr1073763742 BOOL ) {
7202: ret@var3740 +=@expr1073763743 " bool" ; }
7203: else { if (@expr1073763744 type@var1289 ==@expr1073763745 CHAR ) {
7204: ret@var3740 +=@expr1073763746 " char" ; }
7205: else { if (@expr1073763747 type@var1289 ==@expr1073763748 SHORT ) {
7206: ret@var3740 +=@expr1073763749 " short" ; }
7207: else { if (@expr1073763750 type@var1289 ==@expr1073763751 WCHAR_T ) {
7208: ret@var3740 +=@expr1073763752 " wchar_t" ; }
7209: else { if (@expr1073763753 type@var1289 ==@expr1073763754 INT ) {
7210: ret@var3740 +=@expr1073763755 " int" ; }
7211: else { if (@expr1073763756 type@var1289 ==@expr1073763757 LONG ) {
7212: ret@var3740 +=@expr1073763758 " long" ; }
7213: else { if (@expr1073763759 type@var1289 ==@expr1073763760 LONGLONG ) {
7214: ret@var3740 +=@expr1073763761 " long long" ; }
7215: else { if (@expr1073763762 type@var1289 ==@expr1073763763 UNKNOWN_INT ) {
7216: ret@var3740 +=@expr1073763764 " unknown_int" ; } } } } } } } }
7217: } else { if (@expr1073763765 type@var1289 ==@expr1073763766 FLOAT ) {
7218: ret@var3740 +=@expr1073763767 " float" ; }
7219: else { if (@expr1073763768 type@var1289 ==@expr1073763769 DOUBLE ) {
7220: ret@var3740 +=@expr1073763770 " double" ; }
7221: else { if (@expr1073763771 type@var1289 ==@expr1073763772 LONGDOUBLE ) {
7222: ret@var3740 +=@expr1073763773 " long double" ; }
7223: else { if (@expr1073763774 (@expr1073763775 type@var1289 ==@expr1073763776 ValueType ::@expr21953 Type ::@expr1073763778 NONSTD ||@expr1073763779 type@var1289 ==@expr1073763780 ValueType ::@expr21953 Type ::@expr1073763782 RECORD ) &&@expr1073763783 typeScope@var1294 ) {
7224: std ::@expr1073763784 string className@var3741 (@expr1073763785 typeScope@var1294 .@expr1073763786 className@var3814 ) ;
7225: const Scope * scope@var3742 ; scope@var3742 =@expr1073763787 typeScope@var1294 .@expr21964 definedType@var3812 ?@expr1073763789 typeScope@var1294 .@expr21964 definedType@var3812 .@expr1073763791 enclosingScope@var3815 :@expr1073763792 typeScope@var1294 .@expr1073763793 nestedIn@var3816 ;
7226: while (@expr1073763794 scope@var3742 &&@expr1073763795 scope@var3742 .@expr21972 type@var3743 !=@expr1073763797 Scope ::@expr1073763798 eGlobal ) {
7227: if (@expr1073763799 scope@var3742 .@expr21972 type@var3743 ==@expr1073763801 Scope ::@expr1073763802 eClass ||@expr1073763803 scope@var3742 .@expr21972 type@var3743 ==@expr1073763805 Scope ::@expr1073763806 eStruct ||@expr1073763807 scope@var3742 .@expr21972 type@var3743 ==@expr1073763809 Scope ::@expr1073763810 eNamespace ) {
7228: className@var3741 =@expr1073763811 scope@var3742 .@expr1073763812 className@var3744 +@expr1073763813 "::" +@expr1073763814 className@var3741 ; }
7229: scope@var3742 =@expr1073763815 (@expr1073763816 scope@var3742 .@expr21993 definedType@var3745 &&@expr1073763818 scope@var3742 .@expr21993 definedType@var3745 .@expr21996 enclosingScope@var3746 ) ?@expr1073763821 scope@var3742 .@expr21993 definedType@var3745 .@expr21996 enclosingScope@var3746 :@expr1073763824 scope@var3742 .@expr1073763825 nestedIn@var3747 ;
7230: }
7231: ret@var3740 +=@expr1073763826 ' ' +@expr1073763827 className@var3741 ;
7232: } else { if (@expr1073763828 type@var1289 ==@expr1073763829 ValueType ::@expr21953 Type ::@expr1073763831 CONTAINER &&@expr1073763832 container@var1298 ) {
7233: ret@var3740 +=@expr1073763833 " container(" +@expr1073763834 container@var1298 .@expr22011 startPattern@var3817 +@expr1073763836 ')' ;
7234: } else { if (@expr1073763837 type@var1289 ==@expr1073763838 ValueType ::@expr21953 Type ::@expr1073763840 ITERATOR &&@expr1073763841 container@var1298 ) {
7235: ret@var3740 +=@expr1073763842 " iterator(" +@expr1073763843 container@var1298 .@expr22011 startPattern@var3817 +@expr1073763845 ')' ;
7236: } else { if (@expr1073763846 type@var1289 ==@expr1073763847 ValueType ::@expr21953 Type ::@expr1073763849 SMART_POINTER &&@expr1073763850 smartPointer@var1297 ) {
7237: ret@var3740 +=@expr1073763851 " smart-pointer(" +@expr1073763852 smartPointer@var1297 .@expr1073763853 name@var3818 +@expr1073763854 ")" ;
7238: } } } } } } } } }
7239: for (@expr1073763855 unsigned int p@var3748 =@expr1073763856 0 ; p@var3748 <@expr1073763857 pointer@var1291 ; p@var3748 ++@expr1073763858 ) {
7240: ret@var3740 +=@expr1073763859 " *" ;
7241: if (@expr1073763860 constness@var1292 &@expr1073763861 (@expr1073763862 2 <<@expr1073763863 p@var3748 ) ) {
7242: ret@var3740 +=@expr1073763864 " const" ; }
7243: }
7244: if (@expr1073763865 reference@var1293 ==@expr1073763866 Reference ::@expr1073763867 LValue ) {
7245: ret@var3740 +=@expr1073763868 " &" ; }
7246: else { if (@expr1073763869 reference@var1293 ==@expr1073763870 Reference ::@expr1073763871 RValue ) {
7247: ret@var3740 +=@expr1073763872 " &&" ; } }
7248: return ret@var3740 .@expr1073763873 empty (@expr1073763874 ) ?@expr1073763875 ret@var3740 :@expr1073763876 ret@var3740 .@expr1073763877 substr (@expr1073763878 1 ) ;
7249: }
7250:
7251: ValueType :: MatchResult ValueType :: matchParameter ( const ValueType * call@var3749 , const ValueType * func@var3750 )
7252: {
7253: if (@expr1073763881 !@expr1073763882 call@var3749 ||@expr1073763883 !@expr1073763884 func@var3750 ) {
7254: return ValueType ::@expr22061 MatchResult ::@expr22062 UNKNOWN@expr22055 ; }
7255: if (@expr1073763887 call@var3749 .@expr22064 pointer@var3751 !=@expr1073763889 func@var3750 .@expr22066 pointer@var3752 ) {
7256: if (@expr1073763891 call@var3749 .@expr22064 pointer@var3751 >@expr1073763893 1 &&@expr1073763894 func@var3750 .@expr22066 pointer@var3752 ==@expr1073763896 1 &&@expr1073763897 func@var3750 .@expr22074 type@var3753 ==@expr22075 ValueType ::@expr22076 Type ::@expr22077 VOID ) {
7257: return ValueType ::@expr22061 MatchResult ::@expr22079 FALLBACK1 ; }
7258: if (@expr1073763904 call@var3749 .@expr22064 pointer@var3751 ==@expr22082 1 &&@expr1073763907 func@var3750 .@expr22066 pointer@var3752 ==@expr22085 0 &&@expr1073763910 func@var3750 .@expr22087 isIntegral (@expr22088 ) &&@expr1073763913 func@var3750 .@expr22090 sign@var3754 !=@expr1073763915 ValueType ::@expr22092 Sign ::@expr1073763917 SIGNED@expr1073763880 ) {
7259: return ValueType ::@expr22061 MatchResult ::@expr22079 FALLBACK1 ; }
7260: if (@expr1073763920 call@var3749 .@expr22064 pointer@var3751 ==@expr22082 1 &&@expr1073763923 call@var3749 .@expr22100 type@var3755 ==@expr1073763925 ValueType ::@expr22076 Type ::@expr1073763927 CHAR &&@expr1073763928 func@var3750 .@expr22066 pointer@var3752 ==@expr22085 0 &&@expr1073763931 func@var3750 .@expr22108 container@var3756 &&@expr1073763933 func@var3750 .@expr22108 container@var3756 .@expr1073763935 stdStringLike@var3757 ) {
7261: return ValueType ::@expr22061 MatchResult ::@expr22113 FALLBACK2 ; }
7262: return ValueType ::@expr22061 MatchResult ::@expr22115 NOMATCH ;
7263: }
7264: if (@expr22116 call@var3749 .@expr22064 pointer@var3751 >@expr22118 0 ) {
7265: if (@expr1073763943 (@expr1073763944 call@var3749 .@expr22121 constness@var3758 |@expr1073763946 func@var3750 .@expr22123 constness@var3759 ) !=@expr1073763948 func@var3750 .@expr22123 constness@var3759 ) {
7266: return ValueType ::@expr22061 MatchResult ::@expr22115 NOMATCH ; }
7267: if (@expr1073763952 call@var3749 .@expr22121 constness@var3758 ==@expr1073763954 0 &&@expr1073763955 func@var3750 .@expr22123 constness@var3759 !=@expr1073763957 0 &&@expr1073763958 func@var3750 .@expr22135 reference@var3760 !=@expr22136 Reference ::@expr22137 None ) {
7268: return ValueType ::@expr22061 MatchResult ::@expr22115 NOMATCH ; }
7269: }
7270: if (@expr1073763964 call@var3749 .@expr22100 type@var3755 !=@expr1073763966 func@var3750 .@expr22074 type@var3753 ) {
7271: if (@expr1073763968 call@var3749 .@expr22100 type@var3755 ==@expr1073763970 ValueType ::@expr22076 Type ::@expr22077 VOID ||@expr1073763973 func@var3750 .@expr22074 type@var3753 ==@expr22075 ValueType ::@expr22076 Type ::@expr22077 VOID ) {
7272: return ValueType ::@expr22061 MatchResult ::@expr22079 FALLBACK1 ; }
7273: if (@expr22116 call@var3749 .@expr22064 pointer@var3751 >@expr22118 0 ) {
7274: return func@var3750 .@expr22074 type@var3753 ==@expr1073763984 ValueType ::@expr1073763985 UNKNOWN_TYPE ?@expr1073763986 ValueType ::@expr22061 MatchResult ::@expr22062 UNKNOWN :@expr1073763989 ValueType ::@expr22061 MatchResult ::@expr22115 NOMATCH ; }
7275: if (@expr1073763992 call@var3749 .@expr22169 isIntegral (@expr22170 ) &&@expr22171 func@var3750 .@expr22087 isIntegral (@expr22088 ) ) {
7276: return call@var3749 .@expr22100 type@var3755 <@expr1073763999 func@var3750 .@expr22074 type@var3753 ?@expr1073764001
7277: ValueType ::@expr22061 MatchResult ::@expr22079 FALLBACK1 :@expr1073764004
7278: ValueType ::@expr22061 MatchResult ::@expr22113 FALLBACK2 ; }
7279: else { if (@expr1073764007 call@var3749 .@expr22184 isFloat (@expr22185 ) &&@expr1073764010 func@var3750 .@expr22187 isFloat (@expr22188 ) ) {
7280: return ValueType ::@expr22061 MatchResult ::@expr22079 FALLBACK1 ; }
7281: else { if (@expr1073764015 call@var3749 .@expr22169 isIntegral (@expr22170 ) &&@expr1073764018 func@var3750 .@expr22187 isFloat (@expr22188 ) ) {
7282: return ValueType ::@expr22061 MatchResult ::@expr22113 FALLBACK2 ; }
7283: else { if (@expr1073764023 call@var3749 .@expr22184 isFloat (@expr22185 ) &&@expr1073764026 func@var3750 .@expr22087 isIntegral (@expr22088 ) ) {
7284: return ValueType ::@expr22061 MatchResult ::@expr22113 FALLBACK2 ; } } } }
7285: return ValueType ::@expr22061 MatchResult ::@expr22062 UNKNOWN@expr22055 ;
7286: }
7287:
7288: if (@expr1073764033 call@var3749 .@expr22210 typeScope@var3761 !=@expr1073764035 nullptr ||@expr1073764036 func@var3750 .@expr22213 typeScope@var3762 !=@expr22214 nullptr ) {
7289: if (@expr1073764039 call@var3749 .@expr22210 typeScope@var3761 !=@expr1073764041 func@var3750 .@expr22213 typeScope@var3762 ) {
7290: return ValueType ::@expr22061 MatchResult ::@expr22115 NOMATCH ; }
7291: }
7292:
7293: if (@expr1073764045 call@var3749 .@expr22222 container@var3763 !=@expr1073764047 nullptr ||@expr1073764048 func@var3750 .@expr22108 container@var3756 !=@expr22226 nullptr ) {
7294: if (@expr1073764051 call@var3749 .@expr22222 container@var3763 !=@expr1073764053 func@var3750 .@expr22108 container@var3756 ) {
7295: return ValueType ::@expr22061 MatchResult ::@expr22115 NOMATCH ; }
7296: }
7297:
7298: if (@expr1073764057 func@var3750 .@expr22213 typeScope@var3762 !=@expr22214 nullptr &&@expr1073764060 func@var3750 .@expr22108 container@var3756 !=@expr22226 nullptr ) {
7299: if (@expr1073764063 func@var3750 .@expr22074 type@var3753 <@expr1073764065 ValueType ::@expr22076 Type ::@expr22077 VOID ||@expr1073764068 func@var3750 .@expr22074 type@var3753 ==@expr1073764070 ValueType ::@expr22076 Type ::@expr1073764072 UNKNOWN_INT ) {
7300: return ValueType ::@expr22061 MatchResult ::@expr22062 UNKNOWN@expr22055 ; }
7301: }
7302:
7303: if (@expr1073764075 call@var3749 .@expr22169 isIntegral (@expr22170 ) &&@expr22171 func@var3750 .@expr22087 isIntegral (@expr22088 ) &&@expr1073764081 call@var3749 .@expr22258 sign@var3764 !=@expr1073764083 ValueType ::@expr22092 Sign ::@expr22261 UNKNOWN_SIGN &&@expr1073764086 func@var3750 .@expr22090 sign@var3754 !=@expr1073764088 ValueType ::@expr22092 Sign ::@expr22261 UNKNOWN_SIGN &&@expr1073764091 call@var3749 .@expr22258 sign@var3764 !=@expr1073764093 func@var3750 .@expr22090 sign@var3754 ) {
7304: return ValueType ::@expr22061 MatchResult ::@expr22079 FALLBACK1 ; }
7305:
7306: if (@expr1073764097 func@var3750 .@expr22135 reference@var3760 !=@expr22136 Reference ::@expr22137 None &&@expr1073764101 func@var3750 .@expr22123 constness@var3759 >@expr1073764103 call@var3749 .@expr22121 constness@var3758 ) {
7307: return ValueType ::@expr22061 MatchResult ::@expr22079 FALLBACK1 ; }
7308:
7309: return ValueType ::@expr22061 MatchResult ::@expr1073764108 SAME ;
7310: }
7311:
7312: ValueType :: MatchResult ValueType :: matchParameter ( const ValueType * call@var3765 , const Variable * callVar@var3766 , const Variable * funcVar@var3767 )
7313: {
7314: ValueType vt@var3768 ;
7315: const ValueType * pvt@var3769 ; pvt@var3769 =@expr1073764111 funcVar@var3767 .@expr1073764112 valueType (@expr1073764113 ) ;
7316: if (@expr1073764114 pvt@var3769 &&@expr1073764115 funcVar@var3767 .@expr1073764116 isArray (@expr1073764117 ) &&@expr1073764118 !@expr1073764119 (@expr1073764120 funcVar@var3767 .@expr1073764121 isStlType (@expr1073764122 ) &&@expr1073764123 Token ::@expr1073764124 simpleMatch (@expr1073764125 funcVar@var3767 .@expr22302 typeStartToken (@expr22303 ) , "std :: array" ) ) ) {
7317: vt@var3768 =@expr1073764128 *@expr1073764129 pvt@var3769 ;
7318: if (@expr1073764130 vt@var3768 .@expr22307 pointer@var3770 ==@expr1073764132 0 ) {
7319: ++@expr1073764133 vt@var3768 .@expr22307 pointer@var3770 ; }
7320: pvt@var3769 =@expr1073764135 &@expr1073764136 vt@var3768 ;
7321: }
7322: ValueType ::@expr1073764137 MatchResult res@var3771 ; res@var3771 =@expr1073764138 ValueType ::@expr1073764139 matchParameter (@expr1073764140 call@var3765 , pvt@var3769 ) ;
7323: if (@expr1073764141 callVar@var3766 &&@expr1073764142 (@expr1073764143 (@expr1073764144 res@var3771 ==@expr1073764145 ValueType ::@expr22322 MatchResult ::@expr22323 SAME &&@expr1073764148 call@var3765 .@expr1073764149 container@var3772 ) ||@expr1073764150 res@var3771 ==@expr1073764151 ValueType ::@expr22322 MatchResult ::@expr1073764153 UNKNOWN@expr1073764109 ) ) {
7324: const std ::@expr22330 string type1@var3773 =@expr1073764155 getTypeString (@expr1073764156 callVar@var3766 .@expr1073764157 typeStartToken (@expr1073764158 ) ) ;
7325: const std ::@expr22330 string type2@var3774 =@expr1073764160 getTypeString (@expr1073764161 funcVar@var3767 .@expr22302 typeStartToken (@expr22303 ) ) ;
7326: const bool templateVar@var3775 =@expr1073764164
7327: funcVar@var3767 .@expr22341 scope (@expr22342 ) &&@expr1073764167 funcVar@var3767 .@expr22341 scope (@expr22342 ) .@expr22346 function@var3861 &&@expr1073764171 funcVar@var3767 .@expr22341 scope (@expr22342 ) .@expr22346 function@var3861 .@expr1073764175 templateDef@var3862 ;
7328: if (@expr1073764176 type1@var3773 ==@expr1073764177 type2@var3774 ) {
7329: return ValueType ::@expr22322 MatchResult ::@expr22323 SAME ; }
7330: if (@expr1073764180 !@expr1073764181 templateVar@var3775 &&@expr1073764182 type1@var3773 .@expr1073764183 find (@expr1073764184 "auto" ) ==@expr1073764185 std ::@expr22362 string ::@expr22363 npos &&@expr1073764188 type2@var3774 .@expr1073764189 find (@expr1073764190 "auto" ) ==@expr1073764191 std ::@expr22362 string ::@expr22363 npos@expr1073764110 ) {
7331: return ValueType ::@expr22322 MatchResult ::@expr1073764195 NOMATCH ; }
7332: }
7333: return res@var3771 ;
7334: }

##file cppcheck-2.8/lib/settings.h

14:
|
48:
49: class SimpleEnableGroup<Severity::SeverityType> {
50: uint32_t mFlags@var3776 ; mFlags@var3776 = 0 ;
51: public:
52: uint32_t intValue ( ) const {
53: return mFlags@var3776 ;
54: }
55: void clear ( ) {
56: mFlags@var3776 =@expr1073764196 0 ;
57: }
58: void fill ( ) {
59: mFlags@var3776 =@expr1073764197 0xFFFFFFFF ;
60: }
61: void setEnabledAll ( bool enabled@var3777 ) {
62: if (@expr1073764198 enabled@var3777 ) {
63: fill (@expr1073764199 ) ; }
64: else {
65: clear (@expr1073764200 ) ; }
66: }
67: bool isEnabled ( Severity :: SeverityType flag@var3778 ) const {
68: return (@expr22377 mFlags@var3776 &@expr1073764202 (@expr22377 1U <<@expr1073764204 (@expr1073764205 uint32_t ) flag@var3778 ) ) !=@expr1073764206 0 ;
69: }
70: void enable ( Severity :: SeverityType flag@var3779 ) {
71: mFlags@var3776 |=@expr1073764207 (@expr1073764208 1U <<@expr1073764209 (@expr1073764210 uint32_t ) flag@var3779 ) ;
72: }
73: void disable ( Severity :: SeverityType flag@var3780 ) {
74: mFlags@var3776 &=@expr1073764211 ~@expr1073764212 (@expr1073764213 1U <<@expr1073764214 (@expr1073764215 uint32_t ) flag@var3780 ) ;
75: }
76: void setEnabled ( Severity :: SeverityType flag@var3781 , bool enabled@var3782 ) {
77: if (@expr1073764216 enabled@var3782 ) {
78: enable (@expr1073764217 flag@var3781 ) ; }
79: else {
80: disable (@expr1073764218 flag@var3781 ) ; }
81: }
82: } ;
49: class SimpleEnableGroup<Certainty::CertaintyLevel> {
50: uint32_t mFlags@var3783 ; mFlags@var3783 = 0 ;
51: public:
52: uint32_t intValue ( ) const {
53: return mFlags@var3783 ;
54: }
55: void clear ( ) {
56: mFlags@var3783 =@expr1073764219 0 ;
57: }
58: void fill ( ) {
59: mFlags@var3783 =@expr1073764220 0xFFFFFFFF ;
60: }
61: void setEnabledAll ( bool enabled@var3784 ) {
62: if (@expr1073764221 enabled@var3784 ) {
63: fill (@expr1073764222 ) ; }
64: else {
65: clear (@expr1073764223 ) ; }
66: }
67: bool isEnabled ( Certainty :: CertaintyLevel flag@var3785 ) const {
68: return (@expr22400 mFlags@var3783 &@expr1073764225 (@expr22400 1U <<@expr1073764227 (@expr1073764228 uint32_t ) flag@var3785 ) ) !=@expr1073764229 0 ;
69: }
70: void enable ( Certainty :: CertaintyLevel flag@var3786 ) {
71: mFlags@var3783 |=@expr1073764230 (@expr1073764231 1U <<@expr1073764232 (@expr1073764233 uint32_t ) flag@var3786 ) ;
72: }
73: void disable ( Certainty :: CertaintyLevel flag@var3787 ) {
74: mFlags@var3783 &=@expr1073764234 ~@expr1073764235 (@expr1073764236 1U <<@expr1073764237 (@expr1073764238 uint32_t ) flag@var3787 ) ;
75: }
76: void setEnabled ( Certainty :: CertaintyLevel flag@var3788 , bool enabled@var3789 ) {
77: if (@expr1073764239 enabled@var3789 ) {
78: enable (@expr1073764240 flag@var3788 ) ; }
79: else {
80: disable (@expr1073764241 flag@var3788 ) ; }
81: }
82: } ;
49: class SimpleEnableGroup<Checks::CheckList> {
50: uint32_t mFlags@var3790 ; mFlags@var3790 = 0 ;
51: public:
52: uint32_t intValue ( ) const {
53: return mFlags@var3790 ;
54: }
55: void clear ( ) {
56: mFlags@var3790 =@expr1073764242 0 ;
57: }
58: void fill ( ) {
59: mFlags@var3790 =@expr1073764243 0xFFFFFFFF ;
60: }
61: void setEnabledAll ( bool enabled@var3791 ) {
62: if (@expr1073764244 enabled@var3791 ) {
63: fill (@expr1073764245 ) ; }
64: else {
65: clear (@expr1073764246 ) ; }
66: }
67: bool isEnabled ( Checks :: CheckList flag@var3792 ) const {
68: return (@expr22423 mFlags@var3790 &@expr1073764248 (@expr22423 1U <<@expr1073764250 (@expr1073764251 uint32_t ) flag@var3792 ) ) !=@expr1073764252 0 ;
69: }
70: void enable ( Checks :: CheckList flag@var3793 ) {
71: mFlags@var3790 |=@expr1073764253 (@expr1073764254 1U <<@expr1073764255 (@expr1073764256 uint32_t ) flag@var3793 ) ;
72: }
73: void disable ( Checks :: CheckList flag@var3794 ) {
74: mFlags@var3790 &=@expr1073764257 ~@expr1073764258 (@expr1073764259 1U <<@expr1073764260 (@expr1073764261 uint32_t ) flag@var3794 ) ;
75: }
76: void setEnabled ( Checks :: CheckList flag@var3795 , bool enabled@var3796 ) {
77: if (@expr1073764262 enabled@var3796 ) {
78: enable (@expr1073764263 flag@var3795 ) ; }
79: else {
80: disable (@expr1073764264 flag@var3795 ) ; }
81: }
82: } ;



##Value flow
Line 43
  INT always 0
  LONG always 1
  LONGLONG always 2
  FLOAT always 3
Line 44
  mIsUnsigned always {!<=-1,!>=2}
Line 51
  ( always {!<=-1,!>=2}
Line 52
  return always {!<=-1,!>=2}
  != always {!<=-1,!>=2}
  :: always 3
  FLOAT always 3
Line 54
  ( always {!<=-1,!>=2}
Line 55
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 3
  FLOAT always 3
Line 59
  ( always {!<=-1,!>=2}
Line 74
  ( always !<=-1
Line 83
  ( always {!<=-1,!>=2}
Line 84
  ( always {!<=-1,!>=2}
Line 85
  ( always {!<=-1,!>=2}
Line 86
  ( always {!<=-1,!>=2}
Line 87
  ( always {!<=-1,!>=2}
Line 88
  ( always {!<=-1,!>=2}
Line 89
  ( always {!<=-1,!>=2}
Line 90
  ( always {!<=-1,!>=2}
Line 91
  ( always {!<=-1,!>=2}
Line 92
  ( always {!<=-1,!>=2}
Line 102
  ( always {!<=-1,!>=2}
  , always 1
  supportMicrosoftExtensions always {!<=-1,!>=2}
  = always 1
  true always 1
Line 115
  ( always !<=-1
Line 116
  ( always {!<=-1,!>=2}
Line 117
  ( always {!<=-1,!>=2}
Line 118
  ( always {!<=-1,!>=2}
Line 119
  ( always {!<=-1,!>=2}
Line 120
  ( always {!<=-1,!>=2}
Line 121
  ( always {!<=-1,!>=2}
Line 122
  ( always {!<=-1,!>=2}
Line 128
  ( always {!<=-1,!>=2}
Line 130
  ( always !<=-1
Line 137
  ( always {!<=-1,!>=2}
  , always !<=-1
  :: always !<=-1
  iPos always !<=-1
Line 36
  AST always 0
  SYNTAX always 1
  UNKNOWN_MACRO always 2
  INTERNAL always 3
  LIMIT always 4
  INSTANTIATION always 5
Line 37
  = always 3
  INTERNAL always 3
Line 47
  normal always 0
  inconclusive always 1
  safe always 2
  experimental always 3
Line 54
  unusedFunction always 0
  missingInclude always 1
  internalCheck always 2
Line 68
  none always 0
Line 74
  error always 1
Line 80
  warning always 2
Line 87
  style always 3
Line 93
  performance always 4
Line 101
  portability always 5
Line 108
  information always 6
Line 113
  debug always 7
Line 121
  ( possible lifetime[SubObject]=(cweId)
  cweId always !<=-1
  id always !<=-1
  cweId always !<=-1
Line 122
  id always !<=-1
Line 47
  ( always {!<=-1,!>=2}
Line 49
  return always {!<=-1,!>=2}
  != always {!<=-1,!>=2}
Line 53
  ( always {!<=-1,!>=2}
Line 55
  return always {!<=-1,!>=2}
  != always {!<=-1,!>=2}
Line 59
  ( always {!<=-1,!>=2}
Line 61
  return always {!<=-1,!>=2}
  != always {!<=-1,!>=2}
Line 67
  ( always !<=-1
Line 69
  return always !<=-1
  ( always !<=-1
Line 73
  ( always {!<=-1,!>=2}
Line 75
  return always {!<=-1,!>=2}
  ! {!<=-1,!>=2,0}
  str possible size=0
  ( {!<=-1,!>=2,1}
  && always {!<=-1,!>=2}
  str always !size=0
  == always {!<=-1,!>=2}
  c possible {58@24,39@46653,34@46909}
Line 78
  ( always {!<=-1,!>=2}
  , always !<=-1
  endlen always !<=-1
Line 80
  return always {!<=-1,!>=2}
  ( always !<=-1
  >= always {!<=-1,!>=2}
  endlen always !<=-1
  && always {!<=-1,!>=2}
  ( {!<=-1,>=symbolic=(endlen),!<=symbolic=(endlen-1)}
  - always !<=-1
  endlen {!<=-1,<=symbolic=(str.size()),!>=symbolic=(str.size()+1)}
  endlen {!<=-1,<=symbolic=(str.size()),!>=symbolic=(str.size()+1)}
  end possible " const"@31038
  == always {!<=-1,!>=2}
  0 always 0
Line 84
  ( always {!<=-1,!>=2}
  ( always !0
  & always !0
Line 86
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  end possible " const"@121
  1 always 1
Line 89
  ( always {!<=-1,!>=2}
Line 91
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  q possible {39@182,34@183}
Line 92
  return always {!<=-1,!>=2}
  false always 0
Line 93
  ( always !<=-1
  + always !<=0
  1 always 1
  > always {!<=-1,!>=2}
  p possible {""@182,""@183,""@184,"U"@185,"U"@186,"u"@187,"u"@188,"u8"@189,"u8"@190}
  ( always !<=-1
  && always {!<=-1,!>=2}
  0 always 0
  ( always !<=-1
  + always !<=0
  1 always 1
  == always {!<=-1,!>=2}
  0 always 0
Line 94
  return always {!<=-1,!>=2}
  true always 1
Line 95
  return always {!<=-1,!>=2}
  false always 0
Line 98
  ( always {!<=-1,!>=2}
Line 100
  "" always ""
  "u8" always "u8"
  "u" always "u"
  "U" always "U"
  "L" always "L"
Line 102
  ( always {!<=-1,!>=2}
  q possible {39@58,34@59}
Line 103
  return always {!<=-1,!>=2}
  true always 1
Line 105
  return always {!<=-1,!>=2}
  false always 0
Line 108
  ( always {!<=-1,!>=2}
Line 110
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  '"' always 34
Line 113
  ( always {!<=-1,!>=2}
Line 115
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  '\'' always 39
Line 120
  quotePos always !<=-1
  = always !<=-1
  ( always !<=-1
  q possible {39@55,34@57}
Line 121
  quotePos {symbolic=(str.find(q)),!<=-1}
  + always !<=0
  1U always 1
  ( always !<=-1
  - always !<=-1
  quotePos {symbolic=(str.find(q)),!<=-1}
  - always !<=-1
  2U always 2
Line 126
  ( always {!<=-1,!>=2}
Line 127
  '"' always 34
Line 128
  "" always ""
Line 133
  ( always {!<=-1,!>=2}
Line 134
  '\'' always 39
Line 135
  "" always ""
Line 140
  i possible {2,3}
  == {!<=-1,!>=2,0}
  1 always 1
Line 141
  "st" always "st"
Line 142
  i {3,!1}
  == {!<=-1,!>=2,0}
  2 always 2
Line 143
  "nd" always "nd"
Line 144
  i always {!1,!2}
  == always {!<=-1,!>=2}
  3 always 3
Line 145
  "rd" always "rd"
Line 146
  "th" always "th"
Line 151
  ( always {!<=-1,!>=2}
Line 153
  ( always {!<=-1,!>=2}
Line 155
  ( always {!<=-1,!>=2}
Line 38
  C89 always 0
  C99 always 1
  C11 always 2
  CLatest always 2
  = always 2
  C11 always 2
Line 41
  CPP03 always 0
  CPP11 always 1
  CPP14 always 2
  CPP17 always 3
  CPP20 always 4
  CPP23 always 5
  CPPLatest always 5
  = always 5
  CPP23 always 5
Line 47
  CLatest always 2
  CPPLatest always 5
Line 49
  ( always {!<=-1,!>=2}
Line 50
  = possible size=3
  str possible size=3
Line 51
  str possible size=3
  == always {!<=-1,!>=2}
  "c89" always "c89"
  || always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  "C89" always "C89"
Line 52
  = always 0
  C89 always 0
Line 53
  return always {!<=-1,!>=2}
  true always 1
Line 55
  str possible size=3
  == always {!<=-1,!>=2}
  "c99" always "c99"
  || always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  "C99" always "C99"
Line 56
  = always 1
  C99 always 1
Line 57
  return always {!<=-1,!>=2}
  true always 1
Line 59
  str possible size=3
  == always {!<=-1,!>=2}
  "c11" always "c11"
  || always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  "C11" always "C11"
Line 60
  = always 2
  C11 always 2
Line 61
  return always {!<=-1,!>=2}
  true always 1
Line 63
  return always {!<=-1,!>=2}
  false always 0
Line 67
  C89 always 0
Line 68
  "c89" always "c89"
Line 69
  C99 always 1
Line 70
  "c99" always "c99"
Line 71
  C11 always 2
Line 72
  "c11" always "c11"
Line 74
  "" always ""
Line 77
  std possible size=3
  == always {!<=-1,!>=2}
  "c89" always "c89"
Line 78
  :: always 0
  C89 always 0
Line 80
  std possible size=3
  == always {!<=-1,!>=2}
  "c99" always "c99"
Line 81
  :: always 1
  C99 always 1
Line 83
  == always {!<=-1,!>=2}
  "c11" always "c11"
Line 84
  :: always 2
  C11 always 2
Line 86
  :: always 2
  CLatest always 2
Line 88
  ( always {!<=-1,!>=2}
Line 92
  return always {!<=-1,!>=2}
  ! {!<=-1,!>=2,0}
  stdValue possible size=0
  ( {!<=-1,!>=2,1}
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
Line 99
  CPP03 always 0
Line 100
  "c++03" always "c++03"
Line 101
  CPP11 always 1
Line 102
  "c++11" always "c++11"
Line 103
  CPP14 always 2
Line 104
  "c++14" always "c++14"
Line 105
  CPP17 always 3
Line 106
  "c++17" always "c++17"
Line 107
  CPP20 always 4
Line 108
  "c++20" always "c++20"
Line 109
  CPP23 always 5
Line 110
  "c++23" always "c++23"
Line 112
  "" always ""
Line 115
  std possible size=5
  == always {!<=-1,!>=2}
  "c++03" always "c++03"
Line 116
  :: always 0
  CPP03 always 0
Line 118
  std possible size=5
  == always {!<=-1,!>=2}
  "c++11" always "c++11"
Line 119
  :: always 1
  CPP11 always 1
Line 121
  std possible size=5
  == always {!<=-1,!>=2}
  "c++14" always "c++14"
Line 122
  :: always 2
  CPP14 always 2
Line 124
  std possible size=5
  == always {!<=-1,!>=2}
  "c++17" always "c++17"
Line 125
  :: always 3
  CPP17 always 3
Line 127
  std possible size=5
  == always {!<=-1,!>=2}
  "c++20" always "c++20"
Line 128
  :: always 4
  CPP20 always 4
Line 130
  == always {!<=-1,!>=2}
  "c++23" always "c++23"
Line 131
  :: always 5
  CPP23 always 5
Line 133
  :: always 5
  CPPLatest always 5
Line 58
  OK always 0
  FILE_NOT_FOUND always 1
  BAD_XML always 2
  UNKNOWN_ELEMENT always 3
  MISSING_ATTRIBUTE always 4
  BAD_ATTRIBUTE_VALUE always 5
  UNSUPPORTED_FORMAT always 6
  DUPLICATE_PLATFORM_TYPE always 7
  PLATFORM_TYPE_REDEFINED always 8
Line 62
  :: always 0
  OK always 0
Line 63
  ( possible lifetime[SubObject]=(e)
Line 65
  ( possible lifetime[SubObject]=(e)
  && always {!<=-1,!>=2}
Line 74
  ( always {!<=-1,!>=2}
  , always !<=-1
  len always !<=-1
Line 79
  none always 0
  malloc always 1
  calloc always 2
  strdup always 3
Line 84
  initData always {!<=-1,!>=2}
Line 118
  ? possible 0
  af always !0
  : always 0
  0 always 0
Line 124
  ? possible 0
  af always !0
  : always 0
  0 always 0
Line 138
  , always 1
  = always 1
  1 always 1
Line 141
  = possible 1
  reallocArg possible 1
Line 145
  , always {!<=-1,!>=2}
  noreturn always {!<=-1,!>=2}
Line 146
  = possible {1,0}
  noreturn always {!<=-1,!>=2}
  ? possible {1,0}
  :: always 1
  True always 1
  : always 0
  :: always 0
  False always 0
Line 149
  ( always {!<=-1,!>=2}
Line 152
  ( always {!<=-1,!>=2}
Line 153
  return always {!<=-1,!>=2}
  > always {!<=-1,!>=2}
  0 always 0
  && always {!<=-1,!>=2}
  id {>=1,!<=0}
  & possible {0,1}
  1 always 1
  == {1,0,!<=-1,!>=2}
  0 always 0
Line 155
  ( always {!<=-1,!>=2}
Line 156
  return always {!<=-1,!>=2}
  > always {!<=-1,!>=2}
  0 always 0
  && always {!<=-1,!>=2}
  . {>=1,!<=0}
  & possible {0,1}
  1 always 1
  == {1,0,!<=-1,!>=2}
  0 always 0
Line 160
  ( always {!<=-1,!>=2}
Line 161
  return always {!<=-1,!>=2}
  > always {!<=-1,!>=2}
  0 always 0
  && always {!<=-1,!>=2}
  id {>=1,!<=0}
  & possible {0,1}
  1 always 1
  == {0,1,!<=-1,!>=2}
  1 always 1
Line 163
  ( always {!<=-1,!>=2}
Line 164
  return always {!<=-1,!>=2}
  > always {!<=-1,!>=2}
  0 always 0
  && always {!<=-1,!>=2}
  . {>=1,!<=0}
  & possible {0,1}
  1 always 1
  == {0,1,!<=-1,!>=2}
  1 always 1
Line 167
  ( always {!<=-1,!>=2}
Line 169
  ( always {!<=-1,!>=2}
Line 170
  ( always {!<=-1,!>=2}
Line 190
  ( always {!<=-1,!>=2}
Line 191
  ( always {!<=-1,!>=2}
Line 193
  NONE always 0
  DEFAULT always 1
  ERROR_CODE always 2
Line 201
  ( always {!<=-1,!>=2}
Line 202
  ( always {!<=-1,!>=2}
Line 204
  ( always {!<=-1,!>=2}
Line 209
  -1 always -1
Line 210
  -1 always -1
Line 211
  arrayLike_indexOp always {!<=-1,!>=2}
  false always 0
Line 212
  stdStringLike always {!<=-1,!>=2}
  false always 0
Line 213
  stdAssociativeLike always {!<=-1,!>=2}
  false always 0
Line 214
  opLessAllowed always {!<=-1,!>=2}
  true always 1
Line 215
  hasInitializerListConstructor always {!<=-1,!>=2}
  false always 0
Line 216
  unstableErase always {!<=-1,!>=2}
  false always 0
Line 217
  unstableInsert always {!<=-1,!>=2}
  false always 0
Line 218
  view always {!<=-1,!>=2}
  false always 0
Line 222
  RESIZE always 0
Line 223
  CLEAR always 1
Line 224
  PUSH always 2
Line 225
  POP always 3
Line 226
  FIND always 4
Line 227
  INSERT always 5
Line 228
  ERASE always 6
Line 229
  CHANGE_CONTENT always 7
Line 230
  CHANGE always 8
Line 231
  CHANGE_INTERNAL always 9
Line 232
  NO_ACTION always 10
Line 235
  AT_INDEX always 0
Line 236
  ITEM always 1
Line 237
  BUFFER always 2
Line 238
  BUFFER_NT always 3
Line 239
  START_ITERATOR always 4
Line 240
  END_ITERATOR always 5
Line 241
  ITERATOR always 6
Line 242
  SIZE always 7
Line 243
  EMPTY always 8
Line 244
  NO_YIELD always 9
Line 259
  arrayLike_indexOp always {!<=-1,!>=2}
Line 260
  stdStringLike always {!<=-1,!>=2}
Line 261
  stdAssociativeLike always {!<=-1,!>=2}
Line 262
  opLessAllowed always {!<=-1,!>=2}
Line 263
  hasInitializerListConstructor always {!<=-1,!>=2}
Line 264
  unstableErase always {!<=-1,!>=2}
Line 265
  unstableInsert always {!<=-1,!>=2}
Line 266
  view always {!<=-1,!>=2}
Line 269
  :: possible {symbolic=(functions.end()),end=0}
  i possible {symbolic=(functions.end()),end=0}
  = possible lifetime[Iterator]=(functions)
  ( possible lifetime[Iterator]=(functions)
Line 270
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(functions),end=0}
Line 271
  i always {!symbolic=(functions.end()),!end=0}
Line 272
  :: always 10
  NO_ACTION always 10
Line 276
  :: possible {symbolic=(functions.end()),end=0}
  i possible {symbolic=(functions.end()),end=0}
  = possible lifetime[Iterator]=(functions)
  ( possible lifetime[Iterator]=(functions)
Line 277
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(functions),end=0}
Line 278
  i always {!symbolic=(functions.end()),!end=0}
Line 279
  :: always 9
  NO_YIELD always 9
Line 286
  , always 0
  iterator always {!<=-1,!>=2}
  = always 0
  false always 0
Line 287
  , always 0
  = always 0
  nullptr always 0
Line 292
  notbool always {!<=-1,!>=2}
  false always 0
Line 293
  notnull always {!<=-1,!>=2}
  false always 0
Line 294
  -1 always -1
Line 295
  formatstr always {!<=-1,!>=2}
  false always 0
Line 296
  strz always {!<=-1,!>=2}
  false always 0
Line 297
  optional always {!<=-1,!>=2}
  false always 0
Line 298
  variadic always {!<=-1,!>=2}
  false always 0
Line 302
  notbool always {!<=-1,!>=2}
Line 303
  notnull always {!<=-1,!>=2}
Line 305
  formatstr always {!<=-1,!>=2}
Line 306
  strz always {!<=-1,!>=2}
Line 307
  optional always {!<=-1,!>=2}
Line 308
  variadic always {!<=-1,!>=2}
Line 313
  0 always 0
  it always {!<=-1,!>=2}
  false always 0
  first always {!<=-1,!>=2}
  false always 0
  last always {!<=-1,!>=2}
  false always 0
Line 316
  it always {!<=-1,!>=2}
Line 317
  first always {!<=-1,!>=2}
Line 318
  last always {!<=-1,!>=2}
Line 324
  NONE always 0
  STRLEN always 1
  ARGVALUE always 2
  SIZEOF always 3
  MUL always 4
  VALUE always 5
Line 325
  ( possible lifetime[SubObject]=(t)
  0 always 0
  0 always 0
Line 334
  DIR_IN always 0
Line 335
  DIR_OUT always 1
Line 336
  DIR_INOUT always 2
Line 337
  DIR_UNKNOWN always 3
Line 344
  use always {!<=-1,!>=2}
Line 345
  leakignore always {!<=-1,!>=2}
Line 346
  isconst always {!<=-1,!>=2}
Line 347
  ispure always {!<=-1,!>=2}
Line 349
  ignore always {!<=-1,!>=2}
Line 350
  formatstr always {!<=-1,!>=2}
Line 351
  formatstr_scan always {!<=-1,!>=2}
Line 352
  formatstr_secure always {!<=-1,!>=2}
Line 356
  use always {!<=-1,!>=2}
  false always 0
Line 357
  leakignore always {!<=-1,!>=2}
  false always 0
Line 358
  isconst always {!<=-1,!>=2}
  false always 0
Line 359
  ispure always {!<=-1,!>=2}
  false always 0
Line 360
  :: always 0
  NONE always 0
Line 361
  ignore always {!<=-1,!>=2}
  false always 0
Line 362
  formatstr always {!<=-1,!>=2}
  false always 0
Line 363
  formatstr_scan always {!<=-1,!>=2}
  false always 0
Line 364
  formatstr_secure always {!<=-1,!>=2}
  false always 0
Line 365
  :: always 10
  NO_ACTION always 10
Line 366
  :: always 9
  NO_YIELD always 9
Line 372
  ( always {!<=-1,!>=2}
Line 373
  ( always {!<=-1,!>=2}
Line 374
  ( always {!<=-1,!>=2}
  , always {!<=-1,!>=2}
  pure always {!<=-1,!>=2}
Line 375
  ( always {!<=-1,!>=2}
Line 377
  ( always {!<=-1,!>=2}
Line 379
  return always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  arg always !0
  . always {!<=-1,!>=2}
  notbool always {!<=-1,!>=2}
Line 382
  ( always {!<=-1,!>=2}
Line 383
  ( always {!<=-1,!>=2}
  , always 0
  = always 0
  0 always 0
  , always 0
  = always 0
  nullptr always 0
Line 385
  ( always {!<=-1,!>=2}
Line 387
  return always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  arg always !0
  . always {!<=-1,!>=2}
  formatstr always {!<=-1,!>=2}
Line 390
  ( always {!<=-1,!>=2}
Line 392
  return always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  arg always !0
  . always {!<=-1,!>=2}
  strz always {!<=-1,!>=2}
Line 395
  ( always {!<=-1,!>=2}
Line 396
  ( always {!<=-1,!>=2}
Line 400
  arg always !0
Line 404
  le always 0
  lt always 1
  eq always 2
  ge always 3
  gt always 4
  range always 5
Line 407
  ( always {!<=-1,!>=2}
Line 408
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 414
  && always {!<=-1,!>=2}
  arg always !0
  . always {!<=-1,!>=2}
  it always {!<=-1,!>=2}
  & {lifetime[Address]=(arg->iteratorInfo),!0}
  arg always !0
  nullptr always 0
Line 417
  ( always {!<=-1,!>=2}
Line 421
  ? possible 0
  & {lifetime[Address]=(arg->minsizes),!0}
  arg always !0
  nullptr always 0
Line 426
  ( always {!<=-1,!>=2}
Line 428
  ( always {!<=-1,!>=2}
Line 434
  ( always {!<=-1,!>=2}
Line 436
  ( always {!<=-1,!>=2}
Line 438
  ( always {!<=-1,!>=2}
Line 445
  ( always {!<=-1,!>=2}
Line 447
  ( always {!<=-1,!>=2}
Line 448
  return always {!<=-1,!>=2}
  ( possible lifetime[Iterator]=(mExporters)
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(mExporters),end=0}
Line 451
  ( always {!<=-1,!>=2}
Line 452
  = possible lifetime[Iterator]=(mExporters)
  ( possible lifetime[Iterator]=(mExporters)
Line 453
  return always {!<=-1,!>=2}
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(mExporters),end=0}
  && always {!<=-1,!>=2}
  it always {!symbolic=(mExporters.end()),!end=0}
Line 456
  ( always {!<=-1,!>=2}
Line 457
  = possible lifetime[Iterator]=(mExporters)
  ( possible lifetime[Iterator]=(mExporters)
Line 458
  return always {!<=-1,!>=2}
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(mExporters),end=0}
  && always {!<=-1,!>=2}
  it always {!symbolic=(mExporters.end()),!end=0}
Line 461
  ( always {!<=-1,!>=2}
Line 466
  ( always {!<=-1,!>=2}
Line 467
  return always {!<=-1,!>=2}
  ( possible lifetime[Iterator]=(mReflection)
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(mReflection),end=0}
Line 471
  :: possible {symbolic=(mReflection.end()),end=0}
  it possible {symbolic=(mReflection.end()),end=0}
  = possible lifetime[Iterator]=(mReflection)
  ( possible lifetime[Iterator]=(mReflection)
Line 472
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(mReflection),end=0}
Line 473
  it always {!symbolic=(mReflection.end()),!end=0}
Line 474
  -1 always -1
Line 480
  = always ""
  "" always ""
Line 481
  unique always {!<=-1,!>=2}
  unique always {!<=-1,!>=2}
  = always 0
  false always 0
Line 485
  ( always {!<=-1,!>=2}
Line 489
  size always !<=-1
Line 491
  NO always 0
  BOOL always 1
  CHAR always 2
  SHORT always 3
  INT always 4
  LONG always 5
  LONGLONG always 6
Line 494
  = possible lifetime[Iterator]=(mPodTypes)
  ( possible lifetime[Iterator]=(mPodTypes)
  name possible {symbolic=(mTypeStartToken->str())@2,size=6@38,size=11@38,size=3@2}
Line 495
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(mPodTypes),end=0}
  & {lifetime[Address]=(it->second),!0}
  it always {!symbolic=(mPodTypes.end()),!end=0}
  nullptr always 0
Line 500
  mSigned always {!<=-1,!>=2}
  false always 0
Line 501
  mUnsigned always {!<=-1,!>=2}
  false always 0
Line 502
  mLong always {!<=-1,!>=2}
  false always 0
Line 503
  mPointer always {!<=-1,!>=2}
  false always 0
Line 504
  mPtrPtr always {!<=-1,!>=2}
  false always 0
Line 505
  mConstPtr always {!<=-1,!>=2}
  false always 0
Line 506
  ( always {!<=-1,!>=2}
Line 507
  return always {!<=-1,!>=2}
  mSigned always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  . always {!<=-1,!>=2}
  mSigned always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 508
  mUnsigned always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  . always {!<=-1,!>=2}
  mUnsigned always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 509
  mLong always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  . always {!<=-1,!>=2}
  mLong always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 510
  mPointer always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  . always {!<=-1,!>=2}
  mPointer always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 511
  mPtrPtr always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  . always {!<=-1,!>=2}
  mPtrPtr always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 512
  mConstPtr always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  . always {!<=-1,!>=2}
  mConstPtr always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 513
  == always {!<=-1,!>=2}
Line 515
  ( always {!<=-1,!>=2}
Line 516
  return always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  this always !0
  == always {!<=-1,!>=2}
Line 519
  mSigned always {!<=-1,!>=2}
Line 520
  mUnsigned always {!<=-1,!>=2}
Line 521
  mLong always {!<=-1,!>=2}
Line 522
  mPointer always {!<=-1,!>=2}
Line 523
  mPtrPtr always {!<=-1,!>=2}
Line 524
  mConstPtr always {!<=-1,!>=2}
Line 529
  = possible lifetime[Iterator]=(mPlatformTypes)
  ( possible lifetime[Iterator]=(mPlatformTypes)
Line 530
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(mPlatformTypes),end=0}
  & {lifetime[Address]=(it->second),!0}
  it always {!symbolic=(mPlatformTypes.end()),!end=0}
  nullptr always 0
Line 536
  :: possible {symbolic=(mPlatforms.end()),end=0}
  it possible {symbolic=(mPlatforms.end()),end=0}
  = possible lifetime[Iterator]=(mPlatforms)
  ( possible lifetime[Iterator]=(mPlatforms)
Line 537
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(mPlatforms),end=0}
Line 538
  it always {!symbolic=(mPlatforms.end()),!end=0}
Line 540
  type always !0
Line 543
  = possible lifetime[Iterator]=(mPlatformTypes)
  ( possible lifetime[Iterator]=(mPlatformTypes)
Line 544
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(mPlatformTypes),end=0}
  & {lifetime[Address]=(it2->second),!0}
  it2 always {!symbolic=(mPlatformTypes.end()),!end=0}
  nullptr always 0
Line 552
  ( always {!<=-1,!>=2}
  , always ""
  = always ""
  "" always ""
Line 555
  def always 0
  check always 1
  suppress always 2
Line 570
  ( always {!<=-1,!>=2}
Line 571
  return always {!<=-1,!>=2}
  ( possible lifetime[Iterator]=(mPrefixes)
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(mPrefixes),end=0}
Line 573
  ( always {!<=-1,!>=2}
Line 574
  return always {!<=-1,!>=2}
  ( possible lifetime[Iterator]=(mSuffixes)
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(mSuffixes),end=0}
Line 583
  0 always 0
Line 606
  ( always {!<=-1,!>=2}
Line 607
  return always {!<=-1,!>=2}
  ( possible lifetime[Iterator]=(mBlocks)
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(mBlocks),end=0}
Line 616
  False always 0
  True always 1
  Maybe always 2
Line 646
  = possible lifetime[Iterator]=(data)
  ( possible lifetime[Iterator]=(data)
Line 647
  == always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(data),end=0}
  nullptr always 0
  & {lifetime[Address]=(it->second),!0}
  it always {!symbolic=(data.end()),!end=0}
Line 655
  = always 0
  nullptr always 0
Line 66
  ( always {!<=-1,!>=2}
Line 67
  return always {!<=-1,!>=2}
  < always {!<=-1,!>=2}
Line 73
  ( always {!<=-1,!>=2}
Line 74
  return always {!<=-1,!>=2}
  ( always !<=-1
  == always {!<=-1,!>=2}
  1 always 1
Line 80
  result always {!<=-1,!>=2}
Line 81
  result always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  > always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  x {!>=symbolic=(y+1),<=symbolic=(y)}
  < always {!<=-1,!>=2}
  y {!<=symbolic=(x-1),>=symbolic=(x)}
Line 88
  Upper always 0
  Lower always 1
  Point always 2
Line 90
  = always 0
  0 always 0
Line 91
  :: always 12
  INT always 12
Line 94
  nullptr always 0
Line 95
  0.0 always 0
Line 98
  nullptr always 0
Line 99
  0U always 0
Line 100
  safe always {!<=-1,!>=2}
  false always 0
Line 101
  conditional always {!<=-1,!>=2}
  false always 0
Line 102
  macro always {!<=-1,!>=2}
  false always 0
Line 103
  defaultArg always {!<=-1,!>=2}
  false always 0
Line 104
  0 always 0
Line 105
  0 always 0
Line 108
  nullptr always 0
Line 117
  ( always {!<=-1,!>=2}
Line 118
  != always {!<=-1,!>=2}
Line 119
  return always {!<=-1,!>=2}
  false always 0
Line 120
  valueType always symbolic=(rhs.valueType)
Line 121
  :: always 0
  INT always 0
Line 122
  :: always 5
  CONTAINER_SIZE always 5
Line 123
  :: always 7
  BUFFER_SIZE always 7
Line 124
  :: always 8
  ITERATOR_START always 8
Line 125
  :: always 9
  ITERATOR_END always 9
Line 126
  != always {!<=-1,!>=2}
Line 127
  return always {!<=-1,!>=2}
  false always 0
Line 129
  :: always 1
  TOK always 1
Line 130
  != always {!<=-1,!>=2}
Line 131
  return always {!<=-1,!>=2}
  false always 0
Line 133
  :: always 2
  FLOAT always 2
Line 135
  > always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  floatValue possible <=symbolic=(rhs.floatValue)
  < always {!<=-1,!>=2}
  . possible >=symbolic=(floatValue)
Line 136
  return always {!<=-1,!>=2}
  false always 0
Line 138
  :: always 3
  MOVED always 3
Line 139
  != always {!<=-1,!>=2}
Line 140
  return always {!<=-1,!>=2}
  false always 0
Line 142
  :: always 4
  UNINIT always 4
Line 144
  :: always 6
  LIFETIME always 6
Line 145
  != always {!<=-1,!>=2}
Line 146
  return always {!<=-1,!>=2}
  false always 0
Line 148
  :: always 10
  SYMBOLIC always 10
Line 149
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 150
  return always {!<=-1,!>=2}
  false always 0
Line 151
  != always {!<=-1,!>=2}
Line 152
  return always {!<=-1,!>=2}
  false always 0
Line 155
  return always {!<=-1,!>=2}
  true always 1
Line 161
  :: always 0
  INT always 0
Line 162
  :: always 10
  SYMBOLIC always 10
Line 163
  :: always 7
  BUFFER_SIZE always 7
Line 164
  :: always 5
  CONTAINER_SIZE always 5
Line 165
  :: always 8
  ITERATOR_START always 8
Line 166
  :: always 9
  ITERATOR_END always 9
Line 170
  :: always 2
  FLOAT always 2
Line 174
  :: always 4
  UNINIT always 4
Line 175
  :: always 1
  TOK always 1
Line 176
  :: always 6
  LIFETIME always 6
Line 177
  :: always 3
  MOVED always 3
Line 185
  result always {!<=-1,!>=2}
Line 186
  result always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
Line 190
  result always {!<=-1,!>=2}
Line 192
  ( possible {lifetime[Object]=(x),lifetime[Object]=(result),lifetime[Object]=(compare)}
  ( possible lifetime[Object]=(result)
  result always {!<=-1,!>=2}
  ( possible lifetime[Object]=(compare)
Line 197
  ( always {!<=-1,!>=2}
Line 198
  ! always {!<=-1,!>=2}
  this always !0
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
Line 199
  this always !0
  == always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  this always !0
Line 200
  result always {!<=-1,!>=2}
  result always {!<=-1,!>=2}
  = always 0
  false always 0
Line 202
  this always !0
Line 203
  ( possible {lifetime[Object]=(result),lifetime[Object]=(rhs),lifetime[Object]=(compare)}
  ( possible lifetime[Object]=(result)
  result always 0
  ( possible lifetime[Object]=(rhs)
  ( possible lifetime[Object]=(compare)
Line 204
  return always {!<=-1,!>=2}
  result {!<=-1,!>=2,0}
Line 207
  ( always {!<=-1,!>=2}
Line 208
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 209
  return always {!<=-1,!>=2}
  false always 0
Line 211
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 212
  == always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 213
  == always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 214
  conditional always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  . always {!<=-1,!>=2}
  conditional always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 215
  defaultArg always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  . always {!<=-1,!>=2}
  defaultArg always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 216
  == always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 217
  == always {!<=-1,!>=2}
Line 220
  ( always {!<=-1,!>=2}
Line 221
  return always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  this always !0
  == always {!<=-1,!>=2}
Line 225
  ( always {!<=-1,!>=2}
Line 226
  result always {!<=-1,!>=2}
  result always {!<=-1,!>=2}
  = always 0
  false always 0
Line 227
  this always !0
  ( possible {lifetime[Object]=(x),lifetime[Object]=(result)}
  ( possible lifetime[Object]=(result)
  result always 0
Line 228
  return always {!<=-1,!>=2}
  result {!<=-1,!>=2,0}
Line 232
  bound possible 0
  == {!<=-1,!>=2,0}
  :: always 1
  Lower always 1
Line 233
  this always !0
Line 234
  bound always !1
  == always {!<=-1,!>=2}
  :: always 0
  Upper always 0
Line 235
  this always !0
Line 239
  bound possible 0
  == {!<=-1,!>=2,0}
  :: always 1
  Lower always 1
Line 240
  = always 0
  :: always 0
  Upper always 0
Line 241
  bound always !1
  == always {!<=-1,!>=2}
  :: always 0
  Upper always 0
Line 242
  = always 1
  :: always 1
  Lower always 1
Line 255
  INT always 0
Line 256
  TOK always 1
Line 257
  FLOAT always 2
Line 258
  MOVED always 3
Line 259
  UNINIT always 4
Line 260
  CONTAINER_SIZE always 5
Line 261
  LIFETIME always 6
Line 262
  BUFFER_SIZE always 7
Line 263
  ITERATOR_START always 8
Line 264
  ITERATOR_END always 9
Line 265
  SYMBOLIC always 10
Line 267
  ( always {!<=-1,!>=2}
Line 268
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 0
  INT always 0
Line 270
  ( always {!<=-1,!>=2}
Line 271
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 1
  TOK always 1
Line 273
  ( always {!<=-1,!>=2}
Line 274
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 2
  FLOAT always 2
Line 276
  ( always {!<=-1,!>=2}
Line 277
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 3
  MOVED always 3
Line 279
  ( always {!<=-1,!>=2}
Line 280
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 4
  UNINIT always 4
Line 282
  ( always {!<=-1,!>=2}
Line 283
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 5
  CONTAINER_SIZE always 5
Line 285
  ( always {!<=-1,!>=2}
Line 286
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 6
  LIFETIME always 6
Line 288
  ( always {!<=-1,!>=2}
Line 289
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 7
  BUFFER_SIZE always 7
Line 291
  ( always {!<=-1,!>=2}
Line 292
  return always {!<=-1,!>=2}
  valueType possible 9
  == {!<=-1,!>=2,0}
  :: always 8
  ITERATOR_START always 8
  || always {!<=-1,!>=2}
  valueType always !8
  == always {!<=-1,!>=2}
  :: always 9
  ITERATOR_END always 9
Line 294
  ( always {!<=-1,!>=2}
Line 295
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 8
  ITERATOR_START always 8
Line 297
  ( always {!<=-1,!>=2}
Line 298
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 9
  ITERATOR_END always 9
Line 300
  ( always {!<=-1,!>=2}
Line 301
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 10
  SYMBOLIC always 10
Line 304
  ( always {!<=-1,!>=2}
Line 305
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 6
  LIFETIME always 6
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
Line 308
  ( always {!<=-1,!>=2}
Line 309
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 6
  LIFETIME always 6
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 1
  Argument always 1
Line 312
  ( always {!<=-1,!>=2}
Line 313
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 6
  LIFETIME always 6
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 2
  SubFunction always 2
Line 316
  ( always {!<=-1,!>=2}
Line 317
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 333
  NonMovedVariable always 0
  MovedVariable always 1
  ForwardedVariable always 2
Line 347
  safe always {!<=-1,!>=2}
Line 350
  conditional always {!<=-1,!>=2}
Line 353
  macro always {!<=-1,!>=2}
Line 356
  defaultArg always {!<=-1,!>=2}
Line 373
  Object always 0
Line 375
  SubObject always 1
Line 377
  Lambda always 2
Line 379
  Iterator always 3
Line 381
  Address always 4
Line 384
  Local always 0
  Argument always 1
  SubFunction always 2
  ThisPointer always 3
  ThisValue always 4
Line 394
  Possible always 0
Line 396
  Known always 1
Line 398
  Inconclusive always 2
Line 400
  Impossible always 3
Line 404
  = always 1
  :: always 1
  Known always 1
Line 407
  ( always {!<=-1,!>=2}
Line 408
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 1
  Known always 1
Line 415
  ( always {!<=-1,!>=2}
Line 416
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
Line 419
  ( always {!<=-1,!>=2}
Line 420
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 3
  Impossible always 3
Line 424
  = always 3
  :: always 3
  Impossible always 3
Line 427
  inconclusive always {!<=-1,!>=2}
  = always 1
  true always 1
Line 428
  inconclusive always {!<=-1,!>=2}
Line 429
  = always 2
  :: always 2
  Inconclusive always 2
Line 432
  ( always {!<=-1,!>=2}
Line 433
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 2
  Inconclusive always 2
Line 437
  ( always {!<=-1,!>=2}
Line 441
  ( always {!<=-1,!>=2}
Line 442
  return always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  defaultArg always {!<=-1,!>=2}
Line 445
  ( always {!<=-1,!>=2}
Line 456
  ( always !<=-1
Line 460
  ( always {!<=-1,!>=2}
Line 462
  possible always {!<=-1,!>=2}
  = always 1
  true always 1
Line 467
  ( always {!<=-1,!>=2}
  , always 0
  = always 0
  nullptr always 0
  , always 20
  = always 20
  20 always 20
Line 471
  addressOf always {!<=-1,!>=2}
Line 473
  inconclusive always {!<=-1,!>=2}
Line 475
  nullptr always 0
  addressOf always {!<=-1,!>=2}
  false always 0
  inconclusive always {!<=-1,!>=2}
  false always 0
Line 478
  addressOf always {!<=-1,!>=2}
  false always 0
  ( possible lifetime[Object]=(errorPath)
  inconclusive always {!<=-1,!>=2}
  false always 0
Line 481
  addressOf always {!<=-1,!>=2}
Line 482
  addressOf always {!<=-1,!>=2}
  addressOf always {!<=-1,!>=2}
  ( possible lifetime[Object]=(errorPath)
  inconclusive always {!<=-1,!>=2}
  false always 0
Line 485
  b always {!<=-1,!>=2}
Line 487
  . always {!<=-1,!>=2}
  addressOf always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  b always {!<=-1,!>=2}
Line 491
  b always {!<=-1,!>=2}
Line 493
  . always {!<=-1,!>=2}
  inconclusive always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  b always {!<=-1,!>=2}
Line 511
  escape always {!<=-1,!>=2}
  = always 0
  false always 0
Line 514
  ( always {!<=-1,!>=2}
Line 516
  , always 0
  = always 0
  nullptr always 0
Line 520
  ( always {!<=-1,!>=2}
Line 526
  , always 0
  inconclusive always {!<=-1,!>=2}
  = always 0
  false always 0
Line 529
  inconclusive always {!<=-1,!>=2}
  = always 0
  false always 0
Line 530
  = always 0
  0 always 0
Line 532
  , always 0
  = always 0
  nullptr always 0
  , always 1
  smallest always {!<=-1,!>=2}
  = always 1
  true always 1
Line 62
  ( always !<=-1
Line 74
  mFlags always !<=-1
Line 77
  fIsClass always 1
  = always 1
  1 always 1
  << always 1
  0 always 0
  , always 2
Line 78
  fIsFunction always 2
  = always 2
  1 always 1
  << always 2
  1 always 1
  , always 4
Line 79
  fIsVariable always 4
  = always 4
  1 always 1
  << always 4
  2 always 2
  , always 8
Line 80
  fIsAlias always 8
  = always 8
  1 always 1
  << always 8
  3 always 3
  , always 16
Line 81
  fIsSpecialization always 16
  = always 16
  1 always 1
  << always 16
  4 always 4
  , always 32
Line 82
  fIsPartialSpecialization always 32
  = always 32
  1 always 1
  << always 32
  5 always 5
  , always 64
Line 83
  fIsForwardDeclaration always 64
  = always 64
  1 always 1
  << always 64
  6 always 6
  , always 128
Line 84
  fIsVariadic always 128
  = always 128
  1 always 1
  << always 128
  7 always 7
  , always 256
Line 85
  fIsFriend always 256
  = always 256
  1 always 1
  << always 256
  8 always 8
  , always 7
Line 86
  fFamilyMask always 7
  = always 7
  fIsClass always 1
  | always 3
  fIsFunction always 2
  | always 7
  fIsVariable always 4
Line 89
  state always {!<=-1,!>=2}
Line 90
  fIsClass always 1
  state always {!<=-1,!>=2}
Line 92
  state always {!<=-1,!>=2}
Line 93
  fIsFunction always 2
  state always {!<=-1,!>=2}
Line 95
  state always {!<=-1,!>=2}
Line 96
  fIsVariable always 4
  state always {!<=-1,!>=2}
Line 98
  state always {!<=-1,!>=2}
Line 99
  fIsAlias always 8
  state always {!<=-1,!>=2}
Line 101
  state always {!<=-1,!>=2}
Line 102
  fIsSpecialization always 16
  state always {!<=-1,!>=2}
Line 104
  state always {!<=-1,!>=2}
Line 105
  fIsPartialSpecialization always 32
  state always {!<=-1,!>=2}
Line 107
  state always {!<=-1,!>=2}
Line 108
  fIsForwardDeclaration always 64
  state always {!<=-1,!>=2}
Line 110
  state always {!<=-1,!>=2}
Line 111
  fIsVariadic always 128
  state always {!<=-1,!>=2}
Line 113
  state always {!<=-1,!>=2}
Line 114
  fIsFriend always 256
  state always {!<=-1,!>=2}
Line 122
  ( always {!<=-1,!>=2}
  flag always !<=-1
Line 123
  return always {!<=-1,!>=2}
  mFlags always !<=-1
  & always !<=-1
  flag {!<=-1,256@16,128@17,64@18,32@19,16@20,8@21,4@22,2@23,1@24}
  != always {!<=-1,!>=2}
  0 always 0
Line 131
  flag always !<=-1
  state always {!<=-1,!>=2}
Line 132
  mFlags always !<=-1
  = always !<=-1
  state always {!<=-1,!>=2}
  ? always !<=-1
  mFlags always !<=-1
  | always !<=-1
  flag {!<=-1,256@25,128@26,64@27,32@28,16@29,8@30,4@31,2@32,1@33}
  : always !<=-1
  mFlags always !<=-1
  & always !<=-1
  ~ {!<=0,4294967039@25,4294967167@26,4294967231@27,4294967263@28,4294967279@29,4294967287@30,4294967291@31,4294967293@32,4294967294@33}
  flag {!<=-1,256@25,128@26,64@27,32@28,16@29,8@30,4@31,2@32,1@33}
Line 153
  ( always {!<=-1,!>=2}
Line 154
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 155
  == always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  mFlags always !<=-1
  == always {!<=-1,!>=2}
  . always !<=-1
  mFlags always !<=-1
Line 183
  ( always {!<=-1,!>=2}
Line 184
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsClass always 1
Line 186
  ( always {!<=-1,!>=2}
Line 187
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsFunction always 2
Line 189
  ( always {!<=-1,!>=2}
Line 190
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsVariable always 4
Line 192
  ( always {!<=-1,!>=2}
Line 193
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsAlias always 8
Line 195
  ( always {!<=-1,!>=2}
Line 196
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsSpecialization always 16
Line 198
  ( always {!<=-1,!>=2}
Line 199
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsPartialSpecialization always 32
Line 201
  ( always {!<=-1,!>=2}
Line 202
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsForwardDeclaration always 64
Line 204
  ( always {!<=-1,!>=2}
Line 205
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsVariadic always 128
Line 207
  ( always {!<=-1,!>=2}
Line 208
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsFriend always 256
Line 234
  ( always {!<=-1,!>=2}
Line 242
  ( always {!<=-1,!>=2}
Line 245
  return always {!<=-1,!>=2}
  mFlags always !<=-1
  & always !<=-1
  fFamilyMask always 7
  & always !<=-1
  . always !<=-1
  mFlags always !<=-1
  & always !<=-1
  fFamilyMask always 7
  != always {!<=-1,!>=2}
  0 always 0
Line 265
  ( always {!<=-1,!>=2}
  , always !<=-1
  numberOfArguments always !<=-1
  , always {!<=-1,!>=2}
  variadic always {!<=-1,!>=2}
Line 281
  ( always {!<=-1,!>=2}
Line 289
  ( always {!<=-1,!>=2}
Line 297
  ( always {!<=-1,!>=2}
Line 306
  codeWithTemplates always {!<=-1,!>=2}
Line 314
  ( always {!<=-1,!>=2}
  , always 1
  isTemplate always {!<=-1,!>=2}
  = always 1
  true always 1
Line 322
  ( always {!<=-1,!>=2}
  = always 0
  nullptr always 0
  , always 0
  = always 0
  nullptr always 0
  , always 1
  isTemplate always {!<=-1,!>=2}
  = always 1
  true always 1
Line 335
  ( always {!<=-1,!>=2}
Line 391
  ( always {!<=-1,!>=2}
Line 410
  ( always {!<=-1,!>=2}
Line 424
  , always {!<=-1,!>=2}
Line 425
  copy always {!<=-1,!>=2}
Line 451
  ( always {!<=-1,!>=2}
Line 456
  ( always {!<=-1,!>=2}
Line 486
  , always "    "
Line 487
  = always "    "
  "    " always "    "
Line 488
  = always ""
  "" always ""
Line 494
  mChanged always {!<=-1,!>=2}
Line 118
  LOW always 0
  HIGH always 1
Line 125
  UNKNOWN always 0
  CPP11INIT always 1
  NOINIT always 2
Line 128
  mBits always !<=-1
Line 131
  ( always {!<=-1,!>=2}
Line 134
  0 always 0
Line 135
  0 always 0
Line 136
  0 always 0
Line 137
  0 always 0
Line 138
  0 always 0
Line 139
  nullptr always 0
Line 140
  nullptr always 0
Line 141
  nullptr always 0
Line 142
  nullptr always 0
Line 143
  nullptr always 0
Line 144
  0 always 0
Line 145
  0 always 0
Line 146
  nullptr always 0
Line 147
  nullptr always 0
Line 148
  nullptr always 0
Line 149
  nullptr always 0
Line 150
  nullptr always 0
Line 151
  nullptr always 0
Line 153
  mBits always !<=-1
  0 always 0
Line 182
  eVariable always 0
  eType always 1
  eFunction always 2
  eKeyword always 3
  eName always 4
Line 183
  eNumber always 5
  eString always 6
  eChar always 7
  eBoolean always 8
  eLiteral always 9
  eEnumerator always 10
Line 184
  eArithmeticalOp always 11
  eComparisonOp always 12
  eAssignmentOp always 13
  eLogicalOp always 14
  eBitOp always 15
  eIncDecOp always 16
  eExtendedOp always 17
Line 185
  eBracket always 18
Line 186
  eLambda always 19
Line 187
  eEllipsis always 20
Line 188
  eOther always 21
Line 189
  eNone always 22
Line 192
  = always 0
  nullptr always 0
Line 198
  && always {!<=-1,!>=2}
Line 200
  = always 0
  0 always 0
Line 218
  = always 1
  1 always 1
Line 223
  = always 1
  1 always 1
Line 237
  ( always !0
  this always !0
  index possible {2@106,-2@158,3@180,-3@153,-1@154,1@170,4@149}
Line 246
  ( always !0
  this always !0
  index possible {1@102,2@172,-2@87,-1@89}
Line 275
  ( always {!<=-1,!>=2}
  ( always !0
  & {lifetime[Address]=(pattern),!0}
Line 276
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  tok possible {0@121,symbolic=(tok1)@222,symbolic=(arg?arg:argDef)@81,symbolic=(startTok)@87,symbolic=(tok->scope()->bodyStart)@25,symbolic=(const_cast<Token*>(tok->astParent()))@98,symbolic=(const_cast<Token*>(tok->astParent()->astParent()))@105,symbolic=(lambdaStartToken->astParent())@246,symbolic=(tok->link()->previous())@3,symbolic=(tok)@3}
  pattern possible {"std :: array"@16,")"@95,">"@103,"sizeof ("@121,"= {"@156,"."@190,"return {"@220,"("@253,"decltype ("@41,"std :: move ("@188}
  1 always 1
Line 279
  ( always {!<=-1,!>=2}
  , always !<=-1
  pattern_len always !<=-1
Line 324
  ( always {!<=-1,!>=2}
  , always 0
  = always 0
  0 always 0
Line 370
  = always !0
  this always !0
Line 371
  top possible {symbolic=(this),0}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  top {symbolic=(this),!0}
  ",|(" always ",|("
Line 372
  top always !0
Line 373
  top possible {symbolic=(this),0}
  ? possible 0
  top always !0
  : always 0
  nullptr always 0
Line 380
  = possible {10@171,4@172,0@173}
  t possible {10@171,4@172,0@173}
Line 382
  memoizedIsName always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  mTokType possible {10@171,4@172,0@173}
  == always {!<=-1,!>=2}
  eName always 4
  || always {!<=-1,!>=2}
  mTokType {!4,10@171,0@173}
  == always {!<=-1,!>=2}
  eType always 1
  || always {!<=-1,!>=2}
  mTokType {!4,!1,10@171,0@173}
  == always {!<=-1,!>=2}
  eVariable always 0
  || always {!<=-1,!>=2}
Line 383
  mTokType {!1,!0,10@171}
  == always {!<=-1,!>=2}
  eFunction always 2
  || always {!<=-1,!>=2}
  mTokType {!0,!2,10@171}
  == always {!<=-1,!>=2}
  eKeyword always 3
  || always {!<=-1,!>=2}
  mTokType {!2,!3,10@171}
  == always {!<=-1,!>=2}
  eBoolean always 8
  || always {!<=-1,!>=2}
Line 384
  mTokType {!3,!8,10@171}
  == always {!<=-1,!>=2}
  eEnumerator always 10
Line 385
  fIsName always 2097152
  memoizedIsName {symbolic=(mTokType==eName||mTokType==eType||mTokType==eVariable||mTokType==eFunction||mTokType==eKeyword||mTokType==eBoolean||mTokType==eEnumerator),!<=-1,!>=2,1@171}
Line 387
  memoizedIsLiteral always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  eNumber always 5
  || always {!<=-1,!>=2}
  mTokType always !5
  == always {!<=-1,!>=2}
  eString always 6
  || always {!<=-1,!>=2}
  mTokType always {!5,!6}
  == always {!<=-1,!>=2}
  eChar always 7
  || always {!<=-1,!>=2}
Line 388
  mTokType always {!6,!7}
  == always {!<=-1,!>=2}
  eBoolean always 8
  || always {!<=-1,!>=2}
  mTokType always {!7,!8}
  == always {!<=-1,!>=2}
  eLiteral always 9
  || always {!<=-1,!>=2}
  mTokType always {!8,!9}
  == always {!<=-1,!>=2}
  eEnumerator always 10
Line 389
  fIsLiteral always 4194304
  memoizedIsLiteral {symbolic=(mTokType==eNumber||mTokType==eString||mTokType==eChar||mTokType==eBoolean||mTokType==eLiteral||mTokType==eEnumerator),!<=-1,!>=2}
Line 391
  ( always {!<=-1,!>=2}
Line 392
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  eKeyword always 3
Line 394
  ( always {!<=-1,!>=2}
Line 395
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsName always 2097152
Line 397
  ( always {!<=-1,!>=2}
Line 398
  return always {!<=-1,!>=2}
  mFlags always !<=-1
  == always {!<=-1,!>=2}
  fIsName always 2097152
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  eName always 4
Line 400
  ( always {!<=-1,!>=2}
Line 401
  ( always {!<=-1,!>=2}
Line 402
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsLiteral always 4194304
Line 404
  ( always {!<=-1,!>=2}
Line 405
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  eNumber always 5
Line 407
  ( always {!<=-1,!>=2}
Line 408
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  eEnumerator always 10
Line 410
  ( always {!<=-1,!>=2}
Line 411
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
Line 412
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
Line 413
  == always {!<=-1,!>=2}
  eIncDecOp always 16
Line 415
  ( always {!<=-1,!>=2}
Line 416
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
Line 417
  == always {!<=-1,!>=2}
  eLogicalOp always 14
  || always {!<=-1,!>=2}
Line 418
  mTokType always !14
  == always {!<=-1,!>=2}
  eComparisonOp always 12
  || always {!<=-1,!>=2}
Line 419
  mTokType always {!14,!12}
  == always {!<=-1,!>=2}
  eBitOp always 15
Line 421
  ( always {!<=-1,!>=2}
Line 422
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
Line 423
  == always {!<=-1,!>=2}
  eExtendedOp always 17
Line 425
  ( always {!<=-1,!>=2}
Line 426
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  eArithmeticalOp always 11
Line 428
  ( always {!<=-1,!>=2}
Line 429
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  eComparisonOp always 12
Line 431
  ( always {!<=-1,!>=2}
Line 432
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  eAssignmentOp always 13
Line 434
  ( always {!<=-1,!>=2}
Line 435
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  eBoolean always 8
Line 437
  ( always {!<=-1,!>=2}
Line 438
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  eIncDecOp always 16
Line 440
  ( always {!<=-1,!>=2}
Line 441
  return always {!<=-1,!>=2}
  != always {!<=-1,!>=2}
  nullptr always 0
  && always {!<=-1,!>=2}
  != always {!<=-1,!>=2}
  nullptr always 0
Line 443
  ( always {!<=-1,!>=2}
Line 444
  return always {!<=-1,!>=2}
  s possible {"&"@255,"*","&"@1,"&"@30,"*"@31}
  == always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  != always {!<=-1,!>=2}
  nullptr always 0
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  nullptr always 0
Line 446
  ( always {!<=-1,!>=2}
Line 448
  ( always !<=-1
Line 449
  return always !<=-1
  mFlags always !<=-1
Line 451
  flags_ always !<=-1
Line 452
  mFlags always !<=-1
  = always !<=-1
  flags_ always !<=-1
Line 454
  ( always {!<=-1,!>=2}
Line 455
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsUnsigned always 1
Line 457
  sign always {!<=-1,!>=2}
Line 458
  fIsUnsigned always 1
  sign always {!<=-1,!>=2}
Line 460
  ( always {!<=-1,!>=2}
Line 461
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsSigned always 2
Line 463
  sign always {!<=-1,!>=2}
Line 464
  fIsSigned always 2
  sign always {!<=-1,!>=2}
Line 466
  ( always {!<=-1,!>=2}
Line 467
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsPointerCompare always 4
Line 469
  b always {!<=-1,!>=2}
Line 470
  fIsPointerCompare always 4
  b always {!<=-1,!>=2}
Line 472
  ( always {!<=-1,!>=2}
Line 473
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsLong always 8
Line 475
  size always {!<=-1,!>=2}
Line 476
  fIsLong always 8
  size always {!<=-1,!>=2}
Line 478
  ( always {!<=-1,!>=2}
Line 479
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsStandardType always 16
Line 481
  b always {!<=-1,!>=2}
Line 482
  fIsStandardType always 16
  b {!<=-1,!>=2,1@77,0@179}
Line 484
  ( always {!<=-1,!>=2}
Line 485
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsExpandedMacro always 32
Line 487
  m always {!<=-1,!>=2}
Line 488
  fIsExpandedMacro always 32
  m always {!<=-1,!>=2}
Line 490
  ( always {!<=-1,!>=2}
Line 491
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsCast always 64
Line 493
  c always {!<=-1,!>=2}
Line 494
  fIsCast always 64
  c always {!<=-1,!>=2}
Line 496
  ( always {!<=-1,!>=2}
Line 497
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsAttributeConstructor always 128
Line 499
  ac always {!<=-1,!>=2}
Line 500
  fIsAttributeConstructor always 128
  ac always {!<=-1,!>=2}
Line 502
  ( always {!<=-1,!>=2}
Line 503
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsAttributeDestructor always 256
Line 505
  value always {!<=-1,!>=2}
Line 506
  fIsAttributeDestructor always 256
  value always {!<=-1,!>=2}
Line 508
  ( always {!<=-1,!>=2}
Line 509
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsAttributeUnused always 512
Line 511
  unused always {!<=-1,!>=2}
Line 512
  fIsAttributeUnused always 512
  unused always {!<=-1,!>=2}
Line 514
  ( always {!<=-1,!>=2}
Line 515
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsAttributeUsed always 16384
Line 517
  unused always {!<=-1,!>=2}
Line 518
  fIsAttributeUsed always 16384
  unused always {!<=-1,!>=2}
Line 520
  ( always {!<=-1,!>=2}
Line 521
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsAttributePure always 1024
Line 523
  value always {!<=-1,!>=2}
Line 524
  fIsAttributePure always 1024
  value always {!<=-1,!>=2}
Line 526
  ( always {!<=-1,!>=2}
Line 527
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsAttributeConst always 2048
Line 529
  value always {!<=-1,!>=2}
Line 530
  fIsAttributeConst always 2048
  value always {!<=-1,!>=2}
Line 532
  ( always {!<=-1,!>=2}
Line 533
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsAttributeNoreturn always 4096
Line 535
  value always {!<=-1,!>=2}
Line 536
  fIsAttributeNoreturn always 4096
  value always {!<=-1,!>=2}
Line 538
  ( always {!<=-1,!>=2}
Line 539
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsAttributeNothrow always 8192
Line 541
  value always {!<=-1,!>=2}
Line 542
  fIsAttributeNothrow always 8192
  value always {!<=-1,!>=2}
Line 544
  ( always {!<=-1,!>=2}
Line 545
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsAttributePacked always 32768
Line 547
  value always {!<=-1,!>=2}
Line 548
  fIsAttributePacked always 32768
  value always {!<=-1,!>=2}
Line 550
  ( always {!<=-1,!>=2}
Line 551
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsAttributeNodiscard always 16777216
Line 553
  value always {!<=-1,!>=2}
Line 554
  fIsAttributeNodiscard always 16777216
  value always {!<=-1,!>=2}
Line 556
  ( always {!<=-1,!>=2}
Line 557
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsAttributeMaybeUnused always 65536
Line 559
  value always {!<=-1,!>=2}
Line 560
  fIsAttributeMaybeUnused always 65536
  value always {!<=-1,!>=2}
Line 565
  ( always {!<=-1,!>=2}
Line 566
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 568
  ( always {!<=-1,!>=2}
Line 569
  return always {!<=-1,!>=2}
  nullptr always 0
  != always {!<=-1,!>=2}
Line 571
  ( always {!<=-1,!>=2}
Line 572
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsControlFlowKeyword always 131072
Line 574
  ( always {!<=-1,!>=2}
Line 575
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsOperatorKeyword always 262144
Line 577
  value always {!<=-1,!>=2}
Line 578
  fIsOperatorKeyword always 262144
  value always {!<=-1,!>=2}
Line 580
  ( always {!<=-1,!>=2}
Line 581
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsComplex always 524288
Line 583
  value always {!<=-1,!>=2}
Line 584
  fIsComplex always 524288
  value always {!<=-1,!>=2}
Line 586
  ( always {!<=-1,!>=2}
Line 587
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsEnumType always 1048576
Line 589
  value always {!<=-1,!>=2}
Line 590
  fIsEnumType always 1048576
  value always {!<=-1,!>=2}
Line 592
  ( always {!<=-1,!>=2}
Line 593
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fAtAddress always 33554432
Line 595
  b always {!<=-1,!>=2}
Line 596
  fAtAddress always 33554432
  b always {!<=-1,!>=2}
Line 598
  ( always {!<=-1,!>=2}
Line 599
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIncompleteVar always 67108864
Line 601
  b always {!<=-1,!>=2}
Line 602
  fIncompleteVar always 67108864
  b {!<=-1,!>=2,1@61}
Line 605
  ( always {!<=-1,!>=2}
Line 606
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsIncompleteConstant always 68719476736
Line 608
  b always {!<=-1,!>=2}
Line 609
  fIsIncompleteConstant always 68719476736
  b {!<=-1,!>=2,1@3}
Line 612
  ( always {!<=-1,!>=2}
Line 613
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fConstexpr always 134217728
Line 615
  b always {!<=-1,!>=2}
Line 616
  fConstexpr always 134217728
  b always {!<=-1,!>=2}
Line 619
  ( always {!<=-1,!>=2}
Line 620
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fExternC always 268435456
Line 622
  b always {!<=-1,!>=2}
Line 623
  fExternC always 268435456
  b always {!<=-1,!>=2}
Line 626
  ( always {!<=-1,!>=2}
Line 627
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsSplitVarDeclComma always 536870912
Line 629
  b always {!<=-1,!>=2}
Line 630
  fIsSplitVarDeclComma always 536870912
  b always {!<=-1,!>=2}
Line 633
  ( always {!<=-1,!>=2}
Line 634
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsSplitVarDeclEq always 1073741824
Line 636
  b always {!<=-1,!>=2}
Line 637
  fIsSplitVarDeclEq always 1073741824
  b always {!<=-1,!>=2}
Line 640
  ( always {!<=-1,!>=2}
Line 641
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsImplicitInt always 2147483648
Line 643
  b always {!<=-1,!>=2}
Line 644
  fIsImplicitInt always 2147483648
  b always {!<=-1,!>=2}
Line 647
  ( always {!<=-1,!>=2}
Line 648
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsInline always 4294967296
Line 650
  b always {!<=-1,!>=2}
Line 651
  fIsInline always 4294967296
  b always {!<=-1,!>=2}
Line 654
  ( always {!<=-1,!>=2}
Line 655
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsRemovedVoidParameter always 34359738368
Line 657
  b always {!<=-1,!>=2}
Line 658
  fIsRemovedVoidParameter always 34359738368
  b always {!<=-1,!>=2}
Line 661
  ( always {!<=-1,!>=2}
Line 662
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsTemplate always 8589934592
Line 664
  b always {!<=-1,!>=2}
Line 665
  fIsTemplate always 8589934592
  b always {!<=-1,!>=2}
Line 668
  ( always {!<=-1,!>=2}
Line 669
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsSimplifedScope always 17179869184
Line 671
  b always {!<=-1,!>=2}
Line 672
  fIsSimplifedScope always 17179869184
  b always {!<=-1,!>=2}
Line 675
  ( always {!<=-1,!>=2}
Line 676
  return always {!<=-1,!>=2}
  . always !<=-1
  mBits always !<=-1
  > always {!<=-1,!>=2}
  0 always 0
Line 678
  ( always !<=-1
Line 679
  return always !<=-1
  . always !<=-1
  mBits always !<=-1
Line 685
  ! always {!<=-1,!>=2}
Line 687
  . possible lifetime[Object]=(tokenAndName)
Line 689
  b always !<=-1
Line 690
  . always !<=-1
  mBits always !<=-1
  = always !<=-1
  b always !<=-1
Line 693
  ( always {!<=-1,!>=2}
Line 694
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  eString always 6
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  '"' always 34
  "u8" always "u8"
  || always {!<=-1,!>=2}
Line 695
  == always {!<=-1,!>=2}
  eChar always 7
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  '\'' always 39
  "u8" always "u8"
Line 698
  ( always {!<=-1,!>=2}
Line 699
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  eString always 6
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  '"' always 34
  "u" always "u"
  || always {!<=-1,!>=2}
Line 700
  == always {!<=-1,!>=2}
  eChar always 7
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  '\'' always 39
  "u" always "u"
Line 703
  ( always {!<=-1,!>=2}
Line 704
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  eString always 6
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  '"' always 34
  "U" always "U"
  || always {!<=-1,!>=2}
Line 705
  == always {!<=-1,!>=2}
  eChar always 7
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  '\'' always 39
  "U" always "U"
Line 708
  ( always {!<=-1,!>=2}
Line 709
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  eString always 6
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  '"' always 34
  "" always ""
  || always {!<=-1,!>=2}
Line 710
  == always {!<=-1,!>=2}
  eChar always 7
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  '\'' always 39
  "" always ""
  && always {!<=-1,!>=2}
  ( always !<=-1
  == always {!<=-1,!>=2}
  3 always 3
Line 713
  ( always {!<=-1,!>=2}
Line 714
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  eChar always 7
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  '\'' always 39
  "" always ""
  && always {!<=-1,!>=2}
Line 715
  ( always !<=-1
  > always {!<=-1,!>=2}
  3 always 3
Line 734
  ( always {!<=-1,!>=2}
Line 735
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsTemplateArg always 8388608
Line 737
  value always {!<=-1,!>=2}
Line 738
  fIsTemplateArg always 8388608
  value always {!<=-1,!>=2}
Line 742
  ( always !0
  & {lifetime[Address]=(pattern),!0}
Line 743
  startTok possible symbolic=(tok)@208
  pattern {"<"@80,"["@208,"<"@34}
  1 always 1
Line 745
  , always !<=-1
  pattern_len always !<=-1
Line 748
  ( always !0
  & {lifetime[Address]=(pattern),!0}
Line 749
  pattern possible {"const"@193,"decltype ("@197,"return"@32}
  1 always 1
  end inconclusive symbolic=(function->returnDefEnd())@193
Line 751
  , always !<=-1
  pattern_len always !<=-1
Line 753
  , always 0
  = always 0
  0 always 0
Line 754
  , always 0
  = always 0
  0 always 0
Line 757
  ( always !0
  & {lifetime[Address]=(pattern),!0}
Line 758
  1 always 1
Line 760
  , always !<=-1
  pattern_len always !<=-1
Line 761
  pattern_len always !<=-1
Line 764
  ( always !0
  & {lifetime[Address]=(pattern),!0}
Line 765
  1 always 1
Line 767
  , always !<=-1
  pattern_len always !<=-1
Line 768
  pattern_len always !<=-1
Line 771
  , always 0
  = always 0
  0 always 0
Line 772
  varId possible 0
Line 774
  , always 0
  = always 0
  0 always 0
Line 775
  varId possible 0
Line 837
  , always 0
  prepend always {!<=-1,!>=2}
  = always 0
  false always 0
Line 841
  true always 1
Line 853
  = possible 0
  id possible 0
Line 854
  != always {!<=-1,!>=2}
  0 always 0
Line 855
  eVariable always 0
Line 856
  false always 0
Line 864
  . always !0
Line 877
  = always 0
  nullptr always 0
Line 892
  = always 5
  5 always 5
Line 904
  varid always {!<=-1,!>=2}
  varid always {!<=-1,!>=2}
  = always 0
  false always 0
Line 905
  exprid always {!<=-1,!>=2}
  exprid always {!<=-1,!>=2}
  = always 0
  false always 0
Line 906
  idtype always {!<=-1,!>=2}
  idtype always {!<=-1,!>=2}
  = always 0
  false always 0
Line 907
  attributes always {!<=-1,!>=2}
  attributes always {!<=-1,!>=2}
  = always 0
  false always 0
Line 908
  macro always {!<=-1,!>=2}
  macro always {!<=-1,!>=2}
  = always 0
  false always 0
Line 909
  linenumbers always {!<=-1,!>=2}
  linenumbers always {!<=-1,!>=2}
  = always 0
  false always 0
Line 910
  linebreaks always {!<=-1,!>=2}
  linebreaks always {!<=-1,!>=2}
  = always 0
  false always 0
Line 911
  files always {!<=-1,!>=2}
  files always {!<=-1,!>=2}
  = always 0
  false always 0
Line 914
  . always {!<=-1,!>=2}
  attributes always {!<=-1,!>=2}
  = always 1
  true always 1
Line 915
  . always {!<=-1,!>=2}
  macro always {!<=-1,!>=2}
  = always 1
  true always 1
Line 916
  . always {!<=-1,!>=2}
  linenumbers always {!<=-1,!>=2}
  = always 1
  true always 1
Line 917
  . always {!<=-1,!>=2}
  linebreaks always {!<=-1,!>=2}
  = always 1
  true always 1
Line 918
  . always {!<=-1,!>=2}
  files always {!<=-1,!>=2}
  = always 1
  true always 1
Line 923
  . always {!<=-1,!>=2}
  varid always {!<=-1,!>=2}
  = always 1
  true always 1
Line 928
  . always {!<=-1,!>=2}
  exprid always {!<=-1,!>=2}
  = always 1
  true always 1
Line 933
  . always {!<=-1,!>=2}
  exprid always {!<=-1,!>=2}
  = always 1
  true always 1
Line 934
  . always {!<=-1,!>=2}
  varid always {!<=-1,!>=2}
  = always 1
  true always 1
Line 935
  . always {!<=-1,!>=2}
  idtype always {!<=-1,!>=2}
  = always 1
  true always 1
Line 948
  varid always {!<=-1,!>=2}
  attributes always {!<=-1,!>=2}
  macro always {!<=-1,!>=2}
Line 950
  , always 0
  = always 0
  nullptr always 0
  , always 0
  = always 0
  nullptr always 0
Line 951
  , always 1
  attributes always {!<=-1,!>=2}
  = always 1
  true always 1
Line 952
  varid always {!<=-1,!>=2}
  = always 0
  false always 0
Line 965
  varid always {!<=-1,!>=2}
  attributes always {!<=-1,!>=2}
  linenumbers always {!<=-1,!>=2}
  linebreaks always {!<=-1,!>=2}
  files always {!<=-1,!>=2}
  = always 0
  nullptr always 0
  , always 0
  = always 0
  nullptr always 0
Line 984
  mStr possible size=1
  == always {!<=-1,!>=2}
  "<" always "<"
  || always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  ">" always ">"
Line 1006
  = possible {0@210,lifetime[Address]=(scope)@247,lifetime[Address]=(scope)@254}
  s possible {0@210,lifetime[Address]=(scope)@247,lifetime[Address]=(scope)@254}
Line 1026
  mTokType possible 19
  == {!<=-1,!>=2,0}
  eFunction always 2
  || always {!<=-1,!>=2}
  mTokType always !2
  == always {!<=-1,!>=2}
  eLambda always 19
  : always 0
  nullptr always 0
Line 1034
  = possible 0
  v possible 0
Line 1035
  v possible 0@211
  || always {!<=-1,!>=2}
Line 1036
  eVariable always 0
Line 1037
  == always {!<=-1,!>=2}
  eVariable always 0
Line 1038
  eName always 4
Line 1045
  == always {!<=-1,!>=2}
  eVariable always 0
  ? possible 0
  : always 0
  nullptr always 0
Line 1058
  == always {!<=-1,!>=2}
  eType always 1
  ? possible 0
  : always 0
  nullptr always 0
Line 1061
  , always 0
  = always 0
  nullptr always 0
Line 1071
  == always {!<=-1,!>=2}
  eEnumerator always 10
  ? possible 0
  : always 0
  nullptr always 0
Line 1079
  = possible {0,lifetime[Address]=(enumeratorList)@62}
  e possible {0,lifetime[Address]=(enumeratorList)@62}
Line 1080
  e possible {0@212,lifetime[Address]=(enumeratorList)@62}
Line 1081
  eEnumerator always 10
Line 1082
  == always {!<=-1,!>=2}
  eEnumerator always 10
Line 1083
  eName always 4
Line 1152
  . always !0
Line 1156
  . always !0
Line 1163
  && always {!<=-1,!>=2}
Line 1164
  ! always {!<=-1,!>=2}
Line 1170
  ( always {!<=-1,!>=2}
Line 1171
  ( always {!<=-1,!>=2}
Line 1172
  ( always {!<=-1,!>=2}
Line 1173
  ( always {!<=-1,!>=2}
Line 1182
  condition always {!<=-1,!>=2}
  = always 0
  0 always 0
Line 1197
  ( always {!<=-1,!>=2}
Line 1199
  ( always {!<=-1,!>=2}
Line 1227
  ( always {!<=-1,!>=2}
Line 1243
  fIsUnsigned always 1
  = always 1
  1 always 1
  << always 1
  0 always 0
  , always 2
Line 1244
  fIsSigned always 2
  = always 2
  1 always 1
  << always 2
  1 always 1
  , always 4
Line 1245
  fIsPointerCompare always 4
  = always 4
  1 always 1
  << always 4
  2 always 2
  , always 8
Line 1246
  fIsLong always 8
  = always 8
  1 always 1
  << always 8
  3 always 3
  , always 16
Line 1247
  fIsStandardType always 16
  = always 16
  1 always 1
  << always 16
  4 always 4
  , always 32
Line 1248
  fIsExpandedMacro always 32
  = always 32
  1 always 1
  << always 32
  5 always 5
  , always 64
Line 1249
  fIsCast always 64
  = always 64
  1 always 1
  << always 64
  6 always 6
  , always 128
Line 1250
  fIsAttributeConstructor always 128
  = always 128
  1 always 1
  << always 128
  7 always 7
  , always 256
Line 1251
  fIsAttributeDestructor always 256
  = always 256
  1 always 1
  << always 256
  8 always 8
  , always 512
Line 1252
  fIsAttributeUnused always 512
  = always 512
  1 always 1
  << always 512
  9 always 9
  , always 1024
Line 1253
  fIsAttributePure always 1024
  = always 1024
  1 always 1
  << always 1024
  10 always 10
  , always 2048
Line 1254
  fIsAttributeConst always 2048
  = always 2048
  1 always 1
  << always 2048
  11 always 11
  , always 4096
Line 1255
  fIsAttributeNoreturn always 4096
  = always 4096
  1 always 1
  << always 4096
  12 always 12
  , always 8192
Line 1256
  fIsAttributeNothrow always 8192
  = always 8192
  1 always 1
  << always 8192
  13 always 13
  , always 16384
Line 1257
  fIsAttributeUsed always 16384
  = always 16384
  1 always 1
  << always 16384
  14 always 14
  , always 32768
Line 1258
  fIsAttributePacked always 32768
  = always 32768
  1 always 1
  << always 32768
  15 always 15
  , always 65536
Line 1259
  fIsAttributeMaybeUnused always 65536
  = always 65536
  1 always 1
  << always 65536
  16 always 16
  , always 131072
Line 1260
  fIsControlFlowKeyword always 131072
  = always 131072
  1 always 1
  << always 131072
  17 always 17
  , always 262144
Line 1261
  fIsOperatorKeyword always 262144
  = always 262144
  1 always 1
  << always 262144
  18 always 18
  , always 524288
Line 1262
  fIsComplex always 524288
  = always 524288
  1 always 1
  << always 524288
  19 always 19
  , always 1048576
Line 1263
  fIsEnumType always 1048576
  = always 1048576
  1 always 1
  << always 1048576
  20 always 20
  , always 2097152
Line 1264
  fIsName always 2097152
  = always 2097152
  1 always 1
  << always 2097152
  21 always 21
  , always 4194304
Line 1265
  fIsLiteral always 4194304
  = always 4194304
  1 always 1
  << always 4194304
  22 always 22
  , always 8388608
Line 1266
  fIsTemplateArg always 8388608
  = always 8388608
  1 always 1
  << always 8388608
  23 always 23
  , always 16777216
Line 1267
  fIsAttributeNodiscard always 16777216
  = always 16777216
  1 always 1
  << always 16777216
  24 always 24
  , always 33554432
Line 1268
  fAtAddress always 33554432
  = always 33554432
  1 always 1
  << always 33554432
  25 always 25
  , always 67108864
Line 1269
  fIncompleteVar always 67108864
  = always 67108864
  1 always 1
  << always 67108864
  26 always 26
  , always 134217728
Line 1270
  fConstexpr always 134217728
  = always 134217728
  1 always 1
  << always 134217728
  27 always 27
  , always 268435456
Line 1271
  fExternC always 268435456
  = always 268435456
  1 always 1
  << always 268435456
  28 always 28
  , always 536870912
Line 1272
  fIsSplitVarDeclComma always 536870912
  = always 536870912
  1 always 1
  << always 536870912
  29 always 29
  , always 1073741824
Line 1273
  fIsSplitVarDeclEq always 1073741824
  = always 1073741824
  1 always 1
  << always 1073741824
  30 always 30
  , always 2147483648
Line 1274
  fIsImplicitInt always 2147483648
  = always 2147483648
  1U always 1
  << always 2147483648
  31 always 31
  , always 4294967296
Line 1275
  fIsInline always 4294967296
  = always 4294967296
  1ULL always 1
  << always 4294967296
  32 always 32
  , always 8589934592
Line 1276
  fIsTemplate always 8589934592
  = always 8589934592
  1ULL always 1
  << always 8589934592
  33 always 33
  , always 17179869184
Line 1277
  fIsSimplifedScope always 17179869184
  = always 17179869184
  1ULL always 1
  << always 17179869184
  34 always 34
  , always 34359738368
Line 1278
  fIsRemovedVoidParameter always 34359738368
  = always 34359738368
  1ULL always 1
  << always 34359738368
  35 always 35
  , always 68719476736
Line 1279
  fIsIncompleteConstant always 68719476736
  = always 68719476736
  1ULL always 1
  << always 68719476736
  36 always 36
Line 1284
  mFlags always !<=-1
Line 1293
  ( always {!<=-1,!>=2}
  flag_ always !<=-1
Line 1294
  return always {!<=-1,!>=2}
  mFlags always !<=-1
  & always !<=-1
  flag_ {!<=-1,8388608@181,17179869184@192,8589934592@194,34359738368@196,4294967296@198,2147483648@200,1073741824@202,536870912@204,268435456@206}
  != always {!<=-1,!>=2}
  0 always 0
Line 1302
  flag_ always !<=-1
  state_ always {!<=-1,!>=2}
Line 1303
  mFlags always !<=-1
  = always !<=-1
  state_ {!<=-1,!>=2,symbolic=(mTokType==eName||mTokType==eType||mTokType==eVariable||mTokType==eFunction||mTokType==eKeyword||mTokType==eBoolean||mTokType==eEnumerator)@12,symbolic=(mTokType==eNumber||mTokType==eString||mTokType==eChar||mTokType==eBoolean||mTokType==eLiteral||mTokType==eEnumerator)@13}
  ? always !<=-1
  mFlags always !<=-1
  | always !<=-1
  flag_ {!<=-1,8388608@180,17179869184@191,8589934592@193,34359738368@195,4294967296@197,2147483648@199,1073741824@201,536870912@203,268435456@205}
  : always !<=-1
  mFlags always !<=-1
  & always !<=-1
  ~ always !<=0
  flag_ {!<=-1,8388608@180,17179869184@191,8589934592@193,34359738368@195,4294967296@197,2147483648@199,1073741824@201,536870912@203,268435456@205}
Line 1317
  , always 0
  = always 0
  0 always 0
  , always 0
  = always 0
  0 always 0
Line 1343
  ! always {!<=-1,!>=2}
Line 1344
  nullptr always 0
Line 1345
  this {!0,symbolic=(astParent()->astOperand2())}
  == always {!<=-1,!>=2}
  ( always !0
Line 1346
  ( always !0
Line 1347
  this always {!0,!symbolic=(astParent()->astOperand1())}
  == always {!<=-1,!>=2}
  ( always !0
Line 1348
  ( always !0
Line 1349
  nullptr always 0
Line 1353
  ! always {!<=-1,!>=2}
Line 1354
  nullptr always 0
Line 1355
  this {!0,symbolic=(astParent()->astOperand2())}
  == always {!<=-1,!>=2}
  ( always !0
Line 1356
  ( always !0
Line 1357
  this always {!0,!symbolic=(astParent()->astOperand1())}
  == always {!<=-1,!>=2}
  ( always !0
Line 1358
  ( always !0
Line 1359
  nullptr always 0
Line 1363
  = always !0
  this always !0
Line 1364
  ret possible symbolic=(this)
Line 1365
  = always !0
  . always !0
Line 1366
  ret possible symbolic=(this)
Line 1370
  = always !0
  this always !0
Line 1371
  ret possible symbolic=(this)
Line 1372
  = always !0
  . always !0
Line 1373
  ret possible symbolic=(this)
Line 1385
  ( always {!<=-1,!>=2}
Line 1388
  = always 0
  = always 0
  = always 0
  nullptr always 0
Line 1393
  = always 0
  nullptr always 0
Line 1396
  = always ""
  "" always ""
Line 1402
  sep possible ""
Line 1411
  verbose always {!<=-1,!>=2}
  xml always {!<=-1,!>=2}
Line 1413
  xml always {!<=-1,!>=2}
Line 1418
  cpp11init always {!<=-1,!>=2}
Line 1419
  = possible {1,2}
  cpp11init always {!<=-1,!>=2}
  ? possible {1,2}
  :: always 1
  CPP11INIT always 1
  : always 2
  :: always 2
  NOINIT always 2
Line 55
  Public always 0
  Protected always 1
  Private always 2
  Global always 3
  Namespace always 4
  Argument always 5
  Local always 6
  Throw always 7
Line 61
  nullptr always 0
  0 always 0
  known always {!<=-1,!>=2}
  true always 1
Line 65
  known always {!<=-1,!>=2}
Line 75
  Unknown always 0
  True always 1
  False always 2
Line 81
  nullptr always 0
  nullptr always 0
  :: always 0
  Public always 0
  isVirtual always {!<=-1,!>=2}
  false always 0
Line 87
  isVirtual always {!<=-1,!>=2}
Line 89
  ( always {!<=-1,!>=2}
Line 90
  return always {!<=-1,!>=2}
  this always !0
  < always {!<=-1,!>=2}
Line 96
  nullptr always 0
  nullptr always 0
  nullptr always 0
Line 110
  = always 0
  nullptr always 0
  = always 0
  nullptr always 0
  = always 0
  nullptr always 0
Line 111
  classDef_ inconclusive 0
Line 115
  nullptr always 0
Line 116
  nullptr always 0
Line 117
  0 always 0
Line 118
  classDef_ possible 0
  && always {!<=-1,!>=2}
  classDef_ always !0
  == always {!<=-1,!>=2}
  "enum" always "enum"
Line 119
  = always 1
  :: always 1
  True always 1
Line 120
  classDef_ possible 0
  && always {!<=-1,!>=2}
  classDef_ always !0
  == always {!<=-1,!>=2}
  "using" always "using"
Line 121
  3 always 3
Line 123
  && always {!<=-1,!>=2}
  ( always !0
  != always {!<=-1,!>=2}
  ";" always ";"
Line 124
  = always !0
  ( always !0
Line 131
  classDef always !0
Line 134
  ( always {!<=-1,!>=2}
Line 135
  ( always {!<=-1,!>=2}
Line 136
  ( always {!<=-1,!>=2}
Line 137
  ( always {!<=-1,!>=2}
Line 139
  ( always {!<=-1,!>=2}
Line 140
  return always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  classDef always !0
  == always {!<=-1,!>=2}
  "using" always "using"
Line 152
  ( always {!<=-1,!>=2}
  = always 0
  nullptr always 0
Line 159
  ( always {!<=-1,!>=2}
Line 161
  ( always {!<=-1,!>=2}
Line 166
  nullptr always 0
  0 always 0
  nullptr always 0
  nullptr always 0
  value_known always {!<=-1,!>=2}
  false always 0
Line 172
  value_known always {!<=-1,!>=2}
Line 179
  fIsMutable always 1
  = always 1
  1 always 1
  << always 1
  0 always 0
  , always 2
Line 180
  fIsStatic always 2
  = always 2
  1 always 1
  << always 2
  1 always 1
  , always 4
Line 181
  fIsConst always 4
  = always 4
  1 always 1
  << always 4
  2 always 2
  , always 8
Line 182
  fIsExtern always 8
  = always 8
  1 always 1
  << always 8
  3 always 3
  , always 16
Line 183
  fIsClass always 16
  = always 16
  1 always 1
  << always 16
  4 always 4
  , always 32
Line 184
  fIsArray always 32
  = always 32
  1 always 1
  << always 32
  5 always 5
  , always 64
Line 185
  fIsPointer always 64
  = always 64
  1 always 1
  << always 64
  6 always 6
  , always 128
Line 186
  fIsReference always 128
  = always 128
  1 always 1
  << always 128
  7 always 7
  , always 256
Line 187
  fIsRValueRef always 256
  = always 256
  1 always 1
  << always 256
  8 always 8
  , always 512
Line 188
  fHasDefault always 512
  = always 512
  1 always 1
  << always 512
  9 always 9
  , always 1024
Line 189
  fIsStlType always 1024
  = always 1024
  1 always 1
  << always 1024
  10 always 10
  , always 2048
Line 190
  fIsStlString always 2048
  = always 2048
  1 always 1
  << always 2048
  11 always 11
  , always 4096
Line 191
  fIsFloatType always 4096
  = always 4096
  1 always 1
  << always 4096
  12 always 12
  , always 8192
Line 192
  fIsVolatile always 8192
  = always 8192
  1 always 1
  << always 8192
  13 always 13
  , always 16384
Line 193
  fIsSmartPointer always 16384
  = always 16384
  1 always 1
  << always 16384
  14 always 14
  , always 32768
Line 194
  fIsMaybeUnused always 32768
  = always 32768
  1 always 1
  << always 32768
  15 always 15
  , always 65536
Line 195
  fIsInit always 65536
  = always 65536
  1 always 1
  << always 65536
  16 always 16
Line 203
  ( always {!<=-1,!>=2}
  flag_ always !<=-1
Line 204
  return always {!<=-1,!>=2}
  mFlags always !<=-1
  & always !<=-1
  flag_ {!<=-1,32768@112,4096@116,16384@119,2048@120,1024@121,65536@122,512@123,256@124,128@125}
  != always {!<=-1,!>=2}
  0 always 0
Line 212
  flag_ always !<=-1
  state_ always {!<=-1,!>=2}
Line 213
  mFlags always !<=-1
  = always !<=-1
  state_ {!<=-1,!>=2,1@202,0@235}
  ? always !<=-1
  mFlags always !<=-1
  | always !<=-1
  flag_ {!<=-1,64@202,4@203,16384@204,65536@210,32@211,2@221,8@223,8192@226,1@228}
  : always !<=-1
  mFlags always !<=-1
  & always !<=-1
  ~ {!<=0,4294967291@203,4294967263@211,4294967231@235,4294967279@1,4294966271@7,4294965247@9,4294950911@13,4294966783@24}
  flag_ {!<=-1,4@203,32@211,64@235,16@1,1024@7,2048@9,16384@13,512@24}
Line 222
  ( always {!<=-1,!>=2}
Line 233
  mFlags always !<=-1
  0 always 0
  , possible lifetime[SubObject]=(type_)
Line 234
  ( possible lifetime[SubObject]=(type_)
Line 236
  nullptr always 0
Line 300
  mNameToken always !0
Line 312
  mNameToken always !0
Line 314
  0 always 0
Line 329
  ( always {!<=-1,!>=2}
Line 330
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 0
  Public always 0
Line 337
  ( always {!<=-1,!>=2}
Line 338
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 1
  Protected always 1
Line 345
  ( always {!<=-1,!>=2}
Line 346
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 2
  Private always 2
Line 353
  ( always {!<=-1,!>=2}
Line 354
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 3
  Global always 3
Line 361
  ( always {!<=-1,!>=2}
Line 362
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 4
  Namespace always 4
Line 369
  ( always {!<=-1,!>=2}
Line 370
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 5
  Argument always 5
Line 377
  ( always {!<=-1,!>=2}
Line 378
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 385
  ( always {!<=-1,!>=2}
Line 386
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsMutable always 1
Line 393
  ( always {!<=-1,!>=2}
Line 394
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsVolatile always 8192
Line 401
  ( always {!<=-1,!>=2}
Line 402
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsStatic always 2
Line 409
  ( always {!<=-1,!>=2}
Line 410
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsExtern always 8
Line 417
  ( always {!<=-1,!>=2}
Line 418
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsConst always 4
Line 425
  ( always {!<=-1,!>=2}
Line 426
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 7
  Throw always 7
Line 433
  ( always {!<=-1,!>=2}
Line 434
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsClass always 16
Line 441
  ( always {!<=-1,!>=2}
Line 442
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsArray always 32
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsPointer always 64
Line 449
  ( always {!<=-1,!>=2}
Line 450
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsPointer always 64
Line 457
  ( always {!<=-1,!>=2}
Line 458
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsArray always 32
Line 465
  ( always {!<=-1,!>=2}
Line 471
  ( always {!<=-1,!>=2}
Line 472
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsArray always 32
  || always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsPointer always 64
Line 479
  ( always {!<=-1,!>=2}
Line 480
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsReference always 128
Line 487
  ( always {!<=-1,!>=2}
Line 488
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsRValueRef always 256
Line 495
  ( always {!<=-1,!>=2}
Line 501
  ( always {!<=-1,!>=2}
Line 502
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fHasDefault always 512
Line 509
  ( always {!<=-1,!>=2}
Line 510
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsInit always 65536
Line 526
  ? possible 0
  mType always !0
  : always 0
  nullptr always 0
Line 550
  index_ possible <=symbolic=(var->dimensions().size()-1)@26
Line 557
  ( always {!<=-1,!>=2}
Line 558
  return always {!<=-1,!>=2}
  . always {!<=-1,!>=2}
  known always {!<=-1,!>=2}
Line 569
  ( always {!<=-1,!>=2}
Line 570
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsStlType always 1024
Line 581
  ( always {!<=-1,!>=2}
Line 582
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsStlString always 2048
Line 585
  ( always {!<=-1,!>=2}
Line 586
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsSmartPointer always 16384
Line 601
  ( always {!<=-1,!>=2}
Line 602
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  2 always 2
Line 615
  ( always {!<=-1,!>=2}
Line 616
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( possible lifetime[Iterator]=(stlTypes)
  2 always 2
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(stlTypes),end=0}
Line 623
  ( always {!<=-1,!>=2}
Line 624
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsFloatType always 4096
Line 631
  ( always {!<=-1,!>=2}
Line 632
  return always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always !0
  ( always {!<=-1,!>=2}
Line 635
  ( always {!<=-1,!>=2}
Line 636
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsMaybeUnused always 32768
Line 679
  mFlags always !<=-1
Line 702
  fHasBody always 1
  = always 1
  1 always 1
  << always 1
  0 always 0
  , always 2
Line 703
  fIsInline always 2
  = always 2
  1 always 1
  << always 2
  1 always 1
  , always 4
Line 704
  fIsConst always 4
  = always 4
  1 always 1
  << always 4
  2 always 2
  , always 8
Line 705
  fHasVirtualSpecifier always 8
  = always 8
  1 always 1
  << always 8
  3 always 3
  , always 16
Line 706
  fIsPure always 16
  = always 16
  1 always 1
  << always 16
  4 always 4
  , always 32
Line 707
  fIsStatic always 32
  = always 32
  1 always 1
  << always 32
  5 always 5
  , always 64
Line 708
  fIsStaticLocal always 64
  = always 64
  1 always 1
  << always 64
  6 always 6
  , always 128
Line 709
  fIsExtern always 128
  = always 128
  1 always 1
  << always 128
  7 always 7
  , always 256
Line 710
  fIsFriend always 256
  = always 256
  1 always 1
  << always 256
  8 always 8
  , always 512
Line 711
  fIsExplicit always 512
  = always 512
  1 always 1
  << always 512
  9 always 9
  , always 1024
Line 712
  fIsDefault always 1024
  = always 1024
  1 always 1
  << always 1024
  10 always 10
  , always 2048
Line 713
  fIsDelete always 2048
  = always 2048
  1 always 1
  << always 2048
  11 always 11
  , always 4096
Line 714
  fHasOverrideSpecifier always 4096
  = always 4096
  1 always 1
  << always 4096
  12 always 12
  , always 8192
Line 715
  fHasFinalSpecifier always 8192
  = always 8192
  1 always 1
  << always 8192
  13 always 13
  , always 16384
Line 716
  fIsNoExcept always 16384
  = always 16384
  1 always 1
  << always 16384
  14 always 14
  , always 32768
Line 717
  fIsThrow always 32768
  = always 32768
  1 always 1
  << always 32768
  15 always 15
  , always 65536
Line 718
  fIsOperator always 65536
  = always 65536
  1 always 1
  << always 65536
  16 always 16
  , always 131072
Line 719
  fHasLvalRefQual always 131072
  = always 131072
  1 always 1
  << always 131072
  17 always 17
  , always 262144
Line 720
  fHasRvalRefQual always 262144
  = always 262144
  1 always 1
  << always 262144
  18 always 18
  , always 524288
Line 721
  fIsVariadic always 524288
  = always 524288
  1 always 1
  << always 524288
  19 always 19
  , always 1048576
Line 722
  fIsVolatile always 1048576
  = always 1048576
  1 always 1
  << always 1048576
  20 always 20
  , always 2097152
Line 723
  fHasTrailingReturnType always 2097152
  = always 2097152
  1 always 1
  << always 2097152
  21 always 21
  , always 4194304
Line 724
  fIsEscapeFunction always 4194304
  = always 4194304
  1 always 1
  << always 4194304
  22 always 22
  , always 8388608
Line 725
  fIsInlineKeyword always 8388608
  = always 8388608
  1 always 1
  << always 8388608
  23 always 23
  , always 16777216
Line 726
  fIsConstexpr always 16777216
  = always 16777216
  1 always 1
  << always 16777216
  24 always 24
Line 734
  ( always {!<=-1,!>=2}
  flag always !<=-1
Line 735
  return always {!<=-1,!>=2}
  mFlags always !<=-1
  & always !<=-1
  flag {!<=-1,16777216@77,4194304@79,8388608@80,2097152@82,1048576@83,524288@84,262144@85,131072@86,65536@87}
  != always {!<=-1,!>=2}
  0 always 0
Line 743
  flag always !<=-1
  state always {!<=-1,!>=2}
Line 744
  mFlags always !<=-1
  = always !<=-1
  state {!<=-1,!>=2,1@162}
  ? always !<=-1
  mFlags always !<=-1
  | always !<=-1
  flag {!<=-1,4096@162,8192@164,4194304@78}
  : always !<=-1
  mFlags always !<=-1
  & always !<=-1
  ~ {!<=0,4290772991@78}
  flag {!<=-1,4194304@78}
Line 748
  eConstructor always 0
  eCopyConstructor always 1
  eMoveConstructor always 2
  eOperatorEqual always 3
  eDestructor always 4
  eFunction always 5
  eLambda always 6
Line 760
  ( always !<=-1
Line 763
  ( always !<=-1
  - always !<=-1
Line 772
  ( always {!<=-1,!>=2}
  = always 0
  false always 0
Line 777
  = always 0
  nullptr always 0
Line 779
  ( always {!<=-1,!>=2}
Line 780
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  eLambda always 6
Line 783
  ( always {!<=-1,!>=2}
Line 784
  return always {!<=-1,!>=2}
  type possible {1,2}
  == {!<=-1,!>=2,0}
  eConstructor always 0
  || always {!<=-1,!>=2}
Line 785
  type {2,!0}
  == {!<=-1,!>=2,0}
  eCopyConstructor always 1
  || always {!<=-1,!>=2}
Line 786
  type always {!0,!1}
  == always {!<=-1,!>=2}
  eMoveConstructor always 2
Line 789
  ( always {!<=-1,!>=2}
Line 790
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  eDestructor always 4
Line 792
  ( always {!<=-1,!>=2}
Line 793
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 795
  ( always {!<=-1,!>=2}
Line 796
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 798
  ( always {!<=-1,!>=2}
Line 799
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 801
  ( always {!<=-1,!>=2}
Line 802
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 804
  ( always {!<=-1,!>=2}
Line 805
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 807
  ( always {!<=-1,!>=2}
Line 808
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 810
  ( always {!<=-1,!>=2}
Line 811
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 814
  ( always {!<=-1,!>=2}
Line 815
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fHasBody always 1
Line 817
  ( always {!<=-1,!>=2}
Line 818
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsInline always 2
Line 820
  ( always {!<=-1,!>=2}
Line 821
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsConst always 4
Line 823
  ( always {!<=-1,!>=2}
Line 824
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fHasVirtualSpecifier always 8
Line 826
  ( always {!<=-1,!>=2}
Line 827
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsPure always 16
Line 829
  ( always {!<=-1,!>=2}
Line 830
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsStatic always 32
Line 832
  ( always {!<=-1,!>=2}
Line 833
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsStaticLocal always 64
Line 835
  ( always {!<=-1,!>=2}
Line 836
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsExtern always 128
Line 838
  ( always {!<=-1,!>=2}
Line 839
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsFriend always 256
Line 841
  ( always {!<=-1,!>=2}
Line 842
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsExplicit always 512
Line 844
  ( always {!<=-1,!>=2}
Line 845
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsDefault always 1024
Line 847
  ( always {!<=-1,!>=2}
Line 848
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsDelete always 2048
Line 850
  ( always {!<=-1,!>=2}
Line 851
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsNoExcept always 16384
Line 853
  ( always {!<=-1,!>=2}
Line 854
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsThrow always 32768
Line 856
  ( always {!<=-1,!>=2}
Line 857
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fHasOverrideSpecifier always 4096
Line 859
  ( always {!<=-1,!>=2}
Line 860
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fHasFinalSpecifier always 8192
Line 862
  ( always {!<=-1,!>=2}
Line 863
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsOperator always 65536
Line 865
  ( always {!<=-1,!>=2}
Line 866
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fHasLvalRefQual always 131072
Line 868
  ( always {!<=-1,!>=2}
Line 869
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fHasRvalRefQual always 262144
Line 871
  ( always {!<=-1,!>=2}
Line 872
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsVariadic always 524288
Line 874
  ( always {!<=-1,!>=2}
Line 875
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsVolatile always 1048576
Line 877
  ( always {!<=-1,!>=2}
Line 878
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fHasTrailingReturnType always 2097152
Line 880
  state always {!<=-1,!>=2}
Line 881
  fHasBody always 1
  state {!<=-1,!>=2,1@125}
Line 883
  ( always {!<=-1,!>=2}
Line 884
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsInlineKeyword always 8388608
Line 887
  ( always {!<=-1,!>=2}
Line 888
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsEscapeFunction always 4194304
Line 890
  state always {!<=-1,!>=2}
Line 891
  fIsEscapeFunction always 4194304
  state always {!<=-1,!>=2}
Line 894
  ( always {!<=-1,!>=2}
Line 895
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsConstexpr always 16777216
Line 897
  state always {!<=-1,!>=2}
Line 898
  fIsConstexpr always 16777216
  state {!<=-1,!>=2,1@102}
Line 900
  ( always {!<=-1,!>=2}
Line 919
  ( always {!<=-1,!>=2}
Line 921
  ( always {!<=-1,!>=2}
  , always 0
  = always 0
  false always 0
Line 923
  ( always {!<=-1,!>=2}
  , always 0
  = always 0
  false always 0
Line 925
  ( always {!<=-1,!>=2}
  , always 0
  = always 0
  false always 0
Line 930
  this always !0
  ( always {!<=-1,!>=2}
Line 931
  "{|;" always "{|;"
Line 947
  mFlags always !<=-1
Line 949
  state always {!<=-1,!>=2}
Line 950
  fIsInline always 2
  state {!<=-1,!>=2,1@183}
Line 952
  state always {!<=-1,!>=2}
Line 953
  fIsConst always 4
  state {!<=-1,!>=2,1@122}
Line 955
  state always {!<=-1,!>=2}
Line 956
  fHasVirtualSpecifier always 8
  state {!<=-1,!>=2,1@95}
Line 958
  state always {!<=-1,!>=2}
Line 959
  fIsPure always 16
  state {!<=-1,!>=2,0@176,1@176}
Line 961
  state always {!<=-1,!>=2}
Line 962
  fIsStatic always 32
  state {!<=-1,!>=2,1@97}
Line 964
  state always {!<=-1,!>=2}
Line 965
  fIsStaticLocal always 64
  state {!<=-1,!>=2,1@98}
Line 967
  state always {!<=-1,!>=2}
Line 968
  fIsExtern always 128
  state {!<=-1,!>=2,1@93}
Line 970
  state always {!<=-1,!>=2}
Line 971
  fIsFriend always 256
  state {!<=-1,!>=2,1@100}
Line 973
  state always {!<=-1,!>=2}
Line 974
  fIsExplicit always 512
  state {!<=-1,!>=2,0@133,1@133}
Line 976
  state always {!<=-1,!>=2}
Line 977
  fIsDefault always 1024
  state {!<=-1,!>=2,1@124,0@177}
Line 979
  state always {!<=-1,!>=2}
Line 980
  fIsDelete always 2048
  state {!<=-1,!>=2,0@178,1@178}
Line 982
  state always {!<=-1,!>=2}
Line 983
  fIsNoExcept always 16384
  state {!<=-1,!>=2,0@168,1@168}
Line 985
  state always {!<=-1,!>=2}
Line 986
  fIsThrow always 32768
  state {!<=-1,!>=2,1@174}
Line 988
  state always {!<=-1,!>=2}
Line 989
  fIsOperator always 65536
  state {!<=-1,!>=2,1@117}
Line 991
  state always {!<=-1,!>=2}
Line 992
  fHasLvalRefQual always 131072
  state {!<=-1,!>=2,1@158}
Line 994
  state always {!<=-1,!>=2}
Line 995
  fHasRvalRefQual always 262144
  state {!<=-1,!>=2,1@160}
Line 997
  state always {!<=-1,!>=2}
Line 998
  fIsVariadic always 524288
  state {!<=-1,!>=2,1@131}
Line 1000
  state always {!<=-1,!>=2}
Line 1001
  fIsVolatile always 1048576
  state {!<=-1,!>=2,1@166}
Line 1003
  state always {!<=-1,!>=2}
Line 1004
  fHasTrailingReturnType always 2097152
  state {!<=-1,!>=2,1@140}
Line 1006
  state always {!<=-1,!>=2}
Line 1007
  fIsInlineKeyword always 8388608
  state {!<=-1,!>=2,1@86}
Line 1022
  eGlobal always 0
  eClass always 1
  eStruct always 2
  eUnion always 3
  eNamespace always 4
  eFunction always 5
  eIf always 6
  eElse always 7
  eFor always 8
  eWhile always 9
  eDo always 10
  eSwitch always 11
  eUnconditional always 12
  eTry always 13
  eCatch always 14
  eLambda always 15
  eEnum always 16
Line 1051
  enumClass always {!<=-1,!>=2}
Line 1056
  = possible {0,symbolic=(tok->next())@163}
  start possible {0,symbolic=(tok->next())@163}
Line 1057
  = possible 0
  start possible {0,symbolic=(tok->next())@163}
  ? possible 0
  start {!0,symbolic=(tok->next())@163}
  : always 0
  nullptr always 0
Line 1058
  start possible symbolic=(tok->next())@163
Line 1059
  bodyStartList possible lifetime[Object]=(start)
  start {!0,symbolic=(tok->next())@163}
Line 1062
  ( always {!<=-1,!>=2}
Line 1064
  return always {!<=-1,!>=2}
  ( always !<=-1
  > always {!<=-1,!>=2}
  9 always 9
  && always {!<=-1,!>=2}
  className {>=size=10,!<=size=9}
  0 always 0
  9 always 9
  "Anonymous" always "Anonymous"
  == always {!<=-1,!>=2}
  0 always 0
  && always {!<=-1,!>=2}
  9 always 9
Line 1069
  == always {!<=-1,!>=2}
Line 1070
  & {lifetime[Address]=(enumeratorList),!0}
Line 1072
  nullptr always 0
Line 1075
  ( always {!<=-1,!>=2}
Line 1076
  ! always {!<=-1,!>=2}
  outer possible symbolic=(this)
Line 1077
  return always {!<=-1,!>=2}
  false always 0
Line 1078
  outer always !0
  == always {!<=-1,!>=2}
  this always !0
Line 1079
  return always {!<=-1,!>=2}
  true always 1
Line 1081
  outer {symbolic=(parent),!symbolic=(this),!0}
  != {!<=-1,!>=2,0,1}
  parent possible {symbolic=(nestedIn),symbolic=(outer),0}
  && {!<=-1,!>=2,0}
  parent {symbolic=(nestedIn),!symbolic=(outer),0}
Line 1082
  parent {symbolic=(nestedIn),!symbolic=(outer),!0}
Line 1083
  parent possible {symbolic=(nestedIn),symbolic=(outer),0}
  && always {!<=-1,!>=2}
  parent always !0
  == always {!<=-1,!>=2}
  outer always {!symbolic=(this),!0}
Line 1084
  return always {!<=-1,!>=2}
  true always 1
Line 1085
  return always {!<=-1,!>=2}
  false always 0
Line 1090
  scope always !0
  == always {!<=-1,!>=2}
  :: always 5
  eFunction always 5
Line 1092
  scope always !0
Line 1094
  ! {!<=-1,!>=2,1}
  scope possible 0
Line 1095
  nullptr always 0
Line 1096
  scope always !0
Line 1099
  ( always {!<=-1,!>=2}
Line 1100
  return always {!<=-1,!>=2}
  type possible 2
  == {!<=-1,!>=2,0}
  eClass always 1
  || always {!<=-1,!>=2}
  type always !1
  == always {!<=-1,!>=2}
  eStruct always 2
Line 1103
  ( always {!<=-1,!>=2}
Line 1104
  return always {!<=-1,!>=2}
  type possible {2,3}
  == {!<=-1,!>=2,0}
  eClass always 1
  || always {!<=-1,!>=2}
  type {3,!1}
  == {!<=-1,!>=2,0}
  eStruct always 2
  || always {!<=-1,!>=2}
  type always {!1,!2}
  == always {!<=-1,!>=2}
  eUnion always 3
Line 1107
  ( always {!<=-1,!>=2}
Line 1108
  return always {!<=-1,!>=2}
  type possible {2,3,0,4,16}
  != {!<=-1,!>=2,1}
  eClass always 1
  && always {!<=-1,!>=2}
  type {3,0,4,16,!1}
  != {!<=-1,!>=2,1}
  eStruct always 2
  && always {!<=-1,!>=2}
  type {0,4,16,!1,!2}
  != {!<=-1,!>=2,1}
  eUnion always 3
  && always {!<=-1,!>=2}
  type {4,16,!2,!3}
  != {!<=-1,!>=2,1}
  eGlobal always 0
  && always {!<=-1,!>=2}
  type {16,!3,!0}
  != {!<=-1,!>=2,1}
  eNamespace always 4
  && always {!<=-1,!>=2}
  type always {!0,!4}
  != always {!<=-1,!>=2}
  eEnum always 16
Line 1111
  ( always {!<=-1,!>=2}
Line 1112
  return always {!<=-1,!>=2}
  type possible {9,10}
  == {!<=-1,!>=2,0}
  :: always 8
  eFor always 8
  || always {!<=-1,!>=2}
  type {10,!8}
  == {!<=-1,!>=2,0}
  :: always 9
  eWhile always 9
  || always {!<=-1,!>=2}
  type always {!8,!9}
  == always {!<=-1,!>=2}
  :: always 10
  eDo always 10
Line 1115
  ( always {!<=-1,!>=2}
Line 1116
  return always {!<=-1,!>=2}
  type possible {7,8,9,10,11,12,13,14}
  == {!<=-1,!>=2,0}
  eIf always 6
  || always {!<=-1,!>=2}
  type {8,9,10,11,12,13,14,!6}
  == {!<=-1,!>=2,0}
  eElse always 7
  || always {!<=-1,!>=2}
Line 1117
  type {9,10,11,12,13,14,!6,!7}
  == {!<=-1,!>=2,0}
  eFor always 8
  || always {!<=-1,!>=2}
  type {10,11,12,13,14,!7,!8}
  == {!<=-1,!>=2,0}
  eWhile always 9
  || always {!<=-1,!>=2}
  type {11,12,13,14,!8,!9}
  == {!<=-1,!>=2,0}
  eDo always 10
  || always {!<=-1,!>=2}
Line 1118
  type {12,13,14,!9,!10}
  == {!<=-1,!>=2,0}
  eSwitch always 11
  || always {!<=-1,!>=2}
  type {13,14,!10,!11}
  == {!<=-1,!>=2,0}
  eUnconditional always 12
  || always {!<=-1,!>=2}
Line 1119
  type {14,!11,!12}
  == {!<=-1,!>=2,0}
  eTry always 13
  || always {!<=-1,!>=2}
  type always {!12,!13}
  == always {!<=-1,!>=2}
  eCatch always 14
Line 1123
  ( always {!<=-1,!>=2}
Line 1131
  , always 0
  = always 0
  false always 0
Line 1133
  , always 0
  = always 0
  false always 0
Line 1135
  ( always !0
  this always !0
Line 1140
  ( always !0
  this always !0
Line 1159
  functionList possible lifetime[Object]=(func)
Line 1161
  = {lifetime[Object]=(functionList),!0}
  & {lifetime[Object]=(functionList),!0}
  functionList {lifetime[Object]=(func),!size=0}
Line 1163
  ( possible lifetime[Iterator]=(functionMap)
  back {lifetime[Object]=(functionList),symbolic=(&functionList.back()),!0}
  back {lifetime[Object]=(functionList),symbolic=(&functionList.back()),!0}
Line 1166
  ( always {!<=-1,!>=2}
Line 1200
  ( always {!<=-1,!>=2}
  & {lifetime[Address]=(vartok),!0}
  & {lifetime[Address]=(typetok),!0}
Line 1209
  None always 0
Line 1210
  LValue always 1
Line 1211
  RValue always 2
Line 1217
  UNKNOWN_SIGN always 0
  SIGNED always 1
  UNSIGNED always 2
Line 1219
  UNKNOWN_TYPE always 0
Line 1220
  POD always 1
Line 1221
  NONSTD always 2
Line 1222
  RECORD always 3
Line 1223
  SMART_POINTER always 4
Line 1224
  CONTAINER always 5
Line 1225
  ITERATOR always 6
Line 1226
  VOID always 7
Line 1227
  BOOL always 8
Line 1228
  CHAR always 9
Line 1229
  SHORT always 10
Line 1230
  WCHAR_T always 11
Line 1231
  INT always 12
Line 1232
  LONG always 13
Line 1233
  LONGLONG always 14
Line 1234
  UNKNOWN_INT always 15
Line 1235
  FLOAT always 16
Line 1236
  DOUBLE always 17
Line 1237
  LONGDOUBLE always 18
Line 1242
  = always 0
  :: always 0
  None always 0
Line 1256
  UNKNOWN_SIGN always 0
Line 1257
  UNKNOWN_TYPE always 0
Line 1258
  0 always 0
Line 1259
  0U always 0
Line 1260
  0U always 0
Line 1261
  nullptr always 0
Line 1262
  nullptr always 0
Line 1263
  nullptr always 0
Line 1264
  nullptr always 0
Line 1265
  nullptr always 0
Line 1266
  nullptr always 0
Line 1268
  ( possible lifetime[SubObject]=(s)
Line 1271
  0 always 0
Line 1273
  0U always 0
Line 1274
  nullptr always 0
Line 1275
  nullptr always 0
Line 1276
  nullptr always 0
Line 1277
  nullptr always 0
Line 1278
  nullptr always 0
Line 1279
  nullptr always 0
Line 1281
  ( possible lifetime[SubObject]=(s)
Line 1284
  0 always 0
Line 1287
  nullptr always 0
Line 1288
  nullptr always 0
Line 1289
  nullptr always 0
Line 1290
  nullptr always 0
Line 1291
  nullptr always 0
Line 1292
  nullptr always 0
Line 1294
  ( possible lifetime[SubObject]=(s)
Line 1297
  0 always 0
Line 1300
  nullptr always 0
Line 1301
  nullptr always 0
Line 1302
  nullptr always 0
Line 1303
  nullptr always 0
Line 1304
  nullptr always 0
Line 1305
  nullptr always 0
Line 1313
  UNKNOWN always 0
  SAME always 1
  FALLBACK1 always 2
  FALLBACK2 always 3
  NOMATCH always 4
Line 1317
  ( always {!<=-1,!>=2}
Line 1318
  return always {!<=-1,!>=2}
  >= always {!<=-1,!>=2}
  :: always 8
  BOOL always 8
Line 1321
  ( always {!<=-1,!>=2}
Line 1322
  return always {!<=-1,!>=2}
  type possible {<=15,>=16}
  >= {!<=-1,!>=2,<=1}
  :: always 8
  BOOL always 8
  && always {!<=-1,!>=2}
  type {>=8,!<=7}
  <= {!<=-1,!>=2,>=1}
  :: always 15
  UNKNOWN_INT always 15
Line 1325
  ( always {!<=-1,!>=2}
Line 1326
  return always {!<=-1,!>=2}
  type possible {<=18,>=19}
  >= {!<=-1,!>=2,<=1}
  :: always 16
  FLOAT always 16
  && always {!<=-1,!>=2}
  type {>=16,!<=15}
  <= {!<=-1,!>=2,>=1}
  :: always 18
  LONGDOUBLE always 18
Line 1329
  ( always {!<=-1,!>=2}
Line 1331
  ( always {!<=-1,!>=2}
Line 1332
  return always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  typeScope always !0
  == always {!<=-1,!>=2}
  :: always 16
  eEnum always 16
Line 1335
  , always 0
  = always 0
  false always 0
Line 1338
  ( always {!<=-1,!>=2}
Line 1381
  , always 0
  = always 0
  false always 0
Line 1382
  , always 0
  lookOutside always {!<=-1,!>=2}
  = always 0
  false always 0
Line 1383
  this always !0
  lookOutside always {!<=-1,!>=2}
Line 1388
  this always !0
Line 1391
  ( always {!<=-1,!>=2}
Line 1392
  return always {!<=-1,!>=2}
  < always {!<=-1,!>=2}
  ( always !<=-1
Line 1408
  = always 0
  nullptr always 0
Line 1412
  ( always {!<=-1,!>=2}
Line 1426
  = always 0
  nullptr always 0
Line 1467
  & {lifetime[Address]=(scope),!0}
Line 1468
  & {lifetime[Address]=(scope),!0}
  & {lifetime[Address]=(tok),!0}
Line 1470
  ( always {!<=-1,!>=2}
Line 1482
  ( always {!<=-1,!>=2}
Line 1500
  mIsCpp always {!<=-1,!>=2}
Line 40
  none always 0
Line 41
  op1 always 1
Line 42
  op2 always 2
Line 43
  op1_and_op2 always 3
Line 44
  done always 4
Line 53
  ! always {!<=-1,!>=2}
Line 57
  = always !0
  ast always !0
Line 59
  tok inconclusive symbolic=(ast)
Line 61
  c possible {2,3,1}
  == {!<=-1,!>=2,0}
  :: always 4
  done always 4
Line 63
  c {3,1,!4}
  == {!<=-1,!>=2,0}
  :: always 2
  op2 always 2
  || {!<=-1,!>=2,1}
  c {1,3,!4,!2}
  == {!<=-1,!>=2,0,1}
  :: always 3
  op1_and_op2 always 3
Line 66
  t2 always !0
Line 68
  c {3,!4,2}
  == {!<=-1,!>=2,0}
  :: always 1
  op1 always 1
  || {!<=-1,!>=2,1}
  c {!4,2,3,!1}
  == {!<=-1,!>=2,0,1}
  :: always 3
  op1_and_op2 always 3
Line 71
  t1 always !0
Line 74
  ( always {!<=-1,!>=2}
Line 77
  tokens always !size=0
Line 78
  tokens always !size=0
Line 79
  true always 1
Line 82
  ( always {!<=-1,!>=2}
Line 86
  ( always {!<=-1,!>=2}
Line 92
  , always 100
  = always 100
  100 always 100
Line 94
  ( always {!<=-1,!>=2}
Line 96
  ( always {!<=-1,!>=2}
Line 98
  ( always {!<=-1,!>=2}
Line 100
  ( always {!<=-1,!>=2}
Line 102
  ( always {!<=-1,!>=2}
Line 104
  ( always {!<=-1,!>=2}
Line 106
  ( always {!<=-1,!>=2}
  , always {!<=-1,!>=2}
  unknown always {!<=-1,!>=2}
Line 107
  ( always {!<=-1,!>=2}
Line 109
  ( always {!<=-1,!>=2}
  , always {!<=-1,!>=2}
  unknown always {!<=-1,!>=2}
Line 111
  ( always {!<=-1,!>=2}
Line 113
  ( always {!<=-1,!>=2}
Line 115
  ( always {!<=-1,!>=2}
Line 116
  ( always {!<=-1,!>=2}
Line 118
  ( always {!<=-1,!>=2}
Line 120
  ( always {!<=-1,!>=2}
Line 122
  ( always {!<=-1,!>=2}
Line 123
  ( always {!<=-1,!>=2}
Line 137
  , always 0
  = always 0
  nullptr always 0
Line 139
  ( always {!<=-1,!>=2}
Line 141
  ( always {!<=-1,!>=2}
  cpp always {!<=-1,!>=2}
  , always 0
  unknown always {!<=-1,!>=2}
  = always 0
  false always 0
Line 155
  cpp always {!<=-1,!>=2}
Line 157
  ( always {!<=-1,!>=2}
Line 158
  ( always {!<=-1,!>=2}
Line 179
  ( always {!<=-1,!>=2}
Line 187
  ( always {!<=-1,!>=2}
Line 188
  ( always {!<=-1,!>=2}
Line 190
  ( always {!<=-1,!>=2}
  , always 1
  onVar always {!<=-1,!>=2}
  = always 1
  true always 1
  , always 0
  = always 0
  0 always 0
Line 198
  temporary always {!<=-1,!>=2}
  = always 1
  true always 1
Line 199
  inconclusive always {!<=-1,!>=2}
  = always 1
  true always 1
Line 201
  = always 20
  20 always 20
Line 202
  , always 0
  = always 0
  nullptr always 0
Line 204
  ( always {!<=-1,!>=2}
  cpp always {!<=-1,!>=2}
  macro always {!<=-1,!>=2}
  , always {!<=-1,!>=2}
  pure always {!<=-1,!>=2}
  , always {!<=-1,!>=2}
  followVar always {!<=-1,!>=2}
  , always 0
  = always 0
  nullptr always 0
Line 206
  ( always {!<=-1,!>=2}
Line 211
  ( always {!<=-1,!>=2}
Line 222
  ( always {!<=-1,!>=2}
  isNot always {!<=-1,!>=2}
  cpp always {!<=-1,!>=2}
  , always {!<=-1,!>=2}
  pure always {!<=-1,!>=2}
  , always {!<=-1,!>=2}
  followVar always {!<=-1,!>=2}
  , always 0
  = always 0
  nullptr always 0
Line 224
  ( always {!<=-1,!>=2}
  cpp always {!<=-1,!>=2}
  , always {!<=-1,!>=2}
  pure always {!<=-1,!>=2}
  , always {!<=-1,!>=2}
  followVar always {!<=-1,!>=2}
  , always 0
  = always 0
  nullptr always 0
Line 226
  ( always {!<=-1,!>=2}
Line 228
  ( always {!<=-1,!>=2}
  , always {!<=-1,!>=2}
  pure always {!<=-1,!>=2}
  , always {!<=-1,!>=2}
  cpp always {!<=-1,!>=2}
Line 230
  ( always {!<=-1,!>=2}
  cpp always {!<=-1,!>=2}
  , always 0
  checkArrayAccess always {!<=-1,!>=2}
  = always 0
  false always 0
  , always 1
  checkReference always {!<=-1,!>=2}
  = always 1
  true always 1
Line 232
  ( always {!<=-1,!>=2}
Line 234
  ( always {!<=-1,!>=2}
Line 237
  ( always {!<=-1,!>=2}
  , always 0
Line 238
  = always 0
  nullptr always 0
  , always 0
Line 239
  = always 0
  nullptr always 0
  , always 0
Line 240
  functionScope always {!<=-1,!>=2}
  = always 0
  false always 0
Line 243
  ( always {!<=-1,!>=2}
Line 262
  ( always {!<=-1,!>=2}
Line 272
  ( always {!<=-1,!>=2}
Line 275
  ( always {!<=-1,!>=2}
  , always {!<=-1,!>=2}
  globalvar always {!<=-1,!>=2}
  , always {!<=-1,!>=2}
  cpp always {!<=-1,!>=2}
  , always 20
  = always 20
  20 always 20
Line 276
  ( always {!<=-1,!>=2}
  , always {!<=-1,!>=2}
  globalvar always {!<=-1,!>=2}
  , always {!<=-1,!>=2}
  cpp always {!<=-1,!>=2}
  , always 20
  = always 20
  20 always 20
Line 278
  ( always {!<=-1,!>=2}
  , always {!<=-1,!>=2}
  cpp always {!<=-1,!>=2}
  , always 20
  = always 20
  20 always 20
Line 280
  ( always {!<=-1,!>=2}
  , always {!<=-1,!>=2}
  cpp always {!<=-1,!>=2}
  , always 20
  = always 20
  20 always 20
Line 282
  ( always {!<=-1,!>=2}
Line 286
  , always {!<=-1,!>=2}
Line 287
  cpp always {!<=-1,!>=2}
Line 289
  ( always {!<=-1,!>=2}
  , always {!<=-1,!>=2}
  cpp always {!<=-1,!>=2}
Line 290
  ( always {!<=-1,!>=2}
  , always {!<=-1,!>=2}
  cpp always {!<=-1,!>=2}
Line 292
  , always {!<=-1,!>=2}
  globalvar always {!<=-1,!>=2}
  , always {!<=-1,!>=2}
  cpp always {!<=-1,!>=2}
  , always 20
  = always 20
  20 always 20
Line 293
  , always {!<=-1,!>=2}
  globalvar always {!<=-1,!>=2}
  , always {!<=-1,!>=2}
  cpp always {!<=-1,!>=2}
  , always 20
  = always 20
  20 always 20
Line 295
  ( always {!<=-1,!>=2}
Line 298
  , always {!<=-1,!>=2}
Line 299
  cpp always {!<=-1,!>=2}
  , always 20
Line 300
  = always 20
  20 always 20
Line 302
  ( always {!<=-1,!>=2}
Line 304
  , always {!<=-1,!>=2}
Line 305
  globalvar always {!<=-1,!>=2}
Line 306
  , always {!<=-1,!>=2}
Line 307
  cpp always {!<=-1,!>=2}
  , always 20
Line 308
  = always 20
  20 always 20
Line 311
  ( always {!<=-1,!>=2}
  , always 0
  = always 0
  nullptr always 0
Line 313
  ( always {!<=-1,!>=2}
Line 336
  ( always {!<=-1,!>=2}
Line 348
  ( always {!<=-1,!>=2}
  cpp always {!<=-1,!>=2}
Line 355
  ( always {!<=-1,!>=2}
  cpp always {!<=-1,!>=2}
Line 357
  ( always {!<=-1,!>=2}
Line 359
  ( always {!<=-1,!>=2}
  , always 0
  = always 0
  nullptr always 0
Line 370
  ( always {!<=-1,!>=2}
Line 372
  ( always {!<=-1,!>=2}
Line 374
  ( always {!<=-1,!>=2}
  , always {!<=-1,!>=2}
  cpp always {!<=-1,!>=2}
Line 383
  ( possible lifetime[SubObject]=(cpp)
  cpp always {!<=-1,!>=2}
  mCpp always {!<=-1,!>=2}
  cpp always {!<=-1,!>=2}
  mValueFlowKnown always {!<=-1,!>=2}
  true always 1
Line 385
  ( always {!<=-1,!>=2}
Line 403
  ( always {!<=-1,!>=2}
Line 406
  known always {!<=-1,!>=2}
Line 411
  ( always {!<=-1,!>=2}
Line 413
  = always 0
  nullptr always 0
  = always 0
  nullptr always 0
Line 415
  ( always {!<=-1,!>=2}
Line 419
  NONE always 0
  READ always 1
  WRITE always 2
  BREAK always 3
  RETURN always 4
  BAILOUT always 5
Line 420
  ( possible lifetime[SubObject]=(type)
  nullptr always 0
Line 421
  ( possible lifetime[SubObject]=(type)
Line 426
  , always {!<=-1,!>=2}
  local always {!<=-1,!>=2}
  , always {!<=-1,!>=2}
  inInnerClass always {!<=-1,!>=2}
  , always 0
  = always 0
  0 always 0
Line 429
  ( always {!<=-1,!>=2}
Line 431
  mCpp always {!<=-1,!>=2}
Line 433
  Reassign always 0
  UnusedValue always 1
  ValueFlow always 2
Line 435
  mValueFlowKnown always {!<=-1,!>=2}
Line 438
  ( always {!<=-1,!>=2}
Line 42
  hash always !<=-1
Line 56
  NO_LINE always -1
  hash always !<=-1
  0 always 0
  thisAndNextLine always {!<=-1,!>=2}
  false always 0
  matched always {!<=-1,!>=2}
  false always 0
  checked always {!<=-1,!>=2}
  false always 0
Line 58
  this always !0
Line 60
  = always -1
  NO_LINE always -1
  hash always !<=-1
  0 always 0
  thisAndNextLine always {!<=-1,!>=2}
  false always 0
  matched always {!<=-1,!>=2}
  false always 0
  checked always {!<=-1,!>=2}
  false always 0
Line 67
  hash always !<=-1
  = always !<=-1
  . always !<=-1
  hash always !<=-1
Line 68
  thisAndNextLine always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  . always {!<=-1,!>=2}
  thisAndNextLine always {!<=-1,!>=2}
Line 69
  matched always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  . always {!<=-1,!>=2}
  matched always {!<=-1,!>=2}
Line 70
  checked always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  . always {!<=-1,!>=2}
  checked always {!<=-1,!>=2}
Line 71
  this always !0
Line 74
  ( always {!<=-1,!>=2}
Line 75
  != always {!<=-1,!>=2}
Line 76
  return always {!<=-1,!>=2}
  errorId always !symbolic=(other.errorId)
  < always {!<=-1,!>=2}
  . always !symbolic=(errorId)
Line 77
  < always {!<=-1,!>=2}
Line 78
  return always {!<=-1,!>=2}
  true always 1
Line 79
  != always {!<=-1,!>=2}
Line 80
  return always {!<=-1,!>=2}
  fileName always !symbolic=(other.fileName)
  < always {!<=-1,!>=2}
  . always !symbolic=(fileName)
Line 81
  != always {!<=-1,!>=2}
Line 82
  return always {!<=-1,!>=2}
  symbolName always !symbolic=(other.symbolName)
  < always {!<=-1,!>=2}
  . always !symbolic=(symbolName)
Line 83
  hash always !<=-1
  != always {!<=-1,!>=2}
  . always !<=-1
  hash always !<=-1
Line 84
  return always {!<=-1,!>=2}
  hash always {!<=-1,!symbolic=(other.hash)}
  < always {!<=-1,!>=2}
  . always {!<=-1,!symbolic=(hash)}
  hash always !<=-1
Line 85
  thisAndNextLine always {!<=-1,!>=2}
  != always {!<=-1,!>=2}
  . always {!<=-1,!>=2}
  thisAndNextLine always {!<=-1,!>=2}
Line 86
  return always {!<=-1,!>=2}
  thisAndNextLine always {!<=-1,!>=2,!symbolic=(other.thisAndNextLine)}
Line 87
  return always {!<=-1,!>=2}
  false always 0
Line 96
  ( always {!<=-1,!>=2}
Line 98
  ( always {!<=-1,!>=2}
Line 100
  ( always {!<=-1,!>=2}
Line 104
  ( always {!<=-1,!>=2}
Line 105
  return always {!<=-1,!>=2}
  ! {!<=-1,!>=2,0}
  fileName possible size=0
  ( {!<=-1,!>=2,1}
  && always {!<=-1,!>=2}
  fileName always !size=0
  ( always !<=-1
  "?*" always "?*"
  == always {!<=-1,!>=2}
Line 108
  ( always {!<=-1,!>=2}
Line 109
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 110
  == always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 111
  == always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 112
  == always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 113
  hash always !<=-1
  == always {!<=-1,!>=2}
  . always !<=-1
  hash always !<=-1
  && always {!<=-1,!>=2}
Line 114
  thisAndNextLine always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  . always {!<=-1,!>=2}
  thisAndNextLine always {!<=-1,!>=2}
Line 121
  hash always !<=-1
Line 122
  thisAndNextLine always {!<=-1,!>=2}
Line 123
  matched always {!<=-1,!>=2}
Line 124
  checked always {!<=-1,!>=2}
Line 126
  NO_LINE always -1
  = always -1
  -1 always -1
Line 178
  ( always {!<=-1,!>=2}
Line 185
  ( always {!<=-1,!>=2}
Line 197
  unusedFunctionChecking always {!<=-1,!>=2}
Line 203
  unusedFunctionChecking always {!<=-1,!>=2}
Line 28
  Reset always 0
  = always 0
  0 always 0
  , always 1
Line 29
  Bold always 1
  = always 1
  1 always 1
  , always 2
Line 30
  Dim always 2
  = always 2
  2 always 2
  , always 31
Line 31
  FgRed always 31
  = always 31
  31 always 31
  , always 32
Line 32
  FgGreen always 32
  = always 32
  32 always 32
  , always 34
Line 33
  FgBlue always 34
  = always 34
  34 always 34
  , always 35
Line 34
  FgMagenta always 35
  = always 35
  35 always 35
  , always 39
Line 35
  FgDefault always 39
  = always 39
  39 always 39
  , always 41
Line 36
  BgRed always 41
  = always 41
  41 always 41
  , always 42
Line 37
  BgGreen always 42
  = always 42
  42 always 42
  , always 44
Line 38
  BgBlue always 44
  = always 44
  44 always 44
  , always 49
Line 39
  BgDefault always 49
  = always 49
  49 always 49
Line 40
  457U always 457
Line 41
  476U always 476
Line 42
  676U always 676
Line 43
  682U always 682
Line 44
  825U always 825
Line 70
  fileIndex always !<=-1
  0 always 0
  0 always 0
  column always !<=-1
  0 always 0
Line 72
  column always !<=-1
Line 73
  fileIndex always !<=-1
  0 always 0
  column always !<=-1
  column always !<=-1
Line 75
  column always !<=-1
Line 76
  fileIndex always !<=-1
  0 always 0
  column always !<=-1
  column always !<=-1
Line 86
  convert always {!<=-1,!>=2}
  = always 1
  true always 1
Line 93
  convert always {!<=-1,!>=2}
  = always 1
  true always 1
Line 106
  fileIndex always !<=-1
Line 108
  column always !<=-1
Line 175
  verbose always {!<=-1,!>=2}
Line 180
  ( always {!<=-1,!>=2}
Line 190
  incomplete always {!<=-1,!>=2}
Line 197
  hash always !<=-1
Line 243
  ( always " </array>\r\n</dict>\r\n</plist>"
Line 254
  = always 0
  :: always 0
  Reset always 0
  = always 0
  0 always 0
Line 262
  = always 0
  0 always 0
Line 270
  , always !<=-1
  value always !<=-1
Line 272
  stage possible "SymbolDatabase"@73
Line 273
  ( always !<=-1
  value always !<=-1
Line 289
  ( always {!<=-1,!>=2}
Line 303
  " </array>\r\n</dict>\r\n</plist>" always " </array>\r\n</dict>\r\n</plist>"
Line 44
  >= always {!<=-1,!>=2}
  64 always 64
Line 46
  - possible >=-4611686018427387904
  1LL always 1
  << possible <=4611686018427387904
  bit {!>=64,<=63}
  - {!>=63,<=62}
  1 always 1
Line 50
  >= always {!<=-1,!>=2}
  64 always 64
Line 51
  ~ always !<=-1
  0ULL always 0
  >> always !<=-1
  1 always 1
Line 52
  1LL always 1
  << possible <=4611686018427387904
  bit {!>=64,<=63}
  - {!>=63,<=62}
  1 always 1
  - {<=4611686018427387903,!>=4611686018427387904}
  1LL always 1
Line 58
  ( always {!<=-1,!>=2}
Line 59
  return always {!<=-1,!>=2}
  >= always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  <= always {!<=-1,!>=2}
Line 62
  ( always {!<=-1,!>=2}
  value always !<=-1
Line 63
  intMax always !<=-1
  intMax always !<=-1
  = always !<=-1
Line 64
  return always {!<=-1,!>=2}
  value {!<=-1,symbolic=(MathLib::toULongNumber(tokStr))@53}
  <= always {!<=-1,!>=2}
  intMax always !<=-1
Line 67
  ( always {!<=-1,!>=2}
Line 68
  return always {!<=-1,!>=2}
  >= always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  <= always {!<=-1,!>=2}
Line 71
  ( always {!<=-1,!>=2}
  value always !<=-1
Line 72
  longMax always !<=-1
  longMax always !<=-1
  = always !<=-1
Line 73
  return always {!<=-1,!>=2}
  value {!<=-1,symbolic=(MathLib::toULongNumber(tokStr))@55}
  <= always {!<=-1,!>=2}
  longMax always !<=-1
Line 76
  ( always {!<=-1,!>=2}
  value always !<=-1
Line 77
  longLongMax always !<=-1
  longLongMax always !<=-1
  = always !<=-1
Line 78
  return always {!<=-1,!>=2}
  value {!<=-1,symbolic=(MathLib::toULongNumber(tokStr))@57}
  <= always {!<=-1,!>=2}
  longLongMax always !<=-1
Line 103
  Unspecified always 0
Line 104
  Native always 1
Line 105
  Win32A always 2
Line 106
  Win32W always 3
Line 107
  Win64 always 4
Line 108
  Unix32 always 5
Line 109
  Unix64 always 6
Line 110
  PlatformFile always 7
Line 117
  ( always {!<=-1,!>=2}
Line 125
  ( always {!<=-1,!>=2}
Line 128
  ( always {!<=-1,!>=2}
Line 134
  ( always {!<=-1,!>=2}
Line 135
  return always {!<=-1,!>=2}
  platformType possible {3,4}
  == {!<=-1,!>=2,0}
  Win32A always 2
  || always {!<=-1,!>=2}
Line 136
  platformType {4,!2}
  == {!<=-1,!>=2,0}
  Win32W always 3
  || always {!<=-1,!>=2}
Line 137
  platformType always {!2,!3}
  == always {!<=-1,!>=2}
  Win64 always 4
Line 146
  Unspecified always 0
Line 147
  "Unspecified" always "Unspecified"
Line 148
  Native always 1
Line 149
  "Native" always "Native"
Line 150
  Win32A always 2
Line 151
  "win32A" always "win32A"
Line 152
  Win32W always 3
Line 153
  "win32W" always "win32W"
Line 154
  Win64 always 4
Line 155
  "win64" always "win64"
Line 156
  Unix32 always 5
Line 157
  "unix32" always "unix32"
Line 158
  Unix64 always 6
Line 159
  "unix64" always "unix64"
Line 160
  PlatformFile always 7
Line 161
  "platformFile" always "platformFile"
Line 163
  "unknown" always "unknown"
Line 168
  1 always 1
Line 40
  ( always {!<=-1,!>=2}
Line 41
  return always {!<=-1,!>=2}
  < always {!<=-1,!>=2}
  0 always 0
Line 54
  UNKNOWN always 0
Line 55
  MISSING always 1
Line 56
  FAILURE always 2
Line 57
  COMPILE_DB always 3
Line 58
  VS_SLN always 4
Line 59
  VS_VCXPROJ always 5
Line 60
  BORLAND always 6
Line 61
  CPPCHECK_GUI always 7
Line 66
  :: always 0
  Unspecified always 0
  msc always {!<=-1,!>=2}
  false always 0
  useMfc always {!<=-1,!>=2}
  false always 0
Line 71
  msc always {!<=-1,!>=2}
  ? possible {";_MSC_VER=1900",""}
  ";_MSC_VER=1900" always ";_MSC_VER=1900"
  : always ""
  "" always ""
  useMfc always {!<=-1,!>=2}
  ? possible {";__AFXWIN_H__=1",""}
  ";__AFXWIN_H__=1" always ";__AFXWIN_H__=1"
  : always ""
  "" always ""
Line 78
  msc always {!<=-1,!>=2}
Line 79
  useMfc always {!<=-1,!>=2}
Line 108
  , always 0
  = always 0
  nullptr always 0
Line 110
  ( always {!<=-1,!>=2}
Line 111
  ( always {!<=-1,!>=2}
Line 112
  ( always {!<=-1,!>=2}
Line 114
  ( always {!<=-1,!>=2}
Line 115
  ( always {!<=-1,!>=2}
Line 116
  ( always {!<=-1,!>=2}
Line 128
  8 always 8
  = always "project"
  "project" always "project"
Line 129
  8 always 8
  = always "version"
  "version" always "version"
Line 130
  2 always 2
  = always "1"
  "1" always "1"
Line 131
  9 always 9
  = always "builddir"
  "builddir" always "builddir"
Line 132
  14 always 14
  = always "importproject"
  "importproject" always "importproject"
Line 133
  23 always 23
  = always "analyze-all-vs-configs"
  "analyze-all-vs-configs" always "analyze-all-vs-configs"
Line 134
  7 always 7
  = always "parser"
  "parser" always "parser"
Line 135
  12 always 12
  = always "bug-hunting"
  "bug-hunting" always "bug-hunting"
Line 136
  11 always 11
  = always "includedir"
  "includedir" always "includedir"
Line 137
  4 always 4
  = always "dir"
  "dir" always "dir"
Line 138
  5 always 5
  = always "name"
  "name" always "name"
Line 139
  8 always 8
  = always "defines"
  "defines" always "defines"
Line 140
  7 always 7
  = always "define"
  "define" always "define"
Line 141
  5 always 5
  = always "name"
  "name" always "name"
Line 142
  10 always 10
  = always "undefines"
  "undefines" always "undefines"
Line 143
  9 always 9
  = always "undefine"
  "undefine" always "undefine"
Line 144
  6 always 6
  = always "paths"
  "paths" always "paths"
Line 145
  4 always 4
  = always "dir"
  "dir" always "dir"
Line 146
  5 always 5
  = always "name"
  "name" always "name"
Line 147
  5 always 5
  = always "root"
  "root" always "root"
Line 148
  5 always 5
  = always "name"
  "name" always "name"
Line 149
  7 always 7
  = always "ignore"
  "ignore" always "ignore"
Line 150
  5 always 5
  = always "path"
  "path" always "path"
Line 151
  5 always 5
  = always "name"
  "name" always "name"
Line 152
  8 always 8
  = always "exclude"
  "exclude" always "exclude"
Line 153
  5 always 5
  = always "path"
  "path" always "path"
Line 154
  5 always 5
  = always "name"
  "name" always "name"
Line 155
  19 always 19
  = always "function-contracts"
  "function-contracts" always "function-contracts"
Line 156
  19 always 19
  = always "variable-contracts"
  "variable-contracts" always "variable-contracts"
Line 157
  10 always 10
  = always "libraries"
  "libraries" always "libraries"
Line 158
  8 always 8
  = always "library"
  "library" always "library"
Line 159
  9 always 9
  = always "platform"
  "platform" always "platform"
Line 160
  13 always 13
  = always "suppressions"
  "suppressions" always "suppressions"
Line 161
  12 always 12
  = always "suppression"
  "suppression" always "suppression"
Line 162
  6 always 6
  = always "addon"
  "addon" always "addon"
Line 163
  7 always 7
  = always "addons"
  "addons" always "addons"
Line 164
  5 always 5
  = always "tool"
  "tool" always "tool"
Line 165
  6 always 6
  = always "tools"
  "tools" always "tools"
Line 166
  5 always 5
  = always "tags"
  "tags" always "tags"
Line 167
  4 always 4
  = always "tag"
  "tag" always "tag"
Line 168
  13 always 13
  = always "tag-warnings"
  "tag-warnings" always "tag-warnings"
Line 169
  4 always 4
  = always "tag"
  "tag" always "tag"
Line 170
  8 always 8
  = always "warning"
  "warning" always "warning"
Line 171
  5 always 5
  = always "hash"
  "hash" always "hash"
Line 172
  14 always 14
  = always "check-headers"
  "check-headers" always "check-headers"
Line 173
  23 always 23
  = always "check-unused-templates"
  "check-unused-templates" always "check-unused-templates"
Line 174
  14 always 14
  = always "max-ctu-depth"
  "max-ctu-depth" always "max-ctu-depth"
Line 175
  23 always 23
  = always "max-template-recursion"
  "max-template-recursion" always "max-template-recursion"
Line 176
  37 always 37
  = always "check-unknown-function-return-values"
  "check-unknown-function-return-values" always "check-unknown-function-return-values"
Line 177
  11 always 11
  = always "clang-tidy"
  "clang-tidy" always "clang-tidy"
Line 178
  5 always 5
  = always "name"
  "name" always "name"
Line 179
  18 always 18
  = always "vs-configurations"
  "vs-configurations" always "vs-configurations"
Line 180
  7 always 7
  = always "config"
  "config" always "config"
Line 30
  SHOWTIME_NONE always 0
  = always 0
  0 always 0
  , always 1
Line 31
  SHOWTIME_FILE always 1
  , always 2
Line 32
  SHOWTIME_SUMMARY always 2
  , always 3
Line 33
  SHOWTIME_TOP5 always 3
Line 40
  = always 0
  0 always 0
Line 48
  0 always 0
Line 49
  0 always 0
Line 52
  ( always !<=-1
  ( always !<=-1
Line 70
  , always 0
  = always 0
  nullptr always 0
Line 82
  mStopped always {!<=-1,!>=2}
Line 114
  checkAllConfigurations always {!<=-1,!>=2}
Line 117
  checkConfiguration always {!<=-1,!>=2}
Line 122
  checkHeaders always {!<=-1,!>=2}
Line 125
  checkLibrary always {!<=-1,!>=2}
Line 131
  checkUnusedTemplates always {!<=-1,!>=2}
Line 134
  clang always {!<=-1,!>=2}
Line 140
  clangTidy always {!<=-1,!>=2}
Line 152
  daca always {!<=-1,!>=2}
Line 155
  debugnormal always {!<=-1,!>=2}
Line 158
  debugSimplified always {!<=-1,!>=2}
Line 161
  debugtemplate always {!<=-1,!>=2}
Line 164
  debugwarnings always {!<=-1,!>=2}
Line 167
  dump always {!<=-1,!>=2}
Line 171
  None always 0
  C always 1
  CPP always 2
Line 178
  exceptionHandling always {!<=-1,!>=2}
Line 191
  force always {!<=-1,!>=2}
Line 198
  inlineSuppressions always {!<=-1,!>=2}
Line 202
  jobs always !<=-1
Line 207
  jointSuppressionReport always {!<=-1,!>=2}
Line 243
  preprocessOnly always {!<=-1,!>=2}
Line 248
  quiet always {!<=-1,!>=2}
Line 251
  relativePaths always {!<=-1,!>=2}
Line 254
  reportProgress always {!<=-1,!>=2}
Line 260
  "simple" always "simple"
Line 261
  "rule" always "rule"
Line 262
  :: always 3
  style always 3
Line 280
  classes always {!<=-1,!>=2}
  false always 0
  externalFunctions always {!<=-1,!>=2}
  false always 0
  internalFunctions always {!<=-1,!>=2}
  false always 0
  externalVariables always {!<=-1,!>=2}
  false always 0
Line 289
  classes always {!<=-1,!>=2}
  = always 0
  externalFunctions always {!<=-1,!>=2}
  = always 0
  internalFunctions always {!<=-1,!>=2}
  = always 0
  externalVariables always {!<=-1,!>=2}
  = always 0
  false always 0
Line 298
  classes always {!<=-1,!>=2}
Line 305
  externalFunctions always {!<=-1,!>=2}
Line 311
  internalFunctions always {!<=-1,!>=2}
Line 317
  externalVariables always {!<=-1,!>=2}
Line 350
  verbose always {!<=-1,!>=2}
Line 353
  xml always {!<=-1,!>=2}
Line 362
  ( always {!<=-1,!>=2}
Line 364
  ( always !<=-1
  >= always {!<=-1,!>=2}
  ( always !<=-1
  && always {!<=-1,!>=2}
  0 always 0
  ( {!<=-1,<=symbolic=(file.length()),!>=symbolic=(file.length()+1)}
  == always {!<=-1,!>=2}
  0 always 0
Line 365
  return always {!<=-1,!>=2}
  true always 1
Line 368
  return always {!<=-1,!>=2}
  false always 0
Line 383
  ( always {!<=-1,!>=2}
  , always 0
  inconclusiveCheck always {!<=-1,!>=2}
  = always 0
  false always 0
Line 386
  ( always {!<=-1,!>=2}
Line 387
  return always {!<=-1,!>=2}
  ( possible lifetime[Iterator]=(libraries)
  ( {lifetime[Iterator]=(libraries),start=0}
  ( {lifetime[Iterator]=(libraries),end=0}
  "posix" always "posix"
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(libraries),end=0}
Line 391
  t always {!<=-1,!>=2}
  = always 1
  true always 1
Line 392
  = always {!<=-1,!>=2}
  t always {!<=-1,!>=2}
Line 396
  ( always {!<=-1,!>=2}
Line 397
  return always {!<=-1,!>=2}
Line 58
  ( always {!<=-1,!>=2}
Line 59
  return always {!<=-1,!>=2}
  mIsC always {!<=-1,!>=2}
Line 63
  ( always {!<=-1,!>=2}
Line 64
  return always {!<=-1,!>=2}
  mIsCpp always {!<=-1,!>=2}
Line 73
  , always 0
  split always {!<=-1,!>=2}
  = always 0
  false always 0
Line 90
  , always 1
  one_line always {!<=-1,!>=2}
  = always 1
  true always 1
Line 101
  ( always {!<=-1,!>=2}
Line 103
  && always {!<=-1,!>=2}
Line 156
  ( always !<=-1
Line 175
  ( always {!<=-1,!>=2}
Line 192
  ( always {!<=-1,!>=2}
Line 219
  mIsC always {!<=-1,!>=2}
Line 220
  mIsCpp always {!<=-1,!>=2}
Line 71
  ( always {!<=-1,!>=2}
Line 73
  ( always {!<=-1,!>=2}
Line 75
  return possible lifetime[Iterator]=(mVariableId)
  ( possible lifetime[Iterator]=(mVariableId)
Line 77
  ( always end=0
Line 78
  return possible lifetime[Iterator]=(mVariableId)
  ( {lifetime[Iterator]=(mVariableId),end=0}
Line 84
  & {lifetime[Address]=(mVarId),!0}
Line 99
  ( always {!<=-1,!>=2}
Line 100
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 104
  ( always {!<=-1,!>=2}
Line 105
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 114
  ( always {!<=-1,!>=2}
  , always 0
  = always 0
  nullptr always 0
Line 116
  ( always {!<=-1,!>=2}
Line 117
  && always {!<=-1,!>=2}
Line 119
  ( always {!<=-1,!>=2}
Line 141
  ( always {!<=-1,!>=2}
Line 159
  ( always {!<=-1,!>=2}
Line 167
  ( always {!<=-1,!>=2}
Line 185
  check always {!<=-1,!>=2}
Line 218
  ( always {!<=-1,!>=2}
Line 232
  ( always {!<=-1,!>=2}
Line 292
  ( always {!<=-1,!>=2}
Line 298
  only_k_r_fpar always {!<=-1,!>=2}
Line 299
  , always {!<=-1,!>=2}
  only_k_r_fpar always {!<=-1,!>=2}
Line 314
  ( always {!<=-1,!>=2}
Line 351
  ( always {!<=-1,!>=2}
Line 364
  ( always {!<=-1,!>=2}
Line 380
  , always {!<=-1,!>=2}
  commandWithCondition always {!<=-1,!>=2}
Line 397
  ( always {!<=-1,!>=2}
Line 401
  ( always {!<=-1,!>=2}
Line 420
  ( always {!<=-1,!>=2}
Line 426
  ( always {!<=-1,!>=2}
  valueIsPointer always {!<=-1,!>=2}
  , always {!<=-1,!>=2}
  floatvar always {!<=-1,!>=2}
Line 432
  ( always {!<=-1,!>=2}
  , always {!<=-1,!>=2}
  valueIsPointer always {!<=-1,!>=2}
Line 455
  ( always {!<=-1,!>=2}
Line 462
  ( always {!<=-1,!>=2}
Line 480
  ( always {!<=-1,!>=2}
Line 497
  ( always {!<=-1,!>=2}
Line 582
  , always {!<=-1,!>=2}
  cpp always {!<=-1,!>=2}
Line 591
  ( always {!<=-1,!>=2}
Line 640
  , always ""
  = always ""
  "" always ""
Line 680
  ( always {!<=-1,!>=2}
  , always {!<=-1,!>=2}
  allowSemicolon always {!<=-1,!>=2}
Line 786
  ( always {!<=-1,!>=2}
Line 813
  , always 0
  inconclusive always {!<=-1,!>=2}
  = always 0
  false always 0
Line 814
  , always 0
  inconclusive always {!<=-1,!>=2}
  = always 0
  false always 0
Line 816
  ( always {!<=-1,!>=2}
Line 850
  ( always {!<=-1,!>=2}
Line 855
  ( always {!<=-1,!>=2}
Line 856
  return always {!<=-1,!>=2}
  mCodeWithTemplates always {!<=-1,!>=2}
Line 904
  ( always {!<=-1,!>=2}
Line 911
  ( always {!<=-1,!>=2}
Line 918
  ( always {!<=-1,!>=2}
Line 932
  ( always {!<=-1,!>=2}
Line 933
  return always {!<=-1,!>=2}
  false always 0
Line 950
  , always {!<=-1,!>=2}
  inOperator always {!<=-1,!>=2}
Line 986
  used always {!<=-1,!>=2}
Line 1000
  mCodeWithTemplates always {!<=-1,!>=2}
Line 51
  tokenizer inconclusive 0
Line 53
  ! always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  tokenizer always !0
Line 56
  mIsCpp always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 58
  . possible {83,117,85}
  == {!<=-1,!>=2,0}
  's' always 115
  || {!<=-1,!>=2,0}
  . {117,85,!115}
  == {!<=-1,!>=2,0}
  'S' always 83
Line 59
  = always 1
  :: always 1
  SIGNED always 1
Line 60
  . {85,!115,!83}
  == {!<=-1,!>=2,0}
  'u' always 117
  || always {!<=-1,!>=2}
  . always {!115,!83,!117}
  == always {!<=-1,!>=2}
  'U' always 85
Line 61
  = always 2
  :: always 2
  UNSIGNED always 2
Line 63
  = always 0
  :: always 0
  UNKNOWN_SIGN always 0
Line 76
  false always 0
Line 78
  true always 1
Line 80
  false always 0
Line 89
  ( always {!<=-1,!>=2}
  tok possible symbolic=(classDef)@40
  ":: %name%" always ":: %name%"
Line 91
  ( always {!<=-1,!>=2}
  "%name% ::" always "%name% ::"
  || always {!<=-1,!>=2}
Line 92
  ( always {!<=-1,!>=2}
  "%name% <" always "%name% <"
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  1 always 1
  ">|>> ::" always ">|>> ::"
Line 93
  1 always 1
  == always {!<=-1,!>=2}
  "::" always "::"
Line 94
  2 always 2
Line 96
  1 always 1
  2 always 2
Line 102
  ( always {!<=-1,!>=2}
Line 104
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "{" always "{"
Line 105
  return always {!<=-1,!>=2}
  false always 0
Line 107
  ( always {!<=-1,!>=2}
  tok2 {symbolic=(tok->link()->previous()),symbolic=(tok)}
  "; }" always "; }"
Line 108
  return always {!<=-1,!>=2}
  true always 1
Line 109
  tok2 always symbolic=(tok->link()->previous())
  == always {!<=-1,!>=2}
Line 110
  return always {!<=-1,!>=2}
  false always 0
Line 111
  ( always {!<=-1,!>=2}
  tok2 always !symbolic=(tok)
  "} }" always "} }"
Line 112
  tok2 always !symbolic=(tok)
Line 113
  ( always {!<=-1,!>=2}
  startTok always symbolic=(tok2->link())
  "do|try|else {" always "do|try|else {"
Line 114
  return always {!<=-1,!>=2}
  true always 1
Line 115
  ( always {!<=-1,!>=2}
  startTok always symbolic=(tok2->link())
  ")|] {" always ")|] {"
Line 116
  return always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  tok2 always !symbolic=(tok)
Line 117
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 119
  return always {!<=-1,!>=2}
  false always 0
Line 125
  this always !0
  nullptr always 0
  nullptr always 0
Line 128
  = {lifetime[Object]=(scopeList),!0}
  & {lifetime[Object]=(scopeList),!0}
  scopeList always !size=0
Line 132
  = possible lifetime[Lambda]=(endInitList)
  [ possible lifetime[Lambda]=(endInitList)
Line 133
  ( always {!<=-1,!>=2}
Line 134
  false always 0
Line 135
  == always {!<=-1,!>=2}
  scope possible lifetime[Object]=(scopeList)
Line 142
  = possible 0
  tok possible {symbolic=(tok2),symbolic=(tok2),symbolic=(tok2),symbolic=(tok2),symbolic=(endTok),symbolic=(tok2)}
  ? possible 0
  : always 0
  nullptr always 0
Line 146
  "SymbolDatabase" always "SymbolDatabase"
Line 149
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 150
  ( always {!<=-1,!>=2}
  "class|struct|union|namespace ::| %name% final| {|:|::|<" always "class|struct|union|namespace ::| %name% final| {|:|::|<"
  && always {!<=-1,!>=2}
Line 151
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "new|friend|const|enum|typedef|mutable|volatile|using|)|(|<" always "new|friend|const|enum|typedef|mutable|volatile|using|)|(|<"
  || always {!<=-1,!>=2}
Line 152
  ( always {!<=-1,!>=2}
  "enum class| %name% {" always "enum class| %name% {"
  || always {!<=-1,!>=2}
Line 153
  ( always {!<=-1,!>=2}
  "enum class| %name% : %name% {" always "enum class| %name% : %name% {"
Line 154
  || always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "struct|union|enum %name% {" always "struct|union|enum %name% {"
Line 155
  2 always 2
Line 157
  1 always 1
  == always {!<=-1,!>=2}
  "::" always "::"
Line 159
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  1 always 1
  == always {!<=-1,!>=2}
  "class" always "class"
Line 162
  ( always {!<=-1,!>=2}
  ":: %name%" always ":: %name%"
Line 163
  2 always 2
Line 164
  ( always {!<=-1,!>=2}
  "%name% :: %name%" always "%name% :: %name%"
Line 165
  2 always 2
Line 168
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  "<" always "<"
  && always {!<=-1,!>=2}
Line 170
  ( always {!<=-1,!>=2}
  ":: %name%" always ":: %name%"
Line 171
  2 always 2
Line 175
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "final" always "final"
Line 179
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "{|:" always "{|:"
Line 181
  && always {!<=-1,!>=2}
Line 182
  == always {!<=-1,!>=2}
  ";" always ";"
Line 184
  ( always {!<=-1,!>=2}
  "= {" always "= {"
  && always {!<=-1,!>=2}
Line 185
  ( always {!<=-1,!>=2}
  2 always 2
  "} ;" always "} ;"
Line 186
  2 always 2
Line 187
  ( always {!<=-1,!>=2}
  "(|{" always "(|{"
  && always {!<=-1,!>=2}
Line 188
  1 always 1
  == always {!<=-1,!>=2}
  ";" always ";"
Line 191
  ( always {!<=-1,!>=2}
  "*|&|>" always "*|&|>"
Line 193
  ( always {!<=-1,!>=2}
  "%name% (" always "%name% ("
  && always {!<=-1,!>=2}
  "{;" always "{;"
Line 195
  ( always {!<=-1,!>=2}
  "%name% [|=" always "%name% [|="
Line 198
  ( always {!<=-1,!>=2}
  ";" always ";"
  && always {!<=-1,!>=2}
Line 199
  ( always {!<=-1,!>=2}
  "template|> class|struct" always "template|> class|struct"
Line 204
  ( always {!<=-1,!>=2}
  ";" always ";"
  && always {!<=-1,!>=2}
Line 205
  ( always {!<=-1,!>=2}
  "class|struct|union" always "class|struct|union"
Line 211
  ( always {!<=-1,!>=2}
  "(" always "("
  && always {!<=-1,!>=2}
Line 212
  ( always {!<=-1,!>=2}
  ") ;" always ") ;"
Line 216
  "SymbolDatabase bailout; unhandled code" always "SymbolDatabase bailout; unhandled code"
  :: always 1
  SYNTAX always 1
Line 224
  name always symbolic=(tok->next())
  == always {!<=-1,!>=2}
  "class" always "class"
  && always {!<=-1,!>=2}
  name always symbolic=(tok->next())
  -1 always -1
  == always {!<=-1,!>=2}
  "enum" always "enum"
Line 225
  name always symbolic=(tok->next())
Line 227
  name possible symbolic=(tok->next())
  scope inconclusive lifetime[Object]=(scopeList)
Line 231
  ( always {!<=-1,!>=2}
Line 233
  ! always {!<=-1,!>=2}
Line 234
  nullptr always 0
Line 237
  ! always {!<=-1,!>=2}
Line 243
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  "class" always "class"
Line 244
  = always 2
  :: always 2
  Private always 2
Line 245
  = always 1
  :: always 1
  eClass always 1
Line 246
  == always {!<=-1,!>=2}
  "struct" always "struct"
Line 247
  = always 0
  :: always 0
  Public always 0
Line 248
  = always 2
  :: always 2
  eStruct always 2
Line 254
  ! always {!<=-1,!>=2}
Line 260
  this always !0
  scope inconclusive lifetime[Object]=(scopeList)
Line 261
  = {lifetime[Object]=(scopeList),!0}
  & {lifetime[Object]=(scopeList),!0}
  scopeList always !size=0
Line 263
  == always {!<=-1,!>=2}
  "class" always "class"
Line 264
  new_scope {lifetime[Object]=(scopeList),symbolic=(&scopeList.back())}
  = always 2
  :: always 2
  Private always 2
Line 265
  == always {!<=-1,!>=2}
  "struct" always "struct"
  || always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  "union" always "union"
Line 266
  new_scope {lifetime[Object]=(scopeList),symbolic=(&scopeList.back())}
  = always 0
  :: always 0
  Public always 0
Line 269
  new_scope {lifetime[Object]=(scopeList),symbolic=(&scopeList.back())}
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  new_scope {lifetime[Object]=(scopeList),symbolic=(&scopeList.back())}
  == always {!<=-1,!>=2}
  :: always 16
  eEnum always 16
Line 270
  scope inconclusive lifetime[Object]=(scopeList)
Line 271
  ! always {!<=-1,!>=2}
Line 272
  new_scope possible lifetime[Object]=(scopeList)
  new_scope possible lifetime[Object]=(scopeList)
  scope inconclusive lifetime[Object]=(scopeList)
Line 273
  = {lifetime[Object]=(typeList),!0}
  & {lifetime[Object]=(typeList),!0}
  typeList always !size=0
Line 274
  scope inconclusive lifetime[Object]=(scopeList)
  new_type {lifetime[Object]=(typeList),symbolic=(&typeList.back())}
  = {lifetime[Object]=(typeList),symbolic=(&typeList.back())}
  new_type {lifetime[Object]=(typeList),symbolic=(&typeList.back())}
Line 276
  = possible lifetime[Object]=(scopeList)
  new_scope possible lifetime[Object]=(scopeList)
Line 277
  new_scope inconclusive {lifetime[Object]=(scopeList),symbolic=(&scopeList.back())}
  = possible {lifetime[Object]=(typeList),symbolic=(&typeList.back())}
  new_type possible {lifetime[Object]=(typeList),symbolic=(&typeList.back())}
Line 281
  new_scope inconclusive {lifetime[Object]=(scopeList),symbolic=(&scopeList.back())}
  ( always {!<=-1,!>=2}
Line 283
  new_scope inconclusive lifetime[Object]=(scopeList)
Line 286
  ! always {!<=-1,!>=2}
Line 289
  new_scope inconclusive lifetime[Object]=(scopeList)
  == always {!<=-1,!>=2}
  :: always 16
  eEnum always 16
Line 290
  == always {!<=-1,!>=2}
  ":" always ":"
Line 291
  2 always 2
Line 294
  new_scope inconclusive {lifetime[Object]=(scopeList),symbolic=(&scopeList.back())}
Line 297
  ! always {!<=-1,!>=2}
  new_scope inconclusive {lifetime[Object]=(scopeList),symbolic=(&scopeList.back())}
Line 301
  new_scope inconclusive {lifetime[Object]=(scopeList),symbolic=(&scopeList.back())}
  == always {!<=-1,!>=2}
  :: always 16
  eEnum always 16
Line 302
  new_scope inconclusive lifetime[Object]=(scopeList)
  ( always {!<=-1,!>=2}
Line 303
  scope inconclusive lifetime[Object]=(scopeList)
  . inconclusive lifetime[Object]=(scopeList)
  new_scope inconclusive lifetime[Object]=(scopeList)
Line 305
  ! always {!<=-1,!>=2}
Line 309
  scope inconclusive lifetime[Object]=(scopeList)
  . inconclusive lifetime[Object]=(scopeList)
  new_scope inconclusive lifetime[Object]=(scopeList)
Line 310
  = inconclusive lifetime[Object]=(scopeList)
  new_scope inconclusive lifetime[Object]=(scopeList)
Line 318
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 319
  ( always {!<=-1,!>=2}
  "namespace %name% %type% (" always "namespace %name% %type% ("
  && always {!<=-1,!>=2}
Line 320
  2 always 2
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 321
  ( always {!<=-1,!>=2}
  3 always 3
  ") {" always ") {"
Line 322
  this always !0
  scope inconclusive {lifetime[Object]=(scopeList),lifetime[Object]=(scopeList),lifetime[Object]=(scopeList),lifetime[Object]=(scopeList),lifetime[Object]=(scopeList)}
Line 324
  = {lifetime[Object]=(scopeList),!0}
  & {lifetime[Object]=(scopeList),!0}
  scopeList always !size=0
Line 325
  new_scope {lifetime[Object]=(scopeList),symbolic=(&scopeList.back())}
  = always 0
  :: always 0
  Public always 0
Line 327
  3 always 3
Line 329
  new_scope {lifetime[Object]=(scopeList),symbolic=(&scopeList.back())}
Line 332
  ! always {!<=-1,!>=2}
  new_scope {lifetime[Object]=(scopeList),symbolic=(&scopeList.back())}
Line 338
  scope inconclusive lifetime[Object]=(scopeList)
  . possible lifetime[Object]=(scopeList)
  new_scope {lifetime[Object]=(scopeList),symbolic=(&scopeList.back())}
Line 339
  = {lifetime[Object]=(scopeList),!0}
  & {lifetime[Object]=(scopeList),!0}
Line 345
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "class|struct|union %name% ;" always "class|struct|union %name% ;"
  && always {!<=-1,!>=2}
Line 346
  -1 always -1
  != always {!<=-1,!>=2}
  "friend" always "friend"
Line 347
  ! always {!<=-1,!>=2}
  scope inconclusive {lifetime[Object]=(scopeList),lifetime[Object]=(scopeList),lifetime[Object]=(scopeList),lifetime[Object]=(scopeList),lifetime[Object]=(scopeList)}
Line 349
  nullptr always 0
  scope inconclusive {lifetime[Object]=(scopeList),lifetime[Object]=(scopeList),lifetime[Object]=(scopeList),lifetime[Object]=(scopeList),lifetime[Object]=(scopeList)}
Line 350
  = {lifetime[Object]=(typeList),!0}
  & {lifetime[Object]=(typeList),!0}
  typeList always !size=0
Line 351
  scope inconclusive {lifetime[Object]=(scopeList),lifetime[Object]=(scopeList),lifetime[Object]=(scopeList),lifetime[Object]=(scopeList),lifetime[Object]=(scopeList)}
  new_type {lifetime[Object]=(typeList),symbolic=(&typeList.back())}
  = {lifetime[Object]=(typeList),symbolic=(&typeList.back())}
  new_type {lifetime[Object]=(typeList),symbolic=(&typeList.back())}
Line 353
  2 always 2
Line 357
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "using namespace ::| %type% ;|::" always "using namespace ::| %type% ;|::"
Line 360
  using_info always Uninit
  start always Uninit
Line 361
  2 always 2
  scope inconclusive {lifetime[Object]=(scopeList),lifetime[Object]=(scopeList),lifetime[Object]=(scopeList),lifetime[Object]=(scopeList),lifetime[Object]=(scopeList)}
Line 363
  scope inconclusive {lifetime[Object]=(scopeList),lifetime[Object]=(scopeList),lifetime[Object]=(scopeList),lifetime[Object]=(scopeList),lifetime[Object]=(scopeList)}
Line 366
  2 always 2
  == always {!<=-1,!>=2}
  "::" always "::"
Line 367
  4 always 4
Line 369
  3 always 3
Line 372
  ( always {!<=-1,!>=2}
  "%type% ::" always "%type% ::"
Line 373
  2 always 2
Line 377
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "using %name% =" always "using %name% ="
Line 378
  -1 always -1
  != always {!<=-1,!>=2}
  ">" always ">"
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  scope inconclusive {lifetime[Object]=(scopeList),lifetime[Object]=(scopeList),lifetime[Object]=(scopeList),lifetime[Object]=(scopeList),lifetime[Object]=(scopeList)}
Line 380
  nullptr always 0
  scope inconclusive {lifetime[Object]=(scopeList),lifetime[Object]=(scopeList),lifetime[Object]=(scopeList),lifetime[Object]=(scopeList),lifetime[Object]=(scopeList)}
Line 381
  = {lifetime[Object]=(typeList),!0}
  & {lifetime[Object]=(typeList),!0}
  typeList always !size=0
Line 382
  scope inconclusive {lifetime[Object]=(scopeList),lifetime[Object]=(scopeList),lifetime[Object]=(scopeList),lifetime[Object]=(scopeList),lifetime[Object]=(scopeList)}
  new_type {lifetime[Object]=(typeList),symbolic=(&typeList.back())}
  = {lifetime[Object]=(typeList),symbolic=(&typeList.back())}
  new_type {lifetime[Object]=(typeList),symbolic=(&typeList.back())}
Line 385
  3 always 3
Line 387
  && always {!<=-1,!>=2}
  != always {!<=-1,!>=2}
  ";" always ";"
Line 392
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "struct|union {" always "struct|union {"
  && always {!<=-1,!>=2}
Line 393
  ( always {!<=-1,!>=2}
  "} *|&| %name% ;|[|=" always "} *|&| %name% ;|[|="
Line 394
  this always !0
  scope inconclusive {lifetime[Object]=(scopeList),lifetime[Object]=(scopeList),lifetime[Object]=(scopeList),lifetime[Object]=(scopeList),lifetime[Object]=(scopeList)}
Line 396
  = {lifetime[Object]=(scopeList),!0}
  & {lifetime[Object]=(scopeList),!0}
  scopeList always !size=0
Line 397
  new_scope {lifetime[Object]=(scopeList),symbolic=(&scopeList.back())}
  = always 0
  :: always 0
  Public always 0
Line 400
  varNameTok always symbolic=(tok->next()->link()->next())
  == always {!<=-1,!>=2}
  "*" always "*"
Line 401
  varNameTok always symbolic=(tok->next()->link()->next())
Line 402
  varNameTok always symbolic=(tok->next()->link()->next())
  == always {!<=-1,!>=2}
  "&" always "&"
Line 403
  varNameTok always symbolic=(tok->next()->link()->next())
Line 406
  new_scope {lifetime[Object]=(scopeList),symbolic=(&scopeList.back())}
  scope inconclusive {lifetime[Object]=(scopeList),lifetime[Object]=(scopeList),lifetime[Object]=(scopeList),lifetime[Object]=(scopeList),lifetime[Object]=(scopeList)}
Line 408
  = {lifetime[Object]=(typeList),!0}
  & {lifetime[Object]=(typeList),!0}
  typeList always !size=0
Line 409
  new_scope inconclusive {lifetime[Object]=(scopeList),symbolic=(&scopeList.back())}
  = {lifetime[Object]=(typeList),symbolic=(&typeList.back())}
  new_type {lifetime[Object]=(typeList),symbolic=(&typeList.back())}
Line 410
  scope inconclusive {lifetime[Object]=(scopeList),lifetime[Object]=(scopeList),lifetime[Object]=(scopeList),lifetime[Object]=(scopeList),lifetime[Object]=(scopeList)}
  new_type {lifetime[Object]=(typeList),symbolic=(&typeList.back())}
  = {lifetime[Object]=(typeList),symbolic=(&typeList.back())}
  new_type {lifetime[Object]=(typeList),symbolic=(&typeList.back())}
Line 413
  scope inconclusive {lifetime[Object]=(scopeList),lifetime[Object]=(scopeList),lifetime[Object]=(scopeList),lifetime[Object]=(scopeList),lifetime[Object]=(scopeList)}
  scope inconclusive {lifetime[Object]=(scopeList),lifetime[Object]=(scopeList),lifetime[Object]=(scopeList),lifetime[Object]=(scopeList),lifetime[Object]=(scopeList)}
  new_scope inconclusive {lifetime[Object]=(scopeList),symbolic=(&scopeList.back())}
  scope inconclusive {lifetime[Object]=(scopeList),lifetime[Object]=(scopeList),lifetime[Object]=(scopeList),lifetime[Object]=(scopeList),lifetime[Object]=(scopeList)}
Line 417
  new_scope inconclusive {lifetime[Object]=(scopeList),symbolic=(&scopeList.back())}
  tok2 always symbolic=(tok->next())
Line 420
  ! always {!<=-1,!>=2}
  new_scope inconclusive {lifetime[Object]=(scopeList),symbolic=(&scopeList.back())}
Line 426
  scope inconclusive lifetime[Object]=(scopeList)
  . inconclusive lifetime[Object]=(scopeList)
  new_scope inconclusive {lifetime[Object]=(scopeList),symbolic=(&scopeList.back())}
Line 427
  = inconclusive {lifetime[Object]=(scopeList),symbolic=(&scopeList.back())}
  new_scope inconclusive {lifetime[Object]=(scopeList),symbolic=(&scopeList.back())}
Line 429
  = always symbolic=(tok->next())
  tok2 always symbolic=(tok->next())
Line 433
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "struct|union {" always "struct|union {"
  && always {!<=-1,!>=2}
Line 434
  ( always {!<=-1,!>=2}
  "} ;" always "} ;"
  || always {!<=-1,!>=2}
Line 435
  ( always {!<=-1,!>=2}
  "namespace {" always "namespace {"
Line 436
  this always !0
  scope inconclusive {lifetime[Object]=(scopeList),lifetime[Object]=(scopeList),lifetime[Object]=(scopeList),lifetime[Object]=(scopeList),lifetime[Object]=(scopeList)}
Line 438
  = {lifetime[Object]=(scopeList),!0}
  & {lifetime[Object]=(scopeList),!0}
  scopeList always !size=0
Line 439
  new_scope {lifetime[Object]=(scopeList),symbolic=(&scopeList.back())}
  = always 0
  :: always 0
  Public always 0
Line 443
  new_scope {lifetime[Object]=(scopeList),symbolic=(&scopeList.back())}
  tok2 always symbolic=(tok->next())
Line 445
  new_scope {lifetime[Object]=(scopeList),symbolic=(&scopeList.back())}
  scope inconclusive {lifetime[Object]=(scopeList),lifetime[Object]=(scopeList),lifetime[Object]=(scopeList),lifetime[Object]=(scopeList),lifetime[Object]=(scopeList)}
Line 447
  = {lifetime[Object]=(typeList),!0}
  & {lifetime[Object]=(typeList),!0}
  typeList always !size=0
Line 448
  new_scope inconclusive {lifetime[Object]=(scopeList),symbolic=(&scopeList.back())}
  = {lifetime[Object]=(typeList),symbolic=(&typeList.back())}
  new_type {lifetime[Object]=(typeList),symbolic=(&typeList.back())}
Line 449
  scope inconclusive {lifetime[Object]=(scopeList),lifetime[Object]=(scopeList),lifetime[Object]=(scopeList),lifetime[Object]=(scopeList),lifetime[Object]=(scopeList)}
  new_type {lifetime[Object]=(typeList),symbolic=(&typeList.back())}
  = {lifetime[Object]=(typeList),symbolic=(&typeList.back())}
  new_type {lifetime[Object]=(typeList),symbolic=(&typeList.back())}
Line 453
  ! always {!<=-1,!>=2}
  new_scope inconclusive {lifetime[Object]=(scopeList),symbolic=(&scopeList.back())}
Line 459
  scope inconclusive lifetime[Object]=(scopeList)
  . inconclusive lifetime[Object]=(scopeList)
  new_scope inconclusive {lifetime[Object]=(scopeList),symbolic=(&scopeList.back())}
Line 460
  = inconclusive {lifetime[Object]=(scopeList),symbolic=(&scopeList.back())}
  new_scope inconclusive {lifetime[Object]=(scopeList),symbolic=(&scopeList.back())}
Line 466
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "enum class| %name% ;" always "enum class| %name% ;"
  || always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "enum class| %name% : %name% ;" always "enum class| %name% : %name% ;"
Line 467
  nullptr always 0
  scope inconclusive {lifetime[Object]=(scopeList),lifetime[Object]=(scopeList),lifetime[Object]=(scopeList),lifetime[Object]=(scopeList),lifetime[Object]=(scopeList)}
Line 468
  = {lifetime[Object]=(typeList),!0}
  & {lifetime[Object]=(typeList),!0}
  typeList always !size=0
Line 469
  scope inconclusive {lifetime[Object]=(scopeList),lifetime[Object]=(scopeList),lifetime[Object]=(scopeList),lifetime[Object]=(scopeList),lifetime[Object]=(scopeList)}
  new_type {lifetime[Object]=(typeList),symbolic=(&typeList.back())}
  = {lifetime[Object]=(typeList),symbolic=(&typeList.back())}
  new_type {lifetime[Object]=(typeList),symbolic=(&typeList.back())}
Line 470
  2 always 2
Line 474
  == always {!<=-1,!>=2}
  scope inconclusive {lifetime[Object]=(scopeList),lifetime[Object]=(scopeList),lifetime[Object]=(scopeList),lifetime[Object]=(scopeList),lifetime[Object]=(scopeList)}
Line 475
  scope inconclusive {lifetime[Object]=(scopeList),lifetime[Object]=(scopeList),lifetime[Object]=(scopeList),lifetime[Object]=(scopeList),lifetime[Object]=(scopeList)}
Line 476
  scope inconclusive {lifetime[Object]=(scopeList),lifetime[Object]=(scopeList),lifetime[Object]=(scopeList),lifetime[Object]=(scopeList),lifetime[Object]=(scopeList)}
Line 480
  inInitList possible lifetime[Lambda]=(endInitList)
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
Line 486
  scope inconclusive {lifetime[Object]=(scopeList),lifetime[Object]=(scopeList),lifetime[Object]=(scopeList),lifetime[Object]=(scopeList),lifetime[Object]=(scopeList)}
  ( always {!<=-1,!>=2}
Line 487
  = always 0
  nullptr always 0
Line 488
  = always 0
  nullptr always 0
Line 489
  = always 0
  nullptr always 0
Line 492
  == always {!<=-1,!>=2}
  "private:" always "private:"
Line 493
  scope inconclusive {lifetime[Object]=(scopeList),lifetime[Object]=(scopeList)}
  = always 2
  :: always 2
  Private always 2
Line 494
  == always {!<=-1,!>=2}
  "protected:" always "protected:"
Line 495
  scope inconclusive {lifetime[Object]=(scopeList),lifetime[Object]=(scopeList)}
  = always 1
  :: always 1
  Protected always 1
Line 496
  == always {!<=-1,!>=2}
  "public:" always "public:"
  || always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  "__published:" always "__published:"
Line 497
  scope inconclusive {lifetime[Object]=(scopeList),lifetime[Object]=(scopeList)}
  = always 0
  :: always 0
  Public always 0
Line 498
  ( always {!<=-1,!>=2}
  "public|protected|private %name% :" always "public|protected|private %name% :"
Line 499
  == always {!<=-1,!>=2}
  "private" always "private"
Line 500
  scope inconclusive {lifetime[Object]=(scopeList),lifetime[Object]=(scopeList)}
  = always 2
  :: always 2
  Private always 2
Line 501
  == always {!<=-1,!>=2}
  "protected" always "protected"
Line 502
  scope inconclusive {lifetime[Object]=(scopeList),lifetime[Object]=(scopeList)}
  = always 1
  :: always 1
  Protected always 1
Line 504
  scope inconclusive {lifetime[Object]=(scopeList),lifetime[Object]=(scopeList)}
  = always 0
  :: always 0
  Public always 0
Line 506
  2 always 2
Line 510
  ( always {!<=-1,!>=2}
  scope inconclusive {lifetime[Object]=(scopeList),lifetime[Object]=(scopeList)}
  & {lifetime[Address]=(funcStart),!0}
  & {lifetime[Address]=(argStart),!0}
  & {lifetime[Address]=(declEnd),!0}
Line 511
  != always {!<=-1,!>=2}
  "::" always "::"
  || always {!<=-1,!>=2}
  -2 always -2
  == always {!<=-1,!>=2}
  scope inconclusive {lifetime[Object]=(scopeList),lifetime[Object]=(scopeList)}
Line 512
  scope inconclusive {lifetime[Object]=(scopeList),lifetime[Object]=(scopeList)}
Line 515
  scope inconclusive {lifetime[Object]=(scopeList),lifetime[Object]=(scopeList)}
Line 520
  ( always {!<=-1,!>=2}
Line 521
  scope inconclusive {lifetime[Object]=(scopeList),lifetime[Object]=(scopeList)}
Line 528
  ";" always ";"
Line 530
  scope inconclusive {lifetime[Object]=(scopeList),lifetime[Object]=(scopeList)}
Line 536
  foundInitList always {!<=-1,!>=2}
  foundInitList always {!<=-1,!>=2}
  = always 0
  false always 0
Line 537
  && always {!<=-1,!>=2}
  != always {!<=-1,!>=2}
  "{" always "{"
  && always {!<=-1,!>=2}
  != always {!<=-1,!>=2}
  ";" always ";"
Line 538
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "(|<" always "(|<"
Line 540
  foundInitList always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 541
  ( always {!<=-1,!>=2}
  "%name%|> {" always "%name%|> {"
  && always {!<=-1,!>=2}
Line 542
  ( always {!<=-1,!>=2}
  1 always 1
  "} ,|{" always "} ,|{"
Line 543
  1 always 1
Line 545
  == always {!<=-1,!>=2}
  ":" always ":"
Line 546
  foundInitList always {!<=-1,!>=2}
  = always 1
  true always 1
Line 551
  ! always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  ";" always ";"
Line 554
  scope inconclusive lifetime[Object]=(scopeList)
Line 556
  = {lifetime[Object]=(scopeList),!0}
  & {lifetime[Object]=(scopeList),!0}
  scope inconclusive lifetime[Object]=(scopeList)
Line 559
  & {lifetime[Address]=(scope),!0}
  scope inconclusive lifetime[Object]=(scopeList)
  & {lifetime[Address]=(tok2),!0}
  tok2 always symbolic=(funcStart)
Line 562
  = possible lifetime[Object]=(scopeList)
  funcptr possible lifetime[Object]=(scopeList)
Line 573
  scope inconclusive {lifetime[Object]=(scopeList),lifetime[Object]=(scopeList)}
  -2 always -2
Line 576
  & {lifetime[Address]=(scope),!0}
  scope inconclusive {lifetime[Object]=(scopeList),lifetime[Object]=(scopeList)}
  & {lifetime[Address]=(tok),!0}
Line 584
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "friend class|struct| ::| %any% ;|::" always "friend class|struct| ::| %any% ;|::"
Line 588
  1 always 1
  == always {!<=-1,!>=2}
  "class" always "class"
  2 always 2
Line 592
  == always {!<=-1,!>=2}
  "::" always "::"
Line 596
  && always {!<=-1,!>=2}
  1 always 1
  == always {!<=-1,!>=2}
  "::" always "::"
Line 597
  2 always 2
Line 600
  = always 0
  nullptr always 0
Line 602
  ! always {!<=-1,!>=2}
  scope inconclusive {lifetime[Object]=(scopeList),lifetime[Object]=(scopeList)}
Line 605
  scope inconclusive {lifetime[Object]=(scopeList),lifetime[Object]=(scopeList)}
Line 607
  scope inconclusive {lifetime[Object]=(scopeList),lifetime[Object]=(scopeList),lifetime[Object]=(scopeList),lifetime[Object]=(scopeList),lifetime[Object]=(scopeList)}
  == always {!<=-1,!>=2}
  :: always 4
  eNamespace always 4
  || always {!<=-1,!>=2}
  scope inconclusive {lifetime[Object]=(scopeList),lifetime[Object]=(scopeList),lifetime[Object]=(scopeList),lifetime[Object]=(scopeList),lifetime[Object]=(scopeList)}
  == always {!<=-1,!>=2}
  :: always 0
  eGlobal always 0
Line 608
  = always 0
  nullptr always 0
Line 609
  = always 0
  nullptr always 0
Line 610
  = always 0
  nullptr always 0
Line 613
  ( always {!<=-1,!>=2}
  scope inconclusive {lifetime[Object]=(scopeList),lifetime[Object]=(scopeList),lifetime[Object]=(scopeList),lifetime[Object]=(scopeList),lifetime[Object]=(scopeList)}
  & {lifetime[Address]=(funcStart),!0}
  & {lifetime[Address]=(argStart),!0}
  & {lifetime[Address]=(declEnd),!0}
Line 615
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  "{" always "{"
Line 619
  tok always symbolic=(funcStart)
  && always {!<=-1,!>=2}
  tok always symbolic=(funcStart)
  == always {!<=-1,!>=2}
  "::" always "::"
Line 620
  & {lifetime[Address]=(scope),!0}
  scope inconclusive {lifetime[Object]=(scopeList),lifetime[Object]=(scopeList),lifetime[Object]=(scopeList),lifetime[Object]=(scopeList),lifetime[Object]=(scopeList)}
  & {lifetime[Address]=(tok),!0}
  tok always symbolic=(funcStart)
Line 623
  tok always symbolic=(funcStart)
  && always {!<=-1,!>=2}
Line 624
  tok always symbolic=(funcStart)
  == always {!<=-1,!>=2}
  "~" always "~"
  && always {!<=-1,!>=2}
Line 625
  tok always symbolic=(funcStart)
  -2 always -2
  == always {!<=-1,!>=2}
  "::" always "::"
Line 626
  & {lifetime[Address]=(scope),!0}
  scope inconclusive {lifetime[Object]=(scopeList),lifetime[Object]=(scopeList),lifetime[Object]=(scopeList),lifetime[Object]=(scopeList),lifetime[Object]=(scopeList)}
  & {lifetime[Address]=(tok),!0}
  tok always symbolic=(funcStart)
Line 630
  scope inconclusive {lifetime[Object]=(scopeList),lifetime[Object]=(scopeList),lifetime[Object]=(scopeList),lifetime[Object]=(scopeList),lifetime[Object]=(scopeList)}
  tok always symbolic=(funcStart)
Line 632
  ! always {!<=-1,!>=2}
Line 637
  ! always {!<=-1,!>=2}
Line 641
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  ";" always ";"
Line 642
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  "::" always "::"
  && always {!<=-1,!>=2}
Line 643
  ( always {!<=-1,!>=2}
  "default|delete" always "default|delete"
Line 644
  & {lifetime[Address]=(scope),!0}
  scope inconclusive {lifetime[Object]=(scopeList),lifetime[Object]=(scopeList),lifetime[Object]=(scopeList),lifetime[Object]=(scopeList),lifetime[Object]=(scopeList)}
  & {lifetime[Address]=(tok),!0}
Line 648
  newFunc always {!<=-1,!>=2}
  newFunc always {!<=-1,!>=2}
  = always 1
  true always 1
Line 649
  = possible {lifetime[Iterator]=(scope->functionMap),lifetime[Object]=(scopeList)}
  scope inconclusive lifetime[Object]=(scopeList)
  ( possible {lifetime[Iterator]=(scope->functionMap),lifetime[Object]=(scopeList)}
  i possible {lifetime[Iterator]=(scope->functionMap),lifetime[Object]=(scopeList)}
  != always {!<=-1,!>=2}
  scope inconclusive lifetime[Object]=(scopeList)
  ( {lifetime[Iterator]=(scope->functionMap),lifetime[Object]=(scopeList),end=0}
  && always {!<=-1,!>=2}
  i possible {lifetime[Iterator]=(scope->functionMap),lifetime[Object]=(scopeList)}
  == always {!<=-1,!>=2}
Line 650
  scope inconclusive lifetime[Object]=(scopeList)
  i possible {lifetime[Iterator]=(scope->functionMap),lifetime[Object]=(scopeList)}
  0 always 0
Line 651
  newFunc always {!<=-1,!>=2}
  = always 0
  false always 0
Line 657
  newFunc always {!<=-1,!>=2}
Line 665
  scope inconclusive {lifetime[Object]=(scopeList),lifetime[Object]=(scopeList),lifetime[Object]=(scopeList),lifetime[Object]=(scopeList),lifetime[Object]=(scopeList)}
  ( always {!<=-1,!>=2}
Line 666
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "else|try|do {" always "else|try|do {"
Line 668
  == always {!<=-1,!>=2}
  "else" always "else"
Line 669
  this always !0
  scope inconclusive {lifetime[Object]=(scopeList),lifetime[Object]=(scopeList),lifetime[Object]=(scopeList),lifetime[Object]=(scopeList),lifetime[Object]=(scopeList)}
  :: always 7
  eElse always 7
Line 670
  == always {!<=-1,!>=2}
  "do" always "do"
Line 671
  this always !0
  scope inconclusive {lifetime[Object]=(scopeList),lifetime[Object]=(scopeList),lifetime[Object]=(scopeList),lifetime[Object]=(scopeList),lifetime[Object]=(scopeList)}
  :: always 10
  eDo always 10
Line 673
  this always !0
  scope inconclusive {lifetime[Object]=(scopeList),lifetime[Object]=(scopeList),lifetime[Object]=(scopeList),lifetime[Object]=(scopeList),lifetime[Object]=(scopeList)}
  :: always 13
  eTry always 13
Line 676
  . possible lifetime[Object]=(scopeList)
  & {lifetime[Object]=(scopeList),!0}
Line 677
  = {lifetime[Object]=(scopeList),!0}
  & {lifetime[Object]=(scopeList),!0}
Line 678
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "if|for|while|catch|switch (" always "if|for|while|catch|switch ("
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  ") {" always ") {"
Line 680
  == always {!<=-1,!>=2}
  "if" always "if"
Line 681
  this always !0
  scope inconclusive {lifetime[Object]=(scopeList),lifetime[Object]=(scopeList),lifetime[Object]=(scopeList),lifetime[Object]=(scopeList),lifetime[Object]=(scopeList)}
  :: always 6
  eIf always 6
Line 682
  == always {!<=-1,!>=2}
  "for" always "for"
Line 683
  this always !0
  scope inconclusive {lifetime[Object]=(scopeList),lifetime[Object]=(scopeList),lifetime[Object]=(scopeList),lifetime[Object]=(scopeList),lifetime[Object]=(scopeList)}
  :: always 8
  eFor always 8
Line 684
  == always {!<=-1,!>=2}
  "while" always "while"
Line 685
  this always !0
  scope inconclusive {lifetime[Object]=(scopeList),lifetime[Object]=(scopeList),lifetime[Object]=(scopeList),lifetime[Object]=(scopeList),lifetime[Object]=(scopeList)}
  :: always 9
  eWhile always 9
Line 686
  == always {!<=-1,!>=2}
  "catch" always "catch"
Line 687
  this always !0
  scope inconclusive {lifetime[Object]=(scopeList),lifetime[Object]=(scopeList),lifetime[Object]=(scopeList),lifetime[Object]=(scopeList),lifetime[Object]=(scopeList)}
  :: always 14
  eCatch always 14
Line 689
  this always !0
  scope inconclusive {lifetime[Object]=(scopeList),lifetime[Object]=(scopeList),lifetime[Object]=(scopeList),lifetime[Object]=(scopeList),lifetime[Object]=(scopeList)}
  :: always 11
  eSwitch always 11
Line 691
  . possible lifetime[Object]=(scopeList)
  & {lifetime[Object]=(scopeList),!0}
Line 692
  = {lifetime[Object]=(scopeList),!0}
  & {lifetime[Object]=(scopeList),!0}
Line 693
  scope {lifetime[Object]=(scopeList),symbolic=(&scopeList.back())}
  == always {!<=-1,!>=2}
  :: always 8
  eFor always 8
Line 694
  scope {lifetime[Object]=(scopeList),symbolic=(&scopeList.back())}
  2 always 2
Line 695
  scope {lifetime[Object]=(scopeList),symbolic=(&scopeList.back())}
  == always {!<=-1,!>=2}
  :: always 14
  eCatch always 14
Line 696
  scope {lifetime[Object]=(scopeList),symbolic=(&scopeList.back())}
  2 always 2
  :: always 7
  Throw always 7
Line 698
  ( always {!<=-1,!>=2}
  "%var% {" always "%var% {"
Line 699
  endInitList inconclusive {lifetime[Object]=(scopeList),lifetime[Object]=(scopeList),lifetime[Object]=(scopeList),lifetime[Object]=(scopeList),lifetime[Object]=(scopeList)}
  ( inconclusive {lifetime[Object]=(scopeList),lifetime[Object]=(scopeList),lifetime[Object]=(scopeList),lifetime[Object]=(scopeList),lifetime[Object]=(scopeList)}
  scope inconclusive {lifetime[Object]=(scopeList),lifetime[Object]=(scopeList),lifetime[Object]=(scopeList),lifetime[Object]=(scopeList),lifetime[Object]=(scopeList)}
Line 703
  lambdaStartToken always symbolic=(lambdaEndToken->link())
Line 704
  ( always {!<=-1,!>=2}
  argStart always symbolic=(lambdaStartToken->astParent())
  "[" always "["
  argStart always symbolic=(lambdaStartToken->astParent())
  : always symbolic=(lambdaStartToken->astParent())
  argStart always symbolic=(lambdaStartToken->astParent())
Line 705
  scope inconclusive {lifetime[Object]=(scopeList),lifetime[Object]=(scopeList),lifetime[Object]=(scopeList),lifetime[Object]=(scopeList),lifetime[Object]=(scopeList)}
  argStart always symbolic=(lambdaStartToken->astParent())
Line 706
  ! always {!<=-1,!>=2}
Line 708
  = always symbolic=(lambdaEndToken->link())
  lambdaStartToken always symbolic=(lambdaEndToken->link())
Line 709
  == always {!<=-1,!>=2}
  "{" always "{"
Line 710
  inInitList possible lifetime[Lambda]=(endInitList)
Line 711
  endInitList inconclusive {lifetime[Object]=(scopeList),lifetime[Object]=(scopeList),lifetime[Object]=(scopeList),lifetime[Object]=(scopeList)}
  ( inconclusive {lifetime[Object]=(scopeList),lifetime[Object]=(scopeList),lifetime[Object]=(scopeList),lifetime[Object]=(scopeList)}
  scope inconclusive {lifetime[Object]=(scopeList),lifetime[Object]=(scopeList),lifetime[Object]=(scopeList),lifetime[Object]=(scopeList)}
Line 712
  ( always {!<=-1,!>=2}
Line 713
  this always !0
  scope inconclusive {lifetime[Object]=(scopeList),lifetime[Object]=(scopeList),lifetime[Object]=(scopeList),lifetime[Object]=(scopeList),lifetime[Object]=(scopeList)}
  :: always 12
  eUnconditional always 12
Line 714
  scope inconclusive {lifetime[Object]=(scopeList),lifetime[Object]=(scopeList),lifetime[Object]=(scopeList),lifetime[Object]=(scopeList),lifetime[Object]=(scopeList)}
  . possible lifetime[Object]=(scopeList)
  & {lifetime[Object]=(scopeList),!0}
Line 715
  = {lifetime[Object]=(scopeList),!0}
  & {lifetime[Object]=(scopeList),!0}
Line 716
  scope inconclusive {lifetime[Object]=(scopeList),lifetime[Object]=(scopeList),lifetime[Object]=(scopeList),lifetime[Object]=(scopeList),lifetime[Object]=(scopeList)}
  ( always {!<=-1,!>=2}
Line 717
  endInitList inconclusive {lifetime[Object]=(scopeList),lifetime[Object]=(scopeList),lifetime[Object]=(scopeList),lifetime[Object]=(scopeList),lifetime[Object]=(scopeList)}
  ( inconclusive {lifetime[Object]=(scopeList),lifetime[Object]=(scopeList),lifetime[Object]=(scopeList),lifetime[Object]=(scopeList),lifetime[Object]=(scopeList)}
  scope inconclusive {lifetime[Object]=(scopeList),lifetime[Object]=(scopeList),lifetime[Object]=(scopeList),lifetime[Object]=(scopeList),lifetime[Object]=(scopeList)}
Line 723
  ! always {!<=-1,!>=2}
  scope possible {lifetime[Object]=(scopeList),lifetime[Object]=(scopeList),lifetime[Object]=(scopeList),symbolic=(&scopeList.back())}
Line 726
  == always {!<=-1,!>=2}
  "}" always "}"
Line 734
  ( always {!<=-1,!>=2}
Line 741
  == always {!<=-1,!>=2}
  nullptr always 0
Line 743
  2 always 2
  & {lifetime[Address]=(scopeList),!0}
Line 746
  = always !0
  found always !0
Line 757
  true always 1
Line 758
  && always {!<=-1,!>=2}
  found always !0
  ( always {!<=-1,!>=2}
  & {lifetime[Address]=(typeList),!0}
Line 762
  = possible 0
  found possible 0
Line 788
  = {lifetime[Iterator]=(scope.functionList),lifetime[Object]=(functionList),start=0}
  ( {lifetime[Iterator]=(scope.functionList),lifetime[Object]=(functionList),start=0}
  func possible {lifetime[Iterator]=(scope.functionList),lifetime[Object]=(functionList),start=0}
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(scope.functionList),lifetime[Object]=(functionList),end=0}
Line 790
  func possible {lifetime[Iterator]=(scope.functionList),lifetime[Object]=(functionList)}
  this always !0
  & {lifetime[Address]=(scopeList),!0}
Line 799
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 803
  = {lifetime[Iterator]=(scope.functionList),lifetime[Object]=(functionList),start=0}
  ( {lifetime[Iterator]=(scope.functionList),lifetime[Object]=(functionList),start=0}
  func possible {lifetime[Iterator]=(scope.functionList),lifetime[Object]=(functionList),start=0}
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(scope.functionList),lifetime[Object]=(functionList),end=0}
Line 804
  ! always {!<=-1,!>=2}
  func {lifetime[Iterator]=(scope.functionList),lifetime[Object]=(functionList),!symbolic=(scope.functionList.end()),!end=0}
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  func {lifetime[Iterator]=(scope.functionList),lifetime[Object]=(functionList),!symbolic=(scope.functionList.end()),!end=0}
  ( always !<=-1
  != always {!<=-1,!>=2}
  1 always 1
Line 807
  0 always 0
Line 808
  == always {!<=-1,!>=2}
Line 809
  ( always {!<=-1,!>=2}
Line 810
  = always 2
  :: always 2
  eMoveConstructor always 2
Line 811
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 812
  = always 1
  :: always 1
  eCopyConstructor always 1
Line 815
  . possible {2,1}
  == {!<=-1,!>=2,0,1}
  :: always 1
  eCopyConstructor always 1
  || {!<=-1,!>=2,1}
Line 816
  . {2,!1}
  == {!<=-1,!>=2,1}
  :: always 2
  eMoveConstructor always 2
Line 826
  == always {!<=-1,!>=2}
  :: always 5
  eFunction always 5
Line 827
  functionScopes possible lifetime[Object]=(scopeList)
  & {lifetime[Address]=(scopeList),!0}
Line 835
  ( always {!<=-1,!>=2}
Line 836
  classAndStructScopes possible lifetime[Object]=(scopeList)
  & {lifetime[Address]=(scopeList),!0}
Line 846
  = {lifetime[Iterator]=(scope.functionList),lifetime[Object]=(functionList),start=0}
  ( {lifetime[Iterator]=(scope.functionList),lifetime[Object]=(functionList),start=0}
  func possible {lifetime[Iterator]=(scope.functionList),lifetime[Object]=(functionList),start=0}
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(scope.functionList),lifetime[Object]=(functionList),end=0}
  func possible {lifetime[Iterator]=(scope.functionList),lifetime[Object]=(functionList)}
Line 848
  func {lifetime[Iterator]=(scope.functionList),lifetime[Object]=(functionList),!symbolic=(scope.functionList.end()),!end=0}
Line 849
  = always !0
  func {lifetime[Iterator]=(scope.functionList),lifetime[Object]=(functionList),!symbolic=(scope.functionList.end()),!end=0}
  . always !0
Line 850
  ( always {!<=-1,!>=2}
  type possible {symbolic=(func->retDef),0}
  "static|const|struct|union|enum" always "static|const|struct|union|enum"
Line 853
  func {lifetime[Iterator]=(scope.functionList),lifetime[Object]=(functionList),!end=0}
  & {lifetime[Address]=(scopeList),!0}
  type always !0
Line 854
  ! always {!<=-1,!>=2}
  func {lifetime[Iterator]=(scope.functionList),lifetime[Object]=(functionList),!end=0}
Line 855
  func {lifetime[Iterator]=(scope.functionList),lifetime[Object]=(functionList),!end=0}
  type always !0
  func {lifetime[Iterator]=(scope.functionList),lifetime[Object]=(functionList),!end=0}
Line 864
  ( always {!<=-1,!>=2}
Line 868
  . always !0
  = always 1
  :: always 1
  True always 1
Line 872
  unknowns always !<=-1
  unknowns always !<=-1
  = always 0
  0 always 0
Line 873
  retry always !<=-1
  retry always !<=-1
  = always 0
  0 always 0
Line 876
  unknowns always !<=-1
  = always 0
  0 always 0
Line 879
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 882
  ! always {!<=-1,!>=2}
Line 884
  = {lifetime[Object]=(mBlankTypes),!0}
  & {lifetime[Object]=(mBlankTypes),!0}
  mBlankTypes always !size=0
Line 887
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  . possible lifetime[Object]=(mBlankTypes)
  == always {!<=-1,!>=2}
Line 889
  hasDefaultConstructor always {!<=-1,!>=2}
  hasDefaultConstructor always {!<=-1,!>=2}
  = always 0
  false always 0
Line 892
  == always {!<=-1,!>=2}
  :: always 0
  eConstructor always 0
Line 894
  ( {symbolic=(func.initializedArgCount()),!<=-1}
  == always {!<=-1,!>=2}
  0 always 0
Line 895
  hasDefaultConstructor always {!<=-1,!>=2}
  = always 1
  true always 1
Line 900
  ( always !<=0
  == always {!<=-1,!>=2}
Line 901
  hasDefaultConstructor always {!<=-1,!>=2}
  = always 1
  true always 1
Line 910
  hasDefaultConstructor {!<=-1,!>=2,1}
Line 911
  = always 2
  :: always 2
  False always 2
Line 915
  needInitialization always {!<=-1,!>=2}
  needInitialization always {!<=-1,!>=2}
  = always 0
  false always 0
Line 916
  unknown always {!<=-1,!>=2}
  unknown always {!<=-1,!>=2}
  = always 0
  false always 0
Line 919
  ( always {!<=-1,!>=2}
Line 922
  ( always !0
  == always {!<=-1,!>=2}
  :: always 1
  True always 1
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 923
  needInitialization always {!<=-1,!>=2}
  = always 1
  true always 1
Line 924
  ( always !0
  == always {!<=-1,!>=2}
Line 925
  ! always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always !0
  == always {!<=-1,!>=2}
  :: always 5
  CONTAINER always 5
Line 926
  unknown always {!<=-1,!>=2}
  = always 1
  true always 1
Line 929
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 930
  needInitialization always {!<=-1,!>=2}
  = always 1
  true always 1
Line 935
  needInitialization {!<=-1,!>=2,1}
Line 936
  = always 1
  :: always 1
  True always 1
Line 937
  ! always {!<=-1,!>=2}
  unknown always {!<=-1,!>=2}
Line 938
  . possible lifetime[Object]=(mBlankTypes)
  = always 2
  :: always 2
  False always 2
Line 940
  == always {!<=-1,!>=2}
Line 941
  unknowns always !<=-1
  ++ always !<=-1
Line 944
  == always {!<=-1,!>=2}
  :: always 3
  eUnion always 3
  && always {!<=-1,!>=2}
  . possible lifetime[Object]=(mBlankTypes)
  == always {!<=-1,!>=2}
Line 945
  . possible lifetime[Object]=(mBlankTypes)
  = always 1
  :: always 1
  True always 1
Line 948
  retry always !<=-1
  ++ always !<=-1
Line 949
  unknowns always !<=-1
  && always {!<=-1,!>=2}
  retry always !<=-1
  < always {!<=-1,!>=2}
  100 always 100
Line 952
  retry always !<=-1
  == always {!<=-1,!>=2}
  100 always 100
  && always {!<=-1,!>=2}
  . always {!<=-1,!>=2}
  debugwarnings always {!<=-1,!>=2}
Line 954
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
Line 955
  "debug" always "debug"
  "SymbolDatabase couldn't resolve all user defined types." always "SymbolDatabase couldn't resolve all user defined types."
Line 964
  1 always 1
Line 965
  ( {lifetime[Iterator]=(mVariableList),start=0}
  ( always !<=-1
  ( always 0
  nullptr always 0
Line 971
  varId always !<=-1
  = always !<=-1
Line 972
  varId always !<=-1
Line 973
  varId always !<=0
  = {&,lifetime[Address]=(varlist),!0}
  & {&,lifetime[Address]=(varlist),!0}
Line 975
  ! always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 976
  & {lifetime[Address]=(scopeList),!0}
Line 978
  type always !0
Line 986
  && always {!<=-1,!>=2}
Line 987
  declarationId always !<=-1
  = always !<=0
  ( always !0
Line 988
  declarationId always !<=0
  = {&,lifetime[Address]=(argumentList),!0}
  & {&,lifetime[Address]=(argumentList),!0}
Line 990
  ! always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 991
  & {lifetime[Address]=(scopeList),!0}
Line 993
  type always !0
Line 1001
  functions always !<=-1
  = always !<=-1
  ( always !<=-1
Line 1002
  i always !<=-1
  = always 0
  0 always 0
  i {!<=-1,0}
  < always {!<=-1,!>=2}
  functions {symbolic=(functionScopes.size()),!<=-1}
  ++ always !<=0
  i always !<=-1
Line 1003
  i {!<=-1,<=symbolic=(functions-1),!>=symbolic=(functions)}
Line 1004
  func always symbolic=(functionScopes[i])
  && always {!<=-1,!>=2}
  tok always !0
  != always {!<=-1,!>=2}
  func always symbolic=(functionScopes[i])
  = possible 0
  ( possible 0
Line 1006
  && always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 1007
  ( always !0
  == always {!<=-1,!>=2}
  "." always "."
  || always {!<=-1,!>=2}
Line 1008
  ( always !0
  == always {!<=-1,!>=2}
  "[" always "["
  && always {!<=-1,!>=2}
  1 always 1
  1 always 1
  == always {!<=-1,!>=2}
  "." always "."
Line 1009
  ( always !0
  == always {!<=-1,!>=2}
  "." always "."
  2 always 2
  1 always 1
  2 always 2
Line 1010
  && always {!<=-1,!>=2}
  tok1 always !0
  && always {!<=-1,!>=2}
  tok1 always !0
  ( always !0
  == always {!<=-1,!>=2}
  nullptr always 0
Line 1011
  ( always !0
Line 1012
  var always symbolic=(mVariableList[tok->varId()])
  && always {!<=-1,!>=2}
  var {symbolic=(mVariableList[tok->varId()]),!0}
Line 1014
  var {symbolic=(mVariableList[tok->varId()]),!0}
  ( always !0
  tok1 always !0
Line 1015
  var1 always symbolic=(var->typeScope()->getVariable(tok1->str()))
Line 1017
  tok1 always !0
  ( always !0
  = {symbolic=(var->typeScope()->getVariable(tok1->str())),!0}
  var1 {symbolic=(var->typeScope()->getVariable(tok1->str())),!0}
Line 1030
  bodyEnd inconclusive symbolic=(bodyStart)
Line 1032
  ( possible symbolic=(bodyStart)
  bodyEnd possible symbolic=(bodyStart)
  & {lifetime[Address]=(scope),!0}
Line 1034
  != always {!<=-1,!>=2}
  bodyEnd possible symbolic=(bodyStart)
Line 1035
  != always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  "{" always "{"
Line 1036
  isEndOfScope always {!<=-1,!>=2}
  isEndOfScope always {!<=-1,!>=2}
  = always 0
  false always 0
Line 1039
  ( possible lifetime[Iterator]=(innerScope->bodyStartList)
  list always symbolic=(innerScope->bodyStartList)
  ( {lifetime[Iterator]=(innerScope->bodyStartList),start=0}
  list always symbolic=(innerScope->bodyStartList)
  ( {lifetime[Iterator]=(innerScope->bodyStartList),end=0}
  != always {!<=-1,!>=2}
  list always symbolic=(innerScope->bodyStartList)
  ( {lifetime[Iterator]=(innerScope->bodyStartList),end=0}
Line 1041
  ( possible 0
  == always {!<=-1,!>=2}
  bodyEnd always !symbolic=(bodyStart)
  || always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always !symbolic=(bodyEnd)
Line 1042
  isEndOfScope always {!<=-1,!>=2}
  = always 1
  true always 1
Line 1045
  = always {!symbolic=(bodyEnd),!0}
  ( always {!symbolic=(bodyEnd),!0}
Line 1049
  isEndOfScope {!<=-1,!>=2,1}
Line 1052
  & {lifetime[Address]=(scope),!0}
Line 1058
  == always {!<=-1,!>=2}
  :: always 0
  eGlobal always 0
Line 1067
  firstPass always {!<=-1,!>=2}
Line 1069
  firstPass {!<=-1,!>=2,0@11,1@25}
Line 1074
  ( always !0
  . always !0
  & {lifetime[Address]=(functionList),!0}
Line 1077
  ( always !0
  . always !0
  & {lifetime[Address]=(functionList),!0}
Line 1083
  != always {!<=-1,!>=2}
Line 1084
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  0 always 0
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "%name% [(,)>;]" always "%name% [(,)>;]"
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 1085
  ( possible size=1
  == always {!<=-1,!>=2}
  ">" always ">"
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
Line 1088
  ( possible size=1
  != always {!<=-1,!>=2}
  "(" always "("
Line 1090
  ( always {!<=-1,!>=2}
  start possible symbolic=(tok)
  -2 always -2
  "%name% ::" always "%name% ::"
Line 1091
  -2 always -2
Line 1092
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  start possible symbolic=(tok)
  "[(,<=]" always "[(,<=]"
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  -2 always -2
  "[(,<=] &" always "[(,<=] &"
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "%name% ;" always "%name% ;"
Line 1097
  ! always {!<=-1,!>=2}
Line 1100
  function always !0
Line 1102
  != always {!<=-1,!>=2}
  "(" always "("
Line 1103
  ( always !0
  function always !0
Line 1111
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  . always !0
  && always {!<=-1,!>=2}
Line 1112
  . always !0
Line 1113
  tok always symbolic=(func.arg->link()->next())
  == always {!<=-1,!>=2}
  "noexcept" always "noexcept"
Line 1114
  tok always symbolic=(func.arg->link()->next())
  1 always 1
Line 1115
  ! always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  closingParenTok always !0
Line 1118
  = always !0
  closingParenTok always !0
  ( always !0
Line 1120
  tok possible {symbolic=(func.arg->link()->next()),symbolic=(closingParenTok->next())}
  != always {!<=-1,!>=2}
  ":" always ":"
Line 1124
  && always {!<=-1,!>=2}
  tok always !0
  != always {!<=-1,!>=2}
Line 1125
  ( always {!<=-1,!>=2}
  tok always {!symbolic=(func.functionScope->bodyStart),!0}
  "%name% {|(" always "%name% {|("
Line 1126
  tok always !0
  == always {!<=-1,!>=2}
Line 1127
  tok always !0
Line 1129
  ( always !0
  tok always !0
  function always !0
Line 1132
  tok always !0
  1 always 1
Line 1145
  typenames possible size=0
Line 1149
  != always {!<=-1,!>=2}
Line 1150
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
Line 1153
  ( possible lifetime[Iterator]=(typenames)
  == always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(typenames),end=0}
Line 1158
  type always !0
Line 1166
  && always {!<=-1,!>=2}
  ( always !0
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always !0
Line 1177
  = possible lifetime[Iterator]=(varIds)
  ( possible lifetime[Iterator]=(varIds)
Line 1178
  varId {lifetime[Iterator]=(varIds),symbolic=(varIds.find(vartok->varId()))}
  == always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(varIds),end=0}
Line 1180
  == always {!<=-1,!>=2}
  0 always 0
Line 1181
  memberId always size=0
  [ always !<=-1
  = always !<=-1
Line 1182
  mVariableList possible lifetime[Object]=(membervar)
Line 1184
  ( always !0
Line 1185
  memberId possible size=0
Line 1186
  = {lifetime[Iterator]=(varIds),!size=0}
  varIds always !size=0
  ( {lifetime[Iterator]=(varIds),!size=0}
Line 1188
  varId possible {lifetime[Iterator]=(varIds),lifetime[Iterator]=(varIds),symbolic=(varIds.find(vartok->varId()))}
Line 1189
  == always {!<=-1,!>=2}
  varId possible {lifetime[Iterator]=(varIds),lifetime[Iterator]=(varIds)}
Line 1190
  == always {!<=-1,!>=2}
  0 always 0
Line 1191
  varId possible {lifetime[Iterator]=(varIds),lifetime[Iterator]=(varIds)}
Line 1192
  mVariableList possible lifetime[Object]=(membervar)
Line 1193
  varId possible {lifetime[Iterator]=(varIds),lifetime[Iterator]=(varIds)}
Line 1195
  ( always !0
Line 1197
  ( possible 0
  == {!<=-1,!>=2,1}
  0 always 0
Line 1206
  != always {!<=-1,!>=2}
  tok possible symbolic=(membertok)
Line 1208
  ( always !0
Line 1212
  isVar always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always !0
  || always {!<=-1,!>=2}
  ( always !0
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always !0
  == always {!<=-1,!>=2}
  :: always 5
  CONTAINER always 5
Line 1213
  isArrayAccess always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  isVar {symbolic=(tok->variable()&&(tok->variable()->typeScope()||tok->variable()->isSmartPointer()||(tok->valueType()&&tok->valueType()->type==ValueType::CONTAINER))),!<=-1,!>=2,0}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "[" always "["
Line 1214
  isDirectAccess always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  isVar {symbolic=(tok->variable()&&(tok->variable()->typeScope()||tok->variable()->isSmartPointer()||(tok->valueType()&&tok->valueType()->type==ValueType::CONTAINER))),!<=-1,!>=2,0}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  isArrayAccess always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "." always "."
Line 1215
  isDerefAccess always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  isVar {symbolic=(tok->variable()&&(tok->variable()->typeScope()||tok->variable()->isSmartPointer()||(tok->valueType()&&tok->valueType()->type==ValueType::CONTAINER))),!<=-1,!>=2,0}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  isDirectAccess always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "*" always "*"
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "." always "."
Line 1216
  isVar {symbolic=(tok->variable()&&(tok->variable()->typeScope()||tok->variable()->isSmartPointer()||(tok->valueType()&&tok->valueType()->type==ValueType::CONTAINER))),!<=-1,!>=2}
  && always {!<=-1,!>=2}
  isArrayAccess always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  isDirectAccess always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  isDerefAccess always {!<=-1,!>=2}
Line 1217
  * always 0
  { always 0
Line 1218
  isArrayAccess always {!<=-1,!>=2}
Line 1220
  ( always {!<=-1,!>=2}
  membertok possible {symbolic=(const_cast<Token*>(tok->astParent())),0}
  "[" always "["
Line 1222
  membertok possible symbolic=(const_cast<Token*>(tok->astParent()))
Line 1223
  membertok always !0
Line 1225
  isDirectAccess always {!<=-1,!>=2}
Line 1227
  membertok always symbolic=(const_cast<Token*>(tok->astParent()->astOperand2()))
  == always {!<=-1,!>=2}
Line 1228
  tok always symbolic=(membertok)
Line 1229
  ( always {!<=-1,!>=2}
  gptok always symbolic=(const_cast<Token*>(tok->astParent()->astParent()))
  "." always "."
Line 1230
  gptok always symbolic=(const_cast<Token*>(tok->astParent()->astParent()))
Line 1231
  ( always {!<=-1,!>=2}
  gptok always symbolic=(const_cast<Token*>(tok->astParent()->astParent()))
  "[" always "["
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  gptok always symbolic=(const_cast<Token*>(tok->astParent()->astParent()))
  "." always "."
Line 1232
  gptok always symbolic=(const_cast<Token*>(tok->astParent()->astParent()))
Line 1237
  ( always {!<=-1,!>=2}
  membertok possible {symbolic=(const_cast<Token*>(tok->astParent())),0}
  "*" always "*"
Line 1239
  membertok possible symbolic=(const_cast<Token*>(tok->astParent()))
Line 1240
  membertok always !0
Line 1243
  membertok possible {symbolic=(const_cast<Token*>(tok->astParent()->astOperand2())),symbolic=(gptok->astOperand2()),symbolic=(gptok->astParent()->astOperand2()),symbolic=(tok)}
  && always {!<=-1,!>=2}
  membertok always !0
  != always {!<=-1,!>=2}
Line 1244
  tok always !symbolic=(membertok)
Line 1245
  var always symbolic=(tok->variable())
Line 1246
  var always symbolic=(tok->variable())
  ( always !0
  membertok always {!symbolic=(tok),!0}
Line 1247
  membervar always symbolic=(var->typeScope()->getVariable(membertok->str()))
Line 1248
  membertok always {!symbolic=(tok),!0}
  membervar always !0
Line 1249
  membertok always {!symbolic=(tok),!0}
  == always {!<=-1,!>=2}
  0 always 0
  || always {!<=-1,!>=2}
  membertok always {!symbolic=(tok),!0}
  ( always !0
  == always {!<=-1,!>=2}
  nullptr always 0
Line 1250
  tok always !symbolic=(membertok)
  ( always {!symbolic=(tok),!0}
  membertok always {!symbolic=(tok),!0}
  membervar always !0
Line 1252
  var always symbolic=(tok->variable())
Line 1253
  type always !0
Line 1254
  = possible 0
  classScope always symbolic=(type->classScope)
  ? possible 0
  classScope {symbolic=(type->classScope),!0}
  membertok always {!symbolic=(tok),!0}
  : always 0
  nullptr always 0
Line 1255
  membervar {symbolic=(classScope?classScope->getVariable(membertok->str()):nullptr),0}
Line 1256
  membertok always {!symbolic=(tok),!0}
  membervar always !0
Line 1257
  membertok always {!symbolic=(tok),!0}
  == always {!<=-1,!>=2}
  0 always 0
  || always {!<=-1,!>=2}
  membertok always {!symbolic=(tok),!0}
  ( always !0
  == always {!<=-1,!>=2}
  nullptr always 0
Line 1258
  tok always !symbolic=(membertok)
  ( always {!symbolic=(tok),!0}
  membertok always {!symbolic=(tok),!0}
  membervar always !0
Line 1260
  tok always !symbolic=(membertok)
  && always {!<=-1,!>=2}
  tok always !symbolic=(membertok)
  ( always !0
  == always {!<=-1,!>=2}
  :: always 5
  CONTAINER always 5
Line 1261
  ( always {!<=-1,!>=2}
  var always symbolic=(tok->variable())
  "std :: %type% < %name%" always "std :: %type% < %name%"
Line 1262
  var always symbolic=(tok->variable())
  4 always 4
Line 1263
  && always {!<=-1,!>=2}
  type2tok always !0
  ( always {!<=-1,!>=2}
Line 1264
  type2tok always !0
Line 1265
  = possible 0
  type2tok possible 0
  ? possible 0
  type2tok always !0
  : always 0
  nullptr always 0
Line 1266
  type2 {symbolic=(type2tok?type2tok->type():nullptr),0}
  && always {!<=-1,!>=2}
  type2 {symbolic=(type2tok?type2tok->type():nullptr),!0}
  && always {!<=-1,!>=2}
  type2 {symbolic=(type2tok?type2tok->type():nullptr),!0}
  . always !0
Line 1267
  type2 {symbolic=(type2tok?type2tok->type():nullptr),!0}
  . always !0
  membertok always {!symbolic=(tok),!0}
Line 1268
  membervar always symbolic=(type2->classScope->getVariable(membertok->str()))
Line 1269
  membertok always {!symbolic=(tok),!0}
  membervar always !0
Line 1270
  membertok always {!symbolic=(tok),!0}
  == always {!<=-1,!>=2}
  0 always 0
  || always {!<=-1,!>=2}
  membertok always {!symbolic=(tok),!0}
  ( always !0
  == always {!<=-1,!>=2}
  nullptr always 0
Line 1271
  tok always !symbolic=(membertok)
  ( always {!symbolic=(tok),!0}
  membertok always {!symbolic=(tok),!0}
  membervar always !0
Line 1282
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  "(" always "("
  && always {!<=-1,!>=2}
Line 1283
  ( always {!<=-1,!>=2}
  ") . %name% !!(" always ") . %name% !!("
  || always {!<=-1,!>=2}
Line 1284
  ( always {!<=-1,!>=2}
  ") [" always ") ["
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "] . %name% !!(" always "] . %name% !!("
Line 1285
  ( always !0
Line 1286
  type always symbolic=(tok->function()->retType)
Line 1288
  == always {!<=-1,!>=2}
  "." always "."
Line 1292
  membertok possible {symbolic=(tok->next()->link()->next()->next()),symbolic=(tok->next()->link()->next()->link()->next()->next())}
Line 1293
  ! always {!<=-1,!>=2}
  membervar always symbolic=(membertok->variable())
Line 1294
  type {symbolic=(tok->function()->retType),!0}
Line 1295
  type {symbolic=(tok->function()->retType),!0}
  . always !0
Line 1296
  membervar always symbolic=(type->classScope->getVariable(membertok->str()))
Line 1297
  membervar always !0
Line 1298
  == always {!<=-1,!>=2}
  0 always 0
  || always {!<=-1,!>=2}
  ( always !0
  == always {!<=-1,!>=2}
  nullptr always 0
Line 1299
  ( always !0
Line 1300
  ( always !0
  . always !0
  membervar always !0
Line 1314
  != always {!<=-1,!>=2}
  :: always 16
  eEnum always 16
Line 1319
  & {lifetime[Address]=(enumeratorList),!0}
Line 1323
  != always {!<=-1,!>=2}
  :: always 16
  eEnum always 16
Line 1329
  ! always {!<=-1,!>=2}
Line 1331
  && always {!<=-1,!>=2}
  tok3 always !0
  != always {!<=-1,!>=2}
Line 1332
  == always {!<=-1,!>=2}
  :: always 4
  eName always 4
Line 1335
  e always !0
Line 1343
  != always {!<=-1,!>=2}
Line 1344
  != always {!<=-1,!>=2}
  :: always 4
  eName always 4
Line 1348
  enumerator always !0
Line 1355
  "alignas" always "alignas"
Line 1356
  "alignof" always "alignof"
Line 1357
  "axiom" always "axiom"
Line 1358
  "co_await" always "co_await"
Line 1359
  "co_return" always "co_return"
Line 1360
  "co_yield" always "co_yield"
Line 1361
  "concept" always "concept"
Line 1362
  "synchronized" always "synchronized"
Line 1363
  "consteval" always "consteval"
Line 1364
  "reflexpr" always "reflexpr"
Line 1365
  "requires" always "requires"
Line 1368
  "asm" always "asm"
Line 1369
  "auto" always "auto"
Line 1370
  "catch" always "catch"
Line 1371
  "char" always "char"
Line 1372
  "class" always "class"
Line 1373
  "const" always "const"
Line 1374
  "constexpr" always "constexpr"
Line 1375
  "decltype" always "decltype"
Line 1376
  "default" always "default"
Line 1377
  "do" always "do"
Line 1378
  "enum" always "enum"
Line 1379
  "explicit" always "explicit"
Line 1380
  "export" always "export"
Line 1381
  "extern" always "extern"
Line 1382
  "final" always "final"
Line 1383
  "friend" always "friend"
Line 1384
  "inline" always "inline"
Line 1385
  "mutable" always "mutable"
Line 1386
  "namespace" always "namespace"
Line 1387
  "new" always "new"
Line 1388
  "noexcept" always "noexcept"
Line 1389
  "nullptr" always "nullptr"
Line 1390
  "override" always "override"
Line 1391
  "private" always "private"
Line 1392
  "protected" always "protected"
Line 1393
  "public" always "public"
Line 1394
  "register" always "register"
Line 1395
  "sizeof" always "sizeof"
Line 1396
  "static" always "static"
Line 1397
  "static_assert" always "static_assert"
Line 1398
  "struct" always "struct"
Line 1399
  "template" always "template"
Line 1400
  "this" always "this"
Line 1401
  "thread_local" always "thread_local"
Line 1402
  "throw" always "throw"
Line 1403
  "try" always "try"
Line 1404
  "typedef" always "typedef"
Line 1405
  "typeid" always "typeid"
Line 1406
  "typename" always "typename"
Line 1407
  "union" always "union"
Line 1408
  "using" always "using"
Line 1409
  "virtual" always "virtual"
Line 1410
  "void" always "void"
Line 1411
  "volatile" always "volatile"
Line 1412
  "NULL" always "NULL"
Line 1414
  != always {!<=-1,!>=2}
Line 1416
  ! always {!<=-1,!>=2}
  scope always symbolic=(tok->scope())
Line 1418
  ! always {!<=-1,!>=2}
  scope {symbolic=(tok->scope()),!0}
  ( always {!<=-1,!>=2}
Line 1420
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "%name%" always "%name%"
Line 1422
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 1424
  ( always {!<=-1,!>=2}
  "%var%" always "%var%"
Line 1428
  ( always {!<=-1,!>=2}
  "::|.|(|:|%var%" always "::|.|(|:|%var%"
Line 1430
  ( always {!<=-1,!>=2}
  "&|&&|* )|%var%" always "&|&&|* )|%var%"
Line 1432
  ( always {!<=-1,!>=2}
  ")" always ")"
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "catch (" always "catch ("
Line 1435
  ( always {!<=-1,!>=2}
  -2 always -2
  "%type% ," always "%type% ,"
  || always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  ", %type%" always ", %type%"
Line 1438
  ( always {!<=-1,!>=2}
  "<|>" always "<|>"
  && always {!<=-1,!>=2}
Line 1440
  ( always {!<=-1,!>=2}
  "<" always "<"
  && always {!<=-1,!>=2}
Line 1443
  ( always {!<=-1,!>=2}
  "goto" always "goto"
Line 1445
  cppkeywords always {
  ( always !<=-1
  > always {!<=-1,!>=2}
  0 always 0
Line 1447
  >= always {!<=-1,!>=2}
  :: always 4
  CPP20 always 4
  && always {!<=-1,!>=2}
  cpp20keywords always {
  ( always !<=-1
  > always {!<=-1,!>=2}
  0 always 0
Line 1449
  true always 1
Line 1456
  != always {!<=-1,!>=2}
  :: always 5
  eFunction always 5
Line 1459
  ! always {!<=-1,!>=2}
  function always symbolic=(scope.function)
Line 1461
  "return" always "return"
Line 1463
  function always !0
  ( always {!<=-1,!>=2}
  & {lifetime[Address]=(mSettings->library),!0}
  nullptr always 0
  true always 1
Line 1467
  ( always {!<=-1,!>=2}
Line 1469
  ! always {!<=-1,!>=2}
  tok possible symbolic=(tok->scope()->bodyStart)
Line 1470
  return always {!<=-1,!>=2}
  false always 0
Line 1471
  ( always {!<=-1,!>=2}
  tok {symbolic=(tok->scope()->bodyStart),!0}
  "{" always "{"
  && always {!<=-1,!>=2}
  tok always !0
  && always {!<=-1,!>=2}
  tok always !0
  ( always !0
  != always {!<=-1,!>=2}
  tok always !0
  && always {!<=-1,!>=2}
Line 1472
  tok always {!symbolic=(tok->scope()->bodyStart),!0}
  || always {!<=-1,!>=2}
  tok always {!symbolic=(tok->scope()->bodyStart),!0}
Line 1473
  return always {!<=-1,!>=2}
  true always 1
Line 1474
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  tok {symbolic=(tok->scope()->bodyStart),!0}
  "(|.|[|::|?|:|++|--|%cop%|%assign%" always "(|.|[|::|?|:|++|--|%cop%|%assign%"
Line 1475
  return always {!<=-1,!>=2}
  false always 0
Line 1476
  ( always {!<=-1,!>=2}
  "*|&|&&" always "*|&|&&"
Line 1479
  ! always {!<=-1,!>=2}
  var always symbolic=(tok2->variable())
Line 1480
  false always 0
Line 1481
  var {symbolic=(tok2->variable()),!0}
  == always {!<=-1,!>=2}
Line 1484
  return always {!<=-1,!>=2}
  false always 0
Line 1486
  return always {!<=-1,!>=2}
  true always 1
Line 1491
  "@" always "@"
Line 1492
  ( always {!<=-1,!>=2}
  ".|::" always ".|::"
Line 1494
  result possible symbolic=(tok->str()+"@")
Line 1499
  = always 0
  0 always 0
Line 1502
  ! always {!<=-1,!>=2}
Line 1504
  var always !0
Line 1506
  1 always 1
Line 1509
  = always 0
  nullptr always 0
Line 1510
  != always {!<=-1,!>=2}
  tok possible symbolic=(tok->variable()->nameToken())
Line 1511
  ( always {!<=-1,!>=2}
  tok possible {symbolic=(inConstExpr),symbolic=(tok->variable()->nameToken())}
  "decltype|sizeof|typeof (" always "decltype|sizeof|typeof ("
  && always {!<=-1,!>=2}
Line 1512
  ( always !0
Line 1513
  tok possible symbolic=(tok->variable()->nameToken())
  == always {!<=-1,!>=2}
  inConstExpr possible 0
Line 1514
  = always 0
  nullptr always 0
Line 1515
  inConstExpr always !symbolic=(tok)
Line 1516
  ! always {!<=-1,!>=2}
  tok always !symbolic=(inConstExpr)
  ( always {!<=-1,!>=2}
Line 1518
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  tok always !symbolic=(inConstExpr)
Line 1521
  ( always !<=-1
  > always {!<=-1,!>=2}
  0 always 0
Line 1524
  tok {symbolic=(tok->variable()->nameToken()),!symbolic=(inConstExpr),!0}
  && always {!<=-1,!>=2}
  tok always !symbolic=(inConstExpr)
  == always {!<=-1,!>=2}
  "<" always "<"
Line 1525
  = always !0
  tok always !symbolic=(inConstExpr)
  ( always !0
Line 1526
  ( always {!<=-1,!>=2}
  tok {symbolic=(tok->variable()->nameToken()),!symbolic=(inConstExpr)}
  "%var% [" always "%var% ["
  && always {!<=-1,!>=2}
  tok always !symbolic=(inConstExpr)
  && always {!<=-1,!>=2}
  tok always !symbolic=(inConstExpr)
  ( always !0
  == always {!<=-1,!>=2}
  tok always !symbolic=(inConstExpr)
Line 1527
  tok {!symbolic=(inConstExpr),symbolic=(tok->variable()->nameToken())}
Line 1531
  = always 0
  0 always 0
Line 1537
  != always {!<=-1,!>=2}
Line 1538
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 1540
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 1543
  = always 0
  0 always 0
Line 1544
  ( always !<=-1
  > always {!<=-1,!>=2}
  0 always 0
Line 1546
  true always 1
Line 1547
  ( always !<=-1
  == always {!<=-1,!>=2}
  0 always 0
Line 1553
  sid possible {symbolic=(unknownIds[name]),symbolic=(unknownIds.at(name))}
  > always {!<=-1,!>=2}
  0 always 0
Line 1558
  != always {!<=-1,!>=2}
Line 1559
  > always {!<=-1,!>=2}
  0 always 0
Line 1561
  ( always {!<=-1,!>=2}
Line 1565
  == always {!<=-1,!>=2}
Line 1566
  nullptr always 0
  "Ran out of expression ids." always "Ran out of expression ids."
  :: always 3
  INTERNAL always 3
Line 1568
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "this" always "this"
Line 1569
  == always {!<=-1,!>=2}
  0 always 0
Line 1580
  == always {!<=-1,!>=2}
Line 1582
  tok1 always !symbolic=(tok2)
  == always {!<=-1,!>=2}
  tok2 always !symbolic=(tok1)
Line 1584
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  true always 1
  tok1 always !symbolic=(tok2)
  tok2 always !symbolic=(tok1)
  false always 0
  false always 0
Line 1586
  ( always !symbolic=(tok2->exprId())
  ( always !symbolic=(tok1->exprId())
Line 1600
  ! always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  var always !0
  ( always {!<=-1,!>=2}
Line 1603
  var always !0
Line 1605
  dimension always {symbolic=(const_cast<Dimension&>(const_dimension)),symbolic=(dimension)}
  != always {!<=-1,!>=2}
  0 always 0
  || always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  dimension always {symbolic=(const_cast<Dimension&>(const_dimension)),symbolic=(dimension)}
Line 1608
  ( always {!<=-1,!>=2}
  dimension always {symbolic=(const_cast<Dimension&>(const_dimension)),symbolic=(dimension)}
  "[<,]" always "[<,]"
Line 1609
  . always {!<=-1,!>=2}
  known always {!<=-1,!>=2}
Line 1611
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "[<,]" always "[<,]"
Line 1617
  ";" always ";"
  0 always 0
  0 always 0
  0 always 0
  false always 0
Line 1618
  fail always {!<=-1,!>=2}
  fail always {!<=-1,!>=2}
  = always 0
  false always 0
Line 1619
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  tok always !0
  "[,>]" always "[,>]"
Line 1620
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 1621
  0 always 0
  0 always 0
  0 always 0
  false always 0
Line 1623
  ( always {!<=-1,!>=2}
Line 1624
  0 always 0
  0 always 0
  0 always 0
  false always 0
Line 1627
  fail always {!<=-1,!>=2}
  = always 1
  true always 1
Line 1632
  fail {!<=-1,!>=2,1}
Line 1635
  ";" always ";"
  0 always 0
  0 always 0
  0 always 0
  false always 0
Line 1637
  tok possible symbolic=(tokenList.front())
Line 1638
  ( always {!<=-1,!>=2}
  false always 0
Line 1644
  ( always {!<=-1,!>=2}
  "; %num% ;" always "; %num% ;"
Line 1645
  . always {!<=-1,!>=2}
  known always {!<=-1,!>=2}
  = always 1
  true always 1
Line 1653
  . always {!<=-1,!>=2}
  known always {!<=-1,!>=2}
  = always 0
  false always 0
Line 1656
  ( always {!<=-1,!>=2}
Line 1657
  . always {!<=-1,!>=2}
  known always {!<=-1,!>=2}
  = always 1
  true always 1
Line 1662
  && always {!<=-1,!>=2}
  ( always !0
  == always {!<=-1,!>=2}
  0 always 0
Line 1663
  = always 0
  0 always 0
Line 1665
  :: always 9
  CHAR always 9
Line 1668
  :: always 10
  SHORT always 10
Line 1671
  :: always 12
  INT always 12
Line 1674
  :: always 13
  LONG always 13
Line 1677
  :: always 14
  LONGLONG always 14
Line 1684
  bits possible {symbolic=(mSettings->char_bit),symbolic=(mSettings->short_bit),symbolic=(mSettings->int_bit),symbolic=(mSettings->long_bit),symbolic=(mSettings->long_long_bit),<=62,>=63}
  > {!<=-1,!>=2,<=1}
  0 always 0
  && always {!<=-1,!>=2}
  bits {symbolic=(mSettings->char_bit),symbolic=(mSettings->short_bit),symbolic=(mSettings->int_bit),symbolic=(mSettings->long_bit),symbolic=(mSettings->long_long_bit),>=1,!<=0}
  <= {!<=-1,!>=2,>=1}
  62 always 62
Line 1685
  == always {!<=-1,!>=2}
  :: always 2
  UNSIGNED always 2
Line 1686
  1LL always 1
  bits always {!<=0,!>=63}
Line 1688
  1LL always 1
  bits always {!<=0,!>=63}
  - always {!<=-1,!>=62}
  1 always 1
Line 1699
  nullptr always 0
Line 1700
  nullptr always 0
Line 1701
  nullptr always 0
Line 1702
  nullptr always 0
Line 1703
  nullptr always 0
Line 1704
  nullptr always 0
Line 1708
  ( always {!<=-1,!>=2}
Line 1711
  return always {!<=-1,!>=2}
  false always 0
Line 1716
  false always 0
  && always 0
  == always {!<=-1,!>=2}
  "(" always "("
  && always 0
  1 always 1
  != always {!<=-1,!>=2}
  "*" always "*"
  && always 0
Line 1717
  == always {!<=-1,!>=2}
  ")" always ")"
  || always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  -2 always -2
  ") const" always ") const"
Line 1719
  tok2 {symbolic=(tok->link()->next()),0}
  && always {!<=-1,!>=2}
  tok2 {symbolic=(tok->link()->next()),!0}
  == always {!<=-1,!>=2}
  "(" always "("
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  tok2 {symbolic=(tok->link()->next()),!0}
  "{|;|const|=" always "{|;|const|="
Line 1721
  == always {!<=-1,!>=2}
  "const" always "const"
Line 1722
  -2 always -2
Line 1724
  -1 always -1
Line 1727
  tok2 {symbolic=(tok->link()->next()),!0}
  "{|;" always "{|;"
Line 1728
  return always {!<=-1,!>=2}
  true always 1
Line 1729
  tok2 {symbolic=(tok->link()->next()),0}
  && always {!<=-1,!>=2}
  tok2 {symbolic=(tok->link()->next()),!0}
  == always {!<=-1,!>=2}
  "[" always "["
Line 1730
  tok2 possible symbolic=(tok->link()->next())
  && always {!<=-1,!>=2}
  tok2 {symbolic=(tok->link()->next()),!0}
  ( possible size=1
  == always {!<=-1,!>=2}
  "[" always "["
Line 1731
  tok2 always !0
Line 1732
  ( always {!<=-1,!>=2}
  tok2 possible {symbolic=(tok->link()->next()),0}
  "{|;|const|=" always "{|;|const|="
Line 1734
  == always {!<=-1,!>=2}
  "const" always "const"
Line 1735
  -2 always -2
Line 1737
  -1 always -1
Line 1740
  "{|;" always "{|;"
Line 1741
  return always {!<=-1,!>=2}
  true always 1
Line 1746
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always !0
Line 1747
  return always {!<=-1,!>=2}
  false always 0
Line 1750
  ( always {!<=-1,!>=2}
  "%name% (" always "%name% ("
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 1751
  ( always {!<=-1,!>=2}
  ( always !0
  "%name%|>|&|*|::|~" always "%name%|>|&|*|::|~"
  || always {!<=-1,!>=2}
Line 1752
  ( always {!<=-1,!>=2}
Line 1753
  = always !0
  ( always !0
Line 1754
  ( always !0
  ( always !0
Line 1756
  ! always {!<=-1,!>=2}
  ( always !0
  ";:{" always ";:{"
Line 1757
  return always {!<=-1,!>=2}
  false always 0
Line 1760
  tok1 {symbolic=(tok->previous()),!0}
  == always {!<=-1,!>=2}
  "~" always "~"
Line 1761
  tok1 {symbolic=(tok->previous()),!0}
Line 1764
  ( always {!<=-1,!>=2}
  tok1 possible 0
  "::" always "::"
Line 1766
  ( always {!<=-1,!>=2}
  tok1 possible 0
  "%name%" always "%name%"
Line 1768
  && always {!<=-1,!>=2}
  tok1 always !0
  == always {!<=-1,!>=2}
  ">" always ">"
  && always {!<=-1,!>=2}
  tok1 always !0
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  ( always !0
  "%name%" always "%name%"
Line 1769
  tok1 always !0
  ( always !0
  -2 always -2
Line 1773
  ( always {!<=-1,!>=2}
  tok2 possible {symbolic=(tok->next()->link()->next()),0}
  "const|noexcept|throw|override|final|volatile|&|&&" always "const|noexcept|throw|override|final|volatile|&|&&"
Line 1775
  && always {!<=-1,!>=2}
  tok2 always !0
  == always {!<=-1,!>=2}
  "(" always "("
Line 1776
  tok2 always !0
Line 1780
  && always {!<=-1,!>=2}
  tok2 always !0
  == always {!<=-1,!>=2}
  "." always "."
Line 1781
  tok2 always !0
Line 1782
  ( always {!<=-1,!>=2}
  ";|{|=|override|final" always ";|{|=|override|final"
Line 1784
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "<|[|(" always "<|[|("
Line 1785
  = always !0
  ( always !0
Line 1790
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  tok1 possible 0
  "{|}|;|public:|protected:|private:" always "{|}|;|public:|protected:|private:"
  && always {!<=-1,!>=2}
Line 1792
  ( always {!<=-1,!>=2}
  "%type%|*|&" always "%type%|*|&"
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  ':' always 58
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  "const" always "const"
Line 1796
  ( always {!<=-1,!>=2}
  ")" always ")"
  && always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 1797
  ( always {!<=-1,!>=2}
  ( always !0
  "decltype (" always "decltype ("
Line 1798
  ( always !0
  -2 always -2
Line 1801
  && always {!<=-1,!>=2}
  tok1 always !0
  == always {!<=-1,!>=2}
  ">" always ">"
Line 1802
  tok1 always !0
Line 1803
  tok1 always !0
  ( always !0
Line 1805
  return always {!<=-1,!>=2}
  false always 0
Line 1809
  && always {!<=-1,!>=2}
  tok1 always !0
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  tok1 always !0
Line 1810
  return always {!<=-1,!>=2}
  false always 0
Line 1813
  ( always {!<=-1,!>=2}
  tok1 possible 0
  "%name%" always "%name%"
Line 1814
  ( possible size=6
  == always {!<=-1,!>=2}
  "return" always "return"
Line 1815
  return always {!<=-1,!>=2}
  false always 0
Line 1816
  != always {!<=-1,!>=2}
  "friend" always "friend"
Line 1821
  ( always {!<=-1,!>=2}
  "::" always "::"
Line 1823
  ( always {!<=-1,!>=2}
  tok1 possible 0
  "%name%" always "%name%"
Line 1825
  && always {!<=-1,!>=2}
  tok1 always !0
  == always {!<=-1,!>=2}
  ">" always ">"
  && always {!<=-1,!>=2}
  tok1 always !0
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  ( always !0
  "%name%" always "%name%"
Line 1826
  tok1 always !0
  ( always !0
  -2 always -2
Line 1827
  ( always {!<=-1,!>=2}
  tok1 possible 0
  ")" always ")"
  && always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 1828
  ( always {!<=-1,!>=2}
  ( always !0
  "decltype (" always "decltype ("
Line 1829
  ( always !0
  -2 always -2
Line 1833
  ( always {!<=-1,!>=2}
  tok1 possible 0
  "const|static|extern|template|virtual|struct|class|enum|%name%" always "const|static|extern|template|virtual|struct|class|enum|%name%"
Line 1835
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  "friend" always "friend"
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  ";" always ";"
Line 1836
  return always {!<=-1,!>=2}
  false always 0
Line 1841
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  tok1 possible 0
  ">|{|}|;|public:|protected:|private:" always ">|{|}|;|public:|protected:|private:"
  && always {!<=-1,!>=2}
Line 1842
  return always {!<=-1,!>=2}
  false always 0
Line 1845
  && always {!<=-1,!>=2}
Line 1846
  ( always {!<=-1,!>=2}
  tok2 always !0
  ";|{|=" always ";|{|="
  || always {!<=-1,!>=2}
Line 1847
  tok2 always !0
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  tok2 always !0
  "%name% ;|{" always "%name% ;|{"
  || always {!<=-1,!>=2}
Line 1848
  tok2 always !0
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  tok2 always !0
  "%name% (" always "%name% ("
  && always {!<=-1,!>=2}
  tok2 always !0
  1 always 1
  == always {!<=-1,!>=2}
  "{" always "{"
  || always {!<=-1,!>=2}
Line 1849
  ( always {!<=-1,!>=2}
  tok2 always !0
  ": ::| %name% (|::|<|{" always ": ::| %name% (|::|<|{"
  || always {!<=-1,!>=2}
Line 1850
  ( always {!<=-1,!>=2}
  tok2 always !0
  "&|&&| ;|{" always "&|&&| ;|{"
  || always {!<=-1,!>=2}
Line 1851
  ( always {!<=-1,!>=2}
  tok2 always !0
  "= delete|default ;" always "= delete|default ;"
Line 1853
  = always !0
  tok always symbolic=(*funcStart)
  ( always !0
Line 1854
  tok2 always !0
  "{|;" always "{|;"
Line 1855
  return always {!<=-1,!>=2}
  true always 1
Line 1860
  == always {!<=-1,!>=2}
  :: always 0
  eGlobal always 0
  && always {!<=-1,!>=2}
Line 1861
  ( always {!<=-1,!>=2}
  "%name% (" always "%name% ("
  && always {!<=-1,!>=2}
Line 1862
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 1863
  ( always {!<=-1,!>=2}
  1 always 1
  ") {" always ") {"
  && always {!<=-1,!>=2}
Line 1864
  ! always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  ( always !0
  "[;{}]" always "[;{}]"
Line 1866
  = always !0
  tok always symbolic=(*funcStart)
  ( always !0
Line 1867
  tok always symbolic=(*funcStart)
  1 always 1
Line 1868
  return always {!<=-1,!>=2}
  true always 1
Line 1872
  ( always {!<=-1,!>=2}
  "%name% <" always "%name% <"
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  ( always !0
  ( always !0
  "> (" always "> ("
Line 1873
  ( always !0
  ( always !0
Line 1874
  ( always {!<=-1,!>=2}
  tok2 always symbolic=(tok->next()->link()->next()->link())
  ") const| ;|{|=" always ") const| ;|{|="
  || always {!<=-1,!>=2}
Line 1875
  ( always {!<=-1,!>=2}
  tok2 always symbolic=(tok->next()->link()->next()->link())
  ") : ::| %name% (|::|<|{" always ") : ::| %name% (|::|<|{"
  || always {!<=-1,!>=2}
Line 1876
  ( always {!<=-1,!>=2}
  tok2 always symbolic=(tok->next()->link()->next()->link())
  ") const| noexcept {|;|(" always ") const| noexcept {|;|("
Line 1878
  tok2 always symbolic=(tok->next()->link()->next()->link())
Line 1879
  tok2 always symbolic=(tok->next()->link()->next()->link())
  "{|;" always "{|;"
Line 1880
  return always {!<=-1,!>=2}
  true always 1
Line 1885
  ( always {!<=-1,!>=2}
  "%name% (" always "%name% ("
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 1886
  ( always {!<=-1,!>=2}
  1 always 1
  ") {" always ") {"
  && always {!<=-1,!>=2}
Line 1887
  ! always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  ( always !0
  ";|}" always ";|}"
Line 1888
  ( always {!<=-1,!>=2}
Line 1889
  "debug" always "debug"
  "SymbolDatabase::isFunction found C function '" always "SymbolDatabase::isFunction found C function '"
  "' without a return type." always "' without a return type."
Line 1891
  = always !0
  tok always symbolic=(*funcStart)
  ( always !0
Line 1892
  tok always symbolic=(*funcStart)
  1 always 1
Line 1893
  return always {!<=-1,!>=2}
  true always 1
Line 1898
  return always {!<=-1,!>=2}
  false always 0
Line 1903
  functions always !<=-1
  = always !<=-1
  ( always !<=-1
Line 1904
  i always !<=-1
  = always 0
  0 always 0
  i {!<=-1,0}
  < always {!<=-1,!>=2}
  functions {symbolic=(functionScopes.size()),!<=-1}
  ++ always !<=0
  i always !<=-1
Line 1905
  i {!<=-1,<=symbolic=(functions-1),!>=symbolic=(functions)}
Line 1906
  scope always symbolic=(functionScopes[i])
Line 1907
  scope always symbolic=(functionScopes[i])
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  function always symbolic=(scope->function)
Line 1908
  1 always 1
  scope always symbolic=(functionScopes[i])
Line 1909
  "Executable scope '" always "Executable scope '"
  scope always symbolic=(functionScopes[i])
  "' with unknown function." always "' with unknown function."
Line 1910
  callstack always size=1
  & {lifetime[Address]=(mTokenizer->list),!0}
  :: always 7
  debug always 7
Line 1911
  "symbolDatabaseWarning" always "symbolDatabaseWarning"
Line 1913
  :: always 0
  normal always 0
Line 1922
  functions always !<=-1
  = always !<=-1
  ( always !<=-1
Line 1923
  i always !<=-1
  = always 0
  0 always 0
  i {!<=-1,0}
  < always {!<=-1,!>=2}
  functions {symbolic=(functionScopes.size()),!<=-1}
  ++ always !<=0
  i always !<=-1
Line 1924
  i {!<=-1,<=symbolic=(functions-1),!>=symbolic=(functions)}
Line 1925
  scope always symbolic=(functionScopes[i])
Line 1926
  function always symbolic=(scope->function)
Line 1927
  arg always !<=-1
  = always 0
  0 always 0
  arg {!<=-1,0}
  < always {!<=-1,!>=2}
  function {symbolic=(scope->function),!0}
  ( always !<=-1
  ++ always !<=0
  arg always !<=-1
Line 1928
  == always {!<=-1,!>=2}
  function always !0
  arg {!<=-1,<=symbolic=(function->argCount()-1),!>=symbolic=(function->argCount())}
Line 1929
  function always !0
Line 1933
  nullptr always 0
Line 1939
  = {lifetime[Iterator]=(mVariableList),start=0}
  ( {lifetime[Iterator]=(mVariableList),start=0}
  iter possible {lifetime[Iterator]=(mVariableList),start=0}
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(mVariableList),end=0}
  iter possible lifetime[Iterator]=(mVariableList)
Line 1940
  iter {lifetime[Iterator]=(mVariableList),!symbolic=(mVariableList.end()),!end=0}
Line 1941
  var always symbolic=(*iter)
Line 1942
  ! always {!<=-1,!>=2}
  var {symbolic=(*iter),!0}
Line 1943
  var {symbolic=(*iter),!0}
Line 1944
  ! always {!<=-1,!>=2}
  var always !0
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  function always !0
  ( always {!<=-1,!>=2}
Line 1945
  var always !0
  "Analysis failed (variable without scope). If the code is valid then please report this failure." always "Analysis failed (variable without scope). If the code is valid then please report this failure."
  :: always 3
  INTERNAL always 3
Line 1955
  . always {!<=-1,!>=2}
  debugwarnings always {!<=-1,!>=2}
Line 1971
  mTypeStartToken possible 0
Line 1972
  mTypeEndToken possible 0
Line 1975
  mFlags always !<=-1
  0 always 0
Line 1978
  nullptr always 0
Line 1980
  ! always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 1981
  = always !0
  mTypeEndToken always !0
Line 1982
  ( always {!<=-1,!>=2}
  "%type%|*|&" always "%type%|*|&"
Line 1986
  ( always {!<=-1,!>=2}
  "const|struct|static" always "const|struct|static"
Line 1987
  == always {!<=-1,!>=2}
  "static" always "static"
Line 1988
  fIsStatic always 2
  true always 1
Line 1992
  ( always {!<=-1,!>=2}
  "&" always "&"
Line 1993
  fIsReference always 128
  true always 1
Line 1994
  ( always {!<=-1,!>=2}
  "&&" always "&&"
Line 1995
  fIsReference always 128
  true always 1
Line 1996
  fIsRValueRef always 256
  true always 1
Line 1999
  :: always !<=-1
  pos always !<=-1
  pos always !<=-1
  = always !<=-1
  ( always !<=-1
  "[" always "["
Line 2000
  pos always !<=-1
  != always {!<=-1,!>=2}
Line 2001
  fIsArray always 32
  true always 1
Line 2003
  pos1 always !<=-1
  = always !<=0
  pos {!<=-1,>=symbolic=(pos1+2),<=symbolic=(pos1+1)}
  + always !<=0
  1 always 1
Line 2004
  pos always !<=-1
  = always !<=-1
  ( always !<=-1
  "]" always "]"
  pos1 {symbolic=(pos+1),!<=0}
Line 2006
  = always 0
  nullptr always 0
Line 2007
  . always {!<=-1,!>=2}
  known always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  pos {!<=-1,>=symbolic=(pos1+1),<=symbolic=(pos1)}
  > always {!<=-1,!>=2}
  pos1 {!<=-1,<=symbolic=(pos-1),>=symbolic=(pos)}
Line 2008
  pos always !<=-1
  > always {!<=-1,!>=2}
  pos1 always !<=-1
Line 2009
  pos1 {!<=-1,<=symbolic=(pos-1),!>=symbolic=(pos)}
  pos {!<=-1,>=symbolic=(pos1+1),!<=symbolic=(pos1)}
  - always !<=0
  pos1 {!<=-1,<=symbolic=(pos-1),!>=symbolic=(pos)}
Line 2011
  = always 0
  0 always 0
Line 2013
  ++ {!<=0,>=symbolic=(pos1+2),<=symbolic=(pos1+1)}
  pos {!<=-1,>=symbolic=(pos1+1),<=symbolic=(pos1)}
Line 2014
  pos always !<=-1
  < always {!<=-1,!>=2}
  ( always !<=-1
  && always {!<=-1,!>=2}
  pos {!<=-1,<=symbolic=(clangType.size()-1),!>=symbolic=(clangType.size())}
  == always {!<=-1,!>=2}
  '[' always 91
Line 2018
  = possible 0
  ? possible 0
  mNameToken always !0
  : always 0
  nullptr always 0
Line 2019
  initTok possible {symbolic=(mNameToken?mNameToken->next():nullptr),0}
  && always {!<=-1,!>=2}
  initTok {symbolic=(mNameToken?mNameToken->next():nullptr),!0}
  == always {!<=-1,!>=2}
  "[" always "["
Line 2020
  initTok always !0
Line 2021
  ( always {!<=-1,!>=2}
  initTok possible {symbolic=(mNameToken?mNameToken->next():nullptr),0}
  "=|{" always "=|{"
  || always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  initTok always !0
  ( always {!<=-1,!>=2}
Line 2022
  fIsInit always 65536
  true always 1
Line 2026
  nullptr always 0
Line 2028
  this always !0
Line 2033
  nullptr always 0
Line 2035
  this always !0
Line 2045
  this always !0
  == always {!<=-1,!>=2}
  & {lifetime[Address]=(var),!0}
Line 2046
  this {!0,symbolic=(&var)}
Line 2053
  mFlags always !<=-1
  = always !<=-1
  . always !<=-1
  mFlags always !<=-1
Line 2059
  . always !0
Line 2061
  = always 0
  nullptr always 0
Line 2063
  this always !0
Line 2066
  ( always {!<=-1,!>=2}
Line 2068
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always !0
  && always {!<=-1,!>=2}
  ( always !0
  ( always !0
  == always {!<=-1,!>=2}
  "*" always "*"
Line 2071
  ( always {!<=-1,!>=2}
Line 2073
  return always {!<=-1,!>=2}
  ? always {!<=-1,!>=2}
  mValueType always !0
  == always {!<=-1,!>=2}
  :: always 2
  UNSIGNED always 2
  : always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 2079
  declEnd possible symbolic=(typeStartToken())
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  declEnd {symbolic=(typeStartToken()),!0}
  "[;,)={]" always "[;,)={]"
Line 2080
  declEnd always !0
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  declEnd always !0
  "(|[|<" always "(|[|<"
Line 2081
  = always !0
  declEnd always !0
  ( always !0
Line 2084
  declEnd possible symbolic=(typeStartToken())
Line 2090
  = possible 0
  ? possible 0
  mNameToken always !0
  : always 0
  nullptr always 0
Line 2091
  initTok possible {symbolic=(mNameToken?mNameToken->next():nullptr),0}
  && always {!<=-1,!>=2}
  initTok {symbolic=(mNameToken?mNameToken->next():nullptr),!0}
  == always {!<=-1,!>=2}
  "[" always "["
Line 2092
  initTok always !0
Line 2093
  ( always {!<=-1,!>=2}
  initTok possible {symbolic=(mNameToken?mNameToken->next():nullptr),0}
  "=|{" always "=|{"
  || always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  initTok always !0
  ( always {!<=-1,!>=2}
Line 2094
  fIsInit always 65536
  true always 1
Line 2096
  ! always {!<=-1,!>=2}
Line 2099
  = {&,lifetime[Address]=(settings->library),!0}
  & {&,lifetime[Address]=(settings->library),!0}
  settings always !0
Line 2101
  isContainer always {!<=-1,!>=2}
  isContainer always {!<=-1,!>=2}
  = always 0
  false always 0
Line 2103
  fIsArray always 32
  ( always {!<=-1,!>=2}
  settings always !0
  & {lifetime[Address]=(isContainer),!0}
  isContainer always 0
Line 2106
  mTypeStartToken always !0
  settings always !0
Line 2109
  tok possible symbolic=(mTypeStartToken)
  && always {!<=-1,!>=2}
  tok {symbolic=(mTypeStartToken),!0}
  && always {!<=-1,!>=2}
  tok {symbolic=(mTypeStartToken),!0}
  ( always !0
  ( always {!<=-1,!>=2}
Line 2110
  = always !0
  tok always !0
  ( always !0
Line 2112
  end always symbolic=(mTypeEndToken)
Line 2113
  end {symbolic=(mTypeEndToken),!0}
Line 2114
  != always {!<=-1,!>=2}
  end possible symbolic=(mTypeEndToken)
Line 2115
  tok always !symbolic=(end)
  ( possible {size=6,size=8,size=7,size=5,size=9,size=1,size=2}
  == {!<=-1,!>=2,0}
  "static" always "static"
Line 2116
  fIsStatic always 2
  true always 1
Line 2117
  tok always !symbolic=(end)
  ( possible {size=8,size=7,size=5,size=9,size=1,size=2}
  == {!<=-1,!>=2,0}
  "extern" always "extern"
Line 2118
  fIsExtern always 8
  true always 1
Line 2119
  tok always !symbolic=(end)
  ( possible {size=7,size=5,size=9,size=1,size=2}
  == {!<=-1,!>=2,0}
  "volatile" always "volatile"
  || always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  tok always !symbolic=(end)
  "std :: atomic <" always "std :: atomic <"
Line 2120
  fIsVolatile always 8192
  true always 1
Line 2121
  tok always !symbolic=(end)
  ( possible {size=5,size=9,size=1,size=2}
  == {!<=-1,!>=2,0}
  "mutable" always "mutable"
Line 2122
  fIsMutable always 1
  true always 1
Line 2123
  tok always !symbolic=(end)
  ( possible {size=9,size=1,size=2}
  == {!<=-1,!>=2,0}
  "const" always "const"
Line 2124
  fIsConst always 4
  true always 1
Line 2125
  tok always !symbolic=(end)
  ( possible {size=1,size=2}
  == {!<=-1,!>=2,0}
  "constexpr" always "constexpr"
Line 2126
  fIsConst always 4
  true always 1
Line 2127
  fIsStatic always 2
  true always 1
Line 2128
  tok always !symbolic=(end)
  ( possible {size=1,size=2}
  == {!<=-1,!>=2,0}
  "*" always "*"
Line 2129
  fIsPointer always 64
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  isContainer always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  tok always !symbolic=(end)
  "%name% [" always "%name% ["
  || always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  tok always !symbolic=(end)
  "( * %name% )" always "( * %name% )"
Line 2130
  fIsConst always 4
  false always 0
Line 2131
  tok always !symbolic=(end)
  ( possible size=2
  == {!<=-1,!>=2,0}
  "&" always "&"
Line 2132
  ( always {!<=-1,!>=2}
Line 2133
  fIsRValueRef always 256
  true always 1
Line 2134
  fIsReference always 128
  true always 1
Line 2135
  tok always !symbolic=(end)
  == always {!<=-1,!>=2}
  "&&" always "&&"
Line 2136
  fIsRValueRef always 256
  true always 1
Line 2137
  fIsReference always 128
  true always 1
Line 2140
  tok always !symbolic=(end)
  ( always {!<=-1,!>=2}
Line 2141
  fIsMaybeUnused always 32768
  true always 1
Line 2144
  tok always !symbolic=(end)
  == always {!<=-1,!>=2}
  "<" always "<"
  && always {!<=-1,!>=2}
  tok always !symbolic=(end)
Line 2145
  = always !0
  tok always !symbolic=(end)
  ( always !0
Line 2147
  tok always !symbolic=(end)
Line 2150
  ( always {!<=-1,!>=2}
  mTypeStartToken possible 0
  "static|const|constexpr|volatile %any%" always "static|const|constexpr|volatile %any%"
Line 2152
  && always {!<=-1,!>=2}
  mTypeEndToken always !0
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  mTypeEndToken always !0
  "const|volatile" always "const|volatile"
Line 2153
  = always !0
  mTypeEndToken always !0
  ( always !0
Line 2156
  mTypeStartToken always !0
Line 2157
  = always !0
  mTypeStartToken always !0
  ( always {!<=-1,!>=2}
  "%type% :: %type%" always "%type% :: %type%"
  2 always 2
Line 2158
  "::" always "::"
  2 always 2
Line 2159
  fIsClass always 16
  ! always {!<=-1,!>=2}
  lib {lifetime[Address]=(settings->library),symbolic=(&settings->library),!0}
  strtype possible {symbolic=(mTypeStartToken->str()),size=3}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  mTypeStartToken always !0
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  != always {!<=-1,!>=2}
  "..." always "..."
Line 2160
  fIsStlType always 1024
  ( always {!<=-1,!>=2}
  "std ::" always "std ::"
Line 2161
  fIsStlString always 2048
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  2 always 2
  "string|wstring|u16string|u32string !!::" always "string|wstring|u16string|u32string !!::"
  || always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  2 always 2
  "basic_string <" always "basic_string <"
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  3 always 3
  "> ::" always "> ::"
Line 2162
  fIsSmartPointer always 16384
  lib {lifetime[Address]=(settings->library),symbolic=(&settings->library),!0}
  ( always {!<=-1,!>=2}
Line 2164
  == always {!<=-1,!>=2}
  :: always 5
  Argument always 5
Line 2166
  ! always {!<=-1,!>=2}
  tok always symbolic=(mNameToken)
Line 2170
  tok possible {symbolic=(mTypeEndToken),0}
  && always {!<=-1,!>=2}
  tok {symbolic=(mTypeEndToken),!0}
  == always {!<=-1,!>=2}
  "]" always "]"
Line 2171
  tok always !0
Line 2173
  tok possible {symbolic=(mTypeEndToken),0}
  && always {!<=-1,!>=2}
  tok always !0
  == always {!<=-1,!>=2}
  "[" always "["
Line 2174
  fIsArray always 32
  ( always {!<=-1,!>=2}
  settings always !0
  & {lifetime[Address]=(isContainer),!0}
  isContainer always {!<=-1,!>=2}
Line 2176
  ! {!<=-1,!>=2,1}
  tok possible {symbolic=(mNameToken),0}
Line 2178
  tok always !0
Line 2179
  == always {!<=-1,!>=2}
  "[" always "["
Line 2181
  fHasDefault always 512
  == always {!<=-1,!>=2}
  "=" always "="
Line 2184
  && always {!<=-1,!>=2}
  mScope always !0
  ( always {!<=-1,!>=2}
Line 2189
  ( always {!<=-1,!>=2}
  declEnd always symbolic=(declEndToken())
  "; %name% =" always "; %name% ="
  && always {!<=-1,!>=2}
  declEnd always symbolic=(declEndToken())
  1 always 1
  == always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
Line 2190
  ( always {!<=-1,!>=2}
  declEnd always symbolic=(declEndToken())
  "=|{" always "=|{"
Line 2191
  fHasDefault always 512
  true always 1
Line 2195
  ( always {!<=-1,!>=2}
  mTypeStartToken always !0
  "float|double" always "float|double"
Line 2196
  fIsFloatType always 4096
  true always 1
Line 2202
  == always {!<=-1,!>=2}
  :: always 0
  UNKNOWN_TYPE always 0
Line 2203
  "decltype (" always "decltype ("
Line 2204
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  declType always !0
Line 2209
  mValueType always size=0
  > always {!<=-1,!>=2}
  0 always 0
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "( * %name% )" always "( * %name% )"
Line 2210
  fIsPointer always 64
  true always 1
Line 2211
  fIsConst always 4
  & always !<=-1
  1U always 1
  << always !<=-1
Line 2213
  fIsSmartPointer always 16384
  true always 1
Line 2218
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 2219
  nullptr always 0
Line 2222
  . always !0
Line 2226
  ( always {!<=-1,!>=2}
  ptrType possible symbolic=(typeStartToken())
  "%name%|::" always "%name%|::"
Line 2228
  ( always {!<=-1,!>=2}
  ptrType possible symbolic=(typeStartToken())
  "< %name% >" always "< %name% >"
Line 2230
  nullptr always 0
Line 2237
  ( always {!<=-1,!>=2}
  "%name%|::" always "%name%|::"
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  0 always 0
Line 2239
  ret possible size=0
Line 2242
  ( always {!<=-1,!>=2}
Line 2244
  ! always {!<=-1,!>=2}
Line 2245
  return always {!<=-1,!>=2}
  false always 0
Line 2246
  tokenDef always !0
  ( always {!<=-1,!>=2}
Line 2247
  return always {!<=-1,!>=2}
  true always 1
Line 2248
  tokenDef always !0
Line 2249
  return always {!<=-1,!>=2}
  name always symbolic=(tokenDef->str())
  ( always !<=-1
  > always {!<=-1,!>=2}
  8 always 8
  && always {!<=-1,!>=2}
  name {symbolic=(tokenDef->str()),>=size=9,!<=size=8}
  0 always 0
  8 always 8
  "operator" always "operator"
  == always {!<=-1,!>=2}
  0 always 0
  && always {!<=-1,!>=2}
  "+-*/%&|~^<>!=[(" always "+-*/%&|~^<>!=[("
  name always symbolic=(tokenDef->str())
  8 always 8
Line 2259
  nullptr always 0
Line 2260
  nullptr always 0
Line 2261
  nullptr always 0
Line 2262
  nullptr always 0
Line 2263
  nullptr always 0
Line 2265
  0 always 0
Line 2268
  nullptr always 0
Line 2269
  nullptr always 0
Line 2270
  nullptr always 0
Line 2271
  nullptr always 0
Line 2272
  mFlags always !<=-1
  0 always 0
Line 2275
  ( always {!<=-1,!>=2}
Line 2276
  true always 1
Line 2279
  == always {!<=-1,!>=2}
  "operator=" always "operator="
Line 2280
  = always 3
  :: always 3
  eOperatorEqual always 3
Line 2283
  ( possible symbolic=(scope->className)
  == always {!<=-1,!>=2}
  "[" always "["
Line 2284
  = always 6
  :: always 6
  eLambda always 6
Line 2288
  == always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
Line 2289
  ( always !symbolic=(scope->className)
  0 always 0
  . always !symbolic=(tokenDef->str())
  ( always !<=-1
  == always {!<=-1,!>=2}
  . always !symbolic=(tokenDef->str())
  && always {!<=-1,!>=2}
Line 2290
  ( always !symbolic=(scope->className)
  ( always !<=-1
  > always {!<=-1,!>=2}
  . always !symbolic=(tokenDef->str())
  ( always !<=-1
  + always !<=0
  1 always 1
  && always {!<=-1,!>=2}
Line 2291
  ( always !symbolic=(scope->className)
  . always !symbolic=(tokenDef->str())
  ( {!<=-1,<=symbolic=(tokenDef->str().size()-2),!>=symbolic=(tokenDef->str().size()-1)}
  + always !<=0
  1 always 1
  == always {!<=-1,!>=2}
  '<' always 60
  && always {!<=-1,!>=2}
Line 2292
  != always {!<=-1,!>=2}
  :: always 4
  eNamespace always 4
Line 2294
  == always {!<=-1,!>=2}
  "~" always "~"
Line 2295
  = always 4
  :: always 4
  eDestructor always 4
Line 2298
  = always 0
  :: always 0
  eConstructor always 0
Line 2300
  -1 always -1
  == always {!<=-1,!>=2}
  "explicit" always "explicit"
  || always {!<=-1,!>=2}
  -2 always -2
  == always {!<=-1,!>=2}
  "explicit" always "explicit"
Line 2306
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 2309
  ( always {!<=-1,!>=2}
  "const|volatile| &|&&| ." always "const|volatile| &|&&| ."
Line 2310
  true always 1
Line 2311
  1 always 1
  == always {!<=-1,!>=2}
  "." always "."
Line 2312
  2 always 2
Line 2313
  2 always 2
  == always {!<=-1,!>=2}
  "." always "."
Line 2314
  3 always 3
Line 2315
  3 always 3
  == always {!<=-1,!>=2}
  "." always "."
Line 2316
  4 always 4
Line 2318
  == always {!<=-1,!>=2}
  ">" always ">"
Line 2320
  ( always {!<=-1,!>=2}
  "extern|virtual|static|friend|struct|union|enum" always "extern|virtual|static|friend|struct|union|enum"
Line 2329
  end always symbolic=(argDef->link())
Line 2330
  tok possible symbolic=(end->next())
Line 2331
  tok {symbolic=(end->next()),!0}
  ( possible {size=1,size=2,size=8,size=5}
  == {!<=-1,!>=2,0}
  "const" always "const"
Line 2332
  true always 1
Line 2333
  tok always !0
  ( possible {size=2,size=8,size=5,size=1}
  == {!<=-1,!>=2,0}
  "&" always "&"
Line 2334
  true always 1
Line 2335
  tok always !0
  ( possible {size=8,size=5,size=1}
  == {!<=-1,!>=2,0}
  "&&" always "&&"
Line 2336
  true always 1
Line 2337
  tok always !0
  ( possible {size=5,size=8,size=1}
  == {!<=-1,!>=2,0}
  "override" always "override"
Line 2338
  fHasOverrideSpecifier always 4096
  true always 1
Line 2339
  tok always !0
  ( possible {size=8,size=1}
  == {!<=-1,!>=2,0}
  "final" always "final"
Line 2340
  fHasFinalSpecifier always 8192
  true always 1
Line 2341
  tok always !0
  ( possible {size=8,size=1}
  == {!<=-1,!>=2,0}
  "volatile" always "volatile"
Line 2342
  true always 1
Line 2343
  tok always !0
  ( possible size=1
  == {!<=-1,!>=2,0}
  "noexcept" always "noexcept"
Line 2344
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  tok always !0
  "( false )" always "( false )"
Line 2345
  tok always !0
  == always {!<=-1,!>=2}
  "(" always "("
Line 2346
  tok always !0
  1 always 1
Line 2347
  ( always {!<=-1,!>=2}
  tok always !0
  "throw (" always "throw ("
Line 2348
  true always 1
Line 2349
  tok always !0
  2 always 2
  != always {!<=-1,!>=2}
  ")" always ")"
Line 2350
  tok always !0
Line 2351
  tok always !0
  1 always 1
Line 2352
  ( always {!<=-1,!>=2}
  tok always !0
  "= 0|default|delete ;" always "= 0|default|delete ;"
Line 2353
  tok always !0
  1 always 1
Line 2354
  == always {!<=-1,!>=2}
  "0" always "0"
Line 2355
  == always {!<=-1,!>=2}
  "default" always "default"
Line 2356
  == always {!<=-1,!>=2}
  "delete" always "delete"
Line 2357
  tok always !0
  == always {!<=-1,!>=2}
  "." always "."
Line 2359
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  tok always !0
  ";|{|override|final" always ";|{|override|final"
Line 2360
  tok always !0
Line 2363
  tok possible 0
Line 2364
  tok always !0
Line 2367
  end possible symbolic=(argDef->link())
  ":{" always ":{"
Line 2371
  true always 1
Line 2372
  true always 1
Line 2378
  nullptr always 0
Line 2379
  nullptr always 0
Line 2380
  nullptr always 0
Line 2381
  nullptr always 0
Line 2382
  nullptr always 0
Line 2383
  nullptr always 0
Line 2384
  nullptr always 0
Line 2385
  0 always 0
Line 2388
  nullptr always 0
Line 2389
  nullptr always 0
Line 2390
  nullptr always 0
Line 2391
  nullptr always 0
Line 2392
  mFlags always !<=-1
  0 always 0
Line 2395
  ( always {!<=-1,!>=2}
Line 2396
  true always 1
Line 2399
  == always {!<=-1,!>=2}
  "operator=" always "operator="
Line 2400
  = always 3
  :: always 3
  eOperatorEqual always 3
Line 2405
  ( always {!<=-1,!>=2}
  " const" always " const"
Line 2406
  true always 1
Line 2411
  ( always {!<=-1,!>=2}
Line 2412
  true always 1
Line 2415
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  ( always !0
  ";|}|{|public:|protected:|private:" always ";|}|{|public:|protected:|private:"
Line 2416
  = always !0
  ( always !0
Line 2418
  tok1 always !0
  ( always {!<=-1,!>=2}
Line 2419
  true always 1
Line 2422
  tok1 always !0
  ( possible {size=7,size=6,size=9,size=1}
  == {!<=-1,!>=2,0}
  "extern" always "extern"
Line 2423
  true always 1
Line 2427
  tok1 always !0
  ( possible {size=6,size=9,size=1}
  == {!<=-1,!>=2,0}
  "virtual" always "virtual"
Line 2428
  true always 1
Line 2432
  tok1 always !0
  ( possible {size=6,size=9,size=1}
  == {!<=-1,!>=2,0}
  "static" always "static"
Line 2433
  true always 1
Line 2434
  . possible 0
  == {!<=-1,!>=2,0}
  :: always 4
  eNamespace always 4
  || always {!<=-1,!>=2}
  . always !4
  == always {!<=-1,!>=2}
  :: always 0
  eGlobal always 0
Line 2435
  true always 1
Line 2439
  tok1 always !0
  ( possible {size=9,size=1}
  == {!<=-1,!>=2,0}
  "friend" always "friend"
Line 2440
  true always 1
Line 2444
  tok1 always !0
  ( possible size=1
  == {!<=-1,!>=2,0}
  "constexpr" always "constexpr"
Line 2445
  true always 1
Line 2449
  tok1 always !0
  ( possible size=1
  == always {!<=-1,!>=2}
  ")" always ")"
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  tok1 always !0
  "decltype (" always "decltype ("
Line 2450
  tok1 always !0
Line 2454
  tok1 always !0
  && always {!<=-1,!>=2}
  tok1 always !0
  == always {!<=-1,!>=2}
  ">" always ">"
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  tok1 always !0
  ( always !0
  "template <" always "template <"
Line 2455
  tok1 always !0
  ( always !0
Line 2466
  ! {!<=-1,!>=2,0}
  . possible size=0
  ( {!<=-1,!>=2,1}
Line 2467
  . always !size=0
  "::" always "::"
Line 2469
  "(" always "("
Line 2471
  == always {!<=-1,!>=2}
  0 always 0
  "" always ""
  : always ","
  "," always ","
Line 2472
  ")" always ")"
Line 2479
  ! {!<=-1,!>=2,0}
  . always !0
  . possible size=0
  ( {!<=-1,!>=2,1}
Line 2480
  . always !0
  . always !size=0
  " :: " always " :: "
Line 2481
  = always !0
  . always !0
Line 2483
  name possible symbolic=(scope->className)
Line 2486
  ( always {!<=-1,!>=2}
Line 2491
  match always {!<=-1,!>=2}
  match always {!<=-1,!>=2}
  = always 0
  false always 0
Line 2492
  ( always {!<=-1,!>=2}
  tok1 possible symbolic=(first)
  "%type% :: %type%" always "%type% :: %type%"
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  tok2 possible symbolic=(second)
  "%type% :: %type%" always "%type% :: %type%"
Line 2493
  == always {!<=-1,!>=2}
Line 2494
  2 always 2
Line 2495
  2 always 2
Line 2496
  match always {!<=-1,!>=2}
  = always 1
  true always 1
Line 2498
  match always {!<=-1,!>=2}
  = always 0
  false always 0
Line 2503
  match {!<=-1,!>=2,0}
Line 2504
  return always {!<=-1,!>=2}
  false always 0
Line 2506
  = always 0
  0 always 0
Line 2507
  first possible symbolic=(tok1)
Line 2509
  ( always {!<=-1,!>=2}
  first possible symbolic=(tok1)
  "%type% :: %type%" always "%type% :: %type%"
Line 2511
  " :: " always " :: "
Line 2512
  offset possible 0
  2 always 2
Line 2513
  2 always 2
Line 2514
  == always {!<=-1,!>=2}
Line 2521
  scope always !0
Line 2523
  == always {!<=-1,!>=2}
  . always !0
Line 2524
  return always {!<=-1,!>=2}
  true always 1
Line 2528
  2 always 2
Line 2530
  && always {!<=-1,!>=2}
  start always !0
  != always {!<=-1,!>=2}
  ";" always ";"
Line 2531
  ! {!<=-1,!>=2,0}
  nsName possible size=0
  ( {!<=-1,!>=2,1}
Line 2532
  nsName always !size=0
  " " always " "
Line 2533
  start always !0
Line 2534
  start always !0
Line 2536
  == always {!<=-1,!>=2}
Line 2537
  return always {!<=-1,!>=2}
  true always 1
Line 2540
  scope always !0
Line 2544
  return always {!<=-1,!>=2}
  false always 0
Line 2547
  ( always {!<=-1,!>=2}
Line 2561
  first_type always !0
  == always {!<=-1,!>=2}
Line 2563
  tok1 possible {symbolic=(first_token),0}
  && always {!<=-1,!>=2}
  tok1 {symbolic=(first_token),!0}
  != always {!<=-1,!>=2}
  first_type {!0,symbolic=(second_type)}
Line 2564
  tok1 always !0
Line 2566
  tok2 possible {symbolic=(second_token),0}
  && always {!<=-1,!>=2}
  tok2 {symbolic=(second_token),!0}
  != always {!<=-1,!>=2}
  second_type {!0,symbolic=(first_type)}
Line 2567
  tok2 always !0
Line 2569
  && always {!<=-1,!>=2}
Line 2570
  new_first possible lifetime[Address]=(first)@37
  tok1 always !0
Line 2571
  new_second possible lifetime[Address]=(second)@37
  tok2 always !0
Line 2572
  return always {!<=-1,!>=2}
  true always 1
Line 2576
  return always {!<=-1,!>=2}
  false always 0
Line 2579
  ( always {!<=-1,!>=2}
Line 2581
  isCPP always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  scope possible lifetime[Object]=(scopeList)@133
  ( always {!<=-1,!>=2}
Line 2582
  ! always {!<=-1,!>=2}
  isCPP {symbolic=(scope->check->isCPP()),!<=-1,!>=2}
Line 2583
  return always {!<=-1,!>=2}
  true always 1
Line 2585
  = possible 0@60
  path_length possible 0@60
Line 2586
  = always 0
  0 always 0
Line 2587
  = always 0
  0 always 0
Line 2590
  ( always {!<=-1,!>=2}
  "( )" always "( )"
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "( void )" always "( void )"
  || always {!<=-1,!>=2}
Line 2591
  ( always {!<=-1,!>=2}
  "( void )" always "( void )"
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "( )" always "( )"
Line 2592
  return always {!<=-1,!>=2}
  true always 1
Line 2594
  ( possible size=1
  == always {!<=-1,!>=2}
  ( possible size=1
  && always {!<=-1,!>=2}
Line 2595
  ( always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 2596
  ( always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 2597
  ( {symbolic=(first->str()),size=1,symbolic=(second->str())}
  == always {!<=-1,!>=2}
  "(" always "("
Line 2601
  ( always {symbolic=(first->str()),symbolic=(second->str())}
  == always {!<=-1,!>=2}
  ")" always ")"
Line 2602
  == always {!<=-1,!>=2}
  1 always 1
Line 2603
  return always {!<=-1,!>=2}
  true always 1
Line 2605
  -- always !0
  openParen always !1
Line 2609
  ( always {!<=-1,!>=2}
  "struct|enum|union|class" always "struct|enum|union|class"
Line 2611
  ( always {!<=-1,!>=2}
  "struct|enum|union|class" always "struct|enum|union|class"
Line 2615
  ( always {!<=-1,!>=2}
  "const %type% %name%|,|)" always "const %type% %name%|,|)"
  && always {!<=-1,!>=2}
Line 2616
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "const %type% %name%| [" always "const %type% %name%| ["
Line 2618
  ( always {!<=-1,!>=2}
  "const %type% %name%|,|)" always "const %type% %name%|,|)"
  && always {!<=-1,!>=2}
Line 2619
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "const %type% %name%| [" always "const %type% %name%| ["
Line 2623
  ( possible {symbolic=(second->next()->str()),size=1}
  == always {!<=-1,!>=2}
  "=" always "="
Line 2626
  first always !0
  -2 always -2
Line 2627
  == always {!<=-1,!>=2}
  "=" always "="
Line 2630
  second always !0
  -2 always -2
Line 2631
  ! always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
Line 2632
  return always {!<=-1,!>=2}
  ! {!<=-1,!>=2,1}
  first possible 0
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
Line 2634
  ! always {!<=-1,!>=2}
Line 2635
  return always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
Line 2637
  ( possible {symbolic=(first->next()->str()),size=1}
  == always {!<=-1,!>=2}
  "=" always "="
Line 2640
  second always !0
  -2 always -2
Line 2641
  ! always {!<=-1,!>=2}
Line 2642
  return always {!<=-1,!>=2}
  false always 0
Line 2647
  ( possible {symbolic=(second->next()->str()),size=1}
  == always {!<=-1,!>=2}
  "," always ","
  && always {!<=-1,!>=2}
  != always {!<=-1,!>=2}
  "," always ","
  || always {!<=-1,!>=2}
Line 2648
  ( always {!<=-1,!>=2}
  "!!( )" always "!!( )"
  && always {!<=-1,!>=2}
  != always {!<=-1,!>=2}
  ")" always ")"
Line 2651
  == always {!<=-1,!>=2}
  "=" always "="
Line 2654
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  ",|)" always ",|)"
Line 2656
  ( possible {symbolic=(second->next()->str()),size=1}
  == always {!<=-1,!>=2}
  "[" always "["
  && always {!<=-1,!>=2}
  != always {!<=-1,!>=2}
  "[" always "["
Line 2660
  ( possible {symbolic=(first->next()->str()),size=1}
  == always {!<=-1,!>=2}
  "," always ","
  && always {!<=-1,!>=2}
  != always {!<=-1,!>=2}
  "," always ","
  || always {!<=-1,!>=2}
Line 2661
  ( always {!<=-1,!>=2}
  "!!( )" always "!!( )"
  && always {!<=-1,!>=2}
  != always {!<=-1,!>=2}
  ")" always ")"
Line 2664
  == always {!<=-1,!>=2}
  "=" always "="
Line 2667
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  ",|)" always ",|)"
Line 2669
  ( possible {symbolic=(first->next()->str()),size=1}
  == always {!<=-1,!>=2}
  "[" always "["
  && always {!<=-1,!>=2}
  != always {!<=-1,!>=2}
  "[" always "["
Line 2673
  ( always {!<=-1,!>=2}
  "(|, %type% ,|)" always "(|, %type% ,|)"
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "(|, %type% ,|)" always "(|, %type% ,|)"
Line 2674
  != always {!<=-1,!>=2}
Line 2682
  == always {!<=-1,!>=2}
  1 always 1
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  ")" always ")"
  && always {!<=-1,!>=2}
  != always {!<=-1,!>=2}
  ")" always ")"
Line 2686
  ( always {!<=-1,!>=2}
  "* %name%| ,|)|=" always "* %name%| ,|)|="
  && always {!<=-1,!>=2}
Line 2687
  ( always {!<=-1,!>=2}
  "%name%| [ ] ,|)" always "%name%| [ ] ,|)"
Line 2690
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  ",|)" always ",|)"
Line 2693
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  ",|)" always ",|)"
Line 2697
  ( possible symbolic=(second->next()->str())
  == always {!<=-1,!>=2}
  "*" always "*"
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  "*" always "*"
  && always {!<=-1,!>=2}
Line 2698
  2 always 2
  != always {!<=-1,!>=2}
  "const" always "const"
  && always {!<=-1,!>=2}
  2 always 2
  == always {!<=-1,!>=2}
  "const" always "const"
  || always {!<=-1,!>=2}
Line 2699
  2 always 2
  == always {!<=-1,!>=2}
  "const" always "const"
  && always {!<=-1,!>=2}
  2 always 2
  != always {!<=-1,!>=2}
  "const" always "const"
Line 2700
  2 always 2
  != always {!<=-1,!>=2}
  "const" always "const"
Line 2702
  2 always 2
Line 2704
  2 always 2
Line 2710
  ( always {!<=-1,!>=2}
  "%name% ,|)|=|[" always "%name% ,|)|=|["
  && always {!<=-1,!>=2}
Line 2711
  ( always {!<=-1,!>=2}
  "%name% ,|)|[" always "%name% ,|)|["
  && always {!<=-1,!>=2}
Line 2712
  != always {!<=-1,!>=2}
Line 2718
  == always {!<=-1,!>=2}
  "=" always "="
Line 2721
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  ",|)" always ",|)"
Line 2726
  ( always {!<=-1,!>=2}
Line 2730
  ( always {!<=-1,!>=2}
  & {lifetime[Address]=(first),!0}
  & {lifetime[Address]=(second),!0}
Line 2734
  arg_path_length possible {<=2,>=3}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "%name%" always "%name%"
  && always {!<=-1,!>=2}
  1 always 1
  != always {!<=-1,!>=2}
  "const" always "const"
Line 2737
  ( always {!<=-1,!>=2}
  param always symbolic=(path)
  ( {lifetime[Object]=(param),!0}
  param always symbolic=(path)
  ( always !<=-1
Line 2739
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  ( {lifetime[Object]=(param),!0}
  ( always !<=-1
Line 2740
  ( always !0
  arg_path_length always !0
Line 2741
  = always 0
  0 always 0
Line 2746
  arg_path_length always !0
  <= always {!<=-1,!>=2}
  2 always 2
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "%name%" always "%name%"
  && always {!<=-1,!>=2}
Line 2747
  ( always {!<=-1,!>=2}
  "%name% :: %name%" always "%name% :: %name%"
  || always {!<=-1,!>=2}
Line 2748
  ( always {!<=-1,!>=2}
  "%name% <" always "%name% <"
  && always {!<=-1,!>=2}
Line 2749
  ( always {!<=-1,!>=2}
  1 always 1
  "> :: %name%" always "> :: %name%"
  && always {!<=-1,!>=2}
Line 2750
  == always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
Line 2751
  && always {!<=-1,!>=2}
  ( always !symbolic=(scope->className)
  == always {!<=-1,!>=2}
  . always !0
  || always {!<=-1,!>=2}
Line 2752
  && always {!<=-1,!>=2}
  . always !0
  ( always {!<=-1,!>=2}
  ( always !symbolic=(scope->className)
  && always {!<=-1,!>=2}
Line 2753
  == always {!<=-1,!>=2}
  3 always 3
Line 2754
  ( always {!<=-1,!>=2}
  "%name% <" always "%name% <"
Line 2755
  1 always 1
Line 2757
  2 always 2
Line 2761
  arg_path_length {!0,>=3}
  > {!<=-1,!>=2,>=1}
  2 always 2
  && always {!<=-1,!>=2}
  1 always 1
  != always {!<=-1,!>=2}
  1 always 1
Line 2763
  short_path_length always !<=-1
  short_path_length always !<=-1
  = {>=3,!<=2}
  arg_path_length {!0,>=3,!<=2}
Line 2766
  short_path always symbolic=(path)
  ( always !<=-1
  - always !<=-1
  4 always 4
Line 2767
  short_path_length {>=3,!<=2,!<=0}
  -- {>=3,!<=2,!<=0}
Line 2770
  :: always !<=-1
  lastSpace always !<=-1
  lastSpace always !<=-1
  = always !<=-1
  ( always !<=-1
  ' ' always 32
Line 2771
  lastSpace always !<=-1
  != always {!<=-1,!>=2}
Line 2772
  lastSpace always !<=-1
  + always !<=0
  1 always 1
Line 2773
  short_path_length always {!<=1,!-1}
  -- always {!<=1,!-1}
Line 2774
  ( always !<=-1
  - always !<=-1
  1 always 1
  == always {!<=-1,!>=2}
  '>' always 62
Line 2775
  ( always !<=-1
  - always !<=-1
  3 always 3
Line 2776
  ( always !<=-1
  - always !<=-1
  1 always 1
  == always {!<=-1,!>=2}
  '<' always 60
Line 2777
  lastSpace always !<=-1
  = always !<=-1
  ( always !<=-1
  ' ' always 32
Line 2778
  lastSpace always !<=-1
  + always !<=0
  1 always 1
Line 2779
  short_path_length always !<=-1
  -- always !<=-1
Line 2785
  ( always {!<=-1,!>=2}
  param always symbolic=(short_path)
  ( {lifetime[Object]=(param),!0}
  param always symbolic=(short_path)
  ( always !<=-1
Line 2786
  short_path_length always !<=-1
Line 2787
  = always 0
  0 always 0
Line 2796
  == always {!<=-1,!>=2}
  "," always ","
  || always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  "," always ","
Line 2800
  return always {!<=-1,!>=2}
  false always 0
Line 2803
  ( always {!<=-1,!>=2}
Line 2805
  ( always {!<=-1,!>=2}
  "const|volatile" always "const|volatile"
Line 2808
  1 always 1
  == always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 2809
  return always {!<=-1,!>=2}
  true always 1
Line 2811
  ( always {!<=-1,!>=2}
  "decltype|typeof" always "decltype|typeof"
Line 2812
  return always {!<=-1,!>=2}
  true always 1
Line 2813
  return always {!<=-1,!>=2}
  false always 0
Line 2816
  ( always {!<=-1,!>=2}
  , always {!<=-1,!>=2}
  unknown always {!<=-1,!>=2}
Line 2818
  ! always {!<=-1,!>=2}
Line 2819
  return always {!<=-1,!>=2}
  false always 0
Line 2820
  function always !0
  != always {!<=-1,!>=2}
Line 2821
  return always {!<=-1,!>=2}
  false always 0
Line 2822
  function always !0
Line 2823
  function always !0
  "const" always "const"
  defEnd always symbolic=(function->returnDefEnd())
Line 2824
  return always {!<=-1,!>=2}
  true always 1
Line 2826
  ( always {!<=-1,!>=2}
  defEnd always symbolic=(function->returnDefEnd())
Line 2827
  return always {!<=-1,!>=2}
  unknown always {!<=-1,!>=2}
Line 2828
  return always {!<=-1,!>=2}
  false always 0
Line 2831
  ( always {!<=-1,!>=2}
  , always {!<=-1,!>=2}
  unknown always {!<=-1,!>=2}
Line 2833
  ! always {!<=-1,!>=2}
Line 2834
  return always {!<=-1,!>=2}
  false always 0
Line 2835
  function always !0
  != always {!<=-1,!>=2}
Line 2836
  return always {!<=-1,!>=2}
  false always 0
Line 2837
  function always !0
Line 2838
  defEnd always symbolic=(function->returnDefEnd())
  -1 always -1
  == always {!<=-1,!>=2}
  "&" always "&"
Line 2839
  return always {!<=-1,!>=2}
  true always 1
Line 2841
  ( always {!<=-1,!>=2}
  defEnd always symbolic=(function->returnDefEnd())
Line 2842
  return always {!<=-1,!>=2}
  unknown always {!<=-1,!>=2}
Line 2843
  return always {!<=-1,!>=2}
  false always 0
Line 2846
  ( always {!<=-1,!>=2}
  , always {!<=-1,!>=2}
  unknown always {!<=-1,!>=2}
Line 2848
  ! always {!<=-1,!>=2}
Line 2849
  return always {!<=-1,!>=2}
  false always 0
Line 2850
  function always !0
  . possible 3
  != always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  function always !0
  . always !symbolic=(Function::eFunction)
  != always {!<=-1,!>=2}
  :: always 3
  eOperatorEqual always 3
Line 2851
  return always {!<=-1,!>=2}
  false always 0
Line 2852
  function always !0
Line 2853
  defEnd always symbolic=(function->returnDefEnd())
  -1 always -1
  == always {!<=-1,!>=2}
  "void" always "void"
Line 2854
  return always {!<=-1,!>=2}
  true always 1
Line 2856
  ( always {!<=-1,!>=2}
  defEnd always symbolic=(function->returnDefEnd())
Line 2857
  return always {!<=-1,!>=2}
  unknown always {!<=-1,!>=2}
Line 2858
  unknown always {!<=-1,!>=2}
Line 2861
  isVoid always {!<=-1,!>=2}
  isVoid always {!<=-1,!>=2}
  = always 0
  false always 0
Line 2862
  def possible 0
  && always {!<=-1,!>=2}
  def always !0
  ( always {!<=-1,!>=2}
Line 2863
  isVoid always {!<=-1,!>=2}
  |= always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  "void" always "void"
Line 2864
  isVoid {!<=-1,!>=2,0}
  && always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  def always !0
  "*|&|&&" always "*|&|&&"
Line 2865
  return always {!<=-1,!>=2}
  true always 1
Line 2867
  return always {!<=-1,!>=2}
  false always 0
Line 2873
  ! always {!<=-1,!>=2}
Line 2875
  f always !0
Line 2876
  ! always {!<=-1,!>=2}
  scope always symbolic=(f->functionScope)
Line 2878
  scope {symbolic=(f->functionScope),!0}
  && always {!<=-1,!>=2}
  tok always !0
  != always {!<=-1,!>=2}
  scope {symbolic=(f->functionScope),!0}
  tok possible symbolic=(lambdaEndToken)
Line 2879
  == always {!<=-1,!>=2}
  "{" always "{"
  && always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 2880
  ( always !0
  == always {!<=-1,!>=2}
  :: always 15
  eLambda always 15
  || always {!<=-1,!>=2}
  ( always !0
  . always !15
  == always {!<=-1,!>=2}
  :: always 1
  eClass always 1
Line 2884
  ( always {!<=-1,!>=2}
  "return" always "return"
Line 2890
  = always !0
  lambdaEndToken always !0
Line 2898
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
Line 2899
  nullptr always 0
Line 2900
  ( always {!<=-1,!>=2}
  arg always !0
  ") :" always ") :"
Line 2901
  arg always !0
Line 2902
  ( always {!<=-1,!>=2}
  arg always !0
  ") noexcept (" always ") noexcept ("
  && always {!<=-1,!>=2}
  arg always !0
  2 always 2
  1 always 1
  == always {!<=-1,!>=2}
  ":" always ":"
Line 2903
  arg always !0
  2 always 2
Line 2904
  nullptr always 0
Line 2907
  ( always {!<=-1,!>=2}
Line 2909
  . always {!<=-1,!>=2}
  externalFunctions always {!<=-1,!>=2}
Line 2910
  . possible 0
  == {!<=-1,!>=2,0}
  :: always 4
  eNamespace always 4
  && always {!<=-1,!>=2}
  != always {!<=-1,!>=2}
  0 always 0
Line 2911
  return always {!<=-1,!>=2}
  true always 1
Line 2912
  == always {!<=-1,!>=2}
  :: always 0
  eGlobal always 0
  && always {!<=-1,!>=2}
  != always {!<=-1,!>=2}
  0 always 0
  || always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 2913
  return always {!<=-1,!>=2}
  true always 1
Line 2916
  . always {!<=-1,!>=2}
  internalFunctions always {!<=-1,!>=2}
Line 2917
  . possible 0
  == {!<=-1,!>=2,0}
  :: always 4
  eNamespace always 4
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  0 always 0
Line 2918
  return always {!<=-1,!>=2}
  true always 1
Line 2919
  == always {!<=-1,!>=2}
  :: always 0
  eGlobal always 0
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  0 always 0
  || always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 2920
  return always {!<=-1,!>=2}
  true always 1
Line 2923
  . always {!<=-1,!>=2}
  classes always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 1
  eClass always 1
  || always {!<=-1,!>=2}
  . always !1
  == always {!<=-1,!>=2}
  :: always 2
  eStruct always 2
Line 2924
  return always {!<=-1,!>=2}
  true always 1
Line 2926
  return always {!<=-1,!>=2}
  false always 0
Line 2929
  & always !0
  & always !0
Line 2931
  = always 0
  nullptr always 0
Line 2933
  tok possible symbolic=(funcStart)@213
  != always {!<=-1,!>=2}
  "[" always "["
Line 2934
  = possible lifetime[Iterator]=(scope->functionMap)
  ( possible lifetime[Iterator]=(scope->functionMap)
  i possible lifetime[Iterator]=(scope->functionMap)
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(scope->functionMap),end=0}
  && always {!<=-1,!>=2}
  i {lifetime[Iterator]=(scope->functionMap),!symbolic=(scope->functionMap.end()),!end=0}
  == always {!<=-1,!>=2}
Line 2935
  i possible lifetime[Iterator]=(scope->functionMap)
Line 2936
  f always symbolic=(i->second)
  ( always {!<=-1,!>=2}
Line 2938
  f always symbolic=(i->second)
  ( always {!<=-1,!>=2}
  f always symbolic=(i->second)
  0 always 0
Line 2945
  ! {!<=-1,!>=2,1}
  function possible {symbolic=(const_cast<Function*>(i->second)),0}
Line 2948
  = possible symbolic=(lambdaStartToken->astParent())@248
  argStart possible symbolic=(lambdaStartToken->astParent())@248
Line 2950
  true always 1
Line 2952
  & {lifetime[Address]=(scope),!0}
  scope inconclusive lifetime[Object]=(scopeList)@213
  & {lifetime[Address]=(tok),!0}
Line 2955
  scope always !0
Line 2956
  = always !0
  scope always !0
Line 2959
  nullptr always 0
Line 2962
  & always !0
Line 2966
  & {lifetime[Object]=(scope->functionList),!0}
Line 2971
  destructor {!<=-1,!>=2,0}
  tok possible {lifetime[Address]=(tok)@197,lifetime[Address]=(tok)@208,lifetime[Address]=(tok)@212,lifetime[Address]=(tok)@219}
  == always {!<=-1,!>=2}
  "~" always "~"
Line 2972
  has_const {!<=-1,!>=2,0}
  1 always 1
  == always {!<=-1,!>=2}
  "const" always "const"
Line 2973
  lval always {!<=-1,!>=2}
  has_const {!<=-1,!>=2,0}
  ? possible {2,1}
  2 always 2
  : always 1
  1 always 1
  == always {!<=-1,!>=2}
  "&" always "&"
Line 2974
  rval always {!<=-1,!>=2}
  has_const always {!<=-1,!>=2}
  ? possible {2,1}
  2 always 2
  : always 1
  1 always 1
  == always {!<=-1,!>=2}
  "&&" always "&&"
Line 2975
  = always 0
  0 always 0
Line 2977
  path_length always !<=-1
  path_length always !<=-1
  = always 0
  0 always 0
Line 2978
  tok possible {lifetime[Address]=(tok)@197,lifetime[Address]=(tok)@208,lifetime[Address]=(tok)@212,lifetime[Address]=(tok)@219}
Line 2980
  destructor {!<=-1,!>=2,0}
Line 2981
  tok1 always symbolic=(*tok)
Line 2984
  tok1 possible {symbolic=(*tok),0}
  && always {!<=-1,!>=2}
  tok1 always !0
  && always {!<=-1,!>=2}
  tok1 always !0
  ( always !0
  == always {!<=-1,!>=2}
  "::" always "::"
  && always {!<=-1,!>=2}
  -2 always -2
  && always {!<=-1,!>=2}
Line 2985
  -2 always -2
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  -2 always -2
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
Line 2986
  -2 always -2
  == always {!<=-1,!>=2}
  ">" always ">"
  && always {!<=-1,!>=2}
  -2 always -2
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  -2 always -2
  "%name%" always "%name%"
Line 2988
  tok1 always !0
  -2 always -2
Line 2989
  == always {!<=-1,!>=2}
  ">" always ">"
Line 2994
  ( possible size=2
  + possible size=3
  " " always " "
Line 2996
  path_length always !<=-1
  ++ always !<=-1
Line 2997
  != always {!<=-1,!>=2}
  tok2 always !0
Line 3003
  ! always {!<=-1,!>=2}
Line 3007
  tok1 always !0
  -1 always -1
  == always {!<=-1,!>=2}
  "::" always "::"
Line 3008
  path_length always !<=-1
  ++ always !<=-1
Line 3009
  ( possible lifetime[Iterator]=(path)
  0 always 0
  ":: " always ":: "
Line 3015
  = {lifetime[Iterator]=(scopeList),start=0}
  ( {lifetime[Iterator]=(scopeList),start=0}
  it1 possible {lifetime[Iterator]=(scopeList),start=0}
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(scopeList),end=0}
  it1 possible lifetime[Iterator]=(scopeList)
Line 3016
  scope1 possible lifetime[Object]=(scopeList)
  = {lifetime[Object]=(scopeList),!0}
  & {lifetime[Object]=(scopeList),!0}
  it1 possible lifetime[Iterator]=(scopeList)
Line 3018
  match {!<=-1,!>=2,0}
  match always {!<=-1,!>=2}
  = always 0
  false always 0
Line 3021
  == always {!<=-1,!>=2}
  scope1 {lifetime[Object]=(scopeList),symbolic=(&(*it1)),!0}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  scope1 {lifetime[Object]=(scopeList),symbolic=(&(*it1)),!0,symbolic=(*scope)}
  ( always {!<=-1,!>=2}
Line 3023
  = {lifetime[Iterator]=(scope1->usingList),lifetime[Object]=(scopeList),start=0}
  scope1 {lifetime[Object]=(scopeList),symbolic=(&(*it1)),!0,symbolic=(*scope)}
  ( {lifetime[Iterator]=(scope1->usingList),lifetime[Object]=(scopeList),start=0}
  it2 possible {lifetime[Iterator]=(scope1->usingList),lifetime[Object]=(scopeList),start=0}
  != always {!<=-1,!>=2}
  scope1 {lifetime[Object]=(scopeList),symbolic=(&(*it1)),symbolic=(*scope),!0}
  ( {lifetime[Iterator]=(scope1->usingList),lifetime[Object]=(scopeList),end=0}
  it2 possible {lifetime[Iterator]=(scope1->usingList),lifetime[Object]=(scopeList)}
Line 3024
  it2 {lifetime[Iterator]=(scope1->usingList),lifetime[Object]=(scopeList),!symbolic=(scope1->usingList.end()),!end=0}
Line 3025
  it2 {lifetime[Iterator]=(scope1->usingList),lifetime[Object]=(scopeList),!symbolic=(scope1->usingList.end()),!end=0}
  . always !0
  path_length always !<=-1
Line 3027
  ! always {!<=-1,!>=2}
  func always !0
  ( always {!<=-1,!>=2}
Line 3029
  closeParen {symbolic=((*tok)->next()->link()),0}
Line 3030
  closeParen {symbolic=((*tok)->next()->link()),!0}
  ";" always ";"
Line 3031
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  eq always !0
  -2 always -2
  "= default ;" always "= default ;"
Line 3032
  func always !0
  true always 1
Line 3036
  func always !0
  true always 1
Line 3037
  func always !0
Line 3038
  func always !0
Line 3041
  * always !0
  func always !0
Line 3042
  = always !0
  func always !0
Line 3043
  . always !0
Line 3052
  scope1 {lifetime[Object]=(scopeList),symbolic=(&(*it1)),!0}
  == always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  scope1 {lifetime[Object]=(scopeList),!0}
  != always {!<=-1,!>=2}
Line 3054
  == always {!<=-1,!>=2}
  scope1 {lifetime[Object]=(scopeList),!0}
  || always {!<=-1,!>=2}
  * always !symbolic=(scope1->nestedIn)
  && always {!<=-1,!>=2}
Line 3055
  * always {!symbolic=(scope1->nestedIn),!0}
  == always {!<=-1,!>=2}
  scope1 {lifetime[Object]=(scopeList),!0}
  . always !symbolic=(*scope)
  && always {!<=-1,!>=2}
Line 3056
  ! always {!<=-1,!>=2}
  * always {!symbolic=(scope1->nestedIn),!0}
  . always symbolic=(scope1->nestedIn->className)
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 3057
  * always !symbolic=(scope1->nestedIn)
  == always {!<=-1,!>=2}
  scope1 {lifetime[Object]=(scopeList),!0}
  . always !symbolic=(*scope)
Line 3061
  = possible symbolic=(scope1->nestedIn)
  * possible symbolic=(scope1->nestedIn)
Line 3062
  = possible {symbolic=(*scope),symbolic=(s1)}
  scope1 {lifetime[Object]=(scopeList),!0}
  . possible {symbolic=(*scope),symbolic=(s1)}
Line 3063
  s1 possible {symbolic=(*scope),symbolic=(scope1->nestedIn)}
  && always {!<=-1,!>=2}
  s2 possible symbolic=(scope1->nestedIn)
Line 3064
  s1 always !0
  != always {!<=-1,!>=2}
  s2 always !0
Line 3066
  s1 always !0
Line 3067
  s2 always !0
Line 3070
  s1 possible {symbolic=(*scope),0}
  || always {!<=-1,!>=2}
Line 3076
  scope2 possible {symbolic=(scope1),0}
  && always {!<=-1,!>=2}
  > always {!<=-1,!>=2}
  1 always 1
Line 3077
  count {>=2,!<=1}
  -- {>=2,!<=1}
Line 3078
  1 always 1
  == always {!<=-1,!>=2}
  "<" always "<"
Line 3079
  1 always 1
  2 always 2
Line 3081
  2 always 2
Line 3082
  scope2 always !0
Line 3085
  count possible <=1
  == {!<=-1,!>=2,<=1}
  1 always 1
  && always {!<=-1,!>=2}
Line 3086
  match always {!<=-1,!>=2}
  = always 1
  true always 1
Line 3087
  = always !0
  scope2 always !0
Line 3092
  match {!<=-1,!>=2,1}
Line 3093
  = possible {lifetime[Iterator]=(scope1->functionMap),lifetime[Object]=(scopeList)}
  scope1 possible lifetime[Object]=(scopeList)
  ( possible {lifetime[Iterator]=(scope1->functionMap),lifetime[Object]=(scopeList)}
  it possible {lifetime[Iterator]=(scope1->functionMap),lifetime[Object]=(scopeList)}
  != always {!<=-1,!>=2}
  scope1 possible lifetime[Object]=(scopeList)
  ( {lifetime[Iterator]=(scope1->functionMap),lifetime[Object]=(scopeList),end=0}
  && always {!<=-1,!>=2}
  it {lifetime[Iterator]=(scope1->functionMap),lifetime[Object]=(scopeList),!symbolic=(scope1->functionMap.end()),!end=0}
  == always {!<=-1,!>=2}
  it possible {lifetime[Iterator]=(scope1->functionMap),lifetime[Object]=(scopeList)}
Line 3094
  it possible {lifetime[Iterator]=(scope1->functionMap),lifetime[Object]=(scopeList)}
Line 3095
  ! always {!<=-1,!>=2}
  func always symbolic=(const_cast<Function*>(it->second))
  ( always {!<=-1,!>=2}
Line 3096
  func always symbolic=(const_cast<Function*>(it->second))
  ( always {!<=-1,!>=2}
  scope1 possible lifetime[Object]=(scopeList)
  func always symbolic=(const_cast<Function*>(it->second))
  path_length always !<=-1
Line 3097
  . possible 4
  == {!<=-1,!>=2,1}
  :: always 4
  eDestructor always 4
  && always {!<=-1,!>=2}
  destructor always {!<=-1,!>=2}
Line 3098
  true always 1
Line 3099
  != always {!<=-1,!>=2}
  :: always 4
  eDestructor always 4
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  destructor always {!<=-1,!>=2}
Line 3102
  closeParen {symbolic=((*tok)->next()->link()),0}
Line 3103
  closeParen {symbolic=((*tok)->next()->link()),!0}
  ";" always ";"
Line 3104
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  eq always !0
  -2 always -2
  "= default ;" always "= default ;"
Line 3105
  true always 1
Line 3109
  hasConstKeyword always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  closeParen always !0
  == always {!<=-1,!>=2}
  "const" always "const"
Line 3110
  ( always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  hasConstKeyword {symbolic=(closeParen->next()->str()=="const"),!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 3111
  ( always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  lval always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 3112
  ( always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  rval always {!<=-1,!>=2}
Line 3113
  true always 1
Line 3118
  ( always {!<=-1,!>=2}
Line 3123
  * always !0
  = possible lifetime[Object]=(scopeList)
  scope1 possible lifetime[Object]=(scopeList)
Line 3141
  tok possible {lifetime[Address]=(tok)@157,lifetime[Address]=(tok2)@195}
Line 3142
  this always !0
  tok1 always symbolic=(*tok)
  scope possible {lifetime[Address]=(scope)@157,lifetime[Address]=(scope)@195}
Line 3143
  = {lifetime[Object]=(scopeList),!0}
  & {lifetime[Object]=(scopeList),!0}
  scopeList always !size=0
Line 3146
  foundInitList always {!<=-1,!>=2}
  foundInitList always {!<=-1,!>=2}
  = always 0
  false always 0
Line 3147
  tok1 {symbolic=(*tok),0}
  && always {!<=-1,!>=2}
  tok1 {symbolic=(*tok),!0}
  != always {!<=-1,!>=2}
  "{" always "{"
  && always {!<=-1,!>=2}
  tok1 {symbolic=(*tok),!0}
  != always {!<=-1,!>=2}
  ";" always ";"
Line 3148
  tok1 always !0
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  tok1 always !0
  "(|[|<" always "(|[|<"
Line 3149
  = always !0
  tok1 always !0
  ( always !0
Line 3150
  foundInitList always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  tok1 always !0
  "%name%|> {" always "%name%|> {"
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  tok1 always !0
  1 always 1
  "} ,|{" always "} ,|{"
Line 3151
  tok1 always !0
  1 always 1
Line 3153
  tok1 always !0
  == always {!<=-1,!>=2}
  ":" always ":"
Line 3154
  foundInitList always {!<=-1,!>=2}
  = always 1
  true always 1
Line 3155
  tok1 always !0
Line 3159
  tok1 {symbolic=(*tok),0}
  && always {!<=-1,!>=2}
  tok1 always !0
  == always {!<=-1,!>=2}
  "{" always "{"
Line 3160
  newScope {lifetime[Object]=(scopeList),symbolic=(&scopeList.back()),!0}
  tok1 always !0
Line 3163
  ! always {!<=-1,!>=2}
  newScope {lifetime[Object]=(scopeList),symbolic=(&scopeList.back()),!0}
Line 3166
  = always !0
  ( always !0
Line 3167
  scope possible {lifetime[Address]=(scope)@157,lifetime[Address]=(scope)@195}
  = always 0
  nullptr always 0
Line 3168
  tok possible {lifetime[Address]=(tok)@157,lifetime[Address]=(tok2)@195}
Line 3172
  scope possible {lifetime[Address]=(scope)@157,lifetime[Address]=(scope)@195}
  . possible lifetime[Object]=(scopeList)
  newScope {lifetime[Object]=(scopeList),symbolic=(&scopeList.back()),!0}
Line 3173
  scope possible {lifetime[Address]=(scope)@157,lifetime[Address]=(scope)@195}
  = inconclusive {lifetime[Object]=(scopeList),symbolic=(&scopeList.back())}
  newScope inconclusive {lifetime[Object]=(scopeList),symbolic=(&scopeList.back())}
Line 3174
  tok possible {lifetime[Address]=(tok)@157,lifetime[Address]=(tok2)@195}
  = always !0
  tok1 always !0
Line 3176
  scopeList always !size=0
Line 3177
  scope possible {lifetime[Address]=(scope)@157,lifetime[Address]=(scope)@195}
  = always 0
  nullptr always 0
Line 3178
  tok possible {lifetime[Address]=(tok)@157,lifetime[Address]=(tok2)@195}
  = always 0
  nullptr always 0
Line 3182
  ( always {!<=-1,!>=2}
Line 3184
  return always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  classScope always !0
  == always {!<=-1,!>=2}
  :: always 1
  eClass always 1
Line 3187
  ( always {!<=-1,!>=2}
Line 3190
  return always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  classDef always !0
  == always {!<=-1,!>=2}
  "enum" always "enum"
  || always {!<=-1,!>=2}
Line 3191
  && always {!<=-1,!>=2}
  classScope always !0
  == always {!<=-1,!>=2}
  :: always 16
  eEnum always 16
Line 3194
  ( always {!<=-1,!>=2}
Line 3196
  return always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  classScope always !0
  == always {!<=-1,!>=2}
  :: always 2
  eStruct always 2
Line 3199
  ( always {!<=-1,!>=2}
Line 3201
  return always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  classScope always !0
  == always {!<=-1,!>=2}
  :: always 3
  eUnion always 3
Line 3208
  tok2 possible symbolic=(tok1)
  && always {!<=-1,!>=2}
  tok2 {symbolic=(tok1),!0}
  != always {!<=-1,!>=2}
  "{" always "{"
Line 3210
  tok2 always !0
  == always {!<=-1,!>=2}
  "<" always "<"
Line 3211
  tok2 always !0
Line 3214
  ( always {!<=-1,!>=2}
  tok2 always !0
  ":|," always ":|,"
Line 3215
  tok2 always !0
Line 3218
  ! always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  tok2 always !0
Line 3219
  nullptr always 0
Line 3223
  tok2 always !0
  == always {!<=-1,!>=2}
  "virtual" always "virtual"
Line 3224
  . always {!<=-1,!>=2}
  isVirtual always {!<=-1,!>=2}
  = always 1
  true always 1
Line 3225
  = always !0
  tok2 always !0
  ( always !0
Line 3228
  ( possible {size=9,size=7}
  == {!<=-1,!>=2,0}
  "public" always "public"
Line 3231
  ( possible size=7
  == {!<=-1,!>=2,0}
  "protected" always "protected"
Line 3232
  = always 1
  :: always 1
  Protected always 1
Line 3234
  == always {!<=-1,!>=2}
  "private" always "private"
Line 3235
  = always 2
  :: always 2
  Private always 2
Line 3238
  ( possible size=6
  == {!<=-1,!>=2,0}
  "class" always "class"
Line 3239
  = always 2
  :: always 2
  Private always 2
Line 3240
  == always {!<=-1,!>=2}
  "struct" always "struct"
Line 3243
  ! always {!<=-1,!>=2}
Line 3244
  nullptr always 0
Line 3245
  tok2 always !0
  == always {!<=-1,!>=2}
  "virtual" always "virtual"
Line 3246
  . always {!<=-1,!>=2}
  isVirtual always {!<=-1,!>=2}
  = always 1
  true always 1
Line 3247
  tok2 always !0
Line 3249
  ! always {!<=-1,!>=2}
Line 3250
  nullptr always 0
Line 3252
  = always !0
  tok2 always !0
Line 3254
  tok2 always !0
  == always {!<=-1,!>=2}
  "::" always "::"
Line 3255
  tok2 always !0
Line 3259
  ( always {!<=-1,!>=2}
  tok2 possible 0
  "%name% ::" always "%name% ::"
Line 3260
  2 always 2
Line 3262
  ! always {!<=-1,!>=2}
Line 3263
  nullptr always 0
Line 3265
  tok2 always !0
Line 3267
  tok2 always !0
Line 3269
  && always {!<=-1,!>=2}
  tok2 always !0
  && always {!<=-1,!>=2}
  tok2 always !0
  == always {!<=-1,!>=2}
  "<" always "<"
Line 3270
  tok2 always !0
  ( always !0
  != always {!<=-1,!>=2}
Line 3276
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  baseType always !0
  ( always {!<=-1,!>=2}
  this always !0
Line 3277
  = always !0
  baseType always !0
Line 3282
  tok2 always !0
Line 3285
  tok2 possible {symbolic=(tok1),0}
Line 3291
  && always {!<=-1,!>=2}
  classScope always !0
  . always {!<=-1,!>=2}
  enumClass always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 3292
  next always symbolic=(classDef->next())
  1 always 1
Line 3293
  next always symbolic=(classDef->next())
  == always {!<=-1,!>=2}
  "class" always "class"
Line 3294
  next always symbolic=(classDef->next())
  1 always 1
Line 3295
  next always symbolic=(classDef->next())
  ( always {!<=-1,!>=2}
Line 3296
  next always symbolic=(classDef->next())
Line 3302
  tok possible symbolic=(tok->previous())@117
  && always {!<=-1,!>=2}
  . always {!<=-1,!>=2}
  debugwarnings always {!<=-1,!>=2}
Line 3303
  1 always 1
  tok always !0
Line 3304
  locationList always size=1
  & {lifetime[Address]=(mTokenizer->list),!0}
Line 3305
  :: always 7
  debug always 7
Line 3308
  :: always 0
  normal always 0
Line 3310
  mErrorLogger always !0
Line 3317
  :: possible {symbolic=(classScope->functionMap.end()),end=0}
  it possible {symbolic=(classScope->functionMap.end()),end=0}
  = possible lifetime[Iterator]=(classScope->functionMap)
  classScope always !0
  ( possible lifetime[Iterator]=(classScope->functionMap)
Line 3319
  != always {!<=-1,!>=2}
  classScope always !0
  ( {lifetime[Iterator]=(classScope->functionMap),end=0}
Line 3320
  it always {!symbolic=(classScope->functionMap.end()),!end=0}
Line 3325
  . always !0
Line 3326
  func always symbolic=(i.type->getFunction(funcName))
Line 3327
  func {symbolic=(i.type->getFunction(funcName)),!0}
Line 3330
  nullptr always 0
Line 3333
  ( always {!<=-1,!>=2}
Line 3336
  ! always {!<=-1,!>=2}
  ancestors possible lifetime[Address]=(knownAncestors)@53
Line 3337
  = {&,lifetime[Address]=(knownAncestors),!0}
  & {&,lifetime[Address]=(knownAncestors),!0}
Line 3339
  = {lifetime[Iterator]=(derivedFrom),start=0}
  ( {lifetime[Iterator]=(derivedFrom),start=0}
  parent possible {lifetime[Iterator]=(derivedFrom),start=0}
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(derivedFrom),end=0}
Line 3340
  ! always {!<=-1,!>=2}
  parent possible lifetime[Iterator]=(derivedFrom)
  . possible symbolic=(this)
Line 3342
  this always !0
  == always {!<=-1,!>=2}
  parent possible lifetime[Iterator]=(derivedFrom)
  . always !0
Line 3343
  return always {!<=-1,!>=2}
  true always 1
Line 3344
  ancestors possible lifetime[Address]=(knownAncestors)
  ( possible lifetime[Iterator]=(knownAncestors)
  parent possible lifetime[Iterator]=(derivedFrom)
  != always {!<=-1,!>=2}
  ancestors possible lifetime[Address]=(knownAncestors)
  ( {lifetime[Iterator]=(knownAncestors),end=0}
Line 3345
  return always {!<=-1,!>=2}
  true always 1
Line 3347
  ancestors possible lifetime[Address]=(knownAncestors)
Line 3348
  ( always {!<=-1,!>=2}
  ancestors {lifetime[Address]=(knownAncestors),!size=0}
Line 3349
  return always {!<=-1,!>=2}
  true always 1
Line 3352
  return always {!<=-1,!>=2}
  false always 0
Line 3355
  ( always {!<=-1,!>=2}
Line 3357
  this always !0
  == always {!<=-1,!>=2}
  ancestor possible lifetime[Address]=(typeList)@69
Line 3358
  return always {!<=-1,!>=2}
  true always 1
Line 3359
  = {lifetime[Iterator]=(derivedFrom),start=0}
  ( {lifetime[Iterator]=(derivedFrom),start=0}
  parent possible {lifetime[Iterator]=(derivedFrom),start=0}
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(derivedFrom),end=0}
Line 3360
  parent {lifetime[Iterator]=(derivedFrom),!symbolic=(derivedFrom.end()),!end=0}
  . possible symbolic=(this)
  && always {!<=-1,!>=2}
  parent {lifetime[Iterator]=(derivedFrom),!symbolic=(derivedFrom.end()),!end=0}
  . always !0
  == always {!<=-1,!>=2}
  this always {!0,!symbolic=(ancestor)}
  || always {!<=-1,!>=2}
  parent {lifetime[Iterator]=(derivedFrom),!symbolic=(derivedFrom.end()),!end=0}
  ( always {!<=-1,!>=2}
  ancestor always !symbolic=(this)
Line 3361
  return always {!<=-1,!>=2}
  true always 1
Line 3363
  return always {!<=-1,!>=2}
  false always 0
Line 3366
  ( always {!<=-1,!>=2}
Line 3368
  = {lifetime[Iterator]=(derivedFrom),start=0}
  ( {lifetime[Iterator]=(derivedFrom),start=0}
  parent possible {lifetime[Iterator]=(derivedFrom),start=0}
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(derivedFrom),end=0}
Line 3369
  parent {lifetime[Iterator]=(derivedFrom),!symbolic=(derivedFrom.end()),!end=0}
  == always {!<=-1,!>=2}
Line 3370
  return always {!<=-1,!>=2}
  true always 1
Line 3371
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  ancestor always !symbolic=(parent->name)
Line 3372
  return always {!<=-1,!>=2}
  true always 1
Line 3374
  return always {!<=-1,!>=2}
  false always 0
Line 3377
  ( always {!<=-1,!>=2}
Line 3379
  * always {!<=-1,!>=2}
  isContainer possible {lifetime[Address]=(isContainer)@212,lifetime[Address]=(isContainer)@20}
  = always 0
  false always 0
Line 3381
  && always {!<=-1,!>=2}
  container always !0
  . always {!<=-1,!>=2}
  arrayLike_indexOp always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  container always !0
  > always {!<=-1,!>=2}
  0 always 0
Line 3382
  "<" always "<"
Line 3384
  * always {!<=-1,!>=2}
  isContainer possible {lifetime[Address]=(isContainer)@212,lifetime[Address]=(isContainer)@20}
  = always 1
  true always 1
Line 3386
  tok always !0
Line 3387
  = always 0
  0 always 0
  i possible 0
  < {!<=-1,!>=2,1}
  container always !0
  . always !<=0
  && {!<=-1,!>=2,0}
  tok possible 0
Line 3390
  ( always {!<=-1,!>=2}
  tok possible 0
  "%num% [,>]" always "%num% [,>]"
Line 3392
  . always {!<=-1,!>=2}
  known always {!<=-1,!>=2}
  = always 1
  true always 1
Line 3395
  = always !0
  tok always !0
Line 3396
  . always {!<=-1,!>=2}
  known always {!<=-1,!>=2}
  = always 0
  false always 0
Line 3399
  return always {!<=-1,!>=2}
  true always 1
Line 3404
  ! always {!<=-1,!>=2}
  dim always symbolic=(mNameToken)
Line 3408
  dim possible symbolic=(mTypeEndToken)
  && always {!<=-1,!>=2}
  dim {symbolic=(mTypeEndToken),!0}
  == always {!<=-1,!>=2}
  "]" always "]"
Line 3409
  dim always !0
Line 3411
  dim possible {symbolic=(mNameToken),symbolic=(mTypeEndToken),0}
Line 3412
  dim always !0
Line 3413
  dim possible 0
  && always {!<=-1,!>=2}
  dim always !0
  == always {!<=-1,!>=2}
  ")" always ")"
Line 3414
  dim always !0
Line 3416
  arr always {!<=-1,!>=2}
  arr always {!<=-1,!>=2}
  = always 0
  false always 0
Line 3417
  dim possible 0
  && always {!<=-1,!>=2}
  dim always !0
  && always {!<=-1,!>=2}
  dim always !0
  == always {!<=-1,!>=2}
  "[" always "["
Line 3419
  . always {!<=-1,!>=2}
  known always {!<=-1,!>=2}
  = always 0
  false always 0
Line 3421
  dim always !0
  ( always !0
  != always {!<=-1,!>=2}
  "]" always "]"
Line 3422
  dim always !0
Line 3423
  ( possible 0
  . possible 0
Line 3424
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 3426
  . always {!<=-1,!>=2}
  known always {!<=-1,!>=2}
  = always 1
  true always 1
Line 3430
  dim always !0
Line 3431
  arr always {!<=-1,!>=2}
  = always 1
  true always 1
Line 3433
  return always {!<=-1,!>=2}
  arr {!<=-1,!>=2,0,1}
Line 3438
  type possible {1,2,3,4,6,7,8,9,10,11}
  == {!<=-1,!>=2,0}
  :: always 0
  eGlobal always 0
  ? possible "Global"
  "Global" always "Global"
  : always "Global"
Line 3439
  type possible {2,3,4,6,7,8,9,10,11,13}
  == {!<=-1,!>=2,0}
  :: always 1
  eClass always 1
  ? possible "Class"
  "Class" always "Class"
  : always "Class"
Line 3440
  type possible {3,4,6,7,8,9,10,11,13,14}
  == {!<=-1,!>=2,0}
  :: always 2
  eStruct always 2
  ? possible "Struct"
  "Struct" always "Struct"
  : always "Struct"
Line 3441
  type possible {4,6,7,8,9,10,11,13,14,12}
  == {!<=-1,!>=2,0}
  :: always 3
  eUnion always 3
  ? possible "Union"
  "Union" always "Union"
  : always "Union"
Line 3442
  type possible {6,7,8,9,10,11,13,14,12,15}
  == {!<=-1,!>=2,0}
  :: always 4
  eNamespace always 4
  ? possible "Namespace"
  "Namespace" always "Namespace"
  : always "Namespace"
Line 3443
  type possible {6,7,8,9,10,11,13,14,12,15}
  == always {!<=-1,!>=2}
  ? possible "Function"
  "Function" always "Function"
  : always "Function"
Line 3444
  type possible {7,8,9,10,11,13,14,12,15,16}
  == {!<=-1,!>=2,0}
  :: always 6
  eIf always 6
  ? possible "If"
  "If" always "If"
  : always "If"
Line 3445
  type {8,9,10,11,13,14,12,15,16,!0}
  == {!<=-1,!>=2,0}
  :: always 7
  eElse always 7
  ? possible "Else"
  "Else" always "Else"
  : always "Else"
Line 3446
  type {9,10,11,13,14,12,15,16,!0,!1}
  == {!<=-1,!>=2,0}
  :: always 8
  eFor always 8
  ? possible "For"
  "For" always "For"
  : always "For"
Line 3447
  type {10,11,13,14,12,15,16,!0,!1,!2}
  == {!<=-1,!>=2,0}
  :: always 9
  eWhile always 9
  ? possible "While"
  "While" always "While"
  : always "While"
Line 3448
  type {11,13,14,12,15,16,!0,!1,!2,!3}
  == {!<=-1,!>=2,0}
  :: always 10
  eDo always 10
  ? possible "Do"
  "Do" always "Do"
  : always "Do"
Line 3449
  type {13,14,12,15,16,!0,!1,!2,!3,!4}
  == {!<=-1,!>=2,0}
  :: always 11
  eSwitch always 11
  ? possible "Switch"
  "Switch" always "Switch"
  : always "Switch"
Line 3450
  type {14,12,15,16,!0,!1,!2,!3,!4,!6}
  == {!<=-1,!>=2,0}
  :: always 13
  eTry always 13
  ? possible "Try"
  "Try" always "Try"
  : always "Try"
Line 3451
  type {12,15,16,!0,!1,!2,!3,!4,!6,!7}
  == {!<=-1,!>=2,0}
  :: always 14
  eCatch always 14
  ? possible "Catch"
  "Catch" always "Catch"
  : always "Catch"
Line 3452
  type {15,16,!0,!1,!2,!3,!4,!6,!7,!8}
  == {!<=-1,!>=2,0}
  :: always 12
  eUnconditional always 12
  ? possible "Unconditional"
  "Unconditional" always "Unconditional"
  : always "Unconditional"
Line 3453
  type {16,!0,!1,!2,!3,!4,!6,!7,!8,!9}
  == {!<=-1,!>=2,0}
  :: always 15
  eLambda always 15
  ? possible "Lambda"
  "Lambda" always "Lambda"
  : always "Lambda"
Line 3454
  type always {!0,!1,!2,!3,!4,!6,!7,!8,!9,!10}
  == always {!<=-1,!>=2}
  :: always 16
  eEnum always 16
  ? possible {"Enum","Unknown"}
  "Enum" always "Enum"
  : always "Unknown"
Line 3455
  "Unknown" always "Unknown"
Line 3463
  "Public" always "Public"
Line 3464
  :: always 1
  Protected always 1
Line 3465
  "Protected" always "Protected"
Line 3466
  :: always 2
  Private always 2
Line 3467
  "Private" always "Private"
Line 3468
  :: always 3
  Global always 3
Line 3469
  "Global" always "Global"
Line 3470
  :: always 4
  Namespace always 4
Line 3471
  "Namespace" always "Namespace"
Line 3472
  :: always 5
  Argument always 5
Line 3473
  "Argument" always "Argument"
Line 3475
  "Local" always "Local"
Line 3476
  :: always 7
  Throw always 7
Line 3477
  "Throw" always "Throw"
Line 3479
  "Unknown" always "Unknown"
Line 3485
  tok possible 0@231
Line 3486
  tok always !0
  " " always " "
Line 3487
  tok always !0
  " " always " "
Line 3489
  tok possible 0
Line 3497
  scope always !0
  " " always " "
Line 3498
  ! {!<=-1,!>=2,0}
  scope always !0
  . possible size=0
  ( {!<=-1,!>=2,1}
Line 3499
  scope always !0
  . always !size=0
  " " always " "
Line 3500
  scope always !0
Line 3501
  scope always !0
  . always !0
  " " always " "
Line 3503
  scope possible 0
Line 3511
  tok always !0
  ( always {!<=-1,!>=2}
Line 3512
  "unsigned " always "unsigned "
Line 3513
  tok always !0
  ( always {!<=-1,!>=2}
Line 3514
  "signed " always "signed "
Line 3515
  tok always !0
  ( always {!<=-1,!>=2}
Line 3516
  "_Complex " always "_Complex "
Line 3517
  tok always !0
  ( always {!<=-1,!>=2}
Line 3518
  "long " always "long "
Line 3519
  tok always !0
Line 3526
  indent possible {"            "@215,"        "@216}
  "mNameToken: " always "mNameToken: "
  var possible lifetime[Object]=(scopeList)@215
  ( possible 0
Line 3527
  var possible lifetime[Object]=(scopeList)@215
  ( possible 0
Line 3528
  "    declarationId: " always "    declarationId: "
Line 3530
  indent possible {"            "@215,"        "@216}
  "mTypeStartToken: " always "mTypeStartToken: "
  var possible lifetime[Object]=(scopeList)@215
  ( possible 0
Line 3531
  indent possible {"            "@215,"        "@216}
  "mTypeEndToken: " always "mTypeEndToken: "
  var possible lifetime[Object]=(scopeList)@215
Line 3533
  var possible lifetime[Object]=(scopeList)@215
Line 3534
  = always 0
  nullptr always 0
Line 3535
  "   " always "   "
Line 3536
  = always !0
  ( always !0
  != always {!<=-1,!>=2}
  tok possible symbolic=(autoTok)
Line 3537
  " " always " "
Line 3538
  == always {!<=-1,!>=2}
  "auto" always "auto"
Line 3542
  autoTok possible 0
Line 3543
  autoTok always !0
Line 3544
  "    auto valueType: " always "    auto valueType: "
  valueType always symbolic=(autoTok->valueType())
Line 3545
  ( always !0
Line 3546
  "        " always "        "
  valueType always symbolic=(autoTok->valueType())
Line 3550
  "   " always "   "
  ( always !0
Line 3552
  indent possible {"            "@215,"        "@216}
  "mIndex: " always "mIndex: "
  var possible lifetime[Object]=(scopeList)@215
Line 3553
  indent possible {"            "@215,"        "@216}
  "mAccess: " always "mAccess: "
  var possible lifetime[Object]=(scopeList)@215
Line 3554
  indent possible {"            "@215,"        "@216}
  "mFlags: " always "mFlags: "
Line 3555
  indent possible {"            "@215,"        "@216}
  "    isMutable: " always "    isMutable: "
  var possible lifetime[Object]=(scopeList)@215
  ( always {!<=-1,!>=2}
Line 3556
  indent possible {"            "@215,"        "@216}
  "    isStatic: " always "    isStatic: "
  var possible lifetime[Object]=(scopeList)@215
  ( always {!<=-1,!>=2}
Line 3557
  indent possible {"            "@215,"        "@216}
  "    isExtern: " always "    isExtern: "
  var possible lifetime[Object]=(scopeList)@215
  ( always {!<=-1,!>=2}
Line 3558
  indent possible {"            "@215,"        "@216}
  "    isLocal: " always "    isLocal: "
  var possible lifetime[Object]=(scopeList)@215
  ( always {!<=-1,!>=2}
Line 3559
  indent possible {"            "@215,"        "@216}
  "    isConst: " always "    isConst: "
  var possible lifetime[Object]=(scopeList)@215
  ( always {!<=-1,!>=2}
Line 3560
  indent possible {"            "@215,"        "@216}
  "    isClass: " always "    isClass: "
  var possible lifetime[Object]=(scopeList)@215
  ( always {!<=-1,!>=2}
Line 3561
  indent possible {"            "@215,"        "@216}
  "    isArray: " always "    isArray: "
  var possible lifetime[Object]=(scopeList)@215
  ( always {!<=-1,!>=2}
Line 3562
  indent possible {"            "@215,"        "@216}
  "    isPointer: " always "    isPointer: "
  var possible lifetime[Object]=(scopeList)@215
  ( always {!<=-1,!>=2}
Line 3563
  indent possible {"            "@215,"        "@216}
  "    isReference: " always "    isReference: "
  var possible lifetime[Object]=(scopeList)@215
  ( always {!<=-1,!>=2}
Line 3564
  indent possible {"            "@215,"        "@216}
  "    isRValueRef: " always "    isRValueRef: "
  var possible lifetime[Object]=(scopeList)@215
  ( always {!<=-1,!>=2}
Line 3565
  indent possible {"            "@215,"        "@216}
  "    hasDefault: " always "    hasDefault: "
  var possible lifetime[Object]=(scopeList)@215
  ( always {!<=-1,!>=2}
Line 3566
  indent possible {"            "@215,"        "@216}
  "    isStlType: " always "    isStlType: "
  var possible lifetime[Object]=(scopeList)@215
  ( always {!<=-1,!>=2}
Line 3567
  indent possible {"            "@215,"        "@216}
  "mType: " always "mType: "
Line 3568
  var possible lifetime[Object]=(scopeList)@215
Line 3569
  ( always !0
  " " always " "
  ( always !0
Line 3570
  " " always " "
  ( always !0
Line 3571
  " " always " "
  ( always !0
Line 3573
  "none" always "none"
Line 3575
  var possible lifetime[Object]=(scopeList)@215
Line 3576
  ( always !0
Line 3577
  "valueType: " always "valueType: "
  valueType {symbolic=(var->nameToken()->valueType()),0}
Line 3578
  valueType always symbolic=(var->nameToken()->valueType())
Line 3579
  "    " always "    "
  valueType {symbolic=(var->nameToken()->valueType()),!0}
Line 3583
  indent possible {"            "@215,"        "@216}
  "mScope: " always "mScope: "
  var possible lifetime[Object]=(scopeList)@215
Line 3585
  indent possible {"            "@215,"        "@216}
  "mDimensions:" always "mDimensions:"
Line 3586
  i always !<=-1
  = always 0
  0 always 0
  i {!<=-1,0}
  < always {!<=-1,!>=2}
  var possible lifetime[Object]=(scopeList)@215
  ( always !<=-1
  i always !<=-1
  ++ always !<=-1
Line 3587
  " " always " "
  var possible lifetime[Object]=(scopeList)@215
  i {!<=-1,<=symbolic=(var->dimensions().size()-1),!>=symbolic=(var->dimensions().size())}
Line 3588
  ! always {!<=-1,!>=2}
  var possible lifetime[Object]=(scopeList)@215
  i {!<=-1,<=symbolic=(var->dimensions().size()-1),!>=symbolic=(var->dimensions().size())}
  . always {!<=-1,!>=2}
Line 3589
  "?" always "?"
Line 3598
  "\n### " always "\n### "
  title always !0
  " ###\n" always " ###\n"
Line 3600
  = {lifetime[Iterator]=(scopeList),start=0}
  ( {lifetime[Iterator]=(scopeList),start=0}
  scope possible {lifetime[Iterator]=(scopeList),start=0}
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(scopeList),end=0}
  scope possible lifetime[Iterator]=(scopeList)
Line 3601
  "Scope: " always "Scope: "
  & {lifetime[Object]=(scopeList),!0}
  scope possible lifetime[Iterator]=(scopeList)
  " " always " "
  scope possible lifetime[Iterator]=(scopeList)
Line 3602
  "    className: " always "    className: "
  scope possible lifetime[Iterator]=(scopeList)
Line 3603
  "    classDef: " always "    classDef: "
  scope possible lifetime[Iterator]=(scopeList)
Line 3604
  "    bodyStart: " always "    bodyStart: "
  scope possible lifetime[Iterator]=(scopeList)
Line 3605
  "    bodyEnd: " always "    bodyEnd: "
  scope possible lifetime[Iterator]=(scopeList)
Line 3610
  = {lifetime[Iterator]=(scope->functionList),lifetime[Object]=(scopeList),start=0}
  scope possible lifetime[Iterator]=(scopeList)
  ( {lifetime[Iterator]=(scope->functionList),lifetime[Object]=(scopeList),start=0}
  func possible {lifetime[Iterator]=(scope->functionList),lifetime[Object]=(scopeList),start=0}
  != always {!<=-1,!>=2}
  scope possible lifetime[Iterator]=(scopeList)
  ( {lifetime[Iterator]=(scope->functionList),lifetime[Object]=(scopeList),end=0}
  func possible {lifetime[Iterator]=(scope->functionList),lifetime[Object]=(scopeList)}
Line 3611
  "    Function: " always "    Function: "
  & {lifetime[Object]=(scopeList),!0}
  func possible {lifetime[Iterator]=(scope->functionList),lifetime[Object]=(scopeList)}
Line 3612
  "        name: " always "        name: "
  func possible {lifetime[Iterator]=(scope->functionList),lifetime[Object]=(scopeList)}
Line 3613
  "        type: " always "        type: "
  func possible {lifetime[Iterator]=(scope->functionList),lifetime[Object]=(scopeList)}
  . possible {1,2,3,4,6}
  == {!<=-1,!>=2,0}
  :: always 0
  eConstructor always 0
  "Constructor" always "Constructor"
  : always "Constructor"
Line 3614
  func possible {lifetime[Iterator]=(scope->functionList),lifetime[Object]=(scopeList)}
  . {2,3,4,6,!0}
  == {!<=-1,!>=2,0}
  :: always 1
  eCopyConstructor always 1
  "CopyConstructor" always "CopyConstructor"
  : always "CopyConstructor"
Line 3615
  func possible {lifetime[Iterator]=(scope->functionList),lifetime[Object]=(scopeList)}
  . {3,4,6,!0,!1}
  == {!<=-1,!>=2,0}
  :: always 2
  eMoveConstructor always 2
  "MoveConstructor" always "MoveConstructor"
  : always "MoveConstructor"
Line 3616
  func possible {lifetime[Iterator]=(scope->functionList),lifetime[Object]=(scopeList)}
  . {4,6,!0,!1,!2}
  == {!<=-1,!>=2,0}
  :: always 3
  eOperatorEqual always 3
  "OperatorEqual" always "OperatorEqual"
  : always "OperatorEqual"
Line 3617
  func possible {lifetime[Iterator]=(scope->functionList),lifetime[Object]=(scopeList)}
  . {6,!0,!1,!2,!3}
  == {!<=-1,!>=2,0}
  :: always 4
  eDestructor always 4
  "Destructor" always "Destructor"
  : always "Destructor"
Line 3618
  func possible {lifetime[Iterator]=(scope->functionList),lifetime[Object]=(scopeList)}
  . {6,!0,!1,!2,!3,!4}
  == always {!<=-1,!>=2}
  "Function" always "Function"
  : always "Function"
Line 3619
  func possible {lifetime[Iterator]=(scope->functionList),lifetime[Object]=(scopeList)}
  . always {!0,!1,!2,!3,!4}
  == always {!<=-1,!>=2}
  :: always 6
  eLambda always 6
  "Lambda" always "Lambda"
  : always "Unknown"
Line 3620
  "Unknown" always "Unknown"
Line 3621
  "        access: " always "        access: "
  func possible {lifetime[Iterator]=(scope->functionList),lifetime[Object]=(scopeList)}
Line 3622
  "        hasBody: " always "        hasBody: "
  func possible {lifetime[Iterator]=(scope->functionList),lifetime[Object]=(scopeList)}
  ( always {!<=-1,!>=2}
Line 3623
  "        isInline: " always "        isInline: "
  func possible {lifetime[Iterator]=(scope->functionList),lifetime[Object]=(scopeList)}
  ( always {!<=-1,!>=2}
Line 3624
  "        isConst: " always "        isConst: "
  func possible {lifetime[Iterator]=(scope->functionList),lifetime[Object]=(scopeList)}
  ( always {!<=-1,!>=2}
Line 3625
  "        hasVirtualSpecifier: " always "        hasVirtualSpecifier: "
  func possible {lifetime[Iterator]=(scope->functionList),lifetime[Object]=(scopeList)}
  ( always {!<=-1,!>=2}
Line 3626
  "        isPure: " always "        isPure: "
  func possible {lifetime[Iterator]=(scope->functionList),lifetime[Object]=(scopeList)}
  ( always {!<=-1,!>=2}
Line 3627
  "        isStatic: " always "        isStatic: "
  func possible {lifetime[Iterator]=(scope->functionList),lifetime[Object]=(scopeList)}
  ( always {!<=-1,!>=2}
Line 3628
  "        isStaticLocal: " always "        isStaticLocal: "
  func possible {lifetime[Iterator]=(scope->functionList),lifetime[Object]=(scopeList)}
  ( always {!<=-1,!>=2}
Line 3629
  "        isExtern: " always "        isExtern: "
  func possible {lifetime[Iterator]=(scope->functionList),lifetime[Object]=(scopeList)}
  ( always {!<=-1,!>=2}
Line 3630
  "        isFriend: " always "        isFriend: "
  func possible {lifetime[Iterator]=(scope->functionList),lifetime[Object]=(scopeList)}
  ( always {!<=-1,!>=2}
Line 3631
  "        isExplicit: " always "        isExplicit: "
  func possible {lifetime[Iterator]=(scope->functionList),lifetime[Object]=(scopeList)}
  ( always {!<=-1,!>=2}
Line 3632
  "        isDefault: " always "        isDefault: "
  func possible {lifetime[Iterator]=(scope->functionList),lifetime[Object]=(scopeList)}
  ( always {!<=-1,!>=2}
Line 3633
  "        isDelete: " always "        isDelete: "
  func possible {lifetime[Iterator]=(scope->functionList),lifetime[Object]=(scopeList)}
  ( always {!<=-1,!>=2}
Line 3634
  "        hasOverrideSpecifier: " always "        hasOverrideSpecifier: "
  func possible {lifetime[Iterator]=(scope->functionList),lifetime[Object]=(scopeList)}
  ( always {!<=-1,!>=2}
Line 3635
  "        hasFinalSpecifier: " always "        hasFinalSpecifier: "
  func possible {lifetime[Iterator]=(scope->functionList),lifetime[Object]=(scopeList)}
  ( always {!<=-1,!>=2}
Line 3636
  "        isNoExcept: " always "        isNoExcept: "
  func possible {lifetime[Iterator]=(scope->functionList),lifetime[Object]=(scopeList)}
  ( always {!<=-1,!>=2}
Line 3637
  "        isThrow: " always "        isThrow: "
  func possible {lifetime[Iterator]=(scope->functionList),lifetime[Object]=(scopeList)}
  ( always {!<=-1,!>=2}
Line 3638
  "        isOperator: " always "        isOperator: "
  func possible {lifetime[Iterator]=(scope->functionList),lifetime[Object]=(scopeList)}
  ( always {!<=-1,!>=2}
Line 3639
  "        hasLvalRefQual: " always "        hasLvalRefQual: "
  func possible {lifetime[Iterator]=(scope->functionList),lifetime[Object]=(scopeList)}
  ( always {!<=-1,!>=2}
Line 3640
  "        hasRvalRefQual: " always "        hasRvalRefQual: "
  func possible {lifetime[Iterator]=(scope->functionList),lifetime[Object]=(scopeList)}
  ( always {!<=-1,!>=2}
Line 3641
  "        isVariadic: " always "        isVariadic: "
  func possible {lifetime[Iterator]=(scope->functionList),lifetime[Object]=(scopeList)}
  ( always {!<=-1,!>=2}
Line 3642
  "        isVolatile: " always "        isVolatile: "
  func possible {lifetime[Iterator]=(scope->functionList),lifetime[Object]=(scopeList)}
  ( always {!<=-1,!>=2}
Line 3643
  "        hasTrailingReturnType: " always "        hasTrailingReturnType: "
  func possible {lifetime[Iterator]=(scope->functionList),lifetime[Object]=(scopeList)}
  ( always {!<=-1,!>=2}
Line 3644
  "        attributes:" always "        attributes:"
Line 3645
  func possible {lifetime[Iterator]=(scope->functionList),lifetime[Object]=(scopeList)}
  ( always {!<=-1,!>=2}
Line 3646
  " const " always " const "
Line 3647
  func possible {lifetime[Iterator]=(scope->functionList),lifetime[Object]=(scopeList)}
  ( always {!<=-1,!>=2}
Line 3648
  " pure " always " pure "
Line 3649
  func possible {lifetime[Iterator]=(scope->functionList),lifetime[Object]=(scopeList)}
  ( always {!<=-1,!>=2}
Line 3650
  " noreturn " always " noreturn "
Line 3651
  func possible {lifetime[Iterator]=(scope->functionList),lifetime[Object]=(scopeList)}
  ( always {!<=-1,!>=2}
Line 3652
  " nothrow " always " nothrow "
Line 3653
  func possible {lifetime[Iterator]=(scope->functionList),lifetime[Object]=(scopeList)}
  ( always {!<=-1,!>=2}
Line 3654
  " constructor " always " constructor "
Line 3655
  func possible {lifetime[Iterator]=(scope->functionList),lifetime[Object]=(scopeList)}
  ( always {!<=-1,!>=2}
Line 3656
  " destructor " always " destructor "
Line 3657
  func possible {lifetime[Iterator]=(scope->functionList),lifetime[Object]=(scopeList)}
  ( always {!<=-1,!>=2}
Line 3658
  " nodiscard " always " nodiscard "
Line 3660
  "        noexceptArg: " always "        noexceptArg: "
  func possible {lifetime[Iterator]=(scope->functionList),lifetime[Object]=(scopeList)}
  func possible {lifetime[Iterator]=(scope->functionList),lifetime[Object]=(scopeList)}
  : always "none"
  "none" always "none"
Line 3661
  "        throwArg: " always "        throwArg: "
  func possible {lifetime[Iterator]=(scope->functionList),lifetime[Object]=(scopeList)}
  func possible {lifetime[Iterator]=(scope->functionList),lifetime[Object]=(scopeList)}
  : always "none"
  "none" always "none"
Line 3662
  "        tokenDef: " always "        tokenDef: "
  func possible {lifetime[Iterator]=(scope->functionList),lifetime[Object]=(scopeList)}
Line 3663
  "        argDef: " always "        argDef: "
  func possible {lifetime[Iterator]=(scope->functionList),lifetime[Object]=(scopeList)}
Line 3664
  ! always {!<=-1,!>=2}
  func possible {lifetime[Iterator]=(scope->functionList),lifetime[Object]=(scopeList)}
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  func possible {lifetime[Iterator]=(scope->functionList),lifetime[Object]=(scopeList)}
  ( always {!<=-1,!>=2}
Line 3665
  "        retDef: " always "        retDef: "
  func possible {lifetime[Iterator]=(scope->functionList),lifetime[Object]=(scopeList)}
Line 3666
  func possible {lifetime[Iterator]=(scope->functionList),lifetime[Object]=(scopeList)}
Line 3667
  "           " always "           "
Line 3668
  = always !0
  func possible {lifetime[Iterator]=(scope->functionList),lifetime[Object]=(scopeList)}
  . always !0
  && always {!<=-1,!>=2}
  tok always !0
  != always {!<=-1,!>=2}
  func possible {lifetime[Iterator]=(scope->functionList),lifetime[Object]=(scopeList)}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  tok always {!symbolic=(func->tokenDef),!0}
  "{|;|override|final" always "{|;|override|final"
Line 3669
  " " always " "
Line 3672
  "        retType: " always "        retType: "
  func possible {lifetime[Iterator]=(scope->functionList),lifetime[Object]=(scopeList)}
Line 3674
  func possible {lifetime[Iterator]=(scope->functionList),lifetime[Object]=(scopeList)}
  ( possible 0
Line 3675
  = always !0
  func possible {lifetime[Iterator]=(scope->functionList),lifetime[Object]=(scopeList)}
  ( always !0
Line 3676
  "        valueType: " always "        valueType: "
  valueType {symbolic=(func->tokenDef->next()->valueType()),!0}
Line 3677
  valueType always {1,symbolic=(func->tokenDef->next()->valueType())}
Line 3678
  "            " always "            "
  valueType {symbolic=(func->tokenDef->next()->valueType()),!0}
Line 3682
  func possible {lifetime[Iterator]=(scope->functionList),lifetime[Object]=(scopeList)}
  ( always {!<=-1,!>=2}
Line 3683
  "        token: " always "        token: "
  func possible {lifetime[Iterator]=(scope->functionList),lifetime[Object]=(scopeList)}
Line 3684
  "        arg: " always "        arg: "
  func possible {lifetime[Iterator]=(scope->functionList),lifetime[Object]=(scopeList)}
Line 3686
  "        nestedIn: " always "        nestedIn: "
  func possible {lifetime[Iterator]=(scope->functionList),lifetime[Object]=(scopeList)}
Line 3687
  "        functionScope: " always "        functionScope: "
  func possible {lifetime[Iterator]=(scope->functionList),lifetime[Object]=(scopeList)}
Line 3691
  = {lifetime[Iterator]=(func->argumentList),lifetime[Object]=(scopeList),start=0}
  func possible {lifetime[Iterator]=(scope->functionList),lifetime[Object]=(scopeList)}
  ( {lifetime[Iterator]=(func->argumentList),lifetime[Object]=(scopeList),start=0}
  var possible {lifetime[Iterator]=(func->argumentList),lifetime[Object]=(scopeList),start=0}
  != always {!<=-1,!>=2}
  func possible {lifetime[Iterator]=(scope->functionList),lifetime[Object]=(scopeList)}
  ( {lifetime[Iterator]=(func->argumentList),lifetime[Object]=(scopeList),end=0}
  var possible {lifetime[Iterator]=(func->argumentList),lifetime[Object]=(scopeList)}
Line 3692
  "        Variable: " always "        Variable: "
  & {lifetime[Object]=(scopeList),!0}
  var {lifetime[Iterator]=(func->argumentList),lifetime[Object]=(scopeList),!symbolic=(func->argumentList.end()),!end=0}
Line 3693
  & {lifetime[Object]=(scopeList),!0}
  var {lifetime[Iterator]=(func->argumentList),lifetime[Object]=(scopeList),!end=0}
  "            " always "            "
Line 3699
  = {lifetime[Iterator]=(scope->varlist),lifetime[Object]=(scopeList),start=0}
  scope possible lifetime[Iterator]=(scopeList)
  ( {lifetime[Iterator]=(scope->varlist),lifetime[Object]=(scopeList),start=0}
  var possible {lifetime[Iterator]=(scope->varlist),lifetime[Object]=(scopeList),start=0}
  != always {!<=-1,!>=2}
  scope possible lifetime[Iterator]=(scopeList)
  ( {lifetime[Iterator]=(scope->varlist),lifetime[Object]=(scopeList),end=0}
  var possible {lifetime[Iterator]=(scope->varlist),lifetime[Object]=(scopeList)}
Line 3700
  "    Variable: " always "    Variable: "
  & {lifetime[Object]=(scopeList),!0}
  var {lifetime[Iterator]=(scope->varlist),lifetime[Object]=(scopeList),!symbolic=(scope->varlist.end()),!end=0}
Line 3701
  & {lifetime[Object]=(scopeList),!0}
  var {lifetime[Iterator]=(scope->varlist),lifetime[Object]=(scopeList),!end=0}
  "        " always "        "
Line 3704
  scope possible lifetime[Iterator]=(scopeList)
  == always {!<=-1,!>=2}
  :: always 16
  eEnum always 16
Line 3705
  "    enumType: " always "    enumType: "
Line 3706
  scope possible lifetime[Iterator]=(scopeList)
Line 3707
  scope possible lifetime[Iterator]=(scopeList)
  false always 0
  true always 1
  false always 0
Line 3709
  "int" always "int"
Line 3711
  "    enumClass: " always "    enumClass: "
  scope possible lifetime[Iterator]=(scopeList)
  . always {!<=-1,!>=2}
  enumClass always {!<=-1,!>=2}
Line 3712
  scope possible lifetime[Iterator]=(scopeList)
Line 3713
  "        Enumerator: " always "        Enumerator: "
  " = " always " = "
Line 3714
  . {!<=-1,!>=2,0}
  value_known always {!<=-1,!>=2}
Line 3718
  = always !0
  . always !0
Line 3719
  . always {!<=-1,!>=2}
  value_known always {!<=-1,!>=2}
  " " always " "
  : always ""
  "" always ""
  "[" always "["
  tok {symbolic=(enumerator.start),!0}
Line 3720
  tok possible symbolic=(enumerator.start)
  && always {!<=-1,!>=2}
  tok {symbolic=(enumerator.start),!0}
  != always {!<=-1,!>=2}
Line 3721
  tok always {!symbolic=(enumerator.end),!0}
  ( possible {symbolic=(enumerator.end),0}
Line 3722
  " " always " "
  tok always {!symbolic=(enumerator.end),!0}
  ( {symbolic=(enumerator.end),!0}
Line 3723
  = possible 0
  tok always {!symbolic=(enumerator.end),!0}
  ( possible 0
Line 3726
  "]" always "]"
Line 3733
  "    nestedIn: " always "    nestedIn: "
  scope possible lifetime[Iterator]=(scopeList)
  . possible 0
Line 3734
  scope possible lifetime[Iterator]=(scopeList)
Line 3735
  " " always " "
  scope possible lifetime[Iterator]=(scopeList)
  . always !0
  " " always " "
Line 3736
  scope possible lifetime[Iterator]=(scopeList)
  . always !0
Line 3740
  "    definedType: " always "    definedType: "
  scope possible lifetime[Iterator]=(scopeList)
Line 3742
  "    nestedList[" always "    nestedList["
  scope possible lifetime[Iterator]=(scopeList)
  ( always !<=-1
  "] = (" always "] = ("
Line 3746
  count always !<=-1
  count always !<=-1
  = always !<=-1
  scope possible lifetime[Iterator]=(scopeList)
  ( always !<=-1
Line 3747
  = {lifetime[Iterator]=(scope->nestedList),lifetime[Object]=(scopeList),start=0}
  scope possible lifetime[Iterator]=(scopeList)
  ( {lifetime[Iterator]=(scope->nestedList),lifetime[Object]=(scopeList),start=0}
  nsi possible {lifetime[Iterator]=(scope->nestedList),lifetime[Object]=(scopeList),start=0}
  != always {!<=-1,!>=2}
  scope possible lifetime[Iterator]=(scopeList)
  ( {lifetime[Iterator]=(scope->nestedList),lifetime[Object]=(scopeList),end=0}
  nsi possible {lifetime[Iterator]=(scope->nestedList),lifetime[Object]=(scopeList)}
Line 3748
  " " always " "
  nsi {lifetime[Iterator]=(scope->nestedList),lifetime[Object]=(scopeList),!symbolic=(scope->nestedList.end()),!end=0}
  " " always " "
  nsi {lifetime[Iterator]=(scope->nestedList),lifetime[Object]=(scopeList),!symbolic=(scope->nestedList.end()),!end=0}
  " " always " "
  nsi {lifetime[Iterator]=(scope->nestedList),lifetime[Object]=(scopeList),!symbolic=(scope->nestedList.end()),!end=0}
Line 3749
  count always !<=-1
  -- always !<=-1
  > always {!<=-1,!>=2}
  1 always 1
Line 3750
  "," always ","
Line 3753
  " )" always " )"
Line 3757
  = {lifetime[Iterator]=(scope->usingList),lifetime[Object]=(scopeList),start=0}
  scope possible lifetime[Iterator]=(scopeList)
  ( {lifetime[Iterator]=(scope->usingList),lifetime[Object]=(scopeList),start=0}
  use possible {lifetime[Iterator]=(scope->usingList),lifetime[Object]=(scopeList),start=0}
  != always {!<=-1,!>=2}
  scope possible lifetime[Iterator]=(scopeList)
  ( {lifetime[Iterator]=(scope->usingList),lifetime[Object]=(scopeList),end=0}
  use possible {lifetime[Iterator]=(scope->usingList),lifetime[Object]=(scopeList)}
Line 3758
  "    using: " always "    using: "
  use {lifetime[Iterator]=(scope->usingList),lifetime[Object]=(scopeList),!symbolic=(scope->usingList.end()),!end=0}
  " " always " "
  use {lifetime[Iterator]=(scope->usingList),lifetime[Object]=(scopeList),!symbolic=(scope->usingList.end()),!end=0}
  2 always 2
Line 3759
  use {lifetime[Iterator]=(scope->usingList),lifetime[Object]=(scopeList),!end=0}
  3 always 3
Line 3760
  && always {!<=-1,!>=2}
  tok1 always !0
  == always {!<=-1,!>=2}
  "::" always "::"
Line 3761
  "::" always "::"
  tok1 always !0
  1 always 1
Line 3762
  tok1 always !0
  2 always 2
Line 3764
  " " always " "
  use {lifetime[Iterator]=(scope->usingList),lifetime[Object]=(scopeList),!end=0}
Line 3767
  "    functionOf: " always "    functionOf: "
  scope possible lifetime[Iterator]=(scopeList)
Line 3769
  "    function: " always "    function: "
  scope possible lifetime[Iterator]=(scopeList)
  . possible 0
Line 3770
  scope possible lifetime[Iterator]=(scopeList)
Line 3771
  " " always " "
  scope possible lifetime[Iterator]=(scopeList)
Line 3775
  = {lifetime[Iterator]=(typeList),start=0}
  ( {lifetime[Iterator]=(typeList),start=0}
  type possible {lifetime[Iterator]=(typeList),start=0}
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(typeList),end=0}
  type possible lifetime[Iterator]=(typeList)
Line 3776
  "Type: " always "Type: "
  & {lifetime[Object]=(typeList),!0}
  type {lifetime[Iterator]=(typeList),!symbolic=(typeList.end()),!end=0}
Line 3777
  "    name: " always "    name: "
  type {lifetime[Iterator]=(typeList),!symbolic=(typeList.end()),!end=0}
Line 3778
  "    classDef: " always "    classDef: "
  type {lifetime[Iterator]=(typeList),!symbolic=(typeList.end()),!end=0}
Line 3779
  "    classScope: " always "    classScope: "
  type {lifetime[Iterator]=(typeList),!symbolic=(typeList.end()),!end=0}
Line 3780
  "    enclosingScope: " always "    enclosingScope: "
  type {lifetime[Iterator]=(typeList),!symbolic=(typeList.end()),!end=0}
  . possible 0
Line 3781
  type {lifetime[Iterator]=(typeList),!symbolic=(typeList.end()),!end=0}
Line 3782
  " " always " "
  type {lifetime[Iterator]=(typeList),!symbolic=(typeList.end()),!end=0}
  . always !0
  " " always " "
Line 3783
  type {lifetime[Iterator]=(typeList),!symbolic=(typeList.end()),!end=0}
  . always !0
Line 3786
  "    needInitialization: " always "    needInitialization: "
  type {lifetime[Iterator]=(typeList),!symbolic=(typeList.end()),!end=0}
  . possible {1,2}
  == always {!<=-1,!>=2}
  "Unknown" always "Unknown"
  : always "Unknown"
Line 3787
  type {lifetime[Iterator]=(typeList),!symbolic=(typeList.end()),!end=0}
  . possible 2
  == {!<=-1,!>=2,0}
  :: always 1
  True always 1
  "True" always "True"
  : always "True"
Line 3788
  type {lifetime[Iterator]=(typeList),!symbolic=(typeList.end()),!end=0}
  . always !1
  == always {!<=-1,!>=2}
  :: always 2
  False always 2
  "False" always "False"
  : always "Invalid"
Line 3789
  "Invalid" always "Invalid"
Line 3791
  "    derivedFrom[" always "    derivedFrom["
  type {lifetime[Iterator]=(typeList),!symbolic=(typeList.end()),!end=0}
  ( always !<=-1
  "] = (" always "] = ("
Line 3792
  count always !<=-1
  count always !<=-1
  = always !<=-1
  type {lifetime[Iterator]=(typeList),!symbolic=(typeList.end()),!end=0}
  ( always !<=-1
Line 3793
  type {lifetime[Iterator]=(typeList),!symbolic=(typeList.end()),!end=0}
Line 3794
  . always {!<=-1,!>=2}
  isVirtual always {!<=-1,!>=2}
Line 3795
  "Virtual " always "Virtual "
Line 3797
  . possible {1,2}
  == always {!<=-1,!>=2}
  " Public" always " Public"
  : always " Public"
Line 3798
  . possible 2
  == {!<=-1,!>=2,0}
  :: always 1
  Protected always 1
  " Protected" always " Protected"
  : always " Protected"
Line 3799
  . always !1
  == always {!<=-1,!>=2}
  :: always 2
  Private always 2
  " Private" always " Private"
  : always " Unknown"
Line 3800
  " Unknown" always " Unknown"
Line 3803
  " " always " "
  . always !0
Line 3805
  " Unknown" always " Unknown"
Line 3807
  " " always " "
Line 3808
  count always !<=-1
  -- always !<=-1
  > always {!<=-1,!>=2}
  1 always 1
Line 3809
  "," always ","
Line 3812
  " )" always " )"
Line 3814
  "    friendList[" always "    friendList["
  type {lifetime[Iterator]=(typeList),!symbolic=(typeList.end()),!end=0}
  ( always !<=-1
  "] = (" always "] = ("
Line 3815
  i always !<=-1
  = always 0
  0 always 0
  i {!<=-1,<=symbolic=(type->friendList.size()-1),>=symbolic=(type->friendList.size()),0}
  < always {!<=-1,!>=2}
  type {lifetime[Iterator]=(typeList),!symbolic=(typeList.end()),!end=0}
  ( always !<=-1
  i {!<=-1,<=symbolic=(type->friendList.size()-2),>=symbolic=(type->friendList.size()-1)}
  ++ {!<=-1,<=symbolic=(type->friendList.size()-2),>=symbolic=(type->friendList.size()-1)}
Line 3816
  type {lifetime[Iterator]=(typeList),!symbolic=(typeList.end()),!end=0}
  i {!<=-1,<=symbolic=(type->friendList.size()-1),!>=symbolic=(type->friendList.size())}
Line 3817
  type {lifetime[Iterator]=(typeList),!symbolic=(typeList.end()),!end=0}
  i always {!<=-1,!>=symbolic=(type->friendList.size())}
Line 3819
  " Unknown" always " Unknown"
Line 3821
  ' ' always 32
Line 3822
  type {lifetime[Iterator]=(typeList),!symbolic=(typeList.end()),!end=0}
  i always {!<=-1,!>=symbolic=(type->friendList.size())}
Line 3823
  type {lifetime[Iterator]=(typeList),!symbolic=(typeList.end()),!end=0}
  i always !<=-1
Line 3824
  i always !<=-1
  + always !<=0
  1 always 1
  < always {!<=-1,!>=2}
  type {lifetime[Iterator]=(typeList),!symbolic=(typeList.end()),!end=0}
  ( always !<=-1
Line 3825
  ',' always 44
Line 3828
  " )" always " )"
Line 3831
  i always !<=-1
  = always 1
  1 always 1
  i {!<=-1,1}
  < always {!<=-1,!>=2}
  ( always !<=-1
  i always !<=-1
  ++ always !<=-1
Line 3832
  "mVariableList[" always "mVariableList["
  i {!<=-1,<=symbolic=(mVariableList.size()-1),!>=symbolic=(mVariableList.size()),1}
  "]: " always "]: "
  [ possible 0
  i {!<=-1,<=symbolic=(mVariableList.size()-1),!>=symbolic=(mVariableList.size()),1}
Line 3833
  i {!<=-1,<=symbolic=(mVariableList.size()-1),!>=symbolic=(mVariableList.size()),1}
Line 3834
  " " always " "
  [ possible lifetime[Lambda]=(for(std::list<Scope>::const_iterator scope=scopeList.begin();scope!=scopeList.end();++scope))
  i always !<=-1
  " " always " "
Line 3835
  [ possible lifetime[Lambda]=(for(std::list<Scope>::const_iterator scope=scopeList.begin();scope!=scopeList.end();++scope))
  i always !<=-1
Line 3849
  "  <scopes>" always "  <scopes>"
Line 3850
  = {lifetime[Iterator]=(scopeList),start=0}
  ( {lifetime[Iterator]=(scopeList),start=0}
  scope possible {lifetime[Iterator]=(scopeList),start=0}
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(scopeList),end=0}
  scope possible lifetime[Iterator]=(scopeList)
Line 3851
  "    <scope" always "    <scope"
Line 3852
  " id=\"" always " id=\""
  & {lifetime[Object]=(scopeList),!0}
  scope {lifetime[Iterator]=(scopeList),!symbolic=(scopeList.end()),!end=0}
  "\"" always "\""
Line 3853
  " type=\"" always " type=\""
  scope {lifetime[Iterator]=(scopeList),!symbolic=(scopeList.end()),!end=0}
  "\"" always "\""
Line 3854
  ! {!<=-1,!>=2,0}
  scope {lifetime[Iterator]=(scopeList),!symbolic=(scopeList.end()),!end=0}
  . possible size=0
  ( {!<=-1,!>=2,1}
Line 3855
  " className=\"" always " className=\""
  scope {lifetime[Iterator]=(scopeList),!symbolic=(scopeList.end()),!end=0}
  . always !size=0
  "\"" always "\""
Line 3856
  scope {lifetime[Iterator]=(scopeList),!symbolic=(scopeList.end()),!end=0}
Line 3857
  " bodyStart=\"" always " bodyStart=\""
  scope {lifetime[Iterator]=(scopeList),!symbolic=(scopeList.end()),!end=0}
  . always !0
  '\"' always 34
Line 3858
  scope {lifetime[Iterator]=(scopeList),!symbolic=(scopeList.end()),!end=0}
Line 3859
  " bodyEnd=\"" always " bodyEnd=\""
  scope {lifetime[Iterator]=(scopeList),!symbolic=(scopeList.end()),!end=0}
  . always !0
  '\"' always 34
Line 3860
  scope {lifetime[Iterator]=(scopeList),!symbolic=(scopeList.end()),!end=0}
Line 3861
  " nestedIn=\"" always " nestedIn=\""
  scope {lifetime[Iterator]=(scopeList),!symbolic=(scopeList.end()),!end=0}
  . always !0
  "\"" always "\""
Line 3862
  scope {lifetime[Iterator]=(scopeList),!symbolic=(scopeList.end()),!end=0}
Line 3863
  " function=\"" always " function=\""
  scope {lifetime[Iterator]=(scopeList),!symbolic=(scopeList.end()),!end=0}
  . always !0
  "\"" always "\""
Line 3864
  scope {lifetime[Iterator]=(scopeList),!symbolic=(scopeList.end()),!end=0}
  ( {!<=-1,!>=2,0}
  && always {!<=-1,!>=2}
  scope {lifetime[Iterator]=(scopeList),!symbolic=(scopeList.end()),!end=0}
  ( always {!<=-1,!>=2}
Line 3865
  "/>" always "/>"
Line 3867
  '>' always 62
Line 3868
  ! {!<=-1,!>=2,0}
  scope {lifetime[Iterator]=(scopeList),!symbolic=(scopeList.end()),!end=0}
  . possible size=0
  ( {!<=-1,!>=2,1}
Line 3869
  "      <functionList>" always "      <functionList>"
Line 3870
  = {lifetime[Iterator]=(scope->functionList),lifetime[Object]=(scopeList),start=0}
  scope {lifetime[Iterator]=(scopeList),!symbolic=(scopeList.end()),!end=0}
  ( {lifetime[Iterator]=(scope->functionList),lifetime[Object]=(scopeList),start=0}
  function possible {lifetime[Iterator]=(scope->functionList),lifetime[Object]=(scopeList),start=0}
  != always {!<=-1,!>=2}
  scope {lifetime[Iterator]=(scopeList),!end=0}
  ( {lifetime[Iterator]=(scope->functionList),lifetime[Object]=(scopeList),end=0}
  function possible {lifetime[Iterator]=(scope->functionList),lifetime[Object]=(scopeList)}
Line 3871
  "        <function id=\"" always "        <function id=\""
  & {lifetime[Object]=(scopeList),!0}
  function {lifetime[Iterator]=(scope->functionList),lifetime[Object]=(scopeList),!symbolic=(scope->functionList.end()),!end=0}
Line 3872
  "\" token=\"" always "\" token=\""
  function {lifetime[Iterator]=(scope->functionList),lifetime[Object]=(scopeList),!symbolic=(scope->functionList.end()),!end=0}
Line 3873
  "\" tokenDef=\"" always "\" tokenDef=\""
  function {lifetime[Iterator]=(scope->functionList),lifetime[Object]=(scopeList),!symbolic=(scope->functionList.end()),!end=0}
Line 3874
  "\" name=\"" always "\" name=\""
  function {lifetime[Iterator]=(scope->functionList),lifetime[Object]=(scopeList),!symbolic=(scope->functionList.end()),!end=0}
  '\"' always 34
Line 3875
  " type=\"" always " type=\""
  function {lifetime[Iterator]=(scope->functionList),lifetime[Object]=(scopeList),!symbolic=(scope->functionList.end()),!end=0}
  . possible {1,2,3,4,6}
  == {!<=-1,!>=2,0}
  :: always 0
  eConstructor always 0
  "Constructor" always "Constructor"
  : always "Constructor"
Line 3876
  function {lifetime[Iterator]=(scope->functionList),lifetime[Object]=(scopeList),!symbolic=(scope->functionList.end()),!end=0}
  . {2,3,4,6,!0}
  == {!<=-1,!>=2,0}
  :: always 1
  eCopyConstructor always 1
  "CopyConstructor" always "CopyConstructor"
  : always "CopyConstructor"
Line 3877
  function {lifetime[Iterator]=(scope->functionList),lifetime[Object]=(scopeList),!symbolic=(scope->functionList.end()),!end=0}
  . {3,4,6,!0,!1}
  == {!<=-1,!>=2,0}
  :: always 2
  eMoveConstructor always 2
  "MoveConstructor" always "MoveConstructor"
  : always "MoveConstructor"
Line 3878
  function {lifetime[Iterator]=(scope->functionList),lifetime[Object]=(scopeList),!symbolic=(scope->functionList.end()),!end=0}
  . {4,6,!0,!1,!2}
  == {!<=-1,!>=2,0}
  :: always 3
  eOperatorEqual always 3
  "OperatorEqual" always "OperatorEqual"
  : always "OperatorEqual"
Line 3879
  function {lifetime[Iterator]=(scope->functionList),lifetime[Object]=(scopeList),!symbolic=(scope->functionList.end()),!end=0}
  . {6,!0,!1,!2,!3}
  == {!<=-1,!>=2,0}
  :: always 4
  eDestructor always 4
  "Destructor" always "Destructor"
  : always "Destructor"
Line 3880
  function {lifetime[Iterator]=(scope->functionList),lifetime[Object]=(scopeList),!symbolic=(scope->functionList.end()),!end=0}
  . {6,!0,!1,!2,!3,!4}
  == always {!<=-1,!>=2}
  "Function" always "Function"
  : always "Function"
Line 3881
  function {lifetime[Iterator]=(scope->functionList),lifetime[Object]=(scopeList),!symbolic=(scope->functionList.end()),!end=0}
  . always {!0,!1,!2,!3,!4}
  == always {!<=-1,!>=2}
  :: always 6
  eLambda always 6
  "Lambda" always "Lambda"
  : always "Unknown"
Line 3882
  "Unknown" always "Unknown"
  '\"' always 34
Line 3883
  function {lifetime[Iterator]=(scope->functionList),lifetime[Object]=(scopeList),!symbolic=(scope->functionList.end()),!end=0}
Line 3884
  function {lifetime[Iterator]=(scope->functionList),lifetime[Object]=(scopeList),!symbolic=(scope->functionList.end()),!end=0}
  ( always {!<=-1,!>=2}
Line 3885
  " hasVirtualSpecifier=\"true\"" always " hasVirtualSpecifier=\"true\""
Line 3886
  function {lifetime[Iterator]=(scope->functionList),lifetime[Object]=(scopeList),!symbolic=(scope->functionList.end()),!end=0}
  ( always {!<=-1,!>=2}
Line 3887
  " isImplicitlyVirtual=\"true\"" always " isImplicitlyVirtual=\"true\""
Line 3889
  function {lifetime[Iterator]=(scope->functionList),lifetime[Object]=(scopeList),!end=0}
  ( always {!<=-1,!>=2}
Line 3890
  " isInlineKeyword=\"true\"" always " isInlineKeyword=\"true\""
Line 3891
  function {lifetime[Iterator]=(scope->functionList),lifetime[Object]=(scopeList),!end=0}
  ( always {!<=-1,!>=2}
Line 3892
  " isStatic=\"true\"" always " isStatic=\"true\""
Line 3893
  function {lifetime[Iterator]=(scope->functionList),lifetime[Object]=(scopeList),!end=0}
  ( always !<=-1
  == always {!<=-1,!>=2}
  0U always 0
Line 3894
  "/>" always "/>"
Line 3896
  ">" always ">"
Line 3897
  argnr always !<=-1
  = always 0
  0 always 0
  argnr {!<=-1,0}
  < always {!<=-1,!>=2}
  function {lifetime[Iterator]=(scope->functionList),lifetime[Object]=(scopeList),!end=0}
  ( always !<=-1
  ++ always !<=0
  argnr always !<=-1
Line 3898
  arg inconclusive lifetime[Object]=(scopeList)
  = inconclusive lifetime[Object]=(scopeList)
  function {lifetime[Iterator]=(scope->functionList),lifetime[Object]=(scopeList),!end=0}
  ( inconclusive lifetime[Object]=(scopeList)
  argnr {!<=-1,<=symbolic=(function->argCount()-1),!>=symbolic=(function->argCount())}
Line 3899
  "          <arg nr=\"" always "          <arg nr=\""
  argnr always !<=-1
  + always !<=0
  1 always 1
  "\" variable=\"" always "\" variable=\""
  arg inconclusive lifetime[Object]=(scopeList)
  "\"/>" always "\"/>"
Line 3900
  variables inconclusive lifetime[Object]=(scopeList)
  arg inconclusive lifetime[Object]=(scopeList)
Line 3902
  "        </function>" always "        </function>"
Line 3905
  "      </functionList>" always "      </functionList>"
Line 3907
  ! {!<=-1,!>=2,0}
  scope {lifetime[Iterator]=(scopeList),!end=0}
  . possible size=0
  ( {!<=-1,!>=2,1}
Line 3908
  "      <varlist>" always "      <varlist>"
Line 3909
  = {lifetime[Iterator]=(scope->varlist),lifetime[Object]=(scopeList),start=0}
  scope {lifetime[Iterator]=(scopeList),!end=0}
  ( {lifetime[Iterator]=(scope->varlist),lifetime[Object]=(scopeList),start=0}
  var possible {lifetime[Iterator]=(scope->varlist),lifetime[Object]=(scopeList),start=0}
  != always {!<=-1,!>=2}
  scope {lifetime[Iterator]=(scopeList),!end=0}
  ( {lifetime[Iterator]=(scope->varlist),lifetime[Object]=(scopeList),end=0}
  var possible {lifetime[Iterator]=(scope->varlist),lifetime[Object]=(scopeList)}
Line 3910
  "        <var id=\"" always "        <var id=\""
  & {lifetime[Object]=(scopeList),!0}
  var {lifetime[Iterator]=(scope->varlist),lifetime[Object]=(scopeList),!symbolic=(scope->varlist.end()),!end=0}
  "\"/>" always "\"/>"
Line 3911
  "      </varlist>" always "      </varlist>"
Line 3913
  "    </scope>" always "    </scope>"
Line 3916
  "  </scopes>" always "  </scopes>"
Line 3921
  "  <variables>" always "  <variables>"
Line 3923
  ! always {!<=-1,!>=2}
Line 3925
  "    <var id=\"" always "    <var id=\""
  var always !0
  '\"' always 34
Line 3926
  " nameToken=\"" always " nameToken=\""
  var always !0
  '\"' always 34
Line 3927
  " typeStartToken=\"" always " typeStartToken=\""
  var always !0
  '\"' always 34
Line 3928
  " typeEndToken=\"" always " typeEndToken=\""
  var always !0
  '\"' always 34
Line 3929
  " access=\"" always " access=\""
  var always !0
  '\"' always 34
Line 3930
  " scope=\"" always " scope=\""
  var always !0
  '\"' always 34
Line 3931
  var always !0
Line 3932
  " constness=\"" always " constness=\""
  var always !0
  ( always !0
  '\"' always 34
Line 3933
  " isArray=\"" always " isArray=\""
  var always !0
  ( always {!<=-1,!>=2}
  '\"' always 34
Line 3934
  " isClass=\"" always " isClass=\""
  var always !0
  ( always {!<=-1,!>=2}
  '\"' always 34
Line 3935
  " isConst=\"" always " isConst=\""
  var always !0
  ( always {!<=-1,!>=2}
  '\"' always 34
Line 3936
  " isExtern=\"" always " isExtern=\""
  var always !0
  ( always {!<=-1,!>=2}
  '\"' always 34
Line 3937
  " isPointer=\"" always " isPointer=\""
  var always !0
  ( always {!<=-1,!>=2}
  '\"' always 34
Line 3938
  " isReference=\"" always " isReference=\""
  var always !0
  ( always {!<=-1,!>=2}
  '\"' always 34
Line 3939
  " isStatic=\"" always " isStatic=\""
  var always !0
  ( always {!<=-1,!>=2}
  '\"' always 34
Line 3940
  " isVolatile=\"" always " isVolatile=\""
  var always !0
  ( always {!<=-1,!>=2}
  '\"' always 34
Line 3941
  "/>" always "/>"
Line 3943
  "  </variables>" always "  </variables>"
Line 3953
  argType always !0
Line 3957
  scope always !0
Line 3959
  . always !0
Line 3961
  argType always !0
Line 3964
  scope always !0
Line 3966
  nullptr always 0
Line 3974
  = possible 1
  ? possible 1
  arg always !0
  : always 1
Line 3975
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  start {symbolic=(arg?arg:argDef),0,1}
  "(" always "("
Line 3977
  ! always {!<=-1,!>=2}
  start always symbolic=(arg?arg:argDef)
  && always {!<=-1,!>=2}
  start {symbolic=(arg?arg:argDef),!0}
  != always {!<=-1,!>=2}
  start {symbolic=(arg?arg:argDef),!0}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  start {symbolic=(arg?arg:argDef),!0}
  "( void )" always "( void )"
Line 3980
  count always !<=-1
  count always !<=-1
  = always 0
  0 always 0
Line 3982
  start always !0
Line 3983
  ( always {!<=-1,!>=2}
  ",|)" always ",|)"
Line 3987
  = always 0
  nullptr always 0
Line 3988
  = always 0
  nullptr always 0
Line 3991
  ( always {!<=-1,!>=2}
  tok possible symbolic=(startTok)
  "decltype (" always "decltype ("
Line 3992
  1 always 1
Line 3995
  tok possible symbolic=(startTok)
  != {!<=-1,!>=2,0}
  startTok possible symbolic=(tok)
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  tok always !symbolic=(startTok)
  "( & %var% ) [" always "( & %var% ) ["
Line 3996
  tok always !symbolic=(startTok)
  2 always 2
Line 3998
  tok always !symbolic=(startTok)
Line 3999
  tok possible symbolic=(startTok)
  != {!<=-1,!>=2,0}
  startTok possible symbolic=(tok)
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  tok always !symbolic=(startTok)
  "( * %var% ) ( ) [,)]" always "( * %var% ) ( ) [,)]"
Line 4000
  tok always !symbolic=(startTok)
  2 always 2
Line 4002
  tok always !symbolic=(startTok)
  2 always 2
Line 4003
  tok possible symbolic=(startTok)
  != {!<=-1,!>=2,0}
  startTok possible symbolic=(tok)
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  tok always !symbolic=(startTok)
  "( * %var% ) [" always "( * %var% ) ["
Line 4004
  tok always !symbolic=(startTok)
  2 always 2
Line 4006
  tok always !symbolic=(startTok)
Line 4007
  tok possible symbolic=(startTok)
  != always {!<=-1,!>=2}
  0 always 0
Line 4009
  tok always symbolic=(nameTok)
Line 4010
  ( possible size=1
  == always {!<=-1,!>=2}
  "[" always "["
Line 4013
  == always {!<=-1,!>=2}
  "[" always "["
Line 4015
  == always {!<=-1,!>=2}
  "<" always "<"
Line 4017
  ! always {!<=-1,!>=2}
Line 4021
  tok possible symbolic=(nameTok)
Line 4023
  ! always {!<=-1,!>=2}
Line 4025
  ( possible size=1
  != always {!<=-1,!>=2}
  "," always ","
  && always {!<=-1,!>=2}
  != always {!<=-1,!>=2}
  ")" always ")"
  && always {!<=-1,!>=2}
  != always {!<=-1,!>=2}
  "=" always "="
Line 4029
  ( always {!<=-1,!>=2}
  typeTok possible symbolic=(startTok)
  "const|volatile|enum|struct|::" always "const|volatile|enum|struct|::"
Line 4031
  ( always {!<=-1,!>=2}
  typeTok possible symbolic=(startTok)
  ",|)" always ",|)"
Line 4035
  ( always {!<=-1,!>=2}
  typeTok possible symbolic=(tok->previous())
  "%type% ::" always "%type% ::"
Line 4036
  2 always 2
Line 4039
  ! always {!<=-1,!>=2}
Line 4040
  ( possible symbolic=(typeTok)
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  -1 always -1
  "const|volatile" always "const|volatile"
Line 4041
  != always {!<=-1,!>=2}
Line 4042
  = always !symbolic=(typeTok)
  ( always !symbolic=(typeTok)
Line 4043
  nameTok {symbolic=(tok->previous()),!symbolic=(typeTok)}
Line 4045
  ( always {!<=-1,!>=2}
Line 4046
  nameTok {symbolic=(tok->previous()),!symbolic=(typeTok)}
  "varid0" always "varid0"
  "Function::addArguments found argument \'" always "Function::addArguments found argument \'"
  nameTok {symbolic=(tok->previous()),!symbolic=(typeTok)}
  "\' with varid 0." always "\' with varid 0."
Line 4048
  = always symbolic=(tok->previous())
  typeTok always symbolic=(tok->previous())
Line 4053
  = always 0
  nullptr always 0
Line 4054
  ! always {!<=-1,!>=2}
  typeTok possible {symbolic=(endTok),symbolic=(tok->previous())}
  ( always {!<=-1,!>=2}
Line 4062
  == always {!<=-1,!>=2}
  "=" always "="
Line 4064
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "[{[(<]" always "[{[(<]"
Line 4065
  = always !0
  ( always !0
Line 4067
  ( possible size=1
  != always {!<=-1,!>=2}
  "," always ","
  && always {!<=-1,!>=2}
  != always {!<=-1,!>=2}
  ")" always ")"
Line 4071
  ( always {!<=-1,!>=2}
  startTok possible symbolic=(nameTok)
  "enum|struct|const|volatile" always "enum|struct|const|volatile"
Line 4074
  == always {!<=-1,!>=2}
Line 4077
  nameTok always !symbolic=(startTok)
  count always !<=-1
  ++ always !<=-1
  :: always 5
  Argument always 5
Line 4079
  == always {!<=-1,!>=2}
  ")" always ")"
Line 4081
  ( always {!<=-1,!>=2}
  "..." always "..."
Line 4082
  true always 1
Line 4089
  && always {!<=-1,!>=2}
  tok always !0
  != always {!<=-1,!>=2}
Line 4090
  == always {!<=-1,!>=2}
  "=" always "="
Line 4092
  1 always 1
  == always {!<=-1,!>=2}
  "[" always "["
Line 4094
  lambdaStart always symbolic=(tok->next())
Line 4095
  ! always {!<=-1,!>=2}
Line 4096
  "Analysis failed (lambda not recognized). If the code is valid then please report this failure." always "Analysis failed (lambda not recognized). If the code is valid then please report this failure."
  :: always 3
  INTERNAL always 3
Line 4102
  ( always {!<=-1,!>=2}
  defaultVal always {!<=-1,!>=2}
Line 4104
  ( always {!<=-1,!>=2}
Line 4105
  return always {!<=-1,!>=2}
  true always 1
Line 4106
  ( always {!<=-1,!>=2}
Line 4107
  return always {!<=-1,!>=2}
  true always 1
Line 4108
  foundAllBaseClasses always {!<=-1,!>=2}
  foundAllBaseClasses always {!<=-1,!>=2}
  = always 1
  true always 1
Line 4109
  & {lifetime[Address]=(foundAllBaseClasses),!0}
  foundAllBaseClasses always 1
Line 4110
  return always {!<=-1,!>=2}
  true always 1
Line 4111
  foundAllBaseClasses always {!<=-1,!>=2}
Line 4112
  return always {!<=-1,!>=2}
  false always 0
Line 4113
  return always {!<=-1,!>=2}
  defaultVal always {!<=-1,!>=2}
Line 4121
  scope possible symbolic=(nestedIn)
Line 4122
  isMemberFunction always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  scope {symbolic=(nestedIn),!0}
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 4123
  = possible lifetime[Iterator]=(scope->functionMap)
  scope always !0
  ( possible lifetime[Iterator]=(scope->functionMap)
Line 4124
  it possible lifetime[Iterator]=(scope->functionMap)
  != always {!<=-1,!>=2}
  scope always !0
  ( {lifetime[Iterator]=(scope->functionMap),end=0}
  && always {!<=-1,!>=2}
  it {lifetime[Iterator]=(scope->functionMap),!symbolic=(scope->functionMap.end()),!end=0}
  == always {!<=-1,!>=2}
Line 4126
  it possible lifetime[Iterator]=(scope->functionMap)
Line 4127
  isMemberFunction {symbolic=(scope->isClassOrStruct()&&!isStatic()),!<=-1,!>=2}
  == always {!<=-1,!>=2}
  func always symbolic=(it->second)
  ( always {!<=-1,!>=2}
Line 4129
  func always symbolic=(it->second)
Line 4131
  isMemberFunction {symbolic=(scope->isClassOrStruct()&&!isStatic()),!<=-1,!>=2}
Line 4141
  foundAllBaseClasses possible lifetime[Address]=(foundAllBaseClasses)@80
Line 4142
  * always {!<=-1,!>=2}
  foundAllBaseClasses {!0,lifetime[Address]=(foundAllBaseClasses)@80}
  = always 1
  true always 1
Line 4143
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 4144
  nullptr always 0
Line 4145
  foundAllBaseClasses possible lifetime[Address]=(foundAllBaseClasses)@80
Line 4154
  ! always {!<=-1,!>=2}
  derivedFromType always symbolic=(i.type)
  || always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  derivedFromType {symbolic=(i.type),!0}
Line 4156
  * always {!<=-1,!>=2}
  foundAllBaseClasses always !0
  = always 0
  false always 0
Line 4160
  = always !0
  derivedFromType {symbolic=(i.type),!0}
  . always !0
Line 4163
  = possible lifetime[Iterator]=(parent->functionMap)
  parent {symbolic=(derivedFromType->classScope),!0}
  ( possible lifetime[Iterator]=(parent->functionMap)
  it possible lifetime[Iterator]=(parent->functionMap)
  != always {!<=-1,!>=2}
  parent {symbolic=(derivedFromType->classScope),!0}
  ( {lifetime[Iterator]=(parent->functionMap),end=0}
  && always {!<=-1,!>=2}
  it {lifetime[Iterator]=(parent->functionMap),!symbolic=(parent->functionMap.end()),!end=0}
  == always {!<=-1,!>=2}
  it possible lifetime[Iterator]=(parent->functionMap)
Line 4164
  it possible lifetime[Iterator]=(parent->functionMap)
Line 4165
  func always symbolic=(it->second)
  ( always {!<=-1,!>=2}
Line 4166
  func always symbolic=(it->second)
Line 4168
  match always {!<=-1,!>=2}
  match always {!<=-1,!>=2}
  = always 1
  true always 1
Line 4171
  temp1 possible symbolic=(func->tokenDef->previous())
  != always {!<=-1,!>=2}
  "virtual" always "virtual"
Line 4172
  ( possible symbolic=(derivedFromType->name())
  != always {!<=-1,!>=2}
  ( possible symbolic=(baseType->name())
  && always {!<=-1,!>=2}
Line 4173
  ! always {!<=-1,!>=2}
  ( always !symbolic=(temp2->str())
  == always {!<=-1,!>=2}
  derivedFromType always !0
  && always {!<=-1,!>=2}
Line 4174
  ( always {!symbolic=(temp1->str()),!symbolic=(derivedFromType->name())}
  == always {!<=-1,!>=2}
Line 4175
  match always {!<=-1,!>=2}
  = always 0
  false always 0
Line 4184
  match always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  match {!<=-1,!>=2,1,0}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  func always symbolic=(it->second)
  0 always 0
Line 4187
  match always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  match {!<=-1,!>=2,0}
Line 4188
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 4189
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 4190
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 4191
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 4194
  match {!<=-1,!>=2,0}
Line 4200
  ! always {!<=-1,!>=2}
  derivedFromType always !0
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  derivedFromType always !0
  ( always {!<=-1,!>=2}
Line 4203
  derivedFromType always !0
Line 4205
  func always !0
Line 4209
  nullptr always 0
Line 4214
  = {lifetime[Iterator]=(argumentList),start=0}
  ( {lifetime[Iterator]=(argumentList),start=0}
  i possible {lifetime[Iterator]=(argumentList),start=0}
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(argumentList),end=0}
  i possible lifetime[Iterator]=(argumentList)
Line 4215
  i {lifetime[Iterator]=(argumentList),!symbolic=(argumentList.end()),!end=0}
  == always {!<=-1,!>=2}
  num possible 0@60
Line 4216
  & {lifetime[Object]=(argumentList),!0}
  i {lifetime[Iterator]=(argumentList),!symbolic=(argumentList.end()),!end=0}
Line 4217
  i {lifetime[Iterator]=(argumentList),!symbolic=(argumentList.end()),!end=0}
  ( always !symbolic=(num)
  > always {!<=-1,!>=2}
  num always !symbolic=(i->index())
Line 4218
  nullptr always 0
Line 4220
  nullptr always 0
Line 4230
  0 always 0
Line 4231
  0 always 0
Line 4233
  nullptr always 0
Line 4234
  nullptr always 0
Line 4235
  nullptr always 0
Line 4236
  nullptr always 0
Line 4237
  enumClass always {!<=-1,!>=2}
  false always 0
Line 4243
  check possible 0
Line 4244
  classDef possible 0
Line 4245
  nullptr always 0
Line 4246
  nullptr always 0
Line 4248
  0 always 0
Line 4249
  0 always 0
Line 4250
  nullptr always 0
Line 4251
  nullptr always 0
Line 4252
  nullptr always 0
Line 4253
  nullptr always 0
Line 4254
  enumClass always {!<=-1,!>=2}
  false always 0
Line 4256
  = possible 0
  classDef possible 0
Line 4257
  ! {!<=-1,!>=2,1}
  classDef {symbolic=(nameTok),0}
Line 4258
  = always 0
  :: always 0
  eGlobal always 0
Line 4259
  classDef {symbolic=(nameTok),!0}
  ( possible {size=6,size=5,size=9,size=4,size=1}
  == {!<=-1,!>=2,0}
  "class" always "class"
  && always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  check always !0
  ( always {!<=-1,!>=2}
Line 4260
  = always 1
  :: always 1
  eClass always 1
Line 4261
  nameTok {symbolic=(classDef),!0}
Line 4262
  classDef {symbolic=(nameTok),!0}
  ( possible {size=5,size=9,size=4,size=1}
  == {!<=-1,!>=2,0}
  "struct" always "struct"
Line 4263
  = always 2
  :: always 2
  eStruct always 2
Line 4264
  nameTok {symbolic=(classDef),!0}
Line 4265
  classDef {symbolic=(nameTok),!0}
  ( possible {size=9,size=4,size=1}
  == {!<=-1,!>=2,0}
  "union" always "union"
Line 4266
  = always 3
  :: always 3
  eUnion always 3
Line 4267
  nameTok {symbolic=(classDef),!0}
Line 4268
  classDef {symbolic=(nameTok),!0}
  ( possible {size=4,size=1}
  == {!<=-1,!>=2,0}
  "namespace" always "namespace"
Line 4269
  = always 4
  :: always 4
  eNamespace always 4
Line 4270
  nameTok {symbolic=(classDef),!0}
Line 4271
  classDef {symbolic=(nameTok),!0}
  ( possible size=1
  == {!<=-1,!>=2,0}
  "enum" always "enum"
Line 4272
  = always 16
  :: always 16
  eEnum always 16
Line 4273
  nameTok {symbolic=(classDef),!0}
Line 4274
  == always {!<=-1,!>=2}
  "class" always "class"
Line 4275
  enumClass always {!<=-1,!>=2}
  = always 1
  true always 1
Line 4278
  classDef {symbolic=(nameTok),!0}
  == always {!<=-1,!>=2}
  "[" always "["
Line 4279
  = always 15
  :: always 15
  eLambda always 15
Line 4284
  nameTok possible symbolic=(classDef)
Line 4285
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 16
  eEnum always 16
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  nameTok always !0
  ":|{" always ":|{"
  || always {!<=-1,!>=2}
  nameTok always !0
  != always {!<=-1,!>=2}
  "{" always "{"
Line 4286
  nameTok always !0
Line 4289
  ( always {!<=-1,!>=2}
Line 4294
  = {lifetime[Iterator]=(functionList),start=0}
  ( {lifetime[Iterator]=(functionList),start=0}
  func possible {lifetime[Iterator]=(functionList),start=0}
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(functionList),end=0}
Line 4295
  func {lifetime[Iterator]=(functionList),!symbolic=(functionList.end()),!end=0}
  == always {!<=-1,!>=2}
  :: always 0
  eConstructor always 0
  && always {!<=-1,!>=2}
  func {lifetime[Iterator]=(functionList),!symbolic=(functionList.end()),!end=0}
  ( always !<=-1
  == always {!<=-1,!>=2}
  0 always 0
Line 4296
  return always {!<=-1,!>=2}
  true always 1
Line 4299
  return always {!<=-1,!>=2}
  false always 0
Line 4305
  eGlobal always 0
Line 4306
  :: always 3
  Global always 3
Line 4307
  eClass always 1
Line 4308
  :: always 2
  Private always 2
Line 4309
  eStruct always 2
Line 4311
  eUnion always 3
Line 4313
  eNamespace always 4
Line 4314
  :: always 4
  Namespace always 4
Line 4325
  = always !<=-1
  ( always !<=-1
Line 4326
  type_ possible 0@212
  scope_ inconclusive {lifetime[Object]=(scopeList)@161,lifetime[Object]=(scopeList)@161,lifetime[Object]=(scopeList)@161,lifetime[Object]=(scopeList)@161}
Line 4332
  ! {!<=-1,!>=2,0}
  bodyStartList possible size=0
  ( {!<=-1,!>=2,1}
Line 4333
  bodyStartList always !size=0
Line 4338
  == always {!<=-1,!>=2}
  :: always 0
  eGlobal always 0
Line 4339
  nullptr always 0
Line 4349
  ( always {!<=-1,!>=2}
  "if|while ( %type%" always "if|while ( %type%"
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "=" always "="
Line 4350
  2 always 2
Line 4354
  && always {!<=-1,!>=2}
  tok always !0
  != {!<=-1,!>=2,1}
  end possible 0@23
Line 4356
  == always {!<=-1,!>=2}
  nullptr always 0
Line 4360
  ( possible {size=12,size=7,size=10,size=8}
  == {!<=-1,!>=2,0}
  "{" always "{"
Line 4367
  ( {!<=-1,!>=2,0}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "class|struct|union|namespace %type% :|{" always "class|struct|union|namespace %type% :|{"
Line 4368
  2 always 2
Line 4369
  tok possible 0
  && always {!<=-1,!>=2}
  tok always !0
  != always {!<=-1,!>=2}
  "{" always "{"
Line 4370
  tok always !0
Line 4371
  tok possible 0
Line 4373
  tok always !0
Line 4377
  ( {!<=-1,!>=2,0}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "struct|union {" always "struct|union {"
Line 4378
  ( always {!<=-1,!>=2}
  ( always !0
  "} %name% ;|[" always "} %name% ;|["
Line 4379
  ( always !0
  2 always 2
Line 4381
  ( always {!<=-1,!>=2}
  ( always !0
  "} ;" always "} ;"
Line 4382
  = always !0
  ( always !0
Line 4389
  ( possible {size=7,size=10,size=8}
  == {!<=-1,!>=2,0}
  "__published:" always "__published:"
Line 4391
  == always {!<=-1,!>=2}
  "{" always "{"
Line 4393
  ( always {!<=-1,!>=2}
  "private:|protected:|public:" always "private:|protected:|public:"
Line 4403
  ( possible {size=10,size=8}
  == {!<=-1,!>=2,0}
  "public:" always "public:"
Line 4406
  ( possible {size=8,size=10}
  == {!<=-1,!>=2,0}
  "protected:" always "protected:"
Line 4407
  = always 1
  :: always 1
  Protected always 1
Line 4409
  ( possible size=10
  == {!<=-1,!>=2,0}
  "private:" always "private:"
Line 4410
  = always 2
  :: always 2
  Private always 2
Line 4415
  ( {!<=-1,!>=2,0}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "class|struct|union %name% ;" always "class|struct|union %name% ;"
Line 4416
  2 always 2
Line 4421
  == always {!<=-1,!>=2}
  "__property" always "__property"
Line 4425
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "return|delete|goto" always "return|delete|goto"
Line 4426
  && always {!<=-1,!>=2}
Line 4427
  ( always !0
  != always {!<=-1,!>=2}
  ";" always ";"
  && always {!<=-1,!>=2}
Line 4428
  ( always !0
  != always {!<=-1,!>=2}
  "}" always "}"
Line 4429
  = always !0
  ( always !0
Line 4435
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "case|default" always "case|default"
Line 4436
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  ( always !0
  "[:;{}]" always "[:;{}]"
Line 4437
  = always !0
  ( always !0
Line 4442
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  ( always !0
  ";|{|}|public:|protected:|private:" always ";|{|}|public:|protected:|private:"
Line 4444
  == always {!<=-1,!>=2}
  ";" always ";"
Line 4449
  ! always {!<=-1,!>=2}
Line 4457
  ( {!<=-1,!>=2,0}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "throw %any% (" always "throw %any% ("
  && always {!<=-1,!>=2}
Line 4458
  ( always {!<=-1,!>=2}
  2 always 2
  ") ;" always ") ;"
Line 4459
  2 always 2
Line 4462
  ( {!<=-1,!>=2,0}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "throw %any% :: %any% (" always "throw %any% :: %any% ("
  && always {!<=-1,!>=2}
Line 4463
  ( always {!<=-1,!>=2}
  4 always 4
  ") ;" always ") ;"
Line 4464
  4 always 4
Line 4468
  ( {!<=-1,!>=2,0}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "friend %type%" always "friend %type%"
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  0 always 0
Line 4469
  2 always 2
  ";|{" always ";|{"
Line 4470
  && always {!<=-1,!>=2}
  next always !0
  == always {!<=-1,!>=2}
  "{" always "{"
Line 4471
  next always !0
Line 4476
  ( {!<=-1,!>=2,0}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "const|constexpr|volatile|static|mutable|extern" always "const|constexpr|volatile|static|mutable|extern"
Line 4484
  >= always {!<=-1,!>=2}
  :: always 3
  CPP17 always 3
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  tok always symbolic=(typestart)
  "auto &|&&| [" always "auto &|&&| ["
Line 4485
  typestart always symbolic=(tok)
  "[" always "["
Line 4486
  typeend always symbolic=(Token::findsimplematch(typestart,"[")->previous())
  2 always 2
  ( always {!<=-1,!>=2}
  "%name%|," always "%name%|,"
Line 4488
  nullptr always 0
  this always !0
Line 4490
  1 always 1
Line 4493
  tok always symbolic=(typestart)
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  tok always symbolic=(typestart)
  "class|struct|union|enum" always "class|struct|union|enum"
Line 4494
  tok always symbolic=(typestart)
Line 4498
  = always 0
  nullptr always 0
Line 4499
  = always 0
  nullptr always 0
Line 4501
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  tok always !0
  vartok always 0
  typetok always 0
Line 4504
  ( always {!<=-1,!>=2}
  tok possible symbolic=(vartok->next())
  "[|{" always "[|{"
Line 4507
  == always {!<=-1,!>=2}
  0 always 0
Line 4508
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 4509
  "varid0" always "varid0"
  "Scope::checkVariable found variable \'" always "Scope::checkVariable found variable \'"
  "\' with varid 0." always "\' with varid 0."
Line 4513
  = always 0
  nullptr always 0
Line 4516
  this always !0
  typetok always !0
Line 4518
  ( always !0
  typetok always !0
Line 4522
  ( always {!<=-1,!>=2}
  "enum|struct" always "enum|struct"
Line 4525
  this always !0
Line 4535
  = {lifetime[Iterator]=(varlist),start=0}
  ( {lifetime[Iterator]=(varlist),start=0}
  iter possible {lifetime[Iterator]=(varlist),start=0}
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(varlist),end=0}
Line 4536
  iter {lifetime[Iterator]=(varlist),!symbolic=(varlist.end()),!end=0}
  == always {!<=-1,!>=2}
Line 4537
  & {lifetime[Object]=(varlist),!0}
  iter {lifetime[Iterator]=(varlist),!symbolic=(varlist.end()),!end=0}
Line 4540
  nullptr always 0
Line 4545
  ( always {!<=-1,!>=2}
  "*|&|&&" always "*|&|&&"
  || always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "( [*&]" always "( [*&]"
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "(|[" always "(|["
Line 4547
  -1 always -1
  == always {!<=-1,!>=2}
  "(" always "("
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "%type% ::" always "%type% ::"
Line 4548
  2 always 2
Line 4551
  ( always {!<=-1,!>=2}
  "( *" always "( *"
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "] ) ;" always "] ) ;"
Line 4553
  ( always {!<=-1,!>=2}
  "%name% [" always "%name% ["
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  1 always 1
  "] ) ;" always "] ) ;"
Line 4563
  ( always {!<=-1,!>=2}
  "const|static|volatile" always "const|static|volatile"
Line 4571
  ( always {!<=-1,!>=2}
  & always !0
  & always !0
Line 4573
  ! always {!<=-1,!>=2}
Line 4574
  return always {!<=-1,!>=2}
  false always 0
Line 4576
  isCPP always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  check always !0
  ( always {!<=-1,!>=2}
Line 4578
  isCPP {symbolic=(check&&check->mTokenizer->isCPP()),!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  tok always !0
  "throw|new" always "throw|new"
Line 4579
  return always {!<=-1,!>=2}
  false always 0
Line 4581
  isCPP11 always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  isCPP {symbolic=(check&&check->mTokenizer->isCPP()),!<=-1,!>=2,0}
  && always {!<=-1,!>=2}
  >= always {!<=-1,!>=2}
  :: always 1
  CPP11 always 1
Line 4583
  isCPP11 {symbolic=(isCPP&&check->mSettings->standards.cpp>=Standards::CPP11),!<=-1,!>=2,0}
  && always {!<=-1,!>=2}
  tok always !0
  == always {!<=-1,!>=2}
  "using" always "using"
Line 4584
  return always {!<=-1,!>=2}
  false always 0
Line 4587
  = always 0
  nullptr always 0
Line 4589
  ( always {!<=-1,!>=2}
  "%type% <" always "%type% <"
Line 4590
  ( always {!<=-1,!>=2}
  "const_cast|dynamic_cast|reinterpret_cast|static_cast <" always "const_cast|dynamic_cast|reinterpret_cast|static_cast <"
Line 4591
  return always {!<=-1,!>=2}
  false always 0
Line 4594
  closeTok always symbolic=(localTypeTok->next()->link())
Line 4595
  closeTok {symbolic=(localTypeTok->next()->link()),!0}
Line 4597
  ( always {!<=-1,!>=2}
  ":: %type% %name% [;=({]" always ":: %type% %name% [;=({]"
Line 4598
  3 always 3
  != always {!<=-1,!>=2}
  "(" always "("
  || always {!<=-1,!>=2}
Line 4599
  ( always {!<=-1,!>=2}
  3 always 3
  "[)}] ;" always "[)}] ;"
Line 4601
  2 always 2
Line 4605
  ( always {!<=-1,!>=2}
  "%type%" always "%type%"
Line 4607
  isCPP11 {symbolic=(isCPP&&check->mSettings->standards.cpp>=Standards::CPP11),!<=-1,!>=2,0}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "decltype (" always "decltype ("
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  1 always 1
  ") %name%|*|&|&&" always ") %name%|*|&|&&"
Line 4608
  1 always 1
Line 4611
  isCPP11 {symbolic=(isCPP&&check->mSettings->standards.cpp>=Standards::CPP11),!<=-1,!>=2,0}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "decltype (" always "decltype ("
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  1 always 1
  ") %name%|*|&|&&" always ") %name%|*|&|&&"
Line 4612
  1 always 1
Line 4616
  ! always {!<=-1,!>=2}
Line 4617
  return always {!<=-1,!>=2}
  false always 0
Line 4619
  ( always {!<=-1,!>=2}
  localVarTok possible 0
  "const|*|&" always "const|*|&"
Line 4622
  ( always {!<=-1,!>=2}
  localVarTok possible 0
  "%name% ;|=" always "%name% ;|="
  || always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  localVarTok always !0
  && always {!<=-1,!>=2}
  localVarTok always !0
  1 always 1
  == always {!<=-1,!>=2}
  ":" always ":"
Line 4625
  ( always {!<=-1,!>=2}
  localVarTok possible 0
  "%name% )|[" always "%name% )|["
  && always {!<=-1,!>=2}
  != always {!<=-1,!>=2}
  "operator" always "operator"
Line 4628
  && always {!<=-1,!>=2}
  localVarTok always !0
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  localVarTok always !0
  "%name% (|{" always "%name% (|{"
  && always {!<=-1,!>=2}
Line 4629
  ( always {!<=-1,!>=2}
  ")|} ;" always ")|} ;"
Line 4630
  = always !0
  localVarTok always !0
Line 4632
  == always {!<=-1,!>=2}
  eCatch always 14
  && always {!<=-1,!>=2}
Line 4633
  ( always {!<=-1,!>=2}
  "%name% )" always "%name% )"
Line 4638
  return always {!<=-1,!>=2}
  nullptr always 0
  != always {!<=-1,!>=2}
  vartok possible symbolic=(localVarTok)
Line 4641
  , always {!<=-1,!>=2}
  isCpp always {!<=-1,!>=2}
Line 4646
  isCpp always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  tok2 always symbolic=(tok->next())
  == always {!<=-1,!>=2}
  "class" always "class"
Line 4647
  tok2 always symbolic=(tok->next())
Line 4650
  tok2 possible symbolic=(tok->next())
Line 4653
  == always {!<=-1,!>=2}
  ":" always ":"
Line 4661
  == always {!<=-1,!>=2}
  "{" always "{"
Line 4665
  ( always {!<=-1,!>=2}
  "%name% =|,|}" always "%name% =|,|}"
  || always {!<=-1,!>=2}
Line 4666
  ( always {!<=-1,!>=2}
  "%name% (" always "%name% ("
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  1 always 1
  ") ,|}" always ") ,|}"
Line 4667
  this always !0
Line 4675
  ( possible size=1
  == always {!<=-1,!>=2}
  "=" always "="
Line 4679
  == always {!<=-1,!>=2}
  "}" always "}"
Line 4680
  nullptr always 0
Line 4684
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  ",|}" always ",|}"
Line 4686
  = always !0
  ( always !0
Line 4690
  == always {!<=-1,!>=2}
  "(" always "("
Line 4695
  ( possible size=1
  == always {!<=-1,!>=2}
  "," always ","
Line 4698
  == always {!<=-1,!>=2}
  "}" always "}"
Line 4704
  == always {!<=-1,!>=2}
Line 4705
  tok2 always symbolic=(end)
Line 4707
  && always {!<=-1,!>=2}
  tok2 always !0
  != always {!<=-1,!>=2}
  ";" always ";"
  && always {!<=-1,!>=2}
  isCpp always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  tok2 always !0
  != always {!<=-1,!>=2}
  ")" always ")"
Line 4708
  = always 0
  nullptr always 0
Line 4710
  = always 0
  nullptr always 0
Line 4712
  = always 0
  nullptr always 0
Line 4714
  tok2 possible 0
Line 4723
  ( possible lifetime[Iterator]=(mTokensThatAreNotEnumeratorValues)
  tokStr always symbolic=(tok->str())
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(mTokensThatAreNotEnumeratorValues),end=0}
Line 4724
  nullptr always 0
Line 4728
  -1 always -1
  == always {!<=-1,!>=2}
  "::" always "::"
Line 4731
  ( always {!<=-1,!>=2}
  tok1 possible symbolic=(tok)
  -2 always -2
  "%name% ::" always "%name% ::"
Line 4732
  -2 always -2
Line 4734
  tok1 possible symbolic=(tok)
  -1 always -1
  == always {!<=-1,!>=2}
  "::" always "::"
Line 4735
  = {lifetime[Object]=(scopeList),!0}
  & {lifetime[Object]=(scopeList),!0}
Line 4740
  scope possible symbolic=(tok->scope())
  && always {!<=-1,!>=2}
  scope always !0
Line 4741
  scope always !0
  . always !0
Line 4743
  = always !0
  temp always !0
Line 4746
  = always !0
  scope always !0
  . always !0
Line 4750
  scope possible {lifetime[Object]=(scopeList),symbolic=(&scopeList.front()),symbolic=(temp),0}
Line 4751
  2 always 2
Line 4752
  scope possible {lifetime[Object]=(scopeList),0}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "%name% ::" always "%name% ::"
Line 4753
  scope {lifetime[Object]=(scopeList),!0}
Line 4754
  2 always 2
Line 4757
  scope possible 0
Line 4758
  scope always !0
Line 4760
  enumerator {symbolic=(scope->findEnumerator(tokStr)),0}
Line 4761
  enumerator {symbolic=(scope->findEnumerator(tokStr)),!0}
Line 4764
  = {lifetime[Iterator]=(scope->nestedList),start=0}
  scope always !0
  ( {lifetime[Iterator]=(scope->nestedList),start=0}
  , {lifetime[Iterator]=(scope->nestedList),end=0}
  = {lifetime[Iterator]=(scope->nestedList),end=0}
  scope always !0
  ( {lifetime[Iterator]=(scope->nestedList),end=0}
  != always {!<=-1,!>=2}
Line 4765
  it always !symbolic=(end)
Line 4767
  enumerator always symbolic=((*it)->findEnumerator(tokStr))
Line 4768
  enumerator {symbolic=((*it)->findEnumerator(tokStr)),!0}
Line 4774
  scope always symbolic=(tok->scope())
Line 4776
  enumerator {symbolic=(scope->findEnumerator(tokStr)),0}
Line 4777
  enumerator {symbolic=(scope->findEnumerator(tokStr)),!0}
Line 4779
  = {lifetime[Iterator]=(scope->nestedList),start=0}
  ( {lifetime[Iterator]=(scope->nestedList),start=0}
  s possible {lifetime[Iterator]=(scope->nestedList),start=0}
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(scope->nestedList),end=0}
Line 4780
  s {lifetime[Iterator]=(scope->nestedList),!symbolic=(scope->nestedList.end()),!end=0}
Line 4782
  enumerator always symbolic=((*s)->findEnumerator(tokStr))
Line 4783
  enumerator {symbolic=((*s)->findEnumerator(tokStr)),!0}
Line 4787
  . always !0
Line 4790
  derivedFromType always symbolic=(i.type)
  && always {!<=-1,!>=2}
  derivedFromType {symbolic=(i.type),!0}
Line 4791
  derivedFromType {symbolic=(i.type),!0}
  . always !0
Line 4793
  enumerator always symbolic=(derivedFromType->classScope->findEnumerator(tokStr))
Line 4794
  enumerator {symbolic=(derivedFromType->classScope->findEnumerator(tokStr)),!0}
Line 4800
  == always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 4801
  = always !0
  . always !0
Line 4803
  = always !0
  . always !0
Line 4807
  enumerator {symbolic=(scope->findEnumerator(tokStr)),0}
Line 4808
  enumerator {symbolic=(scope->findEnumerator(tokStr)),!0}
Line 4810
  = {lifetime[Iterator]=(scope->nestedList),start=0}
  ( {lifetime[Iterator]=(scope->nestedList),start=0}
  s possible {lifetime[Iterator]=(scope->nestedList),start=0}
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(scope->nestedList),end=0}
Line 4811
  s {lifetime[Iterator]=(scope->nestedList),!symbolic=(scope->nestedList.end()),!end=0}
Line 4813
  enumerator always symbolic=((*s)->findEnumerator(tokStr))
Line 4814
  enumerator {symbolic=((*s)->findEnumerator(tokStr)),!0}
Line 4821
  nullptr always 0
Line 4828
  scope possible {symbolic=(scope->functionOf)@108,lifetime[Address]=(scopeList)@54}
  && always {!<=-1,!>=2}
  scope {!0,lifetime[Address]=(scopeList)@54}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  scope {!0,lifetime[Address]=(scopeList)@54}
  . always !0
  ( always {!<=-1,!>=2}
Line 4829
  = always !size=0
  scope {!0,lifetime[Address]=(scopeList)@54}
  . always !size=0
Line 4830
  derivedFrom always !size=0
Line 4832
  base always symbolic=(i.type)
  && always {!<=-1,!>=2}
  base {symbolic=(i.type),!0}
Line 4833
  base {symbolic=(i.type),!0}
  . always !0
  == always {!<=-1,!>=2}
  scope always !0
Line 4834
  nullptr always 0
Line 4835
  base {symbolic=(i.type),!0}
  . always {!symbolic=(scope),!0}
Line 4836
  type always symbolic=(base->classScope->findType(typeTok->str()))
Line 4837
  type {symbolic=(base->classScope->findType(typeTok->str())),!0}
Line 4838
  . always !symbolic=(scope)
Line 4840
  type always !0
Line 4845
  nullptr always 0
Line 4855
  -1 always -1
  != always {!<=-1,!>=2}
  "::" always "::"
  && always {!<=-1,!>=2}
  1 always 1
  != always {!<=-1,!>=2}
  "::" always "::"
Line 4857
  start always symbolic=(scope)
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  start always symbolic=(scope)
Line 4858
  start always symbolic=(scope)
Line 4860
  scope possible symbolic=(start)
Line 4862
  scope always !0
Line 4864
  type always symbolic=(scope->findType(typeTok->str()))
Line 4865
  type {symbolic=(scope->findType(typeTok->str())),!0}
Line 4868
  scope always !0
  ( always {!<=-1,!>=2}
Line 4869
  scope always !0
Line 4872
  type always !0
Line 4876
  scope always !0
  == always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  scope always !0
Line 4877
  = always !0
  scope always !0
  . always !0
Line 4879
  scope1 {symbolic=(scope->functionOf),!0}
Line 4881
  type always symbolic=(scope1->findType(typeTok->str()))
Line 4882
  type {symbolic=(scope1->findType(typeTok->str())),!0}
Line 4884
  scope1 {symbolic=(scope->functionOf),!0}
Line 4887
  type always !0
Line 4890
  scope always !0
Line 4895
  -1 always -1
  == always {!<=-1,!>=2}
  "::" always "::"
Line 4897
  1 always 1
  == always {!<=-1,!>=2}
  "::" always "::"
Line 4898
  nullptr always 0
Line 4903
  ( always {!<=-1,!>=2}
  tok1 possible symbolic=(typeTok)
  -2 always -2
  "%type% ::" always "%type% ::"
  || always {!<=-1,!>=2}
Line 4904
  ( always {!<=-1,!>=2}
  tok1 possible symbolic=(typeTok)
  -2 always -2
  "> ::" always "> ::"
  && always {!<=-1,!>=2}
  tok1 possible symbolic=(typeTok)
  -2 always -2
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  tok1 possible symbolic=(typeTok)
  -2 always -2
  -1 always -1
  "%type%" always "%type%"
Line 4905
  -1 always -1
  == always {!<=-1,!>=2}
  "::" always "::"
Line 4906
  -2 always -2
Line 4908
  -2 always -2
  -1 always -1
Line 4912
  tok1 possible symbolic=(typeTok)
  -1 always -1
  == always {!<=-1,!>=2}
  "::" always "::"
Line 4913
  = {lifetime[Object]=(scopeList),!0}
  & {lifetime[Object]=(scopeList),!0}
Line 4915
  scope {lifetime[Object]=(scopeList),symbolic=(&scopeList.front()),!0}
Line 4920
  scope possible symbolic=(start)
Line 4921
  scope always !0
  == always {!<=-1,!>=2}
Line 4924
  scope always !0
  ( always !symbolic=(scope->className)
Line 4927
  = always !0
  scope1 always !0
Line 4929
  scope always !0
  == always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  scope always !0
Line 4930
  = always !0
  scope always !0
  . always !0
Line 4932
  scope always !0
Line 4937
  scope possible symbolic=(scope1)
Line 4939
  scope possible {symbolic=(temp),0}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "%type% ::" always "%type% ::"
  || always {!<=-1,!>=2}
Line 4940
  ( always {!<=-1,!>=2}
  "%type% <" always "%type% <"
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  1 always 1
  "> ::" always "> ::"
Line 4941
  1 always 1
  == always {!<=-1,!>=2}
  "::" always "::"
Line 4942
  2 always 2
Line 4944
  1 always 1
  2 always 2
Line 4945
  scope always !0
Line 4946
  ! {!<=-1,!>=2,1}
  temp possible 0
Line 4948
  scope always !0
Line 4951
  type always !0
Line 4953
  = possible 0
  temp possible 0
Line 4956
  scope possible {symbolic=(temp),0}
  && always {!<=-1,!>=2}
  scope always !0
Line 4957
  scope always !0
  . always !0
Line 4961
  nullptr always 0
Line 4964
  ( always {!<=-1,!>=2}
Line 4968
  . possible 15
  == {!<=-1,!>=2,0}
  :: always 12
  eUnconditional always 12
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  ") {" always ") {"
Line 4969
  return always {!<=-1,!>=2}
  true always 1
Line 4971
  == always {!<=-1,!>=2}
  :: always 15
  eLambda always 15
Line 4972
  return always {!<=-1,!>=2}
  true always 1
Line 4973
  ( always {!<=-1,!>=2}
Line 4974
  return always {!<=-1,!>=2}
  true always 1
Line 4976
  return always {!<=-1,!>=2}
  false always 0
Line 4981
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  definedType always !0
  ( always {!<=-1,!>=2}
Line 4982
  = always !size=0
  definedType always !0
  . always !size=0
Line 4983
  derivedFrom always !size=0
Line 4985
  base always symbolic=(i.type)
  && always {!<=-1,!>=2}
  base {symbolic=(i.type),!0}
Line 4986
  base {symbolic=(i.type),!0}
  . always !0
  == always {!<=-1,!>=2}
  this always !0
Line 4989
  = possible lifetime[Iterator]=(base->classScope->functionMap)
  base {symbolic=(i.type),!0}
  . always {!symbolic=(this),!0}
  ( possible lifetime[Iterator]=(base->classScope->functionMap)
  it possible lifetime[Iterator]=(base->classScope->functionMap)
  != always {!<=-1,!>=2}
  base {symbolic=(i.type),!0}
  . always {!symbolic=(this),!0}
  ( {lifetime[Iterator]=(base->classScope->functionMap),end=0}
  && always {!<=-1,!>=2}
  it {lifetime[Iterator]=(base->classScope->functionMap),!symbolic=(base->classScope->functionMap.end()),!end=0}
  == always {!<=-1,!>=2}
  it possible lifetime[Iterator]=(base->classScope->functionMap)
Line 4990
  it possible lifetime[Iterator]=(base->classScope->functionMap)
Line 4991
  func always symbolic=(it->second)
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  >= always {!<=-1,!>=2}
  func always symbolic=(it->second)
  ( always !<=-1
  - always !<=-2
  1 always 1
  || always {!<=-1,!>=2}
Line 4992
  == always {!<=-1,!>=2}
  func always symbolic=(it->second)
  ( always !<=-1
  || always {!<=-1,!>=2}
  args always !symbolic=(func->argCount())
  < always {!<=-1,!>=2}
  func always symbolic=(it->second)
  ( always {!symbolic=(args),!<=-1}
  && always {!<=-1,!>=2}
  args {!symbolic=(func->argCount()),<=symbolic=(func->argCount()-1)}
  >= always {!<=-1,!>=2}
  func always symbolic=(it->second)
  ( always !<=-1
Line 4993
  func always symbolic=(it->second)
Line 4997
  base {symbolic=(i.type),!0}
  . always {!symbolic=(this),!0}
Line 5005
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  definedType always !0
  ( always {!<=-1,!>=2}
Line 5006
  = always !size=0
  definedType always !0
  . always !size=0
Line 5007
  derivedFrom always !size=0
Line 5009
  base always symbolic=(i.type)
  && always {!<=-1,!>=2}
  base {symbolic=(i.type),!0}
Line 5010
  base {symbolic=(i.type),!0}
  . always !0
  == always {!<=-1,!>=2}
  this always !0
Line 5013
  base {symbolic=(i.type),!0}
  == always {!<=-1,!>=2}
Line 5014
  base {symbolic=(i.type),!0}
  . always {!symbolic=(this),!0}
Line 5017
  . always !symbolic=(this)
  name always !symbolic=(base->name())
Line 5018
  t always symbolic=(base->classScope->findType(name))
Line 5019
  t {symbolic=(base->classScope->findType(name)),!0}
Line 5024
  nullptr always 0
Line 5029
  this always !0
Line 5030
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  definedType always !0
  ( always {!<=-1,!>=2}
Line 5031
  = always !size=0
  definedType always !0
  . always !size=0
Line 5032
  derivedFrom always !size=0
Line 5034
  base always symbolic=(i.type)
  && always {!<=-1,!>=2}
  base {symbolic=(i.type),!0}
Line 5035
  base {symbolic=(i.type),!0}
Line 5037
  base always !0
Line 5038
  ( possible lifetime[Iterator]=(result)
  ( {lifetime[Iterator]=(result),end=0}
  baseScopes always symbolic=(base->classScope->findAssociatedScopes())
  ( {lifetime[Iterator]=(baseScopes),start=0}
  ( {lifetime[Iterator]=(baseScopes),end=0}
Line 5047
  same always !<=-1
  fallback1 always !<=-1
  fallback2 always !<=-1
Line 5049
  callarg possible symbolic=(arguments[j]->variable())@19
Line 5050
  callarg {!0,symbolic=(arguments[j]->variable())@19}
  callarg {!0,symbolic=(arguments[j]->variable())@19}
Line 5051
  res possible {2,3,4}
  == {!<=-1,!>=2,0}
  :: always 1
  SAME always 1
Line 5052
  same always !<=-1
  ++ always !<=-1
Line 5055
  res {3,4,!1}
  == {!<=-1,!>=2,0}
  :: always 2
  FALLBACK1 always 2
Line 5056
  fallback1 always !<=-1
  ++ always !<=-1
Line 5059
  res {4,!1,!2}
  == {!<=-1,!>=2,0}
  :: always 3
  FALLBACK2 always 3
Line 5060
  fallback2 always !<=-1
  ++ always !<=-1
Line 5063
  res always {!2,!3}
  == always {!<=-1,!>=2}
  :: always 4
  NOMATCH always 4
Line 5066
  ptrequals always {!<=-1,!>=2}
  ptrequals always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  ( {!<=-1,!>=2,0}
  == always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 5067
  constEquals always {!<=-1,!>=2}
  constEquals always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  ! {!<=-1,!>=2,1}
  ( {!<=-1,!>=2,0}
  || always {!<=-1,!>=2}
  -1 always -1
  == always {!<=-1,!>=2}
  "const" always "const"
  == always {!<=-1,!>=2}
  -1 always -1
  == always {!<=-1,!>=2}
  "const" always "const"
Line 5068
  ptrequals {symbolic=(callarg->isArrayOrPointer()==funcarg->isArrayOrPointer()),!<=-1,!>=2,0}
  && always {!<=-1,!>=2}
  constEquals always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 5069
  == always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 5070
  ( always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 5071
  ( always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 5072
  same always !<=-1
  ++ always !<=-1
Line 5073
  ( always {!<=-1,!>=2}
Line 5074
  ptrequals {symbolic=(callarg->isArrayOrPointer()==funcarg->isArrayOrPointer()),!<=-1,!>=2}
  && always {!<=-1,!>=2}
  constEquals always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  "void" always "void"
Line 5075
  fallback1 always !<=-1
  ++ always !<=-1
Line 5076
  constEquals {!<=-1,!>=2,0}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "char|wchar_t" always "char|wchar_t"
Line 5077
  fallback2 always !<=-1
  ++ always !<=-1
Line 5078
  ptrequals {symbolic=(callarg->isArrayOrPointer()==funcarg->isArrayOrPointer()),!<=-1,!>=2}
Line 5079
  takesInt always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "char|short|int|long" always "char|short|int|long"
Line 5080
  takesFloat always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "float|double" always "float|double"
Line 5081
  passesInt always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "char|short|int|long" always "char|short|int|long"
Line 5082
  passesFloat always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "float|double" always "float|double"
Line 5083
  takesInt {!<=-1,!>=2,0}
  && always {!<=-1,!>=2}
  passesInt always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  takesFloat always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  passesFloat always {!<=-1,!>=2}
Line 5084
  fallback1 always !<=-1
  ++ always !<=-1
Line 5085
  takesInt always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  passesFloat always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  takesFloat always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  passesInt always {!<=-1,!>=2}
Line 5086
  fallback2 always !<=-1
  ++ always !<=-1
Line 5093
  ! always {!<=-1,!>=2}
  typeToken possible {symbolic=(vartok->variable()->typeStartToken())@15,symbolic=(funcarg->typeStartToken())@16}
Line 5094
  "" always ""
Line 5095
  ( always {!<=-1,!>=2}
  typeToken possible {symbolic=(vartok->variable()->typeStartToken())@15,symbolic=(funcarg->typeStartToken())@16}
  "%name%|*|&|::" always "%name%|*|&|::"
Line 5096
  == always {!<=-1,!>=2}
  "::" always "::"
Line 5098
  ( always {!<=-1,!>=2}
  ":: %name%" always ":: %name%"
Line 5099
  "::" always "::"
  1 always 1
Line 5100
  2 always 2
Line 5101
  == always {!<=-1,!>=2}
  "<" always "<"
Line 5102
  != always {!<=-1,!>=2}
Line 5104
  ">" always ">"
Line 5108
  ret possible size=0
Line 5110
  ( always {!<=-1,!>=2}
  "%name% const| %var%|*|&" always "%name% const| %var%|*|&"
Line 5115
  "" always ""
Line 5118
  , always {!<=-1,!>=2}
  requireConst always {!<=-1,!>=2}
Line 5120
  isCall always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "(|{" always "(|{"
Line 5127
  args always !<=-1
  = always !<=-1
  ( always !<=-1
Line 5129
  = possible lifetime[Lambda]=(tok)
  [ possible lifetime[Lambda]=(tok)
Line 5130
  = possible lifetime[Iterator]=(scope->functionMap)
  ( possible lifetime[Iterator]=(scope->functionMap)
  it possible lifetime[Iterator]=(scope->functionMap)
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(scope->functionMap),end=0}
  && always {!<=-1,!>=2}
  it {lifetime[Iterator]=(scope->functionMap),!symbolic=(scope->functionMap.cend()),!end=0}
  == always {!<=-1,!>=2}
  it possible lifetime[Iterator]=(scope->functionMap)
Line 5131
  it possible lifetime[Iterator]=(scope->functionMap)
Line 5132
  ! always {!<=-1,!>=2}
  isCall always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  args always !<=-1
  == always {!<=-1,!>=2}
  func always symbolic=(it->second)
  ( always !<=-1
  || always {!<=-1,!>=2}
Line 5133
  func always symbolic=(it->second)
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  args always {!<=-1,!symbolic=(func->argCount())}
  >= always {!<=-1,!>=2}
  func always symbolic=(it->second)
  ( always !<=-1
  - always !<=-2
  1 always 1
  || always {!<=-1,!>=2}
Line 5134
  args always {!<=-1,!symbolic=(func->argCount())}
  < always {!<=-1,!>=2}
  func always symbolic=(it->second)
  ( always {!symbolic=(args),!<=-1}
  && always {!<=-1,!>=2}
  args {!<=-1,!symbolic=(func->argCount()),<=symbolic=(func->argCount()-1)}
  >= always {!<=-1,!>=2}
  func always symbolic=(it->second)
  ( always !<=-1
Line 5135
  func always symbolic=(it->second)
Line 5140
  addMatchingFunctions possible lifetime[Lambda]=(tok)
  this always !0
Line 5144
  == always {!<=-1,!>=2}
  eNamespace always 4
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 5145
  addMatchingFunctions possible lifetime[Lambda]=(tok)
Line 5149
  args {symbolic=(arguments.size()),!<=-1}
Line 5152
  ! always {!<=-1,!>=2}
  isCall always {!<=-1,!>=2}
Line 5153
  ( always {!<=-1,!>=2}
  nullptr always 0
  : always 0
  matches always !size=0
  0 always 0
Line 5156
  = always 0
  nullptr always 0
Line 5157
  = always 0
  nullptr always 0
Line 5160
  i always !<=-1
  = always 0
  0 always 0
  i {!<=-1,0}
  < always {!<=-1,!>=2}
  ( always !<=-1
Line 5161
  constFallback always {!<=-1,!>=2}
  constFallback always {!<=-1,!>=2}
  = always 0
  false always 0
Line 5162
  i always !<=-1
Line 5163
  same always !<=-1
  same always !<=-1
  = always 0
  0 always 0
Line 5165
  requireConst {!<=-1,!>=2,0}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  func always symbolic=(matches[i])
  ( always {!<=-1,!>=2}
Line 5166
  i always !<=-1
  ++ always !<=-1
Line 5170
  ! {!<=-1,!>=2,1}
  requireConst {!<=-1,!>=2,0}
  || always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  func always symbolic=(matches[i])
  ( always {!<=-1,!>=2}
Line 5175
  scope always symbolic=(tok->scope())
  && always {!<=-1,!>=2}
  scope {symbolic=(tok->scope()),!0}
  && always {!<=-1,!>=2}
  scope {symbolic=(tok->scope()),!0}
  . always !0
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  scope always symbolic=(tok->scope())
Line 5177
  scope {symbolic=(tok->scope()),!0}
  . always !0
  ( {!<=-1,!>=2,0}
  != always {!<=-1,!>=2}
  func always symbolic=(matches[i])
  ( always {!<=-1,!>=2}
Line 5178
  scope {symbolic=(tok->scope()),!0}
  . always !0
  ( always {!<=-1,!>=2,!symbolic=(func->isConst())}
Line 5179
  ++ always !<=0
  i always !<=-1
Line 5182
  constFallback always {!<=-1,!>=2}
  = always 1
  true always 1
Line 5187
  fallback1 always !<=-1
  fallback1 always !<=-1
  = always 0
  0 always 0
Line 5188
  fallback2 always !<=-1
  fallback2 always !<=-1
  = always 0
  0 always 0
Line 5189
  erased always {!<=-1,!>=2}
  erased always {!<=-1,!>=2}
  = always 0
  false always 0
Line 5190
  j always !<=-1
  = always 0
  0 always 0
  j {!<=-1,>=symbolic=(func->argCount()-1+1),<=symbolic=(func->argCount()-1),0}
  < always {!<=-1,!>=2}
  args always !<=-1
  ++ always !<=0
  j always !<=-1
Line 5193
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  j always {!<=-1,!>=symbolic=(args)}
  > always {!<=-1,!>=2}
  ( always !<=-1
  - always !<=-2
  1 always 1
Line 5196
  j {!<=-1,<=symbolic=(func->argCount()-1)}
Line 5198
  ! {!<=-1,!>=2,1}
  j {!<=-1,<=symbolic=(func->argCount()-1)}
  ( possible 0
Line 5199
  j always !<=-1
Line 5200
  = always 0
  0 always 0
Line 5201
  vartok possible {symbolic=(arguments[j]),0}
  && always {!<=-1,!>=2}
  vartok {symbolic=(arguments[j]),!0}
  ( always {!<=-1,!>=2}
  "&" always "&"
  || always {!<=-1,!>=2}
  vartok {symbolic=(arguments[j]),!0}
  ( always {!<=-1,!>=2}
  "*" always "*"
Line 5202
  vartok always !0
  ( always {!<=-1,!>=2}
  "&" always "&"
  1 always 1
  : always -1
  -1 always -1
Line 5203
  vartok always !0
Line 5205
  vartok possible {symbolic=(arguments[j]),0}
  && always {!<=-1,!>=2}
  vartok always !0
Line 5206
  vartok always !0
  ( always !0
Line 5211
  ( always {!<=-1,!>=2}
  "%name%" always "%name%"
Line 5213
  ( always {!<=-1,!>=2}
  "%name%|*|&|::|<" always "%name%|*|&|::|<"
Line 5215
  ( possible size=1
  == {!<=-1,!>=2,0}
  "const" always "const"
Line 5216
  1 always 1
Line 5217
  ( possible size=1
  == always {!<=-1,!>=2}
  "*" always "*"
Line 5219
  == always {!<=-1,!>=2}
  "<" always "<"
Line 5220
  ! always {!<=-1,!>=2}
Line 5222
  = always !0
  ( always !0
Line 5229
  callArgTypeToken always symbolic=(vartok->variable()->typeStartToken())
Line 5230
  funcArgTypeToken always symbolic=(funcarg->typeStartToken())
Line 5231
  ! {!<=-1,!>=2,0}
  type1 possible {symbolic=(type2),size=0}
  ( {!<=-1,!>=2,1}
  && always {!<=-1,!>=2}
  type1 always !size=0
  == always {!<=-1,!>=2}
Line 5232
  callArgTypeToken always symbolic=(vartok->variable()->typeStartToken())
Line 5234
  funcArgTypeToken always symbolic=(funcarg->typeStartToken())
Line 5236
  = always 1
  = always 1
  :: always 1
  SIGNED always 1
Line 5237
  = always 12
  = always 12
  :: always 12
  INT always 12
Line 5239
  & {lifetime[Address]=(callArgType),!0}
  & {lifetime[Address]=(funcArgType),!0}
Line 5240
  res possible {2,3}
  == {!<=-1,!>=2,0}
  :: always 1
  SAME always 1
Line 5241
  ++ always !<=0
  same always !<=-1
Line 5242
  res {3,!1}
  == {!<=-1,!>=2,0}
  :: always 2
  FALLBACK1 always 2
Line 5243
  ++ always !<=0
  fallback1 always !<=-1
Line 5244
  res always {!1,!2}
  == always {!<=-1,!>=2}
  :: always 3
  FALLBACK2 always 3
Line 5245
  ++ always !<=0
  fallback2 always !<=-1
Line 5252
  ( always {!<=-1,!>=2}
  j always !<=-1
  "%var% ,|)" always "%var% ,|)"
Line 5253
  [ possible lifetime[Lambda]=(if(check->isCPP()))
  j always !<=-1
Line 5254
  callarg always symbolic=(arguments[j]->variable())
  same always !<=-1
  fallback1 always !<=-1
  fallback2 always !<=-1
Line 5257
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  j always !<=-1
  && always {!<=-1,!>=2}
  j always !<=-1
  ( always !0
  == always {!<=-1,!>=2}
  1 always 1
  && always {!<=-1,!>=2}
  j always !<=-1
  ( always !0
  == always {!<=-1,!>=2}
  :: always 9
  CHAR always 9
Line 5258
  fallback2 always !<=-1
  ++ always !<=-1
Line 5261
  ( {!<=-1,!>=2,0}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  j always !<=-1
  "nullptr|NULL ,|)" always "nullptr|NULL ,|)"
Line 5262
  same always !<=-1
  ++ always !<=-1
Line 5264
  ( {!<=-1,!>=2,0}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  j always !<=-1
Line 5265
  fallback1 always !<=-1
  ++ always !<=-1
Line 5268
  ( always {!<=-1,!>=2}
Line 5269
  j always !<=-1
Line 5270
  vartok always symbolic=(arguments[j])
  == always {!<=-1,!>=2}
  "." always "."
Line 5271
  vartok always symbolic=(arguments[j])
Line 5273
  rml always !0
Line 5275
  vartok possible {symbolic=(arguments[j]),symbolic=(rml->previous())}
  ( always {!<=-1,!>=2}
  "&" always "&"
  || always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "*" always "*"
Line 5279
  unknownDeref {!<=-1,!>=2,0}
  unknownDeref always {!<=-1,!>=2}
  = always 0
  false always 0
Line 5280
  var always symbolic=(vartok->variable())
  && always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always !0
  == always {!<=-1,!>=2}
  "*" always "*"
Line 5281
  var {symbolic=(vartok->variable()),!0}
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  var {symbolic=(vartok->variable()),!0}
  && always {!<=-1,!>=2}
  var {symbolic=(vartok->variable()),!0}
  ( always !0
Line 5282
  var {symbolic=(vartok->variable()),!0}
  ( always !0
  . always !0
Line 5284
  unknownDeref always {!<=-1,!>=2}
  = always 1
  true always 1
Line 5286
  j always !<=-1
  var possible symbolic=(vartok->variable())
Line 5287
  res possible {2,3,4}
  == {!<=-1,!>=2,0}
  :: always 1
  SAME always 1
Line 5288
  ++ always !<=0
  same always !<=-1
Line 5289
  res {3,4,!1}
  == {!<=-1,!>=2,0}
  :: always 2
  FALLBACK1 always 2
Line 5290
  ++ always !<=0
  fallback1 always !<=-1
Line 5291
  res {4,!1,!2}
  == {!<=-1,!>=2,0}
  :: always 3
  FALLBACK2 always 3
Line 5292
  ++ always !<=0
  fallback2 always !<=-1
Line 5293
  res always {!1,!2,!3}
  == always {!<=-1,!>=2}
  :: always 4
  NOMATCH always 4
Line 5294
  unknownDeref always {!<=-1,!>=2}
Line 5297
  ( {lifetime[Iterator]=(matches),start=0}
  + {lifetime[Iterator]=(matches),!<=start=-1}
  i always !<=-1
Line 5298
  erased always {!<=-1,!>=2}
  = always 1
  true always 1
Line 5305
  fallback1 always !<=-1
  ++ always !<=-1
Line 5308
  hasToBe always !<=-1
  = always !<=-1
  ( always {!<=-1,!>=2}
  ? always !<=-1
  ( always !<=-1
  - always !<=-2
  1 always 1
  : always !<=-1
  args always !<=-1
Line 5311
  same always !<=-1
  == always {!<=-1,!>=2}
  hasToBe {symbolic=(func->isVariadic()?(func->argCount()-1):args),!<=-1,symbolic=(same+fallback1),symbolic=(same+fallback2+fallback1)}
Line 5312
  constFallback always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  requireConst always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 5318
  ! always {!<=-1,!>=2}
Line 5319
  same always {!<=-1,!symbolic=(hasToBe)}
  + always !<=-1
  fallback1 always !<=-1
  == always {!<=-1,!>=2}
  hasToBe {symbolic=(func->isVariadic()?(func->argCount()-1):args),!<=-1,symbolic=(same+fallback2+fallback1),!symbolic=(same)}
Line 5321
  ! always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  same always {!<=-1,!symbolic=(hasToBe)}
  + always !<=-1
  fallback2 always !<=-1
  + always !<=-1
  fallback1 always !<=-1
  == always {!<=-1,!>=2}
  hasToBe {symbolic=(func->isVariadic()?(func->argCount()-1):args),!<=-1,!symbolic=(same),!symbolic=(same+fallback1)}
Line 5325
  ! {!<=-1,!>=2,0}
  erased {!<=-1,!>=2,1}
Line 5326
  ++ always !<=0
  i always !<=-1
Line 5330
  fallback1Func possible 0
Line 5331
  fallback1Func always !0
Line 5333
  fallback2Func possible 0
Line 5334
  fallback2Func always !0
Line 5337
  ( possible lifetime[Iterator]=(matches)
  ( possible lifetime[Iterator]=(matches)
  ( {lifetime[Iterator]=(matches),start=0}
  ( {lifetime[Iterator]=(matches),end=0}
Line 5338
  ( always {!<=-1,!>=2}
Line 5339
  ( {lifetime[Iterator]=(matches),end=0}
Line 5342
  ( always !<=-1
  == always {!<=-1,!>=2}
  1 always 1
Line 5343
  matches always size=1
  0 always 0
Line 5345
  nullptr always 0
Line 5354
  currScope possible symbolic=(tok->scope())
  && always {!<=-1,!>=2}
  currScope {symbolic=(tok->scope()),!0}
  ( always {!<=-1,!>=2}
Line 5355
  currScope always !0
Line 5356
  = always !0
  currScope always !0
  . always !0
Line 5358
  currScope always !0
Line 5362
  -1 always -1
  == always {!<=-1,!>=2}
  "::" always "::"
Line 5366
  ( always {!<=-1,!>=2}
  tok1 possible symbolic=(tok)
  -2 always -2
  ">|%type% ::" always ">|%type% ::"
Line 5367
  -2 always -2
  == always {!<=-1,!>=2}
  ">" always ">"
Line 5368
  -2 always -2
Line 5369
  -2 always -2
  -1 always -1
Line 5371
  . always {!<=-1,!>=2}
  debugwarnings always {!<=-1,!>=2}
Line 5372
  -2 always -2
  "debug" always "debug"
  "SymbolDatabase::findFunction found '>' without link." always "SymbolDatabase::findFunction found '>' without link."
Line 5373
  nullptr always 0
Line 5376
  -2 always -2
Line 5380
  tok1 possible symbolic=(tok)
  -1 always -1
  == always {!<=-1,!>=2}
  "::" always "::"
Line 5381
  = {lifetime[Object]=(scopeList),!0}
  & {lifetime[Object]=(scopeList),!0}
Line 5383
  ( always {!<=-1,!>=2}
  "%name% (" always "%name% ("
Line 5384
  currScope {lifetime[Object]=(scopeList),symbolic=(&scopeList.front()),!0}
Line 5386
  currScope {lifetime[Object]=(scopeList),symbolic=(&scopeList.front()),!0}
Line 5392
  currScope always !0
  == always {!<=-1,!>=2}
Line 5395
  currScope always !0
  ( always !symbolic=(currScope->className)
Line 5398
  = always !0
  scope always !0
Line 5401
  currScope always !0
Line 5406
  currScope possible symbolic=(scope)
Line 5407
  currScope possible 0
  && always {!<=-1,!>=2}
  tok1 possible 0
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  tok1 always !0
  "%type% :: %name% [(),>]" always "%type% :: %name% [(),>]"
  || always {!<=-1,!>=2}
Line 5408
  ( always {!<=-1,!>=2}
  tok1 always !0
  "%type% <" always "%type% <"
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  tok1 always !0
  1 always 1
  "> :: %name% (" always "> :: %name% ("
Line 5409
  tok1 always !0
  1 always 1
  == always {!<=-1,!>=2}
  "::" always "::"
Line 5410
  tok1 always !0
  2 always 2
Line 5411
  tok1 always !0
  1 always 1
  == always {!<=-1,!>=2}
  "<" always "<"
Line 5412
  tok1 always !0
  1 always 1
  2 always 2
Line 5414
  = always 0
  nullptr always 0
Line 5416
  tok1 possible 0
Line 5417
  currScope always !0
  tok1 always !0
Line 5419
  func always !0
Line 5421
  currScope always !0
  tok1 always !0
Line 5425
  tok1 possible 0
Line 5426
  tok1 always !0
  2 always 2
Line 5428
  && always {!<=-1,!>=2}
Line 5429
  currScope always !0
  tok1 always !0
Line 5434
  ( always {!<=-1,!>=2}
  -2 always -2
  "!!this ." always "!!this ."
Line 5436
  tok1 {symbolic=(tok->previous()->astOperand1()),0}
  && always {!<=-1,!>=2}
  tok1 {symbolic=(tok->previous()->astOperand1()),!0}
  && always {!<=-1,!>=2}
  tok1 {symbolic=(tok->previous()->astOperand1()),!0}
  ( always !0
Line 5437
  tok1 {symbolic=(tok->previous()->astOperand1()),!0}
  ( always !0
  . always !0
  tok1 {symbolic=(tok->previous()->astOperand1()),!0}
  ( always !0
  == always {!<=-1,!>=2}
  1 always 1
Line 5438
  tok1 {symbolic=(tok->previous()->astOperand1()),0}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  tok1 {symbolic=(tok->previous()->astOperand1()),!0}
  "%name% (" always "%name% ("
  && always {!<=-1,!>=2}
  tok1 {symbolic=(tok->previous()->astOperand1()),!0}
  && always {!<=-1,!>=2}
Line 5439
  tok1 always symbolic=(tok->previous()->astOperand1())
  ( always !0
Line 5440
  tok1 {symbolic=(tok->previous()->astOperand1()),!0}
  ( always !0
  . always !0
Line 5442
  == always {!<=-1,!>=2}
  1 always 1
Line 5443
  ( always {!<=-1,!>=2}
  tok1 {symbolic=(tok->previous()->astOperand1()),0}
  "%var% ." always "%var% ."
Line 5444
  tok1 always symbolic=(tok->previous()->astOperand1())
Line 5445
  && always {!<=-1,!>=2}
  var always !0
Line 5446
  var always !0
  ( always !0
  var always !0
  == always {!<=-1,!>=2}
  1 always 1
Line 5447
  var possible 0
  && always {!<=-1,!>=2}
  var always !0
  && always {!<=-1,!>=2}
  var always !0
  ( always !0
  && always {!<=-1,!>=2}
  tok1 always symbolic=(tok->previous()->astOperand1())
  == always {!<=-1,!>=2}
  "->" always "->"
Line 5448
  var always !0
  ( always !0
  . always !0
  var always !0
  == always {!<=-1,!>=2}
  1 always 1
Line 5449
  ( always {!<=-1,!>=2}
  ( always symbolic=(tok1)
  "(" always "("
Line 5450
  = always symbolic=(tok1)
  ( always symbolic=(tok1)
Line 5451
  castTok always {symbolic=(tok->previous()->astOperand1()),symbolic=(tok1)}
  ( always {!<=-1,!>=2}
Line 5452
  castTok always {symbolic=(tok->previous()->astOperand1()),symbolic=(tok1)}
Line 5454
  == always {!<=-1,!>=2}
  1 always 1
Line 5462
  currScope always !0
Line 5464
  func always !0
Line 5465
  currScope always !0
Line 5469
  ( always {!<=-1,!>=2}
  "%name% (|{" always "%name% (|{"
Line 5472
  false always 0
Line 5474
  nullptr always 0
Line 5482
  == always {!<=-1,!>=2}
Line 5483
  & {lifetime[Address]=(scopeList),!0}
Line 5485
  nullptr always 0
Line 5490
  , always {!<=-1,!>=2}
  isC always {!<=-1,!>=2}
Line 5493
  == always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  != always {!<=-1,!>=2}
Line 5495
  isC always {!<=-1,!>=2}
Line 5496
  isC always 1
Line 5498
  nestedScope always !0
Line 5504
  nested_type always symbolic=(findType(name))
Line 5505
  nested_type {symbolic=(findType(name)),!0}
  ( always {!<=-1,!>=2}
Line 5506
  nested_type {symbolic=(findType(name)),!0}
  == always {!<=-1,!>=2}
  nested_type {symbolic=(findType(name)),!0}
Line 5507
  nested_type {symbolic=(findType(name)),!0}
  . always symbolic=(nested_type->typeEnd)
Line 5509
  nested_type {symbolic=(findType(name)),!0}
Line 5512
  nullptr always 0
Line 5519
  = possible lifetime[Iterator]=(definedTypesMap)
  ( possible lifetime[Iterator]=(definedTypesMap)
Line 5522
  ( {lifetime[Iterator]=(definedTypesMap),end=0}
  != always {!<=-1,!>=2}
  it {lifetime[Iterator]=(definedTypesMap),symbolic=(definedTypesMap.find(name))}
Line 5523
  it {lifetime[Iterator]=(definedTypesMap),symbolic=(definedTypesMap.find(name)),!symbolic=(definedTypesMap.end()),!end=0}
Line 5526
  = possible lifetime[Iterator]=(definedTypesMap)
  ( possible lifetime[Iterator]=(definedTypesMap)
  "" always ""
Line 5527
  it {lifetime[Iterator]=(definedTypesMap),symbolic=(definedTypesMap.find(""))}
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(definedTypesMap),end=0}
Line 5529
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  eNamespace always 4
  || always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 5531
  t always symbolic=(scope->findType(name))
Line 5532
  t {symbolic=(scope->findType(name)),!0}
Line 5538
  nullptr always 0
Line 5546
  == always {!<=-1,!>=2}
Line 5553
  child always !0
Line 5555
  nullptr always 0
Line 5563
  == always {!<=-1,!>=2}
  :: always 4
  eDestructor always 4
Line 5564
  & {lifetime[Address]=(functionList),!0}
Line 5566
  nullptr always 0
Line 5571
  ( always {!<=-1,!>=2}
Line 5573
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 5580
  = always 0
  nullptr always 0
Line 5582
  == always {!<=-1,!>=2}
  "::" always "::"
Line 5584
  = {lifetime[Object]=(scopeList),!0}
  & {lifetime[Object]=(scopeList),!0}
Line 5587
  ( always {!<=-1,!>=2}
Line 5588
  = inconclusive lifetime[Object]=(scopeList)@36727
  startScope inconclusive lifetime[Object]=(scopeList)@36727
Line 5591
  scope {lifetime[Object]=(scopeList),symbolic=(&scopeList.front()),symbolic=(startScope),lifetime[Object]=(scopeList)@36727}
  && always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  tok always !0
  ( always {!<=-1,!>=2}
Line 5592
  tok always !0
  1 always 1
  == always {!<=-1,!>=2}
  "::" always "::"
Line 5593
  scope {lifetime[Object]=(scopeList),!0,lifetime[Object]=(scopeList)@36727}
  tok always !0
Line 5594
  tok always !0
  2 always 2
Line 5595
  tok always !0
  1 always 1
  == always {!<=-1,!>=2}
  "<" always "<"
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  tok always !0
  1 always 1
  "> ::" always "> ::"
Line 5596
  scope {lifetime[Object]=(scopeList),!0,lifetime[Object]=(scopeList)@36727}
  tok always !0
Line 5597
  tok always !0
  1 always 1
  2 always 2
Line 5599
  scope {lifetime[Object]=(scopeList),!0,lifetime[Object]=(scopeList)@36727}
  tok always !0
Line 5603
  nullptr always 0
Line 5608
  , always {!<=-1,!>=2}
  lookOutside always {!<=-1,!>=2}
Line 5611
  ( always {!<=-1,!>=2}
  "struct|union" always "struct|union"
Line 5615
  == always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  1 always 1
  != always {!<=-1,!>=2}
  "::" always "::"
Line 5618
  ( always {!<=-1,!>=2}
Line 5620
  scope possible symbolic=(startScope)
Line 5621
  ( possible symbolic=(typeScope->className)
  == always {!<=-1,!>=2}
  scope {symbolic=(startScope),!0}
  && always {!<=-1,!>=2}
  scope always !0
  ( always {!<=-1,!>=2}
Line 5622
  scope always !0
Line 5623
  scope always !0
  true always 1
Line 5625
  == always {!<=-1,!>=2}
  typeScope always !0
  && always {!<=-1,!>=2}
  typeScope always !0
  ( always {!<=-1,!>=2}
Line 5626
  typeScope always !0
Line 5627
  type always !0
Line 5630
  scope always !0
Line 5632
  nullptr always 0
Line 5638
  == always {!<=-1,!>=2}
  "::" always "::"
Line 5640
  = {lifetime[Object]=(scopeList),!0}
  & {lifetime[Object]=(scopeList),!0}
Line 5644
  = possible {lifetime[Object]=(scopeList),symbolic=(startScope),symbolic=(&scopeList.front())}
  start_scope possible {lifetime[Object]=(scopeList),symbolic=(startScope),symbolic=(&scopeList.front())}
Line 5646
  scope possible {symbolic=(start_scope),lifetime[Object]=(scopeList),symbolic=(startScope),symbolic=(&scopeList.front())}
  && always {!<=-1,!>=2}
  tok possible symbolic=(startTok)
  && always {!<=-1,!>=2}
  tok {symbolic=(startTok),!0}
  ( always {!<=-1,!>=2}
Line 5647
  tok always !0
  1 always 1
  == always {!<=-1,!>=2}
  "::" always "::"
  || always {!<=-1,!>=2}
  tok always !0
  1 always 1
  == always {!<=-1,!>=2}
  "<" always "<"
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  tok always !0
  1 always 1
  "> ::" always "> ::"
Line 5648
  scope {lifetime[Object]=(scopeList),!0}
  tok always !0
Line 5650
  tok always !0
  1 always 1
  == always {!<=-1,!>=2}
  "::" always "::"
Line 5651
  tok always !0
  2 always 2
Line 5653
  tok always !0
  1 always 1
  2 always 2
Line 5655
  start_scope possible lifetime[Object]=(scopeList)
Line 5656
  ! always {!<=-1,!>=2}
Line 5658
  = always !0
  start_scope always !0
Line 5662
  scope {lifetime[Object]=(scopeList),!0}
  tok always !0
Line 5664
  type {symbolic=(scope->findType(tok->str())),0}
Line 5665
  type {symbolic=(scope->findType(tok->str())),!0}
Line 5666
  scope1 always Uninit
  scope {lifetime[Object]=(scopeList),!0}
  tok always !0
Line 5667
  scope1 always !0
Line 5668
  type always symbolic=(scope1->definedType)
Line 5669
  type {symbolic=(scope1->definedType),!0}
Line 5670
  scope {lifetime[Object]=(scopeList),!0}
  == always {!<=-1,!>=2}
  :: always 4
  eNamespace always 4
  && always {!<=-1,!>=2}
  lookOutside always {!<=-1,!>=2}
Line 5671
  scope {lifetime[Object]=(scopeList),!0}
Line 5680
  = {lifetime[Iterator]=(startScope->usingList),start=0}
  startScope always !0
  ( {lifetime[Iterator]=(startScope->usingList),start=0}
Line 5681
  it possible {lifetime[Iterator]=(startScope->usingList),start=0}
  != always {!<=-1,!>=2}
  startScope {symbolic=(start_scope),!0}
  ( {lifetime[Iterator]=(startScope->usingList),end=0}
  it possible lifetime[Iterator]=(startScope->usingList)
Line 5683
  it {lifetime[Iterator]=(startScope->usingList),!symbolic=(startScope->usingList.end()),!end=0}
Line 5684
  = always !0
  startScope always !0
Line 5686
  scope possible {symbolic=(it->scope),symbolic=(start_scope)}
  && always {!<=-1,!>=2}
  tok possible symbolic=(startTok)
  && always {!<=-1,!>=2}
  tok {symbolic=(startTok),!0}
  ( always {!<=-1,!>=2}
Line 5687
  tok always !0
  1 always 1
  == always {!<=-1,!>=2}
  "::" always "::"
  || always {!<=-1,!>=2}
  tok always !0
  1 always 1
  == always {!<=-1,!>=2}
  "<" always "<"
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  tok always !0
  1 always 1
  "> ::" always "> ::"
Line 5688
  scope always !0
  tok always !0
Line 5690
  tok always !0
  1 always 1
  == always {!<=-1,!>=2}
  "::" always "::"
Line 5691
  tok always !0
  2 always 2
Line 5693
  tok always !0
  1 always 1
  2 always 2
Line 5696
  ! always {!<=-1,!>=2}
Line 5698
  = always !0
  start_scope always !0
Line 5702
  scope always !0
  tok always !0
Line 5704
  type {symbolic=(scope->findType(tok->str())),0}
Line 5705
  type {symbolic=(scope->findType(tok->str())),!0}
Line 5706
  scope1 always Uninit
  scope always !0
  tok always !0
Line 5707
  scope1 always !0
Line 5708
  type always symbolic=(scope1->definedType)
Line 5709
  type {symbolic=(scope1->definedType),!0}
Line 5715
  startScope always !0
Line 5719
  nullptr always 0
Line 5727
  ( always {!<=-1,!>=2}
  "struct|union|enum" always "struct|union|enum"
Line 5731
  ( possible size=2
  == always {!<=-1,!>=2}
  startScope possible lifetime[Address]=(scopeList)@15
  && always {!<=-1,!>=2}
  startScope possible lifetime[Address]=(scopeList)@15
  ( always {!<=-1,!>=2}
Line 5732
  startScope possible lifetime[Address]=(scopeList)@15
Line 5734
  hasPath always {!<=-1,!>=2}
  hasPath always {!<=-1,!>=2}
  = always 0
  false always 0
Line 5737
  == always {!<=-1,!>=2}
  "::" always "::"
Line 5738
  hasPath always {!<=-1,!>=2}
  = always 1
  true always 1
Line 5740
  = {lifetime[Object]=(scopeList),!0}
  & {lifetime[Object]=(scopeList),!0}
Line 5744
  = possible {lifetime[Object]=(scopeList),symbolic=(&scopeList.front())}
  startScope possible {lifetime[Object]=(scopeList),symbolic=(&scopeList.front())}
Line 5746
  scope possible {symbolic=(startScope),lifetime[Object]=(scopeList),symbolic=(&scopeList.front())}
  && always {!<=-1,!>=2}
  tok possible symbolic=(startTok)
  && always {!<=-1,!>=2}
  tok {symbolic=(startTok),!0}
  ( always {!<=-1,!>=2}
Line 5747
  tok always !0
  1 always 1
  == always {!<=-1,!>=2}
  "::" always "::"
  || always {!<=-1,!>=2}
  tok always !0
  1 always 1
  == always {!<=-1,!>=2}
  "<" always "<"
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  tok always !0
  1 always 1
  "> ::" always "> ::"
Line 5748
  hasPath always {!<=-1,!>=2}
  = always 1
  true always 1
Line 5749
  scope {lifetime[Object]=(scopeList),!0}
  tok always !0
Line 5751
  tok always !0
  1 always 1
  == always {!<=-1,!>=2}
  "::" always "::"
Line 5752
  tok always !0
  2 always 2
Line 5754
  tok always !0
  1 always 1
  2 always 2
Line 5756
  startScope possible lifetime[Object]=(scopeList)
Line 5757
  ! always {!<=-1,!>=2}
Line 5759
  = always !0
  startScope always !0
Line 5763
  scope {lifetime[Object]=(scopeList),!0}
  tok always !0
Line 5764
  hasPath always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  type always symbolic=(scope->findType(tok->str()))
Line 5765
  type always symbolic=(scope->findType(tok->str()))
Line 5767
  scope {lifetime[Object]=(scopeList),!0}
Line 5768
  ! always {!<=-1,!>=2}
Line 5775
  nullptr always 0
Line 5782
  scope inconclusive {lifetime[Object]=(scopeList)@143,lifetime[Object]=(scopeList)@143,lifetime[Object]=(scopeList)@143,lifetime[Object]=(scopeList)@143}
Line 5785
  s always !0
Line 5786
  scope inconclusive lifetime[Object]=(scopeList)@143
Line 5787
  scope inconclusive lifetime[Object]=(scopeList)@143
  . always !0
Line 5789
  nullptr always 0
Line 5796
  = always 0
  nullptr always 0
Line 5797
  destructor always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  -1 always -1
  == always {!<=-1,!>=2}
  "~" always "~"
Line 5799
  = possible lifetime[Iterator]=(ns->functionMap)
  ( possible lifetime[Iterator]=(ns->functionMap)
Line 5800
  it possible lifetime[Iterator]=(ns->functionMap)
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(ns->functionMap),end=0}
  && always {!<=-1,!>=2}
  it {lifetime[Iterator]=(ns->functionMap),!symbolic=(ns->functionMap.end()),!end=0}
  == always {!<=-1,!>=2}
Line 5802
  it possible lifetime[Iterator]=(ns->functionMap)
  && always {!<=-1,!>=2}
Line 5803
  == always {!<=-1,!>=2}
  destructor always {!<=-1,!>=2}
Line 5809
  ! {!<=-1,!>=2,1}
  function possible {symbolic=(it->second),0}
Line 5811
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  1 always 1
  "::|<" always "::|<"
Line 5812
  1 always 1
  == always {!<=-1,!>=2}
  "::" always "::"
Line 5813
  2 always 2
Line 5814
  1 always 1
Line 5815
  1 always 1
  2 always 2
Line 5817
  nullptr always 0
Line 5818
  == always {!<=-1,!>=2}
  "~" always "~"
Line 5820
  scope always !0
Line 5824
  ( possible symbolic=(it->second)
  function possible symbolic=(it->second)
Line 5838
  "_Alignas" always "_Alignas"
  "_Alignof" always "_Alignof"
  "_Atomic" always "_Atomic"
  "_Bool" always "_Bool"
  "_Complex" always "_Complex"
  "_Generic" always "_Generic"
  "_Imaginary" always "_Imaginary"
  "_Noreturn" always "_Noreturn"
  "_Static_assert" always "_Static_assert"
  "_Thread_local" always "_Thread_local"
  "auto" always "auto"
  "break" always "break"
  "case" always "case"
  "char" always "char"
  "const" always "const"
  "continue" always "continue"
  "default" always "default"
  "do" always "do"
  "double" always "double"
  "else" always "else"
  "enum" always "enum"
  "extern" always "extern"
  "float" always "float"
  "for" always "for"
  "goto" always "goto"
  "if" always "if"
  "inline" always "inline"
  "int" always "int"
  "long" always "long"
  "register" always "register"
  "return" always "return"
  "short" always "short"
  "signed" always "signed"
  "sizeof" always "sizeof"
  "static" always "static"
  "struct" always "struct"
  "switch" always "switch"
  "typedef" always "typedef"
  "union" always "union"
  "unsigned" always "unsigned"
  "void" always "void"
  "volatile" always "volatile"
  "while" always "while"
  "restrict" always "restrict"
Line 5840
  "_Alignas" always "_Alignas"
  "_Alignof" always "_Alignof"
  "_Atomic" always "_Atomic"
  "_Bool" always "_Bool"
  "_Complex" always "_Complex"
  "_Generic" always "_Generic"
  "_Imaginary" always "_Imaginary"
  "_Noreturn" always "_Noreturn"
  "_Static_assert" always "_Static_assert"
  "_Thread_local" always "_Thread_local"
  "auto" always "auto"
  "break" always "break"
  "case" always "case"
  "char" always "char"
  "const" always "const"
  "continue" always "continue"
  "default" always "default"
  "do" always "do"
  "double" always "double"
  "else" always "else"
  "enum" always "enum"
  "extern" always "extern"
  "float" always "float"
  "for" always "for"
  "goto" always "goto"
  "if" always "if"
  "inline" always "inline"
  "int" always "int"
  "long" always "long"
  "register" always "register"
  "return" always "return"
  "short" always "short"
  "signed" always "signed"
  "sizeof" always "sizeof"
  "static" always "static"
  "struct" always "struct"
  "switch" always "switch"
  "typedef" always "typedef"
  "union" always "union"
  "unsigned" always "unsigned"
  "void" always "void"
  "volatile" always "volatile"
  "while" always "while"
Line 5841
  "alignas" always "alignas"
  "alignof" always "alignof"
  "and" always "and"
  "and_eq" always "and_eq"
  "asm" always "asm"
  "bitand" always "bitand"
  "bitor" always "bitor"
  "bool" always "bool"
  "catch" always "catch"
  "char8_t" always "char8_t"
  "char16_t" always "char16_t"
Line 5842
  "char32_t" always "char32_t"
  "class" always "class"
  "compl" always "compl"
  "concept" always "concept"
  "consteval" always "consteval"
  "constexpr" always "constexpr"
  "constinit" always "constinit"
  "const_cast" always "const_cast"
  "co_await" always "co_await"
Line 5843
  "co_return" always "co_return"
  "co_yield" always "co_yield"
  "decltype" always "decltype"
Line 5844
  "delete" always "delete"
  "dynamic_cast" always "dynamic_cast"
  "explicit" always "explicit"
  "export" always "export"
  "false" always "false"
  "friend" always "friend"
Line 5845
  "mutable" always "mutable"
  "namespace" always "namespace"
  "new" always "new"
  "noexcept" always "noexcept"
  "not" always "not"
  "not_eq" always "not_eq"
  "nullptr" always "nullptr"
  "operator" always "operator"
Line 5846
  "or" always "or"
  "or_eq" always "or_eq"
  "private" always "private"
  "protected" always "protected"
  "public" always "public"
  "reinterpret_cast" always "reinterpret_cast"
Line 5847
  "requires" always "requires"
  "static_assert" always "static_assert"
Line 5848
  "static_cast" always "static_cast"
  "template" always "template"
  "this" always "this"
  "thread_local" always "thread_local"
  "throw" always "throw"
Line 5849
  "true" always "true"
  "try" always "try"
  "typeid" always "typeid"
  "typename" always "typename"
  "using" always "using"
Line 5850
  "virtual" always "virtual"
  "wchar_t" always "wchar_t"
  "xor" always "xor"
  "xor_eq" always "xor_eq"
Line 5854
  ( always {!<=-1,!>=2}
Line 5856
  ( always {!<=-1,!>=2}
Line 5857
  return always {!<=-1,!>=2}
  ( possible lifetime[Iterator]=(cpp_keywords)
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(cpp_keywords),end=0}
Line 5859
  return always {!<=-1,!>=2}
  ( possible lifetime[Iterator]=(c_keywords)
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(c_keywords),end=0}
Line 5866
  == always {!<=-1,!>=2}
  0 always 0
  && always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always !0
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always !0
Line 5868
  ( always !0
  . always !0
Line 5869
  enum_type always symbolic=(type->type()->classScope->enumType)
Line 5870
  enum_type {symbolic=(type->type()->classScope->enumType),!0}
Line 5873
  size possible symbolic=(mSettings->sizeof_int)
Line 5882
  = always !<=-1
  ( always !0
  ( always !<=-1
Line 5883
  = always !<=-1
  ( always !<=-1
Line 5886
  ( always !0
Line 5887
  ( always !0
Line 5890
  & {lifetime[Address]=(valuetype),!0}
Line 5891
  == always {!<=-1,!>=2}
  "." always "."
  && always {!<=-1,!>=2}
Line 5892
  ( always !0
Line 5893
  vt always symbolic=(tok->astOperand1()->valueType())
  && always {!<=-1,!>=2}
  vt {symbolic=(tok->astOperand1()->valueType()),!0}
  & possible {0,1}
  1 always 1
  != {0,1,!<=-1,!>=2}
  0 always 0
Line 5894
  1 always 1
Line 5905
  type always symbolic=(enumerator.scope->enumType)
Line 5906
  type {symbolic=(enumerator.scope->enumType),!0}
  type {symbolic=(enumerator.scope->enumType),!0}
  ( always {!<=-1,!>=2}
Line 5907
  == always {!<=-1,!>=2}
  :: always 0
  UNKNOWN_TYPE always 0
  && always {!<=-1,!>=2}
  type always !0
  ( always {!<=-1,!>=2}
Line 5908
  ( always {!<=-1,!>=2}
  type always !0
Line 5910
  ( always {!<=-1,!>=2}
Line 5911
  type always !0
  ( always {!<=-1,!>=2}
Line 5912
  = always 1
  :: always 1
  SIGNED always 1
Line 5913
  type always !0
  ( always {!<=-1,!>=2}
Line 5914
  = always 2
  :: always 2
  UNSIGNED always 2
Line 5915
  == always {!<=-1,!>=2}
  :: always 9
  CHAR always 9
Line 5918
  = always 1
  :: always 1
  SIGNED always 1
Line 5923
  = always 1
  :: always 1
  SIGNED always 1
Line 5924
  = always 12
  :: always 12
  INT always 12
Line 5932
  valuetype always symbolic=(autoTok->valueType())
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  valuetype always symbolic=(autoTok->valueType())
  ( always {!<=-1,!>=2}
Line 5933
  true always 1
Line 5936
  ( always {!<=-1,!>=2}
Line 5938
  return always {!<=-1,!>=2}
  yield possible {0,2,3}
  == {!<=-1,!>=2,0}
  :: always 1
  ITEM always 1
  || always {!<=-1,!>=2}
  yield {2,3,!1}
  == {!<=-1,!>=2,0}
  :: always 0
  AT_INDEX always 0
  || always {!<=-1,!>=2}
Line 5939
  yield {3,!1,!0}
  == {!<=-1,!>=2,0}
  :: always 2
  BUFFER always 2
  || always {!<=-1,!>=2}
  yield always {!0,!2}
  == always {!<=-1,!>=2}
  :: always 3
  BUFFER_NT always 3
Line 5942
  ( always {!<=-1,!>=2}
Line 5944
  return always {!<=-1,!>=2}
  yield possible 3
  == {!<=-1,!>=2,0}
  :: always 2
  BUFFER always 2
  || always {!<=-1,!>=2}
  yield always !2
  == always {!<=-1,!>=2}
  :: always 3
  BUFFER_NT always 3
Line 5949
  tok possible symbolic=(parent->previous())@164
Line 5950
  tok possible symbolic=(parent->previous())@164
Line 5951
  ! always {!<=-1,!>=2}
  parent always symbolic=(tok->astParent())
  || always {!<=-1,!>=2}
  parent {symbolic=(tok->astParent()),!0}
Line 5953
  ! always {!<=-1,!>=2}
  parent {symbolic=(tok->astParent()),!0}
Line 5956
  parent always !0
  ( always 1
  parent always !0
  ( always !0
  : always 0
  nullptr always 0
Line 5957
  parent always !0
  parent always !0
  ( always !0
  : always 0
  nullptr always 0
Line 5959
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  parent always !0
  "<<|>>" always "<<|>>"
Line 5960
  ! always {!<=-1,!>=2}
  mIsCpp always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  vt2 always symbolic=(parent->astOperand2()?parent->astOperand2()->valueType():nullptr)
  && always {!<=-1,!>=2}
  vt2 {symbolic=(parent->astOperand2()?parent->astOperand2()->valueType():nullptr),!0}
  ( always {!<=-1,!>=2}
Line 5961
  vt1 always !0
  . possible {>=12,<=11}
  < {!<=-1,!>=2,>=0}
  :: always 8
  BOOL always 8
  || {!<=-1,!>=2,0}
  vt1 always !0
  . {!<=7,>=8}
  >= {!<=-1,!>=2,>=0}
  :: always 12
  INT always 12
Line 5962
  vt1 always !0
Line 5963
  = always 0
  :: always 0
  None always 0
Line 5964
  parent always !0
Line 5966
  vt1 always !0
Line 5967
  = always 12
  :: always 12
  INT always 12
Line 5968
  = always 1
  :: always 1
  SIGNED always 1
Line 5969
  = always 0
  :: always 0
  None always 0
Line 5970
  parent always !0
Line 5977
  vt1 possible 0
  && always {!<=-1,!>=2}
  vt1 always !0
  && always {!<=-1,!>=2}
  vt1 always !0
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  ". %name% (" always ". %name% ("
  && always {!<=-1,!>=2}
Line 5978
  ( always {!<=-1,!>=2}
Line 5980
  vt1 always !0
  . always !0
  & {lifetime[Address]=(item),!0}
Line 5981
  == always {!<=-1,!>=2}
  0 always 0
Line 5982
  vt1 always !0
Line 5983
  ( always {!<=-1,!>=2}
  vt1 always !0
  . always !0
Line 5984
  1 always 1
Line 5986
  = always 1
  :: always 1
  LValue always 1
Line 5987
  2 always 2
Line 5991
  vt1 possible 0
  && always {!<=-1,!>=2}
  vt1 always !0
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  ". %name% (" always ". %name% ("
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  "->" always "->"
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
Line 5992
  vt1 always !0
  . always !0
Line 5993
  = possible 0
  scope always symbolic=(vt1->smartPointerType->classScope)
  ? possible 0
  scope {symbolic=(vt1->smartPointerType->classScope),!0}
  false always 0
  : always 0
  nullptr always 0
Line 5994
  f possible 0
Line 5995
  f always !0
Line 5998
  ( always {!<=-1,!>=2}
Line 6000
  vt1 always !0
Line 6001
  vt always symbolic=(*vt1)
  = always 0
  :: always 0
  None always 0
Line 6003
  mIsCpp always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  -3 always -3
  "%var% ; %var% =" always "%var% ; %var% ="
  && always {!<=-1,!>=2}
  -3 always -3
  == always {!<=-1,!>=2}
  -1 always -1
  || always {!<=-1,!>=2}
Line 6004
  ( always {!<=-1,!>=2}
  -1 always -1
  "%var% =" always "%var% ="
Line 6005
  -2 always -2
  == always {!<=-1,!>=2}
  ";" always ";"
  -3 always -3
  -1 always -1
Line 6006
  = always 0
  nullptr always 0
Line 6007
  ( always {!<=-1,!>=2}
  -2 always -2
  ";|{|}|(|const|constexpr auto" always ";|{|}|(|const|constexpr auto"
Line 6009
  ( always {!<=-1,!>=2}
  -3 always -3
  ";|{|}|(|const|constexpr auto *|&|&&" always ";|{|}|(|const|constexpr auto *|&|&&"
Line 6010
  -2 always -2
Line 6011
  autoTok possible symbolic=(var1Tok->previous())
Line 6013
  1 always 1
Line 6014
  1 always 1
Line 6015
  autoTok always !0
  1 always 1
  == always {!<=-1,!>=2}
  "*" always "*"
  && always {!<=-1,!>=2}
Line 6017
  ( always {!<=-1,!>=2}
  autoTok always !0
  -1 always -1
  "const|constexpr" always "const|constexpr"
Line 6018
  1 always 1
Line 6019
  autoTok always !0
Line 6020
  autoTok always !0
Line 6021
  > always {!<=-1,!>=2}
Line 6023
  var1Tok possible symbolic=(parent->previous())
Line 6024
  != always {!<=-1,!>=2}
Line 6025
  ( always !symbolic=(var1Tok)
Line 6026
  ( possible symbolic=(var1Tok)
Line 6027
  var {symbolic=(const_cast<Variable*>(parent->previous()->variable())),0}
Line 6029
  == always {!<=-1,!>=2}
  0 always 0
  && always {!<=-1,!>=2}
  autoTok always !0
  1 always 1
  == always {!<=-1,!>=2}
  "*" always "*"
Line 6030
  = always 1
  1 always 1
Line 6031
  1 always 1
  != always {!<=-1,!>=2}
  0 always 0
Line 6032
  1 always 1
Line 6033
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  autoTok always !0
  1 always 1
  "*|&" always "*|&"
Line 6035
  var {symbolic=(const_cast<Variable*>(parent->previous()->variable())),!0}
Line 6036
  && always {!<=-1,!>=2}
  . always !0
Line 6037
  var {symbolic=(const_cast<Variable*>(parent->previous()->variable())),!0}
  . always !0
  . always !0
Line 6038
  autoTok always !0
  == always {!<=-1,!>=2}
  0 always 0
Line 6039
  autoTok always !0
  . always !0
  . always !0
Line 6047
  == always {!<=-1,!>=2}
  "[" always "["
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  mIsCpp always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  > always {!<=-1,!>=2}
  0U always 0
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "[{,]" always "[{,]"
Line 6049
  op1 possible {symbolic=(parent->astOperand1()),symbolic=(op1->variable()->nameToken()),0}
  && always {!<=-1,!>=2}
  op1 {symbolic=(parent->astOperand1()),!0}
  == always {!<=-1,!>=2}
  "[" always "["
Line 6050
  op1 always !0
Line 6054
  ! always {!<=-1,!>=2}
  op1 possible {symbolic=(parent->astOperand1()),symbolic=(op1->variable()->nameToken()),0}
  && always {!<=-1,!>=2}
  op1 always !0
  && always {!<=-1,!>=2}
  op1 always !0
  ( always !0
  == always {!<=-1,!>=2}
  op1 always !0
Line 6055
  1U always 1
Line 6059
  ( always {!<=-1,!>=2}
  "%name% (" always "%name% ("
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  > always {!<=-1,!>=2}
  0U always 0
Line 6061
  1U always 1
Line 6066
  vt2 possible 0
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  "(" always "("
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  -3 always -3
  "std :: move (" always "std :: move ("
Line 6068
  vt always symbolic=(valuetype)
  = always 2
  :: always 2
  RValue always 2
Line 6072
  == always {!<=-1,!>=2}
  "*" always "*"
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  > always {!<=-1,!>=2}
  0U always 0
Line 6074
  1U always 1
Line 6079
  == always {!<=-1,!>=2}
  "*" always "*"
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 6
  ITERATOR always 6
  && always {!<=-1,!>=2}
Line 6082
  . always !0
  & {lifetime[Address]=(vt),!0}
Line 6083
  == always {!<=-1,!>=2}
  0 always 0
Line 6085
  = always 1
  :: always 1
  LValue always 1
Line 6091
  == always {!<=-1,!>=2}
  "*" always "*"
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 4
  SMART_POINTER always 4
  && always {!<=-1,!>=2}
Line 6094
  . always !0
  & {lifetime[Address]=(vt),!0}
Line 6095
  == always {!<=-1,!>=2}
  0 always 0
Line 6101
  == always {!<=-1,!>=2}
  "*" always "*"
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "[" always "["
  && always {!<=-1,!>=2}
  > always {!<=-1,!>=2}
  0U always 0
Line 6103
  op1 possible {symbolic=(parent->astOperand2()->astOperand1()),symbolic=(op1->variable()->nameToken()),0}
  && always {!<=-1,!>=2}
  op1 {symbolic=(parent->astOperand2()->astOperand1()),!0}
  == always {!<=-1,!>=2}
  "[" always "["
Line 6104
  op1 always !0
Line 6106
  op1 possible {symbolic=(parent->astOperand2()->astOperand1()),symbolic=(op1->variable()->nameToken()),0}
  && always {!<=-1,!>=2}
  op1 always !0
  && always {!<=-1,!>=2}
  op1 always !0
  ( always !0
  == always {!<=-1,!>=2}
  op1 always !0
Line 6111
  == always {!<=-1,!>=2}
  "&" always "&"
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
Line 6113
  = always 0
  :: always 0
  None always 0
Line 6114
  1U always 1
Line 6119
  ( possible size=2
  == {!<=-1,!>=2,0}
  "." always "."
  || always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  "::" always "::"
  && always {!<=-1,!>=2}
Line 6120
  && always {!<=-1,!>=2}
  ( always !0
  ( always {!<=-1,!>=2}
Line 6122
  ! always {!<=-1,!>=2}
  var always symbolic=(parent->astOperand2()->variable())
  && always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 6124
  vt1 always !0
Line 6125
  ! always {!<=-1,!>=2}
  typeScope always symbolic=(vt1->typeScope)
Line 6127
  = {lifetime[Iterator]=(typeScope->varlist),start=0}
  typeScope {symbolic=(vt1->typeScope),!0}
  ( {lifetime[Iterator]=(typeScope->varlist),start=0}
  it possible {lifetime[Iterator]=(typeScope->varlist),start=0}
  != always {!<=-1,!>=2}
  typeScope {symbolic=(vt1->typeScope),!0}
  ( {lifetime[Iterator]=(typeScope->varlist),end=0}
Line 6128
  it {lifetime[Iterator]=(typeScope->varlist),!symbolic=(typeScope->varlist.end()),!end=0}
  == always {!<=-1,!>=2}
  name always symbolic=(parent->astOperand2()->str())
Line 6129
  = {lifetime[Object]=(typeScope->varlist),!0}
  & {lifetime[Object]=(typeScope->varlist),!0}
  it {lifetime[Iterator]=(typeScope->varlist),!symbolic=(typeScope->varlist.end()),!end=0}
Line 6134
  var possible {lifetime[Object]=(typeScope->varlist),symbolic=(parent->astOperand2()->variable()),symbolic=(&*it)}
Line 6135
  var {lifetime[Object]=(typeScope->varlist),!0}
Line 6140
  && always {!<=-1,!>=2}
Line 6141
  == always {!<=-1,!>=2}
  ":" always ":"
  && always {!<=-1,!>=2}
Line 6142
  ( always {!<=-1,!>=2}
  "( const| auto *|&| %var% :" always "( const| auto *|&| %var% :"
  && always {!<=-1,!>=2}
Line 6143
  ! always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 6144
  ( always {!<=-1,!>=2}
  "for" always "for"
Line 6145
  isconst always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "const" always "const"
Line 6146
  isconst {!<=-1,!>=2,0}
  ? possible {2,1}
  2 always 2
  : always 1
  1 always 1
Line 6147
  vt2 always !0
Line 6148
  vt2 always !0
Line 6150
  = always 0
  0 always 0
Line 6153
  vt2 always !0
Line 6155
  ( always {!<=-1,!>=2}
  "&" always "&"
Line 6156
  = always 1
  :: always 1
  LValue always 1
Line 6157
  isconst always {!<=-1,!>=2}
Line 6158
  && always {!<=-1,!>=2}
  != always {!<=-1,!>=2}
  :: always 0
  None always 0
Line 6159
  2 always 2
Line 6161
  1 always 1
Line 6165
  var {symbolic=(const_cast<Variable*>(parent->previous()->variable())),0}
Line 6166
  var {symbolic=(const_cast<Variable*>(parent->previous()->variable())),!0}
Line 6167
  vt2 always !0
  && always {!<=-1,!>=2}
  vt2 always !0
  . always !0
Line 6168
  var {symbolic=(const_cast<Variable*>(parent->previous()->variable())),!0}
  vt2 always !0
  . always !0
  . always !0
Line 6169
  vt2 always !0
  . always !0
  . always !0
Line 6172
  vt2 always !0
Line 6175
  typeStart possible symbolic=(parent->astOperand2())
Line 6176
  typeStart {symbolic=(parent->astOperand2()),!0}
Line 6177
  typeStart always !0
  ( always !0
Line 6178
  typeStart always !0
  == always {!<=-1,!>=2}
  "(" always "("
  && always {!<=-1,!>=2}
  typeStart always !0
  && always {!<=-1,!>=2}
  typeStart always !0
  ( always !0
Line 6179
  typeStart always !0
  ( always !0
  ( always !0
Line 6186
  setType {!<=-1,!>=2,0}
  setType always {!<=-1,!>=2}
  = always 0
  false always 0
Line 6188
  = always 0
  nullptr always 0
Line 6189
  ! always {!<=-1,!>=2}
  vt2 always !0
  . always !0
  ( always {!<=-1,!>=2}
Line 6190
  setType always {!<=-1,!>=2}
  = always 1
  true always 1
Line 6191
  = always 3
  :: always 3
  RECORD always 3
Line 6192
  vt2 always !0
Line 6193
  ( always {!<=-1,!>=2}
  vt2 always !0
  . always !0
Line 6194
  = always !0
  vt2 always !0
  . always !0
Line 6195
  ( always {!<=-1,!>=2}
  smartPointerTypeTok possible symbolic=(vt2->containerTypeToken)
  "%name%|::" always "%name%|::"
Line 6197
  ( always {!<=-1,!>=2}
  smartPointerTypeTok possible symbolic=(vt2->containerTypeToken)
  "< %name% > >" always "< %name% > >"
  && always {!<=-1,!>=2}
Line 6198
  setType always {!<=-1,!>=2}
  = always 1
  true always 1
Line 6199
  = always !0
  ( always !0
Line 6200
  = {symbolic=(smartPointerTypeTok->next()->type()),!0}
  templateArgType {symbolic=(smartPointerTypeTok->next()->type()),!0}
Line 6201
  = always 2
  :: always 2
  NONSTD always 2
Line 6203
  vt2 always !0
  . always !0
  & {lifetime[Address]=(autovt),!0}
Line 6204
  setType always {!<=-1,!>=2}
  = always 1
  true always 1
Line 6205
  vt2 always !0
  . always !0
Line 6209
  setType {!<=-1,!>=2,1}
Line 6214
  isconst always {!<=-1,!>=2}
Line 6215
  1 always 1
Line 6218
  var {symbolic=(const_cast<Variable*>(parent->previous()->variable())),0}
Line 6219
  var {symbolic=(const_cast<Variable*>(parent->previous()->variable())),!0}
Line 6220
  && always {!<=-1,!>=2}
  templateArgType always !0
  && always {!<=-1,!>=2}
  templateArgType always !0
  . always !0
Line 6221
  templateArgType always !0
  . always !0
  . always !0
Line 6222
  var {symbolic=(const_cast<Variable*>(parent->previous()->variable())),!0}
  templateArgType always !0
  . always !0
  . always !0
Line 6229
  && always {!<=-1,!>=2}
  vt1 always !0
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  "[" always "["
Line 6231
  vt1 always !0
  . always !0
  & {lifetime[Address]=(vtParent),!0}
Line 6237
  mIsCpp always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "decltype (" always "decltype ("
Line 6238
  vt2 always !0
Line 6243
  mIsCpp always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  >= always {!<=-1,!>=2}
  :: always 3
  CPP17 always 3
  && always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  -2 always -2
  "auto %var% {" always "auto %var% {"
Line 6244
  -2 always -2
Line 6245
  vt2 always !0
Line 6248
  ( always !0
  ( always !0
  vt2 always !0
Line 6250
  "debug" always "debug"
  "Missing variable class for variable with varid" always "Missing variable class for variable with varid"
Line 6254
  ! always {!<=-1,!>=2}
Line 6256
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
Line 6259
  ternary always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  ":" always ":"
  && always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always !0
  == always {!<=-1,!>=2}
  "?" always "?"
Line 6260
  ternary {symbolic=(parent->str()==":"&&parent->astParent()&&parent->astParent()->str()=="?"),!<=-1,!>=2,0}
Line 6261
  && always {!<=-1,!>=2}
  vt1 always !0
  == always {!<=-1,!>=2}
  vt2 always !0
  && always {!<=-1,!>=2}
  vt1 always !0
  == always {!<=-1,!>=2}
  vt2 always !0
  && always {!<=-1,!>=2}
  vt1 always !0
  == always {!<=-1,!>=2}
Line 6262
  vt2 always !0
Line 6266
  ternary {symbolic=(parent->str()==":"&&parent->astParent()&&parent->astParent()->str()=="?"),!<=-1,!>=2,0,1}
  || always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 16
  eIncDecOp always 16
Line 6269
  == always {!<=-1,!>=2}
  "+" always "+"
  && always {!<=-1,!>=2}
  vt1 always !0
  == always {!<=-1,!>=2}
  :: always 5
  CONTAINER always 5
  && always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  vt2 always !0
  ( always {!<=-1,!>=2}
Line 6270
  vt1 always !0
Line 6274
  == always {!<=-1,!>=2}
  "+" always "+"
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  vt2 always !0
  == always {!<=-1,!>=2}
  :: always 5
  CONTAINER always 5
Line 6275
  vt2 always !0
Line 6279
  . possible 0
  != {!<=-1,!>=2,0}
  0U always 0
  && always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  vt2 always !0
  == always {!<=-1,!>=2}
  0U always 0
Line 6284
  . possible 0
  == {!<=-1,!>=2,1}
  0U always 0
  && always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  vt2 always !0
  != always {!<=-1,!>=2}
  0U always 0
Line 6285
  vt2 always !0
Line 6289
  != always {!<=-1,!>=2}
  0U always 0
Line 6290
  ternary always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 16
  eIncDecOp always 16
Line 6293
  :: always 1
  SIGNED always 1
  :: always 12
  INT always 12
  0U always 0
  0U always 0
  "ptrdiff_t" always "ptrdiff_t"
Line 6297
  . possible {17,16,6,5}
  == {!<=-1,!>=2,0}
  :: always 18
  LONGDOUBLE always 18
  || always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  vt2 always !0
  == always {!<=-1,!>=2}
  :: always 18
  LONGDOUBLE always 18
Line 6298
  :: always 0
  UNKNOWN_SIGN always 0
  :: always 18
  LONGDOUBLE always 18
  0U always 0
Line 6301
  . {16,6,5,!18}
  == {!<=-1,!>=2,0}
  :: always 17
  DOUBLE always 17
  || always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  vt2 always !0
  == always {!<=-1,!>=2}
  :: always 17
  DOUBLE always 17
Line 6302
  :: always 0
  UNKNOWN_SIGN always 0
  :: always 17
  DOUBLE always 17
  0U always 0
Line 6305
  . {6,5,!18,!17}
  == {!<=-1,!>=2,0}
  :: always 16
  FLOAT always 16
  || always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  vt2 always !0
  == always {!<=-1,!>=2}
  :: always 16
  FLOAT always 16
Line 6306
  :: always 0
  UNKNOWN_SIGN always 0
  :: always 16
  FLOAT always 16
  0U always 0
Line 6311
  . {5,!17,!16}
  == {!<=-1,!>=2,0}
  :: always 6
  ITERATOR always 6
  && always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  vt2 always !0
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 6312
  == always {!<=-1,!>=2}
  "+" always "+"
  || always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  "-" always "-"
Line 6317
  == always {!<=-1,!>=2}
  "+" always "+"
  && always {!<=-1,!>=2}
  . always !16
  == always {!<=-1,!>=2}
  :: always 5
  CONTAINER always 5
  && always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  vt2 always !0
  == always {!<=-1,!>=2}
  :: always 5
  CONTAINER always 5
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  vt2 always !0
Line 6323
  vt1 always !0
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  vt1 always !0
  == always {!<=-1,!>=2}
  0U always 0
  && always {!<=-1,!>=2}
Line 6324
  ! always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  vt2 always !0
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  vt2 always !0
  == always {!<=-1,!>=2}
  0U always 0
  && always {!<=-1,!>=2}
Line 6325
  ternary always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 15
  eBitOp always 15
  || always {!<=-1,!>=2}
  ( always !15
  == always {!<=-1,!>=2}
  :: always 16
  eIncDecOp always 16
  || always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 6328
  ! always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  vt1 always !0
  > always {!<=-1,!>=2}
  vt2 always !0
Line 6329
  = possible >=symbolic=(vt2->type+1)
  vt1 always !0
  . possible >=symbolic=(vt2->type+1)
Line 6330
  vt1 always !0
Line 6331
  vt1 always !0
Line 6332
  vt1 always !0
  . {!>=symbolic=(vt2->type+1),<=symbolic=(vt2->type)}
  == always {!<=-1,!>=2}
  vt2 always !0
  . {!<=symbolic=(vt1->type-1),>=symbolic=(vt1->type)}
Line 6333
  = always {symbolic=(vt1->type),symbolic=(vt2->type)}
  vt1 always !0
  . always {symbolic=(vt1->type),symbolic=(vt2->type)}
Line 6334
  vt1 always !0
  . possible 0
  == {!<=-1,!>=2,0}
  :: always 2
  UNSIGNED always 2
  || always {!<=-1,!>=2}
  vt2 always !0
  == always {!<=-1,!>=2}
  :: always 2
  UNSIGNED always 2
Line 6335
  = always 2
  :: always 2
  UNSIGNED always 2
Line 6336
  vt1 always !0
  . always !2
  == always {!<=-1,!>=2}
  :: always 0
  UNKNOWN_SIGN always 0
  || always {!<=-1,!>=2}
  vt2 always !0
  . always !2
  == always {!<=-1,!>=2}
  :: always 0
  UNKNOWN_SIGN always 0
Line 6337
  = always 0
  :: always 0
  UNKNOWN_SIGN always 0
Line 6339
  = always 1
  :: always 1
  SIGNED always 1
Line 6340
  vt1 always !0
  ( always {!<=-1,!>=2}
  vt2 always !0
  : always 1
  vt1 always !0
Line 6342
  = always !<=symbolic=(vt1->type)
  vt2 always !0
  . always !<=symbolic=(vt1->type)
Line 6343
  vt2 always !0
Line 6344
  vt2 always !0
Line 6346
  . possible 8
  < {!<=-1,!>=2,1}
  :: always 12
  INT always 12
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ternary always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  . always !>=12
  == always {!<=-1,!>=2}
  :: always 8
  BOOL always 8
Line 6347
  = always 12
  :: always 12
  INT always 12
Line 6348
  = always 1
  :: always 1
  SIGNED always 1
Line 6360
  pointer0 always !<=-1
  = always !<=-1
  valuetype possible {lifetime[Address]=(vt)@41,lifetime[Address]=(vt)@68,lifetime[Address]=(valuetype)@96,lifetime[Address]=(valuetype)@104,lifetime[Address]=(valuetype)@108,lifetime[Address]=(valuetype)@117,lifetime[Address]=(vt)@124,lifetime[Address]=(valuetype)@166,lifetime[Address]=(vt)@174,lifetime[Address]=(vt)@178}
Line 6361
  ( always {!<=-1,!>=2}
  type possible symbolic=(previousType)
  "%name%" always "%name%"
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  type possible symbolic=(previousType)
  ':' always 58
Line 6363
  valuetype possible {lifetime[Address]=(vt)@41,lifetime[Address]=(vt)@68,lifetime[Address]=(valuetype)@96,lifetime[Address]=(valuetype)@104,lifetime[Address]=(valuetype)@108,lifetime[Address]=(valuetype)@117,lifetime[Address]=(vt)@124,lifetime[Address]=(valuetype)@166,lifetime[Address]=(vt)@174,lifetime[Address]=(vt)@178}
  = always 0
  :: always 0
  UNKNOWN_SIGN always 0
Line 6364
  ! always {!<=-1,!>=2}
  valuetype possible {lifetime[Address]=(vt)@41,lifetime[Address]=(vt)@68,lifetime[Address]=(valuetype)@96,lifetime[Address]=(valuetype)@104,lifetime[Address]=(valuetype)@108,lifetime[Address]=(valuetype)@117,lifetime[Address]=(vt)@124,lifetime[Address]=(valuetype)@166,lifetime[Address]=(vt)@174,lifetime[Address]=(vt)@178}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  valuetype possible {lifetime[Address]=(vt)@41,lifetime[Address]=(vt)@68,lifetime[Address]=(valuetype)@96,lifetime[Address]=(valuetype)@104,lifetime[Address]=(valuetype)@108,lifetime[Address]=(valuetype)@117,lifetime[Address]=(vt)@124,lifetime[Address]=(valuetype)@166,lifetime[Address]=(vt)@174,lifetime[Address]=(vt)@178}
Line 6365
  valuetype possible {lifetime[Address]=(vt)@41,lifetime[Address]=(vt)@68,lifetime[Address]=(valuetype)@96,lifetime[Address]=(valuetype)@104,lifetime[Address]=(valuetype)@108,lifetime[Address]=(valuetype)@117,lifetime[Address]=(vt)@124,lifetime[Address]=(valuetype)@166,lifetime[Address]=(vt)@174,lifetime[Address]=(vt)@178}
  = always 0
  :: always 0
  UNKNOWN_TYPE always 0
Line 6366
  valuetype possible {lifetime[Address]=(vt)@41,lifetime[Address]=(vt)@68,lifetime[Address]=(valuetype)@96,lifetime[Address]=(valuetype)@104,lifetime[Address]=(valuetype)@108,lifetime[Address]=(valuetype)@117,lifetime[Address]=(vt)@124,lifetime[Address]=(valuetype)@166,lifetime[Address]=(vt)@174,lifetime[Address]=(vt)@178}
Line 6367
  valuetype possible {lifetime[Address]=(vt)@41,lifetime[Address]=(vt)@68,lifetime[Address]=(valuetype)@96,lifetime[Address]=(valuetype)@104,lifetime[Address]=(valuetype)@108,lifetime[Address]=(valuetype)@117,lifetime[Address]=(vt)@124,lifetime[Address]=(valuetype)@166,lifetime[Address]=(vt)@174,lifetime[Address]=(vt)@178}
  = always 4
  :: always 4
  SMART_POINTER always 4
Line 6368
  valuetype possible {lifetime[Address]=(vt)@41,lifetime[Address]=(vt)@68,lifetime[Address]=(valuetype)@96,lifetime[Address]=(valuetype)@104,lifetime[Address]=(valuetype)@108,lifetime[Address]=(valuetype)@117,lifetime[Address]=(vt)@124,lifetime[Address]=(valuetype)@166,lifetime[Address]=(vt)@174,lifetime[Address]=(vt)@178}
  == always {!<=-1,!>=2}
  :: always 16
  eEnum always 16
Line 6369
  valuetype possible {lifetime[Address]=(vt)@41,lifetime[Address]=(vt)@68,lifetime[Address]=(valuetype)@96,lifetime[Address]=(valuetype)@104,lifetime[Address]=(valuetype)@108,lifetime[Address]=(valuetype)@117,lifetime[Address]=(vt)@124,lifetime[Address]=(valuetype)@166,lifetime[Address]=(vt)@174,lifetime[Address]=(vt)@178}
Line 6370
  enum_type always symbolic=(valuetype->typeScope->enumType)
Line 6371
  enum_type {symbolic=(valuetype->typeScope->enumType),!0}
  ( always {!<=-1,!>=2}
Line 6372
  valuetype possible {lifetime[Address]=(vt)@41,lifetime[Address]=(vt)@68,lifetime[Address]=(valuetype)@96,lifetime[Address]=(valuetype)@104,lifetime[Address]=(valuetype)@108,lifetime[Address]=(valuetype)@117,lifetime[Address]=(vt)@124,lifetime[Address]=(valuetype)@166,lifetime[Address]=(vt)@174,lifetime[Address]=(vt)@178}
  = always 1
  :: always 1
  SIGNED always 1
Line 6373
  enum_type {symbolic=(valuetype->typeScope->enumType),!0}
  ( always {!<=-1,!>=2}
Line 6374
  valuetype possible {lifetime[Address]=(vt)@41,lifetime[Address]=(vt)@68,lifetime[Address]=(valuetype)@96,lifetime[Address]=(valuetype)@104,lifetime[Address]=(valuetype)@108,lifetime[Address]=(valuetype)@117,lifetime[Address]=(vt)@124,lifetime[Address]=(valuetype)@166,lifetime[Address]=(vt)@174,lifetime[Address]=(vt)@178}
  = always 2
  :: always 2
  UNSIGNED always 2
Line 6376
  valuetype possible {lifetime[Address]=(vt)@41,lifetime[Address]=(vt)@68,lifetime[Address]=(valuetype)@96,lifetime[Address]=(valuetype)@104,lifetime[Address]=(valuetype)@108,lifetime[Address]=(valuetype)@117,lifetime[Address]=(vt)@124,lifetime[Address]=(valuetype)@166,lifetime[Address]=(vt)@174,lifetime[Address]=(vt)@178}
Line 6377
  enum_type always !0
  enum_type always !0
  ( always {!<=-1,!>=2}
Line 6378
  != always {!<=-1,!>=2}
  :: always 0
  UNKNOWN_TYPE always 0
Line 6379
  valuetype possible {lifetime[Address]=(vt)@41,lifetime[Address]=(vt)@68,lifetime[Address]=(valuetype)@96,lifetime[Address]=(valuetype)@104,lifetime[Address]=(valuetype)@108,lifetime[Address]=(valuetype)@117,lifetime[Address]=(vt)@124,lifetime[Address]=(valuetype)@166,lifetime[Address]=(vt)@174,lifetime[Address]=(vt)@178}
  = always !0
  t always !0
Line 6380
  enum_type always !0
  ( always {!<=-1,!>=2}
Line 6381
  valuetype possible {lifetime[Address]=(vt)@41,lifetime[Address]=(vt)@68,lifetime[Address]=(valuetype)@96,lifetime[Address]=(valuetype)@104,lifetime[Address]=(valuetype)@108,lifetime[Address]=(valuetype)@117,lifetime[Address]=(vt)@124,lifetime[Address]=(valuetype)@166,lifetime[Address]=(vt)@174,lifetime[Address]=(vt)@178}
  ( always {!<=-1,!>=2}
  enum_type always !0
Line 6383
  valuetype possible {lifetime[Address]=(vt)@41,lifetime[Address]=(vt)@68,lifetime[Address]=(valuetype)@96,lifetime[Address]=(valuetype)@104,lifetime[Address]=(valuetype)@108,lifetime[Address]=(valuetype)@117,lifetime[Address]=(vt)@124,lifetime[Address]=(valuetype)@166,lifetime[Address]=(vt)@174,lifetime[Address]=(vt)@178}
  = always 12
  :: always 12
  INT always 12
Line 6385
  valuetype possible {lifetime[Address]=(vt)@41,lifetime[Address]=(vt)@68,lifetime[Address]=(valuetype)@96,lifetime[Address]=(valuetype)@104,lifetime[Address]=(valuetype)@108,lifetime[Address]=(valuetype)@117,lifetime[Address]=(vt)@124,lifetime[Address]=(valuetype)@166,lifetime[Address]=(vt)@174,lifetime[Address]=(vt)@178}
  = always 3
  :: always 3
  RECORD always 3
Line 6386
  par always {!<=-1,!>=2}
  par always {!<=-1,!>=2}
  = always 0
  false always 0
Line 6387
  ( always {!<=-1,!>=2}
  "%name%|*|&|&&|::|(" always "%name%|*|&|&&|::|("
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "typename|template" always "typename|template"
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  0 always 0
  && always {!<=-1,!>=2}
Line 6388
  ! always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
Line 6389
  isIterator always {!<=-1,!>=2}
  isIterator always {!<=-1,!>=2}
  = always 0
  false always 0
Line 6390
  == always {!<=-1,!>=2}
  "(" always "("
Line 6391
  ( always {!<=-1,!>=2}
  ") const| {" always ") const| {"
Line 6393
  par always {!<=-1,!>=2}
Line 6395
  par always {!<=-1,!>=2}
  = always 1
  true always 1
Line 6397
  ( always {!<=-1,!>=2}
  "decltype (" always "decltype ("
  && always {!<=-1,!>=2}
Line 6398
  = always !0
  ( always !0
Line 6399
  valuetype possible {lifetime[Address]=(vt)@41,lifetime[Address]=(vt)@68,lifetime[Address]=(valuetype)@96,lifetime[Address]=(valuetype)@104,lifetime[Address]=(valuetype)@108,lifetime[Address]=(valuetype)@117,lifetime[Address]=(vt)@124,lifetime[Address]=(valuetype)@166,lifetime[Address]=(vt)@174,lifetime[Address]=(vt)@178}
  == always {!<=-1,!>=2}
  :: always 0
  UNKNOWN_SIGN always 0
Line 6400
  valuetype possible {lifetime[Address]=(vt)@41,lifetime[Address]=(vt)@68,lifetime[Address]=(valuetype)@96,lifetime[Address]=(valuetype)@104,lifetime[Address]=(valuetype)@108,lifetime[Address]=(valuetype)@117,lifetime[Address]=(vt)@124,lifetime[Address]=(valuetype)@166,lifetime[Address]=(vt)@174,lifetime[Address]=(vt)@178}
  vt2 {symbolic=(type->next()->valueType()),!0}
Line 6401
  valuetype possible {lifetime[Address]=(vt)@41,lifetime[Address]=(vt)@68,lifetime[Address]=(valuetype)@96,lifetime[Address]=(valuetype)@104,lifetime[Address]=(valuetype)@108,lifetime[Address]=(valuetype)@117,lifetime[Address]=(vt)@124,lifetime[Address]=(valuetype)@166,lifetime[Address]=(vt)@174,lifetime[Address]=(vt)@178}
  == always {!<=-1,!>=2}
  :: always 0
  UNKNOWN_TYPE always 0
Line 6402
  valuetype possible {lifetime[Address]=(vt)@41,lifetime[Address]=(vt)@68,lifetime[Address]=(valuetype)@96,lifetime[Address]=(valuetype)@104,lifetime[Address]=(valuetype)@108,lifetime[Address]=(valuetype)@117,lifetime[Address]=(vt)@124,lifetime[Address]=(valuetype)@166,lifetime[Address]=(vt)@174,lifetime[Address]=(vt)@178}
  vt2 {symbolic=(type->next()->valueType()),!0}
Line 6403
  valuetype possible {lifetime[Address]=(vt)@41,lifetime[Address]=(vt)@68,lifetime[Address]=(valuetype)@96,lifetime[Address]=(valuetype)@104,lifetime[Address]=(valuetype)@108,lifetime[Address]=(valuetype)@117,lifetime[Address]=(vt)@124,lifetime[Address]=(valuetype)@166,lifetime[Address]=(vt)@174,lifetime[Address]=(vt)@178}
  vt2 {symbolic=(type->next()->valueType()),!0}
Line 6404
  valuetype possible {lifetime[Address]=(vt)@41,lifetime[Address]=(vt)@68,lifetime[Address]=(valuetype)@96,lifetime[Address]=(valuetype)@104,lifetime[Address]=(valuetype)@108,lifetime[Address]=(valuetype)@117,lifetime[Address]=(vt)@124,lifetime[Address]=(valuetype)@166,lifetime[Address]=(vt)@174,lifetime[Address]=(vt)@178}
  vt2 {symbolic=(type->next()->valueType()),!0}
Line 6405
  valuetype possible {lifetime[Address]=(vt)@41,lifetime[Address]=(vt)@68,lifetime[Address]=(valuetype)@96,lifetime[Address]=(valuetype)@104,lifetime[Address]=(valuetype)@108,lifetime[Address]=(valuetype)@117,lifetime[Address]=(vt)@124,lifetime[Address]=(valuetype)@166,lifetime[Address]=(vt)@174,lifetime[Address]=(vt)@178}
  vt2 {symbolic=(type->next()->valueType()),!0}
Line 6406
  1 always 1
Line 6408
  ( always {!<=-1,!>=2}
Line 6409
  valuetype possible {lifetime[Address]=(vt)@41,lifetime[Address]=(vt)@68,lifetime[Address]=(valuetype)@96,lifetime[Address]=(valuetype)@104,lifetime[Address]=(valuetype)@108,lifetime[Address]=(valuetype)@117,lifetime[Address]=(vt)@124,lifetime[Address]=(valuetype)@166,lifetime[Address]=(vt)@174,lifetime[Address]=(vt)@178}
  = always 1
  :: always 1
  SIGNED always 1
Line 6410
  ( always {!<=-1,!>=2}
Line 6411
  valuetype possible {lifetime[Address]=(vt)@41,lifetime[Address]=(vt)@68,lifetime[Address]=(valuetype)@96,lifetime[Address]=(valuetype)@104,lifetime[Address]=(valuetype)@108,lifetime[Address]=(valuetype)@117,lifetime[Address]=(vt)@124,lifetime[Address]=(valuetype)@166,lifetime[Address]=(vt)@174,lifetime[Address]=(vt)@178}
  = always 2
  :: always 2
  UNSIGNED always 2
Line 6412
  valuetype possible {lifetime[Address]=(vt)@41,lifetime[Address]=(vt)@68,lifetime[Address]=(valuetype)@96,lifetime[Address]=(valuetype)@104,lifetime[Address]=(valuetype)@108,lifetime[Address]=(valuetype)@117,lifetime[Address]=(vt)@124,lifetime[Address]=(valuetype)@166,lifetime[Address]=(vt)@174,lifetime[Address]=(vt)@178}
  . possible 13
  == {!<=-1,!>=2,0}
  :: always 0
  UNKNOWN_TYPE always 0
  && always {!<=-1,!>=2}
Line 6413
  && always {!<=-1,!>=2}
  ( always !0
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always !0
  && always {!<=-1,!>=2}
Line 6414
  . always !0
  != always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  . always !0
  != always {!<=-1,!>=2}
Line 6415
  ( always !0
  . always {!symbolic=(previousType),!0}
  valuetype possible {lifetime[Address]=(vt)@41,lifetime[Address]=(vt)@68,lifetime[Address]=(valuetype)@96,lifetime[Address]=(valuetype)@104,lifetime[Address]=(valuetype)@108,lifetime[Address]=(valuetype)@117,lifetime[Address]=(vt)@124,lifetime[Address]=(valuetype)@166,lifetime[Address]=(vt)@174,lifetime[Address]=(vt)@178}
Line 6416
  ( always {!<=-1,!>=2}
  "const|constexpr" always "const|constexpr"
Line 6417
  valuetype possible {lifetime[Address]=(vt)@41,lifetime[Address]=(vt)@68,lifetime[Address]=(valuetype)@96,lifetime[Address]=(valuetype)@104,lifetime[Address]=(valuetype)@108,lifetime[Address]=(valuetype)@117,lifetime[Address]=(vt)@124,lifetime[Address]=(valuetype)@166,lifetime[Address]=(vt)@174,lifetime[Address]=(vt)@178}
  1 always 1
  valuetype possible {lifetime[Address]=(vt)@41,lifetime[Address]=(vt)@68,lifetime[Address]=(valuetype)@96,lifetime[Address]=(valuetype)@104,lifetime[Address]=(valuetype)@108,lifetime[Address]=(valuetype)@117,lifetime[Address]=(vt)@124,lifetime[Address]=(valuetype)@166,lifetime[Address]=(vt)@174,lifetime[Address]=(vt)@178}
  - always !<=-1
  pointer0 always !<=-1
Line 6418
  . always {!<=-1,!>=2}
  clang always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always !<=-1
  > always {!<=-1,!>=2}
  2 always 2
  && always {!<=-1,!>=2}
  ( {>=size=3,!<=size=2}
  ( always !<=-1
  "::" always "::"
  < always {!<=-1,!>=2}
  ( {>=size=3,!<=size=2}
  ( always !<=-1
  "<" always "<"
Line 6420
  :: always !<=-1
  pos1 always !<=-1
  pos1 always !<=-1
  = always 0
  0 always 0
Line 6422
  :: {symbolic=(pos1-2),!<=-1}
  pos2 {symbolic=(pos1-2),!<=-1}
  pos2 always !<=-1
  = always !<=-1
  ( possible >=size=3
  ( always !<=-1
  "::" always "::"
  pos1 {symbolic=(pos2+2),!<=-1,0}
Line 6423
  pos2 always !<=-1
  == always {!<=-1,!>=2}
Line 6424
  pos1 always !<=-1
  0 always 0
  0 always 0
  0 always 0
  false always 0
Line 6427
  pos1 {!<=-1,0}
  pos2 always !<=-1
  - always !<=-1
  pos1 {!<=-1,0}
  0 always 0
  0 always 0
  0 always 0
  false always 0
Line 6428
  "::" always "::"
  0 always 0
  0 always 0
  0 always 0
  false always 0
Line 6429
  pos1 always !<=-1
  = always !<=1
  pos2 always !<=-1
  + always !<=1
  2 always 2
Line 6430
  pos1 {!<=-1,0}
  < {!<=-1,!>=2,>=1}
  ( {>=3,!<=2}
Line 6432
  & {lifetime[Address]=(isIterator),!0}
  isIterator always 0
Line 6434
  isIterator always {!<=-1,!>=2}
Line 6435
  = always 6
  :: always 6
  ITERATOR always 6
Line 6437
  = always 5
  :: always 5
  CONTAINER always 5
Line 6438
  = always !0
  container always !0
Line 6441
  scope always symbolic=(type->scope())
  scope always symbolic=(type->scope())
Line 6443
  scope always symbolic=(type->scope())
  == always {!<=-1,!>=2}
  :: always 1
  eClass always 1
  :: always 3
  RECORD always 3
  : always 2
  :: always 2
  NONSTD always 2
Line 6445
  & {lifetime[Address]=(isIterator),!0}
  isIterator always 0
Line 6446
  isIterator always {!<=-1,!>=2}
Line 6447
  valuetype possible {lifetime[Address]=(vt)@41,lifetime[Address]=(vt)@68,lifetime[Address]=(valuetype)@96,lifetime[Address]=(valuetype)@104,lifetime[Address]=(valuetype)@108,lifetime[Address]=(valuetype)@117,lifetime[Address]=(vt)@124,lifetime[Address]=(valuetype)@166,lifetime[Address]=(vt)@174,lifetime[Address]=(vt)@178}
  = always 6
  :: always 6
  ITERATOR always 6
Line 6449
  valuetype possible {lifetime[Address]=(vt)@41,lifetime[Address]=(vt)@68,lifetime[Address]=(valuetype)@96,lifetime[Address]=(valuetype)@104,lifetime[Address]=(valuetype)@108,lifetime[Address]=(valuetype)@117,lifetime[Address]=(vt)@124,lifetime[Address]=(valuetype)@166,lifetime[Address]=(vt)@174,lifetime[Address]=(vt)@178}
  = always 5
  :: always 5
  CONTAINER always 5
Line 6450
  valuetype possible {lifetime[Address]=(vt)@41,lifetime[Address]=(vt)@68,lifetime[Address]=(valuetype)@96,lifetime[Address]=(valuetype)@104,lifetime[Address]=(valuetype)@108,lifetime[Address]=(valuetype)@117,lifetime[Address]=(vt)@124,lifetime[Address]=(valuetype)@166,lifetime[Address]=(vt)@174,lifetime[Address]=(vt)@178}
  = always !0
  container always !0
Line 6451
  ( always {!<=-1,!>=2}
  type possible 0
  "%type%|::|<" always "%type%|::|<"
  && always {!<=-1,!>=2}
  != always {!<=-1,!>=2}
  "const" always "const"
Line 6452
  == always {!<=-1,!>=2}
  "<" always "<"
  && always {!<=-1,!>=2}
Line 6453
  container always !0
  >= always {!<=-1,!>=2}
  0 always 0
Line 6455
  = always 0
  0 always 0
  templateType possible symbolic=(type->next())
  && always {!<=-1,!>=2}
  j possible 0
  < always {!<=-1,!>=2}
  container always !0
  . always !<=-1
Line 6457
  valuetype possible {lifetime[Address]=(vt)@41,lifetime[Address]=(vt)@68,lifetime[Address]=(valuetype)@96,lifetime[Address]=(valuetype)@104,lifetime[Address]=(valuetype)@108,lifetime[Address]=(valuetype)@117,lifetime[Address]=(vt)@124,lifetime[Address]=(valuetype)@166,lifetime[Address]=(vt)@174,lifetime[Address]=(vt)@178}
  = possible symbolic=(type->next())
  templateType possible symbolic=(type->next())
Line 6459
  = always !0
  ( always !0
Line 6463
  && always {!<=-1,!>=2}
  type always !0
  == always {!<=-1,!>=2}
  "(" always "("
  && always {!<=-1,!>=2}
  type always !0
Line 6465
  type always !0
Line 6468
  "<" always "<"
Line 6469
  ! always {!<=-1,!>=2}
  argTok always symbolic=(Token::findsimplematch(type,"<"))
Line 6471
  valuetype possible {lifetime[Address]=(vt)@41,lifetime[Address]=(vt)@68,lifetime[Address]=(valuetype)@96,lifetime[Address]=(valuetype)@104,lifetime[Address]=(valuetype)@108,lifetime[Address]=(valuetype)@117,lifetime[Address]=(vt)@124,lifetime[Address]=(valuetype)@166,lifetime[Address]=(vt)@174,lifetime[Address]=(vt)@178}
  = always !0
  smartPointer always !0
Line 6472
  valuetype possible {lifetime[Address]=(vt)@41,lifetime[Address]=(vt)@68,lifetime[Address]=(valuetype)@96,lifetime[Address]=(valuetype)@104,lifetime[Address]=(valuetype)@108,lifetime[Address]=(valuetype)@117,lifetime[Address]=(vt)@124,lifetime[Address]=(valuetype)@166,lifetime[Address]=(vt)@174,lifetime[Address]=(vt)@178}
  argTok {symbolic=(Token::findsimplematch(type,"<")),!0}
Line 6473
  valuetype possible {lifetime[Address]=(vt)@41,lifetime[Address]=(vt)@68,lifetime[Address]=(valuetype)@96,lifetime[Address]=(valuetype)@104,lifetime[Address]=(valuetype)@108,lifetime[Address]=(valuetype)@117,lifetime[Address]=(vt)@124,lifetime[Address]=(valuetype)@166,lifetime[Address]=(vt)@174,lifetime[Address]=(vt)@178}
  argTok {symbolic=(Token::findsimplematch(type,"<")),!0}
Line 6474
  valuetype possible {lifetime[Address]=(vt)@41,lifetime[Address]=(vt)@68,lifetime[Address]=(valuetype)@96,lifetime[Address]=(valuetype)@104,lifetime[Address]=(valuetype)@108,lifetime[Address]=(valuetype)@117,lifetime[Address]=(vt)@124,lifetime[Address]=(valuetype)@166,lifetime[Address]=(vt)@174,lifetime[Address]=(vt)@178}
  = always 4
  :: always 4
  SMART_POINTER always 4
Line 6475
  argTok {symbolic=(Token::findsimplematch(type,"<")),!0}
Line 6476
  type always symbolic=(argTok->link())
Line 6477
  type {symbolic=(argTok->link()),!0}
Line 6479
  ( always {!<=-1,!>=2}
  "%name% :: %name%" always "%name% :: %name%"
Line 6482
  ( always {!<=-1,!>=2}
  end possible symbolic=(type)
  "%name% :: %name%" always "%name% :: %name%"
Line 6483
  "::" always "::"
Line 6484
  2 always 2
Line 6486
  end possible symbolic=(type)
Line 6487
  valuetype possible {lifetime[Address]=(vt)@41,lifetime[Address]=(vt)@68,lifetime[Address]=(valuetype)@96,lifetime[Address]=(valuetype)@104,lifetime[Address]=(valuetype)@108,lifetime[Address]=(valuetype)@117,lifetime[Address]=(vt)@124,lifetime[Address]=(valuetype)@166,lifetime[Address]=(vt)@174,lifetime[Address]=(vt)@178}
  ( always {!<=-1,!>=2}
Line 6489
  :: always 0
  UNKNOWN_TYPE always 0
  != always {!<=-1,!>=2}
  ( possible {size=4,size=6,size=1,size=2}
  ( always {!<=-1,!>=2}
Line 6490
  valuetype possible {lifetime[Address]=(vt)@41,lifetime[Address]=(vt)@68,lifetime[Address]=(valuetype)@96,lifetime[Address]=(valuetype)@104,lifetime[Address]=(valuetype)@108,lifetime[Address]=(valuetype)@117,lifetime[Address]=(vt)@124,lifetime[Address]=(valuetype)@166,lifetime[Address]=(vt)@174,lifetime[Address]=(vt)@178}
Line 6491
  valuetype possible {lifetime[Address]=(vt)@41,lifetime[Address]=(vt)@68,lifetime[Address]=(valuetype)@96,lifetime[Address]=(valuetype)@104,lifetime[Address]=(valuetype)@108,lifetime[Address]=(valuetype)@117,lifetime[Address]=(vt)@124,lifetime[Address]=(valuetype)@166,lifetime[Address]=(vt)@174,lifetime[Address]=(vt)@178}
  ( always {!<=-1,!>=2}
Line 6492
  == always {!<=-1,!>=2}
  :: always 13
  LONG always 13
Line 6493
  valuetype possible {lifetime[Address]=(vt)@41,lifetime[Address]=(vt)@68,lifetime[Address]=(valuetype)@96,lifetime[Address]=(valuetype)@104,lifetime[Address]=(valuetype)@108,lifetime[Address]=(valuetype)@117,lifetime[Address]=(vt)@124,lifetime[Address]=(valuetype)@166,lifetime[Address]=(vt)@174,lifetime[Address]=(vt)@178}
  . possible 17
  == {!<=-1,!>=2,0}
  :: always 13
  LONG always 13
Line 6494
  valuetype possible {lifetime[Address]=(vt)@41,lifetime[Address]=(vt)@68,lifetime[Address]=(valuetype)@96,lifetime[Address]=(valuetype)@104,lifetime[Address]=(valuetype)@108,lifetime[Address]=(valuetype)@117,lifetime[Address]=(vt)@124,lifetime[Address]=(valuetype)@166,lifetime[Address]=(vt)@174,lifetime[Address]=(vt)@178}
  = always 14
  :: always 14
  LONGLONG always 14
Line 6495
  valuetype possible {lifetime[Address]=(vt)@41,lifetime[Address]=(vt)@68,lifetime[Address]=(valuetype)@96,lifetime[Address]=(valuetype)@104,lifetime[Address]=(valuetype)@108,lifetime[Address]=(valuetype)@117,lifetime[Address]=(vt)@124,lifetime[Address]=(valuetype)@166,lifetime[Address]=(vt)@174,lifetime[Address]=(vt)@178}
  . always !13
  == always {!<=-1,!>=2}
  :: always 17
  DOUBLE always 17
Line 6496
  valuetype possible {lifetime[Address]=(vt)@41,lifetime[Address]=(vt)@68,lifetime[Address]=(valuetype)@96,lifetime[Address]=(valuetype)@104,lifetime[Address]=(valuetype)@108,lifetime[Address]=(valuetype)@117,lifetime[Address]=(vt)@124,lifetime[Address]=(valuetype)@166,lifetime[Address]=(vt)@174,lifetime[Address]=(vt)@178}
  = always 18
  :: always 18
  LONGDOUBLE always 18
Line 6498
  ( possible {size=6,size=4,size=1,size=2}
  == {!<=-1,!>=2,0}
  "auto" always "auto"
Line 6500
  ! always {!<=-1,!>=2}
  vt always symbolic=(type->valueType())
Line 6501
  nullptr always 0
Line 6502
  valuetype possible {lifetime[Address]=(vt)@41,lifetime[Address]=(vt)@68,lifetime[Address]=(valuetype)@96,lifetime[Address]=(valuetype)@104,lifetime[Address]=(valuetype)@108,lifetime[Address]=(valuetype)@117,lifetime[Address]=(vt)@124,lifetime[Address]=(valuetype)@166,lifetime[Address]=(vt)@174,lifetime[Address]=(vt)@178}
  vt {symbolic=(type->valueType()),!0}
Line 6503
  valuetype possible {lifetime[Address]=(vt)@41,lifetime[Address]=(vt)@68,lifetime[Address]=(valuetype)@96,lifetime[Address]=(valuetype)@104,lifetime[Address]=(valuetype)@108,lifetime[Address]=(valuetype)@117,lifetime[Address]=(vt)@124,lifetime[Address]=(valuetype)@166,lifetime[Address]=(vt)@174,lifetime[Address]=(vt)@178}
  vt {symbolic=(type->valueType()),!0}
Line 6504
  vt {symbolic=(type->valueType()),!0}
  != always {!<=-1,!>=2}
  :: always 0
  UNKNOWN_SIGN always 0
Line 6505
  = always !0
  vt {symbolic=(type->valueType()),!0}
  . always !0
Line 6506
  vt {symbolic=(type->valueType()),!0}
Line 6507
  vt {symbolic=(type->valueType()),!0}
Line 6508
  ( always {!<=-1,!>=2}
  "%name%|*|&|::" always "%name%|*|&|::"
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
Line 6509
  ( possible size=5
  == {!<=-1,!>=2,0}
  "*" always "*"
Line 6511
  ( possible size=1
  == {!<=-1,!>=2,0}
  "const" always "const"
Line 6512
  1 always 1
Line 6516
  ! {!<=-1,!>=2,1}
  valuetype possible {lifetime[Address]=(vt)@41,lifetime[Address]=(vt)@68,lifetime[Address]=(valuetype)@96,lifetime[Address]=(valuetype)@104,lifetime[Address]=(valuetype)@108,lifetime[Address]=(valuetype)@117,lifetime[Address]=(vt)@124,lifetime[Address]=(valuetype)@166,lifetime[Address]=(vt)@174,lifetime[Address]=(vt)@178}
  . possible 0
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  "struct" always "struct"
  || always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  "enum" always "enum"
Line 6517
  valuetype possible {lifetime[Address]=(vt)@41,lifetime[Address]=(vt)@68,lifetime[Address]=(valuetype)@96,lifetime[Address]=(valuetype)@104,lifetime[Address]=(valuetype)@108,lifetime[Address]=(valuetype)@117,lifetime[Address]=(vt)@124,lifetime[Address]=(valuetype)@166,lifetime[Address]=(vt)@174,lifetime[Address]=(vt)@178}
  == always {!<=-1,!>=2}
  "struct" always "struct"
  :: always 3
  RECORD always 3
  : always 2
  :: always 2
  NONSTD always 2
Line 6518
  ! always {!<=-1,!>=2}
  valuetype possible {lifetime[Address]=(vt)@41,lifetime[Address]=(vt)@68,lifetime[Address]=(valuetype)@96,lifetime[Address]=(valuetype)@104,lifetime[Address]=(valuetype)@108,lifetime[Address]=(valuetype)@117,lifetime[Address]=(vt)@124,lifetime[Address]=(valuetype)@166,lifetime[Address]=(vt)@174,lifetime[Address]=(vt)@178}
  && always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always !0
Line 6519
  ( always !0
  . always !0
  == always {!<=-1,!>=2}
  :: always 16
  eEnum always 16
Line 6520
  valuetype possible {lifetime[Address]=(vt)@41,lifetime[Address]=(vt)@68,lifetime[Address]=(valuetype)@96,lifetime[Address]=(valuetype)@104,lifetime[Address]=(valuetype)@108,lifetime[Address]=(valuetype)@117,lifetime[Address]=(vt)@124,lifetime[Address]=(valuetype)@166,lifetime[Address]=(vt)@174,lifetime[Address]=(vt)@178}
  = always 12
  :: always 12
  INT always 12
Line 6521
  valuetype possible {lifetime[Address]=(vt)@41,lifetime[Address]=(vt)@68,lifetime[Address]=(valuetype)@96,lifetime[Address]=(valuetype)@104,lifetime[Address]=(valuetype)@108,lifetime[Address]=(valuetype)@117,lifetime[Address]=(vt)@124,lifetime[Address]=(valuetype)@166,lifetime[Address]=(vt)@174,lifetime[Address]=(vt)@178}
  = always 1
  :: always 1
  SIGNED always 1
Line 6523
  valuetype possible {lifetime[Address]=(vt)@41,lifetime[Address]=(vt)@68,lifetime[Address]=(valuetype)@96,lifetime[Address]=(valuetype)@104,lifetime[Address]=(valuetype)@108,lifetime[Address]=(valuetype)@117,lifetime[Address]=(vt)@124,lifetime[Address]=(valuetype)@166,lifetime[Address]=(vt)@174,lifetime[Address]=(vt)@178}
  = always 3
  :: always 3
  RECORD always 3
Line 6525
  valuetype possible {lifetime[Address]=(vt)@41,lifetime[Address]=(vt)@68,lifetime[Address]=(valuetype)@96,lifetime[Address]=(valuetype)@104,lifetime[Address]=(valuetype)@108,lifetime[Address]=(valuetype)@117,lifetime[Address]=(vt)@124,lifetime[Address]=(valuetype)@166,lifetime[Address]=(vt)@174,lifetime[Address]=(vt)@178}
  = always !0
  ( always !0
  . always !0
Line 6526
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  valuetype possible {lifetime[Address]=(vt)@41,lifetime[Address]=(vt)@68,lifetime[Address]=(valuetype)@96,lifetime[Address]=(valuetype)@104,lifetime[Address]=(valuetype)@108,lifetime[Address]=(valuetype)@117,lifetime[Address]=(vt)@124,lifetime[Address]=(valuetype)@166,lifetime[Address]=(vt)@174,lifetime[Address]=(vt)@178}
  != always {!<=-1,!>=2}
  :: always 0
  UNKNOWN_SIGN always 0
  && always {!<=-1,!>=2}
  valuetype possible {lifetime[Address]=(vt)@41,lifetime[Address]=(vt)@68,lifetime[Address]=(valuetype)@96,lifetime[Address]=(valuetype)@104,lifetime[Address]=(valuetype)@108,lifetime[Address]=(valuetype)@117,lifetime[Address]=(vt)@124,lifetime[Address]=(valuetype)@166,lifetime[Address]=(vt)@174,lifetime[Address]=(vt)@178}
  == always {!<=-1,!>=2}
  0U always 0
Line 6527
  nullptr always 0
Line 6528
  ( possible {size=1,size=2}
  == {!<=-1,!>=2,0}
  "*" always "*"
Line 6529
  valuetype possible {lifetime[Address]=(vt)@41,lifetime[Address]=(vt)@68,lifetime[Address]=(valuetype)@96,lifetime[Address]=(valuetype)@104,lifetime[Address]=(valuetype)@108,lifetime[Address]=(valuetype)@117,lifetime[Address]=(vt)@124,lifetime[Address]=(valuetype)@166,lifetime[Address]=(vt)@174,lifetime[Address]=(vt)@178}
Line 6530
  ( possible size=2
  == {!<=-1,!>=2,0}
  "&" always "&"
Line 6531
  valuetype possible {lifetime[Address]=(vt)@41,lifetime[Address]=(vt)@68,lifetime[Address]=(valuetype)@96,lifetime[Address]=(valuetype)@104,lifetime[Address]=(valuetype)@108,lifetime[Address]=(valuetype)@117,lifetime[Address]=(vt)@124,lifetime[Address]=(valuetype)@166,lifetime[Address]=(vt)@174,lifetime[Address]=(vt)@178}
  = always 1
  :: always 1
  LValue always 1
Line 6532
  == always {!<=-1,!>=2}
  "&&" always "&&"
Line 6533
  valuetype possible {lifetime[Address]=(vt)@41,lifetime[Address]=(vt)@68,lifetime[Address]=(valuetype)@96,lifetime[Address]=(valuetype)@104,lifetime[Address]=(valuetype)@108,lifetime[Address]=(valuetype)@117,lifetime[Address]=(vt)@124,lifetime[Address]=(valuetype)@166,lifetime[Address]=(vt)@174,lifetime[Address]=(vt)@178}
  = always 2
  :: always 2
  RValue always 2
Line 6534
  ( always {!<=-1,!>=2}
Line 6535
  valuetype possible {lifetime[Address]=(vt)@41,lifetime[Address]=(vt)@68,lifetime[Address]=(valuetype)@96,lifetime[Address]=(valuetype)@104,lifetime[Address]=(valuetype)@108,lifetime[Address]=(valuetype)@117,lifetime[Address]=(vt)@124,lifetime[Address]=(valuetype)@166,lifetime[Address]=(vt)@174,lifetime[Address]=(vt)@178}
  ( always {!<=-1,!>=2}
Line 6536
  ( always {!<=-1,!>=2}
  "!!:: %name% !!::" always "!!:: %name% !!::"
Line 6537
  valuetype possible {lifetime[Address]=(vt)@41,lifetime[Address]=(vt)@68,lifetime[Address]=(valuetype)@96,lifetime[Address]=(valuetype)@104,lifetime[Address]=(valuetype)@108,lifetime[Address]=(valuetype)@117,lifetime[Address]=(vt)@124,lifetime[Address]=(valuetype)@166,lifetime[Address]=(vt)@174,lifetime[Address]=(vt)@178}
  ( always {!<=-1,!>=2}
Line 6538
  ! {!<=-1,!>=2,0}
  type possible symbolic=(end)
  ( possible size=0
  ( {!<=-1,!>=2,1}
Line 6539
  valuetype possible {lifetime[Address]=(vt)@41,lifetime[Address]=(vt)@68,lifetime[Address]=(valuetype)@96,lifetime[Address]=(valuetype)@104,lifetime[Address]=(valuetype)@108,lifetime[Address]=(valuetype)@117,lifetime[Address]=(vt)@124,lifetime[Address]=(valuetype)@166,lifetime[Address]=(vt)@174,lifetime[Address]=(vt)@178}
  = always !size=0
  ( always !size=0
Line 6544
  valuetype possible {lifetime[Address]=(vt)@41,lifetime[Address]=(vt)@68,lifetime[Address]=(valuetype)@96,lifetime[Address]=(valuetype)@104,lifetime[Address]=(valuetype)@108,lifetime[Address]=(valuetype)@117,lifetime[Address]=(vt)@124,lifetime[Address]=(valuetype)@166,lifetime[Address]=(vt)@174,lifetime[Address]=(vt)@178}
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  valuetype possible {lifetime[Address]=(vt)@41,lifetime[Address]=(vt)@68,lifetime[Address]=(valuetype)@96,lifetime[Address]=(valuetype)@104,lifetime[Address]=(valuetype)@108,lifetime[Address]=(valuetype)@117,lifetime[Address]=(vt)@124,lifetime[Address]=(valuetype)@166,lifetime[Address]=(vt)@174,lifetime[Address]=(vt)@178}
  == always {!<=-1,!>=2}
  :: always 0
  UNKNOWN_SIGN always 0
Line 6545
  valuetype possible {lifetime[Address]=(vt)@41,lifetime[Address]=(vt)@68,lifetime[Address]=(valuetype)@96,lifetime[Address]=(valuetype)@104,lifetime[Address]=(valuetype)@108,lifetime[Address]=(valuetype)@117,lifetime[Address]=(vt)@124,lifetime[Address]=(valuetype)@166,lifetime[Address]=(vt)@174,lifetime[Address]=(vt)@178}
  . possible {>=10,<=9}
  == {!<=-1,!>=2,>=0,<=1}
  :: always 9
  CHAR always 9
Line 6546
  valuetype possible {lifetime[Address]=(vt)@41,lifetime[Address]=(vt)@68,lifetime[Address]=(valuetype)@96,lifetime[Address]=(valuetype)@104,lifetime[Address]=(valuetype)@108,lifetime[Address]=(valuetype)@117,lifetime[Address]=(vt)@124,lifetime[Address]=(valuetype)@166,lifetime[Address]=(vt)@174,lifetime[Address]=(vt)@178}
Line 6547
  valuetype possible {lifetime[Address]=(vt)@41,lifetime[Address]=(vt)@68,lifetime[Address]=(valuetype)@96,lifetime[Address]=(valuetype)@104,lifetime[Address]=(valuetype)@108,lifetime[Address]=(valuetype)@117,lifetime[Address]=(vt)@124,lifetime[Address]=(valuetype)@166,lifetime[Address]=(vt)@174,lifetime[Address]=(vt)@178}
  . always !9
  >= always {!<=-1,!>=2}
  :: always 10
  SHORT always 10
Line 6548
  valuetype possible {lifetime[Address]=(vt)@41,lifetime[Address]=(vt)@68,lifetime[Address]=(valuetype)@96,lifetime[Address]=(valuetype)@104,lifetime[Address]=(valuetype)@108,lifetime[Address]=(valuetype)@117,lifetime[Address]=(vt)@124,lifetime[Address]=(valuetype)@166,lifetime[Address]=(vt)@174,lifetime[Address]=(vt)@178}
  = always 1
  :: always 1
  SIGNED always 1
Line 6551
  && always {!<=-1,!>=2}
  valuetype possible {lifetime[Address]=(vt)@41,lifetime[Address]=(vt)@68,lifetime[Address]=(valuetype)@96,lifetime[Address]=(valuetype)@104,lifetime[Address]=(valuetype)@108,lifetime[Address]=(valuetype)@117,lifetime[Address]=(vt)@124,lifetime[Address]=(valuetype)@166,lifetime[Address]=(vt)@174,lifetime[Address]=(vt)@178}
  != always {!<=-1,!>=2}
  :: always 0
  UNKNOWN_TYPE always 0
  || always {!<=-1,!>=2}
  valuetype possible {lifetime[Address]=(vt)@41,lifetime[Address]=(vt)@68,lifetime[Address]=(valuetype)@96,lifetime[Address]=(valuetype)@104,lifetime[Address]=(valuetype)@108,lifetime[Address]=(valuetype)@117,lifetime[Address]=(vt)@124,lifetime[Address]=(valuetype)@166,lifetime[Address]=(vt)@174,lifetime[Address]=(vt)@178}
  > always {!<=-1,!>=2}
  0 always 0
  || always {!<=-1,!>=2}
  valuetype possible {lifetime[Address]=(vt)@41,lifetime[Address]=(vt)@68,lifetime[Address]=(valuetype)@96,lifetime[Address]=(valuetype)@104,lifetime[Address]=(valuetype)@108,lifetime[Address]=(valuetype)@117,lifetime[Address]=(vt)@124,lifetime[Address]=(valuetype)@166,lifetime[Address]=(vt)@174,lifetime[Address]=(vt)@178}
  != always {!<=-1,!>=2}
  :: always 0
  None always 0
  type always !0
  nullptr always 0
Line 6556
  && always {!<=-1,!>=2}
  tok always !0
  && always {!<=-1,!>=2}
  tok always !0
  ( always !0
  && always {!<=-1,!>=2}
  ( always !0
  . always !0
  ( always {!<=-1,!>=2}
Line 6557
  tok always !0
  ( always !0
  . always !0
Line 6558
  nullptr always 0
Line 6563
  "operator" always "operator"
Line 6568
  = possible lifetime[Iterator]=(classScope->functionMap)
  classScope always !0
  ( possible lifetime[Iterator]=(classScope->functionMap)
Line 6569
  it {lifetime[Iterator]=(classScope->functionMap),symbolic=(classScope->functionMap.find(functionName)),symbolic=(classScope->functionMap.end()),end=0}
  != {!<=-1,!>=2,0}
  classScope always !0
  ( {lifetime[Iterator]=(classScope->functionMap),end=0}
Line 6570
  it {lifetime[Iterator]=(classScope->functionMap),symbolic=(classScope->functionMap.find(functionName)),!symbolic=(classScope->functionMap.end()),!end=0}
Line 6575
  = possible lifetime[Iterator]=(classScope->functionMap)
  classScope always !0
  ( possible lifetime[Iterator]=(classScope->functionMap)
Line 6576
  it {lifetime[Iterator]=(classScope->functionMap),symbolic=(classScope->functionMap.find(functionName)),symbolic=(classScope->functionMap.end()),end=0}
  != {!<=-1,!>=2,0}
  classScope always !0
  ( {lifetime[Iterator]=(classScope->functionMap),end=0}
Line 6577
  it {lifetime[Iterator]=(classScope->functionMap),symbolic=(classScope->functionMap.find(functionName)),!symbolic=(classScope->functionMap.end()),!end=0}
Line 6580
  nullptr always 0
Line 6583
  reportDebugWarnings always {!<=-1,!>=2}
Line 6585
  ! always {!<=-1,!>=2}
Line 6588
  = possible symbolic=(const_cast<Tokenizer*>(mTokenizer)->list.front())
  tokens possible symbolic=(const_cast<Tokenizer*>(mTokenizer)->list.front())
  tok possible symbolic=(const_cast<Tokenizer*>(mTokenizer)->list.front())
Line 6589
  nullptr always 0
Line 6592
  ( always {!<=-1,!>=2}
Line 6593
  ( always {!<=-1,!>=2}
Line 6594
  = always 17
  :: always 17
  DOUBLE always 17
Line 6595
  ( always !<=-1
  - always !<=-1
  1 always 1
Line 6596
  suffix {symbolic=(tok->str()[tok->str().size()-1]),70,76,108}
  == {!<=-1,!>=2,0}
  'f' always 102
  || always {!<=-1,!>=2}
  suffix {symbolic=(tok->str()[tok->str().size()-1]),76,108,!102}
  == {!<=-1,!>=2,0}
  'F' always 70
Line 6597
  = always 16
  :: always 16
  FLOAT always 16
Line 6598
  suffix {symbolic=(tok->str()[tok->str().size()-1]),108,!102,!70}
  == {!<=-1,!>=2,0}
  'L' always 76
  || always {!<=-1,!>=2}
  suffix {symbolic=(tok->str()[tok->str().size()-1]),!102,!70,!76}
  == always {!<=-1,!>=2}
  'l' always 108
Line 6599
  = always 18
  :: always 18
  LONGDOUBLE always 18
Line 6600
  :: always 0
  UNKNOWN_SIGN always 0
  type possible {16,18}
  0U always 0
Line 6601
  ( always {!<=-1,!>=2}
Line 6602
  = always !<=-1
  ( always !<=-1
Line 6603
  unsignedSuffix always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  tokStr {symbolic=(MathLib::abs(tok->str())),!<=-1}
  ( always !<=-1
  "uU" always "uU"
  != always {!<=-1,!>=2}
Line 6604
  = possible {2,1}
  unsignedSuffix always {!<=-1,!>=2}
  ? possible {2,1}
  :: always 2
  UNSIGNED always 2
  : always 1
  :: always 1
  SIGNED always 1
Line 6605
  = always 12
  :: always 12
  INT always 12
Line 6606
  value always !<=-1
  = always !<=-1
  ( always !<=-1
  tokStr {symbolic=(MathLib::abs(tok->str())),!<=-1}
Line 6607
  pos always !<=-1
  = always !<=-1
  tokStr {symbolic=(MathLib::abs(tok->str())),!<=-1}
  ( always !<=-1
  - always !<=-1
  1U always 1
  pos always !<=-1
  > always {!<=-1,!>=2}
  0U always 0
  -- always !<=-1
  pos always !<=-1
Line 6608
  tokStr {symbolic=(MathLib::abs(tok->str())),!<=-1}
  pos always !<=-1
Line 6609
  suffix {symbolic=(tokStr[pos]),85,108,76,52}
  == {!<=-1,!>=2,0}
  'u' always 117
  || always {!<=-1,!>=2}
  suffix {symbolic=(tokStr[pos]),108,76,52,!117}
  == {!<=-1,!>=2,0}
  'U' always 85
Line 6610
  = always 2
  :: always 2
  UNSIGNED always 2
Line 6611
  suffix {symbolic=(tokStr[pos]),76,52,!117,!85}
  == {!<=-1,!>=2,0}
  'l' always 108
  || always {!<=-1,!>=2}
  suffix {symbolic=(tokStr[pos]),52,!117,!85,!108}
  == {!<=-1,!>=2,0}
  'L' always 76
Line 6612
  = possible {13,14}
  == always {!<=-1,!>=2}
  :: always 12
  INT always 12
  ? possible {13,14}
  :: always 13
  LONG always 13
  : always 14
  :: always 14
  LONGLONG always 14
Line 6613
  pos always !<=-1
  > always {!<=-1,!>=2}
  2U always 2
  && always {!<=-1,!>=2}
  suffix {symbolic=(tokStr[pos]),!117,!85,!108,!76}
  == always {!<=-1,!>=2}
  '4' always 52
  && always {!<=-1,!>=2}
  tokStr {symbolic=(MathLib::abs(tok->str())),!<=-1}
  pos {>=3,!<=2}
  - {>=2,!<=1}
  1 always 1
  == always {!<=-1,!>=2}
  '6' always 54
  && always {!<=-1,!>=2}
  tokStr {symbolic=(MathLib::abs(tok->str())),!<=-1}
  pos always !<=-1
  - always !<=-1
  2 always 2
  == always {!<=-1,!>=2}
  'i' always 105
Line 6614
  = always 14
  :: always 14
  LONGLONG always 14
Line 6615
  pos {>=3,!<=2}
  -= always !<=-1
  2 always 2
Line 6618
  != always {!<=-1,!>=2}
  :: always 0
  Unspecified always 0
Line 6619
  type possible {<=12,>=13}
  <= {!<=-1,!>=2,<=1,>=0}
  :: always 12
  INT always 12
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  unsignedSuffix always {!<=-1,!>=2}
  ? {symbolic=(MathLib::toULongNumber(tokStr)),!<=-1}
  value {symbolic=(MathLib::toULongNumber(tokStr)),!<=-1}
  >> always !<=-1
  1 always 1
  : {symbolic=(MathLib::toULongNumber(tokStr)),!<=-1}
  value {symbolic=(MathLib::toULongNumber(tokStr)),!<=-1}
Line 6620
  = always 12
  :: always 12
  INT always 12
Line 6621
  type possible {<=13,>=14}
  <= {!<=-1,!>=2,<=0}
  :: always 12
  INT always 12
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  tokStr {symbolic=(MathLib::abs(tok->str())),!<=-1}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  value {symbolic=(MathLib::toULongNumber(tokStr)),!<=-1}
  >> always !<=-1
  2 always 2
Line 6622
  = always 12
  :: always 12
  INT always 12
Line 6623
  = always 2
  :: always 2
  UNSIGNED always 2
Line 6624
  type possible {<=13,>=14}
  <= {!<=-1,!>=2,<=1,>=0}
  :: always 13
  LONG always 13
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  unsignedSuffix always {!<=-1,!>=2}
  ? {symbolic=(MathLib::toULongNumber(tokStr)),!<=-1}
  value {symbolic=(MathLib::toULongNumber(tokStr)),!<=-1}
  >> always !<=-1
  1 always 1
  : {symbolic=(MathLib::toULongNumber(tokStr)),!<=-1}
  value {symbolic=(MathLib::toULongNumber(tokStr)),!<=-1}
Line 6625
  = always 13
  :: always 13
  LONG always 13
Line 6626
  type possible >=14
  <= {!<=-1,!>=2,>=0}
  :: always 13
  LONG always 13
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  tokStr {symbolic=(MathLib::abs(tok->str())),!<=-1}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  value {symbolic=(MathLib::toULongNumber(tokStr)),!<=-1}
  >> always !<=-1
  2 always 2
Line 6627
  = always 13
  :: always 13
  LONG always 13
Line 6628
  = always 2
  :: always 2
  UNSIGNED always 2
Line 6629
  ( always {!<=-1,!>=2}
  unsignedSuffix always {!<=-1,!>=2}
  ? {symbolic=(MathLib::toULongNumber(tokStr)),!<=-1}
  value {symbolic=(MathLib::toULongNumber(tokStr)),!<=-1}
  >> always !<=-1
  1 always 1
  : {symbolic=(MathLib::toULongNumber(tokStr)),!<=-1}
  value {symbolic=(MathLib::toULongNumber(tokStr)),!<=-1}
Line 6630
  = always 14
  :: always 14
  LONGLONG always 14
Line 6632
  = always 14
  :: always 14
  LONGLONG always 14
Line 6633
  = always 2
  :: always 2
  UNSIGNED always 2
Line 6637
  sign possible 2
  type possible {12,13,14}
  0U always 0
Line 6639
  ( {!<=-1,!>=2,0}
  || always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 14
  eLogicalOp always 14
Line 6640
  mIsCpp always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
Line 6642
  function always symbolic=(getOperatorFunction(tok))
Line 6644
  function {symbolic=(getOperatorFunction(tok)),!0}
  & {lifetime[Address]=(vt),!0}
Line 6649
  :: always 0
  UNKNOWN_SIGN always 0
  :: always 8
  BOOL always 8
  0U always 0
Line 6650
  ( always {!<=-1,!>=2}
Line 6651
  :: always 0
  UNKNOWN_SIGN always 0
  :: always 8
  BOOL always 8
  0U always 0
Line 6652
  ( {6,7,!14}
  == {!<=-1,!>=2,0,1}
  :: always 7
  eChar always 7
  || always {!<=-1,!>=2}
  ( always {!14,!7}
  == always {!<=-1,!>=2}
  :: always 6
  eString always 6
Line 6653
  = always !<=-1
  ( {7,!14,6}
  == {!<=-1,!>=2,1,0}
  :: always 7
  eChar always 7
  ? always !<=-1
  0U always 0
  : always 1
  1U always 1
Line 6654
  = always !<=-1
  ( {7,!14,6}
  == {!<=-1,!>=2,1,0}
  :: always 7
  eChar always 7
  ? always !<=-1
  0U always 0
  : always 1
  1U always 1
Line 6655
  :: always 0
  UNKNOWN_SIGN always 0
  :: always 9
  CHAR always 9
Line 6657
  mIsCpp {!<=-1,!>=2,0}
  && always {!<=-1,!>=2}
  >= always {!<=-1,!>=2}
  :: always 4
  CPP20 always 4
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 6658
  = always "char8_t"
  "char8_t" always "char8_t"
Line 6659
  ( always {!<=-1,!>=2}
Line 6660
  ( always {!<=-1,!>=2}
Line 6661
  = always "char16_t"
  "char16_t" always "char16_t"
Line 6662
  ( always {!<=-1,!>=2}
Line 6663
  ( always {!<=-1,!>=2}
Line 6664
  = always "char32_t"
  "char32_t" always "char32_t"
Line 6665
  ( always {!<=-1,!>=2}
Line 6666
  ( always {!<=-1,!>=2}
Line 6667
  = always "wchar_t"
  "wchar_t" always "wchar_t"
Line 6668
  = always 11
  :: always 11
  WCHAR_T always 11
Line 6669
  ( always !14
  == always {!<=-1,!>=2}
  :: always 7
  eChar always 7
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  mIsCpp always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 6670
  = always 12
  :: always 12
  INT always 12
Line 6671
  = always 1
  :: always 1
  SIGNED always 1
Line 6674
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "(|{" always "(|{"
Line 6675
  ( always !0
  : always 0
  nullptr always 0
Line 6677
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "( %name%" always "( %name%"
Line 6679
  ( always {!<=-1,!>=2}
  & {lifetime[Address]=(valuetype),!0}
  ")" always ")"
Line 6684
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "static_cast|const_cast|dynamic_cast|reinterpret_cast < %name%" always "static_cast|const_cast|dynamic_cast|reinterpret_cast < %name%"
  && always {!<=-1,!>=2}
  1 always 1
Line 6686
  ( always {!<=-1,!>=2}
  2 always 2
  & {lifetime[Address]=(valuetype),!0}
  ">" always ">"
Line 6691
  ( always {!<=-1,!>=2}
Line 6693
  & {lifetime[Address]=(valuetype),!0}
Line 6701
  ( possible 0
  && always {!<=-1,!>=2}
  ( always !0
  && always {!<=-1,!>=2}
  ( always !0
  ( always !0
Line 6703
  ( always !0
  ( always !0
  . always !0
  & {lifetime[Address]=(valuetype),!0}
Line 6707
  ( always {!<=-1,!>=2}
  ( possible 0
  "sizeof (" always "sizeof ("
Line 6708
  :: always 2
  UNSIGNED always 2
  :: always 13
  LONG always 13
  0U always 0
Line 6709
  == always {!<=-1,!>=2}
  :: always 4
  Win64 always 4
Line 6710
  = always 14
  :: always 14
  LONGLONG always 14
Line 6712
  = always "size_t"
  "size_t" always "size_t"
Line 6715
  ( always {!<=-1,!>=2}
  "( %type% %type%| *| *| )" always "( %type% %type%| *| *| )"
Line 6717
  & {lifetime[Address]=(vt),!0}
Line 6724
  ( possible 0
  && always {!<=-1,!>=2}
  ( always !0
  ( always {!<=-1,!>=2}
Line 6726
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  ( always !0
Line 6731
  ( always {!<=-1,!>=2}
Line 6732
  ( always {!<=-1,!>=2}
Line 6733
  = always 2
  :: always 2
  UNSIGNED always 2
Line 6734
  ( always {!<=-1,!>=2}
Line 6735
  = always 1
  :: always 1
  SIGNED always 1
Line 6736
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  != always {!<=-1,!>=2}
  :: always 15
  UNKNOWN_INT always 15
Line 6742
  ( possible 0
  && always {!<=-1,!>=2}
  ( always !0
  && always {!<=-1,!>=2}
  ( always !0
  ( always !0
  ( always {!<=-1,!>=2}
Line 6744
  = always 3
  :: always 3
  RECORD always 3
Line 6745
  ( always !0
  ( always !0
Line 6749
  ( always {!<=-1,!>=2}
  ( possible 0
  "= {" always "= {"
  && always {!<=-1,!>=2}
  -2 always -2
  && always {!<=-1,!>=2}
  -2 always -2
Line 6750
  -2 always -2
Line 6757
  ( always {!<=-1,!>=2}
  ( always !0
  "%name%" always "%name%"
Line 6759
  ( always !0
  & {lifetime[Address]=(valuetype),!0}
Line 6766
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "%name%|::" always "%name%|::"
Line 6768
  typeStartToken possible symbolic=(tok->astOperand1())
  && always {!<=-1,!>=2}
  typeStartToken {symbolic=(tok->astOperand1()),!0}
  == always {!<=-1,!>=2}
  "::" always "::"
Line 6769
  typeStartToken always !0
Line 6770
  typeStartToken possible {symbolic=(tok->astOperand1()),0}
  || always {!<=-1,!>=2}
Line 6773
  & {lifetime[Address]=(vt),!0}
Line 6781
  e {symbolic=(tok->astOperand1()->expressionString()),size=16}
  == always {!<=-1,!>=2}
  "std::make_shared" always "std::make_shared"
  || always {!<=-1,!>=2}
  e always symbolic=(tok->astOperand1()->expressionString())
  == always {!<=-1,!>=2}
  "std::make_unique" always "std::make_unique"
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  ":: %name% < %name%" always ":: %name% < %name%"
Line 6783
  3 always 3
  & {lifetime[Address]=(vt),!0}
Line 6785
  . always !0
Line 6786
  = always 0
  nullptr always 0
Line 6788
  e possible size=16
  == always {!<=-1,!>=2}
  "std::make_shared" always "std::make_shared"
  && always {!<=-1,!>=2}
  ( always !<=-1
  "std::shared_ptr" always "std::shared_ptr"
  > always {!<=-1,!>=2}
  0 always 0
Line 6789
  = {lifetime[Object]=(smartPointers),!0}
  & {lifetime[Object]=(smartPointers),!0}
  "std::shared_ptr" always "std::shared_ptr"
Line 6790
  e possible size=16
  == always {!<=-1,!>=2}
  "std::make_unique" always "std::make_unique"
  && always {!<=-1,!>=2}
  ( always !<=-1
  "std::unique_ptr" always "std::unique_ptr"
  > always {!<=-1,!>=2}
  0 always 0
Line 6791
  vt possible lifetime[Object]=(smartPointers)
  = {lifetime[Object]=(smartPointers),!0}
  & {lifetime[Object]=(smartPointers),!0}
  "std::unique_ptr" always "std::unique_ptr"
Line 6792
  vt possible lifetime[Object]=(smartPointers)
  = always 4
  :: always 4
  SMART_POINTER always 4
Line 6793
  3 always 3
Line 6799
  ( always {!<=-1,!>=2}
Line 6805
  typestr possible size=0
Line 6806
  ! {!<=-1,!>=2,0}
  typestr possible size=0
  ( {!<=-1,!>=2,1}
Line 6809
  ";" always ";"
Line 6810
  ( always {!<=-1,!>=2}
Line 6812
  & {lifetime[Address]=(valuetype),!0}
Line 6818
  typestr possible size=8
  ( {!<=-1,!>=2,0}
  || always {!<=-1,!>=2}
  typestr {size=8,!size=0}
  == always {!<=-1,!>=2}
  "iterator" always "iterator"
Line 6819
  ( always {!<=-1,!>=2}
  "." always "."
  && always {!<=-1,!>=2}
Line 6820
  && always {!<=-1,!>=2}
Line 6821
  && always {!<=-1,!>=2}
Line 6822
  && always {!<=-1,!>=2}
Line 6823
  ( always !0
Line 6825
  :: possible {symbolic=(cont->functions.end()),end=0}
  it possible {symbolic=(cont->functions.end()),end=0}
  = possible lifetime[Iterator]=(cont->functions)
  ( possible lifetime[Iterator]=(cont->functions)
Line 6826
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(cont->functions),end=0}
Line 6827
  it always {!symbolic=(cont->functions.end()),!end=0}
  . possible {5,6}
  == {!<=-1,!>=2,0}
  :: always 4
  START_ITERATOR always 4
  || {!<=-1,!>=2,0}
Line 6828
  it always {!symbolic=(cont->functions.end()),!end=0}
  . possible 6
  == {!<=-1,!>=2,0}
  :: always 5
  END_ITERATOR always 5
  || always {!<=-1,!>=2}
Line 6829
  it always {!symbolic=(cont->functions.end()),!end=0}
  == always {!<=-1,!>=2}
  :: always 6
  ITERATOR always 6
Line 6831
  = always 6
  :: always 6
  ITERATOR always 6
Line 6842
  ";" always ";"
Line 6843
  ( always {!<=-1,!>=2}
Line 6847
  & {lifetime[Address]=(vt),!0}
Line 6853
  ( possible {size=3,size=6}
  == {!<=-1,!>=2,0}
  "return" always "return"
Line 6855
  functionScope possible {symbolic=(tok->scope()),0}
  && always {!<=-1,!>=2}
  functionScope {symbolic=(tok->scope()),!0}
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  functionScope {symbolic=(tok->scope()),!0}
  != always {!<=-1,!>=2}
  :: always 15
  eLambda always 15
  && always {!<=-1,!>=2}
  functionScope possible symbolic=(tok->scope())
  . always !15
  != always {!<=-1,!>=2}
Line 6856
  functionScope always !0
Line 6857
  functionScope possible {symbolic=(tok->scope()),0}
  && always {!<=-1,!>=2}
  functionScope always !0
  == always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  functionScope always !0
  && always {!<=-1,!>=2}
Line 6858
  . always !0
Line 6859
  functionScope always !0
  . always !0
  . always !0
Line 6861
  ( always {!<=-1,!>=2}
  "return {" always "return {"
Line 6866
  ! always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 6867
  ( always !0
Line 6870
  ( {!<=-1,!>=2,0}
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  "new" always "new"
Line 6872
  ( always {!<=-1,!>=2}
  typeTok always symbolic=(tok->next())
  "( std| ::| nothrow )" always "( std| ::| nothrow )"
Line 6873
  typeTok always symbolic=(tok->next())
Line 6874
  isIterator always {!<=-1,!>=2}
  isIterator always {!<=-1,!>=2}
  = always 0
  false always 0
Line 6875
  typeTok possible symbolic=(tok->next())
  & {lifetime[Address]=(isIterator),!0}
  isIterator always 0
Line 6877
  = always 1
  1 always 1
Line 6878
  = always !0
  c always !0
Line 6879
  = possible {6,5}
  isIterator always {!<=-1,!>=2}
  ? possible {6,5}
  :: always 6
  ITERATOR always 6
  : always 5
  :: always 5
  CONTAINER always 5
Line 6884
  ( always {!<=-1,!>=2}
  "%name% :: %name%" always "%name% :: %name%"
Line 6885
  "::" always "::"
Line 6886
  2 always 2
Line 6888
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "%type% ;|[|(" always "%type% ;|[|("
Line 6892
  = always 1
  1 always 1
Line 6893
  && always {!<=-1,!>=2}
  ( always !0
Line 6894
  = always 3
  :: always 3
  RECORD always 3
Line 6895
  = always !0
  ( always !0
  . always !0
Line 6897
  ( always {!<=-1,!>=2}
Line 6898
  == always {!<=-1,!>=2}
  :: always 0
  UNKNOWN_TYPE always 0
Line 6899
  ( always {!<=-1,!>=2}
Line 6900
  == always {!<=-1,!>=2}
  :: always 0
  UNKNOWN_TYPE always 0
Line 6902
  ( always {!<=-1,!>=2}
Line 6903
  = always 2
  :: always 2
  UNSIGNED always 2
Line 6904
  ( always {!<=-1,!>=2}
Line 6905
  = always 1
  :: always 1
  SIGNED always 1
Line 6906
  . possible {2,1}
  == {!<=-1,!>=2,0}
  :: always 0
  UNKNOWN_SIGN always 0
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 6907
  == always {!<=-1,!>=2}
  :: always 9
  CHAR always 9
  : always 1
  :: always 1
  SIGNED always 1
Line 6910
  ( always {!<=-1,!>=2}
  "(" always "("
Line 6914
  ( {!<=-1,!>=2,0}
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  "return" always "return"
  && always {!<=-1,!>=2}
Line 6915
  = always !0
  ( always !0
Line 6916
  fscope possible {symbolic=(tok->scope()),0}
  && {!<=-1,!>=2,0}
  ! {!<=-1,!>=2,1}
  fscope {symbolic=(tok->scope()),!0}
  . possible 0
Line 6917
  fscope always !0
Line 6918
  fscope possible {symbolic=(tok->scope()),0}
  && always {!<=-1,!>=2}
  fscope always !0
  && always {!<=-1,!>=2}
  fscope always !0
  . always !0
Line 6920
  fscope always !0
  . always !0
  . always !0
  & {lifetime[Address]=(vt),!0}
Line 6926
  reportDebugWarnings {!<=-1,!>=2,0@23}
  && always {!<=-1,!>=2}
  . always {!<=-1,!>=2}
  debugwarnings always {!<=-1,!>=2}
Line 6928
  == always {!<=-1,!>=2}
  "auto" always "auto"
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
Line 6929
  "autoNoType" always "autoNoType"
  "auto token with no type." always "auto token with no type."
Line 6934
  false always 0
Line 6943
  & {lifetime[Address]=(vt),!0}
  == always {!<=-1,!>=2}
  'u' always 117
Line 6947
  , always {!<=-1,!>=2}
  longType always {!<=-1,!>=2}
Line 6949
  typestr possible {size=4,size=5,size=7,size=3,size=6,size=1@89,size=2@89}
  == {!<=-1,!>=2,0}
  "void" always "void"
Line 6950
  :: always 7
  VOID always 7
Line 6951
  typestr possible {size=5,size=4,size=7,size=3,size=6}
  == {!<=-1,!>=2,0}
  "bool" always "bool"
  || always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  "_Bool" always "_Bool"
Line 6952
  :: always 8
  BOOL always 8
Line 6953
  typestr possible {size=5,size=7,size=3,size=4,size=6}
  == {!<=-1,!>=2,0}
  "char" always "char"
Line 6954
  :: always 9
  CHAR always 9
Line 6955
  typestr possible {size=7,size=3,size=4,size=5,size=6}
  == {!<=-1,!>=2,0}
  "short" always "short"
Line 6956
  :: always 10
  SHORT always 10
Line 6957
  typestr possible {size=3,size=4,size=5,size=6}
  == {!<=-1,!>=2,0}
  "wchar_t" always "wchar_t"
Line 6958
  :: always 11
  WCHAR_T always 11
Line 6959
  typestr possible {size=4,size=5,size=6}
  == {!<=-1,!>=2,0}
  "int" always "int"
Line 6960
  :: always 12
  INT always 12
Line 6961
  typestr possible {size=5,size=6}
  == {!<=-1,!>=2,0}
  "long" always "long"
Line 6962
  longType always {!<=-1,!>=2}
  ? possible {14,13}
  :: always 14
  LONGLONG always 14
  : always 13
  :: always 13
  LONG always 13
Line 6963
  typestr possible size=6
  == {!<=-1,!>=2,0}
  "float" always "float"
Line 6964
  :: always 16
  FLOAT always 16
Line 6965
  == always {!<=-1,!>=2}
  "double" always "double"
Line 6966
  longType always {!<=-1,!>=2}
  ? possible {18,17}
  :: always 18
  LONGDOUBLE always 18
  : always 17
  :: always 17
  DOUBLE always 17
Line 6967
  :: always 0
  UNKNOWN_TYPE always 0
Line 6970
  ( always {!<=-1,!>=2}
Line 6972
  typestr possible {size=6,size=11}
Line 6973
  podtype {symbolic=(settings->library.podtype(typestr)),0}
  && always {!<=-1,!>=2}
  podtype {symbolic=(settings->library.podtype(typestr)),!0}
  == always {!<=-1,!>=2}
  's' always 115
  || always {!<=-1,!>=2}
  podtype {symbolic=(settings->library.podtype(typestr)),!0}
  . always !115
  == always {!<=-1,!>=2}
  'u' always 117
Line 6974
  podtype {symbolic=(settings->library.podtype(typestr)),!0}
  . {!<=-1,symbolic=(settings->sizeof_int),symbolic=(settings->sizeof_short),symbolic=(settings->sizeof_long),symbolic=(settings->sizeof_long_long)}
  size always !<=-1
  == always {!<=-1,!>=2}
  1 always 1
Line 6975
  = always 9
  :: always 9
  CHAR always 9
Line 6976
  podtype {symbolic=(settings->library.podtype(typestr)),!0}
  . {!<=-1,symbolic=(settings->sizeof_short),symbolic=(settings->sizeof_long),symbolic=(settings->sizeof_long_long),!1}
  size always !<=-1
  == always {!<=-1,!>=2}
Line 6977
  = always 12
  :: always 12
  INT always 12
Line 6978
  podtype {symbolic=(settings->library.podtype(typestr)),!0}
  . {!<=-1,symbolic=(settings->sizeof_long),symbolic=(settings->sizeof_long_long),!symbolic=(settings->sizeof_int),!1}
  size always !<=-1
  == always {!<=-1,!>=2}
Line 6979
  = always 10
  :: always 10
  SHORT always 10
Line 6980
  podtype {symbolic=(settings->library.podtype(typestr)),!0}
  . {!<=-1,symbolic=(settings->sizeof_long_long),!symbolic=(settings->sizeof_int),!symbolic=(settings->sizeof_short),!1}
  size always !<=-1
  == always {!<=-1,!>=2}
Line 6981
  = always 13
  :: always 13
  LONG always 13
Line 6982
  podtype {symbolic=(settings->library.podtype(typestr)),!0}
  . always {!<=-1,!symbolic=(settings->sizeof_int),!symbolic=(settings->sizeof_short),!symbolic=(settings->sizeof_long),!1}
  size always !<=-1
  == always {!<=-1,!>=2}
Line 6983
  = always 14
  :: always 14
  LONGLONG always 14
Line 6984
  podtype {symbolic=(settings->library.podtype(typestr)),!0}
  . possible {2,3,4,5,6}
  == {!<=-1,!>=2,0}
  :: always 1
  BOOL always 1
Line 6985
  = always 8
  :: always 8
  BOOL always 8
Line 6986
  podtype {symbolic=(settings->library.podtype(typestr)),!0}
  . {3,4,5,6,!1}
  == {!<=-1,!>=2,0}
  :: always 2
  CHAR always 2
Line 6987
  = always 9
  :: always 9
  CHAR always 9
Line 6988
  podtype {symbolic=(settings->library.podtype(typestr)),!0}
  . {4,5,6,!1,!2}
  == {!<=-1,!>=2,0}
  :: always 3
  SHORT always 3
Line 6989
  = always 10
  :: always 10
  SHORT always 10
Line 6990
  podtype {symbolic=(settings->library.podtype(typestr)),!0}
  . {5,6,!1,!2,!3}
  == {!<=-1,!>=2,0}
  :: always 4
  INT always 4
Line 6991
  = always 12
  :: always 12
  INT always 12
Line 6992
  podtype {symbolic=(settings->library.podtype(typestr)),!0}
  . {6,!1,!2,!3,!4}
  == {!<=-1,!>=2,0}
  :: always 5
  LONG always 5
Line 6993
  = always 13
  :: always 13
  LONG always 13
Line 6994
  podtype {symbolic=(settings->library.podtype(typestr)),!0}
  . always {!1,!2,!3,!4,!5}
  == always {!<=-1,!>=2}
  :: always 6
  LONGLONG always 6
Line 6995
  = always 14
  :: always 14
  LONGLONG always 14
Line 6997
  = always 15
  :: always 15
  UNKNOWN_INT always 15
Line 6998
  podtype {symbolic=(settings->library.podtype(typestr)),!0}
  == always {!<=-1,!>=2}
  'u' always 117
Line 6999
  return always {!<=-1,!>=2}
  true always 1
Line 7000
  podtype {symbolic=(settings->library.podtype(typestr)),0}
  && always {!<=-1,!>=2}
  podtype {symbolic=(settings->library.podtype(typestr)),!0}
  == always {!<=-1,!>=2}
  :: always 0
  NO always 0
Line 7001
  = always 1
  :: always 1
  POD always 1
Line 7002
  = always 0
  :: always 0
  UNKNOWN_SIGN always 0
Line 7003
  return always {!<=-1,!>=2}
  true always 1
Line 7006
  typestr possible {size=6,size=11}
Line 7007
  platformType always symbolic=(settings->library.platform_type(typestr,settings->platformString()))
Line 7008
  platformType {symbolic=(settings->library.platform_type(typestr,settings->platformString())),!0}
  . possible {size=5,size=7,size=3,size=4}
  == {!<=-1,!>=2,0}
  "char" always "char"
Line 7009
  = always 9
  :: always 9
  CHAR always 9
Line 7010
  platformType {symbolic=(settings->library.platform_type(typestr,settings->platformString())),!0}
  . possible {size=7,size=3,size=4}
  == {!<=-1,!>=2,0}
  "short" always "short"
Line 7011
  = always 10
  :: always 10
  SHORT always 10
Line 7012
  platformType {symbolic=(settings->library.platform_type(typestr,settings->platformString())),!0}
  . possible {size=3,size=4}
  == {!<=-1,!>=2,0}
  "wchar_t" always "wchar_t"
Line 7013
  = always 11
  :: always 11
  WCHAR_T always 11
Line 7014
  platformType {symbolic=(settings->library.platform_type(typestr,settings->platformString())),!0}
  . possible size=4
  == {!<=-1,!>=2,0}
  "int" always "int"
Line 7015
  platformType {symbolic=(settings->library.platform_type(typestr,settings->platformString())),!0}
  . always {!<=-1,!>=2}
  mLong always {!<=-1,!>=2}
  :: always 13
  LONG always 13
  : always 12
  :: always 12
  INT always 12
Line 7016
  platformType {symbolic=(settings->library.platform_type(typestr,settings->platformString())),!0}
  == always {!<=-1,!>=2}
  "long" always "long"
Line 7017
  platformType {symbolic=(settings->library.platform_type(typestr,settings->platformString())),!0}
  . always {!<=-1,!>=2}
  mLong always {!<=-1,!>=2}
  :: always 14
  LONGLONG always 14
  : always 13
  :: always 13
  LONG always 13
Line 7018
  platformType {symbolic=(settings->library.platform_type(typestr,settings->platformString())),!0}
  . always {!<=-1,!>=2}
  mSigned always {!<=-1,!>=2}
Line 7020
  platformType {symbolic=(settings->library.platform_type(typestr,settings->platformString())),!0}
  . always {!<=-1,!>=2}
  mUnsigned always {!<=-1,!>=2}
Line 7022
  platformType {symbolic=(settings->library.platform_type(typestr,settings->platformString())),!0}
  . always {!<=-1,!>=2}
  mPointer always {!<=-1,!>=2}
Line 7023
  = always 1
  1 always 1
Line 7024
  platformType {symbolic=(settings->library.platform_type(typestr,settings->platformString())),!0}
  . always {!<=-1,!>=2}
  mPtrPtr always {!<=-1,!>=2}
Line 7025
  = always 2
  2 always 2
Line 7026
  platformType {symbolic=(settings->library.platform_type(typestr,settings->platformString())),!0}
  . always {!<=-1,!>=2}
  mConstPtr always {!<=-1,!>=2}
Line 7027
  = always 1
  1 always 1
Line 7028
  return always {!<=-1,!>=2}
  true always 1
Line 7029
  ! always {!<=-1,!>=2}
  podtype always symbolic=(settings->library.podtype(typestr))
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  "size_t" always "size_t"
  || always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  "std::size_t" always "std::size_t"
Line 7030
  = always "size_t"
  "size_t" always "size_t"
Line 7032
  . possible {symbolic=(settings->sizeof_long_long),symbolic=(settings->sizeof_int)}
  == always {!<=-1,!>=2}
Line 7033
  = always 13
  :: always 13
  LONG always 13
Line 7034
  . {symbolic=(settings->sizeof_int),!symbolic=(settings->sizeof_long)}
  == always {!<=-1,!>=2}
Line 7035
  = always 14
  :: always 14
  LONGLONG always 14
Line 7036
  . always {!symbolic=(settings->sizeof_long),!symbolic=(settings->sizeof_long_long)}
  == always {!<=-1,!>=2}
Line 7037
  = always 12
  :: always 12
  INT always 12
Line 7039
  = always 15
  :: always 15
  UNKNOWN_INT always 15
Line 7040
  return always {!<=-1,!>=2}
  true always 1
Line 7043
  return always {!<=-1,!>=2}
  false always 0
Line 7050
  UNKNOWN_TYPE always 0
Line 7051
  "" always ""
Line 7052
  NONSTD always 2
Line 7053
  "valueType-type=\"nonstd\"" always "valueType-type=\"nonstd\""
Line 7055
  POD always 1
Line 7056
  "valueType-type=\"pod\"" always "valueType-type=\"pod\""
Line 7058
  RECORD always 3
Line 7059
  "valueType-type=\"record\"" always "valueType-type=\"record\""
Line 7061
  SMART_POINTER always 4
Line 7062
  "valueType-type=\"smart-pointer\"" always "valueType-type=\"smart-pointer\""
Line 7064
  CONTAINER always 5
Line 7065
  "valueType-type=\"container\"" always "valueType-type=\"container\""
Line 7067
  ITERATOR always 6
Line 7068
  "valueType-type=\"iterator\"" always "valueType-type=\"iterator\""
Line 7070
  VOID always 7
Line 7071
  "valueType-type=\"void\"" always "valueType-type=\"void\""
Line 7073
  BOOL always 8
Line 7074
  "valueType-type=\"bool\"" always "valueType-type=\"bool\""
Line 7076
  CHAR always 9
Line 7077
  "valueType-type=\"char\"" always "valueType-type=\"char\""
Line 7079
  SHORT always 10
Line 7080
  "valueType-type=\"short\"" always "valueType-type=\"short\""
Line 7082
  WCHAR_T always 11
Line 7083
  "valueType-type=\"wchar_t\"" always "valueType-type=\"wchar_t\""
Line 7085
  INT always 12
Line 7086
  "valueType-type=\"int\"" always "valueType-type=\"int\""
Line 7088
  LONG always 13
Line 7089
  "valueType-type=\"long\"" always "valueType-type=\"long\""
Line 7091
  LONGLONG always 14
Line 7092
  "valueType-type=\"long long\"" always "valueType-type=\"long long\""
Line 7094
  UNKNOWN_INT always 15
Line 7095
  "valueType-type=\"unknown int\"" always "valueType-type=\"unknown int\""
Line 7097
  FLOAT always 16
Line 7098
  "valueType-type=\"float\"" always "valueType-type=\"float\""
Line 7100
  DOUBLE always 17
Line 7101
  "valueType-type=\"double\"" always "valueType-type=\"double\""
Line 7103
  LONGDOUBLE always 18
Line 7104
  "valueType-type=\"long double\"" always "valueType-type=\"long double\""
Line 7112
  " valueType-sign=\"signed\"" always " valueType-sign=\"signed\""
Line 7115
  " valueType-sign=\"unsigned\"" always " valueType-sign=\"unsigned\""
Line 7119
  > always {!<=-1,!>=2}
  0 always 0
Line 7120
  " valueType-bits=\"" always " valueType-bits=\""
  bits {>=1,!<=0}
  '\"' always 34
Line 7122
  > always {!<=-1,!>=2}
  0 always 0
Line 7123
  " valueType-pointer=\"" always " valueType-pointer=\""
  pointer {>=1,!<=0}
  '\"' always 34
Line 7125
  > always {!<=-1,!>=2}
  0 always 0
Line 7126
  " valueType-constness=\"" always " valueType-constness=\""
  constness {>=1,!<=0}
  '\"' always 34
Line 7128
  reference possible {1,2}
  == {!<=-1,!>=2,0}
  :: always 0
  None always 0
Line 7129
  " valueType-reference=\"None\"" always " valueType-reference=\"None\""
Line 7130
  reference {2,!0}
  == {!<=-1,!>=2,0}
  :: always 1
  LValue always 1
Line 7131
  " valueType-reference=\"LValue\"" always " valueType-reference=\"LValue\""
Line 7132
  reference always {!0,!1}
  == always {!<=-1,!>=2}
  :: always 2
  RValue always 2
Line 7133
  " valueType-reference=\"RValue\"" always " valueType-reference=\"RValue\""
Line 7136
  " valueType-typeScope=\"" always " valueType-typeScope=\""
  typeScope always !0
  '\"' always 34
Line 7138
  ! {!<=-1,!>=2,0}
  originalTypeName possible size=0
  ( {!<=-1,!>=2,1}
Line 7139
  " valueType-originalTypeName=\"" always " valueType-originalTypeName=\""
  originalTypeName always !size=0
  '\"' always 34
Line 7144
  , always {!<=-1,!>=2}
  p always {!<=-1,!>=2}
Line 7146
  p always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 7149
  && always {!<=-1,!>=2}
  typeScope always !0
  && always {!<=-1,!>=2}
  typeScope always !0
  . always !0
Line 7150
  typeScope always !0
  . always !0
  . always !0
Line 7153
  :: always 8
  BOOL always 8
Line 7155
  :: always 9
  CHAR always 9
Line 7156
  1 always 1
Line 7157
  :: always 10
  SHORT always 10
Line 7159
  :: always 11
  WCHAR_T always 11
Line 7161
  :: always 12
  INT always 12
Line 7163
  :: always 13
  LONG always 13
Line 7165
  :: always 14
  LONGLONG always 14
Line 7167
  :: always 16
  FLOAT always 16
Line 7169
  :: always 17
  DOUBLE always 17
Line 7171
  :: always 18
  LONGDOUBLE always 18
Line 7178
  0 always 0
Line 7181
  ( always {!<=-1,!>=2}
Line 7184
  ( possible {lifetime[Object]=(vt->type),lifetime[Object]=(vt->container),lifetime[Object]=(vt->pointer),lifetime[Object]=(vt->typeScope),lifetime[Object]=(vt->smartPointer)}
Line 7186
  return always {!<=-1,!>=2}
  this always !0
  == always {!<=-1,!>=2}
Line 7192
  & possible {0,1}
  1 always 1
Line 7193
  = always " const"
  " const" always " const"
Line 7194
  type possible {8,9,10,11,12,13,14,15,16,17}
  == {!<=-1,!>=2,0}
  VOID always 7
Line 7195
  " void" always " void"
Line 7196
  ( always {!<=-1,!>=2}
Line 7197
  == always {!<=-1,!>=2}
Line 7198
  " signed" always " signed"
Line 7199
  == always {!<=-1,!>=2}
Line 7200
  " unsigned" always " unsigned"
Line 7201
  type {9,10,11,12,13,14,15,!7}
  == {!<=-1,!>=2,0}
  BOOL always 8
Line 7202
  " bool" always " bool"
Line 7203
  type {10,11,12,13,14,15,!7,!8}
  == {!<=-1,!>=2,0}
  CHAR always 9
Line 7204
  " char" always " char"
Line 7205
  type {11,12,13,14,15,!7,!8,!9}
  == {!<=-1,!>=2,0}
  SHORT always 10
Line 7206
  " short" always " short"
Line 7207
  type {12,13,14,15,!7,!8,!9,!10}
  == {!<=-1,!>=2,0}
  WCHAR_T always 11
Line 7208
  " wchar_t" always " wchar_t"
Line 7209
  type {13,14,15,!7,!8,!9,!10,!11}
  == {!<=-1,!>=2,0}
  INT always 12
Line 7210
  " int" always " int"
Line 7211
  type {14,15,!7,!8,!9,!10,!11,!12}
  == {!<=-1,!>=2,0}
  LONG always 13
Line 7212
  " long" always " long"
Line 7213
  type {15,!7,!8,!9,!10,!11,!12,!13}
  == {!<=-1,!>=2,0}
  LONGLONG always 14
Line 7214
  " long long" always " long long"
Line 7215
  type always {!7,!8,!9,!10,!11,!12,!13,!14}
  == always {!<=-1,!>=2}
  UNKNOWN_INT always 15
Line 7216
  " unknown_int" always " unknown_int"
Line 7217
  type {17,18,2,3,5,6,4,!7}
  == {!<=-1,!>=2,0}
  FLOAT always 16
Line 7218
  " float" always " float"
Line 7219
  type {18,2,3,5,6,4,!7,!16}
  == {!<=-1,!>=2,0}
  DOUBLE always 17
Line 7220
  " double" always " double"
Line 7221
  type {2,3,5,6,4,!7,!16,!17}
  == {!<=-1,!>=2,0}
  LONGDOUBLE always 18
Line 7222
  " long double" always " long double"
Line 7223
  type {3,5,6,4,!7,!16,!17,!18}
  == {!<=-1,!>=2,0}
  :: always 2
  NONSTD always 2
  || always {!<=-1,!>=2}
  type {5,6,4,!7,!16,!17,!18,!2}
  == {!<=-1,!>=2,0}
  :: always 3
  RECORD always 3
  && always {!<=-1,!>=2}
Line 7224
  typeScope always !0
Line 7225
  typeScope always !0
  typeScope always !0
  . always !0
  typeScope always !0
Line 7226
  scope possible symbolic=(typeScope->definedType?typeScope->definedType->enclosingScope:typeScope->nestedIn)
  && always {!<=-1,!>=2}
  scope {symbolic=(typeScope->definedType?typeScope->definedType->enclosingScope:typeScope->nestedIn),!0}
  != always {!<=-1,!>=2}
  :: always 0
  eGlobal always 0
Line 7227
  scope always !0
  . {2,4,!0}
  == {!<=-1,!>=2,0}
  :: always 1
  eClass always 1
  || {!<=-1,!>=2,0}
  scope always !0
  . {4,!0,!1}
  == {!<=-1,!>=2,0}
  :: always 2
  eStruct always 2
  || always {!<=-1,!>=2}
  scope always !0
  . always {!0,!1,!2}
  == always {!<=-1,!>=2}
  :: always 4
  eNamespace always 4
Line 7228
  scope always !0
  "::" always "::"
Line 7229
  scope always !0
  && always {!<=-1,!>=2}
  scope always !0
  . always !0
  scope always !0
  . always !0
  . always !0
  : always 1
  scope always !0
Line 7231
  ' ' always 32
Line 7232
  type {6,4,!7,!16,!17,!18}
  == {!<=-1,!>=2,0}
  :: always 5
  CONTAINER always 5
  && always {!<=-1,!>=2}
Line 7233
  " container(" always " container("
  container always !0
  ')' always 41
Line 7234
  type {4,!7,!16,!17,!18}
  == {!<=-1,!>=2,0}
  :: always 6
  ITERATOR always 6
  && always {!<=-1,!>=2}
Line 7235
  " iterator(" always " iterator("
  container always !0
  ')' always 41
Line 7236
  type always {!7,!16,!17,!18}
  == always {!<=-1,!>=2}
  :: always 4
  SMART_POINTER always 4
  && always {!<=-1,!>=2}
Line 7237
  " smart-pointer(" always " smart-pointer("
  smartPointer always !0
  ")" always ")"
Line 7239
  p always !<=-1
  = always 0
  0 always 0
  p {!<=-1,0}
  < always {!<=-1,!>=2}
  p always !<=-1
  ++ always !<=-1
Line 7240
  " *" always " *"
Line 7241
  2 always 2
  p {!<=-1,<=symbolic=(pointer-1),!>=symbolic=(pointer)}
Line 7242
  ret always !<=size=1
  " const" always " const"
Line 7244
  reference possible 2
  == {!<=-1,!>=2,0}
  :: always 1
  LValue always 1
Line 7245
  " &" always " &"
Line 7246
  reference always !1
  == always {!<=-1,!>=2}
  :: always 2
  RValue always 2
Line 7247
  " &&" always " &&"
Line 7248
  ( always {!<=-1,!>=2}
  ret possible size=0
  ret always !size=0
  1 always 1
Line 7253
  ! always {!<=-1,!>=2}
  call possible lifetime[Address]=(callArgType)@17
  || always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  func possible lifetime[Address]=(funcArgType)@17
Line 7255
  call {!0,lifetime[Address]=(callArgType)@17}
  . possible 1
  != {!<=-1,!>=2,0,1}
  func {!0,lifetime[Address]=(funcArgType)@17}
  . possible {1,0}
Line 7256
  call always !0
  . {!symbolic=(func->pointer),1}
  > {!<=-1,!>=2,0}
  1 always 1
  && always {!<=-1,!>=2}
  func always !0
  . always !symbolic=(call->pointer)
  == always {!<=-1,!>=2}
  1 always 1
  && always {!<=-1,!>=2}
  func always !0
  == always {!<=-1,!>=2}
  :: always 7
  VOID always 7
Line 7257
  :: always 2
  FALLBACK1 always 2
Line 7258
  call always !0
  . {!symbolic=(func->pointer),1}
  == {!<=-1,!>=2,1}
  1 always 1
  && always {!<=-1,!>=2}
  func always !0
  . always {!symbolic=(call->pointer),!1}
  == always {!<=-1,!>=2}
  0 always 0
  && always {!<=-1,!>=2}
  func always !0
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  func always !0
  != always {!<=-1,!>=2}
Line 7259
  :: always 2
  FALLBACK1 always 2
Line 7260
  == always {!<=-1,!>=2}
  1 always 1
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 9
  CHAR always 9
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  0 always 0
  && always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  . always !0
  . always {!<=-1,!>=2}
  stdStringLike always {!<=-1,!>=2}
Line 7261
  :: always 3
  FALLBACK2 always 3
Line 7262
  :: always 4
  NOMATCH always 4
Line 7264
  call always !0
  . always {symbolic=(call->pointer),symbolic=(func->pointer)}
  > always {!<=-1,!>=2}
  0 always 0
Line 7265
  call always !0
  . possible 0
  | possible 0
  func always !0
  . possible 0
  != {!<=-1,!>=2,0}
  func always !0
  . possible 0
Line 7266
  :: always 4
  NOMATCH always 4
Line 7267
  == always {!<=-1,!>=2}
  0 always 0
  && always {!<=-1,!>=2}
  . always symbolic=(call->constness|func->constness)
  != always {!<=-1,!>=2}
  0 always 0
  && always {!<=-1,!>=2}
  != always {!<=-1,!>=2}
  :: always 0
  None always 0
Line 7268
  :: always 4
  NOMATCH always 4
Line 7270
  call always !0
  . possible 7
  != {!<=-1,!>=2,0,1}
  func always !0
  . possible {7,0}
Line 7271
  call always !0
  . always !symbolic=(func->type)
  == always {!<=-1,!>=2}
  :: always 7
  VOID always 7
  || always {!<=-1,!>=2}
  func always !0
  . always !symbolic=(call->type)
  == always {!<=-1,!>=2}
  :: always 7
  VOID always 7
Line 7272
  :: always 2
  FALLBACK1 always 2
Line 7273
  . always {symbolic=(call->pointer),symbolic=(func->pointer)}
  > always {!<=-1,!>=2}
  0 always 0
Line 7274
  . always {!symbolic=(call->type),!7}
  == always {!<=-1,!>=2}
  :: always 0
  UNKNOWN_TYPE always 0
  : always 4
  :: always 4
  NOMATCH always 4
Line 7275
  ( {!<=-1,!>=2,0}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 7276
  . always !7
  < always {!<=-1,!>=2}
  . always !7
Line 7277
  :: always 2
  FALLBACK1 always 2
  : always 3
Line 7278
  :: always 3
  FALLBACK2 always 3
Line 7279
  ( {!<=-1,!>=2,0}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 7280
  :: always 2
  FALLBACK1 always 2
Line 7281
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 7282
  :: always 3
  FALLBACK2 always 3
Line 7283
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 7284
  :: always 3
  FALLBACK2 always 3
Line 7288
  . possible symbolic=(func->typeScope)
  != always {!<=-1,!>=2}
  nullptr always 0
  || always {!<=-1,!>=2}
  != always {!<=-1,!>=2}
  nullptr always 0
Line 7289
  != always {!<=-1,!>=2}
Line 7290
  :: always 4
  NOMATCH always 4
Line 7293
  . possible symbolic=(func->container)
  != always {!<=-1,!>=2}
  nullptr always 0
  || always {!<=-1,!>=2}
  != always {!<=-1,!>=2}
  nullptr always 0
Line 7294
  != always {!<=-1,!>=2}
Line 7295
  :: always 4
  NOMATCH always 4
Line 7298
  != always {!<=-1,!>=2}
  nullptr always 0
  && always {!<=-1,!>=2}
  != always {!<=-1,!>=2}
  nullptr always 0
Line 7299
  . {15,symbolic=(func->type),symbolic=(call->type)}
  < {!<=-1,!>=2,0}
  :: always 7
  VOID always 7
  || {!<=-1,!>=2,>=0}
  . {!<=6,>=7,symbolic=(func->type),symbolic=(call->type)}
  == {!<=-1,!>=2,>=0}
  :: always 15
  UNKNOWN_INT always 15
Line 7303
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  != always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  != always {!<=-1,!>=2}
  :: always !symbolic=(call->sign)
  && always {!<=-1,!>=2}
  . always !symbolic=(ValueType::Sign::UNKNOWN_SIGN)
  != always {!<=-1,!>=2}
  . always !symbolic=(ValueType::Sign::UNKNOWN_SIGN)
Line 7304
  :: always 2
  FALLBACK1 always 2
Line 7306
  != always {!<=-1,!>=2}
  :: always 0
  None always 0
  && always {!<=-1,!>=2}
  > always {!<=-1,!>=2}
Line 7307
  :: always 2
  FALLBACK1 always 2
Line 7309
  :: always 1
  SAME always 1
Line 7316
  pvt always symbolic=(funcVar->valueType())
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "std :: array" always "std :: array"
Line 7317
  pvt {symbolic=(funcVar->valueType()),!0}
Line 7318
  vt always symbolic=(*pvt)
  == always {!<=-1,!>=2}
  0 always 0
Line 7319
  vt always symbolic=(*pvt)
Line 7320
  = {&,lifetime[Address]=(vt),!0}
  & {&,lifetime[Address]=(vt),!0}
  vt possible symbolic=(*pvt)
Line 7322
  pvt possible {lifetime[Address]=(vt),symbolic=(funcVar->valueType()),symbolic=(&vt),&}
Line 7323
  callVar possible symbolic=(arguments[j]->variable())@4921
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 1
  SAME always 1
  && always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
Line 7324
  callVar always !0
Line 7326
  templateVar always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
Line 7327
  && always {!<=-1,!>=2}
  ( always !0
  && always {!<=-1,!>=2}
  ( always !0
  . always !0
Line 7328
  == always {!<=-1,!>=2}
Line 7329
  :: always 1
  SAME always 1
Line 7330
  ! always {!<=-1,!>=2}
  templateVar {symbolic=(funcVar->scope()&&funcVar->scope()->function&&funcVar->scope()->function->templateDef),!<=-1,!>=2}
  && always {!<=-1,!>=2}
  type1 always !symbolic=(type2)
  ( always !<=-1
  "auto" always "auto"
  == always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  type2 always !symbolic=(type1)
  ( always !<=-1
  "auto" always "auto"
  == always {!<=-1,!>=2}
  :: always symbolic=(type1.find("auto"))
Line 7331
  :: always 4
  NOMATCH always 4
Line 50
  mFlags always !<=-1
  mFlags always !<=-1
  = always 0
  0 always 0
Line 52
  ( always !<=-1
Line 53
  return always !<=-1
  mFlags always !<=-1
Line 56
  mFlags always !<=-1
  = always 0
  0 always 0
Line 59
  mFlags always !<=-1
  = always 4294967295
  0xFFFFFFFF always 4294967295
Line 61
  enabled always {!<=-1,!>=2}
Line 62
  enabled always {!<=-1,!>=2}
Line 67
  ( always {!<=-1,!>=2}
Line 68
  return always {!<=-1,!>=2}
  mFlags always !<=-1
  & always !<=-1
  1U always 1
  << always !<=0
  ( always !<=-1
  != always {!<=-1,!>=2}
  0 always 0
Line 71
  mFlags always !<=-1
  |= always !<=-1
  1U always 1
  << always !<=0
  ( always !<=-1
Line 74
  mFlags always !<=-1
  &= always !<=-1
  ~ always !<=4294967295
  1U always 1
  << always !<=0
  ( always !<=-1
Line 76
  , always {!<=-1,!>=2}
  enabled always {!<=-1,!>=2}
Line 77
  enabled always {!<=-1,!>=2}
Line 50
  mFlags always !<=-1
  mFlags always !<=-1
  = always 0
  0 always 0
Line 52
  ( always !<=-1
Line 53
  return always !<=-1
  mFlags always !<=-1
Line 56
  mFlags always !<=-1
  = always 0
  0 always 0
Line 59
  mFlags always !<=-1
  = always 4294967295
  0xFFFFFFFF always 4294967295
Line 61
  enabled always {!<=-1,!>=2}
Line 62
  enabled always {!<=-1,!>=2}
Line 67
  ( always {!<=-1,!>=2}
Line 68
  return always {!<=-1,!>=2}
  mFlags always !<=-1
  & always !<=-1
  1U always 1
  << always !<=0
  ( always !<=-1
  != always {!<=-1,!>=2}
  0 always 0
Line 71
  mFlags always !<=-1
  |= always !<=-1
  1U always 1
  << always !<=0
  ( always !<=-1
Line 74
  mFlags always !<=-1
  &= always !<=-1
  ~ always !<=4294967295
  1U always 1
  << always !<=0
  ( always !<=-1
Line 76
  , always {!<=-1,!>=2}
  enabled always {!<=-1,!>=2}
Line 77
  enabled always {!<=-1,!>=2}
Line 50
  mFlags always !<=-1
  mFlags always !<=-1
  = always 0
  0 always 0
Line 52
  ( always !<=-1
Line 53
  return always !<=-1
  mFlags always !<=-1
Line 56
  mFlags always !<=-1
  = always 0
  0 always 0
Line 59
  mFlags always !<=-1
  = always 4294967295
  0xFFFFFFFF always 4294967295
Line 61
  enabled always {!<=-1,!>=2}
Line 62
  enabled always {!<=-1,!>=2}
Line 67
  ( always {!<=-1,!>=2}
Line 68
  return always {!<=-1,!>=2}
  mFlags always !<=-1
  & always !<=-1
  1U always 1
  << always !<=0
  ( always !<=-1
  != always {!<=-1,!>=2}
  0 always 0
Line 71
  mFlags always !<=-1
  |= always !<=-1
  1U always 1
  << always !<=0
  ( always !<=-1
Line 74
  mFlags always !<=-1
  &= always !<=-1
  ~ always !<=4294967295
  1U always 1
  << always !<=0
  ( always !<=-1
Line 76
  , always {!<=-1,!>=2}
  enabled always {!<=-1,!>=2}
Line 77
  enabled always {!<=-1,!>=2}
