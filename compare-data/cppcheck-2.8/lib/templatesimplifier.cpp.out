

##file cppcheck-2.8/lib/config.h

1:
|
78:
79: static const std :: string emptyString@var1 ;

##file cppcheck-2.8/lib/templatesimplifier.h

1:
|
34:
35: class ErrorLogger ;
36: class Settings ;
37: class Token ;
38: class Tokenizer ;
39: class TokenList ;
40:
|
44:
45: class TemplateSimplifier {
46: friend class TestSimplifyTemplate ;
47:
48: public:
49: explicit TemplateSimplifier ( Tokenizer * tokenizer@var2 ) ;
50: ~ TemplateSimplifier ( ) ;
51:
52:
53:
54: void checkComplicatedSyntaxErrorsInTemplates ( ) ;
55:
|
61:
62: static unsigned int templateParameters ( const Token * tok@var3 ) ;
63:
|
66:
67: class TokenAndName {
68: Token * mToken@var4 ;
69: std :: string mScope@var5 ;
70: std :: string mName@var6 ;
71: std :: string mFullName@var7 ;
72: const Token * mNameToken@var8 ;
73: const Token * mParamEnd@var9 ;
74: unsigned int mFlags@var10 ;
75:
76: enum Anonymous0 {
77: fIsClass = ( 1 << 0 ) ,
78: fIsFunction = ( 1 << 1 ) ,
79: fIsVariable = ( 1 << 2 ) ,
80: fIsAlias = ( 1 << 3 ) ,
81: fIsSpecialization = ( 1 << 4 ) ,
82: fIsPartialSpecialization = ( 1 << 5 ) ,
83: fIsForwardDeclaration = ( 1 << 6 ) ,
84: fIsVariadic = ( 1 << 7 ) ,
85: fIsFriend = ( 1 << 8 ) ,
86: fFamilyMask = ( fIsClass | fIsFunction | fIsVariable )
87: } ;
88:
89: void isClass ( bool state@var11 ) {
90: setFlag (@expr1073744020 fIsClass , state@var11 ) ;
91: }
92: void isFunction ( bool state@var12 ) {
93: setFlag (@expr1073744021 fIsFunction , state@var12 ) ;
94: }
95: void isVariable ( bool state@var13 ) {
96: setFlag (@expr1073744022 fIsVariable , state@var13 ) ;
97: }
98: void isAlias ( bool state@var14 ) {
99: setFlag (@expr1073744023 fIsAlias , state@var14 ) ;
100: }
101: void isSpecialization ( bool state@var15 ) {
102: setFlag (@expr1073744024 fIsSpecialization , state@var15 ) ;
103: }
104: void isPartialSpecialization ( bool state@var16 ) {
105: setFlag (@expr1073744025 fIsPartialSpecialization , state@var16 ) ;
106: }
107: void isForwardDeclaration ( bool state@var17 ) {
108: setFlag (@expr1073744026 fIsForwardDeclaration , state@var17 ) ;
109: }
110: void isVariadic ( bool state@var18 ) {
111: setFlag (@expr1073744027 fIsVariadic , state@var18 ) ;
112: }
113: void isFriend ( bool state@var19 ) {
114: setFlag (@expr1073744028 fIsFriend , state@var19 ) ;
115: }
116:
|
121:
122: bool getFlag ( unsigned int flag@var20 ) const {
123: return (@expr2205 (@expr2205 mFlags@var10 &@expr1073744031 flag@var20 ) !=@expr1073744032 0 ) ;
124: }
125:
|
130:
131: void setFlag ( unsigned int flag@var21 , bool state@var22 ) {
132: mFlags@var10 =@expr1073744033 state@var22 ?@expr1073744034 mFlags@var10 |@expr1073744035 flag@var21 :@expr1073744036 mFlags@var10 &@expr1073744037 ~@expr1073744038 flag@var21 ;
133: }
134:
135: public:
136:
|
140:
141: TokenAndName ( Token * token@var23 , const std :: string & scope@var24 ) ;
142:
|
148:
149: TokenAndName ( Token * token@var25 , const std :: string & scope@var26 , const Token * nameToken@var27 , const Token * paramEnd@var28 ) ;
150: TokenAndName ( const TokenAndName & other@var29 ) ;
151: ~ TokenAndName ( ) ;
152:
153: bool operator== ( const TokenAndName & rhs@var30 ) const {
154: return mToken@var4 ==@expr1073744039 rhs@var30 .@expr1073744040 mToken@var31 &&@expr1073744041 mScope@var5 ==@expr1073744042 rhs@var30 .@expr1073744043 mScope@var32 &&@expr1073744044 mName@var6 ==@expr1073744045 rhs@var30 .@expr1073744046 mName@var33 &&@expr1073744047 mFullName@var7 ==@expr1073744048 rhs@var30 .@expr1073744049 mFullName@var34 &&@expr1073744050
155: mNameToken@var8 ==@expr1073744051 rhs@var30 .@expr1073744052 mNameToken@var35 &&@expr1073744053 mParamEnd@var9 ==@expr1073744054 rhs@var30 .@expr1073744055 mParamEnd@var36 &&@expr1073744056 mFlags@var10 ==@expr1073744057 rhs@var30 .@expr1073744058 mFlags@var37 ;
156: }
157:
158: Token * token ( ) const {
159: return mToken@var4 ;
160: }
161: void token ( Token * token@var38 ) {
162: mToken@var4 =@expr1073744059 token@var38 ;
163: }
164: const std :: string & scope ( ) const {
165: return mScope@var5 ;
166: }
167: const std :: string & name ( ) const {
168: return mName@var6 ;
169: }
170: const std :: string & fullName ( ) const {
171: return mFullName@var7 ;
172: }
173: const Token * nameToken ( ) const {
174: return mNameToken@var8 ;
175: }
176: const Token * paramEnd ( ) const {
177: return mParamEnd@var9 ;
178: }
179: void paramEnd ( const Token * end@var39 ) {
180: mParamEnd@var9 =@expr1073744060 end@var39 ;
181: }
182:
183: bool isClass ( ) const {
184: return getFlag (@expr1073744061 fIsClass ) ;
185: }
186: bool isFunction ( ) const {
187: return getFlag (@expr1073744062 fIsFunction ) ;
188: }
189: bool isVariable ( ) const {
190: return getFlag (@expr1073744063 fIsVariable ) ;
191: }
192: bool isAlias ( ) const {
193: return getFlag (@expr1073744064 fIsAlias ) ;
194: }
195: bool isSpecialization ( ) const {
196: return getFlag (@expr1073744065 fIsSpecialization ) ;
197: }
198: bool isPartialSpecialization ( ) const {
199: return getFlag (@expr1073744066 fIsPartialSpecialization ) ;
200: }
201: bool isForwardDeclaration ( ) const {
202: return getFlag (@expr1073744067 fIsForwardDeclaration ) ;
203: }
204: bool isVariadic ( ) const {
205: return getFlag (@expr1073744068 fIsVariadic ) ;
206: }
207: bool isFriend ( ) const {
208: return getFlag (@expr1073744069 fIsFriend ) ;
209: }
210:
|
216:
217: const Token * aliasStartToken ( ) const ;
218:
|
224:
225: const Token * aliasEndToken ( ) const ;
226:
|
233:
234: bool isAliasToken ( const Token * tok@var40 ) const ;
235:
|
241:
242: bool isSameFamily ( const TemplateSimplifier :: TokenAndName & decl@var41 ) const {
243:
244:
245: return (@expr2246 (@expr2246 mFlags@var10 &@expr1073744072 fFamilyMask ) &@expr1073744073 (@expr2246 decl@var41 .@expr1073744075 mFlags@var42 &@expr1073744076 fFamilyMask ) ) !=@expr1073744077 0 ;
246: }
247: } ;
248:
|
253:
254: static Token * findTemplateDeclarationEnd ( Token * tok@var43 ) ;
255: static const Token * findTemplateDeclarationEnd ( const Token * tok@var44 ) ;
256:
|
264:
265: static bool instantiateMatch ( const Token * instance@var45 , const unsigned long numberOfArguments@var46 , bool variadic@var47 , const char patternAfter@var48 [ ] ) ;
266:
|
272:
273: int getTemplateNamePosition ( const Token * tok@var49 ) ;
274:
|
280:
281: static bool getTemplateNamePositionTemplateClass ( const Token * tok@var50 , int & namepos@var51 ) ;
282:
|
288:
289: static bool getTemplateNamePositionTemplateFunction ( const Token * tok@var52 , int & namepos@var53 ) ;
290:
|
296:
297: static bool getTemplateNamePositionTemplateVariable ( const Token * tok@var54 , int & namepos@var55 ) ;
298:
|
303:
304: void simplifyTemplates (
305: const std :: time_t maxtime@var56 ,
306: bool & codeWithTemplates@var57 ) ;
307:
|
313:
314: static bool simplifyNumericCalculations ( Token * tok@var58 , bool isTemplate@var59 = true ) ;
315:
|
321:
322: bool simplifyCalculations ( Token * frontToken@var60 = nullptr , Token * backToken@var61 = nullptr , bool isTemplate@var62 = true ) ;
323:
|
327:
328: void simplifyTemplateArgs ( Token * start@var63 , Token * end@var64 ) ;
329:
330: private:
331:
|
334:
335: bool getTemplateDeclarations ( ) ;
336:
|
340:
341: void addInstantiation ( Token * token@var65 , const std :: string & scope@var66 ) ;
342:
|
345:
346: void getTemplateInstantiations ( ) ;
347:
|
351:
352: void fixForwardDeclaredDefaultArgumentValues ( ) ;
353:
|
356:
357: void useDefaultArgumentValues ( ) ;
358:
|
362:
363: void useDefaultArgumentValues ( TokenAndName & declaration@var67 ) ;
364:
|
368:
369: void getSpecializations ( ) ;
370:
|
374:
375: void getPartialSpecializations ( ) ;
376:
|
379:
380: void simplifyTemplateAliases ( ) ;
381:
|
390:
391: bool simplifyTemplateInstantiations (
392: const TokenAndName & templateDeclaration@var68 ,
393: const std :: list < const Token * > & specializations@var69 ,
394: const std :: time_t maxtime@var70 ,
395: std :: set < std :: string > & expandedtemplates@var71 ) ;
396:
|
401:
402: void addNamespace ( const TokenAndName & templateDeclaration@var72 , const Token * tok@var73 ) ;
403:
|
409:
410: static bool alreadyHasNamespace ( const TokenAndName & templateDeclaration@var74 , const Token * tok@var75 ) ;
411:
|
419:
420: void expandTemplate (
421: const TokenAndName & templateDeclaration@var76 ,
422: const TokenAndName & templateInstantiation@var77 ,
423: const std :: vector < const Token * > & typeParametersInDeclaration@var78 ,
424: const std :: string & newName@var79 ,
425: bool copy@var80 ) ;
426:
|
432:
433: void replaceTemplateUsage ( const TokenAndName & instantiation@var81 ,
434: const std :: list < std :: string > & typeStringsUsedInTemplateInstantiation@var82 ,
435: const std :: string & newName@var83 ) ;
436:
|
443:
444: static void getTemplateParametersInDeclaration (
445: const Token * tok@var84 ,
446: std :: vector < const Token * > & typeParametersInDeclaration@var85 ) ;
447:
|
450:
451: static bool removeTemplate ( Token * tok@var86 ) ;
452:
453:
454: static void syntaxError ( const Token * tok@var87 ) ;
455:
456: static bool matchSpecialization (
457: const Token * templateDeclarationNameToken@var88 ,
458: const Token * templateInstantiationNameToken@var89 ,
459: const std :: list < const Token * > & specializations@var90 ) ;
460:
|
465:
466: static void eraseTokens ( Token * begin@var91 , const Token * end@var92 ) ;
467:
|
472:
473: static void deleteToken ( Token * tok@var93 ) ;
474:
|
480:
481: std :: string getNewName (
482: Token * tok2@var94 ,
483: std :: list < std :: string > & typeStringsUsedInTemplateInstantiation@var95 ) ;
484:
485: void printOut (
486: const TokenAndName & tokenAndName@var96 ,
487: const std :: string & indent@var97 = "    " ) const ;
488: void printOut ( const std :: string & text@var98 = "" ) const ;
489:
490: Tokenizer * mTokenizer@var99 ;
491: TokenList & mTokenList@var100 ;
492: const Settings * mSettings@var101 ;
493: ErrorLogger * mErrorLogger@var102 ;
494: bool mChanged@var103 ;
495:
496: std :: list < TokenAndName > mTemplateDeclarations@var104 ;
497: std :: list < TokenAndName > mTemplateForwardDeclarations@var105 ;
498: std :: map < Token * , Token * > mTemplateForwardDeclarationsMap@var106 ;
499: std :: map < Token * , Token * > mTemplateSpecializationMap@var107 ;
500: std :: map < Token * , Token * > mTemplatePartialSpecializationMap@var108 ;
501: std :: list < TokenAndName > mTemplateInstantiations@var109 ;
502: std :: list < TokenAndName > mInstantiatedTemplates@var110 ;
503: std :: list < TokenAndName > mMemberFunctionsToDelete@var111 ;
504: std :: vector < TokenAndName > mExplicitInstantiationsToDelete@var112 ;
505: std :: vector < TokenAndName > mTypesUsedInTemplateInstantiation@var113 ;
506: std :: unordered_map < const Token * , int > mTemplateNamePos@var114 ;
507: } ;

##file cppcheck-2.8/lib/errortypes.h

1:
|
31:
32: class Token ;
33:
34:
35: struct InternalError {
36: enum Type { AST , SYNTAX , UNKNOWN_MACRO , INTERNAL , LIMIT , INSTANTIATION } ;
37: InternalError ( const Token * tok@var115 , const std :: string & errorMsg@var116 , Type type@var117 = INTERNAL ) ;
38: const Token * token@var118 ;
39: std :: string errorMessage@var119 ;
40: Type type@var120 ;
41: std :: string id@var121 ;
42: } ;
43:
44: class Certainty {
45: public:
46: enum CertaintyLevel {
47: normal , inconclusive , safe , experimental
48: } ;
49: } ;
50:
51: class Checks {
52: public:
53: enum CheckList {
54: unusedFunction , missingInclude , internalCheck
55: } ;
56: } ;
57:
58:
59: class Severity {
60: public:
61:
62:
63:
64: enum SeverityType {
65:
66:
67:
68: none ,
69:
|
73:
74: error ,
75:
|
79:
80: warning ,
81:
|
86:
87: style ,
88:
|
92:
93: performance ,
94:
|
100:
101: portability ,
102:
|
107:
108: information ,
109:
|
112:
113: debug
114: } ;
115:
116: static std :: string toString ( SeverityType severity@var122 ) ;
117: static SeverityType fromString ( const std :: string & severity@var123 ) ;
118: } ;
119:
120: struct CWE {
121: explicit CWE ( unsigned short cweId@var124 ) : id@var125 ( cweId@var124 ) { }
122: unsigned short id@var125 ;
123: } ;

##file cppcheck-2.8/lib/suppressions.h

1:
|
34:
35: class Tokenizer ;
36:
37:
38: class Suppressions {
39: public:
40:
41: struct ErrorMessage {
42: unsigned long hash@var126 ;
43: std :: string errorId@var127 ;
44: void setFileName ( const std :: string & s@var128 ) ;
45: const std :: string & getFileName ( ) const {
46: return mFileName@var132 ;
47: }
48: int lineNumber@var129 ;
49: Certainty :: CertaintyLevel certainty@var130 ;
50: std :: string symbolNames@var131 ;
51: private:
52: std :: string mFileName@var132 ;
53: } ;
54:
55: struct Suppression {
56: Suppression ( ) : lineNumber@var166 ( NO_LINE ) , hash@var168 ( 0 ) , thisAndNextLine@var169 ( false ) , matched@var170 ( false ) , checked@var171 ( false ) { }
57: Suppression ( const Suppression & other@var133 ) {
58: *@expr1073744078 this@expr1073744079 =@expr1073744080 other@var133 ;
59: }
60: Suppression ( const std :: string & id@var134 , const std :: string & file@var135 , int line@var136 = NO_LINE ) : errorId@var164 ( id@var134 ) , fileName@var165 ( file@var135 ) , lineNumber@var166 ( line@var136 ) , hash@var168 ( 0 ) , thisAndNextLine@var169 ( false ) , matched@var170 ( false ) , checked@var171 ( false ) { }
61:
62: Suppression & operator= ( const Suppression & other@var137 ) {
63: errorId@var164 =@expr1073744081 other@var137 .@expr1073744082 errorId@var138 ;
64: fileName@var165 =@expr1073744083 other@var137 .@expr1073744084 fileName@var139 ;
65: lineNumber@var166 =@expr1073744085 other@var137 .@expr1073744086 lineNumber@var140 ;
66: symbolName@var167 =@expr1073744087 other@var137 .@expr1073744088 symbolName@var141 ;
67: hash@var168 =@expr1073744089 other@var137 .@expr1073744090 hash@var142 ;
68: thisAndNextLine@var169 =@expr1073744091 other@var137 .@expr1073744092 thisAndNextLine@var143 ;
69: matched@var170 =@expr1073744093 other@var137 .@expr1073744094 matched@var144 ;
70: checked@var171 =@expr1073744095 other@var137 .@expr1073744096 checked@var145 ;
71: return *@expr1073744097 this@expr1073744098 ;
72: }
73:
74: bool operator< ( const Suppression & other@var146 ) const {
75: if (@expr1073744099 errorId@var164 !=@expr1073744100 other@var146 .@expr2277 errorId@var147 ) {
76: return errorId@var164 <@expr1073744102 other@var146 .@expr2277 errorId@var147 ; }
77: if (@expr1073744104 lineNumber@var166 <@expr1073744105 other@var146 .@expr1073744106 lineNumber@var148 ) {
78: return true ; }
79: if (@expr1073744107 fileName@var165 !=@expr1073744108 other@var146 .@expr2285 fileName@var149 ) {
80: return fileName@var165 <@expr1073744110 other@var146 .@expr2285 fileName@var149 ; }
81: if (@expr1073744112 symbolName@var167 !=@expr1073744113 other@var146 .@expr2290 symbolName@var150 ) {
82: return symbolName@var167 <@expr1073744115 other@var146 .@expr2290 symbolName@var150 ; }
83: if (@expr1073744117 hash@var168 !=@expr1073744118 other@var146 .@expr2295 hash@var151 ) {
84: return hash@var168 <@expr1073744120 other@var146 .@expr2295 hash@var151 ; }
85: if (@expr1073744122 thisAndNextLine@var169 !=@expr1073744123 other@var146 .@expr1073744124 thisAndNextLine@var152 ) {
86: return thisAndNextLine@var169 ; }
87: return false ;
88: }
89:
|
95:
96: bool parseComment ( std :: string comment@var153 , std :: string * errorMessage@var154 ) ;
97:
98: bool isSuppressed ( const ErrorMessage & errmsg@var155 ) const ;
99:
100: bool isMatch ( const ErrorMessage & errmsg@var156 ) ;
101:
102: std :: string getText ( ) const ;
103:
104: bool isLocal ( ) const {
105: return !@expr1073744126 fileName@var165 .@expr1073744127 empty (@expr1073744128 ) &&@expr1073744129 fileName@var165 .@expr1073744130 find_first_of (@expr1073744131 "?*" ) ==@expr1073744132 std ::@expr1073744133 string ::@expr1073744134 npos@expr1073744125 ;
106: }
107:
108: bool isSameParameters ( const Suppression & other@var157 ) const {
109: return errorId@var164 ==@expr1073744135 other@var157 .@expr1073744136 errorId@var158 &&@expr1073744137
110: fileName@var165 ==@expr1073744138 other@var157 .@expr1073744139 fileName@var159 &&@expr1073744140
111: lineNumber@var166 ==@expr1073744141 other@var157 .@expr1073744142 lineNumber@var160 &&@expr1073744143
112: symbolName@var167 ==@expr1073744144 other@var157 .@expr1073744145 symbolName@var161 &&@expr1073744146
113: hash@var168 ==@expr1073744147 other@var157 .@expr1073744148 hash@var162 &&@expr1073744149
114: thisAndNextLine@var169 ==@expr1073744150 other@var157 .@expr1073744151 thisAndNextLine@var163 ;
115: }
116:
117: std :: string errorId@var164 ;
118: std :: string fileName@var165 ;
119: int lineNumber@var166 ;
120: std :: string symbolName@var167 ;
121: unsigned long hash@var168 ;
122: bool thisAndNextLine@var169 ;
123: bool matched@var170 ;
124: bool checked@var171 ;
125:
126: enum Anonymous1 { NO_LINE = -1 } ;
127: } ;
128:
|
133:
134: std :: string parseFile ( std :: istream & istr@var172 ) ;
135:
|
140:
141: std :: string parseXmlFile ( const char * filename@var173 ) ;
142:
|
148:
149: static std :: vector < Suppression > parseMultiSuppressComment ( const std :: string & comment@var174 , std :: string * errorMessage@var175 ) ;
150:
|
155:
156: std :: string addSuppressionLine ( const std :: string & line@var176 ) ;
157:
|
163:
164: std :: string addSuppression ( const Suppression & suppression@var177 ) ;
165:
|
170:
171: std :: string addSuppressions ( const std :: list < Suppression > & suppressions@var178 ) ;
172:
|
177:
178: bool isSuppressed ( const ErrorMessage & errmsg@var179 ) ;
179:
|
184:
185: bool isSuppressedLocal ( const ErrorMessage & errmsg@var180 ) ;
186:
|
190:
191: void dump ( std :: ostream & out@var181 ) const ;
192:
|
196:
197: std :: list < Suppression > getUnmatchedLocalSuppressions ( const std :: string & file@var182 , const bool unusedFunctionChecking@var183 ) const ;
198:
|
202:
203: std :: list < Suppression > getUnmatchedGlobalSuppressions ( const bool unusedFunctionChecking@var184 ) const ;
204:
|
208:
209: const std :: list < Suppression > & getSuppressions ( ) const ;
210:
|
213:
214: void markUnmatchedInlineSuppressionsAsChecked ( const Tokenizer & tokenizer@var185 ) ;
215:
216: private:
217:
218: std :: list < Suppression > mSuppressions@var186 ;
219: } ;

##file cppcheck-2.8/lib/color.h

1:
|
26:
27: enum class Color {
28: Reset = 0 ,
29: Bold = 1 ,
30: Dim = 2 ,
31: FgRed = 31 ,
32: FgGreen = 32 ,
33: FgBlue = 34 ,
34: FgMagenta = 35 ,
35: FgDefault = 39 ,
36: BgRed = 41 ,
37: BgGreen = 42 ,
38: BgBlue = 44 ,
39: BgDefault = 49
40: } ;
41: std :: ostream & operator<< ( std :: ostream & os@var187 , const Color & c@var188 ) ;
42:
43: std :: string toString ( const Color & c@var189 ) ;

##file cppcheck-2.8/lib/errorlogger.h

1:
|
39:
40: static const struct CWE CWE_USE_OF_UNINITIALIZED_VARIABLE@var190 ( 457U ) ;
41: static const struct CWE CWE_NULL_POINTER_DEREFERENCE@var191 ( 476U ) ;
42: static const struct CWE CWE_USE_OF_POTENTIALLY_DANGEROUS_FUNCTION@var192 ( 676U ) ;
43: static const struct CWE CWE_INCORRECT_CALCULATION@var193 ( 682U ) ;
44: static const struct CWE CWE_EXPIRED_POINTER_DEREFERENCE@var194 ( 825U ) ;
45:
46:
47: class Token ;
48: class TokenList ;
49:
50: namespace tinyxml2 {
51: class XMLElement ;
52: }
53:
|
59:
60: class ErrorMessage {
61: public:
62:
|
66:
67: class FileLocation {
68: public:
69: FileLocation ( )
70: : fileIndex@var210 ( 0 ) , line@var211 ( 0 ) , column@var212 ( 0 ) { }
71:
72: FileLocation ( const std :: string & file@var195 , int line@var196 , unsigned int column@var197 )
73: : fileIndex@var210 ( 0 ) , line@var211 ( line@var196 ) , column@var212 ( column@var197 ) , mOrigFileName@var214 ( file@var195 ) , mFileName@var215 ( file@var195 ) { }
74:
75: FileLocation ( const std :: string & file@var198 , const std :: string & info@var199 , int line@var200 , unsigned int column@var201 )
76: : fileIndex@var210 ( 0 ) , line@var211 ( line@var200 ) , column@var212 ( column@var201 ) , mOrigFileName@var214 ( file@var198 ) , mFileName@var215 ( file@var198 ) , mInfo@var216 ( info@var199 ) { }
77:
78: FileLocation ( const Token * tok@var202 , const TokenList * tokenList@var203 ) ;
79: FileLocation ( const Token * tok@var204 , const std :: string & info@var205 , const TokenList * tokenList@var206 ) ;
80:
|
85:
86: std :: string getfile ( bool convert@var207 = true ) const ;
87:
|
92:
93: std :: string getOrigFile ( bool convert@var208 = true ) const ;
94:
|
98:
99: void setfile ( const std :: string & file@var209 ) ;
100:
|
103:
104: std :: string stringify ( ) const ;
105:
106: unsigned int fileIndex@var210 ;
107: int line@var211 ;
108: unsigned int column@var212 ;
109:
110: std :: string getinfo ( ) const {
111: return mInfo@var216 ;
112: }
113: void setinfo ( const std :: string & i@var213 ) {
114: mInfo@var216 =@expr1073744152 i@var213 ;
115: }
116:
117: private:
118: std :: string mOrigFileName@var214 ;
119: std :: string mFileName@var215 ;
120: std :: string mInfo@var216 ;
121: } ;
122:
123: ErrorMessage ( const std :: list < FileLocation > & callStack@var217 ,
124: const std :: string & file1@var218 ,
125: Severity :: SeverityType severity@var219 ,
126: const std :: string & msg@var220 ,
127: const std :: string & id@var221 , Certainty :: CertaintyLevel certainty@var222 ) ;
128: ErrorMessage ( const std :: list < FileLocation > & callStack@var223 ,
129: const std :: string & file1@var224 ,
130: Severity :: SeverityType severity@var225 ,
131: const std :: string & msg@var226 ,
132: const std :: string & id@var227 ,
133: const CWE & cwe@var228 ,
134: Certainty :: CertaintyLevel certainty@var229 ) ;
135: ErrorMessage ( const std :: list < const Token * > & callstack@var230 ,
136: const TokenList * list@var231 ,
137: Severity :: SeverityType severity@var232 ,
138: const std :: string & id@var233 ,
139: const std :: string & msg@var234 ,
140: Certainty :: CertaintyLevel certainty@var235 ) ;
141: ErrorMessage ( const std :: list < const Token * > & callstack@var236 ,
142: const TokenList * list@var237 ,
143: Severity :: SeverityType severity@var238 ,
144: const std :: string & id@var239 ,
145: const std :: string & msg@var240 ,
146: const CWE & cwe@var241 ,
147: Certainty :: CertaintyLevel certainty@var242 ) ;
148: ErrorMessage ( const std :: list < std :: pair < const Token * , std :: string > > & errorPath@var243 ,
149: const TokenList * tokenList@var244 ,
150: Severity :: SeverityType severity@var245 ,
151: const char id@var246 [ ] ,
152: const std :: string & msg@var247 ,
153: const CWE & cwe@var248 ,
154: Certainty :: CertaintyLevel certainty@var249 ) ;
155: ErrorMessage ( ) ;
156: explicit ErrorMessage ( const tinyxml2 :: XMLElement * const errmsg@var250 ) ;
157:
|
160:
161: std :: string toXML ( ) const ;
162:
163: static std :: string getXMLHeader ( ) ;
164: static std :: string getXMLFooter ( ) ;
165:
|
174:
175: std :: string toString ( bool verbose@var251 ,
176: const std :: string & templateFormat@var252 = emptyString@var1 ,
177: const std :: string & templateLocation@var253 = emptyString@var1 ) const ;
178:
179: std :: string serialize ( ) const ;
180: bool deserialize ( const std :: string & data@var254 ) ;
181:
182: std :: list < FileLocation > callStack@var255 ;
183: std :: string id@var256 ;
184:
185:
186: std :: string file0@var257 ;
187:
188: std :: string function@var258 ;
189:
190: bool incomplete@var259 ;
191:
192: Severity :: SeverityType severity@var260 ;
193: CWE cwe@var261 ;
194: Certainty :: CertaintyLevel certainty@var262 ;
195:
196:
197: unsigned long hash@var263 ;
198:
199:
200: void setmsg ( const std :: string & msg@var264 ) ;
201:
202:
203: const std :: string & shortMessage ( ) const {
204: return mShortMessage@var266 ;
205: }
206:
207:
208: const std :: string & verboseMessage ( ) const {
209: return mVerboseMessage@var267 ;
210: }
211:
212:
213: const std :: string & symbolNames ( ) const {
214: return mSymbolNames@var268 ;
215: }
216:
217: Suppressions :: ErrorMessage toSuppressionsErrorMessage ( ) const ;
218:
219: private:
220: static std :: string fixInvalidChars ( const std :: string & raw@var265 ) ;
221:
222:
223: std :: string mShortMessage@var266 ;
224:
225:
226: std :: string mVerboseMessage@var267 ;
227:
228:
229: std :: string mSymbolNames@var268 ;
230: } ;
231:
|
235:
236: class ErrorLogger {
237: protected:
238: std :: ofstream plistFile@var269 ;
239: public:
240: ErrorLogger ( ) { }
241: virtual ~ ErrorLogger ( ) {
242: if (@expr1073744153 plistFile@var269 .@expr1073744154 is_open (@expr1073744155 ) ) {
243: plistFile@var269 <<@expr1073744156 ErrorLogger ::@expr1073744157 plistFooter (@expr1073744158 ) ;
244: plistFile@var269 .@expr1073744159 close (@expr1073744160 ) ;
245: }
246: }
247:
|
253:
254: virtual void reportOut ( const std :: string & outmsg@var270 , Color c@var271 = Color :: Reset ) = 0 ;
255:
|
261:
262: virtual void reportErr ( const ErrorMessage & msg@var272 ) = 0 ;
263:
|
269:
270: virtual void reportProgress ( const std :: string & filename@var273 , const char stage@var274 [ ] , const unsigned long value@var275 ) {
271: (@expr1073744161 void ) filename@var273 ;
272: (@expr1073744162 void ) stage@var274 ;
273: (@expr1073744163 void ) value@var275 ;
274: }
275:
|
279:
280: virtual void reportInfo ( const ErrorMessage & msg@var276 ) {
281: reportErr (@expr1073744164 msg@var276 ) ;
282: }
283:
|
288:
289: bool reportUnmatchedSuppressions ( const std :: list < Suppressions :: Suppression > & unmatched@var277 ) ;
290:
291: static std :: string callStackToString ( const std :: list < ErrorMessage :: FileLocation > & callStack@var278 ) ;
292:
|
297:
298: static std :: string toxml ( const std :: string & str@var279 ) ;
299:
300: static std :: string plistHeader ( const std :: string & version@var280 , const std :: vector < std :: string > & files@var281 ) ;
301: static std :: string plistData ( const ErrorMessage & msg@var282 ) ;
302: static const char * plistFooter ( ) {
303: return " </array>\r\n</dict>\r\n</plist>"
304:
305: ;
306: }
307: } ;
308:
309:
310: std :: string replaceStr ( std :: string s@var283 , const std :: string & from@var284 , const std :: string & to@var285 ) ;

##file cppcheck-2.8/lib/mathlib.h

1:
|
33:
34: class MathLib {
35: friend class TestMathLib ;
36:
37: public:
38:
39: class value {
40: private:
41: long long mIntValue@var286 ;
42: double mDoubleValue@var287 ;
43: enum class Type { INT , LONG , LONGLONG , FLOAT } ; enum Type mType@var288 ;
44: bool mIsUnsigned@var289 ;
45:
46: void promote ( const value & v@var290 ) ;
47:
48: public:
49: explicit value ( const std :: string & s@var291 ) ;
50: std :: string str ( ) const ;
51: bool isInt ( ) const {
52: return mType@var288 !=@expr1073744165 Type ::@expr1073744166 FLOAT ;
53: }
54: bool isFloat ( ) const {
55: return mType@var288 ==@expr1073744167 Type ::@expr1073744168 FLOAT ;
56: }
57:
58: double getDoubleValue ( ) const {
59: return isFloat (@expr1073744169 ) ?@expr1073744170 mDoubleValue@var287 :@expr1073744171 (@expr1073744172 double ) mIntValue@var286 ;
60: }
61:
62: static value calc ( char op@var292 , const value & v1@var293 , const value & v2@var294 ) ;
63: int compare ( const value & v@var295 ) const ;
64: value add ( int v@var296 ) const ;
65: value shiftLeft ( const value & v@var297 ) const ;
66: value shiftRight ( const value & v@var298 ) const ;
67: } ;
68:
69:
70:
71: static const int bigint_bits@var299 ;
72:
73: static long long toLongNumber ( const std :: string & str@var300 ) ;
74: static unsigned long long toULongNumber ( const std :: string & str@var301 ) ;
75:
76: template < class T > static std :: string toString ( T value@var302 ) {
77: std ::@expr1073744173 ostringstream result@var303 ;
78: result@var303 <<@expr1073744174 value@var302 ;
79: return result@var303 .@expr1073744175 str (@expr1073744176 ) ;
80: }
81: static double toDoubleNumber ( const std :: string & str@var304 ) ;
82:
83: static bool isInt ( const std :: string & str@var305 ) ;
84: static bool isFloat ( const std :: string & str@var306 ) ;
85: static bool isDecimalFloat ( const std :: string & str@var307 ) ;
86: static bool isNegative ( const std :: string & str@var308 ) ;
87: static bool isPositive ( const std :: string & str@var309 ) ;
88: static bool isDec ( const std :: string & str@var310 ) ;
89: static bool isFloatHex ( const std :: string & str@var311 ) ;
90: static bool isIntHex ( const std :: string & str@var312 ) ;
91: static bool isOct ( const std :: string & str@var313 ) ;
92: static bool isBin ( const std :: string & str@var314 ) ;
93:
94: static std :: string getSuffix ( const std :: string & value@var315 ) ;
95:
|
101:
102: static bool isValidIntegerSuffix ( const std :: string & str@var316 , bool supportMicrosoftExtensions@var317 = true ) ;
103:
104: static std :: string add ( const std :: string & first@var318 , const std :: string & second@var319 ) ;
105: static std :: string subtract ( const std :: string & first@var320 , const std :: string & second@var321 ) ;
106: static std :: string multiply ( const std :: string & first@var322 , const std :: string & second@var323 ) ;
107: static std :: string divide ( const std :: string & first@var324 , const std :: string & second@var325 ) ;
108: static std :: string mod ( const std :: string & first@var326 , const std :: string & second@var327 ) ;
109: static std :: string incdec ( const std :: string & var@var328 , const std :: string & op@var329 ) ;
110: static std :: string calculate ( const std :: string & first@var330 , const std :: string & second@var331 , char action@var332 ) ;
111:
112: static std :: string sin ( const std :: string & tok@var333 ) ;
113: static std :: string cos ( const std :: string & tok@var334 ) ;
114: static std :: string tan ( const std :: string & tok@var335 ) ;
115: static std :: string abs ( const std :: string & tok@var336 ) ;
116: static bool isEqual ( const std :: string & first@var337 , const std :: string & second@var338 ) ;
117: static bool isNotEqual ( const std :: string & first@var339 , const std :: string & second@var340 ) ;
118: static bool isGreater ( const std :: string & first@var341 , const std :: string & second@var342 ) ;
119: static bool isGreaterEqual ( const std :: string & first@var343 , const std :: string & second@var344 ) ;
120: static bool isLess ( const std :: string & first@var345 , const std :: string & second@var346 ) ;
121: static bool isLessEqual ( const std :: string & first@var347 , const std :: string & second@var348 ) ;
122: static bool isNullValue ( const std :: string & str@var349 ) ;
123:
|
127:
128: static bool isOctalDigit ( char c@var350 ) ;
129:
130: static unsigned int encodeMultiChar ( const std :: string & str@var351 ) ;
131:
|
136:
137: static bool isDigitSeparator ( const std :: string & iCode@var352 , std :: string :: size_type iPos@var353 ) ;
138: } ;
139:
140: MathLib :: value operator+ ( const MathLib :: value & v1@var354 , const MathLib :: value & v2@var355 ) ;
141: MathLib :: value operator- ( const MathLib :: value & v1@var356 , const MathLib :: value & v2@var357 ) ;
142: MathLib :: value operator* ( const MathLib :: value & v1@var358 , const MathLib :: value & v2@var359 ) ;
143: MathLib :: value operator/ ( const MathLib :: value & v1@var360 , const MathLib :: value & v2@var361 ) ;
144: MathLib :: value operator% ( const MathLib :: value & v1@var362 , const MathLib :: value & v2@var363 ) ;
145: MathLib :: value operator& ( const MathLib :: value & v1@var364 , const MathLib :: value & v2@var365 ) ;
146: MathLib :: value operator| ( const MathLib :: value & v1@var366 , const MathLib :: value & v2@var367 ) ;
147: MathLib :: value operator^ ( const MathLib :: value & v1@var368 , const MathLib :: value & v2@var369 ) ;
148: MathLib :: value operator<< ( const MathLib :: value & v1@var370 , const MathLib :: value & v2@var371 ) ;
149: MathLib :: value operator>> ( const MathLib :: value & v1@var372 , const MathLib :: value & v2@var373 ) ;
150:
151: template < > std :: string MathLib :: toString < double > ( double value@var374 ) ;

##file cppcheck-2.8/lib/platform.h

1:
|
31:
32: namespace tinyxml2 {
33: class XMLDocument ;
34: }
35:
36: namespace cppcheck {
37:
|
40:
41: class Platform {
42: private:
43: static long long min_value ( int bit@var375 ) {
44: if (@expr1073744177 bit@var375 >=@expr1073744178 64 ) {
45: return LLONG_MIN ; }
46: return -@expr1073744179 (@expr1073744180 1LL <<@expr1073744181 (@expr1073744182 bit@var375 -@expr1073744183 1 ) ) ;
47: }
48:
49: static long long max_value ( int bit@var376 ) {
50: if (@expr1073744184 bit@var376 >=@expr1073744185 64 ) {
51: return (@expr2362 ~@expr1073744187 0ULL ) >>@expr1073744188 1 ; }
52: return (@expr2362 1LL <<@expr1073744190 (@expr2362 bit@var376 -@expr1073744192 1 ) ) -@expr1073744193 1LL ;
53: }
54: public:
55: Platform ( ) ;
56: virtual ~ Platform ( ) { }
57:
58: bool isIntValue ( long long value@var377 ) const {
59: return value@var377 >=@expr1073744194 min_value (@expr1073744195 int_bit@var387 ) &&@expr1073744196 value@var377 <=@expr1073744197 max_value (@expr1073744198 int_bit@var387 ) ;
60: }
61:
62: bool isIntValue ( unsigned long long value@var378 ) const {
63: unsigned long long intMax@var379 ; intMax@var379 =@expr1073744199 max_value (@expr1073744200 int_bit@var387 ) ;
64: return value@var378 <=@expr1073744201 intMax@var379 ;
65: }
66:
67: bool isLongValue ( long long value@var380 ) const {
68: return value@var380 >=@expr1073744202 min_value (@expr1073744203 long_bit@var388 ) &&@expr1073744204 value@var380 <=@expr1073744205 max_value (@expr1073744206 long_bit@var388 ) ;
69: }
70:
71: bool isLongValue ( unsigned long long value@var381 ) const {
72: unsigned long long longMax@var382 ; longMax@var382 =@expr1073744207 max_value (@expr1073744208 long_bit@var388 ) ;
73: return value@var381 <=@expr1073744209 longMax@var382 ;
74: }
75:
76: bool isLongLongValue ( unsigned long long value@var383 ) const {
77: unsigned long long longLongMax@var384 ; longLongMax@var384 =@expr1073744210 max_value (@expr1073744211 long_long_bit@var389 ) ;
78: return value@var383 <=@expr1073744212 longLongMax@var384 ;
79: }
80:
81: int char_bit@var385 ;
82: int short_bit@var386 ;
83: int int_bit@var387 ;
84: int long_bit@var388 ;
85: int long_long_bit@var389 ;
86:
87:
88: int sizeof_bool@var390 ;
89: int sizeof_short@var391 ;
90: int sizeof_int@var392 ;
91: int sizeof_long@var393 ;
92: int sizeof_long_long@var394 ;
93: int sizeof_float@var395 ;
94: int sizeof_double@var396 ;
95: int sizeof_long_double@var397 ;
96: int sizeof_wchar_t@var398 ;
97: int sizeof_size_t@var399 ;
98: int sizeof_pointer@var400 ;
99:
100: char defaultSign@var401 ;
101:
102: enum PlatformType {
103: Unspecified ,
104: Native ,
105: Win32A ,
106: Win32W ,
107: Win64 ,
108: Unix32 ,
109: Unix64 ,
110: PlatformFile
111: } ;
112:
113:
114: PlatformType platformType@var402 ;
115:
116:
117: bool platform ( PlatformType type@var403 ) ;
118:
|
124:
125: bool loadPlatformFile ( const char exename@var404 [ ] , const std :: string & filename@var405 ) ;
126:
127:
128: bool loadFromXmlDocument ( const tinyxml2 :: XMLDocument * doc@var406 ) ;
129:
|
133:
134: bool isWindowsPlatform ( ) const {
135: return platformType@var402 ==@expr1073744213 Win32A ||@expr1073744214
136: platformType@var402 ==@expr1073744215 Win32W ||@expr1073744216
137: platformType@var402 ==@expr1073744217 Win64 ;
138: }
139:
140: const char * platformString ( ) const {
141: return platformString (@expr1073744218 platformType@var402 ) ;
142: }
143:
144: static const char * platformString ( PlatformType pt@var407 ) {
145: switch (@expr1073744219 pt@var407 ) {
146: case Unspecified :@expr2396 ;
147: return "Unspecified" ;
148: case Native :@expr2396 ;
149: return "Native" ;
150: case Win32A :@expr2396 ;
151: return "win32A" ;
152: case Win32W :@expr2396 ;
153: return "win32W" ;
154: case Win64 :@expr2396 ;
155: return "win64" ;
156: case Unix32 :@expr2396 ;
157: return "unix32" ;
158: case Unix64 :@expr2396 ;
159: return "unix64" ;
160: case PlatformFile :@expr2396 ;
161: return "platformFile" ;
162: default :@expr2396 ;
163: return "unknown" ;
164: }
165: }
166:
167: long long unsignedCharMax ( ) const {
168: return max_value (@expr1073744229 char_bit@var385 +@expr1073744230 1 ) ;
169: }
170:
171: long long signedCharMax ( ) const {
172: return max_value (@expr1073744231 char_bit@var385 ) ;
173: }
174:
175: long long signedCharMin ( ) const {
176: return min_value (@expr1073744232 char_bit@var385 ) ;
177: }
178: } ;
179:
180: }

##file cppcheck-2.8/lib/utils.h

1:
|
31:
32: struct SelectMapKeys {
33: template < class Pair >
34: Pair :: first_type operator() ( const Pair & p@var408 ) const {
35: return p@var408 .@expr1073744233 first@var409 ;
36: }
37: } ;
38:
39: struct SelectMapValues {
40: template < class Pair >
41: Pair :: second_type operator() ( const Pair & p@var410 ) const {
42: return p@var410 .@expr1073744234 second@var411 ;
43: }
44: } ;
45:
46: template < class Range , class T >
47: bool contains ( const Range & r@var412 , const T & x@var413 )
48: {
49: return std ::@expr1073744235 find (@expr1073744236 r@var412 .@expr1073744237 begin (@expr1073744238 ) , r@var412 .@expr2415 end (@expr2416 ) , x@var413 ) !=@expr1073744241 r@var412 .@expr2415 end (@expr2416 ) ;
50: }
51:
52: template < class T >
53: bool contains ( const std :: initializer_list < T > & r@var414 , const T & x@var415 )
54: {
55: return std ::@expr1073744244 find (@expr1073744245 r@var414 .@expr1073744246 begin (@expr1073744247 ) , r@var414 .@expr2424 end (@expr2425 ) , x@var415 ) !=@expr1073744250 r@var414 .@expr2424 end (@expr2425 ) ;
56: }
57:
58: template < class T , class U >
59: bool contains ( const std :: initializer_list < T > & r@var416 , const U & x@var417 )
60: {
61: return std ::@expr1073744253 find (@expr1073744254 r@var416 .@expr1073744255 begin (@expr1073744256 ) , r@var416 .@expr2433 end (@expr2434 ) , x@var417 ) !=@expr1073744259 r@var416 .@expr2433 end (@expr2434 ) ;
62: }
63:
64:
65: struct EnumClassHash {
66: template < typename T >
67: unsigned long operator() ( T t@var418 ) const
68: {
69: return static_cast < unsigned long > (@expr1073744262 t@var418 ) ;
70: }
71: } ;
72:
73: bool endsWith ( const std :: string & str@var419 , char c@var420 )
74: {
75: return !@expr1073744263 str@var419 .@expr1073744264 empty (@expr1073744265 ) &&@expr1073744266 str@var419 .@expr1073744267 back (@expr1073744268 ) ==@expr1073744269 c@var420 ;
76: }
77:
78: bool endsWith ( const std :: string & str@var421 , const char end@var422 [ ] , unsigned long endlen@var423 )
79: {
80: return (@expr2446 str@var421 .@expr2447 size (@expr2448 ) >=@expr1073744273 endlen@var423 ) &&@expr1073744274 (@expr2446 str@var421 .@expr1073744276 compare (@expr1073744277 str@var421 .@expr2447 size (@expr2448 ) -@expr1073744280 endlen@var423 , endlen@var423 , end@var422 ) ==@expr1073744281 0 ) ;
81: }
82:
83: template < unsigned long N >
84: bool endsWith ( const std :: string & str@var424 , const char ( & end@var425 ) [ N ] )
85: {
86: return endsWith (@expr1073744283 str@var424 , end@var425 , N@expr1073744282 -@expr1073744284 1 ) ;
87: }
88:
89: static bool isPrefixStringCharLiteral ( const std :: string & str@var426 , char q@var427 , const std :: string & p@var428 )
90: {
91: if (@expr1073744285 !@expr1073744286 endsWith (@expr1073744287 str@var426 , q@var427 ) ) {
92: return false ; }
93: if (@expr1073744288 (@expr1073744289 str@var426 .@expr1073744290 length (@expr1073744291 ) +@expr1073744292 1 ) >@expr1073744293 p@var428 .@expr1073744294 length (@expr1073744295 ) &&@expr1073744296 (@expr1073744297 str@var426 .@expr1073744298 compare (@expr1073744299 0 , p@var428 .@expr1073744300 size (@expr1073744301 ) +@expr1073744302 1 , p@var428 +@expr1073744303 q@var427 ) ==@expr1073744304 0 ) ) {
94: return true ; }
95: return false ;
96: }
97:
98: static bool isStringCharLiteral ( const std :: string & str@var429 , char q@var430 )
99: {
100: static const std ::@expr2481 vector < std ::@expr2481 string > suffixes@var431 {@expr1073744307 "" , "u8" , "u" , "U" , "L" } ;
101: for (@expr1073744308 const std ::@expr2481 string &@expr1073744310 p@var432 :@expr1073744311 suffixes@var431 ) {
102: if (@expr1073744312 isPrefixStringCharLiteral (@expr1073744313 str@var429 , q@var430 , p@var432 ) ) {
103: return true ; }
104: }
105: return false ;
106: }
107:
108: static bool isStringLiteral ( const std :: string & str@var433 )
109: {
110: return isStringCharLiteral (@expr1073744314 str@var433 , '"' ) ;
111: }
112:
113: static bool isCharLiteral ( const std :: string & str@var434 )
114: {
115: return isStringCharLiteral (@expr1073744315 str@var434 , '\'' ) ;
116: }
117:
118: static std :: string getStringCharLiteral ( const std :: string & str@var435 , char q@var436 )
119: {
120: const unsigned long quotePos@var437 =@expr1073744316 str@var435 .@expr1073744317 find (@expr1073744318 q@var436 ) ;
121: return str@var435 .@expr1073744319 substr (@expr1073744320 quotePos@var437 +@expr1073744321 1U , str@var435 .@expr1073744322 size (@expr1073744323 ) -@expr1073744324 quotePos@var437 -@expr1073744325 2U ) ;
122: }
123:
124: static std :: string getStringLiteral ( const std :: string & str@var438 )
125: {
126: if (@expr1073744326 isStringLiteral (@expr1073744327 str@var438 ) ) {
127: return getStringCharLiteral (@expr1073744328 str@var438 , '"' ) ; }
128: return "" ;
129: }
130:
131: static std :: string getCharLiteral ( const std :: string & str@var439 )
132: {
133: if (@expr1073744329 isCharLiteral (@expr1073744330 str@var439 ) ) {
134: return getStringCharLiteral (@expr1073744331 str@var439 , '\'' ) ; }
135: return "" ;
136: }
137:
138: static const char * getOrdinalText ( int i@var440 )
139: {
140: if (@expr1073744332 i@var440 ==@expr1073744333 1 ) {
141: return "st" ; }
142: if (@expr1073744334 i@var440 ==@expr1073744335 2 ) {
143: return "nd" ; }
144: if (@expr1073744336 i@var440 ==@expr1073744337 3 ) {
145: return "rd" ; }
146: return "th" ;
147: }
148:
149: int caseInsensitiveStringCompare ( const std :: string & lhs@var441 , const std :: string & rhs@var442 ) ;
150:
151: bool isValidGlobPattern ( const std :: string & pattern@var443 ) ;
152:
153: bool matchglob ( const std :: string & pattern@var444 , const std :: string & name@var445 ) ;
154:
155: bool matchglobs ( const std :: vector < std :: string > & patterns@var446 , const std :: string & name@var447 ) ;
156:
157: void strTolower ( std :: string & str@var448 ) ;

##file cppcheck-2.8/lib/importproject.h

1:
|
37:
38: namespace cppcheck {
39: struct stricmp {
40: bool operator() ( const std :: string & lhs@var449 , const std :: string & rhs@var450 ) const {
41: return caseInsensitiveStringCompare (@expr1073744338 lhs@var449 , rhs@var450 ) <@expr1073744339 0 ;
42: }
43: } ;
44: }
45:
46: class Settings ;
47:
|
50:
51: class ImportProject {
52: public:
53: enum class Type {
54: UNKNOWN ,
55: MISSING ,
56: FAILURE ,
57: COMPILE_DB ,
58: VS_SLN ,
59: VS_VCXPROJ ,
60: BORLAND ,
61: CPPCHECK_GUI
62: } ;
63:
64:
65: struct FileSettings {
66: FileSettings ( ) : platformType@var458 ( cppcheck :: Platform :: Unspecified ) , msc@var459 ( false ) , useMfc@var460 ( false ) { }
67: std :: string cfg@var451 ;
68: std :: string filename@var452 ;
69: std :: string defines@var453 ;
70: std :: string cppcheckDefines ( ) const {
71: return defines@var453 +@expr1073744340 (@expr1073744341 msc@var459 ?@expr1073744342 ";_MSC_VER=1900" :@expr1073744343 "" ) +@expr1073744344 (@expr1073744345 useMfc@var460 ?@expr1073744346 ";__AFXWIN_H__=1" :@expr1073744347 "" ) ;
72: }
73: std :: set < std :: string > undefs@var454 ;
74: std :: list < std :: string > includePaths@var455 ;
75: std :: list < std :: string > systemIncludePaths@var456 ;
76: std :: string standard@var457 ;
77: cppcheck :: Platform :: PlatformType platformType@var458 ;
78: bool msc@var459 ;
79: bool useMfc@var460 ;
80:
81: void parseCommand ( std :: string command@var461 ) ;
82: void setDefines ( std :: string defs@var462 ) ;
83: void setIncludePaths ( const std :: string & basepath@var463 , const std :: list < std :: string > & in@var464 , std :: map < std :: string , std :: string , cppcheck :: stricmp > & variables@var465 ) ;
84: } ;
85: std :: list < FileSettings > fileSettings@var466 ;
86: Type projectType@var467 ;
87:
88: ImportProject ( ) ;
89:
90: void selectOneVsConfig ( cppcheck :: Platform :: PlatformType platform@var468 ) ;
91:
92: std :: list < std :: string > getVSConfigs ( ) ;
93:
94:
95: struct Anonymous2 {
96: std :: string analyzeAllVsConfigs@var469 ;
97: std :: vector < std :: string > pathNames@var470 ;
98: std :: list < std :: string > libraries@var471 ;
99: std :: list < std :: string > excludedPaths@var472 ;
100: std :: list < std :: string > checkVsConfigs@var473 ;
101: std :: string projectFile@var474 ;
102: std :: string platform@var475 ;
103: } ; struct Anonymous2 guiProject@var476 ;
104:
105: void ignorePaths ( const std :: vector < std :: string > & ipaths@var477 ) ;
106: void ignoreOtherConfigs ( const std :: string & cfg@var478 ) ;
107:
108: Type import ( const std :: string & filename@var479 , Settings * settings@var480 = nullptr ) ;
109: protected:
110: bool importCompileCommands ( std :: istream & istr@var481 ) ;
111: bool importCppcheckGuiProject ( std :: istream & istr@var482 , Settings * settings@var483 ) ;
112: virtual bool sourceFileExists ( const std :: string & file@var484 ) ;
113: private:
114: bool importSln ( std :: istream & istr@var485 , const std :: string & path@var486 , const std :: vector < std :: string > & fileFilters@var487 ) ;
115: bool importVcxproj ( const std :: string & filename@var488 , std :: map < std :: string , std :: string , cppcheck :: stricmp > & variables@var489 , const std :: string & additionalIncludeDirectories@var490 , const std :: vector < std :: string > & fileFilters@var491 ) ;
116: bool importBcb6Prj ( const std :: string & projectFilename@var492 ) ;
117:
118: static void printError ( const std :: string & message@var493 ) ;
119:
120: void setRelativePaths ( const std :: string & filename@var494 ) ;
121:
122: std :: string mPath@var495 ;
123: std :: set < std :: string > mAllVSConfigs@var496 ;
124: } ;
125:
126:
127: namespace CppcheckXml {
128: const char ProjectElementName@var497 [ 8 ] = "project" ;
129: const char ProjectVersionAttrib@var498 [ 8 ] = "version" ;
130: const char ProjectFileVersion@var499 [ 2 ] = "1" ;
131: const char BuildDirElementName@var500 [ 9 ] = "builddir" ;
132: const char ImportProjectElementName@var501 [ 14 ] = "importproject" ;
133: const char AnalyzeAllVsConfigsElementName@var502 [ 23 ] = "analyze-all-vs-configs" ;
134: const char Parser@var503 [ 7 ] = "parser" ;
135: const char BugHunting@var504 [ 12 ] = "bug-hunting" ;
136: const char IncludeDirElementName@var505 [ 11 ] = "includedir" ;
137: const char DirElementName@var506 [ 4 ] = "dir" ;
138: const char DirNameAttrib@var507 [ 5 ] = "name" ;
139: const char DefinesElementName@var508 [ 8 ] = "defines" ;
140: const char DefineName@var509 [ 7 ] = "define" ;
141: const char DefineNameAttrib@var510 [ 5 ] = "name" ;
142: const char UndefinesElementName@var511 [ 10 ] = "undefines" ;
143: const char UndefineName@var512 [ 9 ] = "undefine" ;
144: const char PathsElementName@var513 [ 6 ] = "paths" ;
145: const char PathName@var514 [ 4 ] = "dir" ;
146: const char PathNameAttrib@var515 [ 5 ] = "name" ;
147: const char RootPathName@var516 [ 5 ] = "root" ;
148: const char RootPathNameAttrib@var517 [ 5 ] = "name" ;
149: const char IgnoreElementName@var518 [ 7 ] = "ignore" ;
150: const char IgnorePathName@var519 [ 5 ] = "path" ;
151: const char IgnorePathNameAttrib@var520 [ 5 ] = "name" ;
152: const char ExcludeElementName@var521 [ 8 ] = "exclude" ;
153: const char ExcludePathName@var522 [ 5 ] = "path" ;
154: const char ExcludePathNameAttrib@var523 [ 5 ] = "name" ;
155: const char FunctionContracts@var524 [ 19 ] = "function-contracts" ;
156: const char VariableContractsElementName@var525 [ 19 ] = "variable-contracts" ;
157: const char LibrariesElementName@var526 [ 10 ] = "libraries" ;
158: const char LibraryElementName@var527 [ 8 ] = "library" ;
159: const char PlatformElementName@var528 [ 9 ] = "platform" ;
160: const char SuppressionsElementName@var529 [ 13 ] = "suppressions" ;
161: const char SuppressionElementName@var530 [ 12 ] = "suppression" ;
162: const char AddonElementName@var531 [ 6 ] = "addon" ;
163: const char AddonsElementName@var532 [ 7 ] = "addons" ;
164: const char ToolElementName@var533 [ 5 ] = "tool" ;
165: const char ToolsElementName@var534 [ 6 ] = "tools" ;
166: const char TagsElementName@var535 [ 5 ] = "tags" ;
167: const char TagElementName@var536 [ 4 ] = "tag" ;
168: const char TagWarningsElementName@var537 [ 13 ] = "tag-warnings" ;
169: const char TagAttributeName@var538 [ 4 ] = "tag" ;
170: const char WarningElementName@var539 [ 8 ] = "warning" ;
171: const char HashAttributeName@var540 [ 5 ] = "hash" ;
172: const char CheckHeadersElementName@var541 [ 14 ] = "check-headers" ;
173: const char CheckUnusedTemplatesElementName@var542 [ 23 ] = "check-unused-templates" ;
174: const char MaxCtuDepthElementName@var543 [ 14 ] = "max-ctu-depth" ;
175: const char MaxTemplateRecursionElementName@var544 [ 23 ] = "max-template-recursion" ;
176: const char CheckUnknownFunctionReturn@var545 [ 37 ] = "check-unknown-function-return-values" ;
177: const char ClangTidy@var546 [ 11 ] = "clang-tidy" ;
178: const char Name@var547 [ 5 ] = "name" ;
179: const char VSConfigurationElementName@var548 [ 18 ] = "vs-configurations" ;
180: const char VSConfigurationName@var549 [ 7 ] = "config" ;
181: }

##file cppcheck-2.8/lib/standards.h

1:
|
35:
36: struct Standards {
37:
38: enum cstd_t { C89 , C99 , C11 , CLatest = C11 } ; enum cstd_t c@var550 ;
39:
40:
41: enum cppstd_t { CPP03 , CPP11 , CPP14 , CPP17 , CPP20 , CPP23 , CPPLatest = CPP23 } ; enum cppstd_t cpp@var551 ;
42:
43:
44: std :: string stdValue@var552 ;
45:
46:
47: Standards ( ) : c@var550 ( CLatest ) , cpp@var551 ( CPPLatest ) { }
48:
49: bool setC ( const std :: string & str@var553 ) {
50: stdValue@var552 =@expr1073744348 str@var553 ;
51: if (@expr1073744349 str@var553 ==@expr1073744350 "c89" ||@expr1073744351 str@var553 ==@expr1073744352 "C89" ) {
52: c@var550 =@expr1073744353 C89 ;
53: return true ;
54: }
55: if (@expr1073744354 str@var553 ==@expr1073744355 "c99" ||@expr1073744356 str@var553 ==@expr1073744357 "C99" ) {
56: c@var550 =@expr1073744358 C99 ;
57: return true ;
58: }
59: if (@expr1073744359 str@var553 ==@expr1073744360 "c11" ||@expr1073744361 str@var553 ==@expr1073744362 "C11" ) {
60: c@var550 =@expr1073744363 C11 ;
61: return true ;
62: }
63: return false ;
64: }
65: const std :: string getC ( ) const {
66: switch (@expr1073744364 c@var550 ) {
67: case C89 :@expr2541 ;
68: return "c89" ;
69: case C99 :@expr2541 ;
70: return "c99" ;
71: case C11 :@expr2541 ;
72: return "c11" ;
73: }
74: return "" ;
75: }
76: static cstd_t getC ( const std :: string & std@var554 ) {
77: if (@expr1073744368 std@var554 ==@expr1073744369 "c89" ) {
78: return Standards ::@expr1073744370 C89 ;
79: }
80: if (@expr1073744371 std@var554 ==@expr1073744372 "c99" ) {
81: return Standards ::@expr1073744373 C99 ;
82: }
83: if (@expr1073744374 std@var554 ==@expr1073744375 "c11" ) {
84: return Standards ::@expr1073744376 C11 ;
85: }
86: return Standards ::@expr1073744377 CLatest ;
87: }
88: bool setCPP ( std :: string str@var555 ) {
89: stdValue@var552 =@expr1073744378 str@var555 ;
90: strTolower (@expr1073744379 str@var555 ) ;
91: cpp@var551 =@expr1073744380 getCPP (@expr1073744381 str@var555 ) ;
92: return !@expr1073744382 stdValue@var552 .@expr1073744383 empty (@expr1073744384 ) &&@expr1073744385 str@var555 ==@expr1073744386 getCPP (@expr1073744387 ) ;
93: }
94: std :: string getCPP ( ) const {
95: return getCPP (@expr1073744388 cpp@var551 ) ;
96: }
97: static std :: string getCPP ( cppstd_t std@var556 ) {
98: switch (@expr1073744389 std@var556 ) {
99: case CPP03 :@expr2566 ;
100: return "c++03" ;
101: case CPP11 :@expr2566 ;
102: return "c++11" ;
103: case CPP14 :@expr2566 ;
104: return "c++14" ;
105: case CPP17 :@expr2566 ;
106: return "c++17" ;
107: case CPP20 :@expr2566 ;
108: return "c++20" ;
109: case CPP23 :@expr2566 ;
110: return "c++23" ;
111: }
112: return "" ;
113: }
114: static cppstd_t getCPP ( const std :: string & std@var557 ) {
115: if (@expr1073744396 std@var557 ==@expr1073744397 "c++03" ) {
116: return Standards ::@expr1073744398 CPP03 ;
117: }
118: if (@expr1073744399 std@var557 ==@expr1073744400 "c++11" ) {
119: return Standards ::@expr1073744401 CPP11 ;
120: }
121: if (@expr1073744402 std@var557 ==@expr1073744403 "c++14" ) {
122: return Standards ::@expr1073744404 CPP14 ;
123: }
124: if (@expr1073744405 std@var557 ==@expr1073744406 "c++17" ) {
125: return Standards ::@expr1073744407 CPP17 ;
126: }
127: if (@expr1073744408 std@var557 ==@expr1073744409 "c++20" ) {
128: return Standards ::@expr1073744410 CPP20 ;
129: }
130: if (@expr1073744411 std@var557 ==@expr1073744412 "c++23" ) {
131: return Standards ::@expr1073744413 CPP23 ;
132: }
133: return Standards ::@expr1073744414 CPPLatest ;
134: }
135: } ;

##file cppcheck-2.8/lib/library.h

1:
|
37:
38: class Token ;
39: class Settings ;
40:
41: namespace tinyxml2 {
42: class XMLDocument ;
43: class XMLElement ;
44: }
45:
|
51:
52: class Library {
53: friend class TestSymbolDatabase ;
54:
55: public:
56: Library ( ) ;
57:
58: enum class ErrorCode { OK , FILE_NOT_FOUND , BAD_XML , UNKNOWN_ELEMENT , MISSING_ATTRIBUTE , BAD_ATTRIBUTE_VALUE , UNSUPPORTED_FORMAT , DUPLICATE_PLATFORM_TYPE , PLATFORM_TYPE_REDEFINED } ;
59:
60: class Error {
61: public:
62: Error ( ) : errorcode@var561 ( ErrorCode :: OK ) { }
63: explicit Error ( ErrorCode e@var558 ) : errorcode@var561 ( e@var558 ) { }
64: template < typename T >
65: Error ( ErrorCode e@var559 , T && r@var560 ) : errorcode@var561 ( e@var559 ) , reason@var562 ( r@var560 ) { }
66: ErrorCode errorcode@var561 ;
67: std :: string reason@var562 ;
68: } ;
69:
70: Error load ( const char exename@var563 [ ] , const char path@var564 [ ] ) ;
71: Error load ( const tinyxml2 :: XMLDocument & doc@var565 ) ;
72:
73:
74: bool loadxmldata ( const char xmldata@var566 [ ] , unsigned long len@var567 ) ;
75:
76: struct AllocFunc {
77: int groupId@var568 ;
78: int arg@var569 ;
79: enum class BufferSize { none , malloc , calloc , strdup } ;
80: BufferSize bufferSize@var570 ;
81: int bufferSizeArg1@var571 ;
82: int bufferSizeArg2@var572 ;
83: int reallocArg@var573 ;
84: bool initData@var574 ;
85: } ;
86:
87:
88: const AllocFunc * getAllocFuncInfo ( const Token * tok@var575 ) const ;
89:
90:
91: const AllocFunc * getDeallocFuncInfo ( const Token * tok@var576 ) const ;
92:
93:
94: const AllocFunc * getReallocFuncInfo ( const Token * tok@var577 ) const ;
95:
96:
97: int getAllocId ( const Token * tok@var578 , int arg@var579 ) const ;
98:
99:
100: int getDeallocId ( const Token * tok@var580 , int arg@var581 ) const ;
101:
102:
103: int getReallocId ( const Token * tok@var582 , int arg@var583 ) const ;
104:
105:
106: const AllocFunc * getAllocFuncInfo ( const char name@var584 [ ] ) const {
107: return getAllocDealloc (@expr1073744415 mAlloc@var850 , name@var584 ) ;
108: }
109:
110:
111: const AllocFunc * getDeallocFuncInfo ( const char name@var585 [ ] ) const {
112: return getAllocDealloc (@expr1073744416 mDealloc@var851 , name@var585 ) ;
113: }
114:
115:
116: int allocId ( const char name@var586 [ ] ) const {
117: const AllocFunc * af@var587 ; af@var587 =@expr1073744417 getAllocDealloc (@expr1073744418 mAlloc@var850 , name@var586 ) ;
118: return af@var587 ?@expr1073744419 af@var587 .@expr1073744420 groupId@var588 :@expr1073744421 0 ;
119: }
120:
121:
122: int deallocId ( const char name@var589 [ ] ) const {
123: const AllocFunc * af@var590 ; af@var590 =@expr1073744422 getAllocDealloc (@expr1073744423 mDealloc@var851 , name@var589 ) ;
124: return af@var590 ?@expr1073744424 af@var590 .@expr1073744425 groupId@var591 :@expr1073744426 0 ;
125: }
126:
127:
128: void setalloc ( const std :: string & functionname@var592 , int id@var593 , int arg@var594 ) {
129: mAlloc@var850 [@expr2603 functionname@var592 ] .@expr1073744428 groupId@var2204 =@expr1073744429 id@var593 ;
130: mAlloc@var850 [@expr2603 functionname@var592 ] .@expr1073744431 arg@var2205 =@expr1073744432 arg@var594 ;
131: }
132:
133: void setdealloc ( const std :: string & functionname@var595 , int id@var596 , int arg@var597 ) {
134: mDealloc@var851 [@expr2609 functionname@var595 ] .@expr1073744434 groupId@var2206 =@expr1073744435 id@var596 ;
135: mDealloc@var851 [@expr2609 functionname@var595 ] .@expr1073744437 arg@var2207 =@expr1073744438 arg@var597 ;
136: }
137:
138: void setrealloc ( const std :: string & functionname@var598 , int id@var599 , int arg@var600 , int reallocArg@var601 = 1 ) {
139: mRealloc@var852 [@expr2615 functionname@var598 ] .@expr1073744440 groupId@var2208 =@expr1073744441 id@var599 ;
140: mRealloc@var852 [@expr2615 functionname@var598 ] .@expr1073744443 arg@var2209 =@expr1073744444 arg@var600 ;
141: mRealloc@var852 [@expr2615 functionname@var598 ] .@expr1073744446 reallocArg@var2210 =@expr1073744447 reallocArg@var601 ;
142: }
143:
144:
145: void setnoreturn ( const std :: string & funcname@var602 , bool noreturn@var603 ) {
146: mNoReturn@var853 [@expr1073744448 funcname@var602 ] =@expr1073744449 noreturn@var603 ?@expr1073744450 FalseTrueMaybe ::@expr1073744451 True :@expr1073744452 FalseTrueMaybe ::@expr1073744453 False ;
147: }
148:
149: static bool isCompliantValidationExpression ( const char * p@var604 ) ;
150:
151:
152: static bool ismemory ( const int id@var605 ) {
153: return (@expr2630 (@expr2630 id@var605 >@expr1073744456 0 ) &&@expr1073744457 (@expr2630 (@expr2630 id@var605 &@expr1073744460 1 ) ==@expr1073744461 0 ) ) ;
154: }
155: static bool ismemory ( const AllocFunc * const func@var606 ) {
156: return (@expr2638 (@expr2638 func@var606 .@expr2640 groupId@var607 >@expr1073744465 0 ) &&@expr1073744466 (@expr2638 (@expr2638 func@var606 .@expr2640 groupId@var607 &@expr1073744470 1 ) ==@expr1073744471 0 ) ) ;
157: }
158:
159:
160: static bool isresource ( const int id@var608 ) {
161: return (@expr2648 (@expr2648 id@var608 >@expr1073744474 0 ) &&@expr1073744475 (@expr2648 (@expr2648 id@var608 &@expr1073744478 1 ) ==@expr1073744479 1 ) ) ;
162: }
163: static bool isresource ( const AllocFunc * const func@var609 ) {
164: return (@expr2656 (@expr2656 func@var609 .@expr2658 groupId@var610 >@expr1073744483 0 ) &&@expr1073744484 (@expr2656 (@expr2656 func@var609 .@expr2658 groupId@var610 &@expr1073744488 1 ) ==@expr1073744489 1 ) ) ;
165: }
166:
167: bool formatstr_function ( const Token * ftok@var611 ) const ;
168: int formatstr_argno ( const Token * ftok@var612 ) const ;
169: bool formatstr_scan ( const Token * ftok@var613 ) const ;
170: bool formatstr_secure ( const Token * ftok@var614 ) const ;
171:
172: struct NonOverlappingData {
173: int ptr1Arg@var615 ;
174: int ptr2Arg@var616 ;
175: int sizeArg@var617 ;
176: int strlenArg@var618 ;
177: } ;
178: const NonOverlappingData * getNonOverlappingData ( const Token * ftok@var619 ) const ;
179:
180: struct WarnInfo {
181: std :: string message@var620 ;
182: Standards standards@var621 ;
183: Severity :: SeverityType severity@var622 ;
184: } ;
185: std :: map < std :: string , WarnInfo > functionwarn@var623 ;
186:
187: const WarnInfo * getWarnInfo ( const Token * ftok@var624 ) const ;
188:
189:
190: bool isNotLibraryFunction ( const Token * ftok@var625 ) const ;
191: bool matchArguments ( const Token * ftok@var626 , const std :: string & functionName@var627 ) const ;
192:
193: enum class UseRetValType { NONE , DEFAULT , ERROR_CODE } ;
194: UseRetValType getUseRetValType ( const Token * ftok@var628 ) const ;
195:
196: const std :: string & returnValue ( const Token * ftok@var629 ) const ;
197: const std :: string & returnValueType ( const Token * ftok@var630 ) const ;
198: int returnValueContainer ( const Token * ftok@var631 ) const ;
199: std :: vector < long long > unknownReturnValues ( const Token * ftok@var632 ) const ;
200:
201: bool isnoreturn ( const Token * ftok@var633 ) const ;
202: bool isnotnoreturn ( const Token * ftok@var634 ) const ;
203:
204: bool isScopeNoReturn ( const Token * end@var635 , std :: string * unknownFunc@var636 ) const ;
205:
206: class Container {
207: public:
208: Container ( )
209: : type_templateArgNo@var646 ( -1 ) ,
210: size_templateArgNo@var648 ( -1 ) ,
211: arrayLike_indexOp@var649 ( false ) ,
212: stdStringLike@var650 ( false ) ,
213: stdAssociativeLike@var651 ( false ) ,
214: opLessAllowed@var652 ( true ) ,
215: hasInitializerListConstructor@var653 ( false ) ,
216: unstableErase@var654 ( false ) ,
217: unstableInsert@var655 ( false ) ,
218: view@var656 ( false )
219: { }
220:
221: enum class Action {
222: RESIZE ,
223: CLEAR ,
224: PUSH ,
225: POP ,
226: FIND ,
227: INSERT ,
228: ERASE ,
229: CHANGE_CONTENT ,
230: CHANGE ,
231: CHANGE_INTERNAL ,
232: NO_ACTION
233: } ;
234: enum class Yield {
235: AT_INDEX ,
236: ITEM ,
237: BUFFER ,
238: BUFFER_NT ,
239: START_ITERATOR ,
240: END_ITERATOR ,
241: ITERATOR ,
242: SIZE ,
243: EMPTY ,
244: NO_YIELD
245: } ;
246: struct Function {
247: Action action@var637 ;
248: Yield yield@var638 ;
249: } ;
250: struct RangeItemRecordTypeItem {
251: std :: string name@var639 ;
252: int templateParameter@var640 ;
253: } ;
254: std :: string startPattern@var641 ; std :: string startPattern2@var642 ; std :: string endPattern@var643 ; std :: string itEndPattern@var644 ;
255: std :: map < std :: string , Function > functions@var645 ;
256: int type_templateArgNo@var646 ;
257: std :: vector < RangeItemRecordTypeItem > rangeItemRecordType@var647 ;
258: int size_templateArgNo@var648 ;
259: bool arrayLike_indexOp@var649 ;
260: bool stdStringLike@var650 ;
261: bool stdAssociativeLike@var651 ;
262: bool opLessAllowed@var652 ;
263: bool hasInitializerListConstructor@var653 ;
264: bool unstableErase@var654 ;
265: bool unstableInsert@var655 ;
266: bool view@var656 ;
267:
268: Action getAction ( const std :: string & function@var657 ) const {
269: const std ::@expr1073744490 map < std ::@expr1073744491 string , Function > ::@expr1073744492 const_iterator i@var658 =@expr1073744493 functions@var645 .@expr1073744494 find (@expr1073744495 function@var657 ) ;
270: if (@expr1073744496 i@var658 !=@expr1073744497 functions@var645 .@expr1073744498 end (@expr1073744499 ) ) {
271: return i@var658 .@expr1073744500 second@var659 .@expr1073744501 action@var660 ; }
272: return Action ::@expr1073744502 NO_ACTION ;
273: }
274:
275: Yield getYield ( const std :: string & function@var661 ) const {
276: const std ::@expr1073744503 map < std ::@expr1073744504 string , Function > ::@expr1073744505 const_iterator i@var662 =@expr1073744506 functions@var645 .@expr1073744507 find (@expr1073744508 function@var661 ) ;
277: if (@expr1073744509 i@var662 !=@expr1073744510 functions@var645 .@expr1073744511 end (@expr1073744512 ) ) {
278: return i@var662 .@expr1073744513 second@var663 .@expr1073744514 yield@var664 ; }
279: return Yield ::@expr1073744515 NO_YIELD ;
280: }
281:
282: static Yield yieldFrom ( const std :: string & yieldName@var665 ) ;
283: static Action actionFrom ( const std :: string & actionName@var666 ) ;
284: } ;
285: std :: map < std :: string , Container > containers@var667 ;
286: const Container * detectContainer ( const Token * typeStart@var668 , bool iterator@var669 = false ) const ;
287: const Container * detectContainerOrIterator ( const Token * typeStart@var670 , bool * isIterator@var671 = nullptr ) const ;
288:
289: class ArgumentChecks {
290: public:
291: ArgumentChecks ( ) :
292: notbool@var672 ( false ) ,
293: notnull@var673 ( false ) ,
294: notuninit@var674 ( -1 ) ,
295: formatstr@var675 ( false ) ,
296: strz@var676 ( false ) ,
297: optional@var677 ( false ) ,
298: variadic@var678 ( false ) ,
299: iteratorInfo@var684 ( ) ,
300: direction@var692 ( Direction :: DIR_UNKNOWN ) { }
301:
302: bool notbool@var672 ;
303: bool notnull@var673 ;
304: int notuninit@var674 ;
305: bool formatstr@var675 ;
306: bool strz@var676 ;
307: bool optional@var677 ;
308: bool variadic@var678 ;
309: std :: string valid@var679 ;
310:
311: class IteratorInfo {
312: public:
313: IteratorInfo ( ) : container@var680 ( 0 ) , it@var681 ( false ) , first@var682 ( false ) , last@var683 ( false ) { }
314:
315: int container@var680 ;
316: bool it@var681 ;
317: bool first@var682 ;
318: bool last@var683 ;
319: } ;
320: IteratorInfo iteratorInfo@var684 ;
321:
322: class MinSize {
323: public:
324: enum class Type { NONE , STRLEN , ARGVALUE , SIZEOF , MUL , VALUE } ;
325: MinSize ( Type t@var685 , int a@var686 ) : type@var687 ( t@var685 ) , arg@var688 ( a@var686 ) , arg2@var689 ( 0 ) , value@var690 ( 0 ) { }
326: Type type@var687 ;
327: int arg@var688 ;
328: int arg2@var689 ;
329: long long value@var690 ;
330: } ;
331: std :: vector < MinSize > minsizes@var691 ;
332:
333: enum class Direction {
334: DIR_IN ,
335: DIR_OUT ,
336: DIR_INOUT ,
337: DIR_UNKNOWN
338: } ;
339: Direction direction@var692 ;
340: } ;
341:
342: struct Function {
343: std :: map < int , ArgumentChecks > argumentChecks@var693 ;
344: bool use@var694 ;
345: bool leakignore@var695 ;
346: bool isconst@var696 ;
347: bool ispure@var697 ;
348: UseRetValType useretval@var698 ;
349: bool ignore@var699 ;
350: bool formatstr@var700 ;
351: bool formatstr_scan@var701 ;
352: bool formatstr_secure@var702 ;
353: Container :: Action containerAction@var703 ;
354: Container :: Yield containerYield@var704 ;
355: Function ( )
356: : use@var694 ( false ) ,
357: leakignore@var695 ( false ) ,
358: isconst@var696 ( false ) ,
359: ispure@var697 ( false ) ,
360: useretval@var698 ( UseRetValType :: NONE ) ,
361: ignore@var699 ( false ) ,
362: formatstr@var700 ( false ) ,
363: formatstr_scan@var701 ( false ) ,
364: formatstr_secure@var702 ( false ) ,
365: containerAction@var703 ( Container :: Action :: NO_ACTION ) ,
366: containerYield@var704 ( Container :: Yield :: NO_YIELD )
367: { }
368: } ;
369:
370: const Function * getFunction ( const Token * ftok@var705 ) const ;
371: std :: unordered_map < std :: string , Function > functions@var706 ;
372: bool isUse ( const std :: string & functionName@var707 ) const ;
373: bool isLeakIgnore ( const std :: string & functionName@var708 ) const ;
374: bool isFunctionConst ( const std :: string & functionName@var709 , bool pure@var710 ) const ;
375: bool isFunctionConst ( const Token * ftok@var711 ) const ;
376:
377: bool isboolargbad ( const Token * ftok@var712 , int argnr@var713 ) const {
378: const ArgumentChecks * arg@var714 ; arg@var714 =@expr1073744516 getarg (@expr1073744517 ftok@var712 , argnr@var713 ) ;
379: return arg@var714 &&@expr1073744518 arg@var714 .@expr1073744519 notbool@var715 ;
380: }
381:
382: bool isnullargbad ( const Token * ftok@var716 , int argnr@var717 ) const ;
383: bool isuninitargbad ( const Token * ftok@var718 , int argnr@var719 , int indirect@var720 = 0 , bool * hasIndirect@var721 = nullptr ) const ;
384:
385: bool isargformatstr ( const Token * ftok@var722 , int argnr@var723 ) const {
386: const ArgumentChecks * arg@var724 ; arg@var724 =@expr1073744520 getarg (@expr1073744521 ftok@var722 , argnr@var723 ) ;
387: return arg@var724 &&@expr1073744522 arg@var724 .@expr1073744523 formatstr@var725 ;
388: }
389:
390: bool isargstrz ( const Token * ftok@var726 , int argnr@var727 ) const {
391: const ArgumentChecks * arg@var728 ; arg@var728 =@expr1073744524 getarg (@expr1073744525 ftok@var726 , argnr@var727 ) ;
392: return arg@var728 &&@expr1073744526 arg@var728 .@expr1073744527 strz@var729 ;
393: }
394:
395: bool isIntArgValid ( const Token * ftok@var730 , int argnr@var731 , const long long argvalue@var732 ) const ;
396: bool isFloatArgValid ( const Token * ftok@var733 , int argnr@var734 , double argvalue@var735 ) const ;
397:
398: const std :: string & validarg ( const Token * ftok@var736 , int argnr@var737 ) const {
399: const ArgumentChecks * arg@var738 ; arg@var738 =@expr1073744528 getarg (@expr1073744529 ftok@var736 , argnr@var737 ) ;
400: return arg@var738 ?@expr1073744530 arg@var738 .@expr1073744531 valid@var739 :@expr1073744532 emptyString@var1 ;
401: }
402:
403: struct InvalidArgValue {
404: enum class Type { le , lt , eq , ge , gt , range } ; enum Type type@var740 ;
405: std :: string op1@var741 ;
406: std :: string op2@var742 ;
407: bool isInt ( ) const {
408: return MathLib ::@expr1073744533 isInt (@expr1073744534 op1@var741 ) ;
409: }
410: } ;
411:
412: const ArgumentChecks :: IteratorInfo * getArgIteratorInfo ( const Token * ftok@var743 , int argnr@var744 ) const {
413: const ArgumentChecks * arg@var745 ; arg@var745 =@expr1073744535 getarg (@expr1073744536 ftok@var743 , argnr@var744 ) ;
414: return arg@var745 &&@expr1073744537 arg@var745 .@expr2714 iteratorInfo@var746 .@expr1073744539 it@var747 ?@expr1073744540 &@expr1073744541 arg@var745 .@expr2714 iteratorInfo@var746 :@expr1073744543 nullptr ;
415: }
416:
417: bool hasminsize ( const Token * ftok@var748 ) const ;
418:
419: const std :: vector < ArgumentChecks :: MinSize > * argminsizes ( const Token * ftok@var749 , int argnr@var750 ) const {
420: const ArgumentChecks * arg@var751 ; arg@var751 =@expr1073744544 getarg (@expr1073744545 ftok@var749 , argnr@var750 ) ;
421: return arg@var751 ?@expr1073744546 &@expr1073744547 arg@var751 .@expr1073744548 minsizes@var752 :@expr1073744549 nullptr ;
422: }
423:
424: ArgumentChecks :: Direction getArgDirection ( const Token * ftok@var753 , int argnr@var754 ) const ;
425:
426: bool markupFile ( const std :: string & path@var755 ) const ;
427:
428: bool processMarkupAfterCode ( const std :: string & path@var756 ) const ;
429:
430: const std :: set < std :: string > & markupExtensions ( ) const {
431: return mMarkupExtensions@var860 ;
432: }
433:
434: bool reportErrors ( const std :: string & path@var757 ) const ;
435:
436: bool ignorefunction ( const std :: string & functionName@var758 ) const ;
437:
438: bool isexecutableblock ( const std :: string & file@var759 , const std :: string & token@var760 ) const ;
439:
440: int blockstartoffset ( const std :: string & file@var761 ) const ;
441:
442: const std :: string & blockstart ( const std :: string & file@var762 ) const ;
443: const std :: string & blockend ( const std :: string & file@var763 ) const ;
444:
445: bool iskeyword ( const std :: string & file@var764 , const std :: string & keyword@var765 ) const ;
446:
447: bool isexporter ( const std :: string & prefix@var766 ) const {
448: return mExporters@var863 .@expr1073744550 find (@expr1073744551 prefix@var766 ) !=@expr1073744552 mExporters@var863 .@expr1073744553 end (@expr1073744554 ) ;
449: }
450:
451: bool isexportedprefix ( const std :: string & prefix@var767 , const std :: string & token@var768 ) const {
452: const std ::@expr1073744555 map < std ::@expr1073744556 string , ExportedFunctions > ::@expr1073744557 const_iterator it@var769 =@expr1073744558 mExporters@var863 .@expr1073744559 find (@expr1073744560 prefix@var767 ) ;
453: return (@expr1073744561 it@var769 !=@expr1073744562 mExporters@var863 .@expr1073744563 end (@expr1073744564 ) &&@expr1073744565 it@var769 .@expr1073744566 second@var770 .@expr1073744567 isPrefix (@expr1073744568 token@var768 ) ) ;
454: }
455:
456: bool isexportedsuffix ( const std :: string & prefix@var771 , const std :: string & token@var772 ) const {
457: const std ::@expr1073744569 map < std ::@expr1073744570 string , ExportedFunctions > ::@expr1073744571 const_iterator it@var773 =@expr1073744572 mExporters@var863 .@expr1073744573 find (@expr1073744574 prefix@var771 ) ;
458: return (@expr1073744575 it@var773 !=@expr1073744576 mExporters@var863 .@expr1073744577 end (@expr1073744578 ) &&@expr1073744579 it@var773 .@expr1073744580 second@var774 .@expr1073744581 isSuffix (@expr1073744582 token@var772 ) ) ;
459: }
460:
461: bool isimporter ( const std :: string & file@var775 , const std :: string & importer@var776 ) const ;
462:
463: const Token * getContainerFromYield ( const Token * tok@var777 , Container :: Yield yield@var778 ) const ;
464: const Token * getContainerFromAction ( const Token * tok@var779 , Container :: Action action@var780 ) const ;
465:
466: bool isreflection ( const std :: string & token@var781 ) const {
467: return mReflection@var865 .@expr1073744583 find (@expr1073744584 token@var781 ) !=@expr1073744585 mReflection@var865 .@expr1073744586 end (@expr1073744587 ) ;
468: }
469:
470: int reflectionArgument ( const std :: string & token@var782 ) const {
471: const std ::@expr1073744588 map < std ::@expr1073744589 string , int > ::@expr1073744590 const_iterator it@var783 =@expr1073744591 mReflection@var865 .@expr1073744592 find (@expr1073744593 token@var782 ) ;
472: if (@expr1073744594 it@var783 !=@expr1073744595 mReflection@var865 .@expr1073744596 end (@expr1073744597 ) ) {
473: return it@var783 .@expr1073744598 second@var784 ; }
474: return -1 ;
475: }
476:
477: std :: vector < std :: string > defines@var785 ;
478:
479: struct SmartPointer {
480: std :: string name@var786 ; name@var786 = "" ;
481: bool unique@var787 ; unique@var787 = false ;
482: } ;
483:
484: std :: map < std :: string , SmartPointer > smartPointers@var788 ;
485: bool isSmartPointer ( const Token * tok@var789 ) const ;
486: const SmartPointer * detectSmartPointer ( const Token * tok@var790 ) const ;
487:
488: struct PodType {
489: unsigned int size@var791 ;
490: char sign@var792 ;
491: enum class Type { NO , BOOL , CHAR , SHORT , INT , LONG , LONGLONG } ; enum Type stdtype@var793 ;
492: } ;
493: const struct PodType * podtype ( const std :: string & name@var794 ) const {
494: const std ::@expr1073744599 unordered_map < std ::@expr1073744600 string , PodType > ::@expr1073744601 const_iterator it@var795 =@expr1073744602 mPodTypes@var866 .@expr1073744603 find (@expr1073744604 name@var794 ) ;
495: return (@expr2781 it@var795 !=@expr1073744606 mPodTypes@var866 .@expr1073744607 end (@expr1073744608 ) ) ?@expr1073744609 &@expr1073744610 (@expr2781 it@var795 .@expr1073744612 second@var796 ) :@expr1073744613 nullptr ;
496: }
497:
498: struct PlatformType {
499: PlatformType ( )
500: : mSigned@var807 ( false )
501: , mUnsigned@var808 ( false )
502: , mLong@var809 ( false )
503: , mPointer@var810 ( false )
504: , mPtrPtr@var811 ( false )
505: , mConstPtr@var812 ( false ) { }
506: bool operator== ( const PlatformType & type@var797 ) const {
507: return (@expr1073744614 mSigned@var807 ==@expr1073744615 type@var797 .@expr1073744616 mSigned@var798 &&@expr1073744617
508: mUnsigned@var808 ==@expr1073744618 type@var797 .@expr1073744619 mUnsigned@var799 &&@expr1073744620
509: mLong@var809 ==@expr1073744621 type@var797 .@expr1073744622 mLong@var800 &&@expr1073744623
510: mPointer@var810 ==@expr1073744624 type@var797 .@expr1073744625 mPointer@var801 &&@expr1073744626
511: mPtrPtr@var811 ==@expr1073744627 type@var797 .@expr1073744628 mPtrPtr@var802 &&@expr1073744629
512: mConstPtr@var812 ==@expr1073744630 type@var797 .@expr1073744631 mConstPtr@var803 &&@expr1073744632
513: mType@var806 ==@expr1073744633 type@var797 .@expr1073744634 mType@var804 ) ;
514: }
515: bool operator!= ( const PlatformType & type@var805 ) const {
516: return !@expr1073744635 (@expr1073744636 *@expr1073744637 this@expr1073744638 ==@expr1073744639 type@var805 ) ;
517: }
518: std :: string mType@var806 ;
519: bool mSigned@var807 ;
520: bool mUnsigned@var808 ;
521: bool mLong@var809 ;
522: bool mPointer@var810 ;
523: bool mPtrPtr@var811 ;
524: bool mConstPtr@var812 ;
525: } ;
526:
527: struct Platform {
528: const PlatformType * platform_type ( const std :: string & name@var813 ) const {
529: const std ::@expr1073744640 map < std ::@expr1073744641 string , PlatformType > ::@expr1073744642 const_iterator it@var814 =@expr1073744643 mPlatformTypes@var816 .@expr1073744644 find (@expr1073744645 name@var813 ) ;
530: return (@expr2822 it@var814 !=@expr1073744647 mPlatformTypes@var816 .@expr1073744648 end (@expr1073744649 ) ) ?@expr1073744650 &@expr1073744651 (@expr2822 it@var814 .@expr1073744653 second@var815 ) :@expr1073744654 nullptr ;
531: }
532: std :: map < std :: string , PlatformType > mPlatformTypes@var816 ;
533: } ;
534:
535: const PlatformType * platform_type ( const std :: string & name@var817 , const std :: string & platform@var818 ) const {
536: const std ::@expr1073744655 map < std ::@expr2832 string , Platform > ::@expr1073744657 const_iterator it@var819 =@expr1073744658 mPlatforms@var868 .@expr1073744659 find (@expr1073744660 platform@var818 ) ;
537: if (@expr1073744661 it@var819 !=@expr1073744662 mPlatforms@var868 .@expr1073744663 end (@expr1073744664 ) ) {
538: const PlatformType * const type@var820 ; type@var820 =@expr1073744665 it@var819 .@expr1073744666 second@var821 .@expr1073744667 platform_type (@expr1073744668 name@var817 ) ;
539: if (@expr1073744669 type@var820 ) {
540: return type@var820 ; }
541: }
542:
543: const std ::@expr1073744670 map < std ::@expr2832 string , PlatformType > ::@expr1073744672 const_iterator it2@var822 =@expr1073744673 mPlatformTypes@var867 .@expr1073744674 find (@expr1073744675 name@var817 ) ;
544: return (@expr2852 it2@var822 !=@expr1073744677 mPlatformTypes@var867 .@expr1073744678 end (@expr1073744679 ) ) ?@expr1073744680 &@expr1073744681 (@expr2852 it2@var822 .@expr1073744683 second@var823 ) :@expr1073744684 nullptr ;
545: }
546:
|
549:
550: std :: string getFunctionName ( const Token * ftok@var824 ) const ;
551:
552: static bool isContainerYield ( const Token * const cond@var825 , Library :: Container :: Yield y@var826 , const std :: string & fallback@var827 = "" ) ;
553:
554:
555: enum class TypeCheck { def , check , suppress } ;
556: TypeCheck getTypeCheck ( const std :: string & check@var828 , const std :: string & typeName@var829 ) const ;
557:
558: private:
559:
560: Error loadFunction ( const tinyxml2 :: XMLElement * const node@var830 , const std :: string & name@var831 , std :: set < std :: string > & unknown_elements@var832 ) ;
561:
562: class ExportedFunctions {
563: public:
564: void addPrefix ( const std :: string & prefix@var833 ) {
565: mPrefixes@var837 .@expr1073744685 insert (@expr1073744686 prefix@var833 ) ;
566: }
567: void addSuffix ( const std :: string & suffix@var834 ) {
568: mSuffixes@var838 .@expr1073744687 insert (@expr1073744688 suffix@var834 ) ;
569: }
570: bool isPrefix ( const std :: string & prefix@var835 ) const {
571: return (@expr1073744689 mPrefixes@var837 .@expr1073744690 find (@expr1073744691 prefix@var835 ) !=@expr1073744692 mPrefixes@var837 .@expr1073744693 end (@expr1073744694 ) ) ;
572: }
573: bool isSuffix ( const std :: string & suffix@var836 ) const {
574: return (@expr1073744695 mSuffixes@var838 .@expr1073744696 find (@expr1073744697 suffix@var836 ) !=@expr1073744698 mSuffixes@var838 .@expr1073744699 end (@expr1073744700 ) ) ;
575: }
576:
577: private:
578: std :: set < std :: string > mPrefixes@var837 ;
579: std :: set < std :: string > mSuffixes@var838 ;
580: } ;
581: class CodeBlock {
582: public:
583: CodeBlock ( ) : mOffset@var846 ( 0 ) { }
584:
585: void setStart ( const char * s@var839 ) {
586: mStart@var844 =@expr1073744701 s@var839 ;
587: }
588: void setEnd ( const char * e@var840 ) {
589: mEnd@var845 =@expr1073744702 e@var840 ;
590: }
591: void setOffset ( const int o@var841 ) {
592: mOffset@var846 =@expr1073744703 o@var841 ;
593: }
594: void addBlock ( const char * blockName@var842 ) {
595: mBlocks@var847 .@expr1073744704 insert (@expr1073744705 blockName@var842 ) ;
596: }
597: const std :: string & start ( ) const {
598: return mStart@var844 ;
599: }
600: const std :: string & end ( ) const {
601: return mEnd@var845 ;
602: }
603: int offset ( ) const {
604: return mOffset@var846 ;
605: }
606: bool isBlock ( const std :: string & blockName@var843 ) const {
607: return mBlocks@var847 .@expr1073744706 find (@expr1073744707 blockName@var843 ) !=@expr1073744708 mBlocks@var847 .@expr1073744709 end (@expr1073744710 ) ;
608: }
609:
610: private:
611: std :: string mStart@var844 ;
612: std :: string mEnd@var845 ;
613: int mOffset@var846 ;
614: std :: set < std :: string > mBlocks@var847 ;
615: } ;
616: enum class FalseTrueMaybe { False , True , Maybe } ;
617: int mAllocId@var848 ;
618: std :: set < std :: string > mFiles@var849 ;
619: std :: map < std :: string , AllocFunc > mAlloc@var850 ;
620: std :: map < std :: string , AllocFunc > mDealloc@var851 ;
621: std :: map < std :: string , AllocFunc > mRealloc@var852 ;
622: std :: unordered_map < std :: string , FalseTrueMaybe > mNoReturn@var853 ;
623: std :: map < std :: string , std :: string > mReturnValue@var854 ;
624: std :: map < std :: string , std :: string > mReturnValueType@var855 ;
625: std :: map < std :: string , int > mReturnValueContainer@var856 ;
626: std :: map < std :: string , std :: vector < long long > > mUnknownReturnValues@var857 ;
627: std :: map < std :: string , bool > mReportErrors@var858 ;
628: std :: map < std :: string , bool > mProcessAfterCode@var859 ;
629: std :: set < std :: string > mMarkupExtensions@var860 ;
630: std :: map < std :: string , std :: set < std :: string > > mKeywords@var861 ;
631: std :: map < std :: string , CodeBlock > mExecutableBlocks@var862 ;
632: std :: map < std :: string , ExportedFunctions > mExporters@var863 ;
633: std :: map < std :: string , std :: set < std :: string > > mImporters@var864 ;
634: std :: map < std :: string , int > mReflection@var865 ;
635: std :: unordered_map < std :: string , PodType > mPodTypes@var866 ;
636: std :: map < std :: string , PlatformType > mPlatformTypes@var867 ;
637: std :: map < std :: string , Platform > mPlatforms@var868 ;
638: std :: map < std :: pair < std :: string , std :: string > , TypeCheck > mTypeChecks@var869 ;
639: std :: unordered_map < std :: string , NonOverlappingData > mNonOverlappingData@var870 ;
640:
641: const ArgumentChecks * getarg ( const Token * ftok@var871 , int argnr@var872 ) const ;
642:
643: std :: string getFunctionName ( const Token * ftok@var873 , bool * error@var874 ) const ;
644:
645: static const AllocFunc * getAllocDealloc ( const std :: map < std :: string , AllocFunc > & data@var875 , const std :: string & name@var876 ) {
646: const std ::@expr1073744711 map < std ::@expr1073744712 string , AllocFunc > ::@expr1073744713 const_iterator it@var877 =@expr1073744714 data@var875 .@expr1073744715 find (@expr1073744716 name@var876 ) ;
647: return (@expr1073744717 it@var877 ==@expr1073744718 data@var875 .@expr1073744719 end (@expr1073744720 ) ) ?@expr1073744721 nullptr :@expr1073744722 &@expr1073744723 it@var877 .@expr1073744724 second@var878 ;
648: }
649: } ;
650:
651: const Library :: Container * getLibraryContainer ( const Token * tok@var879 ) ;
652:
653: std :: shared_ptr < Token > createTokenFromExpression ( const std :: string & returnValue@var880 ,
654: const Settings * settings@var881 ,
655: std :: unordered_map < int , const Token * > * lookupVarId@var882 = nullptr ) ;

##file cppcheck-2.8/lib/timer.h

1:
|
28:
29: enum class SHOWTIME_MODES {
30: SHOWTIME_NONE = 0 ,
31: SHOWTIME_FILE ,
32: SHOWTIME_SUMMARY ,
33: SHOWTIME_TOP5
34: } ;
35:
36: class TimerResultsIntf {
37: public:
38: virtual ~ TimerResultsIntf ( ) { }
39:
40: virtual void addResults ( const std :: string & str@var883 , std :: clock_t clocks@var884 ) = 0 ;
41: } ;
42:
43: struct TimerResultsData {
44: std :: clock_t mClocks@var885 ;
45: long mNumberOfResults@var886 ;
46:
47: TimerResultsData ( )
48: : mClocks@var885 ( 0 )
49: , mNumberOfResults@var886 ( 0 ) { }
50:
51: double seconds ( ) const {
52: const double ret@var887 =@expr1073744726 (@expr1073744727 double ) (@expr1073744728 (@expr1073744729 unsigned long ) mClocks@var885 ) /@expr1073744730 (@expr1073744731 double ) CLOCKS_PER_SEC@expr1073744725 ;
53: return ret@var887 ;
54: }
55: } ;
56:
57: class TimerResults : public TimerResultsIntf {
58: public:
59: TimerResults ( ) { }
60:
61: void showResults ( SHOWTIME_MODES mode@var888 ) const ;
62: void addResults ( const std :: string & str@var889 , std :: clock_t clocks@var890 ) override ;
63:
64: private:
65: std :: map < std :: string , TimerResultsData > mResults@var891 ;
66: } ;
67:
68: class Timer {
69: public:
70: Timer ( const std :: string & str@var892 , SHOWTIME_MODES showtimeMode@var893 , TimerResultsIntf * timerResults@var894 = nullptr ) ;
71: ~ Timer ( ) ;
72: void stop ( ) ;
73:
74: private:
75: Timer ( const Timer & other@var895 ) ;
76: Timer & operator= ( const Timer & ) ;
77:
78: const std :: string mStr@var896 ;
79: TimerResultsIntf * mTimerResults@var897 ;
80: std :: clock_t mStart@var898 ;
81: const SHOWTIME_MODES mShowTimeMode@var899 ;
82: bool mStopped@var900 ;
83: } ;

##file cppcheck-2.8/lib/settings.h

1:
|
40:
41: namespace ValueFlow {
42: class Value ;
43: }
44:
|
47:
48: class SimpleEnableGroup<Severity::SeverityType> ; class SimpleEnableGroup<Certainty::CertaintyLevel> ; class SimpleEnableGroup<Checks::CheckList> ;
49:
|
89:
90: class Settings : public cppcheck :: Platform {
91: private:
92:
93:
94: static std :: atomic < bool > mTerminated@var901 ;
95:
96: public:
97: Settings ( ) ;
98:
99: void loadCppcheckCfg ( ) ;
100:
101:
102: std :: list < std :: string > addons@var902 ;
103:
104:
105: std :: string addonPython@var903 ;
106:
107:
108: std :: vector < std :: string > basePaths@var904 ;
109:
110:
111: std :: string buildDir@var905 ;
112:
113:
114: bool checkAllConfigurations@var906 ;
115:
116:
117: bool checkConfiguration@var907 ;
118:
|
121:
122: bool checkHeaders@var908 ;
123:
124:
125: bool checkLibrary@var909 ;
126:
127:
128: std :: set < std :: string > checkUnknownFunctionReturn@var910 ;
129:
130:
131: bool checkUnusedTemplates@var911 ;
132:
133:
134: bool clang@var912 ;
135:
136:
137: std :: string clangExecutable@var913 ;
138:
139:
140: bool clangTidy@var914 ;
141:
142:
143: std :: set < std :: string > configExcludePaths@var915 ;
144:
145:
146: std :: string cppcheckCfgProductName@var916 ;
147:
148:
149: std :: string cppcheckCfgAbout@var917 ;
150:
151:
152: bool daca@var918 ;
153:
154:
155: bool debugnormal@var919 ;
156:
157:
158: bool debugSimplified@var920 ;
159:
160:
161: bool debugtemplate@var921 ;
162:
163:
164: bool debugwarnings@var922 ;
165:
166:
167: bool dump@var923 ;
168: std :: string dumpFile@var924 ;
169:
170: enum Language {
171: None , C , CPP
172: } ;
173:
174:
175: Language enforcedLang@var925 ;
176:
177:
178: bool exceptionHandling@var926 ;
179:
180:
181: std :: string exename@var927 ;
182:
183:
184:
185: int exitCode@var928 ;
186:
187:
188: std :: vector < std :: string > fileFilters@var929 ;
189:
190:
191: bool force@var930 ;
192:
193:
194:
195: std :: list < std :: string > includePaths@var931 ;
196:
197:
198: bool inlineSuppressions@var932 ;
199:
200:
201:
202: unsigned int jobs@var933 ;
203:
|
206:
207: bool jointSuppressionReport@var934 ;
208:
209:
210: std :: list < std :: string > libraries@var935 ;
211:
212:
213: Library library@var936 ;
214:
215:
216:
217: int loadAverage@var937 ;
218:
|
221:
222: int maxConfigs@var938 ;
223:
224:
225: int maxCtuDepth@var939 ;
226:
227:
228: int maxTemplateRecursion@var940 ;
229:
230:
231: Suppressions nofail@var941 ;
232:
233:
234: Suppressions nomsg@var942 ;
235:
236:
237: std :: string outputFile@var943 ;
238:
239:
240: std :: string plistOutput@var944 ;
241:
242:
243: bool preprocessOnly@var945 ;
244:
245: ImportProject project@var946 ;
246:
247:
248: bool quiet@var947 ;
249:
250:
251: bool relativePaths@var948 ;
252:
253:
254: bool reportProgress@var949 ;
255:
256:
257: class Rule {
258: public:
259: Rule ( )
260: : tokenlist@var950 ( "simple" )
261: , id@var952 ( "rule" )
262: , severity@var954 ( Severity :: style ) {
263: }
264:
265: std :: string tokenlist@var950 ;
266: std :: string pattern@var951 ;
267: std :: string id@var952 ;
268: std :: string summary@var953 ;
269: Severity :: SeverityType severity@var954 ;
270: } ;
271:
|
274:
275: std :: list < Rule > rules@var955 ;
276:
277:
278: class SafeChecks {
279: public:
280: SafeChecks ( ) : classes@var961 ( false ) , externalFunctions@var962 ( false ) , internalFunctions@var963 ( false ) , externalVariables@var964 ( false ) { }
281:
282: static const char XmlRootName@var956 [ ] ;
283: static const char XmlClasses@var957 [ ] ;
284: static const char XmlExternalFunctions@var958 [ ] ;
285: static const char XmlInternalFunctions@var959 [ ] ;
286: static const char XmlExternalVariables@var960 [ ] ;
287:
288: void clear ( ) {
289: classes@var961 =@expr1073744732 externalFunctions@var962 =@expr1073744733 internalFunctions@var963 =@expr1073744734 externalVariables@var964 =@expr1073744735 false ;
290: }
291:
|
297:
298: bool classes@var961 ;
299:
|
304:
305: bool externalFunctions@var962 ;
306:
|
310:
311: bool internalFunctions@var963 ;
312:
|
316:
317: bool externalVariables@var964 ;
318: } ;
319:
320: SafeChecks safeChecks@var965 ;
321:
322: SimpleEnableGroup<Severity::SeverityType> severity@var966 ;
323: SimpleEnableGroup<Certainty::CertaintyLevel> certainty@var967 ;
324: SimpleEnableGroup<Checks::CheckList> checks@var968 ;
325:
326:
327: SHOWTIME_MODES showtime@var969 ;
328:
329:
330: Standards standards@var970 ;
331:
332:
333:
334: std :: string templateFormat@var971 ;
335:
336:
337:
338: std :: string templateLocation@var972 ;
339:
340:
341: std :: string userDefines@var973 ;
342:
343:
344: std :: set < std :: string > userUndefs@var974 ;
345:
346:
347: std :: list < std :: string > userIncludes@var975 ;
348:
349:
350: bool verbose@var976 ;
351:
352:
353: bool xml@var977 ;
354:
355:
356: int xml_version@var978 ;
357:
|
361:
362: bool configurationExcluded ( const std :: string & file@var979 ) const {
363: for (@expr1073744736 const std ::@expr1073744737 string &@expr1073744738 configExcludePath@var980 :@expr1073744739 configExcludePaths@var915 ) {
364: if (@expr1073744740 file@var979 .@expr1073744741 length (@expr1073744742 ) >=@expr1073744743 configExcludePath@var980 .@expr2920 length (@expr2921 ) &&@expr1073744746 file@var979 .@expr1073744747 compare (@expr1073744748 0 , configExcludePath@var980 .@expr2920 length (@expr2921 ) , configExcludePath@var980 ) ==@expr1073744751 0 ) {
365: return true ;
366: }
367: }
368: return false ;
369: }
370:
|
376:
377: std :: string addEnabled ( const std :: string & str@var981 ) ;
378:
|
382:
383: bool isEnabled ( const ValueFlow :: Value * value@var982 , bool inconclusiveCheck@var983 = false ) const ;
384:
385:
386: bool posix ( ) const {
387: return std ::@expr1073744752 find (@expr1073744753 libraries@var935 .@expr1073744754 begin (@expr1073744755 ) , libraries@var935 .@expr2932 end (@expr2933 ) , "posix" ) !=@expr1073744758 libraries@var935 .@expr2932 end (@expr2933 ) ;
388: }
389:
390:
391: static void terminate ( bool t@var984 = true ) {
392: Settings ::@expr1073744761 mTerminated@var901 =@expr1073744762 t@var984 ;
393: }
394:
395:
396: static bool terminated ( ) {
397: return Settings ::@expr1073744763 mTerminated@var901 ;
398: }
399:
400: std :: set < std :: string > summaryReturn@var985 ;
401:
402: void loadSummaries ( ) ;
403: } ;

##file cppcheck-2.8/lib/valueflow.h

1:
|
36:
37: class ErrorLogger ;
38: struct InferModel ;
39: class Settings ;
40: class SymbolDatabase ;
41: class Token ;
42: class TokenList ;
43: class ValueType ;
44: class Variable ;
45: class Scope ;
46:
47: template < class T >
48: class ValuePtr ;
49:
50: namespace ValueFlow {
51: struct increment {
52: template < class T >
53: void operator() ( T & x@var986 ) const {
54: x@var986 ++@expr1073744764 ;
55: }
56: } ;
57: struct decrement {
58: template < class T >
59: void operator() ( T & x@var987 ) const {
60: x@var987 --@expr1073744765 ;
61: }
62: } ;
63:
64: struct less {
65: template < class T , class U >
66: bool operator() ( const T & x@var988 , const U & y@var989 ) const {
67: return x@var988 <@expr1073744766 y@var989 ;
68: }
69: } ;
70:
71: struct adjacent {
72: template < class T , class U >
73: bool operator() ( const T & x@var990 , const U & y@var991 ) const {
74: return std ::@expr1073744767 abs (@expr1073744768 x@var990 -@expr1073744769 y@var991 ) ==@expr1073744770 1 ;
75: }
76: } ;
77:
78: struct equalVisitor {
79: template < class T , class U >
80: void operator() ( bool & result@var992 , T x@var993 , U y@var994 ) const {
81: result@var992 =@expr1073744771 !@expr1073744772 (@expr1073744773 x@var993 >@expr1073744774 y@var994 ||@expr1073744775 x@var993 <@expr1073744776 y@var994 ) ;
82: }
83: } ;
84: class Value {
85: public:
86:
87:
88: enum class Bound { Upper , Lower , Point } ;
89:
90: explicit Value ( long long val@var995 = 0 , Bound b@var996 = Bound :: Point )
91: : valueType@var1036 ( ValueType :: INT ) ,
92: bound@var1037 ( b@var996 ) ,
93: intvalue@var1038 ( val@var995 ) ,
94: tokvalue@var1039 ( nullptr ) ,
95: floatValue@var1040 ( 0.0 ) ,
96: moveKind@var1041 ( MoveKind :: NonMovedVariable ) ,
97: varvalue@var1042 ( val@var995 ) ,
98: condition@var1043 ( nullptr ) ,
99: varId@var1045 ( 0U ) ,
100: safe@var1046 ( false ) ,
101: conditional@var1047 ( false ) ,
102: macro@var1048 ( false ) ,
103: defaultArg@var1049 ( false ) ,
104: indirect@var1050 ( 0 ) ,
105: path@var1051 ( 0 ) ,
106: wideintvalue@var1052 ( val@var995 ) ,
107: subexpressions@var1053 ( ) ,
108: capturetok@var1054 ( nullptr ) ,
109: lifetimeKind@var1055 ( LifetimeKind :: Object ) ,
110: lifetimeScope@var1056 ( LifetimeScope :: Local ) ,
111: valueKind@var1061 ( ValueKind :: Possible )
112: { }
113: Value ( const Token * c@var997 , long long val@var998 , Bound b@var999 = Bound :: Point ) ;
114:
115: static Value unknown ( ) ;
116:
117: bool equalValue ( const ValueFlow :: Value & rhs@var1000 ) const {
118: if (@expr1073744777 valueType@var1036 !=@expr1073744778 rhs@var1000 .@expr1073744779 valueType@var1001 ) {
119: return false ; }
120: switch (@expr1073744780 valueType@var1036 ) {
121: case ValueType ::@expr1073744781 INT :@expr2958
122: case ValueType ::@expr1073744783 CONTAINER_SIZE :@expr2958
123: case ValueType ::@expr1073744785 BUFFER_SIZE :@expr2958
124: case ValueType ::@expr1073744787 ITERATOR_START :@expr2958
125: case ValueType ::@expr1073744789 ITERATOR_END :@expr2958 ;
126: if (@expr2967 intvalue@var1038 !=@expr2968 rhs@var1000 .@expr2969 intvalue@var1002 ) {
127: return false ; }
128: break ;
129: case ValueType ::@expr1073744794 TOK :@expr2958 ;
130: if (@expr2972 tokvalue@var1039 !=@expr2973 rhs@var1000 .@expr2974 tokvalue@var1003 ) {
131: return false ; }
132: break ;
133: case ValueType ::@expr1073744799 FLOAT :@expr2958 ;
134:
135: if (@expr1073744801 floatValue@var1040 >@expr1073744802 rhs@var1000 .@expr2979 floatValue@var1004 ||@expr1073744804 floatValue@var1040 <@expr1073744805 rhs@var1000 .@expr2979 floatValue@var1004 ) {
136: return false ; }
137: break ;
138: case ValueType ::@expr1073744807 MOVED :@expr2958 ;
139: if (@expr1073744809 moveKind@var1041 !=@expr1073744810 rhs@var1000 .@expr1073744811 moveKind@var1005 ) {
140: return false ; }
141: break ;
142: case ValueType ::@expr1073744812 UNINIT :@expr2958 ;
143: break ;
144: case ValueType ::@expr1073744814 LIFETIME :@expr2958 ;
145: if (@expr2972 tokvalue@var1039 !=@expr2973 rhs@var1000 .@expr2974 tokvalue@var1003 ) {
146: return false ; }
147: break ;
148: case ValueType ::@expr1073744819 SYMBOLIC :@expr2958 ;
149: if (@expr1073744821 !@expr1073744822 sameToken (@expr1073744823 tokvalue@var1039 , rhs@var1000 .@expr2974 tokvalue@var1003 ) ) {
150: return false ; }
151: if (@expr2967 intvalue@var1038 !=@expr2968 rhs@var1000 .@expr2969 intvalue@var1002 ) {
152: return false ; }
153: break ;
154: }
155: return true ;
156: }
157:
158: template < class T , class F >
159: static void visitValue ( T & self@var1006 , F f@var1007 ) {
160: switch (@expr1073744828 self@var1006 .@expr1073744829 valueType@var1008 ) {
161: case ValueType ::@expr1073744830 INT :@expr3007
162: case ValueType ::@expr1073744832 SYMBOLIC :@expr3007
163: case ValueType ::@expr1073744834 BUFFER_SIZE :@expr3007
164: case ValueType ::@expr1073744836 CONTAINER_SIZE :@expr3007
165: case ValueType ::@expr1073744838 ITERATOR_START :@expr3007
166: case ValueType ::@expr1073744840 ITERATOR_END :@expr3007 ; {
167: f@var1007 (@expr1073744842 self@var1006 .@expr1073744843 intvalue@var1009 ) ;
168: break ;
169: }
170: case ValueType ::@expr1073744844 FLOAT :@expr3007 ; {
171: f@var1007 (@expr1073744846 self@var1006 .@expr1073744847 floatValue@var1010 ) ;
172: break ;
173: }
174: case ValueType ::@expr1073744848 UNINIT :@expr3007
175: case ValueType ::@expr1073744850 TOK :@expr3007
176: case ValueType ::@expr1073744852 LIFETIME :@expr3007
177: case ValueType ::@expr1073744854 MOVED :@expr3007 ;
178: break ;
179: }
180: }
181:
182: struct compareVisitor {
183: struct innerVisitor {
184: template < class Compare , class T , class U >
185: void operator() ( bool & result@var1011 , Compare compare@var1012 , T x@var1013 , U y@var1014 ) const {
186: result@var1011 =@expr1073744856 compare@var1012 (@expr1073744857 x@var1013 , y@var1014 ) ;
187: }
188: } ;
189: template < class Compare , class T >
190: void operator() ( bool & result@var1015 , const Value & rhs@var1016 , Compare compare@var1017 , T x@var1018 ) const {
191: visitValue (@expr1073744859 rhs@var1016 ,
192: std ::@expr1073744860 bind (@expr1073744861 innerVisitor {@expr1073744862 } , std ::@expr1073744863 ref (@expr1073744864 result@var1015 ) , std ::@expr1073744865 move (@expr1073744866 compare@var1017 ) , x@var1018 , std ::@expr1073744867 placeholders ::@expr1073744868 _1@expr1073744858 ) ) ;
193: }
194: } ;
195:
196: template < class Compare >
197: bool compareValue ( const Value & rhs@var1019 , Compare compare@var1020 ) const {
198: assert (@expr1073744870 (@expr1073744871 !@expr1073744872 this@expr3049 .@expr1073744874 isSymbolicValue (@expr1073744875 ) &&@expr1073744876 !@expr1073744877 rhs@var1019 .@expr1073744878 isSymbolicValue (@expr1073744879 ) ) ||@expr1073744880
199: (@expr1073744881 this@expr3049 .@expr1073744882 valueType@var1036 ==@expr1073744883 rhs@var1019 .@expr1073744884 valueType@var1021 &&@expr1073744885 sameToken (@expr1073744886 this@expr3049 .@expr1073744887 tokvalue@var1039 , rhs@var1019 .@expr1073744888 tokvalue@var1022 ) ) ) ;
200: bool result@var1023 ; result@var1023 =@expr1073744889 false ;
201: visitValue (@expr1073744890
202: *@expr1073744891 this@expr3049 ,
203: std ::@expr1073744892 bind (@expr1073744893 compareVisitor {@expr1073744894 } , std ::@expr3071 ref (@expr1073744896 result@var1023 ) , std ::@expr3071 ref (@expr1073744898 rhs@var1019 ) , std ::@expr1073744899 move (@expr1073744900 compare@var1020 ) , std ::@expr1073744901 placeholders ::@expr1073744902 _1@expr1073744869 ) ) ;
204: return result@var1023 ;
205: }
206:
207: bool operator== ( const Value & rhs@var1024 ) const {
208: if (@expr1073744903 !@expr1073744904 equalValue (@expr1073744905 rhs@var1024 ) ) {
209: return false ; }
210:
211: return varvalue@var1042 ==@expr1073744906 rhs@var1024 .@expr1073744907 varvalue@var1025 &&@expr1073744908
212: condition@var1043 ==@expr1073744909 rhs@var1024 .@expr1073744910 condition@var1026 &&@expr1073744911
213: varId@var1045 ==@expr1073744912 rhs@var1024 .@expr1073744913 varId@var1027 &&@expr1073744914
214: conditional@var1047 ==@expr1073744915 rhs@var1024 .@expr1073744916 conditional@var1028 &&@expr1073744917
215: defaultArg@var1049 ==@expr1073744918 rhs@var1024 .@expr1073744919 defaultArg@var1029 &&@expr1073744920
216: indirect@var1050 ==@expr1073744921 rhs@var1024 .@expr1073744922 indirect@var1030 &&@expr1073744923
217: valueKind@var1061 ==@expr1073744924 rhs@var1024 .@expr1073744925 valueKind@var1031 ;
218: }
219:
220: bool operator!= ( const Value & rhs@var1032 ) const {
221: return !@expr1073744926 (@expr1073744927 *@expr1073744928 this@expr1073744929 ==@expr1073744930 rhs@var1032 ) ;
222: }
223:
224: template < class T , $class $= $typename $std $:: $enable_if $< std :: is_arithmetic < T > $:: $value $> $:: $type >
225: bool equalTo ( const T & x@var1033 ) const {
226: bool result@var1034 ; result@var1034 =@expr1073744932 false ;
227: visitValue (@expr1073744933 *@expr1073744934 this@expr1073744935 , std ::@expr1073744936 bind (@expr1073744937 equalVisitor {@expr1073744938 } , std ::@expr1073744939 ref (@expr1073744940 result@var1034 ) , x@var1033 , std ::@expr1073744941 placeholders ::@expr1073744942 _1@expr1073744931 ) ) ;
228: return result@var1034 ;
229: }
230:
231: void decreaseRange ( ) {
232: if (@expr1073744943 bound@var1037 ==@expr1073744944 Bound ::@expr1073744945 Lower ) {
233: visitValue (@expr1073744946 *@expr3123 this@expr3124 , increment {@expr1073744949 } ) ; }
234: else { if (@expr1073744950 bound@var1037 ==@expr1073744951 Bound ::@expr1073744952 Upper ) {
235: visitValue (@expr1073744953 *@expr3123 this@expr3124 , decrement {@expr1073744955 } ) ; } }
236: }
237:
238: void invertBound ( ) {
239: if (@expr1073744956 bound@var1037 ==@expr1073744957 Bound ::@expr3134 Lower ) {
240: bound@var1037 =@expr1073744959 Bound ::@expr3136 Upper ; }
241: else { if (@expr1073744961 bound@var1037 ==@expr1073744962 Bound ::@expr3136 Upper ) {
242: bound@var1037 =@expr1073744964 Bound ::@expr3134 Lower ; } }
243: }
244:
245: void invertRange ( ) {
246: invertBound (@expr1073744966 ) ;
247: decreaseRange (@expr1073744967 ) ;
248: }
249:
250: void assumeCondition ( const Token * tok@var1035 ) ;
251:
252: std :: string infoString ( ) const ;
253:
254: enum class ValueType {
255: INT ,
256: TOK ,
257: FLOAT ,
258: MOVED ,
259: UNINIT ,
260: CONTAINER_SIZE ,
261: LIFETIME ,
262: BUFFER_SIZE ,
263: ITERATOR_START ,
264: ITERATOR_END ,
265: SYMBOLIC
266: } ; enum ValueType valueType@var1036 ;
267: bool isIntValue ( ) const {
268: return valueType@var1036 ==@expr1073744969 ValueType ::@expr1073744970 INT@expr1073744968 ;
269: }
270: bool isTokValue ( ) const {
271: return valueType@var1036 ==@expr1073744971 ValueType ::@expr1073744972 TOK ;
272: }
273: bool isFloatValue ( ) const {
274: return valueType@var1036 ==@expr1073744973 ValueType ::@expr1073744974 FLOAT ;
275: }
276: bool isMovedValue ( ) const {
277: return valueType@var1036 ==@expr1073744975 ValueType ::@expr1073744976 MOVED ;
278: }
279: bool isUninitValue ( ) const {
280: return valueType@var1036 ==@expr1073744977 ValueType ::@expr1073744978 UNINIT ;
281: }
282: bool isContainerSizeValue ( ) const {
283: return valueType@var1036 ==@expr1073744979 ValueType ::@expr1073744980 CONTAINER_SIZE ;
284: }
285: bool isLifetimeValue ( ) const {
286: return valueType@var1036 ==@expr1073744981 ValueType ::@expr1073744982 LIFETIME ;
287: }
288: bool isBufferSizeValue ( ) const {
289: return valueType@var1036 ==@expr1073744983 ValueType ::@expr1073744984 BUFFER_SIZE ;
290: }
291: bool isIteratorValue ( ) const {
292: return valueType@var1036 ==@expr1073744985 ValueType ::@expr1073744986 ITERATOR_START ||@expr1073744987 valueType@var1036 ==@expr1073744988 ValueType ::@expr1073744989 ITERATOR_END ;
293: }
294: bool isIteratorStartValue ( ) const {
295: return valueType@var1036 ==@expr1073744990 ValueType ::@expr1073744991 ITERATOR_START ;
296: }
297: bool isIteratorEndValue ( ) const {
298: return valueType@var1036 ==@expr1073744992 ValueType ::@expr1073744993 ITERATOR_END ;
299: }
300: bool isSymbolicValue ( ) const {
301: return valueType@var1036 ==@expr1073744994 ValueType ::@expr1073744995 SYMBOLIC ;
302: }
303:
304: bool isLocalLifetimeValue ( ) const {
305: return valueType@var1036 ==@expr1073744997 ValueType ::@expr1073744998 LIFETIME &&@expr1073744999 lifetimeScope@var1056 ==@expr1073745000 LifetimeScope ::@expr1073745001 Local@expr1073744996 ;
306: }
307:
308: bool isArgumentLifetimeValue ( ) const {
309: return valueType@var1036 ==@expr1073745002 ValueType ::@expr1073745003 LIFETIME &&@expr1073745004 lifetimeScope@var1056 ==@expr1073745005 LifetimeScope ::@expr1073745006 Argument ;
310: }
311:
312: bool isSubFunctionLifetimeValue ( ) const {
313: return valueType@var1036 ==@expr1073745007 ValueType ::@expr1073745008 LIFETIME &&@expr1073745009 lifetimeScope@var1056 ==@expr1073745010 LifetimeScope ::@expr1073745011 SubFunction ;
314: }
315:
316: bool isNonValue ( ) const {
317: return isMovedValue (@expr1073745012 ) ||@expr1073745013 isUninitValue (@expr1073745014 ) ||@expr1073745015 isLifetimeValue (@expr1073745016 ) ;
318: }
319:
320:
321: Bound bound@var1037 ;
322:
323:
324: long long intvalue@var1038 ;
325:
326:
327: const Token * tokvalue@var1039 ;
328:
329:
330: double floatValue@var1040 ;
331:
332:
333: enum class MoveKind { NonMovedVariable , MovedVariable , ForwardedVariable } ; enum MoveKind moveKind@var1041 ;
334:
335:
336: long long varvalue@var1042 ;
337:
338:
339: const Token * condition@var1043 ;
340:
341: std :: list < std :: pair < const Token * , std :: string > > errorPath@var1044 ;
342:
343:
344: int varId@var1045 ;
345:
346:
347: bool safe@var1046 ;
348:
349:
350: bool conditional@var1047 ;
351:
352:
353: bool macro@var1048 ;
354:
355:
356: bool defaultArg@var1049 ;
357:
358: int indirect@var1050 ;
359:
360:
361: long long path@var1051 ;
362:
363:
364: long long wideintvalue@var1052 ;
365:
366: std :: vector < std :: string > subexpressions@var1053 ;
367:
368:
369: const Token * capturetok@var1054 ;
370:
371: enum class LifetimeKind {
372:
373: Object ,
374:
375: SubObject ,
376:
377: Lambda ,
378:
379: Iterator ,
380:
381: Address
382: } ; enum LifetimeKind lifetimeKind@var1055 ;
383:
384: enum class LifetimeScope { Local , Argument , SubFunction , ThisPointer , ThisValue } ; enum LifetimeScope lifetimeScope@var1056 ;
385:
386: static const char * toString ( MoveKind moveKind@var1057 ) ;
387: static const char * toString ( LifetimeKind lifetimeKind@var1058 ) ;
388: static const char * toString ( LifetimeScope lifetimeScope@var1059 ) ;
389: static const char * toString ( Bound bound@var1060 ) ;
390:
391:
392: enum class ValueKind {
393:
394: Possible ,
395:
396: Known ,
397:
398: Inconclusive ,
399:
400: Impossible
401: } ; enum ValueKind valueKind@var1061 ;
402:
403: void setKnown ( ) {
404: valueKind@var1061 =@expr1073745017 ValueKind ::@expr1073745018 Known ;
405: }
406:
407: bool isKnown ( ) const {
408: return valueKind@var1061 ==@expr1073745019 ValueKind ::@expr1073745020 Known ;
409: }
410:
411: void setPossible ( ) {
412: valueKind@var1061 =@expr1073745022 ValueKind ::@expr1073745023 Possible@expr1073745021 ;
413: }
414:
415: bool isPossible ( ) const {
416: return valueKind@var1061 ==@expr1073745025 ValueKind ::@expr1073745026 Possible@expr1073745024 ;
417: }
418:
419: bool isImpossible ( ) const {
420: return valueKind@var1061 ==@expr1073745027 ValueKind ::@expr1073745028 Impossible ;
421: }
422:
423: void setImpossible ( ) {
424: valueKind@var1061 =@expr1073745029 ValueKind ::@expr1073745030 Impossible ;
425: }
426:
427: void setInconclusive ( bool inconclusive@var1062 = true ) {
428: if (@expr1073745031 inconclusive@var1062 ) {
429: valueKind@var1061 =@expr1073745032 ValueKind ::@expr1073745033 Inconclusive ; }
430: }
431:
432: bool isInconclusive ( ) const {
433: return valueKind@var1061 ==@expr1073745034 ValueKind ::@expr1073745035 Inconclusive ;
434: }
435:
436: void changeKnownToPossible ( ) {
437: if (@expr1073745037 isKnown (@expr1073745038 ) ) {
438: valueKind@var1061 =@expr1073745039 ValueKind ::@expr1073745040 Possible@expr1073745036 ; }
439: }
440:
441: bool errorSeverity ( ) const {
442: return !@expr1073745041 condition@var1043 &&@expr1073745042 !@expr1073745043 defaultArg@var1049 ;
443: }
444:
445: static bool sameToken ( const Token * tok1@var1063 , const Token * tok2@var1064 ) ;
446: } ;
447:
448:
449: const ValueFlow :: Value * valueFlowConstantFoldAST ( Token * expr@var1065 , const Settings * settings@var1066 ) ;
450:
451:
452: void setValues ( TokenList * tokenlist@var1067 , SymbolDatabase * symboldatabase@var1068 , ErrorLogger * errorLogger@var1069 , const Settings * settings@var1070 ) ;
453:
454: std :: string eitherTheConditionIsRedundant ( const Token * condition@var1071 ) ;
455:
456: unsigned long getSizeOf ( const ValueType & vt@var1072 , const Settings * settings@var1073 ) ;
457:
458: const ValueFlow :: Value * findValue ( const std :: list < ValueFlow :: Value > & values@var1074 ,
459: const Settings * settings@var1075 ,
460: std :: function < bool ( const ValueFlow :: Value & ) > pred@var1076 ) ;
461:
462: std :: vector < ValueFlow :: Value > isOutOfBounds ( const Value & size@var1077 , const Token * indexTok@var1078 , bool possible@var1079 = true ) ;
463: }
464:
465: ValueFlow :: Value asImpossible ( ValueFlow :: Value v@var1080 ) ;
466:
467: bool isContainerSizeChanged ( const Token * tok@var1081 , const Settings * settings@var1082 = nullptr , int depth@var1083 = 20 ) ;
468:
469: struct LifetimeToken {
470: const Token * token@var1084 ;
471: bool addressOf@var1085 ;
472: std :: list < std :: pair < const Token * , std :: string > > errorPath@var1086 ;
473: bool inconclusive@var1087 ;
474:
475: LifetimeToken ( ) : token@var1084 ( nullptr ) , addressOf@var1085 ( false ) , errorPath@var1086 ( ) , inconclusive@var1087 ( false ) { }
476:
477: LifetimeToken ( const Token * token@var1088 , std :: list < std :: pair < const Token * , std :: string > > errorPath@var1089 )
478: : token@var1084 ( token@var1088 ) , addressOf@var1085 ( false ) , errorPath@var1086 ( std :: move ( errorPath@var1089 ) ) , inconclusive@var1087 ( false )
479: { }
480:
481: LifetimeToken ( const Token * token@var1090 , bool addressOf@var1091 , std :: list < std :: pair < const Token * , std :: string > > errorPath@var1092 )
482: : token@var1084 ( token@var1090 ) , addressOf@var1085 ( addressOf@var1091 ) , errorPath@var1086 ( std :: move ( errorPath@var1092 ) ) , inconclusive@var1087 ( false )
483: { }
484:
485: static std :: vector < LifetimeToken > setAddressOf ( std :: vector < LifetimeToken > v@var1093 , bool b@var1094 ) {
486: for (@expr1073745044 LifetimeToken &@expr1073745045 x@var1095 :@expr1073745046 v@var1093 ) {
487: x@var1095 .@expr1073745047 addressOf@var1096 =@expr1073745048 b@var1094 ; }
488: return v@var1093 ;
489: }
490:
491: static std :: vector < LifetimeToken > setInconclusive ( std :: vector < LifetimeToken > v@var1097 , bool b@var1098 ) {
492: for (@expr1073745049 LifetimeToken &@expr1073745050 x@var1099 :@expr1073745051 v@var1097 ) {
493: x@var1099 .@expr1073745052 inconclusive@var1100 =@expr1073745053 b@var1098 ; }
494: return v@var1097 ;
495: }
496: } ;
497:
498: const Token * parseCompareInt ( const Token * tok@var1101 , ValueFlow :: Value & true_value@var1102 , ValueFlow :: Value & false_value@var1103 , const std :: function < std :: vector < long long > ( const Token * ) > & evaluate@var1104 ) ;
499: const Token * parseCompareInt ( const Token * tok@var1105 , ValueFlow :: Value & true_value@var1106 , ValueFlow :: Value & false_value@var1107 ) ;
500:
501: ValueFlow :: Value inferCondition ( std :: string op@var1108 , long long val@var1109 , const Token * varTok@var1110 ) ;
502: ValueFlow :: Value inferCondition ( const std :: string & op@var1111 , const Token * varTok@var1112 , long long val@var1113 ) ;
503:
504: ValuePtr < InferModel > makeIntegralInferModel ( ) ;
505:
506: const Token * solveExprValue ( const Token * expr@var1114 ,
507: const std :: function < std :: vector < long long > ( const Token * ) > & eval@var1115 ,
508: ValueFlow :: Value & value@var1116 ) ;
509:
510: std :: vector < LifetimeToken > getLifetimeTokens ( const Token * tok@var1117 ,
511: bool escape@var1118 = false ,
512: std :: list < std :: pair < const Token * , std :: string > > errorPath@var1119 = std :: list < std :: pair < const Token * , std :: string > > { } ) ;
513:
514: bool hasLifetimeToken ( const Token * tok@var1120 , const Token * lifetime@var1121 ) ;
515:
516: const Variable * getLifetimeVariable ( const Token * tok@var1122 , std :: list < std :: pair < const Token * , std :: string > > & errorPath@var1123 , bool * addressOf@var1124 = nullptr ) ;
517:
518: const Variable * getLifetimeVariable ( const Token * tok@var1125 ) ;
519:
520: bool isLifetimeBorrowed ( const Token * tok@var1126 , const Settings * settings@var1127 ) ;
521:
522: std :: string lifetimeType ( const Token * tok@var1128 , const ValueFlow :: Value * val@var1129 ) ;
523:
524: std :: string lifetimeMessage ( const Token * tok@var1130 , const ValueFlow :: Value * val@var1131 , std :: list < std :: pair < const Token * , std :: string > > & errorPath@var1132 ) ;
525:
526: ValueFlow :: Value getLifetimeObjValue ( const Token * tok@var1133 , bool inconclusive@var1134 = false ) ;
527:
528: std :: vector < ValueFlow :: Value > getLifetimeObjValues ( const Token * tok@var1135 ,
529: bool inconclusive@var1136 = false ,
530: long long path@var1137 = 0 ) ;
531:
532: const Token * getEndOfExprScope ( const Token * tok@var1138 , const Scope * defaultScope@var1139 = nullptr , bool smallest@var1140 = true ) ;

##file cppcheck-2.8/lib/token.h

1:
|
40:
41: class Enumerator ;
42: class Function ;
43: class Scope ;
44: class Settings ;
45: class Type ;
46: class ValueType ;
47: class Variable ;
48: class TokenList ;
49: class ConstTokenRange ;
50: class Token ;
51:
|
54:
55: struct TokensFrontBack {
56: Token * front@var1141 ;
57: Token * back@var1142 ;
58: const TokenList * list@var1143 ;
59: } ;
60:
61: struct ScopeInfo2 {
62: ScopeInfo2 ( const std :: string & name_@var1144 , const Token * bodyEnd_@var1145 , const std :: set < std :: string > & usingNamespaces_@var1146 = std :: set < std :: string > ( ) ) : name@var1147 ( name_@var1144 ) , bodyEnd@var1148 ( bodyEnd_@var1145 ) , usingNamespaces@var1149 ( usingNamespaces_@var1146 ) { }
63: std :: string name@var1147 ;
64: const Token * const bodyEnd@var1148 ;
65: std :: set < std :: string > usingNamespaces@var1149 ;
66: } ;
67:
68: struct TokenImpl {
69: int mVarId@var1150 ;
70: int mFileIndex@var1151 ;
71: int mLineNumber@var1152 ;
72: int mColumn@var1153 ;
73: int mExprId@var1154 ;
74:
75:
76: Token * mAstOperand1@var1155 ;
77: Token * mAstOperand2@var1156 ;
78: Token * mAstParent@var1157 ;
79:
80:
81: const Scope * mScope@var1158 ;
82: union {
83: const Function * mFunction@var1159 ;
84: const Variable * mVariable@var1160 ;
85: const :: Type * mType@var1161 ;
86: const Enumerator * mEnumerator@var1162 ;
87: } ;
88:
|
92:
93: int mProgressValue@var1163 ;
94:
|
97:
98: int mIndex@var1164 ;
99:
100:
101: std :: string * mOriginalName@var1165 ;
102:
103:
104: ValueType * mValueType@var1166 ;
105:
106:
107: std :: list < ValueFlow :: Value > * mValues@var1167 ;
108: static const std :: list < ValueFlow :: Value > mEmptyValueList@var1168 ;
109:
110:
111: std :: set < TemplateSimplifier :: TokenAndName * > * mTemplateSimplifierPointers@var1169 ;
112:
113:
114: std :: shared_ptr < ScopeInfo2 > mScopeInfo@var1170 ;
115:
116:
117: struct CppcheckAttributes {
118: enum Type { LOW , HIGH } ; enum Type type@var1171 ;
119: long long value@var1172 ;
120: struct CppcheckAttributes * next@var1173 ;
121: } ;
122: struct CppcheckAttributes * mCppcheckAttributes@var1174 ;
123:
124:
125: enum class Cpp11init { UNKNOWN , CPP11INIT , NOINIT } ; enum Cpp11init mCpp11init@var1175 ;
126:
127:
128: unsigned char mBits@var1176 ;
129:
130: void setCppcheckAttribute ( CppcheckAttributes :: Type type@var1177 , long long value@var1178 ) ;
131: bool getCppcheckAttribute ( CppcheckAttributes :: Type type@var1179 , long long * value@var1180 ) const ;
132:
133: TokenImpl ( )
134: : mVarId@var1150 ( 0 )
135: , mFileIndex@var1151 ( 0 )
136: , mLineNumber@var1152 ( 0 )
137: , mColumn@var1153 ( 0 )
138: , mExprId@var1154 ( 0 )
139: , mAstOperand1@var1155 ( nullptr )
140: , mAstOperand2@var1156 ( nullptr )
141: , mAstParent@var1157 ( nullptr )
142: , mScope@var1158 ( nullptr )
143: , mFunction@var1159 ( nullptr )
144: , mProgressValue@var1163 ( 0 )
145: , mIndex@var1164 ( 0 )
146: , mOriginalName@var1165 ( nullptr )
147: , mValueType@var1166 ( nullptr )
148: , mValues@var1167 ( nullptr )
149: , mTemplateSimplifierPointers@var1169 ( nullptr )
150: , mScopeInfo@var1170 ( nullptr )
151: , mCppcheckAttributes@var1174 ( nullptr )
152: , mCpp11init@var1175 ( Cpp11init :: UNKNOWN )
153: , mBits@var1176 ( 0 )
154: { }
155:
156: ~ TokenImpl ( ) ;
157: } ;
158:
|
171:
172: class Token {
173: private:
174: TokensFrontBack * mTokensFrontBack@var1181 ;
175:
176:
177: Token ( const Token & ) ;
178: Token operator= ( const Token & ) ;
179:
180: public:
181: enum Type {
182: eVariable , eType , eFunction , eKeyword , eName ,
183: eNumber , eString , eChar , eBoolean , eLiteral , eEnumerator ,
184: eArithmeticalOp , eComparisonOp , eAssignmentOp , eLogicalOp , eBitOp , eIncDecOp , eExtendedOp ,
185: eBracket ,
186: eLambda ,
187: eEllipsis ,
188: eOther ,
189: eNone
190: } ;
191:
192: explicit Token ( TokensFrontBack * tokensFrontBack@var1182 = nullptr ) ;
193: ~ Token ( ) ;
194:
195: ConstTokenRange until ( const Token * t@var1183 ) const ;
196:
197: template < typename T >
198: void str ( T && s@var1184 ) {
199: mStr@var1396 =@expr1073745054 s@var1184 ;
200: mImpl@var1402 .@expr1073745055 mVarId@var1433 =@expr1073745056 0 ;
201:
202: update_property_info (@expr1073745057 ) ;
203: }
204:
|
208:
209: void concatStr ( const std :: string & b@var1185 ) ;
210:
211: const std :: string & str ( ) const {
212: return mStr@var1396 ;
213: }
214:
|
217:
218: void deleteNext ( int count@var1186 = 1 ) ;
219:
|
222:
223: void deletePrevious ( int count@var1187 = 1 ) ;
224:
|
227:
228: void swapWithNext ( ) ;
229:
|
234:
235: const Token * tokAt ( int index@var1188 ) const ;
236: Token * tokAt ( int index@var1189 ) {
237: return const_cast < Token *@expr3234 > (@expr1073745059 const_cast < const Token *@expr3234 > (@expr1073745061 this@expr1073745062 ) .@expr1073745063 tokAt (@expr1073745064 index@var1189 ) ) ;
238: }
239:
|
243:
244: const Token * linkAt ( int index@var1190 ) const ;
245: Token * linkAt ( int index@var1191 ) {
246: return const_cast < Token *@expr3241 > (@expr1073745066 const_cast < const Token *@expr3241 > (@expr1073745068 this@expr1073745069 ) .@expr1073745070 linkAt (@expr1073745071 index@var1191 ) ) ;
247: }
248:
|
252:
253: const std :: string & strAt ( int index@var1192 ) const ;
254:
|
273:
274: template < unsigned long count >
275: static bool simpleMatch ( const Token * tok@var1193 , const char ( & pattern@var1194 ) [ count ] ) {
276: return simpleMatch (@expr1073745073 tok@var1193 , pattern@var1194 , count@expr1073745072 -@expr1073745074 1 ) ;
277: }
278:
279: static bool simpleMatch ( const Token * tok@var1195 , const char pattern@var1196 [ ] , unsigned long pattern_len@var1197 ) ;
280:
|
323:
324: static bool Match ( const Token * tok@var1198 , const char pattern@var1199 [ ] , int varid@var1200 = 0 ) ;
325:
|
332:
333: static int getStrLength ( const Token * tok@var1201 ) ;
334:
|
341:
342: static int getStrArraySize ( const Token * tok@var1202 ) ;
343:
|
351:
352: static int getStrSize ( const Token * tok@var1203 , const Settings * const settings@var1204 ) ;
353:
|
361:
362: static std :: string getCharAt ( const Token * tok@var1205 , long long index@var1206 ) ;
363:
364: const ValueType * valueType ( ) const {
365: return mImpl@var1402 .@expr1073745075 mValueType@var1434 ;
366: }
367: void setValueType ( ValueType * vt@var1207 ) ;
368:
369: const ValueType * argumentType ( ) const {
370: const Token * top@var1208 ; top@var1208 =@expr1073745076 this@expr1073745077 ;
371: while (@expr1073745078 top@var1208 &&@expr1073745079 !@expr1073745080 Token ::@expr1073745081 Match (@expr1073745082 top@var1208 .@expr3259 astParent (@expr3260 ) , ",|(" ) ) {
372: top@var1208 =@expr1073745085 top@var1208 .@expr3259 astParent (@expr3260 ) ; }
373: return top@var1208 ?@expr1073745088 top@var1208 .@expr1073745089 mImpl@var1209 .@expr1073745090 mValueType@var1210 :@expr1073745091 nullptr ;
374: }
375:
376: Token :: Type tokType ( ) const {
377: return mTokType@var1400 ;
378: }
379: void tokType ( Token :: Type t@var1211 ) {
380: mTokType@var1400 =@expr1073745092 t@var1211 ;
381:
382: const bool memoizedIsName@var1212 =@expr1073745093 mTokType@var1400 ==@expr1073745094 eName ||@expr1073745095 mTokType@var1400 ==@expr1073745096 eType ||@expr1073745097 mTokType@var1400 ==@expr1073745098 eVariable ||@expr1073745099
383: mTokType@var1400 ==@expr1073745100 eFunction ||@expr1073745101 mTokType@var1400 ==@expr1073745102 eKeyword ||@expr1073745103 mTokType@var1400 ==@expr3280 eBoolean ||@expr1073745105
384: mTokType@var1400 ==@expr3282 eEnumerator ;
385: setFlag (@expr1073745107 fIsName , memoizedIsName@var1212 ) ;
386:
387: const bool memoizedIsLiteral@var1213 =@expr1073745108 mTokType@var1400 ==@expr1073745109 eNumber ||@expr1073745110 mTokType@var1400 ==@expr1073745111 eString ||@expr1073745112 mTokType@var1400 ==@expr1073745113 eChar ||@expr1073745114
388: mTokType@var1400 ==@expr3280 eBoolean ||@expr1073745116 mTokType@var1400 ==@expr1073745117 eLiteral ||@expr1073745118 mTokType@var1400 ==@expr3282 eEnumerator ;
389: setFlag (@expr1073745120 fIsLiteral , memoizedIsLiteral@var1213 ) ;
390: }
391: bool isKeyword ( ) const {
392: return mTokType@var1400 ==@expr1073745121 eKeyword ;
393: }
394: bool isName ( ) const {
395: return getFlag (@expr1073745122 fIsName ) ;
396: }
397: bool isNameOnly ( ) const {
398: return mFlags@var1401 ==@expr1073745123 fIsName &&@expr1073745124 mTokType@var1400 ==@expr1073745125 eName ;
399: }
400: bool isUpperCaseName ( ) const ;
401: bool isLiteral ( ) const {
402: return getFlag (@expr1073745126 fIsLiteral ) ;
403: }
404: bool isNumber ( ) const {
405: return mTokType@var1400 ==@expr1073745127 eNumber ;
406: }
407: bool isEnumerator ( ) const {
408: return mTokType@var1400 ==@expr1073745128 eEnumerator ;
409: }
410: bool isOp ( ) const {
411: return (@expr1073745129 isConstOp (@expr1073745130 ) ||@expr1073745131
412: isAssignmentOp (@expr1073745132 ) ||@expr1073745133
413: mTokType@var1400 ==@expr1073745134 eIncDecOp ) ;
414: }
415: bool isConstOp ( ) const {
416: return (@expr1073745135 isArithmeticalOp (@expr1073745136 ) ||@expr1073745137
417: mTokType@var1400 ==@expr1073745138 eLogicalOp ||@expr1073745139
418: mTokType@var1400 ==@expr1073745140 eComparisonOp ||@expr1073745141
419: mTokType@var1400 ==@expr1073745142 eBitOp ) ;
420: }
421: bool isExtendedOp ( ) const {
422: return isConstOp (@expr1073745143 ) ||@expr1073745144
423: mTokType@var1400 ==@expr1073745145 eExtendedOp ;
424: }
425: bool isArithmeticalOp ( ) const {
426: return mTokType@var1400 ==@expr1073745146 eArithmeticalOp ;
427: }
428: bool isComparisonOp ( ) const {
429: return mTokType@var1400 ==@expr1073745147 eComparisonOp ;
430: }
431: bool isAssignmentOp ( ) const {
432: return mTokType@var1400 ==@expr1073745148 eAssignmentOp ;
433: }
434: bool isBoolean ( ) const {
435: return mTokType@var1400 ==@expr1073745149 eBoolean ;
436: }
437: bool isIncDecOp ( ) const {
438: return mTokType@var1400 ==@expr1073745150 eIncDecOp ;
439: }
440: bool isBinaryOp ( ) const {
441: return astOperand1 (@expr1073745151 ) !=@expr1073745152 nullptr &&@expr1073745153 astOperand2 (@expr1073745154 ) !=@expr1073745155 nullptr ;
442: }
443: bool isUnaryOp ( const std :: string & s@var1214 ) const {
444: return s@var1214 ==@expr1073745156 mStr@var1396 &&@expr1073745157 astOperand1 (@expr1073745158 ) !=@expr1073745159 nullptr &&@expr1073745160 astOperand2 (@expr1073745161 ) ==@expr1073745162 nullptr ;
445: }
446: bool isUnaryPreOp ( ) const ;
447:
448: unsigned int flags ( ) const {
449: return mFlags@var1401 ;
450: }
451: void flags ( const unsigned int flags_@var1215 ) {
452: mFlags@var1401 =@expr1073745163 flags_@var1215 ;
453: }
454: bool isUnsigned ( ) const {
455: return getFlag (@expr1073745164 fIsUnsigned ) ;
456: }
457: void isUnsigned ( const bool sign@var1216 ) {
458: setFlag (@expr1073745165 fIsUnsigned , sign@var1216 ) ;
459: }
460: bool isSigned ( ) const {
461: return getFlag (@expr1073745166 fIsSigned ) ;
462: }
463: void isSigned ( const bool sign@var1217 ) {
464: setFlag (@expr1073745167 fIsSigned , sign@var1217 ) ;
465: }
466: bool isPointerCompare ( ) const {
467: return getFlag (@expr1073745168 fIsPointerCompare ) ;
468: }
469: void isPointerCompare ( const bool b@var1218 ) {
470: setFlag (@expr1073745169 fIsPointerCompare , b@var1218 ) ;
471: }
472: bool isLong ( ) const {
473: return getFlag (@expr1073745170 fIsLong ) ;
474: }
475: void isLong ( bool size@var1219 ) {
476: setFlag (@expr1073745171 fIsLong , size@var1219 ) ;
477: }
478: bool isStandardType ( ) const {
479: return getFlag (@expr1073745172 fIsStandardType ) ;
480: }
481: void isStandardType ( const bool b@var1220 ) {
482: setFlag (@expr1073745173 fIsStandardType , b@var1220 ) ;
483: }
484: bool isExpandedMacro ( ) const {
485: return getFlag (@expr1073745174 fIsExpandedMacro ) ;
486: }
487: void isExpandedMacro ( const bool m@var1221 ) {
488: setFlag (@expr1073745175 fIsExpandedMacro , m@var1221 ) ;
489: }
490: bool isCast ( ) const {
491: return getFlag (@expr1073745176 fIsCast ) ;
492: }
493: void isCast ( bool c@var1222 ) {
494: setFlag (@expr1073745177 fIsCast , c@var1222 ) ;
495: }
496: bool isAttributeConstructor ( ) const {
497: return getFlag (@expr1073745178 fIsAttributeConstructor ) ;
498: }
499: void isAttributeConstructor ( const bool ac@var1223 ) {
500: setFlag (@expr1073745179 fIsAttributeConstructor , ac@var1223 ) ;
501: }
502: bool isAttributeDestructor ( ) const {
503: return getFlag (@expr1073745180 fIsAttributeDestructor ) ;
504: }
505: void isAttributeDestructor ( const bool value@var1224 ) {
506: setFlag (@expr1073745181 fIsAttributeDestructor , value@var1224 ) ;
507: }
508: bool isAttributeUnused ( ) const {
509: return getFlag (@expr1073745182 fIsAttributeUnused ) ;
510: }
511: void isAttributeUnused ( bool unused@var1225 ) {
512: setFlag (@expr1073745183 fIsAttributeUnused , unused@var1225 ) ;
513: }
514: bool isAttributeUsed ( ) const {
515: return getFlag (@expr1073745184 fIsAttributeUsed ) ;
516: }
517: void isAttributeUsed ( const bool unused@var1226 ) {
518: setFlag (@expr1073745185 fIsAttributeUsed , unused@var1226 ) ;
519: }
520: bool isAttributePure ( ) const {
521: return getFlag (@expr1073745186 fIsAttributePure ) ;
522: }
523: void isAttributePure ( const bool value@var1227 ) {
524: setFlag (@expr1073745187 fIsAttributePure , value@var1227 ) ;
525: }
526: bool isAttributeConst ( ) const {
527: return getFlag (@expr1073745188 fIsAttributeConst ) ;
528: }
529: void isAttributeConst ( bool value@var1228 ) {
530: setFlag (@expr1073745189 fIsAttributeConst , value@var1228 ) ;
531: }
532: bool isAttributeNoreturn ( ) const {
533: return getFlag (@expr1073745190 fIsAttributeNoreturn ) ;
534: }
535: void isAttributeNoreturn ( const bool value@var1229 ) {
536: setFlag (@expr1073745191 fIsAttributeNoreturn , value@var1229 ) ;
537: }
538: bool isAttributeNothrow ( ) const {
539: return getFlag (@expr1073745192 fIsAttributeNothrow ) ;
540: }
541: void isAttributeNothrow ( const bool value@var1230 ) {
542: setFlag (@expr1073745193 fIsAttributeNothrow , value@var1230 ) ;
543: }
544: bool isAttributePacked ( ) const {
545: return getFlag (@expr1073745194 fIsAttributePacked ) ;
546: }
547: void isAttributePacked ( const bool value@var1231 ) {
548: setFlag (@expr1073745195 fIsAttributePacked , value@var1231 ) ;
549: }
550: bool isAttributeNodiscard ( ) const {
551: return getFlag (@expr1073745196 fIsAttributeNodiscard ) ;
552: }
553: void isAttributeNodiscard ( const bool value@var1232 ) {
554: setFlag (@expr1073745197 fIsAttributeNodiscard , value@var1232 ) ;
555: }
556: bool isAttributeMaybeUnused ( ) const {
557: return getFlag (@expr1073745198 fIsAttributeMaybeUnused ) ;
558: }
559: void isAttributeMaybeUnused ( const bool value@var1233 ) {
560: setFlag (@expr1073745199 fIsAttributeMaybeUnused , value@var1233 ) ;
561: }
562: void setCppcheckAttribute ( TokenImpl :: CppcheckAttributes :: Type type@var1234 , long long value@var1235 ) {
563: mImpl@var1402 .@expr1073745200 setCppcheckAttribute (@expr1073745201 type@var1234 , value@var1235 ) ;
564: }
565: bool getCppcheckAttribute ( TokenImpl :: CppcheckAttributes :: Type type@var1236 , long long * value@var1237 ) const {
566: return mImpl@var1402 .@expr1073745202 getCppcheckAttribute (@expr1073745203 type@var1236 , value@var1237 ) ;
567: }
568: bool hasCppcheckAttributes ( ) const {
569: return nullptr !=@expr1073745204 mImpl@var1402 .@expr1073745205 mCppcheckAttributes@var1435 ;
570: }
571: bool isControlFlowKeyword ( ) const {
572: return getFlag (@expr1073745206 fIsControlFlowKeyword ) ;
573: }
574: bool isOperatorKeyword ( ) const {
575: return getFlag (@expr1073745207 fIsOperatorKeyword ) ;
576: }
577: void isOperatorKeyword ( const bool value@var1238 ) {
578: setFlag (@expr1073745208 fIsOperatorKeyword , value@var1238 ) ;
579: }
580: bool isComplex ( ) const {
581: return getFlag (@expr1073745209 fIsComplex ) ;
582: }
583: void isComplex ( const bool value@var1239 ) {
584: setFlag (@expr1073745210 fIsComplex , value@var1239 ) ;
585: }
586: bool isEnumType ( ) const {
587: return getFlag (@expr1073745211 fIsEnumType ) ;
588: }
589: void isEnumType ( const bool value@var1240 ) {
590: setFlag (@expr1073745212 fIsEnumType , value@var1240 ) ;
591: }
592: bool isAtAddress ( ) const {
593: return getFlag (@expr1073745213 fAtAddress ) ;
594: }
595: void isAtAddress ( bool b@var1241 ) {
596: setFlag (@expr1073745214 fAtAddress , b@var1241 ) ;
597: }
598: bool isIncompleteVar ( ) const {
599: return getFlag (@expr1073745215 fIncompleteVar ) ;
600: }
601: void isIncompleteVar ( bool b@var1242 ) {
602: setFlag (@expr1073745216 fIncompleteVar , b@var1242 ) ;
603: }
604:
605: bool isIncompleteConstant ( ) const {
606: return getFlag (@expr1073745217 fIsIncompleteConstant ) ;
607: }
608: void isIncompleteConstant ( bool b@var1243 ) {
609: setFlag (@expr1073745218 fIsIncompleteConstant , b@var1243 ) ;
610: }
611:
612: bool isConstexpr ( ) const {
613: return getFlag (@expr1073745219 fConstexpr ) ;
614: }
615: void isConstexpr ( bool b@var1244 ) {
616: setFlag (@expr1073745220 fConstexpr , b@var1244 ) ;
617: }
618:
619: bool isExternC ( ) const {
620: return getFlag (@expr1073745221 fExternC ) ;
621: }
622: void isExternC ( bool b@var1245 ) {
623: setFlag (@expr1073745222 fExternC , b@var1245 ) ;
624: }
625:
626: bool isSplittedVarDeclComma ( ) const {
627: return getFlag (@expr1073745223 fIsSplitVarDeclComma ) ;
628: }
629: void isSplittedVarDeclComma ( bool b@var1246 ) {
630: setFlag (@expr1073745224 fIsSplitVarDeclComma , b@var1246 ) ;
631: }
632:
633: bool isSplittedVarDeclEq ( ) const {
634: return getFlag (@expr1073745225 fIsSplitVarDeclEq ) ;
635: }
636: void isSplittedVarDeclEq ( bool b@var1247 ) {
637: setFlag (@expr1073745226 fIsSplitVarDeclEq , b@var1247 ) ;
638: }
639:
640: bool isImplicitInt ( ) const {
641: return getFlag (@expr1073745227 fIsImplicitInt ) ;
642: }
643: void isImplicitInt ( bool b@var1248 ) {
644: setFlag (@expr1073745228 fIsImplicitInt , b@var1248 ) ;
645: }
646:
647: bool isInline ( ) const {
648: return getFlag (@expr1073745229 fIsInline ) ;
649: }
650: void isInline ( bool b@var1249 ) {
651: setFlag (@expr1073745230 fIsInline , b@var1249 ) ;
652: }
653:
654: bool isRemovedVoidParameter ( ) const {
655: return getFlag (@expr1073745231 fIsRemovedVoidParameter ) ;
656: }
657: void setRemovedVoidParameter ( bool b@var1250 ) {
658: setFlag (@expr1073745232 fIsRemovedVoidParameter , b@var1250 ) ;
659: }
660:
661: bool isTemplate ( ) const {
662: return getFlag (@expr1073745233 fIsTemplate ) ;
663: }
664: void isTemplate ( bool b@var1251 ) {
665: setFlag (@expr1073745234 fIsTemplate , b@var1251 ) ;
666: }
667:
668: bool isSimplifiedScope ( ) const {
669: return getFlag (@expr1073745235 fIsSimplifedScope ) ;
670: }
671: void isSimplifiedScope ( bool b@var1252 ) {
672: setFlag (@expr1073745236 fIsSimplifedScope , b@var1252 ) ;
673: }
674:
675: bool isBitfield ( ) const {
676: return mImpl@var1402 .@expr1073745237 mBits@var1436 >@expr1073745238 0 ;
677: }
678: unsigned char bits ( ) const {
679: return mImpl@var1402 .@expr1073745239 mBits@var1436 ;
680: }
681: std :: set < TemplateSimplifier :: TokenAndName * > * templateSimplifierPointers ( ) const {
682: return mImpl@var1402 .@expr1073745240 mTemplateSimplifierPointers@var1437 ;
683: }
684: void templateSimplifierPointer ( TemplateSimplifier :: TokenAndName * tokenAndName@var1253 ) {
685: if (@expr1073745241 !@expr1073745242 mImpl@var1402 .@expr3419 mTemplateSimplifierPointers@var1437 ) {
686: mImpl@var1402 .@expr3419 mTemplateSimplifierPointers@var1437 =@expr1073745245 new std ::@expr1073745246 set < TemplateSimplifier ::@expr1073745247 TokenAndName *@expr1073745248 > ; }
687: mImpl@var1402 .@expr3419 mTemplateSimplifierPointers@var1437 .@expr1073745250 insert (@expr1073745251 tokenAndName@var1253 ) ;
688: }
689: void setBits ( const unsigned char b@var1254 ) {
690: mImpl@var1402 .@expr1073745252 mBits@var1436 =@expr1073745253 b@var1254 ;
691: }
692:
693: bool isUtf8 ( ) const {
694: return (@expr3430 (@expr3430 (@expr3430 mTokType@var1400 ==@expr1073745257 eString ) &&@expr1073745258 isPrefixStringCharLiteral (@expr1073745259 mStr@var1396 , '"' , "u8" ) ) ||@expr1073745260
695: (@expr3430 (@expr3430 mTokType@var1400 ==@expr1073745263 eChar ) &&@expr1073745264 isPrefixStringCharLiteral (@expr1073745265 mStr@var1396 , '\'' , "u8" ) ) ) ;
696: }
697:
698: bool isUtf16 ( ) const {
699: return (@expr3442 (@expr3442 (@expr3442 mTokType@var1400 ==@expr1073745269 eString ) &&@expr1073745270 isPrefixStringCharLiteral (@expr1073745271 mStr@var1396 , '"' , "u" ) ) ||@expr1073745272
700: (@expr3442 (@expr3442 mTokType@var1400 ==@expr1073745275 eChar ) &&@expr1073745276 isPrefixStringCharLiteral (@expr1073745277 mStr@var1396 , '\'' , "u" ) ) ) ;
701: }
702:
703: bool isUtf32 ( ) const {
704: return (@expr3454 (@expr3454 (@expr3454 mTokType@var1400 ==@expr1073745281 eString ) &&@expr1073745282 isPrefixStringCharLiteral (@expr1073745283 mStr@var1396 , '"' , "U" ) ) ||@expr1073745284
705: (@expr3454 (@expr3454 mTokType@var1400 ==@expr1073745287 eChar ) &&@expr1073745288 isPrefixStringCharLiteral (@expr1073745289 mStr@var1396 , '\'' , "U" ) ) ) ;
706: }
707:
708: bool isCChar ( ) const {
709: return (@expr3466 (@expr3466 (@expr3466 mTokType@var1400 ==@expr1073745293 eString ) &&@expr1073745294 isPrefixStringCharLiteral (@expr1073745295 mStr@var1396 , '"' , "" ) ) ||@expr1073745296
710: (@expr3466 (@expr3466 mTokType@var1400 ==@expr1073745299 eChar ) &&@expr1073745300 isPrefixStringCharLiteral (@expr1073745301 mStr@var1396 , '\'' , "" ) &&@expr1073745302 mStr@var1396 .@expr1073745303 length (@expr1073745304 ) ==@expr1073745305 3 ) ) ;
711: }
712:
713: bool isCMultiChar ( ) const {
714: return (@expr3482 (@expr3482 (@expr3482 mTokType@var1400 ==@expr1073745309 eChar ) &&@expr1073745310 isPrefixStringCharLiteral (@expr1073745311 mStr@var1396 , '\'' , "" ) ) &&@expr1073745312
715: (@expr3482 mStr@var1396 .@expr1073745314 length (@expr1073745315 ) >@expr1073745316 3 ) ) ;
716: }
717:
|
733:
734: bool isTemplateArg ( ) const {
735: return getFlag (@expr1073745317 fIsTemplateArg ) ;
736: }
737: void isTemplateArg ( const bool value@var1255 ) {
738: setFlag (@expr1073745318 fIsTemplateArg , value@var1255 ) ;
739: }
740:
741: template < unsigned long count >
742: static const Token * findsimplematch ( const Token * const startTok@var1256 , const char ( & pattern@var1257 ) [ count ] ) {
743: return findsimplematch (@expr1073745320 startTok@var1256 , pattern@var1257 , count@expr1073745319 -@expr1073745321 1 ) ;
744: }
745: static const Token * findsimplematch ( const Token * const startTok@var1258 , const char pattern@var1259 [ ] , unsigned long pattern_len@var1260 ) ;
746:
747: template < unsigned long count >
748: static const Token * findsimplematch ( const Token * const startTok@var1261 , const char ( & pattern@var1262 ) [ count ] , const Token * const end@var1263 ) {
749: return findsimplematch (@expr1073745323 startTok@var1261 , pattern@var1262 , count@expr1073745322 -@expr1073745324 1 , end@var1263 ) ;
750: }
751: static const Token * findsimplematch ( const Token * const startTok@var1264 , const char pattern@var1265 [ ] , unsigned long pattern_len@var1266 , const Token * const end@var1267 ) ;
752:
753: static const Token * findmatch ( const Token * const startTok@var1268 , const char pattern@var1269 [ ] , const int varId@var1270 = 0 ) ;
754: static const Token * findmatch ( const Token * const startTok@var1271 , const char pattern@var1272 [ ] , const Token * const end@var1273 , const int varId@var1274 = 0 ) ;
755:
756: template < unsigned long count >
757: static Token * findsimplematch ( Token * const startTok@var1275 , const char ( & pattern@var1276 ) [ count ] ) {
758: return findsimplematch (@expr1073745326 startTok@var1275 , pattern@var1276 , count@expr1073745325 -@expr1073745327 1 ) ;
759: }
760: static Token * findsimplematch ( Token * const startTok@var1277 , const char pattern@var1278 [ ] , unsigned long pattern_len@var1279 ) {
761: return const_cast < Token *@expr3504 > (@expr1073745329 findsimplematch (@expr1073745330 const_cast < const Token *@expr3504 > (@expr1073745332 startTok@var1277 ) , pattern@var1278 , pattern_len@var1279 ) ) ;
762: }
763: template < unsigned long count >
764: static Token * findsimplematch ( Token * const startTok@var1280 , const char ( & pattern@var1281 ) [ count ] , const Token * const end@var1282 ) {
765: return findsimplematch (@expr1073745334 startTok@var1280 , pattern@var1281 , count@expr1073745333 -@expr1073745335 1 , end@var1282 ) ;
766: }
767: static Token * findsimplematch ( Token * const startTok@var1283 , const char pattern@var1284 [ ] , unsigned long pattern_len@var1285 , const Token * const end@var1286 ) {
768: return const_cast < Token *@expr3512 > (@expr1073745337 findsimplematch (@expr1073745338 const_cast < const Token *@expr3512 > (@expr1073745340 startTok@var1283 ) , pattern@var1284 , pattern_len@var1285 , end@var1286 ) ) ;
769: }
770:
771: static Token * findmatch ( Token * const startTok@var1287 , const char pattern@var1288 [ ] , const int varId@var1289 = 0 ) {
772: return const_cast < Token *@expr3517 > (@expr1073745342 findmatch (@expr1073745343 const_cast < const Token *@expr3517 > (@expr1073745345 startTok@var1287 ) , pattern@var1288 , varId@var1289 ) ) ;
773: }
774: static Token * findmatch ( Token * const startTok@var1290 , const char pattern@var1291 [ ] , const Token * const end@var1292 , const int varId@var1293 = 0 ) {
775: return const_cast < Token *@expr3522 > (@expr1073745347 findmatch (@expr1073745348 const_cast < const Token *@expr3522 > (@expr1073745350 startTok@var1290 ) , pattern@var1291 , end@var1292 , varId@var1293 ) ) ;
776: }
777:
|
791:
792: static int multiCompare ( const Token * tok@var1294 , const char * haystack@var1295 , int varid@var1296 ) ;
793:
794: int fileIndex ( ) const {
795: return mImpl@var1402 .@expr1073745351 mFileIndex@var1438 ;
796: }
797: void fileIndex ( int indexOfFile@var1297 ) {
798: mImpl@var1402 .@expr1073745352 mFileIndex@var1438 =@expr1073745353 indexOfFile@var1297 ;
799: }
800:
801: int linenr ( ) const {
802: return mImpl@var1402 .@expr1073745354 mLineNumber@var1439 ;
803: }
804: void linenr ( int lineNumber@var1298 ) {
805: mImpl@var1402 .@expr1073745355 mLineNumber@var1439 =@expr1073745356 lineNumber@var1298 ;
806: }
807:
808: int column ( ) const {
809: return mImpl@var1402 .@expr1073745357 mColumn@var1440 ;
810: }
811: void column ( int c@var1299 ) {
812: mImpl@var1402 .@expr1073745358 mColumn@var1440 =@expr1073745359 c@var1299 ;
813: }
814:
815: Token * next ( ) const {
816: return mNext@var1397 ;
817: }
818:
|
826:
827: static void eraseTokens ( Token * begin@var1300 , const Token * end@var1301 ) ;
828:
|
836:
837: Token * insertToken ( const std :: string & tokenStr@var1302 , const std :: string & originalNameStr@var1303 = emptyString@var1 , bool prepend@var1304 = false ) ;
838:
839: Token * insertTokenBefore ( const std :: string & tokenStr@var1305 , const std :: string & originalNameStr@var1306 = emptyString@var1 )
840: {
841: return insertToken (@expr1073745360 tokenStr@var1305 , originalNameStr@var1306 , true ) ;
842: }
843:
844: Token * previous ( ) const {
845: return mPrevious@var1398 ;
846: }
847:
848:
849: int varId ( ) const {
850: return mImpl@var1402 .@expr1073745361 mVarId@var1433 ;
851: }
852: void varId ( int id@var1307 ) {
853: mImpl@var1402 .@expr1073745362 mVarId@var1433 =@expr1073745363 id@var1307 ;
854: if (@expr1073745364 id@var1307 !=@expr1073745365 0 ) {
855: tokType (@expr1073745366 eVariable ) ;
856: isStandardType (@expr1073745367 false ) ;
857: } else {
858: update_property_info (@expr1073745368 ) ;
859: }
860: }
861:
862: int exprId ( ) const {
863: if (@expr1073745369 mImpl@var1402 .@expr3546 mExprId@var1441 ) {
864: return mImpl@var1402 .@expr3546 mExprId@var1441 ; }
865: return mImpl@var1402 .@expr1073745372 mVarId@var1433 ;
866: }
867: void exprId ( int id@var1308 ) {
868: mImpl@var1402 .@expr1073745373 mExprId@var1441 =@expr1073745374 id@var1308 ;
869: }
870:
|
876:
877: void printOut ( const char * title@var1309 = nullptr ) const ;
878:
|
886:
887: void printOut ( const char * title@var1310 , const std :: vector < std :: string > & fileNames@var1311 ) const ;
888:
|
891:
892: void printLines ( int lines@var1312 = 5 ) const ;
893:
|
900:
901: static void replace ( Token * replaceThis@var1313 , Token * start@var1314 , Token * end@var1315 ) ;
902:
903: struct stringifyOptions {
904: bool varid@var1316 ; varid@var1316 = false ;
905: bool exprid@var1317 ; exprid@var1317 = false ;
906: bool idtype@var1318 ; idtype@var1318 = false ;
907: bool attributes@var1319 ; attributes@var1319 = false ;
908: bool macro@var1320 ; macro@var1320 = false ;
909: bool linenumbers@var1321 ; linenumbers@var1321 = false ;
910: bool linebreaks@var1322 ; linebreaks@var1322 = false ;
911: bool files@var1323 ; files@var1323 = false ;
912: static stringifyOptions forDebug ( ) {
913: stringifyOptions options@var1324 ;
914: options@var1324 .@expr1073745375 attributes@var1325 =@expr1073745376 true ;
915: options@var1324 .@expr1073745377 macro@var1326 =@expr1073745378 true ;
916: options@var1324 .@expr1073745379 linenumbers@var1327 =@expr1073745380 true ;
917: options@var1324 .@expr1073745381 linebreaks@var1328 =@expr1073745382 true ;
918: options@var1324 .@expr1073745383 files@var1329 =@expr1073745384 true ;
919: return options@var1324 ;
920: }
921: static stringifyOptions forDebugVarId ( ) {
922: stringifyOptions options@var1330 ; options@var1330 =@expr1073745385 forDebug (@expr1073745386 ) ;
923: options@var1330 .@expr1073745387 varid@var1331 =@expr1073745388 true ;
924: return options@var1330 ;
925: }
926: static stringifyOptions forDebugExprId ( ) {
927: stringifyOptions options@var1332 ; options@var1332 =@expr1073745389 forDebug (@expr1073745390 ) ;
928: options@var1332 .@expr1073745391 exprid@var1333 =@expr1073745392 true ;
929: return options@var1332 ;
930: }
931: static stringifyOptions forPrintOut ( ) {
932: stringifyOptions options@var1334 ; options@var1334 =@expr1073745393 forDebug (@expr1073745394 ) ;
933: options@var1334 .@expr1073745395 exprid@var1335 =@expr1073745396 true ;
934: options@var1334 .@expr1073745397 varid@var1336 =@expr1073745398 true ;
935: options@var1334 .@expr1073745399 idtype@var1337 =@expr1073745400 true ;
936: return options@var1334 ;
937: }
938: } ;
939:
940: std :: string stringify ( const stringifyOptions & options@var1338 ) const ;
941:
|
947:
948: std :: string stringify ( bool varid@var1339 , bool attributes@var1340 , bool macro@var1341 ) const ;
949:
950: std :: string stringifyList ( const stringifyOptions & options@var1342 , const std :: vector < std :: string > * fileNames@var1343 = nullptr , const Token * end@var1344 = nullptr ) const ;
951: std :: string stringifyList ( const Token * end@var1345 , bool attributes@var1346 = true ) const ;
952: std :: string stringifyList ( bool varid@var1347 = false ) const ;
953:
|
964:
965: std :: string stringifyList ( bool varid@var1348 , bool attributes@var1349 , bool linenumbers@var1350 , bool linebreaks@var1351 , bool files@var1352 , const std :: vector < std :: string > * fileNames@var1353 = nullptr , const Token * end@var1354 = nullptr ) const ;
966:
|
974:
975: void deleteThis ( ) ;
976:
|
981:
982: void link ( Token * linkToToken@var1355 ) {
983: mLink@var1399 =@expr1073745401 linkToToken@var1355 ;
984: if (@expr1073745402 mStr@var1396 ==@expr1073745403 "<" ||@expr1073745404 mStr@var1396 ==@expr1073745405 ">" ) {
985: update_property_info (@expr1073745406 ) ; }
986: }
987:
|
996:
997: Token * link ( ) const {
998: return mLink@var1399 ;
999: }
1000:
|
1004:
1005: void scope ( const Scope * s@var1356 ) {
1006: mImpl@var1402 .@expr1073745407 mScope@var1442 =@expr1073745408 s@var1356 ;
1007: }
1008:
|
1011:
1012: const Scope * scope ( ) const {
1013: return mImpl@var1402 .@expr1073745409 mScope@var1442 ;
1014: }
1015:
|
1019:
1020: void function ( const Function * f@var1357 ) ;
1021:
|
1024:
1025: const Function * function ( ) const {
1026: return mTokType@var1400 ==@expr1073745410 eFunction ||@expr1073745411 mTokType@var1400 ==@expr1073745412 eLambda ?@expr1073745413 mImpl@var1402 .@expr1073745414 mFunction@var1443 :@expr1073745415 nullptr ;
1027: }
1028:
|
1032:
1033: void variable ( const Variable * v@var1358 ) {
1034: mImpl@var1402 .@expr1073745416 mVariable@var1444 =@expr1073745417 v@var1358 ;
1035: if (@expr1073745418 v@var1358 ||@expr1073745419 mImpl@var1402 .@expr1073745420 mVarId@var1433 ) {
1036: tokType (@expr1073745421 eVariable ) ; }
1037: else { if (@expr1073745422 mTokType@var1400 ==@expr1073745423 eVariable ) {
1038: tokType (@expr1073745424 eName ) ; } }
1039: }
1040:
|
1043:
1044: const Variable * variable ( ) const {
1045: return mTokType@var1400 ==@expr1073745425 eVariable ?@expr1073745426 mImpl@var1402 .@expr1073745427 mVariable@var1444 :@expr1073745428 nullptr ;
1046: }
1047:
|
1051:
1052: void type ( const :: Type * t@var1359 ) ;
1053:
|
1056:
1057: const :: Type * type ( ) const {
1058: return mTokType@var1400 ==@expr1073745429 eType ?@expr1073745430 mImpl@var1402 .@expr1073745431 mType@var1445 :@expr1073745432 nullptr ;
1059: }
1060:
1061: static const :: Type * typeOf ( const Token * tok@var1360 , const Token * * typeTok@var1361 = nullptr ) ;
1062:
1063: static std :: pair < const Token * , const Token * > typeDecl ( const Token * tok@var1362 ) ;
1064:
1065: static std :: string typeStr ( const Token * tok@var1363 ) ;
1066:
|
1069:
1070: const Enumerator * enumerator ( ) const {
1071: return mTokType@var1400 ==@expr1073745433 eEnumerator ?@expr1073745434 mImpl@var1402 .@expr1073745435 mEnumerator@var1446 :@expr1073745436 nullptr ;
1072: }
1073:
|
1077:
1078: void enumerator ( const Enumerator * e@var1364 ) {
1079: mImpl@var1402 .@expr1073745437 mEnumerator@var1446 =@expr1073745438 e@var1364 ;
1080: if (@expr1073745439 e@var1364 ) {
1081: tokType (@expr1073745440 eEnumerator ) ; }
1082: else { if (@expr1073745441 mTokType@var1400 ==@expr1073745442 eEnumerator ) {
1083: tokType (@expr1073745443 eName ) ; } }
1084: }
1085:
|
1088:
1089: static void createMutualLinks ( Token * begin@var1365 , Token * end@var1366 ) ;
1090:
|
1096:
1097: std :: string strValue ( ) const ;
1098:
|
1105:
1106: static void move ( Token * srcStart@var1367 , Token * srcEnd@var1368 , Token * newLocation@var1369 ) ;
1107:
1108:
1109: int progressValue ( ) const {
1110: return mImpl@var1402 .@expr1073745444 mProgressValue@var1447 ;
1111: }
1112:
1113:
1114: static void assignProgressValues ( Token * tok@var1370 ) ;
1115:
|
1120:
1121: Token * nextArgument ( ) const ;
1122:
|
1127:
1128: Token * nextArgumentBeforeCreateLinks2 ( ) const ;
1129:
|
1134:
1135: Token * nextTemplateArgument ( ) const ;
1136:
|
1141:
1142: const Token * findClosingBracket ( ) const ;
1143: Token * findClosingBracket ( ) ;
1144:
1145: const Token * findOpeningBracket ( ) const ;
1146: Token * findOpeningBracket ( ) ;
1147:
|
1150:
1151: const std :: string & originalName ( ) const {
1152: return mImpl@var1402 .@expr3621 mOriginalName@var1448 ?@expr1073745446 *@expr1073745447 mImpl@var1402 .@expr3621 mOriginalName@var1448 :@expr1073745449 emptyString@var1 ;
1153: }
1154:
1155: const std :: list < ValueFlow :: Value > & values ( ) const {
1156: return mImpl@var1402 .@expr3626 mValues@var1421 ?@expr1073745451 *@expr1073745452 mImpl@var1402 .@expr3626 mValues@var1421 :@expr1073745454 TokenImpl ::@expr1073745455 mEmptyValueList@var1168 ;
1157: }
1158:
|
1161:
1162: template < typename T >
1163: void originalName ( T && name@var1371 ) {
1164: if (@expr1073745456 !@expr1073745457 mImpl@var1402 .@expr3634 mOriginalName@var1448 ) {
1165: mImpl@var1402 .@expr3634 mOriginalName@var1448 =@expr1073745460 new std ::@expr1073745461 string (@expr1073745462 name@var1371 ) ; }
1166: else {
1167: *@expr1073745463 mImpl@var1402 .@expr3634 mOriginalName@var1448 =@expr1073745465 name@var1371 ; }
1168: }
1169:
1170: bool hasKnownIntValue ( ) const ;
1171: bool hasKnownValue ( ) const ;
1172: bool hasKnownValue ( ValueFlow :: Value :: ValueType t@var1372 ) const ;
1173: bool hasKnownSymbolicValue ( const Token * tok@var1373 ) const ;
1174:
1175: const ValueFlow :: Value * getKnownValue ( ValueFlow :: Value :: ValueType t@var1374 ) const ;
1176: long long getKnownIntValue ( ) const {
1177: return mImpl@var1402 .@expr1073745467 mValues@var1421 .@expr1073745468 front (@expr1073745469 ) .@expr1073745470 intvalue@expr1073745466 ;
1178: }
1179:
1180: const ValueFlow :: Value * getValue ( const long long val@var1375 ) const ;
1181:
1182: const ValueFlow :: Value * getMaxValue ( bool condition@var1376 , long long path@var1377 = 0 ) const ;
1183:
1184: const ValueFlow :: Value * getMovedValue ( ) const ;
1185:
1186: const ValueFlow :: Value * getValueLE ( const long long val@var1378 , const Settings * settings@var1379 ) const ;
1187: const ValueFlow :: Value * getValueGE ( const long long val@var1380 , const Settings * settings@var1381 ) const ;
1188:
1189: const ValueFlow :: Value * getInvalidValue ( const Token * ftok@var1382 , int argnr@var1383 , const Settings * settings@var1384 ) const ;
1190:
1191: const ValueFlow :: Value * getContainerSizeValue ( const long long val@var1385 ) const ;
1192:
1193: const Token * getValueTokenMaxStrLength ( ) const ;
1194: const Token * getValueTokenMinStrSize ( const Settings * settings@var1386 ) const ;
1195:
1196:
1197: bool addValue ( const ValueFlow :: Value & value@var1387 ) ;
1198:
1199: void removeValues ( std :: function < bool ( const ValueFlow :: Value & ) > pred@var1388 ) {
1200: if (@expr1073745471 mImpl@var1402 .@expr3648 mValues@var1421 ) {
1201: mImpl@var1402 .@expr3648 mValues@var1421 .@expr1073745474 remove_if (@expr1073745475 pred@var1388 ) ; }
1202: }
1203:
1204: int index ( ) const {
1205: return mImpl@var1402 .@expr1073745476 mIndex@var1449 ;
1206: }
1207:
1208: void assignIndexes ( ) ;
1209:
1210: private:
1211:
1212: void next ( Token * nextToken@var1389 ) {
1213: mNext@var1397 =@expr1073745477 nextToken@var1389 ;
1214: }
1215: void previous ( Token * previousToken@var1390 ) {
1216: mPrevious@var1398 =@expr1073745478 previousToken@var1390 ;
1217: }
1218:
1219:
1220: void takeData ( Token * fromToken@var1391 ) ;
1221:
|
1226:
1227: static bool firstWordEquals ( const char * str@var1392 , const char * word@var1393 ) ;
1228:
|
1233:
1234: static const char * chrInFirstWord ( const char * str@var1394 , char c@var1395 ) ;
1235:
1236: std :: string mStr@var1396 ;
1237:
1238: Token * mNext@var1397 ;
1239: Token * mPrevious@var1398 ;
1240: Token * mLink@var1399 ;
1241:
1242: enum Anonymous3 : uint64_t {
1243: fIsUnsigned = ( 1 << 0 ) ,
1244: fIsSigned = ( 1 << 1 ) ,
1245: fIsPointerCompare = ( 1 << 2 ) ,
1246: fIsLong = ( 1 << 3 ) ,
1247: fIsStandardType = ( 1 << 4 ) ,
1248: fIsExpandedMacro = ( 1 << 5 ) ,
1249: fIsCast = ( 1 << 6 ) ,
1250: fIsAttributeConstructor = ( 1 << 7 ) ,
1251: fIsAttributeDestructor = ( 1 << 8 ) ,
1252: fIsAttributeUnused = ( 1 << 9 ) ,
1253: fIsAttributePure = ( 1 << 10 ) ,
1254: fIsAttributeConst = ( 1 << 11 ) ,
1255: fIsAttributeNoreturn = ( 1 << 12 ) ,
1256: fIsAttributeNothrow = ( 1 << 13 ) ,
1257: fIsAttributeUsed = ( 1 << 14 ) ,
1258: fIsAttributePacked = ( 1 << 15 ) ,
1259: fIsAttributeMaybeUnused = ( 1 << 16 ) ,
1260: fIsControlFlowKeyword = ( 1 << 17 ) ,
1261: fIsOperatorKeyword = ( 1 << 18 ) ,
1262: fIsComplex = ( 1 << 19 ) ,
1263: fIsEnumType = ( 1 << 20 ) ,
1264: fIsName = ( 1 << 21 ) ,
1265: fIsLiteral = ( 1 << 22 ) ,
1266: fIsTemplateArg = ( 1 << 23 ) ,
1267: fIsAttributeNodiscard = ( 1 << 24 ) ,
1268: fAtAddress = ( 1 << 25 ) ,
1269: fIncompleteVar = ( 1 << 26 ) ,
1270: fConstexpr = ( 1 << 27 ) ,
1271: fExternC = ( 1 << 28 ) ,
1272: fIsSplitVarDeclComma = ( 1 << 29 ) ,
1273: fIsSplitVarDeclEq = ( 1 << 30 ) ,
1274: fIsImplicitInt = ( 1U << 31 ) ,
1275: fIsInline = ( 1ULL << 32 ) ,
1276: fIsTemplate = ( 1ULL << 33 ) ,
1277: fIsSimplifedScope = ( 1ULL << 34 ) ,
1278: fIsRemovedVoidParameter = ( 1ULL << 35 ) ,
1279: fIsIncompleteConstant = ( 1ULL << 36 ) ,
1280: } ;
1281:
1282: Token :: Type mTokType@var1400 ;
1283:
1284: uint64_t mFlags@var1401 ;
1285:
1286: TokenImpl * mImpl@var1402 ;
1287:
|
1292:
1293: bool getFlag ( uint64_t flag_@var1403 ) const {
1294: return (@expr3655 (@expr3655 mFlags@var1401 &@expr1073745481 flag_@var1403 ) !=@expr1073745482 0 ) ;
1295: }
1296:
|
1301:
1302: void setFlag ( uint64_t flag_@var1404 , bool state_@var1405 ) {
1303: mFlags@var1401 =@expr1073745483 state_@var1405 ?@expr1073745484 mFlags@var1401 |@expr1073745485 flag_@var1404 :@expr1073745486 mFlags@var1401 &@expr1073745487 ~@expr1073745488 flag_@var1404 ;
1304: }
1305:
1306:
1307:
1308: void update_property_info ( ) ;
1309:
1310:
1311: void update_property_isStandardType ( ) ;
1312:
1313:
1314: void update_property_char_string_literal ( ) ;
1315:
1316:
1317: void astStringVerboseRecursive ( std :: string & ret@var1406 , const int indent1@var1407 = 0 , const int indent2@var1408 = 0 ) const ;
1318:
1319: public:
1320: void astOperand1 ( Token * tok@var1409 ) ;
1321: void astOperand2 ( Token * tok@var1410 ) ;
1322: void astParent ( Token * tok@var1411 ) ;
1323:
1324: Token * astOperand1 ( ) {
1325: return mImpl@var1402 .@expr1073745489 mAstOperand1@var1412 ;
1326: }
1327: const Token * astOperand1 ( ) const {
1328: return mImpl@var1402 .@expr1073745490 mAstOperand1@var1412 ;
1329: }
1330: Token * astOperand2 ( ) {
1331: return mImpl@var1402 .@expr1073745491 mAstOperand2@var1413 ;
1332: }
1333: const Token * astOperand2 ( ) const {
1334: return mImpl@var1402 .@expr1073745492 mAstOperand2@var1413 ;
1335: }
1336: Token * astParent ( ) {
1337: return mImpl@var1402 .@expr1073745493 mAstParent@var1414 ;
1338: }
1339: const Token * astParent ( ) const {
1340: return mImpl@var1402 .@expr1073745494 mAstParent@var1414 ;
1341: }
1342: Token * astSibling ( ) {
1343: if (@expr1073745495 !@expr1073745496 astParent (@expr3673 ) ) {
1344: return nullptr ; }
1345: if (@expr1073745498 this@expr3675 ==@expr1073745500 astParent (@expr3673 ) .@expr3678 astOperand1 (@expr3679 ) ) {
1346: return astParent (@expr3673 ) .@expr3681 astOperand2 (@expr3682 ) ; }
1347: else { if (@expr1073745507 this@expr3675 ==@expr1073745508 astParent (@expr3673 ) .@expr3681 astOperand2 (@expr3682 ) ) {
1348: return astParent (@expr3673 ) .@expr3678 astOperand1 (@expr3679 ) ; } }
1349: return nullptr ;
1350:
1351: }
1352: const Token * astSibling ( ) const {
1353: if (@expr1073745515 !@expr1073745516 astParent (@expr3693 ) ) {
1354: return nullptr ; }
1355: if (@expr1073745518 this@expr3695 ==@expr1073745520 astParent (@expr3693 ) .@expr3698 astOperand1 (@expr3699 ) ) {
1356: return astParent (@expr3693 ) .@expr3701 astOperand2 (@expr3702 ) ; }
1357: else { if (@expr1073745527 this@expr3695 ==@expr1073745528 astParent (@expr3693 ) .@expr3701 astOperand2 (@expr3702 ) ) {
1358: return astParent (@expr3693 ) .@expr3698 astOperand1 (@expr3699 ) ; } }
1359: return nullptr ;
1360:
1361: }
1362: Token * astTop ( ) {
1363: Token * ret@var1415 ; ret@var1415 =@expr1073745535 this@expr1073745536 ;
1364: while (@expr1073745537 ret@var1415 .@expr3714 mImpl@var1416 .@expr3715 mAstParent@var1417 ) {
1365: ret@var1415 =@expr1073745540 ret@var1415 .@expr3714 mImpl@var1416 .@expr3715 mAstParent@var1417 ; }
1366: return ret@var1415 ;
1367: }
1368:
1369: const Token * astTop ( ) const {
1370: const Token * ret@var1418 ; ret@var1418 =@expr1073745543 this@expr1073745544 ;
1371: while (@expr1073745545 ret@var1418 .@expr3722 mImpl@var1419 .@expr3723 mAstParent@var1420 ) {
1372: ret@var1418 =@expr1073745548 ret@var1418 .@expr3722 mImpl@var1419 .@expr3723 mAstParent@var1420 ; }
1373: return ret@var1418 ;
1374: }
1375:
1376: std :: pair < const Token * , const Token * > findExpressionStartEndTokens ( ) const ;
1377:
|
1384:
1385: bool isCalculation ( ) const ;
1386:
1387: void clearAst ( ) {
1388: mImpl@var1402 .@expr1073745551 mAstOperand1@var1412 =@expr1073745552 mImpl@var1402 .@expr1073745553 mAstOperand2@var1413 =@expr1073745554 mImpl@var1402 .@expr1073745555 mAstParent@var1414 =@expr1073745556 nullptr ;
1389: }
1390:
1391: void clearValueFlow ( ) {
1392: delete mImpl@var1402 .@expr3733 mValues@var1421 ;
1393: mImpl@var1402 .@expr3733 mValues@var1421 =@expr1073745559 nullptr ;
1394: }
1395:
1396: std :: string astString ( const char * sep@var1422 = "" ) const {
1397: std ::@expr1073745560 string ret@var1423 ;
1398: if (@expr1073745561 mImpl@var1402 .@expr3738 mAstOperand1@var1412 ) {
1399: ret@var1423 =@expr1073745563 mImpl@var1402 .@expr3738 mAstOperand1@var1412 .@expr1073745565 astString (@expr1073745566 sep@var1422 ) ; }
1400: if (@expr1073745567 mImpl@var1402 .@expr3744 mAstOperand2@var1413 ) {
1401: ret@var1423 +=@expr1073745569 mImpl@var1402 .@expr3744 mAstOperand2@var1413 .@expr1073745571 astString (@expr1073745572 sep@var1422 ) ; }
1402: return ret@var1423 +@expr1073745573 sep@var1422 +@expr1073745574 mStr@var1396 ;
1403: }
1404:
1405: std :: string astStringVerbose ( ) const ;
1406:
1407: std :: string astStringZ3 ( ) const ;
1408:
1409: std :: string expressionString ( ) const ;
1410:
1411: void printAst ( bool verbose@var1424 , bool xml@var1425 , const std :: vector < std :: string > & fileNames@var1426 , std :: ostream & out@var1427 ) const ;
1412:
1413: void printValueFlow ( bool xml@var1428 , std :: ostream & out@var1429 ) const ;
1414:
1415: void scopeInfo ( std :: shared_ptr < ScopeInfo2 > newScopeInfo@var1430 ) ;
1416: std :: shared_ptr < ScopeInfo2 > scopeInfo ( ) const ;
1417:
1418: void setCpp11init ( bool cpp11init@var1431 ) const {
1419: mImpl@var1402 .@expr1073745575 mCpp11init@var1432 =@expr1073745576 cpp11init@var1431 ?@expr1073745577 TokenImpl ::@expr3754 Cpp11init ::@expr1073745579 CPP11INIT :@expr1073745580 TokenImpl ::@expr3754 Cpp11init ::@expr1073745582 NOINIT ;
1420: }
1421: TokenImpl :: Cpp11init isCpp11init ( ) const {
1422: return mImpl@var1402 .@expr1073745583 mCpp11init@var1432 ;
1423: }
1424: } ;
1425:
1426: Token * findTypeEnd ( Token * tok@var1450 ) ;
1427: const Token * findTypeEnd ( const Token * tok@var1451 ) ;
1428: Token * findLambdaEndScope ( Token * tok@var1452 ) ;
1429: const Token * findLambdaEndScope ( const Token * tok@var1453 ) ;

##file cppcheck-2.8/lib/tokenlist.h

1:
|
31:
32: class Settings ;
33:
34: namespace simplecpp {
35: class TokenList ;
36: }
37:
|
40:
41: class TokenList {
42: public:
43: explicit TokenList ( const Settings * settings@var1454 ) ;
44: ~ TokenList ( ) ;
45:
46: void setSettings ( const Settings * settings@var1455 ) {
47: mSettings@var1490 =@expr1073745584 settings@var1455 ;
48: }
49:
50: const Settings * getSettings ( ) const {
51: return mSettings@var1490 ;
52: }
53:
54:
55: const std :: string & getSourceFilePath ( ) const ;
56:
57:
58: bool isC ( ) const {
59: return mIsC@var1492 ;
60: }
61:
62:
63: bool isCPP ( ) const {
64: return mIsCpp@var1493 ;
65: }
66:
|
70:
71: static void deleteTokens ( Token * tok@var1456 ) ;
72:
73: void addtoken ( const std :: string & str@var1457 , const int lineno@var1458 , const int column@var1459 , const int fileno@var1460 , bool split@var1461 = false ) ;
74: void addtoken ( const std :: string & str@var1462 , const Token * locationTok@var1463 ) ;
75:
76: void addtoken ( const Token * tok@var1464 , const int lineno@var1465 , const int column@var1466 , const int fileno@var1467 ) ;
77: void addtoken ( const Token * tok@var1468 , const Token * locationTok@var1469 ) ;
78: void addtoken ( const Token * tok@var1470 ) ;
79:
80: static void insertTokens ( Token * dest@var1471 , const Token * src@var1472 , int n@var1473 ) ;
81:
|
89:
90: static Token * copyTokens ( Token * dest@var1474 , const Token * first@var1475 , const Token * last@var1476 , bool one_line@var1477 = true ) ;
91:
|
100:
101: bool createTokens ( std :: istream & code@var1478 , const std :: string & file0@var1479 = emptyString@var1 ) ;
102:
103: void createTokens ( simplecpp :: TokenList && tokenList@var1480 ) ;
104:
105:
106: void deallocateTokens ( ) ;
107:
108:
109: int appendFileIfNew ( const std :: string & fileName@var1481 ) ;
110:
111:
112: const Token * front ( ) const {
113: return mTokensFrontBack@var1487 .@expr1073745585 front@var1494 ;
114: }
115: Token * front ( ) {
116: return mTokensFrontBack@var1487 .@expr1073745586 front@var1494 ;
117: }
118:
119:
120: const Token * back ( ) const {
121: return mTokensFrontBack@var1487 .@expr1073745587 back@var1495 ;
122: }
123: Token * back ( ) {
124: return mTokensFrontBack@var1487 .@expr1073745588 back@var1495 ;
125: }
126:
|
131:
132: const std :: vector < std :: string > & getFiles ( ) const {
133: return mFiles@var1488 ;
134: }
135:
136: std :: string getOrigFile ( const Token * tok@var1482 ) const ;
137:
|
142:
143: const std :: string & file ( const Token * tok@var1483 ) const ;
144:
|
149:
150: std :: string fileLine ( const Token * tok@var1484 ) const ;
151:
|
155:
156: unsigned long long calculateChecksum ( ) const ;
157:
|
160:
161: void createAst ( ) const ;
162:
|
166:
167: void validateAst ( ) const ;
168:
|
174:
175: bool validateToken ( const Token * tok@var1485 ) const ;
176:
|
181:
182: void simplifyPlatformTypes ( ) ;
183:
|
187:
188: void simplifyStdType ( ) ;
189:
190: void clangSetOrigFiles ( ) ;
191:
192: bool isKeyword ( const std :: string & str@var1486 ) const ;
193:
194: private:
195:
196:
197: TokenList ( const TokenList & ) ;
198:
199:
200: TokenList & operator= ( const TokenList & ) ;
201:
202: void determineCppC ( ) ;
203:
204:
205: TokensFrontBack mTokensFrontBack@var1487 ;
206:
207:
208: std :: vector < std :: string > mFiles@var1488 ;
209:
210:
211: std :: vector < std :: string > mOrigFiles@var1489 ;
212:
213:
214: const Settings * mSettings@var1490 ;
215:
216: std :: unordered_set < std :: string > mKeywords@var1491 ;
217:
218:
219: bool mIsC@var1492 ;
220: bool mIsCpp@var1493 ;
221: } ;

##file cppcheck-2.8/lib/tokenize.h

1:
|
35:
36: class Settings ;
37: class SymbolDatabase ;
38: class TimerResults ;
39: class Token ;
40: class TemplateSimplifier ;
41: class ErrorLogger ;
42: class Preprocessor ;
43:
44: namespace simplecpp {
45: class TokenList ;
46: }
47:
|
51:
52: class Tokenizer {
53:
54: friend class TestSimplifyTokens ;
55: friend class TestSimplifyTypedef ;
56: friend class TestSimplifyUsing ;
57: friend class TestTokenizer ;
58: friend class SymbolDatabase ;
59: friend class TestSimplifyTemplate ;
60: friend class TemplateSimplifier ;
61:
62:
63: class VariableMap {
64: private:
65: std :: map < std :: string , int > mVariableId@var1496 ;
66: std :: stack < std :: list < std :: pair < std :: string , int > > > mScopeInfo@var1497 ;
67: mutable int mVarId@var1498 ;
68: public:
69: VariableMap ( ) ;
70: void enterScope ( ) ;
71: bool leaveScope ( ) ;
72: void addVariable ( const std :: string & varname@var1499 ) ;
73: bool hasVariable ( const std :: string & varname@var1500 ) const ;
74: std :: map < std :: string , int > :: const_iterator find ( const std :: string & varname@var1501 ) const {
75: return mVariableId@var1496 .@expr1073745589 find (@expr1073745590 varname@var1501 ) ;
76: }
77: std :: map < std :: string , int > :: const_iterator end ( ) const {
78: return mVariableId@var1496 .@expr1073745591 end (@expr1073745592 ) ;
79: }
80: const std :: map < std :: string , int > & map ( ) const {
81: return mVariableId@var1496 ;
82: }
83: int * getVarId ( ) const {
84: return &@expr1073745593 mVarId@var1498 ;
85: }
86: } ;
87:
88:
89: public:
90: Tokenizer ( ) ;
91: Tokenizer ( const Settings * settings@var1502 , ErrorLogger * errorLogger@var1503 ) ;
92: ~ Tokenizer ( ) ;
93:
94: void setTimerResults ( TimerResults * tr@var1504 ) {
95: mTimerResults@var1624 =@expr1073745594 tr@var1504 ;
96: }
97:
98:
99: bool isC ( ) const {
100: return list@var1602 .@expr1073745595 isC (@expr1073745596 ) ;
101: }
102:
103:
104: bool isCPP ( ) const {
105: return list@var1602 .@expr1073745597 isCPP (@expr1073745598 ) ;
106: }
107:
|
113:
114: bool isScopeNoReturn ( const Token * endScopeToken@var1505 , bool * unknown@var1506 = nullptr ) const ;
115:
116: bool createTokens ( std :: istream & code@var1507 , const std :: string & FileName@var1508 ) ;
117: void createTokens ( simplecpp :: TokenList && tokenList@var1509 ) ;
118:
119: bool simplifyTokens1 ( const std :: string & configuration@var1510 ) ;
120:
|
140:
141: bool tokenize ( std :: istream & code@var1511 ,
142: const char FileName@var1512 [ ] ,
143: const std :: string & configuration@var1513 = emptyString@var1 ) ;
144:
145:
146: void setVarId ( ) ;
147: void setVarIdPass1 ( ) ;
148: void setVarIdPass2 ( ) ;
149:
|
158:
159: bool simplifyTokenList1 ( const char FileName@var1514 [ ] ) ;
160:
|
166:
167: bool simplifyTokenList2 ( ) ;
168:
|
173:
174: void simplifyHeadersAndUnusedTemplates ( ) ;
175:
|
178:
179: void removeExtraTemplateKeywords ( ) ;
180:
|
184:
185: void splitTemplateRightAngleBrackets ( bool check@var1515 ) ;
186:
|
202:
203: static void eraseDeadCode ( Token * begin@var1516 , const Token * end@var1517 ) ;
204:
|
209:
210: int sizeOfType ( const Token * type@var1518 ) const ;
211:
|
217:
218: bool isFunctionParameterPassedByValue ( const Token * fpar@var1519 ) const ;
219:
220:
221:
222: void simplifyAssignmentInFunctionCall ( ) ;
223:
224:
225: void simplifyAssignmentBlock ( ) ;
226:
|
231:
232: bool simplifyCalculations ( ) ;
233:
|
238:
239: void simplifyOffsetPointerDereference ( ) ;
240:
|
244:
245: void simplifyOffsetPointerReference ( ) ;
246:
247:
248: void arraySize ( ) ;
249:
250:
251:
252: void simplifyLabelsCaseDefault ( ) ;
253:
254:
255:
256: void simplifyCaseRange ( ) ;
257:
258:
259: void removeMacrosInGlobalScope ( ) ;
260:
261: void addSemicolonAfterUnknownMacro ( ) ;
262:
263:
264: void removePragma ( ) ;
265:
|
269:
270: void removeMacroInClassDef ( ) ;
271:
272:
273: void removeMacroInVarDecl ( ) ;
274:
275:
276: void removeRedundantAssignment ( ) ;
277:
|
281:
282: void simplifyRealloc ( ) ;
283:
284:
285: void sizeofAddParentheses ( ) ;
286:
|
291:
292: bool simplifySizeof ( ) ;
293:
|
297:
298: void simplifyVarDecl ( const bool only_k_r_fpar@var1520 ) ;
299: void simplifyVarDecl ( Token * tokBegin@var1521 , const Token * const tokEnd@var1522 , const bool only_k_r_fpar@var1523 ) ;
300:
|
304:
305: void simplifyInitVar ( ) ;
306: static Token * initVar ( Token * tok@var1524 ) ;
307:
|
313:
314: bool simplifyConstTernaryOp ( ) ;
315:
|
319:
320: void simplifyCompoundAssignment ( ) ;
321:
|
327:
328: void simplifyStaticConst ( ) ;
329:
|
335:
336: void simplifyIfAndWhileAssign ( ) ;
337:
|
341:
342: void simplifyVariableMultipleAssign ( ) ;
343:
|
350:
351: bool simplifyCAlternativeTokens ( ) ;
352:
|
358:
359: void simplifyComma ( ) ;
360:
|
363:
364: bool simplifyAddBraces ( ) ;
365:
|
371:
372: Token * simplifyAddBracesToCommand ( Token * tok@var1525 ) ;
373:
|
379:
380: Token * simplifyAddBracesPair ( Token * tok@var1526 , bool commandWithCondition@var1527 ) ;
381:
382:
383: void simplifyUsingToTypedef ( ) ;
384:
|
392:
393: void simplifyTypedef ( ) ;
394:
395:
396:
397: bool isMemberFunction ( const Token * openParen@var1528 ) const ;
398:
399:
400:
401: bool simplifyUsing ( ) ;
402:
|
405:
406: void simplifyCasts ( ) ;
407:
|
410:
411: void simplifyUndefinedSizeArray ( ) ;
412:
|
419:
420: bool simplifyKnownVariables ( ) ;
421:
|
425:
426: static bool simplifyKnownVariablesGetData ( int varid@var1529 , Token * * _tok2@var1530 , Token * * _tok3@var1531 , std :: string & value@var1532 , int & valueVarId@var1533 , bool & valueIsPointer@var1534 , bool floatvar@var1535 ) ;
427:
|
431:
432: bool simplifyKnownVariablesSimplify ( Token * * tok2@var1536 , Token * tok3@var1537 , int varid@var1538 , const std :: string & structname@var1539 , std :: string & value@var1540 , int valueVarId@var1541 , bool valueIsPointer@var1542 , const Token * const valueToken@var1543 , int indentlevel@var1544 ) const ;
433:
434:
435: void simplifyEmptyNamespaces ( ) ;
436:
|
439:
440: void simplifyFlowControl ( ) ;
441:
442:
443: void simplifyNestedStrcat ( ) ;
444:
445:
446: void elseif ( ) ;
447:
448:
449: void simplifyIfSwitchForInit ( ) ;
450:
|
454:
455: bool simplifyConditions ( ) ;
456:
|
461:
462: bool removeRedundantConditions ( ) ;
463:
|
467:
468: void removeRedundantFor ( ) ;
469:
|
473:
474: void removeRedundantSemicolons ( ) ;
475:
|
479:
480: bool simplifyFunctionReturn ( ) ;
481:
|
485:
486: void simplifyStructDecl ( ) ;
487:
|
496:
497: bool simplifyRedundantParentheses ( ) ;
498:
499: void simplifyCharAt ( ) ;
500:
501:
502: void simplifyReference ( ) ;
503:
|
507:
508: void simplifyFunctionParameters ( ) ;
509:
|
513:
514: void simplifyFunctionTryCatch ( ) ;
515:
|
518:
519: void simplifyTemplates ( ) ;
520:
521: void simplifyDoublePlusAndDoubleMinus ( ) ;
522:
523: void simplifyRedundantConsecutiveBraces ( ) ;
524:
525: void simplifyArrayAccessSyntax ( ) ;
526:
527: void simplifyParameterVoid ( ) ;
528:
529: void fillTypeSizes ( ) ;
530:
531: void combineOperators ( ) ;
532:
533: void combineStringAndCharLiterals ( ) ;
534:
535: void concatenateNegativeNumberAndAnyPositive ( ) ;
536:
537: void simplifyExternC ( ) ;
538:
539: void simplifyRoundCurlyParentheses ( ) ;
540:
541: void simplifyTypeIntrinsics ( ) ;
542:
543: void simplifySQL ( ) ;
544:
545: void checkForEnumsWithTypedef ( ) ;
546:
547: void findComplicatedSyntaxErrorsInTemplates ( ) ;
548:
|
551:
552: void simplifyMathFunctions ( ) ;
553:
|
556:
557: void simplifyMathExpressions ( ) ;
558:
|
564:
565: static std :: string simplifyString ( const std :: string & source@var1545 ) ;
566:
|
572:
573: const Token * isFunctionHead ( const Token * tok@var1546 , const std :: string & endsWith@var1547 ) const ;
574:
|
581:
582: static const Token * isFunctionHead ( const Token * tok@var1548 , const std :: string & endsWith@var1549 , bool cpp@var1550 ) ;
583:
584: void setPreprocessor ( const Preprocessor * preprocessor@var1551 ) {
585: mPreprocessor@var1625 =@expr1073745599 preprocessor@var1551 ;
586: }
587: const Preprocessor * getPreprocessor ( ) const {
588: return mPreprocessor@var1625 ;
589: }
590:
591: bool hasIfdef ( const Token * start@var1552 , const Token * end@var1553 ) const ;
592:
593: private:
594:
|
597:
598: void simplifyWhile0 ( ) ;
599:
|
602:
603: void simplifyErrNoInWhile ( ) ;
604:
|
607:
608: void simplifyFuncInWhile ( ) ;
609:
|
612:
613: void simplifyStd ( ) ;
614:
615:
616: void simplifyPointerToStandardType ( ) ;
617:
618:
619: void simplifyFunctionPointers ( ) ;
620:
|
624:
625: void cppcheckError ( const Token * tok@var1554 ) const ;
626:
|
629:
630: void createLinks ( ) ;
631:
|
634:
635: void createLinks2 ( ) ;
636:
637: public:
638:
639:
640: void syntaxError ( const Token * tok@var1555 , const std :: string & code@var1556 = "" ) const ;
641:
642:
643: void unmatchedToken ( const Token * tok@var1557 ) const ;
644:
645:
646: void syntaxErrorC ( const Token * tok@var1558 , const std :: string & what@var1559 ) const ;
647:
648:
649: void unknownMacroError ( const Token * tok1@var1560 ) const ;
650:
651: void unhandledCharLiteral ( const Token * tok@var1561 , const std :: string & msg@var1562 ) const ;
652:
653: private:
654:
655:
656: void unhandled_macro_class_x_y ( const Token * tok@var1563 ) const ;
657:
658:
659: void checkConfiguration ( ) const ;
660: void macroWithSemicolonError ( const Token * tok@var1564 , const std :: string & macroName@var1565 ) const ;
661:
|
664:
665: void validateC ( ) const ;
666:
|
670:
671: void validate ( ) const ;
672:
673:
674: void reportUnknownMacros ( ) const ;
675:
676:
677: void findGarbageCode ( ) const ;
678:
679:
680: static bool isGarbageExpr ( const Token * start@var1566 , const Token * end@var1567 , bool allowSemicolon@var1568 ) ;
681:
|
684:
685: void simplifyDeclspec ( ) ;
686:
|
689:
690: void simplifyCallingConvention ( ) ;
691:
|
694:
695: void simplifyAttribute ( ) ;
696:
|
699:
700: void simplifyCppcheckAttribute ( ) ;
701:
702:
703: void removeAlignas ( ) ;
704:
705:
706: void simplifySpaceshipOperator ( ) ;
707:
|
710:
711: void simplifyKeyword ( ) ;
712:
|
715:
716: void simplifyAsm ( ) ;
717:
|
720:
721: void simplifyAsm2 ( ) ;
722:
|
725:
726: void simplifyAt ( ) ;
727:
|
730:
731: void simplifyBitfields ( ) ;
732:
|
735:
736: void removeUnnecessaryQualification ( ) ;
737:
|
740:
741: void simplifyNamespaceStd ( ) ;
742:
|
749:
750: void simplifyMicrosoftMemoryFunctions ( ) ;
751:
|
755:
756: void simplifyMicrosoftStringFunctions ( ) ;
757:
|
760:
761: void simplifyBorland ( ) ;
762:
|
765:
766: void simplifyQtSignalsSlots ( ) ;
767:
|
771:
772: void simplifyOperatorName ( ) ;
773:
774:
775: void simplifyOverloadedOperators ( ) ;
776:
|
779:
780: void simplifyCPPAttribute ( ) ;
781:
|
785:
786: bool simplifyStrlen ( ) ;
787:
|
790:
791: void simplifyNamespaceAliases ( ) ;
792:
|
795:
796: void simplifyNestedNamespace ( ) ;
797:
|
802:
803: void simplifyCoroutines ( ) ;
804:
|
807:
808: void prepareTernaryOpForAST ( ) ;
809:
|
812:
813: void reportError ( const Token * tok@var1569 , const Severity :: SeverityType severity@var1570 , const std :: string & id@var1571 , const std :: string & msg@var1572 , bool inconclusive@var1573 = false ) const ;
814: void reportError ( const std :: list < const Token * > & callstack@var1574 , Severity :: SeverityType severity@var1575 , const std :: string & id@var1576 , const std :: string & msg@var1577 , bool inconclusive@var1578 = false ) const ;
815:
816: bool duplicateTypedef ( Token * * tokPtr@var1579 , const Token * name@var1580 , const Token * typeDef@var1581 ) const ;
817:
818: void unsupportedTypedef ( const Token * tok@var1582 ) const ;
819:
820: void setVarIdClassDeclaration ( const Token * const startToken@var1583 ,
821: const VariableMap & variableMap@var1584 ,
822: const int scopeStartVarId@var1585 ,
823: std :: map < int , std :: map < std :: string , int > > & structMembers@var1586 ) ;
824:
825: void setVarIdStructMembers ( Token * * tok1@var1587 ,
826: std :: map < int , std :: map < std :: string , int > > & structMembers@var1588 ,
827: int * varId@var1589 ) const ;
828:
829: void setVarIdClassFunction ( const std :: string & classname@var1590 ,
830: Token * const startToken@var1591 ,
831: const Token * const endToken@var1592 ,
832: const std :: map < std :: string , int > & varlist@var1593 ,
833: std :: map < int , std :: map < std :: string , int > > & structMembers@var1594 ,
834: int * varId_@var1595 ) ;
835:
|
839:
840: void simplifyReturnStrncat ( ) ;
841:
|
844:
845: void printUnknownTypes ( ) const ;
846:
847:
848: static const Token * findSQLBlockEnd ( const Token * tokSQLStart@var1596 ) ;
849:
850: bool operatorEnd ( const Token * tok@var1597 ) const ;
851:
852: public:
853:
854:
855: bool codeWithTemplates ( ) const {
856: return mCodeWithTemplates@var1623 ;
857: }
858:
859:
860: void setSettings ( const Settings * settings@var1598 ) {
861: mSettings@var1609 =@expr1073745600 settings@var1598 ;
862: list@var1602 .@expr1073745601 setSettings (@expr1073745602 settings@var1598 ) ;
863: }
864:
865: const SymbolDatabase * getSymbolDatabase ( ) const {
866: return mSymbolDatabase@var1611 ;
867: }
868: void createSymbolDatabase ( ) ;
869: void deleteSymbolDatabase ( ) ;
870:
|
875:
876: void printDebugOutput ( int simplification@var1599 ) const ;
877:
878: void dump ( std :: ostream & out@var1600 ) const ;
879:
880: Token * deleteInvalidTypedef ( Token * typeDef@var1601 ) ;
881:
|
885:
886: int varIdCount ( ) const {
887: return mVarId@var1621 ;
888: }
889:
|
892:
893: TokenList list@var1602 ;
894:
895: const Token * tokens ( ) const {
896: return list@var1602 .@expr1073745603 front (@expr1073745604 ) ;
897: }
898:
|
903:
904: static bool isZeroNumber ( const std :: string & s@var1603 ) ;
905:
|
910:
911: static bool isOneNumber ( const std :: string & s@var1604 ) ;
912:
|
917:
918: static bool isTwoNumber ( const std :: string & s@var1605 ) ;
919:
|
925:
926: static const Token * startOfExecutableScope ( const Token * tok@var1606 ) ;
927:
|
931:
932: static bool isMaxTime ( ) {
933: return false ;
934:
935: }
936:
937: const Settings * getSettings ( ) const {
938: return mSettings@var1609 ;
939: }
940:
941: void calculateScopes ( ) ;
942:
943:
944: Tokenizer ( const Tokenizer & ) = delete ;
945:
946:
947: Tokenizer & operator= ( const Tokenizer & ) = delete ;
948:
949: private:
950: Token * processFunc ( Token * tok2@var1607 , bool inOperator@var1608 ) const ;
951:
|
955:
956: int newVarId ( ) {
957: return ++@expr1073745605 mVarId@var1621 ;
958: }
959:
960:
961: void setPodTypes ( ) ;
962:
963:
964: const Settings * mSettings@var1609 ;
965:
966:
967: ErrorLogger * const mErrorLogger@var1610 ;
968:
969:
970: SymbolDatabase * mSymbolDatabase@var1611 ;
971:
972: TemplateSimplifier * mTemplateSimplifier@var1612 ;
973:
974:
975:
976: std :: string mConfiguration@var1613 ;
977:
978:
979: std :: map < std :: string , int > mTypeSize@var1614 ;
980:
981: struct TypedefInfo {
982: std :: string name@var1615 ;
983: std :: string filename@var1616 ;
984: int lineNumber@var1617 ;
985: int column@var1618 ;
986: bool used@var1619 ;
987: } ;
988: std :: vector < TypedefInfo > mTypedefInfo@var1620 ;
989:
990:
991: int mVarId@var1621 ;
992:
993:
994: int mUnnamedCount@var1622 ;
995:
|
999:
1000: bool mCodeWithTemplates@var1623 ;
1001:
|
1004:
1005: TimerResults * mTimerResults@var1624 ;
1006:
|
1011:
1012: const Preprocessor * mPreprocessor@var1625 ;
1013: } ;

##file cppcheck-2.8/lib/templatesimplifier.cpp

1:
|
37:
38: static Token * skipRequires ( Token * tok@var1626 )
39: {
40: if (@expr1073745606 !@expr1073745607 Token ::@expr3784 simpleMatch (@expr1073745609 tok@var1626 , "requires" ) ) {
41: return tok@var1626 ; }
42:
43: while (@expr1073745610 Token ::@expr3787 Match (@expr1073745612 tok@var1626 , "%oror%|&&|requires %name%|(" ) ) {
44: Token * after@var1627 ; after@var1627 =@expr1073745613 tok@var1626 .@expr1073745614 next (@expr1073745615 ) ;
45: if (@expr1073745616 after@var1627 .@expr1073745617 str (@expr1073745618 ) ==@expr1073745619 "(" ) {
46: tok@var1626 =@expr1073745620 after@var1627 .@expr1073745621 link (@expr1073745622 ) .@expr1073745623 next (@expr1073745624 ) ;
47: continue ;
48: }
49: if (@expr1073745625 Token ::@expr3784 simpleMatch (@expr1073745627 after@var1627 , "requires (" ) &&@expr1073745628 Token ::@expr3784 simpleMatch (@expr1073745630 after@var1627 .@expr3807 linkAt (@expr3808 1 ) , ") {" ) ) {
50: tok@var1626 =@expr1073745633 after@var1627 .@expr3807 linkAt (@expr3808 1 ) .@expr1073745636 linkAt (@expr1073745637 1 ) .@expr1073745638 next (@expr1073745639 ) ;
51: continue ;
52: }
53: while (@expr1073745640 Token ::@expr3787 Match (@expr1073745642 after@var1627 , "%name% :: %name%" ) ) {
54: after@var1627 =@expr1073745643 after@var1627 .@expr1073745644 tokAt (@expr1073745645 2 ) ; }
55: if (@expr1073745646 Token ::@expr3787 Match (@expr1073745648 after@var1627 , "%name% <" ) ) {
56: after@var1627 =@expr1073745649 after@var1627 .@expr3826 next (@expr3827 ) .@expr1073745652 findClosingBracket (@expr1073745653 ) ;
57: tok@var1626 =@expr1073745654 after@var1627 ?@expr1073745655 after@var1627 .@expr3826 next (@expr3827 ) :@expr1073745658 nullptr ;
58: } else {
59: break ; }
60: }
61: return tok@var1626 ;
62: }
63:
64: namespace {
65: class FindToken {
66: public:
67: explicit FindToken ( const Token * token@var1628 ) : mToken@var1630 ( token@var1628 ) { }
68: bool operator() ( const TemplateSimplifier :: TokenAndName & tokenAndName@var1629 ) const {
69: return tokenAndName@var1629 .@expr1073745659 token (@expr1073745660 ) ==@expr1073745661 mToken@var1630 ;
70: }
71: private:
72: const Token * const mToken@var1630 ;
73: } ;
74:
75: class FindName {
76: public:
77: explicit FindName ( const std :: string & name@var1631 ) : mName@var1633 ( name@var1631 ) { }
78: bool operator() ( const TemplateSimplifier :: TokenAndName & tokenAndName@var1632 ) const {
79: return tokenAndName@var1632 .@expr1073745662 name (@expr1073745663 ) ==@expr1073745664 mName@var1633 ;
80: }
81: private:
82: const std :: string mName@var1633 ;
83: } ;
84:
85: class FindFullName {
86: public:
87: explicit FindFullName ( const std :: string & fullName@var1634 ) : mFullName@var1636 ( fullName@var1634 ) { }
88: bool operator() ( const TemplateSimplifier :: TokenAndName & tokenAndName@var1635 ) const {
89: return tokenAndName@var1635 .@expr1073745665 fullName (@expr1073745666 ) ==@expr1073745667 mFullName@var1636 ;
90: }
91: private:
92: const std :: string mFullName@var1636 ;
93: } ;
94: }
95:
96: TemplateSimplifier :: TokenAndName :: TokenAndName ( Token * token@var1637 , const std :: string & scope@var1638 ) :
97: mToken@var4 ( token@var1637 ) , mScope@var5 ( scope@var1638 ) , mName@var6 ( mToken@var4 ? mToken@var4 . str ( ) : "" ) ,
98: mFullName@var7 ( mScope@var5 . empty ( ) ? mName@var6 : ( mScope@var5 + " :: " + mName@var6 ) ) ,
99: mNameToken@var8 ( nullptr ) , mParamEnd@var9 ( nullptr ) , mFlags@var10 ( 0 )
100: {
101: if (@expr1073745668 mToken@var4 ) {
102: if (@expr1073745669 mToken@var4 .@expr1073745670 strAt (@expr1073745671 1 ) ==@expr1073745672 "<" ) {
103: const Token * end@var1639 ; end@var1639 =@expr1073745673 mToken@var4 .@expr1073745674 next (@expr1073745675 ) .@expr1073745676 findClosingBracket (@expr1073745677 ) ;
104: if (@expr1073745678 end@var1639 &&@expr1073745679 end@var1639 .@expr1073745680 strAt (@expr1073745681 1 ) ==@expr1073745682 "(" ) {
105: isFunction (@expr1073745683 true ) ;
106: }
107: }
108: mToken@var4 .@expr1073745684 templateSimplifierPointer (@expr1073745685 this@expr1073745686 ) ;
109: }
110: }
111:
112: TemplateSimplifier :: TokenAndName :: TokenAndName ( Token * token@var1640 , const std :: string & scope@var1641 , const Token * nameToken@var1642 , const Token * paramEnd@var1643 ) :
113: mToken@var4 ( token@var1640 ) , mScope@var5 ( scope@var1641 ) , mName@var6 ( nameToken@var1642 . str ( ) ) ,
114: mFullName@var7 ( mScope@var5 . empty ( ) ? mName@var6 : ( mScope@var5 + " :: " + mName@var6 ) ) ,
115: mNameToken@var8 ( nameToken@var1642 ) , mParamEnd@var9 ( paramEnd@var1643 ) , mFlags@var10 ( 0 )
116: {
117:
118: if (@expr1073745687 mToken@var4 &&@expr1073745688 mNameToken@var8 &&@expr1073745689 mParamEnd@var9 ) {
119: isSpecialization (@expr1073745690 Token ::@expr3867 simpleMatch (@expr1073745692 mToken@var4 , "template < >" ) ) ;
120:
121: if (@expr1073745693 !@expr3870 isSpecialization (@expr3871 ) ) {
122: if (@expr1073745696 Token ::@expr3867 simpleMatch (@expr1073745698 mToken@var4 .@expr3875 next (@expr3876 ) .@expr3877 findClosingBracket (@expr3878 ) , "> template <" ) ) {
123: const Token * temp@var1644 ; temp@var1644 =@expr1073745703 mNameToken@var8 .@expr3880 tokAt (@expr3881 -2 ) ;
124: while (@expr1073745706 Token ::@expr3883 Match (@expr1073745708 temp@var1644 , ">|%name% ::" ) ) {
125: if (@expr1073745709 temp@var1644 .@expr1073745710 str (@expr1073745711 ) ==@expr1073745712 ">" ) {
126: temp@var1644 =@expr1073745713 temp@var1644 .@expr1073745714 findOpeningBracket (@expr1073745715 ) .@expr1073745716 previous (@expr1073745717 ) ; }
127: else {
128: temp@var1644 =@expr1073745718 temp@var1644 .@expr1073745719 tokAt (@expr1073745720 -2 ) ; }
129: }
130: isPartialSpecialization (@expr1073745721 temp@var1644 .@expr1073745722 strAt (@expr1073745723 1 ) ==@expr1073745724 "<" ) ;
131: } else {
132: isPartialSpecialization (@expr1073745725 mNameToken@var8 .@expr3902 strAt (@expr1073745727 1 ) ==@expr1073745728 "<" ) ; }
133: }
134:
135: isAlias (@expr1073745729 mParamEnd@var9 .@expr3906 strAt (@expr3907 1 ) ==@expr1073745732 "using" ) ;
136:
137: if (@expr1073745733 isAlias (@expr3910 ) &&@expr1073745735 isPartialSpecialization (@expr1073745736 ) ) {
138: throw InternalError (@expr1073745737 mToken@var4 , "partial specialization of alias templates is not permitted" , InternalError ::@expr3914 SYNTAX ) ;
139: }
140: if (@expr1073745739 isAlias (@expr3910 ) &&@expr1073745741 isSpecialization (@expr3871 ) ) {
141: throw InternalError (@expr1073745743 mToken@var4 , "explicit specialization of alias templates is not permitted" , InternalError ::@expr3914 SYNTAX ) ;
142: }
143:
144: isFriend (@expr1073745745 mParamEnd@var9 .@expr3906 strAt (@expr3907 1 ) ==@expr1073745748 "friend" ) ;
145: const Token * next@var1645 ; next@var1645 =@expr1073745749 mParamEnd@var9 .@expr1073745750 next (@expr1073745751 ) ;
146: if (@expr1073745752 isFriend (@expr3929 ) ) {
147: next@var1645 =@expr1073745754 next@var1645 .@expr1073745755 next (@expr1073745756 ) ; }
148:
149: isClass (@expr1073745757 Token ::@expr3883 Match (@expr1073745759 next@var1645 , "class|struct|union %name% <|{|:|;|::" ) ) ;
150: if (@expr1073745760 mToken@var4 .@expr1073745761 strAt (@expr1073745762 1 ) ==@expr1073745763 "<" &&@expr1073745764 !@expr3870 isSpecialization (@expr3871 ) ) {
151: const Token * end@var1646 ; end@var1646 =@expr1073745767 mToken@var4 .@expr3875 next (@expr3876 ) .@expr3877 findClosingBracket (@expr3878 ) ;
152: isVariadic (@expr1073745772 end@var1646 &&@expr1073745773 Token ::@expr1073745774 findmatch (@expr1073745775 mToken@var4 .@expr1073745776 tokAt (@expr1073745777 2 ) , "%name% ..." , end@var1646 ) ) ;
153: }
154: const Token * tok1@var1647 ; tok1@var1647 =@expr1073745778 mNameToken@var8 .@expr1073745779 next (@expr1073745780 ) ;
155: if (@expr3957 tok1@var1647 .@expr3958 str (@expr3959 ) ==@expr3960 "<" ) {
156: const Token * closing@var1648 ; closing@var1648 =@expr1073745785 tok1@var1647 .@expr3962 findClosingBracket (@expr3963 ) ;
157: if (@expr1073745788 closing@var1648 ) {
158: tok1@var1647 =@expr1073745789 closing@var1648 .@expr1073745790 next (@expr1073745791 ) ; }
159: else {
160: throw InternalError (@expr1073745792 mToken@var4 , "unsupported syntax" , InternalError ::@expr3914 SYNTAX ) ; }
161: }
162: isFunction (@expr1073745794 tok1@var1647 .@expr3958 str (@expr3959 ) ==@expr1073745797 "(" ) ;
163: isVariable (@expr1073745798 !@expr1073745799 isClass (@expr3976 ) &&@expr1073745801 !@expr3978 isAlias (@expr3910 ) &&@expr1073745804 !@expr3981 isFriend (@expr3929 ) &&@expr1073745807 Token ::@expr3883 Match (@expr1073745809 tok1@var1647 , "=|;" ) ) ;
164: if (@expr1073745810 !@expr3981 isFriend (@expr3929 ) ) {
165: if (@expr1073745813 isVariable (@expr3990 ) ) {
166: isForwardDeclaration (@expr3991 tok1@var1647 .@expr3958 str (@expr3959 ) ==@expr3994 ";" ) ; }
167: else { if (@expr1073745819 !@expr3978 isAlias (@expr3910 ) ) {
168: if (@expr1073745822 isFunction (@expr3999 ) ) {
169: tok1@var1647 =@expr1073745824 tok1@var1647 .@expr4001 link (@expr4002 ) .@expr1073745827 next (@expr1073745828 ) ; }
170: while (@expr1073745829 tok1@var1647 &&@expr1073745830 !@expr1073745831 Token ::@expr3883 Match (@expr1073745833 tok1@var1647 , ";|{" ) ) {
171: if (@expr3957 tok1@var1647 .@expr3958 str (@expr3959 ) ==@expr3960 "<" ) {
172: tok1@var1647 =@expr1073745838 tok1@var1647 .@expr3962 findClosingBracket (@expr3963 ) ; }
173: else { if (@expr1073745841 Token ::@expr3883 Match (@expr1073745843 tok1@var1647 , "(|[" ) &&@expr1073745844 tok1@var1647 .@expr4001 link (@expr4002 ) ) {
174: tok1@var1647 =@expr1073745847 tok1@var1647 .@expr4001 link (@expr4002 ) ; } }
175: if (@expr4026 tok1@var1647 ) {
176: tok1@var1647 =@expr1073745851 tok1@var1647 .@expr1073745852 next (@expr1073745853 ) ; }
177: }
178: if (@expr4026 tok1@var1647 ) {
179: isForwardDeclaration (@expr3991 tok1@var1647 .@expr3958 str (@expr3959 ) ==@expr3994 ";" ) ; }
180: } }
181: }
182:
183: if (@expr1073745859 (@expr1073745860 isFunction (@expr3999 ) ||@expr4038 isClass (@expr3976 ) ) &&@expr1073745864
184: (@expr1073745865 mNameToken@var8 .@expr3902 strAt (@expr1073745867 -1 ) ==@expr1073745868 "::" ||@expr1073745869 Token ::@expr3867 simpleMatch (@expr1073745871 mNameToken@var8 .@expr3880 tokAt (@expr3881 -2 ) , ":: ~" ) ) ) {
185: const Token * start@var1649 ; start@var1649 =@expr1073745874 mNameToken@var8 ;
186: if (@expr1073745875 start@var1649 .@expr4052 strAt (@expr1073745877 -1 ) ==@expr1073745878 "~" ) {
187: start@var1649 =@expr1073745879 start@var1649 .@expr1073745880 previous (@expr1073745881 ) ; }
188: const Token * end@var1650 ; end@var1650 =@expr1073745882 start@var1649 ;
189:
190: while (@expr1073745883 start@var1649 &&@expr1073745884 (@expr1073745885 Token ::@expr3883 Match (@expr1073745887 start@var1649 .@expr4064 tokAt (@expr4065 -2 ) , "%name% ::" ) ||@expr1073745890
191: (@expr1073745891 Token ::@expr3867 simpleMatch (@expr1073745893 start@var1649 .@expr4064 tokAt (@expr4065 -2 ) , "> ::" ) &&@expr1073745896
192: start@var1649 .@expr4064 tokAt (@expr4065 -2 ) .@expr4075 findOpeningBracket (@expr4076 ) &&@expr1073745901
193: Token ::@expr3883 Match (@expr1073745903 start@var1649 .@expr4064 tokAt (@expr4065 -2 ) .@expr4075 findOpeningBracket (@expr4076 ) .@expr4084 previous (@expr4085 ) , "%name% <" ) ) ) ) {
194: if (@expr1073745910 start@var1649 .@expr4052 strAt (@expr1073745912 -2 ) ==@expr1073745913 ">" ) {
195: start@var1649 =@expr1073745914 start@var1649 .@expr4064 tokAt (@expr4065 -2 ) .@expr4075 findOpeningBracket (@expr4076 ) .@expr4084 previous (@expr4085 ) ; }
196: else {
197: start@var1649 =@expr1073745921 start@var1649 .@expr4064 tokAt (@expr4065 -2 ) ; }
198: }
199:
200: if (@expr1073745924 start@var1649 &&@expr1073745925 start@var1649 !=@expr1073745926 end@var1650 ) {
201: if (@expr4103 !@expr4104 mScope@var5 .@expr4105 empty (@expr4106 ) ) {
202: mScope@var5 +=@expr1073745931 " ::" ; }
203: while (@expr1073745932 start@var1649 &&@expr1073745933 start@var1649 .@expr4110 next (@expr4111 ) !=@expr1073745936 end@var1650 ) {
204: if (@expr1073745937 start@var1649 .@expr4114 str (@expr4115 ) ==@expr1073745940 "<" ) {
205: start@var1649 =@expr1073745941 start@var1649 .@expr1073745942 findClosingBracket (@expr1073745943 ) ; }
206: else {
207: if (@expr4103 !@expr4104 mScope@var5 .@expr4105 empty (@expr4106 ) ) {
208: mScope@var5 +=@expr1073745948 " " ; }
209: mScope@var5 +=@expr1073745949 start@var1649 .@expr4114 str (@expr4115 ) ;
210: }
211: start@var1649 =@expr1073745952 start@var1649 .@expr4110 next (@expr4111 ) ;
212: }
213: if (@expr1073745955 start@var1649 ) {
214: mFullName@var7 =@expr1073745956 mScope@var5 .@expr4105 empty (@expr4106 ) ?@expr1073745959 mName@var6 :@expr1073745960 (@expr1073745961 mScope@var5 +@expr1073745962 " :: " +@expr1073745963 mName@var6 ) ; }
215: }
216: }
217: }
218:
219:
220: assert (@expr1073745964 isClass (@expr3976 ) ?@expr1073745966 !@expr1073745967 (@expr1073745968 isFunction (@expr3999 ) ||@expr1073745970 isVariable (@expr3990 ) ) :@expr1073745972 true ) ;
221: assert (@expr1073745973 isFunction (@expr3999 ) ?@expr1073745975 !@expr1073745976 (@expr1073745977 isClass (@expr3976 ) ||@expr1073745979 isVariable (@expr3990 ) ) :@expr1073745981 true ) ;
222: assert (@expr1073745982 isVariable (@expr3990 ) ?@expr1073745984 !@expr1073745985 (@expr1073745986 isClass (@expr3976 ) ||@expr4038 isFunction (@expr3999 ) ) :@expr1073745990 true ) ;
223:
224: if (@expr1073745991 mToken@var4 ) {
225: mToken@var4 .@expr1073745992 templateSimplifierPointer (@expr1073745993 this@expr1073745994 ) ; }
226: }
227:
228: TemplateSimplifier :: TokenAndName :: TokenAndName ( const TokenAndName & other@var1651 ) :
229: mToken@var4 ( other@var1651 . mToken@var1652 ) , mScope@var5 ( other@var1651 . mScope@var1653 ) , mName@var6 ( other@var1651 . mName@var1654 ) , mFullName@var7 ( other@var1651 . mFullName@var1655 ) ,
230: mNameToken@var8 ( other@var1651 . mNameToken@var1656 ) , mParamEnd@var9 ( other@var1651 . mParamEnd@var1657 ) , mFlags@var10 ( other@var1651 . mFlags@var1658 )
231: {
232: if (@expr1073745995 mToken@var4 ) {
233: mToken@var4 .@expr1073745996 templateSimplifierPointer (@expr1073745997 this@expr1073745998 ) ; }
234: }
235:
236: TemplateSimplifier :: TokenAndName :: ~ TokenAndName ( )
237: {
238: if (@expr1073745999 mToken@var4 &&@expr1073746000 mToken@var4 .@expr4177 templateSimplifierPointers (@expr4178 ) ) {
239: mToken@var4 .@expr4177 templateSimplifierPointers (@expr4178 ) .@expr1073746005 erase (@expr1073746006 this@expr1073746007 ) ; }
240: }
241:
242: const Token * TemplateSimplifier :: TokenAndName :: aliasStartToken ( ) const
243: {
244: if (@expr1073746008 mParamEnd@var9 ) {
245: return mParamEnd@var9 .@expr1073746009 tokAt (@expr1073746010 4 ) ; }
246: return nullptr ;
247: }
248:
249: const Token * TemplateSimplifier :: TokenAndName :: aliasEndToken ( ) const
250: {
251: if (@expr1073746011 aliasStartToken (@expr4188 ) ) {
252: return Token ::@expr1073746013 findsimplematch (@expr1073746014 aliasStartToken (@expr4188 ) , ";" ) ; }
253: return nullptr ;
254: }
255:
256: bool TemplateSimplifier :: TokenAndName :: isAliasToken ( const Token * tok@var1659 ) const
257: {
258: const Token * end@var1660 ; end@var1660 =@expr1073746016 aliasEndToken (@expr1073746017 ) ;
259:
260: for (@expr1073746018 const Token *@expr1073746019 tok1@var1661 =@expr1073746020 aliasStartToken (@expr1073746021 ) ; tok1@var1661 !=@expr1073746022 end@var1660 ; tok1@var1661 =@expr1073746023 tok1@var1661 .@expr1073746024 next (@expr1073746025 ) ) {
261: if (@expr1073746026 tok1@var1661 ==@expr1073746027 tok@var1659 ) {
262: return true ; }
263: }
264: return false ;
265: }
266:
267: TemplateSimplifier :: TemplateSimplifier ( Tokenizer * tokenizer@var1662 )
268: : mTokenizer@var99 ( tokenizer@var1662 ) , mTokenList@var100 ( tokenizer@var1662 . list@var1663 ) , mSettings@var101 ( tokenizer@var1662 . mSettings@var1664 ) ,
269: mErrorLogger@var102 ( tokenizer@var1662 . mErrorLogger@var1665 ) , mChanged@var103 ( false )
270: { }
271:
272: TemplateSimplifier :: ~ TemplateSimplifier ( )
273: { }
274:
275: void TemplateSimplifier :: checkComplicatedSyntaxErrorsInTemplates ( )
276: {
277:
278: for (@expr1073746028 const Token *@expr4205 tok@var1666 =@expr1073746030 mTokenList@var100 .@expr1073746031 front (@expr1073746032 ) ; tok@var1666 ; tok@var1666 =@expr1073746033 tok@var1666 .@expr4210 next (@expr4211 ) ) {
279:
280: if (@expr1073746036 Token ::@expr4213 simpleMatch (@expr1073746038 tok@var1666 , "( {" ) ) {
281: tok@var1666 =@expr1073746039 tok@var1666 .@expr1073746040 link (@expr1073746041 ) ;
282: if (@expr4218 !@expr4219 tok@var1666 ) {
283: syntaxError (@expr4220 nullptr ) ; }
284: }
285:
286: const Token * start@var1667 ; start@var1667 =@expr1073746045 Tokenizer ::@expr1073746046 startOfExecutableScope (@expr1073746047 tok@var1666 ) ;
287: if (@expr1073746048 start@var1667 ) {
288: tok@var1666 =@expr1073746049 start@var1667 .@expr1073746050 link (@expr1073746051 ) ;
289: }
290:
291:
292: else { if (@expr1073746052 Token ::@expr4213 simpleMatch (@expr1073746054 tok@var1666 , "try {" ) ) {
293: tok@var1666 =@expr1073746055 tok@var1666 .@expr4210 next (@expr4211 ) .@expr4234 link (@expr4235 ) ;
294: while (@expr1073746060 Token ::@expr4213 simpleMatch (@expr1073746062 tok@var1666 , "} catch (" ) ) {
295: tok@var1666 =@expr1073746063 tok@var1666 .@expr1073746064 linkAt (@expr1073746065 2 ) ;
296: if (@expr1073746066 Token ::@expr4213 simpleMatch (@expr1073746068 tok@var1666 , ") {" ) ) {
297: tok@var1666 =@expr1073746069 tok@var1666 .@expr4210 next (@expr4211 ) .@expr4234 link (@expr4235 ) ; }
298: }
299: } }
300:
301: if (@expr4218 !@expr4219 tok@var1666 ) {
302: syntaxError (@expr4220 nullptr ) ; }
303:
304: if (@expr1073746077 tok@var1666 .@expr1073746078 previous (@expr1073746079 ) &&@expr1073746080 !@expr1073746081 Token ::@expr4258 Match (@expr1073746083 tok@var1666 , "[;{}]" ) ) {
305: continue ; }
306:
307:
308: while (@expr1073746084 Token ::@expr4258 Match (@expr1073746086 tok@var1666 , ";|{" ) ) {
309: tok@var1666 =@expr1073746087 tok@var1666 .@expr4210 next (@expr4211 ) ; }
310: while (@expr1073746090 Token ::@expr4258 Match (@expr1073746092 tok@var1666 , "typedef|typename" ) ) {
311: tok@var1666 =@expr1073746093 tok@var1666 .@expr4210 next (@expr4211 ) ; }
312: while (@expr1073746096 Token ::@expr4258 Match (@expr1073746098 tok@var1666 , "%type% ::" ) ) {
313: tok@var1666 =@expr1073746099 tok@var1666 .@expr1073746100 tokAt (@expr1073746101 2 ) ; }
314: if (@expr4218 !@expr4219 tok@var1666 ) {
315: break ; }
316:
317:
318: if (@expr1073746104 Token ::@expr4258 Match (@expr1073746106 tok@var1666 , "%type% <" ) &&@expr1073746107 !@expr1073746108 Token ::@expr4213 simpleMatch (@expr1073746110 tok@var1666 , "template" ) ) {
319:
320: std ::@expr1073746111 set < std ::@expr1073746112 string > usedtypes@var1668 ;
321:
322:
323: unsigned int level@var1669 ; level@var1669 =@expr1073746113 0 ;
324: for (@expr1073746114 const Token *@expr4205 tok2@var1670 =@expr1073746116 tok@var1666 ; tok2@var1670 &&@expr1073746117 !@expr1073746118 Token ::@expr4213 simpleMatch (@expr1073746120 tok2@var1670 , ";" ) ; tok2@var1670 =@expr1073746121 tok2@var1670 .@expr4298 next (@expr4299 ) ) {
325: if (@expr1073746124 Token ::@expr4213 simpleMatch (@expr1073746126 tok2@var1670 , "{" ) &&@expr1073746127
326: (@expr1073746128 !@expr1073746129 Token ::@expr4258 Match (@expr1073746131 tok2@var1670 .@expr4308 previous (@expr4309 ) , ">|%type%" ) ||@expr1073746134 Token ::@expr4213 simpleMatch (@expr1073746136 tok2@var1670 .@expr4313 link (@expr4314 ) , "} ;" ) ) ) {
327: break ; }
328: if (@expr1073746139 tok2@var1670 .@expr4316 str (@expr4317 ) ==@expr1073746142 "(" ) {
329: tok2@var1670 =@expr1073746143 tok2@var1670 .@expr4313 link (@expr4314 ) ; }
330: else { if (@expr1073746146 tok2@var1670 .@expr4316 str (@expr4317 ) ==@expr1073746149 "<" ) {
331: bool inclevel@var1671 ; inclevel@var1671 =@expr1073746150 false ;
332: if (@expr1073746151 Token ::@expr4213 simpleMatch (@expr1073746153 tok2@var1670 .@expr4308 previous (@expr4309 ) , "operator <" ) ) {
333: ; }
334: else { if (@expr1073746156 level@var1669 ==@expr1073746157 0 &&@expr1073746158 Token ::@expr4258 Match (@expr1073746160 tok2@var1670 .@expr4308 previous (@expr4309 ) , "%type%" ) ) {
335:
336: if (@expr1073746163 !@expr1073746164 (@expr1073746165 Token ::@expr4258 Match (@expr1073746167 tok2@var1670 .@expr4298 next (@expr4299 ) , "*| %type%|%num% ;" ) ||@expr1073746170
337: Token ::@expr4258 Match (@expr1073746172 tok2@var1670 .@expr4298 next (@expr4299 ) , "*| %type% . %type% ;" ) ) ) {
338: inclevel@var1671 =@expr1073746175 true ;
339: }
340: } else { if (@expr1073746176 tok2@var1670 .@expr4298 next (@expr4299 ) &&@expr1073746179 tok2@var1670 .@expr4298 next (@expr4299 ) .@expr1073746182 isStandardType (@expr1073746183 ) &&@expr1073746184 !@expr1073746185 Token ::@expr4258 Match (@expr1073746187 tok2@var1670 .@expr4364 tokAt (@expr1073746189 2 ) , "(|{" ) ) {
341: inclevel@var1671 =@expr1073746190 true ; }
342: else { if (@expr1073746191 Token ::@expr4213 simpleMatch (@expr1073746193 tok2@var1670 , "< typename" ) ) {
343: inclevel@var1671 =@expr1073746194 true ; }
344: else { if (@expr1073746195 Token ::@expr4258 Match (@expr4373 tok2@var1670 .@expr4364 tokAt (@expr4375 -2 ) , "<|, %type% <" ) &&@expr1073746200 usedtypes@var1668 .@expr4377 find (@expr1073746202 tok2@var1670 .@expr4308 previous (@expr4309 ) .@expr4381 str (@expr4382 ) ) !=@expr1073746207 usedtypes@var1668 .@expr4384 end (@expr4385 ) ) {
345: inclevel@var1671 =@expr1073746210 true ; }
346: else { if (@expr1073746211 Token ::@expr4258 Match (@expr4389 tok2@var1670 , "< %type%" ) &&@expr1073746214 usedtypes@var1668 .@expr4377 find (@expr1073746216 tok2@var1670 .@expr4298 next (@expr4299 ) .@expr1073746219 str (@expr1073746220 ) ) !=@expr1073746221 usedtypes@var1668 .@expr4384 end (@expr4385 ) ) {
347: inclevel@var1671 =@expr1073746224 true ; }
348: else { if (@expr1073746225 Token ::@expr4258 Match (@expr4389 tok2@var1670 , "< %type%" ) ) {
349:
350:
351: const Token * tok3@var1672 ; tok3@var1672 =@expr1073746228 tok2@var1670 .@expr4298 next (@expr4299 ) ;
352: while (@expr1073746231 Token ::@expr4258 Match (@expr1073746233 tok3@var1672 , "%type% ::" ) ) {
353: tok3@var1672 =@expr1073746234 tok3@var1672 .@expr1073746235 tokAt (@expr1073746236 2 ) ; }
354: if (@expr1073746237 Token ::@expr4258 Match (@expr1073746239 tok3@var1672 , "%type% <" ) ) {
355: inclevel@var1671 =@expr1073746240 true ; }
356: } else { if (@expr1073746241 tok2@var1670 .@expr1073746242 strAt (@expr1073746243 -1 ) ==@expr1073746244 ">" ) {
357: syntaxError (@expr4421 tok@var1666 ) ; } } } } } } } }
358:
359: if (@expr1073746246 inclevel@var1671 ) {
360: ++@expr1073746247 level@var1669 ;
361: if (@expr1073746248 Token ::@expr4258 Match (@expr4373 tok2@var1670 .@expr4364 tokAt (@expr4375 -2 ) , "<|, %type% <" ) ) {
362: usedtypes@var1668 .@expr1073746253 insert (@expr1073746254 tok2@var1670 .@expr4308 previous (@expr4309 ) .@expr4381 str (@expr4382 ) ) ; }
363: }
364: } else { if (@expr1073746259 tok2@var1670 .@expr4316 str (@expr4317 ) ==@expr1073746262 ">" ) {
365: if (@expr4439 level@var1669 >@expr4440 0 ) {
366: --@expr1073746265 level@var1669 ; }
367: } else { if (@expr1073746266 tok2@var1670 .@expr4316 str (@expr4317 ) ==@expr1073746269 ">>" ) {
368: if (@expr4439 level@var1669 >@expr4440 0 ) {
369: --@expr1073746272 level@var1669 ; }
370: if (@expr4439 level@var1669 >@expr4440 0 ) {
371: --@expr1073746275 level@var1669 ; }
372: } } } }
373: }
374: if (@expr4439 level@var1669 >@expr4440 0 ) {
375: syntaxError (@expr4421 tok@var1666 ) ; }
376: }
377: }
378: }
379:
380: unsigned int TemplateSimplifier :: templateParameters ( const Token * tok@var1673 )
381: {
382: unsigned int numberOfParameters@var1674 ; numberOfParameters@var1674 =@expr1073746279 1 ;
383:
384: if (@expr4456 !@expr4457 tok@var1673 ) {
385: return 0 ; }
386: if (@expr1073746282 tok@var1673 .@expr4459 str (@expr4460 ) !=@expr1073746285 "<" ) {
387: return 0 ; }
388: if (@expr1073746286 Token ::@expr4463 Match (@expr1073746288 tok@var1673 .@expr4465 previous (@expr4466 ) , "%var% <" ) ) {
389: return 0 ; }
390: tok@var1673 =@expr1073746291 tok@var1673 .@expr4468 next (@expr4469 ) ;
391: if (@expr1073746294 !@expr4457 tok@var1673 ||@expr1073746296 tok@var1673 .@expr4459 str (@expr4460 ) ==@expr4475 ">" ) {
392: return 0 ; }
393:
394: unsigned int level@var1675 ; level@var1675 =@expr1073746300 0 ;
395:
396: while (@expr1073746301 tok@var1673 ) {
397:
398: if (@expr1073746302 level@var1675 ==@expr4479 0 &&@expr1073746304 Token ::@expr4481 simpleMatch (@expr1073746306 tok@var1673 , "template <" ) ) {
399: const Token * closing@var1676 ; closing@var1676 =@expr1073746307 tok@var1673 .@expr4468 next (@expr4469 ) .@expr1073746310 findClosingBracket (@expr1073746311 ) ;
400: if (@expr1073746312 closing@var1676 ) {
401: if (@expr1073746313 closing@var1676 .@expr1073746314 str (@expr1073746315 ) ==@expr1073746316 ">>" ) {
402: return numberOfParameters@var1674 ; }
403: tok@var1673 =@expr1073746317 closing@var1676 .@expr1073746318 next (@expr1073746319 ) ;
404: if (@expr4456 !@expr4457 tok@var1673 ) {
405: syntaxError (@expr4498 tok@var1673 ) ; }
406: if (@expr1073746323 Token ::@expr4463 Match (@expr4501 tok@var1673 , ">|>>|>>=" ) ) {
407: return numberOfParameters@var1674 ; }
408: else { if (@expr4502 tok@var1673 .@expr4459 str (@expr4460 ) ==@expr4505 "," ) {
409: ++@expr1073746330 numberOfParameters@var1674 ;
410: tok@var1673 =@expr1073746331 tok@var1673 .@expr4468 next (@expr4469 ) ;
411: continue ;
412: } }
413: } else {
414: return 0 ; }
415: }
416:
417:
418: if (@expr1073746334 Token ::@expr4463 Match (@expr4512 tok@var1673 , "const|volatile" ) ) {
419: tok@var1673 =@expr1073746337 tok@var1673 .@expr4468 next (@expr4469 ) ; }
420:
421:
422: if (@expr1073746340 Token ::@expr4463 Match (@expr1073746342 tok@var1673 , "struct|union" ) ) {
423: tok@var1673 =@expr1073746343 tok@var1673 .@expr4468 next (@expr4469 ) ; }
424:
425:
426: if (@expr1073746346 Token ::@expr4463 Match (@expr1073746348 tok@var1673 , "& ::| %name%" ) ) {
427: tok@var1673 =@expr1073746349 tok@var1673 .@expr4468 next (@expr4469 ) ; }
428:
429:
430: if (@expr1073746352 Token ::@expr4481 simpleMatch (@expr1073746354 tok@var1673 , "..." ) ) {
431: if (@expr1073746355 (@expr1073746356 tok@var1673 .@expr4465 previous (@expr4466 ) .@expr4535 isName (@expr4536 ) &&@expr1073746361 !@expr1073746362 Token ::@expr4463 Match (@expr1073746364 tok@var1673 .@expr4541 tokAt (@expr1073746366 -2 ) , "<|,|::" ) ) ||@expr1073746367
432: (@expr1073746368 !@expr1073746369 tok@var1673 .@expr4465 previous (@expr4466 ) .@expr4535 isName (@expr4536 ) &&@expr1073746374 tok@var1673 .@expr1073746375 strAt (@expr1073746376 -1 ) !=@expr1073746377 ">" ) ) {
433: return 0 ; }
434: tok@var1673 =@expr1073746378 tok@var1673 .@expr4468 next (@expr4469 ) ;
435: if (@expr4456 !@expr4457 tok@var1673 ) {
436: return 0 ; }
437: if (@expr1073746383 tok@var1673 .@expr4459 str (@expr4460 ) ==@expr4475 ">" ) {
438: if (@expr4563 level@var1675 ==@expr4479 0 ) {
439: return numberOfParameters@var1674 ; }
440: --@expr1073746389 level@var1675 ;
441: } else { if (@expr4566 tok@var1673 .@expr4459 str (@expr4460 ) ==@expr4569 ">>" ||@expr4570 tok@var1673 .@expr4459 str (@expr4460 ) ==@expr4573 ">>=" ) {
442: if (@expr1073746398 level@var1675 ==@expr4575 1 ) {
443: return numberOfParameters@var1674 ; }
444: level@var1675 -=@expr1073746400 2 ;
445: } else { if (@expr1073746401 tok@var1673 .@expr4459 str (@expr4460 ) ==@expr4505 "," &&@expr1073746405 level@var1675 ==@expr4479 0 ) {
446: ++@expr1073746407 numberOfParameters@var1674 ;
447: tok@var1673 =@expr1073746408 tok@var1673 .@expr4468 next (@expr4469 ) ;
448: continue ;
449: } } }
450: }
451:
452:
453: if (@expr1073746411 Token ::@expr4463 Match (@expr1073746413 tok@var1673 , "=|?|:" ) ) {
454: tok@var1673 =@expr1073746414 tok@var1673 .@expr4468 next (@expr4469 ) ; }
455: if (@expr4456 !@expr4457 tok@var1673 ) {
456: return 0 ; }
457:
458:
459: if (@expr1073746419 Token ::@expr4463 Match (@expr1073746421 tok@var1673 , "(|{" ) ) {
460: tok@var1673 =@expr1073746422 tok@var1673 .@expr4599 link (@expr4600 ) ;
461: if (@expr1073746425 tok@var1673 ) {
462: tok@var1673 =@expr1073746426 tok@var1673 .@expr4468 next (@expr4469 ) ; }
463: if (@expr4456 !@expr4457 tok@var1673 ) {
464: return 0 ; }
465: if (@expr1073746431 tok@var1673 .@expr4459 str (@expr4460 ) ==@expr4475 ">" &&@expr1073746435 level@var1675 ==@expr4479 0 ) {
466: return numberOfParameters@var1674 ; }
467: else { if (@expr1073746437 (@expr1073746438 tok@var1673 .@expr4459 str (@expr4460 ) ==@expr4569 ">>" ||@expr4570 tok@var1673 .@expr4459 str (@expr4460 ) ==@expr4573 ">>=" ) &&@expr1073746446 level@var1675 ==@expr4575 1 ) {
468: return numberOfParameters@var1674 ; }
469: else { if (@expr4502 tok@var1673 .@expr4459 str (@expr4460 ) ==@expr4505 "," ) {
470: if (@expr4563 level@var1675 ==@expr4479 0 ) {
471: ++@expr1073746454 numberOfParameters@var1674 ; }
472: tok@var1673 =@expr1073746455 tok@var1673 .@expr4468 next (@expr4469 ) ;
473: } } }
474: continue ;
475: }
476:
477:
478: if (@expr1073746458 tok@var1673 .@expr4459 str (@expr4460 ) ==@expr1073746461 "::" ) {
479: tok@var1673 =@expr1073746462 tok@var1673 .@expr4468 next (@expr4469 ) ; }
480: while (@expr1073746465 Token ::@expr4463 Match (@expr1073746467 tok@var1673 , "%name% ::" ) ) {
481: tok@var1673 =@expr1073746468 tok@var1673 .@expr4541 tokAt (@expr1073746470 2 ) ;
482: if (@expr1073746471 tok@var1673 &&@expr1073746472 tok@var1673 .@expr4459 str (@expr4460 ) ==@expr1073746475 "*" ) {
483: tok@var1673 =@expr1073746476 tok@var1673 .@expr4468 next (@expr4469 ) ; }
484: }
485: if (@expr4456 !@expr4457 tok@var1673 ) {
486: return 0 ; }
487:
488:
489: if (@expr1073746481 !@expr1073746482 tok@var1673 .@expr1073746483 isNumber (@expr1073746484 ) &&@expr1073746485 tok@var1673 .@expr1073746486 tokType (@expr1073746487 ) !=@expr1073746488 Token ::@expr1073746489 eChar &&@expr1073746490 !@expr1073746491 tok@var1673 .@expr1073746492 isName (@expr1073746493 ) &&@expr1073746494 !@expr1073746495 tok@var1673 .@expr1073746496 isOp (@expr1073746497 ) ) {
490: return 0 ; }
491: tok@var1673 =@expr1073746498 tok@var1673 .@expr4468 next (@expr4469 ) ;
492: if (@expr4456 !@expr4457 tok@var1673 ) {
493: return 0 ; }
494:
495:
496: while (@expr1073746503 Token ::@expr4463 Match (@expr1073746505 tok@var1673 , "*|&|&&|const" ) ) {
497: tok@var1673 =@expr1073746506 tok@var1673 .@expr4468 next (@expr4469 ) ; }
498:
499: if (@expr4456 !@expr4457 tok@var1673 ) {
500: return 0 ; }
501:
502:
503: while (@expr1073746511 Token ::@expr4463 Match (@expr4689 tok@var1673 , "(|[" ) ) {
504: if (@expr1073746514 !@expr1073746515 tok@var1673 .@expr4599 link (@expr4600 ) ) {
505: syntaxError (@expr4498 tok@var1673 ) ; }
506:
507: tok@var1673 =@expr1073746519 tok@var1673 .@expr4599 link (@expr4600 ) .@expr4698 next (@expr4699 ) ;
508: while (@expr1073746524 Token ::@expr4463 Match (@expr4512 tok@var1673 , "const|volatile" ) ) {
509: tok@var1673 =@expr1073746527 tok@var1673 .@expr4468 next (@expr4469 ) ; }
510: }
511: if (@expr4456 !@expr4457 tok@var1673 ) {
512: return 0 ; }
513:
514:
515: if (@expr1073746532 tok@var1673 .@expr4459 str (@expr4460 ) ==@expr1073746535 "<" ) {
516: ++@expr1073746536 level@var1675 ;
517: tok@var1673 =@expr1073746537 tok@var1673 .@expr4468 next (@expr4469 ) ;
518: }
519:
520: if (@expr4456 !@expr4457 tok@var1673 ) {
521: return 0 ; }
522:
523:
524: while (@expr1073746542 Token ::@expr4463 Match (@expr4501 tok@var1673 , ">|>>|>>=" ) ) {
525: if (@expr4563 level@var1675 ==@expr4479 0 ) {
526: return tok@var1673 .@expr4459 str (@expr4460 ) ==@expr4475 ">" &&@expr1073746550 !@expr4727 Token ::@expr4463 Match (@expr4729 tok@var1673 .@expr4468 next (@expr4469 ) , "%num%" ) ?@expr1073746556 numberOfParameters@var1674 :@expr4733 0 ; }
527: --@expr1073746558 level@var1675 ;
528: if (@expr4566 tok@var1673 .@expr4459 str (@expr4460 ) ==@expr4569 ">>" ||@expr4570 tok@var1673 .@expr4459 str (@expr4460 ) ==@expr4573 ">>=" ) {
529: if (@expr4563 level@var1675 ==@expr4479 0 ) {
530: return !@expr4727 Token ::@expr4463 Match (@expr4729 tok@var1673 .@expr4468 next (@expr4469 ) , "%num%" ) ?@expr1073746574 numberOfParameters@var1674 :@expr4733 0 ; }
531: --@expr1073746576 level@var1675 ;
532: }
533: tok@var1673 =@expr1073746577 tok@var1673 .@expr4468 next (@expr4469 ) ;
534:
535: if (@expr1073746580 Token ::@expr4463 Match (@expr4689 tok@var1673 , "(|[" ) ) {
536: tok@var1673 =@expr1073746583 tok@var1673 .@expr4599 link (@expr4600 ) .@expr4698 next (@expr4699 ) ; }
537:
538: if (@expr4456 !@expr4457 tok@var1673 ) {
539: return 0 ; }
540: }
541:
542: if (@expr1073746590 tok@var1673 .@expr4459 str (@expr4460 ) !=@expr1073746593 "," ) {
543: continue ; }
544: if (@expr4563 level@var1675 ==@expr4479 0 ) {
545: ++@expr1073746596 numberOfParameters@var1674 ; }
546: tok@var1673 =@expr1073746597 tok@var1673 .@expr4468 next (@expr4469 ) ;
547: }
548: return 0 ;
549: }
550:
551: const Token * TemplateSimplifier :: findTemplateDeclarationEnd ( const Token * tok@var1677 )
552: {
553: return const_cast < const Token *@expr4776 > (@expr1073746601 findTemplateDeclarationEnd (@expr1073746602 const_cast < Token *@expr4776 > (@expr1073746604 tok@var1677 ) ) ) ;
554: }
555:
556: Token * TemplateSimplifier :: findTemplateDeclarationEnd ( Token * tok@var1678 )
557: {
558: if (@expr1073746605 Token ::@expr1073746606 simpleMatch (@expr1073746607 tok@var1678 , "template <" ) ) {
559: tok@var1678 =@expr1073746608 tok@var1678 .@expr4785 next (@expr4786 ) .@expr1073746611 findClosingBracket (@expr1073746612 ) ;
560: if (@expr1073746613 tok@var1678 ) {
561: tok@var1678 =@expr1073746614 tok@var1678 .@expr4785 next (@expr4786 ) ; }
562: }
563:
564: if (@expr1073746617 !@expr1073746618 tok@var1678 ) {
565: return nullptr ; }
566:
567: Token * tok2@var1679 ; tok2@var1679 =@expr1073746619 tok@var1678 ;
568: bool in_init@var1680 ; in_init@var1680 =@expr1073746620 false ;
569: while (@expr1073746621 tok2@var1679 &&@expr1073746622 !@expr1073746623 Token ::@expr4800 Match (@expr1073746625 tok2@var1679 , ";|{" ) ) {
570: if (@expr1073746626 tok2@var1679 .@expr4803 str (@expr4804 ) ==@expr1073746629 "<" ) {
571: tok2@var1679 =@expr1073746630 tok2@var1679 .@expr1073746631 findClosingBracket (@expr1073746632 ) ; }
572: else { if (@expr1073746633 Token ::@expr4800 Match (@expr1073746635 tok2@var1679 , "(|[" ) &&@expr1073746636 tok2@var1679 .@expr4813 link (@expr4814 ) ) {
573: tok2@var1679 =@expr1073746639 tok2@var1679 .@expr4813 link (@expr4814 ) ; }
574: else { if (@expr1073746642 tok2@var1679 .@expr4803 str (@expr4804 ) ==@expr1073746645 ":" ) {
575: in_init@var1680 =@expr1073746646 true ; }
576: else { if (@expr1073746647 in_init@var1680 &&@expr1073746648 Token ::@expr4800 Match (@expr1073746650 tok2@var1679 , "%name% (|{" ) ) {
577: tok2@var1679 =@expr1073746651 tok2@var1679 .@expr1073746652 linkAt (@expr1073746653 1 ) ;
578: if (@expr1073746654 tok2@var1679 .@expr1073746655 strAt (@expr1073746656 1 ) ==@expr1073746657 "{" ) {
579: in_init@var1680 =@expr1073746658 false ; }
580: } } } }
581: if (@expr1073746659 tok2@var1679 ) {
582: tok2@var1679 =@expr1073746660 tok2@var1679 .@expr1073746661 next (@expr1073746662 ) ; }
583: }
584: if (@expr1073746663 tok2@var1679 &&@expr1073746664 tok2@var1679 .@expr4803 str (@expr4804 ) ==@expr1073746667 "{" ) {
585: tok@var1678 =@expr1073746668 tok2@var1679 .@expr4813 link (@expr4814 ) ;
586: if (@expr1073746671 tok@var1678 &&@expr1073746672 tok@var1678 .@expr1073746673 strAt (@expr1073746674 1 ) ==@expr1073746675 ";" ) {
587: tok@var1678 =@expr1073746676 tok@var1678 .@expr4785 next (@expr4786 ) ; }
588: } else { if (@expr1073746679 tok2@var1679 &&@expr1073746680 tok2@var1679 .@expr4803 str (@expr4804 ) ==@expr1073746683 ";" ) {
589: tok@var1678 =@expr1073746684 tok2@var1679 ; }
590: else {
591: tok@var1678 =@expr1073746685 nullptr ; } }
592:
593: return tok@var1678 ;
594: }
595:
596: void TemplateSimplifier :: eraseTokens ( Token * begin@var1681 , const Token * end@var1682 )
597: {
598: if (@expr1073746686 !@expr1073746687 begin@var1681 ||@expr1073746688 begin@var1681 ==@expr1073746689 end@var1682 ) {
599: return ; }
600:
601: while (@expr1073746690 begin@var1681 .@expr4867 next (@expr4868 ) &&@expr1073746693 begin@var1681 .@expr4867 next (@expr4868 ) !=@expr1073746696 end@var1682 ) {
602: begin@var1681 .@expr1073746697 deleteNext (@expr1073746698 ) ;
603: }
604: }
605:
606: void TemplateSimplifier :: deleteToken ( Token * tok@var1683 )
607: {
608: if (@expr1073746699 tok@var1683 .@expr4876 next (@expr4877 ) ) {
609: tok@var1683 .@expr4876 next (@expr4877 ) .@expr1073746704 deletePrevious (@expr1073746705 ) ; }
610: else {
611: tok@var1683 .@expr1073746706 deleteThis (@expr1073746707 ) ; }
612: }
613:
614: bool TemplateSimplifier :: removeTemplate ( Token * tok@var1684 )
615: {
616: if (@expr1073746708 !@expr1073746709 Token ::@expr1073746710 simpleMatch (@expr1073746711 tok@var1684 , "template <" ) ) {
617: return false ; }
618:
619: Token * end@var1685 ; end@var1685 =@expr1073746712 findTemplateDeclarationEnd (@expr1073746713 tok@var1684 ) ;
620: if (@expr1073746714 end@var1685 &&@expr1073746715 end@var1685 .@expr4892 next (@expr4893 ) ) {
621: eraseTokens (@expr1073746718 tok@var1684 , end@var1685 .@expr4892 next (@expr4893 ) ) ;
622: deleteToken (@expr1073746721 tok@var1684 ) ;
623: return true ;
624: }
625:
626: return false ;
627: }
628:
629: bool TemplateSimplifier :: getTemplateDeclarations ( )
630: {
631: bool codeWithTemplates@var1686 ; codeWithTemplates@var1686 =@expr1073746722 false ;
632: for (@expr1073746723 Token *@expr4900 tok@var1687 =@expr1073746725 mTokenList@var100 .@expr1073746726 front (@expr1073746727 ) ; tok@var1687 ; tok@var1687 =@expr1073746728 tok@var1687 .@expr4905 next (@expr4906 ) ) {
633: if (@expr1073746731 !@expr1073746732 Token ::@expr4909 simpleMatch (@expr1073746734 tok@var1687 , "template <" ) ) {
634: continue ; }
635:
636: if (@expr1073746735 tok@var1687 .@expr4912 strAt (@expr4913 -1 ) ==@expr1073746738 "<" ||@expr1073746739 tok@var1687 .@expr4912 strAt (@expr4913 -1 ) ==@expr1073746742 "," ) {
637: continue ; }
638:
639: if (@expr1073746743 tok@var1687 .@expr4912 strAt (@expr4913 -1 ) ==@expr1073746746 ">" ) {
640: continue ; }
641:
642: const Token * tok1@var1688 ; tok1@var1688 =@expr1073746747 tok@var1687 ;
643: while (@expr1073746748 tok1@var1688 &&@expr1073746749 tok1@var1688 .@expr4926 next (@expr4927 ) ) {
644: const Token * closing@var1689 ; closing@var1689 =@expr1073746752 tok1@var1688 .@expr4926 next (@expr4927 ) .@expr4931 findClosingBracket (@expr4932 ) ;
645: if (@expr1073746757 !@expr1073746758 Token ::@expr4909 simpleMatch (@expr1073746760 closing@var1689 , "> template <" ) ) {
646: break ; }
647: tok1@var1688 =@expr1073746761 closing@var1689 .@expr1073746762 next (@expr1073746763 ) ;
648: }
649: if (@expr1073746764 !@expr1073746765 Token ::@expr4942 Match (@expr1073746767 tok@var1687 , "%any% %any%" ) ) {
650: syntaxError (@expr1073746768 tok@var1687 ) ; }
651: if (@expr1073746769 tok@var1687 .@expr4912 strAt (@expr1073746771 2 ) ==@expr1073746772 "typename" &&@expr1073746773
652: !@expr1073746774 Token ::@expr4942 Match (@expr1073746776 tok@var1687 .@expr1073746777 tokAt (@expr1073746778 3 ) , "%name%|...|,|=|>" ) ) {
653: syntaxError (@expr1073746779 tok@var1687 .@expr4905 next (@expr4906 ) ) ; }
654: codeWithTemplates@var1686 =@expr1073746782 true ;
655: const Token * const parmEnd@var1690 ; parmEnd@var1690 =@expr1073746783 tok1@var1688 .@expr4926 next (@expr4927 ) .@expr4931 findClosingBracket (@expr4932 ) ;
656: for (@expr1073746788 const Token *@expr4900 tok2@var1691 =@expr1073746790 parmEnd@var1690 ; tok2@var1691 ; tok2@var1691 =@expr1073746791 tok2@var1691 .@expr1073746792 next (@expr1073746793 ) ) {
657: if (@expr1073746794 tok2@var1691 .@expr4971 str (@expr4972 ) ==@expr1073746797 "(" &&@expr1073746798 tok2@var1691 .@expr4975 link (@expr4976 ) ) {
658: tok2@var1691 =@expr1073746801 tok2@var1691 .@expr4975 link (@expr4976 ) ; }
659: else { if (@expr1073746804 tok2@var1691 .@expr4971 str (@expr4972 ) ==@expr1073746807 ")" ) {
660: break ; }
661:
662: else { if (@expr1073746808 Token ::@expr4909 simpleMatch (@expr1073746810 tok2@var1691 , "decltype (" ) ) {
663: tok2@var1691 =@expr1073746811 tok2@var1691 .@expr1073746812 linkAt (@expr1073746813 1 ) ; }
664: else { if (@expr1073746814 Token ::@expr4942 Match (@expr1073746816 tok2@var1691 , "{|=|;" ) ) {
665: const int namepos@var1692 =@expr1073746817 getTemplateNamePosition (@expr1073746818 parmEnd@var1690 ) ;
666: if (@expr1073746819 namepos@var1692 >@expr1073746820 0 ) {
667: TokenAndName decl@var1693 (@expr1073746821 tok@var1687 , tok@var1687 .@expr1073746822 scopeInfo (@expr1073746823 ) .@expr1073746824 name@var2211 , parmEnd@var1690 .@expr1073746825 tokAt (@expr1073746826 namepos@var1692 ) , parmEnd@var1690 ) ;
668: if (@expr1073746827 decl@var1693 .@expr1073746828 isForwardDeclaration (@expr1073746829 ) ) {
669:
670: mTemplateForwardDeclarations@var105 .@expr1073746830 emplace_back (@expr1073746831 std ::@expr5008 move (@expr5009 decl@var1693 ) ) ;
671: } else {
672:
673: mTemplateDeclarations@var104 .@expr1073746834 emplace_back (@expr1073746835 std ::@expr5008 move (@expr5009 decl@var1693 ) ) ;
674: }
675: Token * end@var1694 ; end@var1694 =@expr1073746838 findTemplateDeclarationEnd (@expr1073746839 tok@var1687 ) ;
676: if (@expr1073746840 end@var1694 ) {
677: tok@var1687 =@expr1073746841 end@var1694 ; }
678: break ;
679: }
680: } } } }
681: }
682: }
683: return codeWithTemplates@var1686 ;
684: }
685:
686: void TemplateSimplifier :: addInstantiation ( Token * token@var1695 , const std :: string & scope@var1696 )
687: {
688: simplifyTemplateArgs (@expr1073746842 token@var1695 .@expr1073746843 tokAt (@expr1073746844 2 ) , token@var1695 .@expr1073746845 next (@expr1073746846 ) .@expr1073746847 findClosingBracket (@expr1073746848 ) ) ;
689:
690: TokenAndName instantiation@var1697 (@expr1073746849 token@var1695 , scope@var1696 ) ;
691:
692:
693: std ::@expr1073746850 list < TokenAndName > ::@expr1073746851 iterator it@var1698 ; it@var1698 =@expr1073746852 std ::@expr1073746853 find (@expr1073746854 mTemplateInstantiations@var109 .@expr1073746855 begin (@expr1073746856 ) ,
694: mTemplateInstantiations@var109 .@expr5033 end (@expr5034 ) ,
695: instantiation@var1697 ) ;
696:
697: if (@expr1073746859 it@var1698 ==@expr1073746860 mTemplateInstantiations@var109 .@expr5033 end (@expr5034 ) ) {
698: mTemplateInstantiations@var109 .@expr1073746863 emplace_back (@expr1073746864 instantiation@var1697 ) ; }
699: }
700:
701: static void getFunctionArguments ( const Token * nameToken@var1699 , std :: vector < const Token * > & args@var1700 )
702: {
703: const Token * argToken@var1701 ;
704:
705: if (@expr1073746865 nameToken@var1699 .@expr5042 strAt (@expr5043 1 ) ==@expr1073746868 "(" ) {
706: argToken@var1701 =@expr1073746869 nameToken@var1699 .@expr1073746870 tokAt (@expr1073746871 2 ) ; }
707: else { if (@expr1073746872 nameToken@var1699 .@expr5042 strAt (@expr5043 1 ) ==@expr1073746875 "<" ) {
708: const Token * end@var1702 ; end@var1702 =@expr1073746876 nameToken@var1699 .@expr1073746877 next (@expr1073746878 ) .@expr1073746879 findClosingBracket (@expr1073746880 ) ;
709: if (@expr1073746881 end@var1702 ) {
710: argToken@var1701 =@expr1073746882 end@var1702 .@expr1073746883 tokAt (@expr1073746884 2 ) ; }
711: else {
712: return ; }
713: } else {
714: return ; } }
715:
716: if (@expr1073746885 argToken@var1701 .@expr1073746886 str (@expr1073746887 ) ==@expr1073746888 ")" ) {
717: return ; }
718:
719: args@var1700 .@expr5065 push_back (@expr5066 argToken@var1701 ) ;
720:
721: while (@expr1073746891 argToken@var1701 =@expr1073746892 argToken@var1701 .@expr1073746893 nextArgumentBeforeCreateLinks2 (@expr1073746894 ) ) {
722: args@var1700 .@expr5065 push_back (@expr5066 argToken@var1701 ) ; }
723: }
724:
725: static bool areAllParamsTypes ( const std :: vector < const Token * > & params@var1703 )
726: {
727: if (@expr1073746897 params@var1703 .@expr1073746898 empty (@expr1073746899 ) ) {
728: return false ; }
729:
730: for (@expr1073746900 const auto *@expr1073746901 param@var1704 :@expr1073746902 params@var1703 ) {
731: if (@expr1073746903 !@expr1073746904 Token ::@expr1073746905 Match (@expr1073746906 param@var1704 .@expr1073746907 previous (@expr1073746908 ) , "typename|class %name% ,|>" ) ) {
732: return false ; }
733: }
734:
735: return true ;
736: }
737:
738: void TemplateSimplifier :: getTemplateInstantiations ( )
739: {
740: std ::@expr1073746910 multimap < std ::@expr5087 string , const TokenAndName *@expr5088 > functionNameMap@var1705 ;
741:
742: for (@expr1073746913 const auto &@expr5090 decl@var1706 :@expr1073746915 mTemplateDeclarations@var104 ) {
743: if (@expr1073746916 decl@var1706 .@expr1073746917 isFunction (@expr1073746918 ) ) {
744: functionNameMap@var1705 .@expr5095 insert (@expr1073746920 std ::@expr5097 make_pair (@expr1073746922 decl@var1706 .@expr1073746923 name (@expr1073746924 ) , &@expr1073746925 decl@var1706 ) ) ; }
745: }
746:
747: for (@expr1073746926 const auto &@expr5090 decl@var1707 :@expr1073746928 mTemplateForwardDeclarations@var105 ) {
748: if (@expr1073746929 decl@var1707 .@expr1073746930 isFunction (@expr1073746931 ) ) {
749: functionNameMap@var1705 .@expr5095 insert (@expr1073746933 std ::@expr5097 make_pair (@expr1073746935 decl@var1707 .@expr1073746936 name (@expr1073746937 ) , &@expr1073746938 decl@var1707 ) ) ; }
750: }
751:
752: const Token * skip@var1708 ; skip@var1708 =@expr1073746939 nullptr ;
753:
754: for (@expr1073746940 Token *@expr5088 tok@var1709 =@expr1073746942 mTokenList@var100 .@expr1073746943 front (@expr1073746944 ) ; tok@var1709 ; tok@var1709 =@expr1073746945 tok@var1709 .@expr5122 next (@expr5123 ) ) {
755:
756:
757: if (@expr1073746948 Token ::@expr1073746949 simpleMatch (@expr1073746950 tok@var1709 , "template <" ) ) {
758: tok@var1709 =@expr1073746951 tok@var1709 .@expr5122 next (@expr5123 ) .@expr5130 findClosingBracket (@expr5131 ) ;
759: if (@expr1073746956 !@expr1073746957 tok@var1709 ) {
760: break ; }
761:
762: const bool isUsing@var1710 =@expr1073746958 tok@var1709 .@expr5135 strAt (@expr5136 1 ) ==@expr1073746961 "using" ;
763: if (@expr1073746962 isUsing@var1710 &&@expr1073746963 Token ::@expr5140 Match (@expr1073746965 tok@var1709 .@expr5142 tokAt (@expr5143 2 ) , "%name% <" ) ) {
764:
765: Token * tok2@var1711 ; tok2@var1711 =@expr1073746968 Token ::@expr5145 findsimplematch (@expr5146 tok@var1709 .@expr5142 tokAt (@expr5148 3 ) , ";" ) ;
766: if (@expr1073746973 tok2@var1711 ) {
767: tok@var1709 =@expr1073746974 tok2@var1711 ; }
768: } else { if (@expr1073746975 tok@var1709 .@expr5135 strAt (@expr1073746977 -1 ) ==@expr1073746978 "<" ) {
769:
770:
771:
772: unsigned int pos@var1712 ; pos@var1712 =@expr1073746979 getTemplateNamePosition (@expr1073746980 tok@var1709 ) ;
773: if (@expr1073746981 pos@var1712 >@expr1073746982 0 ) {
774: skip@var1708 =@expr1073746983 tok@var1709 .@expr5142 tokAt (@expr1073746985 pos@var1712 ) ; }
775: } else {
776:
|
779:
780: Token * tok2@var1713 ; tok2@var1713 =@expr1073746986 findTemplateDeclarationEnd (@expr1073746987 tok@var1709 .@expr5122 next (@expr5123 ) ) ;
781: if (@expr1073746990 tok2@var1713 ) {
782: tok@var1709 =@expr1073746991 tok2@var1713 ; }
783: } }
784: } else { if (@expr1073746992 Token ::@expr5140 Match (@expr1073746994 tok@var1709 , "template using %name% <" ) ) {
785:
786: Token * tok2@var1714 ; tok2@var1714 =@expr1073746995 Token ::@expr5145 findsimplematch (@expr5146 tok@var1709 .@expr5142 tokAt (@expr5148 3 ) , ";" ) ;
787: if (@expr1073747000 tok2@var1714 ) {
788: tok@var1709 =@expr1073747001 tok2@var1714 ; }
789: } else { if (@expr1073747002 Token ::@expr5140 Match (@expr1073747004 tok@var1709 , "using %name% <" ) ) {
790:
791: Token * tok2@var1715 ; tok2@var1715 =@expr1073747005 Token ::@expr5145 findsimplematch (@expr1073747007 tok@var1709 .@expr5142 tokAt (@expr5143 2 ) , ";" ) ;
792: if (@expr1073747010 tok2@var1715 ) {
793: tok@var1709 =@expr1073747011 tok2@var1715 ; }
794: } else { if (@expr1073747012 Token ::@expr5140 Match (@expr1073747014 tok@var1709 .@expr5191 previous (@expr5192 ) , "(|{|}|;|=|>|<<|:|.|*|&|return|<|,|!|[ %name% ::|<|(" ) ||@expr1073747017
795: Token ::@expr5140 Match (@expr1073747019 tok@var1709 .@expr5191 previous (@expr5192 ) , "%type% %name% ::|<" ) ||@expr1073747022
796: Token ::@expr5140 Match (@expr1073747024 tok@var1709 .@expr5142 tokAt (@expr1073747026 -2 ) , "[,:] private|protected|public %name% ::|<" ) ) {
797: std ::@expr1073747027 string scopeName@var1716 ; scopeName@var1716 =@expr1073747028 tok@var1709 .@expr5205 scopeInfo (@expr5206 ) .@expr5207 name@var2211 ;
798: std ::@expr1073747032 string qualification@var1717 ;
799: Token * qualificationTok@var1718 ; qualificationTok@var1718 =@expr1073747033 tok@var1709 ;
800: while (@expr1073747034 Token ::@expr5140 Match (@expr1073747036 tok@var1709 , "%name% :: %name%" ) ) {
801: qualification@var1717 +=@expr1073747037 (@expr1073747038 qualification@var1717 .@expr5215 empty (@expr5216 ) ?@expr5217 "" :@expr5218 " :: " ) +@expr1073747043 tok@var1709 .@expr5220 str (@expr5221 ) ;
802: tok@var1709 =@expr1073747046 tok@var1709 .@expr5142 tokAt (@expr5143 2 ) ;
803: }
804:
805:
806: if (@expr5225 tok@var1709 ==@expr5226 skip@var1708 ) {
807: skip@var1708 =@expr1073747051 nullptr ;
808: continue ;
809: }
810:
811:
812: if (@expr1073747052 tok@var1709 .@expr5135 strAt (@expr5136 1 ) ==@expr1073747055 "(" ) {
813: std ::@expr1073747056 vector < const Token *@expr5088 > instantiationArgs@var1719 ;
814: getFunctionArguments (@expr1073747058 tok@var1709 , instantiationArgs@var1719 ) ;
815:
816: std ::@expr1073747059 string fullName@var1720 ;
817: if (@expr5236 !@expr5237 qualification@var1717 .@expr5215 empty (@expr5216 ) ) {
818: fullName@var1720 =@expr1073747064 qualification@var1717 +@expr1073747065 " :: " +@expr1073747066 tok@var1709 .@expr5220 str (@expr5221 ) ; }
819: else { if (@expr1073747069 !@expr1073747070 scopeName@var1716 .@expr5247 empty (@expr5248 ) ) {
820: fullName@var1720 =@expr1073747073 scopeName@var1716 +@expr1073747074 " :: " +@expr1073747075 tok@var1709 .@expr5220 str (@expr5221 ) ; }
821: else {
822: fullName@var1720 =@expr1073747078 tok@var1709 .@expr5220 str (@expr5221 ) ; } }
823:
824:
825: for (@expr1073747081 auto pos@var1721 =@expr1073747082 functionNameMap@var1705 .@expr1073747083 lower_bound (@expr1073747084 tok@var1709 .@expr5220 str (@expr5221 ) ) ;
826: pos@var1721 !=@expr1073747087 functionNameMap@var1705 .@expr1073747088 upper_bound (@expr1073747089 tok@var1709 .@expr5220 str (@expr5221 ) ) ; ++@expr1073747092 pos@var1721 ) {
827:
828: if (@expr1073747093 pos@var1721 .@expr5270 second@var1722 .@expr1073747095 fullName (@expr1073747096 ) ==@expr1073747097 fullName@var1720 ||@expr1073747098
829: (@expr1073747099 pos@var1721 .@expr5270 second@var1722 .@expr1073747101 scope (@expr1073747102 ) ==@expr1073747103 fullName@var1720 &&@expr1073747104 tok@var1709 .@expr5220 str (@expr5221 ) ==@expr1073747107 pos@var1721 .@expr5270 second@var1722 .@expr1073747109 name (@expr1073747110 ) ) ) {
830: std ::@expr1073747111 vector < const Token *@expr5088 > templateParams@var1723 ;
831: getTemplateParametersInDeclaration (@expr1073747113 pos@var1721 .@expr5270 second@var1722 .@expr1073747115 token (@expr1073747116 ) .@expr1073747117 tokAt (@expr1073747118 2 ) , templateParams@var1723 ) ;
832:
833:
834: if (@expr1073747119 templateParams@var1723 .@expr1073747120 size (@expr1073747121 ) !=@expr1073747122 1 ||@expr1073747123 !@expr1073747124 areAllParamsTypes (@expr1073747125 templateParams@var1723 ) ) {
835: continue ; }
836:
837: std ::@expr1073747126 vector < const Token *@expr5088 > declarationParams@var1724 ;
838: getFunctionArguments (@expr1073747128 pos@var1721 .@expr5270 second@var1722 .@expr1073747130 nameToken (@expr1073747131 ) , declarationParams@var1724 ) ;
839:
840:
841: if (@expr1073747132 instantiationArgs@var1719 .@expr1073747133 empty (@expr1073747134 ) ||@expr1073747135 instantiationArgs@var1719 .@expr1073747136 size (@expr1073747137 ) !=@expr1073747138 declarationParams@var1724 .@expr5315 size (@expr5316 ) ) {
842: continue ; }
843:
844: unsigned long match@var1725 ; match@var1725 =@expr1073747141 0 ;
845: unsigned long argMatch@var1726 ; argMatch@var1726 =@expr1073747142 0 ;
846: for (@expr1073747143 unsigned long i@var1727 =@expr1073747144 0 ; i@var1727 <@expr1073747145 declarationParams@var1724 .@expr5315 size (@expr5316 ) ; ++@expr1073747148 i@var1727 ) {
847:
848: bool isArgLiteral@var1728 ; isArgLiteral@var1728 =@expr1073747149 Token ::@expr5140 Match (@expr1073747151 instantiationArgs@var1719 [@expr1073747152 i@var1727 ] , "%num%|%str%|%char%|%bool% ,|)" ) ;
849: if (@expr1073747153 isArgLiteral@var1728 &&@expr1073747154 Token ::@expr5140 Match (@expr1073747156 declarationParams@var1724 [@expr5333 i@var1727 ] , "const| %type% &| %name%| ,|)" ) ) {
850: match@var1725 ++@expr1073747158 ;
851:
852:
853: if (@expr1073747159 templateParams@var1723 [@expr1073747160 0 ] .@expr1073747161 str (@expr1073747162 ) ==@expr1073747163 declarationParams@var1724 [@expr5333 i@var1727 ] .@expr1073747165 str (@expr1073747166 ) ) {
854: argMatch@var1726 =@expr1073747167 i@var1727 ; }
855: else {
856:
857: }
858: }
859: }
860:
861: if (@expr1073747168 match@var1725 ==@expr1073747169 declarationParams@var1724 .@expr5315 size (@expr5316 ) ) {
862: const Token * arg@var1729 ; arg@var1729 =@expr1073747172 instantiationArgs@var1719 [@expr1073747173 argMatch@var1726 ] ;
863: tok@var1709 .@expr5350 insertToken (@expr1073747175 ">" ) ;
864: switch (@expr1073747176 arg@var1729 .@expr1073747177 tokType (@expr1073747178 ) ) {
865: case Token ::@expr1073747179 eBoolean :@expr5356 ;
866: tok@var1709 .@expr5350 insertToken (@expr1073747182 "bool" ) ;
867: break ;
868: case Token ::@expr1073747183 eChar :@expr5356 ;
869: if (@expr5361 arg@var1729 .@expr5362 isLong (@expr5363 ) ) {
870: tok@var1709 .@expr5350 insertToken (@expr5365 "wchar_t" ) ; }
871: else {
872: tok@var1709 .@expr5350 insertToken (@expr5367 "char" ) ; }
873: break ;
874: case Token ::@expr1073747192 eString :@expr5356 ;
875: tok@var1709 .@expr5350 insertToken (@expr1073747195 "*" ) ;
876: if (@expr5361 arg@var1729 .@expr5362 isLong (@expr5363 ) ) {
877: tok@var1709 .@expr5350 insertToken (@expr5365 "wchar_t" ) ; }
878: else {
879: tok@var1709 .@expr5350 insertToken (@expr5367 "char" ) ; }
880: tok@var1709 .@expr5350 insertToken (@expr1073747204 "const" ) ;
881: break ;
882: case Token ::@expr1073747205 eNumber :@expr5356 ; {
883: MathLib ::@expr1073747207 value num@var1730 (@expr1073747208 arg@var1729 .@expr5385 str (@expr5386 ) ) ;
884: if (@expr1073747211 num@var1730 .@expr1073747212 isFloat (@expr1073747213 ) ) {
885:
886: char suffix@var1731 ; suffix@var1731 =@expr1073747214 arg@var1729 .@expr5385 str (@expr5386 ) .@expr1073747217 back (@expr1073747218 ) ;
887: if (@expr1073747219 suffix@var1731 ==@expr1073747220 'f' ||@expr1073747221 suffix@var1731 ==@expr1073747222 'F' ) {
888: tok@var1709 .@expr5350 insertToken (@expr1073747224 "float" ) ; }
889: else { if (@expr1073747225 suffix@var1731 ==@expr1073747226 'l' ||@expr1073747227 suffix@var1731 ==@expr1073747228 'L' ) {
890: tok@var1709 .@expr5350 insertToken (@expr5406 "double" ) ;
891: tok@var1709 .@expr5122 next (@expr5123 ) .@expr5409 isLong (@expr5410 true ) ;
892: } else {
893: tok@var1709 .@expr5350 insertToken (@expr5406 "double" ) ; } }
894: } else { if (@expr1073747237 num@var1730 .@expr1073747238 isInt (@expr1073747239 ) ) {
895: std ::@expr1073747240 string suffix@var1732 ; suffix@var1732 =@expr1073747241 MathLib ::@expr1073747242 getSuffix (@expr1073747243 tok@var1709 .@expr5135 strAt (@expr1073747245 3 ) ) ;
896: if (@expr1073747246 suffix@var1732 .@expr5423 find (@expr1073747248 "LL" ) !=@expr1073747249 std ::@expr5426 string ::@expr5427 npos@expr5085 ) {
897: tok@var1709 .@expr5350 insertToken (@expr5429 "long" ) ;
898: tok@var1709 .@expr5122 next (@expr5123 ) .@expr5409 isLong (@expr5410 true ) ;
899: } else { if (@expr1073747258 suffix@var1732 .@expr5423 find (@expr1073747260 'L' ) !=@expr1073747261 std ::@expr5426 string ::@expr5427 npos@expr5085 ) {
900: tok@var1709 .@expr5350 insertToken (@expr5429 "long" ) ; }
901: else {
902: tok@var1709 .@expr5350 insertToken (@expr1073747267 "int" ) ; } }
903: if (@expr1073747268 suffix@var1732 .@expr5423 find (@expr1073747270 'U' ) !=@expr1073747271 std ::@expr5426 string ::@expr5427 npos@expr5085 ) {
904: tok@var1709 .@expr5122 next (@expr5123 ) .@expr1073747276 isUnsigned (@expr1073747277 true ) ; }
905: } }
906: break ;
907: }
908: default :@expr5356 ;
909: break ;
910: }
911: tok@var1709 .@expr5350 insertToken (@expr1073747280 "<" ) ;
912: break ;
913: }
914: }
915: }
916: }
917:
918: if (@expr1073747281 !@expr1073747282 Token ::@expr5140 Match (@expr1073747284 tok@var1709 , "%name% <" ) ||@expr1073747285
919: Token ::@expr5140 Match (@expr1073747287 tok@var1709 , "const_cast|dynamic_cast|reinterpret_cast|static_cast" ) ) {
920: continue ; }
921:
922: if (@expr5225 tok@var1709 ==@expr5226 skip@var1708 ) {
923: skip@var1708 =@expr1073747290 nullptr ;
924: continue ;
925: }
926:
927:
928:
929: Token * tok2@var1733 ; tok2@var1733 =@expr1073747291 tok@var1709 .@expr5122 next (@expr5123 ) .@expr5130 findClosingBracket (@expr5131 ) ;
930:
931:
932:
933: for (@expr1073747296 ; tok2@var1733 &&@expr1073747297 tok2@var1733 !=@expr1073747298 tok@var1709 ; tok2@var1733 =@expr1073747299 tok2@var1733 .@expr1073747300 previous (@expr1073747301 ) ) {
934: if (@expr1073747302 Token ::@expr5140 Match (@expr1073747304 tok2@var1733 , ",|< %name% <" ) &&@expr1073747305
935: (@expr1073747306 tok2@var1733 .@expr1073747307 strAt (@expr1073747308 3 ) ==@expr1073747309 ">" ||@expr1073747310 templateParameters (@expr1073747311 tok2@var1733 .@expr1073747312 tokAt (@expr1073747313 2 ) ) ) ) {
936: addInstantiation (@expr1073747314 tok2@var1733 .@expr5491 next (@expr5492 ) , tok@var1709 .@expr5205 scopeInfo (@expr5206 ) .@expr5207 name@var2211 ) ;
937: } else { if (@expr1073747320 Token ::@expr5140 Match (@expr1073747322 tok2@var1733 .@expr5491 next (@expr5492 ) , "class|struct" ) ) {
938: tok2@var1733 .@expr1073747325 deleteNext (@expr1073747326 ) ; } }
939: }
940:
941:
942: if (@expr1073747327 templateParameters (@expr1073747328 tok@var1709 .@expr5122 next (@expr5123 ) ) ||@expr1073747331 tok@var1709 .@expr5135 strAt (@expr1073747333 2 ) ==@expr1073747334 ">" ) {
943: while (@expr1073747335 true ) {
944: const std ::@expr5087 string fullName@var1734 =@expr1073747337 scopeName@var1716 +@expr5514 (@expr1073747339 scopeName@var1716 .@expr5247 empty (@expr5248 ) ?@expr5518 "" :@expr5218 " :: " ) +@expr1073747344
945: qualification@var1717 +@expr1073747345 (@expr1073747346 qualification@var1717 .@expr5215 empty (@expr5216 ) ?@expr5217 "" :@expr5218 " :: " ) +@expr1073747351 tok@var1709 .@expr5220 str (@expr5221 ) ;
946: const std ::@expr5530 list < TokenAndName > ::@expr1073747355 const_iterator it@var1735 =@expr1073747356 std ::@expr5533 find_if (@expr1073747358 mTemplateDeclarations@var104 .@expr5535 begin (@expr5536 ) , mTemplateDeclarations@var104 .@expr5537 end (@expr5538 ) , FindFullName (@expr1073747363 fullName@var1734 ) ) ;
947: if (@expr1073747364 it@var1735 !=@expr1073747365 mTemplateDeclarations@var104 .@expr5537 end (@expr5538 ) ) {
948:
949: addInstantiation (@expr1073747368 tok@var1709 , it@var1735 .@expr1073747369 scope (@expr1073747370 ) ) ;
950: break ;
951: } else {
952:
953: bool found@var1736 ; found@var1736 =@expr1073747371 false ;
954: for (@expr1073747372 const auto &@expr5090 nameSpace@var1737 :@expr1073747374 tok@var1709 .@expr5205 scopeInfo (@expr5206 ) .@expr1073747377 usingNamespaces@var2212 ) {
955: std ::@expr1073747378 string fullNameSpace@var1738 ; fullNameSpace@var1738 =@expr1073747379 scopeName@var1716 +@expr5514 (@expr1073747381 scopeName@var1716 .@expr5247 empty (@expr5248 ) ?@expr5518 "" :@expr5218 " :: " ) +@expr1073747386
956: nameSpace@var1737 +@expr1073747387 (@expr1073747388 qualification@var1717 .@expr5215 empty (@expr5216 ) ?@expr5217 "" :@expr5218 " :: " ) +@expr1073747393 qualification@var1717 ;
957: std ::@expr1073747394 string newFullName@var1739 ; newFullName@var1739 =@expr1073747395 fullNameSpace@var1738 +@expr1073747396 " :: " +@expr1073747397 tok@var1709 .@expr5220 str (@expr5221 ) ;
958: const std ::@expr5530 list < TokenAndName > ::@expr1073747401 const_iterator it1@var1740 =@expr1073747402 std ::@expr5533 find_if (@expr1073747404 mTemplateDeclarations@var104 .@expr5535 begin (@expr5536 ) , mTemplateDeclarations@var104 .@expr5537 end (@expr5538 ) , FindFullName (@expr1073747409 newFullName@var1739 ) ) ;
959: if (@expr1073747410 it1@var1740 !=@expr1073747411 mTemplateDeclarations@var104 .@expr5537 end (@expr5538 ) ) {
960:
961: std ::@expr5426 string ::@expr1073747415 size_type offset@var1741 ; offset@var1741 =@expr1073747416 0 ;
962: std ::@expr5426 string ::@expr1073747418 size_type pos@var1742 ; pos@var1742 =@expr1073747419 0 ;
963: while (@expr1073747420 (@expr1073747421 pos@var1742 =@expr1073747422 nameSpace@var1737 .@expr5599 substr (@expr5600 offset@var1741 ) .@expr1073747425 find (@expr1073747426 ' ' ) ) !=@expr1073747427 std ::@expr5426 string ::@expr5427 npos@expr5085 ) {
964: qualificationTok@var1718 .@expr5606 insertToken (@expr1073747431 nameSpace@var1737 .@expr5599 substr (@expr1073747433 offset@var1741 , pos@var1742 ) , "" , true ) ;
965: offset@var1741 =@expr1073747434 offset@var1741 +@expr1073747435 pos@var1742 +@expr1073747436 1 ;
966: }
967: qualificationTok@var1718 .@expr5606 insertToken (@expr1073747438 nameSpace@var1737 .@expr5599 substr (@expr5600 offset@var1741 ) , "" , true ) ;
968: qualificationTok@var1718 .@expr5606 insertToken (@expr1073747442 "::" , "" , true ) ;
969: addInstantiation (@expr1073747443 tok@var1709 , it1@var1740 .@expr1073747444 scope (@expr1073747445 ) ) ;
970: found@var1736 =@expr1073747446 true ;
971: break ;
972: }
973: }
974: if (@expr1073747447 found@var1736 ) {
975: break ; }
976:
977: if (@expr1073747448 scopeName@var1716 .@expr5247 empty (@expr5248 ) ) {
978: if (@expr5236 !@expr5237 qualification@var1717 .@expr5215 empty (@expr5216 ) ) {
979: addInstantiation (@expr1073747455 tok@var1709 , qualification@var1717 ) ; }
980: else {
981: addInstantiation (@expr1073747456 tok@var1709 , tok@var1709 .@expr5205 scopeInfo (@expr5206 ) .@expr5207 name@var2211 ) ; }
982: break ;
983: }
984: const std ::@expr5087 string ::@expr5087 size_type pos@var1743 =@expr1073747462 scopeName@var1716 .@expr1073747463 rfind (@expr1073747464 " :: " ) ;
985: scopeName@var1716 =@expr1073747465 (@expr1073747466 pos@var1743 ==@expr1073747467 std ::@expr5426 string ::@expr5427 npos@expr5085 ) ?@expr1073747470 std ::@expr5426 string (@expr1073747472 ) :@expr1073747473 scopeName@var1716 .@expr1073747474 substr (@expr1073747475 0 , pos@var1743 ) ;
986: }
987: }
988: }
989: } } } }
990: }
991: }
992:
993:
994: void TemplateSimplifier :: useDefaultArgumentValues ( )
995: {
996: for (@expr1073747476 TokenAndName &@expr5653 declaration@var1744 :@expr1073747478 mTemplateDeclarations@var104 ) {
997: useDefaultArgumentValues (@expr1073747479 declaration@var1744 ) ; }
998:
999: for (@expr1073747480 TokenAndName &@expr5653 declaration@var1745 :@expr1073747482 mTemplateForwardDeclarations@var105 ) {
1000: useDefaultArgumentValues (@expr1073747483 declaration@var1745 ) ; }
1001: }
1002:
1003: void TemplateSimplifier :: useDefaultArgumentValues ( TokenAndName & declaration@var1746 )
1004: {
1005:
1006: if (@expr1073747484 declaration@var1746 .@expr1073747485 isSpecialization (@expr1073747486 ) ||@expr1073747487 declaration@var1746 .@expr1073747488 isAlias (@expr1073747489 ) ||@expr1073747490 declaration@var1746 .@expr1073747491 isFriend (@expr1073747492 ) ) {
1007: return ; }
1008:
|
1011:
1012: struct Default {
1013: Token * eq@var1747 ;
1014: Token * end@var1748 ;
1015: } ;
1016: std ::@expr1073747493 list < Default > eq@var1749 ;
1017:
1018: std ::@expr1073747494 set < unsigned long > defaultedArgPos@var1750 ;
1019:
1020:
1021: unsigned long templatepar@var1751 ; templatepar@var1751 =@expr1073747495 1 ;
1022:
1023:
1024: unsigned long templateParmDepth@var1752 ; templateParmDepth@var1752 =@expr1073747496 0 ;
1025:
1026:
1027: std ::@expr1073747497 map < std ::@expr5674 string , unsigned int > typeParameterNames@var1753 ;
1028:
1029:
1030: for (@expr1073747499 Token *@expr5676 tok@var1754 =@expr1073747501 declaration@var1746 .@expr5678 token (@expr5679 ) .@expr5680 next (@expr5681 ) ; tok@var1754 ; tok@var1754 =@expr1073747506 tok@var1754 .@expr5683 next (@expr5684 ) ) {
1031: if (@expr1073747509 Token ::@expr1073747510 simpleMatch (@expr1073747511 tok@var1754 , "template <" ) ) {
1032: Token * end@var1755 ; end@var1755 =@expr1073747512 tok@var1754 .@expr5683 next (@expr5684 ) .@expr1073747515 findClosingBracket (@expr1073747516 ) ;
1033: if (@expr1073747517 end@var1755 ) {
1034: tok@var1754 =@expr1073747518 end@var1755 ; }
1035: continue ;
1036: }
1037:
1038: if (@expr1073747519 tok@var1754 .@expr5696 link (@expr5697 ) &&@expr1073747522 Token ::@expr5699 Match (@expr1073747524 tok@var1754 , "{|(|[" ) ) {
1039: tok@var1754 =@expr1073747525 tok@var1754 .@expr5696 link (@expr5697 ) ;
1040: continue ;
1041: }
1042:
1043: if (@expr1073747528 tok@var1754 .@expr5705 str (@expr5706 ) ==@expr1073747531 "<" &&@expr1073747532
1044: (@expr1073747533 tok@var1754 .@expr5710 strAt (@expr5711 1 ) ==@expr1073747536 ">" ||@expr1073747537 (@expr1073747538 tok@var1754 .@expr1073747539 previous (@expr1073747540 ) .@expr1073747541 isName (@expr1073747542 ) &&@expr1073747543
1045: typeParameterNames@var1753 .@expr5720 find (@expr1073747545 tok@var1754 .@expr5710 strAt (@expr1073747547 -1 ) ) ==@expr1073747548 typeParameterNames@var1753 .@expr5725 end (@expr5726 ) ) ) ) {
1046: ++@expr1073747551 templateParmDepth@var1752 ; }
1047:
1048:
1049: if (@expr1073747552 tok@var1754 .@expr5705 str (@expr5706 ) ==@expr1073747555 ">" ) {
1050: if (@expr1073747556 templateParmDepth@var1752 <@expr1073747557 2 ) {
1051: if (@expr5734 !@expr5735 eq@var1749 .@expr5736 empty (@expr5737 ) ) {
1052: eq@var1749 .@expr5738 back (@expr5739 ) .@expr5740 end@var2213 =@expr1073747565 tok@var1754 ; }
1053: break ;
1054: } else {
1055: --@expr1073747566 templateParmDepth@var1752 ; }
1056: }
1057:
1058:
1059: if (@expr1073747567 Token ::@expr5699 Match (@expr1073747569 tok@var1754 , "typename|class|%type% %name% ,|>" ) ) {
1060: typeParameterNames@var1753 [@expr1073747570 tok@var1754 .@expr5710 strAt (@expr5711 1 ) ] =@expr1073747573 templatepar@var1751 -@expr1073747574 1 ; }
1061:
1062:
1063: if (@expr1073747575 tok@var1754 .@expr5705 str (@expr5706 ) ==@expr1073747578 "," &&@expr1073747579 (@expr1073747580 1 ==@expr1073747581 templateParmDepth@var1752 ) ) {
1064: if (@expr5734 !@expr5735 eq@var1749 .@expr5736 empty (@expr5737 ) ) {
1065: eq@var1749 .@expr5738 back (@expr5739 ) .@expr5740 end@var2213 =@expr1073747589 tok@var1754 ; }
1066: ++@expr1073747590 templatepar@var1751 ;
1067: }
1068:
1069:
1070: else { if (@expr1073747591 Token ::@expr5699 Match (@expr1073747593 tok@var1754 , "= !!>" ) ) {
1071: if (@expr1073747594 defaultedArgPos@var1750 .@expr1073747595 insert (@expr1073747596 templatepar@var1751 ) .@expr1073747597 second@var1756 ) {
1072: eq@var1749 .@expr1073747598 push_back (@expr1073747599 Default {@expr1073747600 tok@var1754 , nullptr } ) ;
1073: } else {
1074:
1075: eq@var1749 .@expr1073747601 clear (@expr1073747602 ) ;
1076: break ;
1077: }
1078: } }
1079: }
1080: if (@expr1073747603 eq@var1749 .@expr5736 empty (@expr5737 ) ) {
1081: return ; }
1082:
1083:
1084: for (@expr1073747606 const TokenAndName &@expr5783 instantiation@var1757 :@expr1073747608 mTemplateInstantiations@var109 ) {
1085: if (@expr1073747609 declaration@var1746 .@expr1073747610 fullName (@expr1073747611 ) !=@expr1073747612 instantiation@var1757 .@expr1073747613 fullName (@expr1073747614 ) ) {
1086: continue ; }
1087:
1088:
1089: std ::@expr1073747615 vector < std ::@expr5674 vector < const Token *@expr5676 > > instantiationArgs@var1758 ;
1090: unsigned long index@var1759 ; index@var1759 =@expr1073747618 0 ;
1091: const Token * end@var1760 ; end@var1760 =@expr1073747619 instantiation@var1757 .@expr5796 token (@expr5797 ) .@expr5798 next (@expr5799 ) .@expr1073747624 findClosingBracket (@expr1073747625 ) ;
1092: if (@expr1073747626 !@expr1073747627 end@var1760 ) {
1093: continue ; }
1094: if (@expr1073747628 end@var1760 !=@expr1073747629 instantiation@var1757 .@expr5796 token (@expr5797 ) .@expr5808 tokAt (@expr5809 2 ) ) {
1095: instantiationArgs@var1758 .@expr5810 resize (@expr1073747635 1 ) ; }
1096: for (@expr1073747636 const Token *@expr5676 tok1@var1761 =@expr1073747638 instantiation@var1757 .@expr5796 token (@expr5797 ) .@expr5808 tokAt (@expr5809 2 ) ; tok1@var1761 &&@expr1073747643 tok1@var1761 !=@expr1073747644 end@var1760 ; tok1@var1761 =@expr1073747645 tok1@var1761 .@expr5822 next (@expr5823 ) ) {
1097: if (@expr1073747648 tok1@var1761 .@expr5825 link (@expr5826 ) &&@expr1073747651 Token ::@expr5699 Match (@expr1073747653 tok1@var1761 , "{|(|[" ) ) {
1098: const Token * endLink@var1762 ; endLink@var1762 =@expr1073747654 tok1@var1761 .@expr5825 link (@expr5826 ) ;
1099: do {
1100: instantiationArgs@var1758 [@expr5833 index@var1759 ] .@expr5834 push_back (@expr5835 tok1@var1761 ) ;
1101: tok1@var1761 =@expr1073747660 tok1@var1761 .@expr5822 next (@expr5823 ) ;
1102: } while (@expr1073747663 tok1@var1761 &&@expr1073747664 tok1@var1761 !=@expr1073747665 endLink@var1762 ) ;
1103: instantiationArgs@var1758 [@expr5833 index@var1759 ] .@expr5834 push_back (@expr5835 tok1@var1761 ) ;
1104: } else { if (@expr1073747669 tok1@var1761 .@expr5846 str (@expr5847 ) ==@expr1073747672 "<" &&@expr1073747673
1105: (@expr1073747674 tok1@var1761 .@expr5851 strAt (@expr1073747676 1 ) ==@expr1073747677 ">" ||@expr1073747678 (@expr1073747679 tok1@var1761 .@expr1073747680 previous (@expr1073747681 ) .@expr1073747682 isName (@expr1073747683 ) &&@expr1073747684
1106: typeParameterNames@var1753 .@expr5720 find (@expr1073747686 tok1@var1761 .@expr5851 strAt (@expr1073747688 -1 ) ) ==@expr1073747689 typeParameterNames@var1753 .@expr5725 end (@expr5726 ) ) ) ) {
1107: const Token * endLink@var1763 ; endLink@var1763 =@expr1073747692 tok1@var1761 .@expr1073747693 findClosingBracket (@expr1073747694 ) ;
1108: do {
1109: instantiationArgs@var1758 [@expr5833 index@var1759 ] .@expr5834 push_back (@expr5835 tok1@var1761 ) ;
1110: tok1@var1761 =@expr1073747698 tok1@var1761 .@expr5822 next (@expr5823 ) ;
1111: } while (@expr1073747701 tok1@var1761 &&@expr1073747702 tok1@var1761 !=@expr1073747703 endLink@var1763 ) ;
1112: instantiationArgs@var1758 [@expr5833 index@var1759 ] .@expr5834 push_back (@expr5835 tok1@var1761 ) ;
1113: } else { if (@expr1073747707 tok1@var1761 .@expr5846 str (@expr5847 ) ==@expr1073747710 "," ) {
1114: ++@expr1073747711 index@var1759 ;
1115: instantiationArgs@var1758 .@expr5810 resize (@expr1073747713 index@var1759 +@expr1073747714 1 ) ;
1116: } else {
1117: instantiationArgs@var1758 [@expr5833 index@var1759 ] .@expr5834 push_back (@expr5835 tok1@var1761 ) ; } } }
1118: }
1119:
1120:
1121: Token * tok@var1764 ; tok@var1764 =@expr1073747718 instantiation@var1757 .@expr5796 token (@expr5797 ) .@expr5798 next (@expr5799 ) ;
1122: unsigned int usedpar@var1765 ; usedpar@var1765 =@expr1073747723 templateParameters (@expr1073747724 tok@var1764 ) ;
1123: Token * instantiationEnd@var1766 ; instantiationEnd@var1766 =@expr1073747725 tok@var1764 .@expr1073747726 findClosingBracket (@expr1073747727 ) ;
1124: tok@var1764 =@expr1073747728 instantiationEnd@var1766 ;
1125:
1126: if (@expr1073747729 tok@var1764 &&@expr1073747730 tok@var1764 .@expr1073747731 str (@expr1073747732 ) ==@expr1073747733 ">" ) {
1127: tok@var1764 =@expr1073747734 tok@var1764 .@expr1073747735 previous (@expr1073747736 ) ;
1128: std ::@expr1073747737 list < Default > ::@expr1073747738 const_iterator it@var1767 ; it@var1767 =@expr1073747739 eq@var1749 .@expr1073747740 begin (@expr1073747741 ) ;
1129: for (@expr1073747742 unsigned long i@var1768 =@expr1073747743 templatepar@var1751 -@expr1073747744 eq@var1749 .@expr1073747745 size (@expr1073747746 ) ; it@var1767 !=@expr5923 eq@var1749 .@expr5924 end@var2214 (@expr5925 ) &&@expr1073747750 i@var1768 <@expr1073747751 usedpar@var1765 ; ++@expr1073747752 i@var1768 ) {
1130: ++@expr1073747753 it@var1767 ; }
1131: int count@var1769 ; count@var1769 =@expr1073747754 0 ;
1132: while (@expr1073747755 it@var1767 !=@expr5923 eq@var1749 .@expr5924 end@var2214 (@expr5925 ) ) {
1133:
1134: if (@expr1073747759 !@expr1073747760 it@var1767 .@expr5937 end@var1770 ) {
1135: if (@expr1073747762 mSettings@var101 .@expr1073747763 debugwarnings@var2196 ) {
1136: const std ::@expr1073747764 list < const Token *@expr5676 > locationList@var1771 (@expr1073747766 1 , it@var1767 .@expr5943 eq@var1772 ) ;
1137: const ErrorMessage errmsg@var1773 (@expr1073747768 locationList@var1771 , &@expr1073747769 mTokenizer@var99 .@expr1073747770 list@var2197 ,
1138: Severity ::@expr5947 debug ,
1139: "noparamend" ,
1140: "TemplateSimplifier couldn't find end of template parameter." ,
1141: Certainty ::@expr1073747772 normal ) ;
1142: if (@expr1073747773 mErrorLogger@var102 &&@expr1073747774 mSettings@var101 .@expr1073747775 severity@var2198 .@expr1073747776 isEnabled (@expr1073747777 Severity ::@expr5947 debug ) ) {
1143: mErrorLogger@var102 .@expr1073747779 reportErr (@expr1073747780 errmsg@var1773 ) ; }
1144: }
1145: break ;
1146: }
1147:
1148: if (@expr1073747781 (@expr1073747782 usedpar@var1765 +@expr1073747783 count@var1769 ) &&@expr1073747784 usedpar@var1765 <=@expr1073747785 (@expr1073747786 instantiationArgs@var1758 .@expr5963 size (@expr5964 ) +@expr1073747789 count@var1769 ) ) {
1149: tok@var1764 .@expr5966 insertToken (@expr1073747791 "," ) ;
1150: tok@var1764 =@expr1073747792 tok@var1764 .@expr5969 next (@expr5970 ) ;
1151: }
1152: std ::@expr1073747795 stack < Token *@expr5676 > links@var1774 ;
1153: for (@expr1073747797 const Token *@expr5676 from@var1775 =@expr1073747799 it@var1767 .@expr5943 eq@var1772 .@expr1073747801 next (@expr1073747802 ) ; from@var1775 &&@expr1073747803 from@var1775 !=@expr1073747804 it@var1767 .@expr5937 end@var1770 ; from@var1775 =@expr1073747806 from@var1775 .@expr1073747807 next (@expr1073747808 ) ) {
1154: auto entry@var1776 ; entry@var1776 =@expr1073747809 typeParameterNames@var1753 .@expr5720 find (@expr1073747811 from@var1775 .@expr5988 str (@expr5989 ) ) ;
1155: if (@expr1073747814 entry@var1776 !=@expr1073747815 typeParameterNames@var1753 .@expr5725 end (@expr5726 ) &&@expr1073747818 entry@var1776 .@expr5995 second@var1777 <@expr1073747820 instantiationArgs@var1758 .@expr5963 size (@expr5964 ) ) {
1156: for (@expr1073747823 const Token *@expr5676 tok1@var1778 :@expr1073747825 instantiationArgs@var1758 [@expr1073747826 entry@var1776 .@expr5995 second@var1777 ] ) {
1157: tok@var1764 .@expr5966 insertToken (@expr1073747829 tok1@var1778 .@expr1073747830 str (@expr1073747831 ) , tok1@var1778 .@expr1073747832 originalName (@expr1073747833 ) ) ;
1158: tok@var1764 =@expr1073747834 tok@var1764 .@expr5969 next (@expr5970 ) ;
1159:
1160: if (@expr6013 Token ::@expr5699 Match (@expr6015 tok@var1764 , "(|[|{" ) ) {
1161: links@var1774 .@expr6016 push (@expr6017 tok@var1764 ) ; }
1162: else { if (@expr6018 !@expr6019 links@var1774 .@expr6020 empty (@expr6021 ) &&@expr6022 Token ::@expr5699 Match (@expr6024 tok@var1764 , ")|]|}" ) ) {
1163: Token ::@expr6025 createMutualLinks (@expr6026 links@var1774 .@expr6027 top (@expr6028 ) , tok@var1764 ) ;
1164: links@var1774 .@expr6029 pop (@expr6030 ) ;
1165: } }
1166: }
1167: } else {
1168: tok@var1764 .@expr5966 insertToken (@expr1073747856 from@var1775 .@expr5988 str (@expr5989 ) , from@var1775 .@expr1073747859 originalName (@expr1073747860 ) ) ;
1169: tok@var1764 =@expr1073747861 tok@var1764 .@expr5969 next (@expr5970 ) ;
1170:
1171: if (@expr6013 Token ::@expr5699 Match (@expr6015 tok@var1764 , "(|[|{" ) ) {
1172: links@var1774 .@expr6016 push (@expr6017 tok@var1764 ) ; }
1173: else { if (@expr6018 !@expr6019 links@var1774 .@expr6020 empty (@expr6021 ) &&@expr6022 Token ::@expr5699 Match (@expr6024 tok@var1764 , ")|]|}" ) ) {
1174: Token ::@expr6025 createMutualLinks (@expr6026 links@var1774 .@expr6027 top (@expr6028 ) , tok@var1764 ) ;
1175: links@var1774 .@expr6029 pop (@expr6030 ) ;
1176: } }
1177: }
1178: }
1179: ++@expr1073747882 it@var1767 ;
1180: count@var1769 ++@expr1073747883 ;
1181: usedpar@var1765 ++@expr1073747884 ;
1182: }
1183: }
1184:
1185: simplifyTemplateArgs (@expr1073747885 instantiation@var1757 .@expr5796 token (@expr5797 ) .@expr5798 next (@expr5799 ) , instantiationEnd@var1766 ) ;
1186: }
1187:
1188: for (@expr1073747890 const auto &@expr5783 entry@var1779 :@expr1073747892 eq@var1749 ) {
1189: Token * const eqtok@var1780 ; eqtok@var1780 =@expr1073747893 entry@var1779 .@expr1073747894 eq@var1781 ;
1190: Token * tok2@var1782 ;
1191: int indentlevel@var1783 ; indentlevel@var1783 =@expr1073747895 0 ;
1192: for (@expr1073747896 tok2@var1782 =@expr1073747897 eqtok@var1780 .@expr1073747898 next (@expr1073747899 ) ; tok2@var1782 ; tok2@var1782 =@expr1073747900 tok2@var1782 .@expr6077 next (@expr6078 ) ) {
1193: if (@expr1073747903 Token ::@expr5699 Match (@expr1073747905 tok2@var1782 , ";|)|}|]" ) ) {
1194: tok2@var1782 =@expr1073747906 nullptr ;
1195: break ;
1196: }
1197: if (@expr1073747907 Token ::@expr5699 Match (@expr1073747909 tok2@var1782 , "(|{|[" ) ) {
1198: tok2@var1782 =@expr1073747910 tok2@var1782 .@expr1073747911 link (@expr1073747912 ) ; }
1199: else { if (@expr1073747913 Token ::@expr5699 Match (@expr1073747915 tok2@var1782 , "%type% <" ) &&@expr1073747916 (@expr1073747917 tok2@var1782 .@expr1073747918 strAt (@expr1073747919 2 ) ==@expr1073747920 ">" ||@expr1073747921 templateParameters (@expr1073747922 tok2@var1782 .@expr6077 next (@expr6078 ) ) ) ) {
1200: std ::@expr6101 list < TokenAndName > ::@expr1073747926 iterator ti@var1784 ; ti@var1784 =@expr1073747927 std ::@expr6104 find_if (@expr1073747929 mTemplateInstantiations@var109 .@expr6106 begin (@expr6107 ) ,
1201: mTemplateInstantiations@var109 .@expr6108 end (@expr6109 ) ,
1202: FindToken (@expr1073747934 tok2@var1782 ) ) ;
1203: if (@expr1073747935 ti@var1784 !=@expr1073747936 mTemplateInstantiations@var109 .@expr6108 end (@expr6109 ) ) {
1204: mTemplateInstantiations@var109 .@expr1073747939 erase (@expr1073747940 ti@var1784 ) ; }
1205: ++@expr1073747941 indentlevel@var1783 ;
1206: } else { if (@expr1073747942 indentlevel@var1783 >@expr1073747943 0 &&@expr1073747944 tok2@var1782 .@expr1073747945 str (@expr1073747946 ) ==@expr1073747947 ">" ) {
1207: --@expr1073747948 indentlevel@var1783 ; }
1208: else { if (@expr1073747949 indentlevel@var1783 ==@expr1073747950 0 &&@expr1073747951 Token ::@expr5699 Match (@expr1073747953 tok2@var1782 , ",|>" ) ) {
1209: break ; } } } }
1210: if (@expr1073747954 indentlevel@var1783 <@expr1073747955 0 ) {
1211: break ; }
1212: }
1213:
1214:
1215: if (@expr1073747956 !@expr1073747957 tok2@var1782 ) {
1216: continue ; }
1217:
1218:
1219: std ::@expr6101 list < TokenAndName > ::@expr1073747959 iterator ti2@var1785 ; ti2@var1785 =@expr1073747960 std ::@expr6104 find_if (@expr1073747962 mTemplateInstantiations@var109 .@expr6106 begin (@expr6107 ) ,
1220: mTemplateInstantiations@var109 .@expr6108 end (@expr6109 ) ,
1221: FindName (@expr1073747967 declaration@var1746 .@expr1073747968 name (@expr1073747969 ) ) ) ;
1222:
1223: if (@expr1073747970 ti2@var1785 ==@expr1073747971 mTemplateInstantiations@var109 .@expr6108 end (@expr6109 ) ) {
1224: continue ; }
1225:
1226: eraseTokens (@expr1073747974 eqtok@var1780 , tok2@var1782 ) ;
1227: eqtok@var1780 .@expr1073747975 deleteThis (@expr1073747976 ) ;
1228:
1229:
1230: declaration@var1746 .@expr1073747977 paramEnd (@expr1073747978 declaration@var1746 .@expr5678 token (@expr5679 ) .@expr5680 next (@expr5681 ) .@expr1073747983 findClosingBracket (@expr1073747984 ) ) ;
1231: }
1232: }
1233:
1234: void TemplateSimplifier :: simplifyTemplateAliases ( )
1235: {
1236: for (@expr1073747986 std ::@expr6163 list < TokenAndName > ::@expr6163 iterator it1@var1786 =@expr1073747989 mTemplateDeclarations@var104 .@expr1073747990 begin (@expr1073747991 ) ; it1@var1786 !=@expr1073747992 mTemplateDeclarations@var104 .@expr1073747993 end (@expr1073747994 ) ; ) {
1237: TokenAndName &@expr6171 aliasDeclaration@var1787 =@expr1073747996 *@expr1073747997 it1@var1786 ;
1238:
1239: if (@expr1073747998 !@expr1073747999 aliasDeclaration@var1787 .@expr1073748000 isAlias (@expr1073748001 ) ) {
1240: ++@expr1073748002 it1@var1786 ;
1241: continue ;
1242: }
1243:
1244:
1245: std ::@expr1073748003 vector < const Token *@expr6180 > aliasParameters@var1788 ;
1246: getTemplateParametersInDeclaration (@expr1073748005 aliasDeclaration@var1787 .@expr6182 token (@expr6183 ) .@expr1073748008 tokAt (@expr1073748009 2 ) , aliasParameters@var1788 ) ;
1247: std ::@expr1073748010 map < std ::@expr6163 string , unsigned int > aliasParameterNames@var1789 ;
1248: for (@expr1073748012 unsigned int argnr@var1790 =@expr1073748013 0 ; argnr@var1790 <@expr1073748014 aliasParameters@var1788 .@expr6191 size (@expr6192 ) ; ++@expr1073748017 argnr@var1790 ) {
1249: aliasParameterNames@var1789 [@expr1073748018 aliasParameters@var1788 [@expr1073748019 argnr@var1790 ] .@expr1073748020 str (@expr1073748021 ) ] =@expr1073748022 argnr@var1790 ; }
1250:
1251:
1252: bool found@var1791 ; found@var1791 =@expr1073748023 false ;
1253: for (@expr1073748024 std ::@expr6163 list < TokenAndName > ::@expr6163 iterator it2@var1792 =@expr1073748027 mTemplateInstantiations@var109 .@expr6204 begin (@expr6205 ) ; it2@var1792 !=@expr1073748030 mTemplateInstantiations@var109 .@expr6207 end (@expr6208 ) ; ) {
1254: TokenAndName &@expr6171 aliasUsage@var1793 =@expr1073748034 *@expr1073748035 it2@var1792 ;
1255: if (@expr1073748036 !@expr1073748037 aliasUsage@var1793 .@expr6214 token (@expr6215 ) ||@expr1073748040 aliasUsage@var1793 .@expr1073748041 fullName (@expr1073748042 ) !=@expr1073748043 aliasDeclaration@var1787 .@expr1073748044 fullName (@expr1073748045 ) ) {
1256: ++@expr1073748046 it2@var1792 ;
1257: continue ;
1258: }
1259:
1260:
1261: if (@expr1073748047 aliasDeclaration@var1787 .@expr1073748048 isAliasToken (@expr1073748049 aliasUsage@var1793 .@expr6214 token (@expr6215 ) ) ) {
1262: ++@expr1073748052 it2@var1792 ;
1263: continue ;
1264: }
1265:
1266: std ::@expr1073748053 vector < std ::@expr6163 pair < Token *@expr6180 , Token *@expr6180 > > args@var1794 ;
1267: Token * tok2@var1795 ; tok2@var1795 =@expr1073748057 aliasUsage@var1793 .@expr6214 token (@expr6215 ) .@expr1073748060 tokAt (@expr1073748061 2 ) ;
1268: while (@expr1073748062 tok2@var1795 ) {
1269: Token * const start@var1796 ; start@var1796 =@expr1073748063 tok2@var1795 ;
1270: while (@expr1073748064 tok2@var1795 &&@expr1073748065 !@expr1073748066 Token ::@expr6243 Match (@expr1073748068 tok2@var1795 , "[,>;{}]" ) ) {
1271: if (@expr1073748069 tok2@var1795 .@expr6246 link (@expr6247 ) &&@expr1073748072 Token ::@expr6243 Match (@expr1073748074 tok2@var1795 , "(|[" ) ) {
1272: tok2@var1795 =@expr1073748075 tok2@var1795 .@expr6246 link (@expr6247 ) ; }
1273: else { if (@expr1073748078 tok2@var1795 .@expr6255 str (@expr6256 ) ==@expr1073748081 "<" ) {
1274: tok2@var1795 =@expr1073748082 tok2@var1795 .@expr1073748083 findClosingBracket (@expr1073748084 ) ;
1275: if (@expr1073748085 !@expr6262 tok2@var1795 ) {
1276: break ; }
1277: } }
1278: tok2@var1795 =@expr1073748087 tok2@var1795 .@expr6264 next (@expr6265 ) ;
1279: }
1280:
1281: args@var1794 .@expr1073748090 emplace_back (@expr1073748091 start@var1796 , tok2@var1795 ) ;
1282: if (@expr1073748092 tok2@var1795 &&@expr1073748093 tok2@var1795 .@expr6255 str (@expr6256 ) ==@expr1073748096 "," ) {
1283: tok2@var1795 =@expr1073748097 tok2@var1795 .@expr6264 next (@expr6265 ) ;
1284: } else {
1285: break ;
1286: }
1287: }
1288: if (@expr1073748100 !@expr6262 tok2@var1795 ||@expr1073748102 tok2@var1795 .@expr6255 str (@expr6256 ) !=@expr1073748105 ">" ||@expr1073748106
1289: (@expr1073748107 !@expr1073748108 aliasDeclaration@var1787 .@expr6285 isVariadic (@expr6286 ) &&@expr1073748111 (@expr1073748112 args@var1794 .@expr6289 size (@expr6290 ) !=@expr1073748115 aliasParameters@var1788 .@expr6191 size (@expr6192 ) ) ) ||@expr1073748118
1290: (@expr1073748119 aliasDeclaration@var1787 .@expr6285 isVariadic (@expr6286 ) &&@expr1073748122 (@expr1073748123 args@var1794 .@expr6289 size (@expr6290 ) <@expr1073748126 aliasParameters@var1788 .@expr6191 size (@expr6192 ) ) ) ) {
1291: ++@expr1073748129 it2@var1792 ;
1292: continue ;
1293: }
1294:
1295: mChanged@var103 =@expr1073748130 true ;
1296:
1297:
1298: Token * dst@var1797 ; dst@var1797 =@expr1073748131 aliasUsage@var1793 .@expr6214 token (@expr6215 ) .@expr1073748134 next (@expr1073748135 ) .@expr1073748136 findClosingBracket (@expr1073748137 ) ;
1299: Token * end@var1798 ; end@var1798 =@expr1073748138 TokenList ::@expr6315 copyTokens (@expr1073748140 dst@var1797 , aliasDeclaration@var1787 .@expr1073748141 aliasStartToken (@expr1073748142 ) , aliasDeclaration@var1787 .@expr6319 aliasEndToken (@expr6320 ) .@expr1073748145 previous (@expr1073748146 ) , false ) .@expr1073748147 next (@expr1073748148 ) ;
1300:
1301:
1302: for (@expr1073748149 Token *@expr6180 tok1@var1799 =@expr1073748151 dst@var1797 .@expr6328 next (@expr6329 ) ; tok1@var1799 !=@expr1073748154 end@var1798 ; tok1@var1799 =@expr1073748155 tok1@var1799 .@expr6332 next (@expr6333 ) ) {
1303: if (@expr1073748158 !@expr1073748159 tok1@var1799 .@expr1073748160 isName (@expr1073748161 ) ) {
1304: continue ; }
1305: if (@expr1073748162 aliasParameterNames@var1789 .@expr6339 find (@expr1073748164 tok1@var1799 .@expr6341 str (@expr6342 ) ) !=@expr1073748167 aliasParameterNames@var1789 .@expr6344 end (@expr6345 ) ) {
1306: const unsigned int argnr@var1800 =@expr1073748170 aliasParameterNames@var1789 [@expr1073748171 tok1@var1799 .@expr6341 str (@expr6342 ) ] ;
1307: const Token * const fromStart@var1801 ; fromStart@var1801 =@expr1073748174 args@var1794 [@expr6351 argnr@var1800 ] .@expr1073748176 first@expr1073747985 ;
1308: const Token * const fromEnd@var1802 ; fromEnd@var1802 =@expr1073748177 args@var1794 [@expr6351 argnr@var1800 ] .@expr1073748179 second .@expr1073748180 previous (@expr1073748181 ) ;
1309: Token * temp@var1803 ; temp@var1803 =@expr1073748182 TokenList ::@expr6315 copyTokens (@expr1073748184 tok1@var1799 , fromStart@var1801 , fromEnd@var1802 , true ) ;
1310: const bool tempOK@var1804 (@expr1073748185 temp@var1803 &&@expr1073748186 temp@var1803 !=@expr1073748187 tok1@var1799 .@expr6332 next (@expr6333 ) ) ;
1311: tok1@var1799 .@expr6366 deleteThis (@expr6367 ) ;
1312: if (@expr1073748192 tempOK@var1804 ) {
1313: tok1@var1799 =@expr1073748193 temp@var1803 ; }
1314: } else { if (@expr1073748194 tok1@var1799 .@expr6341 str (@expr6342 ) ==@expr1073748197 "typename" ) {
1315: tok1@var1799 .@expr6366 deleteThis (@expr6367 ) ; } }
1316: }
1317:
1318:
1319: for (@expr1073748200 Token *@expr6180 tok1@var1805 =@expr1073748202 dst@var1797 .@expr6328 next (@expr6329 ) ; tok1@var1805 !=@expr1073748205 end@var1798 ; tok1@var1805 =@expr1073748206 tok1@var1805 .@expr1073748207 next (@expr1073748208 ) ) {
1320: if (@expr1073748209 !@expr1073748210 tok1@var1805 .@expr1073748211 isName (@expr1073748212 ) ) {
1321: continue ; }
1322: if (@expr1073748213 aliasParameterNames@var1789 .@expr6339 find (@expr1073748215 tok2@var1795 .@expr6255 str (@expr6256 ) ) ==@expr1073748218 aliasParameterNames@var1789 .@expr6344 end (@expr6345 ) ) {
1323:
1324: if (@expr1073748221 Token ::@expr6243 Match (@expr1073748223 tok1@var1805 , "%name% <" ) ) {
1325: const std ::@expr1073748224 list < TokenAndName > ::@expr1073748225 iterator it@var1806 =@expr1073748226 std ::@expr1073748227 find_if (@expr1073748228 mTemplateInstantiations@var109 .@expr6204 begin (@expr6205 ) ,
1326: mTemplateInstantiations@var109 .@expr6207 end (@expr6208 ) ,
1327: FindToken (@expr1073748233 tok1@var1805 ) ) ;
1328: if (@expr1073748234 it@var1806 !=@expr1073748235 mTemplateInstantiations@var109 .@expr6207 end (@expr6208 ) ) {
1329: addInstantiation (@expr1073748238 tok2@var1795 , it@var1806 .@expr1073748239 scope (@expr1073748240 ) ) ; }
1330: }
1331: }
1332: }
1333:
1334:
1335: eraseTokens (@expr1073748241 aliasUsage@var1793 .@expr6214 token (@expr6215 ) .@expr1073748244 previous (@expr1073748245 ) , dst@var1797 .@expr6328 next (@expr6329 ) ) ;
1336: found@var1791 =@expr1073748248 true ;
1337:
1338:
1339: it2@var1792 =@expr1073748249 mTemplateInstantiations@var109 .@expr1073748250 erase (@expr1073748251 it2@var1792 ) ;
1340: }
1341:
1342: if (@expr1073748252 found@var1791 ) {
1343: Token * end@var1807 ; end@var1807 =@expr1073748253 const_cast < Token *@expr6180 > (@expr1073748255 aliasDeclaration@var1787 .@expr6319 aliasEndToken (@expr6320 ) ) ;
1344:
1345:
1346: if (@expr1073748258 aliasDeclaration@var1787 .@expr6182 token (@expr6183 ) .@expr6437 previous (@expr6438 ) ) {
1347: eraseTokens (@expr1073748263 aliasDeclaration@var1787 .@expr6182 token (@expr6183 ) .@expr6437 previous (@expr6438 ) , end@var1807 .@expr6444 next (@expr6445 ) ?@expr6446 end@var1807 .@expr6444 next (@expr6445 ) :@expr6449 end@var1807 ) ; }
1348: else {
1349: eraseTokens (@expr1073748274 mTokenList@var100 .@expr6451 front (@expr6452 ) , end@var1807 .@expr6444 next (@expr6445 ) ?@expr6446 end@var1807 .@expr6444 next (@expr6445 ) :@expr6449 end@var1807 ) ;
1350: deleteToken (@expr1073748283 mTokenList@var100 .@expr6451 front (@expr6452 ) ) ;
1351: }
1352:
1353:
1354: it1@var1786 =@expr1073748286 mTemplateDeclarations@var104 .@expr1073748287 erase (@expr1073748288 it1@var1786 ) ;
1355: } else {
1356: ++@expr1073748289 it1@var1786 ; }
1357: }
1358: }
1359:
1360: bool TemplateSimplifier :: instantiateMatch ( const Token * instance@var1808 , const unsigned long numberOfArguments@var1809 , bool variadic@var1810 , const char patternAfter@var1811 [ ] )
1361: {
1362: assert (@expr1073748290 instance@var1808 .@expr1073748291 strAt (@expr1073748292 1 ) ==@expr1073748293 "<" ) ;
1363:
1364: auto n@var1812 ; n@var1812 =@expr1073748294 templateParameters (@expr1073748295 instance@var1808 .@expr6472 next (@expr6473 ) ) ;
1365: if (@expr1073748298 variadic@var1810 ?@expr1073748299 (@expr1073748300 n@var1812 +@expr1073748301 1 <@expr1073748302 numberOfArguments@var1809 ) :@expr1073748303 (@expr1073748304 numberOfArguments@var1809 !=@expr1073748305 n@var1812 ) ) {
1366: return false ; }
1367:
1368: if (@expr1073748306 patternAfter@var1811 ) {
1369: const Token * tok@var1813 ; tok@var1813 =@expr1073748307 instance@var1808 .@expr6472 next (@expr6473 ) .@expr1073748310 findClosingBracket (@expr1073748311 ) ;
1370: if (@expr1073748312 !@expr1073748313 tok@var1813 ||@expr1073748314 !@expr1073748315 Token ::@expr1073748316 Match (@expr1073748317 tok@var1813 .@expr1073748318 next (@expr1073748319 ) , patternAfter@var1811 ) ) {
1371: return false ; }
1372: }
1373:
1374:
1375: return true ;
1376: }
1377:
1378:
1379: bool TemplateSimplifier :: getTemplateNamePositionTemplateFunction ( const Token * tok@var1814 , int & namepos@var1815 )
1380: {
1381: namepos@var1815 =@expr1073748320 1 ;
1382: while (@expr1073748321 tok@var1814 &&@expr1073748322 tok@var1814 .@expr6499 next (@expr6500 ) ) {
1383: if (@expr1073748325 Token ::@expr6502 Match (@expr1073748327 tok@var1814 .@expr6499 next (@expr6500 ) , ";|{" ) ) {
1384: return false ; }
1385:
1386: else { if (@expr1073748330 Token ::@expr1073748331 simpleMatch (@expr1073748332 tok@var1814 .@expr6499 next (@expr6500 ) , "decltype (" ) ) {
1387: const Token * end@var1816 ; end@var1816 =@expr1073748335 tok@var1814 .@expr1073748336 linkAt (@expr1073748337 2 ) .@expr1073748338 previous (@expr1073748339 ) ;
1388: while (@expr1073748340 tok@var1814 .@expr6499 next (@expr6500 ) &&@expr1073748343 tok@var1814 !=@expr1073748344 end@var1816 ) {
1389: tok@var1814 =@expr1073748345 tok@var1814 .@expr6499 next (@expr6500 ) ;
1390: namepos@var1815 ++@expr1073748348 ;
1391: }
1392: } else { if (@expr1073748349 Token ::@expr6502 Match (@expr1073748351 tok@var1814 .@expr6499 next (@expr6500 ) , "%type% <" ) ) {
1393: const Token * closing@var1817 ; closing@var1817 =@expr1073748354 tok@var1814 .@expr6531 tokAt (@expr6532 2 ) .@expr1073748357 findClosingBracket (@expr1073748358 ) ;
1394: if (@expr1073748359 closing@var1817 ) {
1395: if (@expr1073748360 closing@var1817 .@expr1073748361 strAt (@expr1073748362 1 ) ==@expr1073748363 "(" &&@expr1073748364 Tokenizer ::@expr6541 isFunctionHead (@expr1073748366 closing@var1817 .@expr1073748367 next (@expr1073748368 ) , ";|{|:" , true ) ) {
1396: return true ; }
1397: while (@expr1073748369 tok@var1814 .@expr6499 next (@expr6500 ) &&@expr1073748372 tok@var1814 .@expr6499 next (@expr6500 ) !=@expr1073748375 closing@var1817 ) {
1398: tok@var1814 =@expr1073748376 tok@var1814 .@expr6499 next (@expr6500 ) ;
1399: namepos@var1815 ++@expr1073748379 ;
1400: }
1401: }
1402: } else { if (@expr1073748380 Token ::@expr6502 Match (@expr1073748382 tok@var1814 .@expr6499 next (@expr6500 ) , "%type% (" ) &&@expr1073748385 Tokenizer ::@expr6541 isFunctionHead (@expr1073748387 tok@var1814 .@expr6531 tokAt (@expr6532 2 ) , ";|{|:" , true ) ) {
1403: return true ;
1404: } } } }
1405: tok@var1814 =@expr1073748390 tok@var1814 .@expr6499 next (@expr6500 ) ;
1406: namepos@var1815 ++@expr1073748393 ;
1407: }
1408: return false ;
1409: }
1410:
1411: bool TemplateSimplifier :: getTemplateNamePositionTemplateVariable ( const Token * tok@var1818 , int & namepos@var1819 )
1412: {
1413: namepos@var1819 =@expr1073748394 1 ;
1414: while (@expr1073748395 tok@var1818 &&@expr1073748396 tok@var1818 .@expr6573 next (@expr6574 ) ) {
1415: if (@expr1073748399 Token ::@expr6576 Match (@expr1073748401 tok@var1818 .@expr6573 next (@expr6574 ) , ";|{|(|using" ) ) {
1416: return false ; }
1417:
1418: else { if (@expr1073748404 Token ::@expr1073748405 simpleMatch (@expr1073748406 tok@var1818 .@expr6573 next (@expr6574 ) , "decltype (" ) ) {
1419: const Token * end@var1820 ; end@var1820 =@expr1073748409 tok@var1818 .@expr1073748410 linkAt (@expr1073748411 2 ) ;
1420: while (@expr1073748412 tok@var1818 .@expr6573 next (@expr6574 ) &&@expr1073748415 tok@var1818 !=@expr1073748416 end@var1820 ) {
1421: tok@var1818 =@expr1073748417 tok@var1818 .@expr6573 next (@expr6574 ) ;
1422: namepos@var1819 ++@expr1073748420 ;
1423: }
1424: } else { if (@expr1073748421 Token ::@expr6576 Match (@expr1073748423 tok@var1818 .@expr6573 next (@expr6574 ) , "%type% <" ) ) {
1425: const Token * closing@var1821 ; closing@var1821 =@expr1073748426 tok@var1818 .@expr1073748427 tokAt (@expr1073748428 2 ) .@expr1073748429 findClosingBracket (@expr1073748430 ) ;
1426: if (@expr1073748431 closing@var1821 ) {
1427: if (@expr1073748432 Token ::@expr6576 Match (@expr1073748434 closing@var1821 .@expr1073748435 next (@expr1073748436 ) , "=|;" ) ) {
1428: return true ; }
1429: while (@expr1073748437 tok@var1818 .@expr6573 next (@expr6574 ) &&@expr1073748440 tok@var1818 .@expr6573 next (@expr6574 ) !=@expr1073748443 closing@var1821 ) {
1430: tok@var1818 =@expr1073748444 tok@var1818 .@expr6573 next (@expr6574 ) ;
1431: namepos@var1819 ++@expr1073748447 ;
1432: }
1433: }
1434: } else { if (@expr1073748448 Token ::@expr6576 Match (@expr1073748450 tok@var1818 .@expr6573 next (@expr6574 ) , "%type% =|;" ) ) {
1435: return true ;
1436: } } } }
1437: tok@var1818 =@expr1073748453 tok@var1818 .@expr6573 next (@expr6574 ) ;
1438: namepos@var1819 ++@expr1073748456 ;
1439: }
1440: return false ;
1441: }
1442:
1443: bool TemplateSimplifier :: getTemplateNamePositionTemplateClass ( const Token * tok@var1822 , int & namepos@var1823 )
1444: {
1445: if (@expr1073748457 Token ::@expr6634 Match (@expr1073748459 tok@var1822 , "> friend| class|struct|union %type% :|<|;|{|::" ) ) {
1446: namepos@var1823 =@expr1073748460 tok@var1822 .@expr6637 strAt (@expr6638 1 ) ==@expr1073748463 "friend" ?@expr1073748464 3 :@expr1073748465 2 ;
1447: tok@var1822 =@expr1073748466 tok@var1822 .@expr6643 tokAt (@expr1073748468 namepos@var1823 ) ;
1448: while (@expr1073748469 Token ::@expr6634 Match (@expr1073748471 tok@var1822 , "%type% :: %type%" ) ||@expr1073748472
1449: (@expr1073748473 Token ::@expr6634 Match (@expr1073748475 tok@var1822 , "%type% <" ) &&@expr1073748476 Token ::@expr6634 Match (@expr1073748478 tok@var1822 .@expr6655 next (@expr6656 ) .@expr6657 findClosingBracket (@expr6658 ) , "> :: %type%" ) ) ) {
1450: if (@expr1073748483 tok@var1822 .@expr6637 strAt (@expr6638 1 ) ==@expr1073748486 "::" ) {
1451: tok@var1822 =@expr1073748487 tok@var1822 .@expr6643 tokAt (@expr1073748489 2 ) ;
1452: namepos@var1823 +=@expr1073748490 2 ;
1453: } else {
1454: const Token * end@var1824 ; end@var1824 =@expr1073748491 tok@var1822 .@expr6655 next (@expr6656 ) .@expr6657 findClosingBracket (@expr6658 ) ;
1455: if (@expr1073748496 !@expr1073748497 end@var1824 ||@expr1073748498 !@expr1073748499 end@var1824 .@expr6676 tokAt (@expr6677 2 ) ) {
1456:
1457: namepos@var1823 =@expr1073748502 -1 ;
1458: return true ;
1459: }
1460: end@var1824 =@expr1073748503 end@var1824 .@expr6676 tokAt (@expr6677 2 ) ;
1461: do {
1462: tok@var1822 =@expr1073748506 tok@var1822 .@expr6655 next (@expr6656 ) ;
1463: namepos@var1823 +=@expr1073748509 1 ;
1464: } while (@expr1073748510 tok@var1822 &&@expr1073748511 tok@var1822 !=@expr1073748512 end@var1824 ) ;
1465: }
1466: }
1467: return true ;
1468: }
1469: return false ;
1470: }
1471:
1472: int TemplateSimplifier :: getTemplateNamePosition ( const Token * tok@var1825 )
1473: {
1474: assert (@expr1073748513 tok@var1825 &&@expr1073748514 tok@var1825 .@expr1073748515 str (@expr1073748516 ) ==@expr1073748517 ">" ) ;
1475:
1476: auto it@var1826 ; it@var1826 =@expr1073748518 mTemplateNamePos@var114 .@expr1073748519 find (@expr1073748520 tok@var1825 ) ;
1477: if (@expr1073748521 !@expr1073748522 mSettings@var101 .@expr1073748523 debugtemplate@var2199 &&@expr1073748524 it@var1826 !=@expr1073748525 mTemplateNamePos@var114 .@expr1073748526 end (@expr1073748527 ) ) {
1478: return it@var1826 .@expr1073748528 second@var1827 ;
1479: }
1480:
1481: int namepos@var1828 ; namepos@var1828 =@expr1073748529 0 ;
1482: if (@expr1073748530 getTemplateNamePositionTemplateClass (@expr1073748531 tok@var1825 , namepos@var1828 ) ) {
1483: ; }
1484: else { if (@expr1073748532 Token ::@expr6709 Match (@expr1073748534 tok@var1825 , "> using %name% =" ) ) {
1485:
1486: if (@expr1073748535 !@expr1073748536 Token ::@expr6709 Match (@expr1073748538 tok@var1825 .@expr1073748539 tokAt (@expr1073748540 4 ) , "class|struct|union|enum %name%| {" ) ) {
1487: namepos@var1828 =@expr1073748541 2 ; }
1488: } else { if (@expr1073748542 getTemplateNamePositionTemplateVariable (@expr1073748543 tok@var1825 , namepos@var1828 ) ) {
1489: ; }
1490: else { if (@expr1073748544 !@expr1073748545 getTemplateNamePositionTemplateFunction (@expr1073748546 tok@var1825 , namepos@var1828 ) ) {
1491: namepos@var1828 =@expr1073748547 -1 ; } } } }
1492: mTemplateNamePos@var114 [@expr1073748548 tok@var1825 ] =@expr1073748549 namepos@var1828 ;
1493: return namepos@var1828 ;
1494: }
1495:
1496: void TemplateSimplifier :: addNamespace ( const TokenAndName & templateDeclaration@var1829 , const Token * tok@var1830 )
1497: {
1498:
1499: const Token * tokStart@var1831 ; tokStart@var1831 =@expr1073748551 tok@var1830 ;
1500: int offset@var1832 ; offset@var1832 =@expr1073748552 0 ;
1501: while (@expr1073748553 Token ::@expr1073748554 Match (@expr1073748555 tokStart@var1831 .@expr6732 tokAt (@expr6733 -2 ) , "%name% ::" ) ) {
1502: tokStart@var1831 =@expr1073748558 tokStart@var1831 .@expr6732 tokAt (@expr6733 -2 ) ;
1503: offset@var1832 -=@expr1073748561 2 ;
1504: }
1505:
1506: const bool insert@var1833 =@expr1073748562 tokStart@var1831 !=@expr1073748563 tok@var1830 ;
1507:
1508: std ::@expr6740 string ::@expr1073748565 size_type start@var1834 ; start@var1834 =@expr1073748566 0 ;
1509: std ::@expr6740 string ::@expr1073748568 size_type end@var1835 ; end@var1835 =@expr1073748569 0 ;
1510: bool inTemplate@var1836 ; inTemplate@var1836 =@expr1073748570 false ;
1511: int level@var1837 ; level@var1837 =@expr1073748571 0 ;
1512: while (@expr1073748572 (@expr1073748573 end@var1835 =@expr1073748574 templateDeclaration@var1829 .@expr6751 scope (@expr6752 ) .@expr1073748577 find (@expr1073748578 " " , start@var1834 ) ) !=@expr1073748579 std ::@expr6740 string ::@expr1073748581 npos@expr1073748550 ) {
1513: std ::@expr1073748582 string token@var1838 ; token@var1838 =@expr1073748583 templateDeclaration@var1829 .@expr6751 scope (@expr6752 ) .@expr6762 substr (@expr6763 start@var1834 , end@var1835 -@expr6764 start@var1834 ) ;
1514:
1515: if (@expr1073748589 token@var1838 ==@expr1073748590 tokStart@var1831 .@expr6767 str (@expr6768 ) &&@expr1073748593 tok@var1830 .@expr6770 strAt (@expr6771 -1 ) !=@expr6772 "::" ) {
1516: break ; }
1517: if (@expr1073748597 token@var1838 ==@expr1073748598 "<" ) {
1518: inTemplate@var1836 =@expr1073748599 true ;
1519: ++@expr1073748600 level@var1837 ;
1520: }
1521: if (@expr1073748601 inTemplate@var1836 ) {
1522: if (@expr6778 insert@var1833 ) {
1523: mTokenList@var100 .@expr6779 back (@expr6780 ) .@expr6781 tokAt (@expr6782 offset@var1832 ) .@expr6783 str (@expr1073748608 mTokenList@var100 .@expr6779 back (@expr6780 ) .@expr6787 strAt (@expr6788 offset@var1832 ) +@expr1073748613 token@var1838 ) ; }
1524: else {
1525: mTokenList@var100 .@expr6779 back (@expr6780 ) .@expr6792 str (@expr1073748617 mTokenList@var100 .@expr6779 back (@expr6780 ) .@expr6792 str (@expr6797 ) +@expr1073748622 token@var1838 ) ; }
1526: if (@expr1073748623 token@var1838 ==@expr1073748624 ">" ) {
1527: --@expr1073748625 level@var1837 ;
1528: if (@expr1073748626 level@var1837 ==@expr1073748627 0 ) {
1529: inTemplate@var1836 =@expr1073748628 false ; }
1530: }
1531: } else {
1532: if (@expr6778 insert@var1833 ) {
1533: mTokenList@var100 .@expr6779 back (@expr6780 ) .@expr6781 tokAt (@expr6782 offset@var1832 ) .@expr6810 insertToken (@expr1073748635 token@var1838 , "" ) ; }
1534: else {
1535: mTokenList@var100 .@expr6812 addtoken (@expr1073748637 token@var1838 , tok@var1830 .@expr6814 linenr (@expr6815 ) , tok@var1830 .@expr6816 column (@expr6817 ) , tok@var1830 .@expr6818 fileIndex (@expr6819 ) ) ; }
1536: }
1537: start@var1834 =@expr1073748644 end@var1835 +@expr1073748645 1 ;
1538: }
1539:
1540: std ::@expr1073748646 string token@var1839 ; token@var1839 =@expr1073748647 templateDeclaration@var1829 .@expr6751 scope (@expr6752 ) .@expr6762 substr (@expr6763 start@var1834 , end@var1835 -@expr6764 start@var1834 ) ;
1541: if (@expr1073748653 token@var1839 !=@expr1073748654 tokStart@var1831 .@expr6767 str (@expr6768 ) ||@expr1073748657 tok@var1830 .@expr6770 strAt (@expr6771 -1 ) !=@expr6772 "::" ) {
1542: if (@expr6778 insert@var1833 ) {
1543: if (@expr6838 !@expr6839 inTemplate@var1836 ) {
1544: mTokenList@var100 .@expr6779 back (@expr6780 ) .@expr6781 tokAt (@expr6782 offset@var1832 ) .@expr6810 insertToken (@expr1073748669 templateDeclaration@var1829 .@expr6751 scope (@expr6752 ) .@expr6762 substr (@expr6849 start@var1834 ) , "" ) ; }
1545: else {
1546: mTokenList@var100 .@expr6779 back (@expr6780 ) .@expr6781 tokAt (@expr6782 offset@var1832 ) .@expr6783 str (@expr1073748679 mTokenList@var100 .@expr6779 back (@expr6780 ) .@expr6787 strAt (@expr6788 offset@var1832 ) +@expr1073748684 templateDeclaration@var1829 .@expr6751 scope (@expr6752 ) .@expr6762 substr (@expr6849 start@var1834 ) ) ; }
1547: mTokenList@var100 .@expr6779 back (@expr6780 ) .@expr6781 tokAt (@expr6782 offset@var1832 ) .@expr6810 insertToken (@expr1073748694 "::" , "" ) ;
1548: } else {
1549: if (@expr6838 !@expr6839 inTemplate@var1836 ) {
1550: mTokenList@var100 .@expr6812 addtoken (@expr1073748698 templateDeclaration@var1829 .@expr6751 scope (@expr6752 ) .@expr6762 substr (@expr6849 start@var1834 ) , tok@var1830 .@expr6814 linenr (@expr6815 ) , tok@var1830 .@expr6816 column (@expr6817 ) , tok@var1830 .@expr6818 fileIndex (@expr6819 ) ) ; }
1551: else {
1552: mTokenList@var100 .@expr6779 back (@expr6780 ) .@expr6792 str (@expr1073748712 mTokenList@var100 .@expr6779 back (@expr6780 ) .@expr6792 str (@expr6797 ) +@expr1073748717 templateDeclaration@var1829 .@expr6751 scope (@expr6752 ) .@expr6762 substr (@expr6849 start@var1834 ) ) ; }
1553: mTokenList@var100 .@expr6812 addtoken (@expr1073748723 "::" , tok@var1830 .@expr6814 linenr (@expr6815 ) , tok@var1830 .@expr6816 column (@expr6817 ) , tok@var1830 .@expr6818 fileIndex (@expr6819 ) ) ;
1554: }
1555: }
1556: }
1557:
1558: bool TemplateSimplifier :: alreadyHasNamespace ( const TokenAndName & templateDeclaration@var1840 , const Token * tok@var1841 )
1559: {
1560: const std ::@expr1073748731 string &@expr1073748732 scope@var1842 =@expr1073748733 templateDeclaration@var1840 .@expr1073748734 scope (@expr1073748735 ) ;
1561:
1562:
1563: std ::@expr6912 string ::@expr1073748737 size_type pos@var1843 ; pos@var1843 =@expr1073748738 0 ;
1564: int offset@var1844 ; offset@var1844 =@expr1073748739 -2 ;
1565:
1566: while (@expr1073748740 (@expr1073748741 pos@var1843 =@expr1073748742 scope@var1842 .@expr1073748743 find (@expr1073748744 "::" , pos@var1843 ) ) !=@expr1073748745 std ::@expr6912 string ::@expr1073748747 npos@expr1073748730 ) {
1567: offset@var1844 -=@expr1073748748 2 ;
1568: pos@var1843 +=@expr1073748749 2 ;
1569: }
1570:
1571: return Token ::@expr1073748750 simpleMatch (@expr1073748751 tok@var1841 .@expr1073748752 tokAt (@expr1073748753 offset@var1844 ) , scope@var1842 .@expr1073748754 c_str (@expr1073748755 ) , scope@var1842 .@expr1073748756 size (@expr1073748757 ) ) ;
1572: }
1573:
1574: void TemplateSimplifier :: expandTemplate (
1575: const TokenAndName & templateDeclaration@var1845 ,
1576: const TokenAndName & templateInstantiation@var1846 ,
1577: const std :: vector < const Token * > & typeParametersInDeclaration@var1847 ,
1578: const std :: string & newName@var1848 ,
1579: bool copy@var1849 )
1580: {
1581: bool inTemplateDefinition@var1850 ; inTemplateDefinition@var1850 =@expr1073748759 false ;
1582: const Token * startOfTemplateDeclaration@var1851 ; startOfTemplateDeclaration@var1851 =@expr1073748760 nullptr ;
1583: const Token * endOfTemplateDefinition@var1852 ; endOfTemplateDefinition@var1852 =@expr1073748761 nullptr ;
1584: const Token * const templateDeclarationNameToken@var1853 ; templateDeclarationNameToken@var1853 =@expr1073748762 templateDeclaration@var1845 .@expr1073748763 nameToken (@expr1073748764 ) ;
1585: const Token * const templateDeclarationToken@var1854 ; templateDeclarationToken@var1854 =@expr1073748765 templateDeclaration@var1845 .@expr1073748766 paramEnd (@expr1073748767 ) ;
1586: const bool isClass@var1855 =@expr1073748768 templateDeclaration@var1845 .@expr1073748769 isClass (@expr1073748770 ) ;
1587: const bool isFunction@var1856 =@expr1073748771 templateDeclaration@var1845 .@expr6948 isFunction (@expr6949 ) ;
1588: const bool isSpecialization@var1857 =@expr1073748774 templateDeclaration@var1845 .@expr1073748775 isSpecialization (@expr1073748776 ) ;
1589: const bool isVariable@var1858 =@expr1073748777 templateDeclaration@var1845 .@expr1073748778 isVariable (@expr1073748779 ) ;
1590: struct newInstantiation {
1591: newInstantiation (@expr1073748780 Token * t@var1859 , const std ::@expr6957 string & s@var1860 ) :@expr1073748782 token@var1861 (@expr1073748783 t@var1859 ) , scope@var1862 (@expr1073748784 s@var1860 ) { }
1592: Token * token@var1861 ;
1593: std ::@expr1073748785 string scope@var1862 ;
1594: } ;
1595: std ::@expr1073748786 vector < newInstantiation > newInstantiations@var1863 ;
1596:
1597:
1598: if (@expr1073748787 copy@var1849 &&@expr1073748788 isClass@var1855 ) {
1599: templateDeclaration@var1845 .@expr6965 token (@expr6966 ) .@expr6967 insertToken (@expr1073748792 templateDeclarationToken@var1854 .@expr1073748793 strAt (@expr1073748794 1 ) , "" , true ) ;
1600: templateDeclaration@var1845 .@expr6965 token (@expr6966 ) .@expr6967 insertToken (@expr1073748798 newName@var1848 , "" , true ) ;
1601: templateDeclaration@var1845 .@expr6965 token (@expr6966 ) .@expr6967 insertToken (@expr1073748802 ";" , "" , true ) ;
1602: } else { if (@expr1073748803 (@expr1073748804 isFunction@var1856 &&@expr1073748805 (@expr1073748806 copy@var1849 ||@expr1073748807 isSpecialization@var1857 ) ) ||@expr1073748808
1603: (@expr1073748809 isVariable@var1858 &&@expr1073748810 !@expr6987 isSpecialization@var1857 ) ||@expr1073748812
1604: (@expr1073748813 isClass@var1855 &&@expr1073748814 isSpecialization@var1857 &&@expr1073748815 mTemplateSpecializationMap@var107 .@expr6992 find (@expr1073748817 templateDeclaration@var1845 .@expr6965 token (@expr6966 ) ) !=@expr1073748820 mTemplateSpecializationMap@var107 .@expr6997 end (@expr6998 ) ) ) {
1605: Token * dst@var1864 ; dst@var1864 =@expr1073748823 templateDeclaration@var1845 .@expr6965 token (@expr6966 ) ;
1606: Token * dstStart@var1865 ; dstStart@var1865 =@expr1073748826 dst@var1864 .@expr7003 previous (@expr7004 ) ;
1607: bool isStatic@var1866 ; isStatic@var1866 =@expr1073748829 false ;
1608: std ::@expr1073748830 string scope@var1867 ;
1609: Token * start@var1868 ;
1610: Token * end@var1869 ;
1611: auto it@var1870 ; it@var1870 =@expr1073748831 mTemplateForwardDeclarationsMap@var106 .@expr1073748832 find (@expr1073748833 dst@var1864 ) ;
1612: if (@expr1073748834 !@expr6987 isSpecialization@var1857 &&@expr1073748836 it@var1870 !=@expr7013 mTemplateForwardDeclarationsMap@var106 .@expr7014 end (@expr7015 ) ) {
1613: dst@var1864 =@expr1073748840 it@var1870 .@expr7017 second@var1871 ;
1614: dstStart@var1865 =@expr1073748842 dst@var1864 .@expr7003 previous (@expr7004 ) ;
1615: const Token * temp1@var1872 ; temp1@var1872 =@expr1073748845 dst@var1864 .@expr7022 tokAt (@expr1073748847 1 ) .@expr1073748848 findClosingBracket (@expr1073748849 ) ;
1616: const Token * temp2@var1873 ; temp2@var1873 =@expr1073748850 temp1@var1872 .@expr1073748851 tokAt (@expr1073748852 getTemplateNamePosition (@expr1073748853 temp1@var1872 ) ) ;
1617: start@var1868 =@expr1073748854 temp1@var1872 .@expr1073748855 next (@expr1073748856 ) ;
1618: end@var1869 =@expr1073748857 temp2@var1873 .@expr1073748858 linkAt (@expr1073748859 1 ) .@expr1073748860 next (@expr1073748861 ) ;
1619: } else {
1620: if (@expr1073748862 it@var1870 !=@expr7013 mTemplateForwardDeclarationsMap@var106 .@expr7014 end (@expr7015 ) ) {
1621: std ::@expr7042 list < TokenAndName > ::@expr1073748867 iterator it1@var1874 ; it1@var1874 =@expr1073748868 std ::@expr7045 find_if (@expr1073748870 mTemplateForwardDeclarations@var105 .@expr1073748871 begin (@expr1073748872 ) ,
1622: mTemplateForwardDeclarations@var105 .@expr7049 end (@expr7050 ) ,
1623: FindToken (@expr1073748875 it@var1870 .@expr7017 second@var1871 ) ) ;
1624: if (@expr1073748877 it1@var1874 !=@expr1073748878 mTemplateForwardDeclarations@var105 .@expr7049 end (@expr7050 ) ) {
1625: mMemberFunctionsToDelete@var111 .@expr7057 push_back (@expr1073748882 *@expr1073748883 it1@var1874 ) ; }
1626: }
1627:
1628: auto it2@var1875 ; it2@var1875 =@expr1073748884 mTemplateSpecializationMap@var107 .@expr6992 find (@expr1073748886 dst@var1864 ) ;
1629: if (@expr1073748887 it2@var1875 !=@expr1073748888 mTemplateSpecializationMap@var107 .@expr6997 end (@expr6998 ) ) {
1630: dst@var1864 =@expr1073748891 it2@var1875 .@expr1073748892 second@var1876 ;
1631: dstStart@var1865 =@expr1073748893 dst@var1864 .@expr7003 previous (@expr7004 ) ;
1632: isStatic@var1866 =@expr1073748896 dst@var1864 .@expr1073748897 next (@expr1073748898 ) .@expr1073748899 findClosingBracket (@expr1073748900 ) .@expr1073748901 strAt (@expr1073748902 1 ) ==@expr1073748903 "static" ;
1633: const Token * temp@var1877 ; temp@var1877 =@expr1073748904 templateDeclarationNameToken@var1853 ;
1634: while (@expr1073748905 Token ::@expr7082 Match (@expr1073748907 temp@var1877 .@expr7084 tokAt (@expr7085 -2 ) , "%name% ::" ) ) {
1635: scope@var1867 .@expr1073748910 insert (@expr1073748911 0 , temp@var1877 .@expr1073748912 strAt (@expr1073748913 -2 ) +@expr1073748914 " :: " ) ;
1636: temp@var1877 =@expr1073748915 temp@var1877 .@expr7084 tokAt (@expr7085 -2 ) ;
1637: }
1638: }
1639: start@var1868 =@expr1073748918 templateDeclarationToken@var1854 .@expr1073748919 next (@expr1073748920 ) ;
1640: end@var1869 =@expr1073748921 templateDeclarationNameToken@var1853 .@expr1073748922 next (@expr1073748923 ) ;
1641: if (@expr1073748924 end@var1869 .@expr7101 str (@expr7102 ) ==@expr1073748927 "<" ) {
1642: end@var1869 =@expr1073748928 end@var1869 .@expr1073748929 findClosingBracket (@expr1073748930 ) .@expr1073748931 next (@expr1073748932 ) ; }
1643: if (@expr1073748933 end@var1869 .@expr7101 str (@expr7102 ) ==@expr1073748936 "(" ) {
1644: end@var1869 =@expr1073748937 end@var1869 .@expr1073748938 link (@expr1073748939 ) .@expr1073748940 next (@expr1073748941 ) ; }
1645: else { if (@expr1073748942 isVariable@var1858 &&@expr1073748943 end@var1869 .@expr7101 str (@expr7102 ) ==@expr1073748946 "=" ) {
1646: Token * temp@var1878 ; temp@var1878 =@expr1073748947 end@var1869 .@expr7124 next (@expr7125 ) ;
1647: while (@expr1073748950 temp@var1878 &&@expr1073748951 temp@var1878 .@expr1073748952 str (@expr1073748953 ) !=@expr1073748954 ";" ) {
1648: if (@expr1073748955 temp@var1878 .@expr7132 link (@expr7133 ) &&@expr1073748958 Token ::@expr7082 Match (@expr1073748960 temp@var1878 , "{|[|(" ) ) {
1649: temp@var1878 =@expr1073748961 temp@var1878 .@expr7132 link (@expr7133 ) ; }
1650: temp@var1878 =@expr1073748964 temp@var1878 .@expr1073748965 next (@expr1073748966 ) ;
1651: }
1652: end@var1869 =@expr1073748967 temp@var1878 ;
1653: } }
1654: }
1655: unsigned int typeindentlevel@var1879 ; typeindentlevel@var1879 =@expr1073748968 0 ;
1656: while (@expr1073748969 end@var1869 &&@expr1073748970 !@expr1073748971 (@expr1073748972 typeindentlevel@var1879 ==@expr7149 0 &&@expr1073748974 Token ::@expr7082 Match (@expr1073748976 end@var1869 , ";|{|:" ) ) ) {
1657: if (@expr1073748977 Token ::@expr7082 Match (@expr1073748979 end@var1869 , "<|(|{" ) ) {
1658: ++@expr1073748980 typeindentlevel@var1879 ; }
1659: else { if (@expr1073748981 Token ::@expr7082 Match (@expr1073748983 end@var1869 , ">|)|}" ) ) {
1660: --@expr1073748984 typeindentlevel@var1879 ; } }
1661: end@var1869 =@expr1073748985 end@var1869 .@expr7124 next (@expr7125 ) ;
1662: }
1663:
1664: if (@expr1073748988 isStatic@var1866 ) {
1665: dst@var1864 .@expr7165 insertToken (@expr1073748990 "static" , "" , true ) ;
1666: if (@expr1073748991 start@var1868 ) {
1667: dst@var1864 .@expr7003 previous (@expr7004 ) .@expr7170 linenr (@expr7171 start@var1868 .@expr7172 linenr (@expr7173 ) ) ;
1668: dst@var1864 .@expr7003 previous (@expr7004 ) .@expr7176 column (@expr7177 start@var1868 .@expr7178 column (@expr7179 ) ) ;
1669: }
1670: }
1671:
1672: std ::@expr1073749004 map < const Token *@expr7181 , Token *@expr7181 > links@var1880 ;
1673: bool inAssignment@var1881 ; inAssignment@var1881 =@expr1073749007 false ;
1674: while (@expr1073749008 start@var1868 &&@expr1073749009 start@var1868 !=@expr1073749010 end@var1869 ) {
1675: if (@expr1073749011 isVariable@var1858 &&@expr1073749012 start@var1868 .@expr7189 str (@expr7190 ) ==@expr1073749015 "=" ) {
1676: inAssignment@var1881 =@expr1073749016 true ; }
1677: unsigned int itype@var1882 ; itype@var1882 =@expr1073749017 0 ;
1678: while (@expr1073749018 itype@var1882 <@expr7195 typeParametersInDeclaration@var1847 .@expr7196 size (@expr7197 ) &&@expr1073749022 typeParametersInDeclaration@var1847 [@expr7199 itype@var1882 ] .@expr1073749024 str (@expr1073749025 ) !=@expr1073749026 start@var1868 .@expr7189 str (@expr7190 ) ) {
1679: ++@expr1073749029 itype@var1882 ; }
1680:
1681: if (@expr1073749030 itype@var1882 <@expr7195 typeParametersInDeclaration@var1847 .@expr7196 size (@expr7197 ) &&@expr1073749034 itype@var1882 <@expr1073749035 mTypesUsedInTemplateInstantiation@var113 .@expr7212 size (@expr7213 ) &&@expr1073749038
1682: (@expr1073749039 !@expr1073749040 isVariable@var1858 ||@expr1073749041 !@expr1073749042 Token ::@expr7082 Match (@expr1073749044 typeParametersInDeclaration@var1847 [@expr7199 itype@var1882 ] .@expr1073749046 previous (@expr1073749047 ) , "<|, %type% >|," ) ) ) {
1683: typeindentlevel@var1879 =@expr1073749048 0 ;
1684: std ::@expr1073749049 stack < Token *@expr7181 > brackets1@var1883 ;
1685: bool pointerType@var1884 ; pointerType@var1884 =@expr1073749051 false ;
1686: Token * const dst1@var1885 ; dst1@var1885 =@expr1073749052 dst@var1864 .@expr7003 previous (@expr7004 ) ;
1687: const bool isVariadicTemplateArg@var1886 =@expr1073749055 templateDeclaration@var1845 .@expr7232 isVariadic (@expr7233 ) &&@expr1073749058 itype@var1882 +@expr1073749059 1 ==@expr1073749060 typeParametersInDeclaration@var1847 .@expr7196 size (@expr7197 ) ;
1688: if (@expr1073749063 isVariadicTemplateArg@var1886 &&@expr1073749064 Token ::@expr7082 Match (@expr1073749066 start@var1868 , "%name% ... %name%" ) ) {
1689: start@var1868 =@expr1073749067 start@var1868 .@expr7244 tokAt (@expr1073749069 2 ) ; }
1690: const std ::@expr1073749070 string endStr@var1887 (@expr1073749071 isVariadicTemplateArg@var1886 ?@expr1073749072 ">" :@expr7249 ",>" ) ;
1691: for (@expr1073749074 const Token *@expr7181 typetok@var1888 =@expr1073749076 mTypesUsedInTemplateInstantiation@var113 [@expr1073749077 itype@var1882 ] .@expr1073749078 token (@expr1073749079 ) ;
1692: typetok@var1888 &&@expr1073749080 (@expr1073749081 typeindentlevel@var1879 >@expr7258 0 ||@expr1073749083 endStr@var1887 .@expr1073749084 find (@expr1073749085 typetok@var1888 .@expr7262 str (@expr7263 ) [@expr1073749088 0 ] ) ==@expr1073749089 std ::@expr6957 string ::@expr7267 npos@expr6934 ) ;
1693: typetok@var1888 =@expr1073749092 typetok@var1888 .@expr7269 next (@expr7270 ) ) {
1694: if (@expr1073749095 typeindentlevel@var1879 ==@expr7149 0 &&@expr1073749097 typetok@var1888 .@expr7262 str (@expr7263 ) ==@expr1073749100 "*" ) {
1695: pointerType@var1884 =@expr1073749101 true ; }
1696: if (@expr1073749102 Token ::@expr7279 simpleMatch (@expr1073749104 typetok@var1888 , "..." ) ) {
1697: continue ; }
1698: if (@expr1073749105 Token ::@expr7082 Match (@expr1073749107 typetok@var1888 , "%name% <" ) &&@expr1073749108 (@expr1073749109 typetok@var1888 .@expr1073749110 strAt (@expr1073749111 2 ) ==@expr1073749112 ">" ||@expr1073749113 templateParameters (@expr1073749114 typetok@var1888 .@expr7269 next (@expr7270 ) ) ) ) {
1699: ++@expr1073749117 typeindentlevel@var1879 ; }
1700: else { if (@expr1073749118 typeindentlevel@var1879 >@expr7258 0 &&@expr1073749120 typetok@var1888 .@expr7262 str (@expr7263 ) ==@expr1073749123 ">" ) {
1701: --@expr1073749124 typeindentlevel@var1879 ; }
1702: else { if (@expr1073749125 typetok@var1888 .@expr7262 str (@expr7263 ) ==@expr1073749128 "(" ) {
1703: ++@expr1073749129 typeindentlevel@var1879 ; }
1704: else { if (@expr1073749130 typetok@var1888 .@expr7262 str (@expr7263 ) ==@expr1073749133 ")" ) {
1705: --@expr1073749134 typeindentlevel@var1879 ; } } } }
1706: dst@var1864 .@expr7165 insertToken (@expr1073749136 typetok@var1888 .@expr7262 str (@expr7263 ) , typetok@var1888 .@expr1073749139 originalName (@expr1073749140 ) , true ) ;
1707: dst@var1864 .@expr7003 previous (@expr7004 ) .@expr7170 linenr (@expr7171 start@var1868 .@expr7172 linenr (@expr7173 ) ) ;
1708: dst@var1864 .@expr7003 previous (@expr7004 ) .@expr7176 column (@expr7177 start@var1868 .@expr7178 column (@expr7179 ) ) ;
1709: Token * previous@var1889 ; previous@var1889 =@expr1073749153 dst@var1864 .@expr7003 previous (@expr7004 ) ;
1710: previous@var1889 .@expr1073749156 isTemplateArg (@expr1073749157 true ) ;
1711: previous@var1889 .@expr1073749158 isSigned (@expr1073749159 typetok@var1888 .@expr1073749160 isSigned (@expr1073749161 ) ) ;
1712: previous@var1889 .@expr1073749162 isUnsigned (@expr1073749163 typetok@var1888 .@expr1073749164 isUnsigned (@expr1073749165 ) ) ;
1713: previous@var1889 .@expr1073749166 isLong (@expr1073749167 typetok@var1888 .@expr1073749168 isLong (@expr1073749169 ) ) ;
1714: if (@expr1073749170 Token ::@expr7082 Match (@expr1073749172 previous@var1889 , "{|(|[" ) ) {
1715: brackets1@var1883 .@expr1073749173 push (@expr1073749174 previous@var1889 ) ;
1716: } else { if (@expr1073749175 previous@var1889 .@expr7352 str (@expr7353 ) ==@expr1073749178 "}" ) {
1717: assert (@expr7355 brackets1@var1883 .@expr7356 empty (@expr7357 ) ==@expr7358 false ) ;
1718: assert (@expr1073749183 brackets1@var1883 .@expr7360 top (@expr7361 ) .@expr7362 str (@expr7363 ) ==@expr1073749188 "{" ) ;
1719: Token ::@expr7365 createMutualLinks (@expr7366 brackets1@var1883 .@expr7360 top (@expr7361 ) , previous@var1889 ) ;
1720: brackets1@var1883 .@expr7369 pop (@expr7370 ) ;
1721: } else { if (@expr1073749195 previous@var1889 .@expr7352 str (@expr7353 ) ==@expr1073749198 ")" ) {
1722: assert (@expr7355 brackets1@var1883 .@expr7356 empty (@expr7357 ) ==@expr7358 false ) ;
1723: assert (@expr1073749203 brackets1@var1883 .@expr7360 top (@expr7361 ) .@expr7362 str (@expr7363 ) ==@expr1073749208 "(" ) ;
1724: Token ::@expr7365 createMutualLinks (@expr7366 brackets1@var1883 .@expr7360 top (@expr7361 ) , previous@var1889 ) ;
1725: brackets1@var1883 .@expr7369 pop (@expr7370 ) ;
1726: } else { if (@expr1073749215 previous@var1889 .@expr7352 str (@expr7353 ) ==@expr1073749218 "]" ) {
1727: assert (@expr7355 brackets1@var1883 .@expr7356 empty (@expr7357 ) ==@expr7358 false ) ;
1728: assert (@expr1073749223 brackets1@var1883 .@expr7360 top (@expr7361 ) .@expr7362 str (@expr7363 ) ==@expr1073749228 "[" ) ;
1729: Token ::@expr7365 createMutualLinks (@expr7366 brackets1@var1883 .@expr7360 top (@expr7361 ) , previous@var1889 ) ;
1730: brackets1@var1883 .@expr7369 pop (@expr7370 ) ;
1731: } } } }
1732: }
1733: if (@expr1073749235 pointerType@var1884 &&@expr1073749236 Token ::@expr7279 simpleMatch (@expr1073749238 dst1@var1885 , "const" ) ) {
1734: dst@var1864 .@expr7165 insertToken (@expr1073749240 "const" , dst1@var1885 .@expr1073749241 originalName (@expr1073749242 ) , true ) ;
1735: dst@var1864 .@expr7003 previous (@expr7004 ) .@expr7170 linenr (@expr7171 start@var1868 .@expr7172 linenr (@expr7173 ) ) ;
1736: dst@var1864 .@expr7003 previous (@expr7004 ) .@expr7176 column (@expr7177 start@var1868 .@expr7178 column (@expr7179 ) ) ;
1737: dst1@var1885 .@expr1073749255 deleteThis (@expr1073749256 ) ;
1738: }
1739: } else {
1740: if (@expr1073749257 isSpecialization@var1857 &&@expr1073749258 !@expr1073749259 copy@var1849 &&@expr1073749260 !@expr1073749261 scope@var1867 .@expr1073749262 empty (@expr1073749263 ) &&@expr1073749264 Token ::@expr7082 Match (@expr1073749266 start@var1868 , (@expr1073749267 scope@var1867 +@expr1073749268 templateDeclarationNameToken@var1853 .@expr7445 str (@expr7446 ) ) .@expr1073749271 c_str (@expr1073749272 ) ) ) {
1741:
1742: while (@expr1073749273 start@var1868 .@expr7450 strAt (@expr7451 1 ) !=@expr1073749276 templateDeclarationNameToken@var1853 .@expr7445 str (@expr7446 ) ) {
1743: start@var1868 =@expr1073749279 start@var1868 .@expr7456 next (@expr7457 ) ; }
1744: } else { if (@expr1073749282 start@var1868 .@expr7189 str (@expr7190 ) ==@expr1073749285 templateDeclarationNameToken@var1853 .@expr7445 str (@expr7446 ) &&@expr1073749288
1745: !@expr1073749289 (@expr1073749290 templateDeclaration@var1845 .@expr6948 isFunction (@expr6949 ) &&@expr1073749293 templateDeclaration@var1845 .@expr7470 scope (@expr7471 ) .@expr7472 empty (@expr7473 ) &&@expr1073749298
1746: (@expr1073749299 start@var1868 .@expr7450 strAt (@expr1073749301 -1 ) ==@expr1073749302 "." ||@expr1073749303 Token ::@expr7279 simpleMatch (@expr1073749305 start@var1868 .@expr7244 tokAt (@expr1073749307 -2 ) , ". template" ) ) ) ) {
1747: if (@expr1073749308 start@var1868 .@expr7450 strAt (@expr7451 1 ) !=@expr1073749311 "<" ||@expr1073749312 Token ::@expr7082 Match (@expr1073749314 start@var1868 , newName@var1848 .@expr7491 c_str (@expr7492 ) ) ||@expr1073749317 !@expr1073749318 inAssignment@var1881 ) {
1748: dst@var1864 .@expr7165 insertToken (@expr1073749320 newName@var1848 , "" , true ) ;
1749: dst@var1864 .@expr7003 previous (@expr7004 ) .@expr7170 linenr (@expr7171 start@var1868 .@expr7172 linenr (@expr7173 ) ) ;
1750: dst@var1864 .@expr7003 previous (@expr7004 ) .@expr7176 column (@expr7177 start@var1868 .@expr7178 column (@expr7179 ) ) ;
1751: if (@expr7509 start@var1868 .@expr7450 strAt (@expr7451 1 ) ==@expr7512 "<" ) {
1752: start@var1868 =@expr1073749337 start@var1868 .@expr7456 next (@expr7457 ) .@expr7516 findClosingBracket (@expr7517 ) ; }
1753: } else {
1754: dst@var1864 .@expr7165 insertToken (@expr1073749343 start@var1868 .@expr7189 str (@expr7190 ) , "" , true ) ;
1755: dst@var1864 .@expr7003 previous (@expr7004 ) .@expr7170 linenr (@expr7171 start@var1868 .@expr7172 linenr (@expr7173 ) ) ;
1756: dst@var1864 .@expr7003 previous (@expr7004 ) .@expr7176 column (@expr7177 start@var1868 .@expr7178 column (@expr7179 ) ) ;
1757: newInstantiations@var1863 .@expr7534 emplace_back (@expr1073749359 dst@var1864 .@expr7003 previous (@expr7004 ) , templateDeclaration@var1845 .@expr7470 scope (@expr7471 ) ) ;
1758: }
1759: } else {
1760:
1761: if (@expr7509 start@var1868 .@expr7450 strAt (@expr7451 1 ) ==@expr7512 "<" ) {
1762:
1763: Token * closing@var1890 ; closing@var1890 =@expr1073749368 start@var1868 .@expr7456 next (@expr7457 ) .@expr7516 findClosingBracket (@expr7517 ) ;
1764: if (@expr1073749373 closing@var1890 ) {
1765: std ::@expr1073749374 string name@var1891 ;
1766: const Token * type@var1892 ; type@var1892 =@expr1073749375 start@var1868 ;
1767: while (@expr1073749376 type@var1892 &&@expr1073749377 type@var1892 !=@expr1073749378 closing@var1890 .@expr1073749379 next (@expr1073749380 ) ) {
1768: if (@expr1073749381 !@expr1073749382 name@var1891 .@expr1073749383 empty (@expr1073749384 ) ) {
1769: name@var1891 +=@expr1073749385 " " ; }
1770: name@var1891 +=@expr1073749386 type@var1892 .@expr1073749387 str (@expr1073749388 ) ;
1771: type@var1892 =@expr1073749389 type@var1892 .@expr1073749390 next (@expr1073749391 ) ;
1772: }
1773:
1774: for (@expr1073749392 const auto &@expr7569 inst@var1893 :@expr1073749394 mTemplateInstantiations@var109 ) {
1775: if (@expr1073749395 Token ::@expr7279 simpleMatch (@expr1073749397 inst@var1893 .@expr1073749398 token (@expr1073749399 ) , name@var1891 .@expr1073749400 c_str (@expr1073749401 ) , name@var1891 .@expr1073749402 size (@expr1073749403 ) ) ) {
1776:
1777: dst@var1864 .@expr7165 insertToken (@expr1073749405 name@var1891 , "" , true ) ;
1778: dst@var1864 .@expr7003 previous (@expr7004 ) .@expr7170 linenr (@expr7171 start@var1868 .@expr7172 linenr (@expr7173 ) ) ;
1779: dst@var1864 .@expr7003 previous (@expr7004 ) .@expr7176 column (@expr7177 start@var1868 .@expr7178 column (@expr7179 ) ) ;
1780: start@var1868 =@expr1073749418 closing@var1890 ;
1781: break ;
1782: }
1783: }
1784: }
1785:
1786: if (@expr1073749419 start@var1868 !=@expr1073749420 closing@var1890 ) {
1787: dst@var1864 .@expr7165 insertToken (@expr7598 start@var1868 .@expr7189 str (@expr7190 ) , start@var1868 .@expr7601 originalName (@expr7602 ) , true ) ;
1788: dst@var1864 .@expr7003 previous (@expr7004 ) .@expr7170 linenr (@expr7171 start@var1868 .@expr7172 linenr (@expr7173 ) ) ;
1789: dst@var1864 .@expr7003 previous (@expr7004 ) .@expr7176 column (@expr7177 start@var1868 .@expr7178 column (@expr7179 ) ) ;
1790: dst@var1864 .@expr7003 previous (@expr7004 ) .@expr7617 isSigned (@expr7618 start@var1868 .@expr7619 isSigned (@expr7620 ) ) ;
1791: dst@var1864 .@expr7003 previous (@expr7004 ) .@expr7623 isUnsigned (@expr7624 start@var1868 .@expr7625 isUnsigned (@expr7626 ) ) ;
1792: dst@var1864 .@expr7003 previous (@expr7004 ) .@expr7629 isLong (@expr7630 start@var1868 .@expr7631 isLong (@expr7632 ) ) ;
1793: }
1794: } else {
1795: dst@var1864 .@expr7165 insertToken (@expr7598 start@var1868 .@expr7189 str (@expr7190 ) , start@var1868 .@expr7601 originalName (@expr7602 ) , true ) ;
1796: dst@var1864 .@expr7003 previous (@expr7004 ) .@expr7170 linenr (@expr7171 start@var1868 .@expr7172 linenr (@expr7173 ) ) ;
1797: dst@var1864 .@expr7003 previous (@expr7004 ) .@expr7176 column (@expr7177 start@var1868 .@expr7178 column (@expr7179 ) ) ;
1798: dst@var1864 .@expr7003 previous (@expr7004 ) .@expr7617 isSigned (@expr7618 start@var1868 .@expr7619 isSigned (@expr7620 ) ) ;
1799: dst@var1864 .@expr7003 previous (@expr7004 ) .@expr7623 isUnsigned (@expr7624 start@var1868 .@expr7625 isUnsigned (@expr7626 ) ) ;
1800: dst@var1864 .@expr7003 previous (@expr7004 ) .@expr7629 isLong (@expr7630 start@var1868 .@expr7631 isLong (@expr7632 ) ) ;
1801: }
1802: } }
1803:
1804: if (@expr1073749493 !@expr1073749494 start@var1868 ) {
1805: continue ; }
1806:
1807: if (@expr1073749495 start@var1868 .@expr7672 link (@expr7673 ) ) {
1808: if (@expr1073749498 Token ::@expr7082 Match (@expr1073749500 start@var1868 , "[|{|(" ) ) {
1809: links@var1880 [@expr1073749501 start@var1868 .@expr7672 link (@expr7673 ) ] =@expr1073749504 dst@var1864 .@expr7003 previous (@expr7004 ) ;
1810: } else { if (@expr1073749507 Token ::@expr7082 Match (@expr1073749509 start@var1868 , "]|}|)" ) ) {
1811: std ::@expr1073749510 map < const Token *@expr7181 , Token *@expr7181 > ::@expr1073749513 iterator link@var1894 ; link@var1894 =@expr1073749514 links@var1880 .@expr1073749515 find (@expr1073749516 start@var1868 ) ;
1812:
1813: if (@expr1073749517 link@var1894 !=@expr1073749518 links@var1880 .@expr1073749519 end (@expr1073749520 ) ) {
1814: Token ::@expr7365 createMutualLinks (@expr1073749522 link@var1894 .@expr1073749523 second@var1895 , dst@var1864 .@expr7003 previous (@expr7004 ) ) ;
1815: links@var1880 .@expr1073749526 erase (@expr1073749527 start@var1868 ) ;
1816: }
1817: } }
1818: }
1819: }
1820:
1821: start@var1868 =@expr1073749528 start@var1868 .@expr7456 next (@expr7457 ) ;
1822: }
1823: dst@var1864 .@expr7165 insertToken (@expr1073749532 ";" , "" , true ) ;
1824: dst@var1864 .@expr7003 previous (@expr7004 ) .@expr7170 linenr (@expr1073749536 dst@var1864 .@expr7022 tokAt (@expr7714 -2 ) .@expr1073749539 linenr (@expr1073749540 ) ) ;
1825: dst@var1864 .@expr7003 previous (@expr7004 ) .@expr7176 column (@expr1073749544 dst@var1864 .@expr7022 tokAt (@expr7714 -2 ) .@expr1073749547 column (@expr1073749548 ) +@expr1073749549 1 ) ;
1826:
1827: if (@expr1073749550 isVariable@var1858 ||@expr1073749551 isFunction@var1856 ) {
1828: simplifyTemplateArgs (@expr1073749552 dstStart@var1865 , dst@var1864 ) ; }
1829: } }
1830:
1831: if (@expr1073749553 copy@var1849 &&@expr1073749554 (@expr1073749555 isClass@var1855 ||@expr1073749556 isFunction@var1856 ) ) {
1832:
1833: Token * start@var1896 ; start@var1896 =@expr1073749557 templateInstantiation@var1846 .@expr1073749558 token (@expr1073749559 ) ;
1834: while (@expr1073749560 start@var1896 &&@expr1073749561 !@expr1073749562 Token ::@expr7082 Match (@expr1073749564 start@var1896 .@expr7741 previous (@expr7742 ) , "}|;|extern" ) ) {
1835: start@var1896 =@expr1073749567 start@var1896 .@expr7741 previous (@expr7742 ) ; }
1836: if (@expr1073749570 Token ::@expr7082 Match (@expr1073749572 start@var1896 , "template !!<" ) ) {
1837: if (@expr1073749573 start@var1896 .@expr1073749574 strAt (@expr1073749575 -1 ) ==@expr1073749576 "extern" ) {
1838: start@var1896 =@expr1073749577 start@var1896 .@expr7741 previous (@expr7742 ) ; }
1839: mExplicitInstantiationsToDelete@var112 .@expr1073749580 emplace_back (@expr1073749581 start@var1896 , "" ) ;
1840: }
1841: }
1842:
1843: for (@expr1073749582 Token *@expr7181 tok3@var1897 =@expr1073749584 mTokenList@var100 .@expr1073749585 front (@expr1073749586 ) ; tok3@var1897 ; tok3@var1897 =@expr1073749587 tok3@var1897 ?@expr1073749588 tok3@var1897 .@expr7765 next (@expr7766 ) :@expr1073749591 nullptr ) {
1844: if (@expr1073749592 inTemplateDefinition@var1850 ) {
1845: if (@expr1073749593 !@expr1073749594 endOfTemplateDefinition@var1852 ) {
1846: if (@expr1073749595 isVariable@var1858 ) {
1847: Token * temp@var1898 ; temp@var1898 =@expr1073749596 tok3@var1897 .@expr1073749597 findClosingBracket (@expr1073749598 ) ;
1848: if (@expr1073749599 temp@var1898 ) {
1849: while (@expr1073749600 temp@var1898 &&@expr1073749601 temp@var1898 .@expr1073749602 str (@expr1073749603 ) !=@expr1073749604 ";" ) {
1850: if (@expr1073749605 temp@var1898 .@expr7782 link (@expr7783 ) &&@expr1073749608 Token ::@expr7082 Match (@expr1073749610 temp@var1898 , "{|[|(" ) ) {
1851: temp@var1898 =@expr1073749611 temp@var1898 .@expr7782 link (@expr7783 ) ; }
1852: temp@var1898 =@expr1073749614 temp@var1898 .@expr1073749615 next (@expr1073749616 ) ;
1853: }
1854: endOfTemplateDefinition@var1852 =@expr1073749617 temp@var1898 ;
1855: }
1856: } else { if (@expr7794 tok3@var1897 .@expr7795 str (@expr7796 ) ==@expr7797 "{" ) {
1857: endOfTemplateDefinition@var1852 =@expr1073749622 tok3@var1897 .@expr7799 link (@expr7800 ) ; } }
1858: }
1859: if (@expr1073749625 tok3@var1897 ==@expr1073749626 endOfTemplateDefinition@var1852 ) {
1860: inTemplateDefinition@var1850 =@expr1073749627 false ;
1861: startOfTemplateDeclaration@var1851 =@expr1073749628 nullptr ;
1862: }
1863: }
1864:
1865: if (@expr1073749629 tok3@var1897 .@expr7795 str (@expr7796 ) ==@expr1073749632 "template" ) {
1866: if (@expr1073749633 tok3@var1897 .@expr7765 next (@expr7766 ) &&@expr1073749636 tok3@var1897 .@expr7765 next (@expr7766 ) .@expr1073749639 str (@expr1073749640 ) ==@expr1073749641 "<" ) {
1867: std ::@expr1073749642 vector < const Token *@expr7181 > localTypeParametersInDeclaration@var1899 ;
1868: getTemplateParametersInDeclaration (@expr1073749644 tok3@var1897 .@expr7821 tokAt (@expr7822 2 ) , localTypeParametersInDeclaration@var1899 ) ;
1869: if (@expr1073749647 localTypeParametersInDeclaration@var1899 .@expr1073749648 size (@expr1073749649 ) !=@expr1073749650 typeParametersInDeclaration@var1847 .@expr7196 size (@expr7197 ) ) {
1870: inTemplateDefinition@var1850 =@expr1073749653 false ; }
1871: else {
1872: inTemplateDefinition@var1850 =@expr1073749654 true ; }
1873: } else {
1874: inTemplateDefinition@var1850 =@expr1073749655 false ;
1875: }
1876: startOfTemplateDeclaration@var1851 =@expr1073749656 tok3@var1897 ;
1877: }
1878: if (@expr1073749657 Token ::@expr7082 Match (@expr1073749659 tok3@var1897 , "(|[" ) ) {
1879: tok3@var1897 =@expr1073749660 tok3@var1897 .@expr7799 link (@expr7800 ) ; }
1880:
1881:
1882: if (@expr1073749663 tok3@var1897 ==@expr1073749664 templateDeclarationToken@var1854 ) {
1883: tok3@var1897 =@expr1073749665 tok3@var1897 .@expr7765 next (@expr7766 ) ;
1884: if (@expr1073749668 tok3@var1897 .@expr7795 str (@expr7796 ) ==@expr1073749671 "static" ) {
1885: tok3@var1897 =@expr1073749672 tok3@var1897 .@expr7765 next (@expr7766 ) ; }
1886: }
1887:
1888:
1889: else { if (@expr1073749675 inTemplateDefinition@var1850 &&@expr1073749676
1890: Token ::@expr7082 Match (@expr1073749678 tok3@var1897 , "%name% <" ) &&@expr1073749679
1891: templateInstantiation@var1846 .@expr7856 name (@expr7857 ) ==@expr1073749682 tok3@var1897 .@expr7795 str (@expr7796 ) &&@expr1073749685
1892: instantiateMatch (@expr1073749686 tok3@var1897 , typeParametersInDeclaration@var1847 .@expr7196 size (@expr7197 ) , templateDeclaration@var1845 .@expr7232 isVariadic (@expr7233 ) , ":: ~| %name% (" ) ) {
1893:
1894: bool istemplate@var1900 ; istemplate@var1900 =@expr1073749691 false ;
1895: Token * tok5@var1901 ; tok5@var1901 =@expr1073749692 nullptr ;
1896: for (@expr1073749693 Token *@expr7181 prev@var1902 =@expr1073749695 tok3@var1897 ; prev@var1902 &&@expr1073749696 !@expr1073749697 Token ::@expr7082 Match (@expr1073749699 prev@var1902 , "[;{}]" ) ; prev@var1902 =@expr1073749700 prev@var1902 .@expr1073749701 previous (@expr1073749702 ) ) {
1897: if (@expr1073749703 prev@var1902 .@expr1073749704 str (@expr1073749705 ) ==@expr1073749706 "template" ) {
1898: istemplate@var1900 =@expr1073749707 true ;
1899: tok5@var1901 =@expr1073749708 prev@var1902 ;
1900: break ;
1901: }
1902: }
1903: if (@expr1073749709 !@expr1073749710 istemplate@var1900 ) {
1904: continue ; }
1905:
1906: const Token * tok4@var1903 ; tok4@var1903 =@expr1073749711 tok3@var1897 .@expr7765 next (@expr7766 ) .@expr7890 findClosingBracket (@expr7891 ) ;
1907: while (@expr1073749716 tok4@var1903 &&@expr1073749717 tok4@var1903 .@expr1073749718 str (@expr1073749719 ) !=@expr1073749720 "(" ) {
1908: tok4@var1903 =@expr1073749721 tok4@var1903 .@expr1073749722 next (@expr1073749723 ) ; }
1909: if (@expr1073749724 !@expr1073749725 Tokenizer ::@expr1073749726 isFunctionHead (@expr1073749727 tok4@var1903 , ":{" , true ) ) {
1910: continue ; }
1911:
1912: tok5@var1901 =@expr1073749728 tok5@var1901 .@expr7905 next (@expr7906 ) .@expr7907 findClosingBracket (@expr7908 ) ;
1913: if (@expr1073749733 tok5@var1901 ) {
1914: tok5@var1901 =@expr1073749734 tok5@var1901 .@expr7905 next (@expr7906 ) ; }
1915:
1916: std ::@expr1073749737 stack < Token *@expr7181 > brackets2@var1904 ;
1917: while (@expr1073749739 tok5@var1901 &&@expr1073749740 tok5@var1901 !=@expr1073749741 tok3@var1897 ) {
1918:
1919: if (@expr1073749742 Token ::@expr7082 Match (@expr1073749744 tok5@var1901 , "%name% <" ) &&@expr1073749745 tok5@var1901 .@expr7922 str (@expr7923 ) ==@expr1073749748 templateInstantiation@var1846 .@expr7856 name (@expr7857 ) ) {
1920: if (@expr7927 copy@var1849 ) {
1921: if (@expr1073749752 !@expr7929 templateDeclaration@var1845 .@expr7470 scope (@expr7471 ) .@expr7472 empty (@expr7473 ) &&@expr1073749758 tok5@var1901 .@expr1073749759 strAt (@expr1073749760 -1 ) !=@expr1073749761 "::" ) {
1922: addNamespace (@expr1073749762 templateDeclaration@var1845 , tok5@var1901 ) ; }
1923: mTokenList@var100 .@expr7939 addtoken (@expr1073749764 newName@var1848 , tok5@var1901 .@expr1073749765 linenr (@expr1073749766 ) , tok5@var1901 .@expr1073749767 column (@expr1073749768 ) , tok5@var1901 .@expr1073749769 fileIndex (@expr1073749770 ) ) ;
1924: tok5@var1901 =@expr1073749771 tok5@var1901 .@expr7905 next (@expr7906 ) .@expr7907 findClosingBracket (@expr7908 ) ;
1925: } else {
1926: tok5@var1901 .@expr7922 str (@expr1073749777 newName@var1848 ) ;
1927: eraseTokens (@expr1073749778 tok5@var1901 , tok5@var1901 .@expr7905 next (@expr7906 ) .@expr7907 findClosingBracket (@expr7908 ) .@expr1073749783 next (@expr1073749784 ) ) ;
1928: }
1929: } else { if (@expr7927 copy@var1849 ) {
1930: bool added@var1905 ; added@var1905 =@expr1073749786 false ;
1931: if (@expr1073749787 tok5@var1901 .@expr1073749788 isName (@expr1073749789 ) &&@expr1073749790 !@expr1073749791 Token ::@expr7082 Match (@expr1073749793 tok5@var1901 , "class|typename|struct" ) &&@expr1073749794 !@expr1073749795 tok5@var1901 .@expr1073749796 isStandardType (@expr1073749797 ) ) {
1932:
1933: unsigned int itype@var1906 ; itype@var1906 =@expr1073749798 0 ;
1934: while (@expr1073749799 itype@var1906 <@expr7976 typeParametersInDeclaration@var1847 .@expr7196 size (@expr7197 ) &&@expr1073749803 typeParametersInDeclaration@var1847 [@expr1073749804 itype@var1906 ] .@expr1073749805 str (@expr1073749806 ) !=@expr1073749807 tok5@var1901 .@expr7922 str (@expr7923 ) ) {
1935: ++@expr1073749810 itype@var1906 ; }
1936:
1937:
1938: if (@expr1073749811 itype@var1906 <@expr7976 typeParametersInDeclaration@var1847 .@expr7196 size (@expr7197 ) &&@expr1073749815 itype@var1906 <@expr1073749816 mTypesUsedInTemplateInstantiation@var113 .@expr7212 size (@expr7213 ) ) {
1939: std ::@expr1073749819 stack < Token *@expr7181 > brackets1@var1907 ;
1940: for (@expr1073749821 const Token *@expr7181 typetok@var1908 =@expr1073749823 mTypesUsedInTemplateInstantiation@var113 [@expr1073749824 itype@var1906 ] .@expr1073749825 token (@expr1073749826 ) ;
1941: typetok@var1908 &&@expr1073749827 !@expr1073749828 Token ::@expr7082 Match (@expr1073749830 typetok@var1908 , ",|>" ) ;
1942: typetok@var1908 =@expr1073749831 typetok@var1908 .@expr1073749832 next (@expr1073749833 ) ) {
1943: if (@expr1073749834 !@expr1073749835 Token ::@expr7279 simpleMatch (@expr1073749837 typetok@var1908 , "..." ) ) {
1944: mTokenList@var100 .@expr7939 addtoken (@expr1073749839 typetok@var1908 , tok5@var1901 ) ;
1945: Token * back@var1909 ; back@var1909 =@expr1073749840 mTokenList@var100 .@expr8017 back (@expr8018 ) ;
1946: if (@expr1073749843 Token ::@expr7082 Match (@expr1073749845 back@var1909 , "{|(|[" ) ) {
1947: brackets1@var1907 .@expr1073749846 push (@expr1073749847 back@var1909 ) ;
1948: } else { if (@expr1073749848 back@var1909 .@expr8025 str (@expr8026 ) ==@expr1073749851 "}" ) {
1949: assert (@expr8028 brackets1@var1907 .@expr8029 empty (@expr8030 ) ==@expr8031 false ) ;
1950: assert (@expr1073749856 brackets1@var1907 .@expr8033 top (@expr8034 ) .@expr8035 str (@expr8036 ) ==@expr1073749861 "{" ) ;
1951: Token ::@expr7365 createMutualLinks (@expr8039 brackets1@var1907 .@expr8033 top (@expr8034 ) , back@var1909 ) ;
1952: brackets1@var1907 .@expr8042 pop (@expr8043 ) ;
1953: } else { if (@expr1073749868 back@var1909 .@expr8025 str (@expr8026 ) ==@expr1073749871 ")" ) {
1954: assert (@expr8028 brackets1@var1907 .@expr8029 empty (@expr8030 ) ==@expr8031 false ) ;
1955: assert (@expr1073749876 brackets1@var1907 .@expr8033 top (@expr8034 ) .@expr8035 str (@expr8036 ) ==@expr1073749881 "(" ) ;
1956: Token ::@expr7365 createMutualLinks (@expr8039 brackets1@var1907 .@expr8033 top (@expr8034 ) , back@var1909 ) ;
1957: brackets1@var1907 .@expr8042 pop (@expr8043 ) ;
1958: } else { if (@expr1073749888 back@var1909 .@expr8025 str (@expr8026 ) ==@expr1073749891 "]" ) {
1959: assert (@expr8028 brackets1@var1907 .@expr8029 empty (@expr8030 ) ==@expr8031 false ) ;
1960: assert (@expr1073749896 brackets1@var1907 .@expr8033 top (@expr8034 ) .@expr8035 str (@expr8036 ) ==@expr1073749901 "[" ) ;
1961: Token ::@expr7365 createMutualLinks (@expr8039 brackets1@var1907 .@expr8033 top (@expr8034 ) , back@var1909 ) ;
1962: brackets1@var1907 .@expr8042 pop (@expr8043 ) ;
1963: } } } }
1964: back@var1909 .@expr1073749908 isTemplateArg (@expr1073749909 true ) ;
1965: back@var1909 .@expr1073749910 isUnsigned (@expr1073749911 typetok@var1908 .@expr1073749912 isUnsigned (@expr1073749913 ) ) ;
1966: back@var1909 .@expr1073749914 isSigned (@expr1073749915 typetok@var1908 .@expr1073749916 isSigned (@expr1073749917 ) ) ;
1967: back@var1909 .@expr1073749918 isLong (@expr1073749919 typetok@var1908 .@expr1073749920 isLong (@expr1073749921 ) ) ;
1968: added@var1905 =@expr1073749922 true ;
1969: break ;
1970: }
1971: }
1972: }
1973: }
1974: if (@expr1073749923 !@expr1073749924 added@var1905 ) {
1975: mTokenList@var100 .@expr7939 addtoken (@expr1073749926 tok5@var1901 ) ;
1976: Token * back@var1910 ; back@var1910 =@expr1073749927 mTokenList@var100 .@expr8017 back (@expr8018 ) ;
1977: if (@expr1073749930 Token ::@expr7082 Match (@expr1073749932 back@var1910 , "{|(|[" ) ) {
1978: brackets2@var1904 .@expr1073749933 push (@expr1073749934 back@var1910 ) ;
1979: } else { if (@expr1073749935 back@var1910 .@expr8112 str (@expr8113 ) ==@expr1073749938 "}" ) {
1980: assert (@expr8115 brackets2@var1904 .@expr8116 empty (@expr8117 ) ==@expr8118 false ) ;
1981: assert (@expr1073749943 brackets2@var1904 .@expr8120 top (@expr8121 ) .@expr8122 str (@expr8123 ) ==@expr1073749948 "{" ) ;
1982: Token ::@expr7365 createMutualLinks (@expr8126 brackets2@var1904 .@expr8120 top (@expr8121 ) , back@var1910 ) ;
1983: brackets2@var1904 .@expr8129 pop (@expr8130 ) ;
1984: } else { if (@expr1073749955 back@var1910 .@expr8112 str (@expr8113 ) ==@expr1073749958 ")" ) {
1985: assert (@expr8115 brackets2@var1904 .@expr8116 empty (@expr8117 ) ==@expr8118 false ) ;
1986: assert (@expr1073749963 brackets2@var1904 .@expr8120 top (@expr8121 ) .@expr8122 str (@expr8123 ) ==@expr1073749968 "(" ) ;
1987: Token ::@expr7365 createMutualLinks (@expr8126 brackets2@var1904 .@expr8120 top (@expr8121 ) , back@var1910 ) ;
1988: brackets2@var1904 .@expr8129 pop (@expr8130 ) ;
1989: } else { if (@expr1073749975 back@var1910 .@expr8112 str (@expr8113 ) ==@expr1073749978 "]" ) {
1990: assert (@expr8115 brackets2@var1904 .@expr8116 empty (@expr8117 ) ==@expr8118 false ) ;
1991: assert (@expr1073749983 brackets2@var1904 .@expr8120 top (@expr8121 ) .@expr8122 str (@expr8123 ) ==@expr1073749988 "[" ) ;
1992: Token ::@expr7365 createMutualLinks (@expr8126 brackets2@var1904 .@expr8120 top (@expr8121 ) , back@var1910 ) ;
1993: brackets2@var1904 .@expr8129 pop (@expr8130 ) ;
1994: } } } }
1995: }
1996: } }
1997:
1998: tok5@var1901 =@expr1073749995 tok5@var1901 .@expr7905 next (@expr7906 ) ;
1999: }
2000: if (@expr7927 copy@var1849 ) {
2001: if (@expr1073749999 !@expr7929 templateDeclaration@var1845 .@expr7470 scope (@expr7471 ) .@expr7472 empty (@expr7473 ) &&@expr1073750005 tok3@var1897 .@expr8182 strAt (@expr1073750007 -1 ) !=@expr1073750008 "::" ) {
2002: addNamespace (@expr8185 templateDeclaration@var1845 , tok3@var1897 ) ; }
2003: mTokenList@var100 .@expr7939 addtoken (@expr1073750011 newName@var1848 , tok3@var1897 .@expr1073750012 linenr (@expr1073750013 ) , tok3@var1897 .@expr1073750014 column (@expr1073750015 ) , tok3@var1897 .@expr1073750016 fileIndex (@expr1073750017 ) ) ;
2004: }
2005:
2006: while (@expr1073750018 tok3@var1897 &&@expr1073750019 tok3@var1897 .@expr7795 str (@expr7796 ) !=@expr1073750022 "::" ) {
2007: tok3@var1897 =@expr1073750023 tok3@var1897 .@expr7765 next (@expr7766 ) ; }
2008:
2009: std ::@expr7042 list < TokenAndName > ::@expr1073750027 iterator it@var1911 ; it@var1911 =@expr1073750028 std ::@expr7045 find_if (@expr1073750030 mTemplateDeclarations@var104 .@expr1073750031 begin (@expr1073750032 ) ,
2010: mTemplateDeclarations@var104 .@expr8209 end (@expr8210 ) ,
2011: FindToken (@expr1073750035 startOfTemplateDeclaration@var1851 ) ) ;
2012: if (@expr1073750036 it@var1911 !=@expr1073750037 mTemplateDeclarations@var104 .@expr8209 end (@expr8210 ) ) {
2013: mMemberFunctionsToDelete@var111 .@expr7057 push_back (@expr1073750041 *@expr1073750042 it@var1911 ) ; }
2014: }
2015:
2016:
2017: else {
2018: continue ; } }
2019:
2020: std ::@expr1073750043 stack < Token *@expr7181 > brackets@var1912 ;
2021:
2022:
2023: const std ::@expr1073750045 string lastName@var1913 =@expr1073750046 (@expr1073750047 templateInstantiation@var1846 .@expr7856 name (@expr7857 ) .@expr1073750050 find (@expr1073750051 ' ' ) !=@expr1073750052 std ::@expr6957 string ::@expr7267 npos@expr6934 ) ?@expr1073750055 templateInstantiation@var1846 .@expr7856 name (@expr7857 ) .@expr1073750058 substr (@expr1073750059 templateInstantiation@var1846 .@expr7856 name (@expr7857 ) .@expr1073750062 rfind (@expr1073750063 ' ' ) +@expr1073750064 1 ) :@expr1073750065 templateInstantiation@var1846 .@expr7856 name (@expr7857 ) ;
2024:
2025: std ::@expr1073750068 stack < const Token *@expr7181 > templates@var1914 ;
2026: for (@expr1073750070 ; tok3@var1897 ; tok3@var1897 =@expr1073750071 tok3@var1897 .@expr7765 next (@expr7766 ) ) {
2027: if (@expr1073750074 tok3@var1897 .@expr1073750075 isName (@expr1073750076 ) &&@expr1073750077 !@expr1073750078 Token ::@expr7082 Match (@expr1073750080 tok3@var1897 , "class|typename|struct" ) &&@expr1073750081 !@expr1073750082 tok3@var1897 .@expr1073750083 isStandardType (@expr1073750084 ) ) {
2028:
2029: unsigned int itype@var1915 ; itype@var1915 =@expr1073750085 0 ;
2030: while (@expr1073750086 itype@var1915 <@expr8263 typeParametersInDeclaration@var1847 .@expr7196 size (@expr7197 ) &&@expr1073750090 typeParametersInDeclaration@var1847 [@expr1073750091 itype@var1915 ] .@expr1073750092 str (@expr1073750093 ) !=@expr1073750094 tok3@var1897 .@expr7795 str (@expr7796 ) ) {
2031: ++@expr1073750097 itype@var1915 ; }
2032:
2033:
2034: if (@expr1073750098 itype@var1915 <@expr8263 typeParametersInDeclaration@var1847 .@expr7196 size (@expr7197 ) &&@expr1073750102 itype@var1915 <@expr1073750103 mTypesUsedInTemplateInstantiation@var113 .@expr7212 size (@expr7213 ) ) {
2035: unsigned int typeindentlevel@var1916 ; typeindentlevel@var1916 =@expr1073750106 0 ;
2036: std ::@expr1073750107 stack < Token *@expr7181 > brackets1@var1917 ;
2037: Token * const beforeTypeToken@var1918 ; beforeTypeToken@var1918 =@expr1073750109 mTokenList@var100 .@expr8017 back (@expr8018 ) ;
2038: bool pointerType@var1919 ; pointerType@var1919 =@expr1073750112 false ;
2039: const bool isVariadicTemplateArg@var1920 =@expr1073750113 templateDeclaration@var1845 .@expr7232 isVariadic (@expr7233 ) &&@expr1073750116 itype@var1915 +@expr1073750117 1 ==@expr1073750118 typeParametersInDeclaration@var1847 .@expr7196 size (@expr7197 ) ;
2040: if (@expr1073750121 isVariadicTemplateArg@var1920 &&@expr1073750122 Token ::@expr7082 Match (@expr1073750124 tok3@var1897 , "%name% ... %name%" ) ) {
2041: tok3@var1897 =@expr1073750125 tok3@var1897 .@expr7821 tokAt (@expr7822 2 ) ; }
2042: const std ::@expr1073750128 string endStr@var1921 (@expr1073750129 isVariadicTemplateArg@var1920 ?@expr1073750130 ">" :@expr7249 ",>" ) ;
2043: for (@expr1073750132 const Token *@expr7181 typetok@var1922 =@expr1073750134 mTypesUsedInTemplateInstantiation@var113 [@expr1073750135 itype@var1915 ] .@expr1073750136 token (@expr1073750137 ) ;
2044: typetok@var1922 &&@expr1073750138 (@expr1073750139 typeindentlevel@var1916 >@expr8316 0 ||@expr1073750141 endStr@var1921 .@expr1073750142 find (@expr1073750143 typetok@var1922 .@expr8320 str (@expr8321 ) [@expr1073750146 0 ] ) ==@expr1073750147 std ::@expr6957 string ::@expr7267 npos@expr6934 ) ;
2045: typetok@var1922 =@expr1073750150 typetok@var1922 .@expr8327 next (@expr8328 ) ) {
2046: if (@expr1073750153 typeindentlevel@var1916 ==@expr1073750154 0 &&@expr1073750155 typetok@var1922 .@expr8320 str (@expr8321 ) ==@expr1073750158 "*" ) {
2047: pointerType@var1919 =@expr1073750159 true ; }
2048: if (@expr1073750160 Token ::@expr7279 simpleMatch (@expr1073750162 typetok@var1922 , "..." ) ) {
2049: continue ; }
2050: if (@expr1073750163 Token ::@expr7082 Match (@expr1073750165 typetok@var1922 , "%name% <" ) &&@expr1073750166
2051: (@expr1073750167 typetok@var1922 .@expr1073750168 strAt (@expr1073750169 2 ) ==@expr1073750170 ">" ||@expr1073750171 templateParameters (@expr1073750172 typetok@var1922 .@expr8327 next (@expr8328 ) ) ) ) {
2052: brackets1@var1917 .@expr8351 push (@expr8352 typetok@var1922 .@expr8327 next (@expr8328 ) ) ;
2053: ++@expr1073750179 typeindentlevel@var1916 ;
2054: } else { if (@expr1073750180 typeindentlevel@var1916 >@expr8316 0 &&@expr1073750182 typetok@var1922 .@expr8320 str (@expr8321 ) ==@expr1073750185 ">" &&@expr1073750186 brackets1@var1917 .@expr8363 top (@expr8364 ) .@expr8365 str (@expr8366 ) ==@expr1073750191 "<" ) {
2055: --@expr1073750192 typeindentlevel@var1916 ;
2056: brackets1@var1917 .@expr8369 pop (@expr8370 ) ;
2057: } else { if (@expr1073750195 Token ::@expr7082 Match (@expr1073750197 typetok@var1922 , "const_cast|dynamic_cast|reinterpret_cast|static_cast <" ) ) {
2058: brackets1@var1917 .@expr8351 push (@expr8352 typetok@var1922 .@expr8327 next (@expr8328 ) ) ;
2059: ++@expr1073750202 typeindentlevel@var1916 ;
2060: } else { if (@expr1073750203 typetok@var1922 .@expr8320 str (@expr8321 ) ==@expr1073750206 "(" ) {
2061: ++@expr1073750207 typeindentlevel@var1916 ; }
2062: else { if (@expr1073750208 typetok@var1922 .@expr8320 str (@expr8321 ) ==@expr1073750211 ")" ) {
2063: --@expr1073750212 typeindentlevel@var1916 ; } } } } }
2064: Token * back@var1923 ;
2065: if (@expr7927 copy@var1849 ) {
2066: mTokenList@var100 .@expr7939 addtoken (@expr1073750215 typetok@var1922 , tok3@var1897 ) ;
2067: back@var1923 =@expr1073750216 mTokenList@var100 .@expr8017 back (@expr8018 ) ;
2068: } else {
2069: back@var1923 =@expr1073750219 const_cast < Token *@expr7181 > (@expr1073750221 typetok@var1922 ) ; }
2070: if (@expr1073750222 Token ::@expr7082 Match (@expr1073750224 back@var1923 , "{|(|[" ) ) {
2071: brackets1@var1917 .@expr8351 push (@expr1073750226 back@var1923 ) ; }
2072: else { if (@expr1073750227 back@var1923 .@expr8404 str (@expr8405 ) ==@expr1073750230 "}" ) {
2073: assert (@expr8407 brackets1@var1917 .@expr8408 empty (@expr8409 ) ==@expr8410 false ) ;
2074: assert (@expr1073750235 brackets1@var1917 .@expr8363 top (@expr8364 ) .@expr8365 str (@expr8366 ) ==@expr1073750240 "{" ) ;
2075: if (@expr7927 copy@var1849 ) {
2076: Token ::@expr7365 createMutualLinks (@expr8419 brackets1@var1917 .@expr8363 top (@expr8364 ) , back@var1923 ) ; }
2077: brackets1@var1917 .@expr8369 pop (@expr8370 ) ;
2078: } else { if (@expr1073750248 back@var1923 .@expr8404 str (@expr8405 ) ==@expr1073750251 ")" ) {
2079: assert (@expr8407 brackets1@var1917 .@expr8408 empty (@expr8409 ) ==@expr8410 false ) ;
2080: assert (@expr1073750256 brackets1@var1917 .@expr8363 top (@expr8364 ) .@expr8365 str (@expr8366 ) ==@expr1073750261 "(" ) ;
2081: if (@expr7927 copy@var1849 ) {
2082: Token ::@expr7365 createMutualLinks (@expr8419 brackets1@var1917 .@expr8363 top (@expr8364 ) , back@var1923 ) ; }
2083: brackets1@var1917 .@expr8369 pop (@expr8370 ) ;
2084: } else { if (@expr1073750269 back@var1923 .@expr8404 str (@expr8405 ) ==@expr1073750272 "]" ) {
2085: assert (@expr8407 brackets1@var1917 .@expr8408 empty (@expr8409 ) ==@expr8410 false ) ;
2086: assert (@expr1073750277 brackets1@var1917 .@expr8363 top (@expr8364 ) .@expr8365 str (@expr8366 ) ==@expr1073750282 "[" ) ;
2087: if (@expr7927 copy@var1849 ) {
2088: Token ::@expr7365 createMutualLinks (@expr8419 brackets1@var1917 .@expr8363 top (@expr8364 ) , back@var1923 ) ; }
2089: brackets1@var1917 .@expr8369 pop (@expr8370 ) ;
2090: } } } }
2091: if (@expr7927 copy@var1849 ) {
2092: back@var1923 .@expr1073750291 isTemplateArg (@expr1073750292 true ) ; }
2093: }
2094: if (@expr1073750293 pointerType@var1919 &&@expr1073750294 Token ::@expr7279 simpleMatch (@expr1073750296 beforeTypeToken@var1918 , "const" ) ) {
2095: mTokenList@var100 .@expr7939 addtoken (@expr1073750298 beforeTypeToken@var1918 ) ;
2096: beforeTypeToken@var1918 .@expr1073750299 deleteThis (@expr1073750300 ) ;
2097: }
2098: continue ;
2099: }
2100: }
2101:
2102:
2103: if (@expr1073750301 tok3@var1897 .@expr7795 str (@expr7796 ) ==@expr1073750304 lastName@var1913 ) {
2104: if (@expr1073750305 Token ::@expr7279 simpleMatch (@expr1073750307 tok3@var1897 .@expr7765 next (@expr7766 ) , "<" ) ) {
2105: Token * closingBracket@var1924 ; closingBracket@var1924 =@expr1073750310 tok3@var1897 .@expr7765 next (@expr7766 ) .@expr7890 findClosingBracket (@expr7891 ) ;
2106: if (@expr1073750315 closingBracket@var1924 ) {
2107:
2108: if (@expr1073750316 tok3@var1897 ==@expr1073750317 templateDeclarationNameToken@var1853 ||@expr1073750318
2109: Token ::@expr7082 Match (@expr1073750320 tok3@var1897 , newName@var1848 .@expr7491 c_str (@expr7492 ) ) ) {
2110: if (@expr7927 copy@var1849 ) {
2111: mTokenList@var100 .@expr7939 addtoken (@expr8501 newName@var1848 , tok3@var1897 ) ;
2112: tok3@var1897 =@expr1073750326 closingBracket@var1924 ;
2113: } else {
2114: tok3@var1897 .@expr7795 str (@expr8504 newName@var1848 ) ;
2115: eraseTokens (@expr1073750329 tok3@var1897 , closingBracket@var1924 .@expr8506 next (@expr8507 ) ) ;
2116: }
2117: continue ;
2118: } else { if (@expr1073750332 !@expr7929 templateDeclaration@var1845 .@expr7470 scope (@expr7471 ) .@expr7472 empty (@expr7473 ) &&@expr1073750338
2119: !@expr1073750339 alreadyHasNamespace (@expr1073750340 templateDeclaration@var1845 , tok3@var1897 ) &&@expr1073750341
2120: !@expr1073750342 Token ::@expr7082 Match (@expr1073750344 closingBracket@var1924 .@expr8506 next (@expr8507 ) , "(|::" ) ) {
2121: if (@expr7927 copy@var1849 ) {
2122: addNamespace (@expr8185 templateDeclaration@var1845 , tok3@var1897 ) ; }
2123: } }
2124: }
2125: } else {
2126:
2127: if (@expr1073750349 Token ::@expr7082 Match (@expr1073750351 tok3@var1897 .@expr7821 tokAt (@expr1073750353 -3 ) , "> friend class|struct|union" ) ) {
2128: if (@expr7927 copy@var1849 ) {
2129: mTokenList@var100 .@expr7939 addtoken (@expr8532 tok3@var1897 ) ; }
2130: } else { if (@expr7927 copy@var1849 ) {
2131:
2132: if (@expr1073750358 !@expr7929 templateDeclaration@var1845 .@expr7470 scope (@expr7471 ) .@expr7472 empty (@expr7473 ) &&@expr1073750364
2133: (@expr1073750365 isClass@var1855 ?@expr1073750366 tok3@var1897 .@expr8182 strAt (@expr8544 1 ) !=@expr1073750369 "(" :@expr1073750370 true ) ) {
2134: addNamespace (@expr8185 templateDeclaration@var1845 , tok3@var1897 ) ;
2135: }
2136: mTokenList@var100 .@expr7939 addtoken (@expr8501 newName@var1848 , tok3@var1897 ) ;
2137: } else { if (@expr1073750374 !@expr1073750375 Token ::@expr7082 Match (@expr1073750377 tok3@var1897 .@expr7765 next (@expr7766 ) , ":|{|=|;|[|]" ) ) {
2138: tok3@var1897 .@expr7795 str (@expr8504 newName@var1848 ) ; } } }
2139: continue ;
2140: }
2141: }
2142:
2143:
2144: if (@expr7927 copy@var1849 ) {
2145: mTokenList@var100 .@expr7939 addtoken (@expr8532 tok3@var1897 ) ; }
2146:
2147:
2148: if (@expr1073750385 Token ::@expr7279 simpleMatch (@expr1073750387 tok3@var1897 , "template <" ) ) {
2149: Token * tok2@var1925 ; tok2@var1925 =@expr1073750388 findTemplateDeclarationEnd (@expr1073750389 tok3@var1897 ) ;
2150: if (@expr1073750390 tok2@var1925 ) {
2151: templates@var1914 .@expr1073750391 push (@expr1073750392 tok2@var1925 ) ; }
2152: } else { if (@expr1073750393 !@expr1073750394 templates@var1914 .@expr8571 empty (@expr8572 ) &&@expr1073750397 templates@var1914 .@expr1073750398 top (@expr1073750399 ) ==@expr1073750400 tok3@var1897 ) {
2153: templates@var1914 .@expr1073750401 pop (@expr1073750402 ) ; } }
2154:
2155: if (@expr1073750403 Token ::@expr7082 Match (@expr1073750405 tok3@var1897 , "%type% <" ) &&@expr1073750406
2156: !@expr1073750407 Token ::@expr7082 Match (@expr1073750409 tok3@var1897 , "template|static_cast|const_cast|reinterpret_cast|dynamic_cast" ) &&@expr1073750410
2157: Token ::@expr7082 Match (@expr1073750412 tok3@var1897 .@expr7765 next (@expr7766 ) .@expr7890 findClosingBracket (@expr7891 ) , ">|>>" ) ) {
2158: const Token * closingBracket@var1926 ; closingBracket@var1926 =@expr1073750417 tok3@var1897 .@expr7765 next (@expr7766 ) .@expr7890 findClosingBracket (@expr7891 ) ;
2159: if (@expr1073750422 Token ::@expr7279 simpleMatch (@expr1073750424 closingBracket@var1926 .@expr1073750425 next (@expr1073750426 ) , "&" ) ) {
2160: int num@var1927 ; num@var1927 =@expr1073750427 0 ;
2161: const Token * par@var1928 ; par@var1928 =@expr1073750428 tok3@var1897 .@expr7765 next (@expr7766 ) ;
2162: while (@expr1073750431 num@var1927 <@expr8608 typeParametersInDeclaration@var1847 .@expr7196 size (@expr7197 ) &&@expr1073750435 par@var1928 !=@expr8612 closingBracket@var1926 ) {
2163: const std ::@expr1073750437 string pattern@var1929 (@expr1073750438 "[<,] " +@expr1073750439 typeParametersInDeclaration@var1847 [@expr1073750440 num@var1927 ] .@expr1073750441 str (@expr1073750442 ) +@expr1073750443 " [,>]" ) ;
2164: if (@expr1073750444 !@expr1073750445 Token ::@expr7082 Match (@expr1073750447 par@var1928 , pattern@var1929 .@expr1073750448 c_str (@expr1073750449 ) ) ) {
2165: break ; }
2166: ++@expr1073750450 num@var1927 ;
2167: par@var1928 =@expr1073750451 par@var1928 .@expr1073750452 tokAt (@expr1073750453 2 ) ;
2168: }
2169: if (@expr1073750454 num@var1927 <@expr8608 typeParametersInDeclaration@var1847 .@expr7196 size (@expr7197 ) ||@expr1073750458 par@var1928 !=@expr8612 closingBracket@var1926 ) {
2170: continue ; }
2171: }
2172:
2173: std ::@expr1073750460 string scope@var1930 ;
2174: const Token * prev@var1931 ; prev@var1931 =@expr1073750461 tok3@var1897 ;
2175: for (@expr1073750462 ; Token ::@expr7082 Match (@expr1073750464 prev@var1931 .@expr8641 tokAt (@expr8642 -2 ) , "%name% ::" ) ; prev@var1931 =@expr1073750467 prev@var1931 .@expr8641 tokAt (@expr8642 -2 ) ) {
2176: if (@expr8646 scope@var1930 .@expr8647 empty (@expr8648 ) ) {
2177: scope@var1930 =@expr1073750473 prev@var1931 .@expr8650 strAt (@expr8651 -2 ) ; }
2178: else {
2179: scope@var1930 =@expr1073750476 prev@var1931 .@expr8650 strAt (@expr8651 -2 ) +@expr1073750479 " :: " +@expr1073750480 scope@var1930 ; }
2180: }
2181:
2182:
2183: if (@expr1073750481 prev@var1931 .@expr8650 strAt (@expr1073750483 -1 ) !=@expr1073750484 "::" ) {
2184:
2185: std ::@expr1073750485 string token_scope@var1932 ; token_scope@var1932 =@expr1073750486 tok3@var1897 .@expr1073750487 scopeInfo (@expr1073750488 ) .@expr1073750489 name@var2211 ;
2186: std ::@expr6957 string ::@expr1073750491 size_type end@var1933 ; end@var1933 =@expr1073750492 token_scope@var1932 .@expr1073750493 find_last_of (@expr1073750494 " :: " ) ;
2187: if (@expr1073750495 end@var1933 !=@expr1073750496 std ::@expr6957 string ::@expr7267 npos@expr6934 ) {
2188: token_scope@var1932 .@expr1073750499 resize (@expr1073750500 end@var1933 ) ;
2189: if (@expr8646 scope@var1930 .@expr8647 empty (@expr8648 ) ) {
2190: scope@var1930 =@expr1073750504 token_scope@var1932 ; }
2191: else {
2192: scope@var1930 =@expr1073750505 token_scope@var1932 +@expr1073750506 " :: " +@expr1073750507 scope@var1930 ; }
2193: }
2194: }
2195:
2196:
2197: if (@expr1073750508 templates@var1914 .@expr8571 empty (@expr8572 ) ) {
2198: if (@expr7927 copy@var1849 ) {
2199: newInstantiations@var1863 .@expr7534 emplace_back (@expr1073750513 mTokenList@var100 .@expr8017 back (@expr8018 ) , scope@var1930 ) ; }
2200: else { if (@expr1073750516 !@expr1073750517 inTemplateDefinition@var1850 ) {
2201: newInstantiations@var1863 .@expr7534 emplace_back (@expr1073750519 tok3@var1897 , scope@var1930 ) ; } }
2202: }
2203: }
2204:
2205:
2206: else { if (@expr7927 copy@var1849 ) {
2207: if (@expr7794 tok3@var1897 .@expr7795 str (@expr7796 ) ==@expr7797 "{" ) {
2208: brackets@var1912 .@expr8701 push (@expr8702 mTokenList@var100 .@expr8017 back (@expr8018 ) ) ;
2209: } else { if (@expr1073750529 tok3@var1897 .@expr7795 str (@expr7796 ) ==@expr1073750532 "(" ) {
2210: brackets@var1912 .@expr8701 push (@expr8702 mTokenList@var100 .@expr8017 back (@expr8018 ) ) ;
2211: } else { if (@expr1073750537 tok3@var1897 .@expr7795 str (@expr7796 ) ==@expr1073750540 "[" ) {
2212: brackets@var1912 .@expr8701 push (@expr8702 mTokenList@var100 .@expr8017 back (@expr8018 ) ) ;
2213: } else { if (@expr1073750545 tok3@var1897 .@expr7795 str (@expr7796 ) ==@expr1073750548 "}" ) {
2214: assert (@expr8725 brackets@var1912 .@expr8726 empty (@expr8727 ) ==@expr8728 false ) ;
2215: assert (@expr1073750553 brackets@var1912 .@expr8730 top (@expr8731 ) .@expr8732 str (@expr8733 ) ==@expr1073750558 "{" ) ;
2216: Token ::@expr7365 createMutualLinks (@expr8736 brackets@var1912 .@expr8730 top (@expr8731 ) , mTokenList@var100 .@expr8017 back (@expr8018 ) ) ;
2217: if (@expr1073750565 tok3@var1897 .@expr8182 strAt (@expr8544 1 ) ==@expr1073750568 ";" ) {
2218: const Token * tokSemicolon@var1934 ; tokSemicolon@var1934 =@expr1073750569 tok3@var1897 .@expr7765 next (@expr7766 ) ;
2219: mTokenList@var100 .@expr7939 addtoken (@expr1073750573 tokSemicolon@var1934 , tokSemicolon@var1934 .@expr1073750574 linenr (@expr1073750575 ) , tokSemicolon@var1934 .@expr1073750576 column (@expr1073750577 ) , tokSemicolon@var1934 .@expr1073750578 fileIndex (@expr1073750579 ) ) ;
2220: }
2221: brackets@var1912 .@expr8756 pop (@expr8757 ) ;
2222: if (@expr1073750582 brackets@var1912 .@expr8726 empty (@expr8727 ) &&@expr1073750585 !@expr1073750586 Token ::@expr7082 Match (@expr1073750588 tok3@var1897 , "} >|,|{" ) ) {
2223: inTemplateDefinition@var1850 =@expr1073750589 false ;
2224: break ;
2225: }
2226: } else { if (@expr1073750590 tok3@var1897 .@expr7795 str (@expr7796 ) ==@expr1073750593 ")" ) {
2227: assert (@expr8725 brackets@var1912 .@expr8726 empty (@expr8727 ) ==@expr8728 false ) ;
2228: assert (@expr1073750598 brackets@var1912 .@expr8730 top (@expr8731 ) .@expr8732 str (@expr8733 ) ==@expr1073750603 "(" ) ;
2229: Token ::@expr7365 createMutualLinks (@expr8736 brackets@var1912 .@expr8730 top (@expr8731 ) , mTokenList@var100 .@expr8017 back (@expr8018 ) ) ;
2230: brackets@var1912 .@expr8756 pop (@expr8757 ) ;
2231: } else { if (@expr1073750612 tok3@var1897 .@expr7795 str (@expr7796 ) ==@expr1073750615 "]" ) {
2232: assert (@expr8725 brackets@var1912 .@expr8726 empty (@expr8727 ) ==@expr8728 false ) ;
2233: assert (@expr1073750620 brackets@var1912 .@expr8730 top (@expr8731 ) .@expr8732 str (@expr8733 ) ==@expr1073750625 "[" ) ;
2234: Token ::@expr7365 createMutualLinks (@expr8736 brackets@var1912 .@expr8730 top (@expr8731 ) , mTokenList@var100 .@expr8017 back (@expr8018 ) ) ;
2235: brackets@var1912 .@expr8756 pop (@expr8757 ) ;
2236: } } } } } }
2237: } }
2238: }
2239:
2240: assert (@expr1073750634 brackets@var1912 .@expr8726 empty (@expr8727 ) ) ;
2241: }
2242:
2243:
2244: for (@expr1073750637 const auto &@expr7569 inst@var1935 :@expr1073750639 newInstantiations@var1863 ) {
2245: simplifyTemplateArgs (@expr1073750640 inst@var1935 .@expr8817 token@var1936 .@expr8818 tokAt (@expr8819 2 ) , inst@var1935 .@expr8817 token@var1936 .@expr1073750645 next (@expr1073750646 ) .@expr1073750647 findClosingBracket (@expr1073750648 ) ) ;
2246:
2247: if (@expr1073750649 templateDeclaration@var1845 .@expr1073750650 name (@expr1073750651 ) !=@expr1073750652 inst@var1935 .@expr8817 token@var1936 .@expr1073750654 str (@expr1073750655 ) ||@expr1073750656
2248: (@expr1073750657 inst@var1935 .@expr8817 token@var1936 .@expr8818 tokAt (@expr8819 2 ) .@expr1073750661 isNumber (@expr1073750662 ) ||@expr1073750663 inst@var1935 .@expr8817 token@var1936 .@expr8818 tokAt (@expr8819 2 ) .@expr1073750667 isStandardType (@expr1073750668 ) ) ) {
2249: mTemplateInstantiations@var109 .@expr1073750669 emplace_back (@expr1073750670 inst@var1935 .@expr8817 token@var1936 , inst@var1935 .@expr1073750672 scope@var1937 ) ; }
2250: }
2251: }
2252:
2253: static bool isLowerThanLogicalAnd ( const Token * lower@var1938 )
2254: {
2255: return lower@var1938 .@expr1073750673 isAssignmentOp (@expr1073750674 ) ||@expr1073750675 Token ::@expr1073750676 Match (@expr1073750677 lower@var1938 , "}|;|(|[|]|)|,|?|:|%oror%|return|throw|case" ) ;
2256: }
2257: static bool isLowerThanOr ( const Token * lower@var1939 )
2258: {
2259: return isLowerThanLogicalAnd (@expr1073750678 lower@var1939 ) ||@expr1073750679 lower@var1939 .@expr1073750680 str (@expr1073750681 ) ==@expr1073750682 "&&" ;
2260: }
2261: static bool isLowerThanXor ( const Token * lower@var1940 )
2262: {
2263: return isLowerThanOr (@expr1073750683 lower@var1940 ) ||@expr1073750684 lower@var1940 .@expr1073750685 str (@expr1073750686 ) ==@expr1073750687 "|" ;
2264: }
2265: static bool isLowerThanAnd ( const Token * lower@var1941 )
2266: {
2267: return isLowerThanXor (@expr1073750688 lower@var1941 ) ||@expr1073750689 lower@var1941 .@expr1073750690 str (@expr1073750691 ) ==@expr1073750692 "^" ;
2268: }
2269: static bool isLowerThanShift ( const Token * lower@var1942 )
2270: {
2271: return isLowerThanAnd (@expr1073750693 lower@var1942 ) ||@expr1073750694 lower@var1942 .@expr1073750695 str (@expr1073750696 ) ==@expr1073750697 "&" ;
2272: }
2273: static bool isLowerThanPlusMinus ( const Token * lower@var1943 )
2274: {
2275: return isLowerThanShift (@expr1073750698 lower@var1943 ) ||@expr1073750699 Token ::@expr1073750700 Match (@expr1073750701 lower@var1943 , "%comp%|<<|>>" ) ;
2276: }
2277: static bool isLowerThanMulDiv ( const Token * lower@var1944 )
2278: {
2279: return isLowerThanPlusMinus (@expr1073750702 lower@var1944 ) ||@expr1073750703 Token ::@expr1073750704 Match (@expr1073750705 lower@var1944 , "+|-" ) ;
2280: }
2281: static bool isLowerEqualThanMulDiv ( const Token * lower@var1945 )
2282: {
2283: return isLowerThanMulDiv (@expr1073750706 lower@var1945 ) ||@expr1073750707 Token ::@expr1073750708 Match (@expr1073750709 lower@var1945 , "[*/%]" ) ;
2284: }
2285:
2286:
2287: bool TemplateSimplifier :: simplifyNumericCalculations ( Token * tok@var1946 , bool isTemplate@var1947 )
2288: {
2289: bool ret@var1948 ; ret@var1948 =@expr1073750710 false ;
2290:
2291: while (@expr1073750711 tok@var1946 .@expr8888 tokAt (@expr8889 3 ) &&@expr1073750714 tok@var1946 .@expr1073750715 isNumber (@expr1073750716 ) &&@expr1073750717 tok@var1946 .@expr8888 tokAt (@expr1073750719 2 ) .@expr1073750720 isNumber (@expr1073750721 ) ) {
2292: const Token * before@var1949 ; before@var1949 =@expr1073750722 tok@var1946 .@expr8899 previous (@expr8900 ) ;
2293: if (@expr1073750725 !@expr1073750726 before@var1949 ) {
2294: break ; }
2295: const Token * op@var1950 ; op@var1950 =@expr1073750727 tok@var1946 .@expr1073750728 next (@expr1073750729 ) ;
2296: const Token * after@var1951 ; after@var1951 =@expr1073750730 tok@var1946 .@expr8888 tokAt (@expr8889 3 ) ;
2297: const std ::@expr8909 string &@expr8910 num1@var1952 =@expr1073750735 op@var1950 .@expr1073750736 previous (@expr1073750737 ) .@expr1073750738 str (@expr1073750739 ) ;
2298: const std ::@expr8909 string &@expr8910 num2@var1953 =@expr1073750742 op@var1950 .@expr1073750743 next (@expr1073750744 ) .@expr1073750745 str (@expr1073750746 ) ;
2299: if (@expr1073750747 Token ::@expr8924 Match (@expr1073750749 before@var1949 , "* %num% /" ) &&@expr1073750750 (@expr1073750751 num2@var1953 !=@expr1073750752 "0" ) &&@expr1073750753 num1@var1952 ==@expr1073750754 MathLib ::@expr1073750755 multiply (@expr1073750756 num2@var1953 , MathLib ::@expr1073750757 divide (@expr1073750758 num1@var1952 , num2@var1953 ) ) ) {
2300:
2301: } else { if (@expr1073750759 !@expr1073750760 (@expr1073750761 (@expr1073750762 op@var1950 .@expr8939 str (@expr8940 ) ==@expr1073750765 "*" &&@expr1073750766 (@expr1073750767 isLowerThanMulDiv (@expr8944 before@var1949 ) ||@expr1073750769 before@var1949 .@expr1073750770 str (@expr1073750771 ) ==@expr1073750772 "*" ) &&@expr1073750773 isLowerEqualThanMulDiv (@expr8950 after@var1951 ) ) ||@expr1073750775
2302: (@expr1073750776 Token ::@expr8924 Match (@expr1073750778 op@var1950 , "[/%]" ) &&@expr1073750779 isLowerThanMulDiv (@expr8944 before@var1949 ) &&@expr1073750781 isLowerEqualThanMulDiv (@expr8950 after@var1951 ) ) ||@expr1073750783
2303: (@expr1073750784 Token ::@expr8924 Match (@expr1073750786 op@var1950 , "[+-]" ) &&@expr1073750787 isLowerThanMulDiv (@expr8944 before@var1949 ) &&@expr1073750789 isLowerThanMulDiv (@expr1073750790 after@var1951 ) ) ||@expr1073750791
2304: (@expr1073750792 Token ::@expr8924 Match (@expr1073750794 op@var1950 , ">>|<<" ) &&@expr1073750795 isLowerThanShift (@expr8972 before@var1949 ) &&@expr1073750797 isLowerThanPlusMinus (@expr1073750798 after@var1951 ) ) ||@expr1073750799
2305: (@expr1073750800 op@var1950 .@expr8939 str (@expr8940 ) ==@expr1073750803 "&" &&@expr1073750804 isLowerThanShift (@expr8972 before@var1949 ) &&@expr1073750806 isLowerThanShift (@expr1073750807 after@var1951 ) ) ||@expr1073750808
2306: (@expr1073750809 op@var1950 .@expr8939 str (@expr8940 ) ==@expr1073750812 "^" &&@expr1073750813 isLowerThanAnd (@expr1073750814 before@var1949 ) &&@expr1073750815 isLowerThanAnd (@expr1073750816 after@var1951 ) ) ||@expr1073750817
2307: (@expr1073750818 op@var1950 .@expr8939 str (@expr8940 ) ==@expr1073750821 "|" &&@expr1073750822 isLowerThanXor (@expr1073750823 before@var1949 ) &&@expr1073750824 isLowerThanXor (@expr1073750825 after@var1951 ) ) ||@expr1073750826
2308: (@expr1073750827 op@var1950 .@expr8939 str (@expr8940 ) ==@expr1073750830 "&&" &&@expr1073750831 isLowerThanOr (@expr1073750832 before@var1949 ) &&@expr1073750833 isLowerThanOr (@expr1073750834 after@var1951 ) ) ||@expr1073750835
2309: (@expr1073750836 op@var1950 .@expr8939 str (@expr8940 ) ==@expr9015 "||" &&@expr1073750840 isLowerThanLogicalAnd (@expr1073750841 before@var1949 ) &&@expr1073750842 isLowerThanLogicalAnd (@expr1073750843 after@var1951 ) ) ) ) {
2310: break ; } }
2311:
2312:
2313: if (@expr1073750844 Token ::@expr8924 Match (@expr1073750846 op@var1950 , "[/%] 0" ) ) {
2314: if (@expr1073750847 isTemplate@var1947 ) { throw InternalError (@expr1073750848 op@var1950 , "Instantiation error: Divide by zero in template instantiation." , InternalError ::@expr1073750849 INSTANTIATION ) ; }
2315: else { return ret@var1948 ; }
2316: }
2317:
2318:
2319: if (@expr1073750850 Token ::@expr8924 Match (@expr1073750852 op@var1950 , ">>|<<|&|^|%or%" ) ) {
2320:
2321:
2322:
2323: if (@expr1073750853 MathLib ::@expr9030 isNegative (@expr1073750855 num1@var1952 ) ||@expr1073750856 MathLib ::@expr9030 isNegative (@expr1073750858 num2@var1953 ) ) {
2324: break ; }
2325:
2326: const MathLib ::@expr1073750859 value v1@var1954 (@expr1073750860 num1@var1952 ) ;
2327: const MathLib ::@expr1073750861 value v2@var1955 (@expr1073750862 num2@var1953 ) ;
2328:
2329: if (@expr1073750863 !@expr1073750864 v1@var1954 .@expr1073750865 isInt (@expr1073750866 ) ||@expr1073750867 !@expr1073750868 v2@var1955 .@expr1073750869 isInt (@expr1073750870 ) ) {
2330: break ; }
2331:
2332: switch (@expr1073750871 op@var1950 .@expr8939 str (@expr8940 ) [@expr9050 0 ] ) {
2333: case '<' :@expr9051 ;
2334: tok@var1946 .@expr9052 str (@expr1073750877 (@expr1073750878 v1@var1954 <<@expr1073750879 v2@var1955 ) .@expr1073750880 str (@expr1073750881 ) ) ;
2335: break ;
2336: case '>' :@expr9051 ;
2337: tok@var1946 .@expr9052 str (@expr1073750884 (@expr1073750885 v1@var1954 >>@expr1073750886 v2@var1955 ) .@expr1073750887 str (@expr1073750888 ) ) ;
2338: break ;
2339: case '&' :@expr9051 ;
2340: tok@var1946 .@expr9052 str (@expr1073750891 (@expr1073750892 v1@var1954 &@expr1073750893 v2@var1955 ) .@expr1073750894 str (@expr1073750895 ) ) ;
2341: break ;
2342: case '|' :@expr9051 ;
2343: tok@var1946 .@expr9052 str (@expr1073750898 (@expr1073750899 v1@var1954 |@expr1073750900 v2@var1955 ) .@expr1073750901 str (@expr1073750902 ) ) ;
2344: break ;
2345: case '^' :@expr9051 ;
2346: tok@var1946 .@expr9052 str (@expr1073750905 (@expr1073750906 v1@var1954 ^@expr1073750907 v2@var1955 ) .@expr1073750908 str (@expr1073750909 ) ) ;
2347: break ;
2348: }
2349: }
2350:
2351:
2352: else { if (@expr1073750910 Token ::@expr8924 Match (@expr1073750912 op@var1950 , "%oror%|&&" ) ) {
2353: const bool op1@var1956 =@expr1073750913 !@expr1073750914 MathLib ::@expr9091 isNullValue (@expr1073750916 num1@var1952 ) ;
2354: const bool op2@var1957 =@expr1073750917 !@expr1073750918 MathLib ::@expr9091 isNullValue (@expr1073750920 num2@var1953 ) ;
2355: const bool result@var1958 =@expr1073750921 (@expr1073750922 op@var1950 .@expr8939 str (@expr8940 ) ==@expr9015 "||" ) ?@expr1073750926 (@expr1073750927 op1@var1956 ||@expr1073750928 op2@var1957 ) :@expr1073750929 (@expr1073750930 op1@var1956 &&@expr1073750931 op2@var1957 ) ;
2356: tok@var1946 .@expr9052 str (@expr1073750933 result@var1958 ?@expr1073750934 "1" :@expr1073750935 "0" ) ;
2357: }
2358:
2359: else { if (@expr1073750936 Token ::@expr8924 Match (@expr1073750938 tok@var1946 .@expr8899 previous (@expr8900 ) , "- %num% - %num%" ) ) {
2360: tok@var1946 .@expr9052 str (@expr1073750942 MathLib ::@expr1073750943 add (@expr1073750944 num1@var1952 , num2@var1953 ) ) ; }
2361: else { if (@expr1073750945 Token ::@expr8924 Match (@expr1073750947 tok@var1946 .@expr8899 previous (@expr8900 ) , "- %num% + %num%" ) ) {
2362: tok@var1946 .@expr9052 str (@expr1073750951 MathLib ::@expr1073750952 subtract (@expr1073750953 num1@var1952 , num2@var1953 ) ) ; }
2363: else {
2364: try {
2365: tok@var1946 .@expr9052 str (@expr1073750955 MathLib ::@expr1073750956 calculate (@expr1073750957 num1@var1952 , num2@var1953 , op@var1950 .@expr8939 str (@expr8940 ) [@expr9050 0 ] ) ) ;
2366: } catch (@expr1073750961 InternalError & e@var1959 ) {
2367: e@var1959 .@expr1073750962 token@var1960 =@expr1073750963 tok@var1946 ;
2368: throw ;
2369: }
2370: } } } }
2371:
2372: tok@var1946 .@expr1073750964 deleteNext (@expr1073750965 2 ) ;
2373:
2374: ret@var1948 =@expr1073750966 true ;
2375: }
2376:
2377: return ret@var1948 ;
2378: }
2379:
2380: static Token * skipTernaryOp ( Token * tok@var1961 , const Token * backToken@var1962 )
2381: {
2382: unsigned int colonLevel@var1963 ; colonLevel@var1963 =@expr1073750967 1 ;
2383: while (@expr1073750968 nullptr !=@expr1073750969 (@expr1073750970 tok@var1961 =@expr1073750971 tok@var1961 .@expr9148 next (@expr9149 ) ) ) {
2384: if (@expr1073750974 tok@var1961 .@expr9151 str (@expr9152 ) ==@expr1073750977 "?" ) {
2385: ++@expr1073750978 colonLevel@var1963 ;
2386: } else { if (@expr1073750979 tok@var1961 .@expr9151 str (@expr9152 ) ==@expr1073750982 ":" ) {
2387: --@expr1073750983 colonLevel@var1963 ;
2388: if (@expr1073750984 colonLevel@var1963 ==@expr1073750985 0 ) {
2389: tok@var1961 =@expr1073750986 tok@var1961 .@expr9148 next (@expr9149 ) ;
2390: break ;
2391: }
2392: } }
2393: if (@expr1073750989 tok@var1961 .@expr9166 link (@expr9167 ) &&@expr1073750992 tok@var1961 .@expr9151 str (@expr9152 ) ==@expr1073750995 "(" ) {
2394: tok@var1961 =@expr1073750996 tok@var1961 .@expr9166 link (@expr9167 ) ; }
2395: else { if (@expr1073750999 Token ::@expr1073751000 Match (@expr1073751001 tok@var1961 .@expr9148 next (@expr9149 ) , "[{};)]" ) ||@expr1073751004 tok@var1961 .@expr9148 next (@expr9149 ) ==@expr1073751007 backToken@var1962 ) {
2396: break ; } }
2397: }
2398: if (@expr1073751008 colonLevel@var1963 >@expr1073751009 0 ) {
2399: return nullptr ; }
2400: return tok@var1961 ;
2401: }
2402:
2403: void TemplateSimplifier :: simplifyTemplateArgs ( Token * start@var1964 , Token * end@var1965 )
2404: {
2405:
2406: Token * first@var1966 ; first@var1966 =@expr1073751010 (@expr1073751011 start@var1964 &&@expr1073751012 start@var1964 .@expr9189 previous (@expr9190 ) ) ?@expr1073751015 start@var1964 .@expr9189 previous (@expr9190 ) :@expr1073751018 mTokenList@var100 .@expr1073751019 front (@expr1073751020 ) ;
2407: bool again@var1967 ; again@var1967 =@expr1073751021 true ;
2408:
2409: while (@expr1073751022 again@var1967 ) {
2410: again@var1967 =@expr1073751023 false ;
2411:
2412: for (@expr1073751024 Token *@expr9201 tok@var1968 =@expr1073751026 first@var1966 .@expr9203 next (@expr9204 ) ; tok@var1968 &&@expr1073751029 tok@var1968 !=@expr1073751030 end@var1965 ; tok@var1968 =@expr1073751031 tok@var1968 .@expr9208 next (@expr9209 ) ) {
2413: if (@expr1073751034 tok@var1968 .@expr9211 str (@expr9212 ) ==@expr1073751037 "sizeof" ) {
2414:
2415: if (@expr1073751038 Token ::@expr9215 Match (@expr1073751040 tok@var1968 .@expr9208 next (@expr9209 ) , "( %char% )" ) ) {
2416: tok@var1968 .@expr9219 deleteNext (@expr9220 ) ;
2417: tok@var1968 .@expr9221 deleteThis (@expr9222 ) ;
2418: tok@var1968 .@expr9219 deleteNext (@expr9220 ) ;
2419: std ::@expr1073751049 ostringstream sz@var1969 ;
2420: sz@var1969 <<@expr1073751050 1 ;
2421: tok@var1968 .@expr9211 str (@expr1073751052 sz@var1969 .@expr1073751053 str (@expr1073751054 ) ) ;
2422: again@var1967 =@expr1073751055 true ;
2423: }
2424:
2425:
2426: else { if (@expr1073751056 Token ::@expr9215 Match (@expr1073751058 tok@var1968 .@expr9208 next (@expr9209 ) , "( %str% )" ) ) {
2427: tok@var1968 .@expr9219 deleteNext (@expr9220 ) ;
2428: tok@var1968 .@expr9221 deleteThis (@expr9222 ) ;
2429: tok@var1968 .@expr9219 deleteNext (@expr9220 ) ;
2430: std ::@expr1073751067 ostringstream ostr@var1970 ;
2431: ostr@var1970 <<@expr1073751068 (@expr1073751069 Token ::@expr1073751070 getStrLength (@expr1073751071 tok@var1968 ) +@expr1073751072 1 ) ;
2432: tok@var1968 .@expr9211 str (@expr1073751074 ostr@var1970 .@expr1073751075 str (@expr1073751076 ) ) ;
2433: again@var1967 =@expr1073751077 true ;
2434: }
2435:
2436: else { if (@expr1073751078 Token ::@expr9215 Match (@expr1073751080 tok@var1968 .@expr9208 next (@expr9209 ) , "( %type% * )" ) ) {
2437: tok@var1968 .@expr9211 str (@expr1073751084 MathLib ::@expr9261 toString (@expr1073751086 mTokenizer@var99 .@expr9263 sizeOfType (@expr1073751088 tok@var1968 .@expr9265 tokAt (@expr9266 3 ) ) ) ) ;
2438: tok@var1968 .@expr9219 deleteNext (@expr1073751092 4 ) ;
2439: again@var1967 =@expr1073751093 true ;
2440: } else { if (@expr1073751094 Token ::@expr1073751095 simpleMatch (@expr1073751096 tok@var1968 .@expr9208 next (@expr9209 ) , "( * )" ) ) {
2441: tok@var1968 .@expr9211 str (@expr1073751100 MathLib ::@expr9261 toString (@expr1073751102 mTokenizer@var99 .@expr9263 sizeOfType (@expr9280 tok@var1968 .@expr9265 tokAt (@expr9282 2 ) ) ) ) ;
2442: tok@var1968 .@expr9219 deleteNext (@expr9284 3 ) ;
2443: again@var1967 =@expr1073751109 true ;
2444: } else { if (@expr1073751110 Token ::@expr9215 Match (@expr1073751112 tok@var1968 .@expr9208 next (@expr9209 ) , "( %type% )" ) ) {
2445: const unsigned int size@var1971 =@expr1073751115 mTokenizer@var99 .@expr9263 sizeOfType (@expr9280 tok@var1968 .@expr9265 tokAt (@expr9282 2 ) ) ;
2446: if (@expr1073751120 size@var1971 >@expr1073751121 0 ) {
2447: tok@var1968 .@expr9211 str (@expr1073751123 MathLib ::@expr9261 toString (@expr1073751125 size@var1971 ) ) ;
2448: tok@var1968 .@expr9219 deleteNext (@expr9284 3 ) ;
2449: again@var1967 =@expr1073751128 true ;
2450: }
2451: } else { if (@expr1073751129 tok@var1968 .@expr9306 strAt (@expr1073751131 1 ) ==@expr1073751132 "(" ) {
2452: tok@var1968 =@expr1073751133 tok@var1968 .@expr1073751134 linkAt (@expr1073751135 1 ) ;
2453: } } } } } }
2454: } else { if (@expr1073751136 Token ::@expr9215 Match (@expr1073751138 tok@var1968 , "%num% %comp% %num%" ) &&@expr1073751139
2455: MathLib ::@expr9316 isInt (@expr1073751141 tok@var1968 .@expr9211 str (@expr9212 ) ) &&@expr1073751144
2456: MathLib ::@expr9316 isInt (@expr1073751146 tok@var1968 .@expr9306 strAt (@expr9324 2 ) ) ) {
2457: if (@expr1073751149 (@expr1073751150 Token ::@expr9215 Match (@expr1073751152 tok@var1968 .@expr9329 previous (@expr9330 ) , "(|&&|%oror%|," ) ||@expr1073751155 tok@var1968 ==@expr1073751156 start@var1964 ) &&@expr1073751157
2458: (@expr1073751158 Token ::@expr9215 Match (@expr1073751160 tok@var1968 .@expr9265 tokAt (@expr9266 3 ) , ")|&&|%oror%|?" ) ||@expr1073751163 tok@var1968 .@expr9265 tokAt (@expr9266 3 ) ==@expr1073751166 end@var1965 ) ) {
2459: const long long op1@var1972 (@expr1073751167 MathLib ::@expr9344 toLongNumber (@expr1073751169 tok@var1968 .@expr9211 str (@expr9212 ) ) ) ;
2460: const std ::@expr1073751172 string & cmp@var1973 (@expr1073751173 tok@var1968 .@expr9208 next (@expr9209 ) .@expr1073751176 str (@expr1073751177 ) ) ;
2461: const long long op2@var1974 (@expr1073751178 MathLib ::@expr9344 toLongNumber (@expr1073751180 tok@var1968 .@expr9306 strAt (@expr9324 2 ) ) ) ;
2462:
2463: std ::@expr1073751183 string result@var1975 ;
2464:
2465: if (@expr1073751184 cmp@var1973 ==@expr1073751185 "==" ) {
2466: result@var1975 =@expr1073751186 (@expr1073751187 op1@var1972 ==@expr1073751188 op2@var1974 ) ?@expr1073751189 "true" :@expr9366 "false" ; }
2467: else { if (@expr1073751191 cmp@var1973 ==@expr1073751192 "!=" ) {
2468: result@var1975 =@expr1073751193 (@expr1073751194 op1@var1972 !=@expr1073751195 op2@var1974 ) ?@expr1073751196 "true" :@expr9366 "false" ; }
2469: else { if (@expr1073751198 cmp@var1973 ==@expr1073751199 "<=" ) {
2470: result@var1975 =@expr1073751200 (@expr1073751201 op1@var1972 <=@expr1073751202 op2@var1974 ) ?@expr1073751203 "true" :@expr9366 "false" ; }
2471: else { if (@expr1073751205 cmp@var1973 ==@expr1073751206 ">=" ) {
2472: result@var1975 =@expr1073751207 (@expr1073751208 op1@var1972 >=@expr1073751209 op2@var1974 ) ?@expr1073751210 "true" :@expr9366 "false" ; }
2473: else { if (@expr1073751212 cmp@var1973 ==@expr1073751213 "<" ) {
2474: result@var1975 =@expr1073751214 (@expr1073751215 op1@var1972 <@expr1073751216 op2@var1974 ) ?@expr1073751217 "true" :@expr9366 "false" ; }
2475: else {
2476: result@var1975 =@expr1073751219 (@expr1073751220 op1@var1972 >@expr1073751221 op2@var1974 ) ?@expr1073751222 "true" :@expr9366 "false" ; } } } } }
2477:
2478: tok@var1968 .@expr9211 str (@expr1073751225 result@var1975 ) ;
2479: tok@var1968 .@expr9219 deleteNext (@expr1073751227 2 ) ;
2480: again@var1967 =@expr1073751228 true ;
2481: tok@var1968 =@expr1073751229 tok@var1968 .@expr9329 previous (@expr9330 ) ;
2482: }
2483: } }
2484: }
2485:
2486: if (@expr1073751232 simplifyCalculations (@expr1073751233 first@var1966 .@expr9203 next (@expr9204 ) , end@var1965 ) ) {
2487: again@var1967 =@expr1073751236 true ; }
2488:
2489: for (@expr1073751237 Token *@expr9201 tok@var1976 =@expr1073751239 first@var1966 .@expr9203 next (@expr9204 ) ; tok@var1976 &&@expr1073751242 tok@var1976 !=@expr1073751243 end@var1965 ; tok@var1976 =@expr1073751244 tok@var1976 .@expr9421 next (@expr9422 ) ) {
2490: if (@expr1073751247 tok@var1976 .@expr1073751248 str (@expr1073751249 ) ==@expr1073751250 "?" &&@expr1073751251
2491: (@expr1073751252 (@expr1073751253 tok@var1976 .@expr9430 previous (@expr9431 ) .@expr1073751256 isNumber (@expr1073751257 ) ||@expr1073751258 tok@var1976 .@expr9430 previous (@expr9431 ) .@expr1073751261 isBoolean (@expr1073751262 ) ) ||@expr1073751263
2492: Token ::@expr9215 Match (@expr1073751265 tok@var1976 .@expr9442 tokAt (@expr1073751267 -3 ) , "( %bool%|%num% )" ) ) ) {
2493: const int offset@var1977 =@expr1073751268 (@expr1073751269 tok@var1976 .@expr9430 previous (@expr9431 ) .@expr1073751272 str (@expr1073751273 ) ==@expr1073751274 ")" ) ?@expr1073751275 2 :@expr1073751276 1 ;
2494:
2495:
2496: Token * colon@var1978 ; colon@var1978 =@expr1073751277 skipTernaryOp (@expr1073751278 tok@var1976 , end@var1965 ) ;
2497: if (@expr1073751279 !@expr1073751280 colon@var1978 ||@expr1073751281 colon@var1978 .@expr9458 previous (@expr9459 ) .@expr1073751284 str (@expr1073751285 ) !=@expr1073751286 ":" ||@expr1073751287 !@expr1073751288 colon@var1978 .@expr1073751289 next (@expr1073751290 ) ) {
2498: continue ; }
2499:
2500:
2501: if (@expr1073751291 colon@var1978 .@expr9458 previous (@expr9459 ) ==@expr1073751294 tok@var1976 .@expr9421 next (@expr9422 ) ) {
2502: tok@var1976 .@expr1073751297 insertToken (@expr1073751298 tok@var1976 .@expr1073751299 strAt (@expr1073751300 -@expr1073751301 offset@var1977 ) ) ; }
2503:
2504:
2505: tok@var1976 =@expr1073751302 tok@var1976 .@expr9442 tokAt (@expr9480 -2 ) ;
2506: if (@expr1073751305 offset@var1977 ==@expr1073751306 2 ) {
2507:
2508: tok@var1976 =@expr1073751307 tok@var1976 .@expr9442 tokAt (@expr9480 -2 ) ;
2509:
2510: tok@var1976 .@expr9486 deleteNext (@expr1073751311 ) ;
2511: tok@var1976 .@expr9421 next (@expr9422 ) .@expr1073751314 deleteNext (@expr1073751315 ) ;
2512: }
2513:
2514: if (@expr1073751316 Token ::@expr9215 Match (@expr1073751318 tok@var1976 .@expr9421 next (@expr9422 ) , "false|0" ) ) {
2515:
2516: Token ::@expr9497 eraseTokens (@expr1073751322 tok@var1976 , colon@var1978 ) ;
2517:
2518: tok@var1976 =@expr1073751323 tok@var1976 .@expr9421 next (@expr9422 ) ;
2519: again@var1967 =@expr1073751326 true ;
2520: }
2521:
2522:
2523: else {
2524:
2525: tok@var1976 .@expr9486 deleteNext (@expr1073751328 2 ) ;
2526:
2527: unsigned int ternaryOplevel@var1979 ; ternaryOplevel@var1979 =@expr1073751329 0 ;
2528: for (@expr1073751330 const Token *@expr9201 endTok@var1980 =@expr1073751332 colon@var1978 ; endTok@var1980 ; endTok@var1980 =@expr1073751333 endTok@var1980 .@expr1073751334 next (@expr1073751335 ) ) {
2529: if (@expr1073751336 Token ::@expr9215 Match (@expr1073751338 endTok@var1980 , "(|[|{" ) ) {
2530: endTok@var1980 =@expr1073751339 endTok@var1980 .@expr1073751340 link (@expr1073751341 ) ; }
2531: else { if (@expr1073751342 endTok@var1980 .@expr9519 str (@expr9520 ) ==@expr1073751345 "<" &&@expr1073751346 (@expr1073751347 endTok@var1980 .@expr1073751348 strAt (@expr1073751349 1 ) ==@expr1073751350 ">" ||@expr1073751351 templateParameters (@expr1073751352 endTok@var1980 ) ) ) {
2532: endTok@var1980 =@expr1073751353 endTok@var1980 .@expr1073751354 findClosingBracket (@expr1073751355 ) ; }
2533: else { if (@expr1073751356 endTok@var1980 .@expr9519 str (@expr9520 ) ==@expr1073751359 "?" ) {
2534: ++@expr1073751360 ternaryOplevel@var1979 ; }
2535: else { if (@expr1073751361 Token ::@expr9215 Match (@expr1073751363 endTok@var1980 , ")|}|]|;|,|:|>" ) ) {
2536: if (@expr1073751364 endTok@var1980 .@expr9519 str (@expr9520 ) ==@expr1073751367 ":" &&@expr1073751368 ternaryOplevel@var1979 ) {
2537: --@expr1073751369 ternaryOplevel@var1979 ; }
2538: else { if (@expr1073751370 endTok@var1980 .@expr9519 str (@expr9520 ) ==@expr1073751373 ">" &&@expr1073751374 !@expr1073751375 end@var1965 ) {
2539: ; }
2540: else {
2541: Token ::@expr9497 eraseTokens (@expr1073751377 colon@var1978 .@expr1073751378 tokAt (@expr1073751379 -2 ) , endTok@var1980 ) ;
2542: again@var1967 =@expr1073751380 true ;
2543: break ;
2544: } }
2545: } } } }
2546: }
2547: }
2548: }
2549: }
2550:
2551: for (@expr1073751381 Token *@expr9201 tok@var1981 =@expr1073751383 first@var1966 .@expr9203 next (@expr9204 ) ; tok@var1981 &&@expr1073751386 tok@var1981 !=@expr1073751387 end@var1965 ; tok@var1981 =@expr1073751388 tok@var1981 .@expr1073751389 next (@expr1073751390 ) ) {
2552: if (@expr1073751391 Token ::@expr9215 Match (@expr1073751393 tok@var1981 , "( %num%|%bool% )" ) &&@expr1073751394
2553: (@expr1073751395 tok@var1981 .@expr9572 previous (@expr9573 ) &&@expr1073751398 !@expr1073751399 Token ::@expr9215 Match (@expr1073751401 tok@var1981 .@expr9572 previous (@expr9573 ) , "%name%" ) ) ) {
2554: tok@var1981 .@expr1073751404 deleteThis (@expr1073751405 ) ;
2555: tok@var1981 .@expr1073751406 deleteNext (@expr1073751407 ) ;
2556: again@var1967 =@expr1073751408 true ;
2557: }
2558: }
2559: }
2560: }
2561:
2562: static bool validTokenStart ( bool bounded@var1982 , const Token * tok@var1983 , const Token * frontToken@var1984 , int offset@var1985 )
2563: {
2564: if (@expr1073751409 !@expr1073751410 bounded@var1982 ) {
2565: return true ; }
2566:
2567: if (@expr1073751411 frontToken@var1984 ) {
2568: frontToken@var1984 =@expr1073751412 frontToken@var1984 .@expr1073751413 previous (@expr1073751414 ) ; }
2569:
2570: while (@expr1073751415 tok@var1983 &&@expr1073751416 offset@var1985 <=@expr1073751417 0 ) {
2571: if (@expr1073751418 tok@var1983 ==@expr1073751419 frontToken@var1984 ) {
2572: return false ; }
2573: ++@expr1073751420 offset@var1985 ;
2574: tok@var1983 =@expr1073751421 tok@var1983 .@expr1073751422 previous (@expr1073751423 ) ;
2575: }
2576:
2577: return tok@var1983 &&@expr1073751424 offset@var1985 >@expr1073751425 0 ;
2578: }
2579:
2580: static bool validTokenEnd ( bool bounded@var1986 , const Token * tok@var1987 , const Token * backToken@var1988 , int offset@var1989 )
2581: {
2582: if (@expr1073751426 !@expr1073751427 bounded@var1986 ) {
2583: return true ; }
2584:
2585: while (@expr1073751428 tok@var1987 &&@expr1073751429 offset@var1989 >=@expr1073751430 0 ) {
2586: if (@expr1073751431 tok@var1987 ==@expr1073751432 backToken@var1988 ) {
2587: return false ; }
2588: --@expr1073751433 offset@var1989 ;
2589: tok@var1987 =@expr1073751434 tok@var1987 .@expr1073751435 next (@expr1073751436 ) ;
2590: }
2591:
2592: return tok@var1987 &&@expr1073751437 offset@var1989 <@expr1073751438 0 ;
2593: }
2594:
2595:
2596:
2597: bool TemplateSimplifier :: simplifyCalculations ( Token * frontToken@var1990 , Token * backToken@var1991 , bool isTemplate@var1992 )
2598: {
2599: bool ret@var1993 ; ret@var1993 =@expr1073751440 false ;
2600: const bool bounded@var1994 =@expr1073751441 frontToken@var1990 ||@expr1073751442 backToken@var1991 ;
2601: if (@expr1073751443 !@expr1073751444 frontToken@var1990 ) {
2602: frontToken@var1990 =@expr1073751445 mTokenList@var100 .@expr1073751446 front (@expr1073751447 ) ;
2603: }
2604: for (@expr1073751448 Token *@expr1073751449 tok@var1995 =@expr1073751450 frontToken@var1990 ; tok@var1995 &&@expr1073751451 tok@var1995 !=@expr1073751452 backToken@var1991 ; tok@var1995 =@expr1073751453 tok@var1995 .@expr9630 next (@expr9631 ) ) {
2605:
|
2612:
2613: if (@expr1073751456 validTokenEnd (@expr9633 bounded@var1994 , tok@var1995 , backToken@var1991 , 4 ) &&@expr1073751458
2614: (@expr1073751459 Token ::@expr9636 Match (@expr1073751461 tok@var1995 .@expr9630 next (@expr9631 ) , "( %name% ) ;|)|,|]" ) ||@expr1073751464
2615: (@expr1073751465 Token ::@expr9636 Match (@expr1073751467 tok@var1995 .@expr9630 next (@expr9631 ) , "( %name% ) %cop%" ) &&@expr1073751470
2616: (@expr1073751471 tok@var1995 .@expr9648 tokAt (@expr1073751473 2 ) .@expr1073751474 varId (@expr1073751475 ) >@expr1073751476 0 ||@expr1073751477
2617: !@expr1073751478 Token ::@expr9636 Match (@expr1073751480 tok@var1995 .@expr9648 tokAt (@expr1073751482 4 ) , "[*&+-~]" ) ) ) ) &&@expr1073751483
2618: !@expr1073751484 tok@var1995 .@expr1073751485 isName (@expr1073751486 ) &&@expr1073751487
2619: tok@var1995 .@expr9664 str (@expr9665 ) !=@expr1073751490 ">" &&@expr1073751491
2620: tok@var1995 .@expr9664 str (@expr9665 ) !=@expr1073751494 ")" &&@expr1073751495
2621: tok@var1995 .@expr9664 str (@expr9665 ) !=@expr1073751498 "]" ) {
2622: tok@var1995 .@expr9675 deleteNext (@expr9676 ) ;
2623: tok@var1995 =@expr1073751501 tok@var1995 .@expr9630 next (@expr9631 ) ;
2624: tok@var1995 .@expr9675 deleteNext (@expr9676 ) ;
2625: ret@var1993 =@expr1073751506 true ;
2626: }
2627:
2628: if (@expr1073751507 validTokenEnd (@expr9684 bounded@var1994 , tok@var1995 , backToken@var1991 , 3 ) &&@expr1073751509
2629: Token ::@expr9636 Match (@expr1073751511 tok@var1995 .@expr9688 previous (@expr9689 ) , "(|&&|%oror% %char% %comp% %num% &&|%oror%|)" ) ) {
2630: tok@var1995 .@expr9664 str (@expr1073751515 MathLib ::@expr1073751516 toString (@expr1073751517 MathLib ::@expr9694 toLongNumber (@expr9695 tok@var1995 .@expr9664 str (@expr9665 ) ) ) ) ;
2631: }
2632:
2633: if (@expr1073751522 validTokenEnd (@expr1073751523 bounded@var1994 , tok@var1995 , backToken@var1991 , 5 ) &&@expr1073751524
2634: Token ::@expr9636 Match (@expr1073751526 tok@var1995 , "decltype ( %type% { } )" ) ) {
2635: tok@var1995 .@expr9703 deleteThis (@expr9704 ) ;
2636: tok@var1995 .@expr9703 deleteThis (@expr9704 ) ;
2637: tok@var1995 .@expr9675 deleteNext (@expr9676 ) ;
2638: tok@var1995 .@expr9675 deleteNext (@expr9676 ) ;
2639: tok@var1995 .@expr9675 deleteNext (@expr9676 ) ;
2640: ret@var1993 =@expr1073751537 true ;
2641: }
2642:
2643: if (@expr1073751538 validTokenEnd (@expr9684 bounded@var1994 , tok@var1995 , backToken@var1991 , 3 ) &&@expr1073751540
2644: Token ::@expr9636 Match (@expr1073751542 tok@var1995 , "decltype ( %bool%|%num% )" ) ) {
2645: tok@var1995 .@expr9703 deleteThis (@expr9704 ) ;
2646: tok@var1995 .@expr9703 deleteThis (@expr9704 ) ;
2647: if (@expr1073751547 tok@var1995 .@expr1073751548 isBoolean (@expr1073751549 ) ) {
2648: tok@var1995 .@expr9664 str (@expr1073751551 "bool" ) ; }
2649: else { if (@expr1073751552 MathLib ::@expr1073751553 isFloat (@expr1073751554 tok@var1995 .@expr9664 str (@expr9665 ) ) ) {
2650:
2651: char suffix@var1996 ; suffix@var1996 =@expr1073751557 tok@var1995 .@expr9664 str (@expr9665 ) .@expr1073751560 back (@expr1073751561 ) ;
2652: if (@expr1073751562 suffix@var1996 ==@expr1073751563 'f' ||@expr1073751564 suffix@var1996 ==@expr1073751565 'F' ) {
2653: tok@var1995 .@expr9664 str (@expr1073751567 "float" ) ; }
2654: else { if (@expr1073751568 suffix@var1996 ==@expr1073751569 'l' ||@expr1073751570 suffix@var1996 ==@expr1073751571 'L' ) {
2655: tok@var1995 .@expr9664 str (@expr9749 "double" ) ;
2656: tok@var1995 .@expr9750 isLong (@expr9751 true ) ;
2657: } else {
2658: tok@var1995 .@expr9664 str (@expr9749 "double" ) ; } }
2659: } else { if (@expr1073751578 MathLib ::@expr9755 isInt (@expr9756 tok@var1995 .@expr9664 str (@expr9665 ) ) ) {
2660: std ::@expr1073751583 string suffix@var1997 ; suffix@var1997 =@expr1073751584 MathLib ::@expr1073751585 getSuffix (@expr1073751586 tok@var1995 .@expr9664 str (@expr9665 ) ) ;
2661: if (@expr1073751589 suffix@var1997 .@expr9766 find (@expr1073751591 "LL" ) !=@expr1073751592 std ::@expr9769 string ::@expr9770 npos@expr9615 ) {
2662: tok@var1995 .@expr9664 str (@expr9772 "long" ) ;
2663: tok@var1995 .@expr9750 isLong (@expr9751 true ) ;
2664: } else { if (@expr1073751599 suffix@var1997 .@expr9766 find (@expr1073751601 'L' ) !=@expr1073751602 std ::@expr9769 string ::@expr9770 npos@expr9615 ) {
2665: tok@var1995 .@expr9664 str (@expr9772 "long" ) ; }
2666: else {
2667: tok@var1995 .@expr9664 str (@expr1073751608 "int" ) ; } }
2668: tok@var1995 .@expr9785 isUnsigned (@expr1073751610 suffix@var1997 .@expr9766 find (@expr1073751612 'U' ) !=@expr1073751613 std ::@expr9769 string ::@expr9770 npos@expr9615 ) ;
2669: } } }
2670: tok@var1995 .@expr9675 deleteNext (@expr9676 ) ;
2671: ret@var1993 =@expr1073751618 true ;
2672: }
2673:
2674: if (@expr1073751619 validTokenEnd (@expr9796 bounded@var1994 , tok@var1995 , backToken@var1991 , 2 ) &&@expr1073751621
2675: (@expr1073751622 Token ::@expr9636 Match (@expr1073751624 tok@var1995 , "char|short|int|long { }" ) ||@expr1073751625
2676: Token ::@expr9636 Match (@expr1073751627 tok@var1995 , "char|short|int|long ( )" ) ) ) {
2677: tok@var1995 .@expr9664 str (@expr1073751629 "0" ) ;
2678: tok@var1995 .@expr1073751630 isSigned (@expr1073751631 false ) ;
2679: tok@var1995 .@expr9785 isUnsigned (@expr1073751633 false ) ;
2680: tok@var1995 .@expr9750 isLong (@expr1073751635 false ) ;
2681: tok@var1995 .@expr9675 deleteNext (@expr9676 ) ;
2682: tok@var1995 .@expr9675 deleteNext (@expr9676 ) ;
2683: ret@var1993 =@expr1073751640 true ;
2684: }
2685:
2686: if (@expr1073751641 tok@var1995 &&@expr1073751642 tok@var1995 .@expr1073751643 isNumber (@expr1073751644 ) ) {
2687: if (@expr1073751645 validTokenEnd (@expr9796 bounded@var1994 , tok@var1995 , backToken@var1991 , 2 ) &&@expr1073751647
2688: simplifyNumericCalculations (@expr1073751648 tok@var1995 , isTemplate@var1992 ) ) {
2689: ret@var1993 =@expr1073751649 true ;
2690: Token * prev@var1998 ; prev@var1998 =@expr1073751650 tok@var1995 .@expr9648 tokAt (@expr9828 -2 ) ;
2691: while (@expr1073751653 validTokenStart (@expr9830 bounded@var1994 , tok@var1995 , frontToken@var1990 , -2 ) &&@expr1073751655
2692: prev@var1998 &&@expr1073751656 simplifyNumericCalculations (@expr1073751657 prev@var1998 , isTemplate@var1992 ) ) {
2693: tok@var1995 =@expr1073751658 prev@var1998 ;
2694: prev@var1998 =@expr1073751659 prev@var1998 .@expr1073751660 tokAt (@expr1073751661 -2 ) ;
2695: }
2696: }
2697:
2698:
2699: if (@expr1073751662 validTokenStart (@expr9839 bounded@var1994 , tok@var1995 , frontToken@var1990 , -1 ) &&@expr9840
2700: validTokenEnd (@expr9841 bounded@var1994 , tok@var1995 , backToken@var1991 , 1 ) &&@expr1073751666
2701: (@expr1073751667 Token ::@expr9636 Match (@expr1073751669 tok@var1995 .@expr9688 previous (@expr9689 ) , "[(=,] 0 &&" ) ||@expr1073751672
2702: Token ::@expr9636 Match (@expr1073751674 tok@var1995 .@expr9688 previous (@expr9689 ) , "[(=,] 1 %oror%" ) ) ) {
2703: unsigned int par@var1999 ; par@var1999 =@expr1073751677 0 ;
2704: const Token * tok2@var2000 ; tok2@var2000 =@expr1073751678 tok@var1995 ;
2705: const bool andAnd@var2001 =@expr1073751679 tok@var1995 .@expr9630 next (@expr9631 ) .@expr9858 str (@expr9859 ) ==@expr1073751684 "&&" ;
2706: for (@expr1073751685 ; tok2@var2000 ; tok2@var2000 =@expr1073751686 tok2@var2000 .@expr1073751687 next (@expr1073751688 ) ) {
2707: if (@expr1073751689 tok2@var2000 .@expr9866 str (@expr9867 ) ==@expr1073751692 "(" ||@expr1073751693 tok2@var2000 .@expr9866 str (@expr9867 ) ==@expr1073751696 "[" ) {
2708: ++@expr1073751697 par@var1999 ; }
2709: else { if (@expr1073751698 tok2@var2000 .@expr9866 str (@expr9867 ) ==@expr1073751701 ")" ||@expr1073751702 tok2@var2000 .@expr9866 str (@expr9867 ) ==@expr1073751705 "]" ) {
2710: if (@expr1073751706 par@var1999 ==@expr9883 0 ) {
2711: break ; }
2712: --@expr1073751708 par@var1999 ;
2713: } else { if (@expr1073751709 par@var1999 ==@expr9883 0 &&@expr1073751711 isLowerThanLogicalAnd (@expr1073751712 tok2@var2000 ) &&@expr1073751713 (@expr1073751714 andAnd@var2001 ||@expr1073751715 tok2@var2000 .@expr9866 str (@expr9867 ) !=@expr1073751718 "||" ) ) {
2714: break ; } } }
2715: }
2716: if (@expr1073751719 tok2@var2000 ) {
2717: eraseTokens (@expr1073751720 tok@var1995 , tok2@var2000 ) ;
2718: ret@var1993 =@expr1073751721 true ;
2719: }
2720: continue ;
2721: }
2722:
2723: if (@expr1073751722 tok@var1995 .@expr9664 str (@expr9665 ) ==@expr1073751725 "0" &&@expr1073751726 validTokenStart (@expr9839 bounded@var1994 , tok@var1995 , frontToken@var1990 , -1 ) ) {
2724: if (@expr1073751728 validTokenEnd (@expr9841 bounded@var1994 , tok@var1995 , backToken@var1991 , 1 ) &&@expr1073751730
2725: (@expr1073751731 (@expr1073751732 Token ::@expr9636 Match (@expr1073751734 tok@var1995 .@expr9688 previous (@expr9689 ) , "[+-] 0 %cop%|;" ) &&@expr1073751737 isLowerThanMulDiv (@expr1073751738 tok@var1995 .@expr9630 next (@expr9631 ) ) ) ||@expr1073751741
2726: (@expr1073751742 Token ::@expr9636 Match (@expr1073751744 tok@var1995 .@expr9688 previous (@expr9689 ) , "%or% 0 %cop%|;" ) &&@expr1073751747 isLowerThanXor (@expr1073751748 tok@var1995 .@expr9630 next (@expr9631 ) ) ) ) ) {
2727: tok@var1995 =@expr1073751751 tok@var1995 .@expr9688 previous (@expr9689 ) ;
2728: if (@expr1073751754 Token ::@expr9636 Match (@expr1073751756 tok@var1995 .@expr9648 tokAt (@expr9934 -4 ) , "[;{}] %name% = %name% [+-|] 0 ;" ) &&@expr1073751759
2729: tok@var1995 .@expr9936 strAt (@expr1073751761 -3 ) ==@expr1073751762 tok@var1995 .@expr9688 previous (@expr9689 ) .@expr1073751765 str (@expr1073751766 ) ) {
2730: tok@var1995 =@expr1073751767 tok@var1995 .@expr9648 tokAt (@expr9934 -4 ) ;
2731: tok@var1995 .@expr9675 deleteNext (@expr1073751771 5 ) ;
2732: } else {
2733: tok@var1995 =@expr1073751772 tok@var1995 .@expr9688 previous (@expr9689 ) ;
2734: tok@var1995 .@expr9675 deleteNext (@expr9952 2 ) ;
2735: }
2736: ret@var1993 =@expr1073751777 true ;
2737: } else { if (@expr1073751778 validTokenEnd (@expr9841 bounded@var1994 , tok@var1995 , backToken@var1991 , 1 ) &&@expr1073751780
2738: (@expr1073751781 Token ::@expr9636 Match (@expr1073751783 tok@var1995 .@expr9688 previous (@expr9689 ) , "[=([,] 0 [+|]" ) ||@expr1073751786
2739: Token ::@expr9636 Match (@expr1073751788 tok@var1995 .@expr9688 previous (@expr9689 ) , "return|case 0 [+|]" ) ) ) {
2740: tok@var1995 =@expr1073751791 tok@var1995 .@expr9688 previous (@expr9689 ) ;
2741: tok@var1995 .@expr9675 deleteNext (@expr9952 2 ) ;
2742: ret@var1993 =@expr1073751796 true ;
2743: } else { if (@expr1073751797 (@expr1073751798 (@expr1073751799 Token ::@expr9636 Match (@expr1073751801 tok@var1995 .@expr9688 previous (@expr9689 ) , "[=[(,] 0 * %name%|%num% ,|]|)|;|=|%cop%" ) ||@expr1073751804
2744: Token ::@expr9636 Match (@expr1073751806 tok@var1995 .@expr9688 previous (@expr9689 ) , "return|case 0 *|&& %name%|%num% ,|:|;|=|%cop%" ) ) &&@expr1073751809
2745: validTokenEnd (@expr9684 bounded@var1994 , tok@var1995 , backToken@var1991 , 3 ) ) ||@expr1073751811
2746: (@expr1073751812 (@expr1073751813 Token ::@expr9636 Match (@expr1073751815 tok@var1995 .@expr9688 previous (@expr9689 ) , "[=[(,] 0 * (" ) ||@expr1073751818
2747: Token ::@expr9636 Match (@expr1073751820 tok@var1995 .@expr9688 previous (@expr9689 ) , "return|case 0 *|&& (" ) ) &&@expr1073751823
2748: validTokenEnd (@expr9796 bounded@var1994 , tok@var1995 , backToken@var1991 , 2 ) ) ) {
2749: tok@var1995 .@expr9675 deleteNext (@expr9676 ) ;
2750: if (@expr10003 tok@var1995 .@expr9630 next (@expr9631 ) .@expr9858 str (@expr9859 ) ==@expr10008 "(" ) {
2751: eraseTokens (@expr10009 tok@var1995 , tok@var1995 .@expr9630 next (@expr9631 ) .@expr10012 link (@expr10013 ) ) ; }
2752: tok@var1995 .@expr9675 deleteNext (@expr9676 ) ;
2753: ret@var1993 =@expr1073751840 true ;
2754: } else { if (@expr1073751841 validTokenEnd (@expr9633 bounded@var1994 , tok@var1995 , backToken@var1991 , 4 ) &&@expr1073751843
2755: (@expr1073751844 Token ::@expr9636 Match (@expr1073751846 tok@var1995 .@expr9688 previous (@expr9689 ) , "[=[(,] 0 && *|& %any% ,|]|)|;|=|%cop%" ) ||@expr1073751849
2756: Token ::@expr9636 Match (@expr1073751851 tok@var1995 .@expr9688 previous (@expr9689 ) , "return|case 0 && *|& %any% ,|:|;|=|%cop%" ) ) ) {
2757: tok@var1995 .@expr9675 deleteNext (@expr9676 ) ;
2758: tok@var1995 .@expr9675 deleteNext (@expr9676 ) ;
2759: if (@expr10003 tok@var1995 .@expr9630 next (@expr9631 ) .@expr9858 str (@expr9859 ) ==@expr10008 "(" ) {
2760: eraseTokens (@expr10009 tok@var1995 , tok@var1995 .@expr9630 next (@expr9631 ) .@expr10012 link (@expr10013 ) ) ; }
2761: tok@var1995 .@expr9675 deleteNext (@expr9676 ) ;
2762: ret@var1993 =@expr1073751871 true ;
2763: } } } }
2764: }
2765:
2766: if (@expr1073751872 tok@var1995 .@expr9664 str (@expr9665 ) ==@expr1073751875 "1" &&@expr1073751876 validTokenStart (@expr9839 bounded@var1994 , tok@var1995 , frontToken@var1990 , -1 ) ) {
2767: if (@expr1073751878 validTokenEnd (@expr9684 bounded@var1994 , tok@var1995 , backToken@var1991 , 3 ) &&@expr1073751880
2768: (@expr1073751881 Token ::@expr9636 Match (@expr1073751883 tok@var1995 .@expr9688 previous (@expr9689 ) , "[=[(,] 1 %oror% %any% ,|]|)|;|=|%cop%" ) ||@expr1073751886
2769: Token ::@expr9636 Match (@expr1073751888 tok@var1995 .@expr9688 previous (@expr9689 ) , "return|case 1 %oror% %any% ,|:|;|=|%cop%" ) ) ) {
2770: tok@var1995 .@expr9675 deleteNext (@expr9676 ) ;
2771: if (@expr10003 tok@var1995 .@expr9630 next (@expr9631 ) .@expr9858 str (@expr9859 ) ==@expr10008 "(" ) {
2772: eraseTokens (@expr10009 tok@var1995 , tok@var1995 .@expr9630 next (@expr9631 ) .@expr10012 link (@expr10013 ) ) ; }
2773: tok@var1995 .@expr9675 deleteNext (@expr9676 ) ;
2774: ret@var1993 =@expr1073751906 true ;
2775: } else { if (@expr1073751907 validTokenEnd (@expr9633 bounded@var1994 , tok@var1995 , backToken@var1991 , 4 ) &&@expr1073751909
2776: (@expr1073751910 Token ::@expr9636 Match (@expr1073751912 tok@var1995 .@expr9688 previous (@expr9689 ) , "[=[(,] 1 %oror% *|& %any% ,|]|)|;|=|%cop%" ) ||@expr1073751915
2777: Token ::@expr9636 Match (@expr1073751917 tok@var1995 .@expr9688 previous (@expr9689 ) , "return|case 1 %oror% *|& %any% ,|:|;|=|%cop%" ) ) ) {
2778: tok@var1995 .@expr9675 deleteNext (@expr9676 ) ;
2779: tok@var1995 .@expr9675 deleteNext (@expr9676 ) ;
2780: if (@expr10003 tok@var1995 .@expr9630 next (@expr9631 ) .@expr9858 str (@expr9859 ) ==@expr10008 "(" ) {
2781: eraseTokens (@expr10009 tok@var1995 , tok@var1995 .@expr9630 next (@expr9631 ) .@expr10012 link (@expr10013 ) ) ; }
2782: tok@var1995 .@expr9675 deleteNext (@expr9676 ) ;
2783: ret@var1993 =@expr1073751937 true ;
2784: } }
2785: }
2786:
2787: if (@expr1073751938 (@expr1073751939 Token ::@expr9636 Match (@expr1073751941 tok@var1995 .@expr9648 tokAt (@expr9828 -2 ) , "%any% * 1" ) &&@expr1073751944
2788: validTokenStart (@expr9830 bounded@var1994 , tok@var1995 , frontToken@var1990 , -2 ) ) ||@expr1073751946
2789: (@expr1073751947 Token ::@expr9636 Match (@expr1073751949 tok@var1995 .@expr9688 previous (@expr9689 ) , "%any% 1 *" ) &&@expr1073751952
2790: validTokenStart (@expr9839 bounded@var1994 , tok@var1995 , frontToken@var1990 , -1 ) ) ) {
2791: tok@var1995 =@expr1073751954 tok@var1995 .@expr9688 previous (@expr9689 ) ;
2792: if (@expr1073751957 tok@var1995 .@expr9664 str (@expr9665 ) ==@expr1073751960 "*" ) {
2793: tok@var1995 =@expr1073751961 tok@var1995 .@expr9688 previous (@expr9689 ) ; }
2794: tok@var1995 .@expr9675 deleteNext (@expr9952 2 ) ;
2795: ret@var1993 =@expr1073751966 true ;
2796: }
2797:
2798:
2799: if (@expr1073751967 validTokenStart (@expr9830 bounded@var1994 , tok@var1995 , frontToken@var1990 , -2 ) &&@expr1073751969
2800: Token ::@expr9636 Match (@expr1073751971 tok@var1995 .@expr9648 tokAt (@expr9828 -2 ) , "%op%|< ( %num% )" ) &&@expr1073751974
2801: tok@var1995 .@expr9936 strAt (@expr1073751976 -2 ) !=@expr1073751977 ">" ) {
2802: tok@var1995 =@expr1073751978 tok@var1995 .@expr9688 previous (@expr9689 ) ;
2803: tok@var1995 .@expr9703 deleteThis (@expr9704 ) ;
2804: tok@var1995 .@expr9675 deleteNext (@expr9676 ) ;
2805: ret@var1993 =@expr1073751985 true ;
2806: }
2807:
2808: if (@expr1073751986 validTokenStart (@expr9839 bounded@var1994 , tok@var1995 , frontToken@var1990 , -1 ) &&@expr9840
2809: validTokenEnd (@expr9841 bounded@var1994 , tok@var1995 , backToken@var1991 , 1 ) &&@expr1073751990
2810: (@expr1073751991 Token ::@expr9636 Match (@expr1073751993 tok@var1995 .@expr9688 previous (@expr9689 ) , "( 0 [|+]" ) ||@expr1073751996
2811: Token ::@expr9636 Match (@expr1073751998 tok@var1995 .@expr9688 previous (@expr9689 ) , "[|+-] 0 )" ) ) ) {
2812: tok@var1995 =@expr1073752001 tok@var1995 .@expr9688 previous (@expr9689 ) ;
2813: if (@expr1073752004 Token ::@expr9636 Match (@expr1073752006 tok@var1995 , "[|+-]" ) ) {
2814: tok@var1995 =@expr1073752007 tok@var1995 .@expr9688 previous (@expr9689 ) ; }
2815: tok@var1995 .@expr9675 deleteNext (@expr9952 2 ) ;
2816: ret@var1993 =@expr1073752012 true ;
2817: }
2818:
2819: if (@expr1073752013 validTokenEnd (@expr9796 bounded@var1994 , tok@var1995 , backToken@var1991 , 2 ) &&@expr1073752015
2820: Token ::@expr9636 Match (@expr1073752017 tok@var1995 , "%num% %comp% %num%" ) &&@expr1073752018
2821: MathLib ::@expr9755 isInt (@expr9756 tok@var1995 .@expr9664 str (@expr9665 ) ) &&@expr1073752023
2822: MathLib ::@expr9755 isInt (@expr1073752025 tok@var1995 .@expr9936 strAt (@expr10203 2 ) ) ) {
2823: if (@expr1073752028 validTokenStart (@expr9839 bounded@var1994 , tok@var1995 , frontToken@var1990 , -1 ) &&@expr1073752030
2824: Token ::@expr9636 Match (@expr1073752032 tok@var1995 .@expr9688 previous (@expr9689 ) , "(|&&|%oror%" ) &&@expr1073752035
2825: Token ::@expr9636 Match (@expr1073752037 tok@var1995 .@expr9648 tokAt (@expr1073752039 3 ) , ")|&&|%oror%|?" ) ) {
2826: const long long op1@var2002 (@expr1073752040 MathLib ::@expr9694 toLongNumber (@expr9695 tok@var1995 .@expr9664 str (@expr9665 ) ) ) ;
2827: const std ::@expr9769 string & cmp@var2003 (@expr1073752046 tok@var1995 .@expr9630 next (@expr9631 ) .@expr9858 str (@expr9859 ) ) ;
2828: const long long op2@var2004 (@expr1073752051 MathLib ::@expr9694 toLongNumber (@expr1073752053 tok@var1995 .@expr9936 strAt (@expr10203 2 ) ) ) ;
2829:
2830: std ::@expr1073752056 string result@var2005 ;
2831:
2832: if (@expr1073752057 cmp@var2003 ==@expr1073752058 "==" ) {
2833: result@var2005 =@expr1073752059 (@expr1073752060 op1@var2002 ==@expr1073752061 op2@var2004 ) ?@expr1073752062 "1" :@expr10239 "0" ; }
2834: else { if (@expr1073752064 cmp@var2003 ==@expr1073752065 "!=" ) {
2835: result@var2005 =@expr1073752066 (@expr1073752067 op1@var2002 !=@expr1073752068 op2@var2004 ) ?@expr1073752069 "1" :@expr10239 "0" ; }
2836: else { if (@expr1073752071 cmp@var2003 ==@expr1073752072 "<=" ) {
2837: result@var2005 =@expr1073752073 (@expr1073752074 op1@var2002 <=@expr1073752075 op2@var2004 ) ?@expr1073752076 "1" :@expr10239 "0" ; }
2838: else { if (@expr1073752078 cmp@var2003 ==@expr1073752079 ">=" ) {
2839: result@var2005 =@expr1073752080 (@expr1073752081 op1@var2002 >=@expr1073752082 op2@var2004 ) ?@expr1073752083 "1" :@expr10239 "0" ; }
2840: else { if (@expr1073752085 cmp@var2003 ==@expr1073752086 "<" ) {
2841: result@var2005 =@expr1073752087 (@expr1073752088 op1@var2002 <@expr1073752089 op2@var2004 ) ?@expr1073752090 "1" :@expr10239 "0" ; }
2842: else {
2843: result@var2005 =@expr1073752092 (@expr1073752093 op1@var2002 >@expr1073752094 op2@var2004 ) ?@expr1073752095 "1" :@expr10239 "0" ; } } } } }
2844:
2845: tok@var1995 .@expr9664 str (@expr1073752098 result@var2005 ) ;
2846: tok@var1995 .@expr9675 deleteNext (@expr9952 2 ) ;
2847: ret@var1993 =@expr1073752101 true ;
2848: tok@var1995 =@expr1073752102 tok@var1995 .@expr9688 previous (@expr9689 ) ;
2849: }
2850: }
2851: }
2852: }
2853: return ret@var1993 ;
2854: }
2855:
2856: void TemplateSimplifier :: getTemplateParametersInDeclaration (
2857: const Token * tok@var2006 ,
2858: std :: vector < const Token * > & typeParametersInDeclaration@var2007 )
2859: {
2860: assert (@expr1073752105 tok@var2006 .@expr10282 strAt (@expr1073752107 -1 ) ==@expr1073752108 "<" ) ;
2861:
2862: typeParametersInDeclaration@var2007 .@expr1073752109 clear (@expr1073752110 ) ;
2863: const Token * end@var2008 ; end@var2008 =@expr1073752111 tok@var2006 .@expr1073752112 previous (@expr1073752113 ) .@expr1073752114 findClosingBracket (@expr1073752115 ) ;
2864: bool inDefaultValue@var2009 ; inDefaultValue@var2009 =@expr1073752116 false ;
2865: for (@expr1073752117 ; tok@var2006 &&@expr1073752118 tok@var2006 !=@expr1073752119 end@var2008 ; tok@var2006 =@expr1073752120 tok@var2006 .@expr10297 next (@expr10298 ) ) {
2866: if (@expr1073752123 Token ::@expr1073752124 simpleMatch (@expr1073752125 tok@var2006 , "template <" ) ) {
2867: const Token * closing@var2010 ; closing@var2010 =@expr1073752126 tok@var2006 .@expr10297 next (@expr10298 ) .@expr1073752129 findClosingBracket (@expr1073752130 ) ;
2868: if (@expr1073752131 closing@var2010 ) {
2869: tok@var2006 =@expr1073752132 closing@var2010 .@expr1073752133 next (@expr1073752134 ) ; }
2870: } else { if (@expr1073752135 tok@var2006 .@expr10312 link (@expr10313 ) &&@expr1073752138 Token ::@expr10315 Match (@expr1073752140 tok@var2006 , "{|(|[" ) ) {
2871: tok@var2006 =@expr1073752141 tok@var2006 .@expr10312 link (@expr10313 ) ; }
2872: else { if (@expr1073752144 Token ::@expr10315 Match (@expr1073752146 tok@var2006 , "%name% ,|>|=" ) ) {
2873: if (@expr1073752147 !@expr1073752148 inDefaultValue@var2009 ) {
2874: typeParametersInDeclaration@var2007 .@expr1073752149 push_back (@expr1073752150 tok@var2006 ) ;
2875: if (@expr1073752151 tok@var2006 .@expr10282 strAt (@expr1073752153 1 ) ==@expr1073752154 "=" ) {
2876: inDefaultValue@var2009 =@expr1073752155 true ; }
2877: }
2878: } else { if (@expr1073752156 inDefaultValue@var2009 ) {
2879: if (@expr1073752157 tok@var2006 .@expr10334 str (@expr10335 ) ==@expr1073752160 "," ) {
2880: inDefaultValue@var2009 =@expr1073752161 false ; }
2881: else { if (@expr1073752162 tok@var2006 .@expr10334 str (@expr10335 ) ==@expr1073752165 "<" ) {
2882: const Token * closing@var2011 ; closing@var2011 =@expr1073752166 tok@var2006 .@expr1073752167 findClosingBracket (@expr1073752168 ) ;
2883: if (@expr1073752169 closing@var2011 ) {
2884: tok@var2006 =@expr1073752170 closing@var2011 ; }
2885: } }
2886: } } } }
2887: }
2888: }
2889:
2890: bool TemplateSimplifier :: matchSpecialization (
2891: const Token * templateDeclarationNameToken@var2012 ,
2892: const Token * templateInstantiationNameToken@var2013 ,
2893: const std :: list < const Token * > & specializations@var2014 )
2894: {
2895:
2896: for (@expr1073752172 std ::@expr10349 list < const Token *@expr10350 > ::@expr10349 const_iterator it@var2015 =@expr1073752176 specializations@var2014 .@expr1073752177 begin (@expr1073752178 ) ; it@var2015 !=@expr1073752179 specializations@var2014 .@expr1073752180 end (@expr1073752181 ) ; ++@expr1073752182 it@var2015 ) {
2897: if (@expr1073752183 !@expr1073752184 Token ::@expr10361 Match (@expr1073752186 *@expr10363 it@var2015 , "%name% <" ) ) {
2898: continue ; }
2899: const Token * startToken@var2016 ; startToken@var2016 =@expr1073752188 *@expr10363 it@var2015 ;
2900: while (@expr1073752190 startToken@var2016 .@expr10367 previous (@expr10368 ) &&@expr1073752193 !@expr1073752194 Token ::@expr10361 Match (@expr1073752196 startToken@var2016 .@expr10367 previous (@expr10368 ) , "[;{}]" ) ) {
2901: startToken@var2016 =@expr1073752199 startToken@var2016 .@expr10367 previous (@expr10368 ) ; }
2902: if (@expr1073752202 !@expr1073752203 Token ::@expr1073752204 simpleMatch (@expr1073752205 startToken@var2016 , "template <" ) ) {
2903: continue ; }
2904: std ::@expr1073752206 vector < const Token *@expr10350 > templateParameters@var2017 ;
2905: getTemplateParametersInDeclaration (@expr1073752208 startToken@var2016 .@expr1073752209 tokAt (@expr1073752210 2 ) , templateParameters@var2017 ) ;
2906:
2907: const Token * instToken@var2018 ; instToken@var2018 =@expr1073752211 templateInstantiationNameToken@var2013 .@expr1073752212 tokAt (@expr1073752213 2 ) ;
2908: const Token * declToken@var2019 ; declToken@var2019 =@expr1073752214 (@expr10391 *@expr10363 it@var2015 ) .@expr1073752217 tokAt (@expr1073752218 2 ) ;
2909: const Token * const endToken@var2020 ; endToken@var2020 =@expr1073752219 (@expr10391 *@expr10363 it@var2015 ) .@expr1073752222 next (@expr1073752223 ) .@expr1073752224 findClosingBracket (@expr1073752225 ) ;
2910: if (@expr1073752226 !@expr1073752227 endToken@var2020 ) {
2911: continue ; }
2912: while (@expr1073752228 declToken@var2019 !=@expr1073752229 endToken@var2020 ) {
2913: if (@expr1073752230 declToken@var2019 .@expr10407 str (@expr10408 ) !=@expr1073752233 instToken@var2018 .@expr10410 str (@expr10411 ) ||@expr1073752236
2914: declToken@var2019 .@expr1073752237 isSigned (@expr1073752238 ) !=@expr1073752239 instToken@var2018 .@expr1073752240 isSigned (@expr1073752241 ) ||@expr1073752242
2915: declToken@var2019 .@expr1073752243 isUnsigned (@expr1073752244 ) !=@expr1073752245 instToken@var2018 .@expr1073752246 isUnsigned (@expr1073752247 ) ||@expr1073752248
2916: declToken@var2019 .@expr1073752249 isLong (@expr1073752250 ) !=@expr1073752251 instToken@var2018 .@expr1073752252 isLong (@expr1073752253 ) ) {
2917: int nr@var2021 ; nr@var2021 =@expr1073752254 0 ;
2918: while (@expr1073752255 nr@var2021 <@expr1073752256 templateParameters@var2017 .@expr10433 size (@expr10434 ) &&@expr1073752259 templateParameters@var2017 [@expr1073752260 nr@var2021 ] .@expr1073752261 str (@expr1073752262 ) !=@expr1073752263 declToken@var2019 .@expr10407 str (@expr10408 ) ) {
2919: ++@expr1073752266 nr@var2021 ; }
2920:
2921: if (@expr1073752267 nr@var2021 ==@expr1073752268 templateParameters@var2017 .@expr10433 size (@expr10434 ) ) {
2922: break ; }
2923: }
2924: declToken@var2019 =@expr1073752271 declToken@var2019 .@expr1073752272 next (@expr1073752273 ) ;
2925: instToken@var2018 =@expr1073752274 instToken@var2018 .@expr1073752275 next (@expr1073752276 ) ;
2926: }
2927:
2928: if (@expr1073752277 declToken@var2019 &&@expr1073752278 instToken@var2018 &&@expr1073752279 declToken@var2019 ==@expr1073752280 endToken@var2020 &&@expr1073752281 instToken@var2018 .@expr10410 str (@expr10411 ) ==@expr1073752284 ">" ) {
2929:
2930: return templateDeclarationNameToken@var2012 ==@expr1073752285 *@expr10363 it@var2015 ;
2931: }
2932: }
2933:
2934:
2935: return Token ::@expr10361 Match (@expr1073752288 templateDeclarationNameToken@var2012 , "%name% !!<" ) &&@expr1073752289
2936: (@expr1073752290 templateDeclarationNameToken@var2012 .@expr1073752291 str (@expr1073752292 ) .@expr1073752293 find (@expr1073752294 '<' ) ==@expr1073752295 std ::@expr1073752296 string ::@expr1073752297 npos@expr1073752171 ) ;
2937: }
2938:
2939: std :: string TemplateSimplifier :: getNewName (
2940: Token * tok2@var2022 ,
2941: std :: list < std :: string > & typeStringsUsedInTemplateInstantiation@var2023 )
2942: {
2943: std ::@expr1073752298 string typeForNewName@var2024 ;
2944: unsigned int indentlevel@var2025 ; indentlevel@var2025 =@expr1073752299 0 ;
2945: const Token * endToken@var2026 ; endToken@var2026 =@expr1073752300 tok2@var2022 .@expr1073752301 next (@expr1073752302 ) .@expr1073752303 findClosingBracket (@expr1073752304 ) ;
2946: for (@expr1073752305 Token *@expr1073752306 tok3@var2027 =@expr1073752307 tok2@var2022 .@expr1073752308 tokAt (@expr1073752309 2 ) ; tok3@var2027 !=@expr1073752310 endToken@var2026 &&@expr1073752311 (@expr1073752312 indentlevel@var2025 >@expr10489 0 ||@expr1073752314 tok3@var2027 .@expr10491 str (@expr10492 ) !=@expr1073752317 ">" ) ; tok3@var2027 =@expr1073752318 tok3@var2027 .@expr10495 next (@expr10496 ) ) {
2947:
2948: if (@expr1073752321 tok3@var2027 .@expr10491 str (@expr10492 ) ==@expr1073752324 "[" &&@expr1073752325 !@expr1073752326 Token ::@expr10503 Match (@expr1073752328 tok3@var2027 .@expr10495 next (@expr10496 ) , "%num%| ]" ) ) {
2949: typeForNewName@var2024 .@expr10507 clear (@expr10508 ) ;
2950: break ;
2951: }
2952: if (@expr1073752333 !@expr1073752334 tok3@var2027 .@expr10495 next (@expr10496 ) ) {
2953: typeForNewName@var2024 .@expr10507 clear (@expr10508 ) ;
2954: break ;
2955: }
2956: if (@expr1073752339 Token ::@expr10503 Match (@expr1073752341 tok3@var2027 .@expr1073752342 tokAt (@expr1073752343 -2 ) , "<|,|:: %name% <" ) &&@expr1073752344 (@expr1073752345 tok3@var2027 .@expr10522 strAt (@expr10523 1 ) ==@expr1073752348 ">" ||@expr1073752349 templateParameters (@expr1073752350 tok3@var2027 ) ) ) {
2957: ++@expr1073752351 indentlevel@var2025 ; }
2958: else { if (@expr1073752352 indentlevel@var2025 >@expr10489 0 &&@expr1073752354 Token ::@expr10503 Match (@expr1073752356 tok3@var2027 , "> ,|>|::" ) ) {
2959: --@expr1073752357 indentlevel@var2025 ; } }
2960: if (@expr1073752358 indentlevel@var2025 ==@expr1073752359 0 &&@expr1073752360 Token ::@expr10503 Match (@expr1073752362 tok3@var2027 .@expr1073752363 previous (@expr1073752364 ) , "[<,]" ) ) {
2961: mTypesUsedInTemplateInstantiation@var113 .@expr1073752365 emplace_back (@expr1073752366 tok3@var2027 , "" ) ;
2962: }
2963: if (@expr1073752367 Token ::@expr10503 Match (@expr1073752369 tok3@var2027 , "(|[" ) ) {
2964: ++@expr1073752370 indentlevel@var2025 ; }
2965: else { if (@expr1073752371 Token ::@expr10503 Match (@expr1073752373 tok3@var2027 , ")|]" ) ) {
2966: --@expr1073752374 indentlevel@var2025 ; } }
2967: const bool constconst@var2028 =@expr1073752375 tok3@var2027 .@expr10491 str (@expr10492 ) ==@expr1073752378 "const" &&@expr1073752379 tok3@var2027 .@expr10522 strAt (@expr10523 1 ) ==@expr1073752382 "const" ;
2968: if (@expr1073752383 !@expr10560 constconst@var2028 ) {
2969: if (@expr10561 tok3@var2027 .@expr10562 isUnsigned (@expr10563 ) ) {
2970: typeStringsUsedInTemplateInstantiation@var2023 .@expr10564 push_back (@expr1073752389 "unsigned" ) ; }
2971: else { if (@expr10566 tok3@var2027 .@expr10567 isSigned (@expr10568 ) ) {
2972: typeStringsUsedInTemplateInstantiation@var2023 .@expr10564 push_back (@expr1073752394 "signed" ) ; } }
2973: if (@expr10571 tok3@var2027 .@expr10572 isLong (@expr10573 ) ) {
2974: typeStringsUsedInTemplateInstantiation@var2023 .@expr10564 push_back (@expr1073752399 "long" ) ; }
2975: typeStringsUsedInTemplateInstantiation@var2023 .@expr10564 push_back (@expr1073752401 tok3@var2027 .@expr10491 str (@expr10492 ) ) ;
2976: }
2977:
2978: if (@expr1073752404 !@expr10560 constconst@var2028 &&@expr1073752406 !@expr1073752407 Token ::@expr10503 Match (@expr1073752409 tok3@var2027 , "class|struct|enum" ) ) {
2979: if (@expr1073752410 !@expr1073752411 typeForNewName@var2024 .@expr1073752412 empty (@expr1073752413 ) ) {
2980: typeForNewName@var2024 +=@expr1073752414 ' ' ; }
2981: if (@expr10561 tok3@var2027 .@expr10562 isUnsigned (@expr10563 ) ) {
2982: typeForNewName@var2024 +=@expr1073752418 "unsigned " ; }
2983: else { if (@expr10566 tok3@var2027 .@expr10567 isSigned (@expr10568 ) ) {
2984: typeForNewName@var2024 +=@expr1073752422 "signed " ; } }
2985: if (@expr10571 tok3@var2027 .@expr10572 isLong (@expr10573 ) ) {
2986: typeForNewName@var2024 +=@expr1073752426 "long " ;
2987: }
2988: typeForNewName@var2024 +=@expr1073752427 tok3@var2027 .@expr10491 str (@expr10492 ) ;
2989: }
2990: }
2991:
2992: return typeForNewName@var2024 ;
2993: }
2994:
2995: bool TemplateSimplifier :: simplifyTemplateInstantiations (
2996: const TokenAndName & templateDeclaration@var2029 ,
2997: const std :: list < const Token * > & specializations@var2030 ,
2998: const std :: time_t maxtime@var2031 ,
2999: std :: set < std :: string > & expandedtemplates@var2032 )
3000: {
3001:
|
3005:
3006: std ::@expr1073752430 vector < const Token *@expr10607 > typeParametersInDeclaration@var2033 ;
3007: getTemplateParametersInDeclaration (@expr1073752432 templateDeclaration@var2029 .@expr1073752433 token (@expr1073752434 ) .@expr1073752435 tokAt (@expr1073752436 2 ) , typeParametersInDeclaration@var2033 ) ;
3008: const bool printDebug@var2034 =@expr1073752437 mSettings@var101 .@expr1073752438 debugwarnings@var2196 ;
3009: const bool specialized@var2035 =@expr1073752439 templateDeclaration@var2029 .@expr1073752440 isSpecialization (@expr1073752441 ) ;
3010: const bool isfunc@var2036 =@expr1073752442 templateDeclaration@var2029 .@expr10619 isFunction (@expr10620 ) ;
3011: const bool isVar@var2037 =@expr1073752445 templateDeclaration@var2029 .@expr1073752446 isVariable (@expr1073752447 ) ;
3012:
3013:
3014: std ::@expr1073752448 string ::@expr1073752449 size_type numberOfTemplateInstantiations@var2038 ; numberOfTemplateInstantiations@var2038 =@expr1073752450 mTemplateInstantiations@var109 .@expr10627 size (@expr10628 ) ;
3015: unsigned int recursiveCount@var2039 ; recursiveCount@var2039 =@expr1073752453 0 ;
3016:
3017: bool instantiated@var2040 ; instantiated@var2040 =@expr1073752454 false ;
3018:
3019: for (@expr1073752455 const TokenAndName &@expr1073752456 instantiation@var2041 :@expr1073752457 mTemplateInstantiations@var109 ) {
3020:
3021: if (@expr1073752458 !@expr1073752459 instantiation@var2041 .@expr10636 token (@expr10637 ) ) {
3022: continue ; }
3023: if (@expr1073752462 numberOfTemplateInstantiations@var2038 !=@expr1073752463 mTemplateInstantiations@var109 .@expr10627 size (@expr10628 ) ) {
3024: numberOfTemplateInstantiations@var2038 =@expr1073752466 mTemplateInstantiations@var109 .@expr10627 size (@expr10628 ) ;
3025: ++@expr1073752469 recursiveCount@var2039 ;
3026: if (@expr1073752470 recursiveCount@var2039 >@expr1073752471 mSettings@var101 .@expr10648 maxTemplateRecursion@var2200 ) {
3027: std ::@expr1073752473 list < std ::@expr10650 string > typeStringsUsedInTemplateInstantiation@var2042 ;
3028: const std ::@expr10650 string typeForNewName@var2043 =@expr1073752476 templateDeclaration@var2029 .@expr10653 name (@expr10654 ) +@expr1073752479 "<" +@expr1073752480 getNewName (@expr1073752481 instantiation@var2041 .@expr10636 token (@expr10637 ) , typeStringsUsedInTemplateInstantiation@var2042 ) +@expr1073752484 ">" ;
3029:
3030: const std ::@expr1073752485 list < const Token *@expr10607 > callstack@var2044 (@expr1073752487 1 , instantiation@var2041 .@expr10636 token (@expr10637 ) ) ;
3031: const ErrorMessage errmsg@var2045 (@expr1073752490 callstack@var2044 ,
3032: &@expr1073752491 mTokenizer@var99 .@expr1073752492 list@var2197 ,
3033: Severity ::@expr10669 information ,
3034: "templateRecursion" ,
3035: "TemplateSimplifier: max template recursion ("
3036: +@expr1073752494 MathLib ::@expr1073752495 toString (@expr1073752496 mSettings@var101 .@expr10648 maxTemplateRecursion@var2200 )
3037: +@expr1073752498 ") reached for template '" +@expr1073752499 typeForNewName@var2043 +@expr1073752500 "'. You might want to limit Cppcheck recursion." ,
3038: Certainty ::@expr10677 normal ) ;
3039: if (@expr1073752502 mErrorLogger@var102 &&@expr1073752503 mSettings@var101 .@expr1073752504 severity@var2198 .@expr1073752505 isEnabled (@expr1073752506 Severity ::@expr10669 information ) ) {
3040: mErrorLogger@var102 .@expr10684 reportErr (@expr1073752509 errmsg@var2045 ) ; }
3041:
3042:
3043: break ;
3044: }
3045: }
3046:
3047:
3048: if (@expr1073752510 !@expr1073752511 Token ::@expr10688 Match (@expr1073752513 instantiation@var2041 .@expr10636 token (@expr10637 ) , "%name% <" ) ) {
3049: continue ; }
3050:
3051: if (@expr1073752516 !@expr1073752517 (@expr1073752518 (@expr1073752519 instantiation@var2041 .@expr10696 fullName (@expr10697 ) ==@expr1073752522 templateDeclaration@var2029 .@expr1073752523 fullName (@expr1073752524 ) ) ||@expr1073752525
3052: (@expr1073752526 instantiation@var2041 .@expr10703 name (@expr10704 ) ==@expr1073752529 templateDeclaration@var2029 .@expr10653 name (@expr10654 ) &&@expr1073752532
3053: instantiation@var2041 .@expr10696 fullName (@expr10697 ) ==@expr1073752535 templateDeclaration@var2029 .@expr10712 scope (@expr10713 ) ) ) ) {
3054:
3055:
3056:
3057: if (@expr1073752538 instantiation@var2041 .@expr10703 name (@expr10704 ) !=@expr1073752541 templateDeclaration@var2029 .@expr10653 name (@expr10654 ) ) {
3058: continue ; }
3059:
3060:
3061: if (@expr1073752544 !@expr1073752545 instantiation@var2041 .@expr1073752546 scope (@expr1073752547 ) .@expr1073752548 empty (@expr1073752549 ) &&@expr1073752550 !@expr1073752551 templateDeclaration@var2029 .@expr10712 scope (@expr10713 ) .@expr10730 empty (@expr10731 ) ) {
3062: continue ; }
3063: }
3064:
3065:
3066: if (@expr1073752556 templateDeclaration@var2029 .@expr10733 nameToken (@expr10734 ) .@expr1073752559 strAt (@expr1073752560 -1 ) ==@expr1073752561 "~" &&@expr1073752562 instantiation@var2041 .@expr10636 token (@expr10637 ) .@expr10741 strAt (@expr10742 -1 ) !=@expr1073752567 "~" ) {
3067: continue ; }
3068:
3069:
3070: if (@expr1073752568 !@expr1073752569 instantiation@var2041 .@expr10746 isFunction (@expr10747 ) &&@expr1073752572 templateDeclaration@var2029 .@expr10619 isFunction (@expr10620 ) ) {
3071:
3072: if (@expr1073752575 !@expr1073752576 Token ::@expr10753 simpleMatch (@expr1073752578 instantiation@var2041 .@expr10636 token (@expr10637 ) .@expr10757 tokAt (@expr10758 -2 ) , "decltype (" ) ) {
3073: continue ; }
3074: }
3075:
3076: if (@expr1073752583 templateDeclaration@var2029 .@expr10619 isFunction (@expr10620 ) &&@expr1073752586 instantiation@var2041 .@expr10746 isFunction (@expr10747 ) ) {
3077: std ::@expr1073752589 vector < const Token *@expr10607 > declFuncArgs@var2046 ;
3078: getFunctionArguments (@expr1073752591 templateDeclaration@var2029 .@expr10733 nameToken (@expr10734 ) , declFuncArgs@var2046 ) ;
3079: std ::@expr1073752594 vector < const Token *@expr10607 > instFuncParams@var2047 ;
3080: getFunctionArguments (@expr1073752596 instantiation@var2041 .@expr10636 token (@expr10637 ) , instFuncParams@var2047 ) ;
3081:
3082: if (@expr1073752599 declFuncArgs@var2046 .@expr10776 size (@expr10777 ) !=@expr1073752602 instFuncParams@var2047 .@expr10779 size (@expr10780 ) ) {
3083:
3084: const Token * tok@var2048 ; tok@var2048 =@expr1073752605 templateDeclaration@var2029 .@expr10733 nameToken (@expr10734 ) .@expr1073752608 tokAt (@expr1073752609 2 ) ;
3085: const Token * end@var2049 ; end@var2049 =@expr1073752610 templateDeclaration@var2029 .@expr10733 nameToken (@expr10734 ) .@expr1073752613 linkAt (@expr1073752614 1 ) ;
3086: unsigned long count@var2050 ; count@var2050 =@expr1073752615 0 ;
3087: for (@expr1073752616 ; tok@var2048 !=@expr1073752617 end@var2049 ; tok@var2048 =@expr1073752618 tok@var2048 .@expr1073752619 next (@expr1073752620 ) ) {
3088: if (@expr1073752621 tok@var2048 .@expr1073752622 str (@expr1073752623 ) ==@expr1073752624 "=" ) {
3089: count@var2050 ++@expr1073752625 ; }
3090: }
3091:
3092: if (@expr1073752626 instFuncParams@var2047 .@expr10779 size (@expr10780 ) <@expr1073752629 (@expr1073752630 declFuncArgs@var2046 .@expr10776 size (@expr10777 ) -@expr1073752633 count@var2050 ) ||@expr1073752634 instFuncParams@var2047 .@expr10779 size (@expr10780 ) >@expr1073752637 declFuncArgs@var2046 .@expr10776 size (@expr10777 ) ) {
3093: continue ; }
3094: }
3095: }
3096:
3097:
3098: if (@expr1073752640 templateDeclaration@var2029 .@expr10619 isFunction (@expr10620 ) &&@expr1073752643 templateDeclaration@var2029 .@expr10712 scope (@expr10713 ) .@expr10730 empty (@expr10731 ) &&@expr1073752648
3099: (@expr1073752649 instantiation@var2041 .@expr10636 token (@expr10637 ) .@expr10741 strAt (@expr10742 -1 ) ==@expr1073752654 "." ||@expr1073752655
3100: Token ::@expr10753 simpleMatch (@expr1073752657 instantiation@var2041 .@expr10636 token (@expr10637 ) .@expr10757 tokAt (@expr10758 -2 ) , ". template" ) ) ) {
3101: continue ; }
3102:
3103: if (@expr1073752662 !@expr1073752663 matchSpecialization (@expr1073752664 templateDeclaration@var2029 .@expr10733 nameToken (@expr10734 ) , instantiation@var2041 .@expr10636 token (@expr10637 ) , specializations@var2030 ) ) {
3104: continue ; }
3105:
3106: Token * const tok2@var2051 ; tok2@var2051 =@expr1073752669 instantiation@var2041 .@expr10636 token (@expr10637 ) ;
3107: if (@expr10848 mErrorLogger@var102 &&@expr10849 !@expr10850 mTokenList@var100 .@expr10851 getFiles (@expr10852 ) .@expr10853 empty (@expr10854 ) ) {
3108: mErrorLogger@var102 .@expr10855 reportProgress (@expr1073752680 mTokenList@var100 .@expr10851 getFiles (@expr10852 ) [@expr10859 0 ] , "TemplateSimplifier::simplifyTemplateInstantiations()" , tok2@var2051 .@expr1073752684 progressValue (@expr1073752685 ) ) ; }
3109:
|
3112:
3113: (@expr10862 void ) maxtime@var2031 ;
3114:
3115: assert (@expr1073752687 mTokenList@var100 .@expr10864 validateToken (@expr1073752689 tok2@var2051 ) ) ;
3116:
3117: const Token * startToken@var2052 ; startToken@var2052 =@expr1073752690 tok2@var2051 ;
3118: while (@expr1073752691 Token ::@expr10688 Match (@expr1073752693 startToken@var2052 .@expr10870 tokAt (@expr10871 -2 ) , ">|%name% :: %name%" ) ) {
3119: if (@expr1073752696 startToken@var2052 .@expr1073752697 strAt (@expr1073752698 -2 ) ==@expr1073752699 ">" ) {
3120: const Token * tok3@var2053 ; tok3@var2053 =@expr1073752700 startToken@var2052 .@expr10870 tokAt (@expr10871 -2 ) .@expr1073752703 findOpeningBracket (@expr1073752704 ) ;
3121: if (@expr1073752705 tok3@var2053 ) {
3122: startToken@var2052 =@expr1073752706 tok3@var2053 .@expr1073752707 previous (@expr1073752708 ) ; }
3123: else {
3124: break ; }
3125: } else {
3126: startToken@var2052 =@expr1073752709 startToken@var2052 .@expr10870 tokAt (@expr10871 -2 ) ; }
3127: }
3128:
3129: if (@expr1073752712 Token ::@expr10688 Match (@expr1073752714 startToken@var2052 .@expr1073752715 previous (@expr1073752716 ) , ";|{|}|=|const" ) &&@expr1073752717
3130: (@expr1073752718 !@expr10895 specialized@var2035 &&@expr1073752720 !@expr1073752721 instantiateMatch (@expr1073752722 tok2@var2051 , typeParametersInDeclaration@var2033 .@expr10899 size (@expr10900 ) , templateDeclaration@var2029 .@expr10901 isVariadic (@expr10902 ) , isfunc@var2036 ?@expr1073752727 "(" :@expr1073752728 isVar@var2037 ?@expr1073752729 ";|%op%|(" :@expr1073752730 "*|&|::| %name%" ) ) ) {
3131: continue ; }
3132:
3133:
3134: mTypesUsedInTemplateInstantiation@var113 .@expr10907 clear (@expr10908 ) ;
3135: std ::@expr1073752733 list < std ::@expr10650 string > typeStringsUsedInTemplateInstantiation@var2054 ;
3136: std ::@expr1073752735 string typeForNewName@var2055 ; typeForNewName@var2055 =@expr1073752736 getNewName (@expr1073752737 tok2@var2051 , typeStringsUsedInTemplateInstantiation@var2054 ) ;
3137:
3138: if (@expr1073752738 (@expr1073752739 typeForNewName@var2055 .@expr10916 empty (@expr10917 ) &&@expr1073752742 !@expr1073752743 templateDeclaration@var2029 .@expr10901 isVariadic (@expr10902 ) ) ||@expr1073752746
3139: (@expr1073752747 !@expr1073752748 typeParametersInDeclaration@var2033 .@expr1073752749 empty (@expr1073752750 ) &&@expr1073752751 !@expr1073752752 instantiateMatch (@expr1073752753 tok2@var2051 , typeParametersInDeclaration@var2033 .@expr10899 size (@expr10900 ) , templateDeclaration@var2029 .@expr10901 isVariadic (@expr10902 ) , nullptr ) ) ) {
3140: if (@expr10934 printDebug@var2034 &&@expr10935 mErrorLogger@var102 ) {
3141: std ::@expr1073752760 list < const Token *@expr10607 > callstack@var2056 (@expr1073752762 1 , tok2@var2051 ) ;
3142: mErrorLogger@var102 .@expr10684 reportErr (@expr1073752764 ErrorMessage (@expr1073752765 callstack@var2056 , &@expr10942 mTokenList@var100 , Severity ::@expr10943 debug , "debug" ,
3143: "Failed to instantiate template \"" +@expr1073752768 instantiation@var2041 .@expr10703 name (@expr10704 ) +@expr1073752771 "\". The checking continues anyway." , Certainty ::@expr10677 normal ) ) ;
3144: }
3145: if (@expr1073752773 typeForNewName@var2055 .@expr10916 empty (@expr10917 ) ) {
3146: continue ; }
3147: break ;
3148: }
3149:
3150:
3151: const std ::@expr1073752776 string newName@var2057 (@expr1073752777 templateDeclaration@var2029 .@expr10653 name (@expr10654 ) +@expr10956 " < " +@expr1073752781 typeForNewName@var2055 +@expr1073752782 " >" ) ;
3152: const std ::@expr1073752783 string newFullName@var2058 (@expr1073752784 templateDeclaration@var2029 .@expr10712 scope (@expr10713 ) +@expr10963 (@expr1073752788 templateDeclaration@var2029 .@expr10712 scope (@expr10713 ) .@expr10730 empty (@expr10731 ) ?@expr10969 "" :@expr10970 " :: " ) +@expr1073752795 newName@var2057 ) ;
3153:
3154: if (@expr1073752796 expandedtemplates@var2032 .@expr10973 insert (@expr1073752798 newFullName@var2058 ) .@expr1073752799 second@var2059 ) {
3155: expandTemplate (@expr1073752800 templateDeclaration@var2029 , instantiation@var2041 , typeParametersInDeclaration@var2033 , newName@var2057 , !@expr10895 specialized@var2035 &&@expr10978 !@expr10979 isVar@var2037 ) ;
3156: instantiated@var2040 =@expr1073752804 true ;
3157: mChanged@var103 =@expr1073752805 true ;
3158: }
3159:
3160:
3161: replaceTemplateUsage (@expr1073752806 instantiation@var2041 , typeStringsUsedInTemplateInstantiation@var2054 , newName@var2057 ) ;
3162: }
3163:
3164:
3165:
3166: if (@expr1073752807 !@expr1073752808 instantiated@var2040 &&@expr1073752809 specialized@var2035 ) {
3167: Token * tok2@var2060 ; tok2@var2060 =@expr1073752810 const_cast < Token *@expr10607 > (@expr1073752812 templateDeclaration@var2029 .@expr10733 nameToken (@expr10734 ) ) ;
3168: if (@expr10848 mErrorLogger@var102 &&@expr10849 !@expr10850 mTokenList@var100 .@expr10851 getFiles (@expr10852 ) .@expr10853 empty (@expr10854 ) ) {
3169: mErrorLogger@var102 .@expr10855 reportProgress (@expr1073752823 mTokenList@var100 .@expr10851 getFiles (@expr10852 ) [@expr10859 0 ] , "TemplateSimplifier::simplifyTemplateInstantiations()" , tok2@var2060 .@expr1073752827 progressValue (@expr1073752828 ) ) ; }
3170:
|
3173:
3174: (@expr10862 void ) maxtime@var2031 ;
3175:
3176: assert (@expr1073752830 mTokenList@var100 .@expr10864 validateToken (@expr1073752832 tok2@var2060 ) ) ;
3177:
3178: Token * startToken@var2061 ; startToken@var2061 =@expr1073752833 tok2@var2060 ;
3179: while (@expr1073752834 Token ::@expr10688 Match (@expr1073752836 startToken@var2061 .@expr11013 tokAt (@expr11014 -2 ) , ">|%name% :: %name%" ) ) {
3180: if (@expr1073752839 startToken@var2061 .@expr1073752840 strAt (@expr1073752841 -2 ) ==@expr1073752842 ">" ) {
3181: const Token * tok3@var2062 ; tok3@var2062 =@expr1073752843 startToken@var2061 .@expr11013 tokAt (@expr11014 -2 ) .@expr1073752846 findOpeningBracket (@expr1073752847 ) ;
3182: if (@expr1073752848 tok3@var2062 ) {
3183: startToken@var2061 =@expr1073752849 tok3@var2062 .@expr1073752850 previous (@expr1073752851 ) ; }
3184: else {
3185: break ; }
3186: } else {
3187: startToken@var2061 =@expr1073752852 startToken@var2061 .@expr11013 tokAt (@expr11014 -2 ) ; }
3188: }
3189:
|
3195:
3196: if (@expr1073752855 !@expr1073752856 Token ::@expr10688 Match (@expr1073752858 tok2@var2060 , "%name% <" ) ) {
3197: return false ; }
3198:
3199: if (@expr1073752859 !@expr1073752860 matchSpecialization (@expr1073752861 templateDeclaration@var2029 .@expr10733 nameToken (@expr10734 ) , tok2@var2060 , specializations@var2030 ) ) {
3200: return false ; }
3201:
3202:
3203: mTypesUsedInTemplateInstantiation@var113 .@expr10907 clear (@expr10908 ) ;
3204: std ::@expr1073752866 list < std ::@expr10650 string > typeStringsUsedInTemplateInstantiation@var2063 ;
3205: std ::@expr1073752868 string typeForNewName@var2064 ; typeForNewName@var2064 =@expr1073752869 getNewName (@expr1073752870 tok2@var2060 , typeStringsUsedInTemplateInstantiation@var2063 ) ;
3206:
3207: if (@expr1073752871 typeForNewName@var2064 .@expr1073752872 empty (@expr1073752873 ) ) {
3208: if (@expr10934 printDebug@var2034 &&@expr10935 mErrorLogger@var102 ) {
3209: std ::@expr1073752876 list < const Token *@expr10607 > callstack@var2065 (@expr1073752878 1 , tok2@var2060 ) ;
3210: mErrorLogger@var102 .@expr10684 reportErr (@expr1073752880 ErrorMessage (@expr1073752881 callstack@var2065 , &@expr10942 mTokenList@var100 , Severity ::@expr10943 debug , "debug" ,
3211: "Failed to instantiate template \"" +@expr1073752884 templateDeclaration@var2029 .@expr10653 name (@expr10654 ) +@expr1073752887 "\". The checking continues anyway." , Certainty ::@expr10677 normal ) ) ;
3212: }
3213: return false ;
3214: }
3215:
3216:
3217: const std ::@expr1073752889 string newName@var2066 (@expr1073752890 templateDeclaration@var2029 .@expr10653 name (@expr10654 ) +@expr10956 " < " +@expr1073752894 typeForNewName@var2064 +@expr1073752895 " >" ) ;
3218: const std ::@expr1073752896 string newFullName@var2067 (@expr1073752897 templateDeclaration@var2029 .@expr10712 scope (@expr10713 ) +@expr10963 (@expr1073752901 templateDeclaration@var2029 .@expr10712 scope (@expr10713 ) .@expr10730 empty (@expr10731 ) ?@expr10969 "" :@expr10970 " :: " ) +@expr1073752908 newName@var2066 ) ;
3219:
3220: if (@expr1073752909 expandedtemplates@var2032 .@expr10973 insert (@expr1073752911 newFullName@var2067 ) .@expr1073752912 second@var2068 ) {
3221: expandTemplate (@expr1073752913 templateDeclaration@var2029 , templateDeclaration@var2029 , typeParametersInDeclaration@var2033 , newName@var2066 , !@expr10895 specialized@var2035 &&@expr10978 !@expr10979 isVar@var2037 ) ;
3222: instantiated@var2040 =@expr1073752917 true ;
3223: mChanged@var103 =@expr1073752918 true ;
3224: }
3225:
3226:
3227: replaceTemplateUsage (@expr1073752919 templateDeclaration@var2029 , typeStringsUsedInTemplateInstantiation@var2063 , newName@var2066 ) ;
3228: }
3229:
3230:
3231: return instantiated@var2040 ;
3232: }
3233:
3234: static bool matchTemplateParameters ( const Token * nameTok@var2069 , const std :: list < std :: string > & strings@var2070 )
3235: {
3236: std ::@expr1073752920 list < std ::@expr1073752921 string > ::@expr1073752922 const_iterator it@var2071 ; it@var2071 =@expr1073752923 strings@var2070 .@expr1073752924 begin (@expr1073752925 ) ;
3237: const Token * tok@var2072 ; tok@var2072 =@expr1073752926 nameTok@var2069 .@expr1073752927 tokAt (@expr1073752928 2 ) ;
3238: const Token * end@var2073 ; end@var2073 =@expr1073752929 nameTok@var2069 .@expr1073752930 next (@expr1073752931 ) .@expr1073752932 findClosingBracket (@expr1073752933 ) ;
3239: if (@expr1073752934 !@expr1073752935 end@var2073 ) {
3240: return false ; }
3241: while (@expr1073752936 tok@var2072 &&@expr1073752937 tok@var2072 !=@expr1073752938 end@var2073 &&@expr1073752939 it@var2071 !=@expr1073752940 strings@var2070 .@expr11117 end (@expr11118 ) ) {
3242: if (@expr1073752943 tok@var2072 .@expr1073752944 isUnsigned (@expr1073752945 ) ) {
3243: if (@expr1073752946 *@expr11123 it@var2071 !=@expr1073752948 "unsigned" ) {
3244: return false ; }
3245: else {
3246: ++@expr1073752949 it@var2071 ;
3247: if (@expr11126 it@var2071 ==@expr11127 strings@var2070 .@expr11117 end (@expr11118 ) ) {
3248: return false ; }
3249: }
3250: } else { if (@expr1073752954 tok@var2072 .@expr1073752955 isSigned (@expr1073752956 ) ) {
3251: if (@expr1073752957 *@expr11123 it@var2071 !=@expr1073752959 "signed" ) {
3252: return false ; }
3253: else {
3254: ++@expr1073752960 it@var2071 ;
3255: if (@expr11126 it@var2071 ==@expr11127 strings@var2070 .@expr11117 end (@expr11118 ) ) {
3256: return false ; }
3257: }
3258: } }
3259: if (@expr1073752965 tok@var2072 .@expr1073752966 isLong (@expr1073752967 ) ) {
3260: if (@expr1073752968 *@expr11123 it@var2071 !=@expr1073752970 "long" ) {
3261: return false ; }
3262: else {
3263: ++@expr1073752971 it@var2071 ;
3264: if (@expr11126 it@var2071 ==@expr11127 strings@var2070 .@expr11117 end (@expr11118 ) ) {
3265: return false ; }
3266: }
3267: }
3268: if (@expr1073752976 *@expr11123 it@var2071 !=@expr1073752978 tok@var2072 .@expr11155 str (@expr11156 ) ) {
3269: return false ; }
3270: tok@var2072 =@expr1073752981 tok@var2072 .@expr1073752982 next (@expr1073752983 ) ;
3271: ++@expr1073752984 it@var2071 ;
3272: }
3273: return it@var2071 ==@expr11127 strings@var2070 .@expr11117 end (@expr11118 ) &&@expr1073752988 tok@var2072 &&@expr1073752989 tok@var2072 .@expr11155 str (@expr11156 ) ==@expr1073752992 ">" ;
3274: }
3275:
3276: void TemplateSimplifier :: replaceTemplateUsage (
3277: const TokenAndName & instantiation@var2074 ,
3278: const std :: list < std :: string > & typeStringsUsedInTemplateInstantiation@var2075 ,
3279: const std :: string & newName@var2076 )
3280: {
3281: std ::@expr1073752995 list < std ::@expr11172 pair < Token *@expr11173 , Token *@expr11173 > > removeTokens@var2077 ;
3282: for (@expr1073752999 Token *@expr11173 nameTok@var2078 =@expr1073753001 mTokenList@var100 .@expr1073753002 front (@expr1073753003 ) ; nameTok@var2078 ; nameTok@var2078 =@expr1073753004 nameTok@var2078 .@expr11181 next (@expr11182 ) ) {
3283: if (@expr1073753007 !@expr1073753008 Token ::@expr11185 Match (@expr1073753010 nameTok@var2078 , "%name% <" ) ||@expr1073753011
3284: Token ::@expr11185 Match (@expr1073753013 nameTok@var2078 , "template|const_cast|dynamic_cast|reinterpret_cast|static_cast" ) ) {
3285: continue ; }
3286:
3287: std ::@expr1073753014 set < TemplateSimplifier ::@expr11172 TokenAndName *@expr11173 > * pointers@var2079 ; pointers@var2079 =@expr1073753017 nameTok@var2078 .@expr1073753018 templateSimplifierPointers (@expr1073753019 ) ;
3288:
3289:
3290: if (@expr1073753020 pointers@var2079 &&@expr1073753021 pointers@var2079 .@expr1073753022 size (@expr1073753023 ) ) {
3291:
3292: if (@expr1073753024 instantiation@var2074 .@expr1073753025 fullName (@expr1073753026 ) !=@expr1073753027 (@expr1073753028 *@expr1073753029 pointers@var2079 .@expr1073753030 begin (@expr1073753031 ) ) .@expr1073753032 fullName (@expr1073753033 ) ) {
3293:
3294: if (@expr11210 nameTok@var2078 .@expr11211 str (@expr11212 ) !=@expr11213 instantiation@var2074 .@expr11214 name (@expr11215 ) ) {
3295: continue ; }
3296: }
3297: }
3298:
3299: else {
3300:
3301: if (@expr11210 nameTok@var2078 .@expr11211 str (@expr11212 ) !=@expr11213 instantiation@var2074 .@expr11214 name (@expr11215 ) ) {
3302: continue ; }
3303: }
3304:
3305: if (@expr1073753046 !@expr1073753047 matchTemplateParameters (@expr1073753048 nameTok@var2078 , typeStringsUsedInTemplateInstantiation@var2075 ) ) {
3306: continue ; }
3307:
3308: Token * tok2@var2080 ; tok2@var2080 =@expr1073753049 nameTok@var2078 .@expr11181 next (@expr11182 ) .@expr1073753052 findClosingBracket (@expr1073753053 ) ;
3309:
3310: if (@expr1073753054 !@expr1073753055 tok2@var2080 ) {
3311: break ; }
3312:
3313: const Token * const nameTok1@var2081 ; nameTok1@var2081 =@expr1073753056 nameTok@var2078 ;
3314: nameTok@var2078 .@expr11211 str (@expr1073753058 newName@var2076 ) ;
3315:
3316:
3317:
3318: for (@expr1073753059 Token *@expr11173 tok@var2082 =@expr1073753061 nameTok1@var2081 .@expr1073753062 next (@expr1073753063 ) ; tok@var2082 !=@expr1073753064 tok2@var2080 ; tok@var2082 =@expr1073753065 tok@var2082 .@expr1073753066 next (@expr1073753067 ) ) {
3319: if (@expr1073753068 tok@var2082 .@expr1073753069 isName (@expr1073753070 ) &&@expr1073753071 tok@var2082 .@expr11248 templateSimplifierPointers (@expr11249 ) &&@expr1073753074 !@expr1073753075 tok@var2082 .@expr11248 templateSimplifierPointers (@expr11249 ) .@expr1073753078 empty (@expr1073753079 ) ) {
3320: std ::@expr1073753080 list < TokenAndName > ::@expr1073753081 iterator ti@var2083 ;
3321: for (@expr1073753082 ti@var2083 =@expr1073753083 mTemplateInstantiations@var109 .@expr1073753084 begin (@expr1073753085 ) ; ti@var2083 !=@expr1073753086 mTemplateInstantiations@var109 .@expr1073753087 end (@expr1073753088 ) ; ) {
3322: if (@expr1073753089 ti@var2083 .@expr1073753090 token (@expr1073753091 ) ==@expr1073753092 tok@var2082 ) {
3323: mTemplateInstantiations@var109 .@expr1073753093 erase (@expr1073753094 ti@var2083 ++@expr1073753095 ) ;
3324: break ;
3325: } else {
3326: ++@expr1073753096 ti@var2083 ;
3327: }
3328: }
3329: }
3330: }
3331:
3332: if (@expr1073753097 Token ::@expr1073753098 simpleMatch (@expr1073753099 nameTok@var2078 .@expr11276 previous (@expr11277 ) , ">" ) ) {
3333: mTemplateNamePos@var114 .@expr1073753102 erase (@expr1073753103 nameTok@var2078 .@expr11276 previous (@expr11277 ) ) ; }
3334: removeTokens@var2077 .@expr1073753106 emplace_back (@expr1073753107 nameTok@var2078 , tok2@var2080 .@expr1073753108 next (@expr1073753109 ) ) ;
3335:
3336: nameTok@var2078 =@expr1073753110 tok2@var2080 ;
3337: }
3338: while (@expr1073753111 !@expr1073753112 removeTokens@var2077 .@expr1073753113 empty (@expr1073753114 ) ) {
3339: eraseTokens (@expr1073753115 removeTokens@var2077 .@expr11292 back (@expr11293 ) .@expr1073753118 first@expr1073752993 , removeTokens@var2077 .@expr11292 back (@expr11293 ) .@expr1073753121 second@expr1073752994 ) ;
3340: removeTokens@var2077 .@expr1073753122 pop_back (@expr1073753123 ) ;
3341: }
3342: }
3343:
3344: static bool specMatch (
3345: const TemplateSimplifier :: TokenAndName & spec@var2084 ,
3346: const TemplateSimplifier :: TokenAndName & decl@var2085 )
3347: {
3348:
3349: if (@expr1073753124 decl@var2085 .@expr1073753125 isPartialSpecialization (@expr1073753126 ) ||@expr1073753127 decl@var2085 .@expr1073753128 isSpecialization (@expr1073753129 ) ||@expr1073753130 decl@var2085 .@expr1073753131 isAlias (@expr1073753132 ) ||@expr1073753133 decl@var2085 .@expr1073753134 isFriend (@expr1073753135 ) ) {
3350: return false ; }
3351:
3352: if (@expr1073753136 !@expr1073753137 spec@var2084 .@expr1073753138 isSameFamily (@expr1073753139 decl@var2085 ) ) {
3353: return false ; }
3354:
3355:
3356: if (@expr1073753140 spec@var2084 .@expr1073753141 fullName (@expr1073753142 ) ==@expr1073753143 decl@var2085 .@expr1073753144 fullName (@expr1073753145 ) ) {
3357: if (@expr1073753146 spec@var2084 .@expr1073753147 isFunction (@expr1073753148 ) ) {
3358: std ::@expr1073753149 vector < const Token *@expr11326 > specArgs@var2086 ;
3359: std ::@expr1073753151 vector < const Token *@expr11326 > declArgs@var2087 ;
3360: getFunctionArguments (@expr1073753153 spec@var2084 .@expr1073753154 nameToken (@expr1073753155 ) , specArgs@var2086 ) ;
3361: getFunctionArguments (@expr1073753156 decl@var2085 .@expr1073753157 nameToken (@expr1073753158 ) , declArgs@var2087 ) ;
3362:
3363: if (@expr1073753159 specArgs@var2086 .@expr1073753160 size (@expr1073753161 ) ==@expr1073753162 declArgs@var2087 .@expr1073753163 size (@expr1073753164 ) ) {
3364:
3365: return true ;
3366: }
3367: } else {
3368: return true ; }
3369: }
3370:
3371: return false ;
3372: }
3373:
3374: void TemplateSimplifier :: getSpecializations ( )
3375: {
3376:
3377: for (@expr1073753165 auto &@expr11342 spec@var2088 :@expr1073753167 mTemplateDeclarations@var104 ) {
3378: if (@expr1073753168 spec@var2088 .@expr1073753169 isSpecialization (@expr1073753170 ) ) {
3379: bool found@var2089 ; found@var2089 =@expr1073753171 false ;
3380: for (@expr1073753172 auto &@expr11342 decl@var2090 :@expr1073753174 mTemplateDeclarations@var104 ) {
3381: if (@expr1073753175 specMatch (@expr1073753176 spec@var2088 , decl@var2090 ) ) {
3382: mTemplateSpecializationMap@var107 [@expr11353 spec@var2088 .@expr11354 token (@expr11355 ) ] =@expr1073753180 decl@var2090 .@expr1073753181 token (@expr1073753182 ) ;
3383: found@var2089 =@expr1073753183 true ;
3384: break ;
3385: }
3386: }
3387:
3388: if (@expr1073753184 !@expr1073753185 found@var2089 ) {
3389: for (@expr1073753186 auto &@expr11342 decl@var2091 :@expr1073753188 mTemplateForwardDeclarations@var105 ) {
3390: if (@expr1073753189 specMatch (@expr1073753190 spec@var2088 , decl@var2091 ) ) {
3391: mTemplateSpecializationMap@var107 [@expr11353 spec@var2088 .@expr11354 token (@expr11355 ) ] =@expr1073753194 decl@var2091 .@expr1073753195 token (@expr1073753196 ) ;
3392: break ;
3393: }
3394: }
3395: }
3396: }
3397: }
3398: }
3399:
3400: void TemplateSimplifier :: getPartialSpecializations ( )
3401: {
3402:
3403: for (@expr1073753197 auto &@expr11374 spec@var2092 :@expr1073753199 mTemplateDeclarations@var104 ) {
3404: if (@expr1073753200 spec@var2092 .@expr1073753201 isPartialSpecialization (@expr1073753202 ) ) {
3405: bool found@var2093 ; found@var2093 =@expr1073753203 false ;
3406: for (@expr1073753204 auto &@expr11374 decl@var2094 :@expr1073753206 mTemplateDeclarations@var104 ) {
3407: if (@expr1073753207 specMatch (@expr1073753208 spec@var2092 , decl@var2094 ) ) {
3408: mTemplatePartialSpecializationMap@var108 [@expr11385 spec@var2092 .@expr11386 token (@expr11387 ) ] =@expr1073753212 decl@var2094 .@expr1073753213 token (@expr1073753214 ) ;
3409: found@var2093 =@expr1073753215 true ;
3410: break ;
3411: }
3412: }
3413:
3414: if (@expr1073753216 !@expr1073753217 found@var2093 ) {
3415: for (@expr1073753218 auto &@expr11374 decl@var2095 :@expr1073753220 mTemplateForwardDeclarations@var105 ) {
3416: if (@expr1073753221 specMatch (@expr1073753222 spec@var2092 , decl@var2095 ) ) {
3417: mTemplatePartialSpecializationMap@var108 [@expr11385 spec@var2092 .@expr11386 token (@expr11387 ) ] =@expr1073753226 decl@var2095 .@expr1073753227 token (@expr1073753228 ) ;
3418: break ;
3419: }
3420: }
3421: }
3422: }
3423: }
3424: }
3425:
3426: void TemplateSimplifier :: fixForwardDeclaredDefaultArgumentValues ( )
3427: {
3428:
3429: for (@expr1073753229 const auto &@expr11406 forwardDecl@var2096 :@expr1073753231 mTemplateForwardDeclarations@var105 ) {
3430: std ::@expr1073753232 vector < const Token *@expr11409 > params1@var2097 ;
3431:
3432: getTemplateParametersInDeclaration (@expr1073753234 forwardDecl@var2096 .@expr11411 token (@expr11412 ) .@expr1073753237 tokAt (@expr1073753238 2 ) , params1@var2097 ) ;
3433:
3434: for (@expr1073753239 auto &@expr11406 decl@var2098 :@expr1073753241 mTemplateDeclarations@var104 ) {
3435:
3436: if (@expr1073753242 decl@var2098 .@expr1073753243 isPartialSpecialization (@expr1073753244 ) ||@expr1073753245 decl@var2098 .@expr1073753246 isAlias (@expr1073753247 ) ||@expr1073753248 decl@var2098 .@expr1073753249 isFriend (@expr1073753250 ) ) {
3437: continue ; }
3438:
3439: std ::@expr1073753251 vector < const Token *@expr11409 > params2@var2099 ;
3440:
3441: getTemplateParametersInDeclaration (@expr1073753253 decl@var2098 .@expr11430 token (@expr11431 ) .@expr1073753256 tokAt (@expr1073753257 2 ) , params2@var2099 ) ;
3442:
3443:
3444: if (@expr1073753258 params1@var2097 .@expr11435 size (@expr11436 ) ==@expr1073753261 params2@var2099 .@expr1073753262 size (@expr1073753263 ) ) {
3445:
3446: if (@expr1073753264 forwardDecl@var2096 .@expr1073753265 fullName (@expr1073753266 ) ==@expr1073753267 decl@var2098 .@expr1073753268 fullName (@expr1073753269 ) ) {
3447:
3448: if (@expr1073753270 (@expr1073753271 decl@var2098 .@expr11448 nameToken (@expr11449 ) .@expr11450 strAt (@expr11451 1 ) ==@expr1073753276 "(" &&@expr1073753277 forwardDecl@var2096 .@expr11454 nameToken (@expr11455 ) .@expr11456 strAt (@expr11457 1 ) ==@expr1073753282 "(" ) ||@expr1073753283
3449: (@expr1073753284 decl@var2098 .@expr11448 nameToken (@expr11449 ) .@expr11450 strAt (@expr11451 1 ) ==@expr1073753289 "{" &&@expr1073753290 forwardDecl@var2096 .@expr11454 nameToken (@expr11455 ) .@expr11456 strAt (@expr11457 1 ) ==@expr1073753295 ";" ) ) {
3450: mTemplateForwardDeclarationsMap@var106 [@expr1073753296 decl@var2098 .@expr11430 token (@expr11431 ) ] =@expr1073753299 forwardDecl@var2096 .@expr11411 token (@expr11412 ) ;
3451: }
3452:
3453: for (@expr1073753302 unsigned long k@var2100 =@expr1073753303 0 ; k@var2100 <@expr1073753304 params1@var2097 .@expr11435 size (@expr11436 ) ; k@var2100 ++@expr1073753307 ) {
3454:
3455: if (@expr1073753308 params1@var2097 [@expr11485 k@var2100 ] .@expr1073753310 strAt (@expr1073753311 1 ) ==@expr1073753312 "=" &&@expr1073753313 params2@var2099 [@expr11490 k@var2100 ] .@expr1073753315 strAt (@expr1073753316 1 ) !=@expr1073753317 "=" ) {
3456: int level@var2101 ; level@var2101 =@expr1073753318 0 ;
3457: const Token * end@var2102 ; end@var2102 =@expr1073753319 params1@var2097 [@expr11485 k@var2100 ] .@expr11497 next (@expr11498 ) ;
3458: while (@expr1073753323 end@var2102 &&@expr1073753324 !@expr1073753325 (@expr1073753326 level@var2101 ==@expr1073753327 0 &&@expr1073753328 Token ::@expr11505 Match (@expr1073753330 end@var2102 , ",|>" ) ) ) {
3459: if (@expr1073753331 Token ::@expr11505 Match (@expr1073753333 end@var2102 , "{|(|<" ) ) {
3460: level@var2101 ++@expr1073753334 ; }
3461: else { if (@expr1073753335 Token ::@expr11505 Match (@expr1073753337 end@var2102 , "}|)|>" ) ) {
3462: level@var2101 --@expr1073753338 ; } }
3463: end@var2102 =@expr1073753339 end@var2102 .@expr1073753340 next (@expr1073753341 ) ;
3464: }
3465: if (@expr1073753342 end@var2102 ) {
3466: TokenList ::@expr1073753343 copyTokens (@expr1073753344 const_cast < Token *@expr11409 > (@expr1073753346 params2@var2099 [@expr11490 k@var2100 ] ) , params1@var2097 [@expr11485 k@var2100 ] .@expr11497 next (@expr11498 ) , end@var2102 .@expr1073753351 previous (@expr1073753352 ) ) ; }
3467: }
3468: }
3469:
3470:
3471: decl@var2098 .@expr1073753353 paramEnd (@expr1073753354 decl@var2098 .@expr11430 token (@expr11431 ) .@expr1073753357 next (@expr1073753358 ) .@expr1073753359 findClosingBracket (@expr1073753360 ) ) ;
3472: }
3473: }
3474: }
3475: }
3476: }
3477:
3478: void TemplateSimplifier :: printOut ( const TokenAndName & tokenAndName@var2103 , const std :: string & indent@var2104 ) const
3479: {
3480: std ::@expr11539 cout@expr11537 <<@expr11540 indent@var2104 <<@expr1073753365 "token: " ;
3481: if (@expr1073753366 tokenAndName@var2103 .@expr11543 token (@expr11544 ) ) {
3482: std ::@expr11539 cout@expr11537 <<@expr11546 "\"" <<@expr1073753371 tokenAndName@var2103 .@expr11543 token (@expr11544 ) .@expr1073753374 str (@expr1073753375 ) <<@expr1073753376 "\" " <<@expr1073753377 mTokenList@var100 .@expr11554 fileLine (@expr1073753379 tokenAndName@var2103 .@expr11543 token (@expr11544 ) ) ; }
3483: else {
3484: std ::@expr11539 cout@expr11537 <<@expr11559 "nullptr" ; }
3485: std ::@expr11539 cout@expr11537 <<@expr11561 std ::@expr11562 endl@expr11538 ;
3486: std ::@expr11539 cout@expr11537 <<@expr11540 indent@var2104 <<@expr1073753389 "scope: \"" <<@expr1073753390 tokenAndName@var2103 .@expr1073753391 scope (@expr1073753392 ) <<@expr1073753393 "\"" <<@expr1073753394 std ::@expr11562 endl@expr11538 ;
3487: std ::@expr11539 cout@expr11537 <<@expr11540 indent@var2104 <<@expr1073753398 "name: \"" <<@expr1073753399 tokenAndName@var2103 .@expr1073753400 name (@expr1073753401 ) <<@expr1073753402 "\"" <<@expr1073753403 std ::@expr11562 endl@expr11538 ;
3488: std ::@expr11539 cout@expr11537 <<@expr11540 indent@var2104 <<@expr1073753407 "fullName: \"" <<@expr1073753408 tokenAndName@var2103 .@expr1073753409 fullName (@expr1073753410 ) <<@expr1073753411 "\"" <<@expr1073753412 std ::@expr11562 endl@expr11538 ;
3489: std ::@expr11539 cout@expr11537 <<@expr11540 indent@var2104 <<@expr1073753416 "nameToken: " ;
3490: if (@expr1073753417 tokenAndName@var2103 .@expr11594 nameToken (@expr11595 ) ) {
3491: std ::@expr11539 cout@expr11537 <<@expr11546 "\"" <<@expr1073753422 tokenAndName@var2103 .@expr11594 nameToken (@expr11595 ) .@expr1073753425 str (@expr1073753426 ) <<@expr1073753427 "\" " <<@expr1073753428 mTokenList@var100 .@expr11554 fileLine (@expr1073753430 tokenAndName@var2103 .@expr11594 nameToken (@expr11595 ) ) ; }
3492: else {
3493: std ::@expr11539 cout@expr11537 <<@expr11559 "nullptr" ; }
3494: std ::@expr11539 cout@expr11537 <<@expr11561 std ::@expr11562 endl@expr11538 ;
3495: std ::@expr11539 cout@expr11537 <<@expr11540 indent@var2104 <<@expr1073753440 "paramEnd: " ;
3496: if (@expr1073753441 tokenAndName@var2103 .@expr11618 paramEnd (@expr11619 ) ) {
3497: std ::@expr11539 cout@expr11537 <<@expr11546 "\"" <<@expr1073753446 tokenAndName@var2103 .@expr11618 paramEnd (@expr11619 ) .@expr1073753449 str (@expr1073753450 ) <<@expr1073753451 "\" " <<@expr1073753452 mTokenList@var100 .@expr11554 fileLine (@expr1073753454 tokenAndName@var2103 .@expr11618 paramEnd (@expr11619 ) ) ; }
3498: else {
3499: std ::@expr11539 cout@expr11537 <<@expr11559 "nullptr" ; }
3500: std ::@expr11539 cout@expr11537 <<@expr11561 std ::@expr11562 endl@expr11538 ;
3501: std ::@expr11539 cout@expr11537 <<@expr11540 indent@var2104 <<@expr1073753464 "flags: " ;
3502: if (@expr1073753465 tokenAndName@var2103 .@expr1073753466 isClass (@expr1073753467 ) ) {
3503: std ::@expr11539 cout@expr11537 <<@expr1073753469 " isClass" ; }
3504: if (@expr1073753470 tokenAndName@var2103 .@expr1073753471 isFunction (@expr1073753472 ) ) {
3505: std ::@expr11539 cout@expr11537 <<@expr1073753474 " isFunction" ; }
3506: if (@expr1073753475 tokenAndName@var2103 .@expr1073753476 isVariable (@expr1073753477 ) ) {
3507: std ::@expr11539 cout@expr11537 <<@expr1073753479 " isVariable" ; }
3508: if (@expr1073753480 tokenAndName@var2103 .@expr11657 isAlias (@expr11658 ) ) {
3509: std ::@expr11539 cout@expr11537 <<@expr1073753484 " isAlias" ; }
3510: if (@expr1073753485 tokenAndName@var2103 .@expr1073753486 isSpecialization (@expr1073753487 ) ) {
3511: std ::@expr11539 cout@expr11537 <<@expr1073753489 " isSpecialization" ; }
3512: if (@expr1073753490 tokenAndName@var2103 .@expr1073753491 isPartialSpecialization (@expr1073753492 ) ) {
3513: std ::@expr11539 cout@expr11537 <<@expr1073753494 " isPartialSpecialization" ; }
3514: if (@expr1073753495 tokenAndName@var2103 .@expr1073753496 isForwardDeclaration (@expr1073753497 ) ) {
3515: std ::@expr11539 cout@expr11537 <<@expr1073753499 " isForwardDeclaration" ; }
3516: if (@expr1073753500 tokenAndName@var2103 .@expr1073753501 isVariadic (@expr1073753502 ) ) {
3517: std ::@expr11539 cout@expr11537 <<@expr1073753504 " isVariadic" ; }
3518: if (@expr1073753505 tokenAndName@var2103 .@expr1073753506 isFriend (@expr1073753507 ) ) {
3519: std ::@expr11539 cout@expr11537 <<@expr1073753509 " isFriend" ; }
3520: std ::@expr11539 cout@expr11537 <<@expr11561 std ::@expr11562 endl@expr11538 ;
3521: if (@expr1073753513 tokenAndName@var2103 .@expr11543 token (@expr11544 ) &&@expr1073753516 !@expr1073753517 tokenAndName@var2103 .@expr11618 paramEnd (@expr11619 ) &&@expr1073753520 tokenAndName@var2103 .@expr11543 token (@expr11544 ) .@expr1073753523 strAt (@expr1073753524 1 ) ==@expr1073753525 "<" ) {
3522: const Token * end@var2105 ; end@var2105 =@expr1073753526 tokenAndName@var2103 .@expr11543 token (@expr11544 ) .@expr11705 next (@expr11706 ) .@expr1073753531 findClosingBracket (@expr1073753532 ) ;
3523: if (@expr1073753533 end@var2105 ) {
3524: const Token * start@var2106 ; start@var2106 =@expr1073753534 tokenAndName@var2103 .@expr11543 token (@expr11544 ) .@expr11705 next (@expr11706 ) ;
3525: std ::@expr11539 cout@expr11537 <<@expr11540 indent@var2104 <<@expr1073753541 "type: " ;
3526: while (@expr1073753542 start@var2106 &&@expr1073753543 start@var2106 !=@expr1073753544 end@var2105 ) {
3527: if (@expr1073753545 start@var2106 .@expr1073753546 isUnsigned (@expr1073753547 ) ) {
3528: std ::@expr11539 cout@expr11537 <<@expr1073753549 "unsigned" ; }
3529: else { if (@expr1073753550 start@var2106 .@expr1073753551 isSigned (@expr1073753552 ) ) {
3530: std ::@expr11539 cout@expr11537 <<@expr1073753554 "signed" ; } }
3531: if (@expr1073753555 start@var2106 .@expr1073753556 isLong (@expr1073753557 ) ) {
3532: std ::@expr11539 cout@expr11537 <<@expr1073753559 "long" ; }
3533: std ::@expr11539 cout@expr11537 <<@expr1073753561 start@var2106 .@expr1073753562 str (@expr1073753563 ) ;
3534: start@var2106 =@expr1073753564 start@var2106 .@expr1073753565 next (@expr1073753566 ) ;
3535: }
3536: std ::@expr11539 cout@expr11537 <<@expr1073753568 end@var2105 .@expr1073753569 str (@expr1073753570 ) <<@expr1073753571 std ::@expr11562 endl@expr11538 ;
3537: }
3538: } else { if (@expr1073753573 tokenAndName@var2103 .@expr11657 isAlias (@expr11658 ) &&@expr1073753576 tokenAndName@var2103 .@expr11618 paramEnd (@expr11619 ) ) {
3539: if (@expr1073753579 tokenAndName@var2103 .@expr11756 aliasStartToken (@expr11757 ) ) {
3540: std ::@expr11539 cout@expr11537 <<@expr11540 indent@var2104 <<@expr1073753584 "aliasStartToken: \"" <<@expr1073753585 tokenAndName@var2103 .@expr11756 aliasStartToken (@expr11757 ) .@expr1073753588 str (@expr1073753589 ) <<@expr1073753590 "\" "
3541: <<@expr1073753591 mTokenList@var100 .@expr11554 fileLine (@expr1073753593 tokenAndName@var2103 .@expr11756 aliasStartToken (@expr11757 ) ) <<@expr1073753596 std ::@expr11562 endl@expr11538 ;
3542: }
3543: if (@expr1073753598 tokenAndName@var2103 .@expr11775 aliasEndToken (@expr11776 ) ) {
3544: std ::@expr11539 cout@expr11537 <<@expr11540 indent@var2104 <<@expr1073753603 "aliasEndToken: \"" <<@expr1073753604 tokenAndName@var2103 .@expr11775 aliasEndToken (@expr11776 ) .@expr1073753607 str (@expr1073753608 ) <<@expr1073753609 "\" "
3545: <<@expr1073753610 mTokenList@var100 .@expr11554 fileLine (@expr1073753612 tokenAndName@var2103 .@expr11775 aliasEndToken (@expr11776 ) ) <<@expr1073753615 std ::@expr11562 endl@expr11538 ;
3546: }
3547: } }
3548: }
3549:
3550: void TemplateSimplifier :: printOut ( const std :: string & text@var2107 ) const
3551: {
3552: std ::@expr11795 cout@expr11793 <<@expr11796 std ::@expr11797 endl@expr11794 ;
3553: std ::@expr11795 cout@expr11793 <<@expr1073753623 text@var2107 <<@expr1073753624 std ::@expr11797 endl@expr11794 ;
3554: std ::@expr11795 cout@expr11793 <<@expr11796 std ::@expr11797 endl@expr11794 ;
3555: std ::@expr11795 cout@expr11793 <<@expr1073753630 "mTemplateDeclarations: " <<@expr1073753631 mTemplateDeclarations@var104 .@expr1073753632 size (@expr1073753633 ) <<@expr1073753634 std ::@expr11797 endl@expr11794 ;
3556: int count@var2108 ; count@var2108 =@expr1073753636 0 ;
3557: for (@expr1073753637 const auto &@expr11814 decl@var2109 :@expr1073753639 mTemplateDeclarations@var104 ) {
3558: std ::@expr11795 cout@expr11793 <<@expr1073753641 "mTemplateDeclarations[" <<@expr1073753642 count@var2108 ++@expr1073753643 <<@expr1073753644 "]:" <<@expr1073753645 std ::@expr11797 endl@expr11794 ;
3559: printOut (@expr1073753647 decl@var2109 ) ;
3560: }
3561: std ::@expr11795 cout@expr11793 <<@expr1073753649 "mTemplateForwardDeclarations: " <<@expr1073753650 mTemplateForwardDeclarations@var105 .@expr1073753651 size (@expr1073753652 ) <<@expr1073753653 std ::@expr11797 endl@expr11794 ;
3562: count@var2108 =@expr1073753655 0 ;
3563: for (@expr1073753656 const auto &@expr11814 decl@var2110 :@expr1073753658 mTemplateForwardDeclarations@var105 ) {
3564: std ::@expr11795 cout@expr11793 <<@expr1073753660 "mTemplateForwardDeclarations[" <<@expr1073753661 count@var2108 ++@expr1073753662 <<@expr1073753663 "]:" <<@expr1073753664 std ::@expr11797 endl@expr11794 ;
3565: printOut (@expr1073753666 decl@var2110 ) ;
3566: }
3567: std ::@expr11795 cout@expr11793 <<@expr1073753668 "mTemplateForwardDeclarationsMap: " <<@expr1073753669 mTemplateForwardDeclarationsMap@var106 .@expr1073753670 size (@expr1073753671 ) <<@expr1073753672 std ::@expr11797 endl@expr11794 ;
3568: unsigned int mapIndex@var2111 ; mapIndex@var2111 =@expr1073753674 0 ;
3569: for (@expr1073753675 const auto &@expr11814 mapItem@var2112 :@expr1073753677 mTemplateForwardDeclarationsMap@var106 ) {
3570: unsigned int declIndex@var2113 ; declIndex@var2113 =@expr1073753678 0 ;
3571: for (@expr1073753679 const auto &@expr11814 decl@var2114 :@expr1073753681 mTemplateDeclarations@var104 ) {
3572: if (@expr1073753682 mapItem@var2112 .@expr1073753683 first@var2115 ==@expr1073753684 decl@var2114 .@expr1073753685 token (@expr1073753686 ) ) {
3573: unsigned int forwardIndex@var2116 ; forwardIndex@var2116 =@expr1073753687 0 ;
3574: for (@expr1073753688 const auto &@expr11814 forwardDecl@var2117 :@expr1073753690 mTemplateForwardDeclarations@var105 ) {
3575: if (@expr1073753691 mapItem@var2112 .@expr1073753692 second@var2118 ==@expr1073753693 forwardDecl@var2117 .@expr1073753694 token (@expr1073753695 ) ) {
3576: std ::@expr11795 cout@expr11793 <<@expr1073753697 "mTemplateForwardDeclarationsMap[" <<@expr1073753698 mapIndex@var2111 <<@expr1073753699 "]:" <<@expr1073753700 std ::@expr11797 endl@expr11794 ;
3577: std ::@expr11795 cout@expr11793 <<@expr11879 "    mTemplateDeclarations[" <<@expr1073753704 declIndex@var2113
3578: <<@expr1073753705 "] => mTemplateForwardDeclarations[" <<@expr1073753706 forwardIndex@var2116 <<@expr1073753707 "]" <<@expr1073753708 std ::@expr11797 endl@expr11794 ;
3579: break ;
3580: }
3581: forwardIndex@var2116 ++@expr1073753710 ;
3582: }
3583: break ;
3584: }
3585: declIndex@var2113 ++@expr1073753711 ;
3586: }
3587: mapIndex@var2111 ++@expr1073753712 ;
3588: }
3589: std ::@expr11795 cout@expr11793 <<@expr1073753714 "mTemplateSpecializationMap: " <<@expr1073753715 mTemplateSpecializationMap@var107 .@expr1073753716 size (@expr1073753717 ) <<@expr1073753718 std ::@expr11797 endl@expr11794 ;
3590: for (@expr1073753720 const auto &@expr11814 mapItem@var2119 :@expr1073753722 mTemplateSpecializationMap@var107 ) {
3591: unsigned int decl1Index@var2120 ; decl1Index@var2120 =@expr1073753723 0 ;
3592: for (@expr1073753724 const auto &@expr11814 decl1@var2121 :@expr1073753726 mTemplateDeclarations@var104 ) {
3593: if (@expr1073753727 decl1@var2121 .@expr1073753728 isSpecialization (@expr1073753729 ) &&@expr1073753730 mapItem@var2119 .@expr1073753731 first@var2122 ==@expr1073753732 decl1@var2121 .@expr1073753733 token (@expr1073753734 ) ) {
3594: bool found@var2123 ; found@var2123 =@expr1073753735 false ;
3595: unsigned int decl2Index@var2124 ; decl2Index@var2124 =@expr1073753736 0 ;
3596: for (@expr1073753737 const auto &@expr11814 decl2@var2125 :@expr1073753739 mTemplateDeclarations@var104 ) {
3597: if (@expr1073753740 mapItem@var2119 .@expr11917 second@var2126 ==@expr1073753742 decl2@var2125 .@expr1073753743 token (@expr1073753744 ) ) {
3598: std ::@expr11795 cout@expr11793 <<@expr11922 "mTemplateSpecializationMap[" <<@expr11923 mapIndex@var2111 <<@expr11924 "]:" <<@expr11925 std ::@expr11797 endl@expr11794 ;
3599: std ::@expr11795 cout@expr11793 <<@expr11879 "    mTemplateDeclarations[" <<@expr11929 decl1Index@var2120
3600: <<@expr1073753754 "] => mTemplateDeclarations[" <<@expr1073753755 decl2Index@var2124 <<@expr1073753756 "]" <<@expr1073753757 std ::@expr11797 endl@expr11794 ;
3601: found@var2123 =@expr1073753759 true ;
3602: break ;
3603: }
3604: decl2Index@var2124 ++@expr1073753760 ;
3605: }
3606: if (@expr1073753761 !@expr1073753762 found@var2123 ) {
3607: decl2Index@var2124 =@expr1073753763 0 ;
3608: for (@expr1073753764 const auto &@expr11814 decl2@var2127 :@expr1073753766 mTemplateForwardDeclarations@var105 ) {
3609: if (@expr1073753767 mapItem@var2119 .@expr11917 second@var2126 ==@expr1073753769 decl2@var2127 .@expr1073753770 token (@expr1073753771 ) ) {
3610: std ::@expr11795 cout@expr11793 <<@expr11922 "mTemplateSpecializationMap[" <<@expr11923 mapIndex@var2111 <<@expr11924 "]:" <<@expr11925 std ::@expr11797 endl@expr11794 ;
3611: std ::@expr11795 cout@expr11793 <<@expr11879 "    mTemplateDeclarations[" <<@expr11929 decl1Index@var2120
3612: <<@expr1073753781 "] => mTemplateForwardDeclarations[" <<@expr1073753782 decl2Index@var2124 <<@expr1073753783 "]" <<@expr1073753784 std ::@expr11797 endl@expr11794 ;
3613: break ;
3614: }
3615: decl2Index@var2124 ++@expr1073753786 ;
3616: }
3617: }
3618: break ;
3619: }
3620: decl1Index@var2120 ++@expr1073753787 ;
3621: }
3622: mapIndex@var2111 ++@expr1073753788 ;
3623: }
3624: std ::@expr11795 cout@expr11793 <<@expr1073753790 "mTemplatePartialSpecializationMap: " <<@expr1073753791 mTemplatePartialSpecializationMap@var108 .@expr1073753792 size (@expr1073753793 ) <<@expr1073753794 std ::@expr11797 endl@expr11794 ;
3625: for (@expr1073753796 const auto &@expr11814 mapItem@var2128 :@expr1073753798 mTemplatePartialSpecializationMap@var108 ) {
3626: unsigned int decl1Index@var2129 ; decl1Index@var2129 =@expr1073753799 0 ;
3627: for (@expr1073753800 const auto &@expr11814 decl1@var2130 :@expr1073753802 mTemplateDeclarations@var104 ) {
3628: if (@expr1073753803 mapItem@var2128 .@expr1073753804 first@var2131 ==@expr1073753805 decl1@var2130 .@expr1073753806 token (@expr1073753807 ) ) {
3629: bool found@var2132 ; found@var2132 =@expr1073753808 false ;
3630: unsigned int decl2Index@var2133 ; decl2Index@var2133 =@expr1073753809 0 ;
3631: for (@expr1073753810 const auto &@expr11814 decl2@var2134 :@expr1073753812 mTemplateDeclarations@var104 ) {
3632: if (@expr1073753813 mapItem@var2128 .@expr11990 second@var2135 ==@expr1073753815 decl2@var2134 .@expr1073753816 token (@expr1073753817 ) ) {
3633: std ::@expr11795 cout@expr11793 <<@expr11995 "mTemplatePartialSpecializationMap[" <<@expr11996 mapIndex@var2111 <<@expr11997 "]:" <<@expr11998 std ::@expr11797 endl@expr11794 ;
3634: std ::@expr11795 cout@expr11793 <<@expr11879 "    mTemplateDeclarations[" <<@expr12002 decl1Index@var2129
3635: <<@expr1073753827 "] => mTemplateDeclarations[" <<@expr1073753828 decl2Index@var2133 <<@expr1073753829 "]" <<@expr1073753830 std ::@expr11797 endl@expr11794 ;
3636: found@var2132 =@expr1073753832 true ;
3637: break ;
3638: }
3639: decl2Index@var2133 ++@expr1073753833 ;
3640: }
3641: if (@expr1073753834 !@expr1073753835 found@var2132 ) {
3642: decl2Index@var2133 =@expr1073753836 0 ;
3643: for (@expr1073753837 const auto &@expr11814 decl2@var2136 :@expr1073753839 mTemplateForwardDeclarations@var105 ) {
3644: if (@expr1073753840 mapItem@var2128 .@expr11990 second@var2135 ==@expr1073753842 decl2@var2136 .@expr1073753843 token (@expr1073753844 ) ) {
3645: std ::@expr11795 cout@expr11793 <<@expr11995 "mTemplatePartialSpecializationMap[" <<@expr11996 mapIndex@var2111 <<@expr11997 "]:" <<@expr11998 std ::@expr11797 endl@expr11794 ;
3646: std ::@expr11795 cout@expr11793 <<@expr11879 "    mTemplateDeclarations[" <<@expr12002 decl1Index@var2129
3647: <<@expr1073753854 "] => mTemplateForwardDeclarations[" <<@expr1073753855 decl2Index@var2133 <<@expr1073753856 "]" <<@expr1073753857 std ::@expr11797 endl@expr11794 ;
3648: break ;
3649: }
3650: decl2Index@var2133 ++@expr1073753859 ;
3651: }
3652: }
3653: break ;
3654: }
3655: decl1Index@var2129 ++@expr1073753860 ;
3656: }
3657: mapIndex@var2111 ++@expr1073753861 ;
3658: }
3659: std ::@expr11795 cout@expr11793 <<@expr1073753863 "mTemplateInstantiations: " <<@expr1073753864 mTemplateInstantiations@var109 .@expr1073753865 size (@expr1073753866 ) <<@expr1073753867 std ::@expr11797 endl@expr11794 ;
3660: count@var2108 =@expr1073753869 0 ;
3661: for (@expr1073753870 const auto &@expr11814 decl@var2137 :@expr1073753872 mTemplateInstantiations@var109 ) {
3662: std ::@expr11795 cout@expr11793 <<@expr1073753874 "mTemplateInstantiations[" <<@expr1073753875 count@var2108 ++@expr1073753876 <<@expr1073753877 "]:" <<@expr1073753878 std ::@expr11797 endl@expr11794 ;
3663: printOut (@expr1073753880 decl@var2137 ) ;
3664: }
3665: }
3666:
3667: void TemplateSimplifier :: simplifyTemplates (
3668: const std :: time_t maxtime@var2138 ,
3669: bool & codeWithTemplates@var2139 )
3670: {
3671:
3672: for (@expr1073753881 Token *@expr12058 tok@var2140 =@expr1073753883 mTokenList@var100 .@expr12060 front (@expr12061 ) ; tok@var2140 ; tok@var2140 =@expr1073753886 tok@var2140 .@expr1073753887 next (@expr1073753888 ) ) {
3673: if (@expr1073753889 Token ::@expr12066 simpleMatch (@expr1073753891 tok@var2140 , "sizeof ..." ) ) {
3674: tok@var2140 .@expr1073753892 str (@expr1073753893 "sizeof..." ) ;
3675: tok@var2140 .@expr1073753894 deleteNext (@expr1073753895 ) ;
3676: }
3677: }
3678:
3679:
3680: for (@expr1073753896 Token *@expr12058 tok@var2141 =@expr1073753898 mTokenList@var100 .@expr12060 front (@expr12061 ) ; tok@var2141 ; tok@var2141 =@expr1073753901 tok@var2141 .@expr12078 next (@expr12079 ) ) {
3681: if (@expr1073753904 Token ::@expr12081 Match (@expr1073753906 tok@var2141 , "typename %name%" ) &&@expr1073753907 !@expr1073753908 Token ::@expr12081 Match (@expr1073753910 tok@var2141 .@expr1073753911 tokAt (@expr1073753912 -3 ) , "using %name% =" ) ) {
3682: tok@var2141 .@expr1073753913 deleteThis (@expr1073753914 ) ; }
3683:
3684: if (@expr1073753915 Token ::@expr12066 simpleMatch (@expr1073753917 tok@var2141 , "template <" ) ) {
3685: tok@var2141 =@expr1073753918 tok@var2141 .@expr12078 next (@expr12079 ) .@expr1073753921 findClosingBracket (@expr1073753922 ) ;
3686: if (@expr1073753923 !@expr1073753924 tok@var2141 ) {
3687: break ; }
3688: }
3689: }
3690:
3691: if (@expr1073753925 mSettings@var101 .@expr12102 standards@var2201 .@expr12103 cpp@var2202 >=@expr1073753928 Standards ::@expr1073753929 CPP20 ) {
3692:
3693:
3694: for (@expr1073753930 Token *@expr12058 tok@var2142 =@expr1073753932 mTokenList@var100 .@expr12060 front (@expr12061 ) ; tok@var2142 ; tok@var2142 =@expr1073753935 tok@var2142 .@expr12112 next (@expr12113 ) ) {
3695: if (@expr1073753938 !@expr1073753939 Token ::@expr12081 Match (@expr1073753941 tok@var2142 , ")|>|>> requires %name%|(" ) ) {
3696: continue ; }
3697: Token * end@var2143 ; end@var2143 =@expr1073753942 skipRequires (@expr1073753943 tok@var2142 .@expr12112 next (@expr12113 ) ) ;
3698: if (@expr1073753946 end@var2143 ) {
3699: Token ::@expr12123 eraseTokens (@expr1073753948 tok@var2142 , end@var2143 ) ; }
3700: }
3701:
3702:
3703: for (@expr1073753949 Token *@expr12058 tok@var2144 =@expr1073753951 mTokenList@var100 .@expr12060 front (@expr12061 ) ; tok@var2144 ; tok@var2144 =@expr1073753954 tok@var2144 .@expr1073753955 next (@expr1073753956 ) ) {
3704: if (@expr1073753957 Token ::@expr12066 simpleMatch (@expr1073753959 tok@var2144 , "explicit (" ) ) {
3705: bool isFalse@var2145 ; isFalse@var2145 =@expr1073753960 Token ::@expr12066 simpleMatch (@expr1073753962 tok@var2144 .@expr1073753963 tokAt (@expr1073753964 2 ) , "false )" ) ;
3706: Token ::@expr12123 eraseTokens (@expr1073753966 tok@var2144 , tok@var2144 .@expr1073753967 linkAt (@expr1073753968 1 ) .@expr1073753969 next (@expr1073753970 ) ) ;
3707: if (@expr1073753971 isFalse@var2145 ) {
3708: tok@var2144 .@expr1073753972 deleteThis (@expr1073753973 ) ; }
3709: }
3710: }
3711: }
3712:
3713: mTokenizer@var99 .@expr1073753974 calculateScopes (@expr1073753975 ) ;
3714:
3715: unsigned int passCount@var2146 ; passCount@var2146 =@expr1073753976 0 ;
3716: const unsigned int passCountMax@var2147 =@expr1073753977 10 ;
3717: for (@expr1073753978 ; passCount@var2146 <@expr1073753979 passCountMax@var2147 ; ++@expr1073753980 passCount@var2146 ) {
3718: if (@expr1073753981 passCount@var2146 ) {
3719:
3720: bool usingChanged@var2148 ; usingChanged@var2148 =@expr1073753982 false ;
3721: while (@expr1073753983 mTokenizer@var99 .@expr1073753984 simplifyUsing (@expr1073753985 ) ) {
3722: usingChanged@var2148 =@expr1073753986 true ; }
3723:
3724: if (@expr1073753987 !@expr1073753988 usingChanged@var2148 &&@expr1073753989 !@expr1073753990 mChanged@var103 ) {
3725: break ; }
3726:
3727: mChanged@var103 =@expr1073753991 usingChanged@var2148 ;
3728: mTemplateDeclarations@var104 .@expr1073753992 clear (@expr1073753993 ) ;
3729: mTemplateForwardDeclarations@var105 .@expr1073753994 clear (@expr1073753995 ) ;
3730: mTemplateForwardDeclarationsMap@var106 .@expr1073753996 clear (@expr1073753997 ) ;
3731: mTemplateSpecializationMap@var107 .@expr1073753998 clear (@expr1073753999 ) ;
3732: mTemplatePartialSpecializationMap@var108 .@expr1073754000 clear (@expr1073754001 ) ;
3733: mTemplateInstantiations@var109 .@expr1073754002 clear (@expr1073754003 ) ;
3734: mInstantiatedTemplates@var110 .@expr1073754004 clear (@expr1073754005 ) ;
3735: mExplicitInstantiationsToDelete@var112 .@expr1073754006 clear (@expr1073754007 ) ;
3736: mTemplateNamePos@var114 .@expr1073754008 clear (@expr1073754009 ) ;
3737: }
3738:
3739: bool hasTemplates@var2149 ; hasTemplates@var2149 =@expr1073754010 getTemplateDeclarations (@expr1073754011 ) ;
3740:
3741: if (@expr1073754012 passCount@var2146 ==@expr1073754013 0 ) {
3742: codeWithTemplates@var2139 =@expr1073754014 hasTemplates@var2149 ; }
3743:
3744:
3745: if (@expr1073754015 mTemplateDeclarations@var104 .@expr1073754016 empty (@expr1073754017 ) &&@expr1073754018 mTemplateForwardDeclarations@var105 .@expr1073754019 empty (@expr1073754020 ) ) {
3746: return ; }
3747:
3748: if (@expr1073754021 mSettings@var101 .@expr12198 debugtemplate@var2199 &&@expr1073754023 mSettings@var101 .@expr1073754024 debugnormal@var2203 ) {
3749: std ::@expr1073754025 string title@var2150 (@expr1073754026 "Template Simplifier pass " +@expr1073754027 std ::@expr12204 to_string (@expr12205 passCount@var2146 +@expr12206 1 ) ) ;
3750: mTokenList@var100 .@expr12060 front (@expr12061 ) .@expr1073754033 printOut (@expr1073754034 title@var2150 .@expr1073754035 c_str (@expr1073754036 ) , mTokenList@var100 .@expr1073754037 getFiles (@expr1073754038 ) ) ;
3751: }
3752:
3753:
3754: fixForwardDeclaredDefaultArgumentValues (@expr1073754039 ) ;
3755:
3756:
3757: getSpecializations (@expr1073754040 ) ;
3758:
3759:
3760: getPartialSpecializations (@expr1073754041 ) ;
3761:
3762:
3763: getTemplateInstantiations (@expr1073754042 ) ;
3764:
3765:
3766: useDefaultArgumentValues (@expr1073754043 ) ;
3767:
3768: simplifyTemplateAliases (@expr1073754044 ) ;
3769:
3770: if (@expr1073754045 mSettings@var101 .@expr12198 debugtemplate@var2199 ) {
3771: printOut (@expr1073754047 "### Template Simplifier pass " +@expr1073754048 std ::@expr12204 to_string (@expr12205 passCount@var2146 +@expr12206 1 ) +@expr1073754052 " ###" ) ; }
3772:
3773: std ::@expr1073754053 set < std ::@expr12230 string > expandedtemplates@var2151 ;
3774:
3775: for (@expr1073754055 std ::@expr12230 list < TokenAndName > ::@expr12230 reverse_iterator iter1@var2152 =@expr1073754058 mTemplateDeclarations@var104 .@expr1073754059 rbegin (@expr1073754060 ) ; iter1@var2152 !=@expr1073754061 mTemplateDeclarations@var104 .@expr1073754062 rend (@expr1073754063 ) ; ++@expr1073754064 iter1@var2152 ) {
3776: if (@expr1073754065 iter1@var2152 .@expr1073754066 isAlias (@expr1073754067 ) ||@expr1073754068 iter1@var2152 .@expr1073754069 isFriend (@expr1073754070 ) ) {
3777: continue ; }
3778:
3779:
3780: std ::@expr1073754071 list < const Token *@expr12058 > specializations@var2153 ;
3781: for (@expr1073754073 std ::@expr12230 list < TokenAndName > ::@expr12230 const_iterator iter2@var2154 =@expr1073754076 mTemplateDeclarations@var104 .@expr12253 begin (@expr12254 ) ; iter2@var2154 !=@expr1073754079 mTemplateDeclarations@var104 .@expr12256 end (@expr12257 ) ; ++@expr1073754082 iter2@var2154 ) {
3782: if (@expr1073754083 iter2@var2154 .@expr1073754084 isAlias (@expr1073754085 ) ||@expr1073754086 iter2@var2154 .@expr1073754087 isFriend (@expr1073754088 ) ) {
3783: continue ; }
3784:
3785: if (@expr1073754089 iter1@var2152 .@expr1073754090 fullName (@expr1073754091 ) ==@expr1073754092 iter2@var2154 .@expr1073754093 fullName (@expr1073754094 ) ) {
3786: specializations@var2153 .@expr1073754095 push_back (@expr1073754096 iter2@var2154 .@expr1073754097 nameToken (@expr1073754098 ) ) ; }
3787: }
3788:
3789: const bool instantiated@var2155 =@expr1073754099 simplifyTemplateInstantiations (@expr1073754100
3790: *@expr12277 iter1@var2152 ,
3791: specializations@var2153 ,
3792: maxtime@var2138 ,
3793: expandedtemplates@var2151 ) ;
3794: if (@expr1073754102 instantiated@var2155 ) {
3795: mInstantiatedTemplates@var110 .@expr1073754103 push_back (@expr1073754104 *@expr12277 iter1@var2152 ) ; }
3796: }
3797:
3798: for (@expr1073754106 std ::@expr12230 list < TokenAndName > ::@expr12230 const_iterator it@var2156 =@expr1073754109 mInstantiatedTemplates@var110 .@expr1073754110 begin (@expr1073754111 ) ; it@var2156 !=@expr1073754112 mInstantiatedTemplates@var110 .@expr1073754113 end (@expr1073754114 ) ; ++@expr1073754115 it@var2156 ) {
3799: std ::@expr12292 list < TokenAndName > ::@expr1073754117 iterator decl@var2157 ;
3800: for (@expr1073754118 decl@var2157 =@expr1073754119 mTemplateDeclarations@var104 .@expr12253 begin (@expr12254 ) ; decl@var2157 !=@expr12298 mTemplateDeclarations@var104 .@expr12256 end (@expr12257 ) ; ++@expr1073754125 decl@var2157 ) {
3801: if (@expr1073754126 decl@var2157 .@expr1073754127 token (@expr1073754128 ) ==@expr1073754129 it@var2156 .@expr12306 token (@expr12307 ) ) {
3802: break ; }
3803: }
3804: if (@expr1073754132 decl@var2157 !=@expr12298 mTemplateDeclarations@var104 .@expr12256 end (@expr12257 ) ) {
3805: if (@expr1073754136 it@var2156 .@expr1073754137 isSpecialization (@expr1073754138 ) ) {
3806:
3807: Token * tok@var2158 ; tok@var2158 =@expr1073754139 it@var2156 .@expr12306 token (@expr12307 ) ;
3808: tok@var2158 .@expr1073754142 deleteNext (@expr1073754143 2 ) ;
3809: tok@var2158 .@expr1073754144 deleteThis (@expr1073754145 ) ;
3810: } else {
3811:
3812: auto it1@var2159 ; it1@var2159 =@expr1073754146 mTemplateForwardDeclarationsMap@var106 .@expr1073754147 find (@expr1073754148 it@var2156 .@expr12306 token (@expr12307 ) ) ;
3813: if (@expr1073754151 it1@var2159 !=@expr1073754152 mTemplateForwardDeclarationsMap@var106 .@expr1073754153 end (@expr1073754154 ) ) {
3814: removeTemplate (@expr1073754155 it1@var2159 .@expr1073754156 second@var2160 ) ; }
3815: removeTemplate (@expr1073754157 it@var2156 .@expr12306 token (@expr12307 ) ) ;
3816: }
3817: mTemplateDeclarations@var104 .@expr12336 erase (@expr1073754161 decl@var2157 ) ;
3818: }
3819: }
3820:
3821:
3822: while (@expr1073754162 !@expr1073754163 mMemberFunctionsToDelete@var111 .@expr1073754164 empty (@expr1073754165 ) ) {
3823: const std ::@expr12292 list < TokenAndName > ::@expr1073754167 iterator it@var2161 =@expr1073754168 std ::@expr12345 find_if (@expr1073754170 mTemplateDeclarations@var104 .@expr12253 begin (@expr12254 ) ,
3824: mTemplateDeclarations@var104 .@expr12256 end (@expr12257 ) ,
3825: FindToken (@expr12351 mMemberFunctionsToDelete@var111 .@expr12352 begin (@expr12353 ) .@expr12354 token (@expr12355 ) ) ) ;
3826:
3827: if (@expr1073754180 it@var2161 !=@expr1073754181 mTemplateDeclarations@var104 .@expr12256 end (@expr12257 ) ) {
3828: removeTemplate (@expr1073754184 it@var2161 .@expr1073754185 token (@expr1073754186 ) ) ;
3829: mTemplateDeclarations@var104 .@expr12336 erase (@expr1073754188 it@var2161 ) ;
3830: } else {
3831: const std ::@expr12292 list < TokenAndName > ::@expr1073754190 iterator it1@var2162 =@expr1073754191 std ::@expr12345 find_if (@expr1073754193 mTemplateForwardDeclarations@var105 .@expr1073754194 begin (@expr1073754195 ) ,
3832: mTemplateForwardDeclarations@var105 .@expr12372 end (@expr12373 ) ,
3833: FindToken (@expr12351 mMemberFunctionsToDelete@var111 .@expr12352 begin (@expr12353 ) .@expr12354 token (@expr12355 ) ) ) ;
3834:
3835: if (@expr1073754203 it1@var2162 !=@expr1073754204 mTemplateForwardDeclarations@var105 .@expr12372 end (@expr12373 ) ) {
3836: removeTemplate (@expr1073754207 it1@var2162 .@expr1073754208 token (@expr1073754209 ) ) ;
3837: mTemplateForwardDeclarations@var105 .@expr1073754210 erase (@expr1073754211 it1@var2162 ) ;
3838: }
3839: }
3840: mMemberFunctionsToDelete@var111 .@expr1073754212 erase (@expr1073754213 mMemberFunctionsToDelete@var111 .@expr12352 begin (@expr12353 ) ) ;
3841: }
3842:
3843:
3844: for (@expr1073754216 TokenAndName &@expr1073754217 j@var2163 :@expr1073754218 mExplicitInstantiationsToDelete@var112 ) {
3845: Token * start@var2164 ; start@var2164 =@expr1073754219 j@var2163 .@expr1073754220 token (@expr1073754221 ) ;
3846: if (@expr1073754222 start@var2164 ) {
3847: Token * end@var2165 ; end@var2165 =@expr1073754223 start@var2164 .@expr1073754224 next (@expr1073754225 ) ;
3848: while (@expr1073754226 end@var2165 &&@expr1073754227 end@var2165 .@expr1073754228 str (@expr1073754229 ) !=@expr1073754230 ";" ) {
3849: end@var2165 =@expr1073754231 end@var2165 .@expr12408 next (@expr12409 ) ; }
3850: if (@expr1073754234 start@var2164 .@expr12411 previous (@expr12412 ) ) {
3851: start@var2164 =@expr1073754237 start@var2164 .@expr12411 previous (@expr12412 ) ; }
3852: if (@expr1073754240 end@var2165 &&@expr1073754241 end@var2165 .@expr12408 next (@expr12409 ) ) {
3853: end@var2165 =@expr1073754244 end@var2165 .@expr12408 next (@expr12409 ) ; }
3854: eraseTokens (@expr1073754247 start@var2164 , end@var2165 ) ;
3855: }
3856: }
3857: }
3858:
3859: if (@expr1073754248 passCount@var2146 ==@expr1073754249 passCountMax@var2147 ) {
3860: if (@expr1073754250 mSettings@var101 .@expr1073754251 debugwarnings@var2196 ) {
3861: const std ::@expr1073754252 list < const Token *@expr12058 > locationList@var2166 (@expr1073754254 1 , mTokenList@var100 .@expr12060 front (@expr12061 ) ) ;
3862: const ErrorMessage errmsg@var2167 (@expr1073754257 locationList@var2166 , &@expr1073754258 mTokenizer@var99 .@expr1073754259 list@var2197 ,
3863: Severity ::@expr1073754260 debug ,
3864: "debug" ,
3865: "TemplateSimplifier: pass count limit hit before simplifications were finished." ,
3866: Certainty ::@expr1073754261 normal ) ;
3867: if (@expr1073754262 mErrorLogger@var102 ) {
3868: mErrorLogger@var102 .@expr1073754263 reportErr (@expr1073754264 errmsg@var2167 ) ; }
3869: }
3870: }
3871:
3872:
3873: if (@expr1073754265 mSettings@var101 .@expr12102 standards@var2201 .@expr12103 cpp@var2202 >=@expr1073754268 Standards ::@expr1073754269 CPP17 ) {
3874: bool simplify@var2168 ; simplify@var2168 =@expr1073754270 false ;
3875: for (@expr1073754271 Token *@expr12058 tok@var2169 =@expr1073754273 mTokenList@var100 .@expr12060 front (@expr12061 ) ; tok@var2169 ; tok@var2169 =@expr1073754276 tok@var2169 .@expr12453 next (@expr12454 ) ) {
3876: if (@expr1073754279 tok@var2169 .@expr12456 str (@expr12457 ) ==@expr1073754282 "template" ) {
3877: simplify@var2168 =@expr1073754283 false ; }
3878: if (@expr1073754284 tok@var2169 .@expr12456 str (@expr12457 ) ==@expr1073754287 "{" ) {
3879: simplify@var2168 =@expr1073754288 true ; }
3880: if (@expr1073754289 !@expr1073754290 simplify@var2168 ||@expr1073754291 tok@var2169 .@expr12456 str (@expr12457 ) !=@expr1073754294 "(" ) {
3881: continue ; }
3882: const Token * op@var2170 ; op@var2170 =@expr1073754295 nullptr ;
3883: const Token * args@var2171 ; args@var2171 =@expr1073754296 nullptr ;
3884: if (@expr1073754297 Token ::@expr12081 Match (@expr1073754299 tok@var2169 , "( ... %op%" ) ) {
3885: op@var2170 =@expr1073754300 tok@var2169 .@expr12477 tokAt (@expr12478 2 ) ;
3886: args@var2171 =@expr1073754303 tok@var2169 .@expr12480 link (@expr12481 ) .@expr12482 previous (@expr12483 ) ;
3887: } else { if (@expr1073754308 Token ::@expr12081 Match (@expr1073754310 tok@var2169 , "( %name% %op% ..." ) ) {
3888: op@var2170 =@expr1073754311 tok@var2169 .@expr12477 tokAt (@expr12478 2 ) ;
3889: args@var2171 =@expr1073754314 tok@var2169 .@expr12480 link (@expr12481 ) .@expr12482 previous (@expr12483 ) .@expr1073754319 isName (@expr1073754320 ) ?@expr1073754321 nullptr :@expr1073754322 tok@var2169 .@expr12453 next (@expr12454 ) ;
3890: } else { if (@expr1073754325 Token ::@expr12081 Match (@expr1073754327 tok@var2169 .@expr12480 link (@expr12481 ) .@expr12506 tokAt (@expr12507 -3 ) , "%op% ... )" ) ) {
3891: op@var2170 =@expr1073754332 tok@var2169 .@expr12480 link (@expr12481 ) .@expr12506 tokAt (@expr12512 -2 ) ;
3892: args@var2171 =@expr1073754337 tok@var2169 .@expr12453 next (@expr12454 ) ;
3893: } else { if (@expr1073754340 Token ::@expr12081 Match (@expr1073754342 tok@var2169 .@expr12480 link (@expr12481 ) .@expr12506 tokAt (@expr12507 -3 ) , "... %op% %name% )" ) ) {
3894: op@var2170 =@expr1073754347 tok@var2169 .@expr12480 link (@expr12481 ) .@expr12506 tokAt (@expr12512 -2 ) ;
3895: args@var2171 =@expr1073754352 tok@var2169 .@expr12453 next (@expr12454 ) .@expr1073754355 isName (@expr1073754356 ) ?@expr1073754357 nullptr :@expr1073754358 tok@var2169 .@expr12480 link (@expr12481 ) .@expr12482 previous (@expr12483 ) ;
3896: } else {
3897: continue ;
3898: } } } }
3899:
3900:
3901: const std ::@expr12230 string strop@var2172 =@expr1073754364 op@var2170 .@expr1073754365 str (@expr1073754366 ) ;
3902: const std ::@expr12230 string strargs@var2173 =@expr1073754368 (@expr1073754369 args@var2171 &&@expr1073754370 args@var2171 .@expr1073754371 isName (@expr1073754372 ) ) ?@expr1073754373 args@var2171 .@expr1073754374 str (@expr1073754375 ) :@expr1073754376 "" ;
3903:
3904: Token ::@expr12123 eraseTokens (@expr1073754378 tok@var2169 , tok@var2169 .@expr12480 link (@expr12481 ) ) ;
3905: tok@var2169 .@expr12557 insertToken (@expr1073754382 ")" ) ;
3906: if (@expr1073754383 !@expr1073754384 strargs@var2173 .@expr1073754385 empty (@expr1073754386 ) ) {
3907: tok@var2169 .@expr12557 insertToken (@expr1073754388 "..." ) ;
3908: tok@var2169 .@expr12557 insertToken (@expr1073754390 strargs@var2173 ) ;
3909: }
3910: tok@var2169 .@expr12557 insertToken (@expr1073754392 "(" ) ;
3911: Token ::@expr1073754393 createMutualLinks (@expr1073754394 tok@var2169 .@expr12453 next (@expr12454 ) , tok@var2169 .@expr12480 link (@expr12481 ) .@expr12482 previous (@expr12483 ) ) ;
3912: tok@var2169 .@expr12557 insertToken (@expr1073754402 "__cppcheck_fold_" +@expr1073754403 strop@var2172 +@expr1073754404 "__" ) ;
3913: }
3914: }
3915: }
3916:
3917: void TemplateSimplifier :: syntaxError ( const Token * tok@var2174 )
3918: {
3919: throw InternalError (@expr1073754405 tok@var2174 , "syntax error" , InternalError ::@expr1073754406 SYNTAX ) ;
3920: }

##file cppcheck-2.8/lib/settings.h

12:
|
48:
49: class SimpleEnableGroup<Severity::SeverityType> {
50: uint32_t mFlags@var2175 ; mFlags@var2175 = 0 ;
51: public:
52: uint32_t intValue ( ) const {
53: return mFlags@var2175 ;
54: }
55: void clear ( ) {
56: mFlags@var2175 =@expr1073754407 0 ;
57: }
58: void fill ( ) {
59: mFlags@var2175 =@expr1073754408 0xFFFFFFFF ;
60: }
61: void setEnabledAll ( bool enabled@var2176 ) {
62: if (@expr1073754409 enabled@var2176 ) {
63: fill (@expr1073754410 ) ; }
64: else {
65: clear (@expr1073754411 ) ; }
66: }
67: bool isEnabled ( Severity :: SeverityType flag@var2177 ) const {
68: return (@expr12588 mFlags@var2175 &@expr1073754413 (@expr12588 1U <<@expr1073754415 (@expr1073754416 uint32_t ) flag@var2177 ) ) !=@expr1073754417 0 ;
69: }
70: void enable ( Severity :: SeverityType flag@var2178 ) {
71: mFlags@var2175 |=@expr1073754418 (@expr1073754419 1U <<@expr1073754420 (@expr1073754421 uint32_t ) flag@var2178 ) ;
72: }
73: void disable ( Severity :: SeverityType flag@var2179 ) {
74: mFlags@var2175 &=@expr1073754422 ~@expr1073754423 (@expr1073754424 1U <<@expr1073754425 (@expr1073754426 uint32_t ) flag@var2179 ) ;
75: }
76: void setEnabled ( Severity :: SeverityType flag@var2180 , bool enabled@var2181 ) {
77: if (@expr1073754427 enabled@var2181 ) {
78: enable (@expr1073754428 flag@var2180 ) ; }
79: else {
80: disable (@expr1073754429 flag@var2180 ) ; }
81: }
82: } ;
49: class SimpleEnableGroup<Certainty::CertaintyLevel> {
50: uint32_t mFlags@var2182 ; mFlags@var2182 = 0 ;
51: public:
52: uint32_t intValue ( ) const {
53: return mFlags@var2182 ;
54: }
55: void clear ( ) {
56: mFlags@var2182 =@expr1073754430 0 ;
57: }
58: void fill ( ) {
59: mFlags@var2182 =@expr1073754431 0xFFFFFFFF ;
60: }
61: void setEnabledAll ( bool enabled@var2183 ) {
62: if (@expr1073754432 enabled@var2183 ) {
63: fill (@expr1073754433 ) ; }
64: else {
65: clear (@expr1073754434 ) ; }
66: }
67: bool isEnabled ( Certainty :: CertaintyLevel flag@var2184 ) const {
68: return (@expr12611 mFlags@var2182 &@expr1073754436 (@expr12611 1U <<@expr1073754438 (@expr1073754439 uint32_t ) flag@var2184 ) ) !=@expr1073754440 0 ;
69: }
70: void enable ( Certainty :: CertaintyLevel flag@var2185 ) {
71: mFlags@var2182 |=@expr1073754441 (@expr1073754442 1U <<@expr1073754443 (@expr1073754444 uint32_t ) flag@var2185 ) ;
72: }
73: void disable ( Certainty :: CertaintyLevel flag@var2186 ) {
74: mFlags@var2182 &=@expr1073754445 ~@expr1073754446 (@expr1073754447 1U <<@expr1073754448 (@expr1073754449 uint32_t ) flag@var2186 ) ;
75: }
76: void setEnabled ( Certainty :: CertaintyLevel flag@var2187 , bool enabled@var2188 ) {
77: if (@expr1073754450 enabled@var2188 ) {
78: enable (@expr1073754451 flag@var2187 ) ; }
79: else {
80: disable (@expr1073754452 flag@var2187 ) ; }
81: }
82: } ;
49: class SimpleEnableGroup<Checks::CheckList> {
50: uint32_t mFlags@var2189 ; mFlags@var2189 = 0 ;
51: public:
52: uint32_t intValue ( ) const {
53: return mFlags@var2189 ;
54: }
55: void clear ( ) {
56: mFlags@var2189 =@expr1073754453 0 ;
57: }
58: void fill ( ) {
59: mFlags@var2189 =@expr1073754454 0xFFFFFFFF ;
60: }
61: void setEnabledAll ( bool enabled@var2190 ) {
62: if (@expr1073754455 enabled@var2190 ) {
63: fill (@expr1073754456 ) ; }
64: else {
65: clear (@expr1073754457 ) ; }
66: }
67: bool isEnabled ( Checks :: CheckList flag@var2191 ) const {
68: return (@expr12634 mFlags@var2189 &@expr1073754459 (@expr12634 1U <<@expr1073754461 (@expr1073754462 uint32_t ) flag@var2191 ) ) !=@expr1073754463 0 ;
69: }
70: void enable ( Checks :: CheckList flag@var2192 ) {
71: mFlags@var2189 |=@expr1073754464 (@expr1073754465 1U <<@expr1073754466 (@expr1073754467 uint32_t ) flag@var2192 ) ;
72: }
73: void disable ( Checks :: CheckList flag@var2193 ) {
74: mFlags@var2189 &=@expr1073754468 ~@expr1073754469 (@expr1073754470 1U <<@expr1073754471 (@expr1073754472 uint32_t ) flag@var2193 ) ;
75: }
76: void setEnabled ( Checks :: CheckList flag@var2194 , bool enabled@var2195 ) {
77: if (@expr1073754473 enabled@var2195 ) {
78: enable (@expr1073754474 flag@var2194 ) ; }
79: else {
80: disable (@expr1073754475 flag@var2194 ) ; }
81: }
82: } ;



##Value flow
Line 62
  ( always !<=-1
Line 74
  mFlags always !<=-1
Line 77
  fIsClass always 1
  = always 1
  1 always 1
  << always 1
  0 always 0
  , always 2
Line 78
  fIsFunction always 2
  = always 2
  1 always 1
  << always 2
  1 always 1
  , always 4
Line 79
  fIsVariable always 4
  = always 4
  1 always 1
  << always 4
  2 always 2
  , always 8
Line 80
  fIsAlias always 8
  = always 8
  1 always 1
  << always 8
  3 always 3
  , always 16
Line 81
  fIsSpecialization always 16
  = always 16
  1 always 1
  << always 16
  4 always 4
  , always 32
Line 82
  fIsPartialSpecialization always 32
  = always 32
  1 always 1
  << always 32
  5 always 5
  , always 64
Line 83
  fIsForwardDeclaration always 64
  = always 64
  1 always 1
  << always 64
  6 always 6
  , always 128
Line 84
  fIsVariadic always 128
  = always 128
  1 always 1
  << always 128
  7 always 7
  , always 256
Line 85
  fIsFriend always 256
  = always 256
  1 always 1
  << always 256
  8 always 8
  , always 7
Line 86
  fFamilyMask always 7
  = always 7
  fIsClass always 1
  | always 3
  fIsFunction always 2
  | always 7
  fIsVariable always 4
Line 89
  state always {!<=-1,!>=2}
Line 90
  fIsClass always 1
  state always {!<=-1,!>=2}
Line 92
  state always {!<=-1,!>=2}
Line 93
  fIsFunction always 2
  state {!<=-1,!>=2,0@182,1@182}
Line 95
  state always {!<=-1,!>=2}
Line 96
  fIsVariable always 4
  state {!<=-1,!>=2,0@184,1@184}
Line 98
  state always {!<=-1,!>=2}
Line 99
  fIsAlias always 8
  state {!<=-1,!>=2,0@165,1@165}
Line 101
  state always {!<=-1,!>=2}
Line 102
  fIsSpecialization always 16
  state always {!<=-1,!>=2}
Line 104
  state always {!<=-1,!>=2}
Line 105
  fIsPartialSpecialization always 32
  state {!<=-1,!>=2,0@163,1@163}
Line 107
  state always {!<=-1,!>=2}
Line 108
  fIsForwardDeclaration always 64
  state {!<=-1,!>=2,0@190,1@190}
Line 110
  state always {!<=-1,!>=2}
Line 111
  fIsVariadic always 128
  state {!<=-1,!>=2,0@177,1@177}
Line 113
  state always {!<=-1,!>=2}
Line 114
  fIsFriend always 256
  state {!<=-1,!>=2,0@170,1@170}
Line 122
  ( always {!<=-1,!>=2}
  flag always !<=-1
Line 123
  return always {!<=-1,!>=2}
  mFlags always !<=-1
  & always !<=-1
  flag {!<=-1,256@154,128@155,64@156,32@157,16@158,8@159,4@160,2@161,1@162}
  != always {!<=-1,!>=2}
  0 always 0
Line 131
  flag always !<=-1
  state always {!<=-1,!>=2}
Line 132
  mFlags always !<=-1
  = always !<=-1
  state always {!<=-1,!>=2}
  ? always !<=-1
  mFlags always !<=-1
  | always !<=-1
  flag {!<=-1,16@167,1@171}
  : always !<=-1
  mFlags always !<=-1
  & always !<=-1
  ~ {!<=0,4294967279@167,4294967294@171}
  flag {!<=-1,16@167,1@171}
Line 153
  ( always {!<=-1,!>=2}
Line 154
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 155
  == always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  mFlags always !<=-1
  == always {!<=-1,!>=2}
  . always !<=-1
  mFlags always !<=-1
Line 183
  ( always {!<=-1,!>=2}
Line 184
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsClass always 1
Line 186
  ( always {!<=-1,!>=2}
Line 187
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsFunction always 2
Line 189
  ( always {!<=-1,!>=2}
Line 190
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsVariable always 4
Line 192
  ( always {!<=-1,!>=2}
Line 193
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsAlias always 8
Line 195
  ( always {!<=-1,!>=2}
Line 196
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsSpecialization always 16
Line 198
  ( always {!<=-1,!>=2}
Line 199
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsPartialSpecialization always 32
Line 201
  ( always {!<=-1,!>=2}
Line 202
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsForwardDeclaration always 64
Line 204
  ( always {!<=-1,!>=2}
Line 205
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsVariadic always 128
Line 207
  ( always {!<=-1,!>=2}
Line 208
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsFriend always 256
Line 234
  ( always {!<=-1,!>=2}
Line 242
  ( always {!<=-1,!>=2}
Line 245
  return always {!<=-1,!>=2}
  mFlags always !<=-1
  & always !<=-1
  fFamilyMask always 7
  & always !<=-1
  . always !<=-1
  mFlags always !<=-1
  & always !<=-1
  fFamilyMask always 7
  != always {!<=-1,!>=2}
  0 always 0
Line 265
  ( always {!<=-1,!>=2}
Line 281
  ( always {!<=-1,!>=2}
Line 289
  ( always {!<=-1,!>=2}
Line 297
  ( always {!<=-1,!>=2}
Line 314
  ( always {!<=-1,!>=2}
  , always 1
  = always 1
  true always 1
Line 322
  ( always {!<=-1,!>=2}
  = always 0
  nullptr always 0
  , always 0
  = always 0
  nullptr always 0
  , always 1
  = always 1
  true always 1
Line 335
  ( always {!<=-1,!>=2}
Line 391
  ( always {!<=-1,!>=2}
Line 410
  ( always {!<=-1,!>=2}
Line 451
  ( always {!<=-1,!>=2}
Line 456
  ( always {!<=-1,!>=2}
Line 486
  , always "    "
Line 487
  = always "    "
  "    " always "    "
Line 488
  = always ""
  "" always ""
Line 494
  mChanged always {!<=-1,!>=2}
Line 36
  AST always 0
  SYNTAX always 1
  UNKNOWN_MACRO always 2
  INTERNAL always 3
  LIMIT always 4
  INSTANTIATION always 5
Line 37
  = always 3
  INTERNAL always 3
Line 47
  normal always 0
  inconclusive always 1
  safe always 2
  experimental always 3
Line 54
  unusedFunction always 0
  missingInclude always 1
  internalCheck always 2
Line 68
  none always 0
Line 74
  error always 1
Line 80
  warning always 2
Line 87
  style always 3
Line 93
  performance always 4
Line 101
  portability always 5
Line 108
  information always 6
Line 113
  debug always 7
Line 121
  ( possible lifetime[SubObject]=(cweId)
  cweId always !<=-1
  id always !<=-1
  cweId always !<=-1
Line 122
  id always !<=-1
Line 42
  hash always !<=-1
Line 56
  NO_LINE always -1
  hash always !<=-1
  0 always 0
  thisAndNextLine always {!<=-1,!>=2}
  false always 0
  matched always {!<=-1,!>=2}
  false always 0
  checked always {!<=-1,!>=2}
  false always 0
Line 58
  this always !0
Line 60
  = always -1
  NO_LINE always -1
  hash always !<=-1
  0 always 0
  thisAndNextLine always {!<=-1,!>=2}
  false always 0
  matched always {!<=-1,!>=2}
  false always 0
  checked always {!<=-1,!>=2}
  false always 0
Line 67
  hash always !<=-1
  = always !<=-1
  . always !<=-1
  hash always !<=-1
Line 68
  thisAndNextLine always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  . always {!<=-1,!>=2}
  thisAndNextLine always {!<=-1,!>=2}
Line 69
  matched always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  . always {!<=-1,!>=2}
  matched always {!<=-1,!>=2}
Line 70
  checked always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  . always {!<=-1,!>=2}
  checked always {!<=-1,!>=2}
Line 71
  this always !0
Line 74
  ( always {!<=-1,!>=2}
Line 75
  != always {!<=-1,!>=2}
Line 76
  return always {!<=-1,!>=2}
  errorId always !symbolic=(other.errorId)
  < always {!<=-1,!>=2}
  . always !symbolic=(errorId)
Line 77
  < always {!<=-1,!>=2}
Line 78
  return always {!<=-1,!>=2}
  true always 1
Line 79
  != always {!<=-1,!>=2}
Line 80
  return always {!<=-1,!>=2}
  fileName always !symbolic=(other.fileName)
  < always {!<=-1,!>=2}
  . always !symbolic=(fileName)
Line 81
  != always {!<=-1,!>=2}
Line 82
  return always {!<=-1,!>=2}
  symbolName always !symbolic=(other.symbolName)
  < always {!<=-1,!>=2}
  . always !symbolic=(symbolName)
Line 83
  hash always !<=-1
  != always {!<=-1,!>=2}
  . always !<=-1
  hash always !<=-1
Line 84
  return always {!<=-1,!>=2}
  hash always {!<=-1,!symbolic=(other.hash)}
  < always {!<=-1,!>=2}
  . always {!<=-1,!symbolic=(hash)}
  hash always !<=-1
Line 85
  thisAndNextLine always {!<=-1,!>=2}
  != always {!<=-1,!>=2}
  . always {!<=-1,!>=2}
  thisAndNextLine always {!<=-1,!>=2}
Line 86
  return always {!<=-1,!>=2}
  thisAndNextLine always {!<=-1,!>=2,!symbolic=(other.thisAndNextLine)}
Line 87
  return always {!<=-1,!>=2}
  false always 0
Line 96
  ( always {!<=-1,!>=2}
Line 98
  ( always {!<=-1,!>=2}
Line 100
  ( always {!<=-1,!>=2}
Line 104
  ( always {!<=-1,!>=2}
Line 105
  return always {!<=-1,!>=2}
  ! {!<=-1,!>=2,0}
  fileName possible size=0
  ( {!<=-1,!>=2,1}
  && always {!<=-1,!>=2}
  fileName always !size=0
  ( always !<=-1
  "?*" always "?*"
  == always {!<=-1,!>=2}
Line 108
  ( always {!<=-1,!>=2}
Line 109
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 110
  == always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 111
  == always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 112
  == always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 113
  hash always !<=-1
  == always {!<=-1,!>=2}
  . always !<=-1
  hash always !<=-1
  && always {!<=-1,!>=2}
Line 114
  thisAndNextLine always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  . always {!<=-1,!>=2}
  thisAndNextLine always {!<=-1,!>=2}
Line 121
  hash always !<=-1
Line 122
  thisAndNextLine always {!<=-1,!>=2}
Line 123
  matched always {!<=-1,!>=2}
Line 124
  checked always {!<=-1,!>=2}
Line 126
  NO_LINE always -1
  = always -1
  -1 always -1
Line 178
  ( always {!<=-1,!>=2}
Line 185
  ( always {!<=-1,!>=2}
Line 197
  unusedFunctionChecking always {!<=-1,!>=2}
Line 203
  unusedFunctionChecking always {!<=-1,!>=2}
Line 28
  Reset always 0
  = always 0
  0 always 0
  , always 1
Line 29
  Bold always 1
  = always 1
  1 always 1
  , always 2
Line 30
  Dim always 2
  = always 2
  2 always 2
  , always 31
Line 31
  FgRed always 31
  = always 31
  31 always 31
  , always 32
Line 32
  FgGreen always 32
  = always 32
  32 always 32
  , always 34
Line 33
  FgBlue always 34
  = always 34
  34 always 34
  , always 35
Line 34
  FgMagenta always 35
  = always 35
  35 always 35
  , always 39
Line 35
  FgDefault always 39
  = always 39
  39 always 39
  , always 41
Line 36
  BgRed always 41
  = always 41
  41 always 41
  , always 42
Line 37
  BgGreen always 42
  = always 42
  42 always 42
  , always 44
Line 38
  BgBlue always 44
  = always 44
  44 always 44
  , always 49
Line 39
  BgDefault always 49
  = always 49
  49 always 49
Line 40
  457U always 457
Line 41
  476U always 476
Line 42
  676U always 676
Line 43
  682U always 682
Line 44
  825U always 825
Line 70
  fileIndex always !<=-1
  0 always 0
  0 always 0
  column always !<=-1
  0 always 0
Line 72
  column always !<=-1
Line 73
  fileIndex always !<=-1
  0 always 0
  column always !<=-1
  column always !<=-1
Line 75
  column always !<=-1
Line 76
  fileIndex always !<=-1
  0 always 0
  column always !<=-1
  column always !<=-1
Line 86
  convert always {!<=-1,!>=2}
  = always 1
  true always 1
Line 93
  convert always {!<=-1,!>=2}
  = always 1
  true always 1
Line 106
  fileIndex always !<=-1
Line 108
  column always !<=-1
Line 175
  verbose always {!<=-1,!>=2}
Line 180
  ( always {!<=-1,!>=2}
Line 190
  incomplete always {!<=-1,!>=2}
Line 197
  hash always !<=-1
Line 243
  ( always " </array>\r\n</dict>\r\n</plist>"
Line 254
  = always 0
  :: always 0
  Reset always 0
  = always 0
  0 always 0
Line 262
  = always 0
  0 always 0
Line 270
  , always !<=-1
  value always !<=-1
Line 272
  stage possible {"TemplateSimplifier::simplifyTemplateInstantiations()"@42,"TemplateSimplifier::simplifyTemplateInstantiations()"@61}
Line 273
  ( always !<=-1
  value always !<=-1
Line 289
  ( always {!<=-1,!>=2}
Line 303
  " </array>\r\n</dict>\r\n</plist>" always " </array>\r\n</dict>\r\n</plist>"
Line 43
  INT always 0
  LONG always 1
  LONGLONG always 2
  FLOAT always 3
Line 44
  mIsUnsigned always {!<=-1,!>=2}
Line 51
  ( always {!<=-1,!>=2}
Line 52
  return always {!<=-1,!>=2}
  != always {!<=-1,!>=2}
  :: always 3
  FLOAT always 3
Line 54
  ( always {!<=-1,!>=2}
Line 55
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 3
  FLOAT always 3
Line 59
  ( always {!<=-1,!>=2}
Line 74
  ( always !<=-1
Line 78
  value possible >=1@29
Line 83
  ( always {!<=-1,!>=2}
Line 84
  ( always {!<=-1,!>=2}
Line 85
  ( always {!<=-1,!>=2}
Line 86
  ( always {!<=-1,!>=2}
Line 87
  ( always {!<=-1,!>=2}
Line 88
  ( always {!<=-1,!>=2}
Line 89
  ( always {!<=-1,!>=2}
Line 90
  ( always {!<=-1,!>=2}
Line 91
  ( always {!<=-1,!>=2}
Line 92
  ( always {!<=-1,!>=2}
Line 102
  ( always {!<=-1,!>=2}
  , always 1
  supportMicrosoftExtensions always {!<=-1,!>=2}
  = always 1
  true always 1
Line 115
  ( always !<=-1
Line 116
  ( always {!<=-1,!>=2}
Line 117
  ( always {!<=-1,!>=2}
Line 118
  ( always {!<=-1,!>=2}
Line 119
  ( always {!<=-1,!>=2}
Line 120
  ( always {!<=-1,!>=2}
Line 121
  ( always {!<=-1,!>=2}
Line 122
  ( always {!<=-1,!>=2}
Line 128
  ( always {!<=-1,!>=2}
Line 130
  ( always !<=-1
Line 137
  ( always {!<=-1,!>=2}
  , always !<=-1
  :: always !<=-1
  iPos always !<=-1
Line 44
  >= always {!<=-1,!>=2}
  64 always 64
Line 46
  - possible >=-4611686018427387904
  1LL always 1
  << possible <=4611686018427387904
  bit {!>=64,<=63}
  - {!>=63,<=62}
  1 always 1
Line 50
  >= always {!<=-1,!>=2}
  64 always 64
Line 51
  ~ always !<=-1
  0ULL always 0
  >> always !<=-1
  1 always 1
Line 52
  1LL always 1
  << possible <=4611686018427387904
  bit {!>=64,<=63}
  - {!>=63,<=62}
  1 always 1
  - {<=4611686018427387903,!>=4611686018427387904}
  1LL always 1
Line 58
  ( always {!<=-1,!>=2}
Line 59
  return always {!<=-1,!>=2}
  >= always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  <= always {!<=-1,!>=2}
Line 62
  ( always {!<=-1,!>=2}
  value always !<=-1
Line 63
  intMax always !<=-1
  intMax always !<=-1
  = always !<=-1
Line 64
  return always {!<=-1,!>=2}
  value always !<=-1
  <= always {!<=-1,!>=2}
  intMax always !<=-1
Line 67
  ( always {!<=-1,!>=2}
Line 68
  return always {!<=-1,!>=2}
  >= always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  <= always {!<=-1,!>=2}
Line 71
  ( always {!<=-1,!>=2}
  value always !<=-1
Line 72
  longMax always !<=-1
  longMax always !<=-1
  = always !<=-1
Line 73
  return always {!<=-1,!>=2}
  value always !<=-1
  <= always {!<=-1,!>=2}
  longMax always !<=-1
Line 76
  ( always {!<=-1,!>=2}
  value always !<=-1
Line 77
  longLongMax always !<=-1
  longLongMax always !<=-1
  = always !<=-1
Line 78
  return always {!<=-1,!>=2}
  value always !<=-1
  <= always {!<=-1,!>=2}
  longLongMax always !<=-1
Line 103
  Unspecified always 0
Line 104
  Native always 1
Line 105
  Win32A always 2
Line 106
  Win32W always 3
Line 107
  Win64 always 4
Line 108
  Unix32 always 5
Line 109
  Unix64 always 6
Line 110
  PlatformFile always 7
Line 117
  ( always {!<=-1,!>=2}
Line 125
  ( always {!<=-1,!>=2}
Line 128
  ( always {!<=-1,!>=2}
Line 134
  ( always {!<=-1,!>=2}
Line 135
  return always {!<=-1,!>=2}
  platformType possible {3,4}
  == {!<=-1,!>=2,0}
  Win32A always 2
  || always {!<=-1,!>=2}
Line 136
  platformType {4,!2}
  == {!<=-1,!>=2,0}
  Win32W always 3
  || always {!<=-1,!>=2}
Line 137
  platformType always {!2,!3}
  == always {!<=-1,!>=2}
  Win64 always 4
Line 146
  Unspecified always 0
Line 147
  "Unspecified" always "Unspecified"
Line 148
  Native always 1
Line 149
  "Native" always "Native"
Line 150
  Win32A always 2
Line 151
  "win32A" always "win32A"
Line 152
  Win32W always 3
Line 153
  "win32W" always "win32W"
Line 154
  Win64 always 4
Line 155
  "win64" always "win64"
Line 156
  Unix32 always 5
Line 157
  "unix32" always "unix32"
Line 158
  Unix64 always 6
Line 159
  "unix64" always "unix64"
Line 160
  PlatformFile always 7
Line 161
  "platformFile" always "platformFile"
Line 163
  "unknown" always "unknown"
Line 168
  1 always 1
Line 47
  ( always {!<=-1,!>=2}
Line 49
  return always {!<=-1,!>=2}
  != always {!<=-1,!>=2}
Line 53
  ( always {!<=-1,!>=2}
Line 55
  return always {!<=-1,!>=2}
  != always {!<=-1,!>=2}
Line 59
  ( always {!<=-1,!>=2}
Line 61
  return always {!<=-1,!>=2}
  != always {!<=-1,!>=2}
Line 67
  ( always !<=-1
Line 69
  return always !<=-1
  ( always !<=-1
Line 73
  ( always {!<=-1,!>=2}
Line 75
  return always {!<=-1,!>=2}
  ! {!<=-1,!>=2,0}
  str possible size=0
  ( {!<=-1,!>=2,1}
  && always {!<=-1,!>=2}
  str always !size=0
  == always {!<=-1,!>=2}
  c possible {39@5771,34@6027}
Line 78
  ( always {!<=-1,!>=2}
  , always !<=-1
  endlen always !<=-1
Line 80
  return always {!<=-1,!>=2}
  ( always !<=-1
  >= always {!<=-1,!>=2}
  endlen always !<=-1
  && always {!<=-1,!>=2}
  ( {!<=-1,>=symbolic=(endlen),!<=symbolic=(endlen-1)}
  - always !<=-1
  endlen {!<=-1,<=symbolic=(str.size()),!>=symbolic=(str.size()+1)}
  endlen {!<=-1,<=symbolic=(str.size()),!>=symbolic=(str.size()+1)}
  == always {!<=-1,!>=2}
  0 always 0
Line 84
  ( always {!<=-1,!>=2}
  ( always !0
  & always !0
Line 86
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  1 always 1
Line 89
  ( always {!<=-1,!>=2}
Line 91
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  q possible {39@22,34@23}
Line 92
  return always {!<=-1,!>=2}
  false always 0
Line 93
  ( always !<=-1
  + always !<=0
  1 always 1
  > always {!<=-1,!>=2}
  p possible {""@22,""@23,""@24,"U"@25,"U"@26,"u"@27,"u"@28,"u8"@29,"u8"@30}
  ( always !<=-1
  && always {!<=-1,!>=2}
  0 always 0
  ( always !<=-1
  + always !<=0
  1 always 1
  == always {!<=-1,!>=2}
  0 always 0
Line 94
  return always {!<=-1,!>=2}
  true always 1
Line 95
  return always {!<=-1,!>=2}
  false always 0
Line 98
  ( always {!<=-1,!>=2}
Line 100
  "" always ""
  "u8" always "u8"
  "u" always "u"
  "U" always "U"
  "L" always "L"
Line 102
  ( always {!<=-1,!>=2}
  q possible {39@136,34@137}
Line 103
  return always {!<=-1,!>=2}
  true always 1
Line 105
  return always {!<=-1,!>=2}
  false always 0
Line 108
  ( always {!<=-1,!>=2}
Line 110
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  '"' always 34
Line 113
  ( always {!<=-1,!>=2}
Line 115
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  '\'' always 39
Line 120
  quotePos always !<=-1
  = always !<=-1
  ( always !<=-1
  q possible {39@133,34@135}
Line 121
  quotePos {symbolic=(str.find(q)),!<=-1}
  + always !<=0
  1U always 1
  ( always !<=-1
  - always !<=-1
  quotePos {symbolic=(str.find(q)),!<=-1}
  - always !<=-1
  2U always 2
Line 126
  ( always {!<=-1,!>=2}
Line 127
  '"' always 34
Line 128
  "" always ""
Line 133
  ( always {!<=-1,!>=2}
Line 134
  '\'' always 39
Line 135
  "" always ""
Line 140
  i possible {2,3}
  == {!<=-1,!>=2,0}
  1 always 1
Line 141
  "st" always "st"
Line 142
  i {3,!1}
  == {!<=-1,!>=2,0}
  2 always 2
Line 143
  "nd" always "nd"
Line 144
  i always {!1,!2}
  == always {!<=-1,!>=2}
  3 always 3
Line 145
  "rd" always "rd"
Line 146
  "th" always "th"
Line 151
  ( always {!<=-1,!>=2}
Line 153
  ( always {!<=-1,!>=2}
Line 155
  ( always {!<=-1,!>=2}
Line 40
  ( always {!<=-1,!>=2}
Line 41
  return always {!<=-1,!>=2}
  < always {!<=-1,!>=2}
  0 always 0
Line 54
  UNKNOWN always 0
Line 55
  MISSING always 1
Line 56
  FAILURE always 2
Line 57
  COMPILE_DB always 3
Line 58
  VS_SLN always 4
Line 59
  VS_VCXPROJ always 5
Line 60
  BORLAND always 6
Line 61
  CPPCHECK_GUI always 7
Line 66
  :: always 0
  Unspecified always 0
  msc always {!<=-1,!>=2}
  false always 0
  useMfc always {!<=-1,!>=2}
  false always 0
Line 71
  msc always {!<=-1,!>=2}
  ? possible {";_MSC_VER=1900",""}
  ";_MSC_VER=1900" always ";_MSC_VER=1900"
  : always ""
  "" always ""
  useMfc always {!<=-1,!>=2}
  ? possible {";__AFXWIN_H__=1",""}
  ";__AFXWIN_H__=1" always ";__AFXWIN_H__=1"
  : always ""
  "" always ""
Line 78
  msc always {!<=-1,!>=2}
Line 79
  useMfc always {!<=-1,!>=2}
Line 108
  , always 0
  = always 0
  nullptr always 0
Line 110
  ( always {!<=-1,!>=2}
Line 111
  ( always {!<=-1,!>=2}
Line 112
  ( always {!<=-1,!>=2}
Line 114
  ( always {!<=-1,!>=2}
Line 115
  ( always {!<=-1,!>=2}
Line 116
  ( always {!<=-1,!>=2}
Line 128
  8 always 8
  = always "project"
  "project" always "project"
Line 129
  8 always 8
  = always "version"
  "version" always "version"
Line 130
  2 always 2
  = always "1"
  "1" always "1"
Line 131
  9 always 9
  = always "builddir"
  "builddir" always "builddir"
Line 132
  14 always 14
  = always "importproject"
  "importproject" always "importproject"
Line 133
  23 always 23
  = always "analyze-all-vs-configs"
  "analyze-all-vs-configs" always "analyze-all-vs-configs"
Line 134
  7 always 7
  = always "parser"
  "parser" always "parser"
Line 135
  12 always 12
  = always "bug-hunting"
  "bug-hunting" always "bug-hunting"
Line 136
  11 always 11
  = always "includedir"
  "includedir" always "includedir"
Line 137
  4 always 4
  = always "dir"
  "dir" always "dir"
Line 138
  5 always 5
  = always "name"
  "name" always "name"
Line 139
  8 always 8
  = always "defines"
  "defines" always "defines"
Line 140
  7 always 7
  = always "define"
  "define" always "define"
Line 141
  5 always 5
  = always "name"
  "name" always "name"
Line 142
  10 always 10
  = always "undefines"
  "undefines" always "undefines"
Line 143
  9 always 9
  = always "undefine"
  "undefine" always "undefine"
Line 144
  6 always 6
  = always "paths"
  "paths" always "paths"
Line 145
  4 always 4
  = always "dir"
  "dir" always "dir"
Line 146
  5 always 5
  = always "name"
  "name" always "name"
Line 147
  5 always 5
  = always "root"
  "root" always "root"
Line 148
  5 always 5
  = always "name"
  "name" always "name"
Line 149
  7 always 7
  = always "ignore"
  "ignore" always "ignore"
Line 150
  5 always 5
  = always "path"
  "path" always "path"
Line 151
  5 always 5
  = always "name"
  "name" always "name"
Line 152
  8 always 8
  = always "exclude"
  "exclude" always "exclude"
Line 153
  5 always 5
  = always "path"
  "path" always "path"
Line 154
  5 always 5
  = always "name"
  "name" always "name"
Line 155
  19 always 19
  = always "function-contracts"
  "function-contracts" always "function-contracts"
Line 156
  19 always 19
  = always "variable-contracts"
  "variable-contracts" always "variable-contracts"
Line 157
  10 always 10
  = always "libraries"
  "libraries" always "libraries"
Line 158
  8 always 8
  = always "library"
  "library" always "library"
Line 159
  9 always 9
  = always "platform"
  "platform" always "platform"
Line 160
  13 always 13
  = always "suppressions"
  "suppressions" always "suppressions"
Line 161
  12 always 12
  = always "suppression"
  "suppression" always "suppression"
Line 162
  6 always 6
  = always "addon"
  "addon" always "addon"
Line 163
  7 always 7
  = always "addons"
  "addons" always "addons"
Line 164
  5 always 5
  = always "tool"
  "tool" always "tool"
Line 165
  6 always 6
  = always "tools"
  "tools" always "tools"
Line 166
  5 always 5
  = always "tags"
  "tags" always "tags"
Line 167
  4 always 4
  = always "tag"
  "tag" always "tag"
Line 168
  13 always 13
  = always "tag-warnings"
  "tag-warnings" always "tag-warnings"
Line 169
  4 always 4
  = always "tag"
  "tag" always "tag"
Line 170
  8 always 8
  = always "warning"
  "warning" always "warning"
Line 171
  5 always 5
  = always "hash"
  "hash" always "hash"
Line 172
  14 always 14
  = always "check-headers"
  "check-headers" always "check-headers"
Line 173
  23 always 23
  = always "check-unused-templates"
  "check-unused-templates" always "check-unused-templates"
Line 174
  14 always 14
  = always "max-ctu-depth"
  "max-ctu-depth" always "max-ctu-depth"
Line 175
  23 always 23
  = always "max-template-recursion"
  "max-template-recursion" always "max-template-recursion"
Line 176
  37 always 37
  = always "check-unknown-function-return-values"
  "check-unknown-function-return-values" always "check-unknown-function-return-values"
Line 177
  11 always 11
  = always "clang-tidy"
  "clang-tidy" always "clang-tidy"
Line 178
  5 always 5
  = always "name"
  "name" always "name"
Line 179
  18 always 18
  = always "vs-configurations"
  "vs-configurations" always "vs-configurations"
Line 180
  7 always 7
  = always "config"
  "config" always "config"
Line 38
  C89 always 0
  C99 always 1
  C11 always 2
  CLatest always 2
  = always 2
  C11 always 2
Line 41
  CPP03 always 0
  CPP11 always 1
  CPP14 always 2
  CPP17 always 3
  CPP20 always 4
  CPP23 always 5
  CPPLatest always 5
  = always 5
  CPP23 always 5
Line 47
  CLatest always 2
  CPPLatest always 5
Line 49
  ( always {!<=-1,!>=2}
Line 50
  = possible size=3
  str possible size=3
Line 51
  str possible size=3
  == always {!<=-1,!>=2}
  "c89" always "c89"
  || always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  "C89" always "C89"
Line 52
  = always 0
  C89 always 0
Line 53
  return always {!<=-1,!>=2}
  true always 1
Line 55
  str possible size=3
  == always {!<=-1,!>=2}
  "c99" always "c99"
  || always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  "C99" always "C99"
Line 56
  = always 1
  C99 always 1
Line 57
  return always {!<=-1,!>=2}
  true always 1
Line 59
  str possible size=3
  == always {!<=-1,!>=2}
  "c11" always "c11"
  || always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  "C11" always "C11"
Line 60
  = always 2
  C11 always 2
Line 61
  return always {!<=-1,!>=2}
  true always 1
Line 63
  return always {!<=-1,!>=2}
  false always 0
Line 67
  C89 always 0
Line 68
  "c89" always "c89"
Line 69
  C99 always 1
Line 70
  "c99" always "c99"
Line 71
  C11 always 2
Line 72
  "c11" always "c11"
Line 74
  "" always ""
Line 77
  std possible size=3
  == always {!<=-1,!>=2}
  "c89" always "c89"
Line 78
  :: always 0
  C89 always 0
Line 80
  std possible size=3
  == always {!<=-1,!>=2}
  "c99" always "c99"
Line 81
  :: always 1
  C99 always 1
Line 83
  == always {!<=-1,!>=2}
  "c11" always "c11"
Line 84
  :: always 2
  C11 always 2
Line 86
  :: always 2
  CLatest always 2
Line 88
  ( always {!<=-1,!>=2}
Line 92
  return always {!<=-1,!>=2}
  ! {!<=-1,!>=2,0}
  stdValue possible size=0
  ( {!<=-1,!>=2,1}
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
Line 99
  CPP03 always 0
Line 100
  "c++03" always "c++03"
Line 101
  CPP11 always 1
Line 102
  "c++11" always "c++11"
Line 103
  CPP14 always 2
Line 104
  "c++14" always "c++14"
Line 105
  CPP17 always 3
Line 106
  "c++17" always "c++17"
Line 107
  CPP20 always 4
Line 108
  "c++20" always "c++20"
Line 109
  CPP23 always 5
Line 110
  "c++23" always "c++23"
Line 112
  "" always ""
Line 115
  std possible size=5
  == always {!<=-1,!>=2}
  "c++03" always "c++03"
Line 116
  :: always 0
  CPP03 always 0
Line 118
  std possible size=5
  == always {!<=-1,!>=2}
  "c++11" always "c++11"
Line 119
  :: always 1
  CPP11 always 1
Line 121
  std possible size=5
  == always {!<=-1,!>=2}
  "c++14" always "c++14"
Line 122
  :: always 2
  CPP14 always 2
Line 124
  std possible size=5
  == always {!<=-1,!>=2}
  "c++17" always "c++17"
Line 125
  :: always 3
  CPP17 always 3
Line 127
  std possible size=5
  == always {!<=-1,!>=2}
  "c++20" always "c++20"
Line 128
  :: always 4
  CPP20 always 4
Line 130
  == always {!<=-1,!>=2}
  "c++23" always "c++23"
Line 131
  :: always 5
  CPP23 always 5
Line 133
  :: always 5
  CPPLatest always 5
Line 58
  OK always 0
  FILE_NOT_FOUND always 1
  BAD_XML always 2
  UNKNOWN_ELEMENT always 3
  MISSING_ATTRIBUTE always 4
  BAD_ATTRIBUTE_VALUE always 5
  UNSUPPORTED_FORMAT always 6
  DUPLICATE_PLATFORM_TYPE always 7
  PLATFORM_TYPE_REDEFINED always 8
Line 62
  :: always 0
  OK always 0
Line 63
  ( possible lifetime[SubObject]=(e)
Line 65
  ( possible lifetime[SubObject]=(e)
  && always {!<=-1,!>=2}
Line 74
  ( always {!<=-1,!>=2}
  , always !<=-1
  len always !<=-1
Line 79
  none always 0
  malloc always 1
  calloc always 2
  strdup always 3
Line 84
  initData always {!<=-1,!>=2}
Line 118
  ? possible 0
  af always !0
  : always 0
  0 always 0
Line 124
  ? possible 0
  af always !0
  : always 0
  0 always 0
Line 138
  , always 1
  = always 1
  1 always 1
Line 141
  = possible 1
  reallocArg possible 1
Line 145
  , always {!<=-1,!>=2}
  noreturn always {!<=-1,!>=2}
Line 146
  = possible {1,0}
  noreturn always {!<=-1,!>=2}
  ? possible {1,0}
  :: always 1
  True always 1
  : always 0
  :: always 0
  False always 0
Line 149
  ( always {!<=-1,!>=2}
Line 152
  ( always {!<=-1,!>=2}
Line 153
  return always {!<=-1,!>=2}
  > always {!<=-1,!>=2}
  0 always 0
  && always {!<=-1,!>=2}
  id {>=1,!<=0}
  & possible {0,1}
  1 always 1
  == {1,0,!<=-1,!>=2}
  0 always 0
Line 155
  ( always {!<=-1,!>=2}
Line 156
  return always {!<=-1,!>=2}
  > always {!<=-1,!>=2}
  0 always 0
  && always {!<=-1,!>=2}
  . {>=1,!<=0}
  & possible {0,1}
  1 always 1
  == {1,0,!<=-1,!>=2}
  0 always 0
Line 160
  ( always {!<=-1,!>=2}
Line 161
  return always {!<=-1,!>=2}
  > always {!<=-1,!>=2}
  0 always 0
  && always {!<=-1,!>=2}
  id {>=1,!<=0}
  & possible {0,1}
  1 always 1
  == {0,1,!<=-1,!>=2}
  1 always 1
Line 163
  ( always {!<=-1,!>=2}
Line 164
  return always {!<=-1,!>=2}
  > always {!<=-1,!>=2}
  0 always 0
  && always {!<=-1,!>=2}
  . {>=1,!<=0}
  & possible {0,1}
  1 always 1
  == {0,1,!<=-1,!>=2}
  1 always 1
Line 167
  ( always {!<=-1,!>=2}
Line 169
  ( always {!<=-1,!>=2}
Line 170
  ( always {!<=-1,!>=2}
Line 190
  ( always {!<=-1,!>=2}
Line 191
  ( always {!<=-1,!>=2}
Line 193
  NONE always 0
  DEFAULT always 1
  ERROR_CODE always 2
Line 201
  ( always {!<=-1,!>=2}
Line 202
  ( always {!<=-1,!>=2}
Line 204
  ( always {!<=-1,!>=2}
Line 209
  -1 always -1
Line 210
  -1 always -1
Line 211
  arrayLike_indexOp always {!<=-1,!>=2}
  false always 0
Line 212
  stdStringLike always {!<=-1,!>=2}
  false always 0
Line 213
  stdAssociativeLike always {!<=-1,!>=2}
  false always 0
Line 214
  opLessAllowed always {!<=-1,!>=2}
  true always 1
Line 215
  hasInitializerListConstructor always {!<=-1,!>=2}
  false always 0
Line 216
  unstableErase always {!<=-1,!>=2}
  false always 0
Line 217
  unstableInsert always {!<=-1,!>=2}
  false always 0
Line 218
  view always {!<=-1,!>=2}
  false always 0
Line 222
  RESIZE always 0
Line 223
  CLEAR always 1
Line 224
  PUSH always 2
Line 225
  POP always 3
Line 226
  FIND always 4
Line 227
  INSERT always 5
Line 228
  ERASE always 6
Line 229
  CHANGE_CONTENT always 7
Line 230
  CHANGE always 8
Line 231
  CHANGE_INTERNAL always 9
Line 232
  NO_ACTION always 10
Line 235
  AT_INDEX always 0
Line 236
  ITEM always 1
Line 237
  BUFFER always 2
Line 238
  BUFFER_NT always 3
Line 239
  START_ITERATOR always 4
Line 240
  END_ITERATOR always 5
Line 241
  ITERATOR always 6
Line 242
  SIZE always 7
Line 243
  EMPTY always 8
Line 244
  NO_YIELD always 9
Line 259
  arrayLike_indexOp always {!<=-1,!>=2}
Line 260
  stdStringLike always {!<=-1,!>=2}
Line 261
  stdAssociativeLike always {!<=-1,!>=2}
Line 262
  opLessAllowed always {!<=-1,!>=2}
Line 263
  hasInitializerListConstructor always {!<=-1,!>=2}
Line 264
  unstableErase always {!<=-1,!>=2}
Line 265
  unstableInsert always {!<=-1,!>=2}
Line 266
  view always {!<=-1,!>=2}
Line 269
  :: possible {symbolic=(functions.end()),end=0}
  i possible {symbolic=(functions.end()),end=0}
  = possible lifetime[Iterator]=(functions)
  ( possible lifetime[Iterator]=(functions)
Line 270
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(functions),end=0}
Line 271
  i always {!symbolic=(functions.end()),!end=0}
Line 272
  :: always 10
  NO_ACTION always 10
Line 276
  :: possible {symbolic=(functions.end()),end=0}
  i possible {symbolic=(functions.end()),end=0}
  = possible lifetime[Iterator]=(functions)
  ( possible lifetime[Iterator]=(functions)
Line 277
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(functions),end=0}
Line 278
  i always {!symbolic=(functions.end()),!end=0}
Line 279
  :: always 9
  NO_YIELD always 9
Line 286
  , always 0
  iterator always {!<=-1,!>=2}
  = always 0
  false always 0
Line 287
  , always 0
  = always 0
  nullptr always 0
Line 292
  notbool always {!<=-1,!>=2}
  false always 0
Line 293
  notnull always {!<=-1,!>=2}
  false always 0
Line 294
  -1 always -1
Line 295
  formatstr always {!<=-1,!>=2}
  false always 0
Line 296
  strz always {!<=-1,!>=2}
  false always 0
Line 297
  optional always {!<=-1,!>=2}
  false always 0
Line 298
  variadic always {!<=-1,!>=2}
  false always 0
Line 302
  notbool always {!<=-1,!>=2}
Line 303
  notnull always {!<=-1,!>=2}
Line 305
  formatstr always {!<=-1,!>=2}
Line 306
  strz always {!<=-1,!>=2}
Line 307
  optional always {!<=-1,!>=2}
Line 308
  variadic always {!<=-1,!>=2}
Line 313
  0 always 0
  it always {!<=-1,!>=2}
  false always 0
  first always {!<=-1,!>=2}
  false always 0
  last always {!<=-1,!>=2}
  false always 0
Line 316
  it always {!<=-1,!>=2}
Line 317
  first always {!<=-1,!>=2}
Line 318
  last always {!<=-1,!>=2}
Line 324
  NONE always 0
  STRLEN always 1
  ARGVALUE always 2
  SIZEOF always 3
  MUL always 4
  VALUE always 5
Line 325
  ( possible lifetime[SubObject]=(t)
  0 always 0
  0 always 0
Line 334
  DIR_IN always 0
Line 335
  DIR_OUT always 1
Line 336
  DIR_INOUT always 2
Line 337
  DIR_UNKNOWN always 3
Line 344
  use always {!<=-1,!>=2}
Line 345
  leakignore always {!<=-1,!>=2}
Line 346
  isconst always {!<=-1,!>=2}
Line 347
  ispure always {!<=-1,!>=2}
Line 349
  ignore always {!<=-1,!>=2}
Line 350
  formatstr always {!<=-1,!>=2}
Line 351
  formatstr_scan always {!<=-1,!>=2}
Line 352
  formatstr_secure always {!<=-1,!>=2}
Line 356
  use always {!<=-1,!>=2}
  false always 0
Line 357
  leakignore always {!<=-1,!>=2}
  false always 0
Line 358
  isconst always {!<=-1,!>=2}
  false always 0
Line 359
  ispure always {!<=-1,!>=2}
  false always 0
Line 360
  :: always 0
  NONE always 0
Line 361
  ignore always {!<=-1,!>=2}
  false always 0
Line 362
  formatstr always {!<=-1,!>=2}
  false always 0
Line 363
  formatstr_scan always {!<=-1,!>=2}
  false always 0
Line 364
  formatstr_secure always {!<=-1,!>=2}
  false always 0
Line 365
  :: always 10
  NO_ACTION always 10
Line 366
  :: always 9
  NO_YIELD always 9
Line 372
  ( always {!<=-1,!>=2}
Line 373
  ( always {!<=-1,!>=2}
Line 374
  ( always {!<=-1,!>=2}
  , always {!<=-1,!>=2}
  pure always {!<=-1,!>=2}
Line 375
  ( always {!<=-1,!>=2}
Line 377
  ( always {!<=-1,!>=2}
Line 379
  return always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  arg always !0
  . always {!<=-1,!>=2}
  notbool always {!<=-1,!>=2}
Line 382
  ( always {!<=-1,!>=2}
Line 383
  ( always {!<=-1,!>=2}
  , always 0
  = always 0
  0 always 0
  , always 0
  = always 0
  nullptr always 0
Line 385
  ( always {!<=-1,!>=2}
Line 387
  return always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  arg always !0
  . always {!<=-1,!>=2}
  formatstr always {!<=-1,!>=2}
Line 390
  ( always {!<=-1,!>=2}
Line 392
  return always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  arg always !0
  . always {!<=-1,!>=2}
  strz always {!<=-1,!>=2}
Line 395
  ( always {!<=-1,!>=2}
Line 396
  ( always {!<=-1,!>=2}
Line 400
  arg always !0
Line 404
  le always 0
  lt always 1
  eq always 2
  ge always 3
  gt always 4
  range always 5
Line 407
  ( always {!<=-1,!>=2}
Line 408
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 414
  && always {!<=-1,!>=2}
  arg always !0
  . always {!<=-1,!>=2}
  it always {!<=-1,!>=2}
  & {lifetime[Address]=(arg->iteratorInfo),!0}
  arg always !0
  nullptr always 0
Line 417
  ( always {!<=-1,!>=2}
Line 421
  ? possible 0
  & {lifetime[Address]=(arg->minsizes),!0}
  arg always !0
  nullptr always 0
Line 426
  ( always {!<=-1,!>=2}
Line 428
  ( always {!<=-1,!>=2}
Line 434
  ( always {!<=-1,!>=2}
Line 436
  ( always {!<=-1,!>=2}
Line 438
  ( always {!<=-1,!>=2}
Line 445
  ( always {!<=-1,!>=2}
Line 447
  ( always {!<=-1,!>=2}
Line 448
  return always {!<=-1,!>=2}
  ( possible lifetime[Iterator]=(mExporters)
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(mExporters),end=0}
Line 451
  ( always {!<=-1,!>=2}
Line 452
  = possible lifetime[Iterator]=(mExporters)
  ( possible lifetime[Iterator]=(mExporters)
Line 453
  return always {!<=-1,!>=2}
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(mExporters),end=0}
  && always {!<=-1,!>=2}
  it always {!symbolic=(mExporters.end()),!end=0}
Line 456
  ( always {!<=-1,!>=2}
Line 457
  = possible lifetime[Iterator]=(mExporters)
  ( possible lifetime[Iterator]=(mExporters)
Line 458
  return always {!<=-1,!>=2}
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(mExporters),end=0}
  && always {!<=-1,!>=2}
  it always {!symbolic=(mExporters.end()),!end=0}
Line 461
  ( always {!<=-1,!>=2}
Line 466
  ( always {!<=-1,!>=2}
Line 467
  return always {!<=-1,!>=2}
  ( possible lifetime[Iterator]=(mReflection)
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(mReflection),end=0}
Line 471
  :: possible {symbolic=(mReflection.end()),end=0}
  it possible {symbolic=(mReflection.end()),end=0}
  = possible lifetime[Iterator]=(mReflection)
  ( possible lifetime[Iterator]=(mReflection)
Line 472
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(mReflection),end=0}
Line 473
  it always {!symbolic=(mReflection.end()),!end=0}
Line 474
  -1 always -1
Line 480
  = always ""
  "" always ""
Line 481
  unique always {!<=-1,!>=2}
  unique always {!<=-1,!>=2}
  = always 0
  false always 0
Line 485
  ( always {!<=-1,!>=2}
Line 489
  size always !<=-1
Line 491
  NO always 0
  BOOL always 1
  CHAR always 2
  SHORT always 3
  INT always 4
  LONG always 5
  LONGLONG always 6
Line 494
  = possible lifetime[Iterator]=(mPodTypes)
  ( possible lifetime[Iterator]=(mPodTypes)
Line 495
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(mPodTypes),end=0}
  & {lifetime[Address]=(it->second),!0}
  it always {!symbolic=(mPodTypes.end()),!end=0}
  nullptr always 0
Line 500
  mSigned always {!<=-1,!>=2}
  false always 0
Line 501
  mUnsigned always {!<=-1,!>=2}
  false always 0
Line 502
  mLong always {!<=-1,!>=2}
  false always 0
Line 503
  mPointer always {!<=-1,!>=2}
  false always 0
Line 504
  mPtrPtr always {!<=-1,!>=2}
  false always 0
Line 505
  mConstPtr always {!<=-1,!>=2}
  false always 0
Line 506
  ( always {!<=-1,!>=2}
Line 507
  return always {!<=-1,!>=2}
  mSigned always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  . always {!<=-1,!>=2}
  mSigned always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 508
  mUnsigned always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  . always {!<=-1,!>=2}
  mUnsigned always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 509
  mLong always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  . always {!<=-1,!>=2}
  mLong always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 510
  mPointer always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  . always {!<=-1,!>=2}
  mPointer always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 511
  mPtrPtr always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  . always {!<=-1,!>=2}
  mPtrPtr always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 512
  mConstPtr always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  . always {!<=-1,!>=2}
  mConstPtr always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 513
  == always {!<=-1,!>=2}
Line 515
  ( always {!<=-1,!>=2}
Line 516
  return always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  this always !0
  == always {!<=-1,!>=2}
Line 519
  mSigned always {!<=-1,!>=2}
Line 520
  mUnsigned always {!<=-1,!>=2}
Line 521
  mLong always {!<=-1,!>=2}
Line 522
  mPointer always {!<=-1,!>=2}
Line 523
  mPtrPtr always {!<=-1,!>=2}
Line 524
  mConstPtr always {!<=-1,!>=2}
Line 529
  = possible lifetime[Iterator]=(mPlatformTypes)
  ( possible lifetime[Iterator]=(mPlatformTypes)
Line 530
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(mPlatformTypes),end=0}
  & {lifetime[Address]=(it->second),!0}
  it always {!symbolic=(mPlatformTypes.end()),!end=0}
  nullptr always 0
Line 536
  :: possible {symbolic=(mPlatforms.end()),end=0}
  it possible {symbolic=(mPlatforms.end()),end=0}
  = possible lifetime[Iterator]=(mPlatforms)
  ( possible lifetime[Iterator]=(mPlatforms)
Line 537
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(mPlatforms),end=0}
Line 538
  it always {!symbolic=(mPlatforms.end()),!end=0}
Line 540
  type always !0
Line 543
  = possible lifetime[Iterator]=(mPlatformTypes)
  ( possible lifetime[Iterator]=(mPlatformTypes)
Line 544
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(mPlatformTypes),end=0}
  & {lifetime[Address]=(it2->second),!0}
  it2 always {!symbolic=(mPlatformTypes.end()),!end=0}
  nullptr always 0
Line 552
  ( always {!<=-1,!>=2}
  , always ""
  = always ""
  "" always ""
Line 555
  def always 0
  check always 1
  suppress always 2
Line 570
  ( always {!<=-1,!>=2}
Line 571
  return always {!<=-1,!>=2}
  ( possible lifetime[Iterator]=(mPrefixes)
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(mPrefixes),end=0}
Line 573
  ( always {!<=-1,!>=2}
Line 574
  return always {!<=-1,!>=2}
  ( possible lifetime[Iterator]=(mSuffixes)
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(mSuffixes),end=0}
Line 583
  0 always 0
Line 606
  ( always {!<=-1,!>=2}
Line 607
  return always {!<=-1,!>=2}
  ( possible lifetime[Iterator]=(mBlocks)
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(mBlocks),end=0}
Line 616
  False always 0
  True always 1
  Maybe always 2
Line 646
  = possible lifetime[Iterator]=(data)
  ( possible lifetime[Iterator]=(data)
Line 647
  == always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(data),end=0}
  nullptr always 0
  & {lifetime[Address]=(it->second),!0}
  it always {!symbolic=(data.end()),!end=0}
Line 655
  = always 0
  nullptr always 0
Line 30
  SHOWTIME_NONE always 0
  = always 0
  0 always 0
  , always 1
Line 31
  SHOWTIME_FILE always 1
  , always 2
Line 32
  SHOWTIME_SUMMARY always 2
  , always 3
Line 33
  SHOWTIME_TOP5 always 3
Line 40
  = always 0
  0 always 0
Line 48
  0 always 0
Line 49
  0 always 0
Line 52
  ( always !<=-1
  ( always !<=-1
Line 70
  , always 0
  = always 0
  nullptr always 0
Line 82
  mStopped always {!<=-1,!>=2}
Line 114
  checkAllConfigurations always {!<=-1,!>=2}
Line 117
  checkConfiguration always {!<=-1,!>=2}
Line 122
  checkHeaders always {!<=-1,!>=2}
Line 125
  checkLibrary always {!<=-1,!>=2}
Line 131
  checkUnusedTemplates always {!<=-1,!>=2}
Line 134
  clang always {!<=-1,!>=2}
Line 140
  clangTidy always {!<=-1,!>=2}
Line 152
  daca always {!<=-1,!>=2}
Line 155
  debugnormal always {!<=-1,!>=2}
Line 158
  debugSimplified always {!<=-1,!>=2}
Line 161
  debugtemplate always {!<=-1,!>=2}
Line 164
  debugwarnings always {!<=-1,!>=2}
Line 167
  dump always {!<=-1,!>=2}
Line 171
  None always 0
  C always 1
  CPP always 2
Line 178
  exceptionHandling always {!<=-1,!>=2}
Line 191
  force always {!<=-1,!>=2}
Line 198
  inlineSuppressions always {!<=-1,!>=2}
Line 202
  jobs always !<=-1
Line 207
  jointSuppressionReport always {!<=-1,!>=2}
Line 243
  preprocessOnly always {!<=-1,!>=2}
Line 248
  quiet always {!<=-1,!>=2}
Line 251
  relativePaths always {!<=-1,!>=2}
Line 254
  reportProgress always {!<=-1,!>=2}
Line 260
  "simple" always "simple"
Line 261
  "rule" always "rule"
Line 262
  :: always 3
  style always 3
Line 280
  classes always {!<=-1,!>=2}
  false always 0
  externalFunctions always {!<=-1,!>=2}
  false always 0
  internalFunctions always {!<=-1,!>=2}
  false always 0
  externalVariables always {!<=-1,!>=2}
  false always 0
Line 289
  classes always {!<=-1,!>=2}
  = always 0
  externalFunctions always {!<=-1,!>=2}
  = always 0
  internalFunctions always {!<=-1,!>=2}
  = always 0
  externalVariables always {!<=-1,!>=2}
  = always 0
  false always 0
Line 298
  classes always {!<=-1,!>=2}
Line 305
  externalFunctions always {!<=-1,!>=2}
Line 311
  internalFunctions always {!<=-1,!>=2}
Line 317
  externalVariables always {!<=-1,!>=2}
Line 350
  verbose always {!<=-1,!>=2}
Line 353
  xml always {!<=-1,!>=2}
Line 362
  ( always {!<=-1,!>=2}
Line 364
  ( always !<=-1
  >= always {!<=-1,!>=2}
  ( always !<=-1
  && always {!<=-1,!>=2}
  0 always 0
  ( {!<=-1,<=symbolic=(file.length()),!>=symbolic=(file.length()+1)}
  == always {!<=-1,!>=2}
  0 always 0
Line 365
  return always {!<=-1,!>=2}
  true always 1
Line 368
  return always {!<=-1,!>=2}
  false always 0
Line 383
  ( always {!<=-1,!>=2}
  , always 0
  inconclusiveCheck always {!<=-1,!>=2}
  = always 0
  false always 0
Line 386
  ( always {!<=-1,!>=2}
Line 387
  return always {!<=-1,!>=2}
  ( possible lifetime[Iterator]=(libraries)
  ( {lifetime[Iterator]=(libraries),start=0}
  ( {lifetime[Iterator]=(libraries),end=0}
  "posix" always "posix"
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(libraries),end=0}
Line 391
  t always {!<=-1,!>=2}
  = always 1
  true always 1
Line 392
  = always {!<=-1,!>=2}
  t always {!<=-1,!>=2}
Line 396
  ( always {!<=-1,!>=2}
Line 397
  return always {!<=-1,!>=2}
Line 66
  ( always {!<=-1,!>=2}
Line 67
  return always {!<=-1,!>=2}
  < always {!<=-1,!>=2}
Line 73
  ( always {!<=-1,!>=2}
Line 74
  return always {!<=-1,!>=2}
  ( always !<=-1
  == always {!<=-1,!>=2}
  1 always 1
Line 80
  result always {!<=-1,!>=2}
Line 81
  result always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  > always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  x {!>=symbolic=(y+1),<=symbolic=(y)}
  < always {!<=-1,!>=2}
  y {!<=symbolic=(x-1),>=symbolic=(x)}
Line 88
  Upper always 0
  Lower always 1
  Point always 2
Line 90
  = always 0
  0 always 0
Line 94
  nullptr always 0
Line 95
  0.0 always 0
Line 98
  nullptr always 0
Line 99
  0U always 0
Line 100
  safe always {!<=-1,!>=2}
  false always 0
Line 101
  conditional always {!<=-1,!>=2}
  false always 0
Line 102
  macro always {!<=-1,!>=2}
  false always 0
Line 103
  defaultArg always {!<=-1,!>=2}
  false always 0
Line 104
  0 always 0
Line 105
  0 always 0
Line 108
  nullptr always 0
Line 117
  ( always {!<=-1,!>=2}
Line 118
  != always {!<=-1,!>=2}
Line 119
  return always {!<=-1,!>=2}
  false always 0
Line 120
  valueType always symbolic=(rhs.valueType)
Line 122
  :: always 5
  CONTAINER_SIZE always 5
Line 123
  :: always 7
  BUFFER_SIZE always 7
Line 124
  :: always 8
  ITERATOR_START always 8
Line 125
  :: always 9
  ITERATOR_END always 9
Line 126
  != always {!<=-1,!>=2}
Line 127
  return always {!<=-1,!>=2}
  false always 0
Line 129
  :: always 1
  TOK always 1
Line 130
  != always {!<=-1,!>=2}
Line 131
  return always {!<=-1,!>=2}
  false always 0
Line 133
  :: always 2
  FLOAT always 2
Line 135
  > always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  floatValue possible <=symbolic=(rhs.floatValue)
  < always {!<=-1,!>=2}
  . possible >=symbolic=(floatValue)
Line 136
  return always {!<=-1,!>=2}
  false always 0
Line 138
  :: always 3
  MOVED always 3
Line 139
  != always {!<=-1,!>=2}
Line 140
  return always {!<=-1,!>=2}
  false always 0
Line 142
  :: always 4
  UNINIT always 4
Line 144
  :: always 6
  LIFETIME always 6
Line 145
  != always {!<=-1,!>=2}
Line 146
  return always {!<=-1,!>=2}
  false always 0
Line 148
  :: always 10
  SYMBOLIC always 10
Line 149
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 150
  return always {!<=-1,!>=2}
  false always 0
Line 151
  != always {!<=-1,!>=2}
Line 152
  return always {!<=-1,!>=2}
  false always 0
Line 155
  return always {!<=-1,!>=2}
  true always 1
Line 162
  :: always 10
  SYMBOLIC always 10
Line 163
  :: always 7
  BUFFER_SIZE always 7
Line 164
  :: always 5
  CONTAINER_SIZE always 5
Line 165
  :: always 8
  ITERATOR_START always 8
Line 166
  :: always 9
  ITERATOR_END always 9
Line 170
  :: always 2
  FLOAT always 2
Line 174
  :: always 4
  UNINIT always 4
Line 175
  :: always 1
  TOK always 1
Line 176
  :: always 6
  LIFETIME always 6
Line 177
  :: always 3
  MOVED always 3
Line 185
  result always {!<=-1,!>=2}
Line 186
  result always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
Line 190
  result always {!<=-1,!>=2}
Line 192
  ( possible {lifetime[Object]=(x),lifetime[Object]=(result),lifetime[Object]=(compare)}
  ( possible lifetime[Object]=(result)
  result always {!<=-1,!>=2}
  ( possible lifetime[Object]=(compare)
Line 197
  ( always {!<=-1,!>=2}
Line 198
  ! always {!<=-1,!>=2}
  this always !0
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
Line 199
  this always !0
  == always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  this always !0
Line 200
  result always {!<=-1,!>=2}
  result always {!<=-1,!>=2}
  = always 0
  false always 0
Line 202
  this always !0
Line 203
  ( possible {lifetime[Object]=(result),lifetime[Object]=(rhs),lifetime[Object]=(compare)}
  ( possible lifetime[Object]=(result)
  result always 0
  ( possible lifetime[Object]=(rhs)
  ( possible lifetime[Object]=(compare)
Line 204
  return always {!<=-1,!>=2}
  result {!<=-1,!>=2,0}
Line 207
  ( always {!<=-1,!>=2}
Line 208
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 209
  return always {!<=-1,!>=2}
  false always 0
Line 211
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 212
  == always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 213
  == always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 214
  conditional always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  . always {!<=-1,!>=2}
  conditional always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 215
  defaultArg always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  . always {!<=-1,!>=2}
  defaultArg always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 216
  == always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 217
  == always {!<=-1,!>=2}
Line 220
  ( always {!<=-1,!>=2}
Line 221
  return always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  this always !0
  == always {!<=-1,!>=2}
Line 225
  ( always {!<=-1,!>=2}
Line 226
  result always {!<=-1,!>=2}
  result always {!<=-1,!>=2}
  = always 0
  false always 0
Line 227
  this always !0
  ( possible {lifetime[Object]=(x),lifetime[Object]=(result)}
  ( possible lifetime[Object]=(result)
  result always 0
Line 228
  return always {!<=-1,!>=2}
  result {!<=-1,!>=2,0}
Line 232
  bound possible 0
  == {!<=-1,!>=2,0}
  :: always 1
  Lower always 1
Line 233
  this always !0
Line 234
  bound always !1
  == always {!<=-1,!>=2}
  :: always 0
  Upper always 0
Line 235
  this always !0
Line 239
  bound possible 0
  == {!<=-1,!>=2,0}
  :: always 1
  Lower always 1
Line 240
  = always 0
  :: always 0
  Upper always 0
Line 241
  bound always !1
  == always {!<=-1,!>=2}
  :: always 0
  Upper always 0
Line 242
  = always 1
  :: always 1
  Lower always 1
Line 255
  INT always 0
Line 256
  TOK always 1
Line 257
  FLOAT always 2
Line 258
  MOVED always 3
Line 259
  UNINIT always 4
Line 260
  CONTAINER_SIZE always 5
Line 261
  LIFETIME always 6
Line 262
  BUFFER_SIZE always 7
Line 263
  ITERATOR_START always 8
Line 264
  ITERATOR_END always 9
Line 265
  SYMBOLIC always 10
Line 267
  ( always {!<=-1,!>=2}
Line 268
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
Line 270
  ( always {!<=-1,!>=2}
Line 271
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 1
  TOK always 1
Line 273
  ( always {!<=-1,!>=2}
Line 274
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 2
  FLOAT always 2
Line 276
  ( always {!<=-1,!>=2}
Line 277
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 3
  MOVED always 3
Line 279
  ( always {!<=-1,!>=2}
Line 280
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 4
  UNINIT always 4
Line 282
  ( always {!<=-1,!>=2}
Line 283
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 5
  CONTAINER_SIZE always 5
Line 285
  ( always {!<=-1,!>=2}
Line 286
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 6
  LIFETIME always 6
Line 288
  ( always {!<=-1,!>=2}
Line 289
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 7
  BUFFER_SIZE always 7
Line 291
  ( always {!<=-1,!>=2}
Line 292
  return always {!<=-1,!>=2}
  valueType possible 9
  == {!<=-1,!>=2,0}
  :: always 8
  ITERATOR_START always 8
  || always {!<=-1,!>=2}
  valueType always !8
  == always {!<=-1,!>=2}
  :: always 9
  ITERATOR_END always 9
Line 294
  ( always {!<=-1,!>=2}
Line 295
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 8
  ITERATOR_START always 8
Line 297
  ( always {!<=-1,!>=2}
Line 298
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 9
  ITERATOR_END always 9
Line 300
  ( always {!<=-1,!>=2}
Line 301
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 10
  SYMBOLIC always 10
Line 304
  ( always {!<=-1,!>=2}
Line 305
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 6
  LIFETIME always 6
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
Line 308
  ( always {!<=-1,!>=2}
Line 309
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 6
  LIFETIME always 6
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 1
  Argument always 1
Line 312
  ( always {!<=-1,!>=2}
Line 313
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 6
  LIFETIME always 6
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 2
  SubFunction always 2
Line 316
  ( always {!<=-1,!>=2}
Line 317
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 333
  NonMovedVariable always 0
  MovedVariable always 1
  ForwardedVariable always 2
Line 347
  safe always {!<=-1,!>=2}
Line 350
  conditional always {!<=-1,!>=2}
Line 353
  macro always {!<=-1,!>=2}
Line 356
  defaultArg always {!<=-1,!>=2}
Line 373
  Object always 0
Line 375
  SubObject always 1
Line 377
  Lambda always 2
Line 379
  Iterator always 3
Line 381
  Address always 4
Line 384
  Local always 0
  Argument always 1
  SubFunction always 2
  ThisPointer always 3
  ThisValue always 4
Line 394
  Possible always 0
Line 396
  Known always 1
Line 398
  Inconclusive always 2
Line 400
  Impossible always 3
Line 404
  = always 1
  :: always 1
  Known always 1
Line 407
  ( always {!<=-1,!>=2}
Line 408
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 1
  Known always 1
Line 415
  ( always {!<=-1,!>=2}
Line 416
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
Line 419
  ( always {!<=-1,!>=2}
Line 420
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 3
  Impossible always 3
Line 424
  = always 3
  :: always 3
  Impossible always 3
Line 427
  inconclusive always {!<=-1,!>=2}
  = always 1
  true always 1
Line 428
  inconclusive always {!<=-1,!>=2}
Line 429
  = always 2
  :: always 2
  Inconclusive always 2
Line 432
  ( always {!<=-1,!>=2}
Line 433
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 2
  Inconclusive always 2
Line 437
  ( always {!<=-1,!>=2}
Line 441
  ( always {!<=-1,!>=2}
Line 442
  return always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  defaultArg always {!<=-1,!>=2}
Line 445
  ( always {!<=-1,!>=2}
Line 456
  ( always !<=-1
Line 460
  ( always {!<=-1,!>=2}
Line 462
  possible always {!<=-1,!>=2}
  = always 1
  true always 1
Line 467
  ( always {!<=-1,!>=2}
  , always 0
  = always 0
  nullptr always 0
  , always 20
  = always 20
  20 always 20
Line 471
  addressOf always {!<=-1,!>=2}
Line 473
  inconclusive always {!<=-1,!>=2}
Line 475
  nullptr always 0
  addressOf always {!<=-1,!>=2}
  false always 0
  inconclusive always {!<=-1,!>=2}
  false always 0
Line 478
  addressOf always {!<=-1,!>=2}
  false always 0
  ( possible lifetime[Object]=(errorPath)
  inconclusive always {!<=-1,!>=2}
  false always 0
Line 481
  addressOf always {!<=-1,!>=2}
Line 482
  addressOf always {!<=-1,!>=2}
  addressOf always {!<=-1,!>=2}
  ( possible lifetime[Object]=(errorPath)
  inconclusive always {!<=-1,!>=2}
  false always 0
Line 485
  b always {!<=-1,!>=2}
Line 487
  . always {!<=-1,!>=2}
  addressOf always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  b always {!<=-1,!>=2}
Line 491
  b always {!<=-1,!>=2}
Line 493
  . always {!<=-1,!>=2}
  inconclusive always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  b always {!<=-1,!>=2}
Line 511
  escape always {!<=-1,!>=2}
  = always 0
  false always 0
Line 514
  ( always {!<=-1,!>=2}
Line 516
  , always 0
  = always 0
  nullptr always 0
Line 520
  ( always {!<=-1,!>=2}
Line 526
  , always 0
  inconclusive always {!<=-1,!>=2}
  = always 0
  false always 0
Line 529
  inconclusive always {!<=-1,!>=2}
  = always 0
  false always 0
Line 530
  = always 0
  0 always 0
Line 532
  , always 0
  = always 0
  nullptr always 0
  , always 1
  smallest always {!<=-1,!>=2}
  = always 1
  true always 1
Line 118
  LOW always 0
  HIGH always 1
Line 125
  UNKNOWN always 0
  CPP11INIT always 1
  NOINIT always 2
Line 128
  mBits always !<=-1
Line 131
  ( always {!<=-1,!>=2}
Line 134
  0 always 0
Line 135
  0 always 0
Line 136
  0 always 0
Line 137
  0 always 0
Line 138
  0 always 0
Line 139
  nullptr always 0
Line 140
  nullptr always 0
Line 141
  nullptr always 0
Line 142
  nullptr always 0
Line 143
  nullptr always 0
Line 144
  0 always 0
Line 145
  0 always 0
Line 146
  nullptr always 0
Line 147
  nullptr always 0
Line 148
  nullptr always 0
Line 149
  nullptr always 0
Line 150
  nullptr always 0
Line 151
  nullptr always 0
Line 153
  mBits always !<=-1
  0 always 0
Line 182
  eVariable always 0
  eType always 1
  eFunction always 2
  eKeyword always 3
  eName always 4
Line 183
  eNumber always 5
  eString always 6
  eChar always 7
  eBoolean always 8
  eLiteral always 9
  eEnumerator always 10
Line 184
  eArithmeticalOp always 11
  eComparisonOp always 12
  eAssignmentOp always 13
  eLogicalOp always 14
  eBitOp always 15
  eIncDecOp always 16
  eExtendedOp always 17
Line 185
  eBracket always 18
Line 186
  eLambda always 19
Line 187
  eEllipsis always 20
Line 188
  eOther always 21
Line 189
  eNone always 22
Line 192
  = always 0
  nullptr always 0
Line 198
  && always {!<=-1,!>=2}
Line 200
  = always 0
  0 always 0
Line 218
  = always 1
  1 always 1
Line 223
  = always 1
  1 always 1
Line 237
  ( always !0
  this always !0
  index possible {-3@18,2@29,-2@90,4@132,-4@188,3@254,1@161}
Line 246
  ( always !0
  this always !0
  index possible 1@30
Line 275
  ( always {!<=-1,!>=2}
  ( always !0
  & {lifetime[Address]=(pattern),!0}
Line 276
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  tok possible {symbolic=(*it)@99,symbolic=(tok1->next()->findClosingBracket())@255,symbolic=(tok->next())@234}
  pattern possible {"sizeof ..."@15,"template <"@19,"explicit ("@27,"false )"@28,">"@234,"decltype ("@18,". template"@34,"template <"@99,"template <"@118,"( * )"@21}
  1 always 1
Line 279
  ( always {!<=-1,!>=2}
  , always !<=-1
  pattern_len always !<=-1
Line 324
  ( always {!<=-1,!>=2}
  , always 0
  = always 0
  0 always 0
Line 370
  = always !0
  this always !0
Line 371
  top possible {symbolic=(this),0}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  top {symbolic=(this),!0}
  ",|(" always ",|("
Line 372
  top always !0
Line 373
  top possible {symbolic=(this),0}
  ? possible 0
  top always !0
  : always 0
  nullptr always 0
Line 380
  = possible {10@11,4@12,0@13}
  t possible {10@11,4@12,0@13}
Line 382
  memoizedIsName always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  mTokType possible {10@11,4@12,0@13}
  == always {!<=-1,!>=2}
  eName always 4
  || always {!<=-1,!>=2}
  mTokType {!4,10@11,0@13}
  == always {!<=-1,!>=2}
  eType always 1
  || always {!<=-1,!>=2}
  mTokType {!4,!1,10@11,0@13}
  == always {!<=-1,!>=2}
  eVariable always 0
  || always {!<=-1,!>=2}
Line 383
  mTokType {!1,!0,10@11}
  == always {!<=-1,!>=2}
  eFunction always 2
  || always {!<=-1,!>=2}
  mTokType {!0,!2,10@11}
  == always {!<=-1,!>=2}
  eKeyword always 3
  || always {!<=-1,!>=2}
  mTokType {!2,!3,10@11}
  == always {!<=-1,!>=2}
  eBoolean always 8
  || always {!<=-1,!>=2}
Line 384
  mTokType {!3,!8,10@11}
  == always {!<=-1,!>=2}
  eEnumerator always 10
Line 385
  fIsName always 2097152
  memoizedIsName {symbolic=(mTokType==eName||mTokType==eType||mTokType==eVariable||mTokType==eFunction||mTokType==eKeyword||mTokType==eBoolean||mTokType==eEnumerator),!<=-1,!>=2,1@11}
Line 387
  memoizedIsLiteral always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  eNumber always 5
  || always {!<=-1,!>=2}
  mTokType always !5
  == always {!<=-1,!>=2}
  eString always 6
  || always {!<=-1,!>=2}
  mTokType always {!5,!6}
  == always {!<=-1,!>=2}
  eChar always 7
  || always {!<=-1,!>=2}
Line 388
  mTokType always {!6,!7}
  == always {!<=-1,!>=2}
  eBoolean always 8
  || always {!<=-1,!>=2}
  mTokType always {!7,!8}
  == always {!<=-1,!>=2}
  eLiteral always 9
  || always {!<=-1,!>=2}
  mTokType always {!8,!9}
  == always {!<=-1,!>=2}
  eEnumerator always 10
Line 389
  fIsLiteral always 4194304
  memoizedIsLiteral {symbolic=(mTokType==eNumber||mTokType==eString||mTokType==eChar||mTokType==eBoolean||mTokType==eLiteral||mTokType==eEnumerator),!<=-1,!>=2}
Line 391
  ( always {!<=-1,!>=2}
Line 392
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  eKeyword always 3
Line 394
  ( always {!<=-1,!>=2}
Line 395
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsName always 2097152
Line 397
  ( always {!<=-1,!>=2}
Line 398
  return always {!<=-1,!>=2}
  mFlags always !<=-1
  == always {!<=-1,!>=2}
  fIsName always 2097152
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  eName always 4
Line 400
  ( always {!<=-1,!>=2}
Line 401
  ( always {!<=-1,!>=2}
Line 402
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsLiteral always 4194304
Line 404
  ( always {!<=-1,!>=2}
Line 405
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  eNumber always 5
Line 407
  ( always {!<=-1,!>=2}
Line 408
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  eEnumerator always 10
Line 410
  ( always {!<=-1,!>=2}
Line 411
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
Line 412
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
Line 413
  == always {!<=-1,!>=2}
  eIncDecOp always 16
Line 415
  ( always {!<=-1,!>=2}
Line 416
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
Line 417
  == always {!<=-1,!>=2}
  eLogicalOp always 14
  || always {!<=-1,!>=2}
Line 418
  mTokType always !14
  == always {!<=-1,!>=2}
  eComparisonOp always 12
  || always {!<=-1,!>=2}
Line 419
  mTokType always {!14,!12}
  == always {!<=-1,!>=2}
  eBitOp always 15
Line 421
  ( always {!<=-1,!>=2}
Line 422
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
Line 423
  == always {!<=-1,!>=2}
  eExtendedOp always 17
Line 425
  ( always {!<=-1,!>=2}
Line 426
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  eArithmeticalOp always 11
Line 428
  ( always {!<=-1,!>=2}
Line 429
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  eComparisonOp always 12
Line 431
  ( always {!<=-1,!>=2}
Line 432
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  eAssignmentOp always 13
Line 434
  ( always {!<=-1,!>=2}
Line 435
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  eBoolean always 8
Line 437
  ( always {!<=-1,!>=2}
Line 438
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  eIncDecOp always 16
Line 440
  ( always {!<=-1,!>=2}
Line 441
  return always {!<=-1,!>=2}
  != always {!<=-1,!>=2}
  nullptr always 0
  && always {!<=-1,!>=2}
  != always {!<=-1,!>=2}
  nullptr always 0
Line 443
  ( always {!<=-1,!>=2}
Line 444
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  != always {!<=-1,!>=2}
  nullptr always 0
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  nullptr always 0
Line 446
  ( always {!<=-1,!>=2}
Line 448
  ( always !<=-1
Line 449
  return always !<=-1
  mFlags always !<=-1
Line 451
  flags_ always !<=-1
Line 452
  mFlags always !<=-1
  = always !<=-1
  flags_ always !<=-1
Line 454
  ( always {!<=-1,!>=2}
Line 455
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsUnsigned always 1
Line 457
  sign always {!<=-1,!>=2}
Line 458
  fIsUnsigned always 1
  sign {!<=-1,!>=2,0@152,1@152}
Line 460
  ( always {!<=-1,!>=2}
Line 461
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsSigned always 2
Line 463
  sign always {!<=-1,!>=2}
Line 464
  fIsSigned always 2
  sign {!<=-1,!>=2,0@154}
Line 466
  ( always {!<=-1,!>=2}
Line 467
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsPointerCompare always 4
Line 469
  b always {!<=-1,!>=2}
Line 470
  fIsPointerCompare always 4
  b always {!<=-1,!>=2}
Line 472
  ( always {!<=-1,!>=2}
Line 473
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsLong always 8
Line 475
  size always {!<=-1,!>=2}
Line 476
  fIsLong always 8
  size {!<=-1,!>=2,1@148,0@156}
Line 478
  ( always {!<=-1,!>=2}
Line 479
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsStandardType always 16
Line 481
  b always {!<=-1,!>=2}
Line 482
  fIsStandardType always 16
  b {!<=-1,!>=2,0@19}
Line 484
  ( always {!<=-1,!>=2}
Line 485
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsExpandedMacro always 32
Line 487
  m always {!<=-1,!>=2}
Line 488
  fIsExpandedMacro always 32
  m always {!<=-1,!>=2}
Line 490
  ( always {!<=-1,!>=2}
Line 491
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsCast always 64
Line 493
  c always {!<=-1,!>=2}
Line 494
  fIsCast always 64
  c always {!<=-1,!>=2}
Line 496
  ( always {!<=-1,!>=2}
Line 497
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsAttributeConstructor always 128
Line 499
  ac always {!<=-1,!>=2}
Line 500
  fIsAttributeConstructor always 128
  ac always {!<=-1,!>=2}
Line 502
  ( always {!<=-1,!>=2}
Line 503
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsAttributeDestructor always 256
Line 505
  value always {!<=-1,!>=2}
Line 506
  fIsAttributeDestructor always 256
  value always {!<=-1,!>=2}
Line 508
  ( always {!<=-1,!>=2}
Line 509
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsAttributeUnused always 512
Line 511
  unused always {!<=-1,!>=2}
Line 512
  fIsAttributeUnused always 512
  unused always {!<=-1,!>=2}
Line 514
  ( always {!<=-1,!>=2}
Line 515
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsAttributeUsed always 16384
Line 517
  unused always {!<=-1,!>=2}
Line 518
  fIsAttributeUsed always 16384
  unused always {!<=-1,!>=2}
Line 520
  ( always {!<=-1,!>=2}
Line 521
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsAttributePure always 1024
Line 523
  value always {!<=-1,!>=2}
Line 524
  fIsAttributePure always 1024
  value always {!<=-1,!>=2}
Line 526
  ( always {!<=-1,!>=2}
Line 527
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsAttributeConst always 2048
Line 529
  value always {!<=-1,!>=2}
Line 530
  fIsAttributeConst always 2048
  value always {!<=-1,!>=2}
Line 532
  ( always {!<=-1,!>=2}
Line 533
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsAttributeNoreturn always 4096
Line 535
  value always {!<=-1,!>=2}
Line 536
  fIsAttributeNoreturn always 4096
  value always {!<=-1,!>=2}
Line 538
  ( always {!<=-1,!>=2}
Line 539
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsAttributeNothrow always 8192
Line 541
  value always {!<=-1,!>=2}
Line 542
  fIsAttributeNothrow always 8192
  value always {!<=-1,!>=2}
Line 544
  ( always {!<=-1,!>=2}
Line 545
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsAttributePacked always 32768
Line 547
  value always {!<=-1,!>=2}
Line 548
  fIsAttributePacked always 32768
  value always {!<=-1,!>=2}
Line 550
  ( always {!<=-1,!>=2}
Line 551
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsAttributeNodiscard always 16777216
Line 553
  value always {!<=-1,!>=2}
Line 554
  fIsAttributeNodiscard always 16777216
  value always {!<=-1,!>=2}
Line 556
  ( always {!<=-1,!>=2}
Line 557
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsAttributeMaybeUnused always 65536
Line 559
  value always {!<=-1,!>=2}
Line 560
  fIsAttributeMaybeUnused always 65536
  value always {!<=-1,!>=2}
Line 565
  ( always {!<=-1,!>=2}
Line 566
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 568
  ( always {!<=-1,!>=2}
Line 569
  return always {!<=-1,!>=2}
  nullptr always 0
  != always {!<=-1,!>=2}
Line 571
  ( always {!<=-1,!>=2}
Line 572
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsControlFlowKeyword always 131072
Line 574
  ( always {!<=-1,!>=2}
Line 575
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsOperatorKeyword always 262144
Line 577
  value always {!<=-1,!>=2}
Line 578
  fIsOperatorKeyword always 262144
  value always {!<=-1,!>=2}
Line 580
  ( always {!<=-1,!>=2}
Line 581
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsComplex always 524288
Line 583
  value always {!<=-1,!>=2}
Line 584
  fIsComplex always 524288
  value always {!<=-1,!>=2}
Line 586
  ( always {!<=-1,!>=2}
Line 587
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsEnumType always 1048576
Line 589
  value always {!<=-1,!>=2}
Line 590
  fIsEnumType always 1048576
  value always {!<=-1,!>=2}
Line 592
  ( always {!<=-1,!>=2}
Line 593
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fAtAddress always 33554432
Line 595
  b always {!<=-1,!>=2}
Line 596
  fAtAddress always 33554432
  b always {!<=-1,!>=2}
Line 598
  ( always {!<=-1,!>=2}
Line 599
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIncompleteVar always 67108864
Line 601
  b always {!<=-1,!>=2}
Line 602
  fIncompleteVar always 67108864
  b always {!<=-1,!>=2}
Line 605
  ( always {!<=-1,!>=2}
Line 606
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsIncompleteConstant always 68719476736
Line 608
  b always {!<=-1,!>=2}
Line 609
  fIsIncompleteConstant always 68719476736
  b always {!<=-1,!>=2}
Line 612
  ( always {!<=-1,!>=2}
Line 613
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fConstexpr always 134217728
Line 615
  b always {!<=-1,!>=2}
Line 616
  fConstexpr always 134217728
  b always {!<=-1,!>=2}
Line 619
  ( always {!<=-1,!>=2}
Line 620
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fExternC always 268435456
Line 622
  b always {!<=-1,!>=2}
Line 623
  fExternC always 268435456
  b always {!<=-1,!>=2}
Line 626
  ( always {!<=-1,!>=2}
Line 627
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsSplitVarDeclComma always 536870912
Line 629
  b always {!<=-1,!>=2}
Line 630
  fIsSplitVarDeclComma always 536870912
  b always {!<=-1,!>=2}
Line 633
  ( always {!<=-1,!>=2}
Line 634
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsSplitVarDeclEq always 1073741824
Line 636
  b always {!<=-1,!>=2}
Line 637
  fIsSplitVarDeclEq always 1073741824
  b always {!<=-1,!>=2}
Line 640
  ( always {!<=-1,!>=2}
Line 641
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsImplicitInt always 2147483648
Line 643
  b always {!<=-1,!>=2}
Line 644
  fIsImplicitInt always 2147483648
  b always {!<=-1,!>=2}
Line 647
  ( always {!<=-1,!>=2}
Line 648
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsInline always 4294967296
Line 650
  b always {!<=-1,!>=2}
Line 651
  fIsInline always 4294967296
  b always {!<=-1,!>=2}
Line 654
  ( always {!<=-1,!>=2}
Line 655
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsRemovedVoidParameter always 34359738368
Line 657
  b always {!<=-1,!>=2}
Line 658
  fIsRemovedVoidParameter always 34359738368
  b always {!<=-1,!>=2}
Line 661
  ( always {!<=-1,!>=2}
Line 662
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsTemplate always 8589934592
Line 664
  b always {!<=-1,!>=2}
Line 665
  fIsTemplate always 8589934592
  b always {!<=-1,!>=2}
Line 668
  ( always {!<=-1,!>=2}
Line 669
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsSimplifedScope always 17179869184
Line 671
  b always {!<=-1,!>=2}
Line 672
  fIsSimplifedScope always 17179869184
  b always {!<=-1,!>=2}
Line 675
  ( always {!<=-1,!>=2}
Line 676
  return always {!<=-1,!>=2}
  . always !<=-1
  mBits always !<=-1
  > always {!<=-1,!>=2}
  0 always 0
Line 678
  ( always !<=-1
Line 679
  return always !<=-1
  . always !<=-1
  mBits always !<=-1
Line 685
  ! always {!<=-1,!>=2}
Line 687
  . possible lifetime[Object]=(tokenAndName)
Line 689
  b always !<=-1
Line 690
  . always !<=-1
  mBits always !<=-1
  = always !<=-1
  b always !<=-1
Line 693
  ( always {!<=-1,!>=2}
Line 694
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  eString always 6
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  '"' always 34
  "u8" always "u8"
  || always {!<=-1,!>=2}
Line 695
  == always {!<=-1,!>=2}
  eChar always 7
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  '\'' always 39
  "u8" always "u8"
Line 698
  ( always {!<=-1,!>=2}
Line 699
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  eString always 6
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  '"' always 34
  "u" always "u"
  || always {!<=-1,!>=2}
Line 700
  == always {!<=-1,!>=2}
  eChar always 7
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  '\'' always 39
  "u" always "u"
Line 703
  ( always {!<=-1,!>=2}
Line 704
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  eString always 6
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  '"' always 34
  "U" always "U"
  || always {!<=-1,!>=2}
Line 705
  == always {!<=-1,!>=2}
  eChar always 7
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  '\'' always 39
  "U" always "U"
Line 708
  ( always {!<=-1,!>=2}
Line 709
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  eString always 6
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  '"' always 34
  "" always ""
  || always {!<=-1,!>=2}
Line 710
  == always {!<=-1,!>=2}
  eChar always 7
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  '\'' always 39
  "" always ""
  && always {!<=-1,!>=2}
  ( always !<=-1
  == always {!<=-1,!>=2}
  3 always 3
Line 713
  ( always {!<=-1,!>=2}
Line 714
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  eChar always 7
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  '\'' always 39
  "" always ""
  && always {!<=-1,!>=2}
Line 715
  ( always !<=-1
  > always {!<=-1,!>=2}
  3 always 3
Line 734
  ( always {!<=-1,!>=2}
Line 735
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsTemplateArg always 8388608
Line 737
  value always {!<=-1,!>=2}
Line 738
  fIsTemplateArg always 8388608
  value {!<=-1,!>=2,1@214}
Line 742
  ( always !0
  & {lifetime[Address]=(pattern),!0}
Line 743
  pattern possible {";"@186,";"@192,";"@194,";"@151}
  1 always 1
Line 745
  , always !<=-1
  pattern_len always !<=-1
Line 748
  ( always !0
  & {lifetime[Address]=(pattern),!0}
Line 749
  1 always 1
Line 751
  , always !<=-1
  pattern_len always !<=-1
Line 753
  , always 0
  = always 0
  0 always 0
Line 754
  , always 0
  = always 0
  0 always 0
Line 757
  ( always !0
  & {lifetime[Address]=(pattern),!0}
Line 758
  1 always 1
Line 760
  , always !<=-1
  pattern_len always !<=-1
Line 761
  pattern_len always !<=-1
Line 764
  ( always !0
  & {lifetime[Address]=(pattern),!0}
Line 765
  1 always 1
Line 767
  , always !<=-1
  pattern_len always !<=-1
Line 768
  pattern_len always !<=-1
Line 771
  , always 0
  = always 0
  0 always 0
Line 772
  varId possible 0
Line 774
  , always 0
  = always 0
  0 always 0
Line 775
  varId possible 0
Line 837
  , always 0
  prepend always {!<=-1,!>=2}
  = always 0
  false always 0
Line 841
  true always 1
Line 853
  = possible 0
  id possible 0
Line 854
  != always {!<=-1,!>=2}
  0 always 0
Line 855
  eVariable always 0
Line 856
  false always 0
Line 864
  . always !0
Line 877
  = always 0
  nullptr always 0
Line 892
  = always 5
  5 always 5
Line 904
  varid always {!<=-1,!>=2}
  varid always {!<=-1,!>=2}
  = always 0
  false always 0
Line 905
  exprid always {!<=-1,!>=2}
  exprid always {!<=-1,!>=2}
  = always 0
  false always 0
Line 906
  idtype always {!<=-1,!>=2}
  idtype always {!<=-1,!>=2}
  = always 0
  false always 0
Line 907
  attributes always {!<=-1,!>=2}
  attributes always {!<=-1,!>=2}
  = always 0
  false always 0
Line 908
  macro always {!<=-1,!>=2}
  macro always {!<=-1,!>=2}
  = always 0
  false always 0
Line 909
  linenumbers always {!<=-1,!>=2}
  linenumbers always {!<=-1,!>=2}
  = always 0
  false always 0
Line 910
  linebreaks always {!<=-1,!>=2}
  linebreaks always {!<=-1,!>=2}
  = always 0
  false always 0
Line 911
  files always {!<=-1,!>=2}
  files always {!<=-1,!>=2}
  = always 0
  false always 0
Line 914
  . always {!<=-1,!>=2}
  attributes always {!<=-1,!>=2}
  = always 1
  true always 1
Line 915
  . always {!<=-1,!>=2}
  macro always {!<=-1,!>=2}
  = always 1
  true always 1
Line 916
  . always {!<=-1,!>=2}
  linenumbers always {!<=-1,!>=2}
  = always 1
  true always 1
Line 917
  . always {!<=-1,!>=2}
  linebreaks always {!<=-1,!>=2}
  = always 1
  true always 1
Line 918
  . always {!<=-1,!>=2}
  files always {!<=-1,!>=2}
  = always 1
  true always 1
Line 923
  . always {!<=-1,!>=2}
  varid always {!<=-1,!>=2}
  = always 1
  true always 1
Line 928
  . always {!<=-1,!>=2}
  exprid always {!<=-1,!>=2}
  = always 1
  true always 1
Line 933
  . always {!<=-1,!>=2}
  exprid always {!<=-1,!>=2}
  = always 1
  true always 1
Line 934
  . always {!<=-1,!>=2}
  varid always {!<=-1,!>=2}
  = always 1
  true always 1
Line 935
  . always {!<=-1,!>=2}
  idtype always {!<=-1,!>=2}
  = always 1
  true always 1
Line 948
  varid always {!<=-1,!>=2}
  attributes always {!<=-1,!>=2}
  macro always {!<=-1,!>=2}
Line 950
  , always 0
  = always 0
  nullptr always 0
  , always 0
  = always 0
  nullptr always 0
Line 951
  , always 1
  attributes always {!<=-1,!>=2}
  = always 1
  true always 1
Line 952
  varid always {!<=-1,!>=2}
  = always 0
  false always 0
Line 965
  varid always {!<=-1,!>=2}
  attributes always {!<=-1,!>=2}
  linenumbers always {!<=-1,!>=2}
  linebreaks always {!<=-1,!>=2}
  files always {!<=-1,!>=2}
  = always 0
  nullptr always 0
  , always 0
  = always 0
  nullptr always 0
Line 984
  mStr possible size=1
  == always {!<=-1,!>=2}
  "<" always "<"
  || always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  ">" always ">"
Line 1026
  mTokType possible 19
  == {!<=-1,!>=2,0}
  eFunction always 2
  || always {!<=-1,!>=2}
  mTokType always !2
  == always {!<=-1,!>=2}
  eLambda always 19
  : always 0
  nullptr always 0
Line 1034
  = possible 0
  v possible 0
Line 1035
  || always {!<=-1,!>=2}
Line 1036
  eVariable always 0
Line 1037
  == always {!<=-1,!>=2}
  eVariable always 0
Line 1038
  eName always 4
Line 1045
  == always {!<=-1,!>=2}
  eVariable always 0
  ? possible 0
  : always 0
  nullptr always 0
Line 1058
  == always {!<=-1,!>=2}
  eType always 1
  ? possible 0
  : always 0
  nullptr always 0
Line 1061
  , always 0
  = always 0
  nullptr always 0
Line 1071
  == always {!<=-1,!>=2}
  eEnumerator always 10
  ? possible 0
  : always 0
  nullptr always 0
Line 1079
  = possible 0
  e possible 0
Line 1081
  eEnumerator always 10
Line 1082
  == always {!<=-1,!>=2}
  eEnumerator always 10
Line 1083
  eName always 4
Line 1152
  . always !0
Line 1156
  . always !0
Line 1163
  && always {!<=-1,!>=2}
Line 1164
  ! always {!<=-1,!>=2}
Line 1170
  ( always {!<=-1,!>=2}
Line 1171
  ( always {!<=-1,!>=2}
Line 1172
  ( always {!<=-1,!>=2}
Line 1173
  ( always {!<=-1,!>=2}
Line 1182
  condition always {!<=-1,!>=2}
  = always 0
  0 always 0
Line 1197
  ( always {!<=-1,!>=2}
Line 1199
  ( always {!<=-1,!>=2}
Line 1227
  ( always {!<=-1,!>=2}
Line 1243
  fIsUnsigned always 1
  = always 1
  1 always 1
  << always 1
  0 always 0
  , always 2
Line 1244
  fIsSigned always 2
  = always 2
  1 always 1
  << always 2
  1 always 1
  , always 4
Line 1245
  fIsPointerCompare always 4
  = always 4
  1 always 1
  << always 4
  2 always 2
  , always 8
Line 1246
  fIsLong always 8
  = always 8
  1 always 1
  << always 8
  3 always 3
  , always 16
Line 1247
  fIsStandardType always 16
  = always 16
  1 always 1
  << always 16
  4 always 4
  , always 32
Line 1248
  fIsExpandedMacro always 32
  = always 32
  1 always 1
  << always 32
  5 always 5
  , always 64
Line 1249
  fIsCast always 64
  = always 64
  1 always 1
  << always 64
  6 always 6
  , always 128
Line 1250
  fIsAttributeConstructor always 128
  = always 128
  1 always 1
  << always 128
  7 always 7
  , always 256
Line 1251
  fIsAttributeDestructor always 256
  = always 256
  1 always 1
  << always 256
  8 always 8
  , always 512
Line 1252
  fIsAttributeUnused always 512
  = always 512
  1 always 1
  << always 512
  9 always 9
  , always 1024
Line 1253
  fIsAttributePure always 1024
  = always 1024
  1 always 1
  << always 1024
  10 always 10
  , always 2048
Line 1254
  fIsAttributeConst always 2048
  = always 2048
  1 always 1
  << always 2048
  11 always 11
  , always 4096
Line 1255
  fIsAttributeNoreturn always 4096
  = always 4096
  1 always 1
  << always 4096
  12 always 12
  , always 8192
Line 1256
  fIsAttributeNothrow always 8192
  = always 8192
  1 always 1
  << always 8192
  13 always 13
  , always 16384
Line 1257
  fIsAttributeUsed always 16384
  = always 16384
  1 always 1
  << always 16384
  14 always 14
  , always 32768
Line 1258
  fIsAttributePacked always 32768
  = always 32768
  1 always 1
  << always 32768
  15 always 15
  , always 65536
Line 1259
  fIsAttributeMaybeUnused always 65536
  = always 65536
  1 always 1
  << always 65536
  16 always 16
  , always 131072
Line 1260
  fIsControlFlowKeyword always 131072
  = always 131072
  1 always 1
  << always 131072
  17 always 17
  , always 262144
Line 1261
  fIsOperatorKeyword always 262144
  = always 262144
  1 always 1
  << always 262144
  18 always 18
  , always 524288
Line 1262
  fIsComplex always 524288
  = always 524288
  1 always 1
  << always 524288
  19 always 19
  , always 1048576
Line 1263
  fIsEnumType always 1048576
  = always 1048576
  1 always 1
  << always 1048576
  20 always 20
  , always 2097152
Line 1264
  fIsName always 2097152
  = always 2097152
  1 always 1
  << always 2097152
  21 always 21
  , always 4194304
Line 1265
  fIsLiteral always 4194304
  = always 4194304
  1 always 1
  << always 4194304
  22 always 22
  , always 8388608
Line 1266
  fIsTemplateArg always 8388608
  = always 8388608
  1 always 1
  << always 8388608
  23 always 23
  , always 16777216
Line 1267
  fIsAttributeNodiscard always 16777216
  = always 16777216
  1 always 1
  << always 16777216
  24 always 24
  , always 33554432
Line 1268
  fAtAddress always 33554432
  = always 33554432
  1 always 1
  << always 33554432
  25 always 25
  , always 67108864
Line 1269
  fIncompleteVar always 67108864
  = always 67108864
  1 always 1
  << always 67108864
  26 always 26
  , always 134217728
Line 1270
  fConstexpr always 134217728
  = always 134217728
  1 always 1
  << always 134217728
  27 always 27
  , always 268435456
Line 1271
  fExternC always 268435456
  = always 268435456
  1 always 1
  << always 268435456
  28 always 28
  , always 536870912
Line 1272
  fIsSplitVarDeclComma always 536870912
  = always 536870912
  1 always 1
  << always 536870912
  29 always 29
  , always 1073741824
Line 1273
  fIsSplitVarDeclEq always 1073741824
  = always 1073741824
  1 always 1
  << always 1073741824
  30 always 30
  , always 2147483648
Line 1274
  fIsImplicitInt always 2147483648
  = always 2147483648
  1U always 1
  << always 2147483648
  31 always 31
  , always 4294967296
Line 1275
  fIsInline always 4294967296
  = always 4294967296
  1ULL always 1
  << always 4294967296
  32 always 32
  , always 8589934592
Line 1276
  fIsTemplate always 8589934592
  = always 8589934592
  1ULL always 1
  << always 8589934592
  33 always 33
  , always 17179869184
Line 1277
  fIsSimplifedScope always 17179869184
  = always 17179869184
  1ULL always 1
  << always 17179869184
  34 always 34
  , always 34359738368
Line 1278
  fIsRemovedVoidParameter always 34359738368
  = always 34359738368
  1ULL always 1
  << always 34359738368
  35 always 35
  , always 68719476736
Line 1279
  fIsIncompleteConstant always 68719476736
  = always 68719476736
  1ULL always 1
  << always 68719476736
  36 always 36
Line 1284
  mFlags always !<=-1
Line 1293
  ( always {!<=-1,!>=2}
  flag_ always !<=-1
Line 1294
  return always {!<=-1,!>=2}
  mFlags always !<=-1
  & always !<=-1
  flag_ {!<=-1,8388608@21,17179869184@32,8589934592@34,34359738368@36,4294967296@38,2147483648@40,1073741824@42,536870912@44,268435456@46}
  != always {!<=-1,!>=2}
  0 always 0
Line 1302
  flag_ always !<=-1
  state_ always {!<=-1,!>=2}
Line 1303
  mFlags always !<=-1
  = always !<=-1
  state_ {!<=-1,!>=2,symbolic=(mTokType==eName||mTokType==eType||mTokType==eVariable||mTokType==eFunction||mTokType==eKeyword||mTokType==eBoolean||mTokType==eEnumerator)@108,symbolic=(mTokType==eNumber||mTokType==eString||mTokType==eChar||mTokType==eBoolean||mTokType==eLiteral||mTokType==eEnumerator)@109}
  ? always !<=-1
  mFlags always !<=-1
  | always !<=-1
  flag_ {!<=-1,17179869184@31,8589934592@33,34359738368@35,4294967296@37,2147483648@39,1073741824@41,536870912@43,268435456@45,134217728@47}
  : always !<=-1
  mFlags always !<=-1
  & always !<=-1
  ~ always !<=0
  flag_ {!<=-1,17179869184@31,8589934592@33,34359738368@35,4294967296@37,2147483648@39,1073741824@41,536870912@43,268435456@45,134217728@47}
Line 1317
  , always 0
  = always 0
  0 always 0
  , always 0
  = always 0
  0 always 0
Line 1343
  ! always {!<=-1,!>=2}
Line 1344
  nullptr always 0
Line 1345
  this {!0,symbolic=(astParent()->astOperand2())}
  == always {!<=-1,!>=2}
  ( always !0
Line 1346
  ( always !0
Line 1347
  this always {!0,!symbolic=(astParent()->astOperand1())}
  == always {!<=-1,!>=2}
  ( always !0
Line 1348
  ( always !0
Line 1349
  nullptr always 0
Line 1353
  ! always {!<=-1,!>=2}
Line 1354
  nullptr always 0
Line 1355
  this {!0,symbolic=(astParent()->astOperand2())}
  == always {!<=-1,!>=2}
  ( always !0
Line 1356
  ( always !0
Line 1357
  this always {!0,!symbolic=(astParent()->astOperand1())}
  == always {!<=-1,!>=2}
  ( always !0
Line 1358
  ( always !0
Line 1359
  nullptr always 0
Line 1363
  = always !0
  this always !0
Line 1364
  ret possible symbolic=(this)
Line 1365
  = always !0
  . always !0
Line 1366
  ret possible symbolic=(this)
Line 1370
  = always !0
  this always !0
Line 1371
  ret possible symbolic=(this)
Line 1372
  = always !0
  . always !0
Line 1373
  ret possible symbolic=(this)
Line 1385
  ( always {!<=-1,!>=2}
Line 1388
  = always 0
  = always 0
  = always 0
  nullptr always 0
Line 1393
  = always 0
  nullptr always 0
Line 1396
  = always ""
  "" always ""
Line 1402
  sep possible ""
Line 1411
  verbose always {!<=-1,!>=2}
  xml always {!<=-1,!>=2}
Line 1413
  xml always {!<=-1,!>=2}
Line 1418
  cpp11init always {!<=-1,!>=2}
Line 1419
  = possible {1,2}
  cpp11init always {!<=-1,!>=2}
  ? possible {1,2}
  :: always 1
  CPP11INIT always 1
  : always 2
  :: always 2
  NOINIT always 2
Line 58
  ( always {!<=-1,!>=2}
Line 59
  return always {!<=-1,!>=2}
  mIsC always {!<=-1,!>=2}
Line 63
  ( always {!<=-1,!>=2}
Line 64
  return always {!<=-1,!>=2}
  mIsCpp always {!<=-1,!>=2}
Line 73
  , always 0
  split always {!<=-1,!>=2}
  = always 0
  false always 0
Line 90
  , always 1
  one_line always {!<=-1,!>=2}
  = always 1
  true always 1
Line 101
  ( always {!<=-1,!>=2}
Line 103
  && always {!<=-1,!>=2}
Line 156
  ( always !<=-1
Line 175
  ( always {!<=-1,!>=2}
Line 192
  ( always {!<=-1,!>=2}
Line 219
  mIsC always {!<=-1,!>=2}
Line 220
  mIsCpp always {!<=-1,!>=2}
Line 71
  ( always {!<=-1,!>=2}
Line 73
  ( always {!<=-1,!>=2}
Line 75
  return possible lifetime[Iterator]=(mVariableId)
  ( possible lifetime[Iterator]=(mVariableId)
Line 77
  ( always end=0
Line 78
  return possible lifetime[Iterator]=(mVariableId)
  ( {lifetime[Iterator]=(mVariableId),end=0}
Line 84
  & {lifetime[Address]=(mVarId),!0}
Line 99
  ( always {!<=-1,!>=2}
Line 100
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 104
  ( always {!<=-1,!>=2}
Line 105
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 114
  ( always {!<=-1,!>=2}
  , always 0
  = always 0
  nullptr always 0
Line 116
  ( always {!<=-1,!>=2}
Line 117
  && always {!<=-1,!>=2}
Line 119
  ( always {!<=-1,!>=2}
Line 141
  ( always {!<=-1,!>=2}
Line 159
  ( always {!<=-1,!>=2}
Line 167
  ( always {!<=-1,!>=2}
Line 185
  check always {!<=-1,!>=2}
Line 218
  ( always {!<=-1,!>=2}
Line 232
  ( always {!<=-1,!>=2}
Line 292
  ( always {!<=-1,!>=2}
Line 298
  only_k_r_fpar always {!<=-1,!>=2}
Line 299
  , always {!<=-1,!>=2}
  only_k_r_fpar always {!<=-1,!>=2}
Line 314
  ( always {!<=-1,!>=2}
Line 351
  ( always {!<=-1,!>=2}
Line 364
  ( always {!<=-1,!>=2}
Line 380
  , always {!<=-1,!>=2}
  commandWithCondition always {!<=-1,!>=2}
Line 397
  ( always {!<=-1,!>=2}
Line 401
  ( always {!<=-1,!>=2}
Line 420
  ( always {!<=-1,!>=2}
Line 426
  ( always {!<=-1,!>=2}
  valueIsPointer always {!<=-1,!>=2}
  , always {!<=-1,!>=2}
  floatvar always {!<=-1,!>=2}
Line 432
  ( always {!<=-1,!>=2}
  , always {!<=-1,!>=2}
  valueIsPointer always {!<=-1,!>=2}
Line 455
  ( always {!<=-1,!>=2}
Line 462
  ( always {!<=-1,!>=2}
Line 480
  ( always {!<=-1,!>=2}
Line 497
  ( always {!<=-1,!>=2}
Line 582
  , always {!<=-1,!>=2}
  cpp always {!<=-1,!>=2}
Line 591
  ( always {!<=-1,!>=2}
Line 640
  , always ""
  = always ""
  "" always ""
Line 680
  ( always {!<=-1,!>=2}
  , always {!<=-1,!>=2}
  allowSemicolon always {!<=-1,!>=2}
Line 786
  ( always {!<=-1,!>=2}
Line 813
  , always 0
  inconclusive always {!<=-1,!>=2}
  = always 0
  false always 0
Line 814
  , always 0
  inconclusive always {!<=-1,!>=2}
  = always 0
  false always 0
Line 816
  ( always {!<=-1,!>=2}
Line 850
  ( always {!<=-1,!>=2}
Line 855
  ( always {!<=-1,!>=2}
Line 856
  return always {!<=-1,!>=2}
  mCodeWithTemplates always {!<=-1,!>=2}
Line 904
  ( always {!<=-1,!>=2}
Line 911
  ( always {!<=-1,!>=2}
Line 918
  ( always {!<=-1,!>=2}
Line 932
  ( always {!<=-1,!>=2}
Line 933
  return always {!<=-1,!>=2}
  false always 0
Line 950
  , always {!<=-1,!>=2}
  inOperator always {!<=-1,!>=2}
Line 986
  used always {!<=-1,!>=2}
Line 1000
  mCodeWithTemplates always {!<=-1,!>=2}
Line 40
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "requires" always "requires"
Line 43
  ( always {!<=-1,!>=2}
  tok possible {symbolic=(after?after->next():nullptr),0}
  "%oror%|&&|requires %name%|(" always "%oror%|&&|requires %name%|("
Line 45
  after always symbolic=(tok->next())
  == always {!<=-1,!>=2}
  "(" always "("
Line 46
  after always symbolic=(tok->next())
Line 49
  ( always {!<=-1,!>=2}
  after always symbolic=(tok->next())
  "requires (" always "requires ("
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  after always symbolic=(tok->next())
  1 always 1
  ") {" always ") {"
Line 50
  after always symbolic=(tok->next())
  1 always 1
  1 always 1
Line 53
  ( always {!<=-1,!>=2}
  "%name% :: %name%" always "%name% :: %name%"
Line 54
  2 always 2
Line 55
  ( always {!<=-1,!>=2}
  "%name% <" always "%name% <"
Line 57
  = possible 0
  ? possible 0
  after always !0
  : always 0
  nullptr always 0
Line 68
  ( always {!<=-1,!>=2}
Line 69
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
Line 78
  ( always {!<=-1,!>=2}
Line 79
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
Line 88
  ( always {!<=-1,!>=2}
Line 89
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
Line 97
  mToken possible 0
  mToken possible 0
  ? possible ""
  : always ""
  "" always ""
Line 98
  ( always {!<=-1,!>=2}
  " :: " always " :: "
Line 99
  nullptr always 0
  nullptr always 0
  mFlags always !<=-1
  0 always 0
Line 102
  mToken always !0
  1 always 1
  == always {!<=-1,!>=2}
  "<" always "<"
Line 103
  mToken always !0
Line 104
  end always symbolic=(mToken->next()->findClosingBracket())
  && always {!<=-1,!>=2}
  end {symbolic=(mToken->next()->findClosingBracket()),!0}
  1 always 1
  == always {!<=-1,!>=2}
  "(" always "("
Line 105
  true always 1
Line 108
  this always !0
Line 113
  mToken possible 0
Line 114
  ( always {!<=-1,!>=2}
  " :: " always " :: "
Line 115
  mNameToken possible 0
  mParamEnd possible 0
  mFlags always !<=-1
  0 always 0
Line 118
  && always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 119
  ( always {!<=-1,!>=2}
  mToken always !0
  "template < >" always "template < >"
Line 121
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 122
  ( always {!<=-1,!>=2}
  "> template <" always "> template <"
Line 123
  -2 always -2
Line 124
  ( always {!<=-1,!>=2}
  ">|%name% ::" always ">|%name% ::"
Line 125
  == always {!<=-1,!>=2}
  ">" always ">"
Line 128
  -2 always -2
Line 130
  1 always 1
  == always {!<=-1,!>=2}
  "<" always "<"
Line 132
  1 always 1
  == always {!<=-1,!>=2}
  "<" always "<"
Line 135
  1 always 1
  == always {!<=-1,!>=2}
  "using" always "using"
Line 137
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 138
  "partial specialization of alias templates is not permitted" always "partial specialization of alias templates is not permitted"
  :: always 1
  SYNTAX always 1
Line 140
  ( {!<=-1,!>=2,0}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 141
  "explicit specialization of alias templates is not permitted" always "explicit specialization of alias templates is not permitted"
  :: always 1
  SYNTAX always 1
Line 144
  1 always 1
  == always {!<=-1,!>=2}
  "friend" always "friend"
Line 146
  ( always {!<=-1,!>=2}
Line 147
  next always symbolic=(mParamEnd->next())
Line 149
  ( always {!<=-1,!>=2}
  next possible symbolic=(mParamEnd->next())
  "class|struct|union %name% <|{|:|;|::" always "class|struct|union %name% <|{|:|;|::"
Line 150
  1 always 1
  == always {!<=-1,!>=2}
  "<" always "<"
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 152
  end {symbolic=(mToken->next()->findClosingBracket()),0}
  && always {!<=-1,!>=2}
  2 always 2
  "%name% ..." always "%name% ..."
  end always !0
Line 155
  tok1 always symbolic=(mNameToken->next())
  == always {!<=-1,!>=2}
  "<" always "<"
Line 156
  tok1 always symbolic=(mNameToken->next())
Line 157
  closing {symbolic=(tok1->findClosingBracket()),0}
Line 158
  closing {symbolic=(tok1->findClosingBracket()),!0}
Line 160
  "unsupported syntax" always "unsupported syntax"
  :: always 1
  SYNTAX always 1
Line 162
  tok1 possible symbolic=(mNameToken->next())
  == always {!<=-1,!>=2}
  "(" always "("
Line 163
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "=|;" always "=|;"
Line 164
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 165
  ( always {!<=-1,!>=2}
Line 166
  == always {!<=-1,!>=2}
  ";" always ";"
Line 167
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 168
  ( always {!<=-1,!>=2}
Line 170
  tok1 possible 0
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  tok1 always !0
  ";|{" always ";|{"
Line 171
  tok1 always !0
  == always {!<=-1,!>=2}
  "<" always "<"
Line 172
  tok1 always !0
Line 173
  ( always {!<=-1,!>=2}
  tok1 always !0
  "(|[" always "(|["
  && always {!<=-1,!>=2}
  tok1 always !0
Line 174
  = always !0
  tok1 always !0
  ( always !0
Line 176
  tok1 always !0
Line 178
  tok1 possible 0
Line 179
  tok1 always !0
  == always {!<=-1,!>=2}
  ";" always ";"
Line 183
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 184
  -1 always -1
  == always {!<=-1,!>=2}
  "::" always "::"
  || always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  -2 always -2
  ":: ~" always ":: ~"
Line 186
  start always symbolic=(mNameToken)
  -1 always -1
  == always {!<=-1,!>=2}
  "~" always "~"
Line 187
  start always symbolic=(mNameToken)
Line 188
  = possible symbolic=(mNameToken)
  start possible symbolic=(mNameToken)
Line 190
  start possible {symbolic=(mNameToken),symbolic=(end),0}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  start {symbolic=(end),!0}
  -2 always -2
  "%name% ::" always "%name% ::"
  || always {!<=-1,!>=2}
Line 191
  ( always {!<=-1,!>=2}
  start {symbolic=(end),!0}
  -2 always -2
  "> ::" always "> ::"
  && always {!<=-1,!>=2}
Line 192
  start {symbolic=(end),!0}
  -2 always -2
  && always {!<=-1,!>=2}
Line 193
  ( always {!<=-1,!>=2}
  start {symbolic=(end),!0}
  -2 always -2
  "%name% <" always "%name% <"
Line 194
  start always !0
  -2 always -2
  == always {!<=-1,!>=2}
  ">" always ">"
Line 195
  start always !0
  -2 always -2
Line 197
  start always !0
  -2 always -2
Line 200
  start possible {symbolic=(end),0}
  && always {!<=-1,!>=2}
  start always !0
  != always {!<=-1,!>=2}
Line 201
  ! {!<=-1,!>=2,0}
  mScope possible size=0
  ( {!<=-1,!>=2,1}
Line 202
  mScope always !size=0
  " ::" always " ::"
Line 203
  start possible 0
  && always {!<=-1,!>=2}
  start always !0
  != always {!<=-1,!>=2}
Line 204
  start always !0
  == always {!<=-1,!>=2}
  "<" always "<"
Line 205
  start always !0
Line 207
  ! {!<=-1,!>=2,0}
  mScope possible size=0
  ( {!<=-1,!>=2,1}
Line 208
  mScope always !size=0
  " " always " "
Line 209
  start always !0
Line 214
  ( always {!<=-1,!>=2}
  mScope always !size=0
  " :: " always " :: "
Line 220
  ( always {!<=-1,!>=2}
  ? always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  : always 1
  true always 1
Line 221
  ( always {!<=-1,!>=2}
  ? always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  : always 1
  true always 1
Line 222
  ( always {!<=-1,!>=2}
  ? always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  : always 1
  true always 1
Line 225
  mToken always !0
  this always !0
Line 229
  mToken possible 0
Line 230
  mFlags always !<=-1
  . always !<=-1
  mFlags always !<=-1
Line 233
  mToken always !0
  this always !0
Line 238
  && always {!<=-1,!>=2}
  mToken always !0
Line 239
  mToken always !0
  ( always !0
  this always !0
Line 245
  mParamEnd always !0
  4 always 4
Line 246
  nullptr always 0
Line 252
  ( always !0
  ";" always ";"
Line 253
  nullptr always 0
Line 256
  ( always {!<=-1,!>=2}
Line 260
  tok1 possible symbolic=(tok)
  != always {!<=-1,!>=2}
  end always symbolic=(aliasEndToken())
Line 261
  == always {!<=-1,!>=2}
Line 262
  return always {!<=-1,!>=2}
  true always 1
Line 264
  return always {!<=-1,!>=2}
  false always 0
Line 269
  mChanged always {!<=-1,!>=2}
  false always 0
Line 280
  ( always {!<=-1,!>=2}
  "( {" always "( {"
Line 282
  ! always {!<=-1,!>=2}
Line 283
  nullptr always 0
Line 288
  start always !0
Line 292
  ( always {!<=-1,!>=2}
  "try {" always "try {"
Line 294
  ( always {!<=-1,!>=2}
  "} catch (" always "} catch ("
Line 295
  2 always 2
Line 296
  ( always {!<=-1,!>=2}
  ") {" always ") {"
Line 301
  ! always {!<=-1,!>=2}
  tok possible symbolic=(start->link())
Line 302
  nullptr always 0
Line 304
  tok always !0
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  tok always !0
  "[;{}]" always "[;{}]"
Line 308
  ( always {!<=-1,!>=2}
  ";|{" always ";|{"
Line 310
  ( always {!<=-1,!>=2}
  "typedef|typename" always "typedef|typename"
Line 312
  ( always {!<=-1,!>=2}
  tok possible 0
  "%type% ::" always "%type% ::"
Line 313
  2 always 2
Line 314
  ! always {!<=-1,!>=2}
Line 318
  ( always {!<=-1,!>=2}
  tok always !0
  "%type% <" always "%type% <"
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  tok always !0
  "template" always "template"
Line 323
  level always !<=-1
  level always !<=-1
  = always 0
  0 always 0
Line 324
  = always !0
  tok always !0
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  tok2 always !0
  ";" always ";"
  = possible 0
  ( possible 0
Line 325
  ( always {!<=-1,!>=2}
  "{" always "{"
  && always {!<=-1,!>=2}
Line 326
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  ">|%type%" always ">|%type%"
  || always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "} ;" always "} ;"
Line 328
  ( possible {size=1,size=2}
  == {!<=-1,!>=2,0}
  "(" always "("
Line 330
  ( possible {size=1,size=2}
  == {!<=-1,!>=2,0}
  "<" always "<"
Line 331
  inclevel {!<=-1,!>=2,0}
  inclevel always {!<=-1,!>=2}
  = always 0
  false always 0
Line 332
  ( always {!<=-1,!>=2}
  "operator <" always "operator <"
Line 334
  level always !<=-1
  == always {!<=-1,!>=2}
  0 always 0
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "%type%" always "%type%"
Line 336
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "*| %type%|%num% ;" always "*| %type%|%num% ;"
  || always {!<=-1,!>=2}
Line 337
  ( always {!<=-1,!>=2}
  "*| %type% . %type% ;" always "*| %type% . %type% ;"
Line 338
  inclevel always {!<=-1,!>=2}
  = always 1
  true always 1
Line 340
  && always {!<=-1,!>=2}
  ( always !0
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  2 always 2
  "(|{" always "(|{"
Line 341
  inclevel always {!<=-1,!>=2}
  = always 1
  true always 1
Line 342
  ( always {!<=-1,!>=2}
  "< typename" always "< typename"
Line 343
  inclevel always {!<=-1,!>=2}
  = always 1
  true always 1
Line 344
  ( always {!<=-1,!>=2}
  -2 always -2
  "<|, %type% <" always "<|, %type% <"
  && always {!<=-1,!>=2}
  ( possible lifetime[Iterator]=(usedtypes)
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(usedtypes),end=0}
Line 345
  inclevel always {!<=-1,!>=2}
  = always 1
  true always 1
Line 346
  ( always {!<=-1,!>=2}
  "< %type%" always "< %type%"
  && always {!<=-1,!>=2}
  ( possible lifetime[Iterator]=(usedtypes)
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(usedtypes),end=0}
Line 347
  inclevel always {!<=-1,!>=2}
  = always 1
  true always 1
Line 348
  ( always {!<=-1,!>=2}
  "< %type%" always "< %type%"
Line 352
  ( always {!<=-1,!>=2}
  tok3 possible symbolic=(tok2->next())
  "%type% ::" always "%type% ::"
Line 353
  2 always 2
Line 354
  ( always {!<=-1,!>=2}
  tok3 possible symbolic=(tok2->next())
  "%type% <" always "%type% <"
Line 355
  inclevel always {!<=-1,!>=2}
  = always 1
  true always 1
Line 356
  -1 always -1
  == always {!<=-1,!>=2}
  ">" always ">"
Line 357
  tok always !0
Line 359
  inclevel {!<=-1,!>=2,0,1}
Line 360
  ++ always !<=0
  level always !<=-1
Line 361
  ( always {!<=-1,!>=2}
  -2 always -2
  "<|, %type% <" always "<|, %type% <"
Line 364
  ( possible size=2
  == {!<=-1,!>=2,0}
  ">" always ">"
Line 365
  level always !<=-1
  > always {!<=-1,!>=2}
  0 always 0
Line 366
  -- {!<=-1,>=0}
  level {>=1,!<=0}
Line 367
  == always {!<=-1,!>=2}
  ">>" always ">>"
Line 368
  level always !<=-1
  > always {!<=-1,!>=2}
  0 always 0
Line 369
  -- {!<=-1,>=0}
  level {>=1,!<=0}
Line 370
  level always !<=-1
  > always {!<=-1,!>=2}
  0 always 0
Line 371
  -- {!<=-1,>=0}
  level {>=1,!<=0}
Line 374
  level always !<=-1
  > always {!<=-1,!>=2}
  0 always 0
Line 375
  tok always !0
Line 380
  ( always !<=-1
Line 382
  numberOfParameters always !<=-1
  numberOfParameters always !<=-1
  = always 1
  1 always 1
Line 384
  ! always {!<=-1,!>=2}
  tok possible symbolic=(instantiation.token()->next())@145
Line 385
  return always !<=-1
  0 always 0
Line 386
  tok {!0,symbolic=(instantiation.token()->next())@145}
  != always {!<=-1,!>=2}
  "<" always "<"
Line 387
  return always !<=-1
  0 always 0
Line 388
  ( always {!<=-1,!>=2}
  tok always !0
  "%var% <" always "%var% <"
Line 389
  return always !<=-1
  0 always 0
Line 391
  ! always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  tok always !0
  == always {!<=-1,!>=2}
  ">" always ">"
Line 392
  return always !<=-1
  0 always 0
Line 394
  level always !<=-1
  level always !<=-1
  = always 0
  0 always 0
Line 398
  level {!<=-1,0,1}
  == {!<=-1,!>=2,1,0}
  0 always 0
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  tok always !0
  "template <" always "template <"
Line 399
  tok always !0
Line 400
  closing always symbolic=(tok->next()->findClosingBracket())
Line 401
  closing {symbolic=(tok->next()->findClosingBracket()),!0}
  == always {!<=-1,!>=2}
  ">>" always ">>"
Line 402
  return always !<=-1
  numberOfParameters always !<=-1
Line 403
  closing {symbolic=(tok->next()->findClosingBracket()),!0}
Line 404
  ! always {!<=-1,!>=2}
  tok always symbolic=(closing->next())
Line 405
  tok always {0,symbolic=(closing->next())}
Line 406
  ( always {!<=-1,!>=2}
  tok {symbolic=(closing->next()),!0}
  ">|>>|>>=" always ">|>>|>>="
Line 407
  return always !<=-1
  numberOfParameters always !<=-1
Line 408
  tok {symbolic=(closing->next()),!0}
  == always {!<=-1,!>=2}
  "," always ","
Line 409
  ++ always !<=0
  numberOfParameters always !<=-1
Line 410
  tok {symbolic=(closing->next()),!0}
Line 414
  return always !<=-1
  0 always 0
Line 418
  ( always {!<=-1,!>=2}
  "const|volatile" always "const|volatile"
Line 422
  ( always {!<=-1,!>=2}
  "struct|union" always "struct|union"
Line 426
  ( always {!<=-1,!>=2}
  "& ::| %name%" always "& ::| %name%"
Line 430
  ( always {!<=-1,!>=2}
  "..." always "..."
Line 431
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  -2 always -2
  "<|,|::" always "<|,|::"
  || always {!<=-1,!>=2}
Line 432
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  -1 always -1
  != always {!<=-1,!>=2}
  ">" always ">"
Line 433
  return always !<=-1
  0 always 0
Line 435
  ! always {!<=-1,!>=2}
Line 436
  return always !<=-1
  0 always 0
Line 437
  tok always !0
  ( possible {size=2,size=3,size=1}
  == {!<=-1,!>=2,0}
  ">" always ">"
Line 438
  level always !<=-1
  == always {!<=-1,!>=2}
  0 always 0
Line 439
  return always !<=-1
  numberOfParameters always !<=-1
Line 440
  -- always !<=-1
  level always !<=0
Line 441
  tok always !0
  ( possible {size=3,size=1}
  == {!<=-1,!>=2,0}
  ">>" always ">>"
  || always {!<=-1,!>=2}
  tok always !0
  == always {!<=-1,!>=2}
  ">>=" always ">>="
Line 442
  level always !<=-1
  == always {!<=-1,!>=2}
  1 always 1
Line 443
  return always !<=-1
  numberOfParameters always !<=-1
Line 444
  level always {!<=-1,!1}
  -= always !<=-1
  2 always 2
Line 445
  tok always !0
  == always {!<=-1,!>=2}
  "," always ","
  && always {!<=-1,!>=2}
  level always !<=-1
  == always {!<=-1,!>=2}
  0 always 0
Line 446
  ++ always !<=0
  numberOfParameters always !<=-1
Line 447
  tok always !0
Line 453
  ( always {!<=-1,!>=2}
  "=|?|:" always "=|?|:"
Line 455
  ! always {!<=-1,!>=2}
Line 456
  return always !<=-1
  0 always 0
Line 459
  ( always {!<=-1,!>=2}
  tok always !0
  "(|{" always "(|{"
Line 460
  tok always !0
Line 462
  tok always !0
Line 463
  ! always {!<=-1,!>=2}
Line 464
  return always !<=-1
  0 always 0
Line 465
  tok always !0
  ( possible {size=2,size=3,size=1}
  == {!<=-1,!>=2,0}
  ">" always ">"
  && always {!<=-1,!>=2}
  level always !<=-1
  == always {!<=-1,!>=2}
  0 always 0
Line 466
  return always !<=-1
  numberOfParameters always !<=-1
Line 467
  tok always !0
  ( possible {size=3,size=1}
  == {!<=-1,!>=2,0}
  ">>" always ">>"
  || always {!<=-1,!>=2}
  tok always !0
  == always {!<=-1,!>=2}
  ">>=" always ">>="
  && always {!<=-1,!>=2}
  level always !<=-1
  == always {!<=-1,!>=2}
  1 always 1
Line 468
  return always !<=-1
  numberOfParameters always !<=-1
Line 469
  tok always !0
  == always {!<=-1,!>=2}
  "," always ","
Line 470
  level always !<=-1
  == always {!<=-1,!>=2}
  0 always 0
Line 471
  ++ always !<=0
  numberOfParameters always !<=-1
Line 472
  tok always !0
Line 478
  tok always !0
  == always {!<=-1,!>=2}
  "::" always "::"
Line 479
  tok always !0
Line 480
  ( always {!<=-1,!>=2}
  tok possible 0
  "%name% ::" always "%name% ::"
Line 481
  2 always 2
Line 482
  && always {!<=-1,!>=2}
  tok always !0
  == always {!<=-1,!>=2}
  "*" always "*"
Line 483
  tok always !0
Line 485
  ! always {!<=-1,!>=2}
Line 486
  return always !<=-1
  0 always 0
Line 489
  ! always {!<=-1,!>=2}
  tok always !0
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  tok always !0
  != always {!<=-1,!>=2}
  :: always 7
  eChar always 7
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  tok always !0
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  tok always !0
  ( always {!<=-1,!>=2}
Line 490
  return always !<=-1
  0 always 0
Line 491
  tok always !0
Line 492
  ! always {!<=-1,!>=2}
Line 493
  return always !<=-1
  0 always 0
Line 496
  ( always {!<=-1,!>=2}
  tok possible 0
  "*|&|&&|const" always "*|&|&&|const"
Line 499
  ! always {!<=-1,!>=2}
Line 500
  return always !<=-1
  0 always 0
Line 503
  ( always {!<=-1,!>=2}
  tok possible 0
  "(|[" always "(|["
Line 504
  ! always {!<=-1,!>=2}
Line 507
  ( always !0
Line 508
  ( always {!<=-1,!>=2}
  "const|volatile" always "const|volatile"
Line 511
  ! always {!<=-1,!>=2}
Line 512
  return always !<=-1
  0 always 0
Line 515
  tok always !0
  == always {!<=-1,!>=2}
  "<" always "<"
Line 516
  ++ always !<=0
  level always !<=-1
Line 517
  tok always !0
Line 520
  ! always {!<=-1,!>=2}
Line 521
  return always !<=-1
  0 always 0
Line 524
  ( always {!<=-1,!>=2}
  ">|>>|>>=" always ">|>>|>>="
Line 525
  level {!<=-1,1}
  == {!<=-1,!>=2,0}
  0 always 0
Line 526
  return always !<=-1
  == always {!<=-1,!>=2}
  ">" always ">"
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "%num%" always "%num%"
  ? always !<=-1
  numberOfParameters always !<=-1
  : always 0
  0 always 0
Line 527
  -- {!<=-1,0}
  level {1,!<=0}
Line 528
  ( possible size=3
  == {!<=-1,!>=2,0}
  ">>" always ">>"
  || always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  ">>=" always ">>="
Line 529
  level always !<=-1
  == always {!<=-1,!>=2}
  0 always 0
Line 530
  return always !<=-1
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "%num%" always "%num%"
  ? always !<=-1
  numberOfParameters always !<=-1
  : always 0
  0 always 0
Line 531
  -- always {!<=-1,!-2}
  level always {!<=0,!-1}
Line 535
  ( always {!<=-1,!>=2}
  "(|[" always "(|["
Line 538
  ! always {!<=-1,!>=2}
Line 539
  return always !<=-1
  0 always 0
Line 542
  != always {!<=-1,!>=2}
  "," always ","
Line 544
  level always !<=-1
  == always {!<=-1,!>=2}
  0 always 0
Line 545
  ++ always !<=0
  numberOfParameters always !<=-1
Line 548
  return always !<=-1
  0 always 0
Line 558
  ( always {!<=-1,!>=2}
  "template <" always "template <"
Line 561
  tok always !0
Line 564
  ! always {!<=-1,!>=2}
Line 565
  nullptr always 0
Line 567
  = always !0
  tok always !0
Line 568
  in_init always {!<=-1,!>=2}
  in_init always {!<=-1,!>=2}
  = always 0
  false always 0
Line 569
  tok2 possible {symbolic=(tok),0}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  tok2 {symbolic=(tok),!0}
  ";|{" always ";|{"
Line 570
  tok2 always !0
  ( possible size=1
  == always {!<=-1,!>=2}
  "<" always "<"
Line 571
  tok2 always !0
Line 572
  ( always {!<=-1,!>=2}
  tok2 always !0
  "(|[" always "(|["
  && always {!<=-1,!>=2}
  tok2 always !0
Line 573
  = always !0
  tok2 always !0
  ( always !0
Line 574
  tok2 always !0
  == always {!<=-1,!>=2}
  ":" always ":"
Line 575
  in_init always {!<=-1,!>=2}
  = always 1
  true always 1
Line 576
  in_init always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  tok2 always !0
  "%name% (|{" always "%name% (|{"
Line 577
  tok2 always !0
  1 always 1
Line 578
  1 always 1
  == always {!<=-1,!>=2}
  "{" always "{"
Line 579
  in_init always {!<=-1,!>=2}
  = always 0
  false always 0
Line 582
  tok2 always !0
Line 584
  tok2 possible {symbolic=(tok),0}
  && always {!<=-1,!>=2}
  tok2 always !0
  == always {!<=-1,!>=2}
  "{" always "{"
Line 585
  tok2 always !0
Line 586
  tok {symbolic=(tok2->link()),0}
  && always {!<=-1,!>=2}
  tok {symbolic=(tok2->link()),!0}
  1 always 1
  == always {!<=-1,!>=2}
  ";" always ";"
Line 587
  tok {symbolic=(tok2->link()),!0}
Line 588
  tok2 possible 0
  && always {!<=-1,!>=2}
  tok2 always !0
  == always {!<=-1,!>=2}
  ";" always ";"
Line 589
  = always !0
  tok2 always !0
Line 591
  = always 0
  nullptr always 0
Line 593
  tok possible {symbolic=(tok2->link()),symbolic=(tok2),0}
Line 598
  ! always {!<=-1,!>=2}
  begin possible symbolic=(end)
  || always {!<=-1,!>=2}
  begin always !0
  == always {!<=-1,!>=2}
Line 601
  begin always {!symbolic=(end),!0}
  && always {!<=-1,!>=2}
  begin always {!symbolic=(end),!0}
  ( always !0
  != always {!<=-1,!>=2}
  end always !symbolic=(begin)
Line 602
  begin always {!symbolic=(end),!0}
Line 609
  ( always !0
Line 614
  ( always {!<=-1,!>=2}
Line 616
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "template <" always "template <"
Line 617
  return always {!<=-1,!>=2}
  false always 0
Line 620
  && always {!<=-1,!>=2}
  end always !0
Line 621
  end always !0
  ( always !0
Line 623
  return always {!<=-1,!>=2}
  true always 1
Line 626
  return always {!<=-1,!>=2}
  false always 0
Line 629
  ( always {!<=-1,!>=2}
Line 631
  codeWithTemplates always {!<=-1,!>=2}
  codeWithTemplates always {!<=-1,!>=2}
  = always 0
  false always 0
Line 632
  tok possible symbolic=(end)
Line 633
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "template <" always "template <"
Line 636
  -1 always -1
  == always {!<=-1,!>=2}
  "<" always "<"
  || always {!<=-1,!>=2}
  -1 always -1
  == always {!<=-1,!>=2}
  "," always ","
Line 639
  -1 always -1
  == always {!<=-1,!>=2}
  ">" always ">"
Line 643
  tok1 possible {symbolic=(tok),symbolic=(closing->next())}
  && always {!<=-1,!>=2}
  tok1 {symbolic=(tok),symbolic=(closing->next()),!0}
Line 644
  tok1 always !0
  ( always !0
Line 645
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  closing always symbolic=(tok1->next()->findClosingBracket())
  "> template <" always "> template <"
Line 647
  closing always symbolic=(tok1->next()->findClosingBracket())
Line 649
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  tok possible symbolic=(tok1)
  "%any% %any%" always "%any% %any%"
Line 651
  2 always 2
  == always {!<=-1,!>=2}
  "typename" always "typename"
  && always {!<=-1,!>=2}
Line 652
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  3 always 3
  "%name%|...|,|=|>" always "%name%|...|,|=|>"
Line 654
  codeWithTemplates always {!<=-1,!>=2}
  = always 1
  true always 1
Line 656
  = always symbolic=(tok1->next()->findClosingBracket())
  parmEnd always symbolic=(tok1->next()->findClosingBracket())
  tok2 possible symbolic=(tok1->next()->findClosingBracket())
Line 657
  tok2 possible symbolic=(tok1->next()->findClosingBracket())
  ( possible size=1
  == always {!<=-1,!>=2}
  "(" always "("
  && always {!<=-1,!>=2}
Line 658
  = always !0
  ( always !0
Line 659
  == always {!<=-1,!>=2}
  ")" always ")"
Line 662
  ( always {!<=-1,!>=2}
  "decltype (" always "decltype ("
Line 663
  1 always 1
Line 664
  ( always {!<=-1,!>=2}
  "{|=|;" always "{|=|;"
Line 665
  parmEnd always symbolic=(tok1->next()->findClosingBracket())
Line 666
  > always {!<=-1,!>=2}
  0 always 0
Line 667
  parmEnd always symbolic=(tok1->next()->findClosingBracket())
  namepos {>=1,!<=0}
  parmEnd always symbolic=(tok1->next()->findClosingBracket())
Line 668
  ( always {!<=-1,!>=2}
Line 677
  = always !0
  end always !0
Line 683
  return always {!<=-1,!>=2}
  codeWithTemplates {!<=-1,!>=2,0}
Line 688
  2 always 2
Line 693
  = possible lifetime[Iterator]=(mTemplateInstantiations)
  ( possible lifetime[Iterator]=(mTemplateInstantiations)
  ( {lifetime[Iterator]=(mTemplateInstantiations),start=0}
Line 694
  ( {lifetime[Iterator]=(mTemplateInstantiations),end=0}
Line 697
  it possible lifetime[Iterator]=(mTemplateInstantiations)
  == always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(mTemplateInstantiations),end=0}
Line 705
  1 always 1
  == always {!<=-1,!>=2}
  "(" always "("
Line 706
  2 always 2
Line 707
  1 always 1
  == always {!<=-1,!>=2}
  "<" always "<"
Line 709
  end always symbolic=(nameToken->next()->findClosingBracket())
Line 710
  end {symbolic=(nameToken->next()->findClosingBracket()),!0}
  2 always 2
Line 716
  == always {!<=-1,!>=2}
  ")" always ")"
Line 719
  args possible size=0@212
Line 722
  argToken always !0
Line 725
  ( always {!<=-1,!>=2}
Line 727
  params possible size=1@209
  ( {!<=-1,!>=2,0@209}
Line 728
  return always {!<=-1,!>=2}
  false always 0
Line 730
  params {!size=0,size=1@209}
Line 731
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "typename|class %name% ,|>" always "typename|class %name% ,|>"
Line 732
  return always {!<=-1,!>=2}
  false always 0
Line 735
  return always {!<=-1,!>=2}
  true always 1
Line 743
  ( always {!<=-1,!>=2}
Line 744
  functionNameMap possible lifetime[Object]=(mTemplateDeclarations)
  ( possible lifetime[Iterator]=(functionNameMap)
  ( possible lifetime[Object]=(mTemplateDeclarations)
  & {lifetime[Address]=(mTemplateDeclarations),!0}
Line 748
  ( always {!<=-1,!>=2}
Line 749
  functionNameMap possible {lifetime[Object]=(mTemplateDeclarations),lifetime[Object]=(mTemplateForwardDeclarations)}
  ( possible lifetime[Iterator]=(functionNameMap)
  ( possible lifetime[Object]=(mTemplateForwardDeclarations)
  & {lifetime[Address]=(mTemplateForwardDeclarations),!0}
Line 752
  = always 0
  nullptr always 0
Line 754
  tok possible {symbolic=(tok2),symbolic=(tok2),symbolic=(tok2),symbolic=(tok2)}
Line 757
  ( always {!<=-1,!>=2}
  "template <" always "template <"
Line 759
  ! always {!<=-1,!>=2}
Line 762
  isUsing always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  tok always !0
  1 always 1
  == always {!<=-1,!>=2}
  "using" always "using"
Line 763
  isUsing always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  tok always !0
  2 always 2
  "%name% <" always "%name% <"
Line 765
  tok always !0
  3 always 3
  ";" always ";"
Line 767
  = always !0
  tok2 always !0
Line 768
  tok always !0
  -1 always -1
  == always {!<=-1,!>=2}
  "<" always "<"
Line 772
  pos always !<=-1
  pos always !<=-1
  = always !<=-1
  tok always !0
Line 773
  pos always !<=-1
  > always {!<=-1,!>=2}
  0 always 0
Line 774
  tok always !0
  pos {>=1,!<=0}
Line 780
  tok always !0
Line 782
  = always !0
  tok2 always !0
Line 784
  ( always {!<=-1,!>=2}
  "template using %name% <" always "template using %name% <"
Line 786
  3 always 3
  ";" always ";"
Line 788
  = always !0
  tok2 always !0
Line 789
  ( always {!<=-1,!>=2}
  "using %name% <" always "using %name% <"
Line 791
  2 always 2
  ";" always ";"
Line 793
  = always !0
  tok2 always !0
Line 794
  ( always {!<=-1,!>=2}
  "(|{|}|;|=|>|<<|:|.|*|&|return|<|,|!|[ %name% ::|<|(" always "(|{|}|;|=|>|<<|:|.|*|&|return|<|,|!|[ %name% ::|<|("
  || always {!<=-1,!>=2}
Line 795
  ( always {!<=-1,!>=2}
  "%type% %name% ::|<" always "%type% %name% ::|<"
  || always {!<=-1,!>=2}
Line 796
  ( always {!<=-1,!>=2}
  -2 always -2
  "[,:] private|protected|public %name% ::|<" always "[,:] private|protected|public %name% ::|<"
Line 800
  ( always {!<=-1,!>=2}
  tok possible {symbolic=(qualificationTok),symbolic=(skip)}
  "%name% :: %name%" always "%name% :: %name%"
Line 801
  ( always {!<=-1,!>=2}
  "" always ""
  : always " :: "
  " :: " always " :: "
Line 802
  2 always 2
Line 806
  tok possible symbolic=(qualificationTok)
  == always {!<=-1,!>=2}
Line 807
  = always 0
  nullptr always 0
Line 812
  1 always 1
  == always {!<=-1,!>=2}
  "(" always "("
Line 814
  instantiationArgs always size=0
Line 817
  ! {!<=-1,!>=2,0}
  qualification possible size=0
  ( {!<=-1,!>=2,1}
Line 818
  qualification always !size=0
  " :: " always " :: "
Line 819
  ! {!<=-1,!>=2,0}
  scopeName possible size=0
  ( {!<=-1,!>=2,1}
Line 820
  scopeName always !size=0
  " :: " always " :: "
Line 825
  = possible lifetime[Iterator]=(functionNameMap)
  ( possible lifetime[Iterator]=(functionNameMap)
  ( possible symbolic=(fullName)
Line 826
  pos possible lifetime[Iterator]=(functionNameMap)
  != always {!<=-1,!>=2}
  ( possible lifetime[Iterator]=(functionNameMap)
  pos possible lifetime[Iterator]=(functionNameMap)
Line 828
  pos {lifetime[Iterator]=(functionNameMap),!symbolic=(functionNameMap.upper_bound(tok->str()))}
  == always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
Line 829
  pos {lifetime[Iterator]=(functionNameMap),!symbolic=(functionNameMap.upper_bound(tok->str()))}
  == always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  pos {lifetime[Iterator]=(functionNameMap),!symbolic=(functionNameMap.upper_bound(tok->str()))}
Line 831
  pos {lifetime[Iterator]=(functionNameMap),!symbolic=(functionNameMap.upper_bound(tok->str()))}
  2 always 2
  templateParams always size=0
Line 834
  ( always !<=-1
  != always {!<=-1,!>=2}
  1 always 1
  || always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  templateParams always size=1
Line 838
  declarationParams always size=0
Line 841
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  instantiationArgs always !size=0
  ( always !<=0
  != always {!<=-1,!>=2}
  ( always !<=-1
Line 844
  match always !<=-1
  match always !<=-1
  = always 0
  0 always 0
Line 845
  argMatch always !<=-1
  argMatch always !<=-1
  = always 0
  0 always 0
Line 846
  i always !<=-1
  = always 0
  0 always 0
  i {symbolic=(argMatch+1),!<=-1,0}
  < always {!<=-1,!>=2}
  ( {!<=-1,symbolic=(match),symbolic=(instantiationArgs.size())}
  ++ {symbolic=(argMatch+1),!<=0}
  i {symbolic=(argMatch),!<=-1}
Line 848
  isArgLiteral always {!<=-1,!>=2}
  isArgLiteral always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  instantiationArgs always !size=0
  i {!<=-1,<=symbolic=(declarationParams.size()-1),!>=symbolic=(declarationParams.size())}
  "%num%|%str%|%char%|%bool% ,|)" always "%num%|%str%|%char%|%bool% ,|)"
Line 849
  isArgLiteral always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  i always {!<=-1,!>=symbolic=(declarationParams.size())}
  "const| %type% &| %name%| ,|)" always "const| %type% &| %name%| ,|)"
Line 850
  match always !<=-1
  ++ always !<=-1
Line 853
  templateParams always size=1
  0 always 0
  == always {!<=-1,!>=2}
  i always !<=-1
Line 854
  argMatch always !<=-1
  = always !<=-1
  i always !<=-1
Line 861
  match always !<=-1
  == always {!<=-1,!>=2}
  ( always !<=-1
Line 862
  instantiationArgs always !size=0
  argMatch {!<=-1,0}
Line 863
  ">" always ">"
Line 864
  arg always symbolic=(instantiationArgs[argMatch])
Line 865
  :: always 8
  eBoolean always 8
Line 866
  "bool" always "bool"
Line 868
  :: always 7
  eChar always 7
Line 869
  ( always {!<=-1,!>=2}
Line 870
  "wchar_t" always "wchar_t"
Line 872
  "char" always "char"
Line 874
  :: always 6
  eString always 6
Line 875
  "*" always "*"
Line 876
  ( always {!<=-1,!>=2}
Line 877
  "wchar_t" always "wchar_t"
Line 879
  "char" always "char"
Line 880
  "const" always "const"
Line 882
  :: always 5
  eNumber always 5
Line 884
  ( always {!<=-1,!>=2}
Line 887
  suffix {symbolic=(arg->str().back()),70,108,76}
  == {!<=-1,!>=2,0}
  'f' always 102
  || always {!<=-1,!>=2}
  suffix {symbolic=(arg->str().back()),108,76,!102}
  == {!<=-1,!>=2,0}
  'F' always 70
Line 888
  "float" always "float"
Line 889
  suffix {symbolic=(arg->str().back()),76,!102,!70}
  == {!<=-1,!>=2,0}
  'l' always 108
  || always {!<=-1,!>=2}
  suffix {symbolic=(arg->str().back()),!102,!70,!108}
  == always {!<=-1,!>=2}
  'L' always 76
Line 890
  "double" always "double"
Line 891
  true always 1
Line 893
  "double" always "double"
Line 894
  ( always {!<=-1,!>=2}
Line 895
  3 always 3
Line 896
  ( always !<=-1
  "LL" always "LL"
  != always {!<=-1,!>=2}
Line 897
  "long" always "long"
Line 898
  true always 1
Line 899
  ( always !<=-1
  'L' always 76
  != always {!<=-1,!>=2}
Line 900
  "long" always "long"
Line 902
  "int" always "int"
Line 903
  ( always !<=-1
  'U' always 85
  != always {!<=-1,!>=2}
Line 904
  true always 1
Line 911
  "<" always "<"
Line 918
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  tok possible symbolic=(skip)
  "%name% <" always "%name% <"
  || always {!<=-1,!>=2}
Line 919
  ( always {!<=-1,!>=2}
  "const_cast|dynamic_cast|reinterpret_cast|static_cast" always "const_cast|dynamic_cast|reinterpret_cast|static_cast"
Line 922
  == always {!<=-1,!>=2}
Line 923
  = always 0
  nullptr always 0
Line 933
  tok2 possible symbolic=(tok->next()->findClosingBracket())
  && always {!<=-1,!>=2}
  tok2 {symbolic=(tok->next()->findClosingBracket()),!0}
  != always {!<=-1,!>=2}
Line 934
  ( always {!<=-1,!>=2}
  tok2 possible symbolic=(tok->next()->findClosingBracket())
  ",|< %name% <" always ",|< %name% <"
  && always {!<=-1,!>=2}
Line 935
  3 always 3
  == always {!<=-1,!>=2}
  ">" always ">"
  || always {!<=-1,!>=2}
  ( always !<=-1
  2 always 2
Line 937
  ( always {!<=-1,!>=2}
  "class|struct" always "class|struct"
Line 942
  ( always !<=-1
  || always {!<=-1,!>=2}
  2 always 2
  == always {!<=-1,!>=2}
  ">" always ">"
Line 943
  true always 1
Line 944
  ( always {!<=-1,!>=2}
  "" always ""
  : always " :: "
  " :: " always " :: "
Line 945
  ( always {!<=-1,!>=2}
  "" always ""
  : always " :: "
  " :: " always " :: "
Line 946
  :: possible {symbolic=(mTemplateDeclarations.end()),end=0}
  it possible {symbolic=(mTemplateDeclarations.end()),end=0}
  = possible lifetime[Iterator]=(mTemplateDeclarations)
  ( possible lifetime[Iterator]=(mTemplateDeclarations)
  ( {lifetime[Iterator]=(mTemplateDeclarations),start=0}
  ( {lifetime[Iterator]=(mTemplateDeclarations),end=0}
  fullName always symbolic=(scopeName+(scopeName.empty()?"":" :: ")+qualification+(qualification.empty()?"":" :: ")+tok->str())
Line 947
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(mTemplateDeclarations),end=0}
Line 949
  it always {!symbolic=(mTemplateDeclarations.end()),!end=0}
Line 953
  found always {!<=-1,!>=2}
  found always {!<=-1,!>=2}
  = always 0
  false always 0
Line 955
  ( always {!<=-1,!>=2}
  "" always ""
  : always " :: "
  " :: " always " :: "
Line 956
  ( always {!<=-1,!>=2}
  "" always ""
  : always " :: "
  " :: " always " :: "
Line 957
  fullNameSpace always symbolic=(scopeName+(scopeName.empty()?"":" :: ")+nameSpace+(qualification.empty()?"":" :: ")+qualification)
  " :: " always " :: "
Line 958
  :: possible {symbolic=(mTemplateDeclarations.end()),end=0}
  it1 possible {symbolic=(mTemplateDeclarations.end()),end=0}
  = possible lifetime[Iterator]=(mTemplateDeclarations)
  ( possible lifetime[Iterator]=(mTemplateDeclarations)
  ( {lifetime[Iterator]=(mTemplateDeclarations),start=0}
  ( {lifetime[Iterator]=(mTemplateDeclarations),end=0}
  newFullName always symbolic=(fullNameSpace+" :: "+tok->str())
Line 959
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(mTemplateDeclarations),end=0}
Line 961
  :: always !<=-1
  offset always !<=-1
  offset always !<=-1
  = always 0
  0 always 0
Line 962
  :: always !<=-1
  pos always !<=-1
  pos always !<=-1
  = always 0
  0 always 0
Line 963
  pos always !<=-1
  = always !<=-1
  offset {!<=-1,0}
  ' ' always 32
  != always {!<=-1,!>=2}
Line 964
  offset always !<=-1
  pos always !<=-1
  "" always ""
  true always 1
Line 965
  offset always !<=-1
  = always !<=0
  offset always !<=-1
  + always !<=-1
  pos always !<=-1
  + always !<=0
  1 always 1
Line 967
  offset {!<=-1,0}
  "" always ""
  true always 1
Line 968
  "::" always "::"
  "" always ""
  true always 1
Line 969
  it1 always {!symbolic=(mTemplateDeclarations.end()),!end=0}
Line 970
  found always {!<=-1,!>=2}
  = always 1
  true always 1
Line 974
  found {!<=-1,!>=2,1}
Line 977
  ( always {!<=-1,!>=2}
Line 978
  ! {!<=-1,!>=2,0}
  qualification possible size=0
  ( {!<=-1,!>=2,1}
Line 979
  qualification always !size=0
Line 984
  pos always !<=-1
  = always !<=-1
  scopeName always !size=0
  ( always !<=-1
  " :: " always " :: "
Line 985
  pos always !<=-1
  == always {!<=-1,!>=2}
  scopeName always !size=0
  0 always 0
  pos always !<=-1
Line 1006
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 1021
  templatepar always !<=-1
  templatepar always !<=-1
  = always 1
  1 always 1
Line 1024
  templateParmDepth always !<=-1
  templateParmDepth always !<=-1
  = always 0
  0 always 0
Line 1031
  ( always {!<=-1,!>=2}
  "template <" always "template <"
Line 1033
  end always symbolic=(tok->next()->findClosingBracket())
Line 1034
  = {symbolic=(tok->next()->findClosingBracket()),!0}
  end {symbolic=(tok->next()->findClosingBracket()),!0}
Line 1038
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "{|(|[" always "{|(|["
Line 1039
  = always !0
  ( always !0
Line 1043
  ( possible size=1
  == always {!<=-1,!>=2}
  "<" always "<"
  && always {!<=-1,!>=2}
Line 1044
  1 always 1
  == always {!<=-1,!>=2}
  ">" always ">"
  || always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 1045
  ( possible lifetime[Iterator]=(typeParameterNames)
  -1 always -1
  == always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(typeParameterNames),end=0}
Line 1046
  ++ always !<=0
  templateParmDepth always !<=-1
Line 1049
  ( possible size=1
  == always {!<=-1,!>=2}
  ">" always ">"
Line 1050
  templateParmDepth always !<=-1
  < always {!<=-1,!>=2}
  2 always 2
Line 1051
  ! {!<=-1,!>=2,0}
  eq possible size=0
  ( {!<=-1,!>=2,1}
Line 1052
  eq always !size=0
Line 1055
  -- {!<=0,>=1}
  templateParmDepth {!<=1,>=2}
Line 1059
  ( always {!<=-1,!>=2}
  "typename|class|%type% %name% ,|>" always "typename|class|%type% %name% ,|>"
Line 1060
  [ always !<=-1
  1 always 1
  = always !<=-1
  templatepar always !<=-1
  - always !<=-1
  1 always 1
Line 1063
  == always {!<=-1,!>=2}
  "," always ","
  && always {!<=-1,!>=2}
  1 always 1
  == always {!<=-1,!>=2}
  templateParmDepth always !<=-1
Line 1064
  ! {!<=-1,!>=2,0}
  eq possible size=0
  ( {!<=-1,!>=2,1}
Line 1065
  eq always !size=0
Line 1066
  ++ always !<=0
  templatepar always !<=-1
Line 1070
  ( always {!<=-1,!>=2}
  "= !!>" always "= !!>"
Line 1071
  templatepar always !<=-1
Line 1072
  nullptr always 0
Line 1075
  eq always NonMovedVariable
Line 1080
  eq possible {NonMovedVariable,size=0}
  ( {!<=-1,!>=2,1}
Line 1085
  != always {!<=-1,!>=2}
Line 1090
  index always !<=-1
  index always !<=-1
  = always 0
  0 always 0
Line 1092
  ! always {!<=-1,!>=2}
  end always symbolic=(instantiation.token()->next()->findClosingBracket())
Line 1094
  end {symbolic=(instantiation.token()->next()->findClosingBracket()),!0}
  != always {!<=-1,!>=2}
  2 always 2
Line 1095
  1 always 1
Line 1096
  2 always 2
  && always {!<=-1,!>=2}
  tok1 always !0
  != always {!<=-1,!>=2}
  end always !0
Line 1097
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "{|(|[" always "{|(|["
Line 1098
  = always !0
  ( always !0
Line 1100
  index always !<=-1
Line 1102
  tok1 possible symbolic=(endLink)
  && always {!<=-1,!>=2}
  tok1 always !0
  != always {!<=-1,!>=2}
  endLink always !0
Line 1103
  index always !<=-1
Line 1104
  ( possible size=1
  == always {!<=-1,!>=2}
  "<" always "<"
  && always {!<=-1,!>=2}
Line 1105
  1 always 1
  == always {!<=-1,!>=2}
  ">" always ">"
  || always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 1106
  ( possible lifetime[Iterator]=(typeParameterNames)
  -1 always -1
  == always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(typeParameterNames),end=0}
Line 1109
  index always !<=-1
Line 1111
  tok1 possible symbolic=(endLink)
  && always {!<=-1,!>=2}
  tok1 always !0
  != always {!<=-1,!>=2}
Line 1112
  index always !<=-1
Line 1113
  == always {!<=-1,!>=2}
  "," always ","
Line 1114
  ++ always !<=0
  index always !<=-1
Line 1115
  index always !<=-1
  + always !<=0
  1 always 1
Line 1117
  index always !<=-1
Line 1122
  usedpar always !<=-1
  usedpar always !<=-1
  = always !<=-1
  ( always !<=-1
  tok always symbolic=(instantiation.token()->next())
Line 1124
  = always symbolic=(tok->findClosingBracket())
  instantiationEnd always symbolic=(tok->findClosingBracket())
Line 1126
  tok always {symbolic=(instantiationEnd),symbolic=(tok->findClosingBracket())}
  && always {!<=-1,!>=2}
  tok {symbolic=(instantiationEnd),!0,symbolic=(tok->findClosingBracket())}
  == always {!<=-1,!>=2}
  ">" always ">"
Line 1127
  tok {symbolic=(instantiationEnd),!0,symbolic=(tok->findClosingBracket())}
Line 1128
  = {lifetime[Iterator]=(eq),start=0}
  ( {lifetime[Iterator]=(eq),start=0}
Line 1129
  i always !<=-1
  = always !<=-1
  templatepar always !<=-1
  - always !<=-1
  ( always !<=-1
  it possible {lifetime[Iterator]=(eq),symbolic=(eq.begin()),start=0}
  != {!<=-1,!>=2,0}
  ( {lifetime[Iterator]=(eq),symbolic=(it),end=0}
  && always {!<=-1,!>=2}
  i always !<=-1
  < always {!<=-1,!>=2}
  usedpar always !<=-1
  ++ always !<=0
  i always !<=-1
Line 1130
  it possible lifetime[Iterator]=(eq)
Line 1131
  = always 0
  0 always 0
Line 1132
  it possible {lifetime[Iterator]=(eq),start=0}
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(eq),end=0}
Line 1134
  ! always {!<=-1,!>=2}
  it {lifetime[Iterator]=(eq),!symbolic=(eq.end()),!end=0}
Line 1135
  . always {!<=-1,!>=2}
  debugwarnings always {!<=-1,!>=2}
Line 1136
  1 always 1
  it {lifetime[Iterator]=(eq),!symbolic=(eq.end()),!end=0}
Line 1137
  locationList always size=1
  & {lifetime[Address]=(mTokenizer->list),!0}
Line 1138
  :: always 7
  debug always 7
Line 1139
  "noparamend" always "noparamend"
Line 1140
  "TemplateSimplifier couldn't find end of template parameter." always "TemplateSimplifier couldn't find end of template parameter."
Line 1141
  :: always 0
  normal always 0
Line 1142
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  :: always 7
  debug always 7
Line 1143
  mErrorLogger always !0
Line 1148
  usedpar always !<=-1
  + always !<=-1
  && always {!<=-1,!>=2}
  usedpar always !<=-1
  <= always {!<=-1,!>=2}
  ( always !<=-1
  + always !<=-1
Line 1149
  "," always ","
Line 1153
  it always {!symbolic=(eq.end()),!end=0}
  && always {!<=-1,!>=2}
  from always !0
  != always {!<=-1,!>=2}
  it always {!symbolic=(eq.end()),!end=0}
Line 1154
  entry possible lifetime[Iterator]=(typeParameterNames)
  = possible lifetime[Iterator]=(typeParameterNames)
  ( possible lifetime[Iterator]=(typeParameterNames)
Line 1155
  entry {lifetime[Iterator]=(typeParameterNames),symbolic=(typeParameterNames.find(from->str()))}
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(typeParameterNames),end=0}
  && always {!<=-1,!>=2}
  entry {lifetime[Iterator]=(typeParameterNames),symbolic=(typeParameterNames.find(from->str())),!symbolic=(typeParameterNames.end()),!end=0}
  < always {!<=-1,!>=2}
  ( always !<=-1
Line 1156
  entry {lifetime[Iterator]=(typeParameterNames),symbolic=(typeParameterNames.find(from->str())),!symbolic=(typeParameterNames.end()),!end=0}
  . {<=symbolic=(instantiationArgs.size()-1),!>=symbolic=(instantiationArgs.size())}
Line 1160
  ( always {!<=-1,!>=2}
  "(|[|{" always "(|[|{"
Line 1162
  ! {!<=-1,!>=2,0}
  links possible size=0
  ( {!<=-1,!>=2,1}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  ")|]|}" always ")|]|}"
Line 1163
  links always !size=0
Line 1164
  links always !size=0
Line 1171
  ( always {!<=-1,!>=2}
  "(|[|{" always "(|[|{"
Line 1173
  ! {!<=-1,!>=2,0}
  links possible size=0
  ( {!<=-1,!>=2,1}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  ")|]|}" always ")|]|}"
Line 1174
  links always !size=0
Line 1175
  links always !size=0
Line 1179
  ++ always !symbolic=(eq.end()+1)
  it always {!symbolic=(eq.end()),!end=0}
Line 1181
  usedpar always !<=-1
  ++ always !<=-1
Line 1185
  instantiationEnd possible symbolic=(tok)
Line 1191
  = always 0
  0 always 0
Line 1192
  eqtok always symbolic=(entry.eq)
Line 1193
  ( always {!<=-1,!>=2}
  ";|)|}|]" always ";|)|}|]"
Line 1194
  = always 0
  nullptr always 0
Line 1197
  ( always {!<=-1,!>=2}
  "(|{|[" always "(|{|["
Line 1199
  ( always {!<=-1,!>=2}
  "%type% <" always "%type% <"
  && always {!<=-1,!>=2}
  2 always 2
  == always {!<=-1,!>=2}
  ">" always ">"
  || always {!<=-1,!>=2}
  ( always !<=-1
Line 1200
  = possible lifetime[Iterator]=(mTemplateInstantiations)
  ( possible lifetime[Iterator]=(mTemplateInstantiations)
  ( {lifetime[Iterator]=(mTemplateInstantiations),start=0}
Line 1201
  ( {lifetime[Iterator]=(mTemplateInstantiations),end=0}
Line 1203
  ti possible lifetime[Iterator]=(mTemplateInstantiations)
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(mTemplateInstantiations),end=0}
Line 1204
  ti {lifetime[Iterator]=(mTemplateInstantiations),!end=0}
Line 1206
  indentlevel possible 0
  > {!<=-1,!>=2,0}
  0 always 0
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  ">" always ">"
Line 1207
  -- {>=0,!<=-1}
  indentlevel {>=1,!<=0}
Line 1208
  indentlevel possible <=0
  == {!<=-1,!>=2,<=1}
  0 always 0
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  ",|>" always ",|>"
Line 1210
  < always {!<=-1,!>=2}
  0 always 0
Line 1215
  ! {!<=-1,!>=2,1}
  tok2 possible 0
Line 1219
  = possible lifetime[Iterator]=(mTemplateInstantiations)
  ( possible lifetime[Iterator]=(mTemplateInstantiations)
  ( {lifetime[Iterator]=(mTemplateInstantiations),start=0}
Line 1220
  ( {lifetime[Iterator]=(mTemplateInstantiations),end=0}
Line 1223
  ti2 possible lifetime[Iterator]=(mTemplateInstantiations)
  == always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(mTemplateInstantiations),end=0}
Line 1226
  tok2 always !0
Line 1236
  = {lifetime[Iterator]=(mTemplateDeclarations),start=0}
  ( {lifetime[Iterator]=(mTemplateDeclarations),start=0}
  it1 possible {lifetime[Iterator]=(mTemplateDeclarations),start=0}
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(mTemplateDeclarations),end=0}
Line 1237
  it1 possible lifetime[Iterator]=(mTemplateDeclarations)
Line 1239
  ! always {!<=-1,!>=2}
  aliasDeclaration always symbolic=(*it1)
  ( always {!<=-1,!>=2}
Line 1240
  it1 possible lifetime[Iterator]=(mTemplateDeclarations)
Line 1246
  2 always 2
  aliasParameters always size=0
Line 1248
  argnr always !<=-1
  = always 0
  0 always 0
  argnr {symbolic=(aliasParameterNames[aliasParameters[argnr]->str()]+1),!<=-1,0}
  < always {!<=-1,!>=2}
  ( always !<=-1
  ++ {symbolic=(aliasParameterNames[aliasParameters[argnr]->str()]+1),!<=0}
  argnr {symbolic=(aliasParameterNames[aliasParameters[argnr]->str()]),!<=-1}
Line 1249
  [ always !<=-1
  [ possible lifetime[Lambda]=(mChanged)
  argnr always !<=-1
  = {!<=-1,<=symbolic=(aliasParameters.size()-1),!>=symbolic=(aliasParameters.size())}
  argnr {!<=-1,<=symbolic=(aliasParameters.size()-1),!>=symbolic=(aliasParameters.size())}
Line 1252
  found always {!<=-1,!>=2}
  found always {!<=-1,!>=2}
  = always 0
  false always 0
Line 1253
  = {lifetime[Iterator]=(mTemplateInstantiations),start=0}
  ( {lifetime[Iterator]=(mTemplateInstantiations),start=0}
  it2 possible {lifetime[Iterator]=(mTemplateInstantiations),start=0}
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(mTemplateInstantiations),end=0}
Line 1254
  it2 possible lifetime[Iterator]=(mTemplateInstantiations)
Line 1255
  ! always {!<=-1,!>=2}
  aliasUsage always symbolic=(*it2)
  || always {!<=-1,!>=2}
  aliasUsage always symbolic=(*it2)
  != always {!<=-1,!>=2}
Line 1256
  it2 possible lifetime[Iterator]=(mTemplateInstantiations)
Line 1261
  ( always {!<=-1,!>=2}
  aliasUsage always symbolic=(*it2)
  ( always !0
Line 1267
  ( always !0
  2 always 2
Line 1269
  = always !0
  tok2 always !0
Line 1270
  tok2 possible symbolic=(start)
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  tok2 {symbolic=(start),!0}
  "[,>;{}]" always "[,>;{}]"
Line 1271
  tok2 always !0
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  tok2 always !0
  "(|[" always "(|["
Line 1272
  = always !0
  tok2 always !0
  ( always !0
Line 1273
  tok2 always !0
  == always {!<=-1,!>=2}
  "<" always "<"
Line 1274
  tok2 always !0
Line 1275
  ! always {!<=-1,!>=2}
Line 1281
  start {symbolic=(tok2),!0}
  tok2 possible {symbolic=(start),0}
Line 1282
  tok2 inconclusive {symbolic=(start),0}
  && always {!<=-1,!>=2}
  tok2 always !0
  == always {!<=-1,!>=2}
  "," always ","
Line 1283
  tok2 always !0
Line 1288
  ! always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  tok2 always !0
  != always {!<=-1,!>=2}
  ">" always ">"
  || always {!<=-1,!>=2}
Line 1289
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always !<=-1
  != always {!<=-1,!>=2}
  ( always !<=-1
  || always {!<=-1,!>=2}
Line 1290
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always !<=-1
  < always {!<=-1,!>=2}
  ( always !<=-1
Line 1295
  mChanged always {!<=-1,!>=2}
  = always 1
  true always 1
Line 1299
  dst always symbolic=(aliasUsage.token()->next()->findClosingBracket())
  false always 0
Line 1302
  dst always symbolic=(aliasUsage.token()->next()->findClosingBracket())
  != always {!<=-1,!>=2}
  tok1 possible symbolic=(temp)
Line 1303
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 1305
  ( possible lifetime[Iterator]=(aliasParameterNames)
  ( possible size=8
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(aliasParameterNames),end=0}
Line 1306
  argnr always !<=-1
  = always !<=-1
  [ always !<=-1
Line 1307
  argnr {symbolic=(aliasParameterNames[tok1->str()]),!<=-1}
Line 1308
  argnr {symbolic=(aliasParameterNames[tok1->str()]),!<=-1}
Line 1309
  true always 1
Line 1310
  tempOK {!<=-1,!>=2,0}
  temp inconclusive symbolic=(tok1->next())
  && always {!<=-1,!>=2}
  temp always !0
  != always {!<=-1,!>=2}
Line 1312
  tempOK always {!<=-1,!>=2}
Line 1314
  == always {!<=-1,!>=2}
  "typename" always "typename"
Line 1319
  dst always symbolic=(aliasUsage.token()->next()->findClosingBracket())
  != always {!<=-1,!>=2}
Line 1320
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 1322
  ( possible lifetime[Iterator]=(aliasParameterNames)
  == always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(aliasParameterNames),end=0}
Line 1324
  ( always {!<=-1,!>=2}
  "%name% <" always "%name% <"
Line 1325
  :: possible {symbolic=(mTemplateInstantiations.end()),end=0}
  it possible {symbolic=(mTemplateInstantiations.end()),end=0}
  = possible lifetime[Iterator]=(mTemplateInstantiations)
  ( possible lifetime[Iterator]=(mTemplateInstantiations)
  ( {lifetime[Iterator]=(mTemplateInstantiations),start=0}
Line 1326
  ( {lifetime[Iterator]=(mTemplateInstantiations),end=0}
Line 1328
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(mTemplateInstantiations),end=0}
Line 1329
  it always {!symbolic=(mTemplateInstantiations.end()),!end=0}
Line 1336
  found always {!<=-1,!>=2}
  = always 1
  true always 1
Line 1342
  found {!<=-1,!>=2,0}
Line 1347
  ( always !0
  end always symbolic=(const_cast<Token*>(aliasDeclaration.aliasEndToken()))
  ( possible 0
  end always symbolic=(const_cast<Token*>(aliasDeclaration.aliasEndToken()))
  ( always !0
  : always {1,symbolic=(const_cast<Token*>(aliasDeclaration.aliasEndToken()))}
  end always symbolic=(const_cast<Token*>(aliasDeclaration.aliasEndToken()))
Line 1349
  end always symbolic=(const_cast<Token*>(aliasDeclaration.aliasEndToken()))
  ( possible 0
  end always symbolic=(const_cast<Token*>(aliasDeclaration.aliasEndToken()))
  ( always !0
  : always {1,symbolic=(const_cast<Token*>(aliasDeclaration.aliasEndToken()))}
  end always symbolic=(const_cast<Token*>(aliasDeclaration.aliasEndToken()))
Line 1360
  ( always {!<=-1,!>=2}
  , always !<=-1
  numberOfArguments always !<=-1
  , always {!<=-1,!>=2}
  variadic always {!<=-1,!>=2}
Line 1362
  1 always 1
  == always {!<=-1,!>=2}
  "<" always "<"
Line 1364
  auto always !<=-1
  n always !<=-1
  n always !<=-1
  = always !<=-1
  ( always !<=-1
Line 1365
  variadic always {!<=-1,!>=2}
  ? always {!<=-1,!>=2}
  n always !<=-1
  + always !<=0
  1 always 1
  < always {!<=-1,!>=2}
  numberOfArguments always !<=-1
  : always {!<=-1,!>=2}
  numberOfArguments always !<=-1
  != always {!<=-1,!>=2}
  n always !<=-1
Line 1366
  return always {!<=-1,!>=2}
  false always 0
Line 1368
  patternAfter possible {0@51,":: ~| %name% ("@87}
Line 1370
  ! always {!<=-1,!>=2}
  tok always symbolic=(instance->next()->findClosingBracket())
  || always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  tok {symbolic=(instance->next()->findClosingBracket()),!0}
  patternAfter always !0
Line 1371
  return always {!<=-1,!>=2}
  false always 0
Line 1375
  return always {!<=-1,!>=2}
  true always 1
Line 1379
  ( always {!<=-1,!>=2}
Line 1381
  = always 1
  1 always 1
Line 1382
  tok possible symbolic=(closing)
  && always {!<=-1,!>=2}
  tok always !0
Line 1383
  ( always {!<=-1,!>=2}
  tok always !0
  ( always !0
  ";|{" always ";|{"
Line 1384
  return always {!<=-1,!>=2}
  false always 0
Line 1386
  ( always {!<=-1,!>=2}
  tok always !0
  ( always !0
  "decltype (" always "decltype ("
Line 1387
  tok always !0
  2 always 2
Line 1388
  && always {!<=-1,!>=2}
  != {!<=-1,!>=2,0}
  end possible symbolic=(tok)
Line 1389
  = always !0
  tok always !symbolic=(end)
  ( always !0
Line 1392
  ( always {!<=-1,!>=2}
  tok always !0
  ( always !0
  "%type% <" always "%type% <"
Line 1393
  tok always !0
  2 always 2
Line 1394
  closing possible symbolic=(tok->next())
Line 1395
  closing {symbolic=(tok->next()),!0}
  1 always 1
  == always {!<=-1,!>=2}
  "(" always "("
  && always {!<=-1,!>=2}
  closing always !0
  ";|{|:" always ";|{|:"
  true always 1
Line 1396
  return always {!<=-1,!>=2}
  true always 1
Line 1397
  && always {!<=-1,!>=2}
  ( always !0
  != always {!<=-1,!>=2}
  closing always !0
Line 1398
  = always {!symbolic=(closing),!0}
  ( always {!symbolic=(closing),!0}
Line 1402
  ( always {!<=-1,!>=2}
  tok always !0
  ( always !0
  "%type% (" always "%type% ("
  && always {!<=-1,!>=2}
  tok always !0
  2 always 2
  ";|{|:" always ";|{|:"
  true always 1
Line 1403
  return always {!<=-1,!>=2}
  true always 1
Line 1405
  = possible {symbolic=(closing),0}
  tok possible symbolic=(end)
  ( possible {symbolic=(closing),0}
Line 1408
  return always {!<=-1,!>=2}
  false always 0
Line 1411
  ( always {!<=-1,!>=2}
Line 1413
  = always 1
  1 always 1
Line 1414
  tok possible symbolic=(closing)
  && always {!<=-1,!>=2}
  tok always !0
Line 1415
  ( always {!<=-1,!>=2}
  tok always !0
  ( always !0
  ";|{|(|using" always ";|{|(|using"
Line 1416
  return always {!<=-1,!>=2}
  false always 0
Line 1418
  ( always {!<=-1,!>=2}
  tok always !0
  ( always !0
  "decltype (" always "decltype ("
Line 1419
  tok always !0
  2 always 2
Line 1420
  && always {!<=-1,!>=2}
  != {!<=-1,!>=2,0}
  end possible symbolic=(tok)
Line 1421
  = always !0
  tok always !symbolic=(end)
  ( always !0
Line 1424
  ( always {!<=-1,!>=2}
  tok always !0
  ( always !0
  "%type% <" always "%type% <"
Line 1425
  tok always !0
  2 always 2
Line 1426
  closing possible symbolic=(tok->next())
Line 1427
  ( always {!<=-1,!>=2}
  closing {symbolic=(tok->next()),!0}
  "=|;" always "=|;"
Line 1428
  return always {!<=-1,!>=2}
  true always 1
Line 1429
  && always {!<=-1,!>=2}
  ( always !0
  != always {!<=-1,!>=2}
  closing always !0
Line 1430
  = always {!symbolic=(closing),!0}
  ( always {!symbolic=(closing),!0}
Line 1434
  ( always {!<=-1,!>=2}
  tok always !0
  ( always !0
  "%type% =|;" always "%type% =|;"
Line 1435
  return always {!<=-1,!>=2}
  true always 1
Line 1437
  = possible {symbolic=(closing),0}
  tok possible symbolic=(end)
  ( possible {symbolic=(closing),0}
Line 1440
  return always {!<=-1,!>=2}
  false always 0
Line 1443
  ( always {!<=-1,!>=2}
Line 1445
  ( always {!<=-1,!>=2}
  "> friend| class|struct|union %type% :|<|;|{|::" always "> friend| class|struct|union %type% :|<|;|{|::"
Line 1446
  1 always 1
  == always {!<=-1,!>=2}
  "friend" always "friend"
  3 always 3
  : always 2
  2 always 2
Line 1448
  ( always {!<=-1,!>=2}
  "%type% :: %type%" always "%type% :: %type%"
  || always {!<=-1,!>=2}
Line 1449
  ( always {!<=-1,!>=2}
  "%type% <" always "%type% <"
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "> :: %type%" always "> :: %type%"
Line 1450
  1 always 1
  == always {!<=-1,!>=2}
  "::" always "::"
Line 1451
  2 always 2
Line 1452
  2 always 2
Line 1455
  ! {!<=-1,!>=2,1}
  end {symbolic=(tok->next()->findClosingBracket()),0}
  || always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  end {symbolic=(tok->next()->findClosingBracket()),!0}
  2 always 2
Line 1457
  = always -1
  -1 always -1
Line 1458
  return always {!<=-1,!>=2}
  true always 1
Line 1460
  end {symbolic=(tok->next()->findClosingBracket()),!0}
  2 always 2
Line 1463
  1 always 1
Line 1464
  tok possible symbolic=(end)
  && always {!<=-1,!>=2}
  tok always !0
  != always {!<=-1,!>=2}
Line 1467
  return always {!<=-1,!>=2}
  true always 1
Line 1469
  return always {!<=-1,!>=2}
  false always 0
Line 1474
  tok possible symbolic=(tok1->next()->findClosingBracket())@12
  && always {!<=-1,!>=2}
  tok {!0,symbolic=(tok1->next()->findClosingBracket())@12}
  == always {!<=-1,!>=2}
  ">" always ">"
Line 1476
  = possible lifetime[Iterator]=(mTemplateNamePos)
  ( possible lifetime[Iterator]=(mTemplateNamePos)
  tok inconclusive symbolic=(tok1->next()->findClosingBracket())@12
Line 1477
  ! always {!<=-1,!>=2}
  . always {!<=-1,!>=2}
  debugtemplate always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  it {lifetime[Iterator]=(mTemplateNamePos),symbolic=(mTemplateNamePos.find(tok))}
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(mTemplateNamePos),end=0}
Line 1478
  it {lifetime[Iterator]=(mTemplateNamePos),symbolic=(mTemplateNamePos.find(tok)),!symbolic=(mTemplateNamePos.end()),!end=0}
Line 1481
  = always 0
  0 always 0
Line 1482
  ( always {!<=-1,!>=2}
  tok inconclusive symbolic=(tok1->next()->findClosingBracket())@12
  namepos always 0
Line 1484
  ( always {!<=-1,!>=2}
  "> using %name% =" always "> using %name% ="
Line 1486
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  4 always 4
  "class|struct|union|enum %name%| {" always "class|struct|union|enum %name%| {"
Line 1487
  = always 2
  2 always 2
Line 1488
  ( always {!<=-1,!>=2}
Line 1490
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 1491
  = always -1
  -1 always -1
Line 1492
  = possible {2,-1}
  namepos possible {2,-1}
Line 1493
  namepos possible {2,-1}
Line 1500
  = always 0
  0 always 0
Line 1501
  ( always {!<=-1,!>=2}
  tokStart possible symbolic=(tok)
  -2 always -2
  "%name% ::" always "%name% ::"
Line 1502
  -2 always -2
Line 1503
  2 always 2
Line 1506
  insert always {!<=-1,!>=2}
  = {!<=-1,!>=2,0}
  tokStart possible symbolic=(tok)
  != {!<=-1,!>=2,0}
  tok possible symbolic=(tokStart)
Line 1508
  :: always !<=-1
  start always !<=-1
  start always !<=-1
  = always 0
  0 always 0
Line 1509
  :: always !<=-1
  end always !<=-1
  end always !<=-1
  = always 0
  0 always 0
Line 1510
  inTemplate always {!<=-1,!>=2}
  inTemplate always {!<=-1,!>=2}
  = always 0
  false always 0
Line 1511
  = always 0
  0 always 0
Line 1512
  end always !<=-1
  = always !<=-1
  ( always !<=-1
  " " always " "
  start {symbolic=(end+1),!<=-1,0}
  != always {!<=-1,!>=2}
Line 1513
  start always !<=-1
  end always !<=-1
  - always !<=-1
  start always !<=-1
Line 1515
  token possible size=1
  == always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  -1 always -1
  != always {!<=-1,!>=2}
  "::" always "::"
Line 1517
  == always {!<=-1,!>=2}
  "<" always "<"
Line 1518
  inTemplate always {!<=-1,!>=2}
  = always 1
  true always 1
Line 1521
  inTemplate {!<=-1,!>=2,1}
Line 1522
  insert {symbolic=(tokStart!=tok),!<=-1,!>=2}
Line 1526
  == always {!<=-1,!>=2}
  ">" always ">"
Line 1527
  -- possible 0
  level possible 1
Line 1528
  == always {!<=-1,!>=2}
  0 always 0
Line 1529
  inTemplate always {!<=-1,!>=2}
  = always 0
  false always 0
Line 1532
  insert {symbolic=(tokStart!=tok),!<=-1,!>=2}
Line 1533
  "" always ""
Line 1537
  start always !<=-1
  = always !<=0
  end always !<=-1
  + always !<=0
  1 always 1
Line 1540
  start {!<=-1,0}
  end always !<=-1
  - always !<=-1
  start {!<=-1,0}
Line 1541
  != always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  -1 always -1
  != always {!<=-1,!>=2}
  "::" always "::"
Line 1542
  insert {symbolic=(tokStart!=tok),!<=-1,!>=2}
Line 1543
  ! always {!<=-1,!>=2}
  inTemplate always {!<=-1,!>=2}
Line 1544
  start always !<=-1
  "" always ""
Line 1546
  start always !<=-1
Line 1547
  "::" always "::"
  "" always ""
Line 1549
  ! always {!<=-1,!>=2}
  inTemplate always {!<=-1,!>=2}
Line 1550
  start always !<=-1
Line 1552
  start always !<=-1
Line 1553
  "::" always "::"
Line 1558
  ( always {!<=-1,!>=2}
Line 1563
  :: always !<=-1
  pos always !<=-1
  pos always !<=-1
  = always 0
  0 always 0
Line 1564
  = always -2
  -2 always -2
Line 1566
  pos always !<=-1
  = always !<=-1
  scope always symbolic=(templateDeclaration.scope())
  ( always !<=-1
  "::" always "::"
  pos {!<=-1,0}
  != always {!<=-1,!>=2}
Line 1567
  2 always 2
Line 1568
  pos always !<=-1
  += always !<=-1
  2 always 2
Line 1571
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  ( {lifetime[Object]=(templateDeclaration.scope()),lifetime[Object]=(templateDeclaration),!0}
  ( always !<=-1
Line 1578
  , always {!<=-1,!>=2}
Line 1579
  copy always {!<=-1,!>=2}
Line 1581
  inTemplateDefinition always {!<=-1,!>=2}
  inTemplateDefinition always {!<=-1,!>=2}
  = always 0
  false always 0
Line 1582
  = always 0
  nullptr always 0
Line 1583
  = always 0
  nullptr always 0
Line 1586
  isClass always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 1587
  isFunction always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 1588
  isSpecialization always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 1589
  isVariable always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 1598
  copy {!<=-1,!>=2,0@57,1@57}
  && always {!<=-1,!>=2}
  isClass {symbolic=(templateDeclaration.isClass()),!<=-1,!>=2}
Line 1599
  1 always 1
  "" always ""
  true always 1
Line 1600
  "" always ""
  true always 1
Line 1601
  ";" always ";"
  "" always ""
  true always 1
Line 1602
  isFunction {symbolic=(templateDeclaration.isFunction()),!<=-1,!>=2}
  && always {!<=-1,!>=2}
  copy {!<=-1,!>=2,0@57}
  || always {!<=-1,!>=2}
  isSpecialization {symbolic=(templateDeclaration.isSpecialization()),!<=-1,!>=2}
  || always {!<=-1,!>=2}
Line 1603
  isVariable {symbolic=(templateDeclaration.isVariable()),!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  isSpecialization {symbolic=(templateDeclaration.isSpecialization()),!<=-1,!>=2}
  || always {!<=-1,!>=2}
Line 1604
  isClass {symbolic=(templateDeclaration.isClass()),!<=-1,!>=2}
  && always {!<=-1,!>=2}
  isSpecialization {symbolic=(templateDeclaration.isSpecialization()),!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( possible lifetime[Iterator]=(mTemplateSpecializationMap)
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(mTemplateSpecializationMap),end=0}
Line 1606
  dst always symbolic=(templateDeclaration.token())
Line 1607
  isStatic always {!<=-1,!>=2}
  isStatic always {!<=-1,!>=2}
  = always 0
  false always 0
Line 1611
  = possible lifetime[Iterator]=(mTemplateForwardDeclarationsMap)
  ( possible lifetime[Iterator]=(mTemplateForwardDeclarationsMap)
  dst always symbolic=(templateDeclaration.token())
Line 1612
  ! always {!<=-1,!>=2}
  isSpecialization {symbolic=(templateDeclaration.isSpecialization()),!<=-1,!>=2}
  && always {!<=-1,!>=2}
  it {lifetime[Iterator]=(mTemplateForwardDeclarationsMap),symbolic=(mTemplateForwardDeclarationsMap.find(dst))}
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(mTemplateForwardDeclarationsMap),end=0}
Line 1613
  it {lifetime[Iterator]=(mTemplateForwardDeclarationsMap),symbolic=(mTemplateForwardDeclarationsMap.find(dst))}
Line 1614
  dst always symbolic=(it->second)
Line 1615
  dst always symbolic=(it->second)
  1 always 1
Line 1618
  1 always 1
Line 1620
  it {lifetime[Iterator]=(mTemplateForwardDeclarationsMap),symbolic=(mTemplateForwardDeclarationsMap.find(dst))}
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(mTemplateForwardDeclarationsMap),end=0}
Line 1621
  = possible lifetime[Iterator]=(mTemplateForwardDeclarations)
  ( possible lifetime[Iterator]=(mTemplateForwardDeclarations)
  ( {lifetime[Iterator]=(mTemplateForwardDeclarations),start=0}
Line 1622
  ( {lifetime[Iterator]=(mTemplateForwardDeclarations),end=0}
Line 1623
  it {lifetime[Iterator]=(mTemplateForwardDeclarationsMap),symbolic=(mTemplateForwardDeclarationsMap.find(dst))}
Line 1624
  it1 possible lifetime[Iterator]=(mTemplateForwardDeclarations)
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(mTemplateForwardDeclarations),end=0}
Line 1625
  it1 possible lifetime[Iterator]=(mTemplateForwardDeclarations)
Line 1628
  = possible lifetime[Iterator]=(mTemplateSpecializationMap)
  ( possible lifetime[Iterator]=(mTemplateSpecializationMap)
Line 1629
  it2 {lifetime[Iterator]=(mTemplateSpecializationMap),symbolic=(mTemplateSpecializationMap.find(dst))}
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(mTemplateSpecializationMap),end=0}
Line 1630
  it2 {lifetime[Iterator]=(mTemplateSpecializationMap),symbolic=(mTemplateSpecializationMap.find(dst))}
Line 1631
  dst always symbolic=(it2->second)
Line 1632
  isStatic always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  dst always symbolic=(it2->second)
  1 always 1
  == always {!<=-1,!>=2}
  "static" always "static"
Line 1634
  ( always {!<=-1,!>=2}
  temp possible symbolic=(templateDeclarationNameToken)
  -2 always -2
  "%name% ::" always "%name% ::"
Line 1635
  ( possible lifetime[Iterator]=(scope)
  0 always 0
  -2 always -2
  " :: " always " :: "
Line 1636
  -2 always -2
Line 1641
  end always symbolic=(templateDeclarationNameToken->next())
  == always {!<=-1,!>=2}
  "<" always "<"
Line 1642
  end always symbolic=(templateDeclarationNameToken->next())
Line 1643
  end possible symbolic=(templateDeclarationNameToken->next())
  == always {!<=-1,!>=2}
  "(" always "("
Line 1645
  isVariable always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  "=" always "="
Line 1647
  temp possible symbolic=(end->next())
  && always {!<=-1,!>=2}
  temp possible symbolic=(end->next())
  != always {!<=-1,!>=2}
  ";" always ";"
Line 1648
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "{|[|(" always "{|[|("
Line 1652
  = possible symbolic=(end->next())
  temp possible symbolic=(end->next())
Line 1655
  typeindentlevel always !<=-1
  typeindentlevel always !<=-1
  = always 0
  0 always 0
Line 1656
  end possible symbolic=(temp)
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  typeindentlevel always !<=-1
  == always {!<=-1,!>=2}
  0 always 0
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  ";|{|:" always ";|{|:"
Line 1657
  ( always {!<=-1,!>=2}
  "<|(|{" always "<|(|{"
Line 1658
  ++ always !<=0
  typeindentlevel always !<=-1
Line 1659
  ( always {!<=-1,!>=2}
  ">|)|}" always ">|)|}"
Line 1660
  -- always !<=-1
  typeindentlevel always !<=-1
Line 1664
  isStatic always {!<=-1,!>=2}
Line 1665
  "static" always "static"
  "" always ""
  true always 1
Line 1673
  inAssignment always {!<=-1,!>=2}
  inAssignment always {!<=-1,!>=2}
  = always 0
  false always 0
Line 1674
  && always {!<=-1,!>=2}
  != always {!<=-1,!>=2}
Line 1675
  isVariable always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  "=" always "="
Line 1676
  inAssignment always {!<=-1,!>=2}
  = always 1
  true always 1
Line 1677
  itype always !<=-1
  itype always !<=-1
  = always 0
  0 always 0
Line 1678
  itype always !<=-1
  < always {!<=-1,!>=2}
  ( always !<=-1
  && always {!<=-1,!>=2}
  itype always !<=-1
  != always {!<=-1,!>=2}
Line 1679
  ++ always !<=0
  itype always !<=-1
Line 1681
  itype always !<=-1
  < always {!<=-1,!>=2}
  ( always !<=-1
  && always {!<=-1,!>=2}
  itype always !<=-1
  < always {!<=-1,!>=2}
  ( always !<=-1
  && always {!<=-1,!>=2}
Line 1682
  ! always {!<=-1,!>=2}
  isVariable always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  [ possible lifetime[Lambda]=(for(const Token*typetok=mTypesUsedInTemplateInstantiation[itype].token();typetok&&(typeindentlevel>0||endStr.find(typetok->str()[0])==std::string::npos);typetok=typetok->next()))
  itype always !<=-1
  "<|, %type% >|," always "<|, %type% >|,"
Line 1683
  typeindentlevel always !<=-1
  = always 0
  0 always 0
Line 1685
  pointerType always {!<=-1,!>=2}
  pointerType always {!<=-1,!>=2}
  = always 0
  false always 0
Line 1687
  isVariadicTemplateArg always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  itype always !<=-1
  + always !<=0
  1 always 1
  == always {!<=-1,!>=2}
  ( always !<=-1
Line 1688
  isVariadicTemplateArg {symbolic=(templateDeclaration.isVariadic()&&itype+1==typeParametersInDeclaration.size()),!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "%name% ... %name%" always "%name% ... %name%"
Line 1689
  2 always 2
Line 1690
  isVariadicTemplateArg always {!<=-1,!>=2}
  ? possible {">",",>"}
  ">" always ">"
  : always ",>"
  ",>" always ",>"
Line 1691
  itype always !<=-1
Line 1692
  && always {!<=-1,!>=2}
  typeindentlevel always !<=-1
  > always {!<=-1,!>=2}
  0 always 0
  || always {!<=-1,!>=2}
  ( always !<=-1
  0 always 0
  == always {!<=-1,!>=2}
Line 1694
  typeindentlevel always !<=-1
  == always {!<=-1,!>=2}
  0 always 0
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  "*" always "*"
Line 1695
  pointerType always {!<=-1,!>=2}
  = always 1
  true always 1
Line 1696
  ( always {!<=-1,!>=2}
  "..." always "..."
Line 1698
  ( always {!<=-1,!>=2}
  "%name% <" always "%name% <"
  && always {!<=-1,!>=2}
  2 always 2
  == always {!<=-1,!>=2}
  ">" always ">"
  || always {!<=-1,!>=2}
  ( always !<=-1
Line 1699
  ++ always !<=0
  typeindentlevel always !<=-1
Line 1700
  typeindentlevel always !<=-1
  > always {!<=-1,!>=2}
  0 always 0
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  ">" always ">"
Line 1701
  -- always !<=-1
  typeindentlevel always !<=-1
Line 1702
  == always {!<=-1,!>=2}
  "(" always "("
Line 1703
  ++ always !<=0
  typeindentlevel always !<=-1
Line 1704
  == always {!<=-1,!>=2}
  ")" always ")"
Line 1705
  -- always !<=-1
  typeindentlevel always !<=-1
Line 1706
  true always 1
Line 1710
  previous always symbolic=(dst->previous())
  true always 1
Line 1711
  previous always symbolic=(dst->previous())
  ( always {!<=-1,!>=2}
Line 1712
  previous always symbolic=(dst->previous())
  ( always {!<=-1,!>=2}
Line 1713
  previous always symbolic=(dst->previous())
  ( always {!<=-1,!>=2}
Line 1714
  ( always {!<=-1,!>=2}
  previous always symbolic=(dst->previous())
  "{|(|[" always "{|(|["
Line 1715
  previous always symbolic=(dst->previous())
Line 1716
  previous always symbolic=(dst->previous())
  == always {!<=-1,!>=2}
  "}" always "}"
Line 1717
  ( always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  false always 0
Line 1718
  == always {!<=-1,!>=2}
  "{" always "{"
Line 1719
  previous always symbolic=(dst->previous())
Line 1721
  previous always symbolic=(dst->previous())
  == always {!<=-1,!>=2}
  ")" always ")"
Line 1722
  ( always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  false always 0
Line 1723
  == always {!<=-1,!>=2}
  "(" always "("
Line 1724
  previous always symbolic=(dst->previous())
Line 1726
  previous always symbolic=(dst->previous())
  == always {!<=-1,!>=2}
  "]" always "]"
Line 1727
  ( always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  false always 0
Line 1728
  == always {!<=-1,!>=2}
  "[" always "["
Line 1729
  previous always symbolic=(dst->previous())
Line 1733
  pointerType always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "const" always "const"
Line 1734
  "const" always "const"
  true always 1
Line 1740
  isSpecialization always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  copy always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  ( {lifetime[Object]=(scope+templateDeclarationNameToken->str()),!0}
Line 1742
  1 always 1
  != always {!<=-1,!>=2}
Line 1744
  == always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 1745
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 1746
  -1 always -1
  == always {!<=-1,!>=2}
  "." always "."
  || always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  -2 always -2
  ". template" always ". template"
Line 1747
  1 always 1
  != always {!<=-1,!>=2}
  "<" always "<"
  || always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  ( {lifetime[Object]=(newName),!0}
  || always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  inAssignment always {!<=-1,!>=2}
Line 1748
  "" always ""
  true always 1
Line 1751
  1 always 1
  == always {!<=-1,!>=2}
  "<" always "<"
Line 1754
  "" always ""
  true always 1
Line 1761
  1 always 1
  == always {!<=-1,!>=2}
  "<" always "<"
Line 1764
  closing always symbolic=(start->next()->findClosingBracket())
Line 1767
  type possible symbolic=(start)
  && always {!<=-1,!>=2}
  type possible symbolic=(start)
  != always {!<=-1,!>=2}
  closing always symbolic=(start->next()->findClosingBracket())
Line 1768
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 1769
  " " always " "
Line 1775
  ( always {!<=-1,!>=2}
  ( {lifetime[Object]=(name),!0}
  ( always !<=-1
Line 1777
  "" always ""
  true always 1
Line 1786
  start possible symbolic=(closing)
  != {!<=-1,!>=2,0}
  closing possible {symbolic=(start->next()->findClosingBracket()),symbolic=(start)}
Line 1787
  true always 1
Line 1790
  ( always {!<=-1,!>=2}
Line 1791
  ( always {!<=-1,!>=2}
Line 1792
  ( always {!<=-1,!>=2}
Line 1795
  true always 1
Line 1798
  ( always {!<=-1,!>=2}
Line 1799
  ( always {!<=-1,!>=2}
Line 1800
  ( always {!<=-1,!>=2}
Line 1804
  ! always {!<=-1,!>=2}
Line 1808
  ( always {!<=-1,!>=2}
  "[|{|(" always "[|{|("
Line 1810
  ( always {!<=-1,!>=2}
  "]|}|)" always "]|}|)"
Line 1811
  = possible lifetime[Iterator]=(links)
  ( possible lifetime[Iterator]=(links)
Line 1813
  link {lifetime[Iterator]=(links),symbolic=(links.find(start))}
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(links),end=0}
Line 1814
  link {lifetime[Iterator]=(links),symbolic=(links.find(start))}
Line 1823
  ";" always ";"
  "" always ""
  true always 1
Line 1824
  -2 always -2
Line 1825
  -2 always -2
  1 always 1
Line 1827
  isVariable always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  isFunction always {!<=-1,!>=2}
Line 1831
  copy {!<=-1,!>=2,0@57,1@57}
  && always {!<=-1,!>=2}
  isClass always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  isFunction always {!<=-1,!>=2}
Line 1834
  start possible symbolic=(templateInstantiation.token())
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  start possible symbolic=(templateInstantiation.token())
  "}|;|extern" always "}|;|extern"
Line 1836
  ( always {!<=-1,!>=2}
  "template !!<" always "template !!<"
Line 1837
  -1 always -1
  == always {!<=-1,!>=2}
  "extern" always "extern"
Line 1839
  "" always ""
Line 1843
  = possible 0
  ? possible 0
  : always 0
  nullptr always 0
Line 1844
  inTemplateDefinition always {!<=-1,!>=2}
Line 1845
  ! always {!<=-1,!>=2}
Line 1846
  isVariable always {!<=-1,!>=2}
Line 1848
  temp always symbolic=(tok3->findClosingBracket())
Line 1849
  temp possible symbolic=(tok3->findClosingBracket())
  && always {!<=-1,!>=2}
  temp possible symbolic=(tok3->findClosingBracket())
  != always {!<=-1,!>=2}
  ";" always ";"
Line 1850
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "{|[|(" always "{|[|("
Line 1854
  = possible symbolic=(tok3->findClosingBracket())
  temp possible symbolic=(tok3->findClosingBracket())
Line 1856
  == always {!<=-1,!>=2}
  "{" always "{"
Line 1859
  == always {!<=-1,!>=2}
  endOfTemplateDefinition possible {symbolic=(temp),symbolic=(tok3->link())}
Line 1860
  inTemplateDefinition always {!<=-1,!>=2}
  = always 0
  false always 0
Line 1861
  = always 0
  nullptr always 0
Line 1865
  == always {!<=-1,!>=2}
  "template" always "template"
Line 1866
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  "<" always "<"
Line 1868
  2 always 2
Line 1869
  ( always !<=-1
  != always {!<=-1,!>=2}
  ( always !<=-1
Line 1870
  inTemplateDefinition always {!<=-1,!>=2}
  = always 0
  false always 0
Line 1872
  inTemplateDefinition always {!<=-1,!>=2}
  = always 1
  true always 1
Line 1874
  inTemplateDefinition always {!<=-1,!>=2}
  = always 0
  false always 0
Line 1878
  ( always {!<=-1,!>=2}
  tok3 possible symbolic=(startOfTemplateDeclaration)
  "(|[" always "(|["
Line 1882
  == always {!<=-1,!>=2}
Line 1884
  == always {!<=-1,!>=2}
  "static" always "static"
Line 1889
  inTemplateDefinition always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 1890
  ( always {!<=-1,!>=2}
  "%name% <" always "%name% <"
  && always {!<=-1,!>=2}
Line 1891
  == always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 1892
  ( always {!<=-1,!>=2}
  ( always !<=-1
  ( always {!<=-1,!>=2}
  ":: ~| %name% (" always ":: ~| %name% ("
Line 1894
  istemplate always {!<=-1,!>=2}
  istemplate always {!<=-1,!>=2}
  = always 0
  false always 0
Line 1895
  = always 0
  nullptr always 0
Line 1896
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "[;{}]" always "[;{}]"
Line 1897
  == always {!<=-1,!>=2}
  "template" always "template"
Line 1898
  istemplate always {!<=-1,!>=2}
  = always 1
  true always 1
Line 1903
  ! always {!<=-1,!>=2}
  istemplate always {!<=-1,!>=2}
Line 1907
  tok4 possible symbolic=(tok3->next()->findClosingBracket())
  && always {!<=-1,!>=2}
  tok4 possible symbolic=(tok3->next()->findClosingBracket())
  != always {!<=-1,!>=2}
  "(" always "("
Line 1909
  ! always {!<=-1,!>=2}
  tok4 possible symbolic=(tok3->next()->findClosingBracket())
  ":{" always ":{"
  true always 1
Line 1917
  && always {!<=-1,!>=2}
  != always {!<=-1,!>=2}
Line 1919
  ( always {!<=-1,!>=2}
  "%name% <" always "%name% <"
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
Line 1920
  copy always {!<=-1,!>=2}
Line 1921
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  -1 always -1
  != always {!<=-1,!>=2}
  "::" always "::"
Line 1929
  copy always {!<=-1,!>=2}
Line 1930
  added always {!<=-1,!>=2}
  added always {!<=-1,!>=2}
  = always 0
  false always 0
Line 1931
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "class|typename|struct" always "class|typename|struct"
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 1933
  itype always !<=-1
  itype always !<=-1
  = always 0
  0 always 0
Line 1934
  itype always !<=-1
  < always {!<=-1,!>=2}
  ( always !<=-1
  && always {!<=-1,!>=2}
  itype always !<=-1
  != always {!<=-1,!>=2}
Line 1935
  ++ always !<=0
  itype always !<=-1
Line 1938
  itype always !<=-1
  < always {!<=-1,!>=2}
  ( always !<=-1
  && always {!<=-1,!>=2}
  itype always !<=-1
  < always {!<=-1,!>=2}
  ( always !<=-1
Line 1940
  itype always !<=-1
Line 1941
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  ",|>" always ",|>"
Line 1943
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "..." always "..."
Line 1946
  ( always {!<=-1,!>=2}
  back always symbolic=(mTokenList.back())
  "{|(|[" always "{|(|["
Line 1947
  back always symbolic=(mTokenList.back())
Line 1948
  back always symbolic=(mTokenList.back())
  == always {!<=-1,!>=2}
  "}" always "}"
Line 1949
  ( always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  false always 0
Line 1950
  == always {!<=-1,!>=2}
  "{" always "{"
Line 1951
  back always symbolic=(mTokenList.back())
Line 1953
  back always symbolic=(mTokenList.back())
  == always {!<=-1,!>=2}
  ")" always ")"
Line 1954
  ( always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  false always 0
Line 1955
  == always {!<=-1,!>=2}
  "(" always "("
Line 1956
  back always symbolic=(mTokenList.back())
Line 1958
  back always symbolic=(mTokenList.back())
  == always {!<=-1,!>=2}
  "]" always "]"
Line 1959
  ( always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  false always 0
Line 1960
  == always {!<=-1,!>=2}
  "[" always "["
Line 1961
  back always symbolic=(mTokenList.back())
Line 1964
  back inconclusive symbolic=(mTokenList.back())
  true always 1
Line 1965
  back inconclusive symbolic=(mTokenList.back())
  ( always {!<=-1,!>=2}
Line 1966
  back inconclusive symbolic=(mTokenList.back())
  ( always {!<=-1,!>=2}
Line 1967
  back inconclusive symbolic=(mTokenList.back())
  ( always {!<=-1,!>=2}
Line 1968
  added always {!<=-1,!>=2}
  = always 1
  true always 1
Line 1974
  ! always {!<=-1,!>=2}
  added always {!<=-1,!>=2}
Line 1977
  ( always {!<=-1,!>=2}
  back always symbolic=(mTokenList.back())
  "{|(|[" always "{|(|["
Line 1978
  back always symbolic=(mTokenList.back())
Line 1979
  back always symbolic=(mTokenList.back())
  == always {!<=-1,!>=2}
  "}" always "}"
Line 1980
  ( always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  false always 0
Line 1981
  == always {!<=-1,!>=2}
  "{" always "{"
Line 1982
  back always symbolic=(mTokenList.back())
Line 1984
  back always symbolic=(mTokenList.back())
  == always {!<=-1,!>=2}
  ")" always ")"
Line 1985
  ( always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  false always 0
Line 1986
  == always {!<=-1,!>=2}
  "(" always "("
Line 1987
  back always symbolic=(mTokenList.back())
Line 1989
  back always symbolic=(mTokenList.back())
  == always {!<=-1,!>=2}
  "]" always "]"
Line 1990
  ( always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  false always 0
Line 1991
  == always {!<=-1,!>=2}
  "[" always "["
Line 1992
  back always symbolic=(mTokenList.back())
Line 2000
  copy always {!<=-1,!>=2}
Line 2001
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  -1 always -1
  != always {!<=-1,!>=2}
  "::" always "::"
Line 2006
  && always {!<=-1,!>=2}
  != always {!<=-1,!>=2}
  "::" always "::"
Line 2009
  = possible lifetime[Iterator]=(mTemplateDeclarations)
  ( possible lifetime[Iterator]=(mTemplateDeclarations)
  ( {lifetime[Iterator]=(mTemplateDeclarations),start=0}
Line 2010
  ( {lifetime[Iterator]=(mTemplateDeclarations),end=0}
Line 2012
  it possible lifetime[Iterator]=(mTemplateDeclarations)
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(mTemplateDeclarations),end=0}
Line 2013
  it possible lifetime[Iterator]=(mTemplateDeclarations)
Line 2023
  ( always !<=-1
  ' ' always 32
  != always {!<=-1,!>=2}
  ( always !<=-1
  ' ' always 32
  + always !<=0
  1 always 1
Line 2027
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "class|typename|struct" always "class|typename|struct"
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 2029
  itype always !<=-1
  itype always !<=-1
  = always 0
  0 always 0
Line 2030
  itype always !<=-1
  < always {!<=-1,!>=2}
  ( always !<=-1
  && always {!<=-1,!>=2}
  itype always !<=-1
  != always {!<=-1,!>=2}
Line 2031
  ++ always !<=0
  itype always !<=-1
Line 2034
  itype always !<=-1
  < always {!<=-1,!>=2}
  ( always !<=-1
  && always {!<=-1,!>=2}
  itype always !<=-1
  < always {!<=-1,!>=2}
  ( always !<=-1
Line 2035
  typeindentlevel always !<=-1
  typeindentlevel always !<=-1
  = always 0
  0 always 0
Line 2038
  pointerType always {!<=-1,!>=2}
  pointerType always {!<=-1,!>=2}
  = always 0
  false always 0
Line 2039
  isVariadicTemplateArg always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  itype always !<=-1
  + always !<=0
  1 always 1
  == always {!<=-1,!>=2}
  ( always !<=-1
Line 2040
  isVariadicTemplateArg {symbolic=(templateDeclaration.isVariadic()&&itype+1==typeParametersInDeclaration.size()),!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "%name% ... %name%" always "%name% ... %name%"
Line 2041
  2 always 2
Line 2042
  isVariadicTemplateArg always {!<=-1,!>=2}
  ? possible {">",",>"}
  ">" always ">"
  : always ",>"
  ",>" always ",>"
Line 2043
  itype always !<=-1
Line 2044
  && always {!<=-1,!>=2}
  typeindentlevel always !<=-1
  > always {!<=-1,!>=2}
  0 always 0
  || always {!<=-1,!>=2}
  ( always !<=-1
  0 always 0
  == always {!<=-1,!>=2}
Line 2046
  typeindentlevel always !<=-1
  == always {!<=-1,!>=2}
  0 always 0
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  "*" always "*"
Line 2047
  pointerType always {!<=-1,!>=2}
  = always 1
  true always 1
Line 2048
  ( always {!<=-1,!>=2}
  "..." always "..."
Line 2050
  ( always {!<=-1,!>=2}
  "%name% <" always "%name% <"
  && always {!<=-1,!>=2}
Line 2051
  2 always 2
  == always {!<=-1,!>=2}
  ">" always ">"
  || always {!<=-1,!>=2}
  ( always !<=-1
Line 2053
  ++ always !<=0
  typeindentlevel always !<=-1
Line 2054
  typeindentlevel always !<=-1
  > always {!<=-1,!>=2}
  0 always 0
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  ">" always ">"
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  "<" always "<"
Line 2055
  -- always !<=-1
  typeindentlevel always !<=-1
Line 2057
  ( always {!<=-1,!>=2}
  "const_cast|dynamic_cast|reinterpret_cast|static_cast <" always "const_cast|dynamic_cast|reinterpret_cast|static_cast <"
Line 2059
  ++ always !<=0
  typeindentlevel always !<=-1
Line 2060
  == always {!<=-1,!>=2}
  "(" always "("
Line 2061
  ++ always !<=0
  typeindentlevel always !<=-1
Line 2062
  == always {!<=-1,!>=2}
  ")" always ")"
Line 2063
  -- always !<=-1
  typeindentlevel always !<=-1
Line 2065
  copy always {!<=-1,!>=2}
Line 2070
  ( always {!<=-1,!>=2}
  back possible {symbolic=(mTokenList.back()),symbolic=(const_cast<Token*>(typetok))}
  "{|(|[" always "{|(|["
Line 2072
  == always {!<=-1,!>=2}
  "}" always "}"
Line 2073
  ( always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  false always 0
Line 2074
  == always {!<=-1,!>=2}
  "{" always "{"
Line 2075
  copy always {!<=-1,!>=2}
Line 2078
  == always {!<=-1,!>=2}
  ")" always ")"
Line 2079
  ( always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  false always 0
Line 2080
  == always {!<=-1,!>=2}
  "(" always "("
Line 2081
  copy always {!<=-1,!>=2}
Line 2084
  == always {!<=-1,!>=2}
  "]" always "]"
Line 2085
  ( always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  false always 0
Line 2086
  == always {!<=-1,!>=2}
  "[" always "["
Line 2087
  copy always {!<=-1,!>=2}
Line 2091
  copy always {!<=-1,!>=2}
Line 2092
  true always 1
Line 2094
  pointerType always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "const" always "const"
Line 2103
  == always {!<=-1,!>=2}
Line 2104
  ( always {!<=-1,!>=2}
  "<" always "<"
Line 2106
  closingBracket always symbolic=(tok3->next()->findClosingBracket())
Line 2108
  == always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
Line 2109
  ( always {!<=-1,!>=2}
  ( {lifetime[Object]=(newName),!0}
Line 2110
  copy always {!<=-1,!>=2}
Line 2112
  = always symbolic=(tok3->next()->findClosingBracket())
  closingBracket always symbolic=(tok3->next()->findClosingBracket())
Line 2118
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 2119
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 2120
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  closingBracket always symbolic=(tok3->next()->findClosingBracket())
  "(|::" always "(|::"
Line 2121
  copy always {!<=-1,!>=2}
Line 2127
  ( always {!<=-1,!>=2}
  -3 always -3
  "> friend class|struct|union" always "> friend class|struct|union"
Line 2128
  copy always {!<=-1,!>=2}
Line 2130
  copy always {!<=-1,!>=2}
Line 2132
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 2133
  isClass always {!<=-1,!>=2}
  ? {1,!<=-1,!>=2}
  1 always 1
  != always {!<=-1,!>=2}
  "(" always "("
  : always 1
  true always 1
Line 2137
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  ":|{|=|;|[|]" always ":|{|=|;|[|]"
Line 2144
  copy {!<=-1,!>=2,0@57,1@57}
Line 2148
  ( always {!<=-1,!>=2}
  "template <" always "template <"
Line 2152
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
Line 2155
  ( always {!<=-1,!>=2}
  "%type% <" always "%type% <"
  && always {!<=-1,!>=2}
Line 2156
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "template|static_cast|const_cast|reinterpret_cast|dynamic_cast" always "template|static_cast|const_cast|reinterpret_cast|dynamic_cast"
  && always {!<=-1,!>=2}
Line 2157
  ( always {!<=-1,!>=2}
  ">|>>" always ">|>>"
Line 2159
  ( always {!<=-1,!>=2}
  closingBracket always symbolic=(tok3->next()->findClosingBracket())
  "&" always "&"
Line 2160
  = always 0
  0 always 0
Line 2162
  < always {!<=-1,!>=2}
  ( always !<=-1
  && always {!<=-1,!>=2}
  par possible symbolic=(tok3->next())
  != always {!<=-1,!>=2}
  closingBracket always symbolic=(tok3->next()->findClosingBracket())
Line 2163
  "[<,] " always "[<,] "
  " [,>]" always " [,>]"
Line 2164
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  ( {lifetime[Object]=(pattern),!0}
Line 2167
  2 always 2
Line 2169
  < always {!<=-1,!>=2}
  ( always !<=-1
  || always {!<=-1,!>=2}
  != always {!<=-1,!>=2}
  closingBracket always symbolic=(tok3->next()->findClosingBracket())
Line 2175
  ( always {!<=-1,!>=2}
  prev possible symbolic=(tok3)
  -2 always -2
  "%name% ::" always "%name% ::"
  -2 always -2
Line 2176
  ( always {!<=-1,!>=2}
Line 2177
  -2 always -2
Line 2179
  -2 always -2
  " :: " always " :: "
Line 2183
  prev possible symbolic=(tok3)
  -1 always -1
  != always {!<=-1,!>=2}
  "::" always "::"
Line 2186
  :: always !<=-1
  end always !<=-1
  end always !<=-1
  = always !<=-1
  token_scope always symbolic=(tok3->scopeInfo()->name)
  ( always !<=-1
  " :: " always " :: "
Line 2187
  end always !<=-1
  != always {!<=-1,!>=2}
Line 2188
  token_scope always symbolic=(tok3->scopeInfo()->name)
  end always !<=-1
Line 2189
  ( always {!<=-1,!>=2}
Line 2192
  " :: " always " :: "
Line 2197
  ( always {!<=-1,!>=2}
Line 2198
  copy always {!<=-1,!>=2}
Line 2200
  ! always {!<=-1,!>=2}
  inTemplateDefinition always {!<=-1,!>=2}
Line 2206
  copy always {!<=-1,!>=2}
Line 2207
  == always {!<=-1,!>=2}
  "{" always "{"
Line 2209
  == always {!<=-1,!>=2}
  "(" always "("
Line 2211
  == always {!<=-1,!>=2}
  "[" always "["
Line 2213
  == always {!<=-1,!>=2}
  "}" always "}"
Line 2214
  ( always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  false always 0
Line 2215
  == always {!<=-1,!>=2}
  "{" always "{"
Line 2217
  1 always 1
  == always {!<=-1,!>=2}
  ";" always ";"
Line 2219
  tokSemicolon always symbolic=(tok3->next())
  tokSemicolon always symbolic=(tok3->next())
  tokSemicolon always symbolic=(tok3->next())
  tokSemicolon always symbolic=(tok3->next())
Line 2222
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "} >|,|{" always "} >|,|{"
Line 2223
  inTemplateDefinition always {!<=-1,!>=2}
  = always 0
  false always 0
Line 2226
  == always {!<=-1,!>=2}
  ")" always ")"
Line 2227
  ( always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  false always 0
Line 2228
  == always {!<=-1,!>=2}
  "(" always "("
Line 2231
  == always {!<=-1,!>=2}
  "]" always "]"
Line 2232
  ( always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  false always 0
Line 2233
  == always {!<=-1,!>=2}
  "[" always "["
Line 2240
  ( always {!<=-1,!>=2}
Line 2245
  2 always 2
Line 2247
  != always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
Line 2248
  2 always 2
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  2 always 2
  ( always {!<=-1,!>=2}
Line 2253
  ( always {!<=-1,!>=2}
Line 2255
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "}|;|(|[|]|)|,|?|:|%oror%|return|throw|case" always "}|;|(|[|]|)|,|?|:|%oror%|return|throw|case"
Line 2257
  ( always {!<=-1,!>=2}
Line 2259
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  "&&" always "&&"
Line 2261
  ( always {!<=-1,!>=2}
Line 2263
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  "|" always "|"
Line 2265
  ( always {!<=-1,!>=2}
Line 2267
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  "^" always "^"
Line 2269
  ( always {!<=-1,!>=2}
Line 2271
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  "&" always "&"
Line 2273
  ( always {!<=-1,!>=2}
Line 2275
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "%comp%|<<|>>" always "%comp%|<<|>>"
Line 2277
  ( always {!<=-1,!>=2}
Line 2279
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "+|-" always "+|-"
Line 2281
  ( always {!<=-1,!>=2}
Line 2283
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "[*/%]" always "[*/%]"
Line 2287
  ( always {!<=-1,!>=2}
  , always {!<=-1,!>=2}
  isTemplate always {!<=-1,!>=2}
Line 2289
  ret always {!<=-1,!>=2}
  ret always {!<=-1,!>=2}
  = always 0
  false always 0
Line 2291
  3 always 3
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  2 always 2
  ( always {!<=-1,!>=2}
Line 2293
  ! {!<=-1,!>=2,1}
  before {symbolic=(tok->previous()),0}
Line 2296
  3 always 3
Line 2299
  ( always {!<=-1,!>=2}
  before always !0
  "* %num% /" always "* %num% /"
  && always {!<=-1,!>=2}
  != always {!<=-1,!>=2}
  "0" always "0"
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
Line 2301
  ! always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  "*" always "*"
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  before always !0
  || always {!<=-1,!>=2}
  before always !0
  == always {!<=-1,!>=2}
  "*" always "*"
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
Line 2302
  ( always {!<=-1,!>=2}
  "[/%]" always "[/%]"
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  before always !0
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
Line 2303
  ( always {!<=-1,!>=2}
  "[+-]" always "[+-]"
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  before always !0
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
Line 2304
  ( always {!<=-1,!>=2}
  ">>|<<" always ">>|<<"
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  before always !0
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
Line 2305
  == always {!<=-1,!>=2}
  "&" always "&"
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  before always !0
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
Line 2306
  == always {!<=-1,!>=2}
  "^" always "^"
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  before always !0
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
Line 2307
  == always {!<=-1,!>=2}
  "|" always "|"
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  before always !0
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
Line 2308
  == always {!<=-1,!>=2}
  "&&" always "&&"
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  before always !0
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
Line 2309
  == always {!<=-1,!>=2}
  "||" always "||"
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  before always !0
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 2313
  ( always {!<=-1,!>=2}
  "[/%] 0" always "[/%] 0"
Line 2314
  isTemplate always {!<=-1,!>=2}
  "Instantiation error: Divide by zero in template instantiation." always "Instantiation error: Divide by zero in template instantiation."
  :: always 5
  INSTANTIATION always 5
Line 2315
  return always {!<=-1,!>=2}
  ret always {!<=-1,!>=2}
Line 2319
  ( always {!<=-1,!>=2}
  ">>|<<|&|^|%or%" always ">>|<<|&|^|%or%"
Line 2323
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 2329
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 2332
  0 always 0
Line 2333
  '<' always 60
Line 2336
  '>' always 62
Line 2339
  '&' always 38
Line 2342
  '|' always 124
Line 2345
  '^' always 94
Line 2352
  ( always {!<=-1,!>=2}
  "%oror%|&&" always "%oror%|&&"
Line 2353
  op1 always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 2354
  op2 always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 2355
  result always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  "||" always "||"
  ? always {!<=-1,!>=2}
  op1 {symbolic=(!MathLib::isNullValue(num1)),!<=-1,!>=2}
  || always {!<=-1,!>=2}
  op2 {symbolic=(!MathLib::isNullValue(num2)),!<=-1,!>=2}
  : always {!<=-1,!>=2}
  op1 {symbolic=(!MathLib::isNullValue(num1)),!<=-1,!>=2}
  && always {!<=-1,!>=2}
  op2 {symbolic=(!MathLib::isNullValue(num2)),!<=-1,!>=2}
Line 2356
  result {symbolic=((op->str()=="||")?(op1||op2):(op1&&op2)),!<=-1,!>=2}
  ? possible {"1","0"}
  "1" always "1"
  : always "0"
  "0" always "0"
Line 2359
  ( always {!<=-1,!>=2}
  "- %num% - %num%" always "- %num% - %num%"
Line 2361
  ( always {!<=-1,!>=2}
  "- %num% + %num%" always "- %num% + %num%"
Line 2365
  0 always 0
Line 2372
  2 always 2
Line 2374
  ret always {!<=-1,!>=2}
  = always 1
  true always 1
Line 2377
  return always {!<=-1,!>=2}
  ret {!<=-1,!>=2,0}
Line 2382
  colonLevel always !<=-1
  colonLevel always !<=-1
  = always 1
  1 always 1
Line 2383
  nullptr always 0
  != always {!<=-1,!>=2}
Line 2384
  tok always !0
  ( possible size=1
  == always {!<=-1,!>=2}
  "?" always "?"
Line 2385
  ++ always !<=0
  colonLevel always !<=-1
Line 2386
  tok always !0
  == always {!<=-1,!>=2}
  ":" always ":"
Line 2387
  -- {!<=-1,0}
  colonLevel {!<=-1,1}
Line 2388
  colonLevel always !<=-1
  == always {!<=-1,!>=2}
  0 always 0
Line 2389
  tok always !0
Line 2393
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  "(" always "("
Line 2394
  = always !0
  ( always !0
Line 2395
  ( always {!<=-1,!>=2}
  ( possible symbolic=(backToken)
  "[{};)]" always "[{};)]"
  || always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
Line 2398
  colonLevel always !<=-1
  > always {!<=-1,!>=2}
  0 always 0
Line 2399
  nullptr always 0
Line 2406
  && always {!<=-1,!>=2}
  start always !0
  start always !0
  ( always !0
  : always 1
Line 2407
  again always {!<=-1,!>=2}
  again always {!<=-1,!>=2}
  = always 1
  true always 1
Line 2409
  again {!<=-1,!>=2,1}
Line 2410
  again always {!<=-1,!>=2}
  = always 0
  false always 0
Line 2412
  first possible symbolic=((start&&start->previous())?start->previous():mTokenList.front())
  && always {!<=-1,!>=2}
  tok always !0
  != always {!<=-1,!>=2}
Line 2413
  tok possible symbolic=(start)
  == always {!<=-1,!>=2}
  "sizeof" always "sizeof"
Line 2415
  ( always {!<=-1,!>=2}
  "( %char% )" always "( %char% )"
Line 2420
  1 always 1
Line 2422
  again always {!<=-1,!>=2}
  = always 1
  true always 1
Line 2426
  ( always {!<=-1,!>=2}
  "( %str% )" always "( %str% )"
Line 2431
  1 always 1
Line 2433
  again always {!<=-1,!>=2}
  = always 1
  true always 1
Line 2436
  ( always {!<=-1,!>=2}
  "( %type% * )" always "( %type% * )"
Line 2437
  3 always 3
Line 2438
  4 always 4
Line 2439
  again always {!<=-1,!>=2}
  = always 1
  true always 1
Line 2440
  ( always {!<=-1,!>=2}
  "( * )" always "( * )"
Line 2441
  2 always 2
Line 2442
  3 always 3
Line 2443
  again always {!<=-1,!>=2}
  = always 1
  true always 1
Line 2444
  ( always {!<=-1,!>=2}
  "( %type% )" always "( %type% )"
Line 2445
  size always !<=-1
  = always !<=-1
  2 always 2
Line 2446
  size always !<=-1
  > always {!<=-1,!>=2}
  0 always 0
Line 2447
  size {>=1,!<=0}
Line 2448
  3 always 3
Line 2449
  again always {!<=-1,!>=2}
  = always 1
  true always 1
Line 2451
  1 always 1
  == always {!<=-1,!>=2}
  "(" always "("
Line 2452
  1 always 1
Line 2454
  ( always {!<=-1,!>=2}
  tok possible symbolic=(start)
  "%num% %comp% %num%" always "%num% %comp% %num%"
  && always {!<=-1,!>=2}
Line 2455
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 2456
  ( always {!<=-1,!>=2}
  2 always 2
Line 2457
  ( always {!<=-1,!>=2}
  tok possible symbolic=(start)
  "(|&&|%oror%|," always "(|&&|%oror%|,"
  || always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 2458
  ( always {!<=-1,!>=2}
  3 always 3
  ")|&&|%oror%|?" always ")|&&|%oror%|?"
  || always {!<=-1,!>=2}
  3 always 3
  == always {!<=-1,!>=2}
Line 2461
  2 always 2
Line 2465
  cmp possible {size=2,size=1}
  == {!<=-1,!>=2,0}
  "==" always "=="
Line 2466
  == always {!<=-1,!>=2}
  "true" always "true"
  : always "false"
  "false" always "false"
Line 2467
  cmp possible {size=2,size=1}
  == {!<=-1,!>=2,0}
  "!=" always "!="
Line 2468
  != always {!<=-1,!>=2}
  "true" always "true"
  : always "false"
  "false" always "false"
Line 2469
  cmp possible {size=2,size=1}
  == {!<=-1,!>=2,0}
  "<=" always "<="
Line 2470
  <= always {!<=-1,!>=2}
  "true" always "true"
  : always "false"
  "false" always "false"
Line 2471
  cmp possible size=1
  == {!<=-1,!>=2,0}
  ">=" always ">="
Line 2472
  >= always {!<=-1,!>=2}
  "true" always "true"
  : always "false"
  "false" always "false"
Line 2473
  == always {!<=-1,!>=2}
  "<" always "<"
Line 2474
  < always {!<=-1,!>=2}
  "true" always "true"
  : always "false"
  "false" always "false"
Line 2476
  > always {!<=-1,!>=2}
  "true" always "true"
  : always "false"
  "false" always "false"
Line 2479
  2 always 2
Line 2480
  again always {!<=-1,!>=2}
  = always 1
  true always 1
Line 2486
  ( always {!<=-1,!>=2}
  first possible symbolic=((start&&start->previous())?start->previous():mTokenList.front())
  end possible 0
Line 2487
  again always {!<=-1,!>=2}
  = always 1
  true always 1
Line 2489
  && always {!<=-1,!>=2}
  tok always !0
  != always {!<=-1,!>=2}
Line 2490
  == always {!<=-1,!>=2}
  "?" always "?"
  && always {!<=-1,!>=2}
Line 2491
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
Line 2492
  ( always {!<=-1,!>=2}
  -3 always -3
  "( %bool%|%num% )" always "( %bool%|%num% )"
Line 2493
  == always {!<=-1,!>=2}
  ")" always ")"
  2 always 2
  : always 1
  1 always 1
Line 2496
  end possible 0
Line 2497
  ! always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  colon always !0
  != always {!<=-1,!>=2}
  ":" always ":"
  || always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  colon always !0
Line 2501
  colon always !0
  == always {!<=-1,!>=2}
Line 2505
  -2 always -2
Line 2506
  == always {!<=-1,!>=2}
  2 always 2
Line 2508
  -2 always -2
Line 2514
  ( always {!<=-1,!>=2}
  "false|0" always "false|0"
Line 2516
  colon always !0
Line 2519
  again always {!<=-1,!>=2}
  = always 1
  true always 1
Line 2525
  2 always 2
Line 2527
  ternaryOplevel always !<=-1
  ternaryOplevel always !<=-1
  = always 0
  0 always 0
Line 2528
  = always !0
  colon always !0
Line 2529
  ( always {!<=-1,!>=2}
  "(|[|{" always "(|[|{"
Line 2531
  ( possible size=1
  == always {!<=-1,!>=2}
  "<" always "<"
  && always {!<=-1,!>=2}
  1 always 1
  == always {!<=-1,!>=2}
  ">" always ">"
  || always {!<=-1,!>=2}
  ( always !<=-1
Line 2533
  ( possible size=1
  == always {!<=-1,!>=2}
  "?" always "?"
Line 2534
  ++ always !<=0
  ternaryOplevel always !<=-1
Line 2535
  ( always {!<=-1,!>=2}
  ")|}|]|;|,|:|>" always ")|}|]|;|,|:|>"
Line 2536
  ( possible size=1
  == always {!<=-1,!>=2}
  ":" always ":"
  && always {!<=-1,!>=2}
  ternaryOplevel always !<=-1
Line 2537
  -- always !<=-1
  ternaryOplevel always !<=0
Line 2538
  == always {!<=-1,!>=2}
  ">" always ">"
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
Line 2541
  colon always !0
  -2 always -2
Line 2542
  again always {!<=-1,!>=2}
  = always 1
  true always 1
Line 2551
  && always {!<=-1,!>=2}
  tok always !0
  != always {!<=-1,!>=2}
Line 2552
  ( always {!<=-1,!>=2}
  "( %num%|%bool% )" always "( %num%|%bool% )"
  && always {!<=-1,!>=2}
Line 2553
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  ( always !0
  "%name%" always "%name%"
Line 2556
  again always {!<=-1,!>=2}
  = always 1
  true always 1
Line 2562
  ( always {!<=-1,!>=2}
  bounded always {!<=-1,!>=2}
Line 2564
  ! always {!<=-1,!>=2}
  bounded always {!<=-1,!>=2}
Line 2565
  return always {!<=-1,!>=2}
  true always 1
Line 2568
  frontToken always !0
Line 2570
  tok possible 0
  && always {!<=-1,!>=2}
  <= always {!<=-1,!>=2}
  0 always 0
Line 2571
  tok always !0
  == always {!<=-1,!>=2}
Line 2572
  return always {!<=-1,!>=2}
  false always 0
Line 2573
  ++ always !>=2
  offset always !>=1
Line 2574
  tok always {!symbolic=(frontToken),!0}
Line 2577
  return always {!<=-1,!>=2}
  tok possible 0
  && always {!<=-1,!>=2}
  > always {!<=-1,!>=2}
  0 always 0
Line 2580
  ( always {!<=-1,!>=2}
  bounded always {!<=-1,!>=2}
Line 2582
  ! always {!<=-1,!>=2}
  bounded always {!<=-1,!>=2}
Line 2583
  return always {!<=-1,!>=2}
  true always 1
Line 2585
  tok possible 0
  && always {!<=-1,!>=2}
  >= always {!<=-1,!>=2}
  0 always 0
Line 2586
  tok always !0
  == always {!<=-1,!>=2}
Line 2587
  return always {!<=-1,!>=2}
  false always 0
Line 2588
  -- always !<=-2
  offset always !<=-1
Line 2589
  tok always {!symbolic=(backToken),!0}
Line 2592
  return always {!<=-1,!>=2}
  tok possible 0
  && always {!<=-1,!>=2}
  < always {!<=-1,!>=2}
  0 always 0
Line 2597
  ( always {!<=-1,!>=2}
  , always {!<=-1,!>=2}
  isTemplate always {!<=-1,!>=2}
Line 2599
  ret always {!<=-1,!>=2}
  ret always {!<=-1,!>=2}
  = always 0
  false always 0
Line 2600
  bounded always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  frontToken possible 0
  || always {!<=-1,!>=2}
Line 2601
  ! always {!<=-1,!>=2}
Line 2604
  = possible symbolic=(mTokenList.front())
  frontToken possible symbolic=(mTokenList.front())
  tok possible symbolic=(mTokenList.front())
  && always {!<=-1,!>=2}
  tok always !0
  != always {!<=-1,!>=2}
Line 2613
  ( always {!<=-1,!>=2}
  bounded always {!<=-1,!>=2}
  4 always 4
  && always {!<=-1,!>=2}
Line 2614
  ( always {!<=-1,!>=2}
  "( %name% ) ;|)|,|]" always "( %name% ) ;|)|,|]"
  || always {!<=-1,!>=2}
Line 2615
  ( always {!<=-1,!>=2}
  "( %name% ) %cop%" always "( %name% ) %cop%"
  && always {!<=-1,!>=2}
Line 2616
  2 always 2
  > always {!<=-1,!>=2}
  0 always 0
  || always {!<=-1,!>=2}
Line 2617
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  4 always 4
  "[*&+-~]" always "[*&+-~]"
  && always {!<=-1,!>=2}
Line 2618
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 2619
  != always {!<=-1,!>=2}
  ">" always ">"
  && always {!<=-1,!>=2}
Line 2620
  != always {!<=-1,!>=2}
  ")" always ")"
  && always {!<=-1,!>=2}
Line 2621
  != always {!<=-1,!>=2}
  "]" always "]"
Line 2625
  ret always {!<=-1,!>=2}
  = always 1
  true always 1
Line 2628
  ( always {!<=-1,!>=2}
  bounded always {!<=-1,!>=2}
  3 always 3
  && always {!<=-1,!>=2}
Line 2629
  ( always {!<=-1,!>=2}
  "(|&&|%oror% %char% %comp% %num% &&|%oror%|)" always "(|&&|%oror% %char% %comp% %num% &&|%oror%|)"
Line 2633
  ( always {!<=-1,!>=2}
  bounded always {!<=-1,!>=2}
  5 always 5
  && always {!<=-1,!>=2}
Line 2634
  ( always {!<=-1,!>=2}
  "decltype ( %type% { } )" always "decltype ( %type% { } )"
Line 2640
  ret always {!<=-1,!>=2}
  = always 1
  true always 1
Line 2643
  ( always {!<=-1,!>=2}
  bounded always {!<=-1,!>=2}
  3 always 3
  && always {!<=-1,!>=2}
Line 2644
  ( always {!<=-1,!>=2}
  "decltype ( %bool%|%num% )" always "decltype ( %bool%|%num% )"
Line 2647
  ( always {!<=-1,!>=2}
Line 2648
  "bool" always "bool"
Line 2649
  ( always {!<=-1,!>=2}
Line 2652
  suffix {symbolic=(tok->str().back()),70,108,76}
  == {!<=-1,!>=2,0}
  'f' always 102
  || always {!<=-1,!>=2}
  suffix {symbolic=(tok->str().back()),108,76,!102}
  == {!<=-1,!>=2,0}
  'F' always 70
Line 2653
  "float" always "float"
Line 2654
  suffix {symbolic=(tok->str().back()),76,!102,!70}
  == {!<=-1,!>=2,0}
  'l' always 108
  || always {!<=-1,!>=2}
  suffix {symbolic=(tok->str().back()),!102,!70,!108}
  == always {!<=-1,!>=2}
  'L' always 76
Line 2655
  "double" always "double"
Line 2656
  true always 1
Line 2658
  "double" always "double"
Line 2659
  ( always {!<=-1,!>=2}
Line 2661
  suffix always symbolic=(MathLib::getSuffix(tok->str()))
  ( always !<=-1
  "LL" always "LL"
  != always {!<=-1,!>=2}
Line 2662
  "long" always "long"
Line 2663
  true always 1
Line 2664
  suffix always symbolic=(MathLib::getSuffix(tok->str()))
  ( always !<=-1
  'L' always 76
  != always {!<=-1,!>=2}
Line 2665
  "long" always "long"
Line 2667
  "int" always "int"
Line 2668
  ( always !<=-1
  'U' always 85
  != always {!<=-1,!>=2}
Line 2671
  ret always {!<=-1,!>=2}
  = always 1
  true always 1
Line 2674
  ( always {!<=-1,!>=2}
  bounded always {!<=-1,!>=2}
  2 always 2
  && always {!<=-1,!>=2}
Line 2675
  ( always {!<=-1,!>=2}
  "char|short|int|long { }" always "char|short|int|long { }"
  || always {!<=-1,!>=2}
Line 2676
  ( always {!<=-1,!>=2}
  "char|short|int|long ( )" always "char|short|int|long ( )"
Line 2677
  "0" always "0"
Line 2678
  false always 0
Line 2679
  false always 0
Line 2680
  false always 0
Line 2683
  ret always {!<=-1,!>=2}
  = always 1
  true always 1
Line 2686
  && always {!<=-1,!>=2}
  tok always !0
  ( always {!<=-1,!>=2}
Line 2687
  ( always {!<=-1,!>=2}
  bounded always {!<=-1,!>=2}
  tok always !0
  2 always 2
  && always {!<=-1,!>=2}
Line 2688
  ( always {!<=-1,!>=2}
  tok always !0
  isTemplate always {!<=-1,!>=2}
Line 2689
  ret always {!<=-1,!>=2}
  = always 1
  true always 1
Line 2690
  tok always !0
  -2 always -2
Line 2691
  ( always {!<=-1,!>=2}
  bounded always {!<=-1,!>=2}
  -2 always -2
  && always {!<=-1,!>=2}
Line 2692
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  prev always !0
  isTemplate always {!<=-1,!>=2}
Line 2693
  = always !0
  prev always !0
Line 2694
  prev {symbolic=(tok),!0}
  -2 always -2
Line 2699
  ( always {!<=-1,!>=2}
  bounded always {!<=-1,!>=2}
  -1 always -1
  && always {!<=-1,!>=2}
Line 2700
  ( always {!<=-1,!>=2}
  bounded always {!<=-1,!>=2}
  1 always 1
  && always {!<=-1,!>=2}
Line 2701
  ( always {!<=-1,!>=2}
  "[(=,] 0 &&" always "[(=,] 0 &&"
  || always {!<=-1,!>=2}
Line 2702
  ( always {!<=-1,!>=2}
  "[(=,] 1 %oror%" always "[(=,] 1 %oror%"
Line 2703
  par always !<=-1
  par always !<=-1
  = always 0
  0 always 0
Line 2705
  andAnd always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  tok always symbolic=(tok2)
  == always {!<=-1,!>=2}
  "&&" always "&&"
Line 2706
  tok2 possible symbolic=(tok)
Line 2707
  tok2 possible symbolic=(tok)
  ( possible {size=1,size=2}
  == {!<=-1,!>=2,0}
  "(" always "("
  || always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  "[" always "["
Line 2708
  ++ always !<=0
  par always !<=-1
Line 2709
  ( possible {size=1,size=2}
  == {!<=-1,!>=2,0}
  ")" always ")"
  || always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  "]" always "]"
Line 2710
  par always !<=-1
  == always {!<=-1,!>=2}
  0 always 0
Line 2712
  -- always !<=-1
  par always !<=0
Line 2713
  par always !<=-1
  == always {!<=-1,!>=2}
  0 always 0
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  andAnd always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  != always {!<=-1,!>=2}
  "||" always "||"
Line 2716
  tok2 possible symbolic=(tok)
Line 2717
  tok2 always !0
Line 2718
  ret always {!<=-1,!>=2}
  = always 1
  true always 1
Line 2723
  == always {!<=-1,!>=2}
  "0" always "0"
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  bounded always {!<=-1,!>=2}
  -1 always -1
Line 2724
  ( always {!<=-1,!>=2}
  bounded always {!<=-1,!>=2}
  1 always 1
  && always {!<=-1,!>=2}
Line 2725
  ( always {!<=-1,!>=2}
  "[+-] 0 %cop%|;" always "[+-] 0 %cop%|;"
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
Line 2726
  ( always {!<=-1,!>=2}
  "%or% 0 %cop%|;" always "%or% 0 %cop%|;"
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 2728
  ( always {!<=-1,!>=2}
  -4 always -4
  "[;{}] %name% = %name% [+-|] 0 ;" always "[;{}] %name% = %name% [+-|] 0 ;"
  && always {!<=-1,!>=2}
Line 2729
  -3 always -3
  == always {!<=-1,!>=2}
Line 2730
  -4 always -4
Line 2731
  5 always 5
Line 2734
  2 always 2
Line 2736
  ret always {!<=-1,!>=2}
  = always 1
  true always 1
Line 2737
  ( always {!<=-1,!>=2}
  bounded always {!<=-1,!>=2}
  1 always 1
  && always {!<=-1,!>=2}
Line 2738
  ( always {!<=-1,!>=2}
  "[=([,] 0 [+|]" always "[=([,] 0 [+|]"
  || always {!<=-1,!>=2}
Line 2739
  ( always {!<=-1,!>=2}
  "return|case 0 [+|]" always "return|case 0 [+|]"
Line 2741
  2 always 2
Line 2742
  ret always {!<=-1,!>=2}
  = always 1
  true always 1
Line 2743
  ( always {!<=-1,!>=2}
  "[=[(,] 0 * %name%|%num% ,|]|)|;|=|%cop%" always "[=[(,] 0 * %name%|%num% ,|]|)|;|=|%cop%"
  || always {!<=-1,!>=2}
Line 2744
  ( always {!<=-1,!>=2}
  "return|case 0 *|&& %name%|%num% ,|:|;|=|%cop%" always "return|case 0 *|&& %name%|%num% ,|:|;|=|%cop%"
  && always {!<=-1,!>=2}
Line 2745
  ( always {!<=-1,!>=2}
  bounded always {!<=-1,!>=2}
  3 always 3
  || always {!<=-1,!>=2}
Line 2746
  ( always {!<=-1,!>=2}
  "[=[(,] 0 * (" always "[=[(,] 0 * ("
  || always {!<=-1,!>=2}
Line 2747
  ( always {!<=-1,!>=2}
  "return|case 0 *|&& (" always "return|case 0 *|&& ("
  && always {!<=-1,!>=2}
Line 2748
  ( always {!<=-1,!>=2}
  bounded always {!<=-1,!>=2}
  2 always 2
Line 2750
  == always {!<=-1,!>=2}
  "(" always "("
Line 2753
  ret always {!<=-1,!>=2}
  = always 1
  true always 1
Line 2754
  ( always {!<=-1,!>=2}
  bounded always {!<=-1,!>=2}
  4 always 4
  && always {!<=-1,!>=2}
Line 2755
  ( always {!<=-1,!>=2}
  "[=[(,] 0 && *|& %any% ,|]|)|;|=|%cop%" always "[=[(,] 0 && *|& %any% ,|]|)|;|=|%cop%"
  || always {!<=-1,!>=2}
Line 2756
  ( always {!<=-1,!>=2}
  "return|case 0 && *|& %any% ,|:|;|=|%cop%" always "return|case 0 && *|& %any% ,|:|;|=|%cop%"
Line 2759
  == always {!<=-1,!>=2}
  "(" always "("
Line 2762
  ret always {!<=-1,!>=2}
  = always 1
  true always 1
Line 2766
  == always {!<=-1,!>=2}
  "1" always "1"
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  bounded always {!<=-1,!>=2}
  -1 always -1
Line 2767
  ( always {!<=-1,!>=2}
  bounded always {!<=-1,!>=2}
  3 always 3
  && always {!<=-1,!>=2}
Line 2768
  ( always {!<=-1,!>=2}
  "[=[(,] 1 %oror% %any% ,|]|)|;|=|%cop%" always "[=[(,] 1 %oror% %any% ,|]|)|;|=|%cop%"
  || always {!<=-1,!>=2}
Line 2769
  ( always {!<=-1,!>=2}
  "return|case 1 %oror% %any% ,|:|;|=|%cop%" always "return|case 1 %oror% %any% ,|:|;|=|%cop%"
Line 2771
  == always {!<=-1,!>=2}
  "(" always "("
Line 2774
  ret always {!<=-1,!>=2}
  = always 1
  true always 1
Line 2775
  ( always {!<=-1,!>=2}
  bounded always {!<=-1,!>=2}
  4 always 4
  && always {!<=-1,!>=2}
Line 2776
  ( always {!<=-1,!>=2}
  "[=[(,] 1 %oror% *|& %any% ,|]|)|;|=|%cop%" always "[=[(,] 1 %oror% *|& %any% ,|]|)|;|=|%cop%"
  || always {!<=-1,!>=2}
Line 2777
  ( always {!<=-1,!>=2}
  "return|case 1 %oror% *|& %any% ,|:|;|=|%cop%" always "return|case 1 %oror% *|& %any% ,|:|;|=|%cop%"
Line 2780
  == always {!<=-1,!>=2}
  "(" always "("
Line 2783
  ret always {!<=-1,!>=2}
  = always 1
  true always 1
Line 2787
  ( always {!<=-1,!>=2}
  -2 always -2
  "%any% * 1" always "%any% * 1"
  && always {!<=-1,!>=2}
Line 2788
  ( always {!<=-1,!>=2}
  bounded always {!<=-1,!>=2}
  -2 always -2
  || always {!<=-1,!>=2}
Line 2789
  ( always {!<=-1,!>=2}
  "%any% 1 *" always "%any% 1 *"
  && always {!<=-1,!>=2}
Line 2790
  ( always {!<=-1,!>=2}
  bounded always {!<=-1,!>=2}
  -1 always -1
Line 2792
  == always {!<=-1,!>=2}
  "*" always "*"
Line 2794
  2 always 2
Line 2795
  ret always {!<=-1,!>=2}
  = always 1
  true always 1
Line 2799
  ( always {!<=-1,!>=2}
  bounded always {!<=-1,!>=2}
  -2 always -2
  && always {!<=-1,!>=2}
Line 2800
  ( always {!<=-1,!>=2}
  -2 always -2
  "%op%|< ( %num% )" always "%op%|< ( %num% )"
  && always {!<=-1,!>=2}
Line 2801
  -2 always -2
  != always {!<=-1,!>=2}
  ">" always ">"
Line 2805
  ret always {!<=-1,!>=2}
  = always 1
  true always 1
Line 2808
  ( always {!<=-1,!>=2}
  bounded always {!<=-1,!>=2}
  -1 always -1
  && always {!<=-1,!>=2}
Line 2809
  ( always {!<=-1,!>=2}
  bounded always {!<=-1,!>=2}
  1 always 1
  && always {!<=-1,!>=2}
Line 2810
  ( always {!<=-1,!>=2}
  "( 0 [|+]" always "( 0 [|+]"
  || always {!<=-1,!>=2}
Line 2811
  ( always {!<=-1,!>=2}
  "[|+-] 0 )" always "[|+-] 0 )"
Line 2813
  ( always {!<=-1,!>=2}
  "[|+-]" always "[|+-]"
Line 2815
  2 always 2
Line 2816
  ret always {!<=-1,!>=2}
  = always 1
  true always 1
Line 2819
  ( always {!<=-1,!>=2}
  bounded always {!<=-1,!>=2}
  2 always 2
  && always {!<=-1,!>=2}
Line 2820
  ( always {!<=-1,!>=2}
  "%num% %comp% %num%" always "%num% %comp% %num%"
  && always {!<=-1,!>=2}
Line 2821
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 2822
  ( always {!<=-1,!>=2}
  2 always 2
Line 2823
  ( always {!<=-1,!>=2}
  bounded always {!<=-1,!>=2}
  -1 always -1
  && always {!<=-1,!>=2}
Line 2824
  ( always {!<=-1,!>=2}
  "(|&&|%oror%" always "(|&&|%oror%"
  && always {!<=-1,!>=2}
Line 2825
  ( always {!<=-1,!>=2}
  3 always 3
  ")|&&|%oror%|?" always ")|&&|%oror%|?"
Line 2828
  2 always 2
Line 2832
  cmp possible {size=2,size=1}
  == {!<=-1,!>=2,0}
  "==" always "=="
Line 2833
  == always {!<=-1,!>=2}
  "1" always "1"
  : always "0"
  "0" always "0"
Line 2834
  cmp possible {size=2,size=1}
  == {!<=-1,!>=2,0}
  "!=" always "!="
Line 2835
  != always {!<=-1,!>=2}
  "1" always "1"
  : always "0"
  "0" always "0"
Line 2836
  cmp possible {size=2,size=1}
  == {!<=-1,!>=2,0}
  "<=" always "<="
Line 2837
  <= always {!<=-1,!>=2}
  "1" always "1"
  : always "0"
  "0" always "0"
Line 2838
  cmp possible size=1
  == {!<=-1,!>=2,0}
  ">=" always ">="
Line 2839
  >= always {!<=-1,!>=2}
  "1" always "1"
  : always "0"
  "0" always "0"
Line 2840
  == always {!<=-1,!>=2}
  "<" always "<"
Line 2841
  < always {!<=-1,!>=2}
  "1" always "1"
  : always "0"
  "0" always "0"
Line 2843
  > always {!<=-1,!>=2}
  "1" always "1"
  : always "0"
  "0" always "0"
Line 2846
  2 always 2
Line 2847
  ret always {!<=-1,!>=2}
  = always 1
  true always 1
Line 2853
  return always {!<=-1,!>=2}
  ret always {!<=-1,!>=2}
Line 2860
  -1 always -1
  == always {!<=-1,!>=2}
  "<" always "<"
Line 2862
  typeParametersInDeclaration {size=0@166,NonMovedVariable}
Line 2864
  inDefaultValue always {!<=-1,!>=2}
  inDefaultValue always {!<=-1,!>=2}
  = always 0
  false always 0
Line 2865
  && always {!<=-1,!>=2}
  tok always !0
  != always {!<=-1,!>=2}
  end possible symbolic=(tok->previous()->findClosingBracket())
  tok possible {symbolic=(closing->next()),symbolic=(closing),symbolic=(tok->findClosingBracket())}
Line 2866
  ( always {!<=-1,!>=2}
  "template <" always "template <"
Line 2868
  closing always symbolic=(tok->next()->findClosingBracket())
Line 2869
  closing {symbolic=(tok->next()->findClosingBracket()),!0}
Line 2870
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "{|(|[" always "{|(|["
Line 2871
  = always !0
  ( always !0
Line 2872
  ( always {!<=-1,!>=2}
  "%name% ,|>|=" always "%name% ,|>|="
Line 2873
  ! always {!<=-1,!>=2}
  inDefaultValue always {!<=-1,!>=2}
Line 2874
  typeParametersInDeclaration possible lifetime[Object]=(tok)
Line 2875
  1 always 1
  == always {!<=-1,!>=2}
  "=" always "="
Line 2876
  inDefaultValue always {!<=-1,!>=2}
  = always 1
  true always 1
Line 2878
  inDefaultValue always {!<=-1,!>=2}
Line 2879
  ( possible size=1
  == always {!<=-1,!>=2}
  "," always ","
Line 2880
  inDefaultValue always {!<=-1,!>=2}
  = always 0
  false always 0
Line 2881
  == always {!<=-1,!>=2}
  "<" always "<"
Line 2883
  closing always symbolic=(tok->findClosingBracket())
Line 2884
  = {symbolic=(tok->findClosingBracket()),!0}
  closing {symbolic=(tok->findClosingBracket()),!0}
Line 2890
  ( always {!<=-1,!>=2}
Line 2896
  = {lifetime[Iterator]=(specializations),start=0}
  ( {lifetime[Iterator]=(specializations),start=0}
  it possible {lifetime[Iterator]=(specializations),start=0}
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(specializations),end=0}
Line 2897
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  it {lifetime[Iterator]=(specializations),!symbolic=(specializations.end()),!end=0}
  "%name% <" always "%name% <"
Line 2900
  startToken possible symbolic=(*it)
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  startToken possible symbolic=(*it)
  ( always !0
  "[;{}]" always "[;{}]"
Line 2901
  = always !0
  ( always !0
Line 2902
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  startToken possible symbolic=(*it)
  "template <" always "template <"
Line 2905
  2 always 2
  templateParameters always size=0
Line 2907
  2 always 2
Line 2908
  2 always 2
Line 2910
  ! always {!<=-1,!>=2}
  endToken {symbolic=((*it)->next()->findClosingBracket()),symbolic=(declToken)}
Line 2912
  != always {!<=-1,!>=2}
  endToken {symbolic=((*it)->next()->findClosingBracket()),!0}
Line 2913
  declToken always !symbolic=(endToken)
  != always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
Line 2914
  declToken always !symbolic=(endToken)
  ( always {!<=-1,!>=2}
  != always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
Line 2915
  declToken always !symbolic=(endToken)
  ( always {!<=-1,!>=2}
  != always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
Line 2916
  declToken always !symbolic=(endToken)
  ( always {!<=-1,!>=2}
  != always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 2917
  = always 0
  0 always 0
Line 2918
  nr possible 0
  < always {!<=-1,!>=2}
  ( always !<=-1
  && always {!<=-1,!>=2}
  nr possible 0
  != always {!<=-1,!>=2}
  declToken always !symbolic=(endToken)
Line 2921
  == always {!<=-1,!>=2}
  ( always !<=-1
Line 2924
  declToken always !symbolic=(endToken)
Line 2928
  declToken possible symbolic=(endToken)
  && always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  declToken always !0
  == always {!<=-1,!>=2}
  endToken {symbolic=((*it)->next()->findClosingBracket()),!0}
  && always {!<=-1,!>=2}
  instToken always !0
  == always {!<=-1,!>=2}
  ">" always ">"
Line 2930
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
Line 2935
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "%name% !!<" always "%name% !!<"
  && always {!<=-1,!>=2}
Line 2936
  ( always !<=-1
  '<' always 60
  == always {!<=-1,!>=2}
Line 2944
  indentlevel always !<=-1
  indentlevel always !<=-1
  = always 0
  0 always 0
Line 2946
  2 always 2
  != always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  indentlevel {!<=-1,0}
  > {!<=-1,!>=2,0}
  0 always 0
  || always {!<=-1,!>=2}
  tok3 always !symbolic=(endToken)
  != always {!<=-1,!>=2}
  ">" always ">"
Line 2948
  == always {!<=-1,!>=2}
  "[" always "["
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "%num%| ]" always "%num%| ]"
Line 2949
  typeForNewName always NonMovedVariable
Line 2952
  ! always {!<=-1,!>=2}
Line 2953
  typeForNewName always NonMovedVariable
Line 2956
  ( always {!<=-1,!>=2}
  -2 always -2
  "<|,|:: %name% <" always "<|,|:: %name% <"
  && always {!<=-1,!>=2}
  1 always 1
  == always {!<=-1,!>=2}
  ">" always ">"
  || always {!<=-1,!>=2}
  ( always !<=-1
Line 2957
  ++ always !<=0
  indentlevel always !<=-1
Line 2958
  indentlevel always !<=-1
  > always {!<=-1,!>=2}
  0 always 0
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "> ,|>|::" always "> ,|>|::"
Line 2959
  -- {!<=-1,>=0}
  indentlevel {>=1,!<=0}
Line 2960
  indentlevel always !<=-1
  == always {!<=-1,!>=2}
  0 always 0
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "[<,]" always "[<,]"
Line 2961
  "" always ""
Line 2963
  ( always {!<=-1,!>=2}
  "(|[" always "(|["
Line 2964
  ++ always !<=0
  indentlevel always !<=-1
Line 2965
  ( always {!<=-1,!>=2}
  ")|]" always ")|]"
Line 2966
  -- always !<=-1
  indentlevel always !<=-1
Line 2967
  constconst always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  "const" always "const"
  && always {!<=-1,!>=2}
  1 always 1
  == always {!<=-1,!>=2}
  "const" always "const"
Line 2968
  ! {!<=-1,!>=2,1}
  constconst {!<=-1,!>=2,0}
Line 2969
  ( always {!<=-1,!>=2}
Line 2970
  "unsigned" always "unsigned"
Line 2971
  ( always {!<=-1,!>=2}
Line 2972
  "signed" always "signed"
Line 2973
  ( always {!<=-1,!>=2}
Line 2974
  "long" always "long"
Line 2978
  ! {!<=-1,!>=2,1}
  constconst {!<=-1,!>=2,0}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "class|struct|enum" always "class|struct|enum"
Line 2979
  ! {!<=-1,!>=2,0}
  typeForNewName possible size=0
  ( {!<=-1,!>=2,1}
Line 2980
  ' ' always 32
Line 2981
  ( always {!<=-1,!>=2}
Line 2982
  "unsigned " always "unsigned "
Line 2983
  ( always {!<=-1,!>=2}
Line 2984
  "signed " always "signed "
Line 2985
  ( always {!<=-1,!>=2}
Line 2986
  "long " always "long "
Line 2992
  typeForNewName possible {NonMovedVariable,size=0}
Line 2995
  ( always {!<=-1,!>=2}
Line 3007
  2 always 2
  typeParametersInDeclaration always size=0
Line 3008
  printDebug always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  . always {!<=-1,!>=2}
  debugwarnings always {!<=-1,!>=2}
Line 3009
  specialized always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 3010
  isfunc always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 3011
  isVar always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 3014
  :: always !<=-1
  numberOfTemplateInstantiations always !<=-1
  numberOfTemplateInstantiations always !<=-1
  = always !<=-1
  ( always !<=-1
Line 3015
  recursiveCount always !<=-1
  recursiveCount always !<=-1
  = always 0
  0 always 0
Line 3017
  instantiated always {!<=-1,!>=2}
  instantiated always {!<=-1,!>=2}
  = always 0
  false always 0
Line 3021
  ! always {!<=-1,!>=2}
Line 3023
  numberOfTemplateInstantiations always !<=-1
  != always {!<=-1,!>=2}
  ( always !<=-1
Line 3024
  numberOfTemplateInstantiations always !<=-1
  = always {!<=-1,!symbolic=(numberOfTemplateInstantiations)}
  ( always {!<=-1,!symbolic=(numberOfTemplateInstantiations)}
Line 3025
  ++ {!<=0,>=symbolic=(mSettings->maxTemplateRecursion+1),<=symbolic=(mSettings->maxTemplateRecursion)}
  recursiveCount {!<=-1,>=symbolic=(mSettings->maxTemplateRecursion),<=symbolic=(mSettings->maxTemplateRecursion-1)}
Line 3026
  recursiveCount always !<=-1
  > always {!<=-1,!>=2}
Line 3028
  "<" always "<"
  ( always !0
  typeStringsUsedInTemplateInstantiation always size=0
  ">" always ">"
Line 3030
  1 always 1
Line 3031
  callstack always size=1
Line 3032
  & {lifetime[Address]=(mTokenizer->list),!0}
Line 3033
  :: always 6
  information always 6
Line 3034
  "templateRecursion" always "templateRecursion"
Line 3035
  "TemplateSimplifier: max template recursion (" always "TemplateSimplifier: max template recursion ("
Line 3037
  ") reached for template '" always ") reached for template '"
  "'. You might want to limit Cppcheck recursion." always "'. You might want to limit Cppcheck recursion."
Line 3038
  :: always 0
  normal always 0
Line 3039
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  :: always 6
  information always 6
Line 3040
  mErrorLogger always !0
Line 3048
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "%name% <" always "%name% <"
Line 3051
  ! always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
Line 3052
  == always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 3053
  ( always !symbolic=(templateDeclaration.fullName())
  == always {!<=-1,!>=2}
Line 3057
  != always {!<=-1,!>=2}
Line 3061
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 3066
  -1 always -1
  == always {!<=-1,!>=2}
  "~" always "~"
  && always {!<=-1,!>=2}
  -1 always -1
  != always {!<=-1,!>=2}
  "~" always "~"
Line 3070
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 3072
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  -2 always -2
  "decltype (" always "decltype ("
Line 3076
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 3078
  declFuncArgs always size=0
Line 3080
  instFuncParams always size=0
Line 3082
  ( {!<=-1,<=symbolic=(instFuncParams.size()-1),>=symbolic=(instFuncParams.size())}
  != always {!<=-1,!>=2}
  ( {!<=-1,>=symbolic=(declFuncArgs.size()+1),<=symbolic=(declFuncArgs.size())}
Line 3084
  2 always 2
Line 3085
  1 always 1
Line 3086
  count always !<=-1
  count always !<=-1
  = always 0
  0 always 0
Line 3087
  != always {!<=-1,!>=2}
Line 3088
  == always {!<=-1,!>=2}
  "=" always "="
Line 3089
  count always !<=-1
  ++ always !<=-1
Line 3092
  ( {!<=-1,>=symbolic=(declFuncArgs.size()+1),!symbolic=(declFuncArgs.size()),<=symbolic=(declFuncArgs.size()-1)}
  < always {!<=-1,!>=2}
  ( always {!<=-1,!symbolic=(instFuncParams.size())}
  - always !<=-1
  count always !<=-1
  || always {!<=-1,!>=2}
  ( {!<=-1,!symbolic=(declFuncArgs.size()),!<=symbolic=(declFuncArgs.size()-count-1),>=symbolic=(declFuncArgs.size()-count)}
  > always {!<=-1,!>=2}
  ( always {!<=-1,!symbolic=(instFuncParams.size())}
Line 3098
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 3099
  -1 always -1
  == always {!<=-1,!>=2}
  "." always "."
  || always {!<=-1,!>=2}
Line 3100
  ( always {!<=-1,!>=2}
  -2 always -2
  ". template" always ". template"
Line 3103
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 3107
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 3108
  mErrorLogger always !0
  ( always !size=0
  0 always 0
  "TemplateSimplifier::simplifyTemplateInstantiations()" always "TemplateSimplifier::simplifyTemplateInstantiations()"
Line 3115
  ( always {!<=-1,!>=2}
Line 3118
  ( always {!<=-1,!>=2}
  startToken possible {symbolic=(tok2),symbolic=(tok3->previous())}
  -2 always -2
  ">|%name% :: %name%" always ">|%name% :: %name%"
Line 3119
  -2 always -2
  == always {!<=-1,!>=2}
  ">" always ">"
Line 3120
  -2 always -2
Line 3122
  tok3 always !0
Line 3126
  -2 always -2
Line 3129
  ( always {!<=-1,!>=2}
  startToken possible symbolic=(tok2)
  ";|{|}|=|const" always ";|{|}|=|const"
  && always {!<=-1,!>=2}
Line 3130
  ! always {!<=-1,!>=2}
  specialized always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  ( always !<=-1
  ( always {!<=-1,!>=2}
  isfunc {!<=-1,!>=2,0}
  ? possible "("
  "(" always "("
  : always "("
  isVar always {!<=-1,!>=2}
  ? possible {";|%op%|(","*|&|::| %name%"}
  ";|%op%|(" always ";|%op%|("
  : always "*|&|::| %name%"
  "*|&|::| %name%" always "*|&|::| %name%"
Line 3136
  typeStringsUsedInTemplateInstantiation always size=0
Line 3138
  typeForNewName possible size=0
  ( {!<=-1,!>=2,0,1}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
Line 3139
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  typeParametersInDeclaration always !size=0
  ( always !<=0
  ( always {!<=-1,!>=2}
  nullptr always 0
Line 3140
  printDebug always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 3141
  1 always 1
Line 3142
  mErrorLogger always !0
  callstack always size=1
  & always !0
  :: always 7
  debug always 7
  "debug" always "debug"
Line 3143
  "Failed to instantiate template \"" always "Failed to instantiate template \""
  "\". The checking continues anyway." always "\". The checking continues anyway."
  :: always 0
  normal always 0
Line 3145
  ( always {!<=-1,!>=2}
Line 3151
  " < " always " < "
  " >" always " >"
Line 3152
  ( possible size=0
  ( always {!<=-1,!>=2}
  "" always ""
  : always " :: "
  " :: " always " :: "
Line 3155
  ! always {!<=-1,!>=2}
  specialized always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  isVar always {!<=-1,!>=2}
Line 3156
  instantiated always {!<=-1,!>=2}
  = always 1
  true always 1
Line 3157
  mChanged always {!<=-1,!>=2}
  = always 1
  true always 1
Line 3166
  ! always {!<=-1,!>=2}
  instantiated always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  specialized always {!<=-1,!>=2}
Line 3168
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 3169
  mErrorLogger always !0
  ( always !size=0
  0 always 0
  "TemplateSimplifier::simplifyTemplateInstantiations()" always "TemplateSimplifier::simplifyTemplateInstantiations()"
Line 3176
  ( always {!<=-1,!>=2}
Line 3179
  ( always {!<=-1,!>=2}
  startToken possible {symbolic=(tok2),symbolic=(tok3->previous())}
  -2 always -2
  ">|%name% :: %name%" always ">|%name% :: %name%"
Line 3180
  -2 always -2
  == always {!<=-1,!>=2}
  ">" always ">"
Line 3181
  -2 always -2
Line 3183
  tok3 always !0
Line 3187
  -2 always -2
Line 3196
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  tok2 possible symbolic=(startToken)
  "%name% <" always "%name% <"
Line 3197
  return always {!<=-1,!>=2}
  false always 0
Line 3199
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 3200
  return always {!<=-1,!>=2}
  false always 0
Line 3205
  typeStringsUsedInTemplateInstantiation always size=0
Line 3207
  ( always {!<=-1,!>=2}
Line 3208
  printDebug always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 3209
  1 always 1
Line 3210
  mErrorLogger always !0
  callstack always size=1
  & always !0
  :: always 7
  debug always 7
  "debug" always "debug"
Line 3211
  "Failed to instantiate template \"" always "Failed to instantiate template \""
  "\". The checking continues anyway." always "\". The checking continues anyway."
  :: always 0
  normal always 0
Line 3213
  return always {!<=-1,!>=2}
  false always 0
Line 3217
  " < " always " < "
  typeForNewName always !size=0
  " >" always " >"
Line 3218
  ( possible size=0
  ( always {!<=-1,!>=2}
  "" always ""
  : always " :: "
  " :: " always " :: "
Line 3221
  ! always {!<=-1,!>=2}
  specialized always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  isVar always {!<=-1,!>=2}
Line 3222
  instantiated always {!<=-1,!>=2}
  = always 1
  true always 1
Line 3223
  mChanged always {!<=-1,!>=2}
  = always 1
  true always 1
Line 3231
  return always {!<=-1,!>=2}
  instantiated {!<=-1,!>=2,1}
Line 3234
  ( always {!<=-1,!>=2}
Line 3236
  = {lifetime[Iterator]=(strings),start=0}
  ( {lifetime[Iterator]=(strings),start=0}
Line 3237
  2 always 2
Line 3239
  ! always {!<=-1,!>=2}
  end {symbolic=(nameTok->next()->findClosingBracket()),symbolic=(tok)}
Line 3240
  return always {!<=-1,!>=2}
  false always 0
Line 3241
  && always {!<=-1,!>=2}
  tok always !0
  != always {!<=-1,!>=2}
  end {symbolic=(nameTok->next()->findClosingBracket()),!0}
  && always {!<=-1,!>=2}
  it possible lifetime[Iterator]=(strings)
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(strings),end=0}
Line 3242
  tok always {!symbolic=(end),!0}
  ( always {!<=-1,!>=2}
Line 3243
  it {lifetime[Iterator]=(strings),symbolic=(strings.end()-1),!symbolic=(strings.end()),!end=0}
  != always {!<=-1,!>=2}
  "unsigned" always "unsigned"
Line 3244
  return always {!<=-1,!>=2}
  false always 0
Line 3246
  ++ {symbolic=(strings.end()),!symbolic=(strings.end()+1)}
  it {lifetime[Iterator]=(strings),symbolic=(strings.end()-1),!symbolic=(strings.end()),!end=0}
Line 3247
  it {lifetime[Iterator]=(strings),!symbolic=(strings.end()+1)}
  == always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(strings),end=0}
Line 3248
  return always {!<=-1,!>=2}
  false always 0
Line 3250
  tok always {!symbolic=(end),!0}
  ( always {!<=-1,!>=2}
Line 3251
  it {lifetime[Iterator]=(strings),symbolic=(strings.end()-1),!symbolic=(strings.end()),!end=0}
  != always {!<=-1,!>=2}
  "signed" always "signed"
Line 3252
  return always {!<=-1,!>=2}
  false always 0
Line 3254
  ++ {symbolic=(strings.end()),!symbolic=(strings.end()+1)}
  it {lifetime[Iterator]=(strings),symbolic=(strings.end()-1),!symbolic=(strings.end()),!end=0}
Line 3255
  it {lifetime[Iterator]=(strings),!symbolic=(strings.end()+1)}
  == always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(strings),end=0}
Line 3256
  return always {!<=-1,!>=2}
  false always 0
Line 3259
  tok always {!symbolic=(end),!0}
  ( always {!<=-1,!>=2}
Line 3260
  it possible symbolic=(strings.end()-1)
  != always {!<=-1,!>=2}
  "long" always "long"
Line 3261
  return always {!<=-1,!>=2}
  false always 0
Line 3263
  ++ possible symbolic=(strings.end())
  it possible symbolic=(strings.end()-1)
Line 3264
  == always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(strings),end=0}
Line 3265
  return always {!<=-1,!>=2}
  false always 0
Line 3268
  != always {!<=-1,!>=2}
  tok always {!symbolic=(end),!0}
Line 3269
  return always {!<=-1,!>=2}
  false always 0
Line 3270
  tok always {!symbolic=(end),!0}
Line 3273
  return always {!<=-1,!>=2}
  it possible {symbolic=(strings.end()),end=0}
  == {!<=-1,!>=2,1}
  ( {lifetime[Iterator]=(strings),symbolic=(it),end=0}
  && always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  tok always !0
  == always {!<=-1,!>=2}
  ">" always ">"
Line 3282
  nameTok possible symbolic=(tok2)
Line 3283
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "%name% <" always "%name% <"
  || always {!<=-1,!>=2}
Line 3284
  ( always {!<=-1,!>=2}
  "template|const_cast|dynamic_cast|reinterpret_cast|static_cast" always "template|const_cast|dynamic_cast|reinterpret_cast|static_cast"
Line 3290
  pointers always symbolic=(nameTok->templateSimplifierPointers())
  && always {!<=-1,!>=2}
  pointers {symbolic=(nameTok->templateSimplifierPointers()),!0}
  ( always !<=-1
Line 3292
  != always {!<=-1,!>=2}
  pointers {symbolic=(nameTok->templateSimplifierPointers()),!0}
  ( always start=0
Line 3294
  != always {!<=-1,!>=2}
Line 3301
  != always {!<=-1,!>=2}
Line 3305
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 3310
  ! always {!<=-1,!>=2}
  tok2 always symbolic=(nameTok->next()->findClosingBracket())
Line 3314
  nameTok always symbolic=(nameTok1)
Line 3318
  nameTok1 always symbolic=(nameTok)
  != always {!<=-1,!>=2}
  tok2 always !0
Line 3319
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always !0
  ( always {!<=-1,!>=2}
Line 3321
  = {lifetime[Iterator]=(mTemplateInstantiations),start=0}
  ( {lifetime[Iterator]=(mTemplateInstantiations),start=0}
  ti {lifetime[Iterator]=(mTemplateInstantiations),start=0}
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(mTemplateInstantiations),end=0}
Line 3322
  ti {lifetime[Iterator]=(mTemplateInstantiations),start=0}
  == always {!<=-1,!>=2}
Line 3323
  ti possible lifetime[Iterator]=(mTemplateInstantiations)
Line 3326
  ti possible lifetime[Iterator]=(mTemplateInstantiations)
Line 3332
  ( always {!<=-1,!>=2}
  nameTok always symbolic=(nameTok1)
  ">" always ">"
Line 3333
  nameTok always symbolic=(nameTok1)
Line 3334
  nameTok always symbolic=(nameTok1)
  tok2 always !0
Line 3336
  = always !0
  tok2 always !0
Line 3338
  ! {!<=-1,!>=2,0}
  removeTokens possible size=0
  ( {!<=-1,!>=2,1}
Line 3339
  removeTokens always !size=0
  removeTokens always !size=0
Line 3340
  removeTokens always !size=0
Line 3344
  ( always {!<=-1,!>=2}
Line 3349
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 3350
  return always {!<=-1,!>=2}
  false always 0
Line 3352
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 3353
  return always {!<=-1,!>=2}
  false always 0
Line 3356
  == always {!<=-1,!>=2}
Line 3357
  ( always {!<=-1,!>=2}
Line 3360
  specArgs always size=0
Line 3361
  declArgs always size=0
Line 3363
  ( always !<=-1
  == always {!<=-1,!>=2}
  ( always !<=-1
Line 3365
  return always {!<=-1,!>=2}
  true always 1
Line 3368
  return always {!<=-1,!>=2}
  true always 1
Line 3371
  return always {!<=-1,!>=2}
  false always 0
Line 3378
  ( always {!<=-1,!>=2}
Line 3379
  found always {!<=-1,!>=2}
  found always {!<=-1,!>=2}
  = always 0
  false always 0
Line 3381
  ( always {!<=-1,!>=2}
Line 3383
  found always {!<=-1,!>=2}
  = always 1
  true always 1
Line 3388
  ! {!<=-1,!>=2,0}
  found {!<=-1,!>=2,1}
Line 3390
  ( always {!<=-1,!>=2}
Line 3404
  ( always {!<=-1,!>=2}
Line 3405
  found always {!<=-1,!>=2}
  found always {!<=-1,!>=2}
  = always 0
  false always 0
Line 3407
  ( always {!<=-1,!>=2}
Line 3409
  found always {!<=-1,!>=2}
  = always 1
  true always 1
Line 3414
  ! {!<=-1,!>=2,0}
  found {!<=-1,!>=2,1}
Line 3416
  ( always {!<=-1,!>=2}
Line 3432
  2 always 2
  params1 always size=0
Line 3436
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 3441
  2 always 2
  params2 always size=0
Line 3444
  ( always !<=-1
  == always {!<=-1,!>=2}
  ( always !<=-1
Line 3446
  == always {!<=-1,!>=2}
Line 3448
  1 always 1
  == always {!<=-1,!>=2}
  "(" always "("
  && always {!<=-1,!>=2}
  1 always 1
  == always {!<=-1,!>=2}
  "(" always "("
  || always {!<=-1,!>=2}
Line 3449
  1 always 1
  == always {!<=-1,!>=2}
  "{" always "{"
  && always {!<=-1,!>=2}
  1 always 1
  == always {!<=-1,!>=2}
  ";" always ";"
Line 3453
  k always !<=-1
  = always 0
  0 always 0
  k {!<=-1,0}
  < always {!<=-1,!>=2}
  ( {!<=-1,symbolic=(params2.size())}
  k always !<=-1
  ++ always !<=-1
Line 3455
  k always !<=-1
  1 always 1
  == always {!<=-1,!>=2}
  "=" always "="
  && always {!<=-1,!>=2}
  k always !<=-1
  1 always 1
  != always {!<=-1,!>=2}
  "=" always "="
Line 3456
  = always 0
  0 always 0
Line 3457
  k always !<=-1
Line 3458
  end possible {symbolic=(params1[k]->next()),0}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  level possible 0
  == {!<=-1,!>=2,1}
  0 always 0
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  end {symbolic=(params1[k]->next()),!0}
  ",|>" always ",|>"
Line 3459
  ( always {!<=-1,!>=2}
  end always !0
  "{|(|<" always "{|(|<"
Line 3461
  ( always {!<=-1,!>=2}
  end always !0
  "}|)|>" always "}|)|>"
Line 3463
  end always !0
Line 3465
  end possible {symbolic=(params1[k]->next()),0}
Line 3466
  k always !<=-1
  [ possible lifetime[Lambda]=(mTokenList)
  k always !<=-1
  end always !0
Line 3480
  "token: " always "token: "
Line 3482
  "\"" always "\""
  ( always !0
  "\" " always "\" "
Line 3484
  "nullptr" always "nullptr"
Line 3486
  "scope: \"" always "scope: \""
  "\"" always "\""
Line 3487
  "name: \"" always "name: \""
  "\"" always "\""
Line 3488
  "fullName: \"" always "fullName: \""
  "\"" always "\""
Line 3489
  "nameToken: " always "nameToken: "
Line 3491
  "\"" always "\""
  ( always !0
  "\" " always "\" "
Line 3493
  "nullptr" always "nullptr"
Line 3495
  "paramEnd: " always "paramEnd: "
Line 3497
  "\"" always "\""
  ( always !0
  "\" " always "\" "
Line 3499
  "nullptr" always "nullptr"
Line 3501
  "flags: " always "flags: "
Line 3502
  ( always {!<=-1,!>=2}
Line 3503
  " isClass" always " isClass"
Line 3504
  ( always {!<=-1,!>=2}
Line 3505
  " isFunction" always " isFunction"
Line 3506
  ( always {!<=-1,!>=2}
Line 3507
  " isVariable" always " isVariable"
Line 3508
  ( always {!<=-1,!>=2}
Line 3509
  " isAlias" always " isAlias"
Line 3510
  ( always {!<=-1,!>=2}
Line 3511
  " isSpecialization" always " isSpecialization"
Line 3512
  ( always {!<=-1,!>=2}
Line 3513
  " isPartialSpecialization" always " isPartialSpecialization"
Line 3514
  ( always {!<=-1,!>=2}
Line 3515
  " isForwardDeclaration" always " isForwardDeclaration"
Line 3516
  ( always {!<=-1,!>=2}
Line 3517
  " isVariadic" always " isVariadic"
Line 3518
  ( always {!<=-1,!>=2}
Line 3519
  " isFriend" always " isFriend"
Line 3521
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always !0
  1 always 1
  == always {!<=-1,!>=2}
  "<" always "<"
Line 3523
  end always symbolic=(tokenAndName.token()->next()->findClosingBracket())
Line 3525
  "type: " always "type: "
Line 3526
  start possible symbolic=(tokenAndName.token()->next())
  && always {!<=-1,!>=2}
  start {symbolic=(tokenAndName.token()->next()),!0}
  != always {!<=-1,!>=2}
  end {symbolic=(tokenAndName.token()->next()->findClosingBracket()),!0}
Line 3527
  start always {!symbolic=(end),!0}
  ( always {!<=-1,!>=2}
Line 3528
  "unsigned" always "unsigned"
Line 3529
  start always {!symbolic=(end),!0}
  ( always {!<=-1,!>=2}
Line 3530
  "signed" always "signed"
Line 3531
  start always {!symbolic=(end),!0}
  ( always {!<=-1,!>=2}
Line 3532
  "long" always "long"
Line 3533
  start always {!symbolic=(end),!0}
Line 3534
  start always {!symbolic=(end),!0}
Line 3536
  end {symbolic=(tokenAndName.token()->next()->findClosingBracket()),symbolic=(start),!0}
Line 3538
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 3540
  "aliasStartToken: \"" always "aliasStartToken: \""
  ( always !0
  "\" " always "\" "
Line 3544
  "aliasEndToken: \"" always "aliasEndToken: \""
  ( always !0
  "\" " always "\" "
Line 3555
  "mTemplateDeclarations: " always "mTemplateDeclarations: "
  ( always !<=-1
Line 3556
  = always 0
  0 always 0
Line 3558
  "mTemplateDeclarations[" always "mTemplateDeclarations["
  count possible 0
  ++ possible 0
  "]:" always "]:"
Line 3561
  "mTemplateForwardDeclarations: " always "mTemplateForwardDeclarations: "
  ( always !<=-1
Line 3562
  = always 0
  0 always 0
Line 3564
  "mTemplateForwardDeclarations[" always "mTemplateForwardDeclarations["
  count possible 0
  ++ possible 0
  "]:" always "]:"
Line 3567
  "mTemplateForwardDeclarationsMap: " always "mTemplateForwardDeclarationsMap: "
  ( always !<=-1
Line 3568
  mapIndex always !<=-1
  mapIndex always !<=-1
  = always 0
  0 always 0
Line 3570
  declIndex always !<=-1
  declIndex always !<=-1
  = always 0
  0 always 0
Line 3572
  == always {!<=-1,!>=2}
Line 3573
  forwardIndex always !<=-1
  forwardIndex always !<=-1
  = always 0
  0 always 0
Line 3575
  == always {!<=-1,!>=2}
Line 3576
  "mTemplateForwardDeclarationsMap[" always "mTemplateForwardDeclarationsMap["
  mapIndex always !<=-1
  "]:" always "]:"
Line 3577
  "    mTemplateDeclarations[" always "    mTemplateDeclarations["
  declIndex always !<=-1
Line 3578
  "] => mTemplateForwardDeclarations[" always "] => mTemplateForwardDeclarations["
  forwardIndex always !<=-1
  "]" always "]"
Line 3581
  forwardIndex always !<=-1
  ++ always !<=-1
Line 3585
  declIndex always !<=-1
  ++ always !<=-1
Line 3587
  mapIndex always !<=-1
  ++ always !<=-1
Line 3589
  "mTemplateSpecializationMap: " always "mTemplateSpecializationMap: "
  ( always !<=-1
Line 3591
  decl1Index always !<=-1
  decl1Index always !<=-1
  = always 0
  0 always 0
Line 3593
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
Line 3594
  found always {!<=-1,!>=2}
  found always {!<=-1,!>=2}
  = always 0
  false always 0
Line 3595
  decl2Index always !<=-1
  decl2Index always !<=-1
  = always 0
  0 always 0
Line 3597
  == always {!<=-1,!>=2}
Line 3598
  "mTemplateSpecializationMap[" always "mTemplateSpecializationMap["
  mapIndex always !<=-1
  "]:" always "]:"
Line 3599
  "    mTemplateDeclarations[" always "    mTemplateDeclarations["
  decl1Index always !<=-1
Line 3600
  "] => mTemplateDeclarations[" always "] => mTemplateDeclarations["
  decl2Index always !<=-1
  "]" always "]"
Line 3601
  found always {!<=-1,!>=2}
  = always 1
  true always 1
Line 3604
  decl2Index always !<=-1
  ++ always !<=-1
Line 3606
  ! {!<=-1,!>=2,0}
  found {!<=-1,!>=2,1}
Line 3607
  decl2Index always !<=-1
  = always 0
  0 always 0
Line 3609
  == always {!<=-1,!>=2}
Line 3610
  "mTemplateSpecializationMap[" always "mTemplateSpecializationMap["
  mapIndex always !<=-1
  "]:" always "]:"
Line 3611
  "    mTemplateDeclarations[" always "    mTemplateDeclarations["
  decl1Index always !<=-1
Line 3612
  "] => mTemplateForwardDeclarations[" always "] => mTemplateForwardDeclarations["
  decl2Index always !<=-1
  "]" always "]"
Line 3615
  decl2Index always !<=-1
  ++ always !<=-1
Line 3620
  decl1Index always !<=-1
  ++ always !<=-1
Line 3622
  mapIndex always !<=-1
  ++ always !<=-1
Line 3624
  "mTemplatePartialSpecializationMap: " always "mTemplatePartialSpecializationMap: "
  ( always !<=-1
Line 3626
  decl1Index always !<=-1
  decl1Index always !<=-1
  = always 0
  0 always 0
Line 3628
  == always {!<=-1,!>=2}
Line 3629
  found always {!<=-1,!>=2}
  found always {!<=-1,!>=2}
  = always 0
  false always 0
Line 3630
  decl2Index always !<=-1
  decl2Index always !<=-1
  = always 0
  0 always 0
Line 3632
  == always {!<=-1,!>=2}
Line 3633
  "mTemplatePartialSpecializationMap[" always "mTemplatePartialSpecializationMap["
  mapIndex always !<=-1
  "]:" always "]:"
Line 3634
  "    mTemplateDeclarations[" always "    mTemplateDeclarations["
  decl1Index always !<=-1
Line 3635
  "] => mTemplateDeclarations[" always "] => mTemplateDeclarations["
  decl2Index always !<=-1
  "]" always "]"
Line 3636
  found always {!<=-1,!>=2}
  = always 1
  true always 1
Line 3639
  decl2Index always !<=-1
  ++ always !<=-1
Line 3641
  ! {!<=-1,!>=2,0}
  found {!<=-1,!>=2,1}
Line 3642
  decl2Index always !<=-1
  = always 0
  0 always 0
Line 3644
  == always {!<=-1,!>=2}
Line 3645
  "mTemplatePartialSpecializationMap[" always "mTemplatePartialSpecializationMap["
  mapIndex always !<=-1
  "]:" always "]:"
Line 3646
  "    mTemplateDeclarations[" always "    mTemplateDeclarations["
  decl1Index always !<=-1
Line 3647
  "] => mTemplateForwardDeclarations[" always "] => mTemplateForwardDeclarations["
  decl2Index always !<=-1
  "]" always "]"
Line 3650
  decl2Index always !<=-1
  ++ always !<=-1
Line 3655
  decl1Index always !<=-1
  ++ always !<=-1
Line 3657
  mapIndex always !<=-1
  ++ always !<=-1
Line 3659
  "mTemplateInstantiations: " always "mTemplateInstantiations: "
  ( always !<=-1
Line 3660
  = always 0
  0 always 0
Line 3662
  "mTemplateInstantiations[" always "mTemplateInstantiations["
  count possible 0
  ++ possible 0
  "]:" always "]:"
Line 3669
  codeWithTemplates always {!<=-1,!>=2}
Line 3673
  ( always {!<=-1,!>=2}
  "sizeof ..." always "sizeof ..."
Line 3674
  "sizeof..." always "sizeof..."
Line 3681
  ( always {!<=-1,!>=2}
  "typename %name%" always "typename %name%"
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  -3 always -3
  "using %name% =" always "using %name% ="
Line 3684
  ( always {!<=-1,!>=2}
  "template <" always "template <"
Line 3686
  ! always {!<=-1,!>=2}
Line 3691
  >= always {!<=-1,!>=2}
  :: always 4
  CPP20 always 4
Line 3695
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  ")|>|>> requires %name%|(" always ")|>|>> requires %name%|("
Line 3699
  end always !0
Line 3704
  ( always {!<=-1,!>=2}
  "explicit (" always "explicit ("
Line 3705
  isFalse always {!<=-1,!>=2}
  isFalse always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  2 always 2
  "false )" always "false )"
Line 3706
  1 always 1
Line 3707
  isFalse always {!<=-1,!>=2}
Line 3715
  passCount {!<=-1,0}
  passCount always !<=-1
  = always 0
  0 always 0
Line 3716
  passCountMax always 10
  = always 10
  10 always 10
Line 3717
  passCount {!<=-1,0}
  < {!<=-1,!>=2,1}
  passCountMax always 10
  ++ always !<=0
  passCount always !<=-1
Line 3718
  passCount {!<=-1,0,<=9,!>=10}
Line 3720
  usingChanged always {!<=-1,!>=2}
  usingChanged always {!<=-1,!>=2}
  = always 0
  false always 0
Line 3721
  ( always {!<=-1,!>=2}
Line 3722
  usingChanged always {!<=-1,!>=2}
  = always 1
  true always 1
Line 3724
  ! {!<=-1,!>=2,1,0}
  usingChanged {!<=-1,!>=2,0,1}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  mChanged always {!<=-1,!>=2}
Line 3727
  mChanged always {!<=-1,!>=2}
  = {!<=-1,!>=2,1}
  usingChanged {!<=-1,!>=2,1}
Line 3739
  hasTemplates always {!<=-1,!>=2}
  hasTemplates always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 3741
  passCount {!<=-1,0}
  == {!<=-1,!>=2,1}
  0 always 0
Line 3742
  codeWithTemplates always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  hasTemplates always {!<=-1,!>=2}
Line 3745
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 3748
  . always {!<=-1,!>=2}
  debugtemplate always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  . always {!<=-1,!>=2}
  debugnormal always {!<=-1,!>=2}
Line 3749
  "Template Simplifier pass " always "Template Simplifier pass "
  passCount always !<=-1
  + always !<=0
  1 always 1
Line 3750
  ( {lifetime[Object]=(title),!0}
Line 3770
  . always {!<=-1,!>=2}
  debugtemplate always {!<=-1,!>=2}
Line 3771
  "### Template Simplifier pass " always "### Template Simplifier pass "
  passCount always !<=-1
  + always !<=0
  1 always 1
  " ###" always " ###"
Line 3775
  = {lifetime[Iterator]=(mTemplateDeclarations),start=0}
  ( {lifetime[Iterator]=(mTemplateDeclarations),start=0}
  iter1 possible {lifetime[Iterator]=(mTemplateDeclarations),start=0}
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(mTemplateDeclarations),end=0}
Line 3776
  iter1 possible lifetime[Iterator]=(mTemplateDeclarations)
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  iter1 possible lifetime[Iterator]=(mTemplateDeclarations)
  ( always {!<=-1,!>=2}
Line 3781
  = {lifetime[Iterator]=(mTemplateDeclarations),start=0}
  ( {lifetime[Iterator]=(mTemplateDeclarations),start=0}
  iter2 possible {lifetime[Iterator]=(mTemplateDeclarations),start=0}
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(mTemplateDeclarations),end=0}
Line 3782
  iter2 {lifetime[Iterator]=(mTemplateDeclarations),!symbolic=(mTemplateDeclarations.end()),!end=0}
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  iter2 {lifetime[Iterator]=(mTemplateDeclarations),!symbolic=(mTemplateDeclarations.end()),!end=0}
  ( always {!<=-1,!>=2}
Line 3785
  == always {!<=-1,!>=2}
Line 3789
  instantiated always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 3794
  instantiated always {!<=-1,!>=2}
Line 3798
  = {lifetime[Iterator]=(mInstantiatedTemplates),start=0}
  ( {lifetime[Iterator]=(mInstantiatedTemplates),start=0}
  it possible {lifetime[Iterator]=(mInstantiatedTemplates),start=0}
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(mInstantiatedTemplates),end=0}
Line 3800
  = {lifetime[Iterator]=(mTemplateDeclarations),start=0}
  ( {lifetime[Iterator]=(mTemplateDeclarations),start=0}
  decl possible {lifetime[Iterator]=(mTemplateDeclarations),start=0}
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(mTemplateDeclarations),end=0}
Line 3801
  decl {lifetime[Iterator]=(mTemplateDeclarations),!symbolic=(mTemplateDeclarations.end()),!end=0}
  == always {!<=-1,!>=2}
  it possible lifetime[Iterator]=(mInstantiatedTemplates)
Line 3804
  decl possible {symbolic=(mTemplateDeclarations.end()),end=0}
  != {!<=-1,!>=2,0}
  ( {lifetime[Iterator]=(mTemplateDeclarations),end=0}
Line 3805
  ( always {!<=-1,!>=2}
Line 3808
  tok always symbolic=(it->token())
  2 always 2
Line 3809
  tok always symbolic=(it->token())
Line 3812
  = possible lifetime[Iterator]=(mTemplateForwardDeclarationsMap)
  ( possible lifetime[Iterator]=(mTemplateForwardDeclarationsMap)
Line 3813
  it1 {lifetime[Iterator]=(mTemplateForwardDeclarationsMap),symbolic=(mTemplateForwardDeclarationsMap.find(it->token()))}
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(mTemplateForwardDeclarationsMap),end=0}
Line 3814
  ( always {!<=-1,!>=2}
  it1 {lifetime[Iterator]=(mTemplateForwardDeclarationsMap),symbolic=(mTemplateForwardDeclarationsMap.find(it->token())),!symbolic=(mTemplateForwardDeclarationsMap.end()),!end=0}
Line 3815
  ( always {!<=-1,!>=2}
Line 3817
  decl always !end=0
Line 3822
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 3823
  :: possible {symbolic=(mTemplateDeclarations.end()),end=0}
  it possible {symbolic=(mTemplateDeclarations.end()),end=0}
  = possible lifetime[Iterator]=(mTemplateDeclarations)
  ( possible lifetime[Iterator]=(mTemplateDeclarations)
  ( {lifetime[Iterator]=(mTemplateDeclarations),start=0}
Line 3824
  ( {lifetime[Iterator]=(mTemplateDeclarations),end=0}
Line 3825
  mMemberFunctionsToDelete always !size=0
  ( {lifetime[Iterator]=(mMemberFunctionsToDelete),!size=0,start=0}
Line 3827
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(mTemplateDeclarations),end=0}
Line 3828
  ( always {!<=-1,!>=2}
  it always {!symbolic=(mTemplateDeclarations.end()),!end=0}
Line 3829
  it always !end=0
Line 3831
  :: possible {symbolic=(mTemplateForwardDeclarations.end()),end=0}
  it1 possible {symbolic=(mTemplateForwardDeclarations.end()),end=0}
  = possible lifetime[Iterator]=(mTemplateForwardDeclarations)
  ( possible lifetime[Iterator]=(mTemplateForwardDeclarations)
  ( {lifetime[Iterator]=(mTemplateForwardDeclarations),start=0}
Line 3832
  ( {lifetime[Iterator]=(mTemplateForwardDeclarations),end=0}
Line 3833
  mMemberFunctionsToDelete always !size=0
  ( {lifetime[Iterator]=(mMemberFunctionsToDelete),!size=0,start=0}
Line 3835
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(mTemplateForwardDeclarations),end=0}
Line 3836
  ( always {!<=-1,!>=2}
  it1 always {!symbolic=(mTemplateForwardDeclarations.end()),!end=0}
Line 3837
  it1 always !end=0
Line 3840
  mMemberFunctionsToDelete always !size=0
  ( {lifetime[Iterator]=(mMemberFunctionsToDelete),start=0}
Line 3846
  start always symbolic=(j.token())
Line 3847
  start {symbolic=(j.token()),!0}
Line 3848
  end possible {symbolic=(start->next()),0}
  && always {!<=-1,!>=2}
  end {symbolic=(start->next()),!0}
  != always {!<=-1,!>=2}
  ";" always ";"
Line 3849
  end always !0
Line 3850
  start {symbolic=(j.token()),!0}
Line 3851
  = always !0
  start {symbolic=(j.token()),!0}
  ( always !0
Line 3852
  && always {!<=-1,!>=2}
  end always !0
Line 3853
  = always !0
  end always !0
  ( always !0
Line 3859
  passCount always !<=-1
  == always {!<=-1,!>=2}
  passCountMax always 10
Line 3860
  . always {!<=-1,!>=2}
  debugwarnings always {!<=-1,!>=2}
Line 3861
  1 always 1
Line 3862
  locationList always size=1
  & {lifetime[Address]=(mTokenizer->list),!0}
Line 3863
  :: always 7
  debug always 7
Line 3864
  "debug" always "debug"
Line 3865
  "TemplateSimplifier: pass count limit hit before simplifications were finished." always "TemplateSimplifier: pass count limit hit before simplifications were finished."
Line 3866
  :: always 0
  normal always 0
Line 3868
  mErrorLogger always !0
Line 3873
  >= always {!<=-1,!>=2}
  :: always 3
  CPP17 always 3
Line 3874
  simplify always {!<=-1,!>=2}
  simplify always {!<=-1,!>=2}
  = always 0
  false always 0
Line 3876
  ( possible size=1
  == {!<=-1,!>=2,0}
  "template" always "template"
Line 3877
  simplify always {!<=-1,!>=2}
  = always 0
  false always 0
Line 3878
  ( possible {size=1,size=8}
  == {!<=-1,!>=2,0}
  "{" always "{"
Line 3879
  simplify always {!<=-1,!>=2}
  = always 1
  true always 1
Line 3880
  ! {!<=-1,!>=2,0}
  simplify {!<=-1,!>=2,1}
  || always {!<=-1,!>=2}
  != always {!<=-1,!>=2}
  "(" always "("
Line 3882
  = always 0
  nullptr always 0
Line 3883
  = always 0
  nullptr always 0
Line 3884
  ( always {!<=-1,!>=2}
  "( ... %op%" always "( ... %op%"
Line 3885
  2 always 2
Line 3887
  ( always {!<=-1,!>=2}
  "( %name% %op% ..." always "( %name% %op% ..."
Line 3888
  2 always 2
Line 3889
  ( always {!<=-1,!>=2}
  nullptr always 0
  : always 0
Line 3890
  ( always {!<=-1,!>=2}
  -3 always -3
  "%op% ... )" always "%op% ... )"
Line 3891
  -2 always -2
Line 3893
  ( always {!<=-1,!>=2}
  -3 always -3
  "... %op% %name% )" always "... %op% %name% )"
Line 3894
  -2 always -2
Line 3895
  ( always {!<=-1,!>=2}
  nullptr always 0
  : always 0
Line 3902
  args possible {symbolic=(tok->link()->previous()),symbolic=(tok->link()->previous()->isName()?nullptr:tok->next()),symbolic=(tok->next()),symbolic=(tok->next()->isName()?nullptr:tok->link()->previous())}
  && always {!<=-1,!>=2}
  args always !0
  ( always {!<=-1,!>=2}
  args always !0
  : always ""
  "" always ""
Line 3905
  ")" always ")"
Line 3906
  ! {!<=-1,!>=2,0}
  strargs {symbolic=((args&&args->isName())?args->str():""),size=0}
  ( {!<=-1,!>=2,1}
Line 3907
  "..." always "..."
Line 3908
  strargs {symbolic=((args&&args->isName())?args->str():""),!size=0}
Line 3910
  "(" always "("
Line 3912
  "__cppcheck_fold_" always "__cppcheck_fold_"
  strop always symbolic=(op->str())
  "__" always "__"
Line 3919
  ( inconclusive lifetime[SubObject]=(tok)
  tok possible {0@48,symbolic=(closing->next())@48}
  "syntax error" always "syntax error"
  :: always 1
  SYNTAX always 1
Line 50
  mFlags always !<=-1
  mFlags always !<=-1
  = always 0
  0 always 0
Line 52
  ( always !<=-1
Line 53
  return always !<=-1
  mFlags always !<=-1
Line 56
  mFlags always !<=-1
  = always 0
  0 always 0
Line 59
  mFlags always !<=-1
  = always 4294967295
  0xFFFFFFFF always 4294967295
Line 61
  enabled always {!<=-1,!>=2}
Line 62
  enabled always {!<=-1,!>=2}
Line 67
  ( always {!<=-1,!>=2}
Line 68
  return always {!<=-1,!>=2}
  mFlags always !<=-1
  & always !<=-1
  1U always 1
  << always !<=0
  ( {!<=-1,6@2,7@148}
  flag possible {6@2,7@148}
  != always {!<=-1,!>=2}
  0 always 0
Line 71
  mFlags always !<=-1
  |= always !<=-1
  1U always 1
  << always !<=0
  ( always !<=-1
Line 74
  mFlags always !<=-1
  &= always !<=-1
  ~ always !<=4294967295
  1U always 1
  << always !<=0
  ( always !<=-1
Line 76
  , always {!<=-1,!>=2}
  enabled always {!<=-1,!>=2}
Line 77
  enabled always {!<=-1,!>=2}
Line 50
  mFlags always !<=-1
  mFlags always !<=-1
  = always 0
  0 always 0
Line 52
  ( always !<=-1
Line 53
  return always !<=-1
  mFlags always !<=-1
Line 56
  mFlags always !<=-1
  = always 0
  0 always 0
Line 59
  mFlags always !<=-1
  = always 4294967295
  0xFFFFFFFF always 4294967295
Line 61
  enabled always {!<=-1,!>=2}
Line 62
  enabled always {!<=-1,!>=2}
Line 67
  ( always {!<=-1,!>=2}
Line 68
  return always {!<=-1,!>=2}
  mFlags always !<=-1
  & always !<=-1
  1U always 1
  << always !<=0
  ( always !<=-1
  != always {!<=-1,!>=2}
  0 always 0
Line 71
  mFlags always !<=-1
  |= always !<=-1
  1U always 1
  << always !<=0
  ( always !<=-1
Line 74
  mFlags always !<=-1
  &= always !<=-1
  ~ always !<=4294967295
  1U always 1
  << always !<=0
  ( always !<=-1
Line 76
  , always {!<=-1,!>=2}
  enabled always {!<=-1,!>=2}
Line 77
  enabled always {!<=-1,!>=2}
Line 50
  mFlags always !<=-1
  mFlags always !<=-1
  = always 0
  0 always 0
Line 52
  ( always !<=-1
Line 53
  return always !<=-1
  mFlags always !<=-1
Line 56
  mFlags always !<=-1
  = always 0
  0 always 0
Line 59
  mFlags always !<=-1
  = always 4294967295
  0xFFFFFFFF always 4294967295
Line 61
  enabled always {!<=-1,!>=2}
Line 62
  enabled always {!<=-1,!>=2}
Line 67
  ( always {!<=-1,!>=2}
Line 68
  return always {!<=-1,!>=2}
  mFlags always !<=-1
  & always !<=-1
  1U always 1
  << always !<=0
  ( always !<=-1
  != always {!<=-1,!>=2}
  0 always 0
Line 71
  mFlags always !<=-1
  |= always !<=-1
  1U always 1
  << always !<=0
  ( always !<=-1
Line 74
  mFlags always !<=-1
  &= always !<=-1
  ~ always !<=4294967295
  1U always 1
  << always !<=0
  ( always !<=-1
Line 76
  , always {!<=-1,!>=2}
  enabled always {!<=-1,!>=2}
Line 77
  enabled always {!<=-1,!>=2}
