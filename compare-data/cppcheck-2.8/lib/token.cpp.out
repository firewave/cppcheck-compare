

##file cppcheck-2.8/lib/config.h

1:
|
78:
79: static const std :: string emptyString@var1 ;

##file cppcheck-2.8/lib/mathlib.h

1:
|
33:
34: class MathLib {
35: friend class TestMathLib ;
36:
37: public:
38:
39: class value {
40: private:
41: long long mIntValue@var2 ;
42: double mDoubleValue@var3 ;
43: enum class Type { INT , LONG , LONGLONG , FLOAT } ; enum Type mType@var4 ;
44: bool mIsUnsigned@var5 ;
45:
46: void promote ( const value & v@var6 ) ;
47:
48: public:
49: explicit value ( const std :: string & s@var7 ) ;
50: std :: string str ( ) const ;
51: bool isInt ( ) const {
52: return mType@var4 !=@expr1073744421 Type ::@expr1073744422 FLOAT ;
53: }
54: bool isFloat ( ) const {
55: return mType@var4 ==@expr1073744423 Type ::@expr1073744424 FLOAT ;
56: }
57:
58: double getDoubleValue ( ) const {
59: return isFloat (@expr1073744425 ) ?@expr1073744426 mDoubleValue@var3 :@expr1073744427 (@expr1073744428 double ) mIntValue@var2 ;
60: }
61:
62: static value calc ( char op@var8 , const value & v1@var9 , const value & v2@var10 ) ;
63: int compare ( const value & v@var11 ) const ;
64: value add ( int v@var12 ) const ;
65: value shiftLeft ( const value & v@var13 ) const ;
66: value shiftRight ( const value & v@var14 ) const ;
67: } ;
68:
69:
70:
71: static const int bigint_bits@var15 ;
72:
73: static long long toLongNumber ( const std :: string & str@var16 ) ;
74: static unsigned long long toULongNumber ( const std :: string & str@var17 ) ;
75:
76: template < class T > static std :: string toString ( T value@var18 ) {
77: std ::@expr1073744429 ostringstream result@var19 ;
78: result@var19 <<@expr1073744430 value@var18 ;
79: return result@var19 .@expr1073744431 str (@expr1073744432 ) ;
80: }
81: static double toDoubleNumber ( const std :: string & str@var20 ) ;
82:
83: static bool isInt ( const std :: string & str@var21 ) ;
84: static bool isFloat ( const std :: string & str@var22 ) ;
85: static bool isDecimalFloat ( const std :: string & str@var23 ) ;
86: static bool isNegative ( const std :: string & str@var24 ) ;
87: static bool isPositive ( const std :: string & str@var25 ) ;
88: static bool isDec ( const std :: string & str@var26 ) ;
89: static bool isFloatHex ( const std :: string & str@var27 ) ;
90: static bool isIntHex ( const std :: string & str@var28 ) ;
91: static bool isOct ( const std :: string & str@var29 ) ;
92: static bool isBin ( const std :: string & str@var30 ) ;
93:
94: static std :: string getSuffix ( const std :: string & value@var31 ) ;
95:
|
101:
102: static bool isValidIntegerSuffix ( const std :: string & str@var32 , bool supportMicrosoftExtensions@var33 = true ) ;
103:
104: static std :: string add ( const std :: string & first@var34 , const std :: string & second@var35 ) ;
105: static std :: string subtract ( const std :: string & first@var36 , const std :: string & second@var37 ) ;
106: static std :: string multiply ( const std :: string & first@var38 , const std :: string & second@var39 ) ;
107: static std :: string divide ( const std :: string & first@var40 , const std :: string & second@var41 ) ;
108: static std :: string mod ( const std :: string & first@var42 , const std :: string & second@var43 ) ;
109: static std :: string incdec ( const std :: string & var@var44 , const std :: string & op@var45 ) ;
110: static std :: string calculate ( const std :: string & first@var46 , const std :: string & second@var47 , char action@var48 ) ;
111:
112: static std :: string sin ( const std :: string & tok@var49 ) ;
113: static std :: string cos ( const std :: string & tok@var50 ) ;
114: static std :: string tan ( const std :: string & tok@var51 ) ;
115: static std :: string abs ( const std :: string & tok@var52 ) ;
116: static bool isEqual ( const std :: string & first@var53 , const std :: string & second@var54 ) ;
117: static bool isNotEqual ( const std :: string & first@var55 , const std :: string & second@var56 ) ;
118: static bool isGreater ( const std :: string & first@var57 , const std :: string & second@var58 ) ;
119: static bool isGreaterEqual ( const std :: string & first@var59 , const std :: string & second@var60 ) ;
120: static bool isLess ( const std :: string & first@var61 , const std :: string & second@var62 ) ;
121: static bool isLessEqual ( const std :: string & first@var63 , const std :: string & second@var64 ) ;
122: static bool isNullValue ( const std :: string & str@var65 ) ;
123:
|
127:
128: static bool isOctalDigit ( char c@var66 ) ;
129:
130: static unsigned int encodeMultiChar ( const std :: string & str@var67 ) ;
131:
|
136:
137: static bool isDigitSeparator ( const std :: string & iCode@var68 , std :: string :: size_type iPos@var69 ) ;
138: } ;
139:
140: MathLib :: value operator+ ( const MathLib :: value & v1@var70 , const MathLib :: value & v2@var71 ) ;
141: MathLib :: value operator- ( const MathLib :: value & v1@var72 , const MathLib :: value & v2@var73 ) ;
142: MathLib :: value operator* ( const MathLib :: value & v1@var74 , const MathLib :: value & v2@var75 ) ;
143: MathLib :: value operator/ ( const MathLib :: value & v1@var76 , const MathLib :: value & v2@var77 ) ;
144: MathLib :: value operator% ( const MathLib :: value & v1@var78 , const MathLib :: value & v2@var79 ) ;
145: MathLib :: value operator& ( const MathLib :: value & v1@var80 , const MathLib :: value & v2@var81 ) ;
146: MathLib :: value operator| ( const MathLib :: value & v1@var82 , const MathLib :: value & v2@var83 ) ;
147: MathLib :: value operator^ ( const MathLib :: value & v1@var84 , const MathLib :: value & v2@var85 ) ;
148: MathLib :: value operator<< ( const MathLib :: value & v1@var86 , const MathLib :: value & v2@var87 ) ;
149: MathLib :: value operator>> ( const MathLib :: value & v1@var88 , const MathLib :: value & v2@var89 ) ;
150:
151: template < > std :: string MathLib :: toString < double > ( double value@var90 ) ;

##file cppcheck-2.8/lib/valueflow.h

1:
|
36:
37: class ErrorLogger ;
38: struct InferModel ;
39: class Settings ;
40: class SymbolDatabase ;
41: class Token ;
42: class TokenList ;
43: class ValueType ;
44: class Variable ;
45: class Scope ;
46:
47: template < class T >
48: class ValuePtr ;
49:
50: namespace ValueFlow {
51: struct increment {
52: template < class T >
53: void operator() ( T & x@var91 ) const {
54: x@var91 ++@expr1073744433 ;
55: }
56: } ;
57: struct decrement {
58: template < class T >
59: void operator() ( T & x@var92 ) const {
60: x@var92 --@expr1073744434 ;
61: }
62: } ;
63:
64: struct less {
65: template < class T , class U >
66: bool operator() ( const T & x@var93 , const U & y@var94 ) const {
67: return x@var93 <@expr1073744435 y@var94 ;
68: }
69: } ;
70:
71: struct adjacent {
72: template < class T , class U >
73: bool operator() ( const T & x@var95 , const U & y@var96 ) const {
74: return std ::@expr1073744436 abs (@expr1073744437 x@var95 -@expr1073744438 y@var96 ) ==@expr1073744439 1 ;
75: }
76: } ;
77:
78: struct equalVisitor {
79: template < class T , class U >
80: void operator() ( bool & result@var97 , T x@var98 , U y@var99 ) const {
81: result@var97 =@expr1073744440 !@expr1073744441 (@expr1073744442 x@var98 >@expr1073744443 y@var99 ||@expr1073744444 x@var98 <@expr1073744445 y@var99 ) ;
82: }
83: } ;
84: class Value {
85: public:
86:
87:
88: enum class Bound { Upper , Lower , Point } ;
89:
90: explicit Value ( long long val@var100 = 0 , Bound b@var101 = Bound :: Point )
91: : valueType@var141 ( ValueType :: INT ) ,
92: bound@var142 ( b@var101 ) ,
93: intvalue@var143 ( val@var100 ) ,
94: tokvalue@var144 ( nullptr ) ,
95: floatValue@var145 ( 0.0 ) ,
96: moveKind@var146 ( MoveKind :: NonMovedVariable ) ,
97: varvalue@var147 ( val@var100 ) ,
98: condition@var148 ( nullptr ) ,
99: varId@var150 ( 0U ) ,
100: safe@var151 ( false ) ,
101: conditional@var152 ( false ) ,
102: macro@var153 ( false ) ,
103: defaultArg@var154 ( false ) ,
104: indirect@var155 ( 0 ) ,
105: path@var156 ( 0 ) ,
106: wideintvalue@var157 ( val@var100 ) ,
107: subexpressions@var158 ( ) ,
108: capturetok@var159 ( nullptr ) ,
109: lifetimeKind@var160 ( LifetimeKind :: Object ) ,
110: lifetimeScope@var161 ( LifetimeScope :: Local ) ,
111: valueKind@var166 ( ValueKind :: Possible )
112: { }
113: Value ( const Token * c@var102 , long long val@var103 , Bound b@var104 = Bound :: Point ) ;
114:
115: static Value unknown ( ) ;
116:
117: bool equalValue ( const ValueFlow :: Value & rhs@var105 ) const {
118: if (@expr1073744446 valueType@var141 !=@expr1073744447 rhs@var105 .@expr1073744448 valueType@var106 ) {
119: return false ; }
120: switch (@expr1073744449 valueType@var141 ) {
121: case ValueType ::@expr1073744450 INT :@expr2627
122: case ValueType ::@expr1073744452 CONTAINER_SIZE :@expr2627
123: case ValueType ::@expr1073744454 BUFFER_SIZE :@expr2627
124: case ValueType ::@expr1073744456 ITERATOR_START :@expr2627
125: case ValueType ::@expr1073744458 ITERATOR_END :@expr2627 ;
126: if (@expr2636 intvalue@var143 !=@expr2637 rhs@var105 .@expr2638 intvalue@var107 ) {
127: return false ; }
128: break ;
129: case ValueType ::@expr1073744463 TOK :@expr2627 ;
130: if (@expr2641 tokvalue@var144 !=@expr2642 rhs@var105 .@expr2643 tokvalue@var108 ) {
131: return false ; }
132: break ;
133: case ValueType ::@expr1073744468 FLOAT :@expr2627 ;
134:
135: if (@expr1073744470 floatValue@var145 >@expr1073744471 rhs@var105 .@expr2648 floatValue@var109 ||@expr1073744473 floatValue@var145 <@expr1073744474 rhs@var105 .@expr2648 floatValue@var109 ) {
136: return false ; }
137: break ;
138: case ValueType ::@expr1073744476 MOVED :@expr2627 ;
139: if (@expr1073744478 moveKind@var146 !=@expr1073744479 rhs@var105 .@expr1073744480 moveKind@var110 ) {
140: return false ; }
141: break ;
142: case ValueType ::@expr1073744481 UNINIT :@expr2627 ;
143: break ;
144: case ValueType ::@expr1073744483 LIFETIME :@expr2627 ;
145: if (@expr2641 tokvalue@var144 !=@expr2642 rhs@var105 .@expr2643 tokvalue@var108 ) {
146: return false ; }
147: break ;
148: case ValueType ::@expr1073744488 SYMBOLIC :@expr2627 ;
149: if (@expr1073744490 !@expr1073744491 sameToken (@expr1073744492 tokvalue@var144 , rhs@var105 .@expr2643 tokvalue@var108 ) ) {
150: return false ; }
151: if (@expr2636 intvalue@var143 !=@expr2637 rhs@var105 .@expr2638 intvalue@var107 ) {
152: return false ; }
153: break ;
154: }
155: return true ;
156: }
157:
158: template < class T , class F >
159: static void visitValue ( T & self@var111 , F f@var112 ) {
160: switch (@expr1073744497 self@var111 .@expr1073744498 valueType@var113 ) {
161: case ValueType ::@expr1073744499 INT :@expr2676
162: case ValueType ::@expr1073744501 SYMBOLIC :@expr2676
163: case ValueType ::@expr1073744503 BUFFER_SIZE :@expr2676
164: case ValueType ::@expr1073744505 CONTAINER_SIZE :@expr2676
165: case ValueType ::@expr1073744507 ITERATOR_START :@expr2676
166: case ValueType ::@expr1073744509 ITERATOR_END :@expr2676 ; {
167: f@var112 (@expr1073744511 self@var111 .@expr1073744512 intvalue@var114 ) ;
168: break ;
169: }
170: case ValueType ::@expr1073744513 FLOAT :@expr2676 ; {
171: f@var112 (@expr1073744515 self@var111 .@expr1073744516 floatValue@var115 ) ;
172: break ;
173: }
174: case ValueType ::@expr1073744517 UNINIT :@expr2676
175: case ValueType ::@expr1073744519 TOK :@expr2676
176: case ValueType ::@expr1073744521 LIFETIME :@expr2676
177: case ValueType ::@expr1073744523 MOVED :@expr2676 ;
178: break ;
179: }
180: }
181:
182: struct compareVisitor {
183: struct innerVisitor {
184: template < class Compare , class T , class U >
185: void operator() ( bool & result@var116 , Compare compare@var117 , T x@var118 , U y@var119 ) const {
186: result@var116 =@expr1073744525 compare@var117 (@expr1073744526 x@var118 , y@var119 ) ;
187: }
188: } ;
189: template < class Compare , class T >
190: void operator() ( bool & result@var120 , const Value & rhs@var121 , Compare compare@var122 , T x@var123 ) const {
191: visitValue (@expr1073744528 rhs@var121 ,
192: std ::@expr1073744529 bind (@expr1073744530 innerVisitor {@expr1073744531 } , std ::@expr1073744532 ref (@expr1073744533 result@var120 ) , std ::@expr1073744534 move (@expr1073744535 compare@var122 ) , x@var123 , std ::@expr1073744536 placeholders ::@expr1073744537 _1@expr1073744527 ) ) ;
193: }
194: } ;
195:
196: template < class Compare >
197: bool compareValue ( const Value & rhs@var124 , Compare compare@var125 ) const {
198: assert (@expr1073744539 (@expr1073744540 !@expr1073744541 this@expr2718 .@expr1073744543 isSymbolicValue (@expr1073744544 ) &&@expr1073744545 !@expr1073744546 rhs@var124 .@expr1073744547 isSymbolicValue (@expr1073744548 ) ) ||@expr1073744549
199: (@expr1073744550 this@expr2718 .@expr1073744551 valueType@var141 ==@expr1073744552 rhs@var124 .@expr1073744553 valueType@var126 &&@expr1073744554 sameToken (@expr1073744555 this@expr2718 .@expr1073744556 tokvalue@var144 , rhs@var124 .@expr1073744557 tokvalue@var127 ) ) ) ;
200: bool result@var128 ; result@var128 =@expr1073744558 false ;
201: visitValue (@expr1073744559
202: *@expr1073744560 this@expr2718 ,
203: std ::@expr1073744561 bind (@expr1073744562 compareVisitor {@expr1073744563 } , std ::@expr2740 ref (@expr1073744565 result@var128 ) , std ::@expr2740 ref (@expr1073744567 rhs@var124 ) , std ::@expr1073744568 move (@expr1073744569 compare@var125 ) , std ::@expr1073744570 placeholders ::@expr1073744571 _1@expr1073744538 ) ) ;
204: return result@var128 ;
205: }
206:
207: bool operator== ( const Value & rhs@var129 ) const {
208: if (@expr1073744572 !@expr1073744573 equalValue (@expr1073744574 rhs@var129 ) ) {
209: return false ; }
210:
211: return varvalue@var147 ==@expr1073744575 rhs@var129 .@expr1073744576 varvalue@var130 &&@expr1073744577
212: condition@var148 ==@expr1073744578 rhs@var129 .@expr1073744579 condition@var131 &&@expr1073744580
213: varId@var150 ==@expr1073744581 rhs@var129 .@expr1073744582 varId@var132 &&@expr1073744583
214: conditional@var152 ==@expr1073744584 rhs@var129 .@expr1073744585 conditional@var133 &&@expr1073744586
215: defaultArg@var154 ==@expr1073744587 rhs@var129 .@expr1073744588 defaultArg@var134 &&@expr1073744589
216: indirect@var155 ==@expr1073744590 rhs@var129 .@expr1073744591 indirect@var135 &&@expr1073744592
217: valueKind@var166 ==@expr1073744593 rhs@var129 .@expr1073744594 valueKind@var136 ;
218: }
219:
220: bool operator!= ( const Value & rhs@var137 ) const {
221: return !@expr1073744595 (@expr1073744596 *@expr1073744597 this@expr1073744598 ==@expr1073744599 rhs@var137 ) ;
222: }
223:
224: template < class T , $class $= $typename $std $:: $enable_if $< std :: is_arithmetic < T > $:: $value $> $:: $type >
225: bool equalTo ( const T & x@var138 ) const {
226: bool result@var139 ; result@var139 =@expr1073744601 false ;
227: visitValue (@expr1073744602 *@expr1073744603 this@expr1073744604 , std ::@expr1073744605 bind (@expr1073744606 equalVisitor {@expr1073744607 } , std ::@expr1073744608 ref (@expr1073744609 result@var139 ) , x@var138 , std ::@expr1073744610 placeholders ::@expr1073744611 _1@expr1073744600 ) ) ;
228: return result@var139 ;
229: }
230:
231: void decreaseRange ( ) {
232: if (@expr1073744612 bound@var142 ==@expr1073744613 Bound ::@expr1073744614 Lower ) {
233: visitValue (@expr1073744615 *@expr2792 this@expr2793 , increment {@expr1073744618 } ) ; }
234: else { if (@expr1073744619 bound@var142 ==@expr1073744620 Bound ::@expr1073744621 Upper ) {
235: visitValue (@expr1073744622 *@expr2792 this@expr2793 , decrement {@expr1073744624 } ) ; } }
236: }
237:
238: void invertBound ( ) {
239: if (@expr1073744625 bound@var142 ==@expr1073744626 Bound ::@expr2803 Lower ) {
240: bound@var142 =@expr1073744628 Bound ::@expr2805 Upper ; }
241: else { if (@expr1073744630 bound@var142 ==@expr1073744631 Bound ::@expr2805 Upper ) {
242: bound@var142 =@expr1073744633 Bound ::@expr2803 Lower ; } }
243: }
244:
245: void invertRange ( ) {
246: invertBound (@expr1073744635 ) ;
247: decreaseRange (@expr1073744636 ) ;
248: }
249:
250: void assumeCondition ( const Token * tok@var140 ) ;
251:
252: std :: string infoString ( ) const ;
253:
254: enum class ValueType {
255: INT ,
256: TOK ,
257: FLOAT ,
258: MOVED ,
259: UNINIT ,
260: CONTAINER_SIZE ,
261: LIFETIME ,
262: BUFFER_SIZE ,
263: ITERATOR_START ,
264: ITERATOR_END ,
265: SYMBOLIC
266: } ; enum ValueType valueType@var141 ;
267: bool isIntValue ( ) const {
268: return valueType@var141 ==@expr1073744637 ValueType ::@expr1073744638 INT ;
269: }
270: bool isTokValue ( ) const {
271: return valueType@var141 ==@expr1073744639 ValueType ::@expr1073744640 TOK ;
272: }
273: bool isFloatValue ( ) const {
274: return valueType@var141 ==@expr1073744641 ValueType ::@expr1073744642 FLOAT ;
275: }
276: bool isMovedValue ( ) const {
277: return valueType@var141 ==@expr1073744643 ValueType ::@expr1073744644 MOVED ;
278: }
279: bool isUninitValue ( ) const {
280: return valueType@var141 ==@expr1073744645 ValueType ::@expr1073744646 UNINIT ;
281: }
282: bool isContainerSizeValue ( ) const {
283: return valueType@var141 ==@expr1073744647 ValueType ::@expr1073744648 CONTAINER_SIZE ;
284: }
285: bool isLifetimeValue ( ) const {
286: return valueType@var141 ==@expr1073744649 ValueType ::@expr1073744650 LIFETIME ;
287: }
288: bool isBufferSizeValue ( ) const {
289: return valueType@var141 ==@expr1073744651 ValueType ::@expr1073744652 BUFFER_SIZE ;
290: }
291: bool isIteratorValue ( ) const {
292: return valueType@var141 ==@expr1073744653 ValueType ::@expr1073744654 ITERATOR_START ||@expr1073744655 valueType@var141 ==@expr1073744656 ValueType ::@expr1073744657 ITERATOR_END ;
293: }
294: bool isIteratorStartValue ( ) const {
295: return valueType@var141 ==@expr1073744658 ValueType ::@expr1073744659 ITERATOR_START ;
296: }
297: bool isIteratorEndValue ( ) const {
298: return valueType@var141 ==@expr1073744660 ValueType ::@expr1073744661 ITERATOR_END ;
299: }
300: bool isSymbolicValue ( ) const {
301: return valueType@var141 ==@expr1073744662 ValueType ::@expr1073744663 SYMBOLIC ;
302: }
303:
304: bool isLocalLifetimeValue ( ) const {
305: return valueType@var141 ==@expr1073744665 ValueType ::@expr1073744666 LIFETIME &&@expr1073744667 lifetimeScope@var161 ==@expr1073744668 LifetimeScope ::@expr1073744669 Local@expr1073744664 ;
306: }
307:
308: bool isArgumentLifetimeValue ( ) const {
309: return valueType@var141 ==@expr1073744670 ValueType ::@expr1073744671 LIFETIME &&@expr1073744672 lifetimeScope@var161 ==@expr1073744673 LifetimeScope ::@expr1073744674 Argument ;
310: }
311:
312: bool isSubFunctionLifetimeValue ( ) const {
313: return valueType@var141 ==@expr1073744675 ValueType ::@expr1073744676 LIFETIME &&@expr1073744677 lifetimeScope@var161 ==@expr1073744678 LifetimeScope ::@expr1073744679 SubFunction ;
314: }
315:
316: bool isNonValue ( ) const {
317: return isMovedValue (@expr1073744680 ) ||@expr1073744681 isUninitValue (@expr1073744682 ) ||@expr1073744683 isLifetimeValue (@expr1073744684 ) ;
318: }
319:
320:
321: Bound bound@var142 ;
322:
323:
324: long long intvalue@var143 ;
325:
326:
327: const Token * tokvalue@var144 ;
328:
329:
330: double floatValue@var145 ;
331:
332:
333: enum class MoveKind { NonMovedVariable , MovedVariable , ForwardedVariable } ; enum MoveKind moveKind@var146 ;
334:
335:
336: long long varvalue@var147 ;
337:
338:
339: const Token * condition@var148 ;
340:
341: std :: list < std :: pair < const Token * , std :: string > > errorPath@var149 ;
342:
343:
344: int varId@var150 ;
345:
346:
347: bool safe@var151 ;
348:
349:
350: bool conditional@var152 ;
351:
352:
353: bool macro@var153 ;
354:
355:
356: bool defaultArg@var154 ;
357:
358: int indirect@var155 ;
359:
360:
361: long long path@var156 ;
362:
363:
364: long long wideintvalue@var157 ;
365:
366: std :: vector < std :: string > subexpressions@var158 ;
367:
368:
369: const Token * capturetok@var159 ;
370:
371: enum class LifetimeKind {
372:
373: Object ,
374:
375: SubObject ,
376:
377: Lambda ,
378:
379: Iterator ,
380:
381: Address
382: } ; enum LifetimeKind lifetimeKind@var160 ;
383:
384: enum class LifetimeScope { Local , Argument , SubFunction , ThisPointer , ThisValue } ; enum LifetimeScope lifetimeScope@var161 ;
385:
386: static const char * toString ( MoveKind moveKind@var162 ) ;
387: static const char * toString ( LifetimeKind lifetimeKind@var163 ) ;
388: static const char * toString ( LifetimeScope lifetimeScope@var164 ) ;
389: static const char * toString ( Bound bound@var165 ) ;
390:
391:
392: enum class ValueKind {
393:
394: Possible ,
395:
396: Known ,
397:
398: Inconclusive ,
399:
400: Impossible
401: } ; enum ValueKind valueKind@var166 ;
402:
403: void setKnown ( ) {
404: valueKind@var166 =@expr1073744685 ValueKind ::@expr1073744686 Known ;
405: }
406:
407: bool isKnown ( ) const {
408: return valueKind@var166 ==@expr1073744687 ValueKind ::@expr1073744688 Known ;
409: }
410:
411: void setPossible ( ) {
412: valueKind@var166 =@expr1073744690 ValueKind ::@expr1073744691 Possible@expr1073744689 ;
413: }
414:
415: bool isPossible ( ) const {
416: return valueKind@var166 ==@expr1073744693 ValueKind ::@expr1073744694 Possible@expr1073744692 ;
417: }
418:
419: bool isImpossible ( ) const {
420: return valueKind@var166 ==@expr1073744695 ValueKind ::@expr1073744696 Impossible ;
421: }
422:
423: void setImpossible ( ) {
424: valueKind@var166 =@expr1073744697 ValueKind ::@expr1073744698 Impossible ;
425: }
426:
427: void setInconclusive ( bool inconclusive@var167 = true ) {
428: if (@expr1073744699 inconclusive@var167 ) {
429: valueKind@var166 =@expr1073744700 ValueKind ::@expr1073744701 Inconclusive ; }
430: }
431:
432: bool isInconclusive ( ) const {
433: return valueKind@var166 ==@expr1073744702 ValueKind ::@expr1073744703 Inconclusive ;
434: }
435:
436: void changeKnownToPossible ( ) {
437: if (@expr1073744705 isKnown (@expr1073744706 ) ) {
438: valueKind@var166 =@expr1073744707 ValueKind ::@expr1073744708 Possible@expr1073744704 ; }
439: }
440:
441: bool errorSeverity ( ) const {
442: return !@expr1073744709 condition@var148 &&@expr1073744710 !@expr1073744711 defaultArg@var154 ;
443: }
444:
445: static bool sameToken ( const Token * tok1@var168 , const Token * tok2@var169 ) ;
446: } ;
447:
448:
449: const ValueFlow :: Value * valueFlowConstantFoldAST ( Token * expr@var170 , const Settings * settings@var171 ) ;
450:
451:
452: void setValues ( TokenList * tokenlist@var172 , SymbolDatabase * symboldatabase@var173 , ErrorLogger * errorLogger@var174 , const Settings * settings@var175 ) ;
453:
454: std :: string eitherTheConditionIsRedundant ( const Token * condition@var176 ) ;
455:
456: unsigned long getSizeOf ( const ValueType & vt@var177 , const Settings * settings@var178 ) ;
457:
458: const ValueFlow :: Value * findValue ( const std :: list < ValueFlow :: Value > & values@var179 ,
459: const Settings * settings@var180 ,
460: std :: function < bool ( const ValueFlow :: Value & ) > pred@var181 ) ;
461:
462: std :: vector < ValueFlow :: Value > isOutOfBounds ( const Value & size@var182 , const Token * indexTok@var183 , bool possible@var184 = true ) ;
463: }
464:
465: ValueFlow :: Value asImpossible ( ValueFlow :: Value v@var185 ) ;
466:
467: bool isContainerSizeChanged ( const Token * tok@var186 , const Settings * settings@var187 = nullptr , int depth@var188 = 20 ) ;
468:
469: struct LifetimeToken {
470: const Token * token@var189 ;
471: bool addressOf@var190 ;
472: ValueFlow :: Value :: ErrorPath errorPath@var191 ;
473: bool inconclusive@var192 ;
474:
475: LifetimeToken ( ) : token@var189 ( nullptr ) , addressOf@var190 ( false ) , errorPath@var191 ( ) , inconclusive@var192 ( false ) { }
476:
477: LifetimeToken ( const Token * token@var193 , ValueFlow :: Value :: ErrorPath errorPath@var194 )
478: : token@var189 ( token@var193 ) , addressOf@var190 ( false ) , errorPath@var191 ( std :: move ( errorPath@var194 ) ) , inconclusive@var192 ( false )
479: { }
480:
481: LifetimeToken ( const Token * token@var195 , bool addressOf@var196 , ValueFlow :: Value :: ErrorPath errorPath@var197 )
482: : token@var189 ( token@var195 ) , addressOf@var190 ( addressOf@var196 ) , errorPath@var191 ( std :: move ( errorPath@var197 ) ) , inconclusive@var192 ( false )
483: { }
484:
485: static std :: vector < LifetimeToken > setAddressOf ( std :: vector < LifetimeToken > v@var198 , bool b@var199 ) {
486: for (@expr1073744712 LifetimeToken &@expr1073744713 x@var200 :@expr1073744714 v@var198 ) {
487: x@var200 .@expr1073744715 addressOf@var201 =@expr1073744716 b@var199 ; }
488: return v@var198 ;
489: }
490:
491: static std :: vector < LifetimeToken > setInconclusive ( std :: vector < LifetimeToken > v@var202 , bool b@var203 ) {
492: for (@expr1073744717 LifetimeToken &@expr1073744718 x@var204 :@expr1073744719 v@var202 ) {
493: x@var204 .@expr1073744720 inconclusive@var205 =@expr1073744721 b@var203 ; }
494: return v@var202 ;
495: }
496: } ;
497:
498: const Token * parseCompareInt ( const Token * tok@var206 , ValueFlow :: Value & true_value@var207 , ValueFlow :: Value & false_value@var208 , const std :: function < std :: vector < long long > ( const Token * ) > & evaluate@var209 ) ;
499: const Token * parseCompareInt ( const Token * tok@var210 , ValueFlow :: Value & true_value@var211 , ValueFlow :: Value & false_value@var212 ) ;
500:
501: ValueFlow :: Value inferCondition ( std :: string op@var213 , long long val@var214 , const Token * varTok@var215 ) ;
502: ValueFlow :: Value inferCondition ( const std :: string & op@var216 , const Token * varTok@var217 , long long val@var218 ) ;
503:
504: ValuePtr < InferModel > makeIntegralInferModel ( ) ;
505:
506: const Token * solveExprValue ( const Token * expr@var219 ,
507: const std :: function < std :: vector < long long > ( const Token * ) > & eval@var220 ,
508: ValueFlow :: Value & value@var221 ) ;
509:
510: std :: vector < LifetimeToken > getLifetimeTokens ( const Token * tok@var222 ,
511: bool escape@var223 = false ,
512: ValueFlow :: Value :: ErrorPath errorPath@var224 = ValueFlow :: Value :: ErrorPath { } ) ;
513:
514: bool hasLifetimeToken ( const Token * tok@var225 , const Token * lifetime@var226 ) ;
515:
516: const Variable * getLifetimeVariable ( const Token * tok@var227 , ValueFlow :: Value :: ErrorPath & errorPath@var228 , bool * addressOf@var229 = nullptr ) ;
517:
518: const Variable * getLifetimeVariable ( const Token * tok@var230 ) ;
519:
520: bool isLifetimeBorrowed ( const Token * tok@var231 , const Settings * settings@var232 ) ;
521:
522: std :: string lifetimeType ( const Token * tok@var233 , const ValueFlow :: Value * val@var234 ) ;
523:
524: std :: string lifetimeMessage ( const Token * tok@var235 , const ValueFlow :: Value * val@var236 , ValueFlow :: Value :: ErrorPath & errorPath@var237 ) ;
525:
526: ValueFlow :: Value getLifetimeObjValue ( const Token * tok@var238 , bool inconclusive@var239 = false ) ;
527:
528: std :: vector < ValueFlow :: Value > getLifetimeObjValues ( const Token * tok@var240 ,
529: bool inconclusive@var241 = false ,
530: long long path@var242 = 0 ) ;
531:
532: const Token * getEndOfExprScope ( const Token * tok@var243 , const Scope * defaultScope@var244 = nullptr , bool smallest@var245 = true ) ;

##file cppcheck-2.8/lib/templatesimplifier.h

1:
|
34:
35: class ErrorLogger ;
36: class Settings ;
37: class Token ;
38: class Tokenizer ;
39: class TokenList ;
40:
|
44:
45: class TemplateSimplifier {
46: friend class TestSimplifyTemplate ;
47:
48: public:
49: explicit TemplateSimplifier ( Tokenizer * tokenizer@var246 ) ;
50: ~ TemplateSimplifier ( ) ;
51:
52:
53:
54: void checkComplicatedSyntaxErrorsInTemplates ( ) ;
55:
|
61:
62: static unsigned int templateParameters ( const Token * tok@var247 ) ;
63:
|
66:
67: class TokenAndName {
68: Token * mToken@var248 ;
69: std :: string mScope@var249 ;
70: std :: string mName@var250 ;
71: std :: string mFullName@var251 ;
72: const Token * mNameToken@var252 ;
73: const Token * mParamEnd@var253 ;
74: unsigned int mFlags@var254 ;
75:
76: enum Anonymous0 {
77: fIsClass = ( 1 << 0 ) ,
78: fIsFunction = ( 1 << 1 ) ,
79: fIsVariable = ( 1 << 2 ) ,
80: fIsAlias = ( 1 << 3 ) ,
81: fIsSpecialization = ( 1 << 4 ) ,
82: fIsPartialSpecialization = ( 1 << 5 ) ,
83: fIsForwardDeclaration = ( 1 << 6 ) ,
84: fIsVariadic = ( 1 << 7 ) ,
85: fIsFriend = ( 1 << 8 ) ,
86: fFamilyMask = ( fIsClass | fIsFunction | fIsVariable )
87: } ;
88:
89: void isClass ( bool state@var255 ) {
90: setFlag (@expr1073744722 fIsClass , state@var255 ) ;
91: }
92: void isFunction ( bool state@var256 ) {
93: setFlag (@expr1073744723 fIsFunction , state@var256 ) ;
94: }
95: void isVariable ( bool state@var257 ) {
96: setFlag (@expr1073744724 fIsVariable , state@var257 ) ;
97: }
98: void isAlias ( bool state@var258 ) {
99: setFlag (@expr1073744725 fIsAlias , state@var258 ) ;
100: }
101: void isSpecialization ( bool state@var259 ) {
102: setFlag (@expr1073744726 fIsSpecialization , state@var259 ) ;
103: }
104: void isPartialSpecialization ( bool state@var260 ) {
105: setFlag (@expr1073744727 fIsPartialSpecialization , state@var260 ) ;
106: }
107: void isForwardDeclaration ( bool state@var261 ) {
108: setFlag (@expr1073744728 fIsForwardDeclaration , state@var261 ) ;
109: }
110: void isVariadic ( bool state@var262 ) {
111: setFlag (@expr1073744729 fIsVariadic , state@var262 ) ;
112: }
113: void isFriend ( bool state@var263 ) {
114: setFlag (@expr1073744730 fIsFriend , state@var263 ) ;
115: }
116:
|
121:
122: bool getFlag ( unsigned int flag@var264 ) const {
123: return (@expr2907 (@expr2907 mFlags@var254 &@expr1073744733 flag@var264 ) !=@expr1073744734 0 ) ;
124: }
125:
|
130:
131: void setFlag ( unsigned int flag@var265 , bool state@var266 ) {
132: mFlags@var254 =@expr1073744735 state@var266 ?@expr1073744736 mFlags@var254 |@expr1073744737 flag@var265 :@expr1073744738 mFlags@var254 &@expr1073744739 ~@expr1073744740 flag@var265 ;
133: }
134:
135: public:
136:
|
140:
141: TokenAndName ( Token * token@var267 , const std :: string & scope@var268 ) ;
142:
|
148:
149: TokenAndName ( Token * token@var269 , const std :: string & scope@var270 , const Token * nameToken@var271 , const Token * paramEnd@var272 ) ;
150: TokenAndName ( const TokenAndName & other@var273 ) ;
151: ~ TokenAndName ( ) ;
152:
153: bool operator== ( const TokenAndName & rhs@var274 ) const {
154: return mToken@var248 ==@expr1073744741 rhs@var274 .@expr1073744742 mToken@var275 &&@expr1073744743 mScope@var249 ==@expr1073744744 rhs@var274 .@expr1073744745 mScope@var276 &&@expr1073744746 mName@var250 ==@expr1073744747 rhs@var274 .@expr1073744748 mName@var277 &&@expr1073744749 mFullName@var251 ==@expr1073744750 rhs@var274 .@expr1073744751 mFullName@var278 &&@expr1073744752
155: mNameToken@var252 ==@expr1073744753 rhs@var274 .@expr1073744754 mNameToken@var279 &&@expr1073744755 mParamEnd@var253 ==@expr1073744756 rhs@var274 .@expr1073744757 mParamEnd@var280 &&@expr1073744758 mFlags@var254 ==@expr1073744759 rhs@var274 .@expr1073744760 mFlags@var281 ;
156: }
157:
158: Token * token ( ) const {
159: return mToken@var248 ;
160: }
161: void token ( Token * token@var282 ) {
162: mToken@var248 =@expr1073744761 token@var282 ;
163: }
164: const std :: string & scope ( ) const {
165: return mScope@var249 ;
166: }
167: const std :: string & name ( ) const {
168: return mName@var250 ;
169: }
170: const std :: string & fullName ( ) const {
171: return mFullName@var251 ;
172: }
173: const Token * nameToken ( ) const {
174: return mNameToken@var252 ;
175: }
176: const Token * paramEnd ( ) const {
177: return mParamEnd@var253 ;
178: }
179: void paramEnd ( const Token * end@var283 ) {
180: mParamEnd@var253 =@expr1073744762 end@var283 ;
181: }
182:
183: bool isClass ( ) const {
184: return getFlag (@expr1073744763 fIsClass ) ;
185: }
186: bool isFunction ( ) const {
187: return getFlag (@expr1073744764 fIsFunction ) ;
188: }
189: bool isVariable ( ) const {
190: return getFlag (@expr1073744765 fIsVariable ) ;
191: }
192: bool isAlias ( ) const {
193: return getFlag (@expr1073744766 fIsAlias ) ;
194: }
195: bool isSpecialization ( ) const {
196: return getFlag (@expr1073744767 fIsSpecialization ) ;
197: }
198: bool isPartialSpecialization ( ) const {
199: return getFlag (@expr1073744768 fIsPartialSpecialization ) ;
200: }
201: bool isForwardDeclaration ( ) const {
202: return getFlag (@expr1073744769 fIsForwardDeclaration ) ;
203: }
204: bool isVariadic ( ) const {
205: return getFlag (@expr1073744770 fIsVariadic ) ;
206: }
207: bool isFriend ( ) const {
208: return getFlag (@expr1073744771 fIsFriend ) ;
209: }
210:
|
216:
217: const Token * aliasStartToken ( ) const ;
218:
|
224:
225: const Token * aliasEndToken ( ) const ;
226:
|
233:
234: bool isAliasToken ( const Token * tok@var284 ) const ;
235:
|
241:
242: bool isSameFamily ( const TemplateSimplifier :: TokenAndName & decl@var285 ) const {
243:
244:
245: return (@expr2948 (@expr2948 mFlags@var254 &@expr1073744774 fFamilyMask ) &@expr1073744775 (@expr2948 decl@var285 .@expr1073744777 mFlags@var286 &@expr1073744778 fFamilyMask ) ) !=@expr1073744779 0 ;
246: }
247: } ;
248:
|
253:
254: static Token * findTemplateDeclarationEnd ( Token * tok@var287 ) ;
255: static const Token * findTemplateDeclarationEnd ( const Token * tok@var288 ) ;
256:
|
264:
265: static bool instantiateMatch ( const Token * instance@var289 , const unsigned long numberOfArguments@var290 , bool variadic@var291 , const char patternAfter@var292 [ ] ) ;
266:
|
272:
273: int getTemplateNamePosition ( const Token * tok@var293 ) ;
274:
|
280:
281: static bool getTemplateNamePositionTemplateClass ( const Token * tok@var294 , int & namepos@var295 ) ;
282:
|
288:
289: static bool getTemplateNamePositionTemplateFunction ( const Token * tok@var296 , int & namepos@var297 ) ;
290:
|
296:
297: static bool getTemplateNamePositionTemplateVariable ( const Token * tok@var298 , int & namepos@var299 ) ;
298:
|
303:
304: void simplifyTemplates (
305: const std :: time_t maxtime@var300 ,
306: bool & codeWithTemplates@var301 ) ;
307:
|
313:
314: static bool simplifyNumericCalculations ( Token * tok@var302 , bool isTemplate@var303 = true ) ;
315:
|
321:
322: bool simplifyCalculations ( Token * frontToken@var304 = nullptr , Token * backToken@var305 = nullptr , bool isTemplate@var306 = true ) ;
323:
|
327:
328: void simplifyTemplateArgs ( Token * start@var307 , Token * end@var308 ) ;
329:
330: private:
331:
|
334:
335: bool getTemplateDeclarations ( ) ;
336:
|
340:
341: void addInstantiation ( Token * token@var309 , const std :: string & scope@var310 ) ;
342:
|
345:
346: void getTemplateInstantiations ( ) ;
347:
|
351:
352: void fixForwardDeclaredDefaultArgumentValues ( ) ;
353:
|
356:
357: void useDefaultArgumentValues ( ) ;
358:
|
362:
363: void useDefaultArgumentValues ( TokenAndName & declaration@var311 ) ;
364:
|
368:
369: void getSpecializations ( ) ;
370:
|
374:
375: void getPartialSpecializations ( ) ;
376:
|
379:
380: void simplifyTemplateAliases ( ) ;
381:
|
390:
391: bool simplifyTemplateInstantiations (
392: const TokenAndName & templateDeclaration@var312 ,
393: const std :: list < const Token * > & specializations@var313 ,
394: const std :: time_t maxtime@var314 ,
395: std :: set < std :: string > & expandedtemplates@var315 ) ;
396:
|
401:
402: void addNamespace ( const TokenAndName & templateDeclaration@var316 , const Token * tok@var317 ) ;
403:
|
409:
410: static bool alreadyHasNamespace ( const TokenAndName & templateDeclaration@var318 , const Token * tok@var319 ) ;
411:
|
419:
420: void expandTemplate (
421: const TokenAndName & templateDeclaration@var320 ,
422: const TokenAndName & templateInstantiation@var321 ,
423: const std :: vector < const Token * > & typeParametersInDeclaration@var322 ,
424: const std :: string & newName@var323 ,
425: bool copy@var324 ) ;
426:
|
432:
433: void replaceTemplateUsage ( const TokenAndName & instantiation@var325 ,
434: const std :: list < std :: string > & typeStringsUsedInTemplateInstantiation@var326 ,
435: const std :: string & newName@var327 ) ;
436:
|
443:
444: static void getTemplateParametersInDeclaration (
445: const Token * tok@var328 ,
446: std :: vector < const Token * > & typeParametersInDeclaration@var329 ) ;
447:
|
450:
451: static bool removeTemplate ( Token * tok@var330 ) ;
452:
453:
454: static void syntaxError ( const Token * tok@var331 ) ;
455:
456: static bool matchSpecialization (
457: const Token * templateDeclarationNameToken@var332 ,
458: const Token * templateInstantiationNameToken@var333 ,
459: const std :: list < const Token * > & specializations@var334 ) ;
460:
|
465:
466: static void eraseTokens ( Token * begin@var335 , const Token * end@var336 ) ;
467:
|
472:
473: static void deleteToken ( Token * tok@var337 ) ;
474:
|
480:
481: std :: string getNewName (
482: Token * tok2@var338 ,
483: std :: list < std :: string > & typeStringsUsedInTemplateInstantiation@var339 ) ;
484:
485: void printOut (
486: const TokenAndName & tokenAndName@var340 ,
487: const std :: string & indent@var341 = "    " ) const ;
488: void printOut ( const std :: string & text@var342 = "" ) const ;
489:
490: Tokenizer * mTokenizer@var343 ;
491: TokenList & mTokenList@var344 ;
492: const Settings * mSettings@var345 ;
493: ErrorLogger * mErrorLogger@var346 ;
494: bool mChanged@var347 ;
495:
496: std :: list < TokenAndName > mTemplateDeclarations@var348 ;
497: std :: list < TokenAndName > mTemplateForwardDeclarations@var349 ;
498: std :: map < Token * , Token * > mTemplateForwardDeclarationsMap@var350 ;
499: std :: map < Token * , Token * > mTemplateSpecializationMap@var351 ;
500: std :: map < Token * , Token * > mTemplatePartialSpecializationMap@var352 ;
501: std :: list < TokenAndName > mTemplateInstantiations@var353 ;
502: std :: list < TokenAndName > mInstantiatedTemplates@var354 ;
503: std :: list < TokenAndName > mMemberFunctionsToDelete@var355 ;
504: std :: vector < TokenAndName > mExplicitInstantiationsToDelete@var356 ;
505: std :: vector < TokenAndName > mTypesUsedInTemplateInstantiation@var357 ;
506: std :: unordered_map < const Token * , int > mTemplateNamePos@var358 ;
507: } ;

##file cppcheck-2.8/lib/utils.h

1:
|
31:
32: struct SelectMapKeys {
33: template < class Pair >
34: Pair :: first_type operator() ( const Pair & p@var359 ) const {
35: return p@var359 .@expr1073744780 first@var360 ;
36: }
37: } ;
38:
39: struct SelectMapValues {
40: template < class Pair >
41: Pair :: second_type operator() ( const Pair & p@var361 ) const {
42: return p@var361 .@expr1073744781 second@var362 ;
43: }
44: } ;
45:
46: template < class Range , class T >
47: bool contains ( const Range & r@var363 , const T & x@var364 )
48: {
49: return std ::@expr1073744782 find (@expr1073744783 r@var363 .@expr1073744784 begin (@expr1073744785 ) , r@var363 .@expr2962 end (@expr2963 ) , x@var364 ) !=@expr1073744788 r@var363 .@expr2962 end (@expr2963 ) ;
50: }
51:
52: template < class T >
53: bool contains ( const std :: initializer_list < T > & r@var365 , const T & x@var366 )
54: {
55: return std ::@expr1073744791 find (@expr1073744792 r@var365 .@expr1073744793 begin (@expr1073744794 ) , r@var365 .@expr2971 end (@expr2972 ) , x@var366 ) !=@expr1073744797 r@var365 .@expr2971 end (@expr2972 ) ;
56: }
57:
58: template < class T , class U >
59: bool contains ( const std :: initializer_list < T > & r@var367 , const U & x@var368 )
60: {
61: return std ::@expr1073744800 find (@expr1073744801 r@var367 .@expr1073744802 begin (@expr1073744803 ) , r@var367 .@expr2980 end (@expr2981 ) , x@var368 ) !=@expr1073744806 r@var367 .@expr2980 end (@expr2981 ) ;
62: }
63:
64:
65: struct EnumClassHash {
66: template < typename T >
67: unsigned long operator() ( T t@var369 ) const
68: {
69: return static_cast < unsigned long > (@expr1073744809 t@var369 ) ;
70: }
71: } ;
72:
73: bool endsWith ( const std :: string & str@var370 , char c@var371 )
74: {
75: return !@expr1073744810 str@var370 .@expr1073744811 empty (@expr1073744812 ) &&@expr1073744813 str@var370 .@expr1073744814 back (@expr1073744815 ) ==@expr1073744816 c@var371 ;
76: }
77:
78: bool endsWith ( const std :: string & str@var372 , const char end@var373 [ ] , unsigned long endlen@var374 )
79: {
80: return (@expr2993 str@var372 .@expr2994 size (@expr2995 ) >=@expr1073744820 endlen@var374 ) &&@expr1073744821 (@expr2993 str@var372 .@expr1073744823 compare (@expr1073744824 str@var372 .@expr2994 size (@expr2995 ) -@expr1073744827 endlen@var374 , endlen@var374 , end@var373 ) ==@expr1073744828 0 ) ;
81: }
82:
83: template < unsigned long N >
84: bool endsWith ( const std :: string & str@var375 , const char ( & end@var376 ) [ N ] )
85: {
86: return endsWith (@expr1073744830 str@var375 , end@var376 , N@expr1073744829 -@expr1073744831 1 ) ;
87: }
88:
89: static bool isPrefixStringCharLiteral ( const std :: string & str@var377 , char q@var378 , const std :: string & p@var379 )
90: {
91: if (@expr1073744832 !@expr1073744833 endsWith (@expr1073744834 str@var377 , q@var378 ) ) {
92: return false ; }
93: if (@expr1073744835 (@expr1073744836 str@var377 .@expr1073744837 length (@expr1073744838 ) +@expr1073744839 1 ) >@expr1073744840 p@var379 .@expr1073744841 length (@expr1073744842 ) &&@expr1073744843 (@expr1073744844 str@var377 .@expr1073744845 compare (@expr1073744846 0 , p@var379 .@expr1073744847 size (@expr1073744848 ) +@expr1073744849 1 , p@var379 +@expr1073744850 q@var378 ) ==@expr1073744851 0 ) ) {
94: return true ; }
95: return false ;
96: }
97:
98: static bool isStringCharLiteral ( const std :: string & str@var380 , char q@var381 )
99: {
100: static const std ::@expr3028 vector < std ::@expr3028 string > suffixes@var382 {@expr1073744854 "" , "u8" , "u" , "U" , "L" } ;
101: for (@expr1073744855 const std ::@expr3028 string &@expr1073744857 p@var383 :@expr1073744858 suffixes@var382 ) {
102: if (@expr1073744859 isPrefixStringCharLiteral (@expr1073744860 str@var380 , q@var381 , p@var383 ) ) {
103: return true ; }
104: }
105: return false ;
106: }
107:
108: static bool isStringLiteral ( const std :: string & str@var384 )
109: {
110: return isStringCharLiteral (@expr1073744861 str@var384 , '"' ) ;
111: }
112:
113: static bool isCharLiteral ( const std :: string & str@var385 )
114: {
115: return isStringCharLiteral (@expr1073744862 str@var385 , '\'' ) ;
116: }
117:
118: static std :: string getStringCharLiteral ( const std :: string & str@var386 , char q@var387 )
119: {
120: const unsigned long quotePos@var388 =@expr1073744863 str@var386 .@expr1073744864 find (@expr1073744865 q@var387 ) ;
121: return str@var386 .@expr1073744866 substr (@expr1073744867 quotePos@var388 +@expr1073744868 1U , str@var386 .@expr1073744869 size (@expr1073744870 ) -@expr1073744871 quotePos@var388 -@expr1073744872 2U ) ;
122: }
123:
124: static std :: string getStringLiteral ( const std :: string & str@var389 )
125: {
126: if (@expr1073744873 isStringLiteral (@expr1073744874 str@var389 ) ) {
127: return getStringCharLiteral (@expr1073744875 str@var389 , '"' ) ; }
128: return "" ;
129: }
130:
131: static std :: string getCharLiteral ( const std :: string & str@var390 )
132: {
133: if (@expr1073744876 isCharLiteral (@expr1073744877 str@var390 ) ) {
134: return getStringCharLiteral (@expr1073744878 str@var390 , '\'' ) ; }
135: return "" ;
136: }
137:
138: static const char * getOrdinalText ( int i@var391 )
139: {
140: if (@expr1073744879 i@var391 ==@expr1073744880 1 ) {
141: return "st" ; }
142: if (@expr1073744881 i@var391 ==@expr1073744882 2 ) {
143: return "nd" ; }
144: if (@expr1073744883 i@var391 ==@expr1073744884 3 ) {
145: return "rd" ; }
146: return "th" ;
147: }
148:
149: int caseInsensitiveStringCompare ( const std :: string & lhs@var392 , const std :: string & rhs@var393 ) ;
150:
151: bool isValidGlobPattern ( const std :: string & pattern@var394 ) ;
152:
153: bool matchglob ( const std :: string & pattern@var395 , const std :: string & name@var396 ) ;
154:
155: bool matchglobs ( const std :: vector < std :: string > & patterns@var397 , const std :: string & name@var398 ) ;
156:
157: void strTolower ( std :: string & str@var399 ) ;

##file cppcheck-2.8/lib/token.h

1:
|
40:
41: class Enumerator ;
42: class Function ;
43: class Scope ;
44: class Settings ;
45: class Type ;
46: class ValueType ;
47: class Variable ;
48: class TokenList ;
49: class ConstTokenRange ;
50: class Token ;
51:
|
54:
55: struct TokensFrontBack {
56: Token * front@var400 ;
57: Token * back@var401 ;
58: const TokenList * list@var402 ;
59: } ;
60:
61: struct ScopeInfo2 {
62: ScopeInfo2 ( const std :: string & name_@var403 , const Token * bodyEnd_@var404 , const std :: set < std :: string > & usingNamespaces_@var405 = std :: set < std :: string > ( ) ) : name@var406 ( name_@var403 ) , bodyEnd@var407 ( bodyEnd_@var404 ) , usingNamespaces@var408 ( usingNamespaces_@var405 ) { }
63: std :: string name@var406 ;
64: const Token * const bodyEnd@var407 ;
65: std :: set < std :: string > usingNamespaces@var408 ;
66: } ;
67:
68: struct TokenImpl {
69: int mVarId@var409 ;
70: int mFileIndex@var410 ;
71: int mLineNumber@var411 ;
72: int mColumn@var412 ;
73: int mExprId@var413 ;
74:
75:
76: Token * mAstOperand1@var414 ;
77: Token * mAstOperand2@var415 ;
78: Token * mAstParent@var416 ;
79:
80:
81: const Scope * mScope@var417 ;
82: union {
83: const Function * mFunction@var418 ;
84: const Variable * mVariable@var419 ;
85: const :: Type * mType@var420 ;
86: const Enumerator * mEnumerator@var421 ;
87: } ;
88:
|
92:
93: int mProgressValue@var422 ;
94:
|
97:
98: int mIndex@var423 ;
99:
100:
101: std :: string * mOriginalName@var424 ;
102:
103:
104: ValueType * mValueType@var425 ;
105:
106:
107: std :: list < ValueFlow :: Value > * mValues@var426 ;
108: static const std :: list < ValueFlow :: Value > mEmptyValueList@var427 ;
109:
110:
111: std :: set < TemplateSimplifier :: TokenAndName * > * mTemplateSimplifierPointers@var428 ;
112:
113:
114: std :: shared_ptr < ScopeInfo2 > mScopeInfo@var429 ;
115:
116:
117: struct CppcheckAttributes {
118: enum Type { LOW , HIGH } ; enum Type type@var430 ;
119: long long value@var431 ;
120: struct CppcheckAttributes * next@var432 ;
121: } ;
122: struct CppcheckAttributes * mCppcheckAttributes@var433 ;
123:
124:
125: enum class Cpp11init { UNKNOWN , CPP11INIT , NOINIT } ; enum Cpp11init mCpp11init@var434 ;
126:
127:
128: unsigned char mBits@var435 ;
129:
130: void setCppcheckAttribute ( CppcheckAttributes :: Type type@var436 , long long value@var437 ) ;
131: bool getCppcheckAttribute ( CppcheckAttributes :: Type type@var438 , long long * value@var439 ) const ;
132:
133: TokenImpl ( )
134: : mVarId@var409 ( 0 )
135: , mFileIndex@var410 ( 0 )
136: , mLineNumber@var411 ( 0 )
137: , mColumn@var412 ( 0 )
138: , mExprId@var413 ( 0 )
139: , mAstOperand1@var414 ( nullptr )
140: , mAstOperand2@var415 ( nullptr )
141: , mAstParent@var416 ( nullptr )
142: , mScope@var417 ( nullptr )
143: , mFunction@var418 ( nullptr )
144: , mProgressValue@var422 ( 0 )
145: , mIndex@var423 ( 0 )
146: , mOriginalName@var424 ( nullptr )
147: , mValueType@var425 ( nullptr )
148: , mValues@var426 ( nullptr )
149: , mTemplateSimplifierPointers@var428 ( nullptr )
150: , mScopeInfo@var429 ( nullptr )
151: , mCppcheckAttributes@var433 ( nullptr )
152: , mCpp11init@var434 ( Cpp11init :: UNKNOWN )
153: , mBits@var435 ( 0 )
154: { }
155:
156: ~ TokenImpl ( ) ;
157: } ;
158:
|
171:
172: class Token {
173: private:
174: TokensFrontBack * mTokensFrontBack@var440 ;
175:
176:
177: Token ( const Token & ) ;
178: Token operator= ( const Token & ) ;
179:
180: public:
181: enum Type {
182: eVariable , eType , eFunction , eKeyword , eName ,
183: eNumber , eString , eChar , eBoolean , eLiteral , eEnumerator ,
184: eArithmeticalOp , eComparisonOp , eAssignmentOp , eLogicalOp , eBitOp , eIncDecOp , eExtendedOp ,
185: eBracket ,
186: eLambda ,
187: eEllipsis ,
188: eOther ,
189: eNone
190: } ;
191:
192: explicit Token ( TokensFrontBack * tokensFrontBack@var441 = nullptr ) ;
193: ~ Token ( ) ;
194:
195: ConstTokenRange until ( const Token * t@var442 ) const ;
196:
197: template < typename T >
198: void str ( T && s@var443 ) {
199: mStr@var655 =@expr1073744885 s@var443 ;
200: mImpl@var661 .@expr1073744886 mVarId@var692 =@expr1073744887 0 ;
201:
202: update_property_info (@expr1073744888 ) ;
203: }
204:
|
208:
209: void concatStr ( const std :: string & b@var444 ) ;
210:
211: const std :: string & str ( ) const {
212: return mStr@var655 ;
213: }
214:
|
217:
218: void deleteNext ( int count@var445 = 1 ) ;
219:
|
222:
223: void deletePrevious ( int count@var446 = 1 ) ;
224:
|
227:
228: void swapWithNext ( ) ;
229:
|
234:
235: const Token * tokAt ( int index@var447 ) const ;
236: Token * tokAt ( int index@var448 ) {
237: return const_cast < Token *@expr3065 > (@expr1073744890 const_cast < const Token *@expr3065 > (@expr1073744892 this@expr1073744893 ) .@expr1073744894 tokAt (@expr1073744895 index@var448 ) ) ;
238: }
239:
|
243:
244: const Token * linkAt ( int index@var449 ) const ;
245: Token * linkAt ( int index@var450 ) {
246: return const_cast < Token *@expr3072 > (@expr1073744897 const_cast < const Token *@expr3072 > (@expr1073744899 this@expr1073744900 ) .@expr1073744901 linkAt (@expr1073744902 index@var450 ) ) ;
247: }
248:
|
252:
253: const std :: string & strAt ( int index@var451 ) const ;
254:
|
273:
274: template < unsigned long count >
275: static bool simpleMatch ( const Token * tok@var452 , const char ( & pattern@var453 ) [ count ] ) {
276: return simpleMatch (@expr1073744904 tok@var452 , pattern@var453 , count@expr1073744903 -@expr1073744905 1 ) ;
277: }
278:
279: static bool simpleMatch ( const Token * tok@var454 , const char pattern@var455 [ ] , unsigned long pattern_len@var456 ) ;
280:
|
323:
324: static bool Match ( const Token * tok@var457 , const char pattern@var458 [ ] , int varid@var459 = 0 ) ;
325:
|
332:
333: static int getStrLength ( const Token * tok@var460 ) ;
334:
|
341:
342: static int getStrArraySize ( const Token * tok@var461 ) ;
343:
|
351:
352: static int getStrSize ( const Token * tok@var462 , const Settings * const settings@var463 ) ;
353:
|
361:
362: static std :: string getCharAt ( const Token * tok@var464 , long long index@var465 ) ;
363:
364: const ValueType * valueType ( ) const {
365: return mImpl@var661 .@expr1073744906 mValueType@var693 ;
366: }
367: void setValueType ( ValueType * vt@var466 ) ;
368:
369: const ValueType * argumentType ( ) const {
370: const Token * top@var467 ; top@var467 =@expr1073744907 this@expr1073744908 ;
371: while (@expr1073744909 top@var467 &&@expr1073744910 !@expr1073744911 Token ::@expr1073744912 Match (@expr1073744913 top@var467 .@expr3090 astParent (@expr3091 ) , ",|(" ) ) {
372: top@var467 =@expr1073744916 top@var467 .@expr3090 astParent (@expr3091 ) ; }
373: return top@var467 ?@expr1073744919 top@var467 .@expr1073744920 mImpl@var468 .@expr1073744921 mValueType@var469 :@expr1073744922 nullptr ;
374: }
375:
376: Token :: Type tokType ( ) const {
377: return mTokType@var659 ;
378: }
379: void tokType ( Token :: Type t@var470 ) {
380: mTokType@var659 =@expr1073744923 t@var470 ;
381:
382: const bool memoizedIsName@var471 =@expr1073744924 mTokType@var659 ==@expr1073744925 eName ||@expr1073744926 mTokType@var659 ==@expr1073744927 eType ||@expr1073744928 mTokType@var659 ==@expr1073744929 eVariable ||@expr1073744930
383: mTokType@var659 ==@expr1073744931 eFunction ||@expr1073744932 mTokType@var659 ==@expr1073744933 eKeyword ||@expr1073744934 mTokType@var659 ==@expr3111 eBoolean ||@expr1073744936
384: mTokType@var659 ==@expr3113 eEnumerator ;
385: setFlag (@expr1073744938 fIsName , memoizedIsName@var471 ) ;
386:
387: const bool memoizedIsLiteral@var472 =@expr1073744939 mTokType@var659 ==@expr1073744940 eNumber ||@expr1073744941 mTokType@var659 ==@expr1073744942 eString ||@expr1073744943 mTokType@var659 ==@expr1073744944 eChar ||@expr1073744945
388: mTokType@var659 ==@expr3111 eBoolean ||@expr1073744947 mTokType@var659 ==@expr1073744948 eLiteral ||@expr1073744949 mTokType@var659 ==@expr3113 eEnumerator ;
389: setFlag (@expr1073744951 fIsLiteral , memoizedIsLiteral@var472 ) ;
390: }
391: bool isKeyword ( ) const {
392: return mTokType@var659 ==@expr1073744952 eKeyword ;
393: }
394: bool isName ( ) const {
395: return getFlag (@expr1073744953 fIsName ) ;
396: }
397: bool isNameOnly ( ) const {
398: return mFlags@var660 ==@expr1073744954 fIsName &&@expr1073744955 mTokType@var659 ==@expr1073744956 eName ;
399: }
400: bool isUpperCaseName ( ) const ;
401: bool isLiteral ( ) const {
402: return getFlag (@expr1073744957 fIsLiteral ) ;
403: }
404: bool isNumber ( ) const {
405: return mTokType@var659 ==@expr1073744958 eNumber ;
406: }
407: bool isEnumerator ( ) const {
408: return mTokType@var659 ==@expr1073744959 eEnumerator ;
409: }
410: bool isOp ( ) const {
411: return (@expr1073744960 isConstOp (@expr1073744961 ) ||@expr1073744962
412: isAssignmentOp (@expr1073744963 ) ||@expr1073744964
413: mTokType@var659 ==@expr1073744965 eIncDecOp ) ;
414: }
415: bool isConstOp ( ) const {
416: return (@expr1073744966 isArithmeticalOp (@expr1073744967 ) ||@expr1073744968
417: mTokType@var659 ==@expr1073744969 eLogicalOp ||@expr1073744970
418: mTokType@var659 ==@expr1073744971 eComparisonOp ||@expr1073744972
419: mTokType@var659 ==@expr1073744973 eBitOp ) ;
420: }
421: bool isExtendedOp ( ) const {
422: return isConstOp (@expr1073744974 ) ||@expr1073744975
423: mTokType@var659 ==@expr1073744976 eExtendedOp ;
424: }
425: bool isArithmeticalOp ( ) const {
426: return mTokType@var659 ==@expr1073744977 eArithmeticalOp ;
427: }
428: bool isComparisonOp ( ) const {
429: return mTokType@var659 ==@expr1073744978 eComparisonOp ;
430: }
431: bool isAssignmentOp ( ) const {
432: return mTokType@var659 ==@expr1073744979 eAssignmentOp ;
433: }
434: bool isBoolean ( ) const {
435: return mTokType@var659 ==@expr1073744980 eBoolean ;
436: }
437: bool isIncDecOp ( ) const {
438: return mTokType@var659 ==@expr1073744981 eIncDecOp ;
439: }
440: bool isBinaryOp ( ) const {
441: return astOperand1 (@expr1073744982 ) !=@expr1073744983 nullptr &&@expr1073744984 astOperand2 (@expr1073744985 ) !=@expr1073744986 nullptr ;
442: }
443: bool isUnaryOp ( const std :: string & s@var473 ) const {
444: return s@var473 ==@expr1073744987 mStr@var655 &&@expr1073744988 astOperand1 (@expr1073744989 ) !=@expr1073744990 nullptr &&@expr1073744991 astOperand2 (@expr1073744992 ) ==@expr1073744993 nullptr ;
445: }
446: bool isUnaryPreOp ( ) const ;
447:
448: unsigned int flags ( ) const {
449: return mFlags@var660 ;
450: }
451: void flags ( const unsigned int flags_@var474 ) {
452: mFlags@var660 =@expr1073744994 flags_@var474 ;
453: }
454: bool isUnsigned ( ) const {
455: return getFlag (@expr1073744995 fIsUnsigned ) ;
456: }
457: void isUnsigned ( const bool sign@var475 ) {
458: setFlag (@expr1073744996 fIsUnsigned , sign@var475 ) ;
459: }
460: bool isSigned ( ) const {
461: return getFlag (@expr1073744997 fIsSigned ) ;
462: }
463: void isSigned ( const bool sign@var476 ) {
464: setFlag (@expr1073744998 fIsSigned , sign@var476 ) ;
465: }
466: bool isPointerCompare ( ) const {
467: return getFlag (@expr1073744999 fIsPointerCompare ) ;
468: }
469: void isPointerCompare ( const bool b@var477 ) {
470: setFlag (@expr1073745000 fIsPointerCompare , b@var477 ) ;
471: }
472: bool isLong ( ) const {
473: return getFlag (@expr1073745001 fIsLong ) ;
474: }
475: void isLong ( bool size@var478 ) {
476: setFlag (@expr1073745002 fIsLong , size@var478 ) ;
477: }
478: bool isStandardType ( ) const {
479: return getFlag (@expr1073745003 fIsStandardType ) ;
480: }
481: void isStandardType ( const bool b@var479 ) {
482: setFlag (@expr1073745004 fIsStandardType , b@var479 ) ;
483: }
484: bool isExpandedMacro ( ) const {
485: return getFlag (@expr1073745005 fIsExpandedMacro ) ;
486: }
487: void isExpandedMacro ( const bool m@var480 ) {
488: setFlag (@expr1073745006 fIsExpandedMacro , m@var480 ) ;
489: }
490: bool isCast ( ) const {
491: return getFlag (@expr1073745007 fIsCast ) ;
492: }
493: void isCast ( bool c@var481 ) {
494: setFlag (@expr1073745008 fIsCast , c@var481 ) ;
495: }
496: bool isAttributeConstructor ( ) const {
497: return getFlag (@expr1073745009 fIsAttributeConstructor ) ;
498: }
499: void isAttributeConstructor ( const bool ac@var482 ) {
500: setFlag (@expr1073745010 fIsAttributeConstructor , ac@var482 ) ;
501: }
502: bool isAttributeDestructor ( ) const {
503: return getFlag (@expr1073745011 fIsAttributeDestructor ) ;
504: }
505: void isAttributeDestructor ( const bool value@var483 ) {
506: setFlag (@expr1073745012 fIsAttributeDestructor , value@var483 ) ;
507: }
508: bool isAttributeUnused ( ) const {
509: return getFlag (@expr1073745013 fIsAttributeUnused ) ;
510: }
511: void isAttributeUnused ( bool unused@var484 ) {
512: setFlag (@expr1073745014 fIsAttributeUnused , unused@var484 ) ;
513: }
514: bool isAttributeUsed ( ) const {
515: return getFlag (@expr1073745015 fIsAttributeUsed ) ;
516: }
517: void isAttributeUsed ( const bool unused@var485 ) {
518: setFlag (@expr1073745016 fIsAttributeUsed , unused@var485 ) ;
519: }
520: bool isAttributePure ( ) const {
521: return getFlag (@expr1073745017 fIsAttributePure ) ;
522: }
523: void isAttributePure ( const bool value@var486 ) {
524: setFlag (@expr1073745018 fIsAttributePure , value@var486 ) ;
525: }
526: bool isAttributeConst ( ) const {
527: return getFlag (@expr1073745019 fIsAttributeConst ) ;
528: }
529: void isAttributeConst ( bool value@var487 ) {
530: setFlag (@expr1073745020 fIsAttributeConst , value@var487 ) ;
531: }
532: bool isAttributeNoreturn ( ) const {
533: return getFlag (@expr1073745021 fIsAttributeNoreturn ) ;
534: }
535: void isAttributeNoreturn ( const bool value@var488 ) {
536: setFlag (@expr1073745022 fIsAttributeNoreturn , value@var488 ) ;
537: }
538: bool isAttributeNothrow ( ) const {
539: return getFlag (@expr1073745023 fIsAttributeNothrow ) ;
540: }
541: void isAttributeNothrow ( const bool value@var489 ) {
542: setFlag (@expr1073745024 fIsAttributeNothrow , value@var489 ) ;
543: }
544: bool isAttributePacked ( ) const {
545: return getFlag (@expr1073745025 fIsAttributePacked ) ;
546: }
547: void isAttributePacked ( const bool value@var490 ) {
548: setFlag (@expr1073745026 fIsAttributePacked , value@var490 ) ;
549: }
550: bool isAttributeNodiscard ( ) const {
551: return getFlag (@expr1073745027 fIsAttributeNodiscard ) ;
552: }
553: void isAttributeNodiscard ( const bool value@var491 ) {
554: setFlag (@expr1073745028 fIsAttributeNodiscard , value@var491 ) ;
555: }
556: bool isAttributeMaybeUnused ( ) const {
557: return getFlag (@expr1073745029 fIsAttributeMaybeUnused ) ;
558: }
559: void isAttributeMaybeUnused ( const bool value@var492 ) {
560: setFlag (@expr1073745030 fIsAttributeMaybeUnused , value@var492 ) ;
561: }
562: void setCppcheckAttribute ( TokenImpl :: CppcheckAttributes :: Type type@var493 , long long value@var494 ) {
563: mImpl@var661 .@expr1073745031 setCppcheckAttribute (@expr1073745032 type@var493 , value@var494 ) ;
564: }
565: bool getCppcheckAttribute ( TokenImpl :: CppcheckAttributes :: Type type@var495 , long long * value@var496 ) const {
566: return mImpl@var661 .@expr1073745033 getCppcheckAttribute (@expr1073745034 type@var495 , value@var496 ) ;
567: }
568: bool hasCppcheckAttributes ( ) const {
569: return nullptr !=@expr1073745035 mImpl@var661 .@expr1073745036 mCppcheckAttributes@var694 ;
570: }
571: bool isControlFlowKeyword ( ) const {
572: return getFlag (@expr1073745037 fIsControlFlowKeyword ) ;
573: }
574: bool isOperatorKeyword ( ) const {
575: return getFlag (@expr1073745038 fIsOperatorKeyword ) ;
576: }
577: void isOperatorKeyword ( const bool value@var497 ) {
578: setFlag (@expr1073745039 fIsOperatorKeyword , value@var497 ) ;
579: }
580: bool isComplex ( ) const {
581: return getFlag (@expr1073745040 fIsComplex ) ;
582: }
583: void isComplex ( const bool value@var498 ) {
584: setFlag (@expr1073745041 fIsComplex , value@var498 ) ;
585: }
586: bool isEnumType ( ) const {
587: return getFlag (@expr1073745042 fIsEnumType ) ;
588: }
589: void isEnumType ( const bool value@var499 ) {
590: setFlag (@expr1073745043 fIsEnumType , value@var499 ) ;
591: }
592: bool isAtAddress ( ) const {
593: return getFlag (@expr1073745044 fAtAddress ) ;
594: }
595: void isAtAddress ( bool b@var500 ) {
596: setFlag (@expr1073745045 fAtAddress , b@var500 ) ;
597: }
598: bool isIncompleteVar ( ) const {
599: return getFlag (@expr1073745046 fIncompleteVar ) ;
600: }
601: void isIncompleteVar ( bool b@var501 ) {
602: setFlag (@expr1073745047 fIncompleteVar , b@var501 ) ;
603: }
604:
605: bool isIncompleteConstant ( ) const {
606: return getFlag (@expr1073745048 fIsIncompleteConstant ) ;
607: }
608: void isIncompleteConstant ( bool b@var502 ) {
609: setFlag (@expr1073745049 fIsIncompleteConstant , b@var502 ) ;
610: }
611:
612: bool isConstexpr ( ) const {
613: return getFlag (@expr1073745050 fConstexpr ) ;
614: }
615: void isConstexpr ( bool b@var503 ) {
616: setFlag (@expr1073745051 fConstexpr , b@var503 ) ;
617: }
618:
619: bool isExternC ( ) const {
620: return getFlag (@expr1073745052 fExternC ) ;
621: }
622: void isExternC ( bool b@var504 ) {
623: setFlag (@expr1073745053 fExternC , b@var504 ) ;
624: }
625:
626: bool isSplittedVarDeclComma ( ) const {
627: return getFlag (@expr1073745054 fIsSplitVarDeclComma ) ;
628: }
629: void isSplittedVarDeclComma ( bool b@var505 ) {
630: setFlag (@expr1073745055 fIsSplitVarDeclComma , b@var505 ) ;
631: }
632:
633: bool isSplittedVarDeclEq ( ) const {
634: return getFlag (@expr1073745056 fIsSplitVarDeclEq ) ;
635: }
636: void isSplittedVarDeclEq ( bool b@var506 ) {
637: setFlag (@expr1073745057 fIsSplitVarDeclEq , b@var506 ) ;
638: }
639:
640: bool isImplicitInt ( ) const {
641: return getFlag (@expr1073745058 fIsImplicitInt ) ;
642: }
643: void isImplicitInt ( bool b@var507 ) {
644: setFlag (@expr1073745059 fIsImplicitInt , b@var507 ) ;
645: }
646:
647: bool isInline ( ) const {
648: return getFlag (@expr1073745060 fIsInline ) ;
649: }
650: void isInline ( bool b@var508 ) {
651: setFlag (@expr1073745061 fIsInline , b@var508 ) ;
652: }
653:
654: bool isRemovedVoidParameter ( ) const {
655: return getFlag (@expr1073745062 fIsRemovedVoidParameter ) ;
656: }
657: void setRemovedVoidParameter ( bool b@var509 ) {
658: setFlag (@expr1073745063 fIsRemovedVoidParameter , b@var509 ) ;
659: }
660:
661: bool isTemplate ( ) const {
662: return getFlag (@expr1073745064 fIsTemplate ) ;
663: }
664: void isTemplate ( bool b@var510 ) {
665: setFlag (@expr1073745065 fIsTemplate , b@var510 ) ;
666: }
667:
668: bool isSimplifiedScope ( ) const {
669: return getFlag (@expr1073745066 fIsSimplifedScope ) ;
670: }
671: void isSimplifiedScope ( bool b@var511 ) {
672: setFlag (@expr1073745067 fIsSimplifedScope , b@var511 ) ;
673: }
674:
675: bool isBitfield ( ) const {
676: return mImpl@var661 .@expr1073745068 mBits@var695 >@expr1073745069 0 ;
677: }
678: unsigned char bits ( ) const {
679: return mImpl@var661 .@expr1073745070 mBits@var695 ;
680: }
681: std :: set < TemplateSimplifier :: TokenAndName * > * templateSimplifierPointers ( ) const {
682: return mImpl@var661 .@expr1073745071 mTemplateSimplifierPointers@var696 ;
683: }
684: void templateSimplifierPointer ( TemplateSimplifier :: TokenAndName * tokenAndName@var512 ) {
685: if (@expr1073745072 !@expr1073745073 mImpl@var661 .@expr3250 mTemplateSimplifierPointers@var696 ) {
686: mImpl@var661 .@expr3250 mTemplateSimplifierPointers@var696 =@expr1073745076 new std ::@expr1073745077 set < TemplateSimplifier ::@expr1073745078 TokenAndName *@expr1073745079 > ; }
687: mImpl@var661 .@expr3250 mTemplateSimplifierPointers@var696 .@expr1073745081 insert (@expr1073745082 tokenAndName@var512 ) ;
688: }
689: void setBits ( const unsigned char b@var513 ) {
690: mImpl@var661 .@expr1073745083 mBits@var695 =@expr1073745084 b@var513 ;
691: }
692:
693: bool isUtf8 ( ) const {
694: return (@expr3261 (@expr3261 (@expr3261 mTokType@var659 ==@expr1073745088 eString ) &&@expr1073745089 isPrefixStringCharLiteral (@expr1073745090 mStr@var655 , '"' , "u8" ) ) ||@expr1073745091
695: (@expr3261 (@expr3261 mTokType@var659 ==@expr1073745094 eChar ) &&@expr1073745095 isPrefixStringCharLiteral (@expr1073745096 mStr@var655 , '\'' , "u8" ) ) ) ;
696: }
697:
698: bool isUtf16 ( ) const {
699: return (@expr3273 (@expr3273 (@expr3273 mTokType@var659 ==@expr1073745100 eString ) &&@expr1073745101 isPrefixStringCharLiteral (@expr1073745102 mStr@var655 , '"' , "u" ) ) ||@expr1073745103
700: (@expr3273 (@expr3273 mTokType@var659 ==@expr1073745106 eChar ) &&@expr1073745107 isPrefixStringCharLiteral (@expr1073745108 mStr@var655 , '\'' , "u" ) ) ) ;
701: }
702:
703: bool isUtf32 ( ) const {
704: return (@expr3285 (@expr3285 (@expr3285 mTokType@var659 ==@expr1073745112 eString ) &&@expr1073745113 isPrefixStringCharLiteral (@expr1073745114 mStr@var655 , '"' , "U" ) ) ||@expr1073745115
705: (@expr3285 (@expr3285 mTokType@var659 ==@expr1073745118 eChar ) &&@expr1073745119 isPrefixStringCharLiteral (@expr1073745120 mStr@var655 , '\'' , "U" ) ) ) ;
706: }
707:
708: bool isCChar ( ) const {
709: return (@expr3297 (@expr3297 (@expr3297 mTokType@var659 ==@expr1073745124 eString ) &&@expr1073745125 isPrefixStringCharLiteral (@expr1073745126 mStr@var655 , '"' , "" ) ) ||@expr1073745127
710: (@expr3297 (@expr3297 mTokType@var659 ==@expr1073745130 eChar ) &&@expr1073745131 isPrefixStringCharLiteral (@expr1073745132 mStr@var655 , '\'' , "" ) &&@expr1073745133 mStr@var655 .@expr1073745134 length (@expr1073745135 ) ==@expr1073745136 3 ) ) ;
711: }
712:
713: bool isCMultiChar ( ) const {
714: return (@expr3313 (@expr3313 (@expr3313 mTokType@var659 ==@expr1073745140 eChar ) &&@expr1073745141 isPrefixStringCharLiteral (@expr1073745142 mStr@var655 , '\'' , "" ) ) &&@expr1073745143
715: (@expr3313 mStr@var655 .@expr1073745145 length (@expr1073745146 ) >@expr1073745147 3 ) ) ;
716: }
717:
|
733:
734: bool isTemplateArg ( ) const {
735: return getFlag (@expr1073745148 fIsTemplateArg ) ;
736: }
737: void isTemplateArg ( const bool value@var514 ) {
738: setFlag (@expr1073745149 fIsTemplateArg , value@var514 ) ;
739: }
740:
741: template < unsigned long count >
742: static const Token * findsimplematch ( const Token * const startTok@var515 , const char ( & pattern@var516 ) [ count ] ) {
743: return findsimplematch (@expr1073745151 startTok@var515 , pattern@var516 , count@expr1073745150 -@expr1073745152 1 ) ;
744: }
745: static const Token * findsimplematch ( const Token * const startTok@var517 , const char pattern@var518 [ ] , unsigned long pattern_len@var519 ) ;
746:
747: template < unsigned long count >
748: static const Token * findsimplematch ( const Token * const startTok@var520 , const char ( & pattern@var521 ) [ count ] , const Token * const end@var522 ) {
749: return findsimplematch (@expr1073745154 startTok@var520 , pattern@var521 , count@expr1073745153 -@expr1073745155 1 , end@var522 ) ;
750: }
751: static const Token * findsimplematch ( const Token * const startTok@var523 , const char pattern@var524 [ ] , unsigned long pattern_len@var525 , const Token * const end@var526 ) ;
752:
753: static const Token * findmatch ( const Token * const startTok@var527 , const char pattern@var528 [ ] , const int varId@var529 = 0 ) ;
754: static const Token * findmatch ( const Token * const startTok@var530 , const char pattern@var531 [ ] , const Token * const end@var532 , const int varId@var533 = 0 ) ;
755:
756: template < unsigned long count >
757: static Token * findsimplematch ( Token * const startTok@var534 , const char ( & pattern@var535 ) [ count ] ) {
758: return findsimplematch (@expr1073745157 startTok@var534 , pattern@var535 , count@expr1073745156 -@expr1073745158 1 ) ;
759: }
760: static Token * findsimplematch ( Token * const startTok@var536 , const char pattern@var537 [ ] , unsigned long pattern_len@var538 ) {
761: return const_cast < Token *@expr3335 > (@expr1073745160 findsimplematch (@expr1073745161 const_cast < const Token *@expr3335 > (@expr1073745163 startTok@var536 ) , pattern@var537 , pattern_len@var538 ) ) ;
762: }
763: template < unsigned long count >
764: static Token * findsimplematch ( Token * const startTok@var539 , const char ( & pattern@var540 ) [ count ] , const Token * const end@var541 ) {
765: return findsimplematch (@expr1073745165 startTok@var539 , pattern@var540 , count@expr1073745164 -@expr1073745166 1 , end@var541 ) ;
766: }
767: static Token * findsimplematch ( Token * const startTok@var542 , const char pattern@var543 [ ] , unsigned long pattern_len@var544 , const Token * const end@var545 ) {
768: return const_cast < Token *@expr3343 > (@expr1073745168 findsimplematch (@expr1073745169 const_cast < const Token *@expr3343 > (@expr1073745171 startTok@var542 ) , pattern@var543 , pattern_len@var544 , end@var545 ) ) ;
769: }
770:
771: static Token * findmatch ( Token * const startTok@var546 , const char pattern@var547 [ ] , const int varId@var548 = 0 ) {
772: return const_cast < Token *@expr3348 > (@expr1073745173 findmatch (@expr1073745174 const_cast < const Token *@expr3348 > (@expr1073745176 startTok@var546 ) , pattern@var547 , varId@var548 ) ) ;
773: }
774: static Token * findmatch ( Token * const startTok@var549 , const char pattern@var550 [ ] , const Token * const end@var551 , const int varId@var552 = 0 ) {
775: return const_cast < Token *@expr3353 > (@expr1073745178 findmatch (@expr1073745179 const_cast < const Token *@expr3353 > (@expr1073745181 startTok@var549 ) , pattern@var550 , end@var551 , varId@var552 ) ) ;
776: }
777:
|
791:
792: static int multiCompare ( const Token * tok@var553 , const char * haystack@var554 , int varid@var555 ) ;
793:
794: int fileIndex ( ) const {
795: return mImpl@var661 .@expr1073745182 mFileIndex@var697 ;
796: }
797: void fileIndex ( int indexOfFile@var556 ) {
798: mImpl@var661 .@expr1073745183 mFileIndex@var697 =@expr1073745184 indexOfFile@var556 ;
799: }
800:
801: int linenr ( ) const {
802: return mImpl@var661 .@expr1073745185 mLineNumber@var698 ;
803: }
804: void linenr ( int lineNumber@var557 ) {
805: mImpl@var661 .@expr1073745186 mLineNumber@var698 =@expr1073745187 lineNumber@var557 ;
806: }
807:
808: int column ( ) const {
809: return mImpl@var661 .@expr1073745188 mColumn@var699 ;
810: }
811: void column ( int c@var558 ) {
812: mImpl@var661 .@expr1073745189 mColumn@var699 =@expr1073745190 c@var558 ;
813: }
814:
815: Token * next ( ) const {
816: return mNext@var656 ;
817: }
818:
|
826:
827: static void eraseTokens ( Token * begin@var559 , const Token * end@var560 ) ;
828:
|
836:
837: Token * insertToken ( const std :: string & tokenStr@var561 , const std :: string & originalNameStr@var562 = emptyString@var1 , bool prepend@var563 = false ) ;
838:
839: Token * insertTokenBefore ( const std :: string & tokenStr@var564 , const std :: string & originalNameStr@var565 = emptyString@var1 )
840: {
841: return insertToken (@expr1073745191 tokenStr@var564 , originalNameStr@var565 , true ) ;
842: }
843:
844: Token * previous ( ) const {
845: return mPrevious@var657 ;
846: }
847:
848:
849: int varId ( ) const {
850: return mImpl@var661 .@expr1073745192 mVarId@var692 ;
851: }
852: void varId ( int id@var566 ) {
853: mImpl@var661 .@expr1073745193 mVarId@var692 =@expr1073745194 id@var566 ;
854: if (@expr1073745195 id@var566 !=@expr1073745196 0 ) {
855: tokType (@expr1073745197 eVariable ) ;
856: isStandardType (@expr1073745198 false ) ;
857: } else {
858: update_property_info (@expr1073745199 ) ;
859: }
860: }
861:
862: int exprId ( ) const {
863: if (@expr1073745200 mImpl@var661 .@expr3377 mExprId@var700 ) {
864: return mImpl@var661 .@expr3377 mExprId@var700 ; }
865: return mImpl@var661 .@expr1073745203 mVarId@var692 ;
866: }
867: void exprId ( int id@var567 ) {
868: mImpl@var661 .@expr1073745204 mExprId@var700 =@expr1073745205 id@var567 ;
869: }
870:
|
876:
877: void printOut ( const char * title@var568 = nullptr ) const ;
878:
|
886:
887: void printOut ( const char * title@var569 , const std :: vector < std :: string > & fileNames@var570 ) const ;
888:
|
891:
892: void printLines ( int lines@var571 = 5 ) const ;
893:
|
900:
901: static void replace ( Token * replaceThis@var572 , Token * start@var573 , Token * end@var574 ) ;
902:
903: struct stringifyOptions {
904: bool varid@var575 ; varid@var575 = false ;
905: bool exprid@var576 ; exprid@var576 = false ;
906: bool idtype@var577 ; idtype@var577 = false ;
907: bool attributes@var578 ; attributes@var578 = false ;
908: bool macro@var579 ; macro@var579 = false ;
909: bool linenumbers@var580 ; linenumbers@var580 = false ;
910: bool linebreaks@var581 ; linebreaks@var581 = false ;
911: bool files@var582 ; files@var582 = false ;
912: static stringifyOptions forDebug ( ) {
913: stringifyOptions options@var583 ;
914: options@var583 .@expr1073745206 attributes@var584 =@expr1073745207 true ;
915: options@var583 .@expr1073745208 macro@var585 =@expr1073745209 true ;
916: options@var583 .@expr1073745210 linenumbers@var586 =@expr1073745211 true ;
917: options@var583 .@expr1073745212 linebreaks@var587 =@expr1073745213 true ;
918: options@var583 .@expr1073745214 files@var588 =@expr1073745215 true ;
919: return options@var583 ;
920: }
921: static stringifyOptions forDebugVarId ( ) {
922: stringifyOptions options@var589 ; options@var589 =@expr1073745216 forDebug (@expr1073745217 ) ;
923: options@var589 .@expr1073745218 varid@var590 =@expr1073745219 true ;
924: return options@var589 ;
925: }
926: static stringifyOptions forDebugExprId ( ) {
927: stringifyOptions options@var591 ; options@var591 =@expr1073745220 forDebug (@expr1073745221 ) ;
928: options@var591 .@expr1073745222 exprid@var592 =@expr1073745223 true ;
929: return options@var591 ;
930: }
931: static stringifyOptions forPrintOut ( ) {
932: stringifyOptions options@var593 ; options@var593 =@expr1073745224 forDebug (@expr1073745225 ) ;
933: options@var593 .@expr1073745226 exprid@var594 =@expr1073745227 true ;
934: options@var593 .@expr1073745228 varid@var595 =@expr1073745229 true ;
935: options@var593 .@expr1073745230 idtype@var596 =@expr1073745231 true ;
936: return options@var593 ;
937: }
938: } ;
939:
940: std :: string stringify ( const stringifyOptions & options@var597 ) const ;
941:
|
947:
948: std :: string stringify ( bool varid@var598 , bool attributes@var599 , bool macro@var600 ) const ;
949:
950: std :: string stringifyList ( const stringifyOptions & options@var601 , const std :: vector < std :: string > * fileNames@var602 = nullptr , const Token * end@var603 = nullptr ) const ;
951: std :: string stringifyList ( const Token * end@var604 , bool attributes@var605 = true ) const ;
952: std :: string stringifyList ( bool varid@var606 = false ) const ;
953:
|
964:
965: std :: string stringifyList ( bool varid@var607 , bool attributes@var608 , bool linenumbers@var609 , bool linebreaks@var610 , bool files@var611 , const std :: vector < std :: string > * fileNames@var612 = nullptr , const Token * end@var613 = nullptr ) const ;
966:
|
974:
975: void deleteThis ( ) ;
976:
|
981:
982: void link ( Token * linkToToken@var614 ) {
983: mLink@var658 =@expr1073745232 linkToToken@var614 ;
984: if (@expr1073745233 mStr@var655 ==@expr1073745234 "<" ||@expr1073745235 mStr@var655 ==@expr1073745236 ">" ) {
985: update_property_info (@expr1073745237 ) ; }
986: }
987:
|
996:
997: Token * link ( ) const {
998: return mLink@var658 ;
999: }
1000:
|
1004:
1005: void scope ( const Scope * s@var615 ) {
1006: mImpl@var661 .@expr1073745238 mScope@var701 =@expr1073745239 s@var615 ;
1007: }
1008:
|
1011:
1012: const Scope * scope ( ) const {
1013: return mImpl@var661 .@expr1073745240 mScope@var701 ;
1014: }
1015:
|
1019:
1020: void function ( const Function * f@var616 ) ;
1021:
|
1024:
1025: const Function * function ( ) const {
1026: return mTokType@var659 ==@expr1073745241 eFunction ||@expr1073745242 mTokType@var659 ==@expr1073745243 eLambda ?@expr1073745244 mImpl@var661 .@expr1073745245 mFunction@var702 :@expr1073745246 nullptr ;
1027: }
1028:
|
1032:
1033: void variable ( const Variable * v@var617 ) {
1034: mImpl@var661 .@expr1073745247 mVariable@var703 =@expr1073745248 v@var617 ;
1035: if (@expr1073745249 v@var617 ||@expr1073745250 mImpl@var661 .@expr1073745251 mVarId@var692 ) {
1036: tokType (@expr1073745252 eVariable ) ; }
1037: else { if (@expr1073745253 mTokType@var659 ==@expr1073745254 eVariable ) {
1038: tokType (@expr1073745255 eName ) ; } }
1039: }
1040:
|
1043:
1044: const Variable * variable ( ) const {
1045: return mTokType@var659 ==@expr1073745256 eVariable ?@expr1073745257 mImpl@var661 .@expr1073745258 mVariable@var703 :@expr1073745259 nullptr ;
1046: }
1047:
|
1051:
1052: void type ( const :: Type * t@var618 ) ;
1053:
|
1056:
1057: const :: Type * type ( ) const {
1058: return mTokType@var659 ==@expr1073745260 eType ?@expr1073745261 mImpl@var661 .@expr1073745262 mType@var704 :@expr1073745263 nullptr ;
1059: }
1060:
1061: static const :: Type * typeOf ( const Token * tok@var619 , const Token * * typeTok@var620 = nullptr ) ;
1062:
1063: static std :: pair < const Token * , const Token * > typeDecl ( const Token * tok@var621 ) ;
1064:
1065: static std :: string typeStr ( const Token * tok@var622 ) ;
1066:
|
1069:
1070: const Enumerator * enumerator ( ) const {
1071: return mTokType@var659 ==@expr1073745264 eEnumerator ?@expr1073745265 mImpl@var661 .@expr1073745266 mEnumerator@var705 :@expr1073745267 nullptr ;
1072: }
1073:
|
1077:
1078: void enumerator ( const Enumerator * e@var623 ) {
1079: mImpl@var661 .@expr1073745268 mEnumerator@var705 =@expr1073745269 e@var623 ;
1080: if (@expr1073745270 e@var623 ) {
1081: tokType (@expr1073745271 eEnumerator ) ; }
1082: else { if (@expr1073745272 mTokType@var659 ==@expr1073745273 eEnumerator ) {
1083: tokType (@expr1073745274 eName ) ; } }
1084: }
1085:
|
1088:
1089: static void createMutualLinks ( Token * begin@var624 , Token * end@var625 ) ;
1090:
|
1096:
1097: std :: string strValue ( ) const ;
1098:
|
1105:
1106: static void move ( Token * srcStart@var626 , Token * srcEnd@var627 , Token * newLocation@var628 ) ;
1107:
1108:
1109: int progressValue ( ) const {
1110: return mImpl@var661 .@expr1073745275 mProgressValue@var706 ;
1111: }
1112:
1113:
1114: static void assignProgressValues ( Token * tok@var629 ) ;
1115:
|
1120:
1121: Token * nextArgument ( ) const ;
1122:
|
1127:
1128: Token * nextArgumentBeforeCreateLinks2 ( ) const ;
1129:
|
1134:
1135: Token * nextTemplateArgument ( ) const ;
1136:
|
1141:
1142: const Token * findClosingBracket ( ) const ;
1143: Token * findClosingBracket ( ) ;
1144:
1145: const Token * findOpeningBracket ( ) const ;
1146: Token * findOpeningBracket ( ) ;
1147:
|
1150:
1151: const std :: string & originalName ( ) const {
1152: return mImpl@var661 .@expr3452 mOriginalName@var707 ?@expr1073745277 *@expr1073745278 mImpl@var661 .@expr3452 mOriginalName@var707 :@expr1073745280 emptyString@var1 ;
1153: }
1154:
1155: const std :: list < ValueFlow :: Value > & values ( ) const {
1156: return mImpl@var661 .@expr3457 mValues@var680 ?@expr1073745282 *@expr1073745283 mImpl@var661 .@expr3457 mValues@var680 :@expr1073745285 TokenImpl ::@expr1073745286 mEmptyValueList@var427 ;
1157: }
1158:
|
1161:
1162: template < typename T >
1163: void originalName ( T && name@var630 ) {
1164: if (@expr1073745287 !@expr1073745288 mImpl@var661 .@expr3465 mOriginalName@var707 ) {
1165: mImpl@var661 .@expr3465 mOriginalName@var707 =@expr1073745291 new std ::@expr1073745292 string (@expr1073745293 name@var630 ) ; }
1166: else {
1167: *@expr1073745294 mImpl@var661 .@expr3465 mOriginalName@var707 =@expr1073745296 name@var630 ; }
1168: }
1169:
1170: bool hasKnownIntValue ( ) const ;
1171: bool hasKnownValue ( ) const ;
1172: bool hasKnownValue ( ValueFlow :: Value :: ValueType t@var631 ) const ;
1173: bool hasKnownSymbolicValue ( const Token * tok@var632 ) const ;
1174:
1175: const ValueFlow :: Value * getKnownValue ( ValueFlow :: Value :: ValueType t@var633 ) const ;
1176: long long getKnownIntValue ( ) const {
1177: return mImpl@var661 .@expr1073745298 mValues@var680 .@expr1073745299 front (@expr1073745300 ) .@expr1073745301 intvalue@expr1073745297 ;
1178: }
1179:
1180: const ValueFlow :: Value * getValue ( const long long val@var634 ) const ;
1181:
1182: const ValueFlow :: Value * getMaxValue ( bool condition@var635 , long long path@var636 = 0 ) const ;
1183:
1184: const ValueFlow :: Value * getMovedValue ( ) const ;
1185:
1186: const ValueFlow :: Value * getValueLE ( const long long val@var637 , const Settings * settings@var638 ) const ;
1187: const ValueFlow :: Value * getValueGE ( const long long val@var639 , const Settings * settings@var640 ) const ;
1188:
1189: const ValueFlow :: Value * getInvalidValue ( const Token * ftok@var641 , int argnr@var642 , const Settings * settings@var643 ) const ;
1190:
1191: const ValueFlow :: Value * getContainerSizeValue ( const long long val@var644 ) const ;
1192:
1193: const Token * getValueTokenMaxStrLength ( ) const ;
1194: const Token * getValueTokenMinStrSize ( const Settings * settings@var645 ) const ;
1195:
1196:
1197: bool addValue ( const ValueFlow :: Value & value@var646 ) ;
1198:
1199: void removeValues ( std :: function < bool ( const ValueFlow :: Value & ) > pred@var647 ) {
1200: if (@expr1073745302 mImpl@var661 .@expr3479 mValues@var680 ) {
1201: mImpl@var661 .@expr3479 mValues@var680 .@expr1073745305 remove_if (@expr1073745306 pred@var647 ) ; }
1202: }
1203:
1204: int index ( ) const {
1205: return mImpl@var661 .@expr1073745307 mIndex@var708 ;
1206: }
1207:
1208: void assignIndexes ( ) ;
1209:
1210: private:
1211:
1212: void next ( Token * nextToken@var648 ) {
1213: mNext@var656 =@expr1073745308 nextToken@var648 ;
1214: }
1215: void previous ( Token * previousToken@var649 ) {
1216: mPrevious@var657 =@expr1073745309 previousToken@var649 ;
1217: }
1218:
1219:
1220: void takeData ( Token * fromToken@var650 ) ;
1221:
|
1226:
1227: static bool firstWordEquals ( const char * str@var651 , const char * word@var652 ) ;
1228:
|
1233:
1234: static const char * chrInFirstWord ( const char * str@var653 , char c@var654 ) ;
1235:
1236: std :: string mStr@var655 ;
1237:
1238: Token * mNext@var656 ;
1239: Token * mPrevious@var657 ;
1240: Token * mLink@var658 ;
1241:
1242: enum Anonymous1 : uint64_t {
1243: fIsUnsigned = ( 1 << 0 ) ,
1244: fIsSigned = ( 1 << 1 ) ,
1245: fIsPointerCompare = ( 1 << 2 ) ,
1246: fIsLong = ( 1 << 3 ) ,
1247: fIsStandardType = ( 1 << 4 ) ,
1248: fIsExpandedMacro = ( 1 << 5 ) ,
1249: fIsCast = ( 1 << 6 ) ,
1250: fIsAttributeConstructor = ( 1 << 7 ) ,
1251: fIsAttributeDestructor = ( 1 << 8 ) ,
1252: fIsAttributeUnused = ( 1 << 9 ) ,
1253: fIsAttributePure = ( 1 << 10 ) ,
1254: fIsAttributeConst = ( 1 << 11 ) ,
1255: fIsAttributeNoreturn = ( 1 << 12 ) ,
1256: fIsAttributeNothrow = ( 1 << 13 ) ,
1257: fIsAttributeUsed = ( 1 << 14 ) ,
1258: fIsAttributePacked = ( 1 << 15 ) ,
1259: fIsAttributeMaybeUnused = ( 1 << 16 ) ,
1260: fIsControlFlowKeyword = ( 1 << 17 ) ,
1261: fIsOperatorKeyword = ( 1 << 18 ) ,
1262: fIsComplex = ( 1 << 19 ) ,
1263: fIsEnumType = ( 1 << 20 ) ,
1264: fIsName = ( 1 << 21 ) ,
1265: fIsLiteral = ( 1 << 22 ) ,
1266: fIsTemplateArg = ( 1 << 23 ) ,
1267: fIsAttributeNodiscard = ( 1 << 24 ) ,
1268: fAtAddress = ( 1 << 25 ) ,
1269: fIncompleteVar = ( 1 << 26 ) ,
1270: fConstexpr = ( 1 << 27 ) ,
1271: fExternC = ( 1 << 28 ) ,
1272: fIsSplitVarDeclComma = ( 1 << 29 ) ,
1273: fIsSplitVarDeclEq = ( 1 << 30 ) ,
1274: fIsImplicitInt = ( 1U << 31 ) ,
1275: fIsInline = ( 1ULL << 32 ) ,
1276: fIsTemplate = ( 1ULL << 33 ) ,
1277: fIsSimplifedScope = ( 1ULL << 34 ) ,
1278: fIsRemovedVoidParameter = ( 1ULL << 35 ) ,
1279: fIsIncompleteConstant = ( 1ULL << 36 ) ,
1280: } ;
1281:
1282: Token :: Type mTokType@var659 ;
1283:
1284: uint64_t mFlags@var660 ;
1285:
1286: TokenImpl * mImpl@var661 ;
1287:
|
1292:
1293: bool getFlag ( uint64_t flag_@var662 ) const {
1294: return (@expr3486 (@expr3486 mFlags@var660 &@expr1073745312 flag_@var662 ) !=@expr1073745313 0 ) ;
1295: }
1296:
|
1301:
1302: void setFlag ( uint64_t flag_@var663 , bool state_@var664 ) {
1303: mFlags@var660 =@expr1073745314 state_@var664 ?@expr1073745315 mFlags@var660 |@expr1073745316 flag_@var663 :@expr1073745317 mFlags@var660 &@expr1073745318 ~@expr1073745319 flag_@var663 ;
1304: }
1305:
1306:
1307:
1308: void update_property_info ( ) ;
1309:
1310:
1311: void update_property_isStandardType ( ) ;
1312:
1313:
1314: void update_property_char_string_literal ( ) ;
1315:
1316:
1317: void astStringVerboseRecursive ( std :: string & ret@var665 , const int indent1@var666 = 0 , const int indent2@var667 = 0 ) const ;
1318:
1319: public:
1320: void astOperand1 ( Token * tok@var668 ) ;
1321: void astOperand2 ( Token * tok@var669 ) ;
1322: void astParent ( Token * tok@var670 ) ;
1323:
1324: Token * astOperand1 ( ) {
1325: return mImpl@var661 .@expr1073745320 mAstOperand1@var671 ;
1326: }
1327: const Token * astOperand1 ( ) const {
1328: return mImpl@var661 .@expr1073745321 mAstOperand1@var671 ;
1329: }
1330: Token * astOperand2 ( ) {
1331: return mImpl@var661 .@expr1073745322 mAstOperand2@var672 ;
1332: }
1333: const Token * astOperand2 ( ) const {
1334: return mImpl@var661 .@expr1073745323 mAstOperand2@var672 ;
1335: }
1336: Token * astParent ( ) {
1337: return mImpl@var661 .@expr1073745324 mAstParent@var673 ;
1338: }
1339: const Token * astParent ( ) const {
1340: return mImpl@var661 .@expr1073745325 mAstParent@var673 ;
1341: }
1342: Token * astSibling ( ) {
1343: if (@expr1073745326 !@expr1073745327 astParent (@expr3504 ) ) {
1344: return nullptr ; }
1345: if (@expr1073745329 this@expr3506 ==@expr1073745331 astParent (@expr3504 ) .@expr3509 astOperand1 (@expr3510 ) ) {
1346: return astParent (@expr3504 ) .@expr3512 astOperand2 (@expr3513 ) ; }
1347: else { if (@expr1073745338 this@expr3506 ==@expr1073745339 astParent (@expr3504 ) .@expr3512 astOperand2 (@expr3513 ) ) {
1348: return astParent (@expr3504 ) .@expr3509 astOperand1 (@expr3510 ) ; } }
1349: return nullptr ;
1350:
1351: }
1352: const Token * astSibling ( ) const {
1353: if (@expr1073745346 !@expr1073745347 astParent (@expr3524 ) ) {
1354: return nullptr ; }
1355: if (@expr1073745349 this@expr3526 ==@expr1073745351 astParent (@expr3524 ) .@expr3529 astOperand1 (@expr3530 ) ) {
1356: return astParent (@expr3524 ) .@expr3532 astOperand2 (@expr3533 ) ; }
1357: else { if (@expr1073745358 this@expr3526 ==@expr1073745359 astParent (@expr3524 ) .@expr3532 astOperand2 (@expr3533 ) ) {
1358: return astParent (@expr3524 ) .@expr3529 astOperand1 (@expr3530 ) ; } }
1359: return nullptr ;
1360:
1361: }
1362: Token * astTop ( ) {
1363: Token * ret@var674 ; ret@var674 =@expr1073745366 this@expr1073745367 ;
1364: while (@expr1073745368 ret@var674 .@expr3545 mImpl@var675 .@expr3546 mAstParent@var676 ) {
1365: ret@var674 =@expr1073745371 ret@var674 .@expr3545 mImpl@var675 .@expr3546 mAstParent@var676 ; }
1366: return ret@var674 ;
1367: }
1368:
1369: const Token * astTop ( ) const {
1370: const Token * ret@var677 ; ret@var677 =@expr1073745374 this@expr1073745375 ;
1371: while (@expr1073745376 ret@var677 .@expr3553 mImpl@var678 .@expr3554 mAstParent@var679 ) {
1372: ret@var677 =@expr1073745379 ret@var677 .@expr3553 mImpl@var678 .@expr3554 mAstParent@var679 ; }
1373: return ret@var677 ;
1374: }
1375:
1376: std :: pair < const Token * , const Token * > findExpressionStartEndTokens ( ) const ;
1377:
|
1384:
1385: bool isCalculation ( ) const ;
1386:
1387: void clearAst ( ) {
1388: mImpl@var661 .@expr1073745382 mAstOperand1@var671 =@expr1073745383 mImpl@var661 .@expr1073745384 mAstOperand2@var672 =@expr1073745385 mImpl@var661 .@expr1073745386 mAstParent@var673 =@expr1073745387 nullptr ;
1389: }
1390:
1391: void clearValueFlow ( ) {
1392: delete mImpl@var661 .@expr3564 mValues@var680 ;
1393: mImpl@var661 .@expr3564 mValues@var680 =@expr1073745390 nullptr ;
1394: }
1395:
1396: std :: string astString ( const char * sep@var681 = "" ) const {
1397: std ::@expr1073745391 string ret@var682 ;
1398: if (@expr1073745392 mImpl@var661 .@expr3569 mAstOperand1@var671 ) {
1399: ret@var682 =@expr1073745394 mImpl@var661 .@expr3569 mAstOperand1@var671 .@expr1073745396 astString (@expr1073745397 sep@var681 ) ; }
1400: if (@expr1073745398 mImpl@var661 .@expr3575 mAstOperand2@var672 ) {
1401: ret@var682 +=@expr1073745400 mImpl@var661 .@expr3575 mAstOperand2@var672 .@expr1073745402 astString (@expr1073745403 sep@var681 ) ; }
1402: return ret@var682 +@expr1073745404 sep@var681 +@expr1073745405 mStr@var655 ;
1403: }
1404:
1405: std :: string astStringVerbose ( ) const ;
1406:
1407: std :: string astStringZ3 ( ) const ;
1408:
1409: std :: string expressionString ( ) const ;
1410:
1411: void printAst ( bool verbose@var683 , bool xml@var684 , const std :: vector < std :: string > & fileNames@var685 , std :: ostream & out@var686 ) const ;
1412:
1413: void printValueFlow ( bool xml@var687 , std :: ostream & out@var688 ) const ;
1414:
1415: void scopeInfo ( std :: shared_ptr < ScopeInfo2 > newScopeInfo@var689 ) ;
1416: std :: shared_ptr < ScopeInfo2 > scopeInfo ( ) const ;
1417:
1418: void setCpp11init ( bool cpp11init@var690 ) const {
1419: mImpl@var661 .@expr1073745406 mCpp11init@var691 =@expr1073745407 cpp11init@var690 ?@expr1073745408 TokenImpl ::@expr3585 Cpp11init ::@expr1073745410 CPP11INIT :@expr1073745411 TokenImpl ::@expr3585 Cpp11init ::@expr1073745413 NOINIT ;
1420: }
1421: TokenImpl :: Cpp11init isCpp11init ( ) const {
1422: return mImpl@var661 .@expr1073745414 mCpp11init@var691 ;
1423: }
1424: } ;
1425:
1426: Token * findTypeEnd ( Token * tok@var709 ) ;
1427: const Token * findTypeEnd ( const Token * tok@var710 ) ;
1428: Token * findLambdaEndScope ( Token * tok@var711 ) ;
1429: const Token * findLambdaEndScope ( const Token * tok@var712 ) ;

##file cppcheck-2.8/lib/errortypes.h

1:
|
31:
32: class Token ;
33:
34:
35: struct InternalError {
36: enum Type { AST , SYNTAX , UNKNOWN_MACRO , INTERNAL , LIMIT , INSTANTIATION } ;
37: InternalError ( const Token * tok@var713 , const std :: string & errorMsg@var714 , Type type@var715 = INTERNAL ) ;
38: const Token * token@var716 ;
39: std :: string errorMessage@var717 ;
40: Type type@var718 ;
41: std :: string id@var719 ;
42: } ;
43:
44: class Certainty {
45: public:
46: enum CertaintyLevel {
47: normal , inconclusive , safe , experimental
48: } ;
49: } ;
50:
51: class Checks {
52: public:
53: enum CheckList {
54: unusedFunction , missingInclude , internalCheck
55: } ;
56: } ;
57:
58:
59: class Severity {
60: public:
61:
62:
63:
64: enum SeverityType {
65:
66:
67:
68: none ,
69:
|
73:
74: error ,
75:
|
79:
80: warning ,
81:
|
86:
87: style ,
88:
|
92:
93: performance ,
94:
|
100:
101: portability ,
102:
|
107:
108: information ,
109:
|
112:
113: debug
114: } ;
115:
116: static std :: string toString ( SeverityType severity@var720 ) ;
117: static SeverityType fromString ( const std :: string & severity@var721 ) ;
118: } ;
119:
120: struct CWE {
121: explicit CWE ( unsigned short cweId@var722 ) : id@var723 ( cweId@var722 ) { }
122: unsigned short id@var723 ;
123: } ;

##file cppcheck-2.8/lib/standards.h

1:
|
35:
36: struct Standards {
37:
38: enum cstd_t { C89 , C99 , C11 , CLatest = C11 } ; enum cstd_t c@var724 ;
39:
40:
41: enum cppstd_t { CPP03 , CPP11 , CPP14 , CPP17 , CPP20 , CPP23 , CPPLatest = CPP23 } ; enum cppstd_t cpp@var725 ;
42:
43:
44: std :: string stdValue@var726 ;
45:
46:
47: Standards ( ) : c@var724 ( CLatest ) , cpp@var725 ( CPPLatest ) { }
48:
49: bool setC ( const std :: string & str@var727 ) {
50: stdValue@var726 =@expr1073745415 str@var727 ;
51: if (@expr1073745416 str@var727 ==@expr1073745417 "c89" ||@expr1073745418 str@var727 ==@expr1073745419 "C89" ) {
52: c@var724 =@expr1073745420 C89 ;
53: return true ;
54: }
55: if (@expr1073745421 str@var727 ==@expr1073745422 "c99" ||@expr1073745423 str@var727 ==@expr1073745424 "C99" ) {
56: c@var724 =@expr1073745425 C99 ;
57: return true ;
58: }
59: if (@expr1073745426 str@var727 ==@expr1073745427 "c11" ||@expr1073745428 str@var727 ==@expr1073745429 "C11" ) {
60: c@var724 =@expr1073745430 C11 ;
61: return true ;
62: }
63: return false ;
64: }
65: const std :: string getC ( ) const {
66: switch (@expr1073745431 c@var724 ) {
67: case C89 :@expr3608 ;
68: return "c89" ;
69: case C99 :@expr3608 ;
70: return "c99" ;
71: case C11 :@expr3608 ;
72: return "c11" ;
73: }
74: return "" ;
75: }
76: static cstd_t getC ( const std :: string & std@var728 ) {
77: if (@expr1073745435 std@var728 ==@expr1073745436 "c89" ) {
78: return Standards ::@expr1073745437 C89 ;
79: }
80: if (@expr1073745438 std@var728 ==@expr1073745439 "c99" ) {
81: return Standards ::@expr1073745440 C99 ;
82: }
83: if (@expr1073745441 std@var728 ==@expr1073745442 "c11" ) {
84: return Standards ::@expr1073745443 C11 ;
85: }
86: return Standards ::@expr1073745444 CLatest ;
87: }
88: bool setCPP ( std :: string str@var729 ) {
89: stdValue@var726 =@expr1073745445 str@var729 ;
90: strTolower (@expr1073745446 str@var729 ) ;
91: cpp@var725 =@expr1073745447 getCPP (@expr1073745448 str@var729 ) ;
92: return !@expr1073745449 stdValue@var726 .@expr1073745450 empty (@expr1073745451 ) &&@expr1073745452 str@var729 ==@expr1073745453 getCPP (@expr1073745454 ) ;
93: }
94: std :: string getCPP ( ) const {
95: return getCPP (@expr1073745455 cpp@var725 ) ;
96: }
97: static std :: string getCPP ( cppstd_t std@var730 ) {
98: switch (@expr1073745456 std@var730 ) {
99: case CPP03 :@expr3633 ;
100: return "c++03" ;
101: case CPP11 :@expr3633 ;
102: return "c++11" ;
103: case CPP14 :@expr3633 ;
104: return "c++14" ;
105: case CPP17 :@expr3633 ;
106: return "c++17" ;
107: case CPP20 :@expr3633 ;
108: return "c++20" ;
109: case CPP23 :@expr3633 ;
110: return "c++23" ;
111: }
112: return "" ;
113: }
114: static cppstd_t getCPP ( const std :: string & std@var731 ) {
115: if (@expr1073745463 std@var731 ==@expr1073745464 "c++03" ) {
116: return Standards ::@expr1073745465 CPP03 ;
117: }
118: if (@expr1073745466 std@var731 ==@expr1073745467 "c++11" ) {
119: return Standards ::@expr1073745468 CPP11 ;
120: }
121: if (@expr1073745469 std@var731 ==@expr1073745470 "c++14" ) {
122: return Standards ::@expr1073745471 CPP14 ;
123: }
124: if (@expr1073745472 std@var731 ==@expr1073745473 "c++17" ) {
125: return Standards ::@expr1073745474 CPP17 ;
126: }
127: if (@expr1073745475 std@var731 ==@expr1073745476 "c++20" ) {
128: return Standards ::@expr1073745477 CPP20 ;
129: }
130: if (@expr1073745478 std@var731 ==@expr1073745479 "c++23" ) {
131: return Standards ::@expr1073745480 CPP23 ;
132: }
133: return Standards ::@expr1073745481 CPPLatest ;
134: }
135: } ;

##file cppcheck-2.8/lib/library.h

1:
|
37:
38: class Token ;
39: class Settings ;
40:
41: namespace tinyxml2 {
42: class XMLDocument ;
43: class XMLElement ;
44: }
45:
|
51:
52: class Library {
53: friend class TestSymbolDatabase ;
54:
55: public:
56: Library ( ) ;
57:
58: enum class ErrorCode { OK , FILE_NOT_FOUND , BAD_XML , UNKNOWN_ELEMENT , MISSING_ATTRIBUTE , BAD_ATTRIBUTE_VALUE , UNSUPPORTED_FORMAT , DUPLICATE_PLATFORM_TYPE , PLATFORM_TYPE_REDEFINED } ;
59:
60: class Error {
61: public:
62: Error ( ) : errorcode@var735 ( ErrorCode :: OK ) { }
63: explicit Error ( ErrorCode e@var732 ) : errorcode@var735 ( e@var732 ) { }
64: template < typename T >
65: Error ( ErrorCode e@var733 , T && r@var734 ) : errorcode@var735 ( e@var733 ) , reason@var736 ( r@var734 ) { }
66: ErrorCode errorcode@var735 ;
67: std :: string reason@var736 ;
68: } ;
69:
70: Error load ( const char exename@var737 [ ] , const char path@var738 [ ] ) ;
71: Error load ( const tinyxml2 :: XMLDocument & doc@var739 ) ;
72:
73:
74: bool loadxmldata ( const char xmldata@var740 [ ] , unsigned long len@var741 ) ;
75:
76: struct AllocFunc {
77: int groupId@var742 ;
78: int arg@var743 ;
79: enum class BufferSize { none , malloc , calloc , strdup } ;
80: BufferSize bufferSize@var744 ;
81: int bufferSizeArg1@var745 ;
82: int bufferSizeArg2@var746 ;
83: int reallocArg@var747 ;
84: bool initData@var748 ;
85: } ;
86:
87:
88: const AllocFunc * getAllocFuncInfo ( const Token * tok@var749 ) const ;
89:
90:
91: const AllocFunc * getDeallocFuncInfo ( const Token * tok@var750 ) const ;
92:
93:
94: const AllocFunc * getReallocFuncInfo ( const Token * tok@var751 ) const ;
95:
96:
97: int getAllocId ( const Token * tok@var752 , int arg@var753 ) const ;
98:
99:
100: int getDeallocId ( const Token * tok@var754 , int arg@var755 ) const ;
101:
102:
103: int getReallocId ( const Token * tok@var756 , int arg@var757 ) const ;
104:
105:
106: const AllocFunc * getAllocFuncInfo ( const char name@var758 [ ] ) const {
107: return getAllocDealloc (@expr1073745482 mAlloc@var1024 , name@var758 ) ;
108: }
109:
110:
111: const AllocFunc * getDeallocFuncInfo ( const char name@var759 [ ] ) const {
112: return getAllocDealloc (@expr1073745483 mDealloc@var1025 , name@var759 ) ;
113: }
114:
115:
116: int allocId ( const char name@var760 [ ] ) const {
117: const AllocFunc * af@var761 ; af@var761 =@expr1073745484 getAllocDealloc (@expr1073745485 mAlloc@var1024 , name@var760 ) ;
118: return af@var761 ?@expr1073745486 af@var761 .@expr1073745487 groupId@var762 :@expr1073745488 0 ;
119: }
120:
121:
122: int deallocId ( const char name@var763 [ ] ) const {
123: const AllocFunc * af@var764 ; af@var764 =@expr1073745489 getAllocDealloc (@expr1073745490 mDealloc@var1025 , name@var763 ) ;
124: return af@var764 ?@expr1073745491 af@var764 .@expr1073745492 groupId@var765 :@expr1073745493 0 ;
125: }
126:
127:
128: void setalloc ( const std :: string & functionname@var766 , int id@var767 , int arg@var768 ) {
129: mAlloc@var1024 [@expr3670 functionname@var766 ] .@expr1073745495 groupId@var2627 =@expr1073745496 id@var767 ;
130: mAlloc@var1024 [@expr3670 functionname@var766 ] .@expr1073745498 arg@var2628 =@expr1073745499 arg@var768 ;
131: }
132:
133: void setdealloc ( const std :: string & functionname@var769 , int id@var770 , int arg@var771 ) {
134: mDealloc@var1025 [@expr3676 functionname@var769 ] .@expr1073745501 groupId@var2629 =@expr1073745502 id@var770 ;
135: mDealloc@var1025 [@expr3676 functionname@var769 ] .@expr1073745504 arg@var2630 =@expr1073745505 arg@var771 ;
136: }
137:
138: void setrealloc ( const std :: string & functionname@var772 , int id@var773 , int arg@var774 , int reallocArg@var775 = 1 ) {
139: mRealloc@var1026 [@expr3682 functionname@var772 ] .@expr1073745507 groupId@var2631 =@expr1073745508 id@var773 ;
140: mRealloc@var1026 [@expr3682 functionname@var772 ] .@expr1073745510 arg@var2632 =@expr1073745511 arg@var774 ;
141: mRealloc@var1026 [@expr3682 functionname@var772 ] .@expr1073745513 reallocArg@var2633 =@expr1073745514 reallocArg@var775 ;
142: }
143:
144:
145: void setnoreturn ( const std :: string & funcname@var776 , bool noreturn@var777 ) {
146: mNoReturn@var1027 [@expr1073745515 funcname@var776 ] =@expr1073745516 noreturn@var777 ?@expr1073745517 FalseTrueMaybe ::@expr1073745518 True :@expr1073745519 FalseTrueMaybe ::@expr1073745520 False ;
147: }
148:
149: static bool isCompliantValidationExpression ( const char * p@var778 ) ;
150:
151:
152: static bool ismemory ( const int id@var779 ) {
153: return (@expr3697 (@expr3697 id@var779 >@expr1073745523 0 ) &&@expr1073745524 (@expr3697 (@expr3697 id@var779 &@expr1073745527 1 ) ==@expr1073745528 0 ) ) ;
154: }
155: static bool ismemory ( const AllocFunc * const func@var780 ) {
156: return (@expr3705 (@expr3705 func@var780 .@expr3707 groupId@var781 >@expr1073745532 0 ) &&@expr1073745533 (@expr3705 (@expr3705 func@var780 .@expr3707 groupId@var781 &@expr1073745537 1 ) ==@expr1073745538 0 ) ) ;
157: }
158:
159:
160: static bool isresource ( const int id@var782 ) {
161: return (@expr3715 (@expr3715 id@var782 >@expr1073745541 0 ) &&@expr1073745542 (@expr3715 (@expr3715 id@var782 &@expr1073745545 1 ) ==@expr1073745546 1 ) ) ;
162: }
163: static bool isresource ( const AllocFunc * const func@var783 ) {
164: return (@expr3723 (@expr3723 func@var783 .@expr3725 groupId@var784 >@expr1073745550 0 ) &&@expr1073745551 (@expr3723 (@expr3723 func@var783 .@expr3725 groupId@var784 &@expr1073745555 1 ) ==@expr1073745556 1 ) ) ;
165: }
166:
167: bool formatstr_function ( const Token * ftok@var785 ) const ;
168: int formatstr_argno ( const Token * ftok@var786 ) const ;
169: bool formatstr_scan ( const Token * ftok@var787 ) const ;
170: bool formatstr_secure ( const Token * ftok@var788 ) const ;
171:
172: struct NonOverlappingData {
173: int ptr1Arg@var789 ;
174: int ptr2Arg@var790 ;
175: int sizeArg@var791 ;
176: int strlenArg@var792 ;
177: } ;
178: const NonOverlappingData * getNonOverlappingData ( const Token * ftok@var793 ) const ;
179:
180: struct WarnInfo {
181: std :: string message@var794 ;
182: Standards standards@var795 ;
183: Severity :: SeverityType severity@var796 ;
184: } ;
185: std :: map < std :: string , WarnInfo > functionwarn@var797 ;
186:
187: const WarnInfo * getWarnInfo ( const Token * ftok@var798 ) const ;
188:
189:
190: bool isNotLibraryFunction ( const Token * ftok@var799 ) const ;
191: bool matchArguments ( const Token * ftok@var800 , const std :: string & functionName@var801 ) const ;
192:
193: enum class UseRetValType { NONE , DEFAULT , ERROR_CODE } ;
194: UseRetValType getUseRetValType ( const Token * ftok@var802 ) const ;
195:
196: const std :: string & returnValue ( const Token * ftok@var803 ) const ;
197: const std :: string & returnValueType ( const Token * ftok@var804 ) const ;
198: int returnValueContainer ( const Token * ftok@var805 ) const ;
199: std :: vector < long long > unknownReturnValues ( const Token * ftok@var806 ) const ;
200:
201: bool isnoreturn ( const Token * ftok@var807 ) const ;
202: bool isnotnoreturn ( const Token * ftok@var808 ) const ;
203:
204: bool isScopeNoReturn ( const Token * end@var809 , std :: string * unknownFunc@var810 ) const ;
205:
206: class Container {
207: public:
208: Container ( )
209: : type_templateArgNo@var820 ( -1 ) ,
210: size_templateArgNo@var822 ( -1 ) ,
211: arrayLike_indexOp@var823 ( false ) ,
212: stdStringLike@var824 ( false ) ,
213: stdAssociativeLike@var825 ( false ) ,
214: opLessAllowed@var826 ( true ) ,
215: hasInitializerListConstructor@var827 ( false ) ,
216: unstableErase@var828 ( false ) ,
217: unstableInsert@var829 ( false ) ,
218: view@var830 ( false )
219: { }
220:
221: enum class Action {
222: RESIZE ,
223: CLEAR ,
224: PUSH ,
225: POP ,
226: FIND ,
227: INSERT ,
228: ERASE ,
229: CHANGE_CONTENT ,
230: CHANGE ,
231: CHANGE_INTERNAL ,
232: NO_ACTION
233: } ;
234: enum class Yield {
235: AT_INDEX ,
236: ITEM ,
237: BUFFER ,
238: BUFFER_NT ,
239: START_ITERATOR ,
240: END_ITERATOR ,
241: ITERATOR ,
242: SIZE ,
243: EMPTY ,
244: NO_YIELD
245: } ;
246: struct Function {
247: Action action@var811 ;
248: Yield yield@var812 ;
249: } ;
250: struct RangeItemRecordTypeItem {
251: std :: string name@var813 ;
252: int templateParameter@var814 ;
253: } ;
254: std :: string startPattern@var815 ; std :: string startPattern2@var816 ; std :: string endPattern@var817 ; std :: string itEndPattern@var818 ;
255: std :: map < std :: string , Function > functions@var819 ;
256: int type_templateArgNo@var820 ;
257: std :: vector < RangeItemRecordTypeItem > rangeItemRecordType@var821 ;
258: int size_templateArgNo@var822 ;
259: bool arrayLike_indexOp@var823 ;
260: bool stdStringLike@var824 ;
261: bool stdAssociativeLike@var825 ;
262: bool opLessAllowed@var826 ;
263: bool hasInitializerListConstructor@var827 ;
264: bool unstableErase@var828 ;
265: bool unstableInsert@var829 ;
266: bool view@var830 ;
267:
268: Action getAction ( const std :: string & function@var831 ) const {
269: const std ::@expr1073745557 map < std ::@expr1073745558 string , Function > ::@expr1073745559 const_iterator i@var832 =@expr1073745560 functions@var819 .@expr1073745561 find (@expr1073745562 function@var831 ) ;
270: if (@expr1073745563 i@var832 !=@expr1073745564 functions@var819 .@expr1073745565 end (@expr1073745566 ) ) {
271: return i@var832 .@expr1073745567 second@var833 .@expr1073745568 action@var834 ; }
272: return Action ::@expr1073745569 NO_ACTION ;
273: }
274:
275: Yield getYield ( const std :: string & function@var835 ) const {
276: const std ::@expr1073745570 map < std ::@expr1073745571 string , Function > ::@expr1073745572 const_iterator i@var836 =@expr1073745573 functions@var819 .@expr1073745574 find (@expr1073745575 function@var835 ) ;
277: if (@expr1073745576 i@var836 !=@expr1073745577 functions@var819 .@expr1073745578 end (@expr1073745579 ) ) {
278: return i@var836 .@expr1073745580 second@var837 .@expr1073745581 yield@var838 ; }
279: return Yield ::@expr1073745582 NO_YIELD ;
280: }
281:
282: static Yield yieldFrom ( const std :: string & yieldName@var839 ) ;
283: static Action actionFrom ( const std :: string & actionName@var840 ) ;
284: } ;
285: std :: map < std :: string , Container > containers@var841 ;
286: const Container * detectContainer ( const Token * typeStart@var842 , bool iterator@var843 = false ) const ;
287: const Container * detectContainerOrIterator ( const Token * typeStart@var844 , bool * isIterator@var845 = nullptr ) const ;
288:
289: class ArgumentChecks {
290: public:
291: ArgumentChecks ( ) :
292: notbool@var846 ( false ) ,
293: notnull@var847 ( false ) ,
294: notuninit@var848 ( -1 ) ,
295: formatstr@var849 ( false ) ,
296: strz@var850 ( false ) ,
297: optional@var851 ( false ) ,
298: variadic@var852 ( false ) ,
299: iteratorInfo@var858 ( ) ,
300: direction@var866 ( Direction :: DIR_UNKNOWN ) { }
301:
302: bool notbool@var846 ;
303: bool notnull@var847 ;
304: int notuninit@var848 ;
305: bool formatstr@var849 ;
306: bool strz@var850 ;
307: bool optional@var851 ;
308: bool variadic@var852 ;
309: std :: string valid@var853 ;
310:
311: class IteratorInfo {
312: public:
313: IteratorInfo ( ) : container@var854 ( 0 ) , it@var855 ( false ) , first@var856 ( false ) , last@var857 ( false ) { }
314:
315: int container@var854 ;
316: bool it@var855 ;
317: bool first@var856 ;
318: bool last@var857 ;
319: } ;
320: IteratorInfo iteratorInfo@var858 ;
321:
322: class MinSize {
323: public:
324: enum class Type { NONE , STRLEN , ARGVALUE , SIZEOF , MUL , VALUE } ;
325: MinSize ( Type t@var859 , int a@var860 ) : type@var861 ( t@var859 ) , arg@var862 ( a@var860 ) , arg2@var863 ( 0 ) , value@var864 ( 0 ) { }
326: Type type@var861 ;
327: int arg@var862 ;
328: int arg2@var863 ;
329: long long value@var864 ;
330: } ;
331: std :: vector < MinSize > minsizes@var865 ;
332:
333: enum class Direction {
334: DIR_IN ,
335: DIR_OUT ,
336: DIR_INOUT ,
337: DIR_UNKNOWN
338: } ;
339: Direction direction@var866 ;
340: } ;
341:
342: struct Function {
343: std :: map < int , ArgumentChecks > argumentChecks@var867 ;
344: bool use@var868 ;
345: bool leakignore@var869 ;
346: bool isconst@var870 ;
347: bool ispure@var871 ;
348: UseRetValType useretval@var872 ;
349: bool ignore@var873 ;
350: bool formatstr@var874 ;
351: bool formatstr_scan@var875 ;
352: bool formatstr_secure@var876 ;
353: Container :: Action containerAction@var877 ;
354: Container :: Yield containerYield@var878 ;
355: Function ( )
356: : use@var868 ( false ) ,
357: leakignore@var869 ( false ) ,
358: isconst@var870 ( false ) ,
359: ispure@var871 ( false ) ,
360: useretval@var872 ( UseRetValType :: NONE ) ,
361: ignore@var873 ( false ) ,
362: formatstr@var874 ( false ) ,
363: formatstr_scan@var875 ( false ) ,
364: formatstr_secure@var876 ( false ) ,
365: containerAction@var877 ( Container :: Action :: NO_ACTION ) ,
366: containerYield@var878 ( Container :: Yield :: NO_YIELD )
367: { }
368: } ;
369:
370: const Function * getFunction ( const Token * ftok@var879 ) const ;
371: std :: unordered_map < std :: string , Function > functions@var880 ;
372: bool isUse ( const std :: string & functionName@var881 ) const ;
373: bool isLeakIgnore ( const std :: string & functionName@var882 ) const ;
374: bool isFunctionConst ( const std :: string & functionName@var883 , bool pure@var884 ) const ;
375: bool isFunctionConst ( const Token * ftok@var885 ) const ;
376:
377: bool isboolargbad ( const Token * ftok@var886 , int argnr@var887 ) const {
378: const ArgumentChecks * arg@var888 ; arg@var888 =@expr1073745583 getarg (@expr1073745584 ftok@var886 , argnr@var887 ) ;
379: return arg@var888 &&@expr1073745585 arg@var888 .@expr1073745586 notbool@var889 ;
380: }
381:
382: bool isnullargbad ( const Token * ftok@var890 , int argnr@var891 ) const ;
383: bool isuninitargbad ( const Token * ftok@var892 , int argnr@var893 , int indirect@var894 = 0 , bool * hasIndirect@var895 = nullptr ) const ;
384:
385: bool isargformatstr ( const Token * ftok@var896 , int argnr@var897 ) const {
386: const ArgumentChecks * arg@var898 ; arg@var898 =@expr1073745587 getarg (@expr1073745588 ftok@var896 , argnr@var897 ) ;
387: return arg@var898 &&@expr1073745589 arg@var898 .@expr1073745590 formatstr@var899 ;
388: }
389:
390: bool isargstrz ( const Token * ftok@var900 , int argnr@var901 ) const {
391: const ArgumentChecks * arg@var902 ; arg@var902 =@expr1073745591 getarg (@expr1073745592 ftok@var900 , argnr@var901 ) ;
392: return arg@var902 &&@expr1073745593 arg@var902 .@expr1073745594 strz@var903 ;
393: }
394:
395: bool isIntArgValid ( const Token * ftok@var904 , int argnr@var905 , const long long argvalue@var906 ) const ;
396: bool isFloatArgValid ( const Token * ftok@var907 , int argnr@var908 , double argvalue@var909 ) const ;
397:
398: const std :: string & validarg ( const Token * ftok@var910 , int argnr@var911 ) const {
399: const ArgumentChecks * arg@var912 ; arg@var912 =@expr1073745595 getarg (@expr1073745596 ftok@var910 , argnr@var911 ) ;
400: return arg@var912 ?@expr1073745597 arg@var912 .@expr1073745598 valid@var913 :@expr1073745599 emptyString@var1 ;
401: }
402:
403: struct InvalidArgValue {
404: enum class Type { le , lt , eq , ge , gt , range } ; enum Type type@var914 ;
405: std :: string op1@var915 ;
406: std :: string op2@var916 ;
407: bool isInt ( ) const {
408: return MathLib ::@expr1073745600 isInt (@expr1073745601 op1@var915 ) ;
409: }
410: } ;
411:
412: const ArgumentChecks :: IteratorInfo * getArgIteratorInfo ( const Token * ftok@var917 , int argnr@var918 ) const {
413: const ArgumentChecks * arg@var919 ; arg@var919 =@expr1073745602 getarg (@expr1073745603 ftok@var917 , argnr@var918 ) ;
414: return arg@var919 &&@expr1073745604 arg@var919 .@expr3781 iteratorInfo@var920 .@expr1073745606 it@var921 ?@expr1073745607 &@expr1073745608 arg@var919 .@expr3781 iteratorInfo@var920 :@expr1073745610 nullptr ;
415: }
416:
417: bool hasminsize ( const Token * ftok@var922 ) const ;
418:
419: const std :: vector < ArgumentChecks :: MinSize > * argminsizes ( const Token * ftok@var923 , int argnr@var924 ) const {
420: const ArgumentChecks * arg@var925 ; arg@var925 =@expr1073745611 getarg (@expr1073745612 ftok@var923 , argnr@var924 ) ;
421: return arg@var925 ?@expr1073745613 &@expr1073745614 arg@var925 .@expr1073745615 minsizes@var926 :@expr1073745616 nullptr ;
422: }
423:
424: ArgumentChecks :: Direction getArgDirection ( const Token * ftok@var927 , int argnr@var928 ) const ;
425:
426: bool markupFile ( const std :: string & path@var929 ) const ;
427:
428: bool processMarkupAfterCode ( const std :: string & path@var930 ) const ;
429:
430: const std :: set < std :: string > & markupExtensions ( ) const {
431: return mMarkupExtensions@var1034 ;
432: }
433:
434: bool reportErrors ( const std :: string & path@var931 ) const ;
435:
436: bool ignorefunction ( const std :: string & functionName@var932 ) const ;
437:
438: bool isexecutableblock ( const std :: string & file@var933 , const std :: string & token@var934 ) const ;
439:
440: int blockstartoffset ( const std :: string & file@var935 ) const ;
441:
442: const std :: string & blockstart ( const std :: string & file@var936 ) const ;
443: const std :: string & blockend ( const std :: string & file@var937 ) const ;
444:
445: bool iskeyword ( const std :: string & file@var938 , const std :: string & keyword@var939 ) const ;
446:
447: bool isexporter ( const std :: string & prefix@var940 ) const {
448: return mExporters@var1037 .@expr1073745617 find (@expr1073745618 prefix@var940 ) !=@expr1073745619 mExporters@var1037 .@expr1073745620 end (@expr1073745621 ) ;
449: }
450:
451: bool isexportedprefix ( const std :: string & prefix@var941 , const std :: string & token@var942 ) const {
452: const std ::@expr1073745622 map < std ::@expr1073745623 string , ExportedFunctions > ::@expr1073745624 const_iterator it@var943 =@expr1073745625 mExporters@var1037 .@expr1073745626 find (@expr1073745627 prefix@var941 ) ;
453: return (@expr1073745628 it@var943 !=@expr1073745629 mExporters@var1037 .@expr1073745630 end (@expr1073745631 ) &&@expr1073745632 it@var943 .@expr1073745633 second@var944 .@expr1073745634 isPrefix (@expr1073745635 token@var942 ) ) ;
454: }
455:
456: bool isexportedsuffix ( const std :: string & prefix@var945 , const std :: string & token@var946 ) const {
457: const std ::@expr1073745636 map < std ::@expr1073745637 string , ExportedFunctions > ::@expr1073745638 const_iterator it@var947 =@expr1073745639 mExporters@var1037 .@expr1073745640 find (@expr1073745641 prefix@var945 ) ;
458: return (@expr1073745642 it@var947 !=@expr1073745643 mExporters@var1037 .@expr1073745644 end (@expr1073745645 ) &&@expr1073745646 it@var947 .@expr1073745647 second@var948 .@expr1073745648 isSuffix (@expr1073745649 token@var946 ) ) ;
459: }
460:
461: bool isimporter ( const std :: string & file@var949 , const std :: string & importer@var950 ) const ;
462:
463: const Token * getContainerFromYield ( const Token * tok@var951 , Container :: Yield yield@var952 ) const ;
464: const Token * getContainerFromAction ( const Token * tok@var953 , Container :: Action action@var954 ) const ;
465:
466: bool isreflection ( const std :: string & token@var955 ) const {
467: return mReflection@var1039 .@expr1073745650 find (@expr1073745651 token@var955 ) !=@expr1073745652 mReflection@var1039 .@expr1073745653 end (@expr1073745654 ) ;
468: }
469:
470: int reflectionArgument ( const std :: string & token@var956 ) const {
471: const std ::@expr1073745655 map < std ::@expr1073745656 string , int > ::@expr1073745657 const_iterator it@var957 =@expr1073745658 mReflection@var1039 .@expr1073745659 find (@expr1073745660 token@var956 ) ;
472: if (@expr1073745661 it@var957 !=@expr1073745662 mReflection@var1039 .@expr1073745663 end (@expr1073745664 ) ) {
473: return it@var957 .@expr1073745665 second@var958 ; }
474: return -1 ;
475: }
476:
477: std :: vector < std :: string > defines@var959 ;
478:
479: struct SmartPointer {
480: std :: string name@var960 ; name@var960 = "" ;
481: bool unique@var961 ; unique@var961 = false ;
482: } ;
483:
484: std :: map < std :: string , SmartPointer > smartPointers@var962 ;
485: bool isSmartPointer ( const Token * tok@var963 ) const ;
486: const SmartPointer * detectSmartPointer ( const Token * tok@var964 ) const ;
487:
488: struct PodType {
489: unsigned int size@var965 ;
490: char sign@var966 ;
491: enum class Type { NO , BOOL , CHAR , SHORT , INT , LONG , LONGLONG } ; enum Type stdtype@var967 ;
492: } ;
493: const struct PodType * podtype ( const std :: string & name@var968 ) const {
494: const std ::@expr1073745666 unordered_map < std ::@expr1073745667 string , PodType > ::@expr1073745668 const_iterator it@var969 =@expr1073745669 mPodTypes@var1040 .@expr1073745670 find (@expr1073745671 name@var968 ) ;
495: return (@expr3848 it@var969 !=@expr1073745673 mPodTypes@var1040 .@expr1073745674 end (@expr1073745675 ) ) ?@expr1073745676 &@expr1073745677 (@expr3848 it@var969 .@expr1073745679 second@var970 ) :@expr1073745680 nullptr ;
496: }
497:
498: struct PlatformType {
499: PlatformType ( )
500: : mSigned@var981 ( false )
501: , mUnsigned@var982 ( false )
502: , mLong@var983 ( false )
503: , mPointer@var984 ( false )
504: , mPtrPtr@var985 ( false )
505: , mConstPtr@var986 ( false ) { }
506: bool operator== ( const PlatformType & type@var971 ) const {
507: return (@expr1073745681 mSigned@var981 ==@expr1073745682 type@var971 .@expr1073745683 mSigned@var972 &&@expr1073745684
508: mUnsigned@var982 ==@expr1073745685 type@var971 .@expr1073745686 mUnsigned@var973 &&@expr1073745687
509: mLong@var983 ==@expr1073745688 type@var971 .@expr1073745689 mLong@var974 &&@expr1073745690
510: mPointer@var984 ==@expr1073745691 type@var971 .@expr1073745692 mPointer@var975 &&@expr1073745693
511: mPtrPtr@var985 ==@expr1073745694 type@var971 .@expr1073745695 mPtrPtr@var976 &&@expr1073745696
512: mConstPtr@var986 ==@expr1073745697 type@var971 .@expr1073745698 mConstPtr@var977 &&@expr1073745699
513: mType@var980 ==@expr1073745700 type@var971 .@expr1073745701 mType@var978 ) ;
514: }
515: bool operator!= ( const PlatformType & type@var979 ) const {
516: return !@expr1073745702 (@expr1073745703 *@expr1073745704 this@expr1073745705 ==@expr1073745706 type@var979 ) ;
517: }
518: std :: string mType@var980 ;
519: bool mSigned@var981 ;
520: bool mUnsigned@var982 ;
521: bool mLong@var983 ;
522: bool mPointer@var984 ;
523: bool mPtrPtr@var985 ;
524: bool mConstPtr@var986 ;
525: } ;
526:
527: struct Platform {
528: const PlatformType * platform_type ( const std :: string & name@var987 ) const {
529: const std ::@expr1073745707 map < std ::@expr1073745708 string , PlatformType > ::@expr1073745709 const_iterator it@var988 =@expr1073745710 mPlatformTypes@var990 .@expr1073745711 find (@expr1073745712 name@var987 ) ;
530: return (@expr3889 it@var988 !=@expr1073745714 mPlatformTypes@var990 .@expr1073745715 end (@expr1073745716 ) ) ?@expr1073745717 &@expr1073745718 (@expr3889 it@var988 .@expr1073745720 second@var989 ) :@expr1073745721 nullptr ;
531: }
532: std :: map < std :: string , PlatformType > mPlatformTypes@var990 ;
533: } ;
534:
535: const PlatformType * platform_type ( const std :: string & name@var991 , const std :: string & platform@var992 ) const {
536: const std ::@expr1073745722 map < std ::@expr3899 string , Platform > ::@expr1073745724 const_iterator it@var993 =@expr1073745725 mPlatforms@var1042 .@expr1073745726 find (@expr1073745727 platform@var992 ) ;
537: if (@expr1073745728 it@var993 !=@expr1073745729 mPlatforms@var1042 .@expr1073745730 end (@expr1073745731 ) ) {
538: const PlatformType * const type@var994 ; type@var994 =@expr1073745732 it@var993 .@expr1073745733 second@var995 .@expr1073745734 platform_type (@expr1073745735 name@var991 ) ;
539: if (@expr1073745736 type@var994 ) {
540: return type@var994 ; }
541: }
542:
543: const std ::@expr1073745737 map < std ::@expr3899 string , PlatformType > ::@expr1073745739 const_iterator it2@var996 =@expr1073745740 mPlatformTypes@var1041 .@expr1073745741 find (@expr1073745742 name@var991 ) ;
544: return (@expr3919 it2@var996 !=@expr1073745744 mPlatformTypes@var1041 .@expr1073745745 end (@expr1073745746 ) ) ?@expr1073745747 &@expr1073745748 (@expr3919 it2@var996 .@expr1073745750 second@var997 ) :@expr1073745751 nullptr ;
545: }
546:
|
549:
550: std :: string getFunctionName ( const Token * ftok@var998 ) const ;
551:
552: static bool isContainerYield ( const Token * const cond@var999 , Library :: Container :: Yield y@var1000 , const std :: string & fallback@var1001 = "" ) ;
553:
554:
555: enum class TypeCheck { def , check , suppress } ;
556: TypeCheck getTypeCheck ( const std :: string & check@var1002 , const std :: string & typeName@var1003 ) const ;
557:
558: private:
559:
560: Error loadFunction ( const tinyxml2 :: XMLElement * const node@var1004 , const std :: string & name@var1005 , std :: set < std :: string > & unknown_elements@var1006 ) ;
561:
562: class ExportedFunctions {
563: public:
564: void addPrefix ( const std :: string & prefix@var1007 ) {
565: mPrefixes@var1011 .@expr1073745752 insert (@expr1073745753 prefix@var1007 ) ;
566: }
567: void addSuffix ( const std :: string & suffix@var1008 ) {
568: mSuffixes@var1012 .@expr1073745754 insert (@expr1073745755 suffix@var1008 ) ;
569: }
570: bool isPrefix ( const std :: string & prefix@var1009 ) const {
571: return (@expr1073745756 mPrefixes@var1011 .@expr1073745757 find (@expr1073745758 prefix@var1009 ) !=@expr1073745759 mPrefixes@var1011 .@expr1073745760 end (@expr1073745761 ) ) ;
572: }
573: bool isSuffix ( const std :: string & suffix@var1010 ) const {
574: return (@expr1073745762 mSuffixes@var1012 .@expr1073745763 find (@expr1073745764 suffix@var1010 ) !=@expr1073745765 mSuffixes@var1012 .@expr1073745766 end (@expr1073745767 ) ) ;
575: }
576:
577: private:
578: std :: set < std :: string > mPrefixes@var1011 ;
579: std :: set < std :: string > mSuffixes@var1012 ;
580: } ;
581: class CodeBlock {
582: public:
583: CodeBlock ( ) : mOffset@var1020 ( 0 ) { }
584:
585: void setStart ( const char * s@var1013 ) {
586: mStart@var1018 =@expr1073745768 s@var1013 ;
587: }
588: void setEnd ( const char * e@var1014 ) {
589: mEnd@var1019 =@expr1073745769 e@var1014 ;
590: }
591: void setOffset ( const int o@var1015 ) {
592: mOffset@var1020 =@expr1073745770 o@var1015 ;
593: }
594: void addBlock ( const char * blockName@var1016 ) {
595: mBlocks@var1021 .@expr1073745771 insert (@expr1073745772 blockName@var1016 ) ;
596: }
597: const std :: string & start ( ) const {
598: return mStart@var1018 ;
599: }
600: const std :: string & end ( ) const {
601: return mEnd@var1019 ;
602: }
603: int offset ( ) const {
604: return mOffset@var1020 ;
605: }
606: bool isBlock ( const std :: string & blockName@var1017 ) const {
607: return mBlocks@var1021 .@expr1073745773 find (@expr1073745774 blockName@var1017 ) !=@expr1073745775 mBlocks@var1021 .@expr1073745776 end (@expr1073745777 ) ;
608: }
609:
610: private:
611: std :: string mStart@var1018 ;
612: std :: string mEnd@var1019 ;
613: int mOffset@var1020 ;
614: std :: set < std :: string > mBlocks@var1021 ;
615: } ;
616: enum class FalseTrueMaybe { False , True , Maybe } ;
617: int mAllocId@var1022 ;
618: std :: set < std :: string > mFiles@var1023 ;
619: std :: map < std :: string , AllocFunc > mAlloc@var1024 ;
620: std :: map < std :: string , AllocFunc > mDealloc@var1025 ;
621: std :: map < std :: string , AllocFunc > mRealloc@var1026 ;
622: std :: unordered_map < std :: string , FalseTrueMaybe > mNoReturn@var1027 ;
623: std :: map < std :: string , std :: string > mReturnValue@var1028 ;
624: std :: map < std :: string , std :: string > mReturnValueType@var1029 ;
625: std :: map < std :: string , int > mReturnValueContainer@var1030 ;
626: std :: map < std :: string , std :: vector < long long > > mUnknownReturnValues@var1031 ;
627: std :: map < std :: string , bool > mReportErrors@var1032 ;
628: std :: map < std :: string , bool > mProcessAfterCode@var1033 ;
629: std :: set < std :: string > mMarkupExtensions@var1034 ;
630: std :: map < std :: string , std :: set < std :: string > > mKeywords@var1035 ;
631: std :: map < std :: string , CodeBlock > mExecutableBlocks@var1036 ;
632: std :: map < std :: string , ExportedFunctions > mExporters@var1037 ;
633: std :: map < std :: string , std :: set < std :: string > > mImporters@var1038 ;
634: std :: map < std :: string , int > mReflection@var1039 ;
635: std :: unordered_map < std :: string , PodType > mPodTypes@var1040 ;
636: std :: map < std :: string , PlatformType > mPlatformTypes@var1041 ;
637: std :: map < std :: string , Platform > mPlatforms@var1042 ;
638: std :: map < std :: pair < std :: string , std :: string > , TypeCheck > mTypeChecks@var1043 ;
639: std :: unordered_map < std :: string , NonOverlappingData > mNonOverlappingData@var1044 ;
640:
641: const ArgumentChecks * getarg ( const Token * ftok@var1045 , int argnr@var1046 ) const ;
642:
643: std :: string getFunctionName ( const Token * ftok@var1047 , bool * error@var1048 ) const ;
644:
645: static const AllocFunc * getAllocDealloc ( const std :: map < std :: string , AllocFunc > & data@var1049 , const std :: string & name@var1050 ) {
646: const std ::@expr1073745778 map < std ::@expr1073745779 string , AllocFunc > ::@expr1073745780 const_iterator it@var1051 =@expr1073745781 data@var1049 .@expr1073745782 find (@expr1073745783 name@var1050 ) ;
647: return (@expr1073745784 it@var1051 ==@expr1073745785 data@var1049 .@expr1073745786 end (@expr1073745787 ) ) ?@expr1073745788 nullptr :@expr1073745789 &@expr1073745790 it@var1051 .@expr1073745791 second@var1052 ;
648: }
649: } ;
650:
651: const Library :: Container * getLibraryContainer ( const Token * tok@var1053 ) ;
652:
653: std :: shared_ptr < Token > createTokenFromExpression ( const std :: string & returnValue@var1054 ,
654: const Settings * settings@var1055 ,
655: std :: unordered_map < int , const Token * > * lookupVarId@var1056 = nullptr ) ;

##file cppcheck-2.8/lib/symboldatabase.h

1:
|
39:
40: namespace cppcheck {
41: class Platform ;
42: }
43:
44: class ErrorLogger ;
45: class Function ;
46: class Scope ;
47: class Settings ;
48: class SymbolDatabase ;
49: class Tokenizer ;
50: class ValueType ;
51:
|
54:
55: enum class AccessControl { Public , Protected , Private , Global , Namespace , Argument , Local , Throw } ;
56:
|
59:
60: struct Dimension {
61: Dimension ( ) : tok@var1057 ( nullptr ) , num@var1058 ( 0 ) , known@var1059 ( true ) { }
62:
63: const Token * tok@var1057 ;
64: long long num@var1058 ;
65: bool known@var1059 ;
66: } ;
67:
68:
69: class Type {
70: public:
71: const Token * classDef@var1060 ;
72: const Scope * classScope@var1061 ;
73: const Scope * enclosingScope@var1062 ;
74: enum class NeedInitialization {
75: Unknown , True , False
76: } ; enum NeedInitialization needInitialization@var1063 ;
77:
78: class BaseInfo {
79: public:
80: BaseInfo ( ) :
81: type@var1065 ( nullptr ) , nameTok@var1066 ( nullptr ) , access@var1067 ( AccessControl :: Public ) , isVirtual@var1068 ( false ) { }
82:
83: std :: string name@var1064 ;
84: const Type * type@var1065 ;
85: const Token * nameTok@var1066 ;
86: AccessControl access@var1067 ;
87: bool isVirtual@var1068 ;
88:
89: bool operator< ( const BaseInfo & rhs@var1069 ) const {
90: return this@expr1073745792 .@expr1073745793 type@var1065 <@expr1073745794 rhs@var1069 .@expr1073745795 type@var1070 ;
91: }
92: } ;
93:
94: struct FriendInfo {
95: FriendInfo ( ) :
96: nameStart@var1071 ( nullptr ) , nameEnd@var1072 ( nullptr ) , type@var1073 ( nullptr ) { }
97:
98: const Token * nameStart@var1071 ;
99: const Token * nameEnd@var1072 ;
100: const Type * type@var1073 ;
101: } ;
102:
103: std :: vector < BaseInfo > derivedFrom@var1074 ;
104: std :: vector < FriendInfo > friendList@var1075 ;
105:
106: const Token * typeStart@var1076 ;
107: const Token * typeEnd@var1077 ;
108: long long sizeOf@var1078 ;
109:
110: Type ( const Token * classDef_@var1079 = nullptr , const Scope * classScope_@var1080 = nullptr , const Scope * enclosingScope_@var1081 = nullptr ) :
111: classDef@var1060 ( classDef_@var1079 ) ,
112: classScope@var1061 ( classScope_@var1080 ) ,
113: enclosingScope@var1062 ( enclosingScope_@var1081 ) ,
114: needInitialization@var1063 ( NeedInitialization :: Unknown ) ,
115: typeStart@var1076 ( nullptr ) ,
116: typeEnd@var1077 ( nullptr ) ,
117: sizeOf@var1078 ( 0 ) {
118: if (@expr1073745796 classDef_@var1079 &&@expr1073745797 classDef_@var1079 .@expr3974 str (@expr3975 ) ==@expr1073745800 "enum" ) {
119: needInitialization@var1063 =@expr1073745801 NeedInitialization ::@expr1073745802 True ; }
120: else { if (@expr1073745803 classDef_@var1079 &&@expr1073745804 classDef_@var1079 .@expr3974 str (@expr3975 ) ==@expr1073745807 "using" ) {
121: typeStart@var1076 =@expr1073745808 classDef@var1060 .@expr1073745809 tokAt (@expr1073745810 3 ) ;
122: typeEnd@var1077 =@expr1073745811 typeStart@var1076 ;
123: while (@expr1073745812 typeEnd@var1077 .@expr3989 next (@expr3990 ) &&@expr1073745815 typeEnd@var1077 .@expr3989 next (@expr3990 ) .@expr1073745818 str (@expr1073745819 ) !=@expr1073745820 ";" ) {
124: typeEnd@var1077 =@expr1073745821 typeEnd@var1077 .@expr3989 next (@expr3990 ) ; }
125: } }
126: }
127:
128: const std :: string & name ( ) const ;
129:
130: const std :: string & type ( ) const {
131: return classDef@var1060 ?@expr1073745824 classDef@var1060 .@expr1073745825 str (@expr1073745826 ) :@expr1073745827 emptyString@var1 ;
132: }
133:
134: bool isClassType ( ) const ;
135: bool isEnumType ( ) const ;
136: bool isStructType ( ) const ;
137: bool isUnionType ( ) const ;
138:
139: bool isTypeAlias ( ) const {
140: return classDef@var1060 &&@expr1073745828 classDef@var1060 .@expr1073745829 str (@expr1073745830 ) ==@expr1073745831 "using" ;
141: }
142:
143: const Token * initBaseInfo ( const Token * tok@var1082 , const Token * tok1@var1083 ) ;
144:
145: const Function * getFunction ( const std :: string & funcName@var1084 ) const ;
146:
|
151:
152: bool hasCircularDependencies ( std :: set < BaseInfo > * ancestors@var1085 = nullptr ) const ;
153:
|
158:
159: bool findDependency ( const Type * ancestor@var1086 ) const ;
160:
161: bool isDerivedFrom ( const std :: string & ancestor@var1087 ) const ;
162: } ;
163:
164: class Enumerator {
165: public:
166: explicit Enumerator ( const Scope * scope_@var1088 ) : scope@var1089 ( scope_@var1088 ) , name@var1090 ( nullptr ) , value@var1091 ( 0 ) , start@var1092 ( nullptr ) , end@var1093 ( nullptr ) , value_known@var1094 ( false ) { }
167: const Scope * scope@var1089 ;
168: const Token * name@var1090 ;
169: long long value@var1091 ;
170: const Token * start@var1092 ;
171: const Token * end@var1093 ;
172: bool value_known@var1094 ;
173: } ;
174:
175:
176: class Variable {
177:
178: enum Anonymous2 {
179: fIsMutable = ( 1 << 0 ) ,
180: fIsStatic = ( 1 << 1 ) ,
181: fIsConst = ( 1 << 2 ) ,
182: fIsExtern = ( 1 << 3 ) ,
183: fIsClass = ( 1 << 4 ) ,
184: fIsArray = ( 1 << 5 ) ,
185: fIsPointer = ( 1 << 6 ) ,
186: fIsReference = ( 1 << 7 ) ,
187: fIsRValueRef = ( 1 << 8 ) ,
188: fHasDefault = ( 1 << 9 ) ,
189: fIsStlType = ( 1 << 10 ) ,
190: fIsStlString = ( 1 << 11 ) ,
191: fIsFloatType = ( 1 << 12 ) ,
192: fIsVolatile = ( 1 << 13 ) ,
193: fIsSmartPointer = ( 1 << 14 ) ,
194: fIsMaybeUnused = ( 1 << 15 ) ,
195: fIsInit = ( 1 << 16 ) ,
196: } ;
197:
|
202:
203: bool getFlag ( unsigned int flag_@var1095 ) const {
204: return (@expr4008 (@expr4008 mFlags@var1131 &@expr1073745834 flag_@var1095 ) !=@expr1073745835 0 ) ;
205: }
206:
|
211:
212: void setFlag ( unsigned int flag_@var1096 , bool state_@var1097 ) {
213: mFlags@var1131 =@expr1073745836 state_@var1097 ?@expr1073745837 mFlags@var1131 |@expr1073745838 flag_@var1096 :@expr1073745839 mFlags@var1131 &@expr1073745840 ~@expr1073745841 flag_@var1096 ;
214: }
215:
|
221:
222: bool arrayDimensions ( const Settings * settings@var1098 , bool * isContainer@var1099 ) ;
223:
224: public:
225: Variable ( const Token * name_@var1100 , const Token * start_@var1101 , const Token * end_@var1102 ,
226: int index_@var1103 , AccessControl access_@var1104 , const Type * type_@var1105 ,
227: const Scope * scope_@var1106 , const Settings * settings@var1107 )
228: : mNameToken@var1126 ( name_@var1100 ) ,
229: mTypeStartToken@var1127 ( start_@var1101 ) ,
230: mTypeEndToken@var1128 ( end_@var1102 ) ,
231: mIndex@var1129 ( index_@var1103 ) ,
232: mAccess@var1130 ( access_@var1104 ) ,
233: mFlags@var1131 ( 0 ) ,
234: mType@var1132 ( type_@var1105 ) ,
235: mScope@var1133 ( scope_@var1106 ) ,
236: mValueType@var1134 ( nullptr ) {
237: evaluate (@expr1073745842 settings@var1107 ) ;
238: }
239:
240: Variable ( const Token * name_@var1108 , const std :: string & clangType@var1109 , const Token * typeStart@var1110 ,
241: const Token * typeEnd@var1111 , int index_@var1112 , AccessControl access_@var1113 ,
242: const Type * type_@var1114 , const Scope * scope_@var1115 ) ;
243:
244: Variable ( const Variable & var@var1116 , const Scope * scope@var1117 ) ;
245:
246: Variable ( const Variable & var@var1118 ) ;
247:
248: ~ Variable ( ) ;
249:
250: Variable & operator= ( const Variable & var@var1119 ) ;
251:
|
255:
256: const Token * nameToken ( ) const {
257: return mNameToken@var1126 ;
258: }
259:
|
267:
268: const Token * typeStartToken ( ) const {
269: return mTypeStartToken@var1127 ;
270: }
271:
|
279:
280: const Token * typeEndToken ( ) const {
281: return mTypeEndToken@var1128 ;
282: }
283:
|
290:
291: const Token * declEndToken ( ) const ;
292:
|
296:
297: const std :: string & name ( ) const {
298:
299: if (@expr1073745843 mNameToken@var1126 ) {
300: return mNameToken@var1126 .@expr1073745844 str (@expr1073745845 ) ; }
301:
302: return emptyString@var1 ;
303: }
304:
|
308:
309: int declarationId ( ) const {
310:
311: if (@expr1073745846 mNameToken@var1126 ) {
312: return mNameToken@var1126 .@expr1073745847 varId (@expr1073745848 ) ; }
313:
314: return 0 ;
315: }
316:
|
320:
321: int index ( ) const {
322: return mIndex@var1129 ;
323: }
324:
|
328:
329: bool isPublic ( ) const {
330: return mAccess@var1130 ==@expr1073745849 AccessControl ::@expr1073745850 Public ;
331: }
332:
|
336:
337: bool isProtected ( ) const {
338: return mAccess@var1130 ==@expr1073745851 AccessControl ::@expr1073745852 Protected ;
339: }
340:
|
344:
345: bool isPrivate ( ) const {
346: return mAccess@var1130 ==@expr1073745853 AccessControl ::@expr1073745854 Private ;
347: }
348:
|
352:
353: bool isGlobal ( ) const {
354: return mAccess@var1130 ==@expr1073745855 AccessControl ::@expr1073745856 Global ;
355: }
356:
|
360:
361: bool isNamespace ( ) const {
362: return mAccess@var1130 ==@expr1073745857 AccessControl ::@expr1073745858 Namespace ;
363: }
364:
|
368:
369: bool isArgument ( ) const {
370: return mAccess@var1130 ==@expr1073745859 AccessControl ::@expr1073745860 Argument ;
371: }
372:
|
376:
377: bool isLocal ( ) const {
378: return (@expr1073745862 mAccess@var1130 ==@expr1073745863 AccessControl ::@expr1073745864 Local@expr1073745861 ) &&@expr1073745865 !@expr1073745866 isExtern (@expr1073745867 ) ;
379: }
380:
|
384:
385: bool isMutable ( ) const {
386: return getFlag (@expr1073745868 fIsMutable ) ;
387: }
388:
|
392:
393: bool isVolatile ( ) const {
394: return getFlag (@expr1073745869 fIsVolatile ) ;
395: }
396:
|
400:
401: bool isStatic ( ) const {
402: return getFlag (@expr1073745870 fIsStatic ) ;
403: }
404:
|
408:
409: bool isExtern ( ) const {
410: return getFlag (@expr1073745871 fIsExtern ) ;
411: }
412:
|
416:
417: bool isConst ( ) const {
418: return getFlag (@expr1073745872 fIsConst ) ;
419: }
420:
|
424:
425: bool isThrow ( ) const {
426: return mAccess@var1130 ==@expr1073745873 AccessControl ::@expr1073745874 Throw ;
427: }
428:
|
432:
433: bool isClass ( ) const {
434: return getFlag (@expr1073745875 fIsClass ) ;
435: }
436:
|
440:
441: bool isArray ( ) const {
442: return getFlag (@expr1073745876 fIsArray ) &&@expr1073745877 !@expr1073745878 getFlag (@expr1073745879 fIsPointer ) ;
443: }
444:
|
448:
449: bool isPointer ( ) const {
450: return getFlag (@expr1073745880 fIsPointer ) ;
451: }
452:
|
456:
457: bool isPointerToArray ( ) const {
458: return isPointer (@expr1073745881 ) &&@expr1073745882 getFlag (@expr1073745883 fIsArray ) ;
459: }
460:
|
464:
465: bool isPointerArray ( ) const ;
466:
|
470:
471: bool isArrayOrPointer ( ) const {
472: return getFlag (@expr1073745884 fIsArray ) ||@expr1073745885 getFlag (@expr1073745886 fIsPointer ) ;
473: }
474:
|
478:
479: bool isReference ( ) const {
480: return getFlag (@expr1073745887 fIsReference ) ;
481: }
482:
|
486:
487: bool isRValueReference ( ) const {
488: return getFlag (@expr1073745888 fIsRValueRef ) ;
489: }
490:
|
494:
495: bool isUnsigned ( ) const ;
496:
|
500:
501: bool hasDefault ( ) const {
502: return getFlag (@expr1073745889 fHasDefault ) ;
503: }
504:
|
508:
509: bool isInit ( ) const {
510: return getFlag (@expr1073745890 fIsInit ) ;
511: }
512:
|
516:
517: const Type * type ( ) const {
518: return mType@var1132 ;
519: }
520:
|
524:
525: const Scope * typeScope ( ) const {
526: return mType@var1132 ?@expr1073745891 mType@var1132 .@expr1073745892 classScope@var1137 :@expr1073745893 nullptr ;
527: }
528:
|
532:
533: const Scope * scope ( ) const {
534: return mScope@var1133 ;
535: }
536:
|
540:
541: const std :: vector < Dimension > & dimensions ( ) const {
542: return mDimensions@var1135 ;
543: }
544:
|
548:
549: long long dimension ( int index_@var1120 ) const {
550: return mDimensions@var1135 [@expr1073745894 index_@var1120 ] .@expr1073745895 num@var2634 ;
551: }
552:
|
556:
557: bool dimensionKnown ( int index_@var1121 ) const {
558: return mDimensions@var1135 [@expr1073745896 index_@var1121 ] .@expr1073745897 known@var2635 ;
559: }
560:
|
568:
569: bool isStlType ( ) const {
570: return getFlag (@expr1073745898 fIsStlType ) ;
571: }
572:
|
580:
581: bool isStlStringType ( ) const {
582: return getFlag (@expr1073745899 fIsStlString ) ;
583: }
584:
585: bool isSmartPointer ( ) const {
586: return getFlag (@expr1073745900 fIsSmartPointer ) ;
587: }
588:
589: const Type * smartPointerType ( ) const ;
590:
|
600:
601: bool isStlType ( const std :: string & stlType@var1122 ) const {
602: return isStlType (@expr1073745901 ) &&@expr1073745902 stlType@var1122 ==@expr1073745903 mTypeStartToken@var1127 .@expr1073745904 strAt (@expr1073745905 2 ) ;
603: }
604:
|
614:
615: bool isStlType ( const std :: set < std :: string > & stlTypes@var1123 ) const {
616: return isStlType (@expr1073745906 ) &&@expr1073745907 stlTypes@var1123 .@expr1073745908 find (@expr1073745909 mTypeStartToken@var1127 .@expr1073745910 strAt (@expr1073745911 2 ) ) !=@expr1073745912 stlTypes@var1123 .@expr1073745913 end (@expr1073745914 ) ;
617: }
618:
|
622:
623: bool isFloatingType ( ) const {
624: return getFlag (@expr1073745915 fIsFloatType ) ;
625: }
626:
|
630:
631: bool isEnumType ( ) const {
632: return type (@expr4092 ) &&@expr1073745917 type (@expr4092 ) .@expr1073745919 isEnumType (@expr1073745920 ) ;
633: }
634:
635: bool isMaybeUnused ( ) const {
636: return getFlag (@expr1073745921 fIsMaybeUnused ) ;
637: }
638:
639: const ValueType * valueType ( ) const {
640: return mValueType@var1134 ;
641: }
642:
643: void setValueType ( const ValueType & valueType@var1124 ) ;
644:
645: AccessControl accessControl ( ) const {
646: return mAccess@var1130 ;
647: }
648:
649: std :: string getTypeName ( ) const ;
650:
651: private:
652:
653: friend class SymbolDatabase ;
654:
|
658:
659: void type ( const Type * t@var1125 ) {
660: mType@var1132 =@expr1073745922 t@var1125 ;
661: }
662:
663:
664: const Token * mNameToken@var1126 ;
665:
666:
667: const Token * mTypeStartToken@var1127 ;
668:
669:
670: const Token * mTypeEndToken@var1128 ;
671:
672:
673: int mIndex@var1129 ;
674:
675:
676: AccessControl mAccess@var1130 ;
677:
678:
679: unsigned int mFlags@var1131 ;
680:
681:
682: const Type * mType@var1132 ;
683:
684:
685: const Scope * mScope@var1133 ;
686:
687: ValueType * mValueType@var1134 ;
688:
689:
690: std :: vector < Dimension > mDimensions@var1135 ;
691:
692:
693: void evaluate ( const Settings * settings@var1136 ) ;
694: } ;
695:
696: class Function {
697:
698: friend class SymbolDatabase ;
699:
700:
701: enum Anonymous3 {
702: fHasBody = ( 1 << 0 ) ,
703: fIsInline = ( 1 << 1 ) ,
704: fIsConst = ( 1 << 2 ) ,
705: fHasVirtualSpecifier = ( 1 << 3 ) ,
706: fIsPure = ( 1 << 4 ) ,
707: fIsStatic = ( 1 << 5 ) ,
708: fIsStaticLocal = ( 1 << 6 ) ,
709: fIsExtern = ( 1 << 7 ) ,
710: fIsFriend = ( 1 << 8 ) ,
711: fIsExplicit = ( 1 << 9 ) ,
712: fIsDefault = ( 1 << 10 ) ,
713: fIsDelete = ( 1 << 11 ) ,
714: fHasOverrideSpecifier = ( 1 << 12 ) ,
715: fHasFinalSpecifier = ( 1 << 13 ) ,
716: fIsNoExcept = ( 1 << 14 ) ,
717: fIsThrow = ( 1 << 15 ) ,
718: fIsOperator = ( 1 << 16 ) ,
719: fHasLvalRefQual = ( 1 << 17 ) ,
720: fHasRvalRefQual = ( 1 << 18 ) ,
721: fIsVariadic = ( 1 << 19 ) ,
722: fIsVolatile = ( 1 << 20 ) ,
723: fHasTrailingReturnType = ( 1 << 21 ) ,
724: fIsEscapeFunction = ( 1 << 22 ) ,
725: fIsInlineKeyword = ( 1 << 23 ) ,
726: fIsConstexpr = ( 1 << 24 ) ,
727: } ;
728:
|
733:
734: bool getFlag ( unsigned int flag@var1138 ) const {
735: return (@expr4099 (@expr4099 mFlags@var1187 &@expr1073745925 flag@var1138 ) !=@expr1073745926 0 ) ;
736: }
737:
|
742:
743: void setFlag ( unsigned int flag@var1139 , bool state@var1140 ) {
744: mFlags@var1187 =@expr1073745927 state@var1140 ?@expr1073745928 mFlags@var1187 |@expr1073745929 flag@var1139 :@expr1073745930 mFlags@var1187 &@expr1073745931 ~@expr1073745932 flag@var1139 ;
745: }
746:
747: public:
748: enum Type { eConstructor , eCopyConstructor , eMoveConstructor , eOperatorEqual , eDestructor , eFunction , eLambda } ;
749:
750: Function ( const Tokenizer * mTokenizer@var1141 , const Token * tok@var1142 , const Scope * scope@var1143 , const Token * tokDef@var1144 , const Token * tokArgDef@var1145 ) ;
751: Function ( const Token * tokenDef@var1146 , const std :: string & clangType@var1147 ) ;
752:
753: const std :: string & name ( ) const {
754: return tokenDef@var1157 .@expr1073745933 str (@expr1073745934 ) ;
755: }
756:
757: std :: string fullName ( ) const ;
758:
759: int argCount ( ) const {
760: return argumentList@var1165 .@expr1073745935 size (@expr1073745936 ) ;
761: }
762: int minArgCount ( ) const {
763: return argumentList@var1165 .@expr1073745937 size (@expr1073745938 ) -@expr1073745939 initArgCount@var1166 ;
764: }
765: const Variable * getArgumentVar ( int num@var1148 ) const ;
766: int initializedArgCount ( ) const {
767: return initArgCount@var1166 ;
768: }
769: void addArguments ( const SymbolDatabase * symbolDatabase@var1149 , const Scope * scope@var1150 ) ;
770:
771:
772: bool isImplicitlyVirtual ( bool defaultVal@var1151 = false ) const ;
773:
774: std :: vector < const Function * > getOverloadedFunctions ( ) const ;
775:
776:
777: const Function * getOverriddenFunction ( bool * foundAllBaseClasses@var1152 = nullptr ) const ;
778:
779: bool isLambda ( ) const {
780: return type@var1167 ==@expr1073745940 eLambda ;
781: }
782:
783: bool isConstructor ( ) const {
784: return type@var1167 ==@expr1073745941 eConstructor ||@expr1073745942
785: type@var1167 ==@expr1073745943 eCopyConstructor ||@expr1073745944
786: type@var1167 ==@expr1073745945 eMoveConstructor ;
787: }
788:
789: bool isDestructor ( ) const {
790: return type@var1167 ==@expr1073745946 eDestructor ;
791: }
792: bool isAttributeConstructor ( ) const {
793: return tokenDef@var1157 .@expr1073745947 isAttributeConstructor (@expr1073745948 ) ;
794: }
795: bool isAttributeDestructor ( ) const {
796: return tokenDef@var1157 .@expr1073745949 isAttributeDestructor (@expr1073745950 ) ;
797: }
798: bool isAttributePure ( ) const {
799: return tokenDef@var1157 .@expr1073745951 isAttributePure (@expr1073745952 ) ;
800: }
801: bool isAttributeConst ( ) const {
802: return tokenDef@var1157 .@expr1073745953 isAttributeConst (@expr1073745954 ) ;
803: }
804: bool isAttributeNoreturn ( ) const {
805: return tokenDef@var1157 .@expr1073745955 isAttributeNoreturn (@expr1073745956 ) ;
806: }
807: bool isAttributeNothrow ( ) const {
808: return tokenDef@var1157 .@expr1073745957 isAttributeNothrow (@expr1073745958 ) ;
809: }
810: bool isAttributeNodiscard ( ) const {
811: return tokenDef@var1157 .@expr1073745959 isAttributeNodiscard (@expr1073745960 ) ;
812: }
813:
814: bool hasBody ( ) const {
815: return getFlag (@expr1073745961 fHasBody ) ;
816: }
817: bool isInline ( ) const {
818: return getFlag (@expr1073745962 fIsInline ) ;
819: }
820: bool isConst ( ) const {
821: return getFlag (@expr1073745963 fIsConst ) ;
822: }
823: bool hasVirtualSpecifier ( ) const {
824: return getFlag (@expr1073745964 fHasVirtualSpecifier ) ;
825: }
826: bool isPure ( ) const {
827: return getFlag (@expr1073745965 fIsPure ) ;
828: }
829: bool isStatic ( ) const {
830: return getFlag (@expr1073745966 fIsStatic ) ;
831: }
832: bool isStaticLocal ( ) const {
833: return getFlag (@expr1073745967 fIsStaticLocal ) ;
834: }
835: bool isExtern ( ) const {
836: return getFlag (@expr1073745968 fIsExtern ) ;
837: }
838: bool isFriend ( ) const {
839: return getFlag (@expr1073745969 fIsFriend ) ;
840: }
841: bool isExplicit ( ) const {
842: return getFlag (@expr1073745970 fIsExplicit ) ;
843: }
844: bool isDefault ( ) const {
845: return getFlag (@expr1073745971 fIsDefault ) ;
846: }
847: bool isDelete ( ) const {
848: return getFlag (@expr1073745972 fIsDelete ) ;
849: }
850: bool isNoExcept ( ) const {
851: return getFlag (@expr1073745973 fIsNoExcept ) ;
852: }
853: bool isThrow ( ) const {
854: return getFlag (@expr1073745974 fIsThrow ) ;
855: }
856: bool hasOverrideSpecifier ( ) const {
857: return getFlag (@expr1073745975 fHasOverrideSpecifier ) ;
858: }
859: bool hasFinalSpecifier ( ) const {
860: return getFlag (@expr1073745976 fHasFinalSpecifier ) ;
861: }
862: bool isOperator ( ) const {
863: return getFlag (@expr1073745977 fIsOperator ) ;
864: }
865: bool hasLvalRefQualifier ( ) const {
866: return getFlag (@expr1073745978 fHasLvalRefQual ) ;
867: }
868: bool hasRvalRefQualifier ( ) const {
869: return getFlag (@expr1073745979 fHasRvalRefQual ) ;
870: }
871: bool isVariadic ( ) const {
872: return getFlag (@expr1073745980 fIsVariadic ) ;
873: }
874: bool isVolatile ( ) const {
875: return getFlag (@expr1073745981 fIsVolatile ) ;
876: }
877: bool hasTrailingReturnType ( ) const {
878: return getFlag (@expr1073745982 fHasTrailingReturnType ) ;
879: }
880: void hasBody ( bool state@var1153 ) {
881: setFlag (@expr1073745983 fHasBody , state@var1153 ) ;
882: }
883: bool isInlineKeyword ( ) const {
884: return getFlag (@expr1073745984 fIsInlineKeyword ) ;
885: }
886:
887: bool isEscapeFunction ( ) const {
888: return getFlag (@expr1073745985 fIsEscapeFunction ) ;
889: }
890: void isEscapeFunction ( bool state@var1154 ) {
891: setFlag (@expr1073745986 fIsEscapeFunction , state@var1154 ) ;
892: }
893:
894: bool isConstexpr ( ) const {
895: return getFlag (@expr1073745987 fIsConstexpr ) ;
896: }
897: void isConstexpr ( bool state@var1155 ) {
898: setFlag (@expr1073745988 fIsConstexpr , state@var1155 ) ;
899: }
900: bool isSafe ( const Settings * settings@var1156 ) const ;
901:
902: const Token * tokenDef@var1157 ;
903: const Token * argDef@var1158 ;
904: const Token * token@var1159 ;
905: const Token * arg@var1160 ;
906: const Token * retDef@var1161 ;
907: const :: Type * retType@var1162 ;
908: const Scope * functionScope@var1163 ;
909: const Scope * nestedIn@var1164 ;
910: std :: list < Variable > argumentList@var1165 ;
911: int initArgCount@var1166 ;
912: Type type@var1167 ;
913: AccessControl access@var1168 ;
914: const Token * noexceptArg@var1169 ;
915: const Token * throwArg@var1170 ;
916: const Token * templateDef@var1171 ;
917: const Token * functionPointerUsage@var1172 ;
918:
919: bool argsMatch ( const Scope * scope@var1173 , const Token * first@var1174 , const Token * second@var1175 , const std :: string & path@var1176 , int path_length@var1177 ) const ;
920:
921: static bool returnsConst ( const Function * function@var1178 , bool unknown@var1179 = false ) ;
922:
923: static bool returnsReference ( const Function * function@var1180 , bool unknown@var1181 = false ) ;
924:
925: static bool returnsVoid ( const Function * function@var1182 , bool unknown@var1183 = false ) ;
926:
927: static std :: vector < const Token * > findReturns ( const Function * f@var1184 ) ;
928:
929: const Token * returnDefEnd ( ) const {
930: if (@expr1073745989 this@expr1073745990 .@expr1073745991 hasTrailingReturnType (@expr1073745992 ) ) {
931: return Token ::@expr1073745993 findmatch (@expr1073745994 retDef@var1161 , "{|;" ) ;
932: } else {
933: return tokenDef@var1157 ;
934: }
935: }
936:
|
940:
941: const Token * constructorMemberInitialization ( ) const ;
942:
943: private:
944:
945: const Function * getOverriddenFunctionRecursive ( const :: Type * baseType@var1185 , bool * foundAllBaseClasses@var1186 ) const ;
946:
947: unsigned int mFlags@var1187 ;
948:
949: void isInline ( bool state@var1188 ) {
950: setFlag (@expr1073745995 fIsInline , state@var1188 ) ;
951: }
952: void isConst ( bool state@var1189 ) {
953: setFlag (@expr1073745996 fIsConst , state@var1189 ) ;
954: }
955: void hasVirtualSpecifier ( bool state@var1190 ) {
956: setFlag (@expr1073745997 fHasVirtualSpecifier , state@var1190 ) ;
957: }
958: void isPure ( bool state@var1191 ) {
959: setFlag (@expr1073745998 fIsPure , state@var1191 ) ;
960: }
961: void isStatic ( bool state@var1192 ) {
962: setFlag (@expr1073745999 fIsStatic , state@var1192 ) ;
963: }
964: void isStaticLocal ( bool state@var1193 ) {
965: setFlag (@expr1073746000 fIsStaticLocal , state@var1193 ) ;
966: }
967: void isExtern ( bool state@var1194 ) {
968: setFlag (@expr1073746001 fIsExtern , state@var1194 ) ;
969: }
970: void isFriend ( bool state@var1195 ) {
971: setFlag (@expr1073746002 fIsFriend , state@var1195 ) ;
972: }
973: void isExplicit ( bool state@var1196 ) {
974: setFlag (@expr1073746003 fIsExplicit , state@var1196 ) ;
975: }
976: void isDefault ( bool state@var1197 ) {
977: setFlag (@expr1073746004 fIsDefault , state@var1197 ) ;
978: }
979: void isDelete ( bool state@var1198 ) {
980: setFlag (@expr1073746005 fIsDelete , state@var1198 ) ;
981: }
982: void isNoExcept ( bool state@var1199 ) {
983: setFlag (@expr1073746006 fIsNoExcept , state@var1199 ) ;
984: }
985: void isThrow ( bool state@var1200 ) {
986: setFlag (@expr1073746007 fIsThrow , state@var1200 ) ;
987: }
988: void isOperator ( bool state@var1201 ) {
989: setFlag (@expr1073746008 fIsOperator , state@var1201 ) ;
990: }
991: void hasLvalRefQualifier ( bool state@var1202 ) {
992: setFlag (@expr1073746009 fHasLvalRefQual , state@var1202 ) ;
993: }
994: void hasRvalRefQualifier ( bool state@var1203 ) {
995: setFlag (@expr1073746010 fHasRvalRefQual , state@var1203 ) ;
996: }
997: void isVariadic ( bool state@var1204 ) {
998: setFlag (@expr1073746011 fIsVariadic , state@var1204 ) ;
999: }
1000: void isVolatile ( bool state@var1205 ) {
1001: setFlag (@expr1073746012 fIsVolatile , state@var1205 ) ;
1002: }
1003: void hasTrailingReturnType ( bool state@var1206 ) {
1004: return setFlag (@expr1073746013 fHasTrailingReturnType , state@var1206 ) ;
1005: }
1006: void isInlineKeyword ( bool state@var1207 ) {
1007: setFlag (@expr1073746014 fIsInlineKeyword , state@var1207 ) ;
1008: }
1009: const Token * setFlags ( const Token * tok1@var1208 , const Scope * scope@var1209 ) ;
1010: } ;
1011:
1012: class Scope {
1013:
1014: friend class TestSymbolDatabase ;
1015:
1016: public:
1017: struct UsingInfo {
1018: const Token * start@var1210 ;
1019: const Scope * scope@var1211 ;
1020: } ;
1021:
1022: enum ScopeType { eGlobal , eClass , eStruct , eUnion , eNamespace , eFunction , eIf , eElse , eFor , eWhile , eDo , eSwitch , eUnconditional , eTry , eCatch , eLambda , eEnum } ;
1023:
1024: Scope ( const SymbolDatabase * check_@var1212 , const Token * classDef_@var1213 , const Scope * nestedIn_@var1214 ) ;
1025: Scope ( const SymbolDatabase * check_@var1215 , const Token * classDef_@var1216 , const Scope * nestedIn_@var1217 , ScopeType type_@var1218 , const Token * start_@var1219 ) ;
1026:
1027: const SymbolDatabase * check@var1220 ;
1028: std :: string className@var1221 ;
1029: const Token * classDef@var1222 ;
1030: const Token * bodyStart@var1223 ;
1031: const Token * bodyEnd@var1224 ;
1032: std :: list < Function > functionList@var1225 ;
1033: std :: multimap < std :: string , const Function * > functionMap@var1226 ;
1034: std :: list < Variable > varlist@var1227 ;
1035: const Scope * nestedIn@var1228 ;
1036: std :: list < Scope * > nestedList@var1229 ;
1037: int numConstructors@var1230 ;
1038: int numCopyOrMoveConstructors@var1231 ;
1039: std :: list < UsingInfo > usingList@var1232 ;
1040: ScopeType type@var1233 ;
1041: Type * definedType@var1234 ;
1042: std :: map < std :: string , Type * > definedTypesMap@var1235 ;
1043: std :: vector < const Token * > bodyStartList@var1236 ;
1044:
1045:
1046: const Scope * functionOf@var1237 ;
1047: Function * function@var1238 ;
1048:
1049:
1050: const Token * enumType@var1239 ;
1051: bool enumClass@var1240 ;
1052:
1053: std :: vector < Enumerator > enumeratorList@var1241 ;
1054:
1055: void setBodyStartEnd ( const Token * start@var1242 ) {
1056: bodyStart@var1223 =@expr1073746015 start@var1242 ;
1057: bodyEnd@var1224 =@expr1073746016 start@var1242 ?@expr1073746017 start@var1242 .@expr1073746018 link (@expr1073746019 ) :@expr1073746020 nullptr ;
1058: if (@expr1073746021 start@var1242 ) {
1059: bodyStartList@var1236 .@expr1073746022 push_back (@expr1073746023 start@var1242 ) ; }
1060: }
1061:
1062: bool isAnonymous ( ) const {
1063:
1064: return className@var1221 .@expr1073746024 size (@expr1073746025 ) >@expr1073746026 9 &&@expr1073746027 className@var1221 .@expr1073746028 compare (@expr1073746029 0 , 9 , "Anonymous" ) ==@expr1073746030 0 &&@expr1073746031 std ::@expr1073746032 isdigit (@expr1073746033 className@var1221 [@expr1073746034 9 ] ) ;
1065: }
1066:
1067: const Enumerator * findEnumerator ( const std :: string & name@var1243 ) const {
1068: for (@expr1073746035 const Enumerator &@expr1073746036 i@var1244 :@expr1073746037 enumeratorList@var1241 ) {
1069: if (@expr1073746038 i@var1244 .@expr1073746039 name@var1245 .@expr1073746040 str (@expr1073746041 ) ==@expr1073746042 name@var1243 ) {
1070: return &@expr1073746043 i@var1244 ; }
1071: }
1072: return nullptr ;
1073: }
1074:
1075: bool isNestedIn ( const Scope * outer@var1246 ) const {
1076: if (@expr1073746044 !@expr1073746045 outer@var1246 ) {
1077: return false ; }
1078: if (@expr1073746046 outer@var1246 ==@expr1073746047 this@expr1073746048 ) {
1079: return true ; }
1080: const Scope * parent@var1247 ; parent@var1247 =@expr1073746049 nestedIn@var1228 ;
1081: while (@expr1073746050 outer@var1246 !=@expr1073746051 parent@var1247 &&@expr1073746052 parent@var1247 ) {
1082: parent@var1247 =@expr1073746053 parent@var1247 .@expr1073746054 nestedIn@var1248 ; }
1083: if (@expr1073746055 parent@var1247 &&@expr1073746056 parent@var1247 ==@expr1073746057 outer@var1246 ) {
1084: return true ; }
1085: return false ;
1086: }
1087:
1088: static Function * nestedInFunction ( const Scope * scope@var1249 ) {
1089: while (@expr1073746058 scope@var1249 ) {
1090: if (@expr1073746059 scope@var1249 .@expr1073746060 type@var1250 ==@expr1073746061 Scope ::@expr1073746062 eFunction ) {
1091: break ; }
1092: scope@var1249 =@expr1073746063 scope@var1249 .@expr1073746064 nestedIn@var1251 ;
1093: }
1094: if (@expr1073746065 !@expr1073746066 scope@var1249 ) {
1095: return nullptr ; }
1096: return scope@var1249 .@expr1073746067 function@var1252 ;
1097: }
1098:
1099: bool isClassOrStruct ( ) const {
1100: return (@expr1073746068 type@var1233 ==@expr1073746069 eClass ||@expr1073746070 type@var1233 ==@expr1073746071 eStruct ) ;
1101: }
1102:
1103: bool isClassOrStructOrUnion ( ) const {
1104: return (@expr1073746072 type@var1233 ==@expr1073746073 eClass ||@expr1073746074 type@var1233 ==@expr1073746075 eStruct ||@expr1073746076 type@var1233 ==@expr1073746077 eUnion ) ;
1105: }
1106:
1107: bool isExecutable ( ) const {
1108: return type@var1233 !=@expr1073746078 eClass &&@expr1073746079 type@var1233 !=@expr1073746080 eStruct &&@expr1073746081 type@var1233 !=@expr1073746082 eUnion &&@expr1073746083 type@var1233 !=@expr1073746084 eGlobal &&@expr1073746085 type@var1233 !=@expr1073746086 eNamespace &&@expr1073746087 type@var1233 !=@expr1073746088 eEnum ;
1109: }
1110:
1111: bool isLoopScope ( ) const {
1112: return type@var1233 ==@expr1073746089 Scope ::@expr4266 ScopeType ::@expr1073746091 eFor ||@expr1073746092 type@var1233 ==@expr1073746093 Scope ::@expr4266 ScopeType ::@expr1073746095 eWhile ||@expr1073746096 type@var1233 ==@expr1073746097 Scope ::@expr4266 ScopeType ::@expr1073746099 eDo ;
1113: }
1114:
1115: bool isLocal ( ) const {
1116: return (@expr1073746100 type@var1233 ==@expr1073746101 eIf ||@expr1073746102 type@var1233 ==@expr1073746103 eElse ||@expr1073746104
1117: type@var1233 ==@expr1073746105 eFor ||@expr1073746106 type@var1233 ==@expr1073746107 eWhile ||@expr1073746108 type@var1233 ==@expr1073746109 eDo ||@expr1073746110
1118: type@var1233 ==@expr1073746111 eSwitch ||@expr1073746112 type@var1233 ==@expr1073746113 eUnconditional ||@expr1073746114
1119: type@var1233 ==@expr1073746115 eTry ||@expr1073746116 type@var1233 ==@expr1073746117 eCatch ) ;
1120: }
1121:
1122:
1123: bool hasInlineOrLambdaFunction ( ) const ;
1124:
|
1130:
1131: const Function * findFunction ( const Token * tok@var1253 , bool requireConst@var1254 = false ) const ;
1132:
1133: const Scope * findRecordInNestedList ( const std :: string & name@var1255 , bool isC@var1256 = false ) const ;
1134: Scope * findRecordInNestedList ( const std :: string & name@var1257 ) {
1135: return const_cast < Scope *@expr4294 > (@expr1073746119 const_cast < const Scope *@expr4294 > (@expr1073746121 this@expr1073746122 ) .@expr1073746123 findRecordInNestedList (@expr1073746124 name@var1257 ) ) ;
1136: }
1137:
1138: const Type * findType ( const std :: string & name@var1258 ) const ;
1139: Type * findType ( const std :: string & name@var1259 ) {
1140: return const_cast < Type *@expr4301 > (@expr1073746126 const_cast < const Scope *@expr4301 > (@expr1073746128 this@expr1073746129 ) .@expr1073746130 findType (@expr1073746131 name@var1259 ) ) ;
1141: }
1142:
|
1146:
1147: Scope * findInNestedListRecursive ( const std :: string & name@var1260 ) ;
1148:
1149: void addVariable ( const Token * token_@var1261 , const Token * start_@var1262 ,
1150: const Token * end_@var1263 , AccessControl access_@var1264 , const Type * type_@var1265 ,
1151: const Scope * scope_@var1266 , const Settings * settings@var1267 ) ;
1152:
1153:
1154: void getVariableList ( const Settings * settings@var1268 ) ;
1155:
1156: const Function * getDestructor ( ) const ;
1157:
1158: void addFunction ( const Function & func@var1269 ) {
1159: functionList@var1225 .@expr1073746132 push_back (@expr1073746133 func@var1269 ) ;
1160:
1161: const Function * back@var1270 ; back@var1270 =@expr1073746134 &@expr1073746135 functionList@var1225 .@expr1073746136 back (@expr1073746137 ) ;
1162:
1163: functionMap@var1226 .@expr1073746138 insert (@expr1073746139 make_pair (@expr1073746140 back@var1270 .@expr1073746141 tokenDef@var1271 .@expr1073746142 str (@expr1073746143 ) , back@var1270 ) ) ;
1164: }
1165:
1166: bool hasDefaultConstructor ( ) const ;
1167:
1168: AccessControl defaultAccess ( ) const ;
1169:
|
1176:
1177: const Token * checkVariable ( const Token * tok@var1272 , AccessControl varaccess@var1273 , const Settings * settings@var1274 ) ;
1178:
|
1183:
1184: const Variable * getVariable ( const std :: string & varname@var1275 ) const ;
1185:
1186: const Token * addEnum ( const Token * tok@var1276 , bool isCpp@var1277 ) ;
1187:
1188: const Scope * findRecordInBase ( const std :: string & name@var1278 ) const ;
1189:
1190: std :: vector < const Scope * > findAssociatedScopes ( ) const ;
1191:
1192: private:
1193:
|
1199:
1200: bool isVariableDeclaration ( const Token * const tok@var1279 , const Token * & vartok@var1280 , const Token * & typetok@var1281 ) const ;
1201:
1202: void findFunctionInBase ( const std :: string & name@var1282 , int args@var1283 , std :: vector < const Function * > & matches@var1284 ) const ;
1203:
1204:
1205: void getVariableList ( const Settings * settings@var1285 , const Token * start@var1286 , const Token * end@var1287 ) ;
1206: } ;
1207:
1208: enum class Reference {
1209: None ,
1210: LValue ,
1211: RValue
1212: } ;
1213:
1214:
1215: class ValueType {
1216:
1217: enum Sign { UNKNOWN_SIGN , SIGNED , UNSIGNED } ; public: enum Sign sign@var1288 ;
1218: enum Type {
1219: UNKNOWN_TYPE ,
1220: POD ,
1221: NONSTD ,
1222: RECORD ,
1223: SMART_POINTER ,
1224: CONTAINER ,
1225: ITERATOR ,
1226: VOID ,
1227: BOOL ,
1228: CHAR ,
1229: SHORT ,
1230: WCHAR_T ,
1231: INT ,
1232: LONG ,
1233: LONGLONG ,
1234: UNKNOWN_INT ,
1235: FLOAT ,
1236: DOUBLE ,
1237: LONGDOUBLE
1238: } ; enum Type type@var1289 ;
1239: int bits@var1290 ;
1240: int pointer@var1291 ;
1241: int constness@var1292 ;
1242: Reference reference@var1293 ; reference@var1293 = Reference :: None ;
1243:
1244: const Scope * typeScope@var1294 ;
1245: const :: Type * smartPointerType@var1295 ;
1246: const Token * smartPointerTypeToken@var1296 ;
1247: const Library :: SmartPointer * smartPointer@var1297 ;
1248: const Library :: Container * container@var1298 ;
1249:
1250: const Token * containerTypeToken@var1299 ;
1251:
1252: std :: string originalTypeName@var1300 ;
1253:
1254:
1255: ValueType ( )
1256: : sign@var1288 ( UNKNOWN_SIGN ) ,
1257: type@var1289 ( UNKNOWN_TYPE ) ,
1258: bits@var1290 ( 0 ) ,
1259: pointer@var1291 ( 0U ) ,
1260: constness@var1292 ( 0U ) ,
1261: typeScope@var1294 ( nullptr ) ,
1262: smartPointerType@var1295 ( nullptr ) ,
1263: smartPointerTypeToken@var1296 ( nullptr ) ,
1264: smartPointer@var1297 ( nullptr ) ,
1265: container@var1298 ( nullptr ) ,
1266: containerTypeToken@var1299 ( nullptr )
1267: { }
1268: ValueType ( enum Sign s@var1301 , enum Type t@var1302 , int p@var1303 )
1269: : sign@var1288 ( s@var1301 ) ,
1270: type@var1289 ( t@var1302 ) ,
1271: bits@var1290 ( 0 ) ,
1272: pointer@var1291 ( p@var1303 ) ,
1273: constness@var1292 ( 0U ) ,
1274: typeScope@var1294 ( nullptr ) ,
1275: smartPointerType@var1295 ( nullptr ) ,
1276: smartPointerTypeToken@var1296 ( nullptr ) ,
1277: smartPointer@var1297 ( nullptr ) ,
1278: container@var1298 ( nullptr ) ,
1279: containerTypeToken@var1299 ( nullptr )
1280: { }
1281: ValueType ( enum Sign s@var1304 , enum Type t@var1305 , int p@var1306 , int c@var1307 )
1282: : sign@var1288 ( s@var1304 ) ,
1283: type@var1289 ( t@var1305 ) ,
1284: bits@var1290 ( 0 ) ,
1285: pointer@var1291 ( p@var1306 ) ,
1286: constness@var1292 ( c@var1307 ) ,
1287: typeScope@var1294 ( nullptr ) ,
1288: smartPointerType@var1295 ( nullptr ) ,
1289: smartPointerTypeToken@var1296 ( nullptr ) ,
1290: smartPointer@var1297 ( nullptr ) ,
1291: container@var1298 ( nullptr ) ,
1292: containerTypeToken@var1299 ( nullptr )
1293: { }
1294: ValueType ( enum Sign s@var1308 , enum Type t@var1309 , int p@var1310 , int c@var1311 , const std :: string & otn@var1312 )
1295: : sign@var1288 ( s@var1308 ) ,
1296: type@var1289 ( t@var1309 ) ,
1297: bits@var1290 ( 0 ) ,
1298: pointer@var1291 ( p@var1310 ) ,
1299: constness@var1292 ( c@var1311 ) ,
1300: typeScope@var1294 ( nullptr ) ,
1301: smartPointerType@var1295 ( nullptr ) ,
1302: smartPointerTypeToken@var1296 ( nullptr ) ,
1303: smartPointer@var1297 ( nullptr ) ,
1304: container@var1298 ( nullptr ) ,
1305: containerTypeToken@var1299 ( nullptr ) ,
1306: originalTypeName@var1300 ( otn@var1312 )
1307: { }
1308:
1309: static ValueType parseDecl ( const Token * type@var1313 , const Settings * settings@var1314 ) ;
1310:
1311: static Type typeFromString ( const std :: string & typestr@var1315 , bool longType@var1316 ) ;
1312:
1313: enum class MatchResult { UNKNOWN , SAME , FALLBACK1 , FALLBACK2 , NOMATCH } ;
1314: static MatchResult matchParameter ( const ValueType * call@var1317 , const ValueType * func@var1318 ) ;
1315: static MatchResult matchParameter ( const ValueType * call@var1319 , const Variable * callVar@var1320 , const Variable * funcVar@var1321 ) ;
1316:
1317: bool isPrimitive ( ) const {
1318: return (@expr1073746144 type@var1289 >=@expr1073746145 ValueType ::@expr1073746146 Type ::@expr1073746147 BOOL ) ;
1319: }
1320:
1321: bool isIntegral ( ) const {
1322: return (@expr1073746148 type@var1289 >=@expr1073746149 ValueType ::@expr4326 Type ::@expr1073746151 BOOL &&@expr1073746152 type@var1289 <=@expr1073746153 ValueType ::@expr4326 Type ::@expr1073746155 UNKNOWN_INT ) ;
1323: }
1324:
1325: bool isFloat ( ) const {
1326: return (@expr1073746156 type@var1289 >=@expr1073746157 ValueType ::@expr4334 Type ::@expr1073746159 FLOAT &&@expr1073746160 type@var1289 <=@expr1073746161 ValueType ::@expr4334 Type ::@expr1073746163 LONGDOUBLE ) ;
1327: }
1328:
1329: bool fromLibraryType ( const std :: string & typestr@var1322 , const Settings * settings@var1323 ) ;
1330:
1331: bool isEnum ( ) const {
1332: return typeScope@var1294 &&@expr1073746164 typeScope@var1294 .@expr1073746165 type@var1324 ==@expr1073746166 Scope ::@expr1073746167 eEnum ;
1333: }
1334:
1335: long long typeSize ( const cppcheck :: Platform & platform@var1325 , bool p@var1326 = false ) const ;
1336:
1337:
1338: bool isTypeEqual ( const ValueType * that@var1327 ) const ;
1339:
1340: std :: string str ( ) const ;
1341: std :: string dump ( ) const ;
1342: } ;
1343:
1344:
1345: class SymbolDatabase {
1346: friend class TestSymbolDatabase ;
1347: public:
1348: SymbolDatabase ( const Tokenizer * tokenizer@var1328 , const Settings * settings@var1329 , ErrorLogger * errorLogger@var1330 ) ;
1349: ~ SymbolDatabase ( ) ;
1350:
1351:
1352: std :: list < Scope > scopeList@var1331 ;
1353:
1354:
1355: std :: vector < const Scope * > functionScopes@var1332 ;
1356:
1357:
1358: std :: vector < const Scope * > classAndStructScopes@var1333 ;
1359:
1360:
1361: std :: list < Type > typeList@var1334 ;
1362:
|
1368:
1369: const Type * findVariableType ( const Scope * start@var1335 , const Token * typeTok@var1336 ) const ;
1370:
|
1375:
1376: const Function * findFunction ( const Token * tok@var1337 ) const ;
1377:
1378:
1379: const Scope * findScopeByName ( const std :: string & name@var1338 ) const ;
1380:
1381: const Type * findType ( const Token * startTok@var1339 , const Scope * startScope@var1340 , bool lookOutside@var1341 = false ) const ;
1382: Type * findType ( const Token * startTok@var1342 , Scope * startScope@var1343 , bool lookOutside@var1344 = false ) const {
1383: return const_cast < Type *@expr4344 > (@expr1073746169 this@expr1073746170 .@expr1073746171 findType (@expr1073746172 startTok@var1342 , const_cast < const Scope *@expr4344 > (@expr1073746174 startScope@var1343 ) , lookOutside@var1344 ) ) ;
1384: }
1385:
1386: const Scope * findScope ( const Token * tok@var1345 , const Scope * startScope@var1346 ) const ;
1387: Scope * findScope ( const Token * tok@var1347 , Scope * startScope@var1348 ) const {
1388: return const_cast < Scope *@expr4351 > (@expr1073746176 this@expr1073746177 .@expr1073746178 findScope (@expr1073746179 tok@var1347 , const_cast < const Scope *@expr4351 > (@expr1073746181 startScope@var1348 ) ) ) ;
1389: }
1390:
1391: bool isVarId ( int varid@var1349 ) const {
1392: return varid@var1349 <@expr1073746182 mVariableList@var1406 .@expr1073746183 size (@expr1073746184 ) ;
1393: }
1394:
1395: const Variable * getVariableFromVarId ( int varId@var1350 ) const {
1396: return mVariableList@var1406 .@expr1073746185 at (@expr1073746186 varId@var1350 ) ;
1397: }
1398:
1399: const std :: vector < const Variable * > & variableList ( ) const {
1400: return mVariableList@var1406 ;
1401: }
1402:
|
1405:
1406: void debugMessage ( const Token * tok@var1351 , const std :: string & type@var1352 , const std :: string & msg@var1353 ) const ;
1407:
1408: void printOut ( const char * title@var1354 = nullptr ) const ;
1409: void printVariable ( const Variable * var@var1355 , const char * indent@var1356 ) const ;
1410: void printXml ( std :: ostream & out@var1357 ) const ;
1411:
1412: bool isCPP ( ) const ;
1413:
|
1416:
1417: void validate ( ) const ;
1418:
1419: void validateExecutableScopes ( ) const ;
1420:
1421:
1422:
1423: void validateVariables ( ) const ;
1424:
1425:
1426: void setValueTypeInTokenList ( bool reportDebugWarnings@var1358 , Token * tokens@var1359 = nullptr ) ;
1427:
|
1432:
1433: int sizeOfType ( const Token * type@var1360 ) const ;
1434:
1435:
1436: void setArrayDimensionsUsingValueFlow ( ) ;
1437:
1438: void clangSetVariables ( const std :: vector < const Variable * > & variableList@var1361 ) ;
1439: void createSymbolDatabaseExprIds ( ) ;
1440:
1441: private:
1442: friend class Scope ;
1443: friend class Function ;
1444:
1445:
1446: void createSymbolDatabaseFindAllScopes ( ) ;
1447: void createSymbolDatabaseClassInfo ( ) ;
1448: void createSymbolDatabaseVariableInfo ( ) ;
1449: void createSymbolDatabaseCopyAndMoveConstructors ( ) ;
1450: void createSymbolDatabaseFunctionScopes ( ) ;
1451: void createSymbolDatabaseClassAndStructScopes ( ) ;
1452: void createSymbolDatabaseFunctionReturnTypes ( ) ;
1453: void createSymbolDatabaseNeedInitialization ( ) ;
1454: void createSymbolDatabaseVariableSymbolTable ( ) ;
1455: void createSymbolDatabaseSetScopePointers ( ) ;
1456: void createSymbolDatabaseSetFunctionPointers ( bool firstPass@var1362 ) ;
1457: void createSymbolDatabaseSetVariablePointers ( ) ;
1458:
1459: void createSymbolDatabaseSetTypePointers ( ) ;
1460: void createSymbolDatabaseSetSmartPointerType ( ) ;
1461: void createSymbolDatabaseEnums ( ) ;
1462: void createSymbolDatabaseEscapeFunctions ( ) ;
1463:
1464: void createSymbolDatabaseIncompleteVars ( ) ;
1465:
1466: void addClassFunction ( Scope * * scope@var1363 , const Token * * tok@var1364 , const Token * argStart@var1365 ) ;
1467: Function * addGlobalFunctionDecl ( Scope * & scope@var1366 , const Token * tok@var1367 , const Token * argStart@var1368 , const Token * funcStart@var1369 ) ;
1468: Function * addGlobalFunction ( Scope * & scope@var1370 , const Token * & tok@var1371 , const Token * argStart@var1372 , const Token * funcStart@var1373 ) ;
1469: void addNewFunction ( Scope * * scope@var1374 , const Token * * tok@var1375 ) ;
1470: bool isFunction ( const Token * tok@var1376 , const Scope * outerScope@var1377 , const Token * * funcStart@var1378 , const Token * * argStart@var1379 , const Token * * declEnd@var1380 ) const ;
1471: const Type * findTypeInNested ( const Token * startTok@var1381 , const Scope * startScope@var1382 ) const ;
1472: const Scope * findNamespace ( const Token * tok@var1383 , const Scope * scope@var1384 ) const ;
1473: Function * findFunctionInScope ( const Token * func@var1385 , const Scope * ns@var1386 , const std :: string & path@var1387 , int path_length@var1388 ) ;
1474: const Type * findVariableTypeInBase ( const Scope * scope@var1389 , const Token * typeTok@var1390 ) const ;
1475:
|
1478:
1479: void fixVarId ( std :: map < unsigned int , std :: map < unsigned int , unsigned int > > & varIds@var1391 , const Token * vartok@var1392 , Token * membertok@var1393 , const Variable * membervar@var1394 ) ;
1480:
1481:
1482: bool isReservedName ( const std :: string & iName@var1395 ) const ;
1483:
1484: const Enumerator * findEnumerator ( const Token * tok@var1396 ) const ;
1485:
1486: void setValueType ( Token * tok@var1397 , const ValueType & valuetype@var1398 ) ;
1487: void setValueType ( Token * tok@var1399 , const Variable & var@var1400 ) ;
1488: void setValueType ( Token * tok@var1401 , const Enumerator & enumerator@var1402 ) ;
1489:
1490: const Tokenizer * mTokenizer@var1403 ;
1491: const Settings * mSettings@var1404 ;
1492: ErrorLogger * mErrorLogger@var1405 ;
1493:
1494:
1495: std :: vector < const Variable * > mVariableList@var1406 ;
1496:
1497:
1498: std :: list < Type > mBlankTypes@var1407 ;
1499:
1500: bool mIsCpp@var1408 ;
1501: ValueType :: Sign mDefaultSignedness@var1409 ;
1502:
1503:
1504: mutable std :: set < std :: string > mTokensThatAreNotEnumeratorValues@var1410 ;
1505: } ;

##file cppcheck-2.8/lib/astutils.h

1:
|
34:
35: class Library ;
36: class Settings ;
37: class Token ;
38:
39: enum class ChildrenToVisit {
40: none ,
41: op1 ,
42: op2 ,
43: op1_and_op2 ,
44: done
45: } ;
46:
|
49:
50: template < class T , class TFunc , $class $= $typename $std $:: $enable_if $< std :: is_convertible < T * , const Token * > $:: $value $> $:: $type >
51: void visitAstNodes ( T * ast@var1411 , const TFunc & visitor@var1412 )
52: {
53: if (@expr1073746187 !@expr1073746188 ast@var1411 ) {
54: return ; }
55:
56: std ::@expr1073746189 stack < T *@expr4366 , std ::@expr1073746191 vector < T *@expr4366 > > tokens@var1413 ;
57: T * tok@var1414 ; tok@var1414 =@expr1073746193 ast@var1411 ;
58: do {
59: ChildrenToVisit c@var1415 ; c@var1415 =@expr1073746194 visitor@var1412 (@expr1073746195 tok@var1414 ) ;
60:
61: if (@expr1073746196 c@var1415 ==@expr1073746197 ChildrenToVisit ::@expr1073746198 done ) {
62: break ; }
63: if (@expr1073746199 c@var1415 ==@expr1073746200 ChildrenToVisit ::@expr1073746201 op2 ||@expr1073746202 c@var1415 ==@expr4379 ChildrenToVisit ::@expr4380 op1_and_op2 ) {
64: T * t2@var1416 ; t2@var1416 =@expr1073746205 tok@var1414 .@expr1073746206 astOperand2 (@expr1073746207 ) ;
65: if (@expr1073746208 t2@var1416 ) {
66: tokens@var1413 .@expr4385 push (@expr1073746210 t2@var1416 ) ; }
67: }
68: if (@expr1073746211 c@var1415 ==@expr1073746212 ChildrenToVisit ::@expr1073746213 op1 ||@expr1073746214 c@var1415 ==@expr4379 ChildrenToVisit ::@expr4380 op1_and_op2 ) {
69: T * t1@var1417 ; t1@var1417 =@expr1073746217 tok@var1414 .@expr1073746218 astOperand1 (@expr1073746219 ) ;
70: if (@expr1073746220 t1@var1417 ) {
71: tokens@var1413 .@expr4385 push (@expr1073746222 t1@var1417 ) ; }
72: }
73:
74: if (@expr1073746223 tokens@var1413 .@expr1073746224 empty (@expr1073746225 ) ) {
75: break ; }
76:
77: tok@var1414 =@expr1073746226 tokens@var1413 .@expr1073746227 top (@expr1073746228 ) ;
78: tokens@var1413 .@expr1073746229 pop (@expr1073746230 ) ;
79: } while (@expr1073746231 true ) ;
80: }
81:
82: const Token * findAstNode ( const Token * ast@var1418 , const std :: function < bool ( const Token * ) > & pred@var1419 ) ;
83: const Token * findExpression ( const int exprid@var1420 ,
84: const Token * start@var1421 ,
85: const Token * end@var1422 ,
86: const std :: function < bool ( const Token * ) > & pred@var1423 ) ;
87: const Token * findExpression ( const Token * start@var1424 , const int exprid@var1425 ) ;
88:
89: std :: vector < const Token * > astFlatten ( const Token * tok@var1426 , const char * op@var1427 ) ;
90: std :: vector < Token * > astFlatten ( Token * tok@var1428 , const char * op@var1429 ) ;
91:
92: int astCount ( const Token * tok@var1430 , const char * op@var1431 , int depth@var1432 = 100 ) ;
93:
94: bool astHasToken ( const Token * root@var1433 , const Token * tok@var1434 ) ;
95:
96: bool astHasVar ( const Token * tok@var1435 , int varid@var1436 ) ;
97:
98: bool astIsPrimitive ( const Token * tok@var1437 ) ;
99:
100: bool astIsSignedChar ( const Token * tok@var1438 ) ;
101:
102: bool astIsUnknownSignChar ( const Token * tok@var1439 ) ;
103:
104: bool astIsGenericChar ( const Token * tok@var1440 ) ;
105:
106: bool astIsIntegral ( const Token * tok@var1441 , bool unknown@var1442 ) ;
107: bool astIsUnsigned ( const Token * tok@var1443 ) ;
108:
109: bool astIsFloat ( const Token * tok@var1444 , bool unknown@var1445 ) ;
110:
111: bool astIsBool ( const Token * tok@var1446 ) ;
112:
113: bool astIsPointer ( const Token * tok@var1447 ) ;
114:
115: bool astIsSmartPointer ( const Token * tok@var1448 ) ;
116: bool astIsUniqueSmartPointer ( const Token * tok@var1449 ) ;
117:
118: bool astIsIterator ( const Token * tok@var1450 ) ;
119:
120: bool astIsContainer ( const Token * tok@var1451 ) ;
121:
122: bool astIsContainerView ( const Token * tok@var1452 ) ;
123: bool astIsContainerOwned ( const Token * tok@var1453 ) ;
124:
|
133:
134: std :: string astCanonicalType ( const Token * expr@var1454 ) ;
135:
136:
137: const Token * astIsVariableComparison ( const Token * tok@var1455 , const std :: string & comp@var1456 , const std :: string & rhs@var1457 , const Token * * vartok@var1458 = nullptr ) ;
138:
139: bool isVariableDecl ( const Token * tok@var1459 ) ;
140:
141: bool isTemporary ( bool cpp@var1460 , const Token * tok@var1461 , const Library * library@var1462 , bool unknown@var1463 = false ) ;
142:
143: const Token * previousBeforeAstLeftmostLeaf ( const Token * tok@var1464 ) ;
144: Token * previousBeforeAstLeftmostLeaf ( Token * tok@var1465 ) ;
145:
146: const Token * nextAfterAstRightmostLeaf ( const Token * tok@var1466 ) ;
147: Token * nextAfterAstRightmostLeaf ( Token * tok@var1467 ) ;
148:
149: Token * astParentSkipParens ( Token * tok@var1468 ) ;
150: const Token * astParentSkipParens ( const Token * tok@var1469 ) ;
151:
152: const Token * getParentMember ( const Token * tok@var1470 ) ;
153:
154: const Token * getParentLifetime ( const Token * tok@var1471 ) ;
155: const Token * getParentLifetime ( bool cpp@var1472 , const Token * tok@var1473 , const Library * library@var1474 ) ;
156:
157: bool astIsLHS ( const Token * tok@var1475 ) ;
158: bool astIsRHS ( const Token * tok@var1476 ) ;
159:
160: Token * getCondTok ( Token * tok@var1477 ) ;
161: const Token * getCondTok ( const Token * tok@var1478 ) ;
162:
163: Token * getInitTok ( Token * tok@var1479 ) ;
164: const Token * getInitTok ( const Token * tok@var1480 ) ;
165:
166: Token * getStepTok ( Token * tok@var1481 ) ;
167: const Token * getStepTok ( const Token * tok@var1482 ) ;
168:
169: Token * getCondTokFromEnd ( Token * endBlock@var1483 ) ;
170: const Token * getCondTokFromEnd ( const Token * endBlock@var1484 ) ;
171:
172:
173:
174: const Token * findNextTokenFromBreak ( const Token * breakToken@var1485 ) ;
175:
|
178:
179: bool extractForLoopValues ( const Token * forToken@var1486 ,
180: int * const varid@var1487 ,
181: bool * const knownInitValue@var1488 ,
182: long long * const initValue@var1489 ,
183: bool * const partialCond@var1490 ,
184: long long * const stepValue@var1491 ,
185: long long * const lastValue@var1492 ) ;
186:
187: bool precedes ( const Token * tok1@var1493 , const Token * tok2@var1494 ) ;
188: bool succeeds ( const Token * tok1@var1495 , const Token * tok2@var1496 ) ;
189:
190: bool exprDependsOnThis ( const Token * expr@var1497 , bool onVar@var1498 = true , int depth@var1499 = 0 ) ;
191:
192: struct ReferenceToken {
193: const Token * token@var1500 ;
194: std :: list < std :: pair < const Token * , std :: string > > errors@var1501 ;
195: } ;
196:
197: std :: vector < ReferenceToken > followAllReferences ( const Token * tok@var1502 ,
198: bool temporary@var1503 = true ,
199: bool inconclusive@var1504 = true ,
200: std :: list < std :: pair < const Token * , std :: string > > errors@var1505 = std :: list < std :: pair < const Token * , std :: string > > { } ,
201: int depth@var1506 = 20 ) ;
202: const Token * followReferences ( const Token * tok@var1507 , std :: list < std :: pair < const Token * , std :: string > > * errors@var1508 = nullptr ) ;
203:
204: bool isSameExpression ( bool cpp@var1509 , bool macro@var1510 , const Token * tok1@var1511 , const Token * tok2@var1512 , const Library & library@var1513 , bool pure@var1514 , bool followVar@var1515 , std :: list < std :: pair < const Token * , std :: string > > * errors@var1516 = nullptr ) ;
205:
206: bool isEqualKnownValue ( const Token * const tok1@var1517 , const Token * const tok2@var1518 ) ;
207:
|
210:
211: bool isUsedAsBool ( const Token * const tok@var1519 ) ;
212:
|
221:
222: bool isOppositeCond ( bool isNot@var1520 , bool cpp@var1521 , const Token * const cond1@var1522 , const Token * const cond2@var1523 , const Library & library@var1524 , bool pure@var1525 , bool followVar@var1526 , std :: list < std :: pair < const Token * , std :: string > > * errors@var1527 = nullptr ) ;
223:
224: bool isOppositeExpression ( bool cpp@var1528 , const Token * const tok1@var1529 , const Token * const tok2@var1530 , const Library & library@var1531 , bool pure@var1532 , bool followVar@var1533 , std :: list < std :: pair < const Token * , std :: string > > * errors@var1534 = nullptr ) ;
225:
226: bool isConstFunctionCall ( const Token * ftok@var1535 , const Library & library@var1536 ) ;
227:
228: bool isConstExpression ( const Token * tok@var1537 , const Library & library@var1538 , bool pure@var1539 , bool cpp@var1540 ) ;
229:
230: bool isWithoutSideEffects ( bool cpp@var1541 , const Token * tok@var1542 , bool checkArrayAccess@var1543 = false , bool checkReference@var1544 = true ) ;
231:
232: bool isUniqueExpression ( const Token * tok@var1545 ) ;
233:
234: bool isEscapeFunction ( const Token * ftok@var1546 , const Library * library@var1547 ) ;
235:
236:
237: bool isReturnScope ( const Token * const endToken@var1548 ,
238: const Library * library@var1549 = nullptr ,
239: const Token * * unknownFunc@var1550 = nullptr ,
240: bool functionScope@var1551 = false ) ;
241:
242:
243: bool isWithinScope ( const Token * tok@var1552 ,
244: const Variable * var@var1553 ,
245: Scope :: ScopeType type@var1554 ) ;
246:
247:
248: const Token * getTokenArgumentFunction ( const Token * tok@var1555 , int & argn@var1556 ) ;
249: Token * getTokenArgumentFunction ( Token * tok@var1557 , int & argn@var1558 ) ;
250:
251: std :: vector < const Variable * > getArgumentVars ( const Token * tok@var1559 , int argnr@var1560 ) ;
252:
|
261:
262: bool isVariableChangedByFunctionCall ( const Token * tok@var1561 , int indirect@var1562 , int varid@var1563 , const Settings * settings@var1564 , bool * inconclusive@var1565 ) ;
263:
|
271:
272: bool isVariableChangedByFunctionCall ( const Token * tok@var1566 , int indirect@var1567 , const Settings * settings@var1568 , bool * inconclusive@var1569 ) ;
273:
274:
275: bool isVariableChanged ( const Token * start@var1570 , const Token * end@var1571 , const int exprid@var1572 , bool globalvar@var1573 , const Settings * settings@var1574 , bool cpp@var1575 , int depth@var1576 = 20 ) ;
276: bool isVariableChanged ( const Token * start@var1577 , const Token * end@var1578 , int indirect@var1579 , const int exprid@var1580 , bool globalvar@var1581 , const Settings * settings@var1582 , bool cpp@var1583 , int depth@var1584 = 20 ) ;
277:
278: bool isVariableChanged ( const Token * tok@var1585 , int indirect@var1586 , const Settings * settings@var1587 , bool cpp@var1588 , int depth@var1589 = 20 ) ;
279:
280: bool isVariableChanged ( const Variable * var@var1590 , const Settings * settings@var1591 , bool cpp@var1592 , int depth@var1593 = 20 ) ;
281:
282: bool isVariablesChanged ( const Token * start@var1594 ,
283: const Token * end@var1595 ,
284: int indirect@var1596 ,
285: std :: vector < const Variable * > vars@var1597 ,
286: const Settings * settings@var1598 ,
287: bool cpp@var1599 ) ;
288:
289: bool isThisChanged ( const Token * tok@var1600 , int indirect@var1601 , const Settings * settings@var1602 , bool cpp@var1603 ) ;
290: bool isThisChanged ( const Token * start@var1604 , const Token * end@var1605 , int indirect@var1606 , const Settings * settings@var1607 , bool cpp@var1608 ) ;
291:
292: const Token * findVariableChanged ( const Token * start@var1609 , const Token * end@var1610 , int indirect@var1611 , const int exprid@var1612 , bool globalvar@var1613 , const Settings * settings@var1614 , bool cpp@var1615 , int depth@var1616 = 20 ) ;
293: Token * findVariableChanged ( Token * start@var1617 , const Token * end@var1618 , int indirect@var1619 , const int exprid@var1620 , bool globalvar@var1621 , const Settings * settings@var1622 , bool cpp@var1623 , int depth@var1624 = 20 ) ;
294:
295: bool isExpressionChanged ( const Token * expr@var1625 ,
296: const Token * start@var1626 ,
297: const Token * end@var1627 ,
298: const Settings * settings@var1628 ,
299: bool cpp@var1629 ,
300: int depth@var1630 = 20 ) ;
301:
302: bool isExpressionChangedAt ( const Token * expr@var1631 ,
303: const Token * tok@var1632 ,
304: int indirect@var1633 ,
305: bool globalvar@var1634 ,
306: const Settings * settings@var1635 ,
307: bool cpp@var1636 ,
308: int depth@var1637 = 20 ) ;
309:
310:
311: bool isAliasOf ( const Token * tok@var1638 , int varid@var1639 , bool * inconclusive@var1640 = nullptr ) ;
312:
313: bool isAliased ( const Variable * var@var1641 ) ;
314:
315: const Token * getArgumentStart ( const Token * ftok@var1642 ) ;
316:
|
320:
321: int numberOfArguments ( const Token * ftok@var1643 ) ;
322:
323:
324: int numberOfArgumentsWithoutAst ( const Token * start@var1644 ) ;
325:
|
328:
329: std :: vector < const Token * > getArguments ( const Token * ftok@var1645 ) ;
330:
331: int getArgumentPos ( const Variable * var@var1646 , const Function * f@var1647 ) ;
332:
|
335:
336: bool isIteratorPair ( std :: vector < const Token * > args@var1648 ) ;
337:
338: const Token * findLambdaStartToken ( const Token * last@var1649 ) ;
339:
|
344:
345: const Token * findLambdaEndToken ( const Token * first@var1650 ) ;
346: Token * findLambdaEndToken ( Token * first@var1651 ) ;
347:
348: bool isLikelyStream ( bool cpp@var1652 , const Token * stream@var1653 ) ;
349:
|
354:
355: bool isLikelyStreamRead ( bool cpp@var1654 , const Token * op@var1655 ) ;
356:
357: bool isCPPCast ( const Token * tok@var1656 ) ;
358:
359: bool isConstVarExpression ( const Token * tok@var1657 , const char * skipMatch@var1658 = nullptr ) ;
360:
361: const Variable * getLHSVariable ( const Token * tok@var1659 ) ;
362:
363: const Token * getLHSVariableToken ( const Token * tok@var1660 ) ;
364:
365: std :: vector < const Variable * > getLHSVariables ( const Token * tok@var1661 ) ;
366:
367:
368: const Token * findAllocFuncCallToken ( const Token * expr@var1662 , const Library & library@var1663 ) ;
369:
370: bool isScopeBracket ( const Token * tok@var1664 ) ;
371:
372: bool isNullOperand ( const Token * expr@var1665 ) ;
373:
374: bool isGlobalData ( const Token * expr@var1666 , bool cpp@var1667 ) ;
375:
|
380:
381: class FwdAnalysis {
382: public:
383: FwdAnalysis ( bool cpp@var1668 , const Library & library@var1669 ) : mCpp@var1702 ( cpp@var1668 ) , mLibrary@var1703 ( library@var1669 ) , mWhat@var1704 ( What :: Reassign ) , mValueFlowKnown@var1706 ( true ) { }
384:
385: bool hasOperand ( const Token * tok@var1670 , const Token * lhs@var1671 ) const ;
386:
|
393:
394: const Token * reassign ( const Token * expr@var1672 , const Token * startToken@var1673 , const Token * endToken@var1674 ) ;
395:
|
402:
403: bool unusedValue ( const Token * expr@var1675 , const Token * startToken@var1676 , const Token * endToken@var1677 ) ;
404:
405: struct KnownAndToken {
406: bool known@var1678 ;
407: const Token * token@var1679 ;
408: } ;
409:
410:
411: bool possiblyAliased ( const Token * expr@var1680 , const Token * startToken@var1681 ) const ;
412:
413: std :: set < int > getExprVarIds ( const Token * expr@var1682 , bool * localOut@var1683 = nullptr , bool * unknownVarIdOut@var1684 = nullptr ) const ;
414: private:
415: static bool isEscapedAlias ( const Token * expr@var1685 ) ;
416:
417:
418: struct Result {
419: enum class Type { NONE , READ , WRITE , BREAK , RETURN , BAILOUT } ; enum Type type@var1686 ;
420: explicit Result ( Type type@var1687 ) : type@var1686 ( type@var1687 ) , token@var1690 ( nullptr ) { }
421: Result ( Type type@var1688 , const Token * token@var1689 ) : type@var1686 ( type@var1688 ) , token@var1690 ( token@var1689 ) { }
422: const Token * token@var1690 ;
423: } ;
424:
425: struct Result check ( const Token * expr@var1691 , const Token * startToken@var1692 , const Token * endToken@var1693 ) ;
426: struct Result checkRecursive ( const Token * expr@var1694 , const Token * startToken@var1695 , const Token * endToken@var1696 , const std :: set < int > & exprVarIds@var1697 , bool local@var1698 , bool inInnerClass@var1699 , int depth@var1700 = 0 ) ;
427:
428:
429: bool isGlobalData ( const Token * expr@var1701 ) const ;
430:
431: const bool mCpp@var1702 ;
432: const Library & mLibrary@var1703 ;
433: enum class What { Reassign , UnusedValue , ValueFlow } ; enum What mWhat@var1704 ;
434: std :: vector < KnownAndToken > mValueFlow@var1705 ;
435: bool mValueFlowKnown@var1706 ;
436: } ;
437:
438: bool isSizeOfEtc ( const Token * tok@var1707 ) ;

##file cppcheck-2.8/lib/platform.h

1:
|
31:
32: namespace tinyxml2 {
33: class XMLDocument ;
34: }
35:
36: namespace cppcheck {
37:
|
40:
41: class Platform {
42: private:
43: static long long min_value ( int bit@var1708 ) {
44: if (@expr1073746232 bit@var1708 >=@expr1073746233 64 ) {
45: return LLONG_MIN ; }
46: return -@expr1073746234 (@expr1073746235 1LL <<@expr1073746236 (@expr1073746237 bit@var1708 -@expr1073746238 1 ) ) ;
47: }
48:
49: static long long max_value ( int bit@var1709 ) {
50: if (@expr1073746239 bit@var1709 >=@expr1073746240 64 ) {
51: return (@expr4417 ~@expr1073746242 0ULL ) >>@expr1073746243 1 ; }
52: return (@expr4417 1LL <<@expr1073746245 (@expr4417 bit@var1709 -@expr1073746247 1 ) ) -@expr1073746248 1LL ;
53: }
54: public:
55: Platform ( ) ;
56: virtual ~ Platform ( ) { }
57:
58: bool isIntValue ( long long value@var1710 ) const {
59: return value@var1710 >=@expr1073746249 min_value (@expr1073746250 int_bit@var1720 ) &&@expr1073746251 value@var1710 <=@expr1073746252 max_value (@expr1073746253 int_bit@var1720 ) ;
60: }
61:
62: bool isIntValue ( unsigned long long value@var1711 ) const {
63: unsigned long long intMax@var1712 ; intMax@var1712 =@expr1073746254 max_value (@expr1073746255 int_bit@var1720 ) ;
64: return value@var1711 <=@expr1073746256 intMax@var1712 ;
65: }
66:
67: bool isLongValue ( long long value@var1713 ) const {
68: return value@var1713 >=@expr1073746257 min_value (@expr1073746258 long_bit@var1721 ) &&@expr1073746259 value@var1713 <=@expr1073746260 max_value (@expr1073746261 long_bit@var1721 ) ;
69: }
70:
71: bool isLongValue ( unsigned long long value@var1714 ) const {
72: unsigned long long longMax@var1715 ; longMax@var1715 =@expr1073746262 max_value (@expr1073746263 long_bit@var1721 ) ;
73: return value@var1714 <=@expr1073746264 longMax@var1715 ;
74: }
75:
76: bool isLongLongValue ( unsigned long long value@var1716 ) const {
77: unsigned long long longLongMax@var1717 ; longLongMax@var1717 =@expr1073746265 max_value (@expr1073746266 long_long_bit@var1722 ) ;
78: return value@var1716 <=@expr1073746267 longLongMax@var1717 ;
79: }
80:
81: int char_bit@var1718 ;
82: int short_bit@var1719 ;
83: int int_bit@var1720 ;
84: int long_bit@var1721 ;
85: int long_long_bit@var1722 ;
86:
87:
88: int sizeof_bool@var1723 ;
89: int sizeof_short@var1724 ;
90: int sizeof_int@var1725 ;
91: int sizeof_long@var1726 ;
92: int sizeof_long_long@var1727 ;
93: int sizeof_float@var1728 ;
94: int sizeof_double@var1729 ;
95: int sizeof_long_double@var1730 ;
96: int sizeof_wchar_t@var1731 ;
97: int sizeof_size_t@var1732 ;
98: int sizeof_pointer@var1733 ;
99:
100: char defaultSign@var1734 ;
101:
102: enum PlatformType {
103: Unspecified ,
104: Native ,
105: Win32A ,
106: Win32W ,
107: Win64 ,
108: Unix32 ,
109: Unix64 ,
110: PlatformFile
111: } ;
112:
113:
114: PlatformType platformType@var1735 ;
115:
116:
117: bool platform ( PlatformType type@var1736 ) ;
118:
|
124:
125: bool loadPlatformFile ( const char exename@var1737 [ ] , const std :: string & filename@var1738 ) ;
126:
127:
128: bool loadFromXmlDocument ( const tinyxml2 :: XMLDocument * doc@var1739 ) ;
129:
|
133:
134: bool isWindowsPlatform ( ) const {
135: return platformType@var1735 ==@expr1073746268 Win32A ||@expr1073746269
136: platformType@var1735 ==@expr1073746270 Win32W ||@expr1073746271
137: platformType@var1735 ==@expr1073746272 Win64 ;
138: }
139:
140: const char * platformString ( ) const {
141: return platformString (@expr1073746273 platformType@var1735 ) ;
142: }
143:
144: static const char * platformString ( PlatformType pt@var1740 ) {
145: switch (@expr1073746274 pt@var1740 ) {
146: case Unspecified :@expr4451 ;
147: return "Unspecified" ;
148: case Native :@expr4451 ;
149: return "Native" ;
150: case Win32A :@expr4451 ;
151: return "win32A" ;
152: case Win32W :@expr4451 ;
153: return "win32W" ;
154: case Win64 :@expr4451 ;
155: return "win64" ;
156: case Unix32 :@expr4451 ;
157: return "unix32" ;
158: case Unix64 :@expr4451 ;
159: return "unix64" ;
160: case PlatformFile :@expr4451 ;
161: return "platformFile" ;
162: default :@expr4451 ;
163: return "unknown" ;
164: }
165: }
166:
167: long long unsignedCharMax ( ) const {
168: return max_value (@expr1073746284 char_bit@var1718 +@expr1073746285 1 ) ;
169: }
170:
171: long long signedCharMax ( ) const {
172: return max_value (@expr1073746286 char_bit@var1718 ) ;
173: }
174:
175: long long signedCharMin ( ) const {
176: return min_value (@expr1073746287 char_bit@var1718 ) ;
177: }
178: } ;
179:
180: }

##file cppcheck-2.8/lib/importproject.h

1:
|
37:
38: namespace cppcheck {
39: struct stricmp {
40: bool operator() ( const std :: string & lhs@var1741 , const std :: string & rhs@var1742 ) const {
41: return caseInsensitiveStringCompare (@expr1073746288 lhs@var1741 , rhs@var1742 ) <@expr1073746289 0 ;
42: }
43: } ;
44: }
45:
46: class Settings ;
47:
|
50:
51: class ImportProject {
52: public:
53: enum class Type {
54: UNKNOWN ,
55: MISSING ,
56: FAILURE ,
57: COMPILE_DB ,
58: VS_SLN ,
59: VS_VCXPROJ ,
60: BORLAND ,
61: CPPCHECK_GUI
62: } ;
63:
64:
65: struct FileSettings {
66: FileSettings ( ) : platformType@var1750 ( cppcheck :: Platform :: Unspecified ) , msc@var1751 ( false ) , useMfc@var1752 ( false ) { }
67: std :: string cfg@var1743 ;
68: std :: string filename@var1744 ;
69: std :: string defines@var1745 ;
70: std :: string cppcheckDefines ( ) const {
71: return defines@var1745 +@expr1073746290 (@expr1073746291 msc@var1751 ?@expr1073746292 ";_MSC_VER=1900" :@expr1073746293 "" ) +@expr1073746294 (@expr1073746295 useMfc@var1752 ?@expr1073746296 ";__AFXWIN_H__=1" :@expr1073746297 "" ) ;
72: }
73: std :: set < std :: string > undefs@var1746 ;
74: std :: list < std :: string > includePaths@var1747 ;
75: std :: list < std :: string > systemIncludePaths@var1748 ;
76: std :: string standard@var1749 ;
77: cppcheck :: Platform :: PlatformType platformType@var1750 ;
78: bool msc@var1751 ;
79: bool useMfc@var1752 ;
80:
81: void parseCommand ( std :: string command@var1753 ) ;
82: void setDefines ( std :: string defs@var1754 ) ;
83: void setIncludePaths ( const std :: string & basepath@var1755 , const std :: list < std :: string > & in@var1756 , std :: map < std :: string , std :: string , cppcheck :: stricmp > & variables@var1757 ) ;
84: } ;
85: std :: list < FileSettings > fileSettings@var1758 ;
86: Type projectType@var1759 ;
87:
88: ImportProject ( ) ;
89:
90: void selectOneVsConfig ( cppcheck :: Platform :: PlatformType platform@var1760 ) ;
91:
92: std :: list < std :: string > getVSConfigs ( ) ;
93:
94:
95: struct Anonymous4 {
96: std :: string analyzeAllVsConfigs@var1761 ;
97: std :: vector < std :: string > pathNames@var1762 ;
98: std :: list < std :: string > libraries@var1763 ;
99: std :: list < std :: string > excludedPaths@var1764 ;
100: std :: list < std :: string > checkVsConfigs@var1765 ;
101: std :: string projectFile@var1766 ;
102: std :: string platform@var1767 ;
103: } ; struct Anonymous4 guiProject@var1768 ;
104:
105: void ignorePaths ( const std :: vector < std :: string > & ipaths@var1769 ) ;
106: void ignoreOtherConfigs ( const std :: string & cfg@var1770 ) ;
107:
108: Type import ( const std :: string & filename@var1771 , Settings * settings@var1772 = nullptr ) ;
109: protected:
110: bool importCompileCommands ( std :: istream & istr@var1773 ) ;
111: bool importCppcheckGuiProject ( std :: istream & istr@var1774 , Settings * settings@var1775 ) ;
112: virtual bool sourceFileExists ( const std :: string & file@var1776 ) ;
113: private:
114: bool importSln ( std :: istream & istr@var1777 , const std :: string & path@var1778 , const std :: vector < std :: string > & fileFilters@var1779 ) ;
115: bool importVcxproj ( const std :: string & filename@var1780 , std :: map < std :: string , std :: string , cppcheck :: stricmp > & variables@var1781 , const std :: string & additionalIncludeDirectories@var1782 , const std :: vector < std :: string > & fileFilters@var1783 ) ;
116: bool importBcb6Prj ( const std :: string & projectFilename@var1784 ) ;
117:
118: static void printError ( const std :: string & message@var1785 ) ;
119:
120: void setRelativePaths ( const std :: string & filename@var1786 ) ;
121:
122: std :: string mPath@var1787 ;
123: std :: set < std :: string > mAllVSConfigs@var1788 ;
124: } ;
125:
126:
127: namespace CppcheckXml {
128: const char ProjectElementName@var1789 [ 8 ] = "project" ;
129: const char ProjectVersionAttrib@var1790 [ 8 ] = "version" ;
130: const char ProjectFileVersion@var1791 [ 2 ] = "1" ;
131: const char BuildDirElementName@var1792 [ 9 ] = "builddir" ;
132: const char ImportProjectElementName@var1793 [ 14 ] = "importproject" ;
133: const char AnalyzeAllVsConfigsElementName@var1794 [ 23 ] = "analyze-all-vs-configs" ;
134: const char Parser@var1795 [ 7 ] = "parser" ;
135: const char BugHunting@var1796 [ 12 ] = "bug-hunting" ;
136: const char IncludeDirElementName@var1797 [ 11 ] = "includedir" ;
137: const char DirElementName@var1798 [ 4 ] = "dir" ;
138: const char DirNameAttrib@var1799 [ 5 ] = "name" ;
139: const char DefinesElementName@var1800 [ 8 ] = "defines" ;
140: const char DefineName@var1801 [ 7 ] = "define" ;
141: const char DefineNameAttrib@var1802 [ 5 ] = "name" ;
142: const char UndefinesElementName@var1803 [ 10 ] = "undefines" ;
143: const char UndefineName@var1804 [ 9 ] = "undefine" ;
144: const char PathsElementName@var1805 [ 6 ] = "paths" ;
145: const char PathName@var1806 [ 4 ] = "dir" ;
146: const char PathNameAttrib@var1807 [ 5 ] = "name" ;
147: const char RootPathName@var1808 [ 5 ] = "root" ;
148: const char RootPathNameAttrib@var1809 [ 5 ] = "name" ;
149: const char IgnoreElementName@var1810 [ 7 ] = "ignore" ;
150: const char IgnorePathName@var1811 [ 5 ] = "path" ;
151: const char IgnorePathNameAttrib@var1812 [ 5 ] = "name" ;
152: const char ExcludeElementName@var1813 [ 8 ] = "exclude" ;
153: const char ExcludePathName@var1814 [ 5 ] = "path" ;
154: const char ExcludePathNameAttrib@var1815 [ 5 ] = "name" ;
155: const char FunctionContracts@var1816 [ 19 ] = "function-contracts" ;
156: const char VariableContractsElementName@var1817 [ 19 ] = "variable-contracts" ;
157: const char LibrariesElementName@var1818 [ 10 ] = "libraries" ;
158: const char LibraryElementName@var1819 [ 8 ] = "library" ;
159: const char PlatformElementName@var1820 [ 9 ] = "platform" ;
160: const char SuppressionsElementName@var1821 [ 13 ] = "suppressions" ;
161: const char SuppressionElementName@var1822 [ 12 ] = "suppression" ;
162: const char AddonElementName@var1823 [ 6 ] = "addon" ;
163: const char AddonsElementName@var1824 [ 7 ] = "addons" ;
164: const char ToolElementName@var1825 [ 5 ] = "tool" ;
165: const char ToolsElementName@var1826 [ 6 ] = "tools" ;
166: const char TagsElementName@var1827 [ 5 ] = "tags" ;
167: const char TagElementName@var1828 [ 4 ] = "tag" ;
168: const char TagWarningsElementName@var1829 [ 13 ] = "tag-warnings" ;
169: const char TagAttributeName@var1830 [ 4 ] = "tag" ;
170: const char WarningElementName@var1831 [ 8 ] = "warning" ;
171: const char HashAttributeName@var1832 [ 5 ] = "hash" ;
172: const char CheckHeadersElementName@var1833 [ 14 ] = "check-headers" ;
173: const char CheckUnusedTemplatesElementName@var1834 [ 23 ] = "check-unused-templates" ;
174: const char MaxCtuDepthElementName@var1835 [ 14 ] = "max-ctu-depth" ;
175: const char MaxTemplateRecursionElementName@var1836 [ 23 ] = "max-template-recursion" ;
176: const char CheckUnknownFunctionReturn@var1837 [ 37 ] = "check-unknown-function-return-values" ;
177: const char ClangTidy@var1838 [ 11 ] = "clang-tidy" ;
178: const char Name@var1839 [ 5 ] = "name" ;
179: const char VSConfigurationElementName@var1840 [ 18 ] = "vs-configurations" ;
180: const char VSConfigurationName@var1841 [ 7 ] = "config" ;
181: }

##file cppcheck-2.8/lib/suppressions.h

1:
|
34:
35: class Tokenizer ;
36:
37:
38: class Suppressions {
39: public:
40:
41: struct ErrorMessage {
42: unsigned long hash@var1842 ;
43: std :: string errorId@var1843 ;
44: void setFileName ( const std :: string & s@var1844 ) ;
45: const std :: string & getFileName ( ) const {
46: return mFileName@var1848 ;
47: }
48: int lineNumber@var1845 ;
49: Certainty :: CertaintyLevel certainty@var1846 ;
50: std :: string symbolNames@var1847 ;
51: private:
52: std :: string mFileName@var1848 ;
53: } ;
54:
55: struct Suppression {
56: Suppression ( ) : lineNumber@var1882 ( NO_LINE ) , hash@var1884 ( 0 ) , thisAndNextLine@var1885 ( false ) , matched@var1886 ( false ) , checked@var1887 ( false ) { }
57: Suppression ( const Suppression & other@var1849 ) {
58: *@expr1073746298 this@expr1073746299 =@expr1073746300 other@var1849 ;
59: }
60: Suppression ( const std :: string & id@var1850 , const std :: string & file@var1851 , int line@var1852 = NO_LINE ) : errorId@var1880 ( id@var1850 ) , fileName@var1881 ( file@var1851 ) , lineNumber@var1882 ( line@var1852 ) , hash@var1884 ( 0 ) , thisAndNextLine@var1885 ( false ) , matched@var1886 ( false ) , checked@var1887 ( false ) { }
61:
62: Suppression & operator= ( const Suppression & other@var1853 ) {
63: errorId@var1880 =@expr1073746301 other@var1853 .@expr1073746302 errorId@var1854 ;
64: fileName@var1881 =@expr1073746303 other@var1853 .@expr1073746304 fileName@var1855 ;
65: lineNumber@var1882 =@expr1073746305 other@var1853 .@expr1073746306 lineNumber@var1856 ;
66: symbolName@var1883 =@expr1073746307 other@var1853 .@expr1073746308 symbolName@var1857 ;
67: hash@var1884 =@expr1073746309 other@var1853 .@expr1073746310 hash@var1858 ;
68: thisAndNextLine@var1885 =@expr1073746311 other@var1853 .@expr1073746312 thisAndNextLine@var1859 ;
69: matched@var1886 =@expr1073746313 other@var1853 .@expr1073746314 matched@var1860 ;
70: checked@var1887 =@expr1073746315 other@var1853 .@expr1073746316 checked@var1861 ;
71: return *@expr1073746317 this@expr1073746318 ;
72: }
73:
74: bool operator< ( const Suppression & other@var1862 ) const {
75: if (@expr1073746319 errorId@var1880 !=@expr1073746320 other@var1862 .@expr4497 errorId@var1863 ) {
76: return errorId@var1880 <@expr1073746322 other@var1862 .@expr4497 errorId@var1863 ; }
77: if (@expr1073746324 lineNumber@var1882 <@expr1073746325 other@var1862 .@expr1073746326 lineNumber@var1864 ) {
78: return true ; }
79: if (@expr1073746327 fileName@var1881 !=@expr1073746328 other@var1862 .@expr4505 fileName@var1865 ) {
80: return fileName@var1881 <@expr1073746330 other@var1862 .@expr4505 fileName@var1865 ; }
81: if (@expr1073746332 symbolName@var1883 !=@expr1073746333 other@var1862 .@expr4510 symbolName@var1866 ) {
82: return symbolName@var1883 <@expr1073746335 other@var1862 .@expr4510 symbolName@var1866 ; }
83: if (@expr1073746337 hash@var1884 !=@expr1073746338 other@var1862 .@expr4515 hash@var1867 ) {
84: return hash@var1884 <@expr1073746340 other@var1862 .@expr4515 hash@var1867 ; }
85: if (@expr1073746342 thisAndNextLine@var1885 !=@expr1073746343 other@var1862 .@expr1073746344 thisAndNextLine@var1868 ) {
86: return thisAndNextLine@var1885 ; }
87: return false ;
88: }
89:
|
95:
96: bool parseComment ( std :: string comment@var1869 , std :: string * errorMessage@var1870 ) ;
97:
98: bool isSuppressed ( const ErrorMessage & errmsg@var1871 ) const ;
99:
100: bool isMatch ( const ErrorMessage & errmsg@var1872 ) ;
101:
102: std :: string getText ( ) const ;
103:
104: bool isLocal ( ) const {
105: return !@expr1073746346 fileName@var1881 .@expr1073746347 empty (@expr1073746348 ) &&@expr1073746349 fileName@var1881 .@expr1073746350 find_first_of (@expr1073746351 "?*" ) ==@expr1073746352 std ::@expr1073746353 string ::@expr1073746354 npos@expr1073746345 ;
106: }
107:
108: bool isSameParameters ( const Suppression & other@var1873 ) const {
109: return errorId@var1880 ==@expr1073746355 other@var1873 .@expr1073746356 errorId@var1874 &&@expr1073746357
110: fileName@var1881 ==@expr1073746358 other@var1873 .@expr1073746359 fileName@var1875 &&@expr1073746360
111: lineNumber@var1882 ==@expr1073746361 other@var1873 .@expr1073746362 lineNumber@var1876 &&@expr1073746363
112: symbolName@var1883 ==@expr1073746364 other@var1873 .@expr1073746365 symbolName@var1877 &&@expr1073746366
113: hash@var1884 ==@expr1073746367 other@var1873 .@expr1073746368 hash@var1878 &&@expr1073746369
114: thisAndNextLine@var1885 ==@expr1073746370 other@var1873 .@expr1073746371 thisAndNextLine@var1879 ;
115: }
116:
117: std :: string errorId@var1880 ;
118: std :: string fileName@var1881 ;
119: int lineNumber@var1882 ;
120: std :: string symbolName@var1883 ;
121: unsigned long hash@var1884 ;
122: bool thisAndNextLine@var1885 ;
123: bool matched@var1886 ;
124: bool checked@var1887 ;
125:
126: enum Anonymous5 { NO_LINE = -1 } ;
127: } ;
128:
|
133:
134: std :: string parseFile ( std :: istream & istr@var1888 ) ;
135:
|
140:
141: std :: string parseXmlFile ( const char * filename@var1889 ) ;
142:
|
148:
149: static std :: vector < Suppression > parseMultiSuppressComment ( const std :: string & comment@var1890 , std :: string * errorMessage@var1891 ) ;
150:
|
155:
156: std :: string addSuppressionLine ( const std :: string & line@var1892 ) ;
157:
|
163:
164: std :: string addSuppression ( const Suppression & suppression@var1893 ) ;
165:
|
170:
171: std :: string addSuppressions ( const std :: list < Suppression > & suppressions@var1894 ) ;
172:
|
177:
178: bool isSuppressed ( const ErrorMessage & errmsg@var1895 ) ;
179:
|
184:
185: bool isSuppressedLocal ( const ErrorMessage & errmsg@var1896 ) ;
186:
|
190:
191: void dump ( std :: ostream & out@var1897 ) const ;
192:
|
196:
197: std :: list < Suppression > getUnmatchedLocalSuppressions ( const std :: string & file@var1898 , const bool unusedFunctionChecking@var1899 ) const ;
198:
|
202:
203: std :: list < Suppression > getUnmatchedGlobalSuppressions ( const bool unusedFunctionChecking@var1900 ) const ;
204:
|
208:
209: const std :: list < Suppression > & getSuppressions ( ) const ;
210:
|
213:
214: void markUnmatchedInlineSuppressionsAsChecked ( const Tokenizer & tokenizer@var1901 ) ;
215:
216: private:
217:
218: std :: list < Suppression > mSuppressions@var1902 ;
219: } ;

##file cppcheck-2.8/lib/timer.h

1:
|
28:
29: enum class SHOWTIME_MODES {
30: SHOWTIME_NONE = 0 ,
31: SHOWTIME_FILE ,
32: SHOWTIME_SUMMARY ,
33: SHOWTIME_TOP5
34: } ;
35:
36: class TimerResultsIntf {
37: public:
38: virtual ~ TimerResultsIntf ( ) { }
39:
40: virtual void addResults ( const std :: string & str@var1903 , std :: clock_t clocks@var1904 ) = 0 ;
41: } ;
42:
43: struct TimerResultsData {
44: std :: clock_t mClocks@var1905 ;
45: long mNumberOfResults@var1906 ;
46:
47: TimerResultsData ( )
48: : mClocks@var1905 ( 0 )
49: , mNumberOfResults@var1906 ( 0 ) { }
50:
51: double seconds ( ) const {
52: const double ret@var1907 =@expr1073746373 (@expr1073746374 double ) (@expr1073746375 (@expr1073746376 unsigned long ) mClocks@var1905 ) /@expr1073746377 (@expr1073746378 double ) CLOCKS_PER_SEC@expr1073746372 ;
53: return ret@var1907 ;
54: }
55: } ;
56:
57: class TimerResults : public TimerResultsIntf {
58: public:
59: TimerResults ( ) { }
60:
61: void showResults ( SHOWTIME_MODES mode@var1908 ) const ;
62: void addResults ( const std :: string & str@var1909 , std :: clock_t clocks@var1910 ) override ;
63:
64: private:
65: std :: map < std :: string , TimerResultsData > mResults@var1911 ;
66: } ;
67:
68: class Timer {
69: public:
70: Timer ( const std :: string & str@var1912 , SHOWTIME_MODES showtimeMode@var1913 , TimerResultsIntf * timerResults@var1914 = nullptr ) ;
71: ~ Timer ( ) ;
72: void stop ( ) ;
73:
74: private:
75: Timer ( const Timer & other@var1915 ) ;
76: Timer & operator= ( const Timer & ) ;
77:
78: const std :: string mStr@var1916 ;
79: TimerResultsIntf * mTimerResults@var1917 ;
80: std :: clock_t mStart@var1918 ;
81: const SHOWTIME_MODES mShowTimeMode@var1919 ;
82: bool mStopped@var1920 ;
83: } ;

##file cppcheck-2.8/lib/settings.h

1:
|
40:
41: namespace ValueFlow {
42: class Value ;
43: }
44:
|
47:
48: class SimpleEnableGroup<Severity::SeverityType> ; class SimpleEnableGroup<Certainty::CertaintyLevel> ; class SimpleEnableGroup<Checks::CheckList> ;
49:
|
89:
90: class Settings : public cppcheck :: Platform {
91: private:
92:
93:
94: static std :: atomic < bool > mTerminated@var1921 ;
95:
96: public:
97: Settings ( ) ;
98:
99: void loadCppcheckCfg ( ) ;
100:
101:
102: std :: list < std :: string > addons@var1922 ;
103:
104:
105: std :: string addonPython@var1923 ;
106:
107:
108: std :: vector < std :: string > basePaths@var1924 ;
109:
110:
111: std :: string buildDir@var1925 ;
112:
113:
114: bool checkAllConfigurations@var1926 ;
115:
116:
117: bool checkConfiguration@var1927 ;
118:
|
121:
122: bool checkHeaders@var1928 ;
123:
124:
125: bool checkLibrary@var1929 ;
126:
127:
128: std :: set < std :: string > checkUnknownFunctionReturn@var1930 ;
129:
130:
131: bool checkUnusedTemplates@var1931 ;
132:
133:
134: bool clang@var1932 ;
135:
136:
137: std :: string clangExecutable@var1933 ;
138:
139:
140: bool clangTidy@var1934 ;
141:
142:
143: std :: set < std :: string > configExcludePaths@var1935 ;
144:
145:
146: std :: string cppcheckCfgProductName@var1936 ;
147:
148:
149: std :: string cppcheckCfgAbout@var1937 ;
150:
151:
152: bool daca@var1938 ;
153:
154:
155: bool debugnormal@var1939 ;
156:
157:
158: bool debugSimplified@var1940 ;
159:
160:
161: bool debugtemplate@var1941 ;
162:
163:
164: bool debugwarnings@var1942 ;
165:
166:
167: bool dump@var1943 ;
168: std :: string dumpFile@var1944 ;
169:
170: enum Language {
171: None , C , CPP
172: } ;
173:
174:
175: Language enforcedLang@var1945 ;
176:
177:
178: bool exceptionHandling@var1946 ;
179:
180:
181: std :: string exename@var1947 ;
182:
183:
184:
185: int exitCode@var1948 ;
186:
187:
188: std :: vector < std :: string > fileFilters@var1949 ;
189:
190:
191: bool force@var1950 ;
192:
193:
194:
195: std :: list < std :: string > includePaths@var1951 ;
196:
197:
198: bool inlineSuppressions@var1952 ;
199:
200:
201:
202: unsigned int jobs@var1953 ;
203:
|
206:
207: bool jointSuppressionReport@var1954 ;
208:
209:
210: std :: list < std :: string > libraries@var1955 ;
211:
212:
213: Library library@var1956 ;
214:
215:
216:
217: int loadAverage@var1957 ;
218:
|
221:
222: int maxConfigs@var1958 ;
223:
224:
225: int maxCtuDepth@var1959 ;
226:
227:
228: int maxTemplateRecursion@var1960 ;
229:
230:
231: Suppressions nofail@var1961 ;
232:
233:
234: Suppressions nomsg@var1962 ;
235:
236:
237: std :: string outputFile@var1963 ;
238:
239:
240: std :: string plistOutput@var1964 ;
241:
242:
243: bool preprocessOnly@var1965 ;
244:
245: ImportProject project@var1966 ;
246:
247:
248: bool quiet@var1967 ;
249:
250:
251: bool relativePaths@var1968 ;
252:
253:
254: bool reportProgress@var1969 ;
255:
256:
257: class Rule {
258: public:
259: Rule ( )
260: : tokenlist@var1970 ( "simple" )
261: , id@var1972 ( "rule" )
262: , severity@var1974 ( Severity :: style ) {
263: }
264:
265: std :: string tokenlist@var1970 ;
266: std :: string pattern@var1971 ;
267: std :: string id@var1972 ;
268: std :: string summary@var1973 ;
269: Severity :: SeverityType severity@var1974 ;
270: } ;
271:
|
274:
275: std :: list < Rule > rules@var1975 ;
276:
277:
278: class SafeChecks {
279: public:
280: SafeChecks ( ) : classes@var1981 ( false ) , externalFunctions@var1982 ( false ) , internalFunctions@var1983 ( false ) , externalVariables@var1984 ( false ) { }
281:
282: static const char XmlRootName@var1976 [ ] ;
283: static const char XmlClasses@var1977 [ ] ;
284: static const char XmlExternalFunctions@var1978 [ ] ;
285: static const char XmlInternalFunctions@var1979 [ ] ;
286: static const char XmlExternalVariables@var1980 [ ] ;
287:
288: void clear ( ) {
289: classes@var1981 =@expr1073746379 externalFunctions@var1982 =@expr1073746380 internalFunctions@var1983 =@expr1073746381 externalVariables@var1984 =@expr1073746382 false ;
290: }
291:
|
297:
298: bool classes@var1981 ;
299:
|
304:
305: bool externalFunctions@var1982 ;
306:
|
310:
311: bool internalFunctions@var1983 ;
312:
|
316:
317: bool externalVariables@var1984 ;
318: } ;
319:
320: SafeChecks safeChecks@var1985 ;
321:
322: SimpleEnableGroup<Severity::SeverityType> severity@var1986 ;
323: SimpleEnableGroup<Certainty::CertaintyLevel> certainty@var1987 ;
324: SimpleEnableGroup<Checks::CheckList> checks@var1988 ;
325:
326:
327: SHOWTIME_MODES showtime@var1989 ;
328:
329:
330: Standards standards@var1990 ;
331:
332:
333:
334: std :: string templateFormat@var1991 ;
335:
336:
337:
338: std :: string templateLocation@var1992 ;
339:
340:
341: std :: string userDefines@var1993 ;
342:
343:
344: std :: set < std :: string > userUndefs@var1994 ;
345:
346:
347: std :: list < std :: string > userIncludes@var1995 ;
348:
349:
350: bool verbose@var1996 ;
351:
352:
353: bool xml@var1997 ;
354:
355:
356: int xml_version@var1998 ;
357:
|
361:
362: bool configurationExcluded ( const std :: string & file@var1999 ) const {
363: for (@expr1073746383 const std ::@expr1073746384 string &@expr1073746385 configExcludePath@var2000 :@expr1073746386 configExcludePaths@var1935 ) {
364: if (@expr1073746387 file@var1999 .@expr1073746388 length (@expr1073746389 ) >=@expr1073746390 configExcludePath@var2000 .@expr4567 length (@expr4568 ) &&@expr1073746393 file@var1999 .@expr1073746394 compare (@expr1073746395 0 , configExcludePath@var2000 .@expr4567 length (@expr4568 ) , configExcludePath@var2000 ) ==@expr1073746398 0 ) {
365: return true ;
366: }
367: }
368: return false ;
369: }
370:
|
376:
377: std :: string addEnabled ( const std :: string & str@var2001 ) ;
378:
|
382:
383: bool isEnabled ( const ValueFlow :: Value * value@var2002 , bool inconclusiveCheck@var2003 = false ) const ;
384:
385:
386: bool posix ( ) const {
387: return std ::@expr1073746399 find (@expr1073746400 libraries@var1955 .@expr1073746401 begin (@expr1073746402 ) , libraries@var1955 .@expr4579 end (@expr4580 ) , "posix" ) !=@expr1073746405 libraries@var1955 .@expr4579 end (@expr4580 ) ;
388: }
389:
390:
391: static void terminate ( bool t@var2004 = true ) {
392: Settings ::@expr1073746408 mTerminated@var1921 =@expr1073746409 t@var2004 ;
393: }
394:
395:
396: static bool terminated ( ) {
397: return Settings ::@expr1073746410 mTerminated@var1921 ;
398: }
399:
400: std :: set < std :: string > summaryReturn@var2005 ;
401:
402: void loadSummaries ( ) ;
403: } ;

##file cppcheck-2.8/lib/tokenlist.h

1:
|
31:
32: class Settings ;
33:
34: namespace simplecpp {
35: class TokenList ;
36: }
37:
|
40:
41: class TokenList {
42: public:
43: explicit TokenList ( const Settings * settings@var2006 ) ;
44: ~ TokenList ( ) ;
45:
46: void setSettings ( const Settings * settings@var2007 ) {
47: mSettings@var2042 =@expr1073746411 settings@var2007 ;
48: }
49:
50: const Settings * getSettings ( ) const {
51: return mSettings@var2042 ;
52: }
53:
54:
55: const std :: string & getSourceFilePath ( ) const ;
56:
57:
58: bool isC ( ) const {
59: return mIsC@var2044 ;
60: }
61:
62:
63: bool isCPP ( ) const {
64: return mIsCpp@var2045 ;
65: }
66:
|
70:
71: static void deleteTokens ( Token * tok@var2008 ) ;
72:
73: void addtoken ( const std :: string & str@var2009 , const int lineno@var2010 , const int column@var2011 , const int fileno@var2012 , bool split@var2013 = false ) ;
74: void addtoken ( const std :: string & str@var2014 , const Token * locationTok@var2015 ) ;
75:
76: void addtoken ( const Token * tok@var2016 , const int lineno@var2017 , const int column@var2018 , const int fileno@var2019 ) ;
77: void addtoken ( const Token * tok@var2020 , const Token * locationTok@var2021 ) ;
78: void addtoken ( const Token * tok@var2022 ) ;
79:
80: static void insertTokens ( Token * dest@var2023 , const Token * src@var2024 , int n@var2025 ) ;
81:
|
89:
90: static Token * copyTokens ( Token * dest@var2026 , const Token * first@var2027 , const Token * last@var2028 , bool one_line@var2029 = true ) ;
91:
|
100:
101: bool createTokens ( std :: istream & code@var2030 , const std :: string & file0@var2031 = emptyString@var1 ) ;
102:
103: void createTokens ( simplecpp :: TokenList && tokenList@var2032 ) ;
104:
105:
106: void deallocateTokens ( ) ;
107:
108:
109: int appendFileIfNew ( const std :: string & fileName@var2033 ) ;
110:
111:
112: const Token * front ( ) const {
113: return mTokensFrontBack@var2039 .@expr1073746412 front@var2046 ;
114: }
115: Token * front ( ) {
116: return mTokensFrontBack@var2039 .@expr1073746413 front@var2046 ;
117: }
118:
119:
120: const Token * back ( ) const {
121: return mTokensFrontBack@var2039 .@expr1073746414 back@var2047 ;
122: }
123: Token * back ( ) {
124: return mTokensFrontBack@var2039 .@expr1073746415 back@var2047 ;
125: }
126:
|
131:
132: const std :: vector < std :: string > & getFiles ( ) const {
133: return mFiles@var2040 ;
134: }
135:
136: std :: string getOrigFile ( const Token * tok@var2034 ) const ;
137:
|
142:
143: const std :: string & file ( const Token * tok@var2035 ) const ;
144:
|
149:
150: std :: string fileLine ( const Token * tok@var2036 ) const ;
151:
|
155:
156: unsigned long long calculateChecksum ( ) const ;
157:
|
160:
161: void createAst ( ) const ;
162:
|
166:
167: void validateAst ( ) const ;
168:
|
174:
175: bool validateToken ( const Token * tok@var2037 ) const ;
176:
|
181:
182: void simplifyPlatformTypes ( ) ;
183:
|
187:
188: void simplifyStdType ( ) ;
189:
190: void clangSetOrigFiles ( ) ;
191:
192: bool isKeyword ( const std :: string & str@var2038 ) const ;
193:
194: private:
195:
196:
197: TokenList ( const TokenList & ) ;
198:
199:
200: TokenList & operator= ( const TokenList & ) ;
201:
202: void determineCppC ( ) ;
203:
204:
205: TokensFrontBack mTokensFrontBack@var2039 ;
206:
207:
208: std :: vector < std :: string > mFiles@var2040 ;
209:
210:
211: std :: vector < std :: string > mOrigFiles@var2041 ;
212:
213:
214: const Settings * mSettings@var2042 ;
215:
216: std :: unordered_set < std :: string > mKeywords@var2043 ;
217:
218:
219: bool mIsC@var2044 ;
220: bool mIsCpp@var2045 ;
221: } ;

##file cppcheck-2.8/lib/tokenrange.h

1:
|
25:
26: class TokenRangeBase<Token,typenamestd::enable_if<std::is_convertible<Token*,constToken*>::value>::type> ; class TokenRangeBase<constToken,typenamestd::enable_if<std::is_convertible<constToken*,constToken*>::value>::type> ;
27:
|
66:
67: class TokenRange : public TokenRangeBase<Token,typenamestd::enable_if<std::is_convertible<Token*,constToken*>::value>::type> {
68: public:
69: TokenRange ( Token * front@var2048 , Token * back@var2049 ) : TokenRangeBase<Token,typenamestd::enable_if<std::is_convertible<Token*,constToken*>::value>::type> ( front@var2048 , back@var2049 ) { }
70: } ;
71:
72: class ConstTokenRange : public TokenRangeBase<constToken,typenamestd::enable_if<std::is_convertible<constToken*,constToken*>::value>::type> {
73: public:
74: ConstTokenRange ( const Token * front@var2050 , const Token * back@var2051 ) : TokenRangeBase<constToken,typenamestd::enable_if<std::is_convertible<constToken*,constToken*>::value>::type> ( front@var2050 , back@var2051 ) { }
75: } ;

##file cppcheck-2.8/lib/token.cpp

1:
|
46:
47: const std :: list < ValueFlow :: Value > TokenImpl :: mEmptyValueList@var427 ;
48:
49: Token :: Token ( TokensFrontBack * tokensFrontBack@var2052 ) :
50: mTokensFrontBack@var440 ( tokensFrontBack@var2052 ) ,
51: mNext@var656 ( nullptr ) ,
52: mPrevious@var657 ( nullptr ) ,
53: mLink@var658 ( nullptr ) ,
54: mTokType@var659 ( eNone ) ,
55: mFlags@var660 ( 0 )
56: {
57: mImpl@var661 =@expr1073746416 new TokenImpl (@expr1073746417 ) ;
58: }
59:
60: Token :: ~ Token ( )
61: {
62: delete mImpl@var661 ;
63: }
64:
|
69:
70: ConstTokenRange Token :: until ( const Token * t@var2053 ) const
71: {
72: return ConstTokenRange (@expr1073746418 this@expr1073746419 , t@var2053 ) ;
73: }
74:
75: static const std :: unordered_set < std :: string > controlFlowKeywords@var2054 = {
76: "goto" ,
77: "do" ,
78: "if" ,
79: "else" ,
80: "for" ,
81: "while" ,
82: "switch" ,
83: "case" ,
84: "break" ,
85: "continue" ,
86: "return"
87: } ;
88:
89: void Token :: update_property_info ( )
90: {
91: setFlag (@expr1073746422 fIsControlFlowKeyword , controlFlowKeywords@var2054 .@expr1073746423 find (@expr1073746424 mStr@var655 ) !=@expr1073746425 controlFlowKeywords@var2054 .@expr1073746426 end (@expr1073746427 ) ) ;
92:
93: if (@expr1073746428 !@expr1073746429 mStr@var655 .@expr1073746430 empty (@expr1073746431 ) ) {
94: if (@expr1073746432 mStr@var655 ==@expr1073746433 "true" ||@expr1073746434 mStr@var655 ==@expr1073746435 "false" ) {
95: tokType (@expr1073746436 eBoolean ) ; }
96: else { if (@expr1073746437 isStringLiteral (@expr1073746438 mStr@var655 ) ) {
97: tokType (@expr1073746439 eString ) ; }
98: else { if (@expr1073746440 isCharLiteral (@expr1073746441 mStr@var655 ) ) {
99: tokType (@expr1073746442 eChar ) ; }
100: else { if (@expr1073746443 std ::@expr1073746444 isalpha (@expr1073746445 (@expr4622 unsigned char ) mStr@var655 [@expr4623 0 ] ) ||@expr1073746448 mStr@var655 [@expr4623 0 ] ==@expr1073746450 '_' ||@expr1073746451 mStr@var655 [@expr4623 0 ] ==@expr1073746453 '$' ) {
101: if (@expr1073746454 mImpl@var661 .@expr1073746455 mVarId@var2598 ) {
102: tokType (@expr1073746456 eVariable ) ; }
103: else { if (@expr1073746457 mTokensFrontBack@var440 &&@expr1073746458 mTokensFrontBack@var440 .@expr4635 list@var2599 &&@expr1073746460 mTokensFrontBack@var440 .@expr4635 list@var2599 .@expr1073746462 isKeyword (@expr1073746463 mStr@var655 ) ) {
104: tokType (@expr1073746464 eKeyword ) ; }
105: else { if (@expr1073746465 mTokType@var659 !=@expr1073746466 eVariable &&@expr1073746467 mTokType@var659 !=@expr1073746468 eFunction &&@expr1073746469 mTokType@var659 !=@expr1073746470 eType &&@expr1073746471 mTokType@var659 !=@expr1073746472 eKeyword ) {
106: tokType (@expr1073746473 eName ) ; } } }
107: } else { if (@expr1073746474 std ::@expr4651 isdigit (@expr1073746476 (@expr4622 unsigned char ) mStr@var655 [@expr4623 0 ] ) ||@expr1073746479 (@expr1073746480 mStr@var655 .@expr1073746481 length (@expr1073746482 ) >@expr1073746483 1 &&@expr1073746484 mStr@var655 [@expr4623 0 ] ==@expr1073746486 '-' &&@expr1073746487 std ::@expr4651 isdigit (@expr1073746489 (@expr1073746490 unsigned char ) mStr@var655 [@expr4667 1 ] ) ) ) {
108: tokType (@expr1073746492 eNumber ) ; }
109: else { if (@expr1073746493 mStr@var655 ==@expr1073746494 "=" ||@expr1073746495 mStr@var655 ==@expr1073746496 "<<=" ||@expr1073746497 mStr@var655 ==@expr1073746498 ">>=" ||@expr1073746499
110: (@expr1073746500 mStr@var655 .@expr4677 size (@expr4678 ) ==@expr1073746503 2U &&@expr1073746504 mStr@var655 [@expr4667 1 ] ==@expr1073746506 '=' &&@expr1073746507 std ::@expr1073746508 strchr (@expr1073746509 "+-*/%&^|" , mStr@var655 [@expr4623 0 ] ) ) ) {
111: tokType (@expr1073746511 eAssignmentOp ) ; }
112: else { if (@expr1073746512 mStr@var655 .@expr4677 size (@expr4678 ) ==@expr4691 1 &&@expr1073746516 mStr@var655 .@expr4693 find_first_of (@expr1073746518 ",[]()?:" ) !=@expr1073746519 std ::@expr4696 string ::@expr4697 npos@expr4596 ) {
113: tokType (@expr1073746522 eExtendedOp ) ; }
114: else { if (@expr1073746523 mStr@var655 ==@expr1073746524 "<<" ||@expr1073746525 mStr@var655 ==@expr1073746526 ">>" ||@expr1073746527 (@expr1073746528 mStr@var655 .@expr4677 size (@expr4678 ) ==@expr4691 1 &&@expr1073746532 mStr@var655 .@expr4693 find_first_of (@expr1073746534 "+-*/%" ) !=@expr1073746535 std ::@expr4696 string ::@expr4697 npos@expr4596 ) ) {
115: tokType (@expr1073746538 eArithmeticalOp ) ; }
116: else { if (@expr1073746539 mStr@var655 .@expr4677 size (@expr4678 ) ==@expr4691 1 &&@expr1073746543 mStr@var655 .@expr4693 find_first_of (@expr1073746545 "&|^~" ) !=@expr1073746546 std ::@expr4696 string ::@expr4697 npos@expr4596 ) {
117: tokType (@expr1073746549 eBitOp ) ; }
118: else { if (@expr1073746550 mStr@var655 .@expr4677 size (@expr4678 ) <=@expr4729 2 &&@expr1073746554
119: (@expr1073746555 mStr@var655 ==@expr1073746556 "&&" ||@expr1073746557
120: mStr@var655 ==@expr1073746558 "||" ||@expr1073746559
121: mStr@var655 ==@expr1073746560 "!" ) ) {
122: tokType (@expr1073746561 eLogicalOp ) ; }
123: else { if (@expr1073746562 mStr@var655 .@expr4677 size (@expr4678 ) <=@expr4729 2 &&@expr1073746566 !@expr1073746567 mLink@var658 &&@expr1073746568
124: (@expr1073746569 mStr@var655 ==@expr1073746570 "==" ||@expr1073746571
125: mStr@var655 ==@expr1073746572 "!=" ||@expr1073746573
126: mStr@var655 ==@expr1073746574 "<" ||@expr1073746575
127: mStr@var655 ==@expr1073746576 "<=" ||@expr1073746577
128: mStr@var655 ==@expr1073746578 ">" ||@expr1073746579
129: mStr@var655 ==@expr1073746580 ">=" ) ) {
130: tokType (@expr4757 eComparisonOp ) ; }
131: else { if (@expr1073746582 mStr@var655 ==@expr1073746583 "<=>" ) {
132: tokType (@expr4757 eComparisonOp ) ; }
133: else { if (@expr1073746585 mStr@var655 .@expr4677 size (@expr4678 ) ==@expr1073746588 2 &&@expr1073746589
134: (@expr1073746590 mStr@var655 ==@expr1073746591 "++" ||@expr1073746592
135: mStr@var655 ==@expr1073746593 "--" ) ) {
136: tokType (@expr1073746594 eIncDecOp ) ; }
137: else { if (@expr1073746595 mStr@var655 .@expr4677 size (@expr4678 ) ==@expr4691 1 &&@expr1073746599 (@expr1073746600 mStr@var655 .@expr4693 find_first_of (@expr1073746602 "{}" ) !=@expr1073746603 std ::@expr4696 string ::@expr4697 npos@expr4596 ||@expr1073746606 (@expr1073746607 mLink@var658 &&@expr1073746608 mStr@var655 .@expr4693 find_first_of (@expr1073746610 "<>" ) !=@expr1073746611 std ::@expr4696 string ::@expr4697 npos@expr4596 ) ) ) {
138: tokType (@expr1073746614 eBracket ) ; }
139: else { if (@expr1073746615 mStr@var655 ==@expr1073746616 "..." ) {
140: tokType (@expr1073746617 eEllipsis ) ; }
141: else {
142: tokType (@expr1073746618 eOther ) ; } } } } } } } } } } } } } } }
143: } else {
144: tokType (@expr1073746619 eNone@expr1073746421 ) ;
145: }
146:
147: update_property_char_string_literal (@expr1073746620 ) ;
148: update_property_isStandardType (@expr1073746621 ) ;
149: }
150:
151: static const std :: unordered_set < std :: string > stdTypes@var2055 = { "bool"
152: , "_Bool"
153: , "char"
154: , "double"
155: , "float"
156: , "int"
157: , "long"
158: , "short"
159: , "size_t"
160: , "void"
161: , "wchar_t"
162: } ;
163:
164: void Token :: update_property_isStandardType ( )
165: {
166: isStandardType (@expr1073746622 false ) ;
167:
168: if (@expr1073746623 mStr@var655 .@expr1073746624 size (@expr1073746625 ) <@expr1073746626 3 ) {
169: return ; }
170:
171: if (@expr1073746627 stdTypes@var2055 .@expr1073746628 find (@expr1073746629 mStr@var655 ) !=@expr1073746630 stdTypes@var2055 .@expr1073746631 end (@expr1073746632 ) ) {
172: isStandardType (@expr1073746633 true ) ;
173: tokType (@expr1073746634 eType ) ;
174: }
175: }
176:
177: void Token :: update_property_char_string_literal ( )
178: {
179: if (@expr1073746635 mTokType@var659 !=@expr1073746636 Token ::@expr4813 eString &&@expr1073746638 mTokType@var659 !=@expr1073746639 Token ::@expr4816 eChar ) {
180: return ; }
181:
182: isLong (@expr1073746641 (@expr1073746642 (@expr1073746643 mTokType@var659 ==@expr1073746644 Token ::@expr4813 eString ) &&@expr1073746646 isPrefixStringCharLiteral (@expr1073746647 mStr@var655 , '"' , "L" ) ) ||@expr1073746648
183: (@expr1073746649 (@expr1073746650 mTokType@var659 ==@expr1073746651 Token ::@expr4816 eChar ) &&@expr1073746653 isPrefixStringCharLiteral (@expr1073746654 mStr@var655 , '\'' , "L" ) ) ) ;
184: }
185:
186: bool Token :: isUpperCaseName ( ) const
187: {
188: if (@expr1073746655 !@expr1073746656 isName (@expr1073746657 ) ) {
189: return false ; }
190: for (@expr1073746658 char i@var2056 :@expr1073746659 mStr@var655 ) {
191: if (@expr1073746660 std ::@expr1073746661 islower (@expr1073746662 i@var2056 ) ) {
192: return false ; }
193: }
194: return true ;
195: }
196:
197: void Token :: concatStr ( const std :: string & b@var2057 )
198: {
199: mStr@var655 .@expr1073746663 pop_back (@expr1073746664 ) ;
200: mStr@var655 .@expr1073746665 append (@expr1073746666 getStringLiteral (@expr1073746667 b@var2057 ) +@expr1073746668 "\"" ) ;
201:
202: if (@expr1073746669 isCChar (@expr1073746670 ) &&@expr1073746671 isStringLiteral (@expr1073746672 b@var2057 ) &&@expr1073746673 b@var2057 [@expr1073746674 0 ] !=@expr1073746675 '"' ) {
203: mStr@var655 .@expr1073746676 insert (@expr1073746677 0 , b@var2057 .@expr1073746678 substr (@expr1073746679 0 , b@var2057 .@expr1073746680 find (@expr1073746681 '"' ) ) ) ;
204: }
205: update_property_info (@expr1073746682 ) ;
206: }
207:
208: std :: string Token :: strValue ( ) const
209: {
210: assert (@expr1073746684 mTokType@var659 ==@expr1073746685 eString ) ;
211: std ::@expr1073746686 string ret@var2058 (@expr1073746687 getStringLiteral (@expr1073746688 mStr@var655 ) ) ;
212: std ::@expr4865 string ::@expr1073746690 size_type pos@var2059 ; pos@var2059 =@expr1073746691 0U ;
213: while (@expr1073746692 (@expr1073746693 pos@var2059 =@expr1073746694 ret@var2058 .@expr1073746695 find (@expr1073746696 '\\' , pos@var2059 ) ) !=@expr1073746697 std ::@expr4865 string ::@expr1073746699 npos@expr1073746683 ) {
214: ret@var2058 .@expr1073746700 erase (@expr1073746701 pos@var2059 , 1U ) ;
215: if (@expr1073746702 ret@var2058 [@expr4879 pos@var2059 ] >=@expr1073746704 'a' ) {
216: if (@expr1073746705 ret@var2058 [@expr4879 pos@var2059 ] ==@expr1073746707 'n' ) {
217: ret@var2058 [@expr4879 pos@var2059 ] =@expr1073746709 '\n' ; }
218: else { if (@expr1073746710 ret@var2058 [@expr4879 pos@var2059 ] ==@expr1073746712 'r' ) {
219: ret@var2058 [@expr4879 pos@var2059 ] =@expr1073746714 '\r' ; }
220: else { if (@expr1073746715 ret@var2058 [@expr4879 pos@var2059 ] ==@expr1073746717 't' ) {
221: ret@var2058 [@expr4879 pos@var2059 ] =@expr1073746719 '\t' ; } } }
222: }
223: if (@expr1073746720 ret@var2058 [@expr4879 pos@var2059 ] ==@expr1073746722 '0' ) {
224: return ret@var2058 .@expr1073746723 substr (@expr1073746724 0 , pos@var2059 ) ; }
225: pos@var2059 ++@expr1073746725 ;
226: }
227: return ret@var2058 ;
228: }
229:
230: void Token :: deleteNext ( int count@var2060 )
231: {
232: while (@expr1073746726 mNext@var656 &&@expr1073746727 count@var2060 >@expr1073746728 0 ) {
233: Token * n@var2061 ; n@var2061 =@expr1073746729 mNext@var656 ;
234:
235:
236: if (@expr1073746730 n@var2061 .@expr4907 mLink@var2062 &&@expr1073746732 n@var2061 .@expr4907 mLink@var2062 .@expr1073746734 mLink@var2063 ==@expr1073746735 n@var2061 ) {
237: n@var2061 .@expr4907 mLink@var2062 .@expr1073746737 link (@expr1073746738 nullptr ) ; }
238:
239: mNext@var656 =@expr1073746739 n@var2061 .@expr1073746740 next (@expr1073746741 ) ;
240: delete n@var2061 ;
241: --@expr1073746742 count@var2060 ;
242: }
243:
244: if (@expr1073746743 mNext@var656 ) {
245: mNext@var656 .@expr1073746744 previous (@expr1073746745 this@expr4922 ) ; }
246: else { if (@expr1073746747 mTokensFrontBack@var440 ) {
247: mTokensFrontBack@var440 .@expr1073746748 back@var2600 =@expr1073746749 this@expr4922 ; } }
248: }
249:
250: void Token :: deletePrevious ( int count@var2064 )
251: {
252: while (@expr1073746750 mPrevious@var657 &&@expr1073746751 count@var2064 >@expr1073746752 0 ) {
253: Token * p@var2065 ; p@var2065 =@expr1073746753 mPrevious@var657 ;
254:
255:
256: if (@expr1073746754 p@var2065 .@expr4931 mLink@var2066 &&@expr1073746756 p@var2065 .@expr4931 mLink@var2066 .@expr1073746758 mLink@var2067 ==@expr1073746759 p@var2065 ) {
257: p@var2065 .@expr4931 mLink@var2066 .@expr1073746761 link (@expr1073746762 nullptr ) ; }
258:
259: mPrevious@var657 =@expr1073746763 p@var2065 .@expr1073746764 previous (@expr1073746765 ) ;
260: delete p@var2065 ;
261: --@expr1073746766 count@var2064 ;
262: }
263:
264: if (@expr1073746767 mPrevious@var657 ) {
265: mPrevious@var657 .@expr1073746768 next (@expr1073746769 this@expr4946 ) ; }
266: else { if (@expr1073746771 mTokensFrontBack@var440 ) {
267: mTokensFrontBack@var440 .@expr1073746772 front@var2601 =@expr1073746773 this@expr4946 ; } }
268: }
269:
270: void Token :: swapWithNext ( )
271: {
272: if (@expr1073746774 mNext@var656 ) {
273: std ::@expr4951 swap (@expr1073746776 mStr@var655 , mNext@var656 .@expr1073746777 mStr@var2602 ) ;
274: std ::@expr4951 swap (@expr1073746779 mTokType@var659 , mNext@var656 .@expr1073746780 mTokType@var2603 ) ;
275: std ::@expr4951 swap (@expr1073746782 mFlags@var660 , mNext@var656 .@expr1073746783 mFlags@var2604 ) ;
276: std ::@expr4951 swap (@expr1073746785 mImpl@var661 , mNext@var656 .@expr4962 mImpl@var2605 ) ;
277: if (@expr1073746787 mImpl@var661 .@expr4964 mTemplateSimplifierPointers@var2606 ) {
278: for (@expr1073746789 auto *@expr4966 templateSimplifierPointer@var2068 :@expr1073746791 *@expr1073746792 mImpl@var661 .@expr4964 mTemplateSimplifierPointers@var2606 ) {
279: templateSimplifierPointer@var2068 .@expr1073746794 token (@expr1073746795 this@expr4972 ) ;
280: } }
281:
282: if (@expr1073746797 mNext@var656 .@expr4962 mImpl@var2605 .@expr4975 mTemplateSimplifierPointers@var2607 ) {
283: for (@expr1073746800 auto *@expr4966 templateSimplifierPointer@var2069 :@expr1073746802 *@expr1073746803 mNext@var656 .@expr4962 mImpl@var2605 .@expr4975 mTemplateSimplifierPointers@var2607 ) {
284: templateSimplifierPointer@var2069 .@expr1073746806 token (@expr1073746807 mNext@var656 ) ;
285: } }
286: if (@expr1073746808 mNext@var656 .@expr4985 mLink@var2608 ) {
287: mNext@var656 .@expr4985 mLink@var2608 .@expr1073746811 mLink@var2609 =@expr1073746812 this@expr4972 ; }
288: if (@expr1073746813 this@expr4972 .@expr4990 mLink@var658 ) {
289: this@expr4972 .@expr4990 mLink@var658 .@expr1073746816 mLink@var2610 =@expr1073746817 mNext@var656 ; }
290: std ::@expr4951 swap (@expr1073746819 mLink@var658 , mNext@var656 .@expr4985 mLink@var2608 ) ;
291: }
292: }
293:
294: void Token :: takeData ( Token * fromToken@var2070 )
295: {
296: mStr@var655 =@expr1073746821 fromToken@var2070 .@expr1073746822 mStr@var2071 ;
297: tokType (@expr1073746823 fromToken@var2070 .@expr1073746824 mTokType@var2072 ) ;
298: mFlags@var660 =@expr1073746825 fromToken@var2070 .@expr1073746826 mFlags@var2073 ;
299: delete mImpl@var661 ;
300: mImpl@var661 =@expr1073746827 fromToken@var2070 .@expr5004 mImpl@var2074 ;
301: fromToken@var2070 .@expr5004 mImpl@var2074 =@expr1073746830 nullptr ;
302: if (@expr1073746831 mImpl@var661 .@expr5008 mTemplateSimplifierPointers@var2606 ) {
303: for (@expr1073746833 auto *@expr1073746834 templateSimplifierPointer@var2075 :@expr1073746835 *@expr1073746836 mImpl@var661 .@expr5008 mTemplateSimplifierPointers@var2606 ) {
304: templateSimplifierPointer@var2075 .@expr1073746838 token (@expr1073746839 this@expr5016 ) ;
305: } }
306: mLink@var658 =@expr1073746841 fromToken@var2070 .@expr1073746842 mLink@var2076 ;
307: if (@expr1073746843 mLink@var658 ) {
308: mLink@var658 .@expr1073746844 link (@expr1073746845 this@expr5016 ) ; }
309: }
310:
311: void Token :: deleteThis ( )
312: {
313: if (@expr1073746846 mNext@var656 ) {
314: takeData (@expr1073746847 mNext@var656 ) ;
315: mNext@var656 .@expr1073746848 link (@expr1073746849 nullptr ) ;
316: deleteNext (@expr1073746850 ) ;
317: } else { if (@expr1073746851 mPrevious@var657 ) {
318: takeData (@expr1073746852 mPrevious@var657 ) ;
319: mPrevious@var657 .@expr1073746853 link (@expr1073746854 nullptr ) ;
320: deletePrevious (@expr1073746855 ) ;
321: } else {
322:
323:
324: str (@expr1073746856 ";" ) ;
325: } }
326: }
327:
328: void Token :: replace ( Token * replaceThis@var2077 , Token * start@var2078 , Token * end@var2079 )
329: {
330:
331: if (@expr1073746857 start@var2078 .@expr5034 previous (@expr5035 ) ) {
332: start@var2078 .@expr5034 previous (@expr5035 ) .@expr1073746862 next (@expr1073746863 end@var2079 .@expr5040 next (@expr5041 ) ) ; }
333:
334: if (@expr1073746866 end@var2079 .@expr5040 next (@expr5041 ) ) {
335: end@var2079 .@expr5040 next (@expr5041 ) .@expr1073746871 previous (@expr1073746872 start@var2078 .@expr5034 previous (@expr5035 ) ) ; }
336:
337:
338: if (@expr1073746875 replaceThis@var2077 .@expr5052 previous (@expr5053 ) ) {
339: replaceThis@var2077 .@expr5052 previous (@expr5053 ) .@expr1073746880 next (@expr1073746881 start@var2078 ) ; }
340:
341: if (@expr1073746882 replaceThis@var2077 .@expr5059 next (@expr5060 ) ) {
342: replaceThis@var2077 .@expr5059 next (@expr5060 ) .@expr1073746887 previous (@expr1073746888 end@var2079 ) ; }
343:
344: start@var2078 .@expr5034 previous (@expr1073746890 replaceThis@var2077 .@expr5052 previous (@expr5053 ) ) ;
345: end@var2079 .@expr5040 next (@expr1073746894 replaceThis@var2077 .@expr5059 next (@expr5060 ) ) ;
346:
347: if (@expr1073746897 end@var2079 .@expr5074 mTokensFrontBack@var2080 &&@expr1073746899 end@var2079 .@expr5074 mTokensFrontBack@var2080 .@expr5077 back@var2081 ==@expr1073746902 end@var2079 ) {
348: while (@expr1073746903 end@var2079 .@expr5040 next (@expr5041 ) ) {
349: end@var2079 =@expr1073746906 end@var2079 .@expr5040 next (@expr5041 ) ; }
350: end@var2079 .@expr5074 mTokensFrontBack@var2080 .@expr5077 back@var2081 =@expr1073746911 end@var2079 ;
351: }
352:
353:
354: for (@expr1073746912 Token *@expr1073746913 tok@var2082 =@expr1073746914 start@var2078 ; tok@var2082 !=@expr1073746915 end@var2079 .@expr5040 next (@expr5041 ) ; tok@var2082 =@expr1073746918 tok@var2082 .@expr1073746919 next (@expr1073746920 ) ) {
355: tok@var2082 .@expr1073746921 mImpl@var2083 .@expr1073746922 mProgressValue@var2084 =@expr1073746923 replaceThis@var2077 .@expr1073746924 mImpl@var2085 .@expr1073746925 mProgressValue@var2086 ; }
356:
357:
358: delete replaceThis@var2077 ;
359: }
360:
361: const Token * Token :: tokAt ( int index@var2087 ) const
362: {
363: const Token * tok@var2088 ; tok@var2088 =@expr1073746926 this@expr1073746927 ;
364: while (@expr1073746928 index@var2087 >@expr1073746929 0 &&@expr1073746930 tok@var2088 ) {
365: tok@var2088 =@expr1073746931 tok@var2088 .@expr1073746932 next (@expr1073746933 ) ;
366: --@expr1073746934 index@var2087 ;
367: }
368: while (@expr1073746935 index@var2087 <@expr1073746936 0 &&@expr1073746937 tok@var2088 ) {
369: tok@var2088 =@expr1073746938 tok@var2088 .@expr1073746939 previous (@expr1073746940 ) ;
370: ++@expr1073746941 index@var2087 ;
371: }
372: return tok@var2088 ;
373: }
374:
375: const Token * Token :: linkAt ( int index@var2089 ) const
376: {
377: const Token * tok@var2090 ; tok@var2090 =@expr1073746942 this@expr5119 .@expr1073746944 tokAt (@expr1073746945 index@var2089 ) ;
378: if (@expr1073746946 !@expr1073746947 tok@var2090 ) {
379: throw InternalError (@expr1073746948 this@expr5119 , "Internal error. Token::linkAt called with index outside the tokens range." ) ;
380: }
381: return tok@var2090 .@expr1073746949 link (@expr1073746950 ) ;
382: }
383:
384: const std :: string & Token :: strAt ( int index@var2091 ) const
385: {
386: const Token * tok@var2092 ; tok@var2092 =@expr1073746951 this@expr1073746952 .@expr1073746953 tokAt (@expr1073746954 index@var2091 ) ;
387: return tok@var2092 ?@expr1073746955 tok@var2092 .@expr1073746956 mStr@var2093 :@expr1073746957 emptyString@var1 ;
388: }
389:
390: static int multiComparePercent ( const Token * tok@var2094 , const char * & haystack@var2095 , int varid@var2096 )
391: {
392: ++@expr1073746958 haystack@var2095 ;
393:
394: switch (@expr1073746959 haystack@var2095 [@expr5136 0 ] ) {
395: case '\0' :@expr5137
396: case ' ' :@expr5137
397: case '|' :@expr5137 ;
398:
399: haystack@var2095 +=@expr1073746964 1 ;
400: if (@expr1073746965 tok@var2094 .@expr1073746966 isArithmeticalOp (@expr1073746967 ) &&@expr1073746968 tok@var2094 .@expr5145 str (@expr5146 ) ==@expr1073746971 "%" ) {
401: return 1 ; }
402: break ;
403: case 'v' :@expr5137 ;
404: if (@expr5149 haystack@var2095 [@expr5150 3 ] ==@expr5151 '%' ) {
405: haystack@var2095 +=@expr1073746976 4 ;
406: if (@expr1073746977 tok@var2094 .@expr5154 varId (@expr5155 ) !=@expr1073746980 0 ) {
407: return 1 ; }
408: } else {
409: if (@expr1073746981 varid@var2096 ==@expr1073746982 0 ) {
410: throw InternalError (@expr1073746983 tok@var2094 , "Internal error. Token::Match called with varid 0. Please report this to Cppcheck developers" ) ;
411: }
412:
413: haystack@var2095 +=@expr1073746984 6 ;
414:
415: if (@expr1073746985 tok@var2094 .@expr5154 varId (@expr5155 ) ==@expr1073746988 varid@var2096 ) {
416: return 1 ; }
417: }
418: break ;
419: case 't' :@expr5137 ;
420:
421: {
422: haystack@var2095 +=@expr1073746990 5 ;
423: if (@expr1073746991 tok@var2094 .@expr5168 isName (@expr5169 ) &&@expr1073746994 tok@var2094 .@expr5154 varId (@expr5155 ) ==@expr1073746997 0 &&@expr1073746998 (@expr1073746999 tok@var2094 .@expr5145 str (@expr5146 ) !=@expr1073747002 "delete" ||@expr1073747003 !@expr1073747004 tok@var2094 .@expr1073747005 isKeyword (@expr1073747006 ) ) ) {
424: return 1 ; }
425: }
426: break ;
427: case 'a' :@expr5137 ;
428:
429: {
430: if (@expr5149 haystack@var2095 [@expr5150 3 ] ==@expr5151 '%' ) {
431: haystack@var2095 +=@expr1073747011 4 ;
432: return 1 ;
433: } else {
434: haystack@var2095 +=@expr1073747012 7 ;
435: if (@expr1073747013 tok@var2094 .@expr1073747014 isAssignmentOp (@expr1073747015 ) ) {
436: return 1 ; }
437: }
438: }
439: break ;
440: case 'n' :@expr5137 ;
441:
442: {
443: if (@expr1073747017 haystack@var2095 [@expr1073747018 4 ] ==@expr1073747019 '%' ) {
444: haystack@var2095 +=@expr1073747020 5 ;
445: if (@expr1073747021 tok@var2094 .@expr5168 isName (@expr5169 ) ) {
446: return 1 ; }
447: } else {
448: haystack@var2095 +=@expr1073747024 4 ;
449: if (@expr1073747025 tok@var2094 .@expr1073747026 isNumber (@expr1073747027 ) ) {
450: return 1 ; }
451: }
452: }
453: break ;
454: case 'c' :@expr5137 ; {
455: haystack@var2095 +=@expr1073747029 1 ;
456:
457: if (@expr1073747030 haystack@var2095 [@expr5136 0 ] ==@expr1073747032 'h' ) {
458: haystack@var2095 +=@expr1073747033 4 ;
459: if (@expr1073747034 tok@var2094 .@expr5211 tokType (@expr5212 ) ==@expr1073747037 Token ::@expr1073747038 eChar ) {
460: return 1 ; }
461: }
462:
463: else { if (@expr1073747039 haystack@var2095 [@expr5216 1 ] ==@expr1073747041 'p' ) {
464: haystack@var2095 +=@expr1073747042 3 ;
465: if (@expr1073747043 tok@var2094 .@expr1073747044 isConstOp (@expr1073747045 ) ) {
466: return 1 ; }
467: }
468:
469: else {
470: haystack@var2095 +=@expr1073747046 4 ;
471: if (@expr1073747047 tok@var2094 .@expr1073747048 isComparisonOp (@expr1073747049 ) ) {
472: return 1 ; }
473: } }
474: }
475: break ;
476: case 's' :@expr5137 ;
477:
478: {
479: haystack@var2095 +=@expr1073747051 4 ;
480: if (@expr1073747052 tok@var2094 .@expr5211 tokType (@expr5212 ) ==@expr1073747055 Token ::@expr1073747056 eString ) {
481: return 1 ; }
482: }
483: break ;
484: case 'b' :@expr5137 ;
485:
486: {
487: haystack@var2095 +=@expr1073747058 5 ;
488: if (@expr1073747059 tok@var2094 .@expr1073747060 isBoolean (@expr1073747061 ) ) {
489: return 1 ; }
490: }
491: break ;
492: case 'o' :@expr5137 ; {
493: ++@expr1073747063 haystack@var2095 ;
494: if (@expr1073747064 haystack@var2095 [@expr5216 1 ] ==@expr1073747066 '%' ) {
495:
496: if (@expr1073747067 haystack@var2095 [@expr5136 0 ] ==@expr1073747069 'p' ) {
497: haystack@var2095 +=@expr1073747070 2 ;
498: if (@expr1073747071 tok@var2094 .@expr1073747072 isOp (@expr1073747073 ) ) {
499: return 1 ; }
500: }
501:
502: else {
503: haystack@var2095 +=@expr1073747074 2 ;
504: if (@expr1073747075 tok@var2094 .@expr5211 tokType (@expr5212 ) ==@expr1073747078 Token ::@expr1073747079 eBitOp &&@expr1073747080 tok@var2094 .@expr5145 str (@expr5146 ) ==@expr1073747083 "|" ) {
505: return 1 ; }
506: }
507: }
508:
509:
510: else {
511: haystack@var2095 +=@expr1073747084 4 ;
512: if (@expr1073747085 tok@var2094 .@expr5211 tokType (@expr5212 ) ==@expr1073747088 Token ::@expr1073747089 eLogicalOp &&@expr1073747090 tok@var2094 .@expr5145 str (@expr5146 ) ==@expr1073747093 "||" ) {
513: return 1 ; }
514: }
515: }
516: break ;
517: default :@expr5137 ;
518:
519: throw InternalError (@expr1073747095 tok@var2094 , "Unexpected command" ) ;
520: }
521:
522: if (@expr1073747096 *@expr1073747097 haystack@var2095 ==@expr1073747098 '|' ) {
523: haystack@var2095 +=@expr1073747099 1 ; }
524: else {
525: return -1 ; }
526:
527: return 0xFFFF ;
528: }
529:
530: int Token :: multiCompare ( const Token * tok@var2097 , const char * haystack@var2098 , int varid@var2099 )
531: {
532: const char * needle@var2100 ; needle@var2100 =@expr1073747100 tok@var2097 .@expr1073747101 str (@expr1073747102 ) .@expr1073747103 c_str (@expr1073747104 ) ;
533: const char * needlePointer@var2101 ; needlePointer@var2101 =@expr1073747105 needle@var2100 ;
534: for (@expr1073747106 ; ; ) {
535: if (@expr1073747107 needlePointer@var2101 ==@expr5284 needle@var2100 &&@expr1073747109 haystack@var2098 [@expr1073747110 0 ] ==@expr1073747111 '%' &&@expr1073747112 haystack@var2098 [@expr5289 1 ] !=@expr1073747114 '|' &&@expr1073747115 haystack@var2098 [@expr5289 1 ] !=@expr1073747117 '\0' &&@expr1073747118 haystack@var2098 [@expr5289 1 ] !=@expr1073747120 ' ' ) {
536: const int ret@var2102 =@expr1073747121 multiComparePercent (@expr1073747122 tok@var2097 , haystack@var2098 , varid@var2099 ) ;
537: if (@expr1073747123 ret@var2102 <@expr1073747124 2 ) {
538: return ret@var2102 ; }
539: } else { if (@expr5301 *@expr5302 haystack@var2098 ==@expr5303 '|' ) {
540: if (@expr1073747128 *@expr5305 needlePointer@var2101 ==@expr1073747130 0 ) {
541:
542: return 1 ;
543: }
544:
545: needlePointer@var2101 =@expr1073747131 needle@var2100 ;
546: ++@expr1073747132 haystack@var2098 ;
547: } else { if (@expr1073747133 *@expr5305 needlePointer@var2101 ==@expr1073747135 *@expr5302 haystack@var2098 ) {
548: if (@expr5313 *@expr5305 needlePointer@var2101 ==@expr5315 '\0' ) {
549: return 1 ; }
550: ++@expr1073747140 needlePointer@var2101 ;
551: ++@expr1073747141 haystack@var2098 ;
552: } else { if (@expr5318 *@expr5302 haystack@var2098 ==@expr5320 ' ' ||@expr5321 *@expr5302 haystack@var2098 ==@expr5323 '\0' ) {
553: if (@expr1073747148 needlePointer@var2101 ==@expr5284 needle@var2100 ) {
554: return 0 ; }
555: break ;
556: }
557:
558:
559: else {
560: needlePointer@var2101 =@expr1073747150 needle@var2100 ;
561:
562: do {
563: ++@expr1073747151 haystack@var2098 ;
564:
565: if (@expr5318 *@expr5302 haystack@var2098 ==@expr5320 ' ' ||@expr5321 *@expr5302 haystack@var2098 ==@expr5323 '\0' ) {
566: return -1 ;
567: }
568: if (@expr5301 *@expr5302 haystack@var2098 ==@expr5303 '|' ) {
569: break ;
570: }
571: } while (@expr1073747161 true ) ;
572:
573: ++@expr1073747162 haystack@var2098 ;
574: } } } }
575: }
576:
577: if (@expr5313 *@expr5305 needlePointer@var2101 ==@expr5315 '\0' ) {
578: return 1 ; }
579:
580: return -1 ;
581: }
582:
583: bool Token :: simpleMatch ( const Token * tok@var2103 , const char pattern@var2104 [ ] , unsigned long pattern_len@var2105 )
584: {
585: if (@expr1073747166 !@expr5343 tok@var2103 ) {
586: return false ; }
587: const char * current@var2106 ; current@var2106 =@expr1073747168 pattern@var2104 ;
588: const char * end@var2107 ; end@var2107 =@expr1073747169 pattern@var2104 +@expr1073747170 pattern_len@var2105 ;
589: const char * next@var2108 ; next@var2108 =@expr1073747171 static_cast < const char *@expr1073747172 > (@expr1073747173 std ::@expr1073747174 memchr (@expr1073747175 pattern@var2104 , ' ' , pattern_len@var2105 ) ) ;
590: if (@expr5352 !@expr5353 next@var2108 ) {
591: next@var2108 =@expr1073747178 end@var2107 ; }
592:
593: while (@expr1073747179 *@expr1073747180 current@var2106 ) {
594: const unsigned long length@var2109 =@expr1073747181 next@var2108 -@expr1073747182 current@var2106 ;
595:
596: if (@expr1073747183 !@expr5343 tok@var2103 ||@expr1073747185 length@var2109 !=@expr1073747186 tok@var2103 .@expr5363 mStr@var2110 .@expr1073747188 length (@expr1073747189 ) ||@expr1073747190 std ::@expr1073747191 strncmp (@expr1073747192 current@var2106 , tok@var2103 .@expr5363 mStr@var2110 .@expr1073747194 c_str (@expr1073747195 ) , length@var2109 ) ) {
597: return false ; }
598:
599: current@var2106 =@expr1073747196 next@var2108 ;
600: if (@expr1073747197 *@expr1073747198 next@var2108 ) {
601: next@var2108 =@expr1073747199 std ::@expr1073747200 strchr (@expr1073747201 ++@expr1073747202 current@var2106 , ' ' ) ;
602: if (@expr5352 !@expr5353 next@var2108 ) {
603: next@var2108 =@expr1073747205 end@var2107 ; }
604: }
605: tok@var2103 =@expr1073747206 tok@var2103 .@expr1073747207 next (@expr1073747208 ) ;
606: }
607:
608: return true ;
609: }
610:
611: bool Token :: firstWordEquals ( const char * str@var2111 , const char * word@var2112 )
612: {
613: for (@expr1073747209 ; ; ) {
614: if (@expr1073747210 *@expr5387 str@var2111 !=@expr1073747212 *@expr5389 word@var2112 ) {
615: return (@expr1073747214 *@expr5387 str@var2111 ==@expr1073747216 ' ' &&@expr1073747217 *@expr5389 word@var2112 ==@expr1073747219 0 ) ;
616: } else { if (@expr1073747220 *@expr5387 str@var2111 ==@expr1073747222 0 ) {
617: break ; } }
618:
619: ++@expr1073747223 str@var2111 ;
620: ++@expr1073747224 word@var2112 ;
621: }
622:
623: return true ;
624: }
625:
626: const char * Token :: chrInFirstWord ( const char * str@var2113 , char c@var2114 )
627: {
628: for (@expr1073747225 ; ; ) {
629: if (@expr1073747226 *@expr5403 str@var2113 ==@expr1073747228 ' ' ||@expr1073747229 *@expr5403 str@var2113 ==@expr1073747231 0 ) {
630: return nullptr ; }
631:
632: if (@expr1073747232 *@expr5403 str@var2113 ==@expr1073747234 c@var2114 ) {
633: return str@var2113 ; }
634:
635: ++@expr1073747235 str@var2113 ;
636: }
637: }
638:
639: bool Token :: Match ( const Token * tok@var2115 , const char pattern@var2116 [ ] , int varid@var2117 )
640: {
641: const char * p@var2118 ; p@var2118 =@expr1073747236 pattern@var2116 ;
642: while (@expr1073747237 *@expr5414 p@var2118 ) {
643:
644: while (@expr1073747239 *@expr5414 p@var2118 ==@expr1073747241 ' ' ) {
645: ++@expr1073747242 p@var2118 ; }
646:
647:
648: if (@expr1073747243 *@expr5414 p@var2118 ==@expr1073747245 '\0' ) {
649: break ; }
650:
651: if (@expr1073747246 !@expr1073747247 tok@var2115 ) {
652:
653: if (@expr5424 p@var2118 [@expr5425 0 ] ==@expr5426 '!' &&@expr5427 p@var2118 [@expr5428 1 ] ==@expr5429 '!' &&@expr5430 p@var2118 [@expr5431 2 ] !=@expr5432 '\0' ) {
654: while (@expr5433 *@expr5414 p@var2118 &&@expr5435 *@expr5414 p@var2118 !=@expr5437 ' ' ) {
655: ++@expr1073747262 p@var2118 ; }
656: continue ;
657: } else {
658: return false ; }
659: }
660:
661:
662: if (@expr1073747263 p@var2118 [@expr5425 0 ] ==@expr1073747265 '[' &&@expr1073747266 chrInFirstWord (@expr1073747267 p@var2118 , ']' ) ) {
663: if (@expr1073747268 tok@var2115 .@expr5445 str (@expr5446 ) .@expr1073747271 length (@expr1073747272 ) !=@expr1073747273 1 ) {
664: return false ; }
665:
666: const char * temp@var2119 ; temp@var2119 =@expr1073747274 p@var2118 +@expr1073747275 1 ;
667: bool chrFound@var2120 ; chrFound@var2120 =@expr1073747276 false ;
668: int count@var2121 ; count@var2121 =@expr1073747277 0 ;
669: while (@expr1073747278 *@expr5455 temp@var2119 &&@expr1073747280 *@expr5455 temp@var2119 !=@expr1073747282 ' ' ) {
670: if (@expr1073747283 *@expr5455 temp@var2119 ==@expr1073747285 ']' ) {
671: ++@expr1073747286 count@var2121 ;
672: }
673:
674: else { if (@expr1073747287 *@expr5455 temp@var2119 ==@expr1073747289 tok@var2115 .@expr5445 str (@expr5446 ) [@expr5468 0 ] ) {
675: chrFound@var2120 =@expr1073747293 true ;
676: break ;
677: } }
678:
679: ++@expr1073747294 temp@var2119 ;
680: }
681:
682: if (@expr1073747295 count@var2121 >@expr1073747296 1 &&@expr1073747297 tok@var2115 .@expr5445 str (@expr5446 ) [@expr5468 0 ] ==@expr1073747301 ']' ) {
683: chrFound@var2120 =@expr1073747302 true ; }
684:
685: if (@expr1073747303 !@expr1073747304 chrFound@var2120 ) {
686: return false ; }
687:
688: p@var2118 =@expr1073747305 temp@var2119 ;
689: while (@expr5433 *@expr5414 p@var2118 &&@expr5435 *@expr5414 p@var2118 !=@expr5437 ' ' ) {
690: ++@expr1073747311 p@var2118 ; }
691: }
692:
693:
694: else { if (@expr5424 p@var2118 [@expr5425 0 ] ==@expr5426 '!' &&@expr5427 p@var2118 [@expr5428 1 ] ==@expr5429 '!' &&@expr5430 p@var2118 [@expr5431 2 ] !=@expr5432 '\0' ) {
695: p@var2118 +=@expr1073747321 2 ;
696: if (@expr1073747322 firstWordEquals (@expr1073747323 p@var2118 , tok@var2115 .@expr5445 str (@expr5446 ) .@expr1073747326 c_str (@expr1073747327 ) ) ) {
697: return false ; }
698: while (@expr5433 *@expr5414 p@var2118 &&@expr5435 *@expr5414 p@var2118 !=@expr5437 ' ' ) {
699: ++@expr1073747333 p@var2118 ; }
700: }
701:
702:
703: else {
704: const int res@var2122 =@expr1073747334 multiCompare (@expr1073747335 tok@var2115 , p@var2118 , varid@var2117 ) ;
705: if (@expr1073747336 res@var2122 ==@expr1073747337 0 ) {
706:
707: while (@expr5433 *@expr5414 p@var2118 &&@expr5435 *@expr5414 p@var2118 !=@expr5437 ' ' ) {
708: ++@expr1073747343 p@var2118 ; }
709: continue ;
710: } else { if (@expr1073747344 res@var2122 ==@expr1073747345 -1 ) {
711:
712: return false ;
713: } }
714: } }
715:
716: while (@expr5433 *@expr5414 p@var2118 &&@expr5435 *@expr5414 p@var2118 !=@expr5437 ' ' ) {
717: ++@expr1073747351 p@var2118 ; }
718:
719: tok@var2115 =@expr1073747352 tok@var2115 .@expr1073747353 next (@expr1073747354 ) ;
720: }
721:
722:
723: return true ;
724: }
725:
726: int Token :: getStrLength ( const Token * tok@var2123 )
727: {
728: assert (@expr1073747355 tok@var2123 !=@expr1073747356 nullptr ) ;
729: assert (@expr1073747357 tok@var2123 .@expr1073747358 mTokType@var2124 ==@expr1073747359 eString ) ;
730:
731: int len@var2125 ; len@var2125 =@expr1073747360 0 ;
732: const std ::@expr1073747361 string str@var2126 (@expr1073747362 getStringLiteral (@expr1073747363 tok@var2123 .@expr1073747364 str (@expr1073747365 ) ) ) ;
733: std ::@expr1073747366 string ::@expr1073747367 const_iterator it@var2127 ; it@var2127 =@expr1073747368 str@var2126 .@expr1073747369 begin (@expr1073747370 ) ;
734: const std ::@expr5547 string ::@expr5547 const_iterator end@var2128 =@expr1073747373 str@var2126 .@expr1073747374 end (@expr1073747375 ) ;
735:
736: while (@expr1073747376 it@var2127 !=@expr1073747377 end@var2128 ) {
737: if (@expr1073747378 *@expr5555 it@var2127 ==@expr1073747380 '\\' ) {
738: ++@expr1073747381 it@var2127 ;
739:
740:
741: if (@expr1073747382 *@expr5555 it@var2127 ==@expr1073747384 '0' ) {
742: return len@var2125 ; }
743: }
744:
745: if (@expr1073747385 *@expr5555 it@var2127 ==@expr1073747387 '\0' ) {
746: return len@var2125 ; }
747:
748: ++@expr1073747388 it@var2127 ;
749: ++@expr1073747389 len@var2125 ;
750: }
751:
752: return len@var2125 ;
753: }
754:
755: int Token :: getStrArraySize ( const Token * tok@var2129 )
756: {
757: assert (@expr1073747390 tok@var2129 !=@expr1073747391 nullptr ) ;
758: assert (@expr1073747392 tok@var2129 .@expr1073747393 tokType (@expr1073747394 ) ==@expr1073747395 eString ) ;
759: const std ::@expr1073747396 string str@var2130 (@expr1073747397 getStringLiteral (@expr1073747398 tok@var2129 .@expr1073747399 str (@expr1073747400 ) ) ) ;
760: int sizeofstring@var2131 ; sizeofstring@var2131 =@expr1073747401 1 ;
761: for (@expr1073747402 int i@var2132 =@expr1073747403 0 ; i@var2132 <@expr1073747404 (@expr1073747405 int ) str@var2130 .@expr1073747406 size (@expr1073747407 ) ; i@var2132 ++@expr1073747408 ) {
762: if (@expr1073747409 str@var2130 [@expr1073747410 i@var2132 ] ==@expr1073747411 '\\' ) {
763: ++@expr1073747412 i@var2132 ; }
764: ++@expr1073747413 sizeofstring@var2131 ;
765: }
766: return sizeofstring@var2131 ;
767: }
768:
769: int Token :: getStrSize ( const Token * tok@var2133 , const Settings * settings@var2134 )
770: {
771: assert (@expr1073747414 tok@var2133 !=@expr1073747415 nullptr &&@expr1073747416 tok@var2133 .@expr1073747417 tokType (@expr1073747418 ) ==@expr1073747419 eString ) ;
772: int sizeofType@var2135 ; sizeofType@var2135 =@expr1073747420 1 ;
773: if (@expr1073747421 tok@var2133 .@expr5598 valueType (@expr5599 ) ) {
774: ValueType vt@var2136 (@expr1073747424 *@expr1073747425 tok@var2133 .@expr5598 valueType (@expr5599 ) ) ;
775: vt@var2136 .@expr1073747428 pointer@var2137 =@expr1073747429 0 ;
776: sizeofType@var2135 =@expr1073747430 ValueFlow ::@expr1073747431 getSizeOf (@expr1073747432 vt@var2136 , settings@var2134 ) ;
777: }
778: return getStrArraySize (@expr1073747433 tok@var2133 ) *@expr1073747434 sizeofType@var2135 ;
779: }
780:
781: std :: string Token :: getCharAt ( const Token * tok@var2138 , long long index@var2139 )
782: {
783: assert (@expr1073747435 tok@var2138 !=@expr1073747436 nullptr ) ;
784: std ::@expr1073747437 string str@var2140 (@expr1073747438 getStringLiteral (@expr1073747439 tok@var2138 .@expr1073747440 str (@expr1073747441 ) ) ) ;
785: std ::@expr1073747442 string ::@expr1073747443 const_iterator it@var2141 ; it@var2141 =@expr1073747444 str@var2140 .@expr1073747445 begin (@expr1073747446 ) ;
786: const std ::@expr5623 string ::@expr5623 const_iterator end@var2142 =@expr1073747449 str@var2140 .@expr1073747450 end (@expr1073747451 ) ;
787:
788: while (@expr1073747452 it@var2141 !=@expr1073747453 end@var2142 ) {
789: if (@expr1073747454 index@var2139 ==@expr5631 0 ) {
790: if (@expr1073747456 *@expr5633 it@var2141 ==@expr1073747458 '\0' ) {
791: return "\\0" ; }
792:
793: std ::@expr1073747459 string ret@var2143 (@expr1073747460 1 , *@expr5633 it@var2141 ) ;
794: if (@expr5638 *@expr5633 it@var2141 ==@expr5640 '\\' ) {
795: ++@expr1073747465 it@var2141 ;
796: ret@var2143 +=@expr1073747466 *@expr5633 it@var2141 ;
797: }
798: return ret@var2143 ;
799: }
800:
801: if (@expr5638 *@expr5633 it@var2141 ==@expr5640 '\\' ) {
802: ++@expr1073747471 it@var2141 ; }
803: ++@expr1073747472 it@var2141 ;
804: --@expr1073747473 index@var2139 ;
805: }
806: assert (@expr1073747474 index@var2139 ==@expr5631 0 ) ;
807:
808: return "\\0" ;
809: }
810:
811: void Token :: move ( Token * srcStart@var2144 , Token * srcEnd@var2145 , Token * newLocation@var2146 )
812: {
813:
814:
815:
816: srcStart@var2144 .@expr5652 previous (@expr5653 ) .@expr1073747478 next (@expr1073747479 srcEnd@var2145 .@expr5656 next (@expr5657 ) ) ;
817: srcEnd@var2145 .@expr5656 next (@expr5657 ) .@expr1073747484 previous (@expr1073747485 srcStart@var2144 .@expr5652 previous (@expr5653 ) ) ;
818:
819:
820: srcEnd@var2145 .@expr5656 next (@expr1073747489 newLocation@var2146 .@expr5666 next (@expr5667 ) ) ;
821: srcStart@var2144 .@expr5652 previous (@expr1073747493 newLocation@var2146 ) ;
822:
823:
824: newLocation@var2146 .@expr5666 next (@expr5667 ) .@expr1073747496 previous (@expr1073747497 srcEnd@var2145 ) ;
825: newLocation@var2146 .@expr5666 next (@expr1073747499 srcStart@var2144 ) ;
826:
827:
828: for (@expr1073747500 Token *@expr1073747501 tok@var2147 =@expr1073747502 srcStart@var2144 ; tok@var2147 !=@expr1073747503 srcEnd@var2145 .@expr5656 next (@expr5657 ) ; tok@var2147 =@expr1073747506 tok@var2147 .@expr1073747507 next (@expr1073747508 ) ) {
829: tok@var2147 .@expr1073747509 mImpl@var2148 .@expr1073747510 mProgressValue@var2149 =@expr1073747511 newLocation@var2146 .@expr1073747512 mImpl@var2150 .@expr1073747513 mProgressValue@var2151 ; }
830: }
831:
832: Token * Token :: nextArgument ( ) const
833: {
834: for (@expr1073747514 const Token *@expr1073747515 tok@var2152 =@expr1073747516 this@expr1073747517 ; tok@var2152 ; tok@var2152 =@expr1073747518 tok@var2152 .@expr5695 next (@expr5696 ) ) {
835: if (@expr1073747521 tok@var2152 .@expr1073747522 str (@expr1073747523 ) ==@expr1073747524 "," ) {
836: return tok@var2152 .@expr5695 next (@expr5696 ) ; }
837: else { if (@expr1073747527 tok@var2152 .@expr5704 link (@expr5705 ) &&@expr1073747530 Token ::@expr5707 Match (@expr1073747532 tok@var2152 , "(|{|[|<" ) ) {
838: tok@var2152 =@expr1073747533 tok@var2152 .@expr5704 link (@expr5705 ) ; }
839: else { if (@expr1073747536 Token ::@expr5707 Match (@expr1073747538 tok@var2152 , ")|;" ) ) {
840: return nullptr ; } } }
841: }
842: return nullptr ;
843: }
844:
845: Token * Token :: nextArgumentBeforeCreateLinks2 ( ) const
846: {
847: for (@expr1073747539 const Token *@expr1073747540 tok@var2153 =@expr1073747541 this@expr1073747542 ; tok@var2153 ; tok@var2153 =@expr1073747543 tok@var2153 .@expr5720 next (@expr5721 ) ) {
848: if (@expr1073747546 tok@var2153 .@expr5723 str (@expr5724 ) ==@expr1073747549 "," ) {
849: return tok@var2153 .@expr5720 next (@expr5721 ) ; }
850: else { if (@expr1073747552 tok@var2153 .@expr5729 link (@expr5730 ) &&@expr1073747555 Token ::@expr5732 Match (@expr1073747557 tok@var2153 , "(|{|[" ) ) {
851: tok@var2153 =@expr1073747558 tok@var2153 .@expr5729 link (@expr5730 ) ; }
852: else { if (@expr1073747561 tok@var2153 .@expr5723 str (@expr5724 ) ==@expr1073747564 "<" ) {
853: const Token * temp@var2154 ; temp@var2154 =@expr1073747565 tok@var2153 .@expr1073747566 findClosingBracket (@expr1073747567 ) ;
854: if (@expr1073747568 temp@var2154 ) {
855: tok@var2153 =@expr1073747569 temp@var2154 ; }
856: } else { if (@expr1073747570 Token ::@expr5732 Match (@expr1073747572 tok@var2153 , ")|;" ) ) {
857: return nullptr ; } } } }
858: }
859: return nullptr ;
860: }
861:
862: Token * Token :: nextTemplateArgument ( ) const
863: {
864: for (@expr1073747573 const Token *@expr1073747574 tok@var2155 =@expr1073747575 this@expr1073747576 ; tok@var2155 ; tok@var2155 =@expr1073747577 tok@var2155 .@expr5754 next (@expr5755 ) ) {
865: if (@expr1073747580 tok@var2155 .@expr1073747581 str (@expr1073747582 ) ==@expr1073747583 "," ) {
866: return tok@var2155 .@expr5754 next (@expr5755 ) ; }
867: else { if (@expr1073747586 tok@var2155 .@expr5763 link (@expr5764 ) &&@expr1073747589 Token ::@expr5766 Match (@expr1073747591 tok@var2155 , "(|{|[|<" ) ) {
868: tok@var2155 =@expr1073747592 tok@var2155 .@expr5763 link (@expr5764 ) ; }
869: else { if (@expr1073747595 Token ::@expr5766 Match (@expr1073747597 tok@var2155 , ">|;" ) ) {
870: return nullptr ; } } }
871: }
872: return nullptr ;
873: }
874:
875: static bool isOperator ( const Token * tok@var2156 )
876: {
877: if (@expr1073747598 tok@var2156 .@expr5775 link (@expr5776 ) ) {
878: tok@var2156 =@expr1073747601 tok@var2156 .@expr5775 link (@expr5776 ) ; }
879:
880: return tok@var2156 .@expr1073747604 strAt (@expr1073747605 -1 ) ==@expr1073747606 "operator" ;
881: }
882:
883: const Token * Token :: findClosingBracket ( ) const
884: {
885: if (@expr1073747607 mStr@var655 !=@expr1073747608 "<" ) {
886: return nullptr ; }
887:
888: if (@expr1073747609 !@expr1073747610 mPrevious@var657 ) {
889: return nullptr ; }
890:
891: if (@expr1073747611 !@expr1073747612 (@expr1073747613 mPrevious@var657 .@expr1073747614 isName (@expr1073747615 ) ||@expr1073747616
892: Token ::@expr5793 Match (@expr1073747618 mPrevious@var657 .@expr1073747619 previous (@expr1073747620 ) , "operator %op% <" ) ||@expr1073747621
893: Token ::@expr5793 Match (@expr1073747623 mPrevious@var657 .@expr1073747624 tokAt (@expr1073747625 -2 ) , "operator [([] [)]] <" ) ) ) {
894: return nullptr ; }
895:
896: const Token * closing@var2157 ; closing@var2157 =@expr1073747626 nullptr ;
897: const bool templateParameter@var2158 (@expr1073747627 strAt (@expr1073747628 -1 ) ==@expr1073747629 "template" ) ;
898: std ::@expr1073747630 set < std ::@expr1073747631 string > templateParameters@var2159 ;
899:
900: bool isDecl@var2160 ; isDecl@var2160 =@expr1073747632 true ;
901: for (@expr1073747633 const Token *@expr1073747634 prev@var2161 =@expr1073747635 previous (@expr1073747636 ) ; prev@var2161 ; prev@var2161 =@expr1073747637 prev@var2161 .@expr1073747638 previous (@expr1073747639 ) ) {
902: if (@expr1073747640 prev@var2161 .@expr1073747641 str (@expr1073747642 ) ==@expr1073747643 "=" ) {
903: isDecl@var2160 =@expr1073747644 false ; }
904: if (@expr1073747645 Token ::@expr1073747646 simpleMatch (@expr1073747647 prev@var2161 , "template <" ) ) {
905: isDecl@var2160 =@expr1073747648 true ; }
906: if (@expr1073747649 Token ::@expr5793 Match (@expr1073747651 prev@var2161 , "[;{}]" ) ) {
907: break ; }
908: }
909:
910: unsigned int depth@var2162 ; depth@var2162 =@expr1073747652 0 ;
911: for (@expr1073747653 closing@var2157 =@expr1073747654 this@expr1073747655 ; closing@var2157 !=@expr1073747656 nullptr ; closing@var2157 =@expr1073747657 closing@var2157 .@expr1073747658 next (@expr1073747659 ) ) {
912: if (@expr1073747660 Token ::@expr5793 Match (@expr1073747662 closing@var2157 , "{|[|(" ) ) {
913: closing@var2157 =@expr1073747663 closing@var2157 .@expr1073747664 link (@expr1073747665 ) ;
914: if (@expr1073747666 !@expr1073747667 closing@var2157 ) {
915: return nullptr ; }
916: } else { if (@expr1073747668 Token ::@expr5793 Match (@expr1073747670 closing@var2157 , "}|]|)|;" ) ) {
917: return nullptr ; }
918:
919: else { if (@expr1073747671 closing@var2157 .@expr5848 str (@expr5849 ) ==@expr1073747674 "<" &&@expr1073747675 closing@var2157 .@expr5852 previous (@expr5853 ) &&@expr1073747678
920: (@expr1073747679 closing@var2157 .@expr5852 previous (@expr5853 ) .@expr5858 isName (@expr5859 ) ||@expr1073747684 isOperator (@expr1073747685 closing@var2157 .@expr5852 previous (@expr5853 ) ) ) &&@expr1073747688
921: (@expr1073747689 templateParameter@var2158 ?@expr1073747690 templateParameters@var2159 .@expr1073747691 find (@expr1073747692 closing@var2157 .@expr5869 strAt (@expr5870 -1 ) ) ==@expr1073747695 templateParameters@var2159 .@expr1073747696 end (@expr1073747697 ) :@expr1073747698 true ) ) {
922: ++@expr1073747699 depth@var2162 ; }
923: else { if (@expr1073747700 closing@var2157 .@expr5848 str (@expr5849 ) ==@expr1073747703 ">" ) {
924: if (@expr1073747704 --@expr1073747705 depth@var2162 ==@expr1073747706 0 ) {
925: return closing@var2157 ; }
926: } else { if (@expr1073747707 closing@var2157 .@expr5848 str (@expr5849 ) ==@expr1073747710 ">>" ||@expr1073747711 closing@var2157 .@expr5848 str (@expr5849 ) ==@expr1073747714 ">>=" ) {
927: if (@expr1073747715 !@expr1073747716 isDecl@var2160 &&@expr1073747717 depth@var2162 ==@expr5894 1 ) {
928: continue ; }
929: if (@expr1073747719 depth@var2162 <=@expr1073747720 2 ) {
930: return closing@var2157 ; }
931: depth@var2162 -=@expr1073747721 2 ;
932: }
933:
934: else { if (@expr1073747722 templateParameter@var2158 &&@expr1073747723 depth@var2162 ==@expr5894 1 &&@expr1073747725 closing@var2157 .@expr5848 str (@expr5849 ) ==@expr1073747728 "," &&@expr1073747729
935: closing@var2157 .@expr5852 previous (@expr5853 ) .@expr5858 isName (@expr5859 ) &&@expr1073747734 !@expr1073747735 Match (@expr1073747736 closing@var2157 .@expr5852 previous (@expr5853 ) , "class|typename|." ) ) {
936: templateParameters@var2159 .@expr1073747739 insert (@expr1073747740 closing@var2157 .@expr5869 strAt (@expr5870 -1 ) ) ; } } } } } }
937: }
938:
939: return closing@var2157 ;
940: }
941:
942: Token * Token :: findClosingBracket ( )
943: {
944:
945: return const_cast < Token *@expr5919 > (@expr1073747744 const_cast < const Token *@expr5919 > (@expr1073747746 this@expr1073747747 ) .@expr1073747748 findClosingBracket (@expr1073747749 ) ) ;
946: }
947:
948: const Token * Token :: findOpeningBracket ( ) const
949: {
950: if (@expr1073747750 mStr@var655 !=@expr1073747751 ">" ) {
951: return nullptr ; }
952:
953: const Token * opening@var2163 ; opening@var2163 =@expr1073747752 nullptr ;
954:
955: unsigned int depth@var2164 ; depth@var2164 =@expr1073747753 0 ;
956: for (@expr1073747754 opening@var2163 =@expr1073747755 this@expr1073747756 ; opening@var2163 !=@expr1073747757 nullptr ; opening@var2163 =@expr1073747758 opening@var2163 .@expr1073747759 previous (@expr1073747760 ) ) {
957: if (@expr1073747761 Token ::@expr5938 Match (@expr1073747763 opening@var2163 , "}|]|)" ) ) {
958: opening@var2163 =@expr1073747764 opening@var2163 .@expr1073747765 link (@expr1073747766 ) ;
959: if (@expr1073747767 !@expr1073747768 opening@var2163 ) {
960: return nullptr ; }
961: } else { if (@expr1073747769 Token ::@expr5938 Match (@expr1073747771 opening@var2163 , "{|{|(|;" ) ) {
962: return nullptr ; }
963: else { if (@expr1073747772 opening@var2163 .@expr5949 str (@expr5950 ) ==@expr1073747775 ">" ) {
964: ++@expr1073747776 depth@var2164 ; }
965: else { if (@expr1073747777 opening@var2163 .@expr5949 str (@expr5950 ) ==@expr1073747780 "<" ) {
966: if (@expr1073747781 --@expr1073747782 depth@var2164 ==@expr1073747783 0 ) {
967: return opening@var2163 ; }
968: } } } }
969: }
970:
971: return opening@var2163 ;
972: }
973:
974: Token * Token :: findOpeningBracket ( )
975: {
976:
977: return const_cast < Token *@expr5960 > (@expr1073747785 const_cast < const Token *@expr5960 > (@expr1073747787 this@expr1073747788 ) .@expr1073747789 findOpeningBracket (@expr1073747790 ) ) ;
978: }
979:
980:
981:
982: const Token * Token :: findsimplematch ( const Token * const startTok@var2165 , const char pattern@var2166 [ ] , unsigned long pattern_len@var2167 )
983: {
984: for (@expr1073747791 const Token *@expr1073747792 tok@var2168 =@expr1073747793 startTok@var2165 ; tok@var2168 ; tok@var2168 =@expr1073747794 tok@var2168 .@expr1073747795 next (@expr1073747796 ) ) {
985: if (@expr1073747797 Token ::@expr1073747798 simpleMatch (@expr1073747799 tok@var2168 , pattern@var2166 , pattern_len@var2167 ) ) {
986: return tok@var2168 ; }
987: }
988: return nullptr ;
989: }
990:
991: const Token * Token :: findsimplematch ( const Token * const startTok@var2169 , const char pattern@var2170 [ ] , unsigned long pattern_len@var2171 , const Token * const end@var2172 )
992: {
993: for (@expr1073747800 const Token *@expr1073747801 tok@var2173 =@expr1073747802 startTok@var2169 ; tok@var2173 &&@expr1073747803 tok@var2173 !=@expr1073747804 end@var2172 ; tok@var2173 =@expr1073747805 tok@var2173 .@expr1073747806 next (@expr1073747807 ) ) {
994: if (@expr1073747808 Token ::@expr1073747809 simpleMatch (@expr1073747810 tok@var2173 , pattern@var2170 , pattern_len@var2171 ) ) {
995: return tok@var2173 ; }
996: }
997: return nullptr ;
998: }
999:
1000: const Token * Token :: findmatch ( const Token * const startTok@var2174 , const char pattern@var2175 [ ] , const int varId@var2176 )
1001: {
1002: for (@expr1073747811 const Token *@expr1073747812 tok@var2177 =@expr1073747813 startTok@var2174 ; tok@var2177 ; tok@var2177 =@expr1073747814 tok@var2177 .@expr1073747815 next (@expr1073747816 ) ) {
1003: if (@expr1073747817 Token ::@expr1073747818 Match (@expr1073747819 tok@var2177 , pattern@var2175 , varId@var2176 ) ) {
1004: return tok@var2177 ; }
1005: }
1006: return nullptr ;
1007: }
1008:
1009: const Token * Token :: findmatch ( const Token * const startTok@var2178 , const char pattern@var2179 [ ] , const Token * const end@var2180 , const int varId@var2181 )
1010: {
1011: for (@expr1073747820 const Token *@expr1073747821 tok@var2182 =@expr1073747822 startTok@var2178 ; tok@var2182 &&@expr1073747823 tok@var2182 !=@expr1073747824 end@var2180 ; tok@var2182 =@expr1073747825 tok@var2182 .@expr1073747826 next (@expr1073747827 ) ) {
1012: if (@expr1073747828 Token ::@expr1073747829 Match (@expr1073747830 tok@var2182 , pattern@var2179 , varId@var2181 ) ) {
1013: return tok@var2182 ; }
1014: }
1015: return nullptr ;
1016: }
1017:
1018: void Token :: function ( const Function * f@var2183 )
1019: {
1020: mImpl@var661 .@expr1073747831 mFunction@var2611 =@expr1073747832 f@var2183 ;
1021: if (@expr1073747833 f@var2183 ) {
1022: if (@expr1073747834 f@var2183 .@expr1073747835 isLambda (@expr1073747836 ) ) {
1023: tokType (@expr1073747837 eLambda ) ; }
1024: else {
1025: tokType (@expr1073747838 eFunction ) ; }
1026: } else { if (@expr1073747839 mTokType@var659 ==@expr1073747840 eFunction ) {
1027: tokType (@expr1073747841 eName ) ; } }
1028: }
1029:
1030: Token * Token :: insertToken ( const std :: string & tokenStr@var2184 , const std :: string & originalNameStr@var2185 , bool prepend@var2186 )
1031: {
1032: Token * newToken@var2187 ;
1033: if (@expr1073747842 mStr@var655 .@expr1073747843 empty (@expr1073747844 ) ) {
1034: newToken@var2187 =@expr1073747845 this@expr6022 ; }
1035: else {
1036: newToken@var2187 =@expr1073747847 new Token (@expr1073747848 mTokensFrontBack@var440 ) ; }
1037: newToken@var2187 .@expr6025 str (@expr1073747850 tokenStr@var2184 ) ;
1038: if (@expr1073747851 !@expr1073747852 originalNameStr@var2185 .@expr1073747853 empty (@expr1073747854 ) ) {
1039: newToken@var2187 .@expr1073747855 originalName (@expr1073747856 originalNameStr@var2185 ) ; }
1040:
1041: if (@expr1073747857 newToken@var2187 !=@expr1073747858 this@expr6022 ) {
1042: newToken@var2187 .@expr6035 mImpl@var2188 .@expr1073747860 mLineNumber@var2189 =@expr1073747861 mImpl@var661 .@expr1073747862 mLineNumber@var2612 ;
1043: newToken@var2187 .@expr6035 mImpl@var2188 .@expr1073747864 mFileIndex@var2190 =@expr1073747865 mImpl@var661 .@expr1073747866 mFileIndex@var2613 ;
1044: newToken@var2187 .@expr6035 mImpl@var2188 .@expr1073747868 mProgressValue@var2191 =@expr1073747869 mImpl@var661 .@expr1073747870 mProgressValue@var2614 ;
1045:
1046: if (@expr1073747871 prepend@var2186 ) {
1047: if (@expr1073747872 this@expr6022 .@expr6049 previous (@expr6050 ) ) {
1048: newToken@var2187 .@expr6051 previous (@expr1073747876 this@expr6022 .@expr6049 previous (@expr6050 ) ) ;
1049: newToken@var2187 .@expr6051 previous (@expr6056 ) .@expr1073747881 next (@expr1073747882 newToken@var2187 ) ;
1050: } else { if (@expr6059 mTokensFrontBack@var440 ) {
1051: mTokensFrontBack@var440 .@expr1073747884 front@var2601 =@expr1073747885 newToken@var2187 ;
1052: } }
1053: this@expr6022 .@expr6049 previous (@expr1073747887 newToken@var2187 ) ;
1054: newToken@var2187 .@expr6064 next (@expr1073747889 this@expr6022 ) ;
1055: } else {
1056: if (@expr1073747890 this@expr6022 .@expr6067 next (@expr6068 ) ) {
1057: newToken@var2187 .@expr6064 next (@expr1073747894 this@expr6022 .@expr6067 next (@expr6068 ) ) ;
1058: newToken@var2187 .@expr6064 next (@expr1073747898 ) .@expr1073747899 previous (@expr1073747900 newToken@var2187 ) ;
1059: } else { if (@expr6059 mTokensFrontBack@var440 ) {
1060: mTokensFrontBack@var440 .@expr1073747902 back@var2600 =@expr1073747903 newToken@var2187 ;
1061: } }
1062: this@expr6022 .@expr6067 next (@expr1073747905 newToken@var2187 ) ;
1063: newToken@var2187 .@expr6051 previous (@expr1073747907 this@expr6022 ) ;
1064: }
1065:
1066: if (@expr1073747908 mImpl@var661 .@expr6085 mScopeInfo@var2615 ) {
1067:
1068: if (@expr1073747910 newToken@var2187 .@expr6025 str (@expr6088 ) ==@expr1073747913 "{" ) {
1069: std ::@expr1073747914 string nextScopeNameAddition@var2192 ;
1070:
1071: Token * tok1@var2193 ; tok1@var2193 =@expr1073747915 newToken@var2187 ;
1072: while (@expr6092 Token ::@expr6093 Match (@expr6094 tok1@var2193 .@expr6095 previous (@expr6096 ) , "const|volatile|final|override|&|&&|noexcept" ) ) {
1073: tok1@var2193 =@expr1073747921 tok1@var2193 .@expr6095 previous (@expr6096 ) ; }
1074: if (@expr1073747924 tok1@var2193 .@expr6095 previous (@expr6096 ) &&@expr1073747927 tok1@var2193 .@expr6104 strAt (@expr6105 -1 ) ==@expr1073747930 ")" ) {
1075: tok1@var2193 =@expr1073747931 tok1@var2193 .@expr1073747932 linkAt (@expr1073747933 -1 ) ;
1076: if (@expr1073747934 Token ::@expr6093 Match (@expr1073747936 tok1@var2193 .@expr6095 previous (@expr6096 ) , "throw|noexcept" ) ) {
1077: tok1@var2193 =@expr1073747939 tok1@var2193 .@expr6095 previous (@expr6096 ) ;
1078: while (@expr6092 Token ::@expr6093 Match (@expr6094 tok1@var2193 .@expr6095 previous (@expr6096 ) , "const|volatile|final|override|&|&&|noexcept" ) ) {
1079: tok1@var2193 =@expr1073747947 tok1@var2193 .@expr6095 previous (@expr6096 ) ; }
1080: if (@expr6126 tok1@var2193 .@expr6104 strAt (@expr6105 -1 ) !=@expr6129 ")" ) {
1081: return newToken@var2187 ; }
1082: } else { if (@expr1073747954 Token ::@expr6093 Match (@expr1073747956 newToken@var2187 .@expr1073747957 tokAt (@expr1073747958 -2 ) , ":|, %name%" ) ) {
1083: tok1@var2193 =@expr1073747959 tok1@var2193 .@expr6136 tokAt (@expr6137 -2 ) ;
1084: if (@expr6126 tok1@var2193 .@expr6104 strAt (@expr6105 -1 ) !=@expr6129 ")" ) {
1085: return newToken@var2187 ; }
1086: } }
1087: if (@expr1073747966 tok1@var2193 .@expr6104 strAt (@expr6105 -1 ) ==@expr1073747969 ">" ) {
1088: tok1@var2193 =@expr1073747970 tok1@var2193 .@expr6095 previous (@expr6096 ) .@expr1073747973 findOpeningBracket (@expr1073747974 ) ; }
1089: if (@expr1073747975 tok1@var2193 &&@expr1073747976 Token ::@expr6093 Match (@expr1073747978 tok1@var2193 .@expr6136 tokAt (@expr1073747980 -3 ) , "%name% :: %name%" ) ) {
1090: tok1@var2193 =@expr1073747981 tok1@var2193 .@expr6136 tokAt (@expr6137 -2 ) ;
1091: std ::@expr1073747984 string scope@var2194 ; scope@var2194 =@expr1073747985 tok1@var2193 .@expr6104 strAt (@expr6105 -1 ) ;
1092: while (@expr1073747988 Token ::@expr6093 Match (@expr1073747990 tok1@var2193 .@expr6136 tokAt (@expr6137 -2 ) , ":: %name%" ) ) {
1093: scope@var2194 =@expr1073747993 tok1@var2193 .@expr6104 strAt (@expr1073747995 -3 ) +@expr1073747996 " :: " +@expr1073747997 scope@var2194 ;
1094: tok1@var2193 =@expr1073747998 tok1@var2193 .@expr6136 tokAt (@expr6137 -2 ) ;
1095: }
1096: nextScopeNameAddition@var2192 +=@expr1073748001 scope@var2194 ;
1097: }
1098: }
1099:
1100:
1101: if (@expr1073748002 Token ::@expr6093 Match (@expr1073748004 newToken@var2187 .@expr6051 previous (@expr6056 ) , "%name%|>" ) ) {
1102: Token * nameTok@var2195 ; nameTok@var2195 =@expr1073748007 newToken@var2187 .@expr6051 previous (@expr6056 ) ;
1103: while (@expr1073748010 nameTok@var2195 &&@expr1073748011 !@expr1073748012 Token ::@expr6093 Match (@expr1073748014 nameTok@var2195 , "namespace|class|struct|union %name% {|::|:|<" ) ) {
1104: nameTok@var2195 =@expr1073748015 nameTok@var2195 .@expr1073748016 previous (@expr1073748017 ) ;
1105: }
1106: if (@expr1073748018 nameTok@var2195 ) {
1107: for (@expr1073748019 nameTok@var2195 =@expr1073748020 nameTok@var2195 .@expr6197 next (@expr6198 ) ; nameTok@var2195 &&@expr1073748023 !@expr1073748024 Token ::@expr6093 Match (@expr1073748026 nameTok@var2195 , "{|:|<" ) ; nameTok@var2195 =@expr1073748027 nameTok@var2195 .@expr6197 next (@expr6198 ) ) {
1108: nextScopeNameAddition@var2192 .@expr6206 append (@expr1073748031 nameTok@var2195 .@expr1073748032 str (@expr1073748033 ) ) ;
1109: nextScopeNameAddition@var2192 .@expr6206 append (@expr1073748035 " " ) ;
1110: }
1111: if (@expr1073748036 nextScopeNameAddition@var2192 .@expr6213 length (@expr6214 ) >@expr1073748039 0 ) { nextScopeNameAddition@var2192 =@expr1073748040 nextScopeNameAddition@var2192 .@expr1073748041 substr (@expr1073748042 0 , nextScopeNameAddition@var2192 .@expr6213 length (@expr6214 ) -@expr1073748045 1 ) ; }
1112: }
1113: }
1114:
1115:
1116: std ::@expr1073748046 shared_ptr < ScopeInfo2 > newScopeInfo@var2196 ; newScopeInfo@var2196 =@expr1073748047 std ::@expr1073748048 make_shared < ScopeInfo2 > (@expr1073748049 mImpl@var661 .@expr6085 mScopeInfo@var2615 .@expr1073748051 name@var2616 , nullptr , mImpl@var661 .@expr6085 mScopeInfo@var2615 .@expr6229 usingNamespaces@var2617 ) ;
1117:
1118: if (@expr1073748054 !@expr1073748055 newScopeInfo@var2196 .@expr6232 name@var2197 .@expr1073748057 empty (@expr1073748058 ) &&@expr1073748059 !@expr1073748060 nextScopeNameAddition@var2192 .@expr1073748061 empty (@expr1073748062 ) ) { newScopeInfo@var2196 .@expr6232 name@var2197 .@expr6240 append (@expr1073748065 " :: " ) ; }
1119: newScopeInfo@var2196 .@expr6232 name@var2197 .@expr6240 append (@expr1073748068 nextScopeNameAddition@var2192 ) ;
1120: nextScopeNameAddition@var2192 =@expr1073748069 "" ;
1121:
1122: newToken@var2187 .@expr1073748070 scopeInfo (@expr1073748071 newScopeInfo@var2196 ) ;
1123: } else { if (@expr1073748072 newToken@var2187 .@expr6025 str (@expr6088 ) ==@expr1073748075 "}" ) {
1124: Token * matchingTok@var2198 ; matchingTok@var2198 =@expr1073748076 newToken@var2187 .@expr6051 previous (@expr6056 ) ;
1125: int depth@var2199 ; depth@var2199 =@expr1073748079 0 ;
1126: while (@expr1073748080 matchingTok@var2198 &&@expr1073748081 (@expr1073748082 depth@var2199 !=@expr1073748083 0 ||@expr1073748084 !@expr1073748085 Token ::@expr6262 simpleMatch (@expr6263 matchingTok@var2198 , "{" ) ) ) {
1127: if (@expr1073748088 Token ::@expr6262 simpleMatch (@expr1073748090 matchingTok@var2198 , "}" ) ) { depth@var2199 ++@expr1073748091 ; }
1128: if (@expr1073748092 Token ::@expr6262 simpleMatch (@expr6263 matchingTok@var2198 , "{" ) ) { depth@var2199 --@expr1073748095 ; }
1129: matchingTok@var2198 =@expr1073748096 matchingTok@var2198 .@expr6273 previous (@expr6274 ) ;
1130: }
1131: if (@expr1073748099 matchingTok@var2198 &&@expr1073748100 matchingTok@var2198 .@expr6273 previous (@expr6274 ) ) {
1132: newToken@var2187 .@expr6035 mImpl@var2188 .@expr6280 mScopeInfo@var2200 =@expr1073748105 matchingTok@var2198 .@expr6273 previous (@expr6274 ) .@expr1073748108 scopeInfo (@expr1073748109 ) ;
1133: }
1134: } else {
1135: if (@expr1073748110 prepend@var2186 &&@expr1073748111 newToken@var2187 .@expr6051 previous (@expr6056 ) ) {
1136: newToken@var2187 .@expr6035 mImpl@var2188 .@expr6280 mScopeInfo@var2200 =@expr1073748116 newToken@var2187 .@expr6051 previous (@expr6056 ) .@expr1073748119 scopeInfo (@expr1073748120 ) ;
1137: } else {
1138: newToken@var2187 .@expr6035 mImpl@var2188 .@expr6280 mScopeInfo@var2200 =@expr1073748123 mImpl@var661 .@expr6085 mScopeInfo@var2615 ;
1139: }
1140: if (@expr1073748125 newToken@var2187 .@expr6025 str (@expr6088 ) ==@expr1073748128 ";" ) {
1141: const Token * statementStart@var2201 ;
1142: for (@expr1073748129 statementStart@var2201 =@expr1073748130 newToken@var2187 ; statementStart@var2201 .@expr6307 previous (@expr6308 ) &&@expr1073748133 !@expr1073748134 Token ::@expr6093 Match (@expr1073748136 statementStart@var2201 .@expr6307 previous (@expr6308 ) , ";|{" ) ; statementStart@var2201 =@expr1073748139 statementStart@var2201 .@expr6307 previous (@expr6308 ) ) { ; }
1143: if (@expr1073748142 Token ::@expr6093 Match (@expr1073748144 statementStart@var2201 , "using namespace %name% ::|;" ) ) {
1144: const Token * tok1@var2202 ; tok1@var2202 =@expr1073748145 statementStart@var2201 .@expr1073748146 tokAt (@expr1073748147 2 ) ;
1145: std ::@expr1073748148 string nameSpace@var2203 ;
1146: while (@expr1073748149 tok1@var2202 &&@expr1073748150 tok1@var2202 .@expr6327 str (@expr6328 ) !=@expr1073748153 ";" ) {
1147: if (@expr1073748154 !@expr1073748155 nameSpace@var2203 .@expr1073748156 empty (@expr1073748157 ) ) {
1148: nameSpace@var2203 +=@expr1073748158 " " ; }
1149: nameSpace@var2203 +=@expr1073748159 tok1@var2202 .@expr6327 str (@expr6328 ) ;
1150: tok1@var2202 =@expr1073748162 tok1@var2202 .@expr1073748163 next (@expr1073748164 ) ;
1151: }
1152: mImpl@var661 .@expr6085 mScopeInfo@var2615 .@expr6229 usingNamespaces@var2617 .@expr1073748167 insert (@expr1073748168 nameSpace@var2203 ) ;
1153: }
1154: }
1155: } }
1156: }
1157: }
1158: return newToken@var2187 ;
1159: }
1160:
1161: void Token :: eraseTokens ( Token * begin@var2204 , const Token * end@var2205 )
1162: {
1163: if (@expr1073748169 !@expr1073748170 begin@var2204 ||@expr1073748171 begin@var2204 ==@expr1073748172 end@var2205 ) {
1164: return ; }
1165:
1166: while (@expr1073748173 begin@var2204 .@expr6350 next (@expr6351 ) &&@expr1073748176 begin@var2204 .@expr6350 next (@expr6351 ) !=@expr1073748179 end@var2205 ) {
1167: begin@var2204 .@expr1073748180 deleteNext (@expr1073748181 ) ;
1168: }
1169: }
1170:
1171: void Token :: createMutualLinks ( Token * begin@var2206 , Token * end@var2207 )
1172: {
1173: assert (@expr1073748182 begin@var2206 !=@expr1073748183 nullptr ) ;
1174: assert (@expr1073748184 end@var2207 !=@expr1073748185 nullptr ) ;
1175: assert (@expr1073748186 begin@var2206 !=@expr1073748187 end@var2207 ) ;
1176: begin@var2206 .@expr1073748188 link (@expr1073748189 end@var2207 ) ;
1177: end@var2207 .@expr1073748190 link (@expr1073748191 begin@var2206 ) ;
1178: }
1179:
1180: void Token :: printOut ( const char * title@var2208 ) const
1181: {
1182: if (@expr1073748194 title@var2208 &&@expr1073748195 title@var2208 [@expr1073748196 0 ] ) {
1183: std ::@expr6373 cout@expr6368 <<@expr1073748198 "\n### " <<@expr1073748199 title@var2208 <<@expr1073748200 " ###\n" ; }
1184: std ::@expr6373 cout@expr6368 <<@expr1073748202 stringifyList (@expr1073748203 stringifyOptions ::@expr1073748204 forPrintOut (@expr1073748205 ) , nullptr , nullptr ) <<@expr1073748206 std ::@expr1073748207 endl@expr1073748193 ;
1185: }
1186:
1187: void Token :: printOut ( const char * title@var2209 , const std :: vector < std :: string > & fileNames@var2210 ) const
1188: {
1189: if (@expr1073748210 title@var2209 &&@expr1073748211 title@var2209 [@expr1073748212 0 ] ) {
1190: std ::@expr6389 cout@expr6384 <<@expr1073748214 "\n### " <<@expr1073748215 title@var2209 <<@expr1073748216 " ###\n" ; }
1191: std ::@expr6389 cout@expr6384 <<@expr1073748218 stringifyList (@expr1073748219 stringifyOptions ::@expr1073748220 forPrintOut (@expr1073748221 ) , &@expr1073748222 fileNames@var2210 , nullptr ) <<@expr1073748223 std ::@expr1073748224 endl@expr1073748209 ;
1192: }
1193:
1194:
1195: void Token :: printLines ( int lines@var2211 ) const
1196: {
1197: const Token * end@var2212 ; end@var2212 =@expr1073748227 this@expr1073748228 ;
1198: while (@expr1073748229 end@var2212 &&@expr1073748230 end@var2212 .@expr1073748231 linenr (@expr1073748232 ) <@expr1073748233 lines@var2211 +@expr1073748234 linenr (@expr1073748235 ) ) {
1199: end@var2212 =@expr1073748236 end@var2212 .@expr1073748237 next (@expr1073748238 ) ; }
1200: std ::@expr1073748239 cout@expr1073748225 <<@expr1073748240 stringifyList (@expr1073748241 stringifyOptions ::@expr1073748242 forDebugExprId (@expr1073748243 ) , nullptr , end@var2212 ) <<@expr1073748244 std ::@expr1073748245 endl@expr1073748226 ;
1201: }
1202:
1203: std :: string Token :: stringify ( const stringifyOptions & options@var2213 ) const
1204: {
1205: std ::@expr1073748247 string ret@var2214 ;
1206: if (@expr1073748248 options@var2213 .@expr1073748249 attributes@var2215 ) {
1207: if (@expr1073748250 isUnsigned (@expr1073748251 ) ) {
1208: ret@var2214 +=@expr1073748252 "unsigned " ; }
1209: else { if (@expr1073748253 isSigned (@expr1073748254 ) ) {
1210: ret@var2214 +=@expr1073748255 "signed " ; } }
1211: if (@expr1073748256 isComplex (@expr1073748257 ) ) {
1212: ret@var2214 +=@expr1073748258 "_Complex " ; }
1213: if (@expr1073748259 isLong (@expr1073748260 ) ) {
1214: if (@expr1073748261 !@expr1073748262 (@expr1073748263 mTokType@var659 ==@expr1073748264 eString ||@expr1073748265 mTokType@var659 ==@expr1073748266 eChar ) ) {
1215: ret@var2214 +=@expr1073748267 "long " ; }
1216: }
1217: }
1218: if (@expr1073748268 options@var2213 .@expr1073748269 macro@var2216 &&@expr1073748270 isExpandedMacro (@expr1073748271 ) ) {
1219: ret@var2214 +=@expr1073748272 '$' ; }
1220: if (@expr1073748273 isName (@expr1073748274 ) &&@expr1073748275 mStr@var655 .@expr6452 find (@expr1073748277 ' ' ) !=@expr1073748278 std ::@expr6455 string ::@expr6456 npos@expr6422 ) {
1221: for (@expr1073748281 char i@var2217 :@expr1073748282 mStr@var655 ) {
1222: if (@expr1073748283 i@var2217 !=@expr1073748284 ' ' ) {
1223: ret@var2214 +=@expr1073748285 i@var2217 ; }
1224: }
1225: } else { if (@expr1073748286 mStr@var655 [@expr1073748287 0 ] !=@expr1073748288 '\"' ||@expr1073748289 mStr@var655 .@expr6452 find (@expr1073748291 '\0' ) ==@expr1073748292 std ::@expr6455 string ::@expr6456 npos@expr6422 ) {
1226: ret@var2214 +=@expr1073748295 mStr@var655 ; }
1227: else {
1228: for (@expr1073748296 char i@var2218 :@expr1073748297 mStr@var655 ) {
1229: if (@expr1073748298 i@var2218 ==@expr1073748299 '\0' ) {
1230: ret@var2214 +=@expr1073748300 "\\0" ; }
1231: else {
1232: ret@var2214 +=@expr1073748301 i@var2218 ; }
1233: }
1234: } }
1235: if (@expr1073748302 options@var2213 .@expr1073748303 varid@var2219 &&@expr1073748304 mImpl@var661 .@expr6481 mVarId@var2598 !=@expr1073748306 0 ) {
1236: ret@var2214 +=@expr1073748307 '@' ;
1237: ret@var2214 +=@expr1073748308 (@expr1073748309 options@var2213 .@expr6486 idtype@var2220 ?@expr1073748311 "var" :@expr1073748312 "" ) ;
1238: ret@var2214 +=@expr1073748313 std ::@expr6490 to_string (@expr1073748315 mImpl@var661 .@expr6481 mVarId@var2598 ) ;
1239: } else { if (@expr1073748317 options@var2213 .@expr1073748318 exprid@var2221 &&@expr1073748319 mImpl@var661 .@expr6496 mExprId@var2618 !=@expr1073748321 0 ) {
1240: ret@var2214 +=@expr1073748322 '@' ;
1241: ret@var2214 +=@expr1073748323 (@expr1073748324 options@var2213 .@expr6486 idtype@var2220 ?@expr1073748326 "expr" :@expr1073748327 "" ) ;
1242: ret@var2214 +=@expr1073748328 std ::@expr6490 to_string (@expr1073748330 mImpl@var661 .@expr6496 mExprId@var2618 ) ;
1243: } }
1244:
1245: return ret@var2214 ;
1246: }
1247:
1248: std :: string Token :: stringify ( bool varid@var2222 , bool attributes@var2223 , bool macro@var2224 ) const
1249: {
1250: stringifyOptions options@var2225 ;
1251: options@var2225 .@expr1073748332 varid@var2226 =@expr1073748333 varid@var2222 ;
1252: options@var2225 .@expr1073748334 attributes@var2227 =@expr1073748335 attributes@var2223 ;
1253: options@var2225 .@expr1073748336 macro@var2228 =@expr1073748337 macro@var2224 ;
1254: return stringify (@expr1073748338 options@var2225 ) ;
1255: }
1256:
1257: std :: string Token :: stringifyList ( const stringifyOptions & options@var2229 , const std :: vector < std :: string > * fileNames@var2230 , const Token * end@var2231 ) const
1258: {
1259: if (@expr1073748339 this@expr6516 ==@expr1073748341 end@var2231 ) {
1260: return "" ; }
1261:
1262: std ::@expr1073748342 string ret@var2232 ;
1263:
1264: unsigned int lineNumber@var2233 ; lineNumber@var2233 =@expr1073748343 mImpl@var661 .@expr1073748344 mLineNumber@var2612 -@expr1073748345 (@expr1073748346 options@var2229 .@expr6523 linenumbers@var2234 ?@expr1073748348 1U :@expr1073748349 0U ) ;
1265: unsigned int fileIndex@var2235 ; fileIndex@var2235 =@expr1073748350 options@var2229 .@expr6527 files@var2236 ?@expr1073748352 ~@expr6529 0U :@expr1073748354 mImpl@var661 .@expr1073748355 mFileIndex@var2613 ;
1266: std ::@expr1073748356 map < int , unsigned int > lineNumbers@var2237 ;
1267: for (@expr1073748357 const Token *@expr1073748358 tok@var2238 =@expr1073748359 this@expr6516 ; tok@var2238 !=@expr1073748360 end@var2231 ; tok@var2238 =@expr1073748361 tok@var2238 .@expr6538 next (@expr6539 ) ) {
1268: assert (@expr1073748364 tok@var2238 &&@expr1073748365 "end precedes token" ) ;
1269: if (@expr1073748366 !@expr1073748367 tok@var2238 ) {
1270: return ret@var2232 ; }
1271: bool fileChange@var2239 ; fileChange@var2239 =@expr1073748368 false ;
1272: if (@expr1073748369 tok@var2238 .@expr6546 mImpl@var2240 .@expr6547 mFileIndex@var2241 !=@expr1073748372 fileIndex@var2235 ) {
1273: if (@expr1073748373 fileIndex@var2235 !=@expr1073748374 ~@expr6529 0U ) {
1274: lineNumbers@var2237 [@expr6552 fileIndex@var2235 ] =@expr1073748377 tok@var2238 .@expr6546 mImpl@var2240 .@expr6547 mFileIndex@var2241 ;
1275: }
1276:
1277: fileIndex@var2235 =@expr1073748380 tok@var2238 .@expr6546 mImpl@var2240 .@expr6547 mFileIndex@var2241 ;
1278: if (@expr1073748383 options@var2229 .@expr6527 files@var2236 ) {
1279: ret@var2232 +=@expr1073748385 "\n\n##file " ;
1280: if (@expr1073748386 fileNames@var2230 &&@expr1073748387 fileNames@var2230 .@expr1073748388 size (@expr1073748389 ) >@expr1073748390 tok@var2238 .@expr6546 mImpl@var2240 .@expr6547 mFileIndex@var2241 ) {
1281: ret@var2232 +=@expr1073748393 fileNames@var2230 .@expr1073748394 at (@expr1073748395 tok@var2238 .@expr6546 mImpl@var2240 .@expr6547 mFileIndex@var2241 ) ; }
1282: else {
1283: ret@var2232 +=@expr1073748398 std ::@expr6575 to_string (@expr1073748400 fileIndex@var2235 ) ; }
1284: ret@var2232 +=@expr1073748401 '\n' ;
1285: }
1286:
1287: lineNumber@var2233 =@expr1073748402 lineNumbers@var2237 [@expr6552 fileIndex@var2235 ] ;
1288: fileChange@var2239 =@expr1073748404 true ;
1289: }
1290:
1291: if (@expr1073748405 options@var2229 .@expr6582 linebreaks@var2242 &&@expr1073748407 (@expr1073748408 lineNumber@var2233 !=@expr1073748409 tok@var2238 .@expr6586 linenr (@expr6587 ) ||@expr1073748412 fileChange@var2239 ) ) {
1292: if (@expr1073748413 lineNumber@var2233 +@expr1073748414 4 <@expr1073748415 tok@var2238 .@expr6586 linenr (@expr6587 ) &&@expr1073748418 fileIndex@var2235 ==@expr1073748419 tok@var2238 .@expr6546 mImpl@var2240 .@expr6547 mFileIndex@var2241 ) {
1293: ret@var2232 +=@expr1073748422 '\n' ;
1294: ret@var2232 +=@expr1073748423 std ::@expr6575 to_string (@expr1073748425 lineNumber@var2233 +@expr1073748426 1 ) ;
1295: ret@var2232 +=@expr1073748427 ":\n|\n" ;
1296: ret@var2232 +=@expr1073748428 std ::@expr6575 to_string (@expr1073748430 tok@var2238 .@expr6586 linenr (@expr6587 ) -@expr1073748433 1 ) ;
1297: ret@var2232 +=@expr1073748434 ":\n" ;
1298: ret@var2232 +=@expr1073748435 std ::@expr6575 to_string (@expr6613 tok@var2238 .@expr6586 linenr (@expr6587 ) ) ;
1299: ret@var2232 +=@expr1073748440 ": " ;
1300: } else { if (@expr1073748441 this@expr6516 ==@expr1073748442 tok@var2238 &&@expr1073748443 options@var2229 .@expr6523 linenumbers@var2234 ) {
1301: ret@var2232 +=@expr1073748445 std ::@expr6575 to_string (@expr6613 tok@var2238 .@expr6586 linenr (@expr6587 ) ) ;
1302: ret@var2232 +=@expr1073748450 ": " ;
1303: } else { if (@expr1073748451 lineNumber@var2233 >@expr1073748452 tok@var2238 .@expr6586 linenr (@expr6587 ) ) {
1304: lineNumber@var2233 =@expr1073748455 tok@var2238 .@expr6586 linenr (@expr6587 ) ;
1305: ret@var2232 +=@expr1073748458 '\n' ;
1306: if (@expr6635 options@var2229 .@expr6523 linenumbers@var2234 ) {
1307: ret@var2232 +=@expr1073748461 std ::@expr6575 to_string (@expr6639 lineNumber@var2233 ) ;
1308: ret@var2232 +=@expr1073748464 ':' ;
1309: ret@var2232 +=@expr1073748465 ' ' ;
1310: }
1311: } else {
1312: while (@expr1073748466 lineNumber@var2233 <@expr1073748467 tok@var2238 .@expr6586 linenr (@expr6587 ) ) {
1313: ++@expr1073748470 lineNumber@var2233 ;
1314: ret@var2232 +=@expr1073748471 '\n' ;
1315: if (@expr6635 options@var2229 .@expr6523 linenumbers@var2234 ) {
1316: ret@var2232 +=@expr1073748474 std ::@expr6575 to_string (@expr6639 lineNumber@var2233 ) ;
1317: ret@var2232 +=@expr1073748477 ':' ;
1318: if (@expr1073748478 lineNumber@var2233 ==@expr1073748479 tok@var2238 .@expr6586 linenr (@expr6587 ) ) {
1319: ret@var2232 +=@expr1073748482 ' ' ; }
1320: }
1321: }
1322: } } }
1323: lineNumber@var2233 =@expr1073748483 tok@var2238 .@expr6586 linenr (@expr6587 ) ;
1324: }
1325:
1326: ret@var2232 +=@expr1073748486 tok@var2238 .@expr1073748487 stringify (@expr1073748488 options@var2229 ) ;
1327: if (@expr1073748489 tok@var2238 .@expr6538 next (@expr6539 ) !=@expr1073748492 end@var2231 &&@expr1073748493 (@expr1073748494 !@expr1073748495 options@var2229 .@expr6582 linebreaks@var2242 ||@expr1073748497 (@expr1073748498 tok@var2238 .@expr6538 next (@expr6539 ) .@expr1073748501 linenr (@expr1073748502 ) ==@expr1073748503 tok@var2238 .@expr6586 linenr (@expr6587 ) &&@expr1073748506 tok@var2238 .@expr6538 next (@expr6539 ) .@expr1073748509 fileIndex (@expr1073748510 ) ==@expr1073748511 tok@var2238 .@expr1073748512 fileIndex (@expr1073748513 ) ) ) ) {
1328: ret@var2232 +=@expr1073748514 ' ' ; }
1329: }
1330: if (@expr1073748515 options@var2229 .@expr6582 linebreaks@var2242 &&@expr1073748517 (@expr1073748518 options@var2229 .@expr6527 files@var2236 ||@expr1073748520 options@var2229 .@expr6523 linenumbers@var2234 ) ) {
1331: ret@var2232 +=@expr1073748522 '\n' ; }
1332: return ret@var2232 ;
1333: }
1334: std :: string Token :: stringifyList ( bool varid@var2243 , bool attributes@var2244 , bool linenumbers@var2245 , bool linebreaks@var2246 , bool files@var2247 , const std :: vector < std :: string > * fileNames@var2248 , const Token * end@var2249 ) const
1335: {
1336: stringifyOptions options@var2250 ;
1337: options@var2250 .@expr1073748523 varid@var2251 =@expr1073748524 varid@var2243 ;
1338: options@var2250 .@expr1073748525 attributes@var2252 =@expr1073748526 attributes@var2244 ;
1339: options@var2250 .@expr1073748527 macro@var2253 =@expr1073748528 attributes@var2244 ;
1340: options@var2250 .@expr1073748529 linenumbers@var2254 =@expr1073748530 linenumbers@var2245 ;
1341: options@var2250 .@expr1073748531 linebreaks@var2255 =@expr1073748532 linebreaks@var2246 ;
1342: options@var2250 .@expr1073748533 files@var2256 =@expr1073748534 files@var2247 ;
1343: return stringifyList (@expr1073748535 options@var2250 , fileNames@var2248 , end@var2249 ) ;
1344: }
1345:
1346: std :: string Token :: stringifyList ( const Token * end@var2257 , bool attributes@var2258 ) const
1347: {
1348: return stringifyList (@expr1073748536 false , attributes@var2258 , false , false , false , nullptr , end@var2257 ) ;
1349: }
1350:
1351: std :: string Token :: stringifyList ( bool varid@var2259 ) const
1352: {
1353: return stringifyList (@expr1073748537 varid@var2259 , false , true , true , true , nullptr , nullptr ) ;
1354: }
1355:
1356: void Token :: astParent ( Token * tok@var2260 )
1357: {
1358: const Token * tok2@var2261 ; tok2@var2261 =@expr1073748538 tok@var2260 ;
1359: while (@expr1073748539 tok2@var2261 ) {
1360: if (@expr1073748540 this@expr6717 ==@expr1073748542 tok2@var2261 ) {
1361: throw InternalError (@expr1073748543 this@expr6717 , "Internal error. AST cyclic dependency." ) ; }
1362: tok2@var2261 =@expr1073748544 tok2@var2261 .@expr1073748545 astParent (@expr1073748546 ) ;
1363: }
1364:
1365: if (@expr1073748547 this@expr6717 .@expr6724 astParent (@expr6725 ) ) {
1366: Token * parent@var2262 ; parent@var2262 =@expr1073748550 this@expr6717 .@expr6724 astParent (@expr6725 ) ;
1367: if (@expr1073748553 parent@var2262 .@expr1073748554 astOperand1 (@expr1073748555 ) ==@expr1073748556 this@expr6717 ) {
1368: parent@var2262 .@expr6733 mImpl@var2263 .@expr1073748558 mAstOperand1@var2264 =@expr1073748559 nullptr ; }
1369: if (@expr1073748560 parent@var2262 .@expr1073748561 astOperand2 (@expr1073748562 ) ==@expr1073748563 this@expr6717 ) {
1370: parent@var2262 .@expr6733 mImpl@var2263 .@expr1073748565 mAstOperand2@var2265 =@expr1073748566 nullptr ; }
1371: }
1372: mImpl@var661 .@expr1073748567 mAstParent@var2619 =@expr1073748568 tok@var2260 ;
1373: }
1374:
1375: void Token :: astOperand1 ( Token * tok@var2266 )
1376: {
1377: if (@expr1073748569 mImpl@var661 .@expr6746 mAstOperand1@var2620 ) {
1378: mImpl@var661 .@expr6746 mAstOperand1@var2620 .@expr1073748572 astParent (@expr1073748573 nullptr ) ; }
1379:
1380: if (@expr1073748574 tok@var2266 ) {
1381: tok@var2266 =@expr1073748575 tok@var2266 .@expr1073748576 astTop (@expr1073748577 ) ;
1382: tok@var2266 .@expr1073748578 astParent (@expr1073748579 this@expr1073748580 ) ;
1383: }
1384: mImpl@var661 .@expr6746 mAstOperand1@var2620 =@expr1073748582 tok@var2266 ;
1385: }
1386:
1387: void Token :: astOperand2 ( Token * tok@var2267 )
1388: {
1389: if (@expr1073748583 mImpl@var661 .@expr6760 mAstOperand2@var2621 ) {
1390: mImpl@var661 .@expr6760 mAstOperand2@var2621 .@expr1073748586 astParent (@expr1073748587 nullptr ) ; }
1391:
1392: if (@expr1073748588 tok@var2267 ) {
1393: tok@var2267 =@expr1073748589 tok@var2267 .@expr1073748590 astTop (@expr1073748591 ) ;
1394: tok@var2267 .@expr1073748592 astParent (@expr1073748593 this@expr1073748594 ) ;
1395: }
1396: mImpl@var661 .@expr6760 mAstOperand2@var2621 =@expr1073748596 tok@var2267 ;
1397: }
1398:
1399: static const Token * goToLeftParenthesis ( const Token * start@var2268 , const Token * end@var2269 )
1400: {
1401:
1402: int par@var2270 ; par@var2270 =@expr1073748597 0 ;
1403: for (@expr1073748598 const Token *@expr1073748599 tok@var2271 =@expr1073748600 start@var2268 ; tok@var2271 &&@expr1073748601 tok@var2271 !=@expr1073748602 end@var2269 ; tok@var2271 =@expr1073748603 tok@var2271 .@expr1073748604 next (@expr1073748605 ) ) {
1404: if (@expr1073748606 tok@var2271 .@expr6783 str (@expr6784 ) ==@expr1073748609 "(" ) {
1405: ++@expr1073748610 par@var2270 ; }
1406: else { if (@expr1073748611 tok@var2271 .@expr6783 str (@expr6784 ) ==@expr1073748614 ")" ) {
1407: if (@expr1073748615 par@var2270 ==@expr1073748616 0 ) {
1408: start@var2268 =@expr1073748617 tok@var2271 .@expr1073748618 link (@expr1073748619 ) ; }
1409: else {
1410: --@expr1073748620 par@var2270 ; }
1411: } }
1412: }
1413: return start@var2268 ;
1414: }
1415:
1416: static const Token * goToRightParenthesis ( const Token * start@var2272 , const Token * end@var2273 )
1417: {
1418:
1419: int par@var2274 ; par@var2274 =@expr1073748621 0 ;
1420: for (@expr1073748622 const Token *@expr1073748623 tok@var2275 =@expr1073748624 end@var2273 ; tok@var2275 &&@expr1073748625 tok@var2275 !=@expr1073748626 start@var2272 ; tok@var2275 =@expr1073748627 tok@var2275 .@expr1073748628 previous (@expr1073748629 ) ) {
1421: if (@expr1073748630 tok@var2275 .@expr6807 str (@expr6808 ) ==@expr1073748633 ")" ) {
1422: ++@expr1073748634 par@var2274 ; }
1423: else { if (@expr1073748635 tok@var2275 .@expr6807 str (@expr6808 ) ==@expr1073748638 "(" ) {
1424: if (@expr1073748639 par@var2274 ==@expr1073748640 0 ) {
1425: end@var2273 =@expr1073748641 tok@var2275 .@expr1073748642 link (@expr1073748643 ) ; }
1426: else {
1427: --@expr1073748644 par@var2274 ; }
1428: } }
1429: }
1430: return end@var2273 ;
1431: }
1432:
1433: std :: pair < const Token * , const Token * > Token :: findExpressionStartEndTokens ( ) const
1434: {
1435: const Token * const top@var2276 ; top@var2276 =@expr1073748645 this@expr1073748646 ;
1436:
1437:
1438: const Token * start@var2277 ; start@var2277 =@expr1073748647 top@var2276 ;
1439: while (@expr1073748648 start@var2277 .@expr6825 astOperand1 (@expr6826 ) &&@expr1073748651 precedes (@expr1073748652 start@var2277 .@expr6825 astOperand1 (@expr6826 ) , start@var2277 ) ) {
1440: start@var2277 =@expr1073748655 start@var2277 .@expr6825 astOperand1 (@expr6826 ) ; }
1441:
1442:
1443: const Token * end@var2278 ; end@var2278 =@expr1073748658 top@var2276 ;
1444: while (@expr1073748659 end@var2278 .@expr6836 astOperand1 (@expr6837 ) &&@expr1073748662 (@expr1073748663 end@var2278 .@expr6840 astOperand2 (@expr6841 ) ||@expr1073748666 end@var2278 .@expr1073748667 isUnaryPreOp (@expr1073748668 ) ) ) {
1445:
1446: if (@expr1073748669 end@var2278 .@expr1073748670 str (@expr1073748671 ) ==@expr1073748672 "[" ) {
1447: const Token * lambdaEnd@var2279 ; lambdaEnd@var2279 =@expr1073748673 findLambdaEndToken (@expr1073748674 end@var2278 ) ;
1448: if (@expr1073748675 lambdaEnd@var2279 ) {
1449: end@var2278 =@expr1073748676 lambdaEnd@var2279 ;
1450: break ;
1451: }
1452: }
1453: if (@expr1073748677 Token ::@expr6854 Match (@expr1073748679 end@var2278 , "(|[|{" ) &&@expr1073748680
1454: !@expr1073748681 (@expr1073748682 Token ::@expr6854 Match (@expr1073748684 end@var2278 , "( %type%" ) &&@expr1073748685 !@expr1073748686 end@var2278 .@expr6840 astOperand2 (@expr6841 ) ) ) {
1455: end@var2278 =@expr1073748689 end@var2278 .@expr6866 link (@expr6867 ) ;
1456: break ;
1457: }
1458: end@var2278 =@expr1073748692 end@var2278 .@expr6840 astOperand2 (@expr6841 ) ?@expr1073748695 end@var2278 .@expr6840 astOperand2 (@expr6841 ) :@expr1073748698 end@var2278 .@expr6836 astOperand1 (@expr6837 ) ;
1459: }
1460:
1461:
1462: start@var2277 =@expr1073748701 goToLeftParenthesis (@expr1073748702 start@var2277 , end@var2278 ) ;
1463: end@var2278 =@expr1073748703 goToRightParenthesis (@expr1073748704 start@var2277 , end@var2278 ) ;
1464: if (@expr1073748705 Token ::@expr1073748706 simpleMatch (@expr1073748707 end@var2278 , "{" ) ) {
1465: end@var2278 =@expr1073748708 end@var2278 .@expr6866 link (@expr6867 ) ; }
1466: return std ::@expr1073748711 pair < const Token *@expr6888 , const Token *@expr6888 > (@expr1073748714 start@var2277 , end@var2278 ) ;
1467: }
1468:
1469: bool Token :: isCalculation ( ) const
1470: {
1471: if (@expr1073748715 !@expr1073748716 Token ::@expr6893 Match (@expr1073748718 this@expr6895 , "%cop%|++|--" ) ) {
1472: return false ; }
1473:
1474: if (@expr1073748720 Token ::@expr6893 Match (@expr1073748722 this@expr6895 , "*|&" ) ) {
1475:
1476: if (@expr1073748723 !@expr1073748724 this@expr6895 .@expr6901 astOperand2 (@expr6902 ) ) {
1477: return false ; }
1478:
1479: if (@expr1073748727 this@expr6895 .@expr6901 astOperand2 (@expr6902 ) .@expr1073748730 str (@expr1073748731 ) ==@expr1073748732 "[" ) {
1480: return false ; }
1481:
1482:
1483: std ::@expr1073748733 stack < const Token *@expr1073748734 > operands@var2280 ;
1484: operands@var2280 .@expr6911 push (@expr1073748736 this@expr6895 ) ;
1485: while (@expr1073748737 !@expr1073748738 operands@var2280 .@expr1073748739 empty (@expr1073748740 ) ) {
1486: const Token * op@var2281 ; op@var2281 =@expr1073748741 operands@var2280 .@expr1073748742 top (@expr1073748743 ) ;
1487: operands@var2280 .@expr1073748744 pop (@expr1073748745 ) ;
1488: if (@expr1073748746 op@var2281 .@expr1073748747 isNumber (@expr1073748748 ) ||@expr1073748749 op@var2281 .@expr1073748750 varId (@expr1073748751 ) >@expr1073748752 0 ) {
1489: return true ; }
1490: if (@expr1073748753 op@var2281 .@expr6930 astOperand1 (@expr6931 ) ) {
1491: operands@var2280 .@expr6911 push (@expr1073748757 op@var2281 .@expr6930 astOperand1 (@expr6931 ) ) ; }
1492: if (@expr1073748760 op@var2281 .@expr6937 astOperand2 (@expr6938 ) ) {
1493: operands@var2280 .@expr6911 push (@expr1073748764 op@var2281 .@expr6937 astOperand2 (@expr6938 ) ) ; }
1494: else { if (@expr1073748767 Token ::@expr6893 Match (@expr1073748769 op@var2281 , "*|&" ) ) {
1495: return false ; } }
1496: }
1497:
1498:
1499: return false ;
1500: }
1501:
1502: return true ;
1503: }
1504:
1505: bool Token :: isUnaryPreOp ( ) const
1506: {
1507: if (@expr1073748770 !@expr1073748771 astOperand1 (@expr1073748772 ) ||@expr1073748773 astOperand2 (@expr1073748774 ) ) {
1508: return false ; }
1509: if (@expr1073748775 !@expr1073748776 Token ::@expr1073748777 Match (@expr1073748778 this@expr1073748779 , "++|--" ) ) {
1510: return true ; }
1511: const Token * tokbefore@var2282 ; tokbefore@var2282 =@expr1073748780 mPrevious@var657 ;
1512: const Token * tokafter@var2283 ; tokafter@var2283 =@expr1073748781 mNext@var656 ;
1513: for (@expr1073748782 int distance@var2284 =@expr1073748783 1 ; distance@var2284 <@expr1073748784 10 &&@expr1073748785 tokbefore@var2282 ; distance@var2284 ++@expr1073748786 ) {
1514: if (@expr1073748787 tokbefore@var2282 ==@expr1073748788 mImpl@var661 .@expr6965 mAstOperand1@var2620 ) {
1515: return false ; }
1516: if (@expr1073748790 tokafter@var2283 ==@expr1073748791 mImpl@var661 .@expr6965 mAstOperand1@var2620 ) {
1517: return true ; }
1518: tokbefore@var2282 =@expr1073748793 tokbefore@var2282 .@expr1073748794 mPrevious@var2285 ;
1519: tokafter@var2283 =@expr1073748795 tokafter@var2283 .@expr1073748796 mPrevious@var2286 ;
1520: }
1521: return false ;
1522: }
1523:
1524: static std :: string stringFromTokenRange ( const Token * start@var2287 , const Token * end@var2288 )
1525: {
1526: std ::@expr1073748797 string ret@var2289 ;
1527: if (@expr1073748798 end@var2288 ) {
1528: end@var2288 =@expr1073748799 end@var2288 .@expr1073748800 next (@expr1073748801 ) ; }
1529: for (@expr1073748802 const Token *@expr1073748803 tok@var2290 =@expr1073748804 start@var2287 ; tok@var2290 &&@expr1073748805 tok@var2290 !=@expr1073748806 end@var2288 ; tok@var2290 =@expr1073748807 tok@var2290 .@expr1073748808 next (@expr1073748809 ) ) {
1530: if (@expr1073748810 tok@var2290 .@expr6987 isUnsigned (@expr6988 ) ) {
1531: ret@var2289 +=@expr1073748813 "unsigned " ; }
1532: if (@expr1073748814 tok@var2290 .@expr6991 isLong (@expr6992 ) &&@expr1073748817 !@expr1073748818 tok@var2290 .@expr1073748819 isLiteral (@expr1073748820 ) ) {
1533: ret@var2289 +=@expr1073748821 "long " ; }
1534: if (@expr1073748822 tok@var2290 .@expr1073748823 tokType (@expr1073748824 ) ==@expr1073748825 Token ::@expr1073748826 eString ) {
1535: for (@expr1073748827 unsigned char c@var2291 :@expr1073748828 tok@var2290 .@expr7005 str (@expr7006 ) ) {
1536: if (@expr1073748831 c@var2291 ==@expr1073748832 '\n' ) {
1537: ret@var2289 +=@expr1073748833 "\\n" ; }
1538: else { if (@expr1073748834 c@var2291 ==@expr1073748835 '\r' ) {
1539: ret@var2289 +=@expr1073748836 "\\r" ; }
1540: else { if (@expr1073748837 c@var2291 ==@expr1073748838 '\t' ) {
1541: ret@var2289 +=@expr1073748839 "\\t" ; }
1542: else { if (@expr1073748840 c@var2291 >=@expr1073748841 ' ' &&@expr1073748842 c@var2291 <=@expr1073748843 126 ) {
1543: ret@var2289 +=@expr1073748844 c@var2291 ; }
1544: else {
1545: char str@var2292 [@expr1073748845 10 ] ;
1546: sprintf (@expr1073748846 str@var2292 , "\\x%02x" , c@var2291 ) ;
1547: ret@var2289 +=@expr1073748847 str@var2292 ;
1548: } } } }
1549: }
1550: } else { if (@expr1073748848 tok@var2290 .@expr7025 originalName (@expr7026 ) .@expr1073748851 empty (@expr1073748852 ) ||@expr1073748853 tok@var2290 .@expr6987 isUnsigned (@expr6988 ) ||@expr1073748856 tok@var2290 .@expr6991 isLong (@expr6992 ) ) {
1551: ret@var2289 +=@expr1073748859 tok@var2290 .@expr7005 str (@expr7006 ) ;
1552: } else {
1553: ret@var2289 +=@expr1073748862 tok@var2290 .@expr7025 originalName (@expr7026 ) ; } }
1554: if (@expr1073748865 Token ::@expr1073748866 Match (@expr1073748867 tok@var2290 , "%name%|%num% %name%|%num%" ) ) {
1555: ret@var2289 +=@expr1073748868 ' ' ; }
1556: }
1557: return ret@var2289 ;
1558: }
1559:
1560: std :: string Token :: expressionString ( ) const
1561: {
1562: const auto tokens@var2293 =@expr1073748869 findExpressionStartEndTokens (@expr1073748870 ) ;
1563: return stringFromTokenRange (@expr1073748871 tokens@var2293 .@expr1073748872 first@var2294 , tokens@var2293 .@expr1073748873 second@var2295 ) ;
1564: }
1565:
1566: static void astStringXml ( const Token * tok@var2296 , int indent@var2297 , std :: ostream & out@var2298 )
1567: {
1568: const std ::@expr1073748875 string strindent@var2299 (@expr1073748876 indent@var2297 , ' ' ) ;
1569:
1570: out@var2298 <<@expr7053 strindent@var2299 <<@expr1073748878 "<token str=\"" <<@expr1073748879 tok@var2296 .@expr1073748880 str (@expr1073748881 ) <<@expr1073748882 '\"' ;
1571: if (@expr1073748883 tok@var2296 .@expr7060 varId (@expr7061 ) ) {
1572: out@var2298 <<@expr1073748886 " varId=\"" <<@expr1073748887 MathLib ::@expr1073748888 toString (@expr1073748889 tok@var2296 .@expr7060 varId (@expr7061 ) ) <<@expr1073748892 '\"' ; }
1573: if (@expr1073748893 tok@var2296 .@expr7070 variable (@expr7071 ) ) {
1574: out@var2298 <<@expr1073748896 " variable=\"" <<@expr1073748897 tok@var2296 .@expr7070 variable (@expr7071 ) <<@expr1073748900 '\"' ; }
1575: if (@expr1073748901 tok@var2296 .@expr7078 function (@expr7079 ) ) {
1576: out@var2298 <<@expr1073748904 " function=\"" <<@expr1073748905 tok@var2296 .@expr7078 function (@expr7079 ) <<@expr1073748908 '\"' ; }
1577: if (@expr1073748909 !@expr1073748910 tok@var2296 .@expr7087 values (@expr7088 ) .@expr1073748913 empty (@expr1073748914 ) ) {
1578: out@var2298 <<@expr1073748915 " values=\"" <<@expr1073748916 &@expr1073748917 tok@var2296 .@expr7087 values (@expr7088 ) <<@expr1073748920 '\"' ; }
1579:
1580: if (@expr1073748921 !@expr1073748922 tok@var2296 .@expr7099 astOperand1 (@expr7100 ) &&@expr1073748925 !@expr1073748926 tok@var2296 .@expr7103 astOperand2 (@expr7104 ) ) {
1581: out@var2298 <<@expr1073748929 "/>" <<@expr1073748930 std ::@expr7107 endl@expr7050 ;
1582: }
1583:
1584: else {
1585: out@var2298 <<@expr1073748932 '>' <<@expr1073748933 std ::@expr7107 endl@expr7050 ;
1586: if (@expr1073748935 tok@var2296 .@expr7099 astOperand1 (@expr7100 ) ) {
1587: astStringXml (@expr1073748938 tok@var2296 .@expr7099 astOperand1 (@expr7100 ) , indent@var2297 +@expr7117 2U , out@var2298 ) ; }
1588: if (@expr1073748942 tok@var2296 .@expr7103 astOperand2 (@expr7104 ) ) {
1589: astStringXml (@expr1073748945 tok@var2296 .@expr7103 astOperand2 (@expr7104 ) , indent@var2297 +@expr7117 2U , out@var2298 ) ; }
1590: out@var2298 <<@expr7053 strindent@var2299 <<@expr1073748950 "</token>" <<@expr1073748951 std ::@expr7107 endl@expr7050 ;
1591: }
1592: }
1593:
1594: void Token :: printAst ( bool verbose@var2300 , bool xml@var2301 , const std :: vector < std :: string > & fileNames@var2302 , std :: ostream & out@var2303 ) const
1595: {
1596: if (@expr1073748954 !@expr1073748955 xml@var2301 ) {
1597: out@var2303 <<@expr1073748956 "\n\n##AST" <<@expr1073748957 std ::@expr7134 endl@expr7129 ; }
1598:
1599: std ::@expr1073748959 set < const Token *@expr7136 > printed@var2304 ;
1600: for (@expr1073748961 const Token *@expr7136 tok@var2305 =@expr1073748963 this@expr1073748964 ; tok@var2305 ; tok@var2305 =@expr1073748965 tok@var2305 .@expr1073748966 next (@expr1073748967 ) ) {
1601: if (@expr1073748968 !@expr1073748969 tok@var2305 .@expr7146 mImpl@var2306 .@expr1073748971 mAstParent@var2307 &&@expr1073748972 tok@var2305 .@expr7146 mImpl@var2306 .@expr1073748974 mAstOperand1@var2308 ) {
1602: if (@expr1073748975 printed@var2304 .@expr1073748976 find (@expr1073748977 tok@var2305 ) !=@expr1073748978 printed@var2304 .@expr1073748979 end (@expr1073748980 ) ) {
1603: continue ; }
1604: printed@var2304 .@expr1073748981 insert (@expr1073748982 tok@var2305 ) ;
1605:
1606: if (@expr1073748983 xml@var2301 ) {
1607: out@var2303 <<@expr1073748984 "<ast scope=\"" <<@expr1073748985 tok@var2305 .@expr1073748986 scope (@expr1073748987 ) <<@expr1073748988 "\" fileIndex=\"" <<@expr1073748989 tok@var2305 .@expr7166 fileIndex (@expr7167 ) <<@expr1073748992 "\" linenr=\"" <<@expr1073748993 tok@var2305 .@expr7170 linenr (@expr7171 )
1608: <<@expr1073748996 "\" column=\"" <<@expr1073748997 tok@var2305 .@expr1073748998 column (@expr1073748999 ) <<@expr1073749000 "\">" <<@expr1073749001 std ::@expr7134 endl@expr7129 ;
1609: astStringXml (@expr1073749003 tok@var2305 , 2U , out@var2303 ) ;
1610: out@var2303 <<@expr1073749004 "</ast>" <<@expr1073749005 std ::@expr7134 endl@expr7129 ;
1611: } else { if (@expr1073749007 verbose@var2300 ) {
1612: out@var2303 <<@expr1073749008 "[" <<@expr1073749009 fileNames@var2302 [@expr1073749010 tok@var2305 .@expr7166 fileIndex (@expr7167 ) ] <<@expr1073749013 ":" <<@expr1073749014 tok@var2305 .@expr7170 linenr (@expr7171 ) <<@expr1073749017 "]" <<@expr1073749018 std ::@expr7134 endl@expr7129 <<@expr1073749020 tok@var2305 .@expr1073749021 astStringVerbose (@expr1073749022 ) <<@expr1073749023 std ::@expr7134 endl@expr7129 ; }
1613: else {
1614: out@var2303 <<@expr1073749025 tok@var2305 .@expr1073749026 astString (@expr1073749027 " " ) <<@expr1073749028 std ::@expr7134 endl@expr7129 ; } }
1615: if (@expr1073749030 tok@var2305 .@expr1073749031 str (@expr1073749032 ) ==@expr1073749033 "(" ) {
1616: tok@var2305 =@expr1073749034 tok@var2305 .@expr1073749035 link (@expr1073749036 ) ; }
1617: }
1618: }
1619: }
1620:
1621: static void indent ( std :: string & str@var2309 , const int indent1@var2310 , const int indent2@var2311 )
1622: {
1623: for (@expr1073749037 int i@var2312 =@expr1073749038 0 ; i@var2312 <@expr1073749039 indent1@var2310 ; ++@expr1073749040 i@var2312 ) {
1624: str@var2309 +=@expr1073749041 ' ' ; }
1625: for (@expr1073749042 int i@var2313 =@expr1073749043 indent1@var2310 ; i@var2313 <@expr1073749044 indent2@var2311 ; i@var2313 +=@expr1073749045 2 ) {
1626: str@var2309 +=@expr1073749046 "| " ; }
1627: }
1628:
1629: void Token :: astStringVerboseRecursive ( std :: string & ret@var2314 , const int indent1@var2315 , const int indent2@var2316 ) const
1630: {
1631: if (@expr1073749048 isExpandedMacro (@expr1073749049 ) ) {
1632: ret@var2314 +=@expr1073749050 '$' ; }
1633: ret@var2314 +=@expr1073749051 mStr@var655 ;
1634: if (@expr1073749052 mImpl@var661 .@expr7229 mValueType@var2622 ) {
1635: ret@var2314 +=@expr1073749054 " \'" +@expr1073749055 mImpl@var661 .@expr7229 mValueType@var2622 .@expr1073749057 str (@expr1073749058 ) +@expr1073749059 '\'' ; }
1636: if (@expr1073749060 function (@expr7237 ) ) {
1637: std ::@expr1073749062 ostringstream ostr@var2317 ;
1638: ostr@var2317 <<@expr1073749063 std ::@expr1073749064 hex@expr1073749047 <<@expr1073749065 function (@expr7237 ) ;
1639: ret@var2314 +=@expr1073749067 " f:" +@expr1073749068 ostr@var2317 .@expr1073749069 str (@expr1073749070 ) ;
1640: }
1641: ret@var2314 +=@expr1073749071 '\n' ;
1642:
1643: if (@expr1073749072 mImpl@var661 .@expr7249 mAstOperand1@var2620 ) {
1644: int i1@var2318 ; i1@var2318 =@expr1073749074 indent1@var2315 ; int i2@var2319 ; i2@var2319 =@expr1073749075 indent2@var2316 +@expr7252 2 ;
1645: if (@expr1073749077 indent1@var2315 ==@expr7254 indent2@var2316 &&@expr1073749079 !@expr1073749080 mImpl@var661 .@expr7257 mAstOperand2@var2621 ) {
1646: i1@var2318 +=@expr1073749082 2 ; }
1647: indent (@expr7259 ret@var2314 , indent1@var2315 , indent2@var2316 ) ;
1648: ret@var2314 +=@expr1073749084 mImpl@var661 .@expr7257 mAstOperand2@var2621 ?@expr1073749086 "|-" :@expr1073749087 "`-" ;
1649: mImpl@var661 .@expr7249 mAstOperand1@var2620 .@expr1073749089 astStringVerboseRecursive (@expr1073749090 ret@var2314 , i1@var2318 , i2@var2319 ) ;
1650: }
1651: if (@expr1073749091 mImpl@var661 .@expr7257 mAstOperand2@var2621 ) {
1652: int i1@var2320 ; i1@var2320 =@expr1073749093 indent1@var2315 ; int i2@var2321 ; i2@var2321 =@expr1073749094 indent2@var2316 +@expr7252 2 ;
1653: if (@expr1073749096 indent1@var2315 ==@expr7254 indent2@var2316 ) {
1654: i1@var2320 +=@expr1073749098 2 ; }
1655: indent (@expr7259 ret@var2314 , indent1@var2315 , indent2@var2316 ) ;
1656: ret@var2314 +=@expr1073749100 "`-" ;
1657: mImpl@var661 .@expr7257 mAstOperand2@var2621 .@expr1073749102 astStringVerboseRecursive (@expr1073749103 ret@var2314 , i1@var2320 , i2@var2321 ) ;
1658: }
1659: }
1660:
1661: std :: string Token :: astStringVerbose ( ) const
1662: {
1663: std ::@expr1073749104 string ret@var2322 ;
1664: astStringVerboseRecursive (@expr1073749105 ret@var2322 ) ;
1665: return ret@var2322 ;
1666: }
1667:
1668: std :: string Token :: astStringZ3 ( ) const
1669: {
1670: if (@expr1073749106 !@expr1073749107 astOperand1 (@expr7284 ) ) {
1671: return str (@expr7285 ) ; }
1672: if (@expr1073749110 !@expr1073749111 astOperand2 (@expr7288 ) ) {
1673: return "(" +@expr7289 str (@expr7285 ) +@expr7291 " " +@expr7292 astOperand1 (@expr7284 ) .@expr7294 astStringZ3 (@expr7295 ) +@expr1073749120 ")" ; }
1674: return "(" +@expr7289 str (@expr7285 ) +@expr7291 " " +@expr7292 astOperand1 (@expr7284 ) .@expr7294 astStringZ3 (@expr7295 ) +@expr1073749128 " " +@expr1073749129 astOperand2 (@expr7288 ) .@expr1073749131 astStringZ3 (@expr1073749132 ) +@expr1073749133 ")" ;
1675: }
1676:
1677: void Token :: printValueFlow ( bool xml@var2323 , std :: ostream & out@var2324 ) const
1678: {
1679: int line@var2325 ; line@var2325 =@expr1073749136 0 ;
1680: if (@expr7313 xml@var2323 ) {
1681: out@var2324 <<@expr1073749138 "  <valueflow>" <<@expr1073749139 std ::@expr7316 endl@expr7310 ; }
1682: else {
1683: out@var2324 <<@expr1073749141 "\n\n##Value flow" <<@expr1073749142 std ::@expr7316 endl@expr7310 ; }
1684: for (@expr1073749144 const Token *@expr1073749145 tok@var2326 =@expr1073749146 this@expr1073749147 ; tok@var2326 ; tok@var2326 =@expr1073749148 tok@var2326 .@expr1073749149 next (@expr1073749150 ) ) {
1685: if (@expr1073749151 !@expr1073749152 tok@var2326 .@expr7329 mImpl@var2327 .@expr7330 mValues@var2328 ) {
1686: continue ; }
1687: if (@expr1073749155 tok@var2326 .@expr7329 mImpl@var2327 .@expr7330 mValues@var2328 .@expr1073749158 empty (@expr1073749159 ) ) {
1688: continue ; }
1689: if (@expr7313 xml@var2323 ) {
1690: out@var2324 <<@expr1073749161 "    <values id=\"" <<@expr1073749162 tok@var2326 .@expr7329 mImpl@var2327 .@expr7330 mValues@var2328 <<@expr1073749165 "\">" <<@expr1073749166 std ::@expr7316 endl@expr7310 ; }
1691: else { if (@expr1073749168 line@var2325 !=@expr1073749169 tok@var2326 .@expr7346 linenr (@expr7347 ) ) {
1692: out@var2324 <<@expr1073749172 "Line " <<@expr1073749173 tok@var2326 .@expr7346 linenr (@expr7347 ) <<@expr1073749176 std ::@expr7316 endl@expr7310 ; } }
1693: line@var2325 =@expr1073749178 tok@var2326 .@expr7346 linenr (@expr7347 ) ;
1694: if (@expr1073749181 !@expr1073749182 xml@var2323 ) {
1695: ValueFlow ::@expr7359 Value ::@expr1073749184 ValueKind valueKind@var2329 ; valueKind@var2329 =@expr1073749185 tok@var2326 .@expr7329 mImpl@var2327 .@expr7330 mValues@var2328 .@expr7364 front (@expr7365 ) .@expr1073749190 valueKind@expr1073749135 ;
1696: bool same@var2330 ; same@var2330 =@expr1073749191 true ;
1697: for (@expr1073749192 const ValueFlow ::@expr7369 Value &@expr7370 value@var2331 :@expr1073749195 *@expr7372 tok@var2326 .@expr7329 mImpl@var2327 .@expr7330 mValues@var2328 ) {
1698: if (@expr1073749199 value@var2331 .@expr1073749200 valueKind@var2332 !=@expr1073749201 valueKind@var2329 ) {
1699: same@var2330 =@expr1073749202 false ;
1700: break ;
1701: }
1702: }
1703: out@var2324 <<@expr1073749203 "  " <<@expr1073749204 tok@var2326 .@expr1073749205 str (@expr1073749206 ) <<@expr1073749207 " " ;
1704: if (@expr1073749208 same@var2330 ) {
1705: switch (@expr1073749209 valueKind@var2329 ) {
1706: case ValueFlow ::@expr7359 Value ::@expr7387 ValueKind ::@expr1073749212 Impossible :@expr7389
1707: case ValueFlow ::@expr7359 Value ::@expr7387 ValueKind ::@expr1073749216 Known :@expr7389 ;
1708: out@var2324 <<@expr1073749218 "always " ;
1709: break ;
1710: case ValueFlow ::@expr7359 Value ::@expr7387 ValueKind ::@expr1073749221 Inconclusive :@expr7389 ;
1711: out@var2324 <<@expr1073749223 "inconclusive " ;
1712: break ;
1713: case ValueFlow ::@expr7359 Value ::@expr7387 ValueKind ::@expr1073749226 Possible :@expr7389 ;
1714: out@var2324 <<@expr1073749228 "possible " ;
1715: break ;
1716: }
1717: }
1718: if (@expr7405 tok@var2326 .@expr7329 mImpl@var2327 .@expr7330 mValues@var2328 .@expr7408 size (@expr7409 ) >@expr7410 1U ) {
1719: out@var2324 <<@expr1073749235 '{' ; }
1720: }
1721: for (@expr1073749236 const ValueFlow ::@expr7369 Value &@expr7370 value@var2333 :@expr1073749239 *@expr7372 tok@var2326 .@expr7329 mImpl@var2327 .@expr7330 mValues@var2328 ) {
1722: if (@expr7313 xml@var2323 ) {
1723: out@var2324 <<@expr1073749244 "      <value " ;
1724: switch (@expr7421 value@var2333 .@expr7422 valueType@var2334 ) {
1725: case ValueFlow ::@expr7359 Value ::@expr7424 ValueType ::@expr7425 INT :@expr7389 ;
1726: if (@expr1073749251 tok@var2326 .@expr7428 valueType (@expr7429 ) &&@expr1073749254 tok@var2326 .@expr7428 valueType (@expr7429 ) .@expr1073749257 sign@var2636 ==@expr1073749258 ValueType ::@expr1073749259 UNSIGNED ) {
1727: out@var2324 <<@expr7436 "intvalue=\"" <<@expr1073749261 (@expr1073749262 unsigned long long ) value@var2333 .@expr7439 intvalue@var2335 <<@expr1073749264 '\"' ; }
1728: else {
1729: out@var2324 <<@expr7436 "intvalue=\"" <<@expr1073749266 value@var2333 .@expr7439 intvalue@var2335 <<@expr1073749268 '\"' ; }
1730: break ;
1731: case ValueFlow ::@expr7359 Value ::@expr7424 ValueType ::@expr7447 TOK :@expr7389 ;
1732: out@var2324 <<@expr1073749273 "tokvalue=\"" <<@expr1073749274 value@var2333 .@expr7451 tokvalue@var2336 <<@expr1073749276 '\"' ;
1733: break ;
1734: case ValueFlow ::@expr7359 Value ::@expr7424 ValueType ::@expr7455 FLOAT :@expr7389 ;
1735: out@var2324 <<@expr1073749281 "floatvalue=\"" <<@expr1073749282 value@var2333 .@expr7459 floatValue@var2337 <<@expr1073749284 '\"' ;
1736: break ;
1737: case ValueFlow ::@expr7359 Value ::@expr7424 ValueType ::@expr7463 MOVED :@expr7389 ;
1738: out@var2324 <<@expr1073749289 "movedvalue=\"" <<@expr1073749290 ValueFlow ::@expr7359 Value ::@expr7468 toString (@expr7469 value@var2333 .@expr7470 moveKind@var2338 ) <<@expr1073749295 '\"' ;
1739: break ;
1740: case ValueFlow ::@expr7359 Value ::@expr7424 ValueType ::@expr7474 UNINIT :@expr7389 ;
1741: out@var2324 <<@expr1073749300 "uninit=\"1\"" ;
1742: break ;
1743: case ValueFlow ::@expr7359 Value ::@expr7424 ValueType ::@expr7479 BUFFER_SIZE :@expr7389 ;
1744: out@var2324 <<@expr1073749305 "buffer-size=\"" <<@expr1073749306 value@var2333 .@expr7439 intvalue@var2335 <<@expr1073749308 "\"" ;
1745: break ;
1746: case ValueFlow ::@expr7359 Value ::@expr7424 ValueType ::@expr7487 CONTAINER_SIZE :@expr7389 ;
1747: out@var2324 <<@expr1073749313 "container-size=\"" <<@expr1073749314 value@var2333 .@expr7439 intvalue@var2335 <<@expr1073749316 '\"' ;
1748: break ;
1749: case ValueFlow ::@expr7359 Value ::@expr7424 ValueType ::@expr7495 ITERATOR_START :@expr7389 ;
1750: out@var2324 <<@expr1073749321 "iterator-start=\"" <<@expr1073749322 value@var2333 .@expr7439 intvalue@var2335 <<@expr1073749324 '\"' ;
1751: break ;
1752: case ValueFlow ::@expr7359 Value ::@expr7424 ValueType ::@expr7503 ITERATOR_END :@expr7389 ;
1753: out@var2324 <<@expr1073749329 "iterator-end=\"" <<@expr1073749330 value@var2333 .@expr7439 intvalue@var2335 <<@expr1073749332 '\"' ;
1754: break ;
1755: case ValueFlow ::@expr7359 Value ::@expr7424 ValueType ::@expr7511 LIFETIME :@expr7389 ;
1756: out@var2324 <<@expr1073749337 "lifetime=\"" <<@expr1073749338 value@var2333 .@expr7451 tokvalue@var2336 <<@expr1073749340 '\"' ;
1757: out@var2324 <<@expr1073749341 " lifetime-scope=\"" <<@expr1073749342 ValueFlow ::@expr7359 Value ::@expr7468 toString (@expr1073749345 value@var2333 .@expr1073749346 lifetimeScope@var2339 ) <<@expr1073749347 "\"" ;
1758: out@var2324 <<@expr1073749348 " lifetime-kind=\"" <<@expr1073749349 ValueFlow ::@expr7359 Value ::@expr7468 toString (@expr7528 value@var2333 .@expr7529 lifetimeKind@var2340 ) <<@expr1073749354 "\"" ;
1759: break ;
1760: case ValueFlow ::@expr7359 Value ::@expr7424 ValueType ::@expr7533 SYMBOLIC :@expr7389 ;
1761: out@var2324 <<@expr1073749359 "symbolic=\"" <<@expr1073749360 value@var2333 .@expr7451 tokvalue@var2336 <<@expr1073749362 '\"' ;
1762: out@var2324 <<@expr1073749363 " symbolic-delta=\"" <<@expr1073749364 value@var2333 .@expr7439 intvalue@var2335 <<@expr1073749366 '\"' ;
1763: break ;
1764: }
1765: out@var2324 <<@expr1073749367 " bound=\"" <<@expr1073749368 ValueFlow ::@expr7359 Value ::@expr7468 toString (@expr1073749371 value@var2333 .@expr7548 bound@var2341 ) <<@expr1073749373 "\"" ;
1766: if (@expr1073749374 value@var2333 .@expr7551 condition@var2342 ) {
1767: out@var2324 <<@expr1073749376 " condition-line=\"" <<@expr1073749377 value@var2333 .@expr7551 condition@var2342 .@expr1073749379 linenr (@expr1073749380 ) <<@expr1073749381 '\"' ; }
1768: if (@expr1073749382 value@var2333 .@expr1073749383 isKnown (@expr1073749384 ) ) {
1769: out@var2324 <<@expr1073749385 " known=\"true\"" ; }
1770: else { if (@expr1073749386 value@var2333 .@expr1073749387 isPossible (@expr1073749388 ) ) {
1771: out@var2324 <<@expr1073749389 " possible=\"true\"" ; }
1772: else { if (@expr7566 value@var2333 .@expr7567 isImpossible (@expr7568 ) ) {
1773: out@var2324 <<@expr1073749393 " impossible=\"true\"" ; }
1774: else { if (@expr1073749394 value@var2333 .@expr1073749395 isInconclusive (@expr1073749396 ) ) {
1775: out@var2324 <<@expr1073749397 " inconclusive=\"true\"" ; } } } }
1776: out@var2324 <<@expr1073749398 " path=\"" <<@expr1073749399 value@var2333 .@expr7576 path@var2343 <<@expr1073749401 "\"" ;
1777: out@var2324 <<@expr1073749402 "/>" <<@expr1073749403 std ::@expr7316 endl@expr7310 ;
1778: }
1779:
1780: else {
1781: if (@expr1073749405 &@expr1073749406 value@var2333 !=@expr1073749407 &@expr1073749408 tok@var2326 .@expr7329 mImpl@var2327 .@expr7330 mValues@var2328 .@expr7364 front (@expr7365 ) ) {
1782: out@var2324 <<@expr1073749413 "," ; }
1783: if (@expr7566 value@var2333 .@expr7567 isImpossible (@expr7568 ) ) {
1784: out@var2324 <<@expr1073749417 "!" ; }
1785: if (@expr1073749418 value@var2333 .@expr7548 bound@var2341 ==@expr1073749420 ValueFlow ::@expr7359 Value ::@expr7598 Bound ::@expr1073749423 Lower ) {
1786: out@var2324 <<@expr1073749424 ">=" ; }
1787: if (@expr1073749425 value@var2333 .@expr7548 bound@var2341 ==@expr1073749427 ValueFlow ::@expr7359 Value ::@expr7598 Bound ::@expr1073749430 Upper ) {
1788: out@var2324 <<@expr1073749431 "<=" ; }
1789: switch (@expr7421 value@var2333 .@expr7422 valueType@var2334 ) {
1790: case ValueFlow ::@expr7359 Value ::@expr7424 ValueType ::@expr7425 INT :@expr7389 ;
1791: out@var2324 <<@expr1073749438 value@var2333 .@expr7439 intvalue@var2335 ;
1792: break ;
1793: case ValueFlow ::@expr7359 Value ::@expr7424 ValueType ::@expr7447 TOK :@expr7389 ;
1794: out@var2324 <<@expr1073749444 value@var2333 .@expr7451 tokvalue@var2336 .@expr1073749446 str (@expr1073749447 ) ;
1795: break ;
1796: case ValueFlow ::@expr7359 Value ::@expr7424 ValueType ::@expr7455 FLOAT :@expr7389 ;
1797: out@var2324 <<@expr1073749452 value@var2333 .@expr7459 floatValue@var2337 ;
1798: break ;
1799: case ValueFlow ::@expr7359 Value ::@expr7424 ValueType ::@expr7463 MOVED :@expr7389 ;
1800: out@var2324 <<@expr1073749458 ValueFlow ::@expr7359 Value ::@expr7468 toString (@expr7469 value@var2333 .@expr7470 moveKind@var2338 ) ;
1801: break ;
1802: case ValueFlow ::@expr7359 Value ::@expr7424 ValueType ::@expr7474 UNINIT :@expr7389 ;
1803: out@var2324 <<@expr1073749467 "Uninit" ;
1804: break ;
1805: case ValueFlow ::@expr7359 Value ::@expr7424 ValueType ::@expr7479 BUFFER_SIZE :@expr7389
1806: case ValueFlow ::@expr7359 Value ::@expr7424 ValueType ::@expr7487 CONTAINER_SIZE :@expr7389 ;
1807: out@var2324 <<@expr1073749476 "size=" <<@expr1073749477 value@var2333 .@expr7439 intvalue@var2335 ;
1808: break ;
1809: case ValueFlow ::@expr7359 Value ::@expr7424 ValueType ::@expr7495 ITERATOR_START :@expr7389 ;
1810: out@var2324 <<@expr1073749483 "start=" <<@expr1073749484 value@var2333 .@expr7439 intvalue@var2335 ;
1811: break ;
1812: case ValueFlow ::@expr7359 Value ::@expr7424 ValueType ::@expr7503 ITERATOR_END :@expr7389 ;
1813: out@var2324 <<@expr1073749490 "end=" <<@expr1073749491 value@var2333 .@expr7439 intvalue@var2335 ;
1814: break ;
1815: case ValueFlow ::@expr7359 Value ::@expr7424 ValueType ::@expr7511 LIFETIME :@expr7389 ;
1816: out@var2324 <<@expr1073749497 "lifetime[" <<@expr1073749498 ValueFlow ::@expr7359 Value ::@expr7468 toString (@expr7528 value@var2333 .@expr7529 lifetimeKind@var2340 ) <<@expr1073749503 "]=("
1817: <<@expr1073749504 value@var2333 .@expr7451 tokvalue@var2336 .@expr7682 expressionString (@expr7683 ) <<@expr1073749508 ")" ;
1818: break ;
1819: case ValueFlow ::@expr7359 Value ::@expr7424 ValueType ::@expr7533 SYMBOLIC :@expr7389 ;
1820: out@var2324 <<@expr1073749513 "symbolic=(" <<@expr1073749514 value@var2333 .@expr7451 tokvalue@var2336 .@expr7682 expressionString (@expr7683 ) ;
1821: if (@expr1073749518 value@var2333 .@expr7439 intvalue@var2335 >@expr1073749520 0 ) {
1822: out@var2324 <<@expr1073749521 "+" <<@expr1073749522 value@var2333 .@expr7439 intvalue@var2335 ; }
1823: else { if (@expr1073749524 value@var2333 .@expr7439 intvalue@var2335 <@expr1073749526 0 ) {
1824: out@var2324 <<@expr1073749527 "-" <<@expr1073749528 -@expr1073749529 value@var2333 .@expr7439 intvalue@var2335 ; } }
1825: out@var2324 <<@expr1073749531 ")" ;
1826: break ;
1827: }
1828: if (@expr1073749532 value@var2333 .@expr7709 indirect@var2344 >@expr1073749534 0 ) {
1829: for (@expr1073749535 int i@var2345 =@expr1073749536 0 ; i@var2345 <@expr1073749537 value@var2333 .@expr7709 indirect@var2344 ; i@var2345 ++@expr1073749539 ) {
1830: out@var2324 <<@expr1073749540 "*" ; } }
1831: if (@expr1073749541 value@var2333 .@expr7576 path@var2343 >@expr1073749543 0 ) {
1832: out@var2324 <<@expr1073749544 "@" <<@expr1073749545 value@var2333 .@expr7576 path@var2343 ; }
1833: }
1834: }
1835: if (@expr7313 xml@var2323 ) {
1836: out@var2324 <<@expr1073749548 "    </values>" <<@expr1073749549 std ::@expr7316 endl@expr7310 ; }
1837: else { if (@expr7405 tok@var2326 .@expr7329 mImpl@var2327 .@expr7330 mValues@var2328 .@expr7408 size (@expr7409 ) >@expr7410 1U ) {
1838: out@var2324 <<@expr1073749557 '}' <<@expr1073749558 std ::@expr7316 endl@expr7310 ; }
1839: else {
1840: out@var2324 <<@expr1073749560 std ::@expr7316 endl@expr7310 ; } }
1841: }
1842: if (@expr7313 xml@var2323 ) {
1843: out@var2324 <<@expr1073749563 "  </valueflow>" <<@expr1073749564 std ::@expr7316 endl@expr7310 ; }
1844: }
1845:
1846: const ValueFlow :: Value * Token :: getValueLE ( const long long val@var2346 , const Settings * settings@var2347 ) const
1847: {
1848: if (@expr1073749566 !@expr1073749567 mImpl@var661 .@expr7744 mValues@var2623 ) {
1849: return nullptr ; }
1850: return ValueFlow ::@expr1073749569 findValue (@expr1073749570 *@expr1073749571 mImpl@var661 .@expr7744 mValues@var2623 , settings@var2347 , [@expr1073749573 &@expr7750 ] (@expr1073749575 const ValueFlow ::@expr1073749576 Value &@expr7750 v@var2348 ) {
1851: return !@expr1073749578 v@var2348 .@expr1073749579 isImpossible (@expr1073749580 ) &&@expr1073749581 v@var2348 .@expr1073749582 isIntValue (@expr1073749583 ) &&@expr1073749584 v@var2348 .@expr1073749585 intvalue@var2349 <=@expr1073749586 val@var2346 ;
1852: } ) ;
1853: }
1854:
1855: const ValueFlow :: Value * Token :: getValueGE ( const long long val@var2350 , const Settings * settings@var2351 ) const
1856: {
1857: if (@expr1073749587 !@expr1073749588 mImpl@var661 .@expr7765 mValues@var2623 ) {
1858: return nullptr ; }
1859: return ValueFlow ::@expr1073749590 findValue (@expr1073749591 *@expr1073749592 mImpl@var661 .@expr7765 mValues@var2623 , settings@var2351 , [@expr1073749594 &@expr7771 ] (@expr1073749596 const ValueFlow ::@expr1073749597 Value &@expr7771 v@var2352 ) {
1860: return !@expr1073749599 v@var2352 .@expr1073749600 isImpossible (@expr1073749601 ) &&@expr1073749602 v@var2352 .@expr1073749603 isIntValue (@expr1073749604 ) &&@expr1073749605 v@var2352 .@expr1073749606 intvalue@var2353 >=@expr1073749607 val@var2350 ;
1861: } ) ;
1862: }
1863:
1864: const ValueFlow :: Value * Token :: getInvalidValue ( const Token * ftok@var2354 , int argnr@var2355 , const Settings * settings@var2356 ) const
1865: {
1866: if (@expr1073749608 !@expr1073749609 mImpl@var661 .@expr7786 mValues@var2623 ||@expr1073749611 !@expr1073749612 settings@var2356 ) {
1867: return nullptr ; }
1868: const ValueFlow ::@expr1073749613 Value * ret@var2357 ; ret@var2357 =@expr1073749614 nullptr ;
1869: std ::@expr1073749615 list < ValueFlow ::@expr1073749616 Value > ::@expr1073749617 const_iterator it@var2358 ;
1870: for (@expr1073749618 it@var2358 =@expr1073749619 mImpl@var661 .@expr7786 mValues@var2623 .@expr1073749621 begin (@expr1073749622 ) ; it@var2358 !=@expr1073749623 mImpl@var661 .@expr7786 mValues@var2623 .@expr1073749625 end (@expr1073749626 ) ; ++@expr1073749627 it@var2358 ) {
1871: if (@expr1073749628 it@var2358 .@expr1073749629 isImpossible (@expr1073749630 ) ) {
1872: continue ; }
1873: if (@expr1073749631 (@expr1073749632 it@var2358 .@expr1073749633 isIntValue (@expr1073749634 ) &&@expr1073749635 !@expr1073749636 settings@var2356 .@expr7813 library@var2359 .@expr1073749638 isIntArgValid (@expr1073749639 ftok@var2354 , argnr@var2355 , it@var2358 .@expr1073749640 intvalue@var2360 ) ) ||@expr1073749641
1874: (@expr1073749642 it@var2358 .@expr1073749643 isFloatValue (@expr1073749644 ) &&@expr1073749645 !@expr1073749646 settings@var2356 .@expr7813 library@var2359 .@expr1073749648 isFloatArgValid (@expr1073749649 ftok@var2354 , argnr@var2355 , it@var2358 .@expr1073749650 floatValue@var2361 ) ) ) {
1875: if (@expr1073749651 !@expr1073749652 ret@var2357 ||@expr1073749653 ret@var2357 .@expr7830 isInconclusive (@expr7831 ) ||@expr1073749656 (@expr1073749657 ret@var2357 .@expr7834 condition@var2362 &&@expr1073749659 !@expr1073749660 it@var2358 .@expr1073749661 isInconclusive (@expr1073749662 ) ) ) {
1876: ret@var2357 =@expr1073749663 &@expr1073749664 (@expr1073749665 *@expr1073749666 it@var2358 ) ; }
1877: if (@expr1073749667 !@expr1073749668 ret@var2357 .@expr7830 isInconclusive (@expr7831 ) &&@expr1073749671 !@expr1073749672 ret@var2357 .@expr7834 condition@var2362 ) {
1878: break ; }
1879: }
1880: }
1881: if (@expr1073749674 ret@var2357 ) {
1882: if (@expr1073749675 ret@var2357 .@expr7830 isInconclusive (@expr7831 ) &&@expr1073749678 !@expr1073749679 settings@var2356 .@expr1073749680 certainty@var2363 .@expr1073749681 isEnabled (@expr1073749682 Certainty ::@expr1073749683 inconclusive ) ) {
1883: return nullptr ; }
1884: if (@expr1073749684 ret@var2357 .@expr7834 condition@var2362 &&@expr1073749686 !@expr1073749687 settings@var2356 .@expr1073749688 severity@var2364 .@expr1073749689 isEnabled (@expr1073749690 Severity ::@expr1073749691 warning ) ) {
1885: return nullptr ; }
1886: }
1887: return ret@var2357 ;
1888: }
1889:
1890: const Token * Token :: getValueTokenMinStrSize ( const Settings * settings@var2365 ) const
1891: {
1892: if (@expr1073749693 !@expr1073749694 mImpl@var661 .@expr7871 mValues@var2623 ) {
1893: return nullptr ; }
1894: const Token * ret@var2366 ; ret@var2366 =@expr1073749696 nullptr ;
1895: int minsize@var2367 ; minsize@var2367 =@expr1073749697 INT_MAX@expr1073749692 ;
1896: std ::@expr1073749698 list < ValueFlow ::@expr1073749699 Value > ::@expr1073749700 const_iterator it@var2368 ;
1897: for (@expr1073749701 it@var2368 =@expr1073749702 mImpl@var661 .@expr7871 mValues@var2623 .@expr1073749704 begin (@expr1073749705 ) ; it@var2368 !=@expr1073749706 mImpl@var661 .@expr7871 mValues@var2623 .@expr1073749708 end (@expr1073749709 ) ; ++@expr1073749710 it@var2368 ) {
1898: if (@expr1073749711 it@var2368 .@expr1073749712 isTokValue (@expr1073749713 ) &&@expr1073749714 it@var2368 .@expr7891 tokvalue@var2369 &&@expr1073749716 it@var2368 .@expr7891 tokvalue@var2369 .@expr1073749718 tokType (@expr1073749719 ) ==@expr1073749720 Token ::@expr1073749721 eString ) {
1899: const int size@var2370 =@expr1073749722 getStrSize (@expr1073749723 it@var2368 .@expr7891 tokvalue@var2369 , settings@var2365 ) ;
1900: if (@expr1073749725 !@expr1073749726 ret@var2366 ||@expr1073749727 size@var2370 <@expr1073749728 minsize@var2367 ) {
1901: minsize@var2367 =@expr1073749729 size@var2370 ;
1902: ret@var2366 =@expr1073749730 it@var2368 .@expr7891 tokvalue@var2369 ;
1903: }
1904: }
1905: }
1906: return ret@var2366 ;
1907: }
1908:
1909: const Token * Token :: getValueTokenMaxStrLength ( ) const
1910: {
1911: if (@expr1073749732 !@expr1073749733 mImpl@var661 .@expr7910 mValues@var2623 ) {
1912: return nullptr ; }
1913: const Token * ret@var2371 ; ret@var2371 =@expr1073749735 nullptr ;
1914: int maxlength@var2372 ; maxlength@var2372 =@expr1073749736 0 ;
1915: std ::@expr1073749737 list < ValueFlow ::@expr1073749738 Value > ::@expr1073749739 const_iterator it@var2373 ;
1916: for (@expr1073749740 it@var2373 =@expr1073749741 mImpl@var661 .@expr7910 mValues@var2623 .@expr1073749743 begin (@expr1073749744 ) ; it@var2373 !=@expr1073749745 mImpl@var661 .@expr7910 mValues@var2623 .@expr1073749747 end (@expr1073749748 ) ; ++@expr1073749749 it@var2373 ) {
1917: if (@expr1073749750 it@var2373 .@expr1073749751 isTokValue (@expr1073749752 ) &&@expr1073749753 it@var2373 .@expr7930 tokvalue@var2374 &&@expr1073749755 it@var2373 .@expr7930 tokvalue@var2374 .@expr1073749757 tokType (@expr1073749758 ) ==@expr1073749759 Token ::@expr1073749760 eString ) {
1918: const int length@var2375 =@expr1073749761 getStrLength (@expr1073749762 it@var2373 .@expr7930 tokvalue@var2374 ) ;
1919: if (@expr1073749764 !@expr1073749765 ret@var2371 ||@expr1073749766 length@var2375 >@expr1073749767 maxlength@var2372 ) {
1920: maxlength@var2372 =@expr1073749768 length@var2375 ;
1921: ret@var2371 =@expr1073749769 it@var2373 .@expr7930 tokvalue@var2374 ;
1922: }
1923: }
1924: }
1925: return ret@var2371 ;
1926: }
1927:
1928: static bool isAdjacent ( const ValueFlow :: Value & x@var2376 , const ValueFlow :: Value & y@var2377 )
1929: {
1930: if (@expr1073749771 x@var2376 .@expr7948 bound@var2378 !=@expr1073749773 ValueFlow ::@expr7950 Value ::@expr1073749775 Bound ::@expr1073749776 Point &&@expr1073749777 x@var2376 .@expr7948 bound@var2378 ==@expr1073749779 y@var2377 .@expr1073749780 bound@var2379 ) {
1931: return true ; }
1932: if (@expr1073749781 x@var2376 .@expr1073749782 valueType@var2380 ==@expr1073749783 ValueFlow ::@expr7950 Value ::@expr1073749785 ValueType ::@expr1073749786 FLOAT ) {
1933: return false ; }
1934: return std ::@expr1073749787 abs (@expr1073749788 x@var2376 .@expr1073749789 intvalue@var2381 -@expr1073749790 y@var2377 .@expr1073749791 intvalue@var2382 ) ==@expr1073749792 1 ;
1935: }
1936:
1937: static bool removePointValue ( std :: list < ValueFlow :: Value > & values@var2383 , ValueFlow :: Value & x@var2384 )
1938: {
1939: const bool isPoint@var2385 =@expr1073749794 x@var2384 .@expr1073749795 bound@var2386 ==@expr1073749796 ValueFlow ::@expr1073749797 Value ::@expr1073749798 Bound ::@expr1073749799 Point@expr1073749793 ;
1940: if (@expr1073749800 !@expr1073749801 isPoint@var2385 ) {
1941: x@var2384 .@expr1073749802 decreaseRange (@expr1073749803 ) ; }
1942: else {
1943: values@var2383 .@expr1073749804 remove (@expr1073749805 x@var2384 ) ; }
1944: return isPoint@var2385 ;
1945: }
1946:
1947: static bool removeContradiction ( std :: list < ValueFlow :: Value > & values@var2387 )
1948: {
1949: bool result@var2388 ; result@var2388 =@expr1073749806 false ;
1950: for (@expr1073749807 ValueFlow ::@expr7984 Value &@expr7985 x@var2389 :@expr1073749810 values@var2387 ) {
1951: if (@expr1073749811 x@var2389 .@expr1073749812 isNonValue (@expr1073749813 ) ) {
1952: continue ; }
1953: for (@expr1073749814 ValueFlow ::@expr7984 Value &@expr7985 y@var2390 :@expr1073749817 values@var2387 ) {
1954: if (@expr1073749818 y@var2390 .@expr1073749819 isNonValue (@expr1073749820 ) ) {
1955: continue ; }
1956: if (@expr1073749821 x@var2389 ==@expr1073749822 y@var2390 ) {
1957: continue ; }
1958: if (@expr1073749823 x@var2389 .@expr1073749824 valueType@var2391 !=@expr1073749825 y@var2390 .@expr1073749826 valueType@var2392 ) {
1959: continue ; }
1960: if (@expr1073749827 x@var2389 .@expr8004 isImpossible (@expr8005 ) ==@expr1073749830 y@var2390 .@expr8007 isImpossible (@expr8008 ) ) {
1961: continue ; }
1962: if (@expr1073749833 x@var2389 .@expr1073749834 isSymbolicValue (@expr1073749835 ) &&@expr1073749836 !@expr1073749837 ValueFlow ::@expr8014 Value ::@expr1073749839 sameToken (@expr1073749840 x@var2389 .@expr1073749841 tokvalue@var2393 , y@var2390 .@expr1073749842 tokvalue@var2394 ) ) {
1963: continue ; }
1964: if (@expr1073749843 !@expr1073749844 x@var2389 .@expr1073749845 equalValue (@expr1073749846 y@var2390 ) ) {
1965: auto compare@var2395 ; compare@var2395 =@expr1073749847 [@expr1073749848 ] (@expr1073749849 const ValueFlow ::@expr7984 Value &@expr7985 x@var2396 , const ValueFlow ::@expr7984 Value &@expr7985 y@var2397 ) {
1966: return x@var2396 .@expr1073749854 compareValue (@expr1073749855 y@var2397 , ValueFlow ::@expr1073749856 less {@expr1073749857 } ) ;
1967: } ;
1968: const ValueFlow ::@expr7984 Value &@expr7985 maxValue@var2398 =@expr1073749860 std ::@expr1073749861 max (@expr1073749862 x@var2389 , y@var2390 , compare@var2395 ) ;
1969: const ValueFlow ::@expr7984 Value &@expr7985 minValue@var2399 =@expr1073749865 std ::@expr1073749866 min (@expr1073749867 x@var2389 , y@var2390 , compare@var2395 ) ;
1970:
1971: if (@expr1073749868 maxValue@var2398 .@expr1073749869 isImpossible (@expr1073749870 ) &&@expr1073749871 maxValue@var2398 .@expr1073749872 bound@var2400 ==@expr1073749873 ValueFlow ::@expr8014 Value ::@expr8051 Bound ::@expr1073749876 Upper ) {
1972: values@var2387 .@expr8053 remove (@expr1073749878 minValue@var2399 ) ;
1973: return true ;
1974: }
1975: if (@expr1073749879 minValue@var2399 .@expr1073749880 isImpossible (@expr1073749881 ) &&@expr1073749882 minValue@var2399 .@expr1073749883 bound@var2401 ==@expr1073749884 ValueFlow ::@expr8014 Value ::@expr8051 Bound ::@expr1073749887 Lower ) {
1976: values@var2387 .@expr8053 remove (@expr1073749889 maxValue@var2398 ) ;
1977: return true ;
1978: }
1979: continue ;
1980: }
1981: const bool removex@var2402 =@expr1073749890 !@expr1073749891 x@var2389 .@expr8004 isImpossible (@expr8005 ) ||@expr1073749894 y@var2390 .@expr1073749895 isKnown (@expr1073749896 ) ;
1982: const bool removey@var2403 =@expr1073749897 !@expr1073749898 y@var2390 .@expr8007 isImpossible (@expr8008 ) ||@expr1073749901 x@var2389 .@expr1073749902 isKnown (@expr1073749903 ) ;
1983: if (@expr1073749904 x@var2389 .@expr1073749905 bound@var2404 ==@expr1073749906 y@var2390 .@expr1073749907 bound@var2405 ) {
1984: if (@expr1073749908 removex@var2402 ) {
1985: values@var2387 .@expr8053 remove (@expr1073749910 x@var2389 ) ; }
1986: if (@expr1073749911 removey@var2403 ) {
1987: values@var2387 .@expr8053 remove (@expr1073749913 y@var2390 ) ; }
1988: return true ;
1989: } else {
1990: result@var2388 =@expr1073749914 removex@var2402 ||@expr1073749915 removey@var2403 ;
1991: bool bail@var2406 ; bail@var2406 =@expr1073749916 false ;
1992: if (@expr1073749917 removex@var2402 &&@expr1073749918 removePointValue (@expr1073749919 values@var2387 , x@var2389 ) ) {
1993: bail@var2406 =@expr1073749920 true ; }
1994: if (@expr1073749921 removey@var2403 &&@expr1073749922 removePointValue (@expr1073749923 values@var2387 , y@var2390 ) ) {
1995: bail@var2406 =@expr1073749924 true ; }
1996: if (@expr1073749925 bail@var2406 ) {
1997: return true ; }
1998: }
1999: }
2000: }
2001: return result@var2388 ;
2002: }
2003:
2004:
2005:
2006: template < class Iterator >
2007: static ValueIterator removeAdjacentValues ( std :: list < ValueFlow :: Value > & values@var2407 , ValueIterator x@var2408 , Iterator start@var2409 , Iterator last@var2410 )
2008: {
2009: if (@expr1073749926 !@expr1073749927 isAdjacent (@expr1073749928 *@expr1073749929 x@var2408 , *@expr1073749930 *@expr1073749931 start@var2409 ) ) {
2010: return std ::@expr1073749932 next (@expr1073749933 x@var2408 ) ; }
2011: auto it@var2411 ; it@var2411 =@expr1073749934 std ::@expr1073749935 adjacent_find (@expr1073749936 start@var2409 , last@var2410 , [@expr1073749937 ] (@expr1073749938 ValueIterator x@var2412 , ValueIterator y@var2413 ) {
2012: return !@expr1073749939 isAdjacent (@expr1073749940 *@expr1073749941 x@var2412 , *@expr1073749942 y@var2413 ) ;
2013: } ) ;
2014: if (@expr1073749943 it@var2411 ==@expr1073749944 last@var2410 ) {
2015: it@var2411 --@expr1073749945 ; }
2016: (@expr1073749946 *@expr1073749947 it@var2411 ) .@expr1073749948 bound@var2414 =@expr1073749949 x@var2408 .@expr1073749950 bound@var2415 ;
2017: std ::@expr1073749951 for_each (@expr1073749952 start@var2409 , it@var2411 , [@expr1073749953 &@expr1073749954 ] (@expr1073749955 ValueIterator y@var2416 ) {
2018: values@var2407 .@expr8132 erase (@expr1073749957 y@var2416 ) ;
2019: } ) ;
2020: return values@var2407 .@expr8132 erase (@expr1073749959 x@var2408 ) ;
2021: }
2022:
2023: static void mergeAdjacent ( std :: list < ValueFlow :: Value > & values@var2417 )
2024: {
2025: for (@expr1073749961 auto x@var2418 =@expr1073749962 values@var2417 .@expr8139 begin (@expr8140 ) ; x@var2418 !=@expr1073749965 values@var2417 .@expr8142 end (@expr8143 ) ; ) {
2026: if (@expr1073749968 x@var2418 .@expr1073749969 isNonValue (@expr1073749970 ) ) {
2027: x@var2418 ++@expr1073749971 ;
2028: continue ;
2029: }
2030: if (@expr1073749972 x@var2418 .@expr8149 bound@var2419 ==@expr1073749974 ValueFlow ::@expr8151 Value ::@expr8152 Bound ::@expr8153 Point@expr8136 ) {
2031: x@var2418 ++@expr1073749978 ;
2032: continue ;
2033: }
2034: std ::@expr1073749979 vector < std ::@expr8156 list < ValueFlow ::@expr8156 Value > ::@expr8156 iterator > adjValues@var2420 ;
2035: for (@expr1073749983 auto y@var2421 =@expr1073749984 values@var2417 .@expr8139 begin (@expr8140 ) ; y@var2421 !=@expr1073749987 values@var2417 .@expr8142 end (@expr8143 ) ; y@var2421 ++@expr1073749990 ) {
2036: if (@expr1073749991 x@var2418 ==@expr1073749992 y@var2421 ) {
2037: continue ; }
2038: if (@expr1073749993 y@var2421 .@expr1073749994 isNonValue (@expr1073749995 ) ) {
2039: continue ; }
2040: if (@expr1073749996 x@var2418 .@expr8173 valueType@var2422 !=@expr1073749998 y@var2421 .@expr1073749999 valueType@var2423 ) {
2041: continue ; }
2042: if (@expr1073750000 x@var2418 .@expr1073750001 valueKind@var2424 !=@expr1073750002 y@var2421 .@expr1073750003 valueKind@var2425 ) {
2043: continue ; }
2044: if (@expr1073750004 x@var2418 .@expr1073750005 isSymbolicValue (@expr1073750006 ) &&@expr1073750007 !@expr1073750008 ValueFlow ::@expr8151 Value ::@expr1073750010 sameToken (@expr1073750011 x@var2418 .@expr1073750012 tokvalue@var2426 , y@var2421 .@expr1073750013 tokvalue@var2427 ) ) {
2045: continue ; }
2046: if (@expr1073750014 x@var2418 .@expr8149 bound@var2419 !=@expr1073750016 y@var2421 .@expr8193 bound@var2428 ) {
2047: if (@expr1073750018 y@var2421 .@expr8193 bound@var2428 !=@expr8196 ValueFlow ::@expr8151 Value ::@expr8152 Bound ::@expr8153 Point@expr8136 &&@expr1073750024 isAdjacent (@expr1073750025 *@expr8202 x@var2418 , *@expr8203 y@var2421 ) ) {
2048: adjValues@var2420 .@expr1073750028 clear (@expr1073750029 ) ;
2049: break ;
2050: }
2051:
2052: if (@expr1073750030 x@var2418 .@expr8173 valueType@var2422 ==@expr1073750032 ValueFlow ::@expr8151 Value ::@expr1073750034 ValueType ::@expr1073750035 FLOAT ) {
2053: continue ; }
2054: if (@expr1073750036 y@var2421 .@expr8193 bound@var2428 !=@expr8196 ValueFlow ::@expr8151 Value ::@expr8152 Bound ::@expr8153 Point@expr8136 ) {
2055: continue ; }
2056: }
2057: if (@expr1073750042 x@var2418 .@expr8149 bound@var2419 ==@expr8220 ValueFlow ::@expr8151 Value ::@expr8152 Bound ::@expr8223 Lower &&@expr1073750048 !@expr1073750049 y@var2421 .@expr1073750050 compareValue (@expr1073750051 *@expr8202 x@var2418 , ValueFlow ::@expr8229 less {@expr1073750054 } ) ) {
2058: continue ; }
2059: if (@expr1073750055 x@var2418 .@expr8149 bound@var2419 ==@expr8233 ValueFlow ::@expr8151 Value ::@expr8152 Bound ::@expr8236 Upper &&@expr1073750061 !@expr1073750062 x@var2418 .@expr1073750063 compareValue (@expr1073750064 *@expr8203 y@var2421 , ValueFlow ::@expr8229 less {@expr1073750067 } ) ) {
2060: continue ; }
2061: adjValues@var2420 .@expr1073750068 push_back (@expr1073750069 y@var2421 ) ;
2062: }
2063: if (@expr1073750070 adjValues@var2420 .@expr1073750071 empty (@expr1073750072 ) ) {
2064: x@var2418 ++@expr1073750073 ;
2065: continue ;
2066: }
2067: std ::@expr1073750074 sort (@expr1073750075 adjValues@var2420 .@expr8252 begin (@expr8253 ) , adjValues@var2420 .@expr8254 end (@expr8255 ) , [@expr1073750080 &@expr1073750081 values@var2417 ] (@expr1073750082 std ::@expr8156 list < ValueFlow ::@expr8156 Value > ::@expr8156 iterator xx@var2429 , std ::@expr8156 list < ValueFlow ::@expr8156 Value > ::@expr8156 iterator yy@var2430 ) {
2068: (@expr1073750089 void ) values@var2417 ;
2069: assert (@expr1073750090 xx@var2429 !=@expr1073750091 values@var2417 .@expr8142 end (@expr8143 ) &&@expr1073750094 yy@var2430 !=@expr1073750095 values@var2417 .@expr8142 end (@expr8143 ) ) ;
2070: return xx@var2429 .@expr1073750098 compareValue (@expr1073750099 *@expr1073750100 yy@var2430 , ValueFlow ::@expr8229 less {@expr1073750102 } ) ;
2071: } ) ;
2072: if (@expr1073750103 x@var2418 .@expr8149 bound@var2419 ==@expr8220 ValueFlow ::@expr8151 Value ::@expr8152 Bound ::@expr8223 Lower ) {
2073: x@var2418 =@expr1073750109 removeAdjacentValues (@expr1073750110 values@var2417 , x@var2418 , adjValues@var2420 .@expr1073750111 rbegin (@expr1073750112 ) , adjValues@var2420 .@expr1073750113 rend (@expr1073750114 ) ) ; }
2074: else { if (@expr1073750115 x@var2418 .@expr8149 bound@var2419 ==@expr8233 ValueFlow ::@expr8151 Value ::@expr8152 Bound ::@expr8236 Upper ) {
2075: x@var2418 =@expr1073750121 removeAdjacentValues (@expr1073750122 values@var2417 , x@var2418 , adjValues@var2420 .@expr8252 begin (@expr8253 ) , adjValues@var2420 .@expr8254 end (@expr8255 ) ) ; } }
2076: }
2077: }
2078:
2079: static void removeOverlaps ( std :: list < ValueFlow :: Value > & values@var2431 )
2080: {
2081: for (@expr1073750127 ValueFlow ::@expr8304 Value &@expr8305 x@var2432 :@expr1073750130 values@var2431 ) {
2082: if (@expr1073750131 x@var2432 .@expr1073750132 isNonValue (@expr1073750133 ) ) {
2083: continue ; }
2084: values@var2431 .@expr1073750134 remove_if (@expr1073750135 [@expr1073750136 &@expr8305 ] (@expr1073750138 ValueFlow ::@expr8304 Value &@expr8305 y@var2433 ) {
2085: if (@expr1073750141 y@var2433 .@expr1073750142 isNonValue (@expr1073750143 ) ) {
2086: return false ; }
2087: if (@expr1073750144 &@expr1073750145 x@var2432 ==@expr1073750146 &@expr1073750147 y@var2433 ) {
2088: return false ; }
2089: if (@expr1073750148 x@var2432 .@expr1073750149 valueType@var2434 !=@expr1073750150 y@var2433 .@expr1073750151 valueType@var2435 ) {
2090: return false ; }
2091: if (@expr1073750152 x@var2432 .@expr1073750153 valueKind@var2436 !=@expr1073750154 y@var2433 .@expr1073750155 valueKind@var2437 ) {
2092: return false ; }
2093:
2094:
2095: if (@expr1073750156 !@expr1073750157 x@var2432 .@expr1073750158 equalValue (@expr1073750159 y@var2433 ) ) {
2096: return false ; }
2097: if (@expr1073750160 x@var2432 .@expr1073750161 bound@var2438 !=@expr1073750162 y@var2433 .@expr1073750163 bound@var2439 ) {
2098: return false ; }
2099: return true ;
2100: } ) ;
2101: }
2102: mergeAdjacent (@expr1073750164 values@var2431 ) ;
2103: }
2104:
2105:
2106:
2107: static void removeContradictions ( std :: list < ValueFlow :: Value > & values@var2440 )
2108: {
2109: removeOverlaps (@expr8341 values@var2440 ) ;
2110: for (@expr1073750166 int i@var2441 =@expr1073750167 0 ; i@var2441 <@expr1073750168 4 ; i@var2441 ++@expr1073750169 ) {
2111: if (@expr1073750170 !@expr1073750171 removeContradiction (@expr1073750172 values@var2440 ) ) {
2112: return ; }
2113: removeOverlaps (@expr8341 values@var2440 ) ;
2114: }
2115: }
2116:
2117: static bool sameValueType ( const ValueFlow :: Value & x@var2442 , const ValueFlow :: Value & y@var2443 )
2118: {
2119: if (@expr1073750174 x@var2442 .@expr1073750175 valueType@var2444 !=@expr1073750176 y@var2443 .@expr1073750177 valueType@var2445 ) {
2120: return false ; }
2121:
2122: if (@expr1073750178 x@var2442 .@expr1073750179 isSymbolicValue (@expr1073750180 ) ) {
2123: return x@var2442 .@expr8357 tokvalue@var2446 .@expr8358 exprId (@expr8359 ) ==@expr1073750184 0 ||@expr1073750185 x@var2442 .@expr8357 tokvalue@var2446 .@expr8358 exprId (@expr8359 ) ==@expr1073750189 y@var2443 .@expr1073750190 tokvalue@var2447 .@expr1073750191 exprId (@expr1073750192 ) ; }
2124: return true ;
2125: }
2126:
2127: bool Token :: addValue ( const ValueFlow :: Value & value@var2448 )
2128: {
2129: if (@expr1073750193 value@var2448 .@expr8370 isKnown (@expr8371 ) &&@expr1073750196 mImpl@var661 .@expr8373 mValues@var2623 ) {
2130:
2131: mImpl@var661 .@expr8373 mValues@var2623 .@expr1073750199 remove_if (@expr1073750200 [@expr1073750201 &@expr8378 ] (@expr1073750203 const ValueFlow ::@expr8380 Value &@expr8378 x@var2449 ) {
2132: return sameValueType (@expr1073750206 x@var2449 , value@var2448 ) ;
2133: } ) ;
2134: }
2135:
2136:
2137: if (@expr1073750207 !@expr1073750208 value@var2448 .@expr8370 isKnown (@expr8371 ) &&@expr1073750211 mImpl@var661 .@expr8373 mValues@var2623 &&@expr1073750213
2138: std ::@expr1073750214 any_of (@expr1073750215 mImpl@var661 .@expr8373 mValues@var2623 .@expr8393 begin (@expr8394 ) , mImpl@var661 .@expr8373 mValues@var2623 .@expr8396 end (@expr8397 ) , [@expr1073750222 &@expr8378 ] (@expr1073750224 const ValueFlow ::@expr8380 Value &@expr8378 x@var2450 ) {
2139: return x@var2450 .@expr1073750227 isKnown (@expr1073750228 ) &&@expr1073750229 sameValueType (@expr1073750230 x@var2450 , value@var2448 ) &&@expr1073750231 !@expr1073750232 x@var2450 .@expr1073750233 equalValue (@expr1073750234 value@var2448 ) ;
2140: } ) ) {
2141: return false ; }
2142:
|
2147:
2148: if (@expr1073750235 mImpl@var661 .@expr8373 mValues@var2623 ) {
2149:
2150:
2151: if (@expr1073750237 mImpl@var661 .@expr8373 mValues@var2623 .@expr1073750239 size (@expr1073750240 ) >=@expr1073750241 10U ) {
2152: return false ; }
2153:
2154:
2155: std ::@expr8418 list < ValueFlow ::@expr8380 Value > ::@expr1073750244 iterator it@var2451 ;
2156: for (@expr1073750245 it@var2451 =@expr1073750246 mImpl@var661 .@expr8373 mValues@var2623 .@expr8393 begin (@expr8394 ) ; it@var2451 !=@expr1073750250 mImpl@var661 .@expr8373 mValues@var2623 .@expr8396 end (@expr8397 ) ; ++@expr1073750254 it@var2451 ) {
2157:
2158: if (@expr1073750255 it@var2451 .@expr1073750256 valueType@var2452 !=@expr1073750257 value@var2448 .@expr1073750258 valueType@var2453 ) {
2159: continue ; }
2160:
2161: if (@expr1073750259 it@var2451 .@expr1073750260 isImpossible (@expr1073750261 ) !=@expr1073750262 value@var2448 .@expr8439 isImpossible (@expr8440 ) ) {
2162: continue ; }
2163:
2164:
2165: if (@expr1073750265 !@expr1073750266 it@var2451 .@expr1073750267 equalValue (@expr1073750268 value@var2448 ) ) {
2166: continue ; }
2167:
2168: if (@expr1073750269 (@expr1073750270 value@var2448 .@expr1073750271 isTokValue (@expr1073750272 ) ||@expr1073750273 value@var2448 .@expr1073750274 isLifetimeValue (@expr1073750275 ) ) &&@expr1073750276 (@expr1073750277 it@var2451 .@expr8454 tokvalue@var2454 !=@expr1073750279 value@var2448 .@expr8456 tokvalue@var2455 ) &&@expr1073750281 (@expr1073750282 it@var2451 .@expr8454 tokvalue@var2454 .@expr1073750284 str (@expr1073750285 ) !=@expr1073750286 value@var2448 .@expr8456 tokvalue@var2455 .@expr1073750288 str (@expr1073750289 ) ) ) {
2169: continue ; }
2170:
2171:
2172: if (@expr1073750290 it@var2451 .@expr1073750291 isInconclusive (@expr1073750292 ) &&@expr1073750293 !@expr1073750294 value@var2448 .@expr1073750295 isInconclusive (@expr1073750296 ) &&@expr1073750297 !@expr1073750298 value@var2448 .@expr8439 isImpossible (@expr8440 ) ) {
2173: *@expr1073750301 it@var2451 =@expr1073750302 value@var2448 ;
2174: if (@expr1073750303 it@var2451 .@expr8480 varId@var2456 ==@expr1073750305 0 ) {
2175: it@var2451 .@expr8480 varId@var2456 =@expr1073750307 mImpl@var661 .@expr8484 mVarId@var2598 ; }
2176: break ;
2177: }
2178:
2179:
2180: return false ;
2181: }
2182:
2183:
2184: if (@expr1073750309 it@var2451 ==@expr1073750310 mImpl@var661 .@expr8373 mValues@var2623 .@expr8396 end (@expr8397 ) ) {
2185: ValueFlow ::@expr1073750314 Value v@var2457 (@expr1073750315 value@var2448 ) ;
2186: if (@expr1073750316 v@var2457 .@expr8493 varId@var2458 ==@expr1073750318 0 ) {
2187: v@var2457 .@expr8493 varId@var2458 =@expr1073750320 mImpl@var661 .@expr8484 mVarId@var2598 ; }
2188: if (@expr1073750322 v@var2457 .@expr1073750323 isKnown (@expr1073750324 ) &&@expr1073750325 v@var2457 .@expr1073750326 isIntValue (@expr1073750327 ) ) {
2189: mImpl@var661 .@expr8373 mValues@var2623 .@expr1073750329 push_front (@expr1073750330 v@var2457 ) ; }
2190: else {
2191: mImpl@var661 .@expr8373 mValues@var2623 .@expr1073750332 push_back (@expr1073750333 v@var2457 ) ; }
2192: }
2193: } else {
2194: ValueFlow ::@expr1073750334 Value v@var2459 (@expr1073750335 value@var2448 ) ;
2195: if (@expr1073750336 v@var2459 .@expr8513 varId@var2460 ==@expr1073750338 0 ) {
2196: v@var2459 .@expr8513 varId@var2460 =@expr1073750340 mImpl@var661 .@expr8484 mVarId@var2598 ; }
2197: mImpl@var661 .@expr8373 mValues@var2623 =@expr1073750343 new std ::@expr8418 list < ValueFlow ::@expr8380 Value > (@expr1073750346 1 , v@var2459 ) ;
2198: }
2199:
2200: removeContradictions (@expr1073750347 *@expr1073750348 mImpl@var661 .@expr8373 mValues@var2623 ) ;
2201:
2202: return true ;
2203: }
2204:
2205: void Token :: assignProgressValues ( Token * tok@var2461 )
2206: {
2207: int total_count@var2462 ; total_count@var2462 =@expr1073750350 0 ;
2208: for (@expr1073750351 Token *@expr8528 tok2@var2463 =@expr1073750353 tok@var2461 ; tok2@var2463 ; tok2@var2463 =@expr1073750354 tok2@var2463 .@expr1073750355 next (@expr1073750356 ) ) {
2209: ++@expr1073750357 total_count@var2462 ; }
2210: int count@var2464 ; count@var2464 =@expr1073750358 0 ;
2211: for (@expr1073750359 Token *@expr8528 tok2@var2465 =@expr1073750361 tok@var2461 ; tok2@var2465 ; tok2@var2465 =@expr1073750362 tok2@var2465 .@expr1073750363 next (@expr1073750364 ) ) {
2212: tok2@var2465 .@expr1073750365 mImpl@var2466 .@expr1073750366 mProgressValue@var2467 =@expr1073750367 count@var2464 ++@expr1073750368 *@expr1073750369 100 /@expr1073750370 total_count@var2462 ; }
2213: }
2214:
2215: void Token :: assignIndexes ( )
2216: {
2217: int index@var2468 ; index@var2468 =@expr1073750371 (@expr1073750372 mPrevious@var657 ?@expr1073750373 mPrevious@var657 .@expr1073750374 mImpl@var2624 .@expr1073750375 mIndex@var2625 :@expr1073750376 0 ) +@expr1073750377 1 ;
2218: for (@expr1073750378 Token *@expr1073750379 tok@var2469 =@expr1073750380 this@expr1073750381 ; tok@var2469 ; tok@var2469 =@expr1073750382 tok@var2469 .@expr1073750383 next (@expr1073750384 ) ) {
2219: tok@var2469 .@expr1073750385 mImpl@var2470 .@expr1073750386 mIndex@var2471 =@expr1073750387 index@var2468 ++@expr1073750388 ; }
2220: }
2221:
2222: void Token :: setValueType ( ValueType * vt@var2472 )
2223: {
2224: if (@expr1073750389 vt@var2472 !=@expr1073750390 mImpl@var661 .@expr8567 mValueType@var2622 ) {
2225: delete mImpl@var661 .@expr8567 mValueType@var2622 ;
2226: mImpl@var661 .@expr8567 mValueType@var2622 =@expr1073750394 vt@var2472 ;
2227: }
2228: }
2229:
2230: void Token :: type ( const :: Type * t@var2473 )
2231: {
2232: mImpl@var661 .@expr8571 mType@var2626 =@expr1073750396 t@var2473 ;
2233: if (@expr1073750397 t@var2473 ) {
2234: tokType (@expr1073750398 eType ) ;
2235: isEnumType (@expr1073750399 mImpl@var661 .@expr8571 mType@var2626 .@expr1073750401 isEnumType (@expr1073750402 ) ) ;
2236: } else { if (@expr1073750403 mTokType@var659 ==@expr1073750404 eType ) {
2237: tokType (@expr1073750405 eName ) ; } }
2238: }
2239:
2240: const :: Type * Token :: typeOf ( const Token * tok@var2474 , const Token * * typeTok@var2475 )
2241: {
2242: if (@expr1073750406 !@expr1073750407 tok@var2474 ) {
2243: return nullptr ; }
2244: if (@expr1073750408 typeTok@var2475 !=@expr1073750409 nullptr ) {
2245: *@expr1073750410 typeTok@var2475 =@expr1073750411 tok@var2474 ; }
2246: const Token * lhsVarTok@var2476 {@expr1073750412 } ;
2247: if (@expr1073750413 Token ::@expr8590 simpleMatch (@expr1073750415 tok@var2474 , "return" ) ) {
2248: const Scope * scope@var2477 ; scope@var2477 =@expr1073750416 tok@var2474 .@expr1073750417 scope (@expr1073750418 ) ;
2249: if (@expr1073750419 !@expr1073750420 scope@var2477 ) {
2250: return nullptr ; }
2251: const Function * function@var2478 ; function@var2478 =@expr1073750421 scope@var2477 .@expr1073750422 function@var2479 ;
2252: if (@expr1073750423 !@expr1073750424 function@var2478 ) {
2253: return nullptr ; }
2254: return function@var2478 .@expr1073750425 retType@var2480 ;
2255: } else { if (@expr1073750426 Token ::@expr8603 Match (@expr1073750428 tok@var2474 , "%type%" ) ) {
2256: return tok@var2474 .@expr1073750429 type (@expr1073750430 ) ;
2257: } else { if (@expr1073750431 Token ::@expr8603 Match (@expr1073750433 tok@var2474 , "%var%" ) ) {
2258: const Variable * var@var2481 ; var@var2481 =@expr1073750434 tok@var2474 .@expr1073750435 variable (@expr1073750436 ) ;
2259: if (@expr1073750437 !@expr1073750438 var@var2481 ) {
2260: return nullptr ; }
2261: return var@var2481 .@expr1073750439 type (@expr1073750440 ) ;
2262: } else { if (@expr1073750441 Token ::@expr8603 Match (@expr1073750443 tok@var2474 , "%name%" ) ) {
2263: const Function * function@var2482 ; function@var2482 =@expr1073750444 tok@var2474 .@expr1073750445 function (@expr1073750446 ) ;
2264: if (@expr1073750447 !@expr1073750448 function@var2482 ) {
2265: return nullptr ; }
2266: return function@var2482 .@expr1073750449 retType@var2483 ;
2267: } else { if (@expr1073750450 Token ::@expr8603 Match (@expr1073750452 tok@var2474 .@expr8629 previous (@expr8630 ) , "%type%|= (|{" ) ) {
2268: return typeOf (@expr1073750455 tok@var2474 .@expr8629 previous (@expr8630 ) , typeTok@var2475 ) ;
2269: } else { if (@expr1073750458 Token ::@expr8590 simpleMatch (@expr1073750460 tok@var2474 , "=" ) &&@expr1073750461 (@expr1073750462 lhsVarTok@var2476 =@expr1073750463 getLHSVariableToken (@expr1073750464 tok@var2474 ) ) !=@expr1073750465 tok@var2474 .@expr1073750466 next (@expr1073750467 ) ) {
2270: return Token ::@expr8644 typeOf (@expr1073750469 lhsVarTok@var2476 , typeTok@var2475 ) ;
2271: } else { if (@expr1073750470 Token ::@expr8590 simpleMatch (@expr1073750472 tok@var2474 , "." ) ) {
2272: return Token ::@expr8644 typeOf (@expr1073750474 tok@var2474 .@expr1073750475 astOperand2 (@expr1073750476 ) , typeTok@var2475 ) ;
2273: } else { if (@expr1073750477 Token ::@expr8590 simpleMatch (@expr1073750479 tok@var2474 , "[" ) ) {
2274: return Token ::@expr8644 typeOf (@expr1073750481 tok@var2474 .@expr1073750482 astOperand1 (@expr1073750483 ) , typeTok@var2475 ) ;
2275: } else { if (@expr1073750484 Token ::@expr8590 simpleMatch (@expr1073750486 tok@var2474 , "{" ) ) {
2276: int argnr@var2484 ;
2277: const Token * ftok@var2485 ; ftok@var2485 =@expr1073750487 getTokenArgumentFunction (@expr1073750488 tok@var2474 , argnr@var2484 ) ;
2278: if (@expr1073750489 argnr@var2484 <@expr1073750490 0 ) {
2279: return nullptr ; }
2280: if (@expr1073750491 !@expr1073750492 ftok@var2485 ) {
2281: return nullptr ; }
2282: if (@expr1073750493 ftok@var2485 ==@expr1073750494 tok@var2474 ) {
2283: return nullptr ; }
2284: std ::@expr1073750495 vector < const Variable *@expr8672 > vars@var2486 ; vars@var2486 =@expr1073750497 getArgumentVars (@expr1073750498 ftok@var2485 , argnr@var2484 ) ;
2285: if (@expr1073750499 vars@var2486 .@expr1073750500 empty (@expr1073750501 ) ) {
2286: return nullptr ; }
2287: if (@expr1073750502 std ::@expr1073750503 all_of (@expr1073750504
2288: vars@var2486 .@expr1073750505 begin (@expr1073750506 ) , vars@var2486 .@expr1073750507 end (@expr1073750508 ) , [@expr1073750509 &@expr1073750510 ] (@expr1073750511 const Variable *@expr8672 var@var2487 ) {
2289: return var@var2487 .@expr1073750513 type (@expr1073750514 ) ==@expr1073750515 vars@var2486 .@expr8692 front (@expr8693 ) .@expr8694 type (@expr8695 ) ;
2290: } ) ) {
2291: return vars@var2486 .@expr8692 front (@expr8693 ) .@expr8694 type (@expr8695 ) ; }
2292: } } } } } } } } }
2293:
2294: return nullptr ;
2295: }
2296:
2297: std :: pair < const Token * , const Token * > Token :: typeDecl ( const Token * tok@var2488 )
2298: {
2299: if (@expr1073750524 !@expr1073750525 tok@var2488 ) {
2300: return { } ; }
2301: if (@expr1073750526 Token ::@expr8703 simpleMatch (@expr1073750528 tok@var2488 , "return" ) ) {
2302: const Scope * scope@var2489 ; scope@var2489 =@expr1073750529 tok@var2488 .@expr1073750530 scope (@expr1073750531 ) ;
2303: if (@expr1073750532 !@expr1073750533 scope@var2489 ) {
2304: return { } ; }
2305: const Function * function@var2490 ; function@var2490 =@expr1073750534 scope@var2489 .@expr1073750535 function@var2491 ;
2306: if (@expr1073750536 !@expr1073750537 function@var2490 ) {
2307: return { } ; }
2308: return {@expr1073750538 function@var2490 .@expr1073750539 retDef@var2492 , function@var2490 .@expr1073750540 returnDefEnd (@expr1073750541 ) } ;
2309: } else { if (@expr1073750542 Token ::@expr8719 Match (@expr1073750544 tok@var2488 , "%type%" ) ) {
2310: return {@expr1073750545 tok@var2488 , tok@var2488 .@expr1073750546 next (@expr1073750547 ) } ;
2311: } else { if (@expr1073750548 Token ::@expr8719 Match (@expr1073750550 tok@var2488 , "%var%" ) ) {
2312: const Variable * var@var2493 ; var@var2493 =@expr1073750551 tok@var2488 .@expr1073750552 variable (@expr1073750553 ) ;
2313: if (@expr1073750554 !@expr1073750555 var@var2493 ) {
2314: return { } ; }
2315: if (@expr1073750556 !@expr1073750557 var@var2493 .@expr8734 typeStartToken (@expr8735 ) ||@expr1073750560 !@expr1073750561 var@var2493 .@expr8738 typeEndToken (@expr8739 ) ) {
2316: return { } ; }
2317: if (@expr1073750564 Token ::@expr8703 simpleMatch (@expr1073750566 var@var2493 .@expr8734 typeStartToken (@expr8735 ) , "auto" ) ) {
2318: const Token * tok2@var2494 ; tok2@var2494 =@expr1073750569 var@var2493 .@expr1073750570 declEndToken (@expr1073750571 ) ;
2319: if (@expr1073750572 Token ::@expr8719 Match (@expr1073750574 tok2@var2494 , "; %varid% =" , var@var2493 .@expr1073750575 declarationId (@expr1073750576 ) ) ) {
2320: tok2@var2494 =@expr1073750577 tok2@var2494 .@expr1073750578 tokAt (@expr1073750579 2 ) ; }
2321: if (@expr1073750580 Token ::@expr8703 simpleMatch (@expr1073750582 tok2@var2494 , "=" ) &&@expr1073750583 Token ::@expr8719 Match (@expr1073750585 tok2@var2494 .@expr8762 astOperand2 (@expr8763 ) , "!!=" ) &&@expr1073750588 tok@var2488 !=@expr1073750589 tok2@var2494 .@expr8762 astOperand2 (@expr8763 ) ) {
2322: std ::@expr1073750592 pair < const Token *@expr8769 , const Token *@expr8769 > r@var2495 ; r@var2495 =@expr1073750595 typeDecl (@expr1073750596 tok2@var2494 .@expr8762 astOperand2 (@expr8763 ) ) ;
2323: if (@expr1073750599 r@var2495 .@expr1073750600 first@var2496 ) {
2324: return r@var2495 ; }
2325: }
2326: }
2327: return {@expr1073750601 var@var2493 .@expr8734 typeStartToken (@expr8735 ) , var@var2493 .@expr8738 typeEndToken (@expr8739 ) .@expr1073750606 next (@expr1073750607 ) } ;
2328: } else { if (@expr1073750608 Token ::@expr8719 Match (@expr1073750610 tok@var2488 .@expr8787 previous (@expr8788 ) , "%name% (" ) ) {
2329: const Function * function@var2497 ; function@var2497 =@expr1073750613 tok@var2488 .@expr8787 previous (@expr8788 ) .@expr1073750616 function (@expr1073750617 ) ;
2330: if (@expr1073750618 !@expr1073750619 function@var2497 ) {
2331: return { } ; }
2332: return {@expr1073750620 function@var2497 .@expr1073750621 retDef@var2498 , function@var2497 .@expr1073750622 returnDefEnd (@expr1073750623 ) } ;
2333: } else { if (@expr1073750624 Token ::@expr8703 simpleMatch (@expr1073750626 tok@var2488 , "=" ) ) {
2334: return Token ::@expr8803 typeDecl (@expr1073750628 tok@var2488 .@expr1073750629 astOperand1 (@expr1073750630 ) ) ;
2335: } else { if (@expr1073750631 Token ::@expr8703 simpleMatch (@expr1073750633 tok@var2488 , "." ) ) {
2336: return Token ::@expr8803 typeDecl (@expr1073750635 tok@var2488 .@expr1073750636 astOperand2 (@expr1073750637 ) ) ;
2337: } else {
2338: const ::@expr1073750638 Type * t@var2499 ; t@var2499 =@expr1073750639 typeOf (@expr1073750640 tok@var2488 ) ;
2339: if (@expr1073750641 !@expr1073750642 t@var2499 ||@expr1073750643 !@expr1073750644 t@var2499 .@expr8821 classDef@var2500 ) {
2340: return { } ; }
2341: return {@expr1073750646 t@var2499 .@expr8821 classDef@var2500 .@expr1073750648 next (@expr1073750649 ) , t@var2499 .@expr8821 classDef@var2500 .@expr1073750651 tokAt (@expr1073750652 2 ) } ;
2342: } } } } } }
2343: }
2344: std :: string Token :: typeStr ( const Token * tok@var2501 )
2345: {
2346: if (@expr1073750653 tok@var2501 .@expr8830 valueType (@expr8831 ) ) {
2347: const ValueType * vt@var2502 ; vt@var2502 =@expr1073750656 tok@var2501 .@expr8830 valueType (@expr8831 ) ;
2348: std ::@expr1073750659 string ret@var2503 ; ret@var2503 =@expr1073750660 vt@var2502 .@expr1073750661 str (@expr1073750662 ) ;
2349: if (@expr1073750663 !@expr1073750664 ret@var2503 .@expr1073750665 empty (@expr1073750666 ) ) {
2350: return ret@var2503 ; }
2351: }
2352: std ::@expr1073750667 pair < const Token *@expr8844 , const Token *@expr8844 > r@var2504 ; r@var2504 =@expr1073750670 Token ::@expr1073750671 typeDecl (@expr1073750672 tok@var2501 ) ;
2353: if (@expr1073750673 !@expr1073750674 r@var2504 .@expr8851 first@var2505 ||@expr1073750676 !@expr1073750677 r@var2504 .@expr8854 second@var2506 ) {
2354: return "" ; }
2355: return r@var2504 .@expr8851 first@var2505 .@expr1073750680 stringifyList (@expr1073750681 r@var2504 .@expr8854 second@var2506 , false ) ;
2356: }
2357:
2358: void Token :: scopeInfo ( std :: shared_ptr < ScopeInfo2 > newScopeInfo@var2507 )
2359: {
2360: mImpl@var661 .@expr1073750683 mScopeInfo@var2615 =@expr1073750684 newScopeInfo@var2507 ;
2361: }
2362: std :: shared_ptr < ScopeInfo2 > Token :: scopeInfo ( ) const
2363: {
2364: return mImpl@var661 .@expr1073750685 mScopeInfo@var2615 ;
2365: }
2366:
2367: bool Token :: hasKnownIntValue ( ) const
2368: {
2369: if (@expr1073750686 !@expr1073750687 mImpl@var661 .@expr8864 mValues@var2623 ) {
2370: return false ; }
2371: return std ::@expr1073750689 any_of (@expr1073750690 mImpl@var661 .@expr8864 mValues@var2623 .@expr1073750692 begin (@expr1073750693 ) , mImpl@var661 .@expr8864 mValues@var2623 .@expr1073750695 end (@expr1073750696 ) , [@expr1073750697 ] (@expr1073750698 const ValueFlow ::@expr1073750699 Value &@expr1073750700 value@var2508 ) {
2372: return value@var2508 .@expr1073750701 isKnown (@expr1073750702 ) &&@expr1073750703 value@var2508 .@expr1073750704 isIntValue (@expr1073750705 ) ;
2373: } ) ;
2374: }
2375:
2376: bool Token :: hasKnownValue ( ) const
2377: {
2378: return mImpl@var661 .@expr8882 mValues@var2623 &&@expr1073750707 std ::@expr1073750708 any_of (@expr1073750709 mImpl@var661 .@expr8882 mValues@var2623 .@expr1073750711 begin (@expr1073750712 ) , mImpl@var661 .@expr8882 mValues@var2623 .@expr1073750714 end (@expr1073750715 ) , std ::@expr1073750716 mem_fn (@expr1073750717 &@expr1073750718 ValueFlow ::@expr1073750719 Value ::@expr1073750720 isKnown ) ) ;
2379: }
2380:
2381: bool Token :: hasKnownValue ( ValueFlow :: Value :: ValueType t@var2509 ) const
2382: {
2383: return mImpl@var661 .@expr8897 mValues@var2623 &&@expr1073750722
2384: std ::@expr1073750723 any_of (@expr1073750724 mImpl@var661 .@expr8897 mValues@var2623 .@expr1073750726 begin (@expr1073750727 ) , mImpl@var661 .@expr8897 mValues@var2623 .@expr1073750729 end (@expr1073750730 ) , [@expr1073750731 &@expr8908 ] (@expr1073750733 const ValueFlow ::@expr1073750734 Value &@expr8908 value@var2510 ) {
2385: return value@var2510 .@expr1073750736 isKnown (@expr1073750737 ) &&@expr1073750738 value@var2510 .@expr1073750739 valueType@var2511 ==@expr1073750740 t@var2509 ;
2386: } ) ;
2387: }
2388:
2389: bool Token :: hasKnownSymbolicValue ( const Token * tok@var2512 ) const
2390: {
2391: if (@expr1073750741 tok@var2512 .@expr8918 exprId (@expr8919 ) ==@expr1073750744 0 ) {
2392: return false ; }
2393: return mImpl@var661 .@expr8921 mValues@var2623 &&@expr1073750746
2394: std ::@expr1073750747 any_of (@expr1073750748 mImpl@var661 .@expr8921 mValues@var2623 .@expr1073750750 begin (@expr1073750751 ) , mImpl@var661 .@expr8921 mValues@var2623 .@expr1073750753 end (@expr1073750754 ) , [@expr1073750755 &@expr8932 ] (@expr1073750757 const ValueFlow ::@expr1073750758 Value &@expr8932 value@var2513 ) {
2395: return value@var2513 .@expr1073750760 isKnown (@expr1073750761 ) &&@expr1073750762 value@var2513 .@expr1073750763 isSymbolicValue (@expr1073750764 ) &&@expr1073750765 value@var2513 .@expr8942 tokvalue@var2514 &&@expr1073750767
2396: value@var2513 .@expr8942 tokvalue@var2514 .@expr1073750769 exprId (@expr1073750770 ) ==@expr1073750771 tok@var2512 .@expr8918 exprId (@expr8919 ) ;
2397: } ) ;
2398: }
2399:
2400: const ValueFlow :: Value * Token :: getKnownValue ( ValueFlow :: Value :: ValueType t@var2515 ) const
2401: {
2402: if (@expr1073750774 !@expr1073750775 mImpl@var661 .@expr8952 mValues@var2623 ) {
2403: return nullptr ; }
2404: auto it@var2516 ; it@var2516 =@expr1073750777 std ::@expr1073750778 find_if (@expr1073750779 mImpl@var661 .@expr8952 mValues@var2623 .@expr1073750781 begin (@expr1073750782 ) , mImpl@var661 .@expr8952 mValues@var2623 .@expr8960 end (@expr8961 ) , [@expr1073750786 &@expr8963 ] (@expr1073750788 const ValueFlow ::@expr1073750789 Value &@expr8963 value@var2517 ) {
2405: return value@var2517 .@expr1073750791 isKnown (@expr1073750792 ) &&@expr1073750793 value@var2517 .@expr1073750794 valueType@var2518 ==@expr1073750795 t@var2515 ;
2406: } ) ;
2407: return it@var2516 ==@expr1073750796 mImpl@var661 .@expr8952 mValues@var2623 .@expr8960 end (@expr8961 ) ?@expr1073750800 nullptr :@expr1073750801 &@expr1073750802 *@expr1073750803 it@var2516 ;
2408: }
2409:
2410: const ValueFlow :: Value * Token :: getValue ( const long long val@var2519 ) const
2411: {
2412: if (@expr1073750804 !@expr1073750805 mImpl@var661 .@expr8982 mValues@var2623 ) {
2413: return nullptr ; }
2414: const auto it@var2520 =@expr1073750807 std ::@expr1073750808 find_if (@expr1073750809 mImpl@var661 .@expr8982 mValues@var2623 .@expr1073750811 begin (@expr1073750812 ) , mImpl@var661 .@expr8982 mValues@var2623 .@expr8990 end (@expr8991 ) , [@expr1073750816 =@expr1073750817 ] (@expr1073750818 const ValueFlow ::@expr1073750819 Value &@expr1073750820 value@var2521 ) {
2415: return value@var2521 .@expr1073750821 isIntValue (@expr1073750822 ) &&@expr1073750823 !@expr1073750824 value@var2521 .@expr1073750825 isImpossible (@expr1073750826 ) &&@expr1073750827 value@var2521 .@expr1073750828 intvalue@var2522 ==@expr1073750829 val@var2519 ;
2416: } ) ;
2417: return it@var2520 ==@expr1073750830 mImpl@var661 .@expr8982 mValues@var2623 .@expr8990 end (@expr8991 ) ?@expr1073750834 nullptr :@expr1073750835 &@expr1073750836 *@expr1073750837 it@var2520 ;
2418: }
2419:
2420: const ValueFlow :: Value * Token :: getMaxValue ( bool condition@var2523 , long long path@var2524 ) const
2421: {
2422: if (@expr1073750838 !@expr1073750839 mImpl@var661 .@expr9016 mValues@var2623 ) {
2423: return nullptr ; }
2424: const ValueFlow ::@expr1073750841 Value * ret@var2525 ; ret@var2525 =@expr1073750842 nullptr ;
2425: for (@expr1073750843 const ValueFlow ::@expr1073750844 Value &@expr1073750845 value@var2526 :@expr1073750846 *@expr1073750847 mImpl@var661 .@expr9016 mValues@var2623 ) {
2426: if (@expr1073750849 !@expr1073750850 value@var2526 .@expr1073750851 isIntValue (@expr1073750852 ) ) {
2427: continue ; }
2428: if (@expr1073750853 value@var2526 .@expr1073750854 isImpossible (@expr1073750855 ) ) {
2429: continue ; }
2430: if (@expr1073750856 path@var2524 >@expr1073750857 -0 &&@expr1073750858 value@var2526 .@expr9035 path@var2527 !=@expr1073750860 0 &&@expr1073750861 value@var2526 .@expr9035 path@var2527 !=@expr1073750863 path@var2524 ) {
2431: continue ; }
2432: if (@expr1073750864 (@expr1073750865 !@expr1073750866 ret@var2525 ||@expr1073750867 value@var2526 .@expr1073750868 intvalue@var2528 >@expr1073750869 ret@var2525 .@expr1073750870 intvalue@var2529 ) &&@expr1073750871
2433: (@expr1073750872 (@expr1073750873 value@var2526 .@expr1073750874 condition@var2530 !=@expr1073750875 nullptr ) ==@expr1073750876 condition@var2523 ) ) {
2434: ret@var2525 =@expr1073750877 &@expr1073750878 value@var2526 ; }
2435: }
2436: return ret@var2525 ;
2437: }
2438:
2439: const ValueFlow :: Value * Token :: getMovedValue ( ) const
2440: {
2441: if (@expr1073750880 !@expr1073750881 mImpl@var661 .@expr9058 mValues@var2623 ) {
2442: return nullptr ; }
2443: const auto it@var2531 =@expr1073750883 std ::@expr1073750884 find_if (@expr1073750885 mImpl@var661 .@expr9058 mValues@var2623 .@expr1073750887 begin (@expr1073750888 ) , mImpl@var661 .@expr9058 mValues@var2623 .@expr9066 end (@expr9067 ) , [@expr1073750892 ] (@expr1073750893 const ValueFlow ::@expr1073750894 Value &@expr1073750895 value@var2532 ) {
2444: return value@var2532 .@expr1073750896 isMovedValue (@expr1073750897 ) &&@expr1073750898 !@expr1073750899 value@var2532 .@expr1073750900 isImpossible (@expr1073750901 ) &&@expr1073750902
2445: value@var2532 .@expr1073750903 moveKind@var2533 !=@expr1073750904 ValueFlow ::@expr1073750905 Value ::@expr1073750906 MoveKind ::@expr1073750907 NonMovedVariable@expr1073750879 ;
2446: } ) ;
2447: return it@var2531 ==@expr1073750908 mImpl@var661 .@expr9058 mValues@var2623 .@expr9066 end (@expr9067 ) ?@expr1073750912 nullptr :@expr1073750913 &@expr1073750914 *@expr1073750915 it@var2531 ;
2448: }
2449:
2450:
2451: const ValueFlow :: Value * Token :: getContainerSizeValue ( const long long val@var2534 ) const
2452: {
2453: if (@expr1073750916 !@expr1073750917 mImpl@var661 .@expr9094 mValues@var2623 ) {
2454: return nullptr ; }
2455: const auto it@var2535 =@expr1073750919 std ::@expr1073750920 find_if (@expr1073750921 mImpl@var661 .@expr9094 mValues@var2623 .@expr1073750923 begin (@expr1073750924 ) , mImpl@var661 .@expr9094 mValues@var2623 .@expr9102 end (@expr9103 ) , [@expr1073750928 =@expr1073750929 ] (@expr1073750930 const ValueFlow ::@expr1073750931 Value &@expr1073750932 value@var2536 ) {
2456: return value@var2536 .@expr1073750933 isContainerSizeValue (@expr1073750934 ) &&@expr1073750935 !@expr1073750936 value@var2536 .@expr1073750937 isImpossible (@expr1073750938 ) &&@expr1073750939 value@var2536 .@expr1073750940 intvalue@var2537 ==@expr1073750941 val@var2534 ;
2457: } ) ;
2458: return it@var2535 ==@expr1073750942 mImpl@var661 .@expr9094 mValues@var2623 .@expr9102 end (@expr9103 ) ?@expr1073750946 nullptr :@expr1073750947 &@expr1073750948 *@expr1073750949 it@var2535 ;
2459: }
2460:
2461: TokenImpl :: ~ TokenImpl ( )
2462: {
2463: delete mOriginalName@var424 ;
2464: delete mValueType@var425 ;
2465: delete mValues@var426 ;
2466:
2467: if (@expr1073750950 mTemplateSimplifierPointers@var428 ) {
2468: for (@expr1073750951 auto *@expr1073750952 templateSimplifierPointer@var2538 :@expr1073750953 *@expr1073750954 mTemplateSimplifierPointers@var428 ) {
2469: templateSimplifierPointer@var2538 .@expr1073750955 token (@expr1073750956 nullptr ) ;
2470: } }
2471: delete mTemplateSimplifierPointers@var428 ;
2472:
2473: while (@expr1073750957 mCppcheckAttributes@var433 ) {
2474: struct CppcheckAttributes * c@var2539 ; c@var2539 =@expr1073750958 mCppcheckAttributes@var433 ;
2475: mCppcheckAttributes@var433 =@expr1073750959 mCppcheckAttributes@var433 .@expr1073750960 next@var2597 ;
2476: delete c@var2539 ;
2477: }
2478: }
2479:
2480: void TokenImpl :: setCppcheckAttribute ( TokenImpl :: CppcheckAttributes :: Type type@var2540 , long long value@var2541 )
2481: {
2482: struct CppcheckAttributes * attr@var2542 ; attr@var2542 =@expr1073750961 mCppcheckAttributes@var433 ;
2483: while (@expr1073750962 attr@var2542 &&@expr1073750963 attr@var2542 .@expr9140 type@var2543 !=@expr1073750965 type@var2540 ) {
2484: attr@var2542 =@expr1073750966 attr@var2542 .@expr9143 next@var2544 ; }
2485: if (@expr1073750968 attr@var2542 ) {
2486: attr@var2542 .@expr9145 value@var2545 =@expr1073750970 value@var2541 ; }
2487: else {
2488: attr@var2542 =@expr1073750971 new CppcheckAttributes ;
2489: attr@var2542 .@expr9140 type@var2543 =@expr1073750973 type@var2540 ;
2490: attr@var2542 .@expr9145 value@var2545 =@expr1073750975 value@var2541 ;
2491: attr@var2542 .@expr9143 next@var2544 =@expr1073750977 mCppcheckAttributes@var433 ;
2492: mCppcheckAttributes@var433 =@expr1073750978 attr@var2542 ;
2493: }
2494: }
2495:
2496: bool TokenImpl :: getCppcheckAttribute ( TokenImpl :: CppcheckAttributes :: Type type@var2546 , long long * value@var2547 ) const
2497: {
2498: struct CppcheckAttributes * attr@var2548 ; attr@var2548 =@expr1073750979 mCppcheckAttributes@var433 ;
2499: while (@expr1073750980 attr@var2548 &&@expr1073750981 attr@var2548 .@expr1073750982 type@var2549 !=@expr1073750983 type@var2546 ) {
2500: attr@var2548 =@expr1073750984 attr@var2548 .@expr1073750985 next@var2550 ; }
2501: if (@expr1073750986 attr@var2548 ) {
2502: *@expr1073750987 value@var2547 =@expr1073750988 attr@var2548 .@expr1073750989 value@var2551 ; }
2503: return attr@var2548 !=@expr1073750990 nullptr ;
2504: }
2505:
2506: Token * findTypeEnd ( Token * tok@var2552 )
2507: {
2508: while (@expr1073750991 Token ::@expr9168 Match (@expr1073750993 tok@var2552 , "%name%|.|::|*|&|&&|<|(|template|decltype|sizeof" ) ) {
2509: if (@expr1073750994 Token ::@expr9168 Match (@expr1073750996 tok@var2552 , "(|<" ) ) {
2510: tok@var2552 =@expr1073750997 tok@var2552 .@expr1073750998 link (@expr1073750999 ) ; }
2511: if (@expr1073751000 !@expr1073751001 tok@var2552 ) {
2512: return nullptr ; }
2513: tok@var2552 =@expr1073751002 tok@var2552 .@expr1073751003 next (@expr1073751004 ) ;
2514: }
2515: return tok@var2552 ;
2516: }
2517:
2518: const Token * findTypeEnd ( const Token * tok@var2553 ) {
2519: return findTypeEnd (@expr1073751005 const_cast < Token *@expr1073751006 > (@expr1073751007 tok@var2553 ) ) ;
2520: }
2521:
2522: Token * findLambdaEndScope ( Token * tok@var2554 )
2523: {
2524: if (@expr1073751008 !@expr1073751009 Token ::@expr9186 simpleMatch (@expr1073751011 tok@var2554 , "[" ) ) {
2525: return nullptr ; }
2526: tok@var2554 =@expr1073751012 tok@var2554 .@expr9189 link (@expr9190 ) ;
2527: if (@expr1073751015 !@expr1073751016 Token ::@expr9193 Match (@expr1073751018 tok@var2554 , "] (|{" ) ) {
2528: return nullptr ; }
2529: tok@var2554 =@expr1073751019 tok@var2554 .@expr9196 linkAt (@expr9197 1 ) ;
2530: if (@expr1073751022 Token ::@expr9186 simpleMatch (@expr1073751024 tok@var2554 , "}" ) ) {
2531: return tok@var2554 ; }
2532: if (@expr1073751025 Token ::@expr9186 simpleMatch (@expr1073751027 tok@var2554 , ") {" ) ) {
2533: return tok@var2554 .@expr9196 linkAt (@expr9197 1 ) ; }
2534: if (@expr1073751030 !@expr1073751031 Token ::@expr9186 simpleMatch (@expr1073751033 tok@var2554 , ")" ) ) {
2535: return nullptr ; }
2536: tok@var2554 =@expr1073751034 tok@var2554 .@expr9211 next (@expr9212 ) ;
2537: while (@expr1073751037 Token ::@expr9193 Match (@expr1073751039 tok@var2554 , "mutable|constexpr|constval|noexcept|." ) ) {
2538: if (@expr1073751040 Token ::@expr9186 simpleMatch (@expr1073751042 tok@var2554 , "noexcept (" ) ) {
2539: tok@var2554 =@expr1073751043 tok@var2554 .@expr9196 linkAt (@expr9197 1 ) ; }
2540: if (@expr1073751046 Token ::@expr9186 simpleMatch (@expr1073751048 tok@var2554 , "." ) ) {
2541: tok@var2554 =@expr1073751049 findTypeEnd (@expr1073751050 tok@var2554 ) ;
2542: break ;
2543: }
2544: tok@var2554 =@expr1073751051 tok@var2554 .@expr9211 next (@expr9212 ) ;
2545: }
2546: if (@expr1073751054 Token ::@expr9186 simpleMatch (@expr1073751056 tok@var2554 , "{" ) ) {
2547: return tok@var2554 .@expr9189 link (@expr9190 ) ; }
2548: return nullptr ;
2549: }
2550: const Token * findLambdaEndScope ( const Token * tok@var2555 ) {
2551: return findLambdaEndScope (@expr1073751059 const_cast < Token *@expr1073751060 > (@expr1073751061 tok@var2555 ) ) ;
2552: }

##file cppcheck-2.8/lib/tokenrange.h

1:
|
26:
27: class TokenRangeBase<Token,typenamestd::enable_if<std::is_convertible<Token*,constToken*>::value>::type> {
28: Token * mFront@var2556 ;
29: Token * mBack@var2557 ;
30:
31: public:
32: TokenRangeBase<Token,typenamestd::enable_if<std::is_convertible<Token*,constToken*>::value>::type> ( Token * front@var2558 , Token * back@var2559 ) : mFront@var2556 ( front@var2558 ) , mBack@var2557 ( back@var2559 ) { }
33:
34: struct TokenIterator {
35:
|
40:
41: Token * mt@var2560 ;
42: TokenIterator ( ) : mt@var2560 ( nullptr ) { }
43: explicit TokenIterator ( Token * t@var2561 ) : mt@var2560 ( t@var2561 ) { }
44: TokenIterator & operator++ ( ) {
45: mt@var2560 =@expr1073751062 mt@var2560 .@expr1073751063 next (@expr1073751064 ) ;
46: return *@expr1073751065 this@expr1073751066 ;
47: }
48: bool operator== ( const TokenIterator & b@var2562 ) const {
49: return mt@var2560 ==@expr1073751067 b@var2562 .@expr1073751068 mt@var2563 ;
50: }
51: bool operator!= ( const TokenIterator & b@var2564 ) const {
52: return mt@var2560 !=@expr1073751069 b@var2564 .@expr1073751070 mt@var2565 ;
53: }
54: Token * operator* ( ) const {
55: return mt@var2560 ;
56: }
57: } ;
58:
59: TokenIterator begin ( ) const {
60: return TokenIterator (@expr1073751071 mFront@var2556 ) ;
61: }
62: TokenIterator end ( ) const {
63: return TokenIterator (@expr1073751072 mBack@var2557 ) ;
64: }
65: } ;
27: class TokenRangeBase<constToken,typenamestd::enable_if<std::is_convertible<constToken*,constToken*>::value>::type> {
28: const Token * mFront@var2566 ;
29: const Token * mBack@var2567 ;
30:
31: public:
32: TokenRangeBase<constToken,typenamestd::enable_if<std::is_convertible<constToken*,constToken*>::value>::type> ( const Token * front@var2568 , const Token * back@var2569 ) : mFront@var2566 ( front@var2568 ) , mBack@var2567 ( back@var2569 ) { }
33:
34: struct TokenIterator {
35:
|
40:
41: const Token * mt@var2570 ;
42: TokenIterator ( ) : mt@var2570 ( nullptr ) { }
43: explicit TokenIterator ( const Token * t@var2571 ) : mt@var2570 ( t@var2571 ) { }
44: TokenIterator & operator++ ( ) {
45: mt@var2570 =@expr1073751073 mt@var2570 .@expr1073751074 next (@expr1073751075 ) ;
46: return *@expr1073751076 this@expr1073751077 ;
47: }
48: bool operator== ( const TokenIterator & b@var2572 ) const {
49: return mt@var2570 ==@expr1073751078 b@var2572 .@expr1073751079 mt@var2573 ;
50: }
51: bool operator!= ( const TokenIterator & b@var2574 ) const {
52: return mt@var2570 !=@expr1073751080 b@var2574 .@expr1073751081 mt@var2575 ;
53: }
54: const Token * operator* ( ) const {
55: return mt@var2570 ;
56: }
57: } ;
58:
59: TokenIterator begin ( ) const {
60: return TokenIterator (@expr1073751082 mFront@var2566 ) ;
61: }
62: TokenIterator end ( ) const {
63: return TokenIterator (@expr1073751083 mBack@var2567 ) ;
64: }
65: } ;

##file cppcheck-2.8/lib/settings.h

8:
|
48:
49: class SimpleEnableGroup<Severity::SeverityType> {
50: uint32_t mFlags@var2576 ; mFlags@var2576 = 0 ;
51: public:
52: uint32_t intValue ( ) const {
53: return mFlags@var2576 ;
54: }
55: void clear ( ) {
56: mFlags@var2576 =@expr1073751084 0 ;
57: }
58: void fill ( ) {
59: mFlags@var2576 =@expr1073751085 0xFFFFFFFF ;
60: }
61: void setEnabledAll ( bool enabled@var2577 ) {
62: if (@expr1073751086 enabled@var2577 ) {
63: fill (@expr1073751087 ) ; }
64: else {
65: clear (@expr1073751088 ) ; }
66: }
67: bool isEnabled ( Severity :: SeverityType flag@var2578 ) const {
68: return (@expr9265 mFlags@var2576 &@expr1073751090 (@expr9265 1U <<@expr1073751092 (@expr1073751093 uint32_t ) flag@var2578 ) ) !=@expr1073751094 0 ;
69: }
70: void enable ( Severity :: SeverityType flag@var2579 ) {
71: mFlags@var2576 |=@expr1073751095 (@expr1073751096 1U <<@expr1073751097 (@expr1073751098 uint32_t ) flag@var2579 ) ;
72: }
73: void disable ( Severity :: SeverityType flag@var2580 ) {
74: mFlags@var2576 &=@expr1073751099 ~@expr1073751100 (@expr1073751101 1U <<@expr1073751102 (@expr1073751103 uint32_t ) flag@var2580 ) ;
75: }
76: void setEnabled ( Severity :: SeverityType flag@var2581 , bool enabled@var2582 ) {
77: if (@expr1073751104 enabled@var2582 ) {
78: enable (@expr1073751105 flag@var2581 ) ; }
79: else {
80: disable (@expr1073751106 flag@var2581 ) ; }
81: }
82: } ;
49: class SimpleEnableGroup<Certainty::CertaintyLevel> {
50: uint32_t mFlags@var2583 ; mFlags@var2583 = 0 ;
51: public:
52: uint32_t intValue ( ) const {
53: return mFlags@var2583 ;
54: }
55: void clear ( ) {
56: mFlags@var2583 =@expr1073751107 0 ;
57: }
58: void fill ( ) {
59: mFlags@var2583 =@expr1073751108 0xFFFFFFFF ;
60: }
61: void setEnabledAll ( bool enabled@var2584 ) {
62: if (@expr1073751109 enabled@var2584 ) {
63: fill (@expr1073751110 ) ; }
64: else {
65: clear (@expr1073751111 ) ; }
66: }
67: bool isEnabled ( Certainty :: CertaintyLevel flag@var2585 ) const {
68: return (@expr9288 mFlags@var2583 &@expr1073751113 (@expr9288 1U <<@expr1073751115 (@expr1073751116 uint32_t ) flag@var2585 ) ) !=@expr1073751117 0 ;
69: }
70: void enable ( Certainty :: CertaintyLevel flag@var2586 ) {
71: mFlags@var2583 |=@expr1073751118 (@expr1073751119 1U <<@expr1073751120 (@expr1073751121 uint32_t ) flag@var2586 ) ;
72: }
73: void disable ( Certainty :: CertaintyLevel flag@var2587 ) {
74: mFlags@var2583 &=@expr1073751122 ~@expr1073751123 (@expr1073751124 1U <<@expr1073751125 (@expr1073751126 uint32_t ) flag@var2587 ) ;
75: }
76: void setEnabled ( Certainty :: CertaintyLevel flag@var2588 , bool enabled@var2589 ) {
77: if (@expr1073751127 enabled@var2589 ) {
78: enable (@expr1073751128 flag@var2588 ) ; }
79: else {
80: disable (@expr1073751129 flag@var2588 ) ; }
81: }
82: } ;
49: class SimpleEnableGroup<Checks::CheckList> {
50: uint32_t mFlags@var2590 ; mFlags@var2590 = 0 ;
51: public:
52: uint32_t intValue ( ) const {
53: return mFlags@var2590 ;
54: }
55: void clear ( ) {
56: mFlags@var2590 =@expr1073751130 0 ;
57: }
58: void fill ( ) {
59: mFlags@var2590 =@expr1073751131 0xFFFFFFFF ;
60: }
61: void setEnabledAll ( bool enabled@var2591 ) {
62: if (@expr1073751132 enabled@var2591 ) {
63: fill (@expr1073751133 ) ; }
64: else {
65: clear (@expr1073751134 ) ; }
66: }
67: bool isEnabled ( Checks :: CheckList flag@var2592 ) const {
68: return (@expr9311 mFlags@var2590 &@expr1073751136 (@expr9311 1U <<@expr1073751138 (@expr1073751139 uint32_t ) flag@var2592 ) ) !=@expr1073751140 0 ;
69: }
70: void enable ( Checks :: CheckList flag@var2593 ) {
71: mFlags@var2590 |=@expr1073751141 (@expr1073751142 1U <<@expr1073751143 (@expr1073751144 uint32_t ) flag@var2593 ) ;
72: }
73: void disable ( Checks :: CheckList flag@var2594 ) {
74: mFlags@var2590 &=@expr1073751145 ~@expr1073751146 (@expr1073751147 1U <<@expr1073751148 (@expr1073751149 uint32_t ) flag@var2594 ) ;
75: }
76: void setEnabled ( Checks :: CheckList flag@var2595 , bool enabled@var2596 ) {
77: if (@expr1073751150 enabled@var2596 ) {
78: enable (@expr1073751151 flag@var2595 ) ; }
79: else {
80: disable (@expr1073751152 flag@var2595 ) ; }
81: }
82: } ;



##Value flow
Line 43
  INT always 0
  LONG always 1
  LONGLONG always 2
  FLOAT always 3
Line 44
  mIsUnsigned always {!<=-1,!>=2}
Line 51
  ( always {!<=-1,!>=2}
Line 52
  return always {!<=-1,!>=2}
  != always {!<=-1,!>=2}
  :: always 3
  FLOAT always 3
Line 54
  ( always {!<=-1,!>=2}
Line 55
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 3
  FLOAT always 3
Line 59
  ( always {!<=-1,!>=2}
Line 74
  ( always !<=-1
Line 83
  ( always {!<=-1,!>=2}
Line 84
  ( always {!<=-1,!>=2}
Line 85
  ( always {!<=-1,!>=2}
Line 86
  ( always {!<=-1,!>=2}
Line 87
  ( always {!<=-1,!>=2}
Line 88
  ( always {!<=-1,!>=2}
Line 89
  ( always {!<=-1,!>=2}
Line 90
  ( always {!<=-1,!>=2}
Line 91
  ( always {!<=-1,!>=2}
Line 92
  ( always {!<=-1,!>=2}
Line 102
  ( always {!<=-1,!>=2}
  , always 1
  supportMicrosoftExtensions always {!<=-1,!>=2}
  = always 1
  true always 1
Line 115
  ( always !<=-1
Line 116
  ( always {!<=-1,!>=2}
Line 117
  ( always {!<=-1,!>=2}
Line 118
  ( always {!<=-1,!>=2}
Line 119
  ( always {!<=-1,!>=2}
Line 120
  ( always {!<=-1,!>=2}
Line 121
  ( always {!<=-1,!>=2}
Line 122
  ( always {!<=-1,!>=2}
Line 128
  ( always {!<=-1,!>=2}
Line 130
  ( always !<=-1
Line 137
  ( always {!<=-1,!>=2}
  , always !<=-1
  :: always !<=-1
  iPos always !<=-1
Line 66
  ( always {!<=-1,!>=2}
Line 67
  return always {!<=-1,!>=2}
  < always {!<=-1,!>=2}
Line 73
  ( always {!<=-1,!>=2}
Line 74
  return always {!<=-1,!>=2}
  ( always !<=-1
  == always {!<=-1,!>=2}
  1 always 1
Line 80
  result always {!<=-1,!>=2}
Line 81
  result always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  > always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  x {!>=symbolic=(y+1),<=symbolic=(y)}
  < always {!<=-1,!>=2}
  y {!<=symbolic=(x-1),>=symbolic=(x)}
Line 88
  Upper always 0
  Lower always 1
  Point always 2
Line 90
  = always 0
  0 always 0
Line 91
  :: always 12
  INT always 12
Line 94
  nullptr always 0
Line 95
  0.0 always 0
Line 98
  nullptr always 0
Line 99
  0U always 0
Line 100
  safe always {!<=-1,!>=2}
  false always 0
Line 101
  conditional always {!<=-1,!>=2}
  false always 0
Line 102
  macro always {!<=-1,!>=2}
  false always 0
Line 103
  defaultArg always {!<=-1,!>=2}
  false always 0
Line 104
  0 always 0
Line 105
  0 always 0
Line 108
  nullptr always 0
Line 117
  ( always {!<=-1,!>=2}
Line 118
  != always {!<=-1,!>=2}
Line 119
  return always {!<=-1,!>=2}
  false always 0
Line 120
  valueType always symbolic=(rhs.valueType)
Line 121
  :: always 0
  INT always 0
Line 122
  :: always 5
  CONTAINER_SIZE always 5
Line 123
  :: always 7
  BUFFER_SIZE always 7
Line 124
  :: always 8
  ITERATOR_START always 8
Line 125
  :: always 9
  ITERATOR_END always 9
Line 126
  != always {!<=-1,!>=2}
Line 127
  return always {!<=-1,!>=2}
  false always 0
Line 129
  :: always 1
  TOK always 1
Line 130
  != always {!<=-1,!>=2}
Line 131
  return always {!<=-1,!>=2}
  false always 0
Line 133
  :: always 2
  FLOAT always 2
Line 135
  > always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  floatValue possible <=symbolic=(rhs.floatValue)
  < always {!<=-1,!>=2}
  . possible >=symbolic=(floatValue)
Line 136
  return always {!<=-1,!>=2}
  false always 0
Line 138
  :: always 3
  MOVED always 3
Line 139
  != always {!<=-1,!>=2}
Line 140
  return always {!<=-1,!>=2}
  false always 0
Line 142
  :: always 4
  UNINIT always 4
Line 144
  :: always 6
  LIFETIME always 6
Line 145
  != always {!<=-1,!>=2}
Line 146
  return always {!<=-1,!>=2}
  false always 0
Line 148
  :: always 10
  SYMBOLIC always 10
Line 149
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 150
  return always {!<=-1,!>=2}
  false always 0
Line 151
  != always {!<=-1,!>=2}
Line 152
  return always {!<=-1,!>=2}
  false always 0
Line 155
  return always {!<=-1,!>=2}
  true always 1
Line 161
  :: always 0
  INT always 0
Line 162
  :: always 10
  SYMBOLIC always 10
Line 163
  :: always 7
  BUFFER_SIZE always 7
Line 164
  :: always 5
  CONTAINER_SIZE always 5
Line 165
  :: always 8
  ITERATOR_START always 8
Line 166
  :: always 9
  ITERATOR_END always 9
Line 170
  :: always 2
  FLOAT always 2
Line 174
  :: always 4
  UNINIT always 4
Line 175
  :: always 1
  TOK always 1
Line 176
  :: always 6
  LIFETIME always 6
Line 177
  :: always 3
  MOVED always 3
Line 185
  result always {!<=-1,!>=2}
Line 186
  result always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
Line 190
  result always {!<=-1,!>=2}
Line 192
  ( possible {lifetime[Object]=(x),lifetime[Object]=(result),lifetime[Object]=(compare)}
  ( possible lifetime[Object]=(result)
  result always {!<=-1,!>=2}
  ( possible lifetime[Object]=(compare)
Line 197
  ( always {!<=-1,!>=2}
Line 198
  ! always {!<=-1,!>=2}
  this always !0
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
Line 199
  this always !0
  == always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  this always !0
Line 200
  result always {!<=-1,!>=2}
  result always {!<=-1,!>=2}
  = always 0
  false always 0
Line 202
  this always !0
Line 203
  ( possible {lifetime[Object]=(result),lifetime[Object]=(rhs),lifetime[Object]=(compare)}
  ( possible lifetime[Object]=(result)
  result always 0
  ( possible lifetime[Object]=(rhs)
  ( possible lifetime[Object]=(compare)
Line 204
  return always {!<=-1,!>=2}
  result {!<=-1,!>=2,0}
Line 207
  ( always {!<=-1,!>=2}
Line 208
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 209
  return always {!<=-1,!>=2}
  false always 0
Line 211
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 212
  == always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 213
  == always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 214
  conditional always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  . always {!<=-1,!>=2}
  conditional always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 215
  defaultArg always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  . always {!<=-1,!>=2}
  defaultArg always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 216
  == always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 217
  == always {!<=-1,!>=2}
Line 220
  ( always {!<=-1,!>=2}
Line 221
  return always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  this always !0
  == always {!<=-1,!>=2}
Line 225
  ( always {!<=-1,!>=2}
Line 226
  result always {!<=-1,!>=2}
  result always {!<=-1,!>=2}
  = always 0
  false always 0
Line 227
  this always !0
  ( possible {lifetime[Object]=(x),lifetime[Object]=(result)}
  ( possible lifetime[Object]=(result)
  result always 0
Line 228
  return always {!<=-1,!>=2}
  result {!<=-1,!>=2,0}
Line 232
  bound possible 0
  == {!<=-1,!>=2,0}
  :: always 1
  Lower always 1
Line 233
  this always !0
Line 234
  bound always !1
  == always {!<=-1,!>=2}
  :: always 0
  Upper always 0
Line 235
  this always !0
Line 239
  bound possible 0
  == {!<=-1,!>=2,0}
  :: always 1
  Lower always 1
Line 240
  = always 0
  :: always 0
  Upper always 0
Line 241
  bound always !1
  == always {!<=-1,!>=2}
  :: always 0
  Upper always 0
Line 242
  = always 1
  :: always 1
  Lower always 1
Line 255
  INT always 0
Line 256
  TOK always 1
Line 257
  FLOAT always 2
Line 258
  MOVED always 3
Line 259
  UNINIT always 4
Line 260
  CONTAINER_SIZE always 5
Line 261
  LIFETIME always 6
Line 262
  BUFFER_SIZE always 7
Line 263
  ITERATOR_START always 8
Line 264
  ITERATOR_END always 9
Line 265
  SYMBOLIC always 10
Line 267
  ( always {!<=-1,!>=2}
Line 268
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 0
  INT always 0
Line 270
  ( always {!<=-1,!>=2}
Line 271
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 1
  TOK always 1
Line 273
  ( always {!<=-1,!>=2}
Line 274
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 2
  FLOAT always 2
Line 276
  ( always {!<=-1,!>=2}
Line 277
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 3
  MOVED always 3
Line 279
  ( always {!<=-1,!>=2}
Line 280
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 4
  UNINIT always 4
Line 282
  ( always {!<=-1,!>=2}
Line 283
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 5
  CONTAINER_SIZE always 5
Line 285
  ( always {!<=-1,!>=2}
Line 286
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 6
  LIFETIME always 6
Line 288
  ( always {!<=-1,!>=2}
Line 289
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 7
  BUFFER_SIZE always 7
Line 291
  ( always {!<=-1,!>=2}
Line 292
  return always {!<=-1,!>=2}
  valueType possible 9
  == {!<=-1,!>=2,0}
  :: always 8
  ITERATOR_START always 8
  || always {!<=-1,!>=2}
  valueType always !8
  == always {!<=-1,!>=2}
  :: always 9
  ITERATOR_END always 9
Line 294
  ( always {!<=-1,!>=2}
Line 295
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 8
  ITERATOR_START always 8
Line 297
  ( always {!<=-1,!>=2}
Line 298
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 9
  ITERATOR_END always 9
Line 300
  ( always {!<=-1,!>=2}
Line 301
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 10
  SYMBOLIC always 10
Line 304
  ( always {!<=-1,!>=2}
Line 305
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 6
  LIFETIME always 6
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
Line 308
  ( always {!<=-1,!>=2}
Line 309
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 6
  LIFETIME always 6
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 1
  Argument always 1
Line 312
  ( always {!<=-1,!>=2}
Line 313
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 6
  LIFETIME always 6
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 2
  SubFunction always 2
Line 316
  ( always {!<=-1,!>=2}
Line 317
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 333
  NonMovedVariable always 0
  MovedVariable always 1
  ForwardedVariable always 2
Line 347
  safe always {!<=-1,!>=2}
Line 350
  conditional always {!<=-1,!>=2}
Line 353
  macro always {!<=-1,!>=2}
Line 356
  defaultArg always {!<=-1,!>=2}
Line 373
  Object always 0
Line 375
  SubObject always 1
Line 377
  Lambda always 2
Line 379
  Iterator always 3
Line 381
  Address always 4
Line 384
  Local always 0
  Argument always 1
  SubFunction always 2
  ThisPointer always 3
  ThisValue always 4
Line 394
  Possible always 0
Line 396
  Known always 1
Line 398
  Inconclusive always 2
Line 400
  Impossible always 3
Line 404
  = always 1
  :: always 1
  Known always 1
Line 407
  ( always {!<=-1,!>=2}
Line 408
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 1
  Known always 1
Line 415
  ( always {!<=-1,!>=2}
Line 416
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
Line 419
  ( always {!<=-1,!>=2}
Line 420
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 3
  Impossible always 3
Line 424
  = always 3
  :: always 3
  Impossible always 3
Line 427
  inconclusive always {!<=-1,!>=2}
  = always 1
  true always 1
Line 428
  inconclusive always {!<=-1,!>=2}
Line 429
  = always 2
  :: always 2
  Inconclusive always 2
Line 432
  ( always {!<=-1,!>=2}
Line 433
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 2
  Inconclusive always 2
Line 437
  ( always {!<=-1,!>=2}
Line 441
  ( always {!<=-1,!>=2}
Line 442
  return always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  defaultArg always {!<=-1,!>=2}
Line 445
  ( always {!<=-1,!>=2}
Line 456
  ( always !<=-1
Line 460
  ( always {!<=-1,!>=2}
Line 462
  possible always {!<=-1,!>=2}
  = always 1
  true always 1
Line 467
  ( always {!<=-1,!>=2}
  , always 0
  = always 0
  nullptr always 0
  , always 20
  = always 20
  20 always 20
Line 471
  addressOf always {!<=-1,!>=2}
Line 473
  inconclusive always {!<=-1,!>=2}
Line 475
  nullptr always 0
  addressOf always {!<=-1,!>=2}
  false always 0
  inconclusive always {!<=-1,!>=2}
  false always 0
Line 478
  addressOf always {!<=-1,!>=2}
  false always 0
  ( possible lifetime[Object]=(errorPath)
  inconclusive always {!<=-1,!>=2}
  false always 0
Line 481
  addressOf always {!<=-1,!>=2}
Line 482
  addressOf always {!<=-1,!>=2}
  addressOf always {!<=-1,!>=2}
  ( possible lifetime[Object]=(errorPath)
  inconclusive always {!<=-1,!>=2}
  false always 0
Line 485
  b always {!<=-1,!>=2}
Line 487
  . always {!<=-1,!>=2}
  addressOf always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  b always {!<=-1,!>=2}
Line 491
  b always {!<=-1,!>=2}
Line 493
  . always {!<=-1,!>=2}
  inconclusive always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  b always {!<=-1,!>=2}
Line 511
  escape always {!<=-1,!>=2}
  = always 0
  false always 0
Line 514
  ( always {!<=-1,!>=2}
Line 516
  , always 0
  = always 0
  nullptr always 0
Line 520
  ( always {!<=-1,!>=2}
Line 526
  , always 0
  inconclusive always {!<=-1,!>=2}
  = always 0
  false always 0
Line 529
  inconclusive always {!<=-1,!>=2}
  = always 0
  false always 0
Line 530
  = always 0
  0 always 0
Line 532
  , always 0
  = always 0
  nullptr always 0
  , always 1
  smallest always {!<=-1,!>=2}
  = always 1
  true always 1
Line 62
  ( always !<=-1
Line 74
  mFlags always !<=-1
Line 77
  fIsClass always 1
  = always 1
  1 always 1
  << always 1
  0 always 0
  , always 2
Line 78
  fIsFunction always 2
  = always 2
  1 always 1
  << always 2
  1 always 1
  , always 4
Line 79
  fIsVariable always 4
  = always 4
  1 always 1
  << always 4
  2 always 2
  , always 8
Line 80
  fIsAlias always 8
  = always 8
  1 always 1
  << always 8
  3 always 3
  , always 16
Line 81
  fIsSpecialization always 16
  = always 16
  1 always 1
  << always 16
  4 always 4
  , always 32
Line 82
  fIsPartialSpecialization always 32
  = always 32
  1 always 1
  << always 32
  5 always 5
  , always 64
Line 83
  fIsForwardDeclaration always 64
  = always 64
  1 always 1
  << always 64
  6 always 6
  , always 128
Line 84
  fIsVariadic always 128
  = always 128
  1 always 1
  << always 128
  7 always 7
  , always 256
Line 85
  fIsFriend always 256
  = always 256
  1 always 1
  << always 256
  8 always 8
  , always 7
Line 86
  fFamilyMask always 7
  = always 7
  fIsClass always 1
  | always 3
  fIsFunction always 2
  | always 7
  fIsVariable always 4
Line 89
  state always {!<=-1,!>=2}
Line 90
  fIsClass always 1
  state always {!<=-1,!>=2}
Line 92
  state always {!<=-1,!>=2}
Line 93
  fIsFunction always 2
  state always {!<=-1,!>=2}
Line 95
  state always {!<=-1,!>=2}
Line 96
  fIsVariable always 4
  state always {!<=-1,!>=2}
Line 98
  state always {!<=-1,!>=2}
Line 99
  fIsAlias always 8
  state always {!<=-1,!>=2}
Line 101
  state always {!<=-1,!>=2}
Line 102
  fIsSpecialization always 16
  state always {!<=-1,!>=2}
Line 104
  state always {!<=-1,!>=2}
Line 105
  fIsPartialSpecialization always 32
  state always {!<=-1,!>=2}
Line 107
  state always {!<=-1,!>=2}
Line 108
  fIsForwardDeclaration always 64
  state always {!<=-1,!>=2}
Line 110
  state always {!<=-1,!>=2}
Line 111
  fIsVariadic always 128
  state always {!<=-1,!>=2}
Line 113
  state always {!<=-1,!>=2}
Line 114
  fIsFriend always 256
  state always {!<=-1,!>=2}
Line 122
  ( always {!<=-1,!>=2}
  flag always !<=-1
Line 123
  return always {!<=-1,!>=2}
  mFlags always !<=-1
  & always !<=-1
  flag {!<=-1,256@144,128@145,64@146,32@147,16@148,8@149,4@150,2@151,1@152}
  != always {!<=-1,!>=2}
  0 always 0
Line 131
  flag always !<=-1
  state always {!<=-1,!>=2}
Line 132
  mFlags always !<=-1
  = always !<=-1
  state always {!<=-1,!>=2}
  ? always !<=-1
  mFlags always !<=-1
  | always !<=-1
  flag {!<=-1,256@153,128@154,64@155,32@156,16@157,8@158,4@159,2@160,1@161}
  : always !<=-1
  mFlags always !<=-1
  & always !<=-1
  ~ {!<=0,4294967039@153,4294967167@154,4294967231@155,4294967263@156,4294967279@157,4294967287@158,4294967291@159,4294967293@160,4294967294@161}
  flag {!<=-1,256@153,128@154,64@155,32@156,16@157,8@158,4@159,2@160,1@161}
Line 153
  ( always {!<=-1,!>=2}
Line 154
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 155
  == always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  mFlags always !<=-1
  == always {!<=-1,!>=2}
  . always !<=-1
  mFlags always !<=-1
Line 183
  ( always {!<=-1,!>=2}
Line 184
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsClass always 1
Line 186
  ( always {!<=-1,!>=2}
Line 187
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsFunction always 2
Line 189
  ( always {!<=-1,!>=2}
Line 190
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsVariable always 4
Line 192
  ( always {!<=-1,!>=2}
Line 193
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsAlias always 8
Line 195
  ( always {!<=-1,!>=2}
Line 196
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsSpecialization always 16
Line 198
  ( always {!<=-1,!>=2}
Line 199
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsPartialSpecialization always 32
Line 201
  ( always {!<=-1,!>=2}
Line 202
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsForwardDeclaration always 64
Line 204
  ( always {!<=-1,!>=2}
Line 205
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsVariadic always 128
Line 207
  ( always {!<=-1,!>=2}
Line 208
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsFriend always 256
Line 234
  ( always {!<=-1,!>=2}
Line 242
  ( always {!<=-1,!>=2}
Line 245
  return always {!<=-1,!>=2}
  mFlags always !<=-1
  & always !<=-1
  fFamilyMask always 7
  & always !<=-1
  . always !<=-1
  mFlags always !<=-1
  & always !<=-1
  fFamilyMask always 7
  != always {!<=-1,!>=2}
  0 always 0
Line 265
  ( always {!<=-1,!>=2}
  , always !<=-1
  numberOfArguments always !<=-1
  , always {!<=-1,!>=2}
  variadic always {!<=-1,!>=2}
Line 281
  ( always {!<=-1,!>=2}
Line 289
  ( always {!<=-1,!>=2}
Line 297
  ( always {!<=-1,!>=2}
Line 306
  codeWithTemplates always {!<=-1,!>=2}
Line 314
  ( always {!<=-1,!>=2}
  , always 1
  isTemplate always {!<=-1,!>=2}
  = always 1
  true always 1
Line 322
  ( always {!<=-1,!>=2}
  = always 0
  nullptr always 0
  , always 0
  = always 0
  nullptr always 0
  , always 1
  isTemplate always {!<=-1,!>=2}
  = always 1
  true always 1
Line 335
  ( always {!<=-1,!>=2}
Line 391
  ( always {!<=-1,!>=2}
Line 410
  ( always {!<=-1,!>=2}
Line 424
  , always {!<=-1,!>=2}
Line 425
  copy always {!<=-1,!>=2}
Line 451
  ( always {!<=-1,!>=2}
Line 456
  ( always {!<=-1,!>=2}
Line 486
  , always "    "
Line 487
  = always "    "
  "    " always "    "
Line 488
  = always ""
  "" always ""
Line 494
  mChanged always {!<=-1,!>=2}
Line 47
  ( always {!<=-1,!>=2}
Line 49
  return always {!<=-1,!>=2}
  != always {!<=-1,!>=2}
Line 53
  ( always {!<=-1,!>=2}
Line 55
  return always {!<=-1,!>=2}
  != always {!<=-1,!>=2}
Line 59
  ( always {!<=-1,!>=2}
Line 61
  return always {!<=-1,!>=2}
  != always {!<=-1,!>=2}
Line 67
  ( always !<=-1
Line 69
  return always !<=-1
  ( always !<=-1
Line 73
  ( always {!<=-1,!>=2}
Line 75
  return always {!<=-1,!>=2}
  ! {!<=-1,!>=2,0}
  str possible size=0
  ( {!<=-1,!>=2,1}
  && always {!<=-1,!>=2}
  str always !size=0
  == always {!<=-1,!>=2}
  c possible {34@28046,39@28302}
Line 78
  ( always {!<=-1,!>=2}
  , always !<=-1
  endlen always !<=-1
Line 80
  return always {!<=-1,!>=2}
  ( always !<=-1
  >= always {!<=-1,!>=2}
  endlen always !<=-1
  && always {!<=-1,!>=2}
  ( {!<=-1,>=symbolic=(endlen),!<=symbolic=(endlen-1)}
  - always !<=-1
  endlen {!<=-1,<=symbolic=(str.size()),!>=symbolic=(str.size()+1)}
  endlen {!<=-1,<=symbolic=(str.size()),!>=symbolic=(str.size()+1)}
  == always {!<=-1,!>=2}
  0 always 0
Line 84
  ( always {!<=-1,!>=2}
  ( always !0
  & always !0
Line 86
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  1 always 1
Line 89
  ( always {!<=-1,!>=2}
Line 91
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  q possible {34@109,39@110}
Line 92
  return always {!<=-1,!>=2}
  false always 0
Line 93
  ( always !<=-1
  + always !<=0
  1 always 1
  > always {!<=-1,!>=2}
  p possible {"L"@109,"L"@110,""@38,""@39,""@40,"U"@41,"U"@42,"u"@43,"u"@44,"u8"@45}
  ( always !<=-1
  && always {!<=-1,!>=2}
  0 always 0
  ( always !<=-1
  + always !<=0
  1 always 1
  == always {!<=-1,!>=2}
  0 always 0
Line 94
  return always {!<=-1,!>=2}
  true always 1
Line 95
  return always {!<=-1,!>=2}
  false always 0
Line 98
  ( always {!<=-1,!>=2}
Line 100
  "" always ""
  "u8" always "u8"
  "u" always "u"
  "U" always "U"
  "L" always "L"
Line 102
  ( always {!<=-1,!>=2}
  q possible {39@139,34@140}
Line 103
  return always {!<=-1,!>=2}
  true always 1
Line 105
  return always {!<=-1,!>=2}
  false always 0
Line 108
  ( always {!<=-1,!>=2}
Line 110
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  str possible {size=1@116,size=3@116,size=2@116}
  '"' always 34
Line 113
  ( always {!<=-1,!>=2}
Line 115
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  str possible {size=1@118,size=3@118,size=2@118}
  '\'' always 39
Line 120
  quotePos always !<=-1
  = always !<=-1
  ( always !<=-1
  q possible {39@136,34@138}
Line 121
  quotePos {symbolic=(str.find(q)),!<=-1}
  + always !<=0
  1U always 1
  ( always !<=-1
  - always !<=-1
  quotePos {symbolic=(str.find(q)),!<=-1}
  - always !<=-1
  2U always 2
Line 126
  ( always {!<=-1,!>=2}
Line 127
  '"' always 34
Line 128
  "" always ""
Line 133
  ( always {!<=-1,!>=2}
Line 134
  '\'' always 39
Line 135
  "" always ""
Line 140
  i possible {2,3}
  == {!<=-1,!>=2,0}
  1 always 1
Line 141
  "st" always "st"
Line 142
  i {3,!1}
  == {!<=-1,!>=2,0}
  2 always 2
Line 143
  "nd" always "nd"
Line 144
  i always {!1,!2}
  == always {!<=-1,!>=2}
  3 always 3
Line 145
  "rd" always "rd"
Line 146
  "th" always "th"
Line 151
  ( always {!<=-1,!>=2}
Line 153
  ( always {!<=-1,!>=2}
Line 155
  ( always {!<=-1,!>=2}
Line 118
  LOW always 0
  HIGH always 1
Line 125
  UNKNOWN always 0
  CPP11INIT always 1
  NOINIT always 2
Line 128
  mBits always !<=-1
Line 131
  ( always {!<=-1,!>=2}
Line 134
  0 always 0
Line 135
  0 always 0
Line 136
  0 always 0
Line 137
  0 always 0
Line 138
  0 always 0
Line 139
  nullptr always 0
Line 140
  nullptr always 0
Line 141
  nullptr always 0
Line 142
  nullptr always 0
Line 143
  nullptr always 0
Line 144
  0 always 0
Line 145
  0 always 0
Line 146
  nullptr always 0
Line 147
  nullptr always 0
Line 148
  nullptr always 0
Line 149
  nullptr always 0
Line 150
  nullptr always 0
Line 151
  nullptr always 0
Line 153
  mBits always !<=-1
  0 always 0
Line 182
  eVariable always 0
  eType always 1
  eFunction always 2
  eKeyword always 3
  eName always 4
Line 183
  eNumber always 5
  eString always 6
  eChar always 7
  eBoolean always 8
  eLiteral always 9
  eEnumerator always 10
Line 184
  eArithmeticalOp always 11
  eComparisonOp always 12
  eAssignmentOp always 13
  eLogicalOp always 14
  eBitOp always 15
  eIncDecOp always 16
  eExtendedOp always 17
Line 185
  eBracket always 18
Line 186
  eLambda always 19
Line 187
  eEllipsis always 20
Line 188
  eOther always 21
Line 189
  eNone always 22
Line 192
  = always 0
  nullptr always 0
Line 198
  && always {!<=-1,!>=2}
Line 200
  = always 0
  0 always 0
Line 218
  = always 1
  1 always 1
Line 223
  = always 1
  1 always 1
Line 237
  ( always !0
  this always !0
  index possible {-2@137,-3@144}
Line 246
  ( always !0
  this always !0
  index possible {1@23,-1@128}
Line 275
  ( always {!<=-1,!>=2}
  ( always !0
  & {lifetime[Address]=(pattern),!0}
Line 276
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  tok possible {symbolic=(var->declEndToken())@76,symbolic=(*typeTok)@99,symbolic=(newToken->previous())@163}
  pattern possible {"["@20,"}"@24,") {"@25,")"@27,"noexcept ("@30,"."@32,"{"@35,"return"@62,"auto"@71,"="@76}
  1 always 1
Line 279
  ( always {!<=-1,!>=2}
Line 324
  ( always {!<=-1,!>=2}
  , always 0
  = always 0
  0 always 0
Line 370
  = always !0
  this always !0
Line 371
  top possible {symbolic=(this),0}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  top {symbolic=(this),!0}
  ",|(" always ",|("
Line 372
  top always !0
Line 373
  top possible {symbolic=(this),0}
  ? possible 0
  top always !0
  : always 0
  nullptr always 0
Line 380
  = possible {1@124,4@126,19@184,2@185,8@115,6@117,7@119,0@120,3@121,5@123}
  t possible {1@124,4@126,19@184,2@185,8@115,6@117,7@119,0@120,3@121,5@123}
Line 382
  memoizedIsName always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  mTokType possible {1@124,4@126,19@184,2@185,8@115,6@117,7@119,0@120,3@121,5@123}
  == always {!<=-1,!>=2}
  eName always 4
  || always {!<=-1,!>=2}
  mTokType {!4,1@124,19@184,2@185,8@115,6@117,7@119,0@120,3@121,5@123}
  == always {!<=-1,!>=2}
  eType always 1
  || always {!<=-1,!>=2}
  mTokType {!4,!1,19@184,2@185,8@115,6@117,7@119,0@120,3@121,5@123}
  == always {!<=-1,!>=2}
  eVariable always 0
  || always {!<=-1,!>=2}
Line 383
  mTokType {!1,!0,19@184,2@185,8@115,6@117,7@119,3@121,5@123}
  == always {!<=-1,!>=2}
  eFunction always 2
  || always {!<=-1,!>=2}
  mTokType {!0,!2,19@184,8@115,6@117,7@119,3@121,5@123}
  == always {!<=-1,!>=2}
  eKeyword always 3
  || always {!<=-1,!>=2}
  mTokType {!2,!3,19@184,8@115,6@117,7@119,5@123}
  == always {!<=-1,!>=2}
  eBoolean always 8
  || always {!<=-1,!>=2}
Line 384
  mTokType {!3,!8,19@184,6@117,7@119,5@123}
  == always {!<=-1,!>=2}
  eEnumerator always 10
Line 385
  fIsName always 2097152
  memoizedIsName {symbolic=(mTokType==eName||mTokType==eType||mTokType==eVariable||mTokType==eFunction||mTokType==eKeyword||mTokType==eBoolean||mTokType==eEnumerator),!<=-1,!>=2,1@124,0@184}
Line 387
  memoizedIsLiteral always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  eNumber always 5
  || always {!<=-1,!>=2}
  mTokType always !5
  == always {!<=-1,!>=2}
  eString always 6
  || always {!<=-1,!>=2}
  mTokType always {!5,!6}
  == always {!<=-1,!>=2}
  eChar always 7
  || always {!<=-1,!>=2}
Line 388
  mTokType always {!6,!7}
  == always {!<=-1,!>=2}
  eBoolean always 8
  || always {!<=-1,!>=2}
  mTokType always {!7,!8}
  == always {!<=-1,!>=2}
  eLiteral always 9
  || always {!<=-1,!>=2}
  mTokType always {!8,!9}
  == always {!<=-1,!>=2}
  eEnumerator always 10
Line 389
  fIsLiteral always 4194304
  memoizedIsLiteral {symbolic=(mTokType==eNumber||mTokType==eString||mTokType==eChar||mTokType==eBoolean||mTokType==eLiteral||mTokType==eEnumerator),!<=-1,!>=2}
Line 391
  ( always {!<=-1,!>=2}
Line 392
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  eKeyword always 3
Line 394
  ( always {!<=-1,!>=2}
Line 395
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsName always 2097152
Line 397
  ( always {!<=-1,!>=2}
Line 398
  return always {!<=-1,!>=2}
  mFlags always !<=-1
  == always {!<=-1,!>=2}
  fIsName always 2097152
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  eName always 4
Line 400
  ( always {!<=-1,!>=2}
Line 401
  ( always {!<=-1,!>=2}
Line 402
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsLiteral always 4194304
Line 404
  ( always {!<=-1,!>=2}
Line 405
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  eNumber always 5
Line 407
  ( always {!<=-1,!>=2}
Line 408
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  eEnumerator always 10
Line 410
  ( always {!<=-1,!>=2}
Line 411
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
Line 412
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
Line 413
  == always {!<=-1,!>=2}
  eIncDecOp always 16
Line 415
  ( always {!<=-1,!>=2}
Line 416
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
Line 417
  == always {!<=-1,!>=2}
  eLogicalOp always 14
  || always {!<=-1,!>=2}
Line 418
  mTokType always !14
  == always {!<=-1,!>=2}
  eComparisonOp always 12
  || always {!<=-1,!>=2}
Line 419
  mTokType always {!14,!12}
  == always {!<=-1,!>=2}
  eBitOp always 15
Line 421
  ( always {!<=-1,!>=2}
Line 422
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
Line 423
  == always {!<=-1,!>=2}
  eExtendedOp always 17
Line 425
  ( always {!<=-1,!>=2}
Line 426
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  eArithmeticalOp always 11
Line 428
  ( always {!<=-1,!>=2}
Line 429
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  eComparisonOp always 12
Line 431
  ( always {!<=-1,!>=2}
Line 432
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  eAssignmentOp always 13
Line 434
  ( always {!<=-1,!>=2}
Line 435
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  eBoolean always 8
Line 437
  ( always {!<=-1,!>=2}
Line 438
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  eIncDecOp always 16
Line 440
  ( always {!<=-1,!>=2}
Line 441
  return always {!<=-1,!>=2}
  != always {!<=-1,!>=2}
  nullptr always 0
  && always {!<=-1,!>=2}
  != always {!<=-1,!>=2}
  nullptr always 0
Line 443
  ( always {!<=-1,!>=2}
Line 444
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  != always {!<=-1,!>=2}
  nullptr always 0
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  nullptr always 0
Line 446
  ( always {!<=-1,!>=2}
Line 448
  ( always !<=-1
Line 449
  return always !<=-1
  mFlags always !<=-1
Line 451
  flags_ always !<=-1
Line 452
  mFlags always !<=-1
  = always !<=-1
  flags_ always !<=-1
Line 454
  ( always {!<=-1,!>=2}
Line 455
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsUnsigned always 1
Line 457
  sign always {!<=-1,!>=2}
Line 458
  fIsUnsigned always 1
  sign always {!<=-1,!>=2}
Line 460
  ( always {!<=-1,!>=2}
Line 461
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsSigned always 2
Line 463
  sign always {!<=-1,!>=2}
Line 464
  fIsSigned always 2
  sign always {!<=-1,!>=2}
Line 466
  ( always {!<=-1,!>=2}
Line 467
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsPointerCompare always 4
Line 469
  b always {!<=-1,!>=2}
Line 470
  fIsPointerCompare always 4
  b always {!<=-1,!>=2}
Line 472
  ( always {!<=-1,!>=2}
Line 473
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsLong always 8
Line 475
  size always {!<=-1,!>=2}
Line 476
  fIsLong always 8
  size {!<=-1,!>=2,0@108,1@108}
Line 478
  ( always {!<=-1,!>=2}
Line 479
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsStandardType always 16
Line 481
  b always {!<=-1,!>=2}
Line 482
  fIsStandardType always 16
  b {!<=-1,!>=2,0@111,1@112}
Line 484
  ( always {!<=-1,!>=2}
Line 485
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsExpandedMacro always 32
Line 487
  m always {!<=-1,!>=2}
Line 488
  fIsExpandedMacro always 32
  m always {!<=-1,!>=2}
Line 490
  ( always {!<=-1,!>=2}
Line 491
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsCast always 64
Line 493
  c always {!<=-1,!>=2}
Line 494
  fIsCast always 64
  c always {!<=-1,!>=2}
Line 496
  ( always {!<=-1,!>=2}
Line 497
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsAttributeConstructor always 128
Line 499
  ac always {!<=-1,!>=2}
Line 500
  fIsAttributeConstructor always 128
  ac always {!<=-1,!>=2}
Line 502
  ( always {!<=-1,!>=2}
Line 503
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsAttributeDestructor always 256
Line 505
  value always {!<=-1,!>=2}
Line 506
  fIsAttributeDestructor always 256
  value always {!<=-1,!>=2}
Line 508
  ( always {!<=-1,!>=2}
Line 509
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsAttributeUnused always 512
Line 511
  unused always {!<=-1,!>=2}
Line 512
  fIsAttributeUnused always 512
  unused always {!<=-1,!>=2}
Line 514
  ( always {!<=-1,!>=2}
Line 515
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsAttributeUsed always 16384
Line 517
  unused always {!<=-1,!>=2}
Line 518
  fIsAttributeUsed always 16384
  unused always {!<=-1,!>=2}
Line 520
  ( always {!<=-1,!>=2}
Line 521
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsAttributePure always 1024
Line 523
  value always {!<=-1,!>=2}
Line 524
  fIsAttributePure always 1024
  value always {!<=-1,!>=2}
Line 526
  ( always {!<=-1,!>=2}
Line 527
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsAttributeConst always 2048
Line 529
  value always {!<=-1,!>=2}
Line 530
  fIsAttributeConst always 2048
  value always {!<=-1,!>=2}
Line 532
  ( always {!<=-1,!>=2}
Line 533
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsAttributeNoreturn always 4096
Line 535
  value always {!<=-1,!>=2}
Line 536
  fIsAttributeNoreturn always 4096
  value always {!<=-1,!>=2}
Line 538
  ( always {!<=-1,!>=2}
Line 539
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsAttributeNothrow always 8192
Line 541
  value always {!<=-1,!>=2}
Line 542
  fIsAttributeNothrow always 8192
  value always {!<=-1,!>=2}
Line 544
  ( always {!<=-1,!>=2}
Line 545
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsAttributePacked always 32768
Line 547
  value always {!<=-1,!>=2}
Line 548
  fIsAttributePacked always 32768
  value always {!<=-1,!>=2}
Line 550
  ( always {!<=-1,!>=2}
Line 551
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsAttributeNodiscard always 16777216
Line 553
  value always {!<=-1,!>=2}
Line 554
  fIsAttributeNodiscard always 16777216
  value always {!<=-1,!>=2}
Line 556
  ( always {!<=-1,!>=2}
Line 557
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsAttributeMaybeUnused always 65536
Line 559
  value always {!<=-1,!>=2}
Line 560
  fIsAttributeMaybeUnused always 65536
  value always {!<=-1,!>=2}
Line 565
  ( always {!<=-1,!>=2}
Line 566
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 568
  ( always {!<=-1,!>=2}
Line 569
  return always {!<=-1,!>=2}
  nullptr always 0
  != always {!<=-1,!>=2}
Line 571
  ( always {!<=-1,!>=2}
Line 572
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsControlFlowKeyword always 131072
Line 574
  ( always {!<=-1,!>=2}
Line 575
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsOperatorKeyword always 262144
Line 577
  value always {!<=-1,!>=2}
Line 578
  fIsOperatorKeyword always 262144
  value always {!<=-1,!>=2}
Line 580
  ( always {!<=-1,!>=2}
Line 581
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsComplex always 524288
Line 583
  value always {!<=-1,!>=2}
Line 584
  fIsComplex always 524288
  value always {!<=-1,!>=2}
Line 586
  ( always {!<=-1,!>=2}
Line 587
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsEnumType always 1048576
Line 589
  value always {!<=-1,!>=2}
Line 590
  fIsEnumType always 1048576
  value always {!<=-1,!>=2}
Line 592
  ( always {!<=-1,!>=2}
Line 593
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fAtAddress always 33554432
Line 595
  b always {!<=-1,!>=2}
Line 596
  fAtAddress always 33554432
  b always {!<=-1,!>=2}
Line 598
  ( always {!<=-1,!>=2}
Line 599
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIncompleteVar always 67108864
Line 601
  b always {!<=-1,!>=2}
Line 602
  fIncompleteVar always 67108864
  b always {!<=-1,!>=2}
Line 605
  ( always {!<=-1,!>=2}
Line 606
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsIncompleteConstant always 68719476736
Line 608
  b always {!<=-1,!>=2}
Line 609
  fIsIncompleteConstant always 68719476736
  b always {!<=-1,!>=2}
Line 612
  ( always {!<=-1,!>=2}
Line 613
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fConstexpr always 134217728
Line 615
  b always {!<=-1,!>=2}
Line 616
  fConstexpr always 134217728
  b always {!<=-1,!>=2}
Line 619
  ( always {!<=-1,!>=2}
Line 620
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fExternC always 268435456
Line 622
  b always {!<=-1,!>=2}
Line 623
  fExternC always 268435456
  b always {!<=-1,!>=2}
Line 626
  ( always {!<=-1,!>=2}
Line 627
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsSplitVarDeclComma always 536870912
Line 629
  b always {!<=-1,!>=2}
Line 630
  fIsSplitVarDeclComma always 536870912
  b always {!<=-1,!>=2}
Line 633
  ( always {!<=-1,!>=2}
Line 634
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsSplitVarDeclEq always 1073741824
Line 636
  b always {!<=-1,!>=2}
Line 637
  fIsSplitVarDeclEq always 1073741824
  b always {!<=-1,!>=2}
Line 640
  ( always {!<=-1,!>=2}
Line 641
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsImplicitInt always 2147483648
Line 643
  b always {!<=-1,!>=2}
Line 644
  fIsImplicitInt always 2147483648
  b always {!<=-1,!>=2}
Line 647
  ( always {!<=-1,!>=2}
Line 648
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsInline always 4294967296
Line 650
  b always {!<=-1,!>=2}
Line 651
  fIsInline always 4294967296
  b always {!<=-1,!>=2}
Line 654
  ( always {!<=-1,!>=2}
Line 655
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsRemovedVoidParameter always 34359738368
Line 657
  b always {!<=-1,!>=2}
Line 658
  fIsRemovedVoidParameter always 34359738368
  b always {!<=-1,!>=2}
Line 661
  ( always {!<=-1,!>=2}
Line 662
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsTemplate always 8589934592
Line 664
  b always {!<=-1,!>=2}
Line 665
  fIsTemplate always 8589934592
  b always {!<=-1,!>=2}
Line 668
  ( always {!<=-1,!>=2}
Line 669
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsSimplifedScope always 17179869184
Line 671
  b always {!<=-1,!>=2}
Line 672
  fIsSimplifedScope always 17179869184
  b always {!<=-1,!>=2}
Line 675
  ( always {!<=-1,!>=2}
Line 676
  return always {!<=-1,!>=2}
  . always !<=-1
  mBits always !<=-1
  > always {!<=-1,!>=2}
  0 always 0
Line 678
  ( always !<=-1
Line 679
  return always !<=-1
  . always !<=-1
  mBits always !<=-1
Line 685
  ! always {!<=-1,!>=2}
Line 687
  . possible lifetime[Object]=(tokenAndName)
Line 689
  b always !<=-1
Line 690
  . always !<=-1
  mBits always !<=-1
  = always !<=-1
  b always !<=-1
Line 693
  ( always {!<=-1,!>=2}
Line 694
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  eString always 6
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  '"' always 34
  "u8" always "u8"
  || always {!<=-1,!>=2}
Line 695
  == always {!<=-1,!>=2}
  eChar always 7
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  '\'' always 39
  "u8" always "u8"
Line 698
  ( always {!<=-1,!>=2}
Line 699
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  eString always 6
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  '"' always 34
  "u" always "u"
  || always {!<=-1,!>=2}
Line 700
  == always {!<=-1,!>=2}
  eChar always 7
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  '\'' always 39
  "u" always "u"
Line 703
  ( always {!<=-1,!>=2}
Line 704
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  eString always 6
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  '"' always 34
  "U" always "U"
  || always {!<=-1,!>=2}
Line 705
  == always {!<=-1,!>=2}
  eChar always 7
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  '\'' always 39
  "U" always "U"
Line 708
  ( always {!<=-1,!>=2}
Line 709
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  eString always 6
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  '"' always 34
  "" always ""
  || always {!<=-1,!>=2}
Line 710
  == always {!<=-1,!>=2}
  eChar always 7
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  '\'' always 39
  "" always ""
  && always {!<=-1,!>=2}
  ( always !<=-1
  == always {!<=-1,!>=2}
  3 always 3
Line 713
  ( always {!<=-1,!>=2}
Line 714
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  eChar always 7
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  '\'' always 39
  "" always ""
  && always {!<=-1,!>=2}
Line 715
  ( always !<=-1
  > always {!<=-1,!>=2}
  3 always 3
Line 734
  ( always {!<=-1,!>=2}
Line 735
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsTemplateArg always 8388608
Line 737
  value always {!<=-1,!>=2}
Line 738
  fIsTemplateArg always 8388608
  value always {!<=-1,!>=2}
Line 742
  ( always !0
  & {lifetime[Address]=(pattern),!0}
Line 743
  1 always 1
Line 748
  ( always !0
  & {lifetime[Address]=(pattern),!0}
Line 749
  1 always 1
Line 753
  , always 0
  = always 0
  0 always 0
Line 754
  , always 0
  = always 0
  0 always 0
Line 757
  ( always !0
  & {lifetime[Address]=(pattern),!0}
Line 758
  1 always 1
Line 760
  , always !<=-1
  pattern_len always !<=-1
Line 761
  pattern_len always !<=-1
Line 764
  ( always !0
  & {lifetime[Address]=(pattern),!0}
Line 765
  1 always 1
Line 767
  , always !<=-1
  pattern_len always !<=-1
Line 768
  pattern_len always !<=-1
Line 771
  , always 0
  = always 0
  0 always 0
Line 772
  varId possible 0
Line 774
  , always 0
  = always 0
  0 always 0
Line 775
  varId possible 0
Line 837
  , always 0
  = always 0
  false always 0
Line 841
  true always 1
Line 853
  = possible 0
  id possible 0
Line 854
  != always {!<=-1,!>=2}
  0 always 0
Line 855
  eVariable always 0
Line 856
  false always 0
Line 864
  . always !0
Line 877
  = always 0
  nullptr always 0
Line 892
  = always 5
  5 always 5
Line 904
  varid always {!<=-1,!>=2}
  varid always {!<=-1,!>=2}
  = always 0
  false always 0
Line 905
  exprid always {!<=-1,!>=2}
  exprid always {!<=-1,!>=2}
  = always 0
  false always 0
Line 906
  idtype always {!<=-1,!>=2}
  idtype always {!<=-1,!>=2}
  = always 0
  false always 0
Line 907
  attributes always {!<=-1,!>=2}
  attributes always {!<=-1,!>=2}
  = always 0
  false always 0
Line 908
  macro always {!<=-1,!>=2}
  macro always {!<=-1,!>=2}
  = always 0
  false always 0
Line 909
  linenumbers always {!<=-1,!>=2}
  linenumbers always {!<=-1,!>=2}
  = always 0
  false always 0
Line 910
  linebreaks always {!<=-1,!>=2}
  linebreaks always {!<=-1,!>=2}
  = always 0
  false always 0
Line 911
  files always {!<=-1,!>=2}
  files always {!<=-1,!>=2}
  = always 0
  false always 0
Line 914
  . always {!<=-1,!>=2}
  attributes always {!<=-1,!>=2}
  = always 1
  true always 1
Line 915
  . always {!<=-1,!>=2}
  macro always {!<=-1,!>=2}
  = always 1
  true always 1
Line 916
  . always {!<=-1,!>=2}
  linenumbers always {!<=-1,!>=2}
  = always 1
  true always 1
Line 917
  . always {!<=-1,!>=2}
  linebreaks always {!<=-1,!>=2}
  = always 1
  true always 1
Line 918
  . always {!<=-1,!>=2}
  files always {!<=-1,!>=2}
  = always 1
  true always 1
Line 923
  . always {!<=-1,!>=2}
  varid always {!<=-1,!>=2}
  = always 1
  true always 1
Line 928
  . always {!<=-1,!>=2}
  exprid always {!<=-1,!>=2}
  = always 1
  true always 1
Line 933
  . always {!<=-1,!>=2}
  exprid always {!<=-1,!>=2}
  = always 1
  true always 1
Line 934
  . always {!<=-1,!>=2}
  varid always {!<=-1,!>=2}
  = always 1
  true always 1
Line 935
  . always {!<=-1,!>=2}
  idtype always {!<=-1,!>=2}
  = always 1
  true always 1
Line 950
  , always 0
  = always 0
  nullptr always 0
  , always 0
  = always 0
  nullptr always 0
Line 951
  , always 1
  = always 1
  true always 1
Line 952
  = always 0
  false always 0
Line 965
  = always 0
  nullptr always 0
  , always 0
  = always 0
  nullptr always 0
Line 983
  = possible 0@89
  linkToToken possible 0@89
Line 984
  mStr possible size=1
  == always {!<=-1,!>=2}
  "<" always "<"
  || always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  ">" always ">"
Line 1026
  mTokType possible 19
  == {!<=-1,!>=2,0}
  eFunction always 2
  || always {!<=-1,!>=2}
  mTokType always !2
  == always {!<=-1,!>=2}
  eLambda always 19
  : always 0
  nullptr always 0
Line 1034
  = possible 0
  v possible 0
Line 1035
  || always {!<=-1,!>=2}
Line 1036
  eVariable always 0
Line 1037
  == always {!<=-1,!>=2}
  eVariable always 0
Line 1038
  eName always 4
Line 1045
  == always {!<=-1,!>=2}
  eVariable always 0
  ? possible 0
  : always 0
  nullptr always 0
Line 1058
  == always {!<=-1,!>=2}
  eType always 1
  ? possible 0
  : always 0
  nullptr always 0
Line 1061
  , always 0
  = always 0
  nullptr always 0
Line 1071
  == always {!<=-1,!>=2}
  eEnumerator always 10
  ? possible 0
  : always 0
  nullptr always 0
Line 1079
  = possible 0
  e possible 0
Line 1081
  eEnumerator always 10
Line 1082
  == always {!<=-1,!>=2}
  eEnumerator always 10
Line 1083
  eName always 4
Line 1152
  . always !0
Line 1156
  . always !0
Line 1163
  && always {!<=-1,!>=2}
Line 1164
  ! always {!<=-1,!>=2}
Line 1170
  ( always {!<=-1,!>=2}
Line 1171
  ( always {!<=-1,!>=2}
Line 1172
  ( always {!<=-1,!>=2}
Line 1173
  ( always {!<=-1,!>=2}
Line 1182
  = always 0
  0 always 0
Line 1197
  ( always {!<=-1,!>=2}
Line 1199
  ( always {!<=-1,!>=2}
Line 1213
  = possible 0@82
  nextToken possible 0@82
Line 1227
  ( always {!<=-1,!>=2}
Line 1243
  fIsUnsigned always 1
  = always 1
  1 always 1
  << always 1
  0 always 0
  , always 2
Line 1244
  fIsSigned always 2
  = always 2
  1 always 1
  << always 2
  1 always 1
  , always 4
Line 1245
  fIsPointerCompare always 4
  = always 4
  1 always 1
  << always 4
  2 always 2
  , always 8
Line 1246
  fIsLong always 8
  = always 8
  1 always 1
  << always 8
  3 always 3
  , always 16
Line 1247
  fIsStandardType always 16
  = always 16
  1 always 1
  << always 16
  4 always 4
  , always 32
Line 1248
  fIsExpandedMacro always 32
  = always 32
  1 always 1
  << always 32
  5 always 5
  , always 64
Line 1249
  fIsCast always 64
  = always 64
  1 always 1
  << always 64
  6 always 6
  , always 128
Line 1250
  fIsAttributeConstructor always 128
  = always 128
  1 always 1
  << always 128
  7 always 7
  , always 256
Line 1251
  fIsAttributeDestructor always 256
  = always 256
  1 always 1
  << always 256
  8 always 8
  , always 512
Line 1252
  fIsAttributeUnused always 512
  = always 512
  1 always 1
  << always 512
  9 always 9
  , always 1024
Line 1253
  fIsAttributePure always 1024
  = always 1024
  1 always 1
  << always 1024
  10 always 10
  , always 2048
Line 1254
  fIsAttributeConst always 2048
  = always 2048
  1 always 1
  << always 2048
  11 always 11
  , always 4096
Line 1255
  fIsAttributeNoreturn always 4096
  = always 4096
  1 always 1
  << always 4096
  12 always 12
  , always 8192
Line 1256
  fIsAttributeNothrow always 8192
  = always 8192
  1 always 1
  << always 8192
  13 always 13
  , always 16384
Line 1257
  fIsAttributeUsed always 16384
  = always 16384
  1 always 1
  << always 16384
  14 always 14
  , always 32768
Line 1258
  fIsAttributePacked always 32768
  = always 32768
  1 always 1
  << always 32768
  15 always 15
  , always 65536
Line 1259
  fIsAttributeMaybeUnused always 65536
  = always 65536
  1 always 1
  << always 65536
  16 always 16
  , always 131072
Line 1260
  fIsControlFlowKeyword always 131072
  = always 131072
  1 always 1
  << always 131072
  17 always 17
  , always 262144
Line 1261
  fIsOperatorKeyword always 262144
  = always 262144
  1 always 1
  << always 262144
  18 always 18
  , always 524288
Line 1262
  fIsComplex always 524288
  = always 524288
  1 always 1
  << always 524288
  19 always 19
  , always 1048576
Line 1263
  fIsEnumType always 1048576
  = always 1048576
  1 always 1
  << always 1048576
  20 always 20
  , always 2097152
Line 1264
  fIsName always 2097152
  = always 2097152
  1 always 1
  << always 2097152
  21 always 21
  , always 4194304
Line 1265
  fIsLiteral always 4194304
  = always 4194304
  1 always 1
  << always 4194304
  22 always 22
  , always 8388608
Line 1266
  fIsTemplateArg always 8388608
  = always 8388608
  1 always 1
  << always 8388608
  23 always 23
  , always 16777216
Line 1267
  fIsAttributeNodiscard always 16777216
  = always 16777216
  1 always 1
  << always 16777216
  24 always 24
  , always 33554432
Line 1268
  fAtAddress always 33554432
  = always 33554432
  1 always 1
  << always 33554432
  25 always 25
  , always 67108864
Line 1269
  fIncompleteVar always 67108864
  = always 67108864
  1 always 1
  << always 67108864
  26 always 26
  , always 134217728
Line 1270
  fConstexpr always 134217728
  = always 134217728
  1 always 1
  << always 134217728
  27 always 27
  , always 268435456
Line 1271
  fExternC always 268435456
  = always 268435456
  1 always 1
  << always 268435456
  28 always 28
  , always 536870912
Line 1272
  fIsSplitVarDeclComma always 536870912
  = always 536870912
  1 always 1
  << always 536870912
  29 always 29
  , always 1073741824
Line 1273
  fIsSplitVarDeclEq always 1073741824
  = always 1073741824
  1 always 1
  << always 1073741824
  30 always 30
  , always 2147483648
Line 1274
  fIsImplicitInt always 2147483648
  = always 2147483648
  1U always 1
  << always 2147483648
  31 always 31
  , always 4294967296
Line 1275
  fIsInline always 4294967296
  = always 4294967296
  1ULL always 1
  << always 4294967296
  32 always 32
  , always 8589934592
Line 1276
  fIsTemplate always 8589934592
  = always 8589934592
  1ULL always 1
  << always 8589934592
  33 always 33
  , always 17179869184
Line 1277
  fIsSimplifedScope always 17179869184
  = always 17179869184
  1ULL always 1
  << always 17179869184
  34 always 34
  , always 34359738368
Line 1278
  fIsRemovedVoidParameter always 34359738368
  = always 34359738368
  1ULL always 1
  << always 34359738368
  35 always 35
  , always 68719476736
Line 1279
  fIsIncompleteConstant always 68719476736
  = always 68719476736
  1ULL always 1
  << always 68719476736
  36 always 36
Line 1284
  mFlags always !<=-1
Line 1293
  ( always {!<=-1,!>=2}
  flag_ always !<=-1
Line 1294
  return always {!<=-1,!>=2}
  mFlags always !<=-1
  & always !<=-1
  flag_ {!<=-1,8388608@37,17179869184@48,8589934592@50,34359738368@52,4294967296@54,2147483648@56,1073741824@58,536870912@60,268435456@62}
  != always {!<=-1,!>=2}
  0 always 0
Line 1302
  flag_ always !<=-1
  state_ always {!<=-1,!>=2}
Line 1303
  mFlags always !<=-1
  = always !<=-1
  state_ {!<=-1,!>=2,0@114,1@114,symbolic=(mTokType==eName||mTokType==eType||mTokType==eVariable||mTokType==eFunction||mTokType==eKeyword||mTokType==eBoolean||mTokType==eEnumerator)@126,symbolic=(mTokType==eNumber||mTokType==eString||mTokType==eChar||mTokType==eBoolean||mTokType==eLiteral||mTokType==eEnumerator)@127}
  ? always !<=-1
  mFlags always !<=-1
  | always !<=-1
  flag_ {!<=-1,131072@114,8388608@36,17179869184@47,8589934592@49,34359738368@51,4294967296@53,2147483648@55,1073741824@57,536870912@59}
  : always !<=-1
  mFlags always !<=-1
  & always !<=-1
  ~ always !<=0
  flag_ {!<=-1,131072@114,8388608@36,17179869184@47,8589934592@49,34359738368@51,4294967296@53,2147483648@55,1073741824@57,536870912@59}
Line 1317
  , always 0
  = always 0
  0 always 0
  , always 0
  = always 0
  0 always 0
Line 1343
  ! always {!<=-1,!>=2}
Line 1344
  nullptr always 0
Line 1345
  this {!0,symbolic=(astParent()->astOperand2())}
  == always {!<=-1,!>=2}
  ( always !0
Line 1346
  ( always !0
Line 1347
  this always {!0,!symbolic=(astParent()->astOperand1())}
  == always {!<=-1,!>=2}
  ( always !0
Line 1348
  ( always !0
Line 1349
  nullptr always 0
Line 1353
  ! always {!<=-1,!>=2}
Line 1354
  nullptr always 0
Line 1355
  this {!0,symbolic=(astParent()->astOperand2())}
  == always {!<=-1,!>=2}
  ( always !0
Line 1356
  ( always !0
Line 1357
  this always {!0,!symbolic=(astParent()->astOperand1())}
  == always {!<=-1,!>=2}
  ( always !0
Line 1358
  ( always !0
Line 1359
  nullptr always 0
Line 1363
  = always !0
  this always !0
Line 1364
  ret possible symbolic=(this)
Line 1365
  = always !0
  . always !0
Line 1366
  ret possible symbolic=(this)
Line 1370
  = always !0
  this always !0
Line 1371
  ret possible symbolic=(this)
Line 1372
  = always !0
  . always !0
Line 1373
  ret possible symbolic=(this)
Line 1385
  ( always {!<=-1,!>=2}
Line 1388
  = always 0
  = always 0
  = always 0
  nullptr always 0
Line 1393
  = always 0
  nullptr always 0
Line 1396
  = always ""
  "" always ""
Line 1402
  sep possible {" "@230,""}
Line 1418
  cpp11init always {!<=-1,!>=2}
Line 1419
  = possible {1,2}
  cpp11init always {!<=-1,!>=2}
  ? possible {1,2}
  :: always 1
  CPP11INIT always 1
  : always 2
  :: always 2
  NOINIT always 2
Line 36
  AST always 0
  SYNTAX always 1
  UNKNOWN_MACRO always 2
  INTERNAL always 3
  LIMIT always 4
  INSTANTIATION always 5
Line 37
  = always 3
  INTERNAL always 3
Line 47
  normal always 0
  inconclusive always 1
  safe always 2
  experimental always 3
Line 54
  unusedFunction always 0
  missingInclude always 1
  internalCheck always 2
Line 68
  none always 0
Line 74
  error always 1
Line 80
  warning always 2
Line 87
  style always 3
Line 93
  performance always 4
Line 101
  portability always 5
Line 108
  information always 6
Line 113
  debug always 7
Line 121
  ( possible lifetime[SubObject]=(cweId)
  cweId always !<=-1
  id always !<=-1
  cweId always !<=-1
Line 122
  id always !<=-1
Line 38
  C89 always 0
  C99 always 1
  C11 always 2
  CLatest always 2
  = always 2
  C11 always 2
Line 41
  CPP03 always 0
  CPP11 always 1
  CPP14 always 2
  CPP17 always 3
  CPP20 always 4
  CPP23 always 5
  CPPLatest always 5
  = always 5
  CPP23 always 5
Line 47
  CLatest always 2
  CPPLatest always 5
Line 49
  ( always {!<=-1,!>=2}
Line 50
  = possible size=3
  str possible size=3
Line 51
  str possible size=3
  == always {!<=-1,!>=2}
  "c89" always "c89"
  || always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  "C89" always "C89"
Line 52
  = always 0
  C89 always 0
Line 53
  return always {!<=-1,!>=2}
  true always 1
Line 55
  str possible size=3
  == always {!<=-1,!>=2}
  "c99" always "c99"
  || always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  "C99" always "C99"
Line 56
  = always 1
  C99 always 1
Line 57
  return always {!<=-1,!>=2}
  true always 1
Line 59
  str possible size=3
  == always {!<=-1,!>=2}
  "c11" always "c11"
  || always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  "C11" always "C11"
Line 60
  = always 2
  C11 always 2
Line 61
  return always {!<=-1,!>=2}
  true always 1
Line 63
  return always {!<=-1,!>=2}
  false always 0
Line 67
  C89 always 0
Line 68
  "c89" always "c89"
Line 69
  C99 always 1
Line 70
  "c99" always "c99"
Line 71
  C11 always 2
Line 72
  "c11" always "c11"
Line 74
  "" always ""
Line 77
  std possible size=3
  == always {!<=-1,!>=2}
  "c89" always "c89"
Line 78
  :: always 0
  C89 always 0
Line 80
  std possible size=3
  == always {!<=-1,!>=2}
  "c99" always "c99"
Line 81
  :: always 1
  C99 always 1
Line 83
  == always {!<=-1,!>=2}
  "c11" always "c11"
Line 84
  :: always 2
  C11 always 2
Line 86
  :: always 2
  CLatest always 2
Line 88
  ( always {!<=-1,!>=2}
Line 92
  return always {!<=-1,!>=2}
  ! {!<=-1,!>=2,0}
  stdValue possible size=0
  ( {!<=-1,!>=2,1}
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
Line 99
  CPP03 always 0
Line 100
  "c++03" always "c++03"
Line 101
  CPP11 always 1
Line 102
  "c++11" always "c++11"
Line 103
  CPP14 always 2
Line 104
  "c++14" always "c++14"
Line 105
  CPP17 always 3
Line 106
  "c++17" always "c++17"
Line 107
  CPP20 always 4
Line 108
  "c++20" always "c++20"
Line 109
  CPP23 always 5
Line 110
  "c++23" always "c++23"
Line 112
  "" always ""
Line 115
  std possible size=5
  == always {!<=-1,!>=2}
  "c++03" always "c++03"
Line 116
  :: always 0
  CPP03 always 0
Line 118
  std possible size=5
  == always {!<=-1,!>=2}
  "c++11" always "c++11"
Line 119
  :: always 1
  CPP11 always 1
Line 121
  std possible size=5
  == always {!<=-1,!>=2}
  "c++14" always "c++14"
Line 122
  :: always 2
  CPP14 always 2
Line 124
  std possible size=5
  == always {!<=-1,!>=2}
  "c++17" always "c++17"
Line 125
  :: always 3
  CPP17 always 3
Line 127
  std possible size=5
  == always {!<=-1,!>=2}
  "c++20" always "c++20"
Line 128
  :: always 4
  CPP20 always 4
Line 130
  == always {!<=-1,!>=2}
  "c++23" always "c++23"
Line 131
  :: always 5
  CPP23 always 5
Line 133
  :: always 5
  CPPLatest always 5
Line 58
  OK always 0
  FILE_NOT_FOUND always 1
  BAD_XML always 2
  UNKNOWN_ELEMENT always 3
  MISSING_ATTRIBUTE always 4
  BAD_ATTRIBUTE_VALUE always 5
  UNSUPPORTED_FORMAT always 6
  DUPLICATE_PLATFORM_TYPE always 7
  PLATFORM_TYPE_REDEFINED always 8
Line 62
  :: always 0
  OK always 0
Line 63
  ( possible lifetime[SubObject]=(e)
Line 65
  ( possible lifetime[SubObject]=(e)
  && always {!<=-1,!>=2}
Line 74
  ( always {!<=-1,!>=2}
  , always !<=-1
  len always !<=-1
Line 79
  none always 0
  malloc always 1
  calloc always 2
  strdup always 3
Line 84
  initData always {!<=-1,!>=2}
Line 118
  ? possible 0
  af always !0
  : always 0
  0 always 0
Line 124
  ? possible 0
  af always !0
  : always 0
  0 always 0
Line 138
  , always 1
  = always 1
  1 always 1
Line 141
  = possible 1
  reallocArg possible 1
Line 145
  , always {!<=-1,!>=2}
  noreturn always {!<=-1,!>=2}
Line 146
  = possible {1,0}
  noreturn always {!<=-1,!>=2}
  ? possible {1,0}
  :: always 1
  True always 1
  : always 0
  :: always 0
  False always 0
Line 149
  ( always {!<=-1,!>=2}
Line 152
  ( always {!<=-1,!>=2}
Line 153
  return always {!<=-1,!>=2}
  > always {!<=-1,!>=2}
  0 always 0
  && always {!<=-1,!>=2}
  id {>=1,!<=0}
  & possible {0,1}
  1 always 1
  == {1,0,!<=-1,!>=2}
  0 always 0
Line 155
  ( always {!<=-1,!>=2}
Line 156
  return always {!<=-1,!>=2}
  > always {!<=-1,!>=2}
  0 always 0
  && always {!<=-1,!>=2}
  . {>=1,!<=0}
  & possible {0,1}
  1 always 1
  == {1,0,!<=-1,!>=2}
  0 always 0
Line 160
  ( always {!<=-1,!>=2}
Line 161
  return always {!<=-1,!>=2}
  > always {!<=-1,!>=2}
  0 always 0
  && always {!<=-1,!>=2}
  id {>=1,!<=0}
  & possible {0,1}
  1 always 1
  == {0,1,!<=-1,!>=2}
  1 always 1
Line 163
  ( always {!<=-1,!>=2}
Line 164
  return always {!<=-1,!>=2}
  > always {!<=-1,!>=2}
  0 always 0
  && always {!<=-1,!>=2}
  . {>=1,!<=0}
  & possible {0,1}
  1 always 1
  == {0,1,!<=-1,!>=2}
  1 always 1
Line 167
  ( always {!<=-1,!>=2}
Line 169
  ( always {!<=-1,!>=2}
Line 170
  ( always {!<=-1,!>=2}
Line 190
  ( always {!<=-1,!>=2}
Line 191
  ( always {!<=-1,!>=2}
Line 193
  NONE always 0
  DEFAULT always 1
  ERROR_CODE always 2
Line 201
  ( always {!<=-1,!>=2}
Line 202
  ( always {!<=-1,!>=2}
Line 204
  ( always {!<=-1,!>=2}
Line 209
  -1 always -1
Line 210
  -1 always -1
Line 211
  arrayLike_indexOp always {!<=-1,!>=2}
  false always 0
Line 212
  stdStringLike always {!<=-1,!>=2}
  false always 0
Line 213
  stdAssociativeLike always {!<=-1,!>=2}
  false always 0
Line 214
  opLessAllowed always {!<=-1,!>=2}
  true always 1
Line 215
  hasInitializerListConstructor always {!<=-1,!>=2}
  false always 0
Line 216
  unstableErase always {!<=-1,!>=2}
  false always 0
Line 217
  unstableInsert always {!<=-1,!>=2}
  false always 0
Line 218
  view always {!<=-1,!>=2}
  false always 0
Line 222
  RESIZE always 0
Line 223
  CLEAR always 1
Line 224
  PUSH always 2
Line 225
  POP always 3
Line 226
  FIND always 4
Line 227
  INSERT always 5
Line 228
  ERASE always 6
Line 229
  CHANGE_CONTENT always 7
Line 230
  CHANGE always 8
Line 231
  CHANGE_INTERNAL always 9
Line 232
  NO_ACTION always 10
Line 235
  AT_INDEX always 0
Line 236
  ITEM always 1
Line 237
  BUFFER always 2
Line 238
  BUFFER_NT always 3
Line 239
  START_ITERATOR always 4
Line 240
  END_ITERATOR always 5
Line 241
  ITERATOR always 6
Line 242
  SIZE always 7
Line 243
  EMPTY always 8
Line 244
  NO_YIELD always 9
Line 259
  arrayLike_indexOp always {!<=-1,!>=2}
Line 260
  stdStringLike always {!<=-1,!>=2}
Line 261
  stdAssociativeLike always {!<=-1,!>=2}
Line 262
  opLessAllowed always {!<=-1,!>=2}
Line 263
  hasInitializerListConstructor always {!<=-1,!>=2}
Line 264
  unstableErase always {!<=-1,!>=2}
Line 265
  unstableInsert always {!<=-1,!>=2}
Line 266
  view always {!<=-1,!>=2}
Line 269
  :: possible {symbolic=(functions.end()),end=0}
  i possible {symbolic=(functions.end()),end=0}
  = possible lifetime[Iterator]=(functions)
  ( possible lifetime[Iterator]=(functions)
Line 270
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(functions),end=0}
Line 271
  i always {!symbolic=(functions.end()),!end=0}
Line 272
  :: always 10
  NO_ACTION always 10
Line 276
  :: possible {symbolic=(functions.end()),end=0}
  i possible {symbolic=(functions.end()),end=0}
  = possible lifetime[Iterator]=(functions)
  ( possible lifetime[Iterator]=(functions)
Line 277
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(functions),end=0}
Line 278
  i always {!symbolic=(functions.end()),!end=0}
Line 279
  :: always 9
  NO_YIELD always 9
Line 286
  , always 0
  iterator always {!<=-1,!>=2}
  = always 0
  false always 0
Line 287
  , always 0
  = always 0
  nullptr always 0
Line 292
  notbool always {!<=-1,!>=2}
  false always 0
Line 293
  notnull always {!<=-1,!>=2}
  false always 0
Line 294
  -1 always -1
Line 295
  formatstr always {!<=-1,!>=2}
  false always 0
Line 296
  strz always {!<=-1,!>=2}
  false always 0
Line 297
  optional always {!<=-1,!>=2}
  false always 0
Line 298
  variadic always {!<=-1,!>=2}
  false always 0
Line 302
  notbool always {!<=-1,!>=2}
Line 303
  notnull always {!<=-1,!>=2}
Line 305
  formatstr always {!<=-1,!>=2}
Line 306
  strz always {!<=-1,!>=2}
Line 307
  optional always {!<=-1,!>=2}
Line 308
  variadic always {!<=-1,!>=2}
Line 313
  0 always 0
  it always {!<=-1,!>=2}
  false always 0
  first always {!<=-1,!>=2}
  false always 0
  last always {!<=-1,!>=2}
  false always 0
Line 316
  it always {!<=-1,!>=2}
Line 317
  first always {!<=-1,!>=2}
Line 318
  last always {!<=-1,!>=2}
Line 324
  NONE always 0
  STRLEN always 1
  ARGVALUE always 2
  SIZEOF always 3
  MUL always 4
  VALUE always 5
Line 325
  ( possible lifetime[SubObject]=(t)
  0 always 0
  0 always 0
Line 334
  DIR_IN always 0
Line 335
  DIR_OUT always 1
Line 336
  DIR_INOUT always 2
Line 337
  DIR_UNKNOWN always 3
Line 344
  use always {!<=-1,!>=2}
Line 345
  leakignore always {!<=-1,!>=2}
Line 346
  isconst always {!<=-1,!>=2}
Line 347
  ispure always {!<=-1,!>=2}
Line 349
  ignore always {!<=-1,!>=2}
Line 350
  formatstr always {!<=-1,!>=2}
Line 351
  formatstr_scan always {!<=-1,!>=2}
Line 352
  formatstr_secure always {!<=-1,!>=2}
Line 356
  use always {!<=-1,!>=2}
  false always 0
Line 357
  leakignore always {!<=-1,!>=2}
  false always 0
Line 358
  isconst always {!<=-1,!>=2}
  false always 0
Line 359
  ispure always {!<=-1,!>=2}
  false always 0
Line 360
  :: always 0
  NONE always 0
Line 361
  ignore always {!<=-1,!>=2}
  false always 0
Line 362
  formatstr always {!<=-1,!>=2}
  false always 0
Line 363
  formatstr_scan always {!<=-1,!>=2}
  false always 0
Line 364
  formatstr_secure always {!<=-1,!>=2}
  false always 0
Line 365
  :: always 10
  NO_ACTION always 10
Line 366
  :: always 9
  NO_YIELD always 9
Line 372
  ( always {!<=-1,!>=2}
Line 373
  ( always {!<=-1,!>=2}
Line 374
  ( always {!<=-1,!>=2}
  , always {!<=-1,!>=2}
  pure always {!<=-1,!>=2}
Line 375
  ( always {!<=-1,!>=2}
Line 377
  ( always {!<=-1,!>=2}
Line 379
  return always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  arg always !0
  . always {!<=-1,!>=2}
  notbool always {!<=-1,!>=2}
Line 382
  ( always {!<=-1,!>=2}
Line 383
  ( always {!<=-1,!>=2}
  , always 0
  = always 0
  0 always 0
  , always 0
  = always 0
  nullptr always 0
Line 385
  ( always {!<=-1,!>=2}
Line 387
  return always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  arg always !0
  . always {!<=-1,!>=2}
  formatstr always {!<=-1,!>=2}
Line 390
  ( always {!<=-1,!>=2}
Line 392
  return always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  arg always !0
  . always {!<=-1,!>=2}
  strz always {!<=-1,!>=2}
Line 395
  ( always {!<=-1,!>=2}
Line 396
  ( always {!<=-1,!>=2}
Line 400
  arg always !0
Line 404
  le always 0
  lt always 1
  eq always 2
  ge always 3
  gt always 4
  range always 5
Line 407
  ( always {!<=-1,!>=2}
Line 408
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 414
  && always {!<=-1,!>=2}
  arg always !0
  . always {!<=-1,!>=2}
  it always {!<=-1,!>=2}
  & {lifetime[Address]=(arg->iteratorInfo),!0}
  arg always !0
  nullptr always 0
Line 417
  ( always {!<=-1,!>=2}
Line 421
  ? possible 0
  & {lifetime[Address]=(arg->minsizes),!0}
  arg always !0
  nullptr always 0
Line 426
  ( always {!<=-1,!>=2}
Line 428
  ( always {!<=-1,!>=2}
Line 434
  ( always {!<=-1,!>=2}
Line 436
  ( always {!<=-1,!>=2}
Line 438
  ( always {!<=-1,!>=2}
Line 445
  ( always {!<=-1,!>=2}
Line 447
  ( always {!<=-1,!>=2}
Line 448
  return always {!<=-1,!>=2}
  ( possible lifetime[Iterator]=(mExporters)
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(mExporters),end=0}
Line 451
  ( always {!<=-1,!>=2}
Line 452
  = possible lifetime[Iterator]=(mExporters)
  ( possible lifetime[Iterator]=(mExporters)
Line 453
  return always {!<=-1,!>=2}
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(mExporters),end=0}
  && always {!<=-1,!>=2}
  it always {!symbolic=(mExporters.end()),!end=0}
Line 456
  ( always {!<=-1,!>=2}
Line 457
  = possible lifetime[Iterator]=(mExporters)
  ( possible lifetime[Iterator]=(mExporters)
Line 458
  return always {!<=-1,!>=2}
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(mExporters),end=0}
  && always {!<=-1,!>=2}
  it always {!symbolic=(mExporters.end()),!end=0}
Line 461
  ( always {!<=-1,!>=2}
Line 466
  ( always {!<=-1,!>=2}
Line 467
  return always {!<=-1,!>=2}
  ( possible lifetime[Iterator]=(mReflection)
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(mReflection),end=0}
Line 471
  :: possible {symbolic=(mReflection.end()),end=0}
  it possible {symbolic=(mReflection.end()),end=0}
  = possible lifetime[Iterator]=(mReflection)
  ( possible lifetime[Iterator]=(mReflection)
Line 472
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(mReflection),end=0}
Line 473
  it always {!symbolic=(mReflection.end()),!end=0}
Line 474
  -1 always -1
Line 480
  = always ""
  "" always ""
Line 481
  unique always {!<=-1,!>=2}
  unique always {!<=-1,!>=2}
  = always 0
  false always 0
Line 485
  ( always {!<=-1,!>=2}
Line 489
  size always !<=-1
Line 491
  NO always 0
  BOOL always 1
  CHAR always 2
  SHORT always 3
  INT always 4
  LONG always 5
  LONGLONG always 6
Line 494
  = possible lifetime[Iterator]=(mPodTypes)
  ( possible lifetime[Iterator]=(mPodTypes)
Line 495
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(mPodTypes),end=0}
  & {lifetime[Address]=(it->second),!0}
  it always {!symbolic=(mPodTypes.end()),!end=0}
  nullptr always 0
Line 500
  mSigned always {!<=-1,!>=2}
  false always 0
Line 501
  mUnsigned always {!<=-1,!>=2}
  false always 0
Line 502
  mLong always {!<=-1,!>=2}
  false always 0
Line 503
  mPointer always {!<=-1,!>=2}
  false always 0
Line 504
  mPtrPtr always {!<=-1,!>=2}
  false always 0
Line 505
  mConstPtr always {!<=-1,!>=2}
  false always 0
Line 506
  ( always {!<=-1,!>=2}
Line 507
  return always {!<=-1,!>=2}
  mSigned always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  . always {!<=-1,!>=2}
  mSigned always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 508
  mUnsigned always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  . always {!<=-1,!>=2}
  mUnsigned always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 509
  mLong always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  . always {!<=-1,!>=2}
  mLong always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 510
  mPointer always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  . always {!<=-1,!>=2}
  mPointer always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 511
  mPtrPtr always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  . always {!<=-1,!>=2}
  mPtrPtr always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 512
  mConstPtr always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  . always {!<=-1,!>=2}
  mConstPtr always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 513
  == always {!<=-1,!>=2}
Line 515
  ( always {!<=-1,!>=2}
Line 516
  return always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  this always !0
  == always {!<=-1,!>=2}
Line 519
  mSigned always {!<=-1,!>=2}
Line 520
  mUnsigned always {!<=-1,!>=2}
Line 521
  mLong always {!<=-1,!>=2}
Line 522
  mPointer always {!<=-1,!>=2}
Line 523
  mPtrPtr always {!<=-1,!>=2}
Line 524
  mConstPtr always {!<=-1,!>=2}
Line 529
  = possible lifetime[Iterator]=(mPlatformTypes)
  ( possible lifetime[Iterator]=(mPlatformTypes)
Line 530
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(mPlatformTypes),end=0}
  & {lifetime[Address]=(it->second),!0}
  it always {!symbolic=(mPlatformTypes.end()),!end=0}
  nullptr always 0
Line 536
  :: possible {symbolic=(mPlatforms.end()),end=0}
  it possible {symbolic=(mPlatforms.end()),end=0}
  = possible lifetime[Iterator]=(mPlatforms)
  ( possible lifetime[Iterator]=(mPlatforms)
Line 537
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(mPlatforms),end=0}
Line 538
  it always {!symbolic=(mPlatforms.end()),!end=0}
Line 540
  type always !0
Line 543
  = possible lifetime[Iterator]=(mPlatformTypes)
  ( possible lifetime[Iterator]=(mPlatformTypes)
Line 544
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(mPlatformTypes),end=0}
  & {lifetime[Address]=(it2->second),!0}
  it2 always {!symbolic=(mPlatformTypes.end()),!end=0}
  nullptr always 0
Line 552
  ( always {!<=-1,!>=2}
  , always ""
  = always ""
  "" always ""
Line 555
  def always 0
  check always 1
  suppress always 2
Line 570
  ( always {!<=-1,!>=2}
Line 571
  return always {!<=-1,!>=2}
  ( possible lifetime[Iterator]=(mPrefixes)
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(mPrefixes),end=0}
Line 573
  ( always {!<=-1,!>=2}
Line 574
  return always {!<=-1,!>=2}
  ( possible lifetime[Iterator]=(mSuffixes)
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(mSuffixes),end=0}
Line 583
  0 always 0
Line 606
  ( always {!<=-1,!>=2}
Line 607
  return always {!<=-1,!>=2}
  ( possible lifetime[Iterator]=(mBlocks)
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(mBlocks),end=0}
Line 616
  False always 0
  True always 1
  Maybe always 2
Line 646
  = possible lifetime[Iterator]=(data)
  ( possible lifetime[Iterator]=(data)
Line 647
  == always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(data),end=0}
  nullptr always 0
  & {lifetime[Address]=(it->second),!0}
  it always {!symbolic=(data.end()),!end=0}
Line 655
  = always 0
  nullptr always 0
Line 55
  Public always 0
  Protected always 1
  Private always 2
  Global always 3
  Namespace always 4
  Argument always 5
  Local always 6
  Throw always 7
Line 61
  nullptr always 0
  0 always 0
  known always {!<=-1,!>=2}
  true always 1
Line 65
  known always {!<=-1,!>=2}
Line 75
  Unknown always 0
  True always 1
  False always 2
Line 81
  nullptr always 0
  nullptr always 0
  :: always 0
  Public always 0
  isVirtual always {!<=-1,!>=2}
  false always 0
Line 87
  isVirtual always {!<=-1,!>=2}
Line 89
  ( always {!<=-1,!>=2}
Line 90
  return always {!<=-1,!>=2}
  this always !0
  < always {!<=-1,!>=2}
Line 96
  nullptr always 0
  nullptr always 0
  nullptr always 0
Line 110
  = always 0
  nullptr always 0
  = always 0
  nullptr always 0
  = always 0
  nullptr always 0
Line 111
  classDef_ inconclusive 0
Line 115
  nullptr always 0
Line 116
  nullptr always 0
Line 117
  0 always 0
Line 118
  classDef_ possible 0
  && always {!<=-1,!>=2}
  classDef_ always !0
  == always {!<=-1,!>=2}
  "enum" always "enum"
Line 119
  = always 1
  :: always 1
  True always 1
Line 120
  classDef_ possible 0
  && always {!<=-1,!>=2}
  classDef_ always !0
  == always {!<=-1,!>=2}
  "using" always "using"
Line 121
  3 always 3
Line 123
  && always {!<=-1,!>=2}
  ( always !0
  != always {!<=-1,!>=2}
  ";" always ";"
Line 124
  = always !0
  ( always !0
Line 131
  classDef always !0
Line 134
  ( always {!<=-1,!>=2}
Line 135
  ( always {!<=-1,!>=2}
Line 136
  ( always {!<=-1,!>=2}
Line 137
  ( always {!<=-1,!>=2}
Line 139
  ( always {!<=-1,!>=2}
Line 140
  return always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  classDef always !0
  == always {!<=-1,!>=2}
  "using" always "using"
Line 152
  ( always {!<=-1,!>=2}
  = always 0
  nullptr always 0
Line 159
  ( always {!<=-1,!>=2}
Line 161
  ( always {!<=-1,!>=2}
Line 166
  nullptr always 0
  0 always 0
  nullptr always 0
  nullptr always 0
  value_known always {!<=-1,!>=2}
  false always 0
Line 172
  value_known always {!<=-1,!>=2}
Line 179
  fIsMutable always 1
  = always 1
  1 always 1
  << always 1
  0 always 0
  , always 2
Line 180
  fIsStatic always 2
  = always 2
  1 always 1
  << always 2
  1 always 1
  , always 4
Line 181
  fIsConst always 4
  = always 4
  1 always 1
  << always 4
  2 always 2
  , always 8
Line 182
  fIsExtern always 8
  = always 8
  1 always 1
  << always 8
  3 always 3
  , always 16
Line 183
  fIsClass always 16
  = always 16
  1 always 1
  << always 16
  4 always 4
  , always 32
Line 184
  fIsArray always 32
  = always 32
  1 always 1
  << always 32
  5 always 5
  , always 64
Line 185
  fIsPointer always 64
  = always 64
  1 always 1
  << always 64
  6 always 6
  , always 128
Line 186
  fIsReference always 128
  = always 128
  1 always 1
  << always 128
  7 always 7
  , always 256
Line 187
  fIsRValueRef always 256
  = always 256
  1 always 1
  << always 256
  8 always 8
  , always 512
Line 188
  fHasDefault always 512
  = always 512
  1 always 1
  << always 512
  9 always 9
  , always 1024
Line 189
  fIsStlType always 1024
  = always 1024
  1 always 1
  << always 1024
  10 always 10
  , always 2048
Line 190
  fIsStlString always 2048
  = always 2048
  1 always 1
  << always 2048
  11 always 11
  , always 4096
Line 191
  fIsFloatType always 4096
  = always 4096
  1 always 1
  << always 4096
  12 always 12
  , always 8192
Line 192
  fIsVolatile always 8192
  = always 8192
  1 always 1
  << always 8192
  13 always 13
  , always 16384
Line 193
  fIsSmartPointer always 16384
  = always 16384
  1 always 1
  << always 16384
  14 always 14
  , always 32768
Line 194
  fIsMaybeUnused always 32768
  = always 32768
  1 always 1
  << always 32768
  15 always 15
  , always 65536
Line 195
  fIsInit always 65536
  = always 65536
  1 always 1
  << always 65536
  16 always 16
Line 203
  ( always {!<=-1,!>=2}
  flag_ always !<=-1
Line 204
  return always {!<=-1,!>=2}
  mFlags always !<=-1
  & always !<=-1
  flag_ {!<=-1,32768@212,4096@215,16384@220,2048@221,1024@222,65536@223,512@224,256@225,128@226}
  != always {!<=-1,!>=2}
  0 always 0
Line 212
  flag_ always !<=-1
  state_ always {!<=-1,!>=2}
Line 213
  mFlags always !<=-1
  = always !<=-1
  state_ always {!<=-1,!>=2}
  ? always !<=-1
  mFlags always !<=-1
  | always !<=-1
  flag_ always !<=-1
  : always !<=-1
  mFlags always !<=-1
  & always !<=-1
  ~ always !<=0
  flag_ always !<=-1
Line 222
  ( always {!<=-1,!>=2}
Line 233
  mFlags always !<=-1
  0 always 0
  , possible lifetime[SubObject]=(type_)
Line 234
  ( possible lifetime[SubObject]=(type_)
Line 236
  nullptr always 0
Line 300
  mNameToken always !0
Line 312
  mNameToken always !0
Line 314
  0 always 0
Line 329
  ( always {!<=-1,!>=2}
Line 330
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 0
  Public always 0
Line 337
  ( always {!<=-1,!>=2}
Line 338
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 1
  Protected always 1
Line 345
  ( always {!<=-1,!>=2}
Line 346
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 2
  Private always 2
Line 353
  ( always {!<=-1,!>=2}
Line 354
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 3
  Global always 3
Line 361
  ( always {!<=-1,!>=2}
Line 362
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 4
  Namespace always 4
Line 369
  ( always {!<=-1,!>=2}
Line 370
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 5
  Argument always 5
Line 377
  ( always {!<=-1,!>=2}
Line 378
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 385
  ( always {!<=-1,!>=2}
Line 386
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsMutable always 1
Line 393
  ( always {!<=-1,!>=2}
Line 394
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsVolatile always 8192
Line 401
  ( always {!<=-1,!>=2}
Line 402
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsStatic always 2
Line 409
  ( always {!<=-1,!>=2}
Line 410
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsExtern always 8
Line 417
  ( always {!<=-1,!>=2}
Line 418
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsConst always 4
Line 425
  ( always {!<=-1,!>=2}
Line 426
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 7
  Throw always 7
Line 433
  ( always {!<=-1,!>=2}
Line 434
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsClass always 16
Line 441
  ( always {!<=-1,!>=2}
Line 442
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsArray always 32
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsPointer always 64
Line 449
  ( always {!<=-1,!>=2}
Line 450
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsPointer always 64
Line 457
  ( always {!<=-1,!>=2}
Line 458
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsArray always 32
Line 465
  ( always {!<=-1,!>=2}
Line 471
  ( always {!<=-1,!>=2}
Line 472
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsArray always 32
  || always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsPointer always 64
Line 479
  ( always {!<=-1,!>=2}
Line 480
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsReference always 128
Line 487
  ( always {!<=-1,!>=2}
Line 488
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsRValueRef always 256
Line 495
  ( always {!<=-1,!>=2}
Line 501
  ( always {!<=-1,!>=2}
Line 502
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fHasDefault always 512
Line 509
  ( always {!<=-1,!>=2}
Line 510
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsInit always 65536
Line 526
  ? possible 0
  mType always !0
  : always 0
  nullptr always 0
Line 557
  ( always {!<=-1,!>=2}
Line 558
  return always {!<=-1,!>=2}
  . always {!<=-1,!>=2}
  known always {!<=-1,!>=2}
Line 569
  ( always {!<=-1,!>=2}
Line 570
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsStlType always 1024
Line 581
  ( always {!<=-1,!>=2}
Line 582
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsStlString always 2048
Line 585
  ( always {!<=-1,!>=2}
Line 586
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsSmartPointer always 16384
Line 601
  ( always {!<=-1,!>=2}
Line 602
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  2 always 2
Line 615
  ( always {!<=-1,!>=2}
Line 616
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( possible lifetime[Iterator]=(stlTypes)
  2 always 2
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(stlTypes),end=0}
Line 623
  ( always {!<=-1,!>=2}
Line 624
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsFloatType always 4096
Line 631
  ( always {!<=-1,!>=2}
Line 632
  return always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always !0
  ( always {!<=-1,!>=2}
Line 635
  ( always {!<=-1,!>=2}
Line 636
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsMaybeUnused always 32768
Line 679
  mFlags always !<=-1
Line 702
  fHasBody always 1
  = always 1
  1 always 1
  << always 1
  0 always 0
  , always 2
Line 703
  fIsInline always 2
  = always 2
  1 always 1
  << always 2
  1 always 1
  , always 4
Line 704
  fIsConst always 4
  = always 4
  1 always 1
  << always 4
  2 always 2
  , always 8
Line 705
  fHasVirtualSpecifier always 8
  = always 8
  1 always 1
  << always 8
  3 always 3
  , always 16
Line 706
  fIsPure always 16
  = always 16
  1 always 1
  << always 16
  4 always 4
  , always 32
Line 707
  fIsStatic always 32
  = always 32
  1 always 1
  << always 32
  5 always 5
  , always 64
Line 708
  fIsStaticLocal always 64
  = always 64
  1 always 1
  << always 64
  6 always 6
  , always 128
Line 709
  fIsExtern always 128
  = always 128
  1 always 1
  << always 128
  7 always 7
  , always 256
Line 710
  fIsFriend always 256
  = always 256
  1 always 1
  << always 256
  8 always 8
  , always 512
Line 711
  fIsExplicit always 512
  = always 512
  1 always 1
  << always 512
  9 always 9
  , always 1024
Line 712
  fIsDefault always 1024
  = always 1024
  1 always 1
  << always 1024
  10 always 10
  , always 2048
Line 713
  fIsDelete always 2048
  = always 2048
  1 always 1
  << always 2048
  11 always 11
  , always 4096
Line 714
  fHasOverrideSpecifier always 4096
  = always 4096
  1 always 1
  << always 4096
  12 always 12
  , always 8192
Line 715
  fHasFinalSpecifier always 8192
  = always 8192
  1 always 1
  << always 8192
  13 always 13
  , always 16384
Line 716
  fIsNoExcept always 16384
  = always 16384
  1 always 1
  << always 16384
  14 always 14
  , always 32768
Line 717
  fIsThrow always 32768
  = always 32768
  1 always 1
  << always 32768
  15 always 15
  , always 65536
Line 718
  fIsOperator always 65536
  = always 65536
  1 always 1
  << always 65536
  16 always 16
  , always 131072
Line 719
  fHasLvalRefQual always 131072
  = always 131072
  1 always 1
  << always 131072
  17 always 17
  , always 262144
Line 720
  fHasRvalRefQual always 262144
  = always 262144
  1 always 1
  << always 262144
  18 always 18
  , always 524288
Line 721
  fIsVariadic always 524288
  = always 524288
  1 always 1
  << always 524288
  19 always 19
  , always 1048576
Line 722
  fIsVolatile always 1048576
  = always 1048576
  1 always 1
  << always 1048576
  20 always 20
  , always 2097152
Line 723
  fHasTrailingReturnType always 2097152
  = always 2097152
  1 always 1
  << always 2097152
  21 always 21
  , always 4194304
Line 724
  fIsEscapeFunction always 4194304
  = always 4194304
  1 always 1
  << always 4194304
  22 always 22
  , always 8388608
Line 725
  fIsInlineKeyword always 8388608
  = always 8388608
  1 always 1
  << always 8388608
  23 always 23
  , always 16777216
Line 726
  fIsConstexpr always 16777216
  = always 16777216
  1 always 1
  << always 16777216
  24 always 24
Line 734
  ( always {!<=-1,!>=2}
  flag always !<=-1
Line 735
  return always {!<=-1,!>=2}
  mFlags always !<=-1
  & always !<=-1
  flag {!<=-1,16777216@177,4194304@179,8388608@180,2097152@182,1048576@183,524288@184,262144@185,131072@186,65536@187}
  != always {!<=-1,!>=2}
  0 always 0
Line 743
  flag always !<=-1
  state always {!<=-1,!>=2}
Line 744
  mFlags always !<=-1
  = always !<=-1
  state always {!<=-1,!>=2}
  ? always !<=-1
  mFlags always !<=-1
  | always !<=-1
  flag {!<=-1,8388608@154,2097152@155,1048576@156,524288@157,262144@158,131072@159,65536@160,32768@161,16384@162}
  : always !<=-1
  mFlags always !<=-1
  & always !<=-1
  ~ {!<=0,4286578687@154,4292870143@155,4293918719@156,4294443007@157,4294705151@158,4294836223@159,4294901759@160,4294934527@161,4294950911@162}
  flag {!<=-1,8388608@154,2097152@155,1048576@156,524288@157,262144@158,131072@159,65536@160,32768@161,16384@162}
Line 748
  eConstructor always 0
  eCopyConstructor always 1
  eMoveConstructor always 2
  eOperatorEqual always 3
  eDestructor always 4
  eFunction always 5
  eLambda always 6
Line 760
  ( always !<=-1
Line 763
  ( always !<=-1
  - always !<=-1
Line 772
  ( always {!<=-1,!>=2}
  defaultVal always {!<=-1,!>=2}
  = always 0
  false always 0
Line 777
  = always 0
  nullptr always 0
Line 779
  ( always {!<=-1,!>=2}
Line 780
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  eLambda always 6
Line 783
  ( always {!<=-1,!>=2}
Line 784
  return always {!<=-1,!>=2}
  type possible {1,2}
  == {!<=-1,!>=2,0}
  eConstructor always 0
  || always {!<=-1,!>=2}
Line 785
  type {2,!0}
  == {!<=-1,!>=2,0}
  eCopyConstructor always 1
  || always {!<=-1,!>=2}
Line 786
  type always {!0,!1}
  == always {!<=-1,!>=2}
  eMoveConstructor always 2
Line 789
  ( always {!<=-1,!>=2}
Line 790
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  eDestructor always 4
Line 792
  ( always {!<=-1,!>=2}
Line 793
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 795
  ( always {!<=-1,!>=2}
Line 796
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 798
  ( always {!<=-1,!>=2}
Line 799
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 801
  ( always {!<=-1,!>=2}
Line 802
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 804
  ( always {!<=-1,!>=2}
Line 805
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 807
  ( always {!<=-1,!>=2}
Line 808
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 810
  ( always {!<=-1,!>=2}
Line 811
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 814
  ( always {!<=-1,!>=2}
Line 815
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fHasBody always 1
Line 817
  ( always {!<=-1,!>=2}
Line 818
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsInline always 2
Line 820
  ( always {!<=-1,!>=2}
Line 821
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsConst always 4
Line 823
  ( always {!<=-1,!>=2}
Line 824
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fHasVirtualSpecifier always 8
Line 826
  ( always {!<=-1,!>=2}
Line 827
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsPure always 16
Line 829
  ( always {!<=-1,!>=2}
Line 830
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsStatic always 32
Line 832
  ( always {!<=-1,!>=2}
Line 833
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsStaticLocal always 64
Line 835
  ( always {!<=-1,!>=2}
Line 836
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsExtern always 128
Line 838
  ( always {!<=-1,!>=2}
Line 839
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsFriend always 256
Line 841
  ( always {!<=-1,!>=2}
Line 842
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsExplicit always 512
Line 844
  ( always {!<=-1,!>=2}
Line 845
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsDefault always 1024
Line 847
  ( always {!<=-1,!>=2}
Line 848
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsDelete always 2048
Line 850
  ( always {!<=-1,!>=2}
Line 851
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsNoExcept always 16384
Line 853
  ( always {!<=-1,!>=2}
Line 854
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsThrow always 32768
Line 856
  ( always {!<=-1,!>=2}
Line 857
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fHasOverrideSpecifier always 4096
Line 859
  ( always {!<=-1,!>=2}
Line 860
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fHasFinalSpecifier always 8192
Line 862
  ( always {!<=-1,!>=2}
Line 863
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsOperator always 65536
Line 865
  ( always {!<=-1,!>=2}
Line 866
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fHasLvalRefQual always 131072
Line 868
  ( always {!<=-1,!>=2}
Line 869
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fHasRvalRefQual always 262144
Line 871
  ( always {!<=-1,!>=2}
Line 872
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsVariadic always 524288
Line 874
  ( always {!<=-1,!>=2}
Line 875
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsVolatile always 1048576
Line 877
  ( always {!<=-1,!>=2}
Line 878
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fHasTrailingReturnType always 2097152
Line 880
  state always {!<=-1,!>=2}
Line 881
  fHasBody always 1
  state always {!<=-1,!>=2}
Line 883
  ( always {!<=-1,!>=2}
Line 884
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsInlineKeyword always 8388608
Line 887
  ( always {!<=-1,!>=2}
Line 888
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsEscapeFunction always 4194304
Line 890
  state always {!<=-1,!>=2}
Line 891
  fIsEscapeFunction always 4194304
  state always {!<=-1,!>=2}
Line 894
  ( always {!<=-1,!>=2}
Line 895
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsConstexpr always 16777216
Line 897
  state always {!<=-1,!>=2}
Line 898
  fIsConstexpr always 16777216
  state always {!<=-1,!>=2}
Line 900
  ( always {!<=-1,!>=2}
Line 919
  ( always {!<=-1,!>=2}
Line 921
  ( always {!<=-1,!>=2}
  , always 0
  unknown always {!<=-1,!>=2}
  = always 0
  false always 0
Line 923
  ( always {!<=-1,!>=2}
  , always 0
  unknown always {!<=-1,!>=2}
  = always 0
  false always 0
Line 925
  ( always {!<=-1,!>=2}
  , always 0
  unknown always {!<=-1,!>=2}
  = always 0
  false always 0
Line 930
  this always !0
  ( always {!<=-1,!>=2}
Line 931
  "{|;" always "{|;"
Line 947
  mFlags always !<=-1
Line 949
  state always {!<=-1,!>=2}
Line 950
  fIsInline always 2
  state always {!<=-1,!>=2}
Line 952
  state always {!<=-1,!>=2}
Line 953
  fIsConst always 4
  state always {!<=-1,!>=2}
Line 955
  state always {!<=-1,!>=2}
Line 956
  fHasVirtualSpecifier always 8
  state always {!<=-1,!>=2}
Line 958
  state always {!<=-1,!>=2}
Line 959
  fIsPure always 16
  state always {!<=-1,!>=2}
Line 961
  state always {!<=-1,!>=2}
Line 962
  fIsStatic always 32
  state always {!<=-1,!>=2}
Line 964
  state always {!<=-1,!>=2}
Line 965
  fIsStaticLocal always 64
  state always {!<=-1,!>=2}
Line 967
  state always {!<=-1,!>=2}
Line 968
  fIsExtern always 128
  state always {!<=-1,!>=2}
Line 970
  state always {!<=-1,!>=2}
Line 971
  fIsFriend always 256
  state always {!<=-1,!>=2}
Line 973
  state always {!<=-1,!>=2}
Line 974
  fIsExplicit always 512
  state always {!<=-1,!>=2}
Line 976
  state always {!<=-1,!>=2}
Line 977
  fIsDefault always 1024
  state always {!<=-1,!>=2}
Line 979
  state always {!<=-1,!>=2}
Line 980
  fIsDelete always 2048
  state always {!<=-1,!>=2}
Line 982
  state always {!<=-1,!>=2}
Line 983
  fIsNoExcept always 16384
  state always {!<=-1,!>=2}
Line 985
  state always {!<=-1,!>=2}
Line 986
  fIsThrow always 32768
  state always {!<=-1,!>=2}
Line 988
  state always {!<=-1,!>=2}
Line 989
  fIsOperator always 65536
  state always {!<=-1,!>=2}
Line 991
  state always {!<=-1,!>=2}
Line 992
  fHasLvalRefQual always 131072
  state always {!<=-1,!>=2}
Line 994
  state always {!<=-1,!>=2}
Line 995
  fHasRvalRefQual always 262144
  state always {!<=-1,!>=2}
Line 997
  state always {!<=-1,!>=2}
Line 998
  fIsVariadic always 524288
  state always {!<=-1,!>=2}
Line 1000
  state always {!<=-1,!>=2}
Line 1001
  fIsVolatile always 1048576
  state always {!<=-1,!>=2}
Line 1003
  state always {!<=-1,!>=2}
Line 1004
  fHasTrailingReturnType always 2097152
  state always {!<=-1,!>=2}
Line 1006
  state always {!<=-1,!>=2}
Line 1007
  fIsInlineKeyword always 8388608
  state always {!<=-1,!>=2}
Line 1022
  eGlobal always 0
  eClass always 1
  eStruct always 2
  eUnion always 3
  eNamespace always 4
  eFunction always 5
  eIf always 6
  eElse always 7
  eFor always 8
  eWhile always 9
  eDo always 10
  eSwitch always 11
  eUnconditional always 12
  eTry always 13
  eCatch always 14
  eLambda always 15
  eEnum always 16
Line 1051
  enumClass always {!<=-1,!>=2}
Line 1056
  = possible 0
  start possible 0
Line 1057
  = possible 0
  start possible 0
  ? possible 0
  start always !0
  : always 0
  nullptr always 0
Line 1059
  bodyStartList possible lifetime[Object]=(start)
  start always !0
Line 1062
  ( always {!<=-1,!>=2}
Line 1064
  return always {!<=-1,!>=2}
  ( always !<=-1
  > always {!<=-1,!>=2}
  9 always 9
  && always {!<=-1,!>=2}
  className {>=size=10,!<=size=9}
  0 always 0
  9 always 9
  "Anonymous" always "Anonymous"
  == always {!<=-1,!>=2}
  0 always 0
  && always {!<=-1,!>=2}
  9 always 9
Line 1069
  == always {!<=-1,!>=2}
Line 1070
  & {lifetime[Address]=(enumeratorList),!0}
Line 1072
  nullptr always 0
Line 1075
  ( always {!<=-1,!>=2}
Line 1076
  ! always {!<=-1,!>=2}
  outer possible symbolic=(this)
Line 1077
  return always {!<=-1,!>=2}
  false always 0
Line 1078
  outer always !0
  == always {!<=-1,!>=2}
  this always !0
Line 1079
  return always {!<=-1,!>=2}
  true always 1
Line 1081
  outer {symbolic=(parent),!symbolic=(this),!0}
  != {!<=-1,!>=2,0,1}
  parent possible {symbolic=(nestedIn),symbolic=(outer),0}
  && {!<=-1,!>=2,0}
  parent {symbolic=(nestedIn),!symbolic=(outer),0}
Line 1082
  parent {symbolic=(nestedIn),!symbolic=(outer),!0}
Line 1083
  parent possible {symbolic=(nestedIn),symbolic=(outer),0}
  && always {!<=-1,!>=2}
  parent always !0
  == always {!<=-1,!>=2}
  outer always {!symbolic=(this),!0}
Line 1084
  return always {!<=-1,!>=2}
  true always 1
Line 1085
  return always {!<=-1,!>=2}
  false always 0
Line 1090
  scope always !0
  == always {!<=-1,!>=2}
  :: always 5
  eFunction always 5
Line 1092
  scope always !0
Line 1094
  ! {!<=-1,!>=2,1}
  scope possible 0
Line 1095
  nullptr always 0
Line 1096
  scope always !0
Line 1099
  ( always {!<=-1,!>=2}
Line 1100
  return always {!<=-1,!>=2}
  type possible 2
  == {!<=-1,!>=2,0}
  eClass always 1
  || always {!<=-1,!>=2}
  type always !1
  == always {!<=-1,!>=2}
  eStruct always 2
Line 1103
  ( always {!<=-1,!>=2}
Line 1104
  return always {!<=-1,!>=2}
  type possible {2,3}
  == {!<=-1,!>=2,0}
  eClass always 1
  || always {!<=-1,!>=2}
  type {3,!1}
  == {!<=-1,!>=2,0}
  eStruct always 2
  || always {!<=-1,!>=2}
  type always {!1,!2}
  == always {!<=-1,!>=2}
  eUnion always 3
Line 1107
  ( always {!<=-1,!>=2}
Line 1108
  return always {!<=-1,!>=2}
  type possible {2,3,0,4,16}
  != {!<=-1,!>=2,1}
  eClass always 1
  && always {!<=-1,!>=2}
  type {3,0,4,16,!1}
  != {!<=-1,!>=2,1}
  eStruct always 2
  && always {!<=-1,!>=2}
  type {0,4,16,!1,!2}
  != {!<=-1,!>=2,1}
  eUnion always 3
  && always {!<=-1,!>=2}
  type {4,16,!2,!3}
  != {!<=-1,!>=2,1}
  eGlobal always 0
  && always {!<=-1,!>=2}
  type {16,!3,!0}
  != {!<=-1,!>=2,1}
  eNamespace always 4
  && always {!<=-1,!>=2}
  type always {!0,!4}
  != always {!<=-1,!>=2}
  eEnum always 16
Line 1111
  ( always {!<=-1,!>=2}
Line 1112
  return always {!<=-1,!>=2}
  type possible {9,10}
  == {!<=-1,!>=2,0}
  :: always 8
  eFor always 8
  || always {!<=-1,!>=2}
  type {10,!8}
  == {!<=-1,!>=2,0}
  :: always 9
  eWhile always 9
  || always {!<=-1,!>=2}
  type always {!8,!9}
  == always {!<=-1,!>=2}
  :: always 10
  eDo always 10
Line 1115
  ( always {!<=-1,!>=2}
Line 1116
  return always {!<=-1,!>=2}
  type possible {7,8,9,10,11,12,13,14}
  == {!<=-1,!>=2,0}
  eIf always 6
  || always {!<=-1,!>=2}
  type {8,9,10,11,12,13,14,!6}
  == {!<=-1,!>=2,0}
  eElse always 7
  || always {!<=-1,!>=2}
Line 1117
  type {9,10,11,12,13,14,!6,!7}
  == {!<=-1,!>=2,0}
  eFor always 8
  || always {!<=-1,!>=2}
  type {10,11,12,13,14,!7,!8}
  == {!<=-1,!>=2,0}
  eWhile always 9
  || always {!<=-1,!>=2}
  type {11,12,13,14,!8,!9}
  == {!<=-1,!>=2,0}
  eDo always 10
  || always {!<=-1,!>=2}
Line 1118
  type {12,13,14,!9,!10}
  == {!<=-1,!>=2,0}
  eSwitch always 11
  || always {!<=-1,!>=2}
  type {13,14,!10,!11}
  == {!<=-1,!>=2,0}
  eUnconditional always 12
  || always {!<=-1,!>=2}
Line 1119
  type {14,!11,!12}
  == {!<=-1,!>=2,0}
  eTry always 13
  || always {!<=-1,!>=2}
  type always {!12,!13}
  == always {!<=-1,!>=2}
  eCatch always 14
Line 1123
  ( always {!<=-1,!>=2}
Line 1131
  , always 0
  requireConst always {!<=-1,!>=2}
  = always 0
  false always 0
Line 1133
  , always 0
  isC always {!<=-1,!>=2}
  = always 0
  false always 0
Line 1135
  ( always !0
  this always !0
Line 1140
  ( always !0
  this always !0
Line 1159
  functionList possible lifetime[Object]=(func)
Line 1161
  = {lifetime[Object]=(functionList),!0}
  & {lifetime[Object]=(functionList),!0}
  functionList {lifetime[Object]=(func),!size=0}
Line 1163
  ( possible lifetime[Iterator]=(functionMap)
  back {lifetime[Object]=(functionList),symbolic=(&functionList.back()),!0}
  back {lifetime[Object]=(functionList),symbolic=(&functionList.back()),!0}
Line 1166
  ( always {!<=-1,!>=2}
Line 1186
  , always {!<=-1,!>=2}
  isCpp always {!<=-1,!>=2}
Line 1200
  ( always {!<=-1,!>=2}
  & {lifetime[Address]=(vartok),!0}
  & {lifetime[Address]=(typetok),!0}
Line 1209
  None always 0
Line 1210
  LValue always 1
Line 1211
  RValue always 2
Line 1217
  UNKNOWN_SIGN always 0
  SIGNED always 1
  UNSIGNED always 2
Line 1219
  UNKNOWN_TYPE always 0
Line 1220
  POD always 1
Line 1221
  NONSTD always 2
Line 1222
  RECORD always 3
Line 1223
  SMART_POINTER always 4
Line 1224
  CONTAINER always 5
Line 1225
  ITERATOR always 6
Line 1226
  VOID always 7
Line 1227
  BOOL always 8
Line 1228
  CHAR always 9
Line 1229
  SHORT always 10
Line 1230
  WCHAR_T always 11
Line 1231
  INT always 12
Line 1232
  LONG always 13
Line 1233
  LONGLONG always 14
Line 1234
  UNKNOWN_INT always 15
Line 1235
  FLOAT always 16
Line 1236
  DOUBLE always 17
Line 1237
  LONGDOUBLE always 18
Line 1242
  = always 0
  :: always 0
  None always 0
Line 1256
  UNKNOWN_SIGN always 0
Line 1257
  UNKNOWN_TYPE always 0
Line 1258
  0 always 0
Line 1259
  0U always 0
Line 1260
  0U always 0
Line 1261
  nullptr always 0
Line 1262
  nullptr always 0
Line 1263
  nullptr always 0
Line 1264
  nullptr always 0
Line 1265
  nullptr always 0
Line 1266
  nullptr always 0
Line 1268
  ( possible lifetime[SubObject]=(s)
Line 1271
  0 always 0
Line 1273
  0U always 0
Line 1274
  nullptr always 0
Line 1275
  nullptr always 0
Line 1276
  nullptr always 0
Line 1277
  nullptr always 0
Line 1278
  nullptr always 0
Line 1279
  nullptr always 0
Line 1281
  ( possible lifetime[SubObject]=(s)
Line 1284
  0 always 0
Line 1287
  nullptr always 0
Line 1288
  nullptr always 0
Line 1289
  nullptr always 0
Line 1290
  nullptr always 0
Line 1291
  nullptr always 0
Line 1292
  nullptr always 0
Line 1294
  ( possible lifetime[SubObject]=(s)
Line 1297
  0 always 0
Line 1300
  nullptr always 0
Line 1301
  nullptr always 0
Line 1302
  nullptr always 0
Line 1303
  nullptr always 0
Line 1304
  nullptr always 0
Line 1305
  nullptr always 0
Line 1311
  , always {!<=-1,!>=2}
  longType always {!<=-1,!>=2}
Line 1313
  UNKNOWN always 0
  SAME always 1
  FALLBACK1 always 2
  FALLBACK2 always 3
  NOMATCH always 4
Line 1317
  ( always {!<=-1,!>=2}
Line 1318
  return always {!<=-1,!>=2}
  >= always {!<=-1,!>=2}
  :: always 8
  BOOL always 8
Line 1321
  ( always {!<=-1,!>=2}
Line 1322
  return always {!<=-1,!>=2}
  type possible {<=15,>=16}
  >= {!<=-1,!>=2,<=1}
  :: always 8
  BOOL always 8
  && always {!<=-1,!>=2}
  type {>=8,!<=7}
  <= {!<=-1,!>=2,>=1}
  :: always 15
  UNKNOWN_INT always 15
Line 1325
  ( always {!<=-1,!>=2}
Line 1326
  return always {!<=-1,!>=2}
  type possible {<=18,>=19}
  >= {!<=-1,!>=2,<=1}
  :: always 16
  FLOAT always 16
  && always {!<=-1,!>=2}
  type {>=16,!<=15}
  <= {!<=-1,!>=2,>=1}
  :: always 18
  LONGDOUBLE always 18
Line 1329
  ( always {!<=-1,!>=2}
Line 1331
  ( always {!<=-1,!>=2}
Line 1332
  return always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  typeScope always !0
  == always {!<=-1,!>=2}
  :: always 16
  eEnum always 16
Line 1335
  , always 0
  p always {!<=-1,!>=2}
  = always 0
  false always 0
Line 1338
  ( always {!<=-1,!>=2}
Line 1381
  , always 0
  lookOutside always {!<=-1,!>=2}
  = always 0
  false always 0
Line 1382
  , always 0
  lookOutside always {!<=-1,!>=2}
  = always 0
  false always 0
Line 1383
  this always !0
  lookOutside always {!<=-1,!>=2}
Line 1388
  this always !0
Line 1391
  ( always {!<=-1,!>=2}
Line 1392
  return always {!<=-1,!>=2}
  < always {!<=-1,!>=2}
  ( always !<=-1
Line 1408
  = always 0
  nullptr always 0
Line 1412
  ( always {!<=-1,!>=2}
Line 1426
  reportDebugWarnings always {!<=-1,!>=2}
  = always 0
  nullptr always 0
Line 1456
  firstPass always {!<=-1,!>=2}
Line 1467
  & {lifetime[Address]=(scope),!0}
Line 1468
  & {lifetime[Address]=(scope),!0}
  & {lifetime[Address]=(tok),!0}
Line 1470
  ( always {!<=-1,!>=2}
Line 1482
  ( always {!<=-1,!>=2}
Line 1500
  mIsCpp always {!<=-1,!>=2}
Line 40
  none always 0
Line 41
  op1 always 1
Line 42
  op2 always 2
Line 43
  op1_and_op2 always 3
Line 44
  done always 4
Line 53
  ! always {!<=-1,!>=2}
Line 57
  = always !0
  ast always !0
Line 59
  tok inconclusive symbolic=(ast)
Line 61
  c possible {2,3,1}
  == {!<=-1,!>=2,0}
  :: always 4
  done always 4
Line 63
  c {3,1,!4}
  == {!<=-1,!>=2,0}
  :: always 2
  op2 always 2
  || {!<=-1,!>=2,1}
  c {1,3,!4,!2}
  == {!<=-1,!>=2,0,1}
  :: always 3
  op1_and_op2 always 3
Line 66
  t2 always !0
Line 68
  c {3,!4,2}
  == {!<=-1,!>=2,0}
  :: always 1
  op1 always 1
  || {!<=-1,!>=2,1}
  c {!4,2,3,!1}
  == {!<=-1,!>=2,0,1}
  :: always 3
  op1_and_op2 always 3
Line 71
  t1 always !0
Line 74
  ( always {!<=-1,!>=2}
Line 77
  tokens always !size=0
Line 78
  tokens always !size=0
Line 79
  true always 1
Line 82
  ( always {!<=-1,!>=2}
Line 86
  ( always {!<=-1,!>=2}
Line 92
  , always 100
  = always 100
  100 always 100
Line 94
  ( always {!<=-1,!>=2}
Line 96
  ( always {!<=-1,!>=2}
Line 98
  ( always {!<=-1,!>=2}
Line 100
  ( always {!<=-1,!>=2}
Line 102
  ( always {!<=-1,!>=2}
Line 104
  ( always {!<=-1,!>=2}
Line 106
  ( always {!<=-1,!>=2}
  , always {!<=-1,!>=2}
  unknown always {!<=-1,!>=2}
Line 107
  ( always {!<=-1,!>=2}
Line 109
  ( always {!<=-1,!>=2}
  , always {!<=-1,!>=2}
  unknown always {!<=-1,!>=2}
Line 111
  ( always {!<=-1,!>=2}
Line 113
  ( always {!<=-1,!>=2}
Line 115
  ( always {!<=-1,!>=2}
Line 116
  ( always {!<=-1,!>=2}
Line 118
  ( always {!<=-1,!>=2}
Line 120
  ( always {!<=-1,!>=2}
Line 122
  ( always {!<=-1,!>=2}
Line 123
  ( always {!<=-1,!>=2}
Line 137
  , always 0
  = always 0
  nullptr always 0
Line 139
  ( always {!<=-1,!>=2}
Line 141
  ( always {!<=-1,!>=2}
  cpp always {!<=-1,!>=2}
  , always 0
  unknown always {!<=-1,!>=2}
  = always 0
  false always 0
Line 155
  cpp always {!<=-1,!>=2}
Line 157
  ( always {!<=-1,!>=2}
Line 158
  ( always {!<=-1,!>=2}
Line 179
  ( always {!<=-1,!>=2}
Line 187
  ( always {!<=-1,!>=2}
Line 188
  ( always {!<=-1,!>=2}
Line 190
  ( always {!<=-1,!>=2}
  , always 1
  onVar always {!<=-1,!>=2}
  = always 1
  true always 1
  , always 0
  = always 0
  0 always 0
Line 198
  temporary always {!<=-1,!>=2}
  = always 1
  true always 1
Line 199
  inconclusive always {!<=-1,!>=2}
  = always 1
  true always 1
Line 201
  = always 20
  20 always 20
Line 202
  , always 0
  = always 0
  nullptr always 0
Line 204
  ( always {!<=-1,!>=2}
  cpp always {!<=-1,!>=2}
  macro always {!<=-1,!>=2}
  , always {!<=-1,!>=2}
  pure always {!<=-1,!>=2}
  , always {!<=-1,!>=2}
  followVar always {!<=-1,!>=2}
  , always 0
  = always 0
  nullptr always 0
Line 206
  ( always {!<=-1,!>=2}
Line 211
  ( always {!<=-1,!>=2}
Line 222
  ( always {!<=-1,!>=2}
  isNot always {!<=-1,!>=2}
  cpp always {!<=-1,!>=2}
  , always {!<=-1,!>=2}
  pure always {!<=-1,!>=2}
  , always {!<=-1,!>=2}
  followVar always {!<=-1,!>=2}
  , always 0
  = always 0
  nullptr always 0
Line 224
  ( always {!<=-1,!>=2}
  cpp always {!<=-1,!>=2}
  , always {!<=-1,!>=2}
  pure always {!<=-1,!>=2}
  , always {!<=-1,!>=2}
  followVar always {!<=-1,!>=2}
  , always 0
  = always 0
  nullptr always 0
Line 226
  ( always {!<=-1,!>=2}
Line 228
  ( always {!<=-1,!>=2}
  , always {!<=-1,!>=2}
  pure always {!<=-1,!>=2}
  , always {!<=-1,!>=2}
  cpp always {!<=-1,!>=2}
Line 230
  ( always {!<=-1,!>=2}
  cpp always {!<=-1,!>=2}
  , always 0
  checkArrayAccess always {!<=-1,!>=2}
  = always 0
  false always 0
  , always 1
  checkReference always {!<=-1,!>=2}
  = always 1
  true always 1
Line 232
  ( always {!<=-1,!>=2}
Line 234
  ( always {!<=-1,!>=2}
Line 237
  ( always {!<=-1,!>=2}
  , always 0
Line 238
  = always 0
  nullptr always 0
  , always 0
Line 239
  = always 0
  nullptr always 0
  , always 0
Line 240
  functionScope always {!<=-1,!>=2}
  = always 0
  false always 0
Line 243
  ( always {!<=-1,!>=2}
Line 262
  ( always {!<=-1,!>=2}
Line 272
  ( always {!<=-1,!>=2}
Line 275
  ( always {!<=-1,!>=2}
  , always {!<=-1,!>=2}
  globalvar always {!<=-1,!>=2}
  , always {!<=-1,!>=2}
  cpp always {!<=-1,!>=2}
  , always 20
  = always 20
  20 always 20
Line 276
  ( always {!<=-1,!>=2}
  , always {!<=-1,!>=2}
  globalvar always {!<=-1,!>=2}
  , always {!<=-1,!>=2}
  cpp always {!<=-1,!>=2}
  , always 20
  = always 20
  20 always 20
Line 278
  ( always {!<=-1,!>=2}
  , always {!<=-1,!>=2}
  cpp always {!<=-1,!>=2}
  , always 20
  = always 20
  20 always 20
Line 280
  ( always {!<=-1,!>=2}
  , always {!<=-1,!>=2}
  cpp always {!<=-1,!>=2}
  , always 20
  = always 20
  20 always 20
Line 282
  ( always {!<=-1,!>=2}
Line 286
  , always {!<=-1,!>=2}
Line 287
  cpp always {!<=-1,!>=2}
Line 289
  ( always {!<=-1,!>=2}
  , always {!<=-1,!>=2}
  cpp always {!<=-1,!>=2}
Line 290
  ( always {!<=-1,!>=2}
  , always {!<=-1,!>=2}
  cpp always {!<=-1,!>=2}
Line 292
  , always {!<=-1,!>=2}
  globalvar always {!<=-1,!>=2}
  , always {!<=-1,!>=2}
  cpp always {!<=-1,!>=2}
  , always 20
  = always 20
  20 always 20
Line 293
  , always {!<=-1,!>=2}
  globalvar always {!<=-1,!>=2}
  , always {!<=-1,!>=2}
  cpp always {!<=-1,!>=2}
  , always 20
  = always 20
  20 always 20
Line 295
  ( always {!<=-1,!>=2}
Line 298
  , always {!<=-1,!>=2}
Line 299
  cpp always {!<=-1,!>=2}
  , always 20
Line 300
  = always 20
  20 always 20
Line 302
  ( always {!<=-1,!>=2}
Line 304
  , always {!<=-1,!>=2}
Line 305
  globalvar always {!<=-1,!>=2}
Line 306
  , always {!<=-1,!>=2}
Line 307
  cpp always {!<=-1,!>=2}
  , always 20
Line 308
  = always 20
  20 always 20
Line 311
  ( always {!<=-1,!>=2}
  , always 0
  = always 0
  nullptr always 0
Line 313
  ( always {!<=-1,!>=2}
Line 336
  ( always {!<=-1,!>=2}
Line 348
  ( always {!<=-1,!>=2}
  cpp always {!<=-1,!>=2}
Line 355
  ( always {!<=-1,!>=2}
  cpp always {!<=-1,!>=2}
Line 357
  ( always {!<=-1,!>=2}
Line 359
  ( always {!<=-1,!>=2}
  , always 0
  = always 0
  nullptr always 0
Line 370
  ( always {!<=-1,!>=2}
Line 372
  ( always {!<=-1,!>=2}
Line 374
  ( always {!<=-1,!>=2}
  , always {!<=-1,!>=2}
  cpp always {!<=-1,!>=2}
Line 383
  ( possible lifetime[SubObject]=(cpp)
  cpp always {!<=-1,!>=2}
  mCpp always {!<=-1,!>=2}
  cpp always {!<=-1,!>=2}
  mValueFlowKnown always {!<=-1,!>=2}
  true always 1
Line 385
  ( always {!<=-1,!>=2}
Line 403
  ( always {!<=-1,!>=2}
Line 406
  known always {!<=-1,!>=2}
Line 411
  ( always {!<=-1,!>=2}
Line 413
  = always 0
  nullptr always 0
  = always 0
  nullptr always 0
Line 415
  ( always {!<=-1,!>=2}
Line 419
  NONE always 0
  READ always 1
  WRITE always 2
  BREAK always 3
  RETURN always 4
  BAILOUT always 5
Line 420
  ( possible lifetime[SubObject]=(type)
  nullptr always 0
Line 421
  ( possible lifetime[SubObject]=(type)
Line 426
  , always {!<=-1,!>=2}
  local always {!<=-1,!>=2}
  , always {!<=-1,!>=2}
  inInnerClass always {!<=-1,!>=2}
  , always 0
  = always 0
  0 always 0
Line 429
  ( always {!<=-1,!>=2}
Line 431
  mCpp always {!<=-1,!>=2}
Line 433
  Reassign always 0
  UnusedValue always 1
  ValueFlow always 2
Line 435
  mValueFlowKnown always {!<=-1,!>=2}
Line 438
  ( always {!<=-1,!>=2}
Line 44
  >= always {!<=-1,!>=2}
  64 always 64
Line 46
  - possible >=-4611686018427387904
  1LL always 1
  << possible <=4611686018427387904
  bit {!>=64,<=63}
  - {!>=63,<=62}
  1 always 1
Line 50
  >= always {!<=-1,!>=2}
  64 always 64
Line 51
  ~ always !<=-1
  0ULL always 0
  >> always !<=-1
  1 always 1
Line 52
  1LL always 1
  << possible <=4611686018427387904
  bit {!>=64,<=63}
  - {!>=63,<=62}
  1 always 1
  - {<=4611686018427387903,!>=4611686018427387904}
  1LL always 1
Line 58
  ( always {!<=-1,!>=2}
Line 59
  return always {!<=-1,!>=2}
  >= always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  <= always {!<=-1,!>=2}
Line 62
  ( always {!<=-1,!>=2}
  value always !<=-1
Line 63
  intMax always !<=-1
  intMax always !<=-1
  = always !<=-1
Line 64
  return always {!<=-1,!>=2}
  value always !<=-1
  <= always {!<=-1,!>=2}
  intMax always !<=-1
Line 67
  ( always {!<=-1,!>=2}
Line 68
  return always {!<=-1,!>=2}
  >= always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  <= always {!<=-1,!>=2}
Line 71
  ( always {!<=-1,!>=2}
  value always !<=-1
Line 72
  longMax always !<=-1
  longMax always !<=-1
  = always !<=-1
Line 73
  return always {!<=-1,!>=2}
  value always !<=-1
  <= always {!<=-1,!>=2}
  longMax always !<=-1
Line 76
  ( always {!<=-1,!>=2}
  value always !<=-1
Line 77
  longLongMax always !<=-1
  longLongMax always !<=-1
  = always !<=-1
Line 78
  return always {!<=-1,!>=2}
  value always !<=-1
  <= always {!<=-1,!>=2}
  longLongMax always !<=-1
Line 103
  Unspecified always 0
Line 104
  Native always 1
Line 105
  Win32A always 2
Line 106
  Win32W always 3
Line 107
  Win64 always 4
Line 108
  Unix32 always 5
Line 109
  Unix64 always 6
Line 110
  PlatformFile always 7
Line 117
  ( always {!<=-1,!>=2}
Line 125
  ( always {!<=-1,!>=2}
Line 128
  ( always {!<=-1,!>=2}
Line 134
  ( always {!<=-1,!>=2}
Line 135
  return always {!<=-1,!>=2}
  platformType possible {3,4}
  == {!<=-1,!>=2,0}
  Win32A always 2
  || always {!<=-1,!>=2}
Line 136
  platformType {4,!2}
  == {!<=-1,!>=2,0}
  Win32W always 3
  || always {!<=-1,!>=2}
Line 137
  platformType always {!2,!3}
  == always {!<=-1,!>=2}
  Win64 always 4
Line 146
  Unspecified always 0
Line 147
  "Unspecified" always "Unspecified"
Line 148
  Native always 1
Line 149
  "Native" always "Native"
Line 150
  Win32A always 2
Line 151
  "win32A" always "win32A"
Line 152
  Win32W always 3
Line 153
  "win32W" always "win32W"
Line 154
  Win64 always 4
Line 155
  "win64" always "win64"
Line 156
  Unix32 always 5
Line 157
  "unix32" always "unix32"
Line 158
  Unix64 always 6
Line 159
  "unix64" always "unix64"
Line 160
  PlatformFile always 7
Line 161
  "platformFile" always "platformFile"
Line 163
  "unknown" always "unknown"
Line 168
  1 always 1
Line 40
  ( always {!<=-1,!>=2}
Line 41
  return always {!<=-1,!>=2}
  < always {!<=-1,!>=2}
  0 always 0
Line 54
  UNKNOWN always 0
Line 55
  MISSING always 1
Line 56
  FAILURE always 2
Line 57
  COMPILE_DB always 3
Line 58
  VS_SLN always 4
Line 59
  VS_VCXPROJ always 5
Line 60
  BORLAND always 6
Line 61
  CPPCHECK_GUI always 7
Line 66
  :: always 0
  Unspecified always 0
  msc always {!<=-1,!>=2}
  false always 0
  useMfc always {!<=-1,!>=2}
  false always 0
Line 71
  msc always {!<=-1,!>=2}
  ? possible {";_MSC_VER=1900",""}
  ";_MSC_VER=1900" always ";_MSC_VER=1900"
  : always ""
  "" always ""
  useMfc always {!<=-1,!>=2}
  ? possible {";__AFXWIN_H__=1",""}
  ";__AFXWIN_H__=1" always ";__AFXWIN_H__=1"
  : always ""
  "" always ""
Line 78
  msc always {!<=-1,!>=2}
Line 79
  useMfc always {!<=-1,!>=2}
Line 108
  , always 0
  = always 0
  nullptr always 0
Line 110
  ( always {!<=-1,!>=2}
Line 111
  ( always {!<=-1,!>=2}
Line 112
  ( always {!<=-1,!>=2}
Line 114
  ( always {!<=-1,!>=2}
Line 115
  ( always {!<=-1,!>=2}
Line 116
  ( always {!<=-1,!>=2}
Line 128
  8 always 8
  = always "project"
  "project" always "project"
Line 129
  8 always 8
  = always "version"
  "version" always "version"
Line 130
  2 always 2
  = always "1"
  "1" always "1"
Line 131
  9 always 9
  = always "builddir"
  "builddir" always "builddir"
Line 132
  14 always 14
  = always "importproject"
  "importproject" always "importproject"
Line 133
  23 always 23
  = always "analyze-all-vs-configs"
  "analyze-all-vs-configs" always "analyze-all-vs-configs"
Line 134
  7 always 7
  = always "parser"
  "parser" always "parser"
Line 135
  12 always 12
  = always "bug-hunting"
  "bug-hunting" always "bug-hunting"
Line 136
  11 always 11
  = always "includedir"
  "includedir" always "includedir"
Line 137
  4 always 4
  = always "dir"
  "dir" always "dir"
Line 138
  5 always 5
  = always "name"
  "name" always "name"
Line 139
  8 always 8
  = always "defines"
  "defines" always "defines"
Line 140
  7 always 7
  = always "define"
  "define" always "define"
Line 141
  5 always 5
  = always "name"
  "name" always "name"
Line 142
  10 always 10
  = always "undefines"
  "undefines" always "undefines"
Line 143
  9 always 9
  = always "undefine"
  "undefine" always "undefine"
Line 144
  6 always 6
  = always "paths"
  "paths" always "paths"
Line 145
  4 always 4
  = always "dir"
  "dir" always "dir"
Line 146
  5 always 5
  = always "name"
  "name" always "name"
Line 147
  5 always 5
  = always "root"
  "root" always "root"
Line 148
  5 always 5
  = always "name"
  "name" always "name"
Line 149
  7 always 7
  = always "ignore"
  "ignore" always "ignore"
Line 150
  5 always 5
  = always "path"
  "path" always "path"
Line 151
  5 always 5
  = always "name"
  "name" always "name"
Line 152
  8 always 8
  = always "exclude"
  "exclude" always "exclude"
Line 153
  5 always 5
  = always "path"
  "path" always "path"
Line 154
  5 always 5
  = always "name"
  "name" always "name"
Line 155
  19 always 19
  = always "function-contracts"
  "function-contracts" always "function-contracts"
Line 156
  19 always 19
  = always "variable-contracts"
  "variable-contracts" always "variable-contracts"
Line 157
  10 always 10
  = always "libraries"
  "libraries" always "libraries"
Line 158
  8 always 8
  = always "library"
  "library" always "library"
Line 159
  9 always 9
  = always "platform"
  "platform" always "platform"
Line 160
  13 always 13
  = always "suppressions"
  "suppressions" always "suppressions"
Line 161
  12 always 12
  = always "suppression"
  "suppression" always "suppression"
Line 162
  6 always 6
  = always "addon"
  "addon" always "addon"
Line 163
  7 always 7
  = always "addons"
  "addons" always "addons"
Line 164
  5 always 5
  = always "tool"
  "tool" always "tool"
Line 165
  6 always 6
  = always "tools"
  "tools" always "tools"
Line 166
  5 always 5
  = always "tags"
  "tags" always "tags"
Line 167
  4 always 4
  = always "tag"
  "tag" always "tag"
Line 168
  13 always 13
  = always "tag-warnings"
  "tag-warnings" always "tag-warnings"
Line 169
  4 always 4
  = always "tag"
  "tag" always "tag"
Line 170
  8 always 8
  = always "warning"
  "warning" always "warning"
Line 171
  5 always 5
  = always "hash"
  "hash" always "hash"
Line 172
  14 always 14
  = always "check-headers"
  "check-headers" always "check-headers"
Line 173
  23 always 23
  = always "check-unused-templates"
  "check-unused-templates" always "check-unused-templates"
Line 174
  14 always 14
  = always "max-ctu-depth"
  "max-ctu-depth" always "max-ctu-depth"
Line 175
  23 always 23
  = always "max-template-recursion"
  "max-template-recursion" always "max-template-recursion"
Line 176
  37 always 37
  = always "check-unknown-function-return-values"
  "check-unknown-function-return-values" always "check-unknown-function-return-values"
Line 177
  11 always 11
  = always "clang-tidy"
  "clang-tidy" always "clang-tidy"
Line 178
  5 always 5
  = always "name"
  "name" always "name"
Line 179
  18 always 18
  = always "vs-configurations"
  "vs-configurations" always "vs-configurations"
Line 180
  7 always 7
  = always "config"
  "config" always "config"
Line 42
  hash always !<=-1
Line 56
  NO_LINE always -1
  hash always !<=-1
  0 always 0
  thisAndNextLine always {!<=-1,!>=2}
  false always 0
  matched always {!<=-1,!>=2}
  false always 0
  checked always {!<=-1,!>=2}
  false always 0
Line 58
  this always !0
Line 60
  = always -1
  NO_LINE always -1
  hash always !<=-1
  0 always 0
  thisAndNextLine always {!<=-1,!>=2}
  false always 0
  matched always {!<=-1,!>=2}
  false always 0
  checked always {!<=-1,!>=2}
  false always 0
Line 67
  hash always !<=-1
  = always !<=-1
  . always !<=-1
  hash always !<=-1
Line 68
  thisAndNextLine always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  . always {!<=-1,!>=2}
  thisAndNextLine always {!<=-1,!>=2}
Line 69
  matched always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  . always {!<=-1,!>=2}
  matched always {!<=-1,!>=2}
Line 70
  checked always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  . always {!<=-1,!>=2}
  checked always {!<=-1,!>=2}
Line 71
  this always !0
Line 74
  ( always {!<=-1,!>=2}
Line 75
  != always {!<=-1,!>=2}
Line 76
  return always {!<=-1,!>=2}
  errorId always !symbolic=(other.errorId)
  < always {!<=-1,!>=2}
  . always !symbolic=(errorId)
Line 77
  < always {!<=-1,!>=2}
Line 78
  return always {!<=-1,!>=2}
  true always 1
Line 79
  != always {!<=-1,!>=2}
Line 80
  return always {!<=-1,!>=2}
  fileName always !symbolic=(other.fileName)
  < always {!<=-1,!>=2}
  . always !symbolic=(fileName)
Line 81
  != always {!<=-1,!>=2}
Line 82
  return always {!<=-1,!>=2}
  symbolName always !symbolic=(other.symbolName)
  < always {!<=-1,!>=2}
  . always !symbolic=(symbolName)
Line 83
  hash always !<=-1
  != always {!<=-1,!>=2}
  . always !<=-1
  hash always !<=-1
Line 84
  return always {!<=-1,!>=2}
  hash always {!<=-1,!symbolic=(other.hash)}
  < always {!<=-1,!>=2}
  . always {!<=-1,!symbolic=(hash)}
  hash always !<=-1
Line 85
  thisAndNextLine always {!<=-1,!>=2}
  != always {!<=-1,!>=2}
  . always {!<=-1,!>=2}
  thisAndNextLine always {!<=-1,!>=2}
Line 86
  return always {!<=-1,!>=2}
  thisAndNextLine always {!<=-1,!>=2,!symbolic=(other.thisAndNextLine)}
Line 87
  return always {!<=-1,!>=2}
  false always 0
Line 96
  ( always {!<=-1,!>=2}
Line 98
  ( always {!<=-1,!>=2}
Line 100
  ( always {!<=-1,!>=2}
Line 104
  ( always {!<=-1,!>=2}
Line 105
  return always {!<=-1,!>=2}
  ! {!<=-1,!>=2,0}
  fileName possible size=0
  ( {!<=-1,!>=2,1}
  && always {!<=-1,!>=2}
  fileName always !size=0
  ( always !<=-1
  "?*" always "?*"
  == always {!<=-1,!>=2}
Line 108
  ( always {!<=-1,!>=2}
Line 109
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 110
  == always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 111
  == always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 112
  == always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 113
  hash always !<=-1
  == always {!<=-1,!>=2}
  . always !<=-1
  hash always !<=-1
  && always {!<=-1,!>=2}
Line 114
  thisAndNextLine always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  . always {!<=-1,!>=2}
  thisAndNextLine always {!<=-1,!>=2}
Line 121
  hash always !<=-1
Line 122
  thisAndNextLine always {!<=-1,!>=2}
Line 123
  matched always {!<=-1,!>=2}
Line 124
  checked always {!<=-1,!>=2}
Line 126
  NO_LINE always -1
  = always -1
  -1 always -1
Line 178
  ( always {!<=-1,!>=2}
Line 185
  ( always {!<=-1,!>=2}
Line 197
  unusedFunctionChecking always {!<=-1,!>=2}
Line 203
  unusedFunctionChecking always {!<=-1,!>=2}
Line 30
  SHOWTIME_NONE always 0
  = always 0
  0 always 0
  , always 1
Line 31
  SHOWTIME_FILE always 1
  , always 2
Line 32
  SHOWTIME_SUMMARY always 2
  , always 3
Line 33
  SHOWTIME_TOP5 always 3
Line 40
  = always 0
  0 always 0
Line 48
  0 always 0
Line 49
  0 always 0
Line 52
  ( always !<=-1
  ( always !<=-1
Line 70
  , always 0
  = always 0
  nullptr always 0
Line 82
  mStopped always {!<=-1,!>=2}
Line 114
  checkAllConfigurations always {!<=-1,!>=2}
Line 117
  checkConfiguration always {!<=-1,!>=2}
Line 122
  checkHeaders always {!<=-1,!>=2}
Line 125
  checkLibrary always {!<=-1,!>=2}
Line 131
  checkUnusedTemplates always {!<=-1,!>=2}
Line 134
  clang always {!<=-1,!>=2}
Line 140
  clangTidy always {!<=-1,!>=2}
Line 152
  daca always {!<=-1,!>=2}
Line 155
  debugnormal always {!<=-1,!>=2}
Line 158
  debugSimplified always {!<=-1,!>=2}
Line 161
  debugtemplate always {!<=-1,!>=2}
Line 164
  debugwarnings always {!<=-1,!>=2}
Line 167
  dump always {!<=-1,!>=2}
Line 171
  None always 0
  C always 1
  CPP always 2
Line 178
  exceptionHandling always {!<=-1,!>=2}
Line 191
  force always {!<=-1,!>=2}
Line 198
  inlineSuppressions always {!<=-1,!>=2}
Line 202
  jobs always !<=-1
Line 207
  jointSuppressionReport always {!<=-1,!>=2}
Line 243
  preprocessOnly always {!<=-1,!>=2}
Line 248
  quiet always {!<=-1,!>=2}
Line 251
  relativePaths always {!<=-1,!>=2}
Line 254
  reportProgress always {!<=-1,!>=2}
Line 260
  "simple" always "simple"
Line 261
  "rule" always "rule"
Line 262
  :: always 3
  style always 3
Line 280
  classes always {!<=-1,!>=2}
  false always 0
  externalFunctions always {!<=-1,!>=2}
  false always 0
  internalFunctions always {!<=-1,!>=2}
  false always 0
  externalVariables always {!<=-1,!>=2}
  false always 0
Line 289
  classes always {!<=-1,!>=2}
  = always 0
  externalFunctions always {!<=-1,!>=2}
  = always 0
  internalFunctions always {!<=-1,!>=2}
  = always 0
  externalVariables always {!<=-1,!>=2}
  = always 0
  false always 0
Line 298
  classes always {!<=-1,!>=2}
Line 305
  externalFunctions always {!<=-1,!>=2}
Line 311
  internalFunctions always {!<=-1,!>=2}
Line 317
  externalVariables always {!<=-1,!>=2}
Line 350
  verbose always {!<=-1,!>=2}
Line 353
  xml always {!<=-1,!>=2}
Line 362
  ( always {!<=-1,!>=2}
Line 364
  ( always !<=-1
  >= always {!<=-1,!>=2}
  ( always !<=-1
  && always {!<=-1,!>=2}
  0 always 0
  ( {!<=-1,<=symbolic=(file.length()),!>=symbolic=(file.length()+1)}
  == always {!<=-1,!>=2}
  0 always 0
Line 365
  return always {!<=-1,!>=2}
  true always 1
Line 368
  return always {!<=-1,!>=2}
  false always 0
Line 383
  ( always {!<=-1,!>=2}
  , always 0
  inconclusiveCheck always {!<=-1,!>=2}
  = always 0
  false always 0
Line 386
  ( always {!<=-1,!>=2}
Line 387
  return always {!<=-1,!>=2}
  ( possible lifetime[Iterator]=(libraries)
  ( {lifetime[Iterator]=(libraries),start=0}
  ( {lifetime[Iterator]=(libraries),end=0}
  "posix" always "posix"
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(libraries),end=0}
Line 391
  t always {!<=-1,!>=2}
  = always 1
  true always 1
Line 392
  = always {!<=-1,!>=2}
  t always {!<=-1,!>=2}
Line 396
  ( always {!<=-1,!>=2}
Line 397
  return always {!<=-1,!>=2}
Line 58
  ( always {!<=-1,!>=2}
Line 59
  return always {!<=-1,!>=2}
  mIsC always {!<=-1,!>=2}
Line 63
  ( always {!<=-1,!>=2}
Line 64
  return always {!<=-1,!>=2}
  mIsCpp always {!<=-1,!>=2}
Line 73
  , always 0
  split always {!<=-1,!>=2}
  = always 0
  false always 0
Line 90
  , always 1
  one_line always {!<=-1,!>=2}
  = always 1
  true always 1
Line 101
  ( always {!<=-1,!>=2}
Line 103
  && always {!<=-1,!>=2}
Line 156
  ( always !<=-1
Line 175
  ( always {!<=-1,!>=2}
Line 192
  ( always {!<=-1,!>=2}
Line 219
  mIsC always {!<=-1,!>=2}
Line 220
  mIsCpp always {!<=-1,!>=2}
Line 51
  nullptr always 0
Line 52
  nullptr always 0
Line 53
  nullptr always 0
Line 55
  mFlags always !<=-1
  0 always 0
Line 72
  this always !0
Line 76
  "goto" always "goto"
Line 77
  "do" always "do"
Line 78
  "if" always "if"
Line 79
  "else" always "else"
Line 80
  "for" always "for"
Line 81
  "while" always "while"
Line 82
  "switch" always "switch"
Line 83
  "case" always "case"
Line 84
  "break" always "break"
Line 85
  "continue" always "continue"
Line 86
  "return" always "return"
Line 91
  fIsControlFlowKeyword always 131072
  ( possible lifetime[Iterator]=(controlFlowKeywords)
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(controlFlowKeywords),end=0}
Line 93
  ! {!<=-1,!>=2,0,1}
  mStr possible {size=0,size=4,size=5,size=1,size=3,size=2}
  ( {!<=-1,!>=2,1,0}
Line 94
  mStr {size=5,size=1,size=3,size=2,!size=0}
  == {!<=-1,!>=2,0}
  "true" always "true"
  || always {!<=-1,!>=2}
  mStr always !size=0
  == always {!<=-1,!>=2}
  "false" always "false"
Line 95
  eBoolean always 8
Line 96
  ( always {!<=-1,!>=2}
  mStr {size=1,size=3,size=2,!size=0}
Line 97
  eString always 6
Line 98
  ( always {!<=-1,!>=2}
  mStr {size=1,size=3,size=2,!size=0}
Line 99
  eChar always 7
Line 100
  ( always !<=-1
  mStr {size=1,size=3,size=2,!size=0}
  0 always 0
  || always {!<=-1,!>=2}
  mStr always !size=0
  0 always 0
  == always {!<=-1,!>=2}
  '_' always 95
  || always {!<=-1,!>=2}
  mStr always !size=0
  0 always 0
  == always {!<=-1,!>=2}
  '$' always 36
Line 102
  eVariable always 0
Line 103
  && always {!<=-1,!>=2}
  mTokensFrontBack always !0
  && always {!<=-1,!>=2}
  mTokensFrontBack always !0
  ( always {!<=-1,!>=2}
  mStr always !size=0
Line 104
  eKeyword always 3
Line 105
  mTokType possible {2,1,3}
  != {!<=-1,!>=2,1}
  eVariable always 0
  && always {!<=-1,!>=2}
  mTokType {1,3,!0}
  != {!<=-1,!>=2,1}
  eFunction always 2
  && always {!<=-1,!>=2}
  mTokType {3,!0,!2}
  != {!<=-1,!>=2,1}
  eType always 1
  && always {!<=-1,!>=2}
  mTokType always {!2,!1}
  != always {!<=-1,!>=2}
  eKeyword always 3
Line 106
  eName always 4
Line 107
  ( always {!<=-1,!95,!36}
  mStr {size=1,size=3,size=2,!size=0}
  [ always {!95,!36}
  0 always 0
  || always {!<=-1,!>=2}
  mStr always !size=0
  ( always !<=0
  > always {!<=-1,!>=2}
  1 always 1
  && always {!<=-1,!>=2}
  mStr {!size=0,>=size=2,!<=size=1}
  0 always 0
  == always {!<=-1,!>=2}
  '-' always 45
  && always {!<=-1,!>=2}
  ( always !<=-1
  mStr {!size=0,>=size=2,!<=size=1}
  1 always 1
Line 108
  eNumber always 5
Line 109
  mStr {size=3,size=2,size=1,!size=0}
  == {!<=-1,!>=2,0}
  "=" always "="
  || always {!<=-1,!>=2}
  mStr always !size=0
  == always {!<=-1,!>=2}
  "<<=" always "<<="
  || always {!<=-1,!>=2}
  mStr always !size=0
  == always {!<=-1,!>=2}
  ">>=" always ">>="
  || always {!<=-1,!>=2}
Line 110
  mStr always !size=0
  ( always !<=0
  == always {!<=-1,!>=2}
  2U always 2
  && always {!<=-1,!>=2}
  mStr always size=2
  1 always 1
  == always {!<=-1,!>=2}
  '=' always 61
  && always {!<=-1,!>=2}
  "+-*/%&^|" always "+-*/%&^|"
  mStr always size=2
  0 always 0
Line 111
  eAssignmentOp always 13
Line 112
  mStr {>=size=1,size=2,size=3,!size=0}
  ( {1,<=2,>=3,!<=0}
  == {!<=-1,!>=2,<=1,>=0}
  1 always 1
  && always {!<=-1,!>=2}
  mStr always size=1
  ( always !<=-1
  ",[]()?:" always ",[]()?:"
  != always {!<=-1,!>=2}
Line 113
  eExtendedOp always 17
Line 114
  mStr {>=size=1,size=2,size=3,!size=0}
  == {!<=-1,!>=2,0}
  "<<" always "<<"
  || always {!<=-1,!>=2}
  mStr always !size=0
  == always {!<=-1,!>=2}
  ">>" always ">>"
  || always {!<=-1,!>=2}
  mStr always !size=0
  ( always !<=0
  == always {!<=-1,!>=2}
  1 always 1
  && always {!<=-1,!>=2}
  mStr always size=1
  ( always !<=-1
  "+-*/%" always "+-*/%"
  != always {!<=-1,!>=2}
Line 115
  eArithmeticalOp always 11
Line 116
  mStr {<=size=2,>=size=3,size=1,!size=0}
  ( {<=2,>=3,1,!<=0}
  == {!<=-1,!>=2,<=1}
  1 always 1
  && always {!<=-1,!>=2}
  mStr always size=1
  ( always !<=-1
  "&|^~" always "&|^~"
  != always {!<=-1,!>=2}
Line 117
  eBitOp always 15
Line 118
  mStr {>=size=1,size=2,size=3,!size=0}
  ( {<=2,>=3,1,!<=0}
  <= {!<=-1,!>=2,<=1,>=0}
  2 always 2
  && always {!<=-1,!>=2}
Line 119
  mStr {size=2,size=1,!size=0,!>=size=3}
  == {!<=-1,!>=2,0}
  "&&" always "&&"
  || always {!<=-1,!>=2}
Line 120
  mStr always {!size=0,!>=size=3}
  == always {!<=-1,!>=2}
  "||" always "||"
  || always {!<=-1,!>=2}
Line 121
  mStr always {!size=0,!>=size=3}
  == always {!<=-1,!>=2}
  "!" always "!"
Line 122
  eLogicalOp always 14
Line 123
  mStr {size=2,size=1,size=3,!size=0}
  ( {>=1,2,3,!<=0}
  <= {!<=-1,!>=2,1,0}
  2 always 2
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 124
  mStr {!size=0,<=size=2,!>=size=3}
  == always {!<=-1,!>=2}
  "==" always "=="
  || always {!<=-1,!>=2}
Line 125
  mStr always {!size=0,!>=size=3}
  == always {!<=-1,!>=2}
  "!=" always "!="
  || always {!<=-1,!>=2}
Line 126
  mStr always {!size=0,!>=size=3}
  == always {!<=-1,!>=2}
  "<" always "<"
  || always {!<=-1,!>=2}
Line 127
  mStr always {!size=0,!>=size=3}
  == always {!<=-1,!>=2}
  "<=" always "<="
  || always {!<=-1,!>=2}
Line 128
  mStr always {!size=0,!>=size=3}
  == always {!<=-1,!>=2}
  ">" always ">"
  || always {!<=-1,!>=2}
Line 129
  mStr always {!size=0,!>=size=3}
  == always {!<=-1,!>=2}
  ">=" always ">="
Line 130
  eComparisonOp always 12
Line 131
  mStr {size=2,size=1,size=3,!size=0}
  == {!<=-1,!>=2,0}
  "<=>" always "<=>"
Line 132
  eComparisonOp always 12
Line 133
  mStr {size=2,size=1,size=3,!size=0}
  ( {1,2,3,!<=0}
  == {!<=-1,!>=2,0,1}
  2 always 2
  && always {!<=-1,!>=2}
Line 134
  mStr always size=2
  == always {!<=-1,!>=2}
  "++" always "++"
  || always {!<=-1,!>=2}
Line 135
  mStr always size=2
  == always {!<=-1,!>=2}
  "--" always "--"
Line 136
  eIncDecOp always 16
Line 137
  mStr {size=3,!size=0}
  ( {3,!<=0}
  == {!<=-1,!>=2,0}
  1 always 1
  && always {!<=-1,!>=2}
  mStr always size=1
  ( always !<=-1
  "{}" always "{}"
  != always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  mStr always !size=0
  ( always !<=-1
  "<>" always "<>"
  != always {!<=-1,!>=2}
Line 138
  eBracket always 18
Line 139
  mStr always !size=0
  == always {!<=-1,!>=2}
  "..." always "..."
Line 140
  eEllipsis always 20
Line 142
  eOther always 21
Line 151
  "bool" always "bool"
Line 152
  "_Bool" always "_Bool"
Line 153
  "char" always "char"
Line 154
  "double" always "double"
Line 155
  "float" always "float"
Line 156
  "int" always "int"
Line 157
  "long" always "long"
Line 158
  "short" always "short"
Line 159
  "size_t" always "size_t"
Line 160
  "void" always "void"
Line 161
  "wchar_t" always "wchar_t"
Line 166
  false always 0
Line 168
  ( always !<=-1
  < always {!<=-1,!>=2}
  3 always 3
Line 171
  ( possible lifetime[Iterator]=(stdTypes)
  mStr {!<=size=2,>=size=3}
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(stdTypes),end=0}
Line 172
  true always 1
Line 173
  eType always 1
Line 179
  mTokType possible 7
  != {!<=-1,!>=2,1}
  :: always 6
  eString always 6
  && always {!<=-1,!>=2}
  mTokType always !6
  != always {!<=-1,!>=2}
  :: always 7
  eChar always 7
Line 182
  mTokType possible {6,7}
  == {!<=-1,!>=2,1,0}
  :: always 6
  eString always 6
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  '"' always 34
  "L" always "L"
  || always {!<=-1,!>=2}
Line 183
  mTokType possible 7
  == {!<=-1,!>=2,1}
  :: always 7
  eChar always 7
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  '\'' always 39
  "L" always "L"
Line 186
  ( always {!<=-1,!>=2}
Line 188
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 189
  return always {!<=-1,!>=2}
  false always 0
Line 192
  return always {!<=-1,!>=2}
  false always 0
Line 194
  return always {!<=-1,!>=2}
  true always 1
Line 200
  "\"" always "\""
Line 202
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  0 always 0
  != always {!<=-1,!>=2}
  '"' always 34
Line 203
  ( possible lifetime[Iterator]=(mStr)
  0 always 0
  0 always 0
  ( always !<=-1
  '"' always 34
Line 210
  == always {!<=-1,!>=2}
  eString always 6
Line 212
  :: always !<=-1
  pos always !<=-1
  pos always !<=-1
  = always 0
  0U always 0
Line 213
  pos always !<=-1
  = always !<=-1
  ( always !<=-1
  '\\' always 92
  pos {!<=-1,0}
  != always {!<=-1,!>=2}
Line 214
  pos always !<=-1
  1U always 1
Line 215
  [ possible {110,114,116}
  pos always !<=-1
  >= {!<=-1,!>=2,1}
  'a' always 97
Line 216
  [ {114,116,>=97,!<=96}
  pos always !<=-1
  == {!<=-1,!>=2,0}
  'n' always 110
Line 217
  pos always !<=-1
  = always 10
  '\n' always 10
Line 218
  [ {116,>=97,!<=96,!110}
  pos always !<=-1
  == {!<=-1,!>=2,0}
  'r' always 114
Line 219
  pos always !<=-1
  = always 13
  '\r' always 13
Line 220
  [ {>=97,!<=96,!110,!114}
  pos always !<=-1
  == {!<=-1,!>=2,>=0}
  't' always 116
Line 221
  pos always !<=-1
  = always 9
  '\t' always 9
Line 223
  [ possible {10,13,9}
  pos always !<=-1
  == {!<=-1,!>=2,0}
  '0' always 48
Line 224
  0 always 0
  pos always !<=-1
Line 225
  pos always !<=-1
  ++ always !<=-1
Line 232
  mNext possible 0
  && always {!<=-1,!>=2}
  > always {!<=-1,!>=2}
  0 always 0
Line 233
  = always !0
  mNext always !0
Line 236
  n {symbolic=(mNext),symbolic=(n->mLink->mLink),!0}
  && always {!<=-1,!>=2}
  n {symbolic=(mNext),!0}
  . always !0
  == always {!<=-1,!>=2}
  n {symbolic=(mNext),!0}
Line 237
  n {symbolic=(mNext),!0,symbolic=(n->mLink->mLink)}
  nullptr always 0
Line 239
  n {symbolic=(mNext),!0}
Line 240
  n always !0
Line 241
  -- always !<=-1
  count always !<=0
Line 244
  mNext possible 0
Line 245
  mNext always !0
  this always !0
Line 247
  mTokensFrontBack always !0
  = always !0
  this always !0
Line 252
  mPrevious possible 0
  && always {!<=-1,!>=2}
  > always {!<=-1,!>=2}
  0 always 0
Line 253
  = always !0
  mPrevious always !0
Line 256
  p {symbolic=(mPrevious),symbolic=(p->mLink->mLink),!0}
  && always {!<=-1,!>=2}
  p {symbolic=(mPrevious),!0}
  . always !0
  == always {!<=-1,!>=2}
  p {symbolic=(mPrevious),!0}
Line 257
  p {symbolic=(mPrevious),!0,symbolic=(p->mLink->mLink)}
  nullptr always 0
Line 259
  p {symbolic=(mPrevious),!0}
Line 260
  p always !0
Line 261
  -- always !<=-1
  count always !<=0
Line 264
  mPrevious possible 0
Line 265
  mPrevious always !0
  this always !0
Line 267
  mTokensFrontBack always !0
  = always !0
  this always !0
Line 273
  mNext always !0
Line 274
  mNext always !0
Line 275
  mFlags always !<=-1
  mNext always !0
  . always !<=-1
  mFlags always !<=-1
Line 276
  mNext always !0
Line 278
  . always !0
Line 279
  this always !0
Line 283
  . always !0
Line 287
  . always !0
  = always !0
  this always !0
Line 288
  this always !0
Line 289
  this always !0
  . always !0
Line 298
  mFlags always !<=-1
  = always !<=-1
  . always !<=-1
  mFlags always !<=-1
Line 301
  = always 0
  nullptr always 0
Line 303
  . always !0
Line 304
  this always !0
Line 308
  mLink always !0
  this always !0
Line 314
  mNext always !0
Line 315
  nullptr always 0
Line 318
  mPrevious always !0
Line 319
  nullptr always 0
Line 324
  ";" always ";"
Line 332
  ( always !0
Line 335
  ( always !0
Line 339
  ( always !0
Line 342
  ( always !0
Line 345
  end possible symbolic=(end->mTokensFrontBack->back)
  ( possible 0
Line 347
  end possible symbolic=(end->mTokensFrontBack->back)
  && always {!<=-1,!>=2}
  . always !0
  == always {!<=-1,!>=2}
Line 348
  end possible symbolic=(end->mTokensFrontBack->back)
Line 349
  = always !0
  ( always !0
Line 354
  != always {!<=-1,!>=2}
  ( possible 0
Line 363
  = always !0
  this always !0
Line 364
  index possible {2@75,1@75,-2@207,-1@32573,-3@38205,3@247,0@1541182}
  > always {!<=-1,!>=2}
  0 always 0
  && always {!<=-1,!>=2}
  tok possible symbolic=(this)
Line 365
  tok always !0
Line 366
  -- {>=0,!<=-1,1@75,2@247}
  index {>=1,!<=0,2@75,3@247}
Line 368
  index possible {<=0,-2@207,-1@32573,-3@38205}
  < {!<=-1,!>=2,<=0}
  0 always 0
  && always {!<=-1,!>=2}
Line 369
  tok always !0
Line 370
  ++ {<=0,!>=1}
  index {<=-1,!>=0}
Line 372
  tok possible 0
Line 377
  this always !0
  index possible {1@6020,-1@32900}
Line 378
  ! always {!<=-1,!>=2}
Line 379
  this always !0
  "Internal error. Token::linkAt called with index outside the tokens range." always "Internal error. Token::linkAt called with index outside the tokens range."
Line 381
  tok always !0
Line 386
  this always !0
  index possible {-1@127,-3@149,2@217}
Line 387
  tok always !0
Line 390
  & always !0
Line 394
  0 always 0
Line 395
  '\0' always 0
Line 396
  ' ' always 32
Line 397
  '|' always 124
Line 399
  1 always 1
Line 400
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  "%" always "%"
Line 401
  1 always 1
Line 403
  'v' always 118
Line 404
  3 always 3
  == always {!<=-1,!>=2}
  '%' always 37
Line 405
  4 always 4
Line 406
  != always {!<=-1,!>=2}
  0 always 0
Line 407
  1 always 1
Line 409
  varid possible symbolic=(tok->varId())
  == always {!<=-1,!>=2}
  0 always 0
Line 410
  ( inconclusive lifetime[SubObject]=(tok)
  "Internal error. Token::Match called with varid 0. Please report this to Cppcheck developers" always "Internal error. Token::Match called with varid 0. Please report this to Cppcheck developers"
Line 413
  6 always 6
Line 415
  == always {!<=-1,!>=2}
  varid always !0
Line 416
  1 always 1
Line 419
  't' always 116
Line 422
  5 always 5
Line 423
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  0 always 0
  && always {!<=-1,!>=2}
  != always {!<=-1,!>=2}
  "delete" always "delete"
  || always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 424
  1 always 1
Line 427
  'a' always 97
Line 430
  3 always 3
  == always {!<=-1,!>=2}
  '%' always 37
Line 431
  4 always 4
Line 432
  1 always 1
Line 434
  7 always 7
Line 435
  ( always {!<=-1,!>=2}
Line 436
  1 always 1
Line 440
  'n' always 110
Line 443
  4 always 4
  == always {!<=-1,!>=2}
  '%' always 37
Line 444
  5 always 5
Line 445
  ( always {!<=-1,!>=2}
Line 446
  1 always 1
Line 448
  4 always 4
Line 449
  ( always {!<=-1,!>=2}
Line 450
  1 always 1
Line 454
  'c' always 99
Line 455
  1 always 1
Line 457
  0 always 0
  == always {!<=-1,!>=2}
  'h' always 104
Line 458
  4 always 4
Line 459
  == always {!<=-1,!>=2}
  :: always 7
  eChar always 7
Line 460
  1 always 1
Line 463
  1 always 1
  == always {!<=-1,!>=2}
  'p' always 112
Line 464
  3 always 3
Line 465
  ( always {!<=-1,!>=2}
Line 466
  1 always 1
Line 470
  4 always 4
Line 471
  ( always {!<=-1,!>=2}
Line 472
  1 always 1
Line 476
  's' always 115
Line 479
  4 always 4
Line 480
  == always {!<=-1,!>=2}
  :: always 6
  eString always 6
Line 481
  1 always 1
Line 484
  'b' always 98
Line 487
  5 always 5
Line 488
  ( always {!<=-1,!>=2}
Line 489
  1 always 1
Line 492
  'o' always 111
Line 494
  1 always 1
  == always {!<=-1,!>=2}
  '%' always 37
Line 496
  0 always 0
  == always {!<=-1,!>=2}
  'p' always 112
Line 497
  2 always 2
Line 498
  ( always {!<=-1,!>=2}
Line 499
  1 always 1
Line 503
  2 always 2
Line 504
  == always {!<=-1,!>=2}
  :: always 15
  eBitOp always 15
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  "|" always "|"
Line 505
  1 always 1
Line 511
  4 always 4
Line 512
  == always {!<=-1,!>=2}
  :: always 14
  eLogicalOp always 14
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  "||" always "||"
Line 513
  1 always 1
Line 519
  ( inconclusive lifetime[SubObject]=(tok)
  "Unexpected command" always "Unexpected command"
Line 522
  == always {!<=-1,!>=2}
  '|' always 124
Line 523
  1 always 1
Line 525
  -1 always -1
Line 527
  0xFFFF always 65535
Line 532
  = {lifetime[Object]=(tok->str()),!0}
  ( {lifetime[Object]=(tok->str()),!0}
Line 533
  = {lifetime[Object]=(tok->str()),symbolic=(tok->str().c_str()),!0}
  needle {lifetime[Object]=(tok->str()),symbolic=(tok->str().c_str()),!0}
Line 535
  needlePointer possible {symbolic=(needle),lifetime[Object]=(tok->str()),symbolic=(tok->str().c_str())}
  == {!<=-1,!>=2,1}
  needle {lifetime[Object]=(tok->str()),symbolic=(tok->str().c_str()),symbolic=(needlePointer),!0}
  && always {!<=-1,!>=2}
  0 always 0
  == always {!<=-1,!>=2}
  '%' always 37
  && always {!<=-1,!>=2}
  1 always 1
  != always {!<=-1,!>=2}
  '|' always 124
  && always {!<=-1,!>=2}
  [ always !124
  1 always 1
  != always {!<=-1,!>=2}
  '\0' always 0
  && always {!<=-1,!>=2}
  [ always {!124,!0}
  1 always 1
  != always {!<=-1,!>=2}
  ' ' always 32
Line 537
  < always {!<=-1,!>=2}
  2 always 2
Line 538
  ret {<=1,!>=2}
Line 539
  * possible {symbolic=(*needlePointer),32,0}
  == {!<=-1,!>=2,0}
  '|' always 124
Line 540
  needlePointer possible lifetime[Object]=(tok->str())
  == always {!<=-1,!>=2}
  0 always 0
Line 542
  1 always 1
Line 545
  = {lifetime[Object]=(tok->str()),symbolic=(tok->str().c_str()),!0}
  needle {lifetime[Object]=(tok->str()),symbolic=(tok->str().c_str()),!0}
Line 547
  * possible 0
  needlePointer possible {symbolic=(needle),lifetime[Object]=(tok->str())}
  == {!<=-1,!>=2,0,1}
  * {32,0,!124}
Line 548
  * always symbolic=(*haystack)
  needlePointer possible lifetime[Object]=(tok->str())
  == always {!<=-1,!>=2}
  '\0' always 0
Line 549
  1 always 1
Line 550
  needlePointer possible lifetime[Object]=(tok->str())
Line 552
  * {!symbolic=(*needlePointer),0,!124}
  == {!<=-1,!>=2,0}
  ' ' always 32
  || always {!<=-1,!>=2}
  * always {!symbolic=(*needlePointer),!124,!32}
  == always {!<=-1,!>=2}
  '\0' always 0
Line 553
  needlePointer possible lifetime[Object]=(tok->str())
  == always {!<=-1,!>=2}
  needle {lifetime[Object]=(tok->str()),symbolic=(tok->str().c_str()),!0}
Line 554
  0 always 0
Line 560
  = {lifetime[Object]=(tok->str()),symbolic=(tok->str().c_str()),!0}
  needle {lifetime[Object]=(tok->str()),symbolic=(tok->str().c_str()),!0}
Line 565
  * possible {0,124}
  == {!<=-1,!>=2,0}
  ' ' always 32
  || {!<=-1,!>=2,0}
  * {124,!32}
  == {!<=-1,!>=2,0}
  '\0' always 0
Line 566
  -1 always -1
Line 568
  * always {!32,!0}
  == always {!<=-1,!>=2}
  '|' always 124
Line 571
  true always 1
Line 577
  == always {!<=-1,!>=2}
  '\0' always 0
Line 578
  1 always 1
Line 580
  -1 always -1
Line 583
  ( always {!<=-1,!>=2}
  , always !<=-1
  pattern_len always !<=-1
Line 585
  ! always {!<=-1,!>=2}
  tok possible symbolic=(var->declEndToken())@19587
Line 586
  return always {!<=-1,!>=2}
  false always 0
Line 587
  = always pattern
  pattern always pattern
Line 588
  pattern always {symbolic=(current),pattern}
  pattern_len always !<=-1
Line 589
  pattern always {symbolic=(current),pattern}
  ' ' always 32
  pattern_len always !<=-1
Line 590
  ! always {!<=-1,!>=2}
  next always symbolic=(static_cast<const char*>(std::memchr(pattern,' ',pattern_len)))
Line 593
  current possible {symbolic=(pattern),symbolic=(next)}
Line 594
  length always !<=-1
  = always !<=-1
  current possible symbolic=(pattern)
Line 596
  ! always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  length {symbolic=(next-current),!<=-1}
  != always {!<=-1,!>=2}
  tok always !0
  ( always !<=-1
  || always {!<=-1,!>=2}
  tok always !0
  ( {lifetime[Object]=(tok->mStr),!0}
  length {symbolic=(next-current),!<=-1,symbolic=(tok->mStr.length())}
Line 597
  return always {!<=-1,!>=2}
  false always 0
Line 600
  next always symbolic=(current)
Line 601
  ++ always symbolic=(next+1)
  current always symbolic=(next)
  ' ' always 32
Line 602
  ! always {!<=-1,!>=2}
Line 605
  tok always !0
Line 608
  return always {!<=-1,!>=2}
  true always 1
Line 611
  ( always {!<=-1,!>=2}
Line 614
  * possible 0
  != always {!<=-1,!>=2}
  word possible lifetime[Object]=(tok->str())@33
Line 615
  return always {!<=-1,!>=2}
  * always !symbolic=(*word)
  == always {!<=-1,!>=2}
  ' ' always 32
  && always {!<=-1,!>=2}
  * always !symbolic=(*str)
  word possible lifetime[Object]=(tok->str())@33
  == always {!<=-1,!>=2}
  0 always 0
Line 616
  * always symbolic=(*word)
  == always {!<=-1,!>=2}
  0 always 0
Line 620
  word possible lifetime[Object]=(tok->str())@33
Line 623
  return always {!<=-1,!>=2}
  true always 1
Line 629
  * possible {symbolic=(c),0}
  == {!<=-1,!>=2,0}
  ' ' always 32
  || always {!<=-1,!>=2}
  * always !32
  == always {!<=-1,!>=2}
  0 always 0
Line 630
  nullptr always 0
Line 632
  * always {!32,!0}
  == always {!<=-1,!>=2}
  c possible 93@29
Line 639
  ( always {!<=-1,!>=2}
Line 641
  = always pattern
  pattern always pattern
Line 642
  * possible {32,1}
  p possible {symbolic=(pattern),pattern}
Line 644
  * possible {0,32}
  p possible symbolic=(pattern)
  == {!<=-1,!>=2,0,1}
  ' ' always 32
Line 648
  * always !32
  p possible symbolic=(pattern)
  == always {!<=-1,!>=2}
  '\0' always 0
Line 651
  ! always {!<=-1,!>=2}
Line 653
  0 always 0
  == always {!<=-1,!>=2}
  '!' always 33
  && always {!<=-1,!>=2}
  1 always 1
  == always {!<=-1,!>=2}
  '!' always 33
  && always {!<=-1,!>=2}
  2 always 2
  != always {!<=-1,!>=2}
  '\0' always 0
Line 654
  && always {!<=-1,!>=2}
  * always !0
  != always {!<=-1,!>=2}
  ' ' always 32
Line 658
  return always {!<=-1,!>=2}
  false always 0
Line 662
  [ possible 33
  0 always 0
  == {!<=-1,!>=2,0}
  '[' always 91
  && always {!<=-1,!>=2}
  ']' always 93
Line 663
  tok always !0
  ( always !<=-1
  != always {!<=-1,!>=2}
  1 always 1
Line 664
  return always {!<=-1,!>=2}
  false always 0
Line 666
  1 always 1
Line 667
  chrFound always {!<=-1,!>=2}
  chrFound always {!<=-1,!>=2}
  = always 0
  false always 0
Line 668
  = always 0
  0 always 0
Line 669
  temp possible symbolic=(p+1)
  && always {!<=-1,!>=2}
  * always !0
  temp possible symbolic=(p+1)
  != always {!<=-1,!>=2}
  ' ' always 32
Line 670
  * {symbolic=(tok->str()[0]),!0,!32}
  temp possible symbolic=(p+1)
  == always {!<=-1,!>=2}
  ']' always 93
Line 674
  * always {!0,!32,!93}
  == always {!<=-1,!>=2}
  tok always !0
  0 always 0
Line 675
  chrFound always {!<=-1,!>=2}
  = always 1
  true always 1
Line 682
  > always {!<=-1,!>=2}
  1 always 1
  && always {!<=-1,!>=2}
  tok always !0
  0 always 0
  == always {!<=-1,!>=2}
  ']' always 93
Line 683
  chrFound always {!<=-1,!>=2}
  = always 1
  true always 1
Line 685
  ! {!<=-1,!>=2,0}
  chrFound {!<=-1,!>=2,1}
Line 686
  return always {!<=-1,!>=2}
  false always 0
Line 689
  p possible {symbolic=(temp),symbolic=(temp+1)}
  && always {!<=-1,!>=2}
  * always !0
  p possible symbolic=(temp)
  != always {!<=-1,!>=2}
  ' ' always 32
Line 690
  ++ possible symbolic=(temp+1)
  p possible symbolic=(temp)
Line 694
  0 always 0
  == always {!<=-1,!>=2}
  '!' always 33
  && always {!<=-1,!>=2}
  1 always 1
  == always {!<=-1,!>=2}
  '!' always 33
  && always {!<=-1,!>=2}
  2 always 2
  != always {!<=-1,!>=2}
  '\0' always 0
Line 695
  2 always 2
Line 696
  ( always {!<=-1,!>=2}
  tok always !0
  ( {lifetime[Object]=(tok->str()),!0}
Line 697
  return always {!<=-1,!>=2}
  false always 0
Line 698
  && always {!<=-1,!>=2}
  * always !0
  != always {!<=-1,!>=2}
  ' ' always 32
Line 704
  tok always !0
Line 705
  res possible -1
  == {!<=-1,!>=2,0}
  0 always 0
Line 707
  && always {!<=-1,!>=2}
  * always !0
  != always {!<=-1,!>=2}
  ' ' always 32
Line 710
  res always !0
  == always {!<=-1,!>=2}
  -1 always -1
Line 712
  return always {!<=-1,!>=2}
  false always 0
Line 716
  * possible {0,32}
  && {!<=-1,!>=2,0}
  * {32,!0}
  != {!<=-1,!>=2,0}
  ' ' always 32
Line 719
  tok always !0
Line 723
  return always {!<=-1,!>=2}
  true always 1
Line 728
  != always {!<=-1,!>=2}
  nullptr always 0
Line 729
  == always {!<=-1,!>=2}
  eString always 6
Line 731
  = always 0
  0 always 0
Line 733
  = {lifetime[Iterator]=(str),start=0}
  ( {lifetime[Iterator]=(str),start=0}
Line 734
  = {lifetime[Iterator]=(str),end=0}
  ( {lifetime[Iterator]=(str),end=0}
Line 736
  it possible {lifetime[Iterator]=(str),symbolic=(str.begin()),start=0}
  != always {!<=-1,!>=2}
  end {lifetime[Iterator]=(str),symbolic=(str.end()),end=0}
Line 737
  it {lifetime[Iterator]=(str),!symbolic=(end),!end=0}
  == always {!<=-1,!>=2}
  '\\' always 92
Line 738
  ++ always !symbolic=(end+1)
  it {lifetime[Iterator]=(str),!symbolic=(end),!end=0}
Line 741
  it {lifetime[Iterator]=(str),!symbolic=(end+1)}
  == always {!<=-1,!>=2}
  '0' always 48
Line 745
  == always {!<=-1,!>=2}
  '\0' always 0
Line 757
  != always {!<=-1,!>=2}
  nullptr always 0
Line 758
  == always {!<=-1,!>=2}
  eString always 6
Line 760
  = always 1
  1 always 1
Line 761
  = always 0
  0 always 0
  i possible 0
  < always {!<=-1,!>=2}
  ( always !<=-1
Line 762
  == always {!<=-1,!>=2}
  '\\' always 92
Line 771
  != always {!<=-1,!>=2}
  nullptr always 0
  && always {!<=-1,!>=2}
  tok always !0
  == always {!<=-1,!>=2}
  eString always 6
Line 772
  = always 1
  1 always 1
Line 774
  ( always !0
Line 775
  = always 0
  0 always 0
Line 776
  = always !<=-1
  ( always !<=-1
Line 778
  sizeofType possible 1
Line 783
  != always {!<=-1,!>=2}
  nullptr always 0
Line 785
  = {lifetime[Iterator]=(str),start=0}
  ( {lifetime[Iterator]=(str),start=0}
Line 786
  = {lifetime[Iterator]=(str),end=0}
  ( {lifetime[Iterator]=(str),end=0}
Line 788
  it inconclusive {lifetime[Iterator]=(str),symbolic=(str.begin()),start=0}
  != always {!<=-1,!>=2}
  end {lifetime[Iterator]=(str),symbolic=(str.end()),end=0}
Line 789
  == always {!<=-1,!>=2}
  0 always 0
Line 790
  it {lifetime[Iterator]=(str),symbolic=(str.begin()),!symbolic=(end),start=0,!end=0}
  == always {!<=-1,!>=2}
  '\0' always 0
Line 791
  "\\0" always "\\0"
Line 793
  1 always 1
  * {92,!0}
  it {lifetime[Iterator]=(str),symbolic=(str.begin()),!symbolic=(end),!end=0}
Line 794
  it inconclusive {lifetime[Iterator]=(str),symbolic=(str.begin())}
  == always {!<=-1,!>=2}
  '\\' always 92
Line 795
  it inconclusive lifetime[Iterator]=(str)
Line 796
  it inconclusive lifetime[Iterator]=(str)
Line 801
  it {lifetime[Iterator]=(str),symbolic=(str.begin()),!symbolic=(end),start=0,!end=0}
  == always {!<=-1,!>=2}
  '\\' always 92
Line 802
  ++ always !symbolic=(end+1)
  it {lifetime[Iterator]=(str),!symbolic=(end),!end=0}
Line 804
  -- always !-1
  index always !0
Line 806
  == always {!<=-1,!>=2}
  0 always 0
Line 808
  "\\0" always "\\0"
Line 828
  != always {!<=-1,!>=2}
Line 834
  = always !0
  this always !0
Line 835
  == always {!<=-1,!>=2}
  "," always ","
Line 837
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "(|{|[|<" always "(|{|[|<"
Line 838
  = always !0
  ( always !0
Line 839
  ( always {!<=-1,!>=2}
  ")|;" always ")|;"
Line 840
  nullptr always 0
Line 842
  nullptr always 0
Line 847
  = always !0
  this always !0
  tok possible {symbolic=(temp),symbolic=(tok->findClosingBracket())}
Line 848
  ( possible size=1
  == always {!<=-1,!>=2}
  "," always ","
Line 850
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "(|{|[" always "(|{|["
Line 851
  = always !0
  ( always !0
Line 852
  == always {!<=-1,!>=2}
  "<" always "<"
Line 854
  temp always symbolic=(tok->findClosingBracket())
Line 855
  = {symbolic=(tok->findClosingBracket()),!0}
  temp {symbolic=(tok->findClosingBracket()),!0}
Line 856
  ( always {!<=-1,!>=2}
  ")|;" always ")|;"
Line 857
  nullptr always 0
Line 859
  nullptr always 0
Line 864
  = always !0
  this always !0
Line 865
  == always {!<=-1,!>=2}
  "," always ","
Line 867
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "(|{|[|<" always "(|{|[|<"
Line 868
  = always !0
  ( always !0
Line 869
  ( always {!<=-1,!>=2}
  ">|;" always ">|;"
Line 870
  nullptr always 0
Line 872
  nullptr always 0
Line 875
  ( always {!<=-1,!>=2}
Line 878
  = always !0
  ( always !0
Line 880
  return always {!<=-1,!>=2}
  -1 always -1
  == always {!<=-1,!>=2}
  "operator" always "operator"
Line 885
  != always {!<=-1,!>=2}
  "<" always "<"
Line 886
  nullptr always 0
Line 888
  ! always {!<=-1,!>=2}
Line 889
  nullptr always 0
Line 891
  ! always {!<=-1,!>=2}
  mPrevious always !0
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
Line 892
  ( always {!<=-1,!>=2}
  mPrevious always !0
  "operator %op% <" always "operator %op% <"
  || always {!<=-1,!>=2}
Line 893
  ( always {!<=-1,!>=2}
  mPrevious always !0
  -2 always -2
  "operator [([] [)]] <" always "operator [([] [)]] <"
Line 894
  nullptr always 0
Line 896
  = always 0
  nullptr always 0
Line 897
  templateParameter always {!<=-1,!>=2}
  -1 always -1
  == always {!<=-1,!>=2}
  "template" always "template"
Line 900
  isDecl always {!<=-1,!>=2}
  isDecl always {!<=-1,!>=2}
  = always 1
  true always 1
Line 902
  == always {!<=-1,!>=2}
  "=" always "="
Line 903
  isDecl always {!<=-1,!>=2}
  = always 0
  false always 0
Line 904
  ( always {!<=-1,!>=2}
  "template <" always "template <"
Line 905
  isDecl always {!<=-1,!>=2}
  = always 1
  true always 1
Line 906
  ( always {!<=-1,!>=2}
  "[;{}]" always "[;{}]"
Line 910
  depth always !<=-1
  depth always !<=-1
  = always 0
  0 always 0
Line 911
  = always !0
  this always !0
  != always {!<=-1,!>=2}
  nullptr always 0
Line 912
  ( always {!<=-1,!>=2}
  "{|[|(" always "{|[|("
Line 914
  ! always {!<=-1,!>=2}
Line 915
  nullptr always 0
Line 916
  ( always {!<=-1,!>=2}
  "}|]|)|;" always "}|]|)|;"
Line 917
  nullptr always 0
Line 919
  ( possible {size=1,size=2,size=3}
  == {!<=-1,!>=2,0}
  "<" always "<"
  && always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 920
  ( always !0
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  ( always !0
  && always {!<=-1,!>=2}
Line 921
  templateParameter always {!<=-1,!>=2}
  ? {1,!<=-1,!>=2}
  ( possible lifetime[Iterator]=(templateParameters)
  -1 always -1
  == always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(templateParameters),end=0}
  : always 1
  true always 1
Line 922
  ++ always !<=0
  depth always !<=-1
Line 923
  ( possible {size=2,size=3,size=1}
  == {!<=-1,!>=2,0}
  ">" always ">"
Line 924
  -- always !<=-1
  depth always !<=-1
  == always {!<=-1,!>=2}
  0 always 0
Line 926
  ( possible {size=3,size=1}
  == {!<=-1,!>=2,0}
  ">>" always ">>"
  || always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  ">>=" always ">>="
Line 927
  ! always {!<=-1,!>=2}
  isDecl always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  depth always !<=-1
  == always {!<=-1,!>=2}
  1 always 1
Line 929
  depth always !<=-1
  <= always {!<=-1,!>=2}
  2 always 2
Line 931
  depth {!<=2,>=3}
  -= always !<=-1
  2 always 2
Line 934
  templateParameter always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  depth always !<=-1
  == always {!<=-1,!>=2}
  1 always 1
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  "," always ","
  && always {!<=-1,!>=2}
Line 935
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "class|typename|." always "class|typename|."
Line 936
  -1 always -1
Line 945
  ( always !0
  this always !0
Line 950
  != always {!<=-1,!>=2}
  ">" always ">"
Line 951
  nullptr always 0
Line 953
  = always 0
  nullptr always 0
Line 955
  depth always !<=-1
  depth always !<=-1
  = always 0
  0 always 0
Line 956
  = always !0
  this always !0
  != always {!<=-1,!>=2}
  nullptr always 0
Line 957
  ( always {!<=-1,!>=2}
  "}|]|)" always "}|]|)"
Line 959
  ! always {!<=-1,!>=2}
Line 960
  nullptr always 0
Line 961
  ( always {!<=-1,!>=2}
  "{|{|(|;" always "{|{|(|;"
Line 962
  nullptr always 0
Line 963
  ( possible size=1
  == always {!<=-1,!>=2}
  ">" always ">"
Line 964
  ++ always !<=0
  depth always !<=-1
Line 965
  == always {!<=-1,!>=2}
  "<" always "<"
Line 966
  -- always !<=-1
  depth always !<=-1
  == always {!<=-1,!>=2}
  0 always 0
Line 977
  ( always !0
  this always !0
Line 982
  , always !<=-1
  pattern_len always !<=-1
Line 985
  ( always {!<=-1,!>=2}
  pattern_len always !<=-1
Line 988
  nullptr always 0
Line 991
  , always !<=-1
  pattern_len always !<=-1
Line 993
  && always {!<=-1,!>=2}
  tok always !0
  != always {!<=-1,!>=2}
Line 994
  ( always {!<=-1,!>=2}
  pattern_len always !<=-1
Line 997
  nullptr always 0
Line 1003
  ( always {!<=-1,!>=2}
  pattern possible "{|;"@175
Line 1006
  nullptr always 0
Line 1011
  && always {!<=-1,!>=2}
  tok always !0
  != always {!<=-1,!>=2}
Line 1012
  ( always {!<=-1,!>=2}
  varId possible 0@34
Line 1015
  nullptr always 0
Line 1020
  = possible 0
  f possible 0
Line 1022
  f always !0
  ( always {!<=-1,!>=2}
Line 1023
  eLambda always 19
Line 1025
  eFunction always 2
Line 1026
  == always {!<=-1,!>=2}
  eFunction always 2
Line 1027
  eName always 4
Line 1030
  , always {!<=-1,!>=2}
  prepend always {!<=-1,!>=2}
Line 1033
  ( always {!<=-1,!>=2}
Line 1034
  = always !0
  this always !0
Line 1037
  newToken possible {symbolic=(this),size=0}
Line 1038
  ! {!<=-1,!>=2,0}
  originalNameStr possible size=0
  ( {!<=-1,!>=2,1}
Line 1041
  != always {!<=-1,!>=2}
  this always !0
Line 1042
  newToken always !symbolic=(this)
Line 1043
  newToken always !symbolic=(this)
Line 1044
  newToken always !symbolic=(this)
Line 1046
  prepend {!<=-1,!>=2,0}
Line 1047
  this always !0
Line 1048
  newToken always !symbolic=(this)
  this always !0
  ( always !0
Line 1049
  newToken always !symbolic=(this)
  newToken always !symbolic=(this)
Line 1051
  mTokensFrontBack always !0
  = always !symbolic=(this)
  newToken always !symbolic=(this)
Line 1053
  this always !0
  newToken always !symbolic=(this)
Line 1054
  this always !0
Line 1056
  this always !0
Line 1057
  newToken always !symbolic=(this)
  this always !0
  ( always !0
Line 1058
  newToken always !symbolic=(this)
  newToken always !symbolic=(this)
Line 1060
  mTokensFrontBack always !0
  = always !symbolic=(this)
  newToken always !symbolic=(this)
Line 1062
  this always !0
  newToken always !symbolic=(this)
Line 1063
  this always !0
Line 1068
  ( possible size=1
  == always {!<=-1,!>=2}
  "{" always "{"
Line 1072
  ( always {!<=-1,!>=2}
  tok1 possible symbolic=(newToken)
  ( possible 0
  "const|volatile|final|override|&|&&|noexcept" always "const|volatile|final|override|&|&&|noexcept"
Line 1074
  tok1 possible symbolic=(newToken)
  && always {!<=-1,!>=2}
  -1 always -1
  == always {!<=-1,!>=2}
  ")" always ")"
Line 1075
  -1 always -1
Line 1076
  ( always {!<=-1,!>=2}
  "throw|noexcept" always "throw|noexcept"
Line 1078
  ( always {!<=-1,!>=2}
  "const|volatile|final|override|&|&&|noexcept" always "const|volatile|final|override|&|&&|noexcept"
Line 1080
  -1 always -1
  != always {!<=-1,!>=2}
  ")" always ")"
Line 1082
  ( always {!<=-1,!>=2}
  -2 always -2
  ":|, %name%" always ":|, %name%"
Line 1083
  -2 always -2
Line 1084
  -1 always -1
  != always {!<=-1,!>=2}
  ")" always ")"
Line 1087
  -1 always -1
  == always {!<=-1,!>=2}
  ">" always ">"
Line 1089
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  tok1 always !0
  -3 always -3
  "%name% :: %name%" always "%name% :: %name%"
Line 1090
  tok1 always !0
  -2 always -2
Line 1091
  -1 always -1
Line 1092
  ( always {!<=-1,!>=2}
  -2 always -2
  ":: %name%" always ":: %name%"
Line 1093
  -3 always -3
  " :: " always " :: "
Line 1094
  -2 always -2
Line 1101
  ( always {!<=-1,!>=2}
  "%name%|>" always "%name%|>"
Line 1103
  nameTok possible {symbolic=(newToken->previous()),0}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  nameTok {symbolic=(newToken->previous()),!0}
  "namespace|class|struct|union %name% {|::|:|<" always "namespace|class|struct|union %name% {|::|:|<"
Line 1104
  nameTok always !0
Line 1106
  nameTok possible {symbolic=(newToken->previous()),0}
Line 1107
  nameTok always !0
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  nameTok always !0
  "{|:|<" always "{|:|<"
Line 1109
  " " always " "
Line 1111
  ( always !<=-1
  > always {!<=-1,!>=2}
  0 always 0
  nextScopeNameAddition {>=size=1,!<=size=0}
  0 always 0
  nextScopeNameAddition {>=size=1,!<=size=0}
  ( {>=1,!<=0}
  - {!<=-1,>=0}
  1 always 1
Line 1116
  = always !0
  ( always !0
  nullptr always 0
Line 1118
  ! {!<=-1,!>=2,0}
  newScopeInfo {symbolic=(std::make_shared<ScopeInfo2>(mImpl->mScopeInfo->name,nullptr,mImpl->mScopeInfo->usingNamespaces)),!0}
  . possible size=0
  ( {!<=-1,!>=2,1}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  newScopeInfo {symbolic=(std::make_shared<ScopeInfo2>(mImpl->mScopeInfo->name,nullptr,mImpl->mScopeInfo->usingNamespaces)),!0}
  . always !size=0
  " :: " always " :: "
Line 1119
  newScopeInfo {symbolic=(std::make_shared<ScopeInfo2>(mImpl->mScopeInfo->name,nullptr,mImpl->mScopeInfo->usingNamespaces)),!0}
  nextScopeNameAddition possible size=0
Line 1120
  = always ""
  "" always ""
Line 1122
  newScopeInfo {symbolic=(std::make_shared<ScopeInfo2>(mImpl->mScopeInfo->name,nullptr,mImpl->mScopeInfo->usingNamespaces)),!0}
Line 1123
  ( possible size=1
  == always {!<=-1,!>=2}
  "}" always "}"
Line 1125
  = always 0
  0 always 0
Line 1126
  matchingTok possible {symbolic=(newToken->previous()),0}
  && always {!<=-1,!>=2}
  depth possible 0
  != {!<=-1,!>=2,0}
  0 always 0
  || always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  matchingTok {symbolic=(newToken->previous()),!0}
  "{" always "{"
Line 1127
  ( always {!<=-1,!>=2}
  matchingTok always !0
  "}" always "}"
Line 1128
  ( always {!<=-1,!>=2}
  matchingTok always !0
  "{" always "{"
Line 1129
  matchingTok always !0
Line 1131
  matchingTok possible {symbolic=(newToken->previous()),0}
  && always {!<=-1,!>=2}
  matchingTok always !0
Line 1132
  matchingTok always !0
  ( always !0
Line 1135
  prepend always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 1136
  ( always !0
Line 1138
  = always !0
  . always !0
Line 1140
  == always {!<=-1,!>=2}
  ";" always ";"
Line 1142
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  ( always !0
  ";|{" always ";|{"
Line 1143
  ( always {!<=-1,!>=2}
  "using namespace %name% ::|;" always "using namespace %name% ::|;"
Line 1144
  2 always 2
Line 1146
  && always {!<=-1,!>=2}
  tok1 always !0
  != always {!<=-1,!>=2}
  ";" always ";"
Line 1147
  ! {!<=-1,!>=2,0}
  nameSpace possible size=0
  ( {!<=-1,!>=2,1}
Line 1148
  nameSpace always !size=0
  " " always " "
Line 1149
  tok1 always !0
Line 1150
  tok1 always !0
Line 1163
  ! always {!<=-1,!>=2}
  begin possible symbolic=(end)
  || always {!<=-1,!>=2}
  begin always !0
  == always {!<=-1,!>=2}
Line 1166
  begin always {!symbolic=(end),!0}
  && always {!<=-1,!>=2}
  begin always {!symbolic=(end),!0}
  ( always !0
  != always {!<=-1,!>=2}
  end always !symbolic=(begin)
Line 1167
  begin always {!symbolic=(end),!0}
Line 1173
  != always {!<=-1,!>=2}
  nullptr always 0
Line 1174
  != always {!<=-1,!>=2}
  nullptr always 0
Line 1175
  != always {!<=-1,!>=2}
Line 1182
  && always {!<=-1,!>=2}
  title always !0
  0 always 0
Line 1183
  "\n### " always "\n### "
  title always !0
  " ###\n" always " ###\n"
Line 1184
  nullptr always 0
  nullptr always 0
Line 1189
  && always {!<=-1,!>=2}
  title always !0
  0 always 0
Line 1190
  "\n### " always "\n### "
  title always !0
  " ###\n" always " ###\n"
Line 1191
  & {lifetime[Address]=(fileNames),!0}
  nullptr always 0
Line 1197
  = always !0
  this always !0
Line 1198
  end possible symbolic=(this)
  && always {!<=-1,!>=2}
  end {symbolic=(this),!0}
  < always {!<=-1,!>=2}
Line 1199
  end always !0
Line 1200
  nullptr always 0
  end possible 0
Line 1206
  . always {!<=-1,!>=2}
  attributes always {!<=-1,!>=2}
Line 1207
  ( always {!<=-1,!>=2}
Line 1208
  ret always size=0
  "unsigned " always "unsigned "
Line 1209
  ( always {!<=-1,!>=2}
Line 1210
  ret always size=0
  "signed " always "signed "
Line 1211
  ( always {!<=-1,!>=2}
Line 1212
  "_Complex " always "_Complex "
Line 1213
  ( always {!<=-1,!>=2}
Line 1214
  ! always {!<=-1,!>=2}
  mTokType possible 7
  == {!<=-1,!>=2,0}
  eString always 6
  || always {!<=-1,!>=2}
  mTokType always !6
  == always {!<=-1,!>=2}
  eChar always 7
Line 1215
  "long " always "long "
Line 1218
  . always {!<=-1,!>=2}
  macro always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 1219
  '$' always 36
Line 1220
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always !<=-1
  ' ' always 32
  != always {!<=-1,!>=2}
Line 1222
  != always {!<=-1,!>=2}
  ' ' always 32
Line 1223
  i always !32
Line 1225
  0 always 0
  != always {!<=-1,!>=2}
  '\"' always 34
  || always {!<=-1,!>=2}
  ( always !<=-1
  '\0' always 0
  == always {!<=-1,!>=2}
Line 1229
  == always {!<=-1,!>=2}
  '\0' always 0
Line 1230
  "\\0" always "\\0"
Line 1232
  i always !0
Line 1235
  . always {!<=-1,!>=2}
  varid always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  != always {!<=-1,!>=2}
  0 always 0
Line 1236
  '@' always 64
Line 1237
  . always {!<=-1,!>=2}
  idtype always {!<=-1,!>=2}
  "var" always "var"
  : always ""
  "" always ""
Line 1238
  . always !0
Line 1239
  . always {!<=-1,!>=2}
  exprid always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  != always {!<=-1,!>=2}
  0 always 0
Line 1240
  '@' always 64
Line 1241
  . always {!<=-1,!>=2}
  idtype always {!<=-1,!>=2}
  "expr" always "expr"
  : always ""
  "" always ""
Line 1242
  . always !0
Line 1248
  varid always {!<=-1,!>=2}
  attributes always {!<=-1,!>=2}
  macro always {!<=-1,!>=2}
Line 1251
  . always {!<=-1,!>=2}
  varid always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  varid always {!<=-1,!>=2}
Line 1252
  . always {!<=-1,!>=2}
  attributes always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  attributes always {!<=-1,!>=2}
Line 1253
  . always {!<=-1,!>=2}
  macro always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  macro always {!<=-1,!>=2}
Line 1259
  this always !0
  == {!<=-1,!>=2,0}
  end possible 0@15936
Line 1260
  "" always ""
Line 1264
  lineNumber always !<=-1
  lineNumber always !<=-1
  = always !<=-1
  - always !<=-1
  . {!<=-1,!>=2,0}
  linenumbers always {!<=-1,!>=2}
  ? always !<=-1
  1U always 1
  : always 0
  0U always 0
Line 1265
  fileIndex always !<=-1
  fileIndex always !<=-1
  = always !<=-1
  . {!<=-1,!>=2,0}
  files always {!<=-1,!>=2}
  ? always !<=-1
  ~ always 4294967295
  0U always 0
  : always 4294967295
Line 1267
  = always {!0,!symbolic=(end)}
  this always {!0,!symbolic=(end)}
  tok possible 0
  != always {!<=-1,!>=2}
  end always !symbolic=(this)
  = possible symbolic=(end)
  ( possible symbolic=(end)
Line 1268
  tok inconclusive 0
  && always {!<=-1,!>=2}
  "end precedes token" always "end precedes token"
Line 1269
  ! always {!<=-1,!>=2}
Line 1271
  fileChange {!<=-1,!>=2,0}
  fileChange always {!<=-1,!>=2}
  = always 0
  false always 0
Line 1272
  tok always !0
  != always {!<=-1,!>=2}
  fileIndex {!<=-1,4294967295}
Line 1273
  fileIndex always {!<=-1,!symbolic=(tok->mImpl->mFileIndex)}
  != always {!<=-1,!>=2}
  ~ always 4294967295
  0U always 0
Line 1274
  [ always !<=-1
  fileIndex always {!<=-1,!symbolic=(tok->mImpl->mFileIndex),!4294967295}
  = always {!<=-1,!symbolic=(fileIndex)}
  tok always !0
  . always !symbolic=(fileIndex)
Line 1277
  fileIndex always !<=-1
  = always {!<=-1,!symbolic=(fileIndex)}
  tok always !0
  . always !symbolic=(fileIndex)
Line 1278
  . always {!<=-1,!>=2}
  files always {!<=-1,!>=2}
Line 1279
  "\n\n##file " always "\n\n##file "
Line 1280
  && always {!<=-1,!>=2}
  fileNames always !0
  ( always !<=-1
  > always {!<=-1,!>=2}
  tok always !0
Line 1281
  fileNames always !0
  tok always !0
Line 1283
  fileIndex always !<=-1
Line 1284
  '\n' always 10
Line 1287
  lineNumber always !<=-1
  = always !<=-1
  [ always !<=-1
  fileIndex always !<=-1
Line 1288
  fileChange always {!<=-1,!>=2}
  = always 1
  true always 1
Line 1291
  . {!<=-1,!>=2,0}
  linebreaks always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  lineNumber always !<=-1
  != always {!<=-1,!>=2}
  tok always !0
  || always {!<=-1,!>=2}
  fileChange always {!<=-1,!>=2}
Line 1292
  lineNumber {!<=-1,>=symbolic=(tok->linenr()+1),<=symbolic=(tok->linenr())}
  + always !<=3
  4 always 4
  < always {!<=-1,!>=2}
  tok {symbolic=(this),!0}
  && always {!<=-1,!>=2}
  fileIndex always !<=-1
  == always {!<=-1,!>=2}
  tok always !0
Line 1293
  '\n' always 10
Line 1294
  lineNumber {!<=-1,<=symbolic=(tok->linenr()-5),!>=symbolic=(tok->linenr()-4)}
  + always !<=0
  1 always 1
Line 1295
  ":\n|\n" always ":\n|\n"
Line 1296
  tok always !0
  ( {>=symbolic=(lineNumber+4+1),!<=symbolic=(lineNumber+4)}
  1 always 1
Line 1297
  ":\n" always ":\n"
Line 1298
  tok always !0
  ( {>=symbolic=(lineNumber+4+1),!<=symbolic=(lineNumber+4)}
Line 1299
  ": " always ": "
Line 1300
  this always !0
  == always {!<=-1,!>=2}
  tok always !0
  && always {!<=-1,!>=2}
  . always {!<=-1,!>=2}
  linenumbers always {!<=-1,!>=2}
Line 1301
  tok {!0,symbolic=(this)}
Line 1302
  ": " always ": "
Line 1303
  lineNumber always !<=-1
  > always {!<=-1,!>=2}
  tok always !0
Line 1304
  lineNumber always !<=-1
  = {!<=-1,<=symbolic=(lineNumber-1),!>=symbolic=(lineNumber)}
  tok always !0
  ( {<=symbolic=(lineNumber-1),!>=symbolic=(lineNumber)}
Line 1305
  '\n' always 10
Line 1306
  . always {!<=-1,!>=2}
  linenumbers always {!<=-1,!>=2}
Line 1307
  lineNumber always !<=-1
Line 1308
  ':' always 58
Line 1309
  ' ' always 32
Line 1312
  lineNumber {!<=-1,<=symbolic=(tok->linenr())}
  < always {!<=-1,!>=2}
  tok always !0
  ( possible >=symbolic=(lineNumber)
Line 1313
  ++ {!<=0,symbolic=(tok->linenr()),!>=symbolic=(tok->linenr()+1)}
  lineNumber {!<=-1,symbolic=(tok->linenr()-1),!>=symbolic=(tok->linenr())}
Line 1314
  '\n' always 10
Line 1315
  . always {!<=-1,!>=2}
  linenumbers always {!<=-1,!>=2}
Line 1316
  lineNumber {!<=-1,symbolic=(tok->linenr()),!>=symbolic=(tok->linenr()+1)}
Line 1317
  ':' always 58
Line 1318
  lineNumber always {!<=-1,!>=symbolic=(tok->linenr()+1)}
  == always {!<=-1,!>=2}
  tok always !0
Line 1319
  ' ' always 32
Line 1323
  lineNumber always !<=-1
  = {!<=-1,<=symbolic=(lineNumber)}
  tok {symbolic=(this),!0}
  ( possible <=symbolic=(lineNumber)
Line 1326
  tok {symbolic=(this),!0}
Line 1327
  tok {symbolic=(this),!0}
  != always {!<=-1,!>=2}
  end always !symbolic=(this)
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  . always {!<=-1,!>=2}
  linebreaks always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  tok always !0
  ( always !symbolic=(end)
  == always {!<=-1,!>=2}
  tok always !0
  && always {!<=-1,!>=2}
  tok always !0
  ( always !symbolic=(end)
  == always {!<=-1,!>=2}
  tok always !0
Line 1328
  ' ' always 32
Line 1330
  . always {!<=-1,!>=2}
  linebreaks always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  . always {!<=-1,!>=2}
  files always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  . always {!<=-1,!>=2}
  linenumbers always {!<=-1,!>=2}
Line 1331
  '\n' always 10
Line 1334
  varid always {!<=-1,!>=2}
  attributes always {!<=-1,!>=2}
  linenumbers always {!<=-1,!>=2}
  linebreaks always {!<=-1,!>=2}
  files always {!<=-1,!>=2}
Line 1337
  . always {!<=-1,!>=2}
  varid always {!<=-1,!>=2}
  = {!<=-1,!>=2,0@63}
  varid {!<=-1,!>=2,0@63}
Line 1338
  . always {!<=-1,!>=2}
  attributes always {!<=-1,!>=2}
  = {!<=-1,!>=2,0@62}
  attributes {!<=-1,!>=2,0@62}
Line 1339
  . always {!<=-1,!>=2}
  macro always {!<=-1,!>=2}
  = {!<=-1,!>=2,0@62}
  attributes {!<=-1,!>=2,0@62}
Line 1340
  . always {!<=-1,!>=2}
  linenumbers always {!<=-1,!>=2}
  = {!<=-1,!>=2,1@62,0@63}
  linenumbers {!<=-1,!>=2,1@62,0@63}
Line 1341
  . always {!<=-1,!>=2}
  linebreaks always {!<=-1,!>=2}
  = {!<=-1,!>=2,1@62,0@63}
  linebreaks {!<=-1,!>=2,1@62,0@63}
Line 1342
  . always {!<=-1,!>=2}
  files always {!<=-1,!>=2}
  = {!<=-1,!>=2,1@62,0@63}
  files {!<=-1,!>=2,1@62,0@63}
Line 1343
  fileNames possible 0@62
  end possible 0@62
Line 1346
  , always {!<=-1,!>=2}
  attributes always {!<=-1,!>=2}
Line 1348
  false always 0
  attributes always {!<=-1,!>=2}
  false always 0
  false always 0
  false always 0
  nullptr always 0
Line 1351
  varid always {!<=-1,!>=2}
Line 1353
  varid always {!<=-1,!>=2}
  false always 0
  true always 1
  true always 1
  true always 1
  nullptr always 0
  nullptr always 0
Line 1358
  = possible 0@51
  tok possible 0@51
Line 1359
  tok2 possible {symbolic=(tok),0@51}
Line 1360
  this always !0
  == always {!<=-1,!>=2}
  tok2 {symbolic=(tok),!0}
Line 1361
  this {!0,symbolic=(this),symbolic=(tok2)}
  "Internal error. AST cyclic dependency." always "Internal error. AST cyclic dependency."
Line 1362
  tok2 always {!symbolic=(this),!0}
Line 1365
  this always !0
Line 1366
  = always !0
  this always !0
  ( always !0
Line 1367
  parent {symbolic=(this->astParent()),!0}
  == always {!<=-1,!>=2}
  this always !0
Line 1368
  parent {symbolic=(this->astParent()),!0}
  = always 0
  nullptr always 0
Line 1369
  parent {symbolic=(this->astParent()),!0}
  == always {!<=-1,!>=2}
  this always !0
Line 1370
  parent {symbolic=(this->astParent()),!0}
  = always 0
  nullptr always 0
Line 1372
  = possible 0@51
  tok possible 0@51
Line 1378
  nullptr always 0
Line 1381
  tok always !0
Line 1382
  this always !0
Line 1390
  nullptr always 0
Line 1393
  tok always !0
Line 1394
  this always !0
Line 1402
  = always 0
  0 always 0
Line 1403
  && always {!<=-1,!>=2}
  tok always !0
  != always {!<=-1,!>=2}
  end possible symbolic=(lambdaEnd)@39
Line 1404
  ( possible size=1
  == always {!<=-1,!>=2}
  "(" always "("
Line 1406
  == always {!<=-1,!>=2}
  ")" always ")"
Line 1407
  == always {!<=-1,!>=2}
  0 always 0
Line 1410
  -- always !-1
  par always !0
Line 1419
  = always 0
  0 always 0
Line 1420
  = possible {symbolic=(top)@40,symbolic=(lambdaEnd)@40,symbolic=(this)@40}
  end possible {symbolic=(top)@40,symbolic=(lambdaEnd)@40,symbolic=(this)@40}
  tok possible {symbolic=(top)@40,symbolic=(lambdaEnd)@40,symbolic=(this)@40}
  && always {!<=-1,!>=2}
  tok {!0,symbolic=(lambdaEnd)@40}
  != always {!<=-1,!>=2}
Line 1421
  tok possible symbolic=(lambdaEnd)@40
  ( possible size=1
  == always {!<=-1,!>=2}
  ")" always ")"
Line 1423
  == always {!<=-1,!>=2}
  "(" always "("
Line 1424
  == always {!<=-1,!>=2}
  0 always 0
Line 1427
  -- always !-1
  par always !0
Line 1430
  end possible symbolic=(lambdaEnd)@40
Line 1435
  = always !0
  this always !0
Line 1438
  = {symbolic=(this),!0}
  top {symbolic=(this),!0}
Line 1439
  start possible {symbolic=(top),symbolic=(this)}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  start possible {symbolic=(top),symbolic=(this)}
  ( always !0
  start possible {symbolic=(top),symbolic=(this)}
Line 1440
  = always !0
  ( always !0
Line 1443
  = {symbolic=(this),symbolic=(start),!0}
  top {symbolic=(this),symbolic=(start),!0}
Line 1444
  end possible {symbolic=(top),symbolic=(this),symbolic=(start)}
  && always {!<=-1,!>=2}
  end possible {symbolic=(top),symbolic=(this)}
  || always {!<=-1,!>=2}
  end possible {symbolic=(top),symbolic=(this)}
  ( always {!<=-1,!>=2}
Line 1446
  == always {!<=-1,!>=2}
  "[" always "["
Line 1449
  = always !0
  lambdaEnd always !0
Line 1453
  ( always {!<=-1,!>=2}
  "(|[|{" always "(|[|{"
  && always {!<=-1,!>=2}
Line 1454
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "( %type%" always "( %type%"
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
Line 1458
  ( always !0
  : always 1
Line 1462
  end possible {symbolic=(top),symbolic=(lambdaEnd),symbolic=(this)}
Line 1463
  end possible {symbolic=(top),symbolic=(lambdaEnd),symbolic=(this)}
Line 1464
  ( always {!<=-1,!>=2}
  "{" always "{"
Line 1469
  ( always {!<=-1,!>=2}
Line 1471
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  this always !0
  "%cop%|++|--" always "%cop%|++|--"
Line 1472
  return always {!<=-1,!>=2}
  false always 0
Line 1474
  ( always {!<=-1,!>=2}
  this always !0
  "*|&" always "*|&"
Line 1476
  ! always {!<=-1,!>=2}
  this always !0
Line 1477
  return always {!<=-1,!>=2}
  false always 0
Line 1479
  this always !0
  ( always !0
  == always {!<=-1,!>=2}
  "[" always "["
Line 1480
  return always {!<=-1,!>=2}
  false always 0
Line 1484
  operands always size=0
  this always !0
Line 1485
  ! {!<=-1,!>=2,1}
  operands possible size=1
  ( {!<=-1,!>=2,0}
Line 1486
  operands {size=1,!size=0}
Line 1487
  operands {size=1,!size=0}
Line 1488
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  > always {!<=-1,!>=2}
  0 always 0
Line 1489
  return always {!<=-1,!>=2}
  true always 1
Line 1491
  operands always !size=-1
  ( always !0
Line 1493
  ( always !0
Line 1494
  ( always {!<=-1,!>=2}
  "*|&" always "*|&"
Line 1495
  return always {!<=-1,!>=2}
  false always 0
Line 1499
  return always {!<=-1,!>=2}
  false always 0
Line 1502
  return always {!<=-1,!>=2}
  true always 1
Line 1505
  ( always {!<=-1,!>=2}
Line 1507
  ! always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
Line 1508
  return always {!<=-1,!>=2}
  false always 0
Line 1509
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  this always !0
  "++|--" always "++|--"
Line 1510
  return always {!<=-1,!>=2}
  true always 1
Line 1513
  = always 1
  1 always 1
  distance possible 1
  < {!<=-1,!>=2,1}
  10 always 10
  && always {!<=-1,!>=2}
  tokbefore possible symbolic=(mPrevious)
Line 1514
  tokbefore possible symbolic=(mPrevious)
  == always {!<=-1,!>=2}
  . possible symbolic=(tokafter)
Line 1515
  return always {!<=-1,!>=2}
  false always 0
Line 1516
  == always {!<=-1,!>=2}
  . always !symbolic=(tokbefore)
Line 1517
  return always {!<=-1,!>=2}
  true always 1
Line 1518
  tokbefore always !symbolic=(mImpl->mAstOperand1)
Line 1519
  tokafter always !symbolic=(mImpl->mAstOperand1)
Line 1521
  return always {!<=-1,!>=2}
  false always 0
Line 1528
  end always !0
Line 1529
  && always {!<=-1,!>=2}
  tok always !0
  != always {!<=-1,!>=2}
Line 1530
  ( {!<=-1,!>=2,0}
Line 1531
  "unsigned " always "unsigned "
Line 1532
  ( {!<=-1,!>=2,0}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 1533
  "long " always "long "
Line 1534
  == always {!<=-1,!>=2}
  :: always 6
  eString always 6
Line 1535
  c always !<=-1
  : always !<=-1
Line 1536
  c {!<=-1,13,9,>=32,<=31,<=126,>=127}
  == {!<=-1,!>=2,0}
  '\n' always 10
Line 1537
  "\\n" always "\\n"
Line 1538
  c {!<=-1,9,>=32,<=31,<=126,>=127,!10}
  == {!<=-1,!>=2,0}
  '\r' always 13
Line 1539
  "\\r" always "\\r"
Line 1540
  c {!<=-1,>=32,<=31,<=126,>=127,!10,!13}
  == {!<=-1,!>=2,>=0}
  '\t' always 9
Line 1541
  "\\t" always "\\t"
Line 1542
  c {!<=-1,<=126,>=127,!10,!13,!9}
  >= {!<=-1,!>=2,<=1}
  ' ' always 32
  && always {!<=-1,!>=2}
  c {!<=-1,!10,!13,!9,>=32,!<=31}
  <= {!<=-1,!>=2,>=1}
  126 always 126
Line 1543
  c {!<=-1,!10,!13,!9,>=32,!<=31,<=126,!>=127}
Line 1545
  10 always 10
Line 1546
  str always Uninit*
  "\\x%02x" always "\\x%02x"
  c {!<=-1,!10,!13,!9,<=31,>=127}
Line 1547
  str inconclusive Uninit*
Line 1550
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 1553
  ( always !size=0
Line 1554
  ( always {!<=-1,!>=2}
  "%name%|%num% %name%|%num%" always "%name%|%num% %name%|%num%"
Line 1555
  ' ' always 32
Line 1563
  tokens always symbolic=(findExpressionStartEndTokens())
  tokens always symbolic=(findExpressionStartEndTokens())
Line 1568
  indent possible 2@226
  ' ' always 32
Line 1570
  "<token str=\"" always "<token str=\""
  '\"' always 34
Line 1572
  " varId=\"" always " varId=\""
  ( always !0
  '\"' always 34
Line 1574
  " variable=\"" always " variable=\""
  ( always !0
  '\"' always 34
Line 1576
  " function=\"" always " function=\""
  ( always !0
  '\"' always 34
Line 1577
  ! {!<=-1,!>=2,0}
  ( possible size=0
  ( {!<=-1,!>=2,1}
Line 1578
  " values=\"" always " values=\""
  & always !0
  ( always !size=0
  '\"' always 34
Line 1580
  ! {!<=-1,!>=2,1}
  ( possible 0
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
Line 1581
  "/>" always "/>"
Line 1585
  '>' always 62
Line 1587
  ( always !0
  + always !<=-1
  2U always 2
Line 1589
  ( always !0
  + always !<=-1
  2U always 2
Line 1590
  "</token>" always "</token>"
Line 1594
  verbose always {!<=-1,!>=2}
  xml always {!<=-1,!>=2}
Line 1596
  ! {!<=-1,!>=2,1}
  xml {!<=-1,!>=2,0}
Line 1597
  "\n\n##AST" always "\n\n##AST"
Line 1600
  = always !0
  this always !0
Line 1601
  ! always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 1602
  ( possible lifetime[Iterator]=(printed)
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(printed),end=0}
Line 1606
  xml always {!<=-1,!>=2}
Line 1607
  "<ast scope=\"" always "<ast scope=\""
  "\" fileIndex=\"" always "\" fileIndex=\""
  "\" linenr=\"" always "\" linenr=\""
Line 1608
  "\" column=\"" always "\" column=\""
  "\">" always "\">"
Line 1609
  2U always 2
Line 1610
  "</ast>" always "</ast>"
Line 1611
  verbose always {!<=-1,!>=2}
Line 1612
  "[" always "["
  ":" always ":"
  "]" always "]"
Line 1614
  " " always " "
Line 1615
  == always {!<=-1,!>=2}
  "(" always "("
Line 1623
  = always 0
  0 always 0
  i possible {0,1}
  < always {!<=-1,!>=2}
  indent1 possible {symbolic=(i1)@217,symbolic=(indent2)@217,symbolic=(i1)@219}
  ++ possible 1
  i possible 0
Line 1624
  ' ' always 32
Line 1625
  < always {!<=-1,!>=2}
  2 always 2
Line 1626
  "| " always "| "
Line 1631
  ( always {!<=-1,!>=2}
Line 1632
  '$' always 36
Line 1635
  " \'" always " \'"
  '\'' always 39
Line 1638
  ( always !0
Line 1639
  " f:" always " f:"
Line 1641
  '\n' always 10
Line 1644
  = possible symbolic=(indent2)
  indent1 possible symbolic=(indent2)
  indent2 possible {symbolic=(indent1),symbolic=(i1)}
  2 always 2
Line 1645
  indent1 {symbolic=(i1),symbolic=(indent2)}
  == {!<=-1,!>=2,1}
  indent2 {symbolic=(i2-2),symbolic=(i1)}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
Line 1646
  i1 always {symbolic=(indent1),symbolic=(indent2)}
  2 always 2
Line 1647
  indent1 possible {symbolic=(i1),symbolic=(indent2)}
  indent2 {symbolic=(i2-2),symbolic=(indent1)}
Line 1648
  . possible 0
  "|-" always "|-"
  : always "`-"
  "`-" always "`-"
Line 1649
  i2 always symbolic=(indent2+2)
Line 1652
  = possible symbolic=(indent2)
  indent1 possible symbolic=(indent2)
  indent2 possible {symbolic=(indent1),symbolic=(i1)}
  2 always 2
Line 1653
  indent1 {symbolic=(i1),symbolic=(indent2)}
  == {!<=-1,!>=2,1}
  indent2 {symbolic=(i2-2),symbolic=(i1)}
Line 1654
  i1 always {symbolic=(indent1),symbolic=(indent2)}
  2 always 2
Line 1655
  indent1 possible {symbolic=(i1),symbolic=(indent2)}
  indent2 {symbolic=(i2-2),symbolic=(indent1)}
Line 1656
  "`-" always "`-"
Line 1657
  i1 possible symbolic=(indent1)
  i2 always symbolic=(indent2+2)
Line 1664
  ret always size=0
Line 1670
  ! always {!<=-1,!>=2}
Line 1672
  ! always {!<=-1,!>=2}
Line 1673
  "(" always "("
  " " always " "
  ( always !0
  ")" always ")"
Line 1674
  "(" always "("
  " " always " "
  ( always !0
  " " always " "
  ( always !0
  ")" always ")"
Line 1677
  xml always {!<=-1,!>=2}
Line 1679
  = always 0
  0 always 0
Line 1680
  xml {!<=-1,!>=2,0}
Line 1681
  "  <valueflow>" always "  <valueflow>"
Line 1683
  "\n\n##Value flow" always "\n\n##Value flow"
Line 1684
  = always !0
  this always !0
Line 1685
  ! always {!<=-1,!>=2}
  . possible size=0
Line 1687
  ( always {!<=-1,!>=2}
Line 1689
  xml {!<=-1,!>=2,0}
Line 1690
  "    <values id=\"" always "    <values id=\""
  . always !size=0
  "\">" always "\">"
Line 1691
  != always {!<=-1,!>=2}
Line 1692
  "Line " always "Line "
  ( always !symbolic=(line)
Line 1693
  = possible symbolic=(line)
  ( possible symbolic=(line)
Line 1694
  ! {!<=-1,!>=2,1,0}
  xml {!<=-1,!>=2,0,1}
Line 1696
  same always {!<=-1,!>=2}
  same always {!<=-1,!>=2}
  = always 1
  true always 1
Line 1698
  != {!<=-1,!>=2,0}
  valueKind possible symbolic=(value.valueKind)
Line 1699
  same always {!<=-1,!>=2}
  = always 0
  false always 0
Line 1703
  "  " always "  "
  " " always " "
Line 1704
  same {!<=-1,!>=2,0}
Line 1706
  :: always 3
  Impossible always 3
Line 1707
  :: always 1
  Known always 1
Line 1708
  "always " always "always "
Line 1710
  :: always 2
  Inconclusive always 2
Line 1711
  "inconclusive " always "inconclusive "
Line 1714
  "possible " always "possible "
Line 1718
  ( always !<=-1
  > always {!<=-1,!>=2}
  1U always 1
Line 1719
  '{' always 123
Line 1721
  . possible {>=size=2,<=size=1}
Line 1722
  xml {!<=-1,!>=2,1,0}
Line 1723
  "      <value " always "      <value "
Line 1725
  :: always 0
  INT always 0
Line 1726
  && always {!<=-1,!>=2}
  ( always !0
  == always {!<=-1,!>=2}
  :: always 2
  UNSIGNED always 2
Line 1727
  "intvalue=\"" always "intvalue=\""
  ( always !<=-1
  '\"' always 34
Line 1729
  "intvalue=\"" always "intvalue=\""
  '\"' always 34
Line 1731
  :: always 1
  TOK always 1
Line 1732
  "tokvalue=\"" always "tokvalue=\""
  '\"' always 34
Line 1734
  :: always 2
  FLOAT always 2
Line 1735
  "floatvalue=\"" always "floatvalue=\""
  '\"' always 34
Line 1737
  :: always 3
  MOVED always 3
Line 1738
  "movedvalue=\"" always "movedvalue=\""
  '\"' always 34
Line 1740
  :: always 4
  UNINIT always 4
Line 1741
  "uninit=\"1\"" always "uninit=\"1\""
Line 1743
  :: always 7
  BUFFER_SIZE always 7
Line 1744
  "buffer-size=\"" always "buffer-size=\""
  "\"" always "\""
Line 1746
  :: always 5
  CONTAINER_SIZE always 5
Line 1747
  "container-size=\"" always "container-size=\""
  '\"' always 34
Line 1749
  :: always 8
  ITERATOR_START always 8
Line 1750
  "iterator-start=\"" always "iterator-start=\""
  '\"' always 34
Line 1752
  :: always 9
  ITERATOR_END always 9
Line 1753
  "iterator-end=\"" always "iterator-end=\""
  '\"' always 34
Line 1755
  :: always 6
  LIFETIME always 6
Line 1756
  "lifetime=\"" always "lifetime=\""
  '\"' always 34
Line 1757
  " lifetime-scope=\"" always " lifetime-scope=\""
  "\"" always "\""
Line 1758
  " lifetime-kind=\"" always " lifetime-kind=\""
  "\"" always "\""
Line 1760
  :: always 10
  SYMBOLIC always 10
Line 1761
  "symbolic=\"" always "symbolic=\""
  '\"' always 34
Line 1762
  " symbolic-delta=\"" always " symbolic-delta=\""
  '\"' always 34
Line 1765
  " bound=\"" always " bound=\""
  "\"" always "\""
Line 1767
  " condition-line=\"" always " condition-line=\""
  . always !0
  '\"' always 34
Line 1768
  ( always {!<=-1,!>=2}
Line 1769
  " known=\"true\"" always " known=\"true\""
Line 1770
  ( always {!<=-1,!>=2}
Line 1771
  " possible=\"true\"" always " possible=\"true\""
Line 1772
  ( always {!<=-1,!>=2}
Line 1773
  " impossible=\"true\"" always " impossible=\"true\""
Line 1774
  ( always {!<=-1,!>=2}
Line 1775
  " inconclusive=\"true\"" always " inconclusive=\"true\""
Line 1776
  " path=\"" always " path=\""
  "\"" always "\""
Line 1777
  "/>" always "/>"
Line 1781
  & {lifetime[Address]=(*tok->mImpl->mValues),!0}
  != always {!<=-1,!>=2}
  & {lifetime[Address]=(tok->mImpl->mValues->front()),!0}
Line 1782
  "," always ","
Line 1783
  ( always {!<=-1,!>=2}
Line 1784
  "!" always "!"
Line 1785
  . possible 0
  == {!<=-1,!>=2,0}
  :: always 1
  Lower always 1
Line 1786
  ">=" always ">="
Line 1787
  . possible 1
  == {!<=-1,!>=2,0}
  :: always 0
  Upper always 0
Line 1788
  "<=" always "<="
Line 1790
  :: always 0
  INT always 0
Line 1793
  :: always 1
  TOK always 1
Line 1796
  :: always 2
  FLOAT always 2
Line 1799
  :: always 3
  MOVED always 3
Line 1802
  :: always 4
  UNINIT always 4
Line 1803
  "Uninit" always "Uninit"
Line 1805
  :: always 7
  BUFFER_SIZE always 7
Line 1806
  :: always 5
  CONTAINER_SIZE always 5
Line 1807
  "size=" always "size="
Line 1809
  :: always 8
  ITERATOR_START always 8
Line 1810
  "start=" always "start="
Line 1812
  :: always 9
  ITERATOR_END always 9
Line 1813
  "end=" always "end="
Line 1815
  :: always 6
  LIFETIME always 6
Line 1816
  "lifetime[" always "lifetime["
  "]=(" always "]=("
Line 1817
  ")" always ")"
Line 1819
  :: always 10
  SYMBOLIC always 10
Line 1820
  "symbolic=(" always "symbolic=("
Line 1821
  > always {!<=-1,!>=2}
  0 always 0
Line 1822
  "+" always "+"
  . {>=1,!<=0}
Line 1823
  . {!>=1,<=0}
  < {!<=-1,!>=2,<=0}
  0 always 0
Line 1824
  "-" always "-"
  - {>=1,!<=0}
  . {<=-1,!>=0}
Line 1825
  ")" always ")"
Line 1828
  > always {!<=-1,!>=2}
  0 always 0
Line 1829
  = always 0
  0 always 0
  i possible {0,1}
  < {!<=-1,!>=2,>=0}
  . {>=1,!<=0}
  i possible 0
  ++ possible 0
Line 1830
  "*" always "*"
Line 1831
  > always {!<=-1,!>=2}
  0 always 0
Line 1832
  "@" always "@"
  . {>=1,!<=0}
Line 1835
  xml always {!<=-1,!>=2}
Line 1836
  "    </values>" always "    </values>"
Line 1837
  ( always !<=-1
  > always {!<=-1,!>=2}
  1U always 1
Line 1838
  '}' always 125
Line 1842
  xml always {!<=-1,!>=2}
Line 1843
  "  </valueflow>" always "  </valueflow>"
Line 1848
  ! always {!<=-1,!>=2}
Line 1849
  nullptr always 0
Line 1850
  . always !0
  [ possible lifetime[Lambda]=(val)
Line 1851
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  <= always {!<=-1,!>=2}
Line 1857
  ! always {!<=-1,!>=2}
Line 1858
  nullptr always 0
Line 1859
  . always !0
  [ possible lifetime[Lambda]=(val)
Line 1860
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  >= always {!<=-1,!>=2}
Line 1866
  ! always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
Line 1867
  nullptr always 0
Line 1868
  = always 0
  nullptr always 0
Line 1870
  = always start=0
  ( always start=0
  it possible start=0
  != always {!<=-1,!>=2}
  ( always end=0
Line 1873
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  settings always !0
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
Line 1874
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  settings always !0
  ( always {!<=-1,!>=2}
Line 1875
  ! always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  ret always !0
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  ret always !0
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
Line 1876
  = {lifetime[Address]=(*it),!0}
  & {lifetime[Address]=(*it),!0}
Line 1877
  ! {!<=-1,!>=2,1}
  ret possible {lifetime[Address]=(*it),symbolic=(&(*it))}
  ( {!<=-1,!>=2,0}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ret possible lifetime[Address]=(*it)
Line 1881
  ret possible 0
Line 1882
  ret always !0
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  settings always !0
  ( always {!<=-1,!>=2}
  :: always 1
  inconclusive always 1
Line 1883
  nullptr always 0
Line 1884
  ret always !0
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  :: always 2
  warning always 2
Line 1885
  nullptr always 0
Line 1887
  ret possible 0
Line 1892
  ! always {!<=-1,!>=2}
Line 1893
  nullptr always 0
Line 1894
  = always 0
  nullptr always 0
Line 1897
  = always start=0
  ( always start=0
  it possible start=0
  != always {!<=-1,!>=2}
  ( always end=0
Line 1898
  && always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 6
  eString always 6
Line 1899
  . always !0
Line 1900
  ! always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  < always {!<=-1,!>=2}
Line 1901
  = possible <=symbolic=(minsize-1)
  size possible <=symbolic=(minsize-1)
Line 1902
  = always !0
  . always !0
Line 1906
  ret possible 0
Line 1911
  ! always {!<=-1,!>=2}
Line 1912
  nullptr always 0
Line 1913
  = always 0
  nullptr always 0
Line 1914
  = always 0
  0 always 0
Line 1916
  = always start=0
  ( always start=0
  it possible start=0
  != always {!<=-1,!>=2}
  ( always end=0
Line 1917
  && always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 6
  eString always 6
Line 1918
  . always !0
Line 1919
  ! always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  > always {!<=-1,!>=2}
Line 1920
  = possible >=symbolic=(maxlength+1)
  length possible >=symbolic=(maxlength+1)
Line 1921
  = always !0
  . always !0
Line 1925
  ret possible 0
Line 1928
  ( always {!<=-1,!>=2}
Line 1930
  . possible symbolic=(y.bound)
  != always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  . always !symbolic=(ValueFlow::Value::Bound::Point)
  == always {!<=-1,!>=2}
Line 1931
  return always {!<=-1,!>=2}
  true always 1
Line 1932
  == always {!<=-1,!>=2}
  :: always 2
  FLOAT always 2
Line 1933
  return always {!<=-1,!>=2}
  false always 0
Line 1934
  return always {!<=-1,!>=2}
  ( always !<=-1
  == always {!<=-1,!>=2}
  1 always 1
Line 1937
  ( always {!<=-1,!>=2}
Line 1939
  isPoint always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
Line 1940
  ! always {!<=-1,!>=2}
  isPoint always {!<=-1,!>=2}
Line 1944
  return always {!<=-1,!>=2}
  isPoint {!<=-1,!>=2,0}
Line 1947
  ( always {!<=-1,!>=2}
Line 1949
  result always {!<=-1,!>=2}
  result always {!<=-1,!>=2}
  = always 0
  false always 0
Line 1951
  ( always {!<=-1,!>=2}
Line 1954
  y possible symbolic=(x)
  ( always {!<=-1,!>=2}
Line 1956
  == always {!<=-1,!>=2}
Line 1958
  x always !symbolic=(y)
  != always {!<=-1,!>=2}
  y always !symbolic=(x)
Line 1960
  x always !symbolic=(y)
  ( always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  y always !symbolic=(x)
  ( always {!<=-1,!>=2}
Line 1962
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 1964
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 1966
  ( always {!<=-1,!>=2}
Line 1971
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 0
  Upper always 0
Line 1973
  return always {!<=-1,!>=2}
  true always 1
Line 1975
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 1
  Lower always 1
Line 1977
  return always {!<=-1,!>=2}
  true always 1
Line 1981
  removex always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 1982
  removey always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 1983
  == always {!<=-1,!>=2}
Line 1984
  removex {symbolic=(!x.isImpossible()||y.isKnown()),!<=-1,!>=2}
Line 1986
  removey {symbolic=(!y.isImpossible()||x.isKnown()),!<=-1,!>=2}
Line 1988
  return always {!<=-1,!>=2}
  true always 1
Line 1990
  result always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  removex {symbolic=(!x.isImpossible()||y.isKnown()),!<=-1,!>=2,0}
  || always {!<=-1,!>=2}
  removey {symbolic=(!y.isImpossible()||x.isKnown()),!<=-1,!>=2}
Line 1991
  bail {!<=-1,!>=2,0}
  bail always {!<=-1,!>=2}
  = always 0
  false always 0
Line 1992
  removex {symbolic=(!x.isImpossible()||y.isKnown()),!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 1993
  bail always {!<=-1,!>=2}
  = always 1
  true always 1
Line 1994
  removey always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 1995
  bail always {!<=-1,!>=2}
  = always 1
  true always 1
Line 1996
  bail {!<=-1,!>=2,1}
Line 1997
  return always {!<=-1,!>=2}
  true always 1
Line 2001
  return always {!<=-1,!>=2}
  result always {!<=-1,!>=2}
Line 2009
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  start possible {lifetime[Iterator]=(adjValues)@155,lifetime[Iterator]=(adjValues)@156,start=0@155}
Line 2010
  ( possible lifetime[Object]=(x)
Line 2011
  = possible {lifetime[Iterator]=(adjValues)@155,lifetime[Iterator]=(adjValues)@156}
  ( possible {lifetime[Iterator]=(adjValues)@155,lifetime[Iterator]=(adjValues)@156}
  start possible {lifetime[Iterator]=(adjValues)@155,lifetime[Iterator]=(adjValues)@156,start=0@155}
  last inconclusive {lifetime[Iterator]=(adjValues)@155,lifetime[Iterator]=(adjValues)@156,end=0@155}
Line 2012
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 2014
  it possible {lifetime[Iterator]=(adjValues)@155,lifetime[Iterator]=(adjValues)@156}
  == always {!<=-1,!>=2}
  last inconclusive {lifetime[Iterator]=(adjValues)@155,lifetime[Iterator]=(adjValues)@156,end=0@155}
Line 2015
  it {lifetime[Iterator]=(adjValues)@155,lifetime[Iterator]=(adjValues)@156,symbolic=(last)}
  -- always symbolic=(last)
Line 2017
  [ possible lifetime[Lambda]=(values)
Line 2025
  = {lifetime[Iterator]=(values),start=0}
  ( {lifetime[Iterator]=(values),start=0}
  x possible {lifetime[Iterator]=(values),start=0}
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(values),end=0}
Line 2026
  x possible lifetime[Iterator]=(values)
Line 2030
  == always {!<=-1,!>=2}
Line 2035
  = {lifetime[Iterator]=(values),start=0}
  ( {lifetime[Iterator]=(values),start=0}
  y possible {lifetime[Iterator]=(values),start=0}
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(values),end=0}
Line 2036
  == always {!<=-1,!>=2}
  y possible lifetime[Iterator]=(values)
Line 2038
  y always !symbolic=(x)
Line 2040
  != always {!<=-1,!>=2}
Line 2042
  != always {!<=-1,!>=2}
Line 2044
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 2046
  . possible 1
  != always {!<=-1,!>=2}
Line 2047
  . always !symbolic=(x->bound)
  != always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 2048
  adjValues always NonMovedVariable
Line 2052
  == always {!<=-1,!>=2}
  :: always 2
  FLOAT always 2
Line 2054
  != always {!<=-1,!>=2}
Line 2057
  . possible {symbolic=(y->bound),0}
  == {!<=-1,!>=2,0}
  :: always 1
  Lower always 1
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
Line 2059
  == always {!<=-1,!>=2}
  :: always 0
  Upper always 0
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
Line 2063
  adjValues possible {NonMovedVariable,size=0}
  ( {!<=-1,!>=2,1}
Line 2067
  adjValues {NonMovedVariable,!size=0}
  ( {lifetime[Iterator]=(adjValues),!size=0,start=0}
  adjValues always !size=0
  ( {lifetime[Iterator]=(adjValues),!size=0,end=0}
  [ possible lifetime[Lambda]=(values)
  & {lifetime[Address]=(values),!0}
Line 2069
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(values),symbolic=(yy),end=0}
  && always {!<=-1,!>=2}
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(values),!symbolic=(xx),end=0}
Line 2072
  . possible 0
  == {!<=-1,!>=2,0}
  :: always 1
  Lower always 1
Line 2073
  adjValues always !size=0
  ( {lifetime[Iterator]=(adjValues),!size=0,start=0}
  adjValues always !size=0
  ( {lifetime[Iterator]=(adjValues),!size=0,end=0}
Line 2074
  . always !1
  == always {!<=-1,!>=2}
  :: always 0
  Upper always 0
Line 2075
  adjValues always !size=0
  ( {lifetime[Iterator]=(adjValues),!size=0,start=0}
  adjValues always !size=0
  ( {lifetime[Iterator]=(adjValues),!size=0,end=0}
Line 2082
  ( always {!<=-1,!>=2}
Line 2084
  [ possible lifetime[Lambda]=(values)
Line 2085
  ( always {!<=-1,!>=2}
Line 2086
  false always 0
Line 2087
  & {lifetime[Address]=(values),!0}
  == always {!<=-1,!>=2}
  & {lifetime[Address]=(y),!0}
Line 2088
  false always 0
Line 2089
  != always {!<=-1,!>=2}
Line 2090
  false always 0
Line 2091
  != always {!<=-1,!>=2}
Line 2092
  false always 0
Line 2095
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 2096
  false always 0
Line 2097
  != always {!<=-1,!>=2}
Line 2098
  false always 0
Line 2099
  true always 1
Line 2110
  = always 0
  0 always 0
  i possible 0
  < {!<=-1,!>=2,1}
  4 always 4
Line 2111
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 2117
  ( always {!<=-1,!>=2}
Line 2119
  != always {!<=-1,!>=2}
Line 2120
  return always {!<=-1,!>=2}
  false always 0
Line 2122
  ( always {!<=-1,!>=2}
Line 2123
  return always {!<=-1,!>=2}
  ( possible symbolic=(y.tokvalue->exprId())
  == always {!<=-1,!>=2}
  0 always 0
  || always {!<=-1,!>=2}
  ( always !0
  == always {!<=-1,!>=2}
Line 2124
  return always {!<=-1,!>=2}
  true always 1
Line 2127
  ( always {!<=-1,!>=2}
Line 2129
  ( {!<=-1,!>=2,0}
  && always {!<=-1,!>=2}
Line 2131
  [ possible lifetime[Lambda]=(value)
Line 2132
  ( always {!<=-1,!>=2}
Line 2137
  ! {!<=-1,!>=2,0,1}
  ( {!<=-1,!>=2,1,0}
  && always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 2138
  ( always {!<=-1,!>=2}
  ( always start=0
  ( always end=0
Line 2139
  return always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
Line 2141
  return always {!<=-1,!>=2}
  false always 0
Line 2148
  . possible {>=size=10,<=size=9}
Line 2151
  ( always !<=-1
  >= always {!<=-1,!>=2}
  10U always 10
Line 2152
  return always {!<=-1,!>=2}
  false always 0
Line 2156
  = always start=0
  ( always start=0
  it possible start=0
  != always {!<=-1,!>=2}
  ( always end=0
Line 2158
  != always {!<=-1,!>=2}
Line 2161
  != always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 2165
  ! always {!<=-1,!>=2}
Line 2168
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  != always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  != always {!<=-1,!>=2}
Line 2172
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 2174
  == always {!<=-1,!>=2}
  0 always 0
Line 2180
  return always {!<=-1,!>=2}
  false always 0
Line 2184
  == always {!<=-1,!>=2}
  ( always end=0
Line 2186
  == always {!<=-1,!>=2}
  0 always 0
Line 2188
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 2195
  == always {!<=-1,!>=2}
  0 always 0
Line 2197
  ( always size=1
  1 always 1
Line 2202
  return always {!<=-1,!>=2}
  true always 1
Line 2207
  = always 0
  0 always 0
Line 2209
  ++ possible 1
  total_count possible 0
Line 2210
  = always 0
  0 always 0
Line 2212
  count possible 0
  ++ possible 0
  * possible 0
  100 always 100
Line 2217
  = possible 1
  ? possible 0
  mPrevious always !0
  : always 0
  0 always 0
  + possible 1
  1 always 1
Line 2218
  = always !0
  this always !0
Line 2219
  = possible 1
  index possible 1
  ++ possible 1
Line 2224
  != always {!<=-1,!>=2}
Line 2225
  . always !symbolic=(vt)
Line 2226
  = always !symbolic=(mImpl->mValueType)
  vt always !symbolic=(mImpl->mValueType)
Line 2232
  = possible 0
  t possible 0
Line 2234
  eType always 1
Line 2235
  ( always {!<=-1,!>=2}
Line 2236
  == always {!<=-1,!>=2}
  eType always 1
Line 2237
  eName always 4
Line 2242
  ! always {!<=-1,!>=2}
Line 2243
  nullptr always 0
Line 2244
  != always {!<=-1,!>=2}
  nullptr always 0
Line 2245
  typeTok always !0
  = always !0
  tok always !0
Line 2246
  * always 0
  { always 0
Line 2247
  ( always {!<=-1,!>=2}
  tok {symbolic=(*typeTok),!0}
  "return" always "return"
Line 2248
  tok always !0
Line 2249
  ! always {!<=-1,!>=2}
  scope always symbolic=(tok->scope())
Line 2250
  nullptr always 0
Line 2251
  scope {symbolic=(tok->scope()),!0}
Line 2252
  ! always {!<=-1,!>=2}
  function always symbolic=(scope->function)
Line 2253
  nullptr always 0
Line 2254
  function {symbolic=(scope->function),!0}
Line 2255
  ( always {!<=-1,!>=2}
  tok always !0
  "%type%" always "%type%"
Line 2256
  tok always !0
Line 2257
  ( always {!<=-1,!>=2}
  tok always !0
  "%var%" always "%var%"
Line 2258
  tok always !0
Line 2259
  ! always {!<=-1,!>=2}
  var always symbolic=(tok->variable())
Line 2260
  nullptr always 0
Line 2261
  var {symbolic=(tok->variable()),!0}
Line 2262
  ( always {!<=-1,!>=2}
  tok always !0
  "%name%" always "%name%"
Line 2263
  tok always !0
Line 2264
  ! always {!<=-1,!>=2}
  function always symbolic=(tok->function())
Line 2265
  nullptr always 0
Line 2266
  function {symbolic=(tok->function()),!0}
Line 2267
  ( always {!<=-1,!>=2}
  tok always !0
  "%type%|= (|{" always "%type%|= (|{"
Line 2268
  tok always !0
Line 2269
  ( always {!<=-1,!>=2}
  tok always !0
  "=" always "="
  && always {!<=-1,!>=2}
  tok always !0
  != always {!<=-1,!>=2}
  tok always !0
Line 2271
  ( always {!<=-1,!>=2}
  tok always !0
  "." always "."
Line 2272
  tok always !0
Line 2273
  ( always {!<=-1,!>=2}
  tok always !0
  "[" always "["
Line 2274
  tok always !0
Line 2275
  ( always {!<=-1,!>=2}
  tok always !0
  "{" always "{"
Line 2277
  tok always !0
  argnr always Uninit
Line 2278
  < always {!<=-1,!>=2}
  0 always 0
Line 2279
  nullptr always 0
Line 2280
  ! always {!<=-1,!>=2}
  ftok possible symbolic=(tok)
Line 2281
  nullptr always 0
Line 2282
  ftok always !0
  == always {!<=-1,!>=2}
Line 2283
  nullptr always 0
Line 2284
  ftok always {!symbolic=(tok),!0}
Line 2285
  ( always {!<=-1,!>=2}
Line 2286
  nullptr always 0
Line 2287
  ( always {!<=-1,!>=2}
Line 2288
  vars always !size=0
  ( {lifetime[Iterator]=(vars),!size=0,start=0}
  vars always !size=0
  ( {lifetime[Iterator]=(vars),!size=0,end=0}
Line 2289
  == always {!<=-1,!>=2}
  vars always !size=0
Line 2291
  vars always !size=0
Line 2294
  nullptr always 0
Line 2299
  ! always {!<=-1,!>=2}
Line 2301
  ( always {!<=-1,!>=2}
  tok always !0
  "return" always "return"
Line 2302
  tok always !0
Line 2303
  ! always {!<=-1,!>=2}
  scope always symbolic=(tok->scope())
Line 2305
  scope {symbolic=(tok->scope()),!0}
Line 2306
  ! always {!<=-1,!>=2}
  function always symbolic=(scope->function)
Line 2308
  function {symbolic=(scope->function),!0}
  function {symbolic=(scope->function),!0}
Line 2309
  ( always {!<=-1,!>=2}
  tok always !0
  "%type%" always "%type%"
Line 2310
  tok always !0
Line 2311
  ( always {!<=-1,!>=2}
  tok always !0
  "%var%" always "%var%"
Line 2312
  tok always !0
Line 2313
  ! always {!<=-1,!>=2}
  var always symbolic=(tok->variable())
Line 2315
  ! always {!<=-1,!>=2}
  var {symbolic=(tok->variable()),!0}
  || always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  var {symbolic=(tok->variable()),!0}
Line 2317
  ( always {!<=-1,!>=2}
  var always !0
  ( always !0
  "auto" always "auto"
Line 2318
  var always !0
Line 2319
  ( always {!<=-1,!>=2}
  tok2 always symbolic=(var->declEndToken())
  "; %varid% =" always "; %varid% ="
  var always !0
Line 2320
  tok2 always symbolic=(var->declEndToken())
  2 always 2
Line 2321
  ( always {!<=-1,!>=2}
  tok2 possible symbolic=(var->declEndToken())
  "=" always "="
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "!!=" always "!!="
  && always {!<=-1,!>=2}
  != always {!<=-1,!>=2}
Line 2322
  ( always !symbolic=(tok)
Line 2327
  var always !0
  ( always !0
  var always !0
  ( always !0
Line 2328
  ( always {!<=-1,!>=2}
  tok always !0
  "%name% (" always "%name% ("
Line 2329
  tok always !0
Line 2330
  ! always {!<=-1,!>=2}
  function always symbolic=(tok->previous()->function())
Line 2332
  function {symbolic=(tok->previous()->function()),!0}
  function {symbolic=(tok->previous()->function()),!0}
Line 2333
  ( always {!<=-1,!>=2}
  tok always !0
  "=" always "="
Line 2334
  tok always !0
Line 2335
  ( always {!<=-1,!>=2}
  tok always !0
  "." always "."
Line 2336
  tok always !0
Line 2338
  tok always !0
Line 2339
  ! always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  t always !0
Line 2341
  t always !0
  . always !0
  t always !0
  . always !0
  2 always 2
Line 2347
  = always !0
  ( always !0
Line 2348
  vt {symbolic=(tok->valueType()),!0}
Line 2349
  ! {!<=-1,!>=2,0}
  ret {symbolic=(vt->str()),size=0}
  ( {!<=-1,!>=2,1}
Line 2350
  ret {symbolic=(vt->str()),!size=0}
Line 2353
  ! always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
Line 2354
  "" always ""
Line 2355
  false always 0
Line 2360
  = possible symbolic=(std::make_shared<ScopeInfo2>(mImpl->mScopeInfo->name,nullptr,mImpl->mScopeInfo->usingNamespaces))@160
  newScopeInfo possible symbolic=(std::make_shared<ScopeInfo2>(mImpl->mScopeInfo->name,nullptr,mImpl->mScopeInfo->usingNamespaces))@160
Line 2367
  ( always {!<=-1,!>=2}
Line 2369
  ! always {!<=-1,!>=2}
Line 2370
  return always {!<=-1,!>=2}
  false always 0
Line 2371
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  ( always start=0
  ( always end=0
Line 2372
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 2376
  ( always {!<=-1,!>=2}
Line 2378
  return always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  ( always start=0
  ( always end=0
  & {lifetime[Address]=(isKnown),!0}
Line 2381
  ( always {!<=-1,!>=2}
Line 2383
  return always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 2384
  ( always {!<=-1,!>=2}
  ( always start=0
  ( always end=0
  [ possible lifetime[Lambda]=(t)
Line 2385
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
Line 2389
  ( always {!<=-1,!>=2}
Line 2391
  == always {!<=-1,!>=2}
  0 always 0
Line 2392
  return always {!<=-1,!>=2}
  false always 0
Line 2393
  return always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 2394
  ( always {!<=-1,!>=2}
  ( always start=0
  ( always end=0
  [ possible lifetime[Lambda]=(tok)
Line 2395
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 2396
  . always !0
  == always {!<=-1,!>=2}
Line 2402
  ! always {!<=-1,!>=2}
Line 2403
  nullptr always 0
Line 2404
  ( always start=0
  ( always end=0
  [ possible lifetime[Lambda]=(t)
Line 2405
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
Line 2407
  == always {!<=-1,!>=2}
  ( always end=0
  nullptr always 0
  & {lifetime[Address]=(*it),!0}
  it always {!symbolic=(mImpl->mValues->end()),!end=0}
Line 2412
  ! always {!<=-1,!>=2}
Line 2413
  nullptr always 0
Line 2414
  ( always start=0
  ( always end=0
  [ possible {lifetime[Lambda]=(value),lifetime[Lambda]=(value),lifetime[Lambda]=(value),lifetime[Lambda]=(val)}
Line 2415
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
Line 2417
  == always {!<=-1,!>=2}
  ( always end=0
  nullptr always 0
  & {lifetime[Address]=(*it),!0}
  it always {!symbolic=(mImpl->mValues->end()),!end=0}
Line 2420
  condition always {!<=-1,!>=2}
Line 2422
  ! always {!<=-1,!>=2}
Line 2423
  nullptr always 0
Line 2424
  = always 0
  nullptr always 0
Line 2425
  . always !0
Line 2426
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 2428
  ( always {!<=-1,!>=2}
Line 2430
  path possible symbolic=(value.path)
  > always {!<=-1,!>=2}
  -0 always 0
  && always {!<=-1,!>=2}
  != always {!<=-1,!>=2}
  0 always 0
  && always {!<=-1,!>=2}
  . always !0
  != always {!<=-1,!>=2}
  path {>=1,!<=0}
Line 2432
  ! always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  > always {!<=-1,!>=2}
  ret always !0
  && always {!<=-1,!>=2}
Line 2433
  != always {!<=-1,!>=2}
  nullptr always 0
  == always {!<=-1,!>=2}
  condition always {!<=-1,!>=2}
Line 2434
  = {&,lifetime[Address]=(*mImpl->mValues),!0}
  & {&,lifetime[Address]=(*mImpl->mValues),!0}
Line 2441
  ! always {!<=-1,!>=2}
Line 2442
  nullptr always 0
Line 2443
  ( always start=0
  ( always end=0
Line 2444
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 2445
  != always {!<=-1,!>=2}
Line 2447
  == always {!<=-1,!>=2}
  ( always end=0
  nullptr always 0
  & {lifetime[Address]=(*it),!0}
  it always {!symbolic=(mImpl->mValues->end()),!end=0}
Line 2453
  ! always {!<=-1,!>=2}
Line 2454
  nullptr always 0
Line 2455
  ( always start=0
  ( always end=0
  [ possible {lifetime[Lambda]=(value),lifetime[Lambda]=(value),lifetime[Lambda]=(value),lifetime[Lambda]=(val)}
Line 2456
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
Line 2458
  == always {!<=-1,!>=2}
  ( always end=0
  nullptr always 0
  & {lifetime[Address]=(*it),!0}
  it always {!symbolic=(mImpl->mValues->end()),!end=0}
Line 2468
  mTemplateSimplifierPointers always !0
Line 2469
  nullptr always 0
Line 2471
  mTemplateSimplifierPointers possible 0
Line 2474
  = always !0
  mCppcheckAttributes always !0
Line 2475
  mCppcheckAttributes {symbolic=(c),!0}
Line 2476
  c always !0
Line 2483
  attr possible {symbolic=(mCppcheckAttributes),0}
  && always {!<=-1,!>=2}
  attr {symbolic=(mCppcheckAttributes),!0}
  != always {!<=-1,!>=2}
Line 2484
  attr always !0
Line 2485
  attr possible {symbolic=(mCppcheckAttributes),0}
Line 2486
  attr always !0
Line 2489
  attr always size=0
Line 2490
  attr always size=0
Line 2491
  attr always size=0
Line 2492
  = always size=0
  attr always size=0
Line 2496
  ( always {!<=-1,!>=2}
Line 2499
  attr possible {symbolic=(mCppcheckAttributes),0}
  && always {!<=-1,!>=2}
  attr {symbolic=(mCppcheckAttributes),!0}
  != always {!<=-1,!>=2}
Line 2500
  attr always !0
Line 2501
  attr possible {symbolic=(mCppcheckAttributes),0}
Line 2502
  attr always !0
Line 2503
  return always {!<=-1,!>=2}
  attr possible 0
  != {!<=-1,!>=2,0}
  nullptr always 0
Line 2508
  ( always {!<=-1,!>=2}
  "%name%|.|::|*|&|&&|<|(|template|decltype|sizeof" always "%name%|.|::|*|&|&&|<|(|template|decltype|sizeof"
Line 2509
  ( always {!<=-1,!>=2}
  "(|<" always "(|<"
Line 2511
  ! always {!<=-1,!>=2}
Line 2512
  nullptr always 0
Line 2513
  tok always !0
Line 2524
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "[" always "["
Line 2525
  nullptr always 0
Line 2527
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "] (|{" always "] (|{"
Line 2528
  nullptr always 0
Line 2529
  1 always 1
Line 2530
  ( always {!<=-1,!>=2}
  "}" always "}"
Line 2532
  ( always {!<=-1,!>=2}
  ") {" always ") {"
Line 2533
  1 always 1
Line 2534
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  ")" always ")"
Line 2535
  nullptr always 0
Line 2537
  ( always {!<=-1,!>=2}
  "mutable|constexpr|constval|noexcept|." always "mutable|constexpr|constval|noexcept|."
Line 2538
  ( always {!<=-1,!>=2}
  "noexcept (" always "noexcept ("
Line 2539
  1 always 1
Line 2540
  ( always {!<=-1,!>=2}
  "." always "."
Line 2546
  ( always {!<=-1,!>=2}
  "{" always "{"
Line 2548
  nullptr always 0
Line 42
  nullptr always 0
Line 46
  this always !0
Line 48
  ( always {!<=-1,!>=2}
Line 49
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
Line 51
  ( always {!<=-1,!>=2}
Line 52
  return always {!<=-1,!>=2}
  != always {!<=-1,!>=2}
Line 42
  nullptr always 0
Line 46
  this always !0
Line 48
  ( always {!<=-1,!>=2}
Line 49
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
Line 51
  ( always {!<=-1,!>=2}
Line 52
  return always {!<=-1,!>=2}
  != always {!<=-1,!>=2}
Line 50
  mFlags always !<=-1
  mFlags always !<=-1
  = always 0
  0 always 0
Line 52
  ( always !<=-1
Line 53
  return always !<=-1
  mFlags always !<=-1
Line 56
  mFlags always !<=-1
  = always 0
  0 always 0
Line 59
  mFlags always !<=-1
  = always 4294967295
  0xFFFFFFFF always 4294967295
Line 61
  enabled always {!<=-1,!>=2}
Line 62
  enabled always {!<=-1,!>=2}
Line 67
  ( always {!<=-1,!>=2}
Line 68
  return always {!<=-1,!>=2}
  mFlags always !<=-1
  & always !<=-1
  1U always 1
  << always !<=0
  ( {!<=-1,2@181}
  flag possible 2@181
  != always {!<=-1,!>=2}
  0 always 0
Line 71
  mFlags always !<=-1
  |= always !<=-1
  1U always 1
  << always !<=0
  ( always !<=-1
Line 74
  mFlags always !<=-1
  &= always !<=-1
  ~ always !<=4294967295
  1U always 1
  << always !<=0
  ( always !<=-1
Line 76
  , always {!<=-1,!>=2}
  enabled always {!<=-1,!>=2}
Line 77
  enabled always {!<=-1,!>=2}
Line 50
  mFlags always !<=-1
  mFlags always !<=-1
  = always 0
  0 always 0
Line 52
  ( always !<=-1
Line 53
  return always !<=-1
  mFlags always !<=-1
Line 56
  mFlags always !<=-1
  = always 0
  0 always 0
Line 59
  mFlags always !<=-1
  = always 4294967295
  0xFFFFFFFF always 4294967295
Line 61
  enabled always {!<=-1,!>=2}
Line 62
  enabled always {!<=-1,!>=2}
Line 67
  ( always {!<=-1,!>=2}
Line 68
  return always {!<=-1,!>=2}
  mFlags always !<=-1
  & always !<=-1
  1U always 1
  << always !<=0
  ( {!<=-1,1@180}
  flag possible 1@180
  != always {!<=-1,!>=2}
  0 always 0
Line 71
  mFlags always !<=-1
  |= always !<=-1
  1U always 1
  << always !<=0
  ( always !<=-1
Line 74
  mFlags always !<=-1
  &= always !<=-1
  ~ always !<=4294967295
  1U always 1
  << always !<=0
  ( always !<=-1
Line 76
  , always {!<=-1,!>=2}
  enabled always {!<=-1,!>=2}
Line 77
  enabled always {!<=-1,!>=2}
Line 50
  mFlags always !<=-1
  mFlags always !<=-1
  = always 0
  0 always 0
Line 52
  ( always !<=-1
Line 53
  return always !<=-1
  mFlags always !<=-1
Line 56
  mFlags always !<=-1
  = always 0
  0 always 0
Line 59
  mFlags always !<=-1
  = always 4294967295
  0xFFFFFFFF always 4294967295
Line 61
  enabled always {!<=-1,!>=2}
Line 62
  enabled always {!<=-1,!>=2}
Line 67
  ( always {!<=-1,!>=2}
Line 68
  return always {!<=-1,!>=2}
  mFlags always !<=-1
  & always !<=-1
  1U always 1
  << always !<=0
  ( always !<=-1
  != always {!<=-1,!>=2}
  0 always 0
Line 71
  mFlags always !<=-1
  |= always !<=-1
  1U always 1
  << always !<=0
  ( always !<=-1
Line 74
  mFlags always !<=-1
  &= always !<=-1
  ~ always !<=4294967295
  1U always 1
  << always !<=0
  ( always !<=-1
Line 76
  , always {!<=-1,!>=2}
  enabled always {!<=-1,!>=2}
Line 77
  enabled always {!<=-1,!>=2}
