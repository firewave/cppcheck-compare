

##file cppcheck-2.8/lib/config.h

1:
|
78:
79: static const std :: string emptyString@var1 ;

##file cppcheck-2.8/lib/errortypes.h

1:
|
31:
32: class Token ;
33:
34:
35: struct InternalError {
36: enum Type { AST , SYNTAX , UNKNOWN_MACRO , INTERNAL , LIMIT , INSTANTIATION } ;
37: InternalError ( const Token * tok@var2 , const std :: string & errorMsg@var3 , Type type@var4 = INTERNAL ) ;
38: const Token * token@var5 ;
39: std :: string errorMessage@var6 ;
40: Type type@var7 ;
41: std :: string id@var8 ;
42: } ;
43:
44: class Certainty {
45: public:
46: enum CertaintyLevel {
47: normal , inconclusive , safe , experimental
48: } ;
49: } ;
50:
51: class Checks {
52: public:
53: enum CheckList {
54: unusedFunction , missingInclude , internalCheck
55: } ;
56: } ;
57:
58:
59: class Severity {
60: public:
61:
62:
63:
64: enum SeverityType {
65:
66:
67:
68: none ,
69:
|
73:
74: error ,
75:
|
79:
80: warning ,
81:
|
86:
87: style ,
88:
|
92:
93: performance ,
94:
|
100:
101: portability ,
102:
|
107:
108: information ,
109:
|
112:
113: debug
114: } ;
115:
116: static std :: string toString ( SeverityType severity@var9 ) ;
117: static SeverityType fromString ( const std :: string & severity@var10 ) ;
118: } ;
119:
120: struct CWE {
121: explicit CWE ( unsigned short cweId@var11 ) : id@var12 ( cweId@var11 ) { }
122: unsigned short id@var12 ;
123: } ;

##file cppcheck-2.8/lib/mathlib.h

1:
|
33:
34: class MathLib {
35: friend class TestMathLib ;
36:
37: public:
38:
39: class value {
40: private:
41: long long mIntValue@var13 ;
42: double mDoubleValue@var14 ;
43: enum class Type { INT , LONG , LONGLONG , FLOAT } ; enum Type mType@var15 ;
44: bool mIsUnsigned@var16 ;
45:
46: void promote ( const value & v@var17 ) ;
47:
48: public:
49: explicit value ( const std :: string & s@var18 ) ;
50: std :: string str ( ) const ;
51: bool isInt ( ) const {
52: return mType@var15 !=@expr1073745387 Type ::@expr1073745388 FLOAT ;
53: }
54: bool isFloat ( ) const {
55: return mType@var15 ==@expr1073745389 Type ::@expr1073745390 FLOAT ;
56: }
57:
58: double getDoubleValue ( ) const {
59: return isFloat (@expr1073745391 ) ?@expr1073745392 mDoubleValue@var14 :@expr1073745393 (@expr1073745394 double ) mIntValue@var13 ;
60: }
61:
62: static value calc ( char op@var19 , const value & v1@var20 , const value & v2@var21 ) ;
63: int compare ( const value & v@var22 ) const ;
64: value add ( int v@var23 ) const ;
65: value shiftLeft ( const value & v@var24 ) const ;
66: value shiftRight ( const value & v@var25 ) const ;
67: } ;
68:
69:
70:
71: static const int bigint_bits@var26 ;
72:
73: static long long toLongNumber ( const std :: string & str@var27 ) ;
74: static unsigned long long toULongNumber ( const std :: string & str@var28 ) ;
75:
76: template < class T > static std :: string toString ( T value@var29 ) {
77: std ::@expr1073745395 ostringstream result@var30 ;
78: result@var30 <<@expr1073745396 value@var29 ;
79: return result@var30 .@expr1073745397 str (@expr1073745398 ) ;
80: }
81: static double toDoubleNumber ( const std :: string & str@var31 ) ;
82:
83: static bool isInt ( const std :: string & str@var32 ) ;
84: static bool isFloat ( const std :: string & str@var33 ) ;
85: static bool isDecimalFloat ( const std :: string & str@var34 ) ;
86: static bool isNegative ( const std :: string & str@var35 ) ;
87: static bool isPositive ( const std :: string & str@var36 ) ;
88: static bool isDec ( const std :: string & str@var37 ) ;
89: static bool isFloatHex ( const std :: string & str@var38 ) ;
90: static bool isIntHex ( const std :: string & str@var39 ) ;
91: static bool isOct ( const std :: string & str@var40 ) ;
92: static bool isBin ( const std :: string & str@var41 ) ;
93:
94: static std :: string getSuffix ( const std :: string & value@var42 ) ;
95:
|
101:
102: static bool isValidIntegerSuffix ( const std :: string & str@var43 , bool supportMicrosoftExtensions@var44 = true ) ;
103:
104: static std :: string add ( const std :: string & first@var45 , const std :: string & second@var46 ) ;
105: static std :: string subtract ( const std :: string & first@var47 , const std :: string & second@var48 ) ;
106: static std :: string multiply ( const std :: string & first@var49 , const std :: string & second@var50 ) ;
107: static std :: string divide ( const std :: string & first@var51 , const std :: string & second@var52 ) ;
108: static std :: string mod ( const std :: string & first@var53 , const std :: string & second@var54 ) ;
109: static std :: string incdec ( const std :: string & var@var55 , const std :: string & op@var56 ) ;
110: static std :: string calculate ( const std :: string & first@var57 , const std :: string & second@var58 , char action@var59 ) ;
111:
112: static std :: string sin ( const std :: string & tok@var60 ) ;
113: static std :: string cos ( const std :: string & tok@var61 ) ;
114: static std :: string tan ( const std :: string & tok@var62 ) ;
115: static std :: string abs ( const std :: string & tok@var63 ) ;
116: static bool isEqual ( const std :: string & first@var64 , const std :: string & second@var65 ) ;
117: static bool isNotEqual ( const std :: string & first@var66 , const std :: string & second@var67 ) ;
118: static bool isGreater ( const std :: string & first@var68 , const std :: string & second@var69 ) ;
119: static bool isGreaterEqual ( const std :: string & first@var70 , const std :: string & second@var71 ) ;
120: static bool isLess ( const std :: string & first@var72 , const std :: string & second@var73 ) ;
121: static bool isLessEqual ( const std :: string & first@var74 , const std :: string & second@var75 ) ;
122: static bool isNullValue ( const std :: string & str@var76 ) ;
123:
|
127:
128: static bool isOctalDigit ( char c@var77 ) ;
129:
130: static unsigned int encodeMultiChar ( const std :: string & str@var78 ) ;
131:
|
136:
137: static bool isDigitSeparator ( const std :: string & iCode@var79 , std :: string :: size_type iPos@var80 ) ;
138: } ;
139:
140: MathLib :: value operator+ ( const MathLib :: value & v1@var81 , const MathLib :: value & v2@var82 ) ;
141: MathLib :: value operator- ( const MathLib :: value & v1@var83 , const MathLib :: value & v2@var84 ) ;
142: MathLib :: value operator* ( const MathLib :: value & v1@var85 , const MathLib :: value & v2@var86 ) ;
143: MathLib :: value operator/ ( const MathLib :: value & v1@var87 , const MathLib :: value & v2@var88 ) ;
144: MathLib :: value operator% ( const MathLib :: value & v1@var89 , const MathLib :: value & v2@var90 ) ;
145: MathLib :: value operator& ( const MathLib :: value & v1@var91 , const MathLib :: value & v2@var92 ) ;
146: MathLib :: value operator| ( const MathLib :: value & v1@var93 , const MathLib :: value & v2@var94 ) ;
147: MathLib :: value operator^ ( const MathLib :: value & v1@var95 , const MathLib :: value & v2@var96 ) ;
148: MathLib :: value operator<< ( const MathLib :: value & v1@var97 , const MathLib :: value & v2@var98 ) ;
149: MathLib :: value operator>> ( const MathLib :: value & v1@var99 , const MathLib :: value & v2@var100 ) ;
150:
151: template < > std :: string MathLib :: toString < double > ( double value@var101 ) ;

##file cppcheck-2.8/lib/valueflow.h

1:
|
36:
37: class ErrorLogger ;
38: struct InferModel ;
39: class Settings ;
40: class SymbolDatabase ;
41: class Token ;
42: class TokenList ;
43: class ValueType ;
44: class Variable ;
45: class Scope ;
46:
47: template < class T >
48: class ValuePtr ;
49:
50: namespace ValueFlow {
51: struct increment {
52: template < class T >
53: void operator() ( T & x@var102 ) const {
54: x@var102 ++@expr1073745399 ;
55: }
56: } ;
57: struct decrement {
58: template < class T >
59: void operator() ( T & x@var103 ) const {
60: x@var103 --@expr1073745400 ;
61: }
62: } ;
63:
64: struct less {
65: template < class T , class U >
66: bool operator() ( const T & x@var104 , const U & y@var105 ) const {
67: return x@var104 <@expr1073745401 y@var105 ;
68: }
69: } ;
70:
71: struct adjacent {
72: template < class T , class U >
73: bool operator() ( const T & x@var106 , const U & y@var107 ) const {
74: return std ::@expr1073745402 abs (@expr1073745403 x@var106 -@expr1073745404 y@var107 ) ==@expr1073745405 1 ;
75: }
76: } ;
77:
78: struct equalVisitor {
79: template < class T , class U >
80: void operator() ( bool & result@var108 , T x@var109 , U y@var110 ) const {
81: result@var108 =@expr1073745406 !@expr1073745407 (@expr1073745408 x@var109 >@expr1073745409 y@var110 ||@expr1073745410 x@var109 <@expr1073745411 y@var110 ) ;
82: }
83: } ;
84: class Value {
85: public:
86:
87:
88: enum class Bound { Upper , Lower , Point } ;
89:
90: explicit Value ( long long val@var111 = 0 , Bound b@var112 = Bound :: Point )
91: : valueType@var152 ( ValueType :: INT ) ,
92: bound@var153 ( b@var112 ) ,
93: intvalue@var154 ( val@var111 ) ,
94: tokvalue@var155 ( nullptr ) ,
95: floatValue@var156 ( 0.0 ) ,
96: moveKind@var157 ( MoveKind :: NonMovedVariable ) ,
97: varvalue@var158 ( val@var111 ) ,
98: condition@var159 ( nullptr ) ,
99: varId@var161 ( 0U ) ,
100: safe@var162 ( false ) ,
101: conditional@var163 ( false ) ,
102: macro@var164 ( false ) ,
103: defaultArg@var165 ( false ) ,
104: indirect@var166 ( 0 ) ,
105: path@var167 ( 0 ) ,
106: wideintvalue@var168 ( val@var111 ) ,
107: subexpressions@var169 ( ) ,
108: capturetok@var170 ( nullptr ) ,
109: lifetimeKind@var171 ( LifetimeKind :: Object ) ,
110: lifetimeScope@var172 ( LifetimeScope :: Local ) ,
111: valueKind@var177 ( ValueKind :: Possible )
112: { }
113: Value ( const Token * c@var113 , long long val@var114 , Bound b@var115 = Bound :: Point ) ;
114:
115: static Value unknown ( ) ;
116:
117: bool equalValue ( const ValueFlow :: Value & rhs@var116 ) const {
118: if (@expr1073745412 valueType@var152 !=@expr1073745413 rhs@var116 .@expr1073745414 valueType@var117 ) {
119: return false ; }
120: switch (@expr1073745415 valueType@var152 ) {
121: case ValueType ::@expr1073745416 INT :@expr3593
122: case ValueType ::@expr1073745418 CONTAINER_SIZE :@expr3593
123: case ValueType ::@expr1073745420 BUFFER_SIZE :@expr3593
124: case ValueType ::@expr1073745422 ITERATOR_START :@expr3593
125: case ValueType ::@expr1073745424 ITERATOR_END :@expr3593 ;
126: if (@expr3602 intvalue@var154 !=@expr3603 rhs@var116 .@expr3604 intvalue@var118 ) {
127: return false ; }
128: break ;
129: case ValueType ::@expr1073745429 TOK :@expr3593 ;
130: if (@expr3607 tokvalue@var155 !=@expr3608 rhs@var116 .@expr3609 tokvalue@var119 ) {
131: return false ; }
132: break ;
133: case ValueType ::@expr1073745434 FLOAT :@expr3593 ;
134:
135: if (@expr1073745436 floatValue@var156 >@expr1073745437 rhs@var116 .@expr3614 floatValue@var120 ||@expr1073745439 floatValue@var156 <@expr1073745440 rhs@var116 .@expr3614 floatValue@var120 ) {
136: return false ; }
137: break ;
138: case ValueType ::@expr1073745442 MOVED :@expr3593 ;
139: if (@expr1073745444 moveKind@var157 !=@expr1073745445 rhs@var116 .@expr1073745446 moveKind@var121 ) {
140: return false ; }
141: break ;
142: case ValueType ::@expr1073745447 UNINIT :@expr3593 ;
143: break ;
144: case ValueType ::@expr1073745449 LIFETIME :@expr3593 ;
145: if (@expr3607 tokvalue@var155 !=@expr3608 rhs@var116 .@expr3609 tokvalue@var119 ) {
146: return false ; }
147: break ;
148: case ValueType ::@expr1073745454 SYMBOLIC :@expr3593 ;
149: if (@expr1073745456 !@expr1073745457 sameToken (@expr1073745458 tokvalue@var155 , rhs@var116 .@expr3609 tokvalue@var119 ) ) {
150: return false ; }
151: if (@expr3602 intvalue@var154 !=@expr3603 rhs@var116 .@expr3604 intvalue@var118 ) {
152: return false ; }
153: break ;
154: }
155: return true ;
156: }
157:
158: template < class T , class F >
159: static void visitValue ( T & self@var122 , F f@var123 ) {
160: switch (@expr1073745463 self@var122 .@expr1073745464 valueType@var124 ) {
161: case ValueType ::@expr1073745465 INT :@expr3642
162: case ValueType ::@expr1073745467 SYMBOLIC :@expr3642
163: case ValueType ::@expr1073745469 BUFFER_SIZE :@expr3642
164: case ValueType ::@expr1073745471 CONTAINER_SIZE :@expr3642
165: case ValueType ::@expr1073745473 ITERATOR_START :@expr3642
166: case ValueType ::@expr1073745475 ITERATOR_END :@expr3642 ; {
167: f@var123 (@expr1073745477 self@var122 .@expr1073745478 intvalue@var125 ) ;
168: break ;
169: }
170: case ValueType ::@expr1073745479 FLOAT :@expr3642 ; {
171: f@var123 (@expr1073745481 self@var122 .@expr1073745482 floatValue@var126 ) ;
172: break ;
173: }
174: case ValueType ::@expr1073745483 UNINIT :@expr3642
175: case ValueType ::@expr1073745485 TOK :@expr3642
176: case ValueType ::@expr1073745487 LIFETIME :@expr3642
177: case ValueType ::@expr1073745489 MOVED :@expr3642 ;
178: break ;
179: }
180: }
181:
182: struct compareVisitor {
183: struct innerVisitor {
184: template < class Compare , class T , class U >
185: void operator() ( bool & result@var127 , Compare compare@var128 , T x@var129 , U y@var130 ) const {
186: result@var127 =@expr1073745491 compare@var128 (@expr1073745492 x@var129 , y@var130 ) ;
187: }
188: } ;
189: template < class Compare , class T >
190: void operator() ( bool & result@var131 , const Value & rhs@var132 , Compare compare@var133 , T x@var134 ) const {
191: visitValue (@expr1073745494 rhs@var132 ,
192: std ::@expr1073745495 bind (@expr1073745496 innerVisitor {@expr1073745497 } , std ::@expr1073745498 ref (@expr1073745499 result@var131 ) , std ::@expr1073745500 move (@expr1073745501 compare@var133 ) , x@var134 , std ::@expr1073745502 placeholders ::@expr1073745503 _1@expr1073745493 ) ) ;
193: }
194: } ;
195:
196: template < class Compare >
197: bool compareValue ( const Value & rhs@var135 , Compare compare@var136 ) const {
198: assert (@expr1073745505 (@expr1073745506 !@expr1073745507 this@expr3684 .@expr1073745509 isSymbolicValue (@expr1073745510 ) &&@expr1073745511 !@expr1073745512 rhs@var135 .@expr1073745513 isSymbolicValue (@expr1073745514 ) ) ||@expr1073745515
199: (@expr1073745516 this@expr3684 .@expr1073745517 valueType@var152 ==@expr1073745518 rhs@var135 .@expr1073745519 valueType@var137 &&@expr1073745520 sameToken (@expr1073745521 this@expr3684 .@expr1073745522 tokvalue@var155 , rhs@var135 .@expr1073745523 tokvalue@var138 ) ) ) ;
200: bool result@var139 ; result@var139 =@expr1073745524 false ;
201: visitValue (@expr1073745525
202: *@expr1073745526 this@expr3684 ,
203: std ::@expr1073745527 bind (@expr1073745528 compareVisitor {@expr1073745529 } , std ::@expr3706 ref (@expr1073745531 result@var139 ) , std ::@expr3706 ref (@expr1073745533 rhs@var135 ) , std ::@expr1073745534 move (@expr1073745535 compare@var136 ) , std ::@expr1073745536 placeholders ::@expr1073745537 _1@expr1073745504 ) ) ;
204: return result@var139 ;
205: }
206:
207: bool operator== ( const Value & rhs@var140 ) const {
208: if (@expr1073745538 !@expr1073745539 equalValue (@expr1073745540 rhs@var140 ) ) {
209: return false ; }
210:
211: return varvalue@var158 ==@expr1073745541 rhs@var140 .@expr1073745542 varvalue@var141 &&@expr1073745543
212: condition@var159 ==@expr1073745544 rhs@var140 .@expr1073745545 condition@var142 &&@expr1073745546
213: varId@var161 ==@expr1073745547 rhs@var140 .@expr1073745548 varId@var143 &&@expr1073745549
214: conditional@var163 ==@expr1073745550 rhs@var140 .@expr1073745551 conditional@var144 &&@expr1073745552
215: defaultArg@var165 ==@expr1073745553 rhs@var140 .@expr1073745554 defaultArg@var145 &&@expr1073745555
216: indirect@var166 ==@expr1073745556 rhs@var140 .@expr1073745557 indirect@var146 &&@expr1073745558
217: valueKind@var177 ==@expr1073745559 rhs@var140 .@expr1073745560 valueKind@var147 ;
218: }
219:
220: bool operator!= ( const Value & rhs@var148 ) const {
221: return !@expr1073745561 (@expr1073745562 *@expr1073745563 this@expr1073745564 ==@expr1073745565 rhs@var148 ) ;
222: }
223:
224: template < class T , $class $= $typename $std $:: $enable_if $< std :: is_arithmetic < T > $:: $value $> $:: $type >
225: bool equalTo ( const T & x@var149 ) const {
226: bool result@var150 ; result@var150 =@expr1073745567 false ;
227: visitValue (@expr1073745568 *@expr1073745569 this@expr1073745570 , std ::@expr1073745571 bind (@expr1073745572 equalVisitor {@expr1073745573 } , std ::@expr1073745574 ref (@expr1073745575 result@var150 ) , x@var149 , std ::@expr1073745576 placeholders ::@expr1073745577 _1@expr1073745566 ) ) ;
228: return result@var150 ;
229: }
230:
231: void decreaseRange ( ) {
232: if (@expr1073745578 bound@var153 ==@expr1073745579 Bound ::@expr1073745580 Lower ) {
233: visitValue (@expr1073745581 *@expr3758 this@expr3759 , increment {@expr1073745584 } ) ; }
234: else { if (@expr1073745585 bound@var153 ==@expr1073745586 Bound ::@expr1073745587 Upper ) {
235: visitValue (@expr1073745588 *@expr3758 this@expr3759 , decrement {@expr1073745590 } ) ; } }
236: }
237:
238: void invertBound ( ) {
239: if (@expr1073745591 bound@var153 ==@expr1073745592 Bound ::@expr3769 Lower ) {
240: bound@var153 =@expr1073745594 Bound ::@expr3771 Upper ; }
241: else { if (@expr1073745596 bound@var153 ==@expr1073745597 Bound ::@expr3771 Upper ) {
242: bound@var153 =@expr1073745599 Bound ::@expr3769 Lower ; } }
243: }
244:
245: void invertRange ( ) {
246: invertBound (@expr1073745601 ) ;
247: decreaseRange (@expr1073745602 ) ;
248: }
249:
250: void assumeCondition ( const Token * tok@var151 ) ;
251:
252: std :: string infoString ( ) const ;
253:
254: enum class ValueType {
255: INT ,
256: TOK ,
257: FLOAT ,
258: MOVED ,
259: UNINIT ,
260: CONTAINER_SIZE ,
261: LIFETIME ,
262: BUFFER_SIZE ,
263: ITERATOR_START ,
264: ITERATOR_END ,
265: SYMBOLIC
266: } ; enum ValueType valueType@var152 ;
267: bool isIntValue ( ) const {
268: return valueType@var152 ==@expr1073745603 ValueType ::@expr1073745604 INT ;
269: }
270: bool isTokValue ( ) const {
271: return valueType@var152 ==@expr1073745605 ValueType ::@expr1073745606 TOK ;
272: }
273: bool isFloatValue ( ) const {
274: return valueType@var152 ==@expr1073745607 ValueType ::@expr1073745608 FLOAT ;
275: }
276: bool isMovedValue ( ) const {
277: return valueType@var152 ==@expr1073745609 ValueType ::@expr1073745610 MOVED ;
278: }
279: bool isUninitValue ( ) const {
280: return valueType@var152 ==@expr1073745611 ValueType ::@expr1073745612 UNINIT ;
281: }
282: bool isContainerSizeValue ( ) const {
283: return valueType@var152 ==@expr1073745613 ValueType ::@expr1073745614 CONTAINER_SIZE ;
284: }
285: bool isLifetimeValue ( ) const {
286: return valueType@var152 ==@expr1073745615 ValueType ::@expr1073745616 LIFETIME ;
287: }
288: bool isBufferSizeValue ( ) const {
289: return valueType@var152 ==@expr1073745617 ValueType ::@expr1073745618 BUFFER_SIZE ;
290: }
291: bool isIteratorValue ( ) const {
292: return valueType@var152 ==@expr1073745619 ValueType ::@expr1073745620 ITERATOR_START ||@expr1073745621 valueType@var152 ==@expr1073745622 ValueType ::@expr1073745623 ITERATOR_END ;
293: }
294: bool isIteratorStartValue ( ) const {
295: return valueType@var152 ==@expr1073745624 ValueType ::@expr1073745625 ITERATOR_START ;
296: }
297: bool isIteratorEndValue ( ) const {
298: return valueType@var152 ==@expr1073745626 ValueType ::@expr1073745627 ITERATOR_END ;
299: }
300: bool isSymbolicValue ( ) const {
301: return valueType@var152 ==@expr1073745628 ValueType ::@expr1073745629 SYMBOLIC ;
302: }
303:
304: bool isLocalLifetimeValue ( ) const {
305: return valueType@var152 ==@expr1073745631 ValueType ::@expr1073745632 LIFETIME &&@expr1073745633 lifetimeScope@var172 ==@expr1073745634 LifetimeScope ::@expr1073745635 Local@expr1073745630 ;
306: }
307:
308: bool isArgumentLifetimeValue ( ) const {
309: return valueType@var152 ==@expr1073745636 ValueType ::@expr1073745637 LIFETIME &&@expr1073745638 lifetimeScope@var172 ==@expr1073745639 LifetimeScope ::@expr1073745640 Argument ;
310: }
311:
312: bool isSubFunctionLifetimeValue ( ) const {
313: return valueType@var152 ==@expr1073745641 ValueType ::@expr1073745642 LIFETIME &&@expr1073745643 lifetimeScope@var172 ==@expr1073745644 LifetimeScope ::@expr1073745645 SubFunction ;
314: }
315:
316: bool isNonValue ( ) const {
317: return isMovedValue (@expr1073745646 ) ||@expr1073745647 isUninitValue (@expr1073745648 ) ||@expr1073745649 isLifetimeValue (@expr1073745650 ) ;
318: }
319:
320:
321: Bound bound@var153 ;
322:
323:
324: long long intvalue@var154 ;
325:
326:
327: const Token * tokvalue@var155 ;
328:
329:
330: double floatValue@var156 ;
331:
332:
333: enum class MoveKind { NonMovedVariable , MovedVariable , ForwardedVariable } ; enum MoveKind moveKind@var157 ;
334:
335:
336: long long varvalue@var158 ;
337:
338:
339: const Token * condition@var159 ;
340:
341: std :: list < std :: pair < const Token * , std :: string > > errorPath@var160 ;
342:
343:
344: int varId@var161 ;
345:
346:
347: bool safe@var162 ;
348:
349:
350: bool conditional@var163 ;
351:
352:
353: bool macro@var164 ;
354:
355:
356: bool defaultArg@var165 ;
357:
358: int indirect@var166 ;
359:
360:
361: long long path@var167 ;
362:
363:
364: long long wideintvalue@var168 ;
365:
366: std :: vector < std :: string > subexpressions@var169 ;
367:
368:
369: const Token * capturetok@var170 ;
370:
371: enum class LifetimeKind {
372:
373: Object ,
374:
375: SubObject ,
376:
377: Lambda ,
378:
379: Iterator ,
380:
381: Address
382: } ; enum LifetimeKind lifetimeKind@var171 ;
383:
384: enum class LifetimeScope { Local , Argument , SubFunction , ThisPointer , ThisValue } ; enum LifetimeScope lifetimeScope@var172 ;
385:
386: static const char * toString ( MoveKind moveKind@var173 ) ;
387: static const char * toString ( LifetimeKind lifetimeKind@var174 ) ;
388: static const char * toString ( LifetimeScope lifetimeScope@var175 ) ;
389: static const char * toString ( Bound bound@var176 ) ;
390:
391:
392: enum class ValueKind {
393:
394: Possible ,
395:
396: Known ,
397:
398: Inconclusive ,
399:
400: Impossible
401: } ; enum ValueKind valueKind@var177 ;
402:
403: void setKnown ( ) {
404: valueKind@var177 =@expr1073745651 ValueKind ::@expr1073745652 Known ;
405: }
406:
407: bool isKnown ( ) const {
408: return valueKind@var177 ==@expr1073745653 ValueKind ::@expr1073745654 Known ;
409: }
410:
411: void setPossible ( ) {
412: valueKind@var177 =@expr1073745656 ValueKind ::@expr1073745657 Possible@expr1073745655 ;
413: }
414:
415: bool isPossible ( ) const {
416: return valueKind@var177 ==@expr1073745659 ValueKind ::@expr1073745660 Possible@expr1073745658 ;
417: }
418:
419: bool isImpossible ( ) const {
420: return valueKind@var177 ==@expr1073745661 ValueKind ::@expr1073745662 Impossible ;
421: }
422:
423: void setImpossible ( ) {
424: valueKind@var177 =@expr1073745663 ValueKind ::@expr1073745664 Impossible ;
425: }
426:
427: void setInconclusive ( bool inconclusive@var178 = true ) {
428: if (@expr1073745665 inconclusive@var178 ) {
429: valueKind@var177 =@expr1073745666 ValueKind ::@expr1073745667 Inconclusive ; }
430: }
431:
432: bool isInconclusive ( ) const {
433: return valueKind@var177 ==@expr1073745668 ValueKind ::@expr1073745669 Inconclusive ;
434: }
435:
436: void changeKnownToPossible ( ) {
437: if (@expr1073745671 isKnown (@expr1073745672 ) ) {
438: valueKind@var177 =@expr1073745673 ValueKind ::@expr1073745674 Possible@expr1073745670 ; }
439: }
440:
441: bool errorSeverity ( ) const {
442: return !@expr1073745675 condition@var159 &&@expr1073745676 !@expr1073745677 defaultArg@var165 ;
443: }
444:
445: static bool sameToken ( const Token * tok1@var179 , const Token * tok2@var180 ) ;
446: } ;
447:
448:
449: const ValueFlow :: Value * valueFlowConstantFoldAST ( Token * expr@var181 , const Settings * settings@var182 ) ;
450:
451:
452: void setValues ( TokenList * tokenlist@var183 , SymbolDatabase * symboldatabase@var184 , ErrorLogger * errorLogger@var185 , const Settings * settings@var186 ) ;
453:
454: std :: string eitherTheConditionIsRedundant ( const Token * condition@var187 ) ;
455:
456: unsigned long getSizeOf ( const ValueType & vt@var188 , const Settings * settings@var189 ) ;
457:
458: const ValueFlow :: Value * findValue ( const std :: list < ValueFlow :: Value > & values@var190 ,
459: const Settings * settings@var191 ,
460: std :: function < bool ( const ValueFlow :: Value & ) > pred@var192 ) ;
461:
462: std :: vector < ValueFlow :: Value > isOutOfBounds ( const Value & size@var193 , const Token * indexTok@var194 , bool possible@var195 = true ) ;
463: }
464:
465: ValueFlow :: Value asImpossible ( ValueFlow :: Value v@var196 ) ;
466:
467: bool isContainerSizeChanged ( const Token * tok@var197 , const Settings * settings@var198 = nullptr , int depth@var199 = 20 ) ;
468:
469: struct LifetimeToken {
470: const Token * token@var200 ;
471: bool addressOf@var201 ;
472: ValueFlow :: Value :: ErrorPath errorPath@var202 ;
473: bool inconclusive@var203 ;
474:
475: LifetimeToken ( ) : token@var200 ( nullptr ) , addressOf@var201 ( false ) , errorPath@var202 ( ) , inconclusive@var203 ( false ) { }
476:
477: LifetimeToken ( const Token * token@var204 , ValueFlow :: Value :: ErrorPath errorPath@var205 )
478: : token@var200 ( token@var204 ) , addressOf@var201 ( false ) , errorPath@var202 ( std :: move ( errorPath@var205 ) ) , inconclusive@var203 ( false )
479: { }
480:
481: LifetimeToken ( const Token * token@var206 , bool addressOf@var207 , ValueFlow :: Value :: ErrorPath errorPath@var208 )
482: : token@var200 ( token@var206 ) , addressOf@var201 ( addressOf@var207 ) , errorPath@var202 ( std :: move ( errorPath@var208 ) ) , inconclusive@var203 ( false )
483: { }
484:
485: static std :: vector < LifetimeToken > setAddressOf ( std :: vector < LifetimeToken > v@var209 , bool b@var210 ) {
486: for (@expr1073745678 LifetimeToken &@expr1073745679 x@var211 :@expr1073745680 v@var209 ) {
487: x@var211 .@expr1073745681 addressOf@var212 =@expr1073745682 b@var210 ; }
488: return v@var209 ;
489: }
490:
491: static std :: vector < LifetimeToken > setInconclusive ( std :: vector < LifetimeToken > v@var213 , bool b@var214 ) {
492: for (@expr1073745683 LifetimeToken &@expr1073745684 x@var215 :@expr1073745685 v@var213 ) {
493: x@var215 .@expr1073745686 inconclusive@var216 =@expr1073745687 b@var214 ; }
494: return v@var213 ;
495: }
496: } ;
497:
498: const Token * parseCompareInt ( const Token * tok@var217 , ValueFlow :: Value & true_value@var218 , ValueFlow :: Value & false_value@var219 , const std :: function < std :: vector < long long > ( const Token * ) > & evaluate@var220 ) ;
499: const Token * parseCompareInt ( const Token * tok@var221 , ValueFlow :: Value & true_value@var222 , ValueFlow :: Value & false_value@var223 ) ;
500:
501: ValueFlow :: Value inferCondition ( std :: string op@var224 , long long val@var225 , const Token * varTok@var226 ) ;
502: ValueFlow :: Value inferCondition ( const std :: string & op@var227 , const Token * varTok@var228 , long long val@var229 ) ;
503:
504: ValuePtr < InferModel > makeIntegralInferModel ( ) ;
505:
506: const Token * solveExprValue ( const Token * expr@var230 ,
507: const std :: function < std :: vector < long long > ( const Token * ) > & eval@var231 ,
508: ValueFlow :: Value & value@var232 ) ;
509:
510: std :: vector < LifetimeToken > getLifetimeTokens ( const Token * tok@var233 ,
511: bool escape@var234 = false ,
512: ValueFlow :: Value :: ErrorPath errorPath@var235 = ValueFlow :: Value :: ErrorPath { } ) ;
513:
514: bool hasLifetimeToken ( const Token * tok@var236 , const Token * lifetime@var237 ) ;
515:
516: const Variable * getLifetimeVariable ( const Token * tok@var238 , ValueFlow :: Value :: ErrorPath & errorPath@var239 , bool * addressOf@var240 = nullptr ) ;
517:
518: const Variable * getLifetimeVariable ( const Token * tok@var241 ) ;
519:
520: bool isLifetimeBorrowed ( const Token * tok@var242 , const Settings * settings@var243 ) ;
521:
522: std :: string lifetimeType ( const Token * tok@var244 , const ValueFlow :: Value * val@var245 ) ;
523:
524: std :: string lifetimeMessage ( const Token * tok@var246 , const ValueFlow :: Value * val@var247 , ValueFlow :: Value :: ErrorPath & errorPath@var248 ) ;
525:
526: ValueFlow :: Value getLifetimeObjValue ( const Token * tok@var249 , bool inconclusive@var250 = false ) ;
527:
528: std :: vector < ValueFlow :: Value > getLifetimeObjValues ( const Token * tok@var251 ,
529: bool inconclusive@var252 = false ,
530: long long path@var253 = 0 ) ;
531:
532: const Token * getEndOfExprScope ( const Token * tok@var254 , const Scope * defaultScope@var255 = nullptr , bool smallest@var256 = true ) ;

##file cppcheck-2.8/lib/templatesimplifier.h

1:
|
34:
35: class ErrorLogger ;
36: class Settings ;
37: class Token ;
38: class Tokenizer ;
39: class TokenList ;
40:
|
44:
45: class TemplateSimplifier {
46: friend class TestSimplifyTemplate ;
47:
48: public:
49: explicit TemplateSimplifier ( Tokenizer * tokenizer@var257 ) ;
50: ~ TemplateSimplifier ( ) ;
51:
52:
53:
54: void checkComplicatedSyntaxErrorsInTemplates ( ) ;
55:
|
61:
62: static unsigned int templateParameters ( const Token * tok@var258 ) ;
63:
|
66:
67: class TokenAndName {
68: Token * mToken@var259 ;
69: std :: string mScope@var260 ;
70: std :: string mName@var261 ;
71: std :: string mFullName@var262 ;
72: const Token * mNameToken@var263 ;
73: const Token * mParamEnd@var264 ;
74: unsigned int mFlags@var265 ;
75:
76: enum Anonymous0 {
77: fIsClass = ( 1 << 0 ) ,
78: fIsFunction = ( 1 << 1 ) ,
79: fIsVariable = ( 1 << 2 ) ,
80: fIsAlias = ( 1 << 3 ) ,
81: fIsSpecialization = ( 1 << 4 ) ,
82: fIsPartialSpecialization = ( 1 << 5 ) ,
83: fIsForwardDeclaration = ( 1 << 6 ) ,
84: fIsVariadic = ( 1 << 7 ) ,
85: fIsFriend = ( 1 << 8 ) ,
86: fFamilyMask = ( fIsClass | fIsFunction | fIsVariable )
87: } ;
88:
89: void isClass ( bool state@var266 ) {
90: setFlag (@expr1073745688 fIsClass , state@var266 ) ;
91: }
92: void isFunction ( bool state@var267 ) {
93: setFlag (@expr1073745689 fIsFunction , state@var267 ) ;
94: }
95: void isVariable ( bool state@var268 ) {
96: setFlag (@expr1073745690 fIsVariable , state@var268 ) ;
97: }
98: void isAlias ( bool state@var269 ) {
99: setFlag (@expr1073745691 fIsAlias , state@var269 ) ;
100: }
101: void isSpecialization ( bool state@var270 ) {
102: setFlag (@expr1073745692 fIsSpecialization , state@var270 ) ;
103: }
104: void isPartialSpecialization ( bool state@var271 ) {
105: setFlag (@expr1073745693 fIsPartialSpecialization , state@var271 ) ;
106: }
107: void isForwardDeclaration ( bool state@var272 ) {
108: setFlag (@expr1073745694 fIsForwardDeclaration , state@var272 ) ;
109: }
110: void isVariadic ( bool state@var273 ) {
111: setFlag (@expr1073745695 fIsVariadic , state@var273 ) ;
112: }
113: void isFriend ( bool state@var274 ) {
114: setFlag (@expr1073745696 fIsFriend , state@var274 ) ;
115: }
116:
|
121:
122: bool getFlag ( unsigned int flag@var275 ) const {
123: return (@expr3873 (@expr3873 mFlags@var265 &@expr1073745699 flag@var275 ) !=@expr1073745700 0 ) ;
124: }
125:
|
130:
131: void setFlag ( unsigned int flag@var276 , bool state@var277 ) {
132: mFlags@var265 =@expr1073745701 state@var277 ?@expr1073745702 mFlags@var265 |@expr1073745703 flag@var276 :@expr1073745704 mFlags@var265 &@expr1073745705 ~@expr1073745706 flag@var276 ;
133: }
134:
135: public:
136:
|
140:
141: TokenAndName ( Token * token@var278 , const std :: string & scope@var279 ) ;
142:
|
148:
149: TokenAndName ( Token * token@var280 , const std :: string & scope@var281 , const Token * nameToken@var282 , const Token * paramEnd@var283 ) ;
150: TokenAndName ( const TokenAndName & other@var284 ) ;
151: ~ TokenAndName ( ) ;
152:
153: bool operator== ( const TokenAndName & rhs@var285 ) const {
154: return mToken@var259 ==@expr1073745707 rhs@var285 .@expr1073745708 mToken@var286 &&@expr1073745709 mScope@var260 ==@expr1073745710 rhs@var285 .@expr1073745711 mScope@var287 &&@expr1073745712 mName@var261 ==@expr1073745713 rhs@var285 .@expr1073745714 mName@var288 &&@expr1073745715 mFullName@var262 ==@expr1073745716 rhs@var285 .@expr1073745717 mFullName@var289 &&@expr1073745718
155: mNameToken@var263 ==@expr1073745719 rhs@var285 .@expr1073745720 mNameToken@var290 &&@expr1073745721 mParamEnd@var264 ==@expr1073745722 rhs@var285 .@expr1073745723 mParamEnd@var291 &&@expr1073745724 mFlags@var265 ==@expr1073745725 rhs@var285 .@expr1073745726 mFlags@var292 ;
156: }
157:
158: Token * token ( ) const {
159: return mToken@var259 ;
160: }
161: void token ( Token * token@var293 ) {
162: mToken@var259 =@expr1073745727 token@var293 ;
163: }
164: const std :: string & scope ( ) const {
165: return mScope@var260 ;
166: }
167: const std :: string & name ( ) const {
168: return mName@var261 ;
169: }
170: const std :: string & fullName ( ) const {
171: return mFullName@var262 ;
172: }
173: const Token * nameToken ( ) const {
174: return mNameToken@var263 ;
175: }
176: const Token * paramEnd ( ) const {
177: return mParamEnd@var264 ;
178: }
179: void paramEnd ( const Token * end@var294 ) {
180: mParamEnd@var264 =@expr1073745728 end@var294 ;
181: }
182:
183: bool isClass ( ) const {
184: return getFlag (@expr1073745729 fIsClass ) ;
185: }
186: bool isFunction ( ) const {
187: return getFlag (@expr1073745730 fIsFunction ) ;
188: }
189: bool isVariable ( ) const {
190: return getFlag (@expr1073745731 fIsVariable ) ;
191: }
192: bool isAlias ( ) const {
193: return getFlag (@expr1073745732 fIsAlias ) ;
194: }
195: bool isSpecialization ( ) const {
196: return getFlag (@expr1073745733 fIsSpecialization ) ;
197: }
198: bool isPartialSpecialization ( ) const {
199: return getFlag (@expr1073745734 fIsPartialSpecialization ) ;
200: }
201: bool isForwardDeclaration ( ) const {
202: return getFlag (@expr1073745735 fIsForwardDeclaration ) ;
203: }
204: bool isVariadic ( ) const {
205: return getFlag (@expr1073745736 fIsVariadic ) ;
206: }
207: bool isFriend ( ) const {
208: return getFlag (@expr1073745737 fIsFriend ) ;
209: }
210:
|
216:
217: const Token * aliasStartToken ( ) const ;
218:
|
224:
225: const Token * aliasEndToken ( ) const ;
226:
|
233:
234: bool isAliasToken ( const Token * tok@var295 ) const ;
235:
|
241:
242: bool isSameFamily ( const TemplateSimplifier :: TokenAndName & decl@var296 ) const {
243:
244:
245: return (@expr3914 (@expr3914 mFlags@var265 &@expr1073745740 fFamilyMask ) &@expr1073745741 (@expr3914 decl@var296 .@expr1073745743 mFlags@var297 &@expr1073745744 fFamilyMask ) ) !=@expr1073745745 0 ;
246: }
247: } ;
248:
|
253:
254: static Token * findTemplateDeclarationEnd ( Token * tok@var298 ) ;
255: static const Token * findTemplateDeclarationEnd ( const Token * tok@var299 ) ;
256:
|
264:
265: static bool instantiateMatch ( const Token * instance@var300 , const unsigned long numberOfArguments@var301 , bool variadic@var302 , const char patternAfter@var303 [ ] ) ;
266:
|
272:
273: int getTemplateNamePosition ( const Token * tok@var304 ) ;
274:
|
280:
281: static bool getTemplateNamePositionTemplateClass ( const Token * tok@var305 , int & namepos@var306 ) ;
282:
|
288:
289: static bool getTemplateNamePositionTemplateFunction ( const Token * tok@var307 , int & namepos@var308 ) ;
290:
|
296:
297: static bool getTemplateNamePositionTemplateVariable ( const Token * tok@var309 , int & namepos@var310 ) ;
298:
|
303:
304: void simplifyTemplates (
305: const std :: time_t maxtime@var311 ,
306: bool & codeWithTemplates@var312 ) ;
307:
|
313:
314: static bool simplifyNumericCalculations ( Token * tok@var313 , bool isTemplate@var314 = true ) ;
315:
|
321:
322: bool simplifyCalculations ( Token * frontToken@var315 = nullptr , Token * backToken@var316 = nullptr , bool isTemplate@var317 = true ) ;
323:
|
327:
328: void simplifyTemplateArgs ( Token * start@var318 , Token * end@var319 ) ;
329:
330: private:
331:
|
334:
335: bool getTemplateDeclarations ( ) ;
336:
|
340:
341: void addInstantiation ( Token * token@var320 , const std :: string & scope@var321 ) ;
342:
|
345:
346: void getTemplateInstantiations ( ) ;
347:
|
351:
352: void fixForwardDeclaredDefaultArgumentValues ( ) ;
353:
|
356:
357: void useDefaultArgumentValues ( ) ;
358:
|
362:
363: void useDefaultArgumentValues ( TokenAndName & declaration@var322 ) ;
364:
|
368:
369: void getSpecializations ( ) ;
370:
|
374:
375: void getPartialSpecializations ( ) ;
376:
|
379:
380: void simplifyTemplateAliases ( ) ;
381:
|
390:
391: bool simplifyTemplateInstantiations (
392: const TokenAndName & templateDeclaration@var323 ,
393: const std :: list < const Token * > & specializations@var324 ,
394: const std :: time_t maxtime@var325 ,
395: std :: set < std :: string > & expandedtemplates@var326 ) ;
396:
|
401:
402: void addNamespace ( const TokenAndName & templateDeclaration@var327 , const Token * tok@var328 ) ;
403:
|
409:
410: static bool alreadyHasNamespace ( const TokenAndName & templateDeclaration@var329 , const Token * tok@var330 ) ;
411:
|
419:
420: void expandTemplate (
421: const TokenAndName & templateDeclaration@var331 ,
422: const TokenAndName & templateInstantiation@var332 ,
423: const std :: vector < const Token * > & typeParametersInDeclaration@var333 ,
424: const std :: string & newName@var334 ,
425: bool copy@var335 ) ;
426:
|
432:
433: void replaceTemplateUsage ( const TokenAndName & instantiation@var336 ,
434: const std :: list < std :: string > & typeStringsUsedInTemplateInstantiation@var337 ,
435: const std :: string & newName@var338 ) ;
436:
|
443:
444: static void getTemplateParametersInDeclaration (
445: const Token * tok@var339 ,
446: std :: vector < const Token * > & typeParametersInDeclaration@var340 ) ;
447:
|
450:
451: static bool removeTemplate ( Token * tok@var341 ) ;
452:
453:
454: static void syntaxError ( const Token * tok@var342 ) ;
455:
456: static bool matchSpecialization (
457: const Token * templateDeclarationNameToken@var343 ,
458: const Token * templateInstantiationNameToken@var344 ,
459: const std :: list < const Token * > & specializations@var345 ) ;
460:
|
465:
466: static void eraseTokens ( Token * begin@var346 , const Token * end@var347 ) ;
467:
|
472:
473: static void deleteToken ( Token * tok@var348 ) ;
474:
|
480:
481: std :: string getNewName (
482: Token * tok2@var349 ,
483: std :: list < std :: string > & typeStringsUsedInTemplateInstantiation@var350 ) ;
484:
485: void printOut (
486: const TokenAndName & tokenAndName@var351 ,
487: const std :: string & indent@var352 = "    " ) const ;
488: void printOut ( const std :: string & text@var353 = "" ) const ;
489:
490: Tokenizer * mTokenizer@var354 ;
491: TokenList & mTokenList@var355 ;
492: const Settings * mSettings@var356 ;
493: ErrorLogger * mErrorLogger@var357 ;
494: bool mChanged@var358 ;
495:
496: std :: list < TokenAndName > mTemplateDeclarations@var359 ;
497: std :: list < TokenAndName > mTemplateForwardDeclarations@var360 ;
498: std :: map < Token * , Token * > mTemplateForwardDeclarationsMap@var361 ;
499: std :: map < Token * , Token * > mTemplateSpecializationMap@var362 ;
500: std :: map < Token * , Token * > mTemplatePartialSpecializationMap@var363 ;
501: std :: list < TokenAndName > mTemplateInstantiations@var364 ;
502: std :: list < TokenAndName > mInstantiatedTemplates@var365 ;
503: std :: list < TokenAndName > mMemberFunctionsToDelete@var366 ;
504: std :: vector < TokenAndName > mExplicitInstantiationsToDelete@var367 ;
505: std :: vector < TokenAndName > mTypesUsedInTemplateInstantiation@var368 ;
506: std :: unordered_map < const Token * , int > mTemplateNamePos@var369 ;
507: } ;

##file cppcheck-2.8/lib/utils.h

1:
|
31:
32: struct SelectMapKeys {
33: template < class Pair >
34: Pair :: first_type operator() ( const Pair & p@var370 ) const {
35: return p@var370 .@expr1073745746 first@var371 ;
36: }
37: } ;
38:
39: struct SelectMapValues {
40: template < class Pair >
41: Pair :: second_type operator() ( const Pair & p@var372 ) const {
42: return p@var372 .@expr1073745747 second@var373 ;
43: }
44: } ;
45:
46: template < class Range , class T >
47: bool contains ( const Range & r@var374 , const T & x@var375 )
48: {
49: return std ::@expr1073745748 find (@expr1073745749 r@var374 .@expr1073745750 begin (@expr1073745751 ) , r@var374 .@expr3928 end (@expr3929 ) , x@var375 ) !=@expr1073745754 r@var374 .@expr3928 end (@expr3929 ) ;
50: }
51:
52: template < class T >
53: bool contains ( const std :: initializer_list < T > & r@var376 , const T & x@var377 )
54: {
55: return std ::@expr1073745757 find (@expr1073745758 r@var376 .@expr1073745759 begin (@expr1073745760 ) , r@var376 .@expr3937 end (@expr3938 ) , x@var377 ) !=@expr1073745763 r@var376 .@expr3937 end (@expr3938 ) ;
56: }
57:
58: template < class T , class U >
59: bool contains ( const std :: initializer_list < T > & r@var378 , const U & x@var379 )
60: {
61: return std ::@expr1073745766 find (@expr1073745767 r@var378 .@expr1073745768 begin (@expr1073745769 ) , r@var378 .@expr3946 end (@expr3947 ) , x@var379 ) !=@expr1073745772 r@var378 .@expr3946 end (@expr3947 ) ;
62: }
63:
64:
65: struct EnumClassHash {
66: template < typename T >
67: unsigned long operator() ( T t@var380 ) const
68: {
69: return static_cast < unsigned long > (@expr1073745775 t@var380 ) ;
70: }
71: } ;
72:
73: bool endsWith ( const std :: string & str@var381 , char c@var382 )
74: {
75: return !@expr1073745776 str@var381 .@expr1073745777 empty (@expr1073745778 ) &&@expr1073745779 str@var381 .@expr1073745780 back (@expr1073745781 ) ==@expr1073745782 c@var382 ;
76: }
77:
78: bool endsWith ( const std :: string & str@var383 , const char end@var384 [ ] , unsigned long endlen@var385 )
79: {
80: return (@expr3959 str@var383 .@expr3960 size (@expr3961 ) >=@expr1073745786 endlen@var385 ) &&@expr1073745787 (@expr3959 str@var383 .@expr1073745789 compare (@expr1073745790 str@var383 .@expr3960 size (@expr3961 ) -@expr1073745793 endlen@var385 , endlen@var385 , end@var384 ) ==@expr1073745794 0 ) ;
81: }
82:
83: template < unsigned long N >
84: bool endsWith ( const std :: string & str@var386 , const char ( & end@var387 ) [ N ] )
85: {
86: return endsWith (@expr1073745796 str@var386 , end@var387 , N@expr1073745795 -@expr1073745797 1 ) ;
87: }
88:
89: static bool isPrefixStringCharLiteral ( const std :: string & str@var388 , char q@var389 , const std :: string & p@var390 )
90: {
91: if (@expr1073745798 !@expr1073745799 endsWith (@expr1073745800 str@var388 , q@var389 ) ) {
92: return false ; }
93: if (@expr1073745801 (@expr1073745802 str@var388 .@expr1073745803 length (@expr1073745804 ) +@expr1073745805 1 ) >@expr1073745806 p@var390 .@expr1073745807 length (@expr1073745808 ) &&@expr1073745809 (@expr1073745810 str@var388 .@expr1073745811 compare (@expr1073745812 0 , p@var390 .@expr1073745813 size (@expr1073745814 ) +@expr1073745815 1 , p@var390 +@expr1073745816 q@var389 ) ==@expr1073745817 0 ) ) {
94: return true ; }
95: return false ;
96: }
97:
98: static bool isStringCharLiteral ( const std :: string & str@var391 , char q@var392 )
99: {
100: static const std ::@expr3994 vector < std ::@expr3994 string > suffixes@var393 {@expr1073745820 "" , "u8" , "u" , "U" , "L" } ;
101: for (@expr1073745821 const std ::@expr3994 string &@expr1073745823 p@var394 :@expr1073745824 suffixes@var393 ) {
102: if (@expr1073745825 isPrefixStringCharLiteral (@expr1073745826 str@var391 , q@var392 , p@var394 ) ) {
103: return true ; }
104: }
105: return false ;
106: }
107:
108: static bool isStringLiteral ( const std :: string & str@var395 )
109: {
110: return isStringCharLiteral (@expr1073745827 str@var395 , '"' ) ;
111: }
112:
113: static bool isCharLiteral ( const std :: string & str@var396 )
114: {
115: return isStringCharLiteral (@expr1073745828 str@var396 , '\'' ) ;
116: }
117:
118: static std :: string getStringCharLiteral ( const std :: string & str@var397 , char q@var398 )
119: {
120: const unsigned long quotePos@var399 =@expr1073745829 str@var397 .@expr1073745830 find (@expr1073745831 q@var398 ) ;
121: return str@var397 .@expr1073745832 substr (@expr1073745833 quotePos@var399 +@expr1073745834 1U , str@var397 .@expr1073745835 size (@expr1073745836 ) -@expr1073745837 quotePos@var399 -@expr1073745838 2U ) ;
122: }
123:
124: static std :: string getStringLiteral ( const std :: string & str@var400 )
125: {
126: if (@expr1073745839 isStringLiteral (@expr1073745840 str@var400 ) ) {
127: return getStringCharLiteral (@expr1073745841 str@var400 , '"' ) ; }
128: return "" ;
129: }
130:
131: static std :: string getCharLiteral ( const std :: string & str@var401 )
132: {
133: if (@expr1073745842 isCharLiteral (@expr1073745843 str@var401 ) ) {
134: return getStringCharLiteral (@expr1073745844 str@var401 , '\'' ) ; }
135: return "" ;
136: }
137:
138: static const char * getOrdinalText ( int i@var402 )
139: {
140: if (@expr1073745845 i@var402 ==@expr1073745846 1 ) {
141: return "st" ; }
142: if (@expr1073745847 i@var402 ==@expr1073745848 2 ) {
143: return "nd" ; }
144: if (@expr1073745849 i@var402 ==@expr1073745850 3 ) {
145: return "rd" ; }
146: return "th" ;
147: }
148:
149: int caseInsensitiveStringCompare ( const std :: string & lhs@var403 , const std :: string & rhs@var404 ) ;
150:
151: bool isValidGlobPattern ( const std :: string & pattern@var405 ) ;
152:
153: bool matchglob ( const std :: string & pattern@var406 , const std :: string & name@var407 ) ;
154:
155: bool matchglobs ( const std :: vector < std :: string > & patterns@var408 , const std :: string & name@var409 ) ;
156:
157: void strTolower ( std :: string & str@var410 ) ;

##file cppcheck-2.8/lib/token.h

1:
|
40:
41: class Enumerator ;
42: class Function ;
43: class Scope ;
44: class Settings ;
45: class Type ;
46: class ValueType ;
47: class Variable ;
48: class TokenList ;
49: class ConstTokenRange ;
50: class Token ;
51:
|
54:
55: struct TokensFrontBack {
56: Token * front@var411 ;
57: Token * back@var412 ;
58: const TokenList * list@var413 ;
59: } ;
60:
61: struct ScopeInfo2 {
62: ScopeInfo2 ( const std :: string & name_@var414 , const Token * bodyEnd_@var415 , const std :: set < std :: string > & usingNamespaces_@var416 = std :: set < std :: string > ( ) ) : name@var417 ( name_@var414 ) , bodyEnd@var418 ( bodyEnd_@var415 ) , usingNamespaces@var419 ( usingNamespaces_@var416 ) { }
63: std :: string name@var417 ;
64: const Token * const bodyEnd@var418 ;
65: std :: set < std :: string > usingNamespaces@var419 ;
66: } ;
67:
68: struct TokenImpl {
69: int mVarId@var420 ;
70: int mFileIndex@var421 ;
71: int mLineNumber@var422 ;
72: int mColumn@var423 ;
73: int mExprId@var424 ;
74:
75:
76: Token * mAstOperand1@var425 ;
77: Token * mAstOperand2@var426 ;
78: Token * mAstParent@var427 ;
79:
80:
81: const Scope * mScope@var428 ;
82: union {
83: const Function * mFunction@var429 ;
84: const Variable * mVariable@var430 ;
85: const :: Type * mType@var431 ;
86: const Enumerator * mEnumerator@var432 ;
87: } ;
88:
|
92:
93: int mProgressValue@var433 ;
94:
|
97:
98: int mIndex@var434 ;
99:
100:
101: std :: string * mOriginalName@var435 ;
102:
103:
104: ValueType * mValueType@var436 ;
105:
106:
107: std :: list < ValueFlow :: Value > * mValues@var437 ;
108: static const std :: list < ValueFlow :: Value > mEmptyValueList@var438 ;
109:
110:
111: std :: set < TemplateSimplifier :: TokenAndName * > * mTemplateSimplifierPointers@var439 ;
112:
113:
114: std :: shared_ptr < ScopeInfo2 > mScopeInfo@var440 ;
115:
116:
117: struct CppcheckAttributes {
118: enum Type { LOW , HIGH } ; enum Type type@var441 ;
119: long long value@var442 ;
120: struct CppcheckAttributes * next@var443 ;
121: } ;
122: struct CppcheckAttributes * mCppcheckAttributes@var444 ;
123:
124:
125: enum class Cpp11init { UNKNOWN , CPP11INIT , NOINIT } ; enum Cpp11init mCpp11init@var445 ;
126:
127:
128: unsigned char mBits@var446 ;
129:
130: void setCppcheckAttribute ( CppcheckAttributes :: Type type@var447 , long long value@var448 ) ;
131: bool getCppcheckAttribute ( CppcheckAttributes :: Type type@var449 , long long * value@var450 ) const ;
132:
133: TokenImpl ( )
134: : mVarId@var420 ( 0 )
135: , mFileIndex@var421 ( 0 )
136: , mLineNumber@var422 ( 0 )
137: , mColumn@var423 ( 0 )
138: , mExprId@var424 ( 0 )
139: , mAstOperand1@var425 ( nullptr )
140: , mAstOperand2@var426 ( nullptr )
141: , mAstParent@var427 ( nullptr )
142: , mScope@var428 ( nullptr )
143: , mFunction@var429 ( nullptr )
144: , mProgressValue@var433 ( 0 )
145: , mIndex@var434 ( 0 )
146: , mOriginalName@var435 ( nullptr )
147: , mValueType@var436 ( nullptr )
148: , mValues@var437 ( nullptr )
149: , mTemplateSimplifierPointers@var439 ( nullptr )
150: , mScopeInfo@var440 ( nullptr )
151: , mCppcheckAttributes@var444 ( nullptr )
152: , mCpp11init@var445 ( Cpp11init :: UNKNOWN )
153: , mBits@var446 ( 0 )
154: { }
155:
156: ~ TokenImpl ( ) ;
157: } ;
158:
|
171:
172: class Token {
173: private:
174: TokensFrontBack * mTokensFrontBack@var451 ;
175:
176:
177: Token ( const Token & ) ;
178: Token operator= ( const Token & ) ;
179:
180: public:
181: enum Type {
182: eVariable , eType , eFunction , eKeyword , eName ,
183: eNumber , eString , eChar , eBoolean , eLiteral , eEnumerator ,
184: eArithmeticalOp , eComparisonOp , eAssignmentOp , eLogicalOp , eBitOp , eIncDecOp , eExtendedOp ,
185: eBracket ,
186: eLambda ,
187: eEllipsis ,
188: eOther ,
189: eNone
190: } ;
191:
192: explicit Token ( TokensFrontBack * tokensFrontBack@var452 = nullptr ) ;
193: ~ Token ( ) ;
194:
195: ConstTokenRange until ( const Token * t@var453 ) const ;
196:
197: template < typename T >
198: void str ( T && s@var454 ) {
199: mStr@var666 =@expr1073745851 s@var454 ;
200: mImpl@var672 .@expr1073745852 mVarId@var703 =@expr1073745853 0 ;
201:
202: update_property_info (@expr1073745854 ) ;
203: }
204:
|
208:
209: void concatStr ( const std :: string & b@var455 ) ;
210:
211: const std :: string & str ( ) const {
212: return mStr@var666 ;
213: }
214:
|
217:
218: void deleteNext ( int count@var456 = 1 ) ;
219:
|
222:
223: void deletePrevious ( int count@var457 = 1 ) ;
224:
|
227:
228: void swapWithNext ( ) ;
229:
|
234:
235: const Token * tokAt ( int index@var458 ) const ;
236: Token * tokAt ( int index@var459 ) {
237: return const_cast < Token *@expr4031 > (@expr1073745856 const_cast < const Token *@expr4031 > (@expr1073745858 this@expr1073745859 ) .@expr1073745860 tokAt (@expr1073745861 index@var459 ) ) ;
238: }
239:
|
243:
244: const Token * linkAt ( int index@var460 ) const ;
245: Token * linkAt ( int index@var461 ) {
246: return const_cast < Token *@expr4038 > (@expr1073745863 const_cast < const Token *@expr4038 > (@expr1073745865 this@expr1073745866 ) .@expr1073745867 linkAt (@expr1073745868 index@var461 ) ) ;
247: }
248:
|
252:
253: const std :: string & strAt ( int index@var462 ) const ;
254:
|
273:
274: template < unsigned long count >
275: static bool simpleMatch ( const Token * tok@var463 , const char ( & pattern@var464 ) [ count ] ) {
276: return simpleMatch (@expr1073745870 tok@var463 , pattern@var464 , count@expr1073745869 -@expr1073745871 1 ) ;
277: }
278:
279: static bool simpleMatch ( const Token * tok@var465 , const char pattern@var466 [ ] , unsigned long pattern_len@var467 ) ;
280:
|
323:
324: static bool Match ( const Token * tok@var468 , const char pattern@var469 [ ] , int varid@var470 = 0 ) ;
325:
|
332:
333: static int getStrLength ( const Token * tok@var471 ) ;
334:
|
341:
342: static int getStrArraySize ( const Token * tok@var472 ) ;
343:
|
351:
352: static int getStrSize ( const Token * tok@var473 , const Settings * const settings@var474 ) ;
353:
|
361:
362: static std :: string getCharAt ( const Token * tok@var475 , long long index@var476 ) ;
363:
364: const ValueType * valueType ( ) const {
365: return mImpl@var672 .@expr1073745872 mValueType@var704 ;
366: }
367: void setValueType ( ValueType * vt@var477 ) ;
368:
369: const ValueType * argumentType ( ) const {
370: const Token * top@var478 ; top@var478 =@expr1073745873 this@expr1073745874 ;
371: while (@expr1073745875 top@var478 &&@expr1073745876 !@expr1073745877 Token ::@expr1073745878 Match (@expr1073745879 top@var478 .@expr4056 astParent (@expr4057 ) , ",|(" ) ) {
372: top@var478 =@expr1073745882 top@var478 .@expr4056 astParent (@expr4057 ) ; }
373: return top@var478 ?@expr1073745885 top@var478 .@expr1073745886 mImpl@var479 .@expr1073745887 mValueType@var480 :@expr1073745888 nullptr ;
374: }
375:
376: Token :: Type tokType ( ) const {
377: return mTokType@var670 ;
378: }
379: void tokType ( Token :: Type t@var481 ) {
380: mTokType@var670 =@expr1073745889 t@var481 ;
381:
382: const bool memoizedIsName@var482 =@expr1073745890 mTokType@var670 ==@expr1073745891 eName ||@expr1073745892 mTokType@var670 ==@expr1073745893 eType ||@expr1073745894 mTokType@var670 ==@expr1073745895 eVariable ||@expr1073745896
383: mTokType@var670 ==@expr1073745897 eFunction ||@expr1073745898 mTokType@var670 ==@expr1073745899 eKeyword ||@expr1073745900 mTokType@var670 ==@expr4077 eBoolean ||@expr1073745902
384: mTokType@var670 ==@expr4079 eEnumerator ;
385: setFlag (@expr1073745904 fIsName , memoizedIsName@var482 ) ;
386:
387: const bool memoizedIsLiteral@var483 =@expr1073745905 mTokType@var670 ==@expr1073745906 eNumber ||@expr1073745907 mTokType@var670 ==@expr1073745908 eString ||@expr1073745909 mTokType@var670 ==@expr1073745910 eChar ||@expr1073745911
388: mTokType@var670 ==@expr4077 eBoolean ||@expr1073745913 mTokType@var670 ==@expr1073745914 eLiteral ||@expr1073745915 mTokType@var670 ==@expr4079 eEnumerator ;
389: setFlag (@expr1073745917 fIsLiteral , memoizedIsLiteral@var483 ) ;
390: }
391: bool isKeyword ( ) const {
392: return mTokType@var670 ==@expr1073745918 eKeyword ;
393: }
394: bool isName ( ) const {
395: return getFlag (@expr1073745919 fIsName ) ;
396: }
397: bool isNameOnly ( ) const {
398: return mFlags@var671 ==@expr1073745920 fIsName &&@expr1073745921 mTokType@var670 ==@expr1073745922 eName ;
399: }
400: bool isUpperCaseName ( ) const ;
401: bool isLiteral ( ) const {
402: return getFlag (@expr1073745923 fIsLiteral ) ;
403: }
404: bool isNumber ( ) const {
405: return mTokType@var670 ==@expr1073745924 eNumber ;
406: }
407: bool isEnumerator ( ) const {
408: return mTokType@var670 ==@expr1073745925 eEnumerator ;
409: }
410: bool isOp ( ) const {
411: return (@expr1073745926 isConstOp (@expr1073745927 ) ||@expr1073745928
412: isAssignmentOp (@expr1073745929 ) ||@expr1073745930
413: mTokType@var670 ==@expr1073745931 eIncDecOp ) ;
414: }
415: bool isConstOp ( ) const {
416: return (@expr1073745932 isArithmeticalOp (@expr1073745933 ) ||@expr1073745934
417: mTokType@var670 ==@expr1073745935 eLogicalOp ||@expr1073745936
418: mTokType@var670 ==@expr1073745937 eComparisonOp ||@expr1073745938
419: mTokType@var670 ==@expr1073745939 eBitOp ) ;
420: }
421: bool isExtendedOp ( ) const {
422: return isConstOp (@expr1073745940 ) ||@expr1073745941
423: mTokType@var670 ==@expr1073745942 eExtendedOp ;
424: }
425: bool isArithmeticalOp ( ) const {
426: return mTokType@var670 ==@expr1073745943 eArithmeticalOp ;
427: }
428: bool isComparisonOp ( ) const {
429: return mTokType@var670 ==@expr1073745944 eComparisonOp ;
430: }
431: bool isAssignmentOp ( ) const {
432: return mTokType@var670 ==@expr1073745945 eAssignmentOp ;
433: }
434: bool isBoolean ( ) const {
435: return mTokType@var670 ==@expr1073745946 eBoolean ;
436: }
437: bool isIncDecOp ( ) const {
438: return mTokType@var670 ==@expr1073745947 eIncDecOp ;
439: }
440: bool isBinaryOp ( ) const {
441: return astOperand1 (@expr1073745948 ) !=@expr1073745949 nullptr &&@expr1073745950 astOperand2 (@expr1073745951 ) !=@expr1073745952 nullptr ;
442: }
443: bool isUnaryOp ( const std :: string & s@var484 ) const {
444: return s@var484 ==@expr1073745953 mStr@var666 &&@expr1073745954 astOperand1 (@expr1073745955 ) !=@expr1073745956 nullptr &&@expr1073745957 astOperand2 (@expr1073745958 ) ==@expr1073745959 nullptr ;
445: }
446: bool isUnaryPreOp ( ) const ;
447:
448: unsigned int flags ( ) const {
449: return mFlags@var671 ;
450: }
451: void flags ( const unsigned int flags_@var485 ) {
452: mFlags@var671 =@expr1073745960 flags_@var485 ;
453: }
454: bool isUnsigned ( ) const {
455: return getFlag (@expr1073745961 fIsUnsigned ) ;
456: }
457: void isUnsigned ( const bool sign@var486 ) {
458: setFlag (@expr1073745962 fIsUnsigned , sign@var486 ) ;
459: }
460: bool isSigned ( ) const {
461: return getFlag (@expr1073745963 fIsSigned ) ;
462: }
463: void isSigned ( const bool sign@var487 ) {
464: setFlag (@expr1073745964 fIsSigned , sign@var487 ) ;
465: }
466: bool isPointerCompare ( ) const {
467: return getFlag (@expr1073745965 fIsPointerCompare ) ;
468: }
469: void isPointerCompare ( const bool b@var488 ) {
470: setFlag (@expr1073745966 fIsPointerCompare , b@var488 ) ;
471: }
472: bool isLong ( ) const {
473: return getFlag (@expr1073745967 fIsLong ) ;
474: }
475: void isLong ( bool size@var489 ) {
476: setFlag (@expr1073745968 fIsLong , size@var489 ) ;
477: }
478: bool isStandardType ( ) const {
479: return getFlag (@expr1073745969 fIsStandardType ) ;
480: }
481: void isStandardType ( const bool b@var490 ) {
482: setFlag (@expr1073745970 fIsStandardType , b@var490 ) ;
483: }
484: bool isExpandedMacro ( ) const {
485: return getFlag (@expr1073745971 fIsExpandedMacro ) ;
486: }
487: void isExpandedMacro ( const bool m@var491 ) {
488: setFlag (@expr1073745972 fIsExpandedMacro , m@var491 ) ;
489: }
490: bool isCast ( ) const {
491: return getFlag (@expr1073745973 fIsCast ) ;
492: }
493: void isCast ( bool c@var492 ) {
494: setFlag (@expr1073745974 fIsCast , c@var492 ) ;
495: }
496: bool isAttributeConstructor ( ) const {
497: return getFlag (@expr1073745975 fIsAttributeConstructor ) ;
498: }
499: void isAttributeConstructor ( const bool ac@var493 ) {
500: setFlag (@expr1073745976 fIsAttributeConstructor , ac@var493 ) ;
501: }
502: bool isAttributeDestructor ( ) const {
503: return getFlag (@expr1073745977 fIsAttributeDestructor ) ;
504: }
505: void isAttributeDestructor ( const bool value@var494 ) {
506: setFlag (@expr1073745978 fIsAttributeDestructor , value@var494 ) ;
507: }
508: bool isAttributeUnused ( ) const {
509: return getFlag (@expr1073745979 fIsAttributeUnused ) ;
510: }
511: void isAttributeUnused ( bool unused@var495 ) {
512: setFlag (@expr1073745980 fIsAttributeUnused , unused@var495 ) ;
513: }
514: bool isAttributeUsed ( ) const {
515: return getFlag (@expr1073745981 fIsAttributeUsed ) ;
516: }
517: void isAttributeUsed ( const bool unused@var496 ) {
518: setFlag (@expr1073745982 fIsAttributeUsed , unused@var496 ) ;
519: }
520: bool isAttributePure ( ) const {
521: return getFlag (@expr1073745983 fIsAttributePure ) ;
522: }
523: void isAttributePure ( const bool value@var497 ) {
524: setFlag (@expr1073745984 fIsAttributePure , value@var497 ) ;
525: }
526: bool isAttributeConst ( ) const {
527: return getFlag (@expr1073745985 fIsAttributeConst ) ;
528: }
529: void isAttributeConst ( bool value@var498 ) {
530: setFlag (@expr1073745986 fIsAttributeConst , value@var498 ) ;
531: }
532: bool isAttributeNoreturn ( ) const {
533: return getFlag (@expr1073745987 fIsAttributeNoreturn ) ;
534: }
535: void isAttributeNoreturn ( const bool value@var499 ) {
536: setFlag (@expr1073745988 fIsAttributeNoreturn , value@var499 ) ;
537: }
538: bool isAttributeNothrow ( ) const {
539: return getFlag (@expr1073745989 fIsAttributeNothrow ) ;
540: }
541: void isAttributeNothrow ( const bool value@var500 ) {
542: setFlag (@expr1073745990 fIsAttributeNothrow , value@var500 ) ;
543: }
544: bool isAttributePacked ( ) const {
545: return getFlag (@expr1073745991 fIsAttributePacked ) ;
546: }
547: void isAttributePacked ( const bool value@var501 ) {
548: setFlag (@expr1073745992 fIsAttributePacked , value@var501 ) ;
549: }
550: bool isAttributeNodiscard ( ) const {
551: return getFlag (@expr1073745993 fIsAttributeNodiscard ) ;
552: }
553: void isAttributeNodiscard ( const bool value@var502 ) {
554: setFlag (@expr1073745994 fIsAttributeNodiscard , value@var502 ) ;
555: }
556: bool isAttributeMaybeUnused ( ) const {
557: return getFlag (@expr1073745995 fIsAttributeMaybeUnused ) ;
558: }
559: void isAttributeMaybeUnused ( const bool value@var503 ) {
560: setFlag (@expr1073745996 fIsAttributeMaybeUnused , value@var503 ) ;
561: }
562: void setCppcheckAttribute ( TokenImpl :: CppcheckAttributes :: Type type@var504 , long long value@var505 ) {
563: mImpl@var672 .@expr1073745997 setCppcheckAttribute (@expr1073745998 type@var504 , value@var505 ) ;
564: }
565: bool getCppcheckAttribute ( TokenImpl :: CppcheckAttributes :: Type type@var506 , long long * value@var507 ) const {
566: return mImpl@var672 .@expr1073745999 getCppcheckAttribute (@expr1073746000 type@var506 , value@var507 ) ;
567: }
568: bool hasCppcheckAttributes ( ) const {
569: return nullptr !=@expr1073746001 mImpl@var672 .@expr1073746002 mCppcheckAttributes@var705 ;
570: }
571: bool isControlFlowKeyword ( ) const {
572: return getFlag (@expr1073746003 fIsControlFlowKeyword ) ;
573: }
574: bool isOperatorKeyword ( ) const {
575: return getFlag (@expr1073746004 fIsOperatorKeyword ) ;
576: }
577: void isOperatorKeyword ( const bool value@var508 ) {
578: setFlag (@expr1073746005 fIsOperatorKeyword , value@var508 ) ;
579: }
580: bool isComplex ( ) const {
581: return getFlag (@expr1073746006 fIsComplex ) ;
582: }
583: void isComplex ( const bool value@var509 ) {
584: setFlag (@expr1073746007 fIsComplex , value@var509 ) ;
585: }
586: bool isEnumType ( ) const {
587: return getFlag (@expr1073746008 fIsEnumType ) ;
588: }
589: void isEnumType ( const bool value@var510 ) {
590: setFlag (@expr1073746009 fIsEnumType , value@var510 ) ;
591: }
592: bool isAtAddress ( ) const {
593: return getFlag (@expr1073746010 fAtAddress ) ;
594: }
595: void isAtAddress ( bool b@var511 ) {
596: setFlag (@expr1073746011 fAtAddress , b@var511 ) ;
597: }
598: bool isIncompleteVar ( ) const {
599: return getFlag (@expr1073746012 fIncompleteVar ) ;
600: }
601: void isIncompleteVar ( bool b@var512 ) {
602: setFlag (@expr1073746013 fIncompleteVar , b@var512 ) ;
603: }
604:
605: bool isIncompleteConstant ( ) const {
606: return getFlag (@expr1073746014 fIsIncompleteConstant ) ;
607: }
608: void isIncompleteConstant ( bool b@var513 ) {
609: setFlag (@expr1073746015 fIsIncompleteConstant , b@var513 ) ;
610: }
611:
612: bool isConstexpr ( ) const {
613: return getFlag (@expr1073746016 fConstexpr ) ;
614: }
615: void isConstexpr ( bool b@var514 ) {
616: setFlag (@expr1073746017 fConstexpr , b@var514 ) ;
617: }
618:
619: bool isExternC ( ) const {
620: return getFlag (@expr1073746018 fExternC ) ;
621: }
622: void isExternC ( bool b@var515 ) {
623: setFlag (@expr1073746019 fExternC , b@var515 ) ;
624: }
625:
626: bool isSplittedVarDeclComma ( ) const {
627: return getFlag (@expr1073746020 fIsSplitVarDeclComma ) ;
628: }
629: void isSplittedVarDeclComma ( bool b@var516 ) {
630: setFlag (@expr1073746021 fIsSplitVarDeclComma , b@var516 ) ;
631: }
632:
633: bool isSplittedVarDeclEq ( ) const {
634: return getFlag (@expr1073746022 fIsSplitVarDeclEq ) ;
635: }
636: void isSplittedVarDeclEq ( bool b@var517 ) {
637: setFlag (@expr1073746023 fIsSplitVarDeclEq , b@var517 ) ;
638: }
639:
640: bool isImplicitInt ( ) const {
641: return getFlag (@expr1073746024 fIsImplicitInt ) ;
642: }
643: void isImplicitInt ( bool b@var518 ) {
644: setFlag (@expr1073746025 fIsImplicitInt , b@var518 ) ;
645: }
646:
647: bool isInline ( ) const {
648: return getFlag (@expr1073746026 fIsInline ) ;
649: }
650: void isInline ( bool b@var519 ) {
651: setFlag (@expr1073746027 fIsInline , b@var519 ) ;
652: }
653:
654: bool isRemovedVoidParameter ( ) const {
655: return getFlag (@expr1073746028 fIsRemovedVoidParameter ) ;
656: }
657: void setRemovedVoidParameter ( bool b@var520 ) {
658: setFlag (@expr1073746029 fIsRemovedVoidParameter , b@var520 ) ;
659: }
660:
661: bool isTemplate ( ) const {
662: return getFlag (@expr1073746030 fIsTemplate ) ;
663: }
664: void isTemplate ( bool b@var521 ) {
665: setFlag (@expr1073746031 fIsTemplate , b@var521 ) ;
666: }
667:
668: bool isSimplifiedScope ( ) const {
669: return getFlag (@expr1073746032 fIsSimplifedScope ) ;
670: }
671: void isSimplifiedScope ( bool b@var522 ) {
672: setFlag (@expr1073746033 fIsSimplifedScope , b@var522 ) ;
673: }
674:
675: bool isBitfield ( ) const {
676: return mImpl@var672 .@expr1073746034 mBits@var706 >@expr1073746035 0 ;
677: }
678: unsigned char bits ( ) const {
679: return mImpl@var672 .@expr1073746036 mBits@var706 ;
680: }
681: std :: set < TemplateSimplifier :: TokenAndName * > * templateSimplifierPointers ( ) const {
682: return mImpl@var672 .@expr1073746037 mTemplateSimplifierPointers@var707 ;
683: }
684: void templateSimplifierPointer ( TemplateSimplifier :: TokenAndName * tokenAndName@var523 ) {
685: if (@expr1073746038 !@expr1073746039 mImpl@var672 .@expr4216 mTemplateSimplifierPointers@var707 ) {
686: mImpl@var672 .@expr4216 mTemplateSimplifierPointers@var707 =@expr1073746042 new std ::@expr1073746043 set < TemplateSimplifier ::@expr1073746044 TokenAndName *@expr1073746045 > ; }
687: mImpl@var672 .@expr4216 mTemplateSimplifierPointers@var707 .@expr1073746047 insert (@expr1073746048 tokenAndName@var523 ) ;
688: }
689: void setBits ( const unsigned char b@var524 ) {
690: mImpl@var672 .@expr1073746049 mBits@var706 =@expr1073746050 b@var524 ;
691: }
692:
693: bool isUtf8 ( ) const {
694: return (@expr4227 (@expr4227 (@expr4227 mTokType@var670 ==@expr1073746054 eString ) &&@expr1073746055 isPrefixStringCharLiteral (@expr1073746056 mStr@var666 , '"' , "u8" ) ) ||@expr1073746057
695: (@expr4227 (@expr4227 mTokType@var670 ==@expr1073746060 eChar ) &&@expr1073746061 isPrefixStringCharLiteral (@expr1073746062 mStr@var666 , '\'' , "u8" ) ) ) ;
696: }
697:
698: bool isUtf16 ( ) const {
699: return (@expr4239 (@expr4239 (@expr4239 mTokType@var670 ==@expr1073746066 eString ) &&@expr1073746067 isPrefixStringCharLiteral (@expr1073746068 mStr@var666 , '"' , "u" ) ) ||@expr1073746069
700: (@expr4239 (@expr4239 mTokType@var670 ==@expr1073746072 eChar ) &&@expr1073746073 isPrefixStringCharLiteral (@expr1073746074 mStr@var666 , '\'' , "u" ) ) ) ;
701: }
702:
703: bool isUtf32 ( ) const {
704: return (@expr4251 (@expr4251 (@expr4251 mTokType@var670 ==@expr1073746078 eString ) &&@expr1073746079 isPrefixStringCharLiteral (@expr1073746080 mStr@var666 , '"' , "U" ) ) ||@expr1073746081
705: (@expr4251 (@expr4251 mTokType@var670 ==@expr1073746084 eChar ) &&@expr1073746085 isPrefixStringCharLiteral (@expr1073746086 mStr@var666 , '\'' , "U" ) ) ) ;
706: }
707:
708: bool isCChar ( ) const {
709: return (@expr4263 (@expr4263 (@expr4263 mTokType@var670 ==@expr1073746090 eString ) &&@expr1073746091 isPrefixStringCharLiteral (@expr1073746092 mStr@var666 , '"' , "" ) ) ||@expr1073746093
710: (@expr4263 (@expr4263 mTokType@var670 ==@expr1073746096 eChar ) &&@expr1073746097 isPrefixStringCharLiteral (@expr1073746098 mStr@var666 , '\'' , "" ) &&@expr1073746099 mStr@var666 .@expr1073746100 length (@expr1073746101 ) ==@expr1073746102 3 ) ) ;
711: }
712:
713: bool isCMultiChar ( ) const {
714: return (@expr4279 (@expr4279 (@expr4279 mTokType@var670 ==@expr1073746106 eChar ) &&@expr1073746107 isPrefixStringCharLiteral (@expr1073746108 mStr@var666 , '\'' , "" ) ) &&@expr1073746109
715: (@expr4279 mStr@var666 .@expr1073746111 length (@expr1073746112 ) >@expr1073746113 3 ) ) ;
716: }
717:
|
733:
734: bool isTemplateArg ( ) const {
735: return getFlag (@expr1073746114 fIsTemplateArg ) ;
736: }
737: void isTemplateArg ( const bool value@var525 ) {
738: setFlag (@expr1073746115 fIsTemplateArg , value@var525 ) ;
739: }
740:
741: template < unsigned long count >
742: static const Token * findsimplematch ( const Token * const startTok@var526 , const char ( & pattern@var527 ) [ count ] ) {
743: return findsimplematch (@expr1073746117 startTok@var526 , pattern@var527 , count@expr1073746116 -@expr1073746118 1 ) ;
744: }
745: static const Token * findsimplematch ( const Token * const startTok@var528 , const char pattern@var529 [ ] , unsigned long pattern_len@var530 ) ;
746:
747: template < unsigned long count >
748: static const Token * findsimplematch ( const Token * const startTok@var531 , const char ( & pattern@var532 ) [ count ] , const Token * const end@var533 ) {
749: return findsimplematch (@expr1073746120 startTok@var531 , pattern@var532 , count@expr1073746119 -@expr1073746121 1 , end@var533 ) ;
750: }
751: static const Token * findsimplematch ( const Token * const startTok@var534 , const char pattern@var535 [ ] , unsigned long pattern_len@var536 , const Token * const end@var537 ) ;
752:
753: static const Token * findmatch ( const Token * const startTok@var538 , const char pattern@var539 [ ] , const int varId@var540 = 0 ) ;
754: static const Token * findmatch ( const Token * const startTok@var541 , const char pattern@var542 [ ] , const Token * const end@var543 , const int varId@var544 = 0 ) ;
755:
756: template < unsigned long count >
757: static Token * findsimplematch ( Token * const startTok@var545 , const char ( & pattern@var546 ) [ count ] ) {
758: return findsimplematch (@expr1073746123 startTok@var545 , pattern@var546 , count@expr1073746122 -@expr1073746124 1 ) ;
759: }
760: static Token * findsimplematch ( Token * const startTok@var547 , const char pattern@var548 [ ] , unsigned long pattern_len@var549 ) {
761: return const_cast < Token *@expr4301 > (@expr1073746126 findsimplematch (@expr1073746127 const_cast < const Token *@expr4301 > (@expr1073746129 startTok@var547 ) , pattern@var548 , pattern_len@var549 ) ) ;
762: }
763: template < unsigned long count >
764: static Token * findsimplematch ( Token * const startTok@var550 , const char ( & pattern@var551 ) [ count ] , const Token * const end@var552 ) {
765: return findsimplematch (@expr1073746131 startTok@var550 , pattern@var551 , count@expr1073746130 -@expr1073746132 1 , end@var552 ) ;
766: }
767: static Token * findsimplematch ( Token * const startTok@var553 , const char pattern@var554 [ ] , unsigned long pattern_len@var555 , const Token * const end@var556 ) {
768: return const_cast < Token *@expr4309 > (@expr1073746134 findsimplematch (@expr1073746135 const_cast < const Token *@expr4309 > (@expr1073746137 startTok@var553 ) , pattern@var554 , pattern_len@var555 , end@var556 ) ) ;
769: }
770:
771: static Token * findmatch ( Token * const startTok@var557 , const char pattern@var558 [ ] , const int varId@var559 = 0 ) {
772: return const_cast < Token *@expr4314 > (@expr1073746139 findmatch (@expr1073746140 const_cast < const Token *@expr4314 > (@expr1073746142 startTok@var557 ) , pattern@var558 , varId@var559 ) ) ;
773: }
774: static Token * findmatch ( Token * const startTok@var560 , const char pattern@var561 [ ] , const Token * const end@var562 , const int varId@var563 = 0 ) {
775: return const_cast < Token *@expr4319 > (@expr1073746144 findmatch (@expr1073746145 const_cast < const Token *@expr4319 > (@expr1073746147 startTok@var560 ) , pattern@var561 , end@var562 , varId@var563 ) ) ;
776: }
777:
|
791:
792: static int multiCompare ( const Token * tok@var564 , const char * haystack@var565 , int varid@var566 ) ;
793:
794: int fileIndex ( ) const {
795: return mImpl@var672 .@expr1073746148 mFileIndex@var708 ;
796: }
797: void fileIndex ( int indexOfFile@var567 ) {
798: mImpl@var672 .@expr1073746149 mFileIndex@var708 =@expr1073746150 indexOfFile@var567 ;
799: }
800:
801: int linenr ( ) const {
802: return mImpl@var672 .@expr1073746151 mLineNumber@var709 ;
803: }
804: void linenr ( int lineNumber@var568 ) {
805: mImpl@var672 .@expr1073746152 mLineNumber@var709 =@expr1073746153 lineNumber@var568 ;
806: }
807:
808: int column ( ) const {
809: return mImpl@var672 .@expr1073746154 mColumn@var710 ;
810: }
811: void column ( int c@var569 ) {
812: mImpl@var672 .@expr1073746155 mColumn@var710 =@expr1073746156 c@var569 ;
813: }
814:
815: Token * next ( ) const {
816: return mNext@var667 ;
817: }
818:
|
826:
827: static void eraseTokens ( Token * begin@var570 , const Token * end@var571 ) ;
828:
|
836:
837: Token * insertToken ( const std :: string & tokenStr@var572 , const std :: string & originalNameStr@var573 = emptyString@var1 , bool prepend@var574 = false ) ;
838:
839: Token * insertTokenBefore ( const std :: string & tokenStr@var575 , const std :: string & originalNameStr@var576 = emptyString@var1 )
840: {
841: return insertToken (@expr1073746157 tokenStr@var575 , originalNameStr@var576 , true ) ;
842: }
843:
844: Token * previous ( ) const {
845: return mPrevious@var668 ;
846: }
847:
848:
849: int varId ( ) const {
850: return mImpl@var672 .@expr1073746158 mVarId@var703 ;
851: }
852: void varId ( int id@var577 ) {
853: mImpl@var672 .@expr1073746159 mVarId@var703 =@expr1073746160 id@var577 ;
854: if (@expr1073746161 id@var577 !=@expr1073746162 0 ) {
855: tokType (@expr1073746163 eVariable ) ;
856: isStandardType (@expr1073746164 false ) ;
857: } else {
858: update_property_info (@expr1073746165 ) ;
859: }
860: }
861:
862: int exprId ( ) const {
863: if (@expr1073746166 mImpl@var672 .@expr4343 mExprId@var711 ) {
864: return mImpl@var672 .@expr4343 mExprId@var711 ; }
865: return mImpl@var672 .@expr1073746169 mVarId@var703 ;
866: }
867: void exprId ( int id@var578 ) {
868: mImpl@var672 .@expr1073746170 mExprId@var711 =@expr1073746171 id@var578 ;
869: }
870:
|
876:
877: void printOut ( const char * title@var579 = nullptr ) const ;
878:
|
886:
887: void printOut ( const char * title@var580 , const std :: vector < std :: string > & fileNames@var581 ) const ;
888:
|
891:
892: void printLines ( int lines@var582 = 5 ) const ;
893:
|
900:
901: static void replace ( Token * replaceThis@var583 , Token * start@var584 , Token * end@var585 ) ;
902:
903: struct stringifyOptions {
904: bool varid@var586 ; varid@var586 = false ;
905: bool exprid@var587 ; exprid@var587 = false ;
906: bool idtype@var588 ; idtype@var588 = false ;
907: bool attributes@var589 ; attributes@var589 = false ;
908: bool macro@var590 ; macro@var590 = false ;
909: bool linenumbers@var591 ; linenumbers@var591 = false ;
910: bool linebreaks@var592 ; linebreaks@var592 = false ;
911: bool files@var593 ; files@var593 = false ;
912: static stringifyOptions forDebug ( ) {
913: stringifyOptions options@var594 ;
914: options@var594 .@expr1073746172 attributes@var595 =@expr1073746173 true ;
915: options@var594 .@expr1073746174 macro@var596 =@expr1073746175 true ;
916: options@var594 .@expr1073746176 linenumbers@var597 =@expr1073746177 true ;
917: options@var594 .@expr1073746178 linebreaks@var598 =@expr1073746179 true ;
918: options@var594 .@expr1073746180 files@var599 =@expr1073746181 true ;
919: return options@var594 ;
920: }
921: static stringifyOptions forDebugVarId ( ) {
922: stringifyOptions options@var600 ; options@var600 =@expr1073746182 forDebug (@expr1073746183 ) ;
923: options@var600 .@expr1073746184 varid@var601 =@expr1073746185 true ;
924: return options@var600 ;
925: }
926: static stringifyOptions forDebugExprId ( ) {
927: stringifyOptions options@var602 ; options@var602 =@expr1073746186 forDebug (@expr1073746187 ) ;
928: options@var602 .@expr1073746188 exprid@var603 =@expr1073746189 true ;
929: return options@var602 ;
930: }
931: static stringifyOptions forPrintOut ( ) {
932: stringifyOptions options@var604 ; options@var604 =@expr1073746190 forDebug (@expr1073746191 ) ;
933: options@var604 .@expr1073746192 exprid@var605 =@expr1073746193 true ;
934: options@var604 .@expr1073746194 varid@var606 =@expr1073746195 true ;
935: options@var604 .@expr1073746196 idtype@var607 =@expr1073746197 true ;
936: return options@var604 ;
937: }
938: } ;
939:
940: std :: string stringify ( const stringifyOptions & options@var608 ) const ;
941:
|
947:
948: std :: string stringify ( bool varid@var609 , bool attributes@var610 , bool macro@var611 ) const ;
949:
950: std :: string stringifyList ( const stringifyOptions & options@var612 , const std :: vector < std :: string > * fileNames@var613 = nullptr , const Token * end@var614 = nullptr ) const ;
951: std :: string stringifyList ( const Token * end@var615 , bool attributes@var616 = true ) const ;
952: std :: string stringifyList ( bool varid@var617 = false ) const ;
953:
|
964:
965: std :: string stringifyList ( bool varid@var618 , bool attributes@var619 , bool linenumbers@var620 , bool linebreaks@var621 , bool files@var622 , const std :: vector < std :: string > * fileNames@var623 = nullptr , const Token * end@var624 = nullptr ) const ;
966:
|
974:
975: void deleteThis ( ) ;
976:
|
981:
982: void link ( Token * linkToToken@var625 ) {
983: mLink@var669 =@expr1073746198 linkToToken@var625 ;
984: if (@expr1073746199 mStr@var666 ==@expr1073746200 "<" ||@expr1073746201 mStr@var666 ==@expr1073746202 ">" ) {
985: update_property_info (@expr1073746203 ) ; }
986: }
987:
|
996:
997: Token * link ( ) const {
998: return mLink@var669 ;
999: }
1000:
|
1004:
1005: void scope ( const Scope * s@var626 ) {
1006: mImpl@var672 .@expr1073746204 mScope@var712 =@expr1073746205 s@var626 ;
1007: }
1008:
|
1011:
1012: const Scope * scope ( ) const {
1013: return mImpl@var672 .@expr1073746206 mScope@var712 ;
1014: }
1015:
|
1019:
1020: void function ( const Function * f@var627 ) ;
1021:
|
1024:
1025: const Function * function ( ) const {
1026: return mTokType@var670 ==@expr1073746207 eFunction ||@expr1073746208 mTokType@var670 ==@expr1073746209 eLambda ?@expr1073746210 mImpl@var672 .@expr1073746211 mFunction@var713 :@expr1073746212 nullptr ;
1027: }
1028:
|
1032:
1033: void variable ( const Variable * v@var628 ) {
1034: mImpl@var672 .@expr1073746213 mVariable@var714 =@expr1073746214 v@var628 ;
1035: if (@expr1073746215 v@var628 ||@expr1073746216 mImpl@var672 .@expr1073746217 mVarId@var703 ) {
1036: tokType (@expr1073746218 eVariable ) ; }
1037: else { if (@expr1073746219 mTokType@var670 ==@expr1073746220 eVariable ) {
1038: tokType (@expr1073746221 eName ) ; } }
1039: }
1040:
|
1043:
1044: const Variable * variable ( ) const {
1045: return mTokType@var670 ==@expr1073746222 eVariable ?@expr1073746223 mImpl@var672 .@expr1073746224 mVariable@var714 :@expr1073746225 nullptr ;
1046: }
1047:
|
1051:
1052: void type ( const :: Type * t@var629 ) ;
1053:
|
1056:
1057: const :: Type * type ( ) const {
1058: return mTokType@var670 ==@expr1073746226 eType ?@expr1073746227 mImpl@var672 .@expr1073746228 mType@var715 :@expr1073746229 nullptr ;
1059: }
1060:
1061: static const :: Type * typeOf ( const Token * tok@var630 , const Token * * typeTok@var631 = nullptr ) ;
1062:
1063: static std :: pair < const Token * , const Token * > typeDecl ( const Token * tok@var632 ) ;
1064:
1065: static std :: string typeStr ( const Token * tok@var633 ) ;
1066:
|
1069:
1070: const Enumerator * enumerator ( ) const {
1071: return mTokType@var670 ==@expr1073746230 eEnumerator ?@expr1073746231 mImpl@var672 .@expr1073746232 mEnumerator@var716 :@expr1073746233 nullptr ;
1072: }
1073:
|
1077:
1078: void enumerator ( const Enumerator * e@var634 ) {
1079: mImpl@var672 .@expr1073746234 mEnumerator@var716 =@expr1073746235 e@var634 ;
1080: if (@expr1073746236 e@var634 ) {
1081: tokType (@expr1073746237 eEnumerator ) ; }
1082: else { if (@expr1073746238 mTokType@var670 ==@expr1073746239 eEnumerator ) {
1083: tokType (@expr1073746240 eName ) ; } }
1084: }
1085:
|
1088:
1089: static void createMutualLinks ( Token * begin@var635 , Token * end@var636 ) ;
1090:
|
1096:
1097: std :: string strValue ( ) const ;
1098:
|
1105:
1106: static void move ( Token * srcStart@var637 , Token * srcEnd@var638 , Token * newLocation@var639 ) ;
1107:
1108:
1109: int progressValue ( ) const {
1110: return mImpl@var672 .@expr1073746241 mProgressValue@var717 ;
1111: }
1112:
1113:
1114: static void assignProgressValues ( Token * tok@var640 ) ;
1115:
|
1120:
1121: Token * nextArgument ( ) const ;
1122:
|
1127:
1128: Token * nextArgumentBeforeCreateLinks2 ( ) const ;
1129:
|
1134:
1135: Token * nextTemplateArgument ( ) const ;
1136:
|
1141:
1142: const Token * findClosingBracket ( ) const ;
1143: Token * findClosingBracket ( ) ;
1144:
1145: const Token * findOpeningBracket ( ) const ;
1146: Token * findOpeningBracket ( ) ;
1147:
|
1150:
1151: const std :: string & originalName ( ) const {
1152: return mImpl@var672 .@expr4418 mOriginalName@var718 ?@expr1073746243 *@expr1073746244 mImpl@var672 .@expr4418 mOriginalName@var718 :@expr1073746246 emptyString@var1 ;
1153: }
1154:
1155: const std :: list < ValueFlow :: Value > & values ( ) const {
1156: return mImpl@var672 .@expr4423 mValues@var691 ?@expr1073746248 *@expr1073746249 mImpl@var672 .@expr4423 mValues@var691 :@expr1073746251 TokenImpl ::@expr1073746252 mEmptyValueList@var438 ;
1157: }
1158:
|
1161:
1162: template < typename T >
1163: void originalName ( T && name@var641 ) {
1164: if (@expr1073746253 !@expr1073746254 mImpl@var672 .@expr4431 mOriginalName@var718 ) {
1165: mImpl@var672 .@expr4431 mOriginalName@var718 =@expr1073746257 new std ::@expr1073746258 string (@expr1073746259 name@var641 ) ; }
1166: else {
1167: *@expr1073746260 mImpl@var672 .@expr4431 mOriginalName@var718 =@expr1073746262 name@var641 ; }
1168: }
1169:
1170: bool hasKnownIntValue ( ) const ;
1171: bool hasKnownValue ( ) const ;
1172: bool hasKnownValue ( ValueFlow :: Value :: ValueType t@var642 ) const ;
1173: bool hasKnownSymbolicValue ( const Token * tok@var643 ) const ;
1174:
1175: const ValueFlow :: Value * getKnownValue ( ValueFlow :: Value :: ValueType t@var644 ) const ;
1176: long long getKnownIntValue ( ) const {
1177: return mImpl@var672 .@expr1073746264 mValues@var691 .@expr1073746265 front (@expr1073746266 ) .@expr1073746267 intvalue@expr1073746263 ;
1178: }
1179:
1180: const ValueFlow :: Value * getValue ( const long long val@var645 ) const ;
1181:
1182: const ValueFlow :: Value * getMaxValue ( bool condition@var646 , long long path@var647 = 0 ) const ;
1183:
1184: const ValueFlow :: Value * getMovedValue ( ) const ;
1185:
1186: const ValueFlow :: Value * getValueLE ( const long long val@var648 , const Settings * settings@var649 ) const ;
1187: const ValueFlow :: Value * getValueGE ( const long long val@var650 , const Settings * settings@var651 ) const ;
1188:
1189: const ValueFlow :: Value * getInvalidValue ( const Token * ftok@var652 , int argnr@var653 , const Settings * settings@var654 ) const ;
1190:
1191: const ValueFlow :: Value * getContainerSizeValue ( const long long val@var655 ) const ;
1192:
1193: const Token * getValueTokenMaxStrLength ( ) const ;
1194: const Token * getValueTokenMinStrSize ( const Settings * settings@var656 ) const ;
1195:
1196:
1197: bool addValue ( const ValueFlow :: Value & value@var657 ) ;
1198:
1199: void removeValues ( std :: function < bool ( const ValueFlow :: Value & ) > pred@var658 ) {
1200: if (@expr1073746268 mImpl@var672 .@expr4445 mValues@var691 ) {
1201: mImpl@var672 .@expr4445 mValues@var691 .@expr1073746271 remove_if (@expr1073746272 pred@var658 ) ; }
1202: }
1203:
1204: int index ( ) const {
1205: return mImpl@var672 .@expr1073746273 mIndex@var719 ;
1206: }
1207:
1208: void assignIndexes ( ) ;
1209:
1210: private:
1211:
1212: void next ( Token * nextToken@var659 ) {
1213: mNext@var667 =@expr1073746274 nextToken@var659 ;
1214: }
1215: void previous ( Token * previousToken@var660 ) {
1216: mPrevious@var668 =@expr1073746275 previousToken@var660 ;
1217: }
1218:
1219:
1220: void takeData ( Token * fromToken@var661 ) ;
1221:
|
1226:
1227: static bool firstWordEquals ( const char * str@var662 , const char * word@var663 ) ;
1228:
|
1233:
1234: static const char * chrInFirstWord ( const char * str@var664 , char c@var665 ) ;
1235:
1236: std :: string mStr@var666 ;
1237:
1238: Token * mNext@var667 ;
1239: Token * mPrevious@var668 ;
1240: Token * mLink@var669 ;
1241:
1242: enum Anonymous1 : uint64_t {
1243: fIsUnsigned = ( 1 << 0 ) ,
1244: fIsSigned = ( 1 << 1 ) ,
1245: fIsPointerCompare = ( 1 << 2 ) ,
1246: fIsLong = ( 1 << 3 ) ,
1247: fIsStandardType = ( 1 << 4 ) ,
1248: fIsExpandedMacro = ( 1 << 5 ) ,
1249: fIsCast = ( 1 << 6 ) ,
1250: fIsAttributeConstructor = ( 1 << 7 ) ,
1251: fIsAttributeDestructor = ( 1 << 8 ) ,
1252: fIsAttributeUnused = ( 1 << 9 ) ,
1253: fIsAttributePure = ( 1 << 10 ) ,
1254: fIsAttributeConst = ( 1 << 11 ) ,
1255: fIsAttributeNoreturn = ( 1 << 12 ) ,
1256: fIsAttributeNothrow = ( 1 << 13 ) ,
1257: fIsAttributeUsed = ( 1 << 14 ) ,
1258: fIsAttributePacked = ( 1 << 15 ) ,
1259: fIsAttributeMaybeUnused = ( 1 << 16 ) ,
1260: fIsControlFlowKeyword = ( 1 << 17 ) ,
1261: fIsOperatorKeyword = ( 1 << 18 ) ,
1262: fIsComplex = ( 1 << 19 ) ,
1263: fIsEnumType = ( 1 << 20 ) ,
1264: fIsName = ( 1 << 21 ) ,
1265: fIsLiteral = ( 1 << 22 ) ,
1266: fIsTemplateArg = ( 1 << 23 ) ,
1267: fIsAttributeNodiscard = ( 1 << 24 ) ,
1268: fAtAddress = ( 1 << 25 ) ,
1269: fIncompleteVar = ( 1 << 26 ) ,
1270: fConstexpr = ( 1 << 27 ) ,
1271: fExternC = ( 1 << 28 ) ,
1272: fIsSplitVarDeclComma = ( 1 << 29 ) ,
1273: fIsSplitVarDeclEq = ( 1 << 30 ) ,
1274: fIsImplicitInt = ( 1U << 31 ) ,
1275: fIsInline = ( 1ULL << 32 ) ,
1276: fIsTemplate = ( 1ULL << 33 ) ,
1277: fIsSimplifedScope = ( 1ULL << 34 ) ,
1278: fIsRemovedVoidParameter = ( 1ULL << 35 ) ,
1279: fIsIncompleteConstant = ( 1ULL << 36 ) ,
1280: } ;
1281:
1282: Token :: Type mTokType@var670 ;
1283:
1284: uint64_t mFlags@var671 ;
1285:
1286: TokenImpl * mImpl@var672 ;
1287:
|
1292:
1293: bool getFlag ( uint64_t flag_@var673 ) const {
1294: return (@expr4452 (@expr4452 mFlags@var671 &@expr1073746278 flag_@var673 ) !=@expr1073746279 0 ) ;
1295: }
1296:
|
1301:
1302: void setFlag ( uint64_t flag_@var674 , bool state_@var675 ) {
1303: mFlags@var671 =@expr1073746280 state_@var675 ?@expr1073746281 mFlags@var671 |@expr1073746282 flag_@var674 :@expr1073746283 mFlags@var671 &@expr1073746284 ~@expr1073746285 flag_@var674 ;
1304: }
1305:
1306:
1307:
1308: void update_property_info ( ) ;
1309:
1310:
1311: void update_property_isStandardType ( ) ;
1312:
1313:
1314: void update_property_char_string_literal ( ) ;
1315:
1316:
1317: void astStringVerboseRecursive ( std :: string & ret@var676 , const int indent1@var677 = 0 , const int indent2@var678 = 0 ) const ;
1318:
1319: public:
1320: void astOperand1 ( Token * tok@var679 ) ;
1321: void astOperand2 ( Token * tok@var680 ) ;
1322: void astParent ( Token * tok@var681 ) ;
1323:
1324: Token * astOperand1 ( ) {
1325: return mImpl@var672 .@expr1073746286 mAstOperand1@var682 ;
1326: }
1327: const Token * astOperand1 ( ) const {
1328: return mImpl@var672 .@expr1073746287 mAstOperand1@var682 ;
1329: }
1330: Token * astOperand2 ( ) {
1331: return mImpl@var672 .@expr1073746288 mAstOperand2@var683 ;
1332: }
1333: const Token * astOperand2 ( ) const {
1334: return mImpl@var672 .@expr1073746289 mAstOperand2@var683 ;
1335: }
1336: Token * astParent ( ) {
1337: return mImpl@var672 .@expr1073746290 mAstParent@var684 ;
1338: }
1339: const Token * astParent ( ) const {
1340: return mImpl@var672 .@expr1073746291 mAstParent@var684 ;
1341: }
1342: Token * astSibling ( ) {
1343: if (@expr1073746292 !@expr1073746293 astParent (@expr4470 ) ) {
1344: return nullptr ; }
1345: if (@expr1073746295 this@expr4472 ==@expr1073746297 astParent (@expr4470 ) .@expr4475 astOperand1 (@expr4476 ) ) {
1346: return astParent (@expr4470 ) .@expr4478 astOperand2 (@expr4479 ) ; }
1347: else { if (@expr1073746304 this@expr4472 ==@expr1073746305 astParent (@expr4470 ) .@expr4478 astOperand2 (@expr4479 ) ) {
1348: return astParent (@expr4470 ) .@expr4475 astOperand1 (@expr4476 ) ; } }
1349: return nullptr ;
1350:
1351: }
1352: const Token * astSibling ( ) const {
1353: if (@expr1073746312 !@expr1073746313 astParent (@expr4490 ) ) {
1354: return nullptr ; }
1355: if (@expr1073746315 this@expr4492 ==@expr1073746317 astParent (@expr4490 ) .@expr4495 astOperand1 (@expr4496 ) ) {
1356: return astParent (@expr4490 ) .@expr4498 astOperand2 (@expr4499 ) ; }
1357: else { if (@expr1073746324 this@expr4492 ==@expr1073746325 astParent (@expr4490 ) .@expr4498 astOperand2 (@expr4499 ) ) {
1358: return astParent (@expr4490 ) .@expr4495 astOperand1 (@expr4496 ) ; } }
1359: return nullptr ;
1360:
1361: }
1362: Token * astTop ( ) {
1363: Token * ret@var685 ; ret@var685 =@expr1073746332 this@expr1073746333 ;
1364: while (@expr1073746334 ret@var685 .@expr4511 mImpl@var686 .@expr4512 mAstParent@var687 ) {
1365: ret@var685 =@expr1073746337 ret@var685 .@expr4511 mImpl@var686 .@expr4512 mAstParent@var687 ; }
1366: return ret@var685 ;
1367: }
1368:
1369: const Token * astTop ( ) const {
1370: const Token * ret@var688 ; ret@var688 =@expr1073746340 this@expr1073746341 ;
1371: while (@expr1073746342 ret@var688 .@expr4519 mImpl@var689 .@expr4520 mAstParent@var690 ) {
1372: ret@var688 =@expr1073746345 ret@var688 .@expr4519 mImpl@var689 .@expr4520 mAstParent@var690 ; }
1373: return ret@var688 ;
1374: }
1375:
1376: std :: pair < const Token * , const Token * > findExpressionStartEndTokens ( ) const ;
1377:
|
1384:
1385: bool isCalculation ( ) const ;
1386:
1387: void clearAst ( ) {
1388: mImpl@var672 .@expr1073746348 mAstOperand1@var682 =@expr1073746349 mImpl@var672 .@expr1073746350 mAstOperand2@var683 =@expr1073746351 mImpl@var672 .@expr1073746352 mAstParent@var684 =@expr1073746353 nullptr ;
1389: }
1390:
1391: void clearValueFlow ( ) {
1392: delete mImpl@var672 .@expr4530 mValues@var691 ;
1393: mImpl@var672 .@expr4530 mValues@var691 =@expr1073746356 nullptr ;
1394: }
1395:
1396: std :: string astString ( const char * sep@var692 = "" ) const {
1397: std ::@expr1073746357 string ret@var693 ;
1398: if (@expr1073746358 mImpl@var672 .@expr4535 mAstOperand1@var682 ) {
1399: ret@var693 =@expr1073746360 mImpl@var672 .@expr4535 mAstOperand1@var682 .@expr1073746362 astString (@expr1073746363 sep@var692 ) ; }
1400: if (@expr1073746364 mImpl@var672 .@expr4541 mAstOperand2@var683 ) {
1401: ret@var693 +=@expr1073746366 mImpl@var672 .@expr4541 mAstOperand2@var683 .@expr1073746368 astString (@expr1073746369 sep@var692 ) ; }
1402: return ret@var693 +@expr1073746370 sep@var692 +@expr1073746371 mStr@var666 ;
1403: }
1404:
1405: std :: string astStringVerbose ( ) const ;
1406:
1407: std :: string astStringZ3 ( ) const ;
1408:
1409: std :: string expressionString ( ) const ;
1410:
1411: void printAst ( bool verbose@var694 , bool xml@var695 , const std :: vector < std :: string > & fileNames@var696 , std :: ostream & out@var697 ) const ;
1412:
1413: void printValueFlow ( bool xml@var698 , std :: ostream & out@var699 ) const ;
1414:
1415: void scopeInfo ( std :: shared_ptr < ScopeInfo2 > newScopeInfo@var700 ) ;
1416: std :: shared_ptr < ScopeInfo2 > scopeInfo ( ) const ;
1417:
1418: void setCpp11init ( bool cpp11init@var701 ) const {
1419: mImpl@var672 .@expr1073746372 mCpp11init@var702 =@expr1073746373 cpp11init@var701 ?@expr1073746374 TokenImpl ::@expr4551 Cpp11init ::@expr1073746376 CPP11INIT :@expr1073746377 TokenImpl ::@expr4551 Cpp11init ::@expr1073746379 NOINIT ;
1420: }
1421: TokenImpl :: Cpp11init isCpp11init ( ) const {
1422: return mImpl@var672 .@expr1073746380 mCpp11init@var702 ;
1423: }
1424: } ;
1425:
1426: Token * findTypeEnd ( Token * tok@var720 ) ;
1427: const Token * findTypeEnd ( const Token * tok@var721 ) ;
1428: Token * findLambdaEndScope ( Token * tok@var722 ) ;
1429: const Token * findLambdaEndScope ( const Token * tok@var723 ) ;

##file cppcheck-2.8/lib/tokenlist.h

1:
|
31:
32: class Settings ;
33:
34: namespace simplecpp {
35: class TokenList ;
36: }
37:
|
40:
41: class TokenList {
42: public:
43: explicit TokenList ( const Settings * settings@var724 ) ;
44: ~ TokenList ( ) ;
45:
46: void setSettings ( const Settings * settings@var725 ) {
47: mSettings@var760 =@expr1073746381 settings@var725 ;
48: }
49:
50: const Settings * getSettings ( ) const {
51: return mSettings@var760 ;
52: }
53:
54:
55: const std :: string & getSourceFilePath ( ) const ;
56:
57:
58: bool isC ( ) const {
59: return mIsC@var762 ;
60: }
61:
62:
63: bool isCPP ( ) const {
64: return mIsCpp@var763 ;
65: }
66:
|
70:
71: static void deleteTokens ( Token * tok@var726 ) ;
72:
73: void addtoken ( const std :: string & str@var727 , const int lineno@var728 , const int column@var729 , const int fileno@var730 , bool split@var731 = false ) ;
74: void addtoken ( const std :: string & str@var732 , const Token * locationTok@var733 ) ;
75:
76: void addtoken ( const Token * tok@var734 , const int lineno@var735 , const int column@var736 , const int fileno@var737 ) ;
77: void addtoken ( const Token * tok@var738 , const Token * locationTok@var739 ) ;
78: void addtoken ( const Token * tok@var740 ) ;
79:
80: static void insertTokens ( Token * dest@var741 , const Token * src@var742 , int n@var743 ) ;
81:
|
89:
90: static Token * copyTokens ( Token * dest@var744 , const Token * first@var745 , const Token * last@var746 , bool one_line@var747 = true ) ;
91:
|
100:
101: bool createTokens ( std :: istream & code@var748 , const std :: string & file0@var749 = emptyString@var1 ) ;
102:
103: void createTokens ( simplecpp :: TokenList && tokenList@var750 ) ;
104:
105:
106: void deallocateTokens ( ) ;
107:
108:
109: int appendFileIfNew ( const std :: string & fileName@var751 ) ;
110:
111:
112: const Token * front ( ) const {
113: return mTokensFrontBack@var757 .@expr1073746382 front@var764 ;
114: }
115: Token * front ( ) {
116: return mTokensFrontBack@var757 .@expr1073746383 front@var764 ;
117: }
118:
119:
120: const Token * back ( ) const {
121: return mTokensFrontBack@var757 .@expr1073746384 back@var765 ;
122: }
123: Token * back ( ) {
124: return mTokensFrontBack@var757 .@expr1073746385 back@var765 ;
125: }
126:
|
131:
132: const std :: vector < std :: string > & getFiles ( ) const {
133: return mFiles@var758 ;
134: }
135:
136: std :: string getOrigFile ( const Token * tok@var752 ) const ;
137:
|
142:
143: const std :: string & file ( const Token * tok@var753 ) const ;
144:
|
149:
150: std :: string fileLine ( const Token * tok@var754 ) const ;
151:
|
155:
156: unsigned long long calculateChecksum ( ) const ;
157:
|
160:
161: void createAst ( ) const ;
162:
|
166:
167: void validateAst ( ) const ;
168:
|
174:
175: bool validateToken ( const Token * tok@var755 ) const ;
176:
|
181:
182: void simplifyPlatformTypes ( ) ;
183:
|
187:
188: void simplifyStdType ( ) ;
189:
190: void clangSetOrigFiles ( ) ;
191:
192: bool isKeyword ( const std :: string & str@var756 ) const ;
193:
194: private:
195:
196:
197: TokenList ( const TokenList & ) ;
198:
199:
200: TokenList & operator= ( const TokenList & ) ;
201:
202: void determineCppC ( ) ;
203:
204:
205: TokensFrontBack mTokensFrontBack@var757 ;
206:
207:
208: std :: vector < std :: string > mFiles@var758 ;
209:
210:
211: std :: vector < std :: string > mOrigFiles@var759 ;
212:
213:
214: const Settings * mSettings@var760 ;
215:
216: std :: unordered_set < std :: string > mKeywords@var761 ;
217:
218:
219: bool mIsC@var762 ;
220: bool mIsCpp@var763 ;
221: } ;

##file cppcheck-2.8/lib/tokenize.h

1:
|
35:
36: class Settings ;
37: class SymbolDatabase ;
38: class TimerResults ;
39: class Token ;
40: class TemplateSimplifier ;
41: class ErrorLogger ;
42: class Preprocessor ;
43:
44: namespace simplecpp {
45: class TokenList ;
46: }
47:
|
51:
52: class Tokenizer {
53:
54: friend class TestSimplifyTokens ;
55: friend class TestSimplifyTypedef ;
56: friend class TestSimplifyUsing ;
57: friend class TestTokenizer ;
58: friend class SymbolDatabase ;
59: friend class TestSimplifyTemplate ;
60: friend class TemplateSimplifier ;
61:
62:
63: class VariableMap {
64: private:
65: std :: map < std :: string , int > mVariableId@var766 ;
66: std :: stack < std :: list < std :: pair < std :: string , int > > > mScopeInfo@var767 ;
67: mutable int mVarId@var768 ;
68: public:
69: VariableMap ( ) ;
70: void enterScope ( ) ;
71: bool leaveScope ( ) ;
72: void addVariable ( const std :: string & varname@var769 ) ;
73: bool hasVariable ( const std :: string & varname@var770 ) const ;
74: std :: map < std :: string , int > :: const_iterator find ( const std :: string & varname@var771 ) const {
75: return mVariableId@var766 .@expr1073746386 find (@expr1073746387 varname@var771 ) ;
76: }
77: std :: map < std :: string , int > :: const_iterator end ( ) const {
78: return mVariableId@var766 .@expr1073746388 end (@expr1073746389 ) ;
79: }
80: const std :: map < std :: string , int > & map ( ) const {
81: return mVariableId@var766 ;
82: }
83: int * getVarId ( ) const {
84: return &@expr1073746390 mVarId@var768 ;
85: }
86: } ;
87:
88:
89: public:
90: Tokenizer ( ) ;
91: Tokenizer ( const Settings * settings@var772 , ErrorLogger * errorLogger@var773 ) ;
92: ~ Tokenizer ( ) ;
93:
94: void setTimerResults ( TimerResults * tr@var774 ) {
95: mTimerResults@var894 =@expr1073746391 tr@var774 ;
96: }
97:
98:
99: bool isC ( ) const {
100: return list@var872 .@expr1073746392 isC (@expr1073746393 ) ;
101: }
102:
103:
104: bool isCPP ( ) const {
105: return list@var872 .@expr1073746394 isCPP (@expr1073746395 ) ;
106: }
107:
|
113:
114: bool isScopeNoReturn ( const Token * endScopeToken@var775 , bool * unknown@var776 = nullptr ) const ;
115:
116: bool createTokens ( std :: istream & code@var777 , const std :: string & FileName@var778 ) ;
117: void createTokens ( simplecpp :: TokenList && tokenList@var779 ) ;
118:
119: bool simplifyTokens1 ( const std :: string & configuration@var780 ) ;
120:
|
140:
141: bool tokenize ( std :: istream & code@var781 ,
142: const char FileName@var782 [ ] ,
143: const std :: string & configuration@var783 = emptyString@var1 ) ;
144:
145:
146: void setVarId ( ) ;
147: void setVarIdPass1 ( ) ;
148: void setVarIdPass2 ( ) ;
149:
|
158:
159: bool simplifyTokenList1 ( const char FileName@var784 [ ] ) ;
160:
|
166:
167: bool simplifyTokenList2 ( ) ;
168:
|
173:
174: void simplifyHeadersAndUnusedTemplates ( ) ;
175:
|
178:
179: void removeExtraTemplateKeywords ( ) ;
180:
|
184:
185: void splitTemplateRightAngleBrackets ( bool check@var785 ) ;
186:
|
202:
203: static void eraseDeadCode ( Token * begin@var786 , const Token * end@var787 ) ;
204:
|
209:
210: int sizeOfType ( const Token * type@var788 ) const ;
211:
|
217:
218: bool isFunctionParameterPassedByValue ( const Token * fpar@var789 ) const ;
219:
220:
221:
222: void simplifyAssignmentInFunctionCall ( ) ;
223:
224:
225: void simplifyAssignmentBlock ( ) ;
226:
|
231:
232: bool simplifyCalculations ( ) ;
233:
|
238:
239: void simplifyOffsetPointerDereference ( ) ;
240:
|
244:
245: void simplifyOffsetPointerReference ( ) ;
246:
247:
248: void arraySize ( ) ;
249:
250:
251:
252: void simplifyLabelsCaseDefault ( ) ;
253:
254:
255:
256: void simplifyCaseRange ( ) ;
257:
258:
259: void removeMacrosInGlobalScope ( ) ;
260:
261: void addSemicolonAfterUnknownMacro ( ) ;
262:
263:
264: void removePragma ( ) ;
265:
|
269:
270: void removeMacroInClassDef ( ) ;
271:
272:
273: void removeMacroInVarDecl ( ) ;
274:
275:
276: void removeRedundantAssignment ( ) ;
277:
|
281:
282: void simplifyRealloc ( ) ;
283:
284:
285: void sizeofAddParentheses ( ) ;
286:
|
291:
292: bool simplifySizeof ( ) ;
293:
|
297:
298: void simplifyVarDecl ( const bool only_k_r_fpar@var790 ) ;
299: void simplifyVarDecl ( Token * tokBegin@var791 , const Token * const tokEnd@var792 , const bool only_k_r_fpar@var793 ) ;
300:
|
304:
305: void simplifyInitVar ( ) ;
306: static Token * initVar ( Token * tok@var794 ) ;
307:
|
313:
314: bool simplifyConstTernaryOp ( ) ;
315:
|
319:
320: void simplifyCompoundAssignment ( ) ;
321:
|
327:
328: void simplifyStaticConst ( ) ;
329:
|
335:
336: void simplifyIfAndWhileAssign ( ) ;
337:
|
341:
342: void simplifyVariableMultipleAssign ( ) ;
343:
|
350:
351: bool simplifyCAlternativeTokens ( ) ;
352:
|
358:
359: void simplifyComma ( ) ;
360:
|
363:
364: bool simplifyAddBraces ( ) ;
365:
|
371:
372: Token * simplifyAddBracesToCommand ( Token * tok@var795 ) ;
373:
|
379:
380: Token * simplifyAddBracesPair ( Token * tok@var796 , bool commandWithCondition@var797 ) ;
381:
382:
383: void simplifyUsingToTypedef ( ) ;
384:
|
392:
393: void simplifyTypedef ( ) ;
394:
395:
396:
397: bool isMemberFunction ( const Token * openParen@var798 ) const ;
398:
399:
400:
401: bool simplifyUsing ( ) ;
402:
|
405:
406: void simplifyCasts ( ) ;
407:
|
410:
411: void simplifyUndefinedSizeArray ( ) ;
412:
|
419:
420: bool simplifyKnownVariables ( ) ;
421:
|
425:
426: static bool simplifyKnownVariablesGetData ( int varid@var799 , Token * * _tok2@var800 , Token * * _tok3@var801 , std :: string & value@var802 , int & valueVarId@var803 , bool & valueIsPointer@var804 , bool floatvar@var805 ) ;
427:
|
431:
432: bool simplifyKnownVariablesSimplify ( Token * * tok2@var806 , Token * tok3@var807 , int varid@var808 , const std :: string & structname@var809 , std :: string & value@var810 , int valueVarId@var811 , bool valueIsPointer@var812 , const Token * const valueToken@var813 , int indentlevel@var814 ) const ;
433:
434:
435: void simplifyEmptyNamespaces ( ) ;
436:
|
439:
440: void simplifyFlowControl ( ) ;
441:
442:
443: void simplifyNestedStrcat ( ) ;
444:
445:
446: void elseif ( ) ;
447:
448:
449: void simplifyIfSwitchForInit ( ) ;
450:
|
454:
455: bool simplifyConditions ( ) ;
456:
|
461:
462: bool removeRedundantConditions ( ) ;
463:
|
467:
468: void removeRedundantFor ( ) ;
469:
|
473:
474: void removeRedundantSemicolons ( ) ;
475:
|
479:
480: bool simplifyFunctionReturn ( ) ;
481:
|
485:
486: void simplifyStructDecl ( ) ;
487:
|
496:
497: bool simplifyRedundantParentheses ( ) ;
498:
499: void simplifyCharAt ( ) ;
500:
501:
502: void simplifyReference ( ) ;
503:
|
507:
508: void simplifyFunctionParameters ( ) ;
509:
|
513:
514: void simplifyFunctionTryCatch ( ) ;
515:
|
518:
519: void simplifyTemplates ( ) ;
520:
521: void simplifyDoublePlusAndDoubleMinus ( ) ;
522:
523: void simplifyRedundantConsecutiveBraces ( ) ;
524:
525: void simplifyArrayAccessSyntax ( ) ;
526:
527: void simplifyParameterVoid ( ) ;
528:
529: void fillTypeSizes ( ) ;
530:
531: void combineOperators ( ) ;
532:
533: void combineStringAndCharLiterals ( ) ;
534:
535: void concatenateNegativeNumberAndAnyPositive ( ) ;
536:
537: void simplifyExternC ( ) ;
538:
539: void simplifyRoundCurlyParentheses ( ) ;
540:
541: void simplifyTypeIntrinsics ( ) ;
542:
543: void simplifySQL ( ) ;
544:
545: void checkForEnumsWithTypedef ( ) ;
546:
547: void findComplicatedSyntaxErrorsInTemplates ( ) ;
548:
|
551:
552: void simplifyMathFunctions ( ) ;
553:
|
556:
557: void simplifyMathExpressions ( ) ;
558:
|
564:
565: static std :: string simplifyString ( const std :: string & source@var815 ) ;
566:
|
572:
573: const Token * isFunctionHead ( const Token * tok@var816 , const std :: string & endsWith@var817 ) const ;
574:
|
581:
582: static const Token * isFunctionHead ( const Token * tok@var818 , const std :: string & endsWith@var819 , bool cpp@var820 ) ;
583:
584: void setPreprocessor ( const Preprocessor * preprocessor@var821 ) {
585: mPreprocessor@var895 =@expr1073746396 preprocessor@var821 ;
586: }
587: const Preprocessor * getPreprocessor ( ) const {
588: return mPreprocessor@var895 ;
589: }
590:
591: bool hasIfdef ( const Token * start@var822 , const Token * end@var823 ) const ;
592:
593: private:
594:
|
597:
598: void simplifyWhile0 ( ) ;
599:
|
602:
603: void simplifyErrNoInWhile ( ) ;
604:
|
607:
608: void simplifyFuncInWhile ( ) ;
609:
|
612:
613: void simplifyStd ( ) ;
614:
615:
616: void simplifyPointerToStandardType ( ) ;
617:
618:
619: void simplifyFunctionPointers ( ) ;
620:
|
624:
625: void cppcheckError ( const Token * tok@var824 ) const ;
626:
|
629:
630: void createLinks ( ) ;
631:
|
634:
635: void createLinks2 ( ) ;
636:
637: public:
638:
639:
640: void syntaxError ( const Token * tok@var825 , const std :: string & code@var826 = "" ) const ;
641:
642:
643: void unmatchedToken ( const Token * tok@var827 ) const ;
644:
645:
646: void syntaxErrorC ( const Token * tok@var828 , const std :: string & what@var829 ) const ;
647:
648:
649: void unknownMacroError ( const Token * tok1@var830 ) const ;
650:
651: void unhandledCharLiteral ( const Token * tok@var831 , const std :: string & msg@var832 ) const ;
652:
653: private:
654:
655:
656: void unhandled_macro_class_x_y ( const Token * tok@var833 ) const ;
657:
658:
659: void checkConfiguration ( ) const ;
660: void macroWithSemicolonError ( const Token * tok@var834 , const std :: string & macroName@var835 ) const ;
661:
|
664:
665: void validateC ( ) const ;
666:
|
670:
671: void validate ( ) const ;
672:
673:
674: void reportUnknownMacros ( ) const ;
675:
676:
677: void findGarbageCode ( ) const ;
678:
679:
680: static bool isGarbageExpr ( const Token * start@var836 , const Token * end@var837 , bool allowSemicolon@var838 ) ;
681:
|
684:
685: void simplifyDeclspec ( ) ;
686:
|
689:
690: void simplifyCallingConvention ( ) ;
691:
|
694:
695: void simplifyAttribute ( ) ;
696:
|
699:
700: void simplifyCppcheckAttribute ( ) ;
701:
702:
703: void removeAlignas ( ) ;
704:
705:
706: void simplifySpaceshipOperator ( ) ;
707:
|
710:
711: void simplifyKeyword ( ) ;
712:
|
715:
716: void simplifyAsm ( ) ;
717:
|
720:
721: void simplifyAsm2 ( ) ;
722:
|
725:
726: void simplifyAt ( ) ;
727:
|
730:
731: void simplifyBitfields ( ) ;
732:
|
735:
736: void removeUnnecessaryQualification ( ) ;
737:
|
740:
741: void simplifyNamespaceStd ( ) ;
742:
|
749:
750: void simplifyMicrosoftMemoryFunctions ( ) ;
751:
|
755:
756: void simplifyMicrosoftStringFunctions ( ) ;
757:
|
760:
761: void simplifyBorland ( ) ;
762:
|
765:
766: void simplifyQtSignalsSlots ( ) ;
767:
|
771:
772: void simplifyOperatorName ( ) ;
773:
774:
775: void simplifyOverloadedOperators ( ) ;
776:
|
779:
780: void simplifyCPPAttribute ( ) ;
781:
|
785:
786: bool simplifyStrlen ( ) ;
787:
|
790:
791: void simplifyNamespaceAliases ( ) ;
792:
|
795:
796: void simplifyNestedNamespace ( ) ;
797:
|
802:
803: void simplifyCoroutines ( ) ;
804:
|
807:
808: void prepareTernaryOpForAST ( ) ;
809:
|
812:
813: void reportError ( const Token * tok@var839 , const Severity :: SeverityType severity@var840 , const std :: string & id@var841 , const std :: string & msg@var842 , bool inconclusive@var843 = false ) const ;
814: void reportError ( const std :: list < const Token * > & callstack@var844 , Severity :: SeverityType severity@var845 , const std :: string & id@var846 , const std :: string & msg@var847 , bool inconclusive@var848 = false ) const ;
815:
816: bool duplicateTypedef ( Token * * tokPtr@var849 , const Token * name@var850 , const Token * typeDef@var851 ) const ;
817:
818: void unsupportedTypedef ( const Token * tok@var852 ) const ;
819:
820: void setVarIdClassDeclaration ( const Token * const startToken@var853 ,
821: const VariableMap & variableMap@var854 ,
822: const int scopeStartVarId@var855 ,
823: std :: map < int , std :: map < std :: string , int > > & structMembers@var856 ) ;
824:
825: void setVarIdStructMembers ( Token * * tok1@var857 ,
826: std :: map < int , std :: map < std :: string , int > > & structMembers@var858 ,
827: int * varId@var859 ) const ;
828:
829: void setVarIdClassFunction ( const std :: string & classname@var860 ,
830: Token * const startToken@var861 ,
831: const Token * const endToken@var862 ,
832: const std :: map < std :: string , int > & varlist@var863 ,
833: std :: map < int , std :: map < std :: string , int > > & structMembers@var864 ,
834: int * varId_@var865 ) ;
835:
|
839:
840: void simplifyReturnStrncat ( ) ;
841:
|
844:
845: void printUnknownTypes ( ) const ;
846:
847:
848: static const Token * findSQLBlockEnd ( const Token * tokSQLStart@var866 ) ;
849:
850: bool operatorEnd ( const Token * tok@var867 ) const ;
851:
852: public:
853:
854:
855: bool codeWithTemplates ( ) const {
856: return mCodeWithTemplates@var893 ;
857: }
858:
859:
860: void setSettings ( const Settings * settings@var868 ) {
861: mSettings@var879 =@expr1073746397 settings@var868 ;
862: list@var872 .@expr1073746398 setSettings (@expr1073746399 settings@var868 ) ;
863: }
864:
865: const SymbolDatabase * getSymbolDatabase ( ) const {
866: return mSymbolDatabase@var881 ;
867: }
868: void createSymbolDatabase ( ) ;
869: void deleteSymbolDatabase ( ) ;
870:
|
875:
876: void printDebugOutput ( int simplification@var869 ) const ;
877:
878: void dump ( std :: ostream & out@var870 ) const ;
879:
880: Token * deleteInvalidTypedef ( Token * typeDef@var871 ) ;
881:
|
885:
886: int varIdCount ( ) const {
887: return mVarId@var891 ;
888: }
889:
|
892:
893: TokenList list@var872 ;
894:
895: const Token * tokens ( ) const {
896: return list@var872 .@expr1073746400 front (@expr1073746401 ) ;
897: }
898:
|
903:
904: static bool isZeroNumber ( const std :: string & s@var873 ) ;
905:
|
910:
911: static bool isOneNumber ( const std :: string & s@var874 ) ;
912:
|
917:
918: static bool isTwoNumber ( const std :: string & s@var875 ) ;
919:
|
925:
926: static const Token * startOfExecutableScope ( const Token * tok@var876 ) ;
927:
|
931:
932: static bool isMaxTime ( ) {
933: return false ;
934:
935: }
936:
937: const Settings * getSettings ( ) const {
938: return mSettings@var879 ;
939: }
940:
941: void calculateScopes ( ) ;
942:
943:
944: Tokenizer ( const Tokenizer & ) = delete ;
945:
946:
947: Tokenizer & operator= ( const Tokenizer & ) = delete ;
948:
949: private:
950: Token * processFunc ( Token * tok2@var877 , bool inOperator@var878 ) const ;
951:
|
955:
956: int newVarId ( ) {
957: return ++@expr1073746402 mVarId@var891 ;
958: }
959:
960:
961: void setPodTypes ( ) ;
962:
963:
964: const Settings * mSettings@var879 ;
965:
966:
967: ErrorLogger * const mErrorLogger@var880 ;
968:
969:
970: SymbolDatabase * mSymbolDatabase@var881 ;
971:
972: TemplateSimplifier * mTemplateSimplifier@var882 ;
973:
974:
975:
976: std :: string mConfiguration@var883 ;
977:
978:
979: std :: map < std :: string , int > mTypeSize@var884 ;
980:
981: struct TypedefInfo {
982: std :: string name@var885 ;
983: std :: string filename@var886 ;
984: int lineNumber@var887 ;
985: int column@var888 ;
986: bool used@var889 ;
987: } ;
988: std :: vector < TypedefInfo > mTypedefInfo@var890 ;
989:
990:
991: int mVarId@var891 ;
992:
993:
994: int mUnnamedCount@var892 ;
995:
|
999:
1000: bool mCodeWithTemplates@var893 ;
1001:
|
1004:
1005: TimerResults * mTimerResults@var894 ;
1006:
|
1011:
1012: const Preprocessor * mPreprocessor@var895 ;
1013: } ;

##file cppcheck-2.8/lib/check.h

1:
|
29:
30: namespace tinyxml2 {
31: class XMLElement ;
32: }
33:
34: namespace CTU {
35: class FileInfo ;
36: }
37:
38: namespace ValueFlow {
39: class Value ;
40: }
41:
42: class Settings ;
43: class Token ;
44: class ErrorLogger ;
45: class ErrorMessage ;
46: class Tokenizer ;
47:
|
57:
58: class Check {
59: public:
60:
61: explicit Check ( const std :: string & aname@var896 ) ;
62:
63:
64: Check ( const std :: string & aname@var897 , const Tokenizer * tokenizer@var898 , const Settings * settings@var899 , ErrorLogger * errorLogger@var900 )
65: : mTokenizer@var911 ( tokenizer@var898 ) , mSettings@var912 ( settings@var899 ) , mErrorLogger@var913 ( errorLogger@var900 ) , mName@var946 ( aname@var897 ) { }
66:
67: virtual ~ Check ( ) {
68: if (@expr1073746403 !@expr1073746404 mTokenizer@var911 ) {
69: instances (@expr1073746405 ) .@expr1073746406 remove (@expr1073746407 this@expr1073746408 ) ; }
70: }
71:
72:
73: static std :: list < Check * > & instances ( ) ;
74:
75:
76: virtual void runChecks ( const Tokenizer * , const Settings * , ErrorLogger * ) = 0 ;
77:
78:
79: virtual void getErrorMessages ( ErrorLogger * errorLogger@var901 , const Settings * settings@var902 ) const = 0 ;
80:
81:
82: const std :: string & name ( ) const {
83: return mName@var946 ;
84: }
85:
86:
87: virtual std :: string classInfo ( ) const = 0 ;
88:
|
93:
94: static void reportError ( const ErrorMessage & errmsg@var903 ) ;
95:
96:
97: class FileInfo {
98: public:
99: FileInfo ( ) { }
100: virtual ~ FileInfo ( ) { }
101: virtual std :: string toString ( ) const {
102: return std ::@expr1073746409 string (@expr1073746410 ) ;
103: }
104: } ;
105:
106: virtual FileInfo * getFileInfo ( const Tokenizer * tokenizer@var904 , const Settings * settings@var905 ) const {
107: (@expr1073746411 void ) tokenizer@var904 ;
108: (@expr1073746412 void ) settings@var905 ;
109: return nullptr ;
110: }
111:
112: virtual FileInfo * loadFileInfoFromXml ( const tinyxml2 :: XMLElement * xmlElement@var906 ) const {
113: (@expr1073746413 void ) xmlElement@var906 ;
114: return nullptr ;
115: }
116:
117:
118: virtual bool analyseWholeProgram ( const CTU :: FileInfo * ctu@var907 , const std :: list < FileInfo * > & fileInfo@var908 , const Settings & , ErrorLogger & ) {
119: (@expr1073746414 void ) ctu@var907 ;
120: (@expr1073746415 void ) fileInfo@var908 ;
121:
122:
123: return false ;
124: }
125:
126: static std :: string getMessageId ( const ValueFlow :: Value & value@var909 , const char id@var910 [ ] ) ;
127:
128: protected:
129: const Tokenizer * const mTokenizer@var911 ;
130: const Settings * const mSettings@var912 ;
131: ErrorLogger * const mErrorLogger@var913 ;
132:
133:
134: void reportError ( const Token * tok@var914 , const Severity :: SeverityType severity@var915 , const std :: string & id@var916 , const std :: string & msg@var917 ) {
135: reportError (@expr1073746416 tok@var914 , severity@var915 , id@var916 , msg@var917 , CWE (@expr1073746417 0U ) , Certainty ::@expr1073746418 normal ) ;
136: }
137:
138:
139: void reportError ( const Token * tok@var918 , const Severity :: SeverityType severity@var919 , const std :: string & id@var920 , const std :: string & msg@var921 , const CWE & cwe@var922 , Certainty :: CertaintyLevel certainty@var923 ) {
140: const std ::@expr1073746419 list < const Token *@expr1073746420 > callstack@var924 (@expr1073746421 1 , tok@var918 ) ;
141: reportError (@expr1073746422 callstack@var924 , severity@var919 , id@var920 , msg@var921 , cwe@var922 , certainty@var923 ) ;
142: }
143:
144:
145: void reportError ( const std :: list < const Token * > & callstack@var925 , Severity :: SeverityType severity@var926 , const std :: string & id@var927 , const std :: string & msg@var928 ) {
146: reportError (@expr1073746423 callstack@var925 , severity@var926 , id@var927 , msg@var928 , CWE (@expr1073746424 0U ) , Certainty ::@expr1073746425 normal ) ;
147: }
148:
149:
150: void reportError ( const std :: list < const Token * > & callstack@var929 , Severity :: SeverityType severity@var930 , const std :: string & id@var931 , const std :: string & msg@var932 , const CWE & cwe@var933 , Certainty :: CertaintyLevel certainty@var934 ) ;
151:
152: void reportError ( const std :: list < std :: pair < const Token * , std :: string > > & errorPath@var935 , Severity :: SeverityType severity@var936 , const char id@var937 [ ] , const std :: string & msg@var938 , const CWE & cwe@var939 , Certainty :: CertaintyLevel certainty@var940 ) ;
153:
154: std :: list < std :: pair < const Token * , std :: string > > getErrorPath ( const Token * errtok@var941 , const ValueFlow :: Value * value@var942 , const std :: string & bug@var943 ) const ;
155:
|
159:
160: bool wrongData ( const Token * tok@var944 , const char * str@var945 ) ;
161:
162:
163: void operator= ( const Check & ) = delete ;
164: Check ( const Check & ) = delete ;
165: private:
166: const std :: string mName@var946 ;
167: } ;

##file cppcheck-2.8/lib/suppressions.h

1:
|
34:
35: class Tokenizer ;
36:
37:
38: class Suppressions {
39: public:
40:
41: struct ErrorMessage {
42: unsigned long hash@var947 ;
43: std :: string errorId@var948 ;
44: void setFileName ( const std :: string & s@var949 ) ;
45: const std :: string & getFileName ( ) const {
46: return mFileName@var953 ;
47: }
48: int lineNumber@var950 ;
49: Certainty :: CertaintyLevel certainty@var951 ;
50: std :: string symbolNames@var952 ;
51: private:
52: std :: string mFileName@var953 ;
53: } ;
54:
55: struct Suppression {
56: Suppression ( ) : lineNumber@var987 ( NO_LINE ) , hash@var989 ( 0 ) , thisAndNextLine@var990 ( false ) , matched@var991 ( false ) , checked@var992 ( false ) { }
57: Suppression ( const Suppression & other@var954 ) {
58: *@expr1073746426 this@expr1073746427 =@expr1073746428 other@var954 ;
59: }
60: Suppression ( const std :: string & id@var955 , const std :: string & file@var956 , int line@var957 = NO_LINE ) : errorId@var985 ( id@var955 ) , fileName@var986 ( file@var956 ) , lineNumber@var987 ( line@var957 ) , hash@var989 ( 0 ) , thisAndNextLine@var990 ( false ) , matched@var991 ( false ) , checked@var992 ( false ) { }
61:
62: Suppression & operator= ( const Suppression & other@var958 ) {
63: errorId@var985 =@expr1073746429 other@var958 .@expr1073746430 errorId@var959 ;
64: fileName@var986 =@expr1073746431 other@var958 .@expr1073746432 fileName@var960 ;
65: lineNumber@var987 =@expr1073746433 other@var958 .@expr1073746434 lineNumber@var961 ;
66: symbolName@var988 =@expr1073746435 other@var958 .@expr1073746436 symbolName@var962 ;
67: hash@var989 =@expr1073746437 other@var958 .@expr1073746438 hash@var963 ;
68: thisAndNextLine@var990 =@expr1073746439 other@var958 .@expr1073746440 thisAndNextLine@var964 ;
69: matched@var991 =@expr1073746441 other@var958 .@expr1073746442 matched@var965 ;
70: checked@var992 =@expr1073746443 other@var958 .@expr1073746444 checked@var966 ;
71: return *@expr1073746445 this@expr1073746446 ;
72: }
73:
74: bool operator< ( const Suppression & other@var967 ) const {
75: if (@expr1073746447 errorId@var985 !=@expr1073746448 other@var967 .@expr4625 errorId@var968 ) {
76: return errorId@var985 <@expr1073746450 other@var967 .@expr4625 errorId@var968 ; }
77: if (@expr1073746452 lineNumber@var987 <@expr1073746453 other@var967 .@expr1073746454 lineNumber@var969 ) {
78: return true ; }
79: if (@expr1073746455 fileName@var986 !=@expr1073746456 other@var967 .@expr4633 fileName@var970 ) {
80: return fileName@var986 <@expr1073746458 other@var967 .@expr4633 fileName@var970 ; }
81: if (@expr1073746460 symbolName@var988 !=@expr1073746461 other@var967 .@expr4638 symbolName@var971 ) {
82: return symbolName@var988 <@expr1073746463 other@var967 .@expr4638 symbolName@var971 ; }
83: if (@expr1073746465 hash@var989 !=@expr1073746466 other@var967 .@expr4643 hash@var972 ) {
84: return hash@var989 <@expr1073746468 other@var967 .@expr4643 hash@var972 ; }
85: if (@expr1073746470 thisAndNextLine@var990 !=@expr1073746471 other@var967 .@expr1073746472 thisAndNextLine@var973 ) {
86: return thisAndNextLine@var990 ; }
87: return false ;
88: }
89:
|
95:
96: bool parseComment ( std :: string comment@var974 , std :: string * errorMessage@var975 ) ;
97:
98: bool isSuppressed ( const ErrorMessage & errmsg@var976 ) const ;
99:
100: bool isMatch ( const ErrorMessage & errmsg@var977 ) ;
101:
102: std :: string getText ( ) const ;
103:
104: bool isLocal ( ) const {
105: return !@expr1073746474 fileName@var986 .@expr1073746475 empty (@expr1073746476 ) &&@expr1073746477 fileName@var986 .@expr1073746478 find_first_of (@expr1073746479 "?*" ) ==@expr1073746480 std ::@expr1073746481 string ::@expr1073746482 npos@expr1073746473 ;
106: }
107:
108: bool isSameParameters ( const Suppression & other@var978 ) const {
109: return errorId@var985 ==@expr1073746483 other@var978 .@expr1073746484 errorId@var979 &&@expr1073746485
110: fileName@var986 ==@expr1073746486 other@var978 .@expr1073746487 fileName@var980 &&@expr1073746488
111: lineNumber@var987 ==@expr1073746489 other@var978 .@expr1073746490 lineNumber@var981 &&@expr1073746491
112: symbolName@var988 ==@expr1073746492 other@var978 .@expr1073746493 symbolName@var982 &&@expr1073746494
113: hash@var989 ==@expr1073746495 other@var978 .@expr1073746496 hash@var983 &&@expr1073746497
114: thisAndNextLine@var990 ==@expr1073746498 other@var978 .@expr1073746499 thisAndNextLine@var984 ;
115: }
116:
117: std :: string errorId@var985 ;
118: std :: string fileName@var986 ;
119: int lineNumber@var987 ;
120: std :: string symbolName@var988 ;
121: unsigned long hash@var989 ;
122: bool thisAndNextLine@var990 ;
123: bool matched@var991 ;
124: bool checked@var992 ;
125:
126: enum Anonymous2 { NO_LINE = -1 } ;
127: } ;
128:
|
133:
134: std :: string parseFile ( std :: istream & istr@var993 ) ;
135:
|
140:
141: std :: string parseXmlFile ( const char * filename@var994 ) ;
142:
|
148:
149: static std :: vector < Suppression > parseMultiSuppressComment ( const std :: string & comment@var995 , std :: string * errorMessage@var996 ) ;
150:
|
155:
156: std :: string addSuppressionLine ( const std :: string & line@var997 ) ;
157:
|
163:
164: std :: string addSuppression ( const Suppression & suppression@var998 ) ;
165:
|
170:
171: std :: string addSuppressions ( const std :: list < Suppression > & suppressions@var999 ) ;
172:
|
177:
178: bool isSuppressed ( const ErrorMessage & errmsg@var1000 ) ;
179:
|
184:
185: bool isSuppressedLocal ( const ErrorMessage & errmsg@var1001 ) ;
186:
|
190:
191: void dump ( std :: ostream & out@var1002 ) const ;
192:
|
196:
197: std :: list < Suppression > getUnmatchedLocalSuppressions ( const std :: string & file@var1003 , const bool unusedFunctionChecking@var1004 ) const ;
198:
|
202:
203: std :: list < Suppression > getUnmatchedGlobalSuppressions ( const bool unusedFunctionChecking@var1005 ) const ;
204:
|
208:
209: const std :: list < Suppression > & getSuppressions ( ) const ;
210:
|
213:
214: void markUnmatchedInlineSuppressionsAsChecked ( const Tokenizer & tokenizer@var1006 ) ;
215:
216: private:
217:
218: std :: list < Suppression > mSuppressions@var1007 ;
219: } ;

##file cppcheck-2.8/lib/color.h

1:
|
26:
27: enum class Color {
28: Reset = 0 ,
29: Bold = 1 ,
30: Dim = 2 ,
31: FgRed = 31 ,
32: FgGreen = 32 ,
33: FgBlue = 34 ,
34: FgMagenta = 35 ,
35: FgDefault = 39 ,
36: BgRed = 41 ,
37: BgGreen = 42 ,
38: BgBlue = 44 ,
39: BgDefault = 49
40: } ;
41: std :: ostream & operator<< ( std :: ostream & os@var1008 , const Color & c@var1009 ) ;
42:
43: std :: string toString ( const Color & c@var1010 ) ;

##file cppcheck-2.8/lib/errorlogger.h

1:
|
39:
40: static const struct CWE CWE_USE_OF_UNINITIALIZED_VARIABLE@var1011 ( 457U ) ;
41: static const struct CWE CWE_NULL_POINTER_DEREFERENCE@var1012 ( 476U ) ;
42: static const struct CWE CWE_USE_OF_POTENTIALLY_DANGEROUS_FUNCTION@var1013 ( 676U ) ;
43: static const struct CWE CWE_INCORRECT_CALCULATION@var1014 ( 682U ) ;
44: static const struct CWE CWE_EXPIRED_POINTER_DEREFERENCE@var1015 ( 825U ) ;
45:
46:
47: class Token ;
48: class TokenList ;
49:
50: namespace tinyxml2 {
51: class XMLElement ;
52: }
53:
|
59:
60: class ErrorMessage {
61: public:
62:
|
66:
67: class FileLocation {
68: public:
69: FileLocation ( )
70: : fileIndex@var1031 ( 0 ) , line@var1032 ( 0 ) , column@var1033 ( 0 ) { }
71:
72: FileLocation ( const std :: string & file@var1016 , int line@var1017 , unsigned int column@var1018 )
73: : fileIndex@var1031 ( 0 ) , line@var1032 ( line@var1017 ) , column@var1033 ( column@var1018 ) , mOrigFileName@var1035 ( file@var1016 ) , mFileName@var1036 ( file@var1016 ) { }
74:
75: FileLocation ( const std :: string & file@var1019 , const std :: string & info@var1020 , int line@var1021 , unsigned int column@var1022 )
76: : fileIndex@var1031 ( 0 ) , line@var1032 ( line@var1021 ) , column@var1033 ( column@var1022 ) , mOrigFileName@var1035 ( file@var1019 ) , mFileName@var1036 ( file@var1019 ) , mInfo@var1037 ( info@var1020 ) { }
77:
78: FileLocation ( const Token * tok@var1023 , const TokenList * tokenList@var1024 ) ;
79: FileLocation ( const Token * tok@var1025 , const std :: string & info@var1026 , const TokenList * tokenList@var1027 ) ;
80:
|
85:
86: std :: string getfile ( bool convert@var1028 = true ) const ;
87:
|
92:
93: std :: string getOrigFile ( bool convert@var1029 = true ) const ;
94:
|
98:
99: void setfile ( const std :: string & file@var1030 ) ;
100:
|
103:
104: std :: string stringify ( ) const ;
105:
106: unsigned int fileIndex@var1031 ;
107: int line@var1032 ;
108: unsigned int column@var1033 ;
109:
110: std :: string getinfo ( ) const {
111: return mInfo@var1037 ;
112: }
113: void setinfo ( const std :: string & i@var1034 ) {
114: mInfo@var1037 =@expr1073746500 i@var1034 ;
115: }
116:
117: private:
118: std :: string mOrigFileName@var1035 ;
119: std :: string mFileName@var1036 ;
120: std :: string mInfo@var1037 ;
121: } ;
122:
123: ErrorMessage ( const std :: list < FileLocation > & callStack@var1038 ,
124: const std :: string & file1@var1039 ,
125: Severity :: SeverityType severity@var1040 ,
126: const std :: string & msg@var1041 ,
127: const std :: string & id@var1042 , Certainty :: CertaintyLevel certainty@var1043 ) ;
128: ErrorMessage ( const std :: list < FileLocation > & callStack@var1044 ,
129: const std :: string & file1@var1045 ,
130: Severity :: SeverityType severity@var1046 ,
131: const std :: string & msg@var1047 ,
132: const std :: string & id@var1048 ,
133: const CWE & cwe@var1049 ,
134: Certainty :: CertaintyLevel certainty@var1050 ) ;
135: ErrorMessage ( const std :: list < const Token * > & callstack@var1051 ,
136: const TokenList * list@var1052 ,
137: Severity :: SeverityType severity@var1053 ,
138: const std :: string & id@var1054 ,
139: const std :: string & msg@var1055 ,
140: Certainty :: CertaintyLevel certainty@var1056 ) ;
141: ErrorMessage ( const std :: list < const Token * > & callstack@var1057 ,
142: const TokenList * list@var1058 ,
143: Severity :: SeverityType severity@var1059 ,
144: const std :: string & id@var1060 ,
145: const std :: string & msg@var1061 ,
146: const CWE & cwe@var1062 ,
147: Certainty :: CertaintyLevel certainty@var1063 ) ;
148: ErrorMessage ( const std :: list < std :: pair < const Token * , std :: string > > & errorPath@var1064 ,
149: const TokenList * tokenList@var1065 ,
150: Severity :: SeverityType severity@var1066 ,
151: const char id@var1067 [ ] ,
152: const std :: string & msg@var1068 ,
153: const CWE & cwe@var1069 ,
154: Certainty :: CertaintyLevel certainty@var1070 ) ;
155: ErrorMessage ( ) ;
156: explicit ErrorMessage ( const tinyxml2 :: XMLElement * const errmsg@var1071 ) ;
157:
|
160:
161: std :: string toXML ( ) const ;
162:
163: static std :: string getXMLHeader ( ) ;
164: static std :: string getXMLFooter ( ) ;
165:
|
174:
175: std :: string toString ( bool verbose@var1072 ,
176: const std :: string & templateFormat@var1073 = emptyString@var1 ,
177: const std :: string & templateLocation@var1074 = emptyString@var1 ) const ;
178:
179: std :: string serialize ( ) const ;
180: bool deserialize ( const std :: string & data@var1075 ) ;
181:
182: std :: list < FileLocation > callStack@var1076 ;
183: std :: string id@var1077 ;
184:
185:
186: std :: string file0@var1078 ;
187:
188: std :: string function@var1079 ;
189:
190: bool incomplete@var1080 ;
191:
192: Severity :: SeverityType severity@var1081 ;
193: CWE cwe@var1082 ;
194: Certainty :: CertaintyLevel certainty@var1083 ;
195:
196:
197: unsigned long hash@var1084 ;
198:
199:
200: void setmsg ( const std :: string & msg@var1085 ) ;
201:
202:
203: const std :: string & shortMessage ( ) const {
204: return mShortMessage@var1087 ;
205: }
206:
207:
208: const std :: string & verboseMessage ( ) const {
209: return mVerboseMessage@var1088 ;
210: }
211:
212:
213: const std :: string & symbolNames ( ) const {
214: return mSymbolNames@var1089 ;
215: }
216:
217: Suppressions :: ErrorMessage toSuppressionsErrorMessage ( ) const ;
218:
219: private:
220: static std :: string fixInvalidChars ( const std :: string & raw@var1086 ) ;
221:
222:
223: std :: string mShortMessage@var1087 ;
224:
225:
226: std :: string mVerboseMessage@var1088 ;
227:
228:
229: std :: string mSymbolNames@var1089 ;
230: } ;
231:
|
235:
236: class ErrorLogger {
237: protected:
238: std :: ofstream plistFile@var1090 ;
239: public:
240: ErrorLogger ( ) { }
241: virtual ~ ErrorLogger ( ) {
242: if (@expr1073746501 plistFile@var1090 .@expr1073746502 is_open (@expr1073746503 ) ) {
243: plistFile@var1090 <<@expr1073746504 ErrorLogger ::@expr1073746505 plistFooter (@expr1073746506 ) ;
244: plistFile@var1090 .@expr1073746507 close (@expr1073746508 ) ;
245: }
246: }
247:
|
253:
254: virtual void reportOut ( const std :: string & outmsg@var1091 , Color c@var1092 = Color :: Reset ) = 0 ;
255:
|
261:
262: virtual void reportErr ( const ErrorMessage & msg@var1093 ) = 0 ;
263:
|
269:
270: virtual void reportProgress ( const std :: string & filename@var1094 , const char stage@var1095 [ ] , const unsigned long value@var1096 ) {
271: (@expr1073746509 void ) filename@var1094 ;
272: (@expr1073746510 void ) stage@var1095 ;
273: (@expr1073746511 void ) value@var1096 ;
274: }
275:
|
279:
280: virtual void reportInfo ( const ErrorMessage & msg@var1097 ) {
281: reportErr (@expr1073746512 msg@var1097 ) ;
282: }
283:
|
288:
289: bool reportUnmatchedSuppressions ( const std :: list < Suppressions :: Suppression > & unmatched@var1098 ) ;
290:
291: static std :: string callStackToString ( const std :: list < ErrorMessage :: FileLocation > & callStack@var1099 ) ;
292:
|
297:
298: static std :: string toxml ( const std :: string & str@var1100 ) ;
299:
300: static std :: string plistHeader ( const std :: string & version@var1101 , const std :: vector < std :: string > & files@var1102 ) ;
301: static std :: string plistData ( const ErrorMessage & msg@var1103 ) ;
302: static const char * plistFooter ( ) {
303: return " </array>\r\n</dict>\r\n</plist>"
304:
305: ;
306: }
307: } ;
308:
309:
310: std :: string replaceStr ( std :: string s@var1104 , const std :: string & from@var1105 , const std :: string & to@var1106 ) ;

##file cppcheck-2.8/lib/standards.h

1:
|
35:
36: struct Standards {
37:
38: enum cstd_t { C89 , C99 , C11 , CLatest = C11 } ; enum cstd_t c@var1107 ;
39:
40:
41: enum cppstd_t { CPP03 , CPP11 , CPP14 , CPP17 , CPP20 , CPP23 , CPPLatest = CPP23 } ; enum cppstd_t cpp@var1108 ;
42:
43:
44: std :: string stdValue@var1109 ;
45:
46:
47: Standards ( ) : c@var1107 ( CLatest ) , cpp@var1108 ( CPPLatest ) { }
48:
49: bool setC ( const std :: string & str@var1110 ) {
50: stdValue@var1109 =@expr1073746513 str@var1110 ;
51: if (@expr1073746514 str@var1110 ==@expr1073746515 "c89" ||@expr1073746516 str@var1110 ==@expr1073746517 "C89" ) {
52: c@var1107 =@expr1073746518 C89 ;
53: return true ;
54: }
55: if (@expr1073746519 str@var1110 ==@expr1073746520 "c99" ||@expr1073746521 str@var1110 ==@expr1073746522 "C99" ) {
56: c@var1107 =@expr1073746523 C99 ;
57: return true ;
58: }
59: if (@expr1073746524 str@var1110 ==@expr1073746525 "c11" ||@expr1073746526 str@var1110 ==@expr1073746527 "C11" ) {
60: c@var1107 =@expr1073746528 C11 ;
61: return true ;
62: }
63: return false ;
64: }
65: const std :: string getC ( ) const {
66: switch (@expr1073746529 c@var1107 ) {
67: case C89 :@expr4706 ;
68: return "c89" ;
69: case C99 :@expr4706 ;
70: return "c99" ;
71: case C11 :@expr4706 ;
72: return "c11" ;
73: }
74: return "" ;
75: }
76: static cstd_t getC ( const std :: string & std@var1111 ) {
77: if (@expr1073746533 std@var1111 ==@expr1073746534 "c89" ) {
78: return Standards ::@expr1073746535 C89 ;
79: }
80: if (@expr1073746536 std@var1111 ==@expr1073746537 "c99" ) {
81: return Standards ::@expr1073746538 C99 ;
82: }
83: if (@expr1073746539 std@var1111 ==@expr1073746540 "c11" ) {
84: return Standards ::@expr1073746541 C11 ;
85: }
86: return Standards ::@expr1073746542 CLatest ;
87: }
88: bool setCPP ( std :: string str@var1112 ) {
89: stdValue@var1109 =@expr1073746543 str@var1112 ;
90: strTolower (@expr1073746544 str@var1112 ) ;
91: cpp@var1108 =@expr1073746545 getCPP (@expr1073746546 str@var1112 ) ;
92: return !@expr1073746547 stdValue@var1109 .@expr1073746548 empty (@expr1073746549 ) &&@expr1073746550 str@var1112 ==@expr1073746551 getCPP (@expr1073746552 ) ;
93: }
94: std :: string getCPP ( ) const {
95: return getCPP (@expr1073746553 cpp@var1108 ) ;
96: }
97: static std :: string getCPP ( cppstd_t std@var1113 ) {
98: switch (@expr1073746554 std@var1113 ) {
99: case CPP03 :@expr4731 ;
100: return "c++03" ;
101: case CPP11 :@expr4731 ;
102: return "c++11" ;
103: case CPP14 :@expr4731 ;
104: return "c++14" ;
105: case CPP17 :@expr4731 ;
106: return "c++17" ;
107: case CPP20 :@expr4731 ;
108: return "c++20" ;
109: case CPP23 :@expr4731 ;
110: return "c++23" ;
111: }
112: return "" ;
113: }
114: static cppstd_t getCPP ( const std :: string & std@var1114 ) {
115: if (@expr1073746561 std@var1114 ==@expr1073746562 "c++03" ) {
116: return Standards ::@expr1073746563 CPP03 ;
117: }
118: if (@expr1073746564 std@var1114 ==@expr1073746565 "c++11" ) {
119: return Standards ::@expr1073746566 CPP11 ;
120: }
121: if (@expr1073746567 std@var1114 ==@expr1073746568 "c++14" ) {
122: return Standards ::@expr1073746569 CPP14 ;
123: }
124: if (@expr1073746570 std@var1114 ==@expr1073746571 "c++17" ) {
125: return Standards ::@expr1073746572 CPP17 ;
126: }
127: if (@expr1073746573 std@var1114 ==@expr1073746574 "c++20" ) {
128: return Standards ::@expr1073746575 CPP20 ;
129: }
130: if (@expr1073746576 std@var1114 ==@expr1073746577 "c++23" ) {
131: return Standards ::@expr1073746578 CPP23 ;
132: }
133: return Standards ::@expr1073746579 CPPLatest ;
134: }
135: } ;

##file cppcheck-2.8/lib/library.h

1:
|
37:
38: class Token ;
39: class Settings ;
40:
41: namespace tinyxml2 {
42: class XMLDocument ;
43: class XMLElement ;
44: }
45:
|
51:
52: class Library {
53: friend class TestSymbolDatabase ;
54:
55: public:
56: Library ( ) ;
57:
58: enum class ErrorCode { OK , FILE_NOT_FOUND , BAD_XML , UNKNOWN_ELEMENT , MISSING_ATTRIBUTE , BAD_ATTRIBUTE_VALUE , UNSUPPORTED_FORMAT , DUPLICATE_PLATFORM_TYPE , PLATFORM_TYPE_REDEFINED } ;
59:
60: class Error {
61: public:
62: Error ( ) : errorcode@var1118 ( ErrorCode :: OK ) { }
63: explicit Error ( ErrorCode e@var1115 ) : errorcode@var1118 ( e@var1115 ) { }
64: template < typename T >
65: Error ( ErrorCode e@var1116 , T && r@var1117 ) : errorcode@var1118 ( e@var1116 ) , reason@var1119 ( r@var1117 ) { }
66: ErrorCode errorcode@var1118 ;
67: std :: string reason@var1119 ;
68: } ;
69:
70: Error load ( const char exename@var1120 [ ] , const char path@var1121 [ ] ) ;
71: Error load ( const tinyxml2 :: XMLDocument & doc@var1122 ) ;
72:
73:
74: bool loadxmldata ( const char xmldata@var1123 [ ] , unsigned long len@var1124 ) ;
75:
76: struct AllocFunc {
77: int groupId@var1125 ;
78: int arg@var1126 ;
79: enum class BufferSize { none , malloc , calloc , strdup } ;
80: BufferSize bufferSize@var1127 ;
81: int bufferSizeArg1@var1128 ;
82: int bufferSizeArg2@var1129 ;
83: int reallocArg@var1130 ;
84: bool initData@var1131 ;
85: } ;
86:
87:
88: const AllocFunc * getAllocFuncInfo ( const Token * tok@var1132 ) const ;
89:
90:
91: const AllocFunc * getDeallocFuncInfo ( const Token * tok@var1133 ) const ;
92:
93:
94: const AllocFunc * getReallocFuncInfo ( const Token * tok@var1134 ) const ;
95:
96:
97: int getAllocId ( const Token * tok@var1135 , int arg@var1136 ) const ;
98:
99:
100: int getDeallocId ( const Token * tok@var1137 , int arg@var1138 ) const ;
101:
102:
103: int getReallocId ( const Token * tok@var1139 , int arg@var1140 ) const ;
104:
105:
106: const AllocFunc * getAllocFuncInfo ( const char name@var1141 [ ] ) const {
107: return getAllocDealloc (@expr1073746580 mAlloc@var1407 , name@var1141 ) ;
108: }
109:
110:
111: const AllocFunc * getDeallocFuncInfo ( const char name@var1142 [ ] ) const {
112: return getAllocDealloc (@expr1073746581 mDealloc@var1408 , name@var1142 ) ;
113: }
114:
115:
116: int allocId ( const char name@var1143 [ ] ) const {
117: const AllocFunc * af@var1144 ; af@var1144 =@expr1073746582 getAllocDealloc (@expr1073746583 mAlloc@var1407 , name@var1143 ) ;
118: return af@var1144 ?@expr1073746584 af@var1144 .@expr1073746585 groupId@var1145 :@expr1073746586 0 ;
119: }
120:
121:
122: int deallocId ( const char name@var1146 [ ] ) const {
123: const AllocFunc * af@var1147 ; af@var1147 =@expr1073746587 getAllocDealloc (@expr1073746588 mDealloc@var1408 , name@var1146 ) ;
124: return af@var1147 ?@expr1073746589 af@var1147 .@expr1073746590 groupId@var1148 :@expr1073746591 0 ;
125: }
126:
127:
128: void setalloc ( const std :: string & functionname@var1149 , int id@var1150 , int arg@var1151 ) {
129: mAlloc@var1407 [@expr4768 functionname@var1149 ] .@expr1073746593 groupId@var3594 =@expr1073746594 id@var1150 ;
130: mAlloc@var1407 [@expr4768 functionname@var1149 ] .@expr1073746596 arg@var3595 =@expr1073746597 arg@var1151 ;
131: }
132:
133: void setdealloc ( const std :: string & functionname@var1152 , int id@var1153 , int arg@var1154 ) {
134: mDealloc@var1408 [@expr4774 functionname@var1152 ] .@expr1073746599 groupId@var3596 =@expr1073746600 id@var1153 ;
135: mDealloc@var1408 [@expr4774 functionname@var1152 ] .@expr1073746602 arg@var3597 =@expr1073746603 arg@var1154 ;
136: }
137:
138: void setrealloc ( const std :: string & functionname@var1155 , int id@var1156 , int arg@var1157 , int reallocArg@var1158 = 1 ) {
139: mRealloc@var1409 [@expr4780 functionname@var1155 ] .@expr1073746605 groupId@var3598 =@expr1073746606 id@var1156 ;
140: mRealloc@var1409 [@expr4780 functionname@var1155 ] .@expr1073746608 arg@var3599 =@expr1073746609 arg@var1157 ;
141: mRealloc@var1409 [@expr4780 functionname@var1155 ] .@expr1073746611 reallocArg@var3600 =@expr1073746612 reallocArg@var1158 ;
142: }
143:
144:
145: void setnoreturn ( const std :: string & funcname@var1159 , bool noreturn@var1160 ) {
146: mNoReturn@var1410 [@expr1073746613 funcname@var1159 ] =@expr1073746614 noreturn@var1160 ?@expr1073746615 FalseTrueMaybe ::@expr1073746616 True :@expr1073746617 FalseTrueMaybe ::@expr1073746618 False ;
147: }
148:
149: static bool isCompliantValidationExpression ( const char * p@var1161 ) ;
150:
151:
152: static bool ismemory ( const int id@var1162 ) {
153: return (@expr4795 (@expr4795 id@var1162 >@expr1073746621 0 ) &&@expr1073746622 (@expr4795 (@expr4795 id@var1162 &@expr1073746625 1 ) ==@expr1073746626 0 ) ) ;
154: }
155: static bool ismemory ( const AllocFunc * const func@var1163 ) {
156: return (@expr4803 (@expr4803 func@var1163 .@expr4805 groupId@var1164 >@expr1073746630 0 ) &&@expr1073746631 (@expr4803 (@expr4803 func@var1163 .@expr4805 groupId@var1164 &@expr1073746635 1 ) ==@expr1073746636 0 ) ) ;
157: }
158:
159:
160: static bool isresource ( const int id@var1165 ) {
161: return (@expr4813 (@expr4813 id@var1165 >@expr1073746639 0 ) &&@expr1073746640 (@expr4813 (@expr4813 id@var1165 &@expr1073746643 1 ) ==@expr1073746644 1 ) ) ;
162: }
163: static bool isresource ( const AllocFunc * const func@var1166 ) {
164: return (@expr4821 (@expr4821 func@var1166 .@expr4823 groupId@var1167 >@expr1073746648 0 ) &&@expr1073746649 (@expr4821 (@expr4821 func@var1166 .@expr4823 groupId@var1167 &@expr1073746653 1 ) ==@expr1073746654 1 ) ) ;
165: }
166:
167: bool formatstr_function ( const Token * ftok@var1168 ) const ;
168: int formatstr_argno ( const Token * ftok@var1169 ) const ;
169: bool formatstr_scan ( const Token * ftok@var1170 ) const ;
170: bool formatstr_secure ( const Token * ftok@var1171 ) const ;
171:
172: struct NonOverlappingData {
173: int ptr1Arg@var1172 ;
174: int ptr2Arg@var1173 ;
175: int sizeArg@var1174 ;
176: int strlenArg@var1175 ;
177: } ;
178: const NonOverlappingData * getNonOverlappingData ( const Token * ftok@var1176 ) const ;
179:
180: struct WarnInfo {
181: std :: string message@var1177 ;
182: Standards standards@var1178 ;
183: Severity :: SeverityType severity@var1179 ;
184: } ;
185: std :: map < std :: string , WarnInfo > functionwarn@var1180 ;
186:
187: const WarnInfo * getWarnInfo ( const Token * ftok@var1181 ) const ;
188:
189:
190: bool isNotLibraryFunction ( const Token * ftok@var1182 ) const ;
191: bool matchArguments ( const Token * ftok@var1183 , const std :: string & functionName@var1184 ) const ;
192:
193: enum class UseRetValType { NONE , DEFAULT , ERROR_CODE } ;
194: UseRetValType getUseRetValType ( const Token * ftok@var1185 ) const ;
195:
196: const std :: string & returnValue ( const Token * ftok@var1186 ) const ;
197: const std :: string & returnValueType ( const Token * ftok@var1187 ) const ;
198: int returnValueContainer ( const Token * ftok@var1188 ) const ;
199: std :: vector < long long > unknownReturnValues ( const Token * ftok@var1189 ) const ;
200:
201: bool isnoreturn ( const Token * ftok@var1190 ) const ;
202: bool isnotnoreturn ( const Token * ftok@var1191 ) const ;
203:
204: bool isScopeNoReturn ( const Token * end@var1192 , std :: string * unknownFunc@var1193 ) const ;
205:
206: class Container {
207: public:
208: Container ( )
209: : type_templateArgNo@var1203 ( -1 ) ,
210: size_templateArgNo@var1205 ( -1 ) ,
211: arrayLike_indexOp@var1206 ( false ) ,
212: stdStringLike@var1207 ( false ) ,
213: stdAssociativeLike@var1208 ( false ) ,
214: opLessAllowed@var1209 ( true ) ,
215: hasInitializerListConstructor@var1210 ( false ) ,
216: unstableErase@var1211 ( false ) ,
217: unstableInsert@var1212 ( false ) ,
218: view@var1213 ( false )
219: { }
220:
221: enum class Action {
222: RESIZE ,
223: CLEAR ,
224: PUSH ,
225: POP ,
226: FIND ,
227: INSERT ,
228: ERASE ,
229: CHANGE_CONTENT ,
230: CHANGE ,
231: CHANGE_INTERNAL ,
232: NO_ACTION
233: } ;
234: enum class Yield {
235: AT_INDEX ,
236: ITEM ,
237: BUFFER ,
238: BUFFER_NT ,
239: START_ITERATOR ,
240: END_ITERATOR ,
241: ITERATOR ,
242: SIZE ,
243: EMPTY ,
244: NO_YIELD
245: } ;
246: struct Function {
247: Action action@var1194 ;
248: Yield yield@var1195 ;
249: } ;
250: struct RangeItemRecordTypeItem {
251: std :: string name@var1196 ;
252: int templateParameter@var1197 ;
253: } ;
254: std :: string startPattern@var1198 ; std :: string startPattern2@var1199 ; std :: string endPattern@var1200 ; std :: string itEndPattern@var1201 ;
255: std :: map < std :: string , Function > functions@var1202 ;
256: int type_templateArgNo@var1203 ;
257: std :: vector < RangeItemRecordTypeItem > rangeItemRecordType@var1204 ;
258: int size_templateArgNo@var1205 ;
259: bool arrayLike_indexOp@var1206 ;
260: bool stdStringLike@var1207 ;
261: bool stdAssociativeLike@var1208 ;
262: bool opLessAllowed@var1209 ;
263: bool hasInitializerListConstructor@var1210 ;
264: bool unstableErase@var1211 ;
265: bool unstableInsert@var1212 ;
266: bool view@var1213 ;
267:
268: Action getAction ( const std :: string & function@var1214 ) const {
269: const std ::@expr1073746655 map < std ::@expr1073746656 string , Function > ::@expr1073746657 const_iterator i@var1215 =@expr1073746658 functions@var1202 .@expr1073746659 find (@expr1073746660 function@var1214 ) ;
270: if (@expr1073746661 i@var1215 !=@expr1073746662 functions@var1202 .@expr1073746663 end (@expr1073746664 ) ) {
271: return i@var1215 .@expr1073746665 second@var1216 .@expr1073746666 action@var1217 ; }
272: return Action ::@expr1073746667 NO_ACTION ;
273: }
274:
275: Yield getYield ( const std :: string & function@var1218 ) const {
276: const std ::@expr1073746668 map < std ::@expr1073746669 string , Function > ::@expr1073746670 const_iterator i@var1219 =@expr1073746671 functions@var1202 .@expr1073746672 find (@expr1073746673 function@var1218 ) ;
277: if (@expr1073746674 i@var1219 !=@expr1073746675 functions@var1202 .@expr1073746676 end (@expr1073746677 ) ) {
278: return i@var1219 .@expr1073746678 second@var1220 .@expr1073746679 yield@var1221 ; }
279: return Yield ::@expr1073746680 NO_YIELD ;
280: }
281:
282: static Yield yieldFrom ( const std :: string & yieldName@var1222 ) ;
283: static Action actionFrom ( const std :: string & actionName@var1223 ) ;
284: } ;
285: std :: map < std :: string , Container > containers@var1224 ;
286: const Container * detectContainer ( const Token * typeStart@var1225 , bool iterator@var1226 = false ) const ;
287: const Container * detectContainerOrIterator ( const Token * typeStart@var1227 , bool * isIterator@var1228 = nullptr ) const ;
288:
289: class ArgumentChecks {
290: public:
291: ArgumentChecks ( ) :
292: notbool@var1229 ( false ) ,
293: notnull@var1230 ( false ) ,
294: notuninit@var1231 ( -1 ) ,
295: formatstr@var1232 ( false ) ,
296: strz@var1233 ( false ) ,
297: optional@var1234 ( false ) ,
298: variadic@var1235 ( false ) ,
299: iteratorInfo@var1241 ( ) ,
300: direction@var1249 ( Direction :: DIR_UNKNOWN ) { }
301:
302: bool notbool@var1229 ;
303: bool notnull@var1230 ;
304: int notuninit@var1231 ;
305: bool formatstr@var1232 ;
306: bool strz@var1233 ;
307: bool optional@var1234 ;
308: bool variadic@var1235 ;
309: std :: string valid@var1236 ;
310:
311: class IteratorInfo {
312: public:
313: IteratorInfo ( ) : container@var1237 ( 0 ) , it@var1238 ( false ) , first@var1239 ( false ) , last@var1240 ( false ) { }
314:
315: int container@var1237 ;
316: bool it@var1238 ;
317: bool first@var1239 ;
318: bool last@var1240 ;
319: } ;
320: IteratorInfo iteratorInfo@var1241 ;
321:
322: class MinSize {
323: public:
324: enum class Type { NONE , STRLEN , ARGVALUE , SIZEOF , MUL , VALUE } ;
325: MinSize ( Type t@var1242 , int a@var1243 ) : type@var1244 ( t@var1242 ) , arg@var1245 ( a@var1243 ) , arg2@var1246 ( 0 ) , value@var1247 ( 0 ) { }
326: Type type@var1244 ;
327: int arg@var1245 ;
328: int arg2@var1246 ;
329: long long value@var1247 ;
330: } ;
331: std :: vector < MinSize > minsizes@var1248 ;
332:
333: enum class Direction {
334: DIR_IN ,
335: DIR_OUT ,
336: DIR_INOUT ,
337: DIR_UNKNOWN
338: } ;
339: Direction direction@var1249 ;
340: } ;
341:
342: struct Function {
343: std :: map < int , ArgumentChecks > argumentChecks@var1250 ;
344: bool use@var1251 ;
345: bool leakignore@var1252 ;
346: bool isconst@var1253 ;
347: bool ispure@var1254 ;
348: UseRetValType useretval@var1255 ;
349: bool ignore@var1256 ;
350: bool formatstr@var1257 ;
351: bool formatstr_scan@var1258 ;
352: bool formatstr_secure@var1259 ;
353: Container :: Action containerAction@var1260 ;
354: Container :: Yield containerYield@var1261 ;
355: Function ( )
356: : use@var1251 ( false ) ,
357: leakignore@var1252 ( false ) ,
358: isconst@var1253 ( false ) ,
359: ispure@var1254 ( false ) ,
360: useretval@var1255 ( UseRetValType :: NONE ) ,
361: ignore@var1256 ( false ) ,
362: formatstr@var1257 ( false ) ,
363: formatstr_scan@var1258 ( false ) ,
364: formatstr_secure@var1259 ( false ) ,
365: containerAction@var1260 ( Container :: Action :: NO_ACTION ) ,
366: containerYield@var1261 ( Container :: Yield :: NO_YIELD )
367: { }
368: } ;
369:
370: const Function * getFunction ( const Token * ftok@var1262 ) const ;
371: std :: unordered_map < std :: string , Function > functions@var1263 ;
372: bool isUse ( const std :: string & functionName@var1264 ) const ;
373: bool isLeakIgnore ( const std :: string & functionName@var1265 ) const ;
374: bool isFunctionConst ( const std :: string & functionName@var1266 , bool pure@var1267 ) const ;
375: bool isFunctionConst ( const Token * ftok@var1268 ) const ;
376:
377: bool isboolargbad ( const Token * ftok@var1269 , int argnr@var1270 ) const {
378: const ArgumentChecks * arg@var1271 ; arg@var1271 =@expr1073746681 getarg (@expr1073746682 ftok@var1269 , argnr@var1270 ) ;
379: return arg@var1271 &&@expr1073746683 arg@var1271 .@expr1073746684 notbool@var1272 ;
380: }
381:
382: bool isnullargbad ( const Token * ftok@var1273 , int argnr@var1274 ) const ;
383: bool isuninitargbad ( const Token * ftok@var1275 , int argnr@var1276 , int indirect@var1277 = 0 , bool * hasIndirect@var1278 = nullptr ) const ;
384:
385: bool isargformatstr ( const Token * ftok@var1279 , int argnr@var1280 ) const {
386: const ArgumentChecks * arg@var1281 ; arg@var1281 =@expr1073746685 getarg (@expr1073746686 ftok@var1279 , argnr@var1280 ) ;
387: return arg@var1281 &&@expr1073746687 arg@var1281 .@expr1073746688 formatstr@var1282 ;
388: }
389:
390: bool isargstrz ( const Token * ftok@var1283 , int argnr@var1284 ) const {
391: const ArgumentChecks * arg@var1285 ; arg@var1285 =@expr1073746689 getarg (@expr1073746690 ftok@var1283 , argnr@var1284 ) ;
392: return arg@var1285 &&@expr1073746691 arg@var1285 .@expr1073746692 strz@var1286 ;
393: }
394:
395: bool isIntArgValid ( const Token * ftok@var1287 , int argnr@var1288 , const long long argvalue@var1289 ) const ;
396: bool isFloatArgValid ( const Token * ftok@var1290 , int argnr@var1291 , double argvalue@var1292 ) const ;
397:
398: const std :: string & validarg ( const Token * ftok@var1293 , int argnr@var1294 ) const {
399: const ArgumentChecks * arg@var1295 ; arg@var1295 =@expr1073746693 getarg (@expr1073746694 ftok@var1293 , argnr@var1294 ) ;
400: return arg@var1295 ?@expr1073746695 arg@var1295 .@expr1073746696 valid@var1296 :@expr1073746697 emptyString@var1 ;
401: }
402:
403: struct InvalidArgValue {
404: enum class Type { le , lt , eq , ge , gt , range } ; enum Type type@var1297 ;
405: std :: string op1@var1298 ;
406: std :: string op2@var1299 ;
407: bool isInt ( ) const {
408: return MathLib ::@expr1073746698 isInt (@expr1073746699 op1@var1298 ) ;
409: }
410: } ;
411:
412: const ArgumentChecks :: IteratorInfo * getArgIteratorInfo ( const Token * ftok@var1300 , int argnr@var1301 ) const {
413: const ArgumentChecks * arg@var1302 ; arg@var1302 =@expr1073746700 getarg (@expr1073746701 ftok@var1300 , argnr@var1301 ) ;
414: return arg@var1302 &&@expr1073746702 arg@var1302 .@expr4879 iteratorInfo@var1303 .@expr1073746704 it@var1304 ?@expr1073746705 &@expr1073746706 arg@var1302 .@expr4879 iteratorInfo@var1303 :@expr1073746708 nullptr ;
415: }
416:
417: bool hasminsize ( const Token * ftok@var1305 ) const ;
418:
419: const std :: vector < ArgumentChecks :: MinSize > * argminsizes ( const Token * ftok@var1306 , int argnr@var1307 ) const {
420: const ArgumentChecks * arg@var1308 ; arg@var1308 =@expr1073746709 getarg (@expr1073746710 ftok@var1306 , argnr@var1307 ) ;
421: return arg@var1308 ?@expr1073746711 &@expr1073746712 arg@var1308 .@expr1073746713 minsizes@var1309 :@expr1073746714 nullptr ;
422: }
423:
424: ArgumentChecks :: Direction getArgDirection ( const Token * ftok@var1310 , int argnr@var1311 ) const ;
425:
426: bool markupFile ( const std :: string & path@var1312 ) const ;
427:
428: bool processMarkupAfterCode ( const std :: string & path@var1313 ) const ;
429:
430: const std :: set < std :: string > & markupExtensions ( ) const {
431: return mMarkupExtensions@var1417 ;
432: }
433:
434: bool reportErrors ( const std :: string & path@var1314 ) const ;
435:
436: bool ignorefunction ( const std :: string & functionName@var1315 ) const ;
437:
438: bool isexecutableblock ( const std :: string & file@var1316 , const std :: string & token@var1317 ) const ;
439:
440: int blockstartoffset ( const std :: string & file@var1318 ) const ;
441:
442: const std :: string & blockstart ( const std :: string & file@var1319 ) const ;
443: const std :: string & blockend ( const std :: string & file@var1320 ) const ;
444:
445: bool iskeyword ( const std :: string & file@var1321 , const std :: string & keyword@var1322 ) const ;
446:
447: bool isexporter ( const std :: string & prefix@var1323 ) const {
448: return mExporters@var1420 .@expr1073746715 find (@expr1073746716 prefix@var1323 ) !=@expr1073746717 mExporters@var1420 .@expr1073746718 end (@expr1073746719 ) ;
449: }
450:
451: bool isexportedprefix ( const std :: string & prefix@var1324 , const std :: string & token@var1325 ) const {
452: const std ::@expr1073746720 map < std ::@expr1073746721 string , ExportedFunctions > ::@expr1073746722 const_iterator it@var1326 =@expr1073746723 mExporters@var1420 .@expr1073746724 find (@expr1073746725 prefix@var1324 ) ;
453: return (@expr1073746726 it@var1326 !=@expr1073746727 mExporters@var1420 .@expr1073746728 end (@expr1073746729 ) &&@expr1073746730 it@var1326 .@expr1073746731 second@var1327 .@expr1073746732 isPrefix (@expr1073746733 token@var1325 ) ) ;
454: }
455:
456: bool isexportedsuffix ( const std :: string & prefix@var1328 , const std :: string & token@var1329 ) const {
457: const std ::@expr1073746734 map < std ::@expr1073746735 string , ExportedFunctions > ::@expr1073746736 const_iterator it@var1330 =@expr1073746737 mExporters@var1420 .@expr1073746738 find (@expr1073746739 prefix@var1328 ) ;
458: return (@expr1073746740 it@var1330 !=@expr1073746741 mExporters@var1420 .@expr1073746742 end (@expr1073746743 ) &&@expr1073746744 it@var1330 .@expr1073746745 second@var1331 .@expr1073746746 isSuffix (@expr1073746747 token@var1329 ) ) ;
459: }
460:
461: bool isimporter ( const std :: string & file@var1332 , const std :: string & importer@var1333 ) const ;
462:
463: const Token * getContainerFromYield ( const Token * tok@var1334 , Container :: Yield yield@var1335 ) const ;
464: const Token * getContainerFromAction ( const Token * tok@var1336 , Container :: Action action@var1337 ) const ;
465:
466: bool isreflection ( const std :: string & token@var1338 ) const {
467: return mReflection@var1422 .@expr1073746748 find (@expr1073746749 token@var1338 ) !=@expr1073746750 mReflection@var1422 .@expr1073746751 end (@expr1073746752 ) ;
468: }
469:
470: int reflectionArgument ( const std :: string & token@var1339 ) const {
471: const std ::@expr1073746753 map < std ::@expr1073746754 string , int > ::@expr1073746755 const_iterator it@var1340 =@expr1073746756 mReflection@var1422 .@expr1073746757 find (@expr1073746758 token@var1339 ) ;
472: if (@expr1073746759 it@var1340 !=@expr1073746760 mReflection@var1422 .@expr1073746761 end (@expr1073746762 ) ) {
473: return it@var1340 .@expr1073746763 second@var1341 ; }
474: return -1 ;
475: }
476:
477: std :: vector < std :: string > defines@var1342 ;
478:
479: struct SmartPointer {
480: std :: string name@var1343 ; name@var1343 = "" ;
481: bool unique@var1344 ; unique@var1344 = false ;
482: } ;
483:
484: std :: map < std :: string , SmartPointer > smartPointers@var1345 ;
485: bool isSmartPointer ( const Token * tok@var1346 ) const ;
486: const SmartPointer * detectSmartPointer ( const Token * tok@var1347 ) const ;
487:
488: struct PodType {
489: unsigned int size@var1348 ;
490: char sign@var1349 ;
491: enum class Type { NO , BOOL , CHAR , SHORT , INT , LONG , LONGLONG } ; enum Type stdtype@var1350 ;
492: } ;
493: const struct PodType * podtype ( const std :: string & name@var1351 ) const {
494: const std ::@expr1073746764 unordered_map < std ::@expr1073746765 string , PodType > ::@expr1073746766 const_iterator it@var1352 =@expr1073746767 mPodTypes@var1423 .@expr1073746768 find (@expr1073746769 name@var1351 ) ;
495: return (@expr4946 it@var1352 !=@expr1073746771 mPodTypes@var1423 .@expr1073746772 end (@expr1073746773 ) ) ?@expr1073746774 &@expr1073746775 (@expr4946 it@var1352 .@expr1073746777 second@var1353 ) :@expr1073746778 nullptr ;
496: }
497:
498: struct PlatformType {
499: PlatformType ( )
500: : mSigned@var1364 ( false )
501: , mUnsigned@var1365 ( false )
502: , mLong@var1366 ( false )
503: , mPointer@var1367 ( false )
504: , mPtrPtr@var1368 ( false )
505: , mConstPtr@var1369 ( false ) { }
506: bool operator== ( const PlatformType & type@var1354 ) const {
507: return (@expr1073746779 mSigned@var1364 ==@expr1073746780 type@var1354 .@expr1073746781 mSigned@var1355 &&@expr1073746782
508: mUnsigned@var1365 ==@expr1073746783 type@var1354 .@expr1073746784 mUnsigned@var1356 &&@expr1073746785
509: mLong@var1366 ==@expr1073746786 type@var1354 .@expr1073746787 mLong@var1357 &&@expr1073746788
510: mPointer@var1367 ==@expr1073746789 type@var1354 .@expr1073746790 mPointer@var1358 &&@expr1073746791
511: mPtrPtr@var1368 ==@expr1073746792 type@var1354 .@expr1073746793 mPtrPtr@var1359 &&@expr1073746794
512: mConstPtr@var1369 ==@expr1073746795 type@var1354 .@expr1073746796 mConstPtr@var1360 &&@expr1073746797
513: mType@var1363 ==@expr1073746798 type@var1354 .@expr1073746799 mType@var1361 ) ;
514: }
515: bool operator!= ( const PlatformType & type@var1362 ) const {
516: return !@expr1073746800 (@expr1073746801 *@expr1073746802 this@expr1073746803 ==@expr1073746804 type@var1362 ) ;
517: }
518: std :: string mType@var1363 ;
519: bool mSigned@var1364 ;
520: bool mUnsigned@var1365 ;
521: bool mLong@var1366 ;
522: bool mPointer@var1367 ;
523: bool mPtrPtr@var1368 ;
524: bool mConstPtr@var1369 ;
525: } ;
526:
527: struct Platform {
528: const PlatformType * platform_type ( const std :: string & name@var1370 ) const {
529: const std ::@expr1073746805 map < std ::@expr1073746806 string , PlatformType > ::@expr1073746807 const_iterator it@var1371 =@expr1073746808 mPlatformTypes@var1373 .@expr1073746809 find (@expr1073746810 name@var1370 ) ;
530: return (@expr4987 it@var1371 !=@expr1073746812 mPlatformTypes@var1373 .@expr1073746813 end (@expr1073746814 ) ) ?@expr1073746815 &@expr1073746816 (@expr4987 it@var1371 .@expr1073746818 second@var1372 ) :@expr1073746819 nullptr ;
531: }
532: std :: map < std :: string , PlatformType > mPlatformTypes@var1373 ;
533: } ;
534:
535: const PlatformType * platform_type ( const std :: string & name@var1374 , const std :: string & platform@var1375 ) const {
536: const std ::@expr1073746820 map < std ::@expr4997 string , Platform > ::@expr1073746822 const_iterator it@var1376 =@expr1073746823 mPlatforms@var1425 .@expr1073746824 find (@expr1073746825 platform@var1375 ) ;
537: if (@expr1073746826 it@var1376 !=@expr1073746827 mPlatforms@var1425 .@expr1073746828 end (@expr1073746829 ) ) {
538: const PlatformType * const type@var1377 ; type@var1377 =@expr1073746830 it@var1376 .@expr1073746831 second@var1378 .@expr1073746832 platform_type (@expr1073746833 name@var1374 ) ;
539: if (@expr1073746834 type@var1377 ) {
540: return type@var1377 ; }
541: }
542:
543: const std ::@expr1073746835 map < std ::@expr4997 string , PlatformType > ::@expr1073746837 const_iterator it2@var1379 =@expr1073746838 mPlatformTypes@var1424 .@expr1073746839 find (@expr1073746840 name@var1374 ) ;
544: return (@expr5017 it2@var1379 !=@expr1073746842 mPlatformTypes@var1424 .@expr1073746843 end (@expr1073746844 ) ) ?@expr1073746845 &@expr1073746846 (@expr5017 it2@var1379 .@expr1073746848 second@var1380 ) :@expr1073746849 nullptr ;
545: }
546:
|
549:
550: std :: string getFunctionName ( const Token * ftok@var1381 ) const ;
551:
552: static bool isContainerYield ( const Token * const cond@var1382 , Library :: Container :: Yield y@var1383 , const std :: string & fallback@var1384 = "" ) ;
553:
554:
555: enum class TypeCheck { def , check , suppress } ;
556: TypeCheck getTypeCheck ( const std :: string & check@var1385 , const std :: string & typeName@var1386 ) const ;
557:
558: private:
559:
560: Error loadFunction ( const tinyxml2 :: XMLElement * const node@var1387 , const std :: string & name@var1388 , std :: set < std :: string > & unknown_elements@var1389 ) ;
561:
562: class ExportedFunctions {
563: public:
564: void addPrefix ( const std :: string & prefix@var1390 ) {
565: mPrefixes@var1394 .@expr1073746850 insert (@expr1073746851 prefix@var1390 ) ;
566: }
567: void addSuffix ( const std :: string & suffix@var1391 ) {
568: mSuffixes@var1395 .@expr1073746852 insert (@expr1073746853 suffix@var1391 ) ;
569: }
570: bool isPrefix ( const std :: string & prefix@var1392 ) const {
571: return (@expr1073746854 mPrefixes@var1394 .@expr1073746855 find (@expr1073746856 prefix@var1392 ) !=@expr1073746857 mPrefixes@var1394 .@expr1073746858 end (@expr1073746859 ) ) ;
572: }
573: bool isSuffix ( const std :: string & suffix@var1393 ) const {
574: return (@expr1073746860 mSuffixes@var1395 .@expr1073746861 find (@expr1073746862 suffix@var1393 ) !=@expr1073746863 mSuffixes@var1395 .@expr1073746864 end (@expr1073746865 ) ) ;
575: }
576:
577: private:
578: std :: set < std :: string > mPrefixes@var1394 ;
579: std :: set < std :: string > mSuffixes@var1395 ;
580: } ;
581: class CodeBlock {
582: public:
583: CodeBlock ( ) : mOffset@var1403 ( 0 ) { }
584:
585: void setStart ( const char * s@var1396 ) {
586: mStart@var1401 =@expr1073746866 s@var1396 ;
587: }
588: void setEnd ( const char * e@var1397 ) {
589: mEnd@var1402 =@expr1073746867 e@var1397 ;
590: }
591: void setOffset ( const int o@var1398 ) {
592: mOffset@var1403 =@expr1073746868 o@var1398 ;
593: }
594: void addBlock ( const char * blockName@var1399 ) {
595: mBlocks@var1404 .@expr1073746869 insert (@expr1073746870 blockName@var1399 ) ;
596: }
597: const std :: string & start ( ) const {
598: return mStart@var1401 ;
599: }
600: const std :: string & end ( ) const {
601: return mEnd@var1402 ;
602: }
603: int offset ( ) const {
604: return mOffset@var1403 ;
605: }
606: bool isBlock ( const std :: string & blockName@var1400 ) const {
607: return mBlocks@var1404 .@expr1073746871 find (@expr1073746872 blockName@var1400 ) !=@expr1073746873 mBlocks@var1404 .@expr1073746874 end (@expr1073746875 ) ;
608: }
609:
610: private:
611: std :: string mStart@var1401 ;
612: std :: string mEnd@var1402 ;
613: int mOffset@var1403 ;
614: std :: set < std :: string > mBlocks@var1404 ;
615: } ;
616: enum class FalseTrueMaybe { False , True , Maybe } ;
617: int mAllocId@var1405 ;
618: std :: set < std :: string > mFiles@var1406 ;
619: std :: map < std :: string , AllocFunc > mAlloc@var1407 ;
620: std :: map < std :: string , AllocFunc > mDealloc@var1408 ;
621: std :: map < std :: string , AllocFunc > mRealloc@var1409 ;
622: std :: unordered_map < std :: string , FalseTrueMaybe > mNoReturn@var1410 ;
623: std :: map < std :: string , std :: string > mReturnValue@var1411 ;
624: std :: map < std :: string , std :: string > mReturnValueType@var1412 ;
625: std :: map < std :: string , int > mReturnValueContainer@var1413 ;
626: std :: map < std :: string , std :: vector < long long > > mUnknownReturnValues@var1414 ;
627: std :: map < std :: string , bool > mReportErrors@var1415 ;
628: std :: map < std :: string , bool > mProcessAfterCode@var1416 ;
629: std :: set < std :: string > mMarkupExtensions@var1417 ;
630: std :: map < std :: string , std :: set < std :: string > > mKeywords@var1418 ;
631: std :: map < std :: string , CodeBlock > mExecutableBlocks@var1419 ;
632: std :: map < std :: string , ExportedFunctions > mExporters@var1420 ;
633: std :: map < std :: string , std :: set < std :: string > > mImporters@var1421 ;
634: std :: map < std :: string , int > mReflection@var1422 ;
635: std :: unordered_map < std :: string , PodType > mPodTypes@var1423 ;
636: std :: map < std :: string , PlatformType > mPlatformTypes@var1424 ;
637: std :: map < std :: string , Platform > mPlatforms@var1425 ;
638: std :: map < std :: pair < std :: string , std :: string > , TypeCheck > mTypeChecks@var1426 ;
639: std :: unordered_map < std :: string , NonOverlappingData > mNonOverlappingData@var1427 ;
640:
641: const ArgumentChecks * getarg ( const Token * ftok@var1428 , int argnr@var1429 ) const ;
642:
643: std :: string getFunctionName ( const Token * ftok@var1430 , bool * error@var1431 ) const ;
644:
645: static const AllocFunc * getAllocDealloc ( const std :: map < std :: string , AllocFunc > & data@var1432 , const std :: string & name@var1433 ) {
646: const std ::@expr1073746876 map < std ::@expr1073746877 string , AllocFunc > ::@expr1073746878 const_iterator it@var1434 =@expr1073746879 data@var1432 .@expr1073746880 find (@expr1073746881 name@var1433 ) ;
647: return (@expr1073746882 it@var1434 ==@expr1073746883 data@var1432 .@expr1073746884 end (@expr1073746885 ) ) ?@expr1073746886 nullptr :@expr1073746887 &@expr1073746888 it@var1434 .@expr1073746889 second@var1435 ;
648: }
649: } ;
650:
651: const Library :: Container * getLibraryContainer ( const Token * tok@var1436 ) ;
652:
653: std :: shared_ptr < Token > createTokenFromExpression ( const std :: string & returnValue@var1437 ,
654: const Settings * settings@var1438 ,
655: std :: unordered_map < int , const Token * > * lookupVarId@var1439 = nullptr ) ;

##file cppcheck-2.8/lib/platform.h

1:
|
31:
32: namespace tinyxml2 {
33: class XMLDocument ;
34: }
35:
36: namespace cppcheck {
37:
|
40:
41: class Platform {
42: private:
43: static long long min_value ( int bit@var1440 ) {
44: if (@expr1073746890 bit@var1440 >=@expr1073746891 64 ) {
45: return LLONG_MIN ; }
46: return -@expr1073746892 (@expr1073746893 1LL <<@expr1073746894 (@expr1073746895 bit@var1440 -@expr1073746896 1 ) ) ;
47: }
48:
49: static long long max_value ( int bit@var1441 ) {
50: if (@expr1073746897 bit@var1441 >=@expr1073746898 64 ) {
51: return (@expr5075 ~@expr1073746900 0ULL ) >>@expr1073746901 1 ; }
52: return (@expr5075 1LL <<@expr1073746903 (@expr5075 bit@var1441 -@expr1073746905 1 ) ) -@expr1073746906 1LL ;
53: }
54: public:
55: Platform ( ) ;
56: virtual ~ Platform ( ) { }
57:
58: bool isIntValue ( long long value@var1442 ) const {
59: return value@var1442 >=@expr1073746907 min_value (@expr1073746908 int_bit@var1452 ) &&@expr1073746909 value@var1442 <=@expr1073746910 max_value (@expr1073746911 int_bit@var1452 ) ;
60: }
61:
62: bool isIntValue ( unsigned long long value@var1443 ) const {
63: unsigned long long intMax@var1444 ; intMax@var1444 =@expr1073746912 max_value (@expr1073746913 int_bit@var1452 ) ;
64: return value@var1443 <=@expr1073746914 intMax@var1444 ;
65: }
66:
67: bool isLongValue ( long long value@var1445 ) const {
68: return value@var1445 >=@expr1073746915 min_value (@expr1073746916 long_bit@var1453 ) &&@expr1073746917 value@var1445 <=@expr1073746918 max_value (@expr1073746919 long_bit@var1453 ) ;
69: }
70:
71: bool isLongValue ( unsigned long long value@var1446 ) const {
72: unsigned long long longMax@var1447 ; longMax@var1447 =@expr1073746920 max_value (@expr1073746921 long_bit@var1453 ) ;
73: return value@var1446 <=@expr1073746922 longMax@var1447 ;
74: }
75:
76: bool isLongLongValue ( unsigned long long value@var1448 ) const {
77: unsigned long long longLongMax@var1449 ; longLongMax@var1449 =@expr1073746923 max_value (@expr1073746924 long_long_bit@var1454 ) ;
78: return value@var1448 <=@expr1073746925 longLongMax@var1449 ;
79: }
80:
81: int char_bit@var1450 ;
82: int short_bit@var1451 ;
83: int int_bit@var1452 ;
84: int long_bit@var1453 ;
85: int long_long_bit@var1454 ;
86:
87:
88: int sizeof_bool@var1455 ;
89: int sizeof_short@var1456 ;
90: int sizeof_int@var1457 ;
91: int sizeof_long@var1458 ;
92: int sizeof_long_long@var1459 ;
93: int sizeof_float@var1460 ;
94: int sizeof_double@var1461 ;
95: int sizeof_long_double@var1462 ;
96: int sizeof_wchar_t@var1463 ;
97: int sizeof_size_t@var1464 ;
98: int sizeof_pointer@var1465 ;
99:
100: char defaultSign@var1466 ;
101:
102: enum PlatformType {
103: Unspecified ,
104: Native ,
105: Win32A ,
106: Win32W ,
107: Win64 ,
108: Unix32 ,
109: Unix64 ,
110: PlatformFile
111: } ;
112:
113:
114: PlatformType platformType@var1467 ;
115:
116:
117: bool platform ( PlatformType type@var1468 ) ;
118:
|
124:
125: bool loadPlatformFile ( const char exename@var1469 [ ] , const std :: string & filename@var1470 ) ;
126:
127:
128: bool loadFromXmlDocument ( const tinyxml2 :: XMLDocument * doc@var1471 ) ;
129:
|
133:
134: bool isWindowsPlatform ( ) const {
135: return platformType@var1467 ==@expr1073746926 Win32A ||@expr1073746927
136: platformType@var1467 ==@expr1073746928 Win32W ||@expr1073746929
137: platformType@var1467 ==@expr1073746930 Win64 ;
138: }
139:
140: const char * platformString ( ) const {
141: return platformString (@expr1073746931 platformType@var1467 ) ;
142: }
143:
144: static const char * platformString ( PlatformType pt@var1472 ) {
145: switch (@expr1073746932 pt@var1472 ) {
146: case Unspecified :@expr5109 ;
147: return "Unspecified" ;
148: case Native :@expr5109 ;
149: return "Native" ;
150: case Win32A :@expr5109 ;
151: return "win32A" ;
152: case Win32W :@expr5109 ;
153: return "win32W" ;
154: case Win64 :@expr5109 ;
155: return "win64" ;
156: case Unix32 :@expr5109 ;
157: return "unix32" ;
158: case Unix64 :@expr5109 ;
159: return "unix64" ;
160: case PlatformFile :@expr5109 ;
161: return "platformFile" ;
162: default :@expr5109 ;
163: return "unknown" ;
164: }
165: }
166:
167: long long unsignedCharMax ( ) const {
168: return max_value (@expr1073746942 char_bit@var1450 +@expr1073746943 1 ) ;
169: }
170:
171: long long signedCharMax ( ) const {
172: return max_value (@expr1073746944 char_bit@var1450 ) ;
173: }
174:
175: long long signedCharMin ( ) const {
176: return min_value (@expr1073746945 char_bit@var1450 ) ;
177: }
178: } ;
179:
180: }

##file cppcheck-2.8/lib/preprocessor.h

1:
|
34:
35: class ErrorLogger ;
36: class Settings ;
37:
|
46:
47: class Directive {
48: public:
49:
50: std :: string file@var1473 ;
51:
52:
53: unsigned int linenr@var1474 ;
54:
55:
56: std :: string str@var1475 ;
57:
58:
59: Directive ( const std :: string & _file@var1476 , const int _linenr@var1477 , const std :: string & _str@var1478 ) ;
60: } ;
61:
|
69:
70: class Preprocessor {
71: public:
72:
|
75:
76: enum HeaderTypes {
77: NoHeader = 0 ,
78: UserHeader ,
79: SystemHeader
80: } ;
81:
82:
83: static char macroChar@var1479 ;
84:
85: explicit Preprocessor ( Settings & settings@var1480 , ErrorLogger * errorLogger@var1481 = nullptr ) ;
86: virtual ~ Preprocessor ( ) ;
87:
88: static std :: atomic < bool > missingIncludeFlag@var1482 ;
89: static std :: atomic < bool > missingSystemIncludeFlag@var1483 ;
90:
91: void inlineSuppressions ( const simplecpp :: TokenList & tokens@var1484 ) ;
92:
93: void setDirectives ( const simplecpp :: TokenList & tokens@var1485 ) ;
94: void setDirectives ( const std :: list < Directive > & directives@var1486 ) {
95: mDirectives@var1538 =@expr1073746946 directives@var1486 ;
96: }
97:
98:
99: const std :: list < Directive > & getDirectives ( ) const {
100: return mDirectives@var1538 ;
101: }
102:
103: std :: set < std :: string > getConfigs ( const simplecpp :: TokenList & tokens@var1487 ) const ;
104:
105: void handleErrors ( const simplecpp :: OutputList & outputList@var1488 , bool throwError@var1489 ) ;
106:
107: bool loadFiles ( const simplecpp :: TokenList & rawtokens@var1490 , std :: vector < std :: string > & files@var1491 ) ;
108:
109: void removeComments ( ) ;
110:
111: void setPlatformInfo ( simplecpp :: TokenList * tokens@var1492 ) const ;
112:
|
123:
124: void preprocess ( std :: istream & istr@var1493 , std :: map < std :: string , std :: string > & result@var1494 , const std :: string & filename@var1495 , const std :: list < std :: string > & includePaths@var1496 = std :: list < std :: string > ( ) ) ;
125:
|
142:
143: void preprocess ( std :: istream & srcCodeStream@var1497 , std :: string & processedFile@var1498 , std :: list < std :: string > & resultConfigurations@var1499 , const std :: string & filename@var1500 , const std :: list < std :: string > & includePaths@var1501 ) ;
144:
145: simplecpp :: TokenList preprocess ( const simplecpp :: TokenList & tokens1@var1502 , const std :: string & cfg@var1503 , std :: vector < std :: string > & files@var1504 , bool throwError@var1505 = false ) ;
146:
147: std :: string getcode ( const simplecpp :: TokenList & tokens1@var1506 , const std :: string & cfg@var1507 , std :: vector < std :: string > & files@var1508 , const bool writeLocations@var1509 ) ;
148:
|
154:
155: std :: string getcode ( const std :: string & filedata@var1510 , const std :: string & cfg@var1511 , const std :: string & filename@var1512 ) ;
156:
|
162:
163: bool validateCfg ( const std :: string & cfg@var1513 , const std :: list < simplecpp :: MacroUsage > & macroUsageList@var1514 ) ;
164: void validateCfgError ( const std :: string & file@var1515 , const unsigned int line@var1516 , const std :: string & cfg@var1517 , const std :: string & macro@var1518 ) ;
165:
|
172:
173: unsigned int calculateChecksum ( const simplecpp :: TokenList & tokens1@var1519 , const std :: string & toolinfo@var1520 ) const ;
174:
175: void simplifyPragmaAsm ( simplecpp :: TokenList * tokenList@var1521 ) ;
176:
177: private:
178:
179: static void simplifyPragmaAsmPrivate ( simplecpp :: TokenList * tokenList@var1522 ) ;
180:
181: public:
182:
183:
184: static void getErrorMessages ( ErrorLogger * errorLogger@var1523 , const Settings * settings@var1524 ) ;
185:
186: void setFile0 ( const std :: string & f@var1525 ) {
187: mFile0@var1540 =@expr1073746947 f@var1525 ;
188: }
189:
|
192:
193: void dump ( std :: ostream & out@var1526 ) const ;
194:
195: void reportOutput ( const simplecpp :: OutputList & outputList@var1527 , bool showerror@var1528 ) ;
196:
197: private:
198: void missingInclude ( const std :: string & filename@var1529 , unsigned int linenr@var1530 , const std :: string & header@var1531 , HeaderTypes headerType@var1532 ) ;
199: void error ( const std :: string & filename@var1533 , unsigned int linenr@var1534 , const std :: string & msg@var1535 ) ;
200:
201: Settings & mSettings@var1536 ;
202: ErrorLogger * mErrorLogger@var1537 ;
203:
204:
205: std :: list < Directive > mDirectives@var1538 ;
206:
207: std :: map < std :: string , simplecpp :: TokenList * > mTokenLists@var1539 ;
208:
209:
210: std :: string mFile0@var1540 ;
211:
212:
213: std :: list < simplecpp :: MacroUsage > mMacroUsage@var1541 ;
214: std :: list < simplecpp :: IfCond > mIfCond@var1542 ;
215: } ;

##file cppcheck-2.8/lib/importproject.h

1:
|
37:
38: namespace cppcheck {
39: struct stricmp {
40: bool operator() ( const std :: string & lhs@var1543 , const std :: string & rhs@var1544 ) const {
41: return caseInsensitiveStringCompare (@expr1073746948 lhs@var1543 , rhs@var1544 ) <@expr1073746949 0 ;
42: }
43: } ;
44: }
45:
46: class Settings ;
47:
|
50:
51: class ImportProject {
52: public:
53: enum class Type {
54: UNKNOWN ,
55: MISSING ,
56: FAILURE ,
57: COMPILE_DB ,
58: VS_SLN ,
59: VS_VCXPROJ ,
60: BORLAND ,
61: CPPCHECK_GUI
62: } ;
63:
64:
65: struct FileSettings {
66: FileSettings ( ) : platformType@var1552 ( cppcheck :: Platform :: Unspecified ) , msc@var1553 ( false ) , useMfc@var1554 ( false ) { }
67: std :: string cfg@var1545 ;
68: std :: string filename@var1546 ;
69: std :: string defines@var1547 ;
70: std :: string cppcheckDefines ( ) const {
71: return defines@var1547 +@expr1073746950 (@expr1073746951 msc@var1553 ?@expr1073746952 ";_MSC_VER=1900" :@expr1073746953 "" ) +@expr1073746954 (@expr1073746955 useMfc@var1554 ?@expr1073746956 ";__AFXWIN_H__=1" :@expr1073746957 "" ) ;
72: }
73: std :: set < std :: string > undefs@var1548 ;
74: std :: list < std :: string > includePaths@var1549 ;
75: std :: list < std :: string > systemIncludePaths@var1550 ;
76: std :: string standard@var1551 ;
77: cppcheck :: Platform :: PlatformType platformType@var1552 ;
78: bool msc@var1553 ;
79: bool useMfc@var1554 ;
80:
81: void parseCommand ( std :: string command@var1555 ) ;
82: void setDefines ( std :: string defs@var1556 ) ;
83: void setIncludePaths ( const std :: string & basepath@var1557 , const std :: list < std :: string > & in@var1558 , std :: map < std :: string , std :: string , cppcheck :: stricmp > & variables@var1559 ) ;
84: } ;
85: std :: list < FileSettings > fileSettings@var1560 ;
86: Type projectType@var1561 ;
87:
88: ImportProject ( ) ;
89:
90: void selectOneVsConfig ( cppcheck :: Platform :: PlatformType platform@var1562 ) ;
91:
92: std :: list < std :: string > getVSConfigs ( ) ;
93:
94:
95: struct Anonymous3 {
96: std :: string analyzeAllVsConfigs@var1563 ;
97: std :: vector < std :: string > pathNames@var1564 ;
98: std :: list < std :: string > libraries@var1565 ;
99: std :: list < std :: string > excludedPaths@var1566 ;
100: std :: list < std :: string > checkVsConfigs@var1567 ;
101: std :: string projectFile@var1568 ;
102: std :: string platform@var1569 ;
103: } ; struct Anonymous3 guiProject@var1570 ;
104:
105: void ignorePaths ( const std :: vector < std :: string > & ipaths@var1571 ) ;
106: void ignoreOtherConfigs ( const std :: string & cfg@var1572 ) ;
107:
108: Type import ( const std :: string & filename@var1573 , Settings * settings@var1574 = nullptr ) ;
109: protected:
110: bool importCompileCommands ( std :: istream & istr@var1575 ) ;
111: bool importCppcheckGuiProject ( std :: istream & istr@var1576 , Settings * settings@var1577 ) ;
112: virtual bool sourceFileExists ( const std :: string & file@var1578 ) ;
113: private:
114: bool importSln ( std :: istream & istr@var1579 , const std :: string & path@var1580 , const std :: vector < std :: string > & fileFilters@var1581 ) ;
115: bool importVcxproj ( const std :: string & filename@var1582 , std :: map < std :: string , std :: string , cppcheck :: stricmp > & variables@var1583 , const std :: string & additionalIncludeDirectories@var1584 , const std :: vector < std :: string > & fileFilters@var1585 ) ;
116: bool importBcb6Prj ( const std :: string & projectFilename@var1586 ) ;
117:
118: static void printError ( const std :: string & message@var1587 ) ;
119:
120: void setRelativePaths ( const std :: string & filename@var1588 ) ;
121:
122: std :: string mPath@var1589 ;
123: std :: set < std :: string > mAllVSConfigs@var1590 ;
124: } ;
125:
126:
127: namespace CppcheckXml {
128: const char ProjectElementName@var1591 [ 8 ] = "project" ;
129: const char ProjectVersionAttrib@var1592 [ 8 ] = "version" ;
130: const char ProjectFileVersion@var1593 [ 2 ] = "1" ;
131: const char BuildDirElementName@var1594 [ 9 ] = "builddir" ;
132: const char ImportProjectElementName@var1595 [ 14 ] = "importproject" ;
133: const char AnalyzeAllVsConfigsElementName@var1596 [ 23 ] = "analyze-all-vs-configs" ;
134: const char Parser@var1597 [ 7 ] = "parser" ;
135: const char BugHunting@var1598 [ 12 ] = "bug-hunting" ;
136: const char IncludeDirElementName@var1599 [ 11 ] = "includedir" ;
137: const char DirElementName@var1600 [ 4 ] = "dir" ;
138: const char DirNameAttrib@var1601 [ 5 ] = "name" ;
139: const char DefinesElementName@var1602 [ 8 ] = "defines" ;
140: const char DefineName@var1603 [ 7 ] = "define" ;
141: const char DefineNameAttrib@var1604 [ 5 ] = "name" ;
142: const char UndefinesElementName@var1605 [ 10 ] = "undefines" ;
143: const char UndefineName@var1606 [ 9 ] = "undefine" ;
144: const char PathsElementName@var1607 [ 6 ] = "paths" ;
145: const char PathName@var1608 [ 4 ] = "dir" ;
146: const char PathNameAttrib@var1609 [ 5 ] = "name" ;
147: const char RootPathName@var1610 [ 5 ] = "root" ;
148: const char RootPathNameAttrib@var1611 [ 5 ] = "name" ;
149: const char IgnoreElementName@var1612 [ 7 ] = "ignore" ;
150: const char IgnorePathName@var1613 [ 5 ] = "path" ;
151: const char IgnorePathNameAttrib@var1614 [ 5 ] = "name" ;
152: const char ExcludeElementName@var1615 [ 8 ] = "exclude" ;
153: const char ExcludePathName@var1616 [ 5 ] = "path" ;
154: const char ExcludePathNameAttrib@var1617 [ 5 ] = "name" ;
155: const char FunctionContracts@var1618 [ 19 ] = "function-contracts" ;
156: const char VariableContractsElementName@var1619 [ 19 ] = "variable-contracts" ;
157: const char LibrariesElementName@var1620 [ 10 ] = "libraries" ;
158: const char LibraryElementName@var1621 [ 8 ] = "library" ;
159: const char PlatformElementName@var1622 [ 9 ] = "platform" ;
160: const char SuppressionsElementName@var1623 [ 13 ] = "suppressions" ;
161: const char SuppressionElementName@var1624 [ 12 ] = "suppression" ;
162: const char AddonElementName@var1625 [ 6 ] = "addon" ;
163: const char AddonsElementName@var1626 [ 7 ] = "addons" ;
164: const char ToolElementName@var1627 [ 5 ] = "tool" ;
165: const char ToolsElementName@var1628 [ 6 ] = "tools" ;
166: const char TagsElementName@var1629 [ 5 ] = "tags" ;
167: const char TagElementName@var1630 [ 4 ] = "tag" ;
168: const char TagWarningsElementName@var1631 [ 13 ] = "tag-warnings" ;
169: const char TagAttributeName@var1632 [ 4 ] = "tag" ;
170: const char WarningElementName@var1633 [ 8 ] = "warning" ;
171: const char HashAttributeName@var1634 [ 5 ] = "hash" ;
172: const char CheckHeadersElementName@var1635 [ 14 ] = "check-headers" ;
173: const char CheckUnusedTemplatesElementName@var1636 [ 23 ] = "check-unused-templates" ;
174: const char MaxCtuDepthElementName@var1637 [ 14 ] = "max-ctu-depth" ;
175: const char MaxTemplateRecursionElementName@var1638 [ 23 ] = "max-template-recursion" ;
176: const char CheckUnknownFunctionReturn@var1639 [ 37 ] = "check-unknown-function-return-values" ;
177: const char ClangTidy@var1640 [ 11 ] = "clang-tidy" ;
178: const char Name@var1641 [ 5 ] = "name" ;
179: const char VSConfigurationElementName@var1642 [ 18 ] = "vs-configurations" ;
180: const char VSConfigurationName@var1643 [ 7 ] = "config" ;
181: }

##file cppcheck-2.8/lib/timer.h

1:
|
28:
29: enum class SHOWTIME_MODES {
30: SHOWTIME_NONE = 0 ,
31: SHOWTIME_FILE ,
32: SHOWTIME_SUMMARY ,
33: SHOWTIME_TOP5
34: } ;
35:
36: class TimerResultsIntf {
37: public:
38: virtual ~ TimerResultsIntf ( ) { }
39:
40: virtual void addResults ( const std :: string & str@var1644 , std :: clock_t clocks@var1645 ) = 0 ;
41: } ;
42:
43: struct TimerResultsData {
44: std :: clock_t mClocks@var1646 ;
45: long mNumberOfResults@var1647 ;
46:
47: TimerResultsData ( )
48: : mClocks@var1646 ( 0 )
49: , mNumberOfResults@var1647 ( 0 ) { }
50:
51: double seconds ( ) const {
52: const double ret@var1648 =@expr1073746959 (@expr1073746960 double ) (@expr1073746961 (@expr1073746962 unsigned long ) mClocks@var1646 ) /@expr1073746963 (@expr1073746964 double ) CLOCKS_PER_SEC@expr1073746958 ;
53: return ret@var1648 ;
54: }
55: } ;
56:
57: class TimerResults : public TimerResultsIntf {
58: public:
59: TimerResults ( ) { }
60:
61: void showResults ( SHOWTIME_MODES mode@var1649 ) const ;
62: void addResults ( const std :: string & str@var1650 , std :: clock_t clocks@var1651 ) override ;
63:
64: private:
65: std :: map < std :: string , TimerResultsData > mResults@var1652 ;
66: } ;
67:
68: class Timer {
69: public:
70: Timer ( const std :: string & str@var1653 , SHOWTIME_MODES showtimeMode@var1654 , TimerResultsIntf * timerResults@var1655 = nullptr ) ;
71: ~ Timer ( ) ;
72: void stop ( ) ;
73:
74: private:
75: Timer ( const Timer & other@var1656 ) ;
76: Timer & operator= ( const Timer & ) ;
77:
78: const std :: string mStr@var1657 ;
79: TimerResultsIntf * mTimerResults@var1658 ;
80: std :: clock_t mStart@var1659 ;
81: const SHOWTIME_MODES mShowTimeMode@var1660 ;
82: bool mStopped@var1661 ;
83: } ;

##file cppcheck-2.8/lib/settings.h

1:
|
40:
41: namespace ValueFlow {
42: class Value ;
43: }
44:
|
47:
48: class SimpleEnableGroup<Severity::SeverityType> ; class SimpleEnableGroup<Certainty::CertaintyLevel> ; class SimpleEnableGroup<Checks::CheckList> ;
49:
|
89:
90: class Settings : public cppcheck :: Platform {
91: private:
92:
93:
94: static std :: atomic < bool > mTerminated@var1662 ;
95:
96: public:
97: Settings ( ) ;
98:
99: void loadCppcheckCfg ( ) ;
100:
101:
102: std :: list < std :: string > addons@var1663 ;
103:
104:
105: std :: string addonPython@var1664 ;
106:
107:
108: std :: vector < std :: string > basePaths@var1665 ;
109:
110:
111: std :: string buildDir@var1666 ;
112:
113:
114: bool checkAllConfigurations@var1667 ;
115:
116:
117: bool checkConfiguration@var1668 ;
118:
|
121:
122: bool checkHeaders@var1669 ;
123:
124:
125: bool checkLibrary@var1670 ;
126:
127:
128: std :: set < std :: string > checkUnknownFunctionReturn@var1671 ;
129:
130:
131: bool checkUnusedTemplates@var1672 ;
132:
133:
134: bool clang@var1673 ;
135:
136:
137: std :: string clangExecutable@var1674 ;
138:
139:
140: bool clangTidy@var1675 ;
141:
142:
143: std :: set < std :: string > configExcludePaths@var1676 ;
144:
145:
146: std :: string cppcheckCfgProductName@var1677 ;
147:
148:
149: std :: string cppcheckCfgAbout@var1678 ;
150:
151:
152: bool daca@var1679 ;
153:
154:
155: bool debugnormal@var1680 ;
156:
157:
158: bool debugSimplified@var1681 ;
159:
160:
161: bool debugtemplate@var1682 ;
162:
163:
164: bool debugwarnings@var1683 ;
165:
166:
167: bool dump@var1684 ;
168: std :: string dumpFile@var1685 ;
169:
170: enum Language {
171: None , C , CPP
172: } ;
173:
174:
175: Language enforcedLang@var1686 ;
176:
177:
178: bool exceptionHandling@var1687 ;
179:
180:
181: std :: string exename@var1688 ;
182:
183:
184:
185: int exitCode@var1689 ;
186:
187:
188: std :: vector < std :: string > fileFilters@var1690 ;
189:
190:
191: bool force@var1691 ;
192:
193:
194:
195: std :: list < std :: string > includePaths@var1692 ;
196:
197:
198: bool inlineSuppressions@var1693 ;
199:
200:
201:
202: unsigned int jobs@var1694 ;
203:
|
206:
207: bool jointSuppressionReport@var1695 ;
208:
209:
210: std :: list < std :: string > libraries@var1696 ;
211:
212:
213: Library library@var1697 ;
214:
215:
216:
217: int loadAverage@var1698 ;
218:
|
221:
222: int maxConfigs@var1699 ;
223:
224:
225: int maxCtuDepth@var1700 ;
226:
227:
228: int maxTemplateRecursion@var1701 ;
229:
230:
231: Suppressions nofail@var1702 ;
232:
233:
234: Suppressions nomsg@var1703 ;
235:
236:
237: std :: string outputFile@var1704 ;
238:
239:
240: std :: string plistOutput@var1705 ;
241:
242:
243: bool preprocessOnly@var1706 ;
244:
245: ImportProject project@var1707 ;
246:
247:
248: bool quiet@var1708 ;
249:
250:
251: bool relativePaths@var1709 ;
252:
253:
254: bool reportProgress@var1710 ;
255:
256:
257: class Rule {
258: public:
259: Rule ( )
260: : tokenlist@var1711 ( "simple" )
261: , id@var1713 ( "rule" )
262: , severity@var1715 ( Severity :: style ) {
263: }
264:
265: std :: string tokenlist@var1711 ;
266: std :: string pattern@var1712 ;
267: std :: string id@var1713 ;
268: std :: string summary@var1714 ;
269: Severity :: SeverityType severity@var1715 ;
270: } ;
271:
|
274:
275: std :: list < Rule > rules@var1716 ;
276:
277:
278: class SafeChecks {
279: public:
280: SafeChecks ( ) : classes@var1722 ( false ) , externalFunctions@var1723 ( false ) , internalFunctions@var1724 ( false ) , externalVariables@var1725 ( false ) { }
281:
282: static const char XmlRootName@var1717 [ ] ;
283: static const char XmlClasses@var1718 [ ] ;
284: static const char XmlExternalFunctions@var1719 [ ] ;
285: static const char XmlInternalFunctions@var1720 [ ] ;
286: static const char XmlExternalVariables@var1721 [ ] ;
287:
288: void clear ( ) {
289: classes@var1722 =@expr1073746965 externalFunctions@var1723 =@expr1073746966 internalFunctions@var1724 =@expr1073746967 externalVariables@var1725 =@expr1073746968 false ;
290: }
291:
|
297:
298: bool classes@var1722 ;
299:
|
304:
305: bool externalFunctions@var1723 ;
306:
|
310:
311: bool internalFunctions@var1724 ;
312:
|
316:
317: bool externalVariables@var1725 ;
318: } ;
319:
320: SafeChecks safeChecks@var1726 ;
321:
322: SimpleEnableGroup<Severity::SeverityType> severity@var1727 ;
323: SimpleEnableGroup<Certainty::CertaintyLevel> certainty@var1728 ;
324: SimpleEnableGroup<Checks::CheckList> checks@var1729 ;
325:
326:
327: SHOWTIME_MODES showtime@var1730 ;
328:
329:
330: Standards standards@var1731 ;
331:
332:
333:
334: std :: string templateFormat@var1732 ;
335:
336:
337:
338: std :: string templateLocation@var1733 ;
339:
340:
341: std :: string userDefines@var1734 ;
342:
343:
344: std :: set < std :: string > userUndefs@var1735 ;
345:
346:
347: std :: list < std :: string > userIncludes@var1736 ;
348:
349:
350: bool verbose@var1737 ;
351:
352:
353: bool xml@var1738 ;
354:
355:
356: int xml_version@var1739 ;
357:
|
361:
362: bool configurationExcluded ( const std :: string & file@var1740 ) const {
363: for (@expr1073746969 const std ::@expr1073746970 string &@expr1073746971 configExcludePath@var1741 :@expr1073746972 configExcludePaths@var1676 ) {
364: if (@expr1073746973 file@var1740 .@expr1073746974 length (@expr1073746975 ) >=@expr1073746976 configExcludePath@var1741 .@expr5153 length (@expr5154 ) &&@expr1073746979 file@var1740 .@expr1073746980 compare (@expr1073746981 0 , configExcludePath@var1741 .@expr5153 length (@expr5154 ) , configExcludePath@var1741 ) ==@expr1073746984 0 ) {
365: return true ;
366: }
367: }
368: return false ;
369: }
370:
|
376:
377: std :: string addEnabled ( const std :: string & str@var1742 ) ;
378:
|
382:
383: bool isEnabled ( const ValueFlow :: Value * value@var1743 , bool inconclusiveCheck@var1744 = false ) const ;
384:
385:
386: bool posix ( ) const {
387: return std ::@expr1073746985 find (@expr1073746986 libraries@var1696 .@expr1073746987 begin (@expr1073746988 ) , libraries@var1696 .@expr5165 end (@expr5166 ) , "posix" ) !=@expr1073746991 libraries@var1696 .@expr5165 end (@expr5166 ) ;
388: }
389:
390:
391: static void terminate ( bool t@var1745 = true ) {
392: Settings ::@expr1073746994 mTerminated@var1662 =@expr1073746995 t@var1745 ;
393: }
394:
395:
396: static bool terminated ( ) {
397: return Settings ::@expr1073746996 mTerminated@var1662 ;
398: }
399:
400: std :: set < std :: string > summaryReturn@var1746 ;
401:
402: void loadSummaries ( ) ;
403: } ;

##file cppcheck-2.8/lib/summaries.h

1:
|
28:
29: class Tokenizer ;
30:
31: namespace Summaries {
32: std :: string create ( const Tokenizer * tokenizer@var1747 , const std :: string & cfg@var1748 ) ;
33: void loadReturn ( const std :: string & buildDir@var1749 , std :: set < std :: string > & summaryReturn@var1750 ) ;
34: }

##file cppcheck-2.8/lib/symboldatabase.h

1:
|
39:
40: namespace cppcheck {
41: class Platform ;
42: }
43:
44: class ErrorLogger ;
45: class Function ;
46: class Scope ;
47: class Settings ;
48: class SymbolDatabase ;
49: class Tokenizer ;
50: class ValueType ;
51:
|
54:
55: enum class AccessControl { Public , Protected , Private , Global , Namespace , Argument , Local , Throw } ;
56:
|
59:
60: struct Dimension {
61: Dimension ( ) : tok@var1751 ( nullptr ) , num@var1752 ( 0 ) , known@var1753 ( true ) { }
62:
63: const Token * tok@var1751 ;
64: long long num@var1752 ;
65: bool known@var1753 ;
66: } ;
67:
68:
69: class Type {
70: public:
71: const Token * classDef@var1754 ;
72: const Scope * classScope@var1755 ;
73: const Scope * enclosingScope@var1756 ;
74: enum class NeedInitialization {
75: Unknown , True , False
76: } ; enum NeedInitialization needInitialization@var1757 ;
77:
78: class BaseInfo {
79: public:
80: BaseInfo ( ) :
81: type@var1759 ( nullptr ) , nameTok@var1760 ( nullptr ) , access@var1761 ( AccessControl :: Public ) , isVirtual@var1762 ( false ) { }
82:
83: std :: string name@var1758 ;
84: const Type * type@var1759 ;
85: const Token * nameTok@var1760 ;
86: AccessControl access@var1761 ;
87: bool isVirtual@var1762 ;
88:
89: bool operator< ( const BaseInfo & rhs@var1763 ) const {
90: return this@expr1073746997 .@expr1073746998 type@var1759 <@expr1073746999 rhs@var1763 .@expr1073747000 type@var1764 ;
91: }
92: } ;
93:
94: struct FriendInfo {
95: FriendInfo ( ) :
96: nameStart@var1765 ( nullptr ) , nameEnd@var1766 ( nullptr ) , type@var1767 ( nullptr ) { }
97:
98: const Token * nameStart@var1765 ;
99: const Token * nameEnd@var1766 ;
100: const Type * type@var1767 ;
101: } ;
102:
103: std :: vector < BaseInfo > derivedFrom@var1768 ;
104: std :: vector < FriendInfo > friendList@var1769 ;
105:
106: const Token * typeStart@var1770 ;
107: const Token * typeEnd@var1771 ;
108: long long sizeOf@var1772 ;
109:
110: Type ( const Token * classDef_@var1773 = nullptr , const Scope * classScope_@var1774 = nullptr , const Scope * enclosingScope_@var1775 = nullptr ) :
111: classDef@var1754 ( classDef_@var1773 ) ,
112: classScope@var1755 ( classScope_@var1774 ) ,
113: enclosingScope@var1756 ( enclosingScope_@var1775 ) ,
114: needInitialization@var1757 ( NeedInitialization :: Unknown ) ,
115: typeStart@var1770 ( nullptr ) ,
116: typeEnd@var1771 ( nullptr ) ,
117: sizeOf@var1772 ( 0 ) {
118: if (@expr1073747001 classDef_@var1773 &&@expr1073747002 classDef_@var1773 .@expr5179 str (@expr5180 ) ==@expr1073747005 "enum" ) {
119: needInitialization@var1757 =@expr1073747006 NeedInitialization ::@expr1073747007 True ; }
120: else { if (@expr1073747008 classDef_@var1773 &&@expr1073747009 classDef_@var1773 .@expr5179 str (@expr5180 ) ==@expr1073747012 "using" ) {
121: typeStart@var1770 =@expr1073747013 classDef@var1754 .@expr1073747014 tokAt (@expr1073747015 3 ) ;
122: typeEnd@var1771 =@expr1073747016 typeStart@var1770 ;
123: while (@expr1073747017 typeEnd@var1771 .@expr5194 next (@expr5195 ) &&@expr1073747020 typeEnd@var1771 .@expr5194 next (@expr5195 ) .@expr1073747023 str (@expr1073747024 ) !=@expr1073747025 ";" ) {
124: typeEnd@var1771 =@expr1073747026 typeEnd@var1771 .@expr5194 next (@expr5195 ) ; }
125: } }
126: }
127:
128: const std :: string & name ( ) const ;
129:
130: const std :: string & type ( ) const {
131: return classDef@var1754 ?@expr1073747029 classDef@var1754 .@expr1073747030 str (@expr1073747031 ) :@expr1073747032 emptyString@var1 ;
132: }
133:
134: bool isClassType ( ) const ;
135: bool isEnumType ( ) const ;
136: bool isStructType ( ) const ;
137: bool isUnionType ( ) const ;
138:
139: bool isTypeAlias ( ) const {
140: return classDef@var1754 &&@expr1073747033 classDef@var1754 .@expr1073747034 str (@expr1073747035 ) ==@expr1073747036 "using" ;
141: }
142:
143: const Token * initBaseInfo ( const Token * tok@var1776 , const Token * tok1@var1777 ) ;
144:
145: const Function * getFunction ( const std :: string & funcName@var1778 ) const ;
146:
|
151:
152: bool hasCircularDependencies ( std :: set < BaseInfo > * ancestors@var1779 = nullptr ) const ;
153:
|
158:
159: bool findDependency ( const Type * ancestor@var1780 ) const ;
160:
161: bool isDerivedFrom ( const std :: string & ancestor@var1781 ) const ;
162: } ;
163:
164: class Enumerator {
165: public:
166: explicit Enumerator ( const Scope * scope_@var1782 ) : scope@var1783 ( scope_@var1782 ) , name@var1784 ( nullptr ) , value@var1785 ( 0 ) , start@var1786 ( nullptr ) , end@var1787 ( nullptr ) , value_known@var1788 ( false ) { }
167: const Scope * scope@var1783 ;
168: const Token * name@var1784 ;
169: long long value@var1785 ;
170: const Token * start@var1786 ;
171: const Token * end@var1787 ;
172: bool value_known@var1788 ;
173: } ;
174:
175:
176: class Variable {
177:
178: enum Anonymous4 {
179: fIsMutable = ( 1 << 0 ) ,
180: fIsStatic = ( 1 << 1 ) ,
181: fIsConst = ( 1 << 2 ) ,
182: fIsExtern = ( 1 << 3 ) ,
183: fIsClass = ( 1 << 4 ) ,
184: fIsArray = ( 1 << 5 ) ,
185: fIsPointer = ( 1 << 6 ) ,
186: fIsReference = ( 1 << 7 ) ,
187: fIsRValueRef = ( 1 << 8 ) ,
188: fHasDefault = ( 1 << 9 ) ,
189: fIsStlType = ( 1 << 10 ) ,
190: fIsStlString = ( 1 << 11 ) ,
191: fIsFloatType = ( 1 << 12 ) ,
192: fIsVolatile = ( 1 << 13 ) ,
193: fIsSmartPointer = ( 1 << 14 ) ,
194: fIsMaybeUnused = ( 1 << 15 ) ,
195: fIsInit = ( 1 << 16 ) ,
196: } ;
197:
|
202:
203: bool getFlag ( unsigned int flag_@var1789 ) const {
204: return (@expr5213 (@expr5213 mFlags@var1825 &@expr1073747039 flag_@var1789 ) !=@expr1073747040 0 ) ;
205: }
206:
|
211:
212: void setFlag ( unsigned int flag_@var1790 , bool state_@var1791 ) {
213: mFlags@var1825 =@expr1073747041 state_@var1791 ?@expr1073747042 mFlags@var1825 |@expr1073747043 flag_@var1790 :@expr1073747044 mFlags@var1825 &@expr1073747045 ~@expr1073747046 flag_@var1790 ;
214: }
215:
|
221:
222: bool arrayDimensions ( const Settings * settings@var1792 , bool * isContainer@var1793 ) ;
223:
224: public:
225: Variable ( const Token * name_@var1794 , const Token * start_@var1795 , const Token * end_@var1796 ,
226: int index_@var1797 , AccessControl access_@var1798 , const Type * type_@var1799 ,
227: const Scope * scope_@var1800 , const Settings * settings@var1801 )
228: : mNameToken@var1820 ( name_@var1794 ) ,
229: mTypeStartToken@var1821 ( start_@var1795 ) ,
230: mTypeEndToken@var1822 ( end_@var1796 ) ,
231: mIndex@var1823 ( index_@var1797 ) ,
232: mAccess@var1824 ( access_@var1798 ) ,
233: mFlags@var1825 ( 0 ) ,
234: mType@var1826 ( type_@var1799 ) ,
235: mScope@var1827 ( scope_@var1800 ) ,
236: mValueType@var1828 ( nullptr ) {
237: evaluate (@expr1073747047 settings@var1801 ) ;
238: }
239:
240: Variable ( const Token * name_@var1802 , const std :: string & clangType@var1803 , const Token * typeStart@var1804 ,
241: const Token * typeEnd@var1805 , int index_@var1806 , AccessControl access_@var1807 ,
242: const Type * type_@var1808 , const Scope * scope_@var1809 ) ;
243:
244: Variable ( const Variable & var@var1810 , const Scope * scope@var1811 ) ;
245:
246: Variable ( const Variable & var@var1812 ) ;
247:
248: ~ Variable ( ) ;
249:
250: Variable & operator= ( const Variable & var@var1813 ) ;
251:
|
255:
256: const Token * nameToken ( ) const {
257: return mNameToken@var1820 ;
258: }
259:
|
267:
268: const Token * typeStartToken ( ) const {
269: return mTypeStartToken@var1821 ;
270: }
271:
|
279:
280: const Token * typeEndToken ( ) const {
281: return mTypeEndToken@var1822 ;
282: }
283:
|
290:
291: const Token * declEndToken ( ) const ;
292:
|
296:
297: const std :: string & name ( ) const {
298:
299: if (@expr1073747048 mNameToken@var1820 ) {
300: return mNameToken@var1820 .@expr1073747049 str (@expr1073747050 ) ; }
301:
302: return emptyString@var1 ;
303: }
304:
|
308:
309: int declarationId ( ) const {
310:
311: if (@expr1073747051 mNameToken@var1820 ) {
312: return mNameToken@var1820 .@expr1073747052 varId (@expr1073747053 ) ; }
313:
314: return 0 ;
315: }
316:
|
320:
321: int index ( ) const {
322: return mIndex@var1823 ;
323: }
324:
|
328:
329: bool isPublic ( ) const {
330: return mAccess@var1824 ==@expr1073747054 AccessControl ::@expr1073747055 Public ;
331: }
332:
|
336:
337: bool isProtected ( ) const {
338: return mAccess@var1824 ==@expr1073747056 AccessControl ::@expr1073747057 Protected ;
339: }
340:
|
344:
345: bool isPrivate ( ) const {
346: return mAccess@var1824 ==@expr1073747058 AccessControl ::@expr1073747059 Private ;
347: }
348:
|
352:
353: bool isGlobal ( ) const {
354: return mAccess@var1824 ==@expr1073747060 AccessControl ::@expr1073747061 Global ;
355: }
356:
|
360:
361: bool isNamespace ( ) const {
362: return mAccess@var1824 ==@expr1073747062 AccessControl ::@expr1073747063 Namespace ;
363: }
364:
|
368:
369: bool isArgument ( ) const {
370: return mAccess@var1824 ==@expr1073747064 AccessControl ::@expr1073747065 Argument ;
371: }
372:
|
376:
377: bool isLocal ( ) const {
378: return (@expr1073747067 mAccess@var1824 ==@expr1073747068 AccessControl ::@expr1073747069 Local@expr1073747066 ) &&@expr1073747070 !@expr1073747071 isExtern (@expr1073747072 ) ;
379: }
380:
|
384:
385: bool isMutable ( ) const {
386: return getFlag (@expr1073747073 fIsMutable ) ;
387: }
388:
|
392:
393: bool isVolatile ( ) const {
394: return getFlag (@expr1073747074 fIsVolatile ) ;
395: }
396:
|
400:
401: bool isStatic ( ) const {
402: return getFlag (@expr1073747075 fIsStatic ) ;
403: }
404:
|
408:
409: bool isExtern ( ) const {
410: return getFlag (@expr1073747076 fIsExtern ) ;
411: }
412:
|
416:
417: bool isConst ( ) const {
418: return getFlag (@expr1073747077 fIsConst ) ;
419: }
420:
|
424:
425: bool isThrow ( ) const {
426: return mAccess@var1824 ==@expr1073747078 AccessControl ::@expr1073747079 Throw ;
427: }
428:
|
432:
433: bool isClass ( ) const {
434: return getFlag (@expr1073747080 fIsClass ) ;
435: }
436:
|
440:
441: bool isArray ( ) const {
442: return getFlag (@expr1073747081 fIsArray ) &&@expr1073747082 !@expr1073747083 getFlag (@expr1073747084 fIsPointer ) ;
443: }
444:
|
448:
449: bool isPointer ( ) const {
450: return getFlag (@expr1073747085 fIsPointer ) ;
451: }
452:
|
456:
457: bool isPointerToArray ( ) const {
458: return isPointer (@expr1073747086 ) &&@expr1073747087 getFlag (@expr1073747088 fIsArray ) ;
459: }
460:
|
464:
465: bool isPointerArray ( ) const ;
466:
|
470:
471: bool isArrayOrPointer ( ) const {
472: return getFlag (@expr1073747089 fIsArray ) ||@expr1073747090 getFlag (@expr1073747091 fIsPointer ) ;
473: }
474:
|
478:
479: bool isReference ( ) const {
480: return getFlag (@expr1073747092 fIsReference ) ;
481: }
482:
|
486:
487: bool isRValueReference ( ) const {
488: return getFlag (@expr1073747093 fIsRValueRef ) ;
489: }
490:
|
494:
495: bool isUnsigned ( ) const ;
496:
|
500:
501: bool hasDefault ( ) const {
502: return getFlag (@expr1073747094 fHasDefault ) ;
503: }
504:
|
508:
509: bool isInit ( ) const {
510: return getFlag (@expr1073747095 fIsInit ) ;
511: }
512:
|
516:
517: const Type * type ( ) const {
518: return mType@var1826 ;
519: }
520:
|
524:
525: const Scope * typeScope ( ) const {
526: return mType@var1826 ?@expr1073747096 mType@var1826 .@expr1073747097 classScope@var1831 :@expr1073747098 nullptr ;
527: }
528:
|
532:
533: const Scope * scope ( ) const {
534: return mScope@var1827 ;
535: }
536:
|
540:
541: const std :: vector < Dimension > & dimensions ( ) const {
542: return mDimensions@var1829 ;
543: }
544:
|
548:
549: long long dimension ( int index_@var1814 ) const {
550: return mDimensions@var1829 [@expr1073747099 index_@var1814 ] .@expr1073747100 num@var3601 ;
551: }
552:
|
556:
557: bool dimensionKnown ( int index_@var1815 ) const {
558: return mDimensions@var1829 [@expr1073747101 index_@var1815 ] .@expr1073747102 known@var3602 ;
559: }
560:
|
568:
569: bool isStlType ( ) const {
570: return getFlag (@expr1073747103 fIsStlType ) ;
571: }
572:
|
580:
581: bool isStlStringType ( ) const {
582: return getFlag (@expr1073747104 fIsStlString ) ;
583: }
584:
585: bool isSmartPointer ( ) const {
586: return getFlag (@expr1073747105 fIsSmartPointer ) ;
587: }
588:
589: const Type * smartPointerType ( ) const ;
590:
|
600:
601: bool isStlType ( const std :: string & stlType@var1816 ) const {
602: return isStlType (@expr1073747106 ) &&@expr1073747107 stlType@var1816 ==@expr1073747108 mTypeStartToken@var1821 .@expr1073747109 strAt (@expr1073747110 2 ) ;
603: }
604:
|
614:
615: bool isStlType ( const std :: set < std :: string > & stlTypes@var1817 ) const {
616: return isStlType (@expr1073747111 ) &&@expr1073747112 stlTypes@var1817 .@expr1073747113 find (@expr1073747114 mTypeStartToken@var1821 .@expr1073747115 strAt (@expr1073747116 2 ) ) !=@expr1073747117 stlTypes@var1817 .@expr1073747118 end (@expr1073747119 ) ;
617: }
618:
|
622:
623: bool isFloatingType ( ) const {
624: return getFlag (@expr1073747120 fIsFloatType ) ;
625: }
626:
|
630:
631: bool isEnumType ( ) const {
632: return type (@expr5297 ) &&@expr1073747122 type (@expr5297 ) .@expr1073747124 isEnumType (@expr1073747125 ) ;
633: }
634:
635: bool isMaybeUnused ( ) const {
636: return getFlag (@expr1073747126 fIsMaybeUnused ) ;
637: }
638:
639: const ValueType * valueType ( ) const {
640: return mValueType@var1828 ;
641: }
642:
643: void setValueType ( const ValueType & valueType@var1818 ) ;
644:
645: AccessControl accessControl ( ) const {
646: return mAccess@var1824 ;
647: }
648:
649: std :: string getTypeName ( ) const ;
650:
651: private:
652:
653: friend class SymbolDatabase ;
654:
|
658:
659: void type ( const Type * t@var1819 ) {
660: mType@var1826 =@expr1073747127 t@var1819 ;
661: }
662:
663:
664: const Token * mNameToken@var1820 ;
665:
666:
667: const Token * mTypeStartToken@var1821 ;
668:
669:
670: const Token * mTypeEndToken@var1822 ;
671:
672:
673: int mIndex@var1823 ;
674:
675:
676: AccessControl mAccess@var1824 ;
677:
678:
679: unsigned int mFlags@var1825 ;
680:
681:
682: const Type * mType@var1826 ;
683:
684:
685: const Scope * mScope@var1827 ;
686:
687: ValueType * mValueType@var1828 ;
688:
689:
690: std :: vector < Dimension > mDimensions@var1829 ;
691:
692:
693: void evaluate ( const Settings * settings@var1830 ) ;
694: } ;
695:
696: class Function {
697:
698: friend class SymbolDatabase ;
699:
700:
701: enum Anonymous5 {
702: fHasBody = ( 1 << 0 ) ,
703: fIsInline = ( 1 << 1 ) ,
704: fIsConst = ( 1 << 2 ) ,
705: fHasVirtualSpecifier = ( 1 << 3 ) ,
706: fIsPure = ( 1 << 4 ) ,
707: fIsStatic = ( 1 << 5 ) ,
708: fIsStaticLocal = ( 1 << 6 ) ,
709: fIsExtern = ( 1 << 7 ) ,
710: fIsFriend = ( 1 << 8 ) ,
711: fIsExplicit = ( 1 << 9 ) ,
712: fIsDefault = ( 1 << 10 ) ,
713: fIsDelete = ( 1 << 11 ) ,
714: fHasOverrideSpecifier = ( 1 << 12 ) ,
715: fHasFinalSpecifier = ( 1 << 13 ) ,
716: fIsNoExcept = ( 1 << 14 ) ,
717: fIsThrow = ( 1 << 15 ) ,
718: fIsOperator = ( 1 << 16 ) ,
719: fHasLvalRefQual = ( 1 << 17 ) ,
720: fHasRvalRefQual = ( 1 << 18 ) ,
721: fIsVariadic = ( 1 << 19 ) ,
722: fIsVolatile = ( 1 << 20 ) ,
723: fHasTrailingReturnType = ( 1 << 21 ) ,
724: fIsEscapeFunction = ( 1 << 22 ) ,
725: fIsInlineKeyword = ( 1 << 23 ) ,
726: fIsConstexpr = ( 1 << 24 ) ,
727: } ;
728:
|
733:
734: bool getFlag ( unsigned int flag@var1832 ) const {
735: return (@expr5304 (@expr5304 mFlags@var1881 &@expr1073747130 flag@var1832 ) !=@expr1073747131 0 ) ;
736: }
737:
|
742:
743: void setFlag ( unsigned int flag@var1833 , bool state@var1834 ) {
744: mFlags@var1881 =@expr1073747132 state@var1834 ?@expr1073747133 mFlags@var1881 |@expr1073747134 flag@var1833 :@expr1073747135 mFlags@var1881 &@expr1073747136 ~@expr1073747137 flag@var1833 ;
745: }
746:
747: public:
748: enum Type { eConstructor , eCopyConstructor , eMoveConstructor , eOperatorEqual , eDestructor , eFunction , eLambda } ;
749:
750: Function ( const Tokenizer * mTokenizer@var1835 , const Token * tok@var1836 , const Scope * scope@var1837 , const Token * tokDef@var1838 , const Token * tokArgDef@var1839 ) ;
751: Function ( const Token * tokenDef@var1840 , const std :: string & clangType@var1841 ) ;
752:
753: const std :: string & name ( ) const {
754: return tokenDef@var1851 .@expr1073747138 str (@expr1073747139 ) ;
755: }
756:
757: std :: string fullName ( ) const ;
758:
759: int argCount ( ) const {
760: return argumentList@var1859 .@expr1073747140 size (@expr1073747141 ) ;
761: }
762: int minArgCount ( ) const {
763: return argumentList@var1859 .@expr1073747142 size (@expr1073747143 ) -@expr1073747144 initArgCount@var1860 ;
764: }
765: const Variable * getArgumentVar ( int num@var1842 ) const ;
766: int initializedArgCount ( ) const {
767: return initArgCount@var1860 ;
768: }
769: void addArguments ( const SymbolDatabase * symbolDatabase@var1843 , const Scope * scope@var1844 ) ;
770:
771:
772: bool isImplicitlyVirtual ( bool defaultVal@var1845 = false ) const ;
773:
774: std :: vector < const Function * > getOverloadedFunctions ( ) const ;
775:
776:
777: const Function * getOverriddenFunction ( bool * foundAllBaseClasses@var1846 = nullptr ) const ;
778:
779: bool isLambda ( ) const {
780: return type@var1861 ==@expr1073747145 eLambda ;
781: }
782:
783: bool isConstructor ( ) const {
784: return type@var1861 ==@expr1073747146 eConstructor ||@expr1073747147
785: type@var1861 ==@expr1073747148 eCopyConstructor ||@expr1073747149
786: type@var1861 ==@expr1073747150 eMoveConstructor ;
787: }
788:
789: bool isDestructor ( ) const {
790: return type@var1861 ==@expr1073747151 eDestructor ;
791: }
792: bool isAttributeConstructor ( ) const {
793: return tokenDef@var1851 .@expr1073747152 isAttributeConstructor (@expr1073747153 ) ;
794: }
795: bool isAttributeDestructor ( ) const {
796: return tokenDef@var1851 .@expr1073747154 isAttributeDestructor (@expr1073747155 ) ;
797: }
798: bool isAttributePure ( ) const {
799: return tokenDef@var1851 .@expr1073747156 isAttributePure (@expr1073747157 ) ;
800: }
801: bool isAttributeConst ( ) const {
802: return tokenDef@var1851 .@expr1073747158 isAttributeConst (@expr1073747159 ) ;
803: }
804: bool isAttributeNoreturn ( ) const {
805: return tokenDef@var1851 .@expr1073747160 isAttributeNoreturn (@expr1073747161 ) ;
806: }
807: bool isAttributeNothrow ( ) const {
808: return tokenDef@var1851 .@expr1073747162 isAttributeNothrow (@expr1073747163 ) ;
809: }
810: bool isAttributeNodiscard ( ) const {
811: return tokenDef@var1851 .@expr1073747164 isAttributeNodiscard (@expr1073747165 ) ;
812: }
813:
814: bool hasBody ( ) const {
815: return getFlag (@expr1073747166 fHasBody ) ;
816: }
817: bool isInline ( ) const {
818: return getFlag (@expr1073747167 fIsInline ) ;
819: }
820: bool isConst ( ) const {
821: return getFlag (@expr1073747168 fIsConst ) ;
822: }
823: bool hasVirtualSpecifier ( ) const {
824: return getFlag (@expr1073747169 fHasVirtualSpecifier ) ;
825: }
826: bool isPure ( ) const {
827: return getFlag (@expr1073747170 fIsPure ) ;
828: }
829: bool isStatic ( ) const {
830: return getFlag (@expr1073747171 fIsStatic ) ;
831: }
832: bool isStaticLocal ( ) const {
833: return getFlag (@expr1073747172 fIsStaticLocal ) ;
834: }
835: bool isExtern ( ) const {
836: return getFlag (@expr1073747173 fIsExtern ) ;
837: }
838: bool isFriend ( ) const {
839: return getFlag (@expr1073747174 fIsFriend ) ;
840: }
841: bool isExplicit ( ) const {
842: return getFlag (@expr1073747175 fIsExplicit ) ;
843: }
844: bool isDefault ( ) const {
845: return getFlag (@expr1073747176 fIsDefault ) ;
846: }
847: bool isDelete ( ) const {
848: return getFlag (@expr1073747177 fIsDelete ) ;
849: }
850: bool isNoExcept ( ) const {
851: return getFlag (@expr1073747178 fIsNoExcept ) ;
852: }
853: bool isThrow ( ) const {
854: return getFlag (@expr1073747179 fIsThrow ) ;
855: }
856: bool hasOverrideSpecifier ( ) const {
857: return getFlag (@expr1073747180 fHasOverrideSpecifier ) ;
858: }
859: bool hasFinalSpecifier ( ) const {
860: return getFlag (@expr1073747181 fHasFinalSpecifier ) ;
861: }
862: bool isOperator ( ) const {
863: return getFlag (@expr1073747182 fIsOperator ) ;
864: }
865: bool hasLvalRefQualifier ( ) const {
866: return getFlag (@expr1073747183 fHasLvalRefQual ) ;
867: }
868: bool hasRvalRefQualifier ( ) const {
869: return getFlag (@expr1073747184 fHasRvalRefQual ) ;
870: }
871: bool isVariadic ( ) const {
872: return getFlag (@expr1073747185 fIsVariadic ) ;
873: }
874: bool isVolatile ( ) const {
875: return getFlag (@expr1073747186 fIsVolatile ) ;
876: }
877: bool hasTrailingReturnType ( ) const {
878: return getFlag (@expr1073747187 fHasTrailingReturnType ) ;
879: }
880: void hasBody ( bool state@var1847 ) {
881: setFlag (@expr1073747188 fHasBody , state@var1847 ) ;
882: }
883: bool isInlineKeyword ( ) const {
884: return getFlag (@expr1073747189 fIsInlineKeyword ) ;
885: }
886:
887: bool isEscapeFunction ( ) const {
888: return getFlag (@expr1073747190 fIsEscapeFunction ) ;
889: }
890: void isEscapeFunction ( bool state@var1848 ) {
891: setFlag (@expr1073747191 fIsEscapeFunction , state@var1848 ) ;
892: }
893:
894: bool isConstexpr ( ) const {
895: return getFlag (@expr1073747192 fIsConstexpr ) ;
896: }
897: void isConstexpr ( bool state@var1849 ) {
898: setFlag (@expr1073747193 fIsConstexpr , state@var1849 ) ;
899: }
900: bool isSafe ( const Settings * settings@var1850 ) const ;
901:
902: const Token * tokenDef@var1851 ;
903: const Token * argDef@var1852 ;
904: const Token * token@var1853 ;
905: const Token * arg@var1854 ;
906: const Token * retDef@var1855 ;
907: const :: Type * retType@var1856 ;
908: const Scope * functionScope@var1857 ;
909: const Scope * nestedIn@var1858 ;
910: std :: list < Variable > argumentList@var1859 ;
911: int initArgCount@var1860 ;
912: Type type@var1861 ;
913: AccessControl access@var1862 ;
914: const Token * noexceptArg@var1863 ;
915: const Token * throwArg@var1864 ;
916: const Token * templateDef@var1865 ;
917: const Token * functionPointerUsage@var1866 ;
918:
919: bool argsMatch ( const Scope * scope@var1867 , const Token * first@var1868 , const Token * second@var1869 , const std :: string & path@var1870 , int path_length@var1871 ) const ;
920:
921: static bool returnsConst ( const Function * function@var1872 , bool unknown@var1873 = false ) ;
922:
923: static bool returnsReference ( const Function * function@var1874 , bool unknown@var1875 = false ) ;
924:
925: static bool returnsVoid ( const Function * function@var1876 , bool unknown@var1877 = false ) ;
926:
927: static std :: vector < const Token * > findReturns ( const Function * f@var1878 ) ;
928:
929: const Token * returnDefEnd ( ) const {
930: if (@expr1073747194 this@expr1073747195 .@expr1073747196 hasTrailingReturnType (@expr1073747197 ) ) {
931: return Token ::@expr1073747198 findmatch (@expr1073747199 retDef@var1855 , "{|;" ) ;
932: } else {
933: return tokenDef@var1851 ;
934: }
935: }
936:
|
940:
941: const Token * constructorMemberInitialization ( ) const ;
942:
943: private:
944:
945: const Function * getOverriddenFunctionRecursive ( const :: Type * baseType@var1879 , bool * foundAllBaseClasses@var1880 ) const ;
946:
947: unsigned int mFlags@var1881 ;
948:
949: void isInline ( bool state@var1882 ) {
950: setFlag (@expr1073747200 fIsInline , state@var1882 ) ;
951: }
952: void isConst ( bool state@var1883 ) {
953: setFlag (@expr1073747201 fIsConst , state@var1883 ) ;
954: }
955: void hasVirtualSpecifier ( bool state@var1884 ) {
956: setFlag (@expr1073747202 fHasVirtualSpecifier , state@var1884 ) ;
957: }
958: void isPure ( bool state@var1885 ) {
959: setFlag (@expr1073747203 fIsPure , state@var1885 ) ;
960: }
961: void isStatic ( bool state@var1886 ) {
962: setFlag (@expr1073747204 fIsStatic , state@var1886 ) ;
963: }
964: void isStaticLocal ( bool state@var1887 ) {
965: setFlag (@expr1073747205 fIsStaticLocal , state@var1887 ) ;
966: }
967: void isExtern ( bool state@var1888 ) {
968: setFlag (@expr1073747206 fIsExtern , state@var1888 ) ;
969: }
970: void isFriend ( bool state@var1889 ) {
971: setFlag (@expr1073747207 fIsFriend , state@var1889 ) ;
972: }
973: void isExplicit ( bool state@var1890 ) {
974: setFlag (@expr1073747208 fIsExplicit , state@var1890 ) ;
975: }
976: void isDefault ( bool state@var1891 ) {
977: setFlag (@expr1073747209 fIsDefault , state@var1891 ) ;
978: }
979: void isDelete ( bool state@var1892 ) {
980: setFlag (@expr1073747210 fIsDelete , state@var1892 ) ;
981: }
982: void isNoExcept ( bool state@var1893 ) {
983: setFlag (@expr1073747211 fIsNoExcept , state@var1893 ) ;
984: }
985: void isThrow ( bool state@var1894 ) {
986: setFlag (@expr1073747212 fIsThrow , state@var1894 ) ;
987: }
988: void isOperator ( bool state@var1895 ) {
989: setFlag (@expr1073747213 fIsOperator , state@var1895 ) ;
990: }
991: void hasLvalRefQualifier ( bool state@var1896 ) {
992: setFlag (@expr1073747214 fHasLvalRefQual , state@var1896 ) ;
993: }
994: void hasRvalRefQualifier ( bool state@var1897 ) {
995: setFlag (@expr1073747215 fHasRvalRefQual , state@var1897 ) ;
996: }
997: void isVariadic ( bool state@var1898 ) {
998: setFlag (@expr1073747216 fIsVariadic , state@var1898 ) ;
999: }
1000: void isVolatile ( bool state@var1899 ) {
1001: setFlag (@expr1073747217 fIsVolatile , state@var1899 ) ;
1002: }
1003: void hasTrailingReturnType ( bool state@var1900 ) {
1004: return setFlag (@expr1073747218 fHasTrailingReturnType , state@var1900 ) ;
1005: }
1006: void isInlineKeyword ( bool state@var1901 ) {
1007: setFlag (@expr1073747219 fIsInlineKeyword , state@var1901 ) ;
1008: }
1009: const Token * setFlags ( const Token * tok1@var1902 , const Scope * scope@var1903 ) ;
1010: } ;
1011:
1012: class Scope {
1013:
1014: friend class TestSymbolDatabase ;
1015:
1016: public:
1017: struct UsingInfo {
1018: const Token * start@var1904 ;
1019: const Scope * scope@var1905 ;
1020: } ;
1021:
1022: enum ScopeType { eGlobal , eClass , eStruct , eUnion , eNamespace , eFunction , eIf , eElse , eFor , eWhile , eDo , eSwitch , eUnconditional , eTry , eCatch , eLambda , eEnum } ;
1023:
1024: Scope ( const SymbolDatabase * check_@var1906 , const Token * classDef_@var1907 , const Scope * nestedIn_@var1908 ) ;
1025: Scope ( const SymbolDatabase * check_@var1909 , const Token * classDef_@var1910 , const Scope * nestedIn_@var1911 , ScopeType type_@var1912 , const Token * start_@var1913 ) ;
1026:
1027: const SymbolDatabase * check@var1914 ;
1028: std :: string className@var1915 ;
1029: const Token * classDef@var1916 ;
1030: const Token * bodyStart@var1917 ;
1031: const Token * bodyEnd@var1918 ;
1032: std :: list < Function > functionList@var1919 ;
1033: std :: multimap < std :: string , const Function * > functionMap@var1920 ;
1034: std :: list < Variable > varlist@var1921 ;
1035: const Scope * nestedIn@var1922 ;
1036: std :: list < Scope * > nestedList@var1923 ;
1037: int numConstructors@var1924 ;
1038: int numCopyOrMoveConstructors@var1925 ;
1039: std :: list < UsingInfo > usingList@var1926 ;
1040: ScopeType type@var1927 ;
1041: Type * definedType@var1928 ;
1042: std :: map < std :: string , Type * > definedTypesMap@var1929 ;
1043: std :: vector < const Token * > bodyStartList@var1930 ;
1044:
1045:
1046: const Scope * functionOf@var1931 ;
1047: Function * function@var1932 ;
1048:
1049:
1050: const Token * enumType@var1933 ;
1051: bool enumClass@var1934 ;
1052:
1053: std :: vector < Enumerator > enumeratorList@var1935 ;
1054:
1055: void setBodyStartEnd ( const Token * start@var1936 ) {
1056: bodyStart@var1917 =@expr1073747220 start@var1936 ;
1057: bodyEnd@var1918 =@expr1073747221 start@var1936 ?@expr1073747222 start@var1936 .@expr1073747223 link (@expr1073747224 ) :@expr1073747225 nullptr ;
1058: if (@expr1073747226 start@var1936 ) {
1059: bodyStartList@var1930 .@expr1073747227 push_back (@expr1073747228 start@var1936 ) ; }
1060: }
1061:
1062: bool isAnonymous ( ) const {
1063:
1064: return className@var1915 .@expr1073747229 size (@expr1073747230 ) >@expr1073747231 9 &&@expr1073747232 className@var1915 .@expr1073747233 compare (@expr1073747234 0 , 9 , "Anonymous" ) ==@expr1073747235 0 &&@expr1073747236 std ::@expr1073747237 isdigit (@expr1073747238 className@var1915 [@expr1073747239 9 ] ) ;
1065: }
1066:
1067: const Enumerator * findEnumerator ( const std :: string & name@var1937 ) const {
1068: for (@expr1073747240 const Enumerator &@expr1073747241 i@var1938 :@expr1073747242 enumeratorList@var1935 ) {
1069: if (@expr1073747243 i@var1938 .@expr1073747244 name@var1939 .@expr1073747245 str (@expr1073747246 ) ==@expr1073747247 name@var1937 ) {
1070: return &@expr1073747248 i@var1938 ; }
1071: }
1072: return nullptr ;
1073: }
1074:
1075: bool isNestedIn ( const Scope * outer@var1940 ) const {
1076: if (@expr1073747249 !@expr1073747250 outer@var1940 ) {
1077: return false ; }
1078: if (@expr1073747251 outer@var1940 ==@expr1073747252 this@expr1073747253 ) {
1079: return true ; }
1080: const Scope * parent@var1941 ; parent@var1941 =@expr1073747254 nestedIn@var1922 ;
1081: while (@expr1073747255 outer@var1940 !=@expr1073747256 parent@var1941 &&@expr1073747257 parent@var1941 ) {
1082: parent@var1941 =@expr1073747258 parent@var1941 .@expr1073747259 nestedIn@var1942 ; }
1083: if (@expr1073747260 parent@var1941 &&@expr1073747261 parent@var1941 ==@expr1073747262 outer@var1940 ) {
1084: return true ; }
1085: return false ;
1086: }
1087:
1088: static Function * nestedInFunction ( const Scope * scope@var1943 ) {
1089: while (@expr1073747263 scope@var1943 ) {
1090: if (@expr1073747264 scope@var1943 .@expr1073747265 type@var1944 ==@expr1073747266 Scope ::@expr1073747267 eFunction ) {
1091: break ; }
1092: scope@var1943 =@expr1073747268 scope@var1943 .@expr1073747269 nestedIn@var1945 ;
1093: }
1094: if (@expr1073747270 !@expr1073747271 scope@var1943 ) {
1095: return nullptr ; }
1096: return scope@var1943 .@expr1073747272 function@var1946 ;
1097: }
1098:
1099: bool isClassOrStruct ( ) const {
1100: return (@expr1073747273 type@var1927 ==@expr1073747274 eClass ||@expr1073747275 type@var1927 ==@expr1073747276 eStruct ) ;
1101: }
1102:
1103: bool isClassOrStructOrUnion ( ) const {
1104: return (@expr1073747277 type@var1927 ==@expr1073747278 eClass ||@expr1073747279 type@var1927 ==@expr1073747280 eStruct ||@expr1073747281 type@var1927 ==@expr1073747282 eUnion ) ;
1105: }
1106:
1107: bool isExecutable ( ) const {
1108: return type@var1927 !=@expr1073747283 eClass &&@expr1073747284 type@var1927 !=@expr1073747285 eStruct &&@expr1073747286 type@var1927 !=@expr1073747287 eUnion &&@expr1073747288 type@var1927 !=@expr1073747289 eGlobal &&@expr1073747290 type@var1927 !=@expr1073747291 eNamespace &&@expr1073747292 type@var1927 !=@expr1073747293 eEnum ;
1109: }
1110:
1111: bool isLoopScope ( ) const {
1112: return type@var1927 ==@expr1073747294 Scope ::@expr5471 ScopeType ::@expr1073747296 eFor ||@expr1073747297 type@var1927 ==@expr1073747298 Scope ::@expr5471 ScopeType ::@expr1073747300 eWhile ||@expr1073747301 type@var1927 ==@expr1073747302 Scope ::@expr5471 ScopeType ::@expr1073747304 eDo ;
1113: }
1114:
1115: bool isLocal ( ) const {
1116: return (@expr1073747305 type@var1927 ==@expr1073747306 eIf ||@expr1073747307 type@var1927 ==@expr1073747308 eElse ||@expr1073747309
1117: type@var1927 ==@expr1073747310 eFor ||@expr1073747311 type@var1927 ==@expr1073747312 eWhile ||@expr1073747313 type@var1927 ==@expr1073747314 eDo ||@expr1073747315
1118: type@var1927 ==@expr1073747316 eSwitch ||@expr1073747317 type@var1927 ==@expr1073747318 eUnconditional ||@expr1073747319
1119: type@var1927 ==@expr1073747320 eTry ||@expr1073747321 type@var1927 ==@expr1073747322 eCatch ) ;
1120: }
1121:
1122:
1123: bool hasInlineOrLambdaFunction ( ) const ;
1124:
|
1130:
1131: const Function * findFunction ( const Token * tok@var1947 , bool requireConst@var1948 = false ) const ;
1132:
1133: const Scope * findRecordInNestedList ( const std :: string & name@var1949 , bool isC@var1950 = false ) const ;
1134: Scope * findRecordInNestedList ( const std :: string & name@var1951 ) {
1135: return const_cast < Scope *@expr5499 > (@expr1073747324 const_cast < const Scope *@expr5499 > (@expr1073747326 this@expr1073747327 ) .@expr1073747328 findRecordInNestedList (@expr1073747329 name@var1951 ) ) ;
1136: }
1137:
1138: const Type * findType ( const std :: string & name@var1952 ) const ;
1139: Type * findType ( const std :: string & name@var1953 ) {
1140: return const_cast < Type *@expr5506 > (@expr1073747331 const_cast < const Scope *@expr5506 > (@expr1073747333 this@expr1073747334 ) .@expr1073747335 findType (@expr1073747336 name@var1953 ) ) ;
1141: }
1142:
|
1146:
1147: Scope * findInNestedListRecursive ( const std :: string & name@var1954 ) ;
1148:
1149: void addVariable ( const Token * token_@var1955 , const Token * start_@var1956 ,
1150: const Token * end_@var1957 , AccessControl access_@var1958 , const Type * type_@var1959 ,
1151: const Scope * scope_@var1960 , const Settings * settings@var1961 ) ;
1152:
1153:
1154: void getVariableList ( const Settings * settings@var1962 ) ;
1155:
1156: const Function * getDestructor ( ) const ;
1157:
1158: void addFunction ( const Function & func@var1963 ) {
1159: functionList@var1919 .@expr1073747337 push_back (@expr1073747338 func@var1963 ) ;
1160:
1161: const Function * back@var1964 ; back@var1964 =@expr1073747339 &@expr1073747340 functionList@var1919 .@expr1073747341 back (@expr1073747342 ) ;
1162:
1163: functionMap@var1920 .@expr1073747343 insert (@expr1073747344 make_pair (@expr1073747345 back@var1964 .@expr1073747346 tokenDef@var1965 .@expr1073747347 str (@expr1073747348 ) , back@var1964 ) ) ;
1164: }
1165:
1166: bool hasDefaultConstructor ( ) const ;
1167:
1168: AccessControl defaultAccess ( ) const ;
1169:
|
1176:
1177: const Token * checkVariable ( const Token * tok@var1966 , AccessControl varaccess@var1967 , const Settings * settings@var1968 ) ;
1178:
|
1183:
1184: const Variable * getVariable ( const std :: string & varname@var1969 ) const ;
1185:
1186: const Token * addEnum ( const Token * tok@var1970 , bool isCpp@var1971 ) ;
1187:
1188: const Scope * findRecordInBase ( const std :: string & name@var1972 ) const ;
1189:
1190: std :: vector < const Scope * > findAssociatedScopes ( ) const ;
1191:
1192: private:
1193:
|
1199:
1200: bool isVariableDeclaration ( const Token * const tok@var1973 , const Token * & vartok@var1974 , const Token * & typetok@var1975 ) const ;
1201:
1202: void findFunctionInBase ( const std :: string & name@var1976 , int args@var1977 , std :: vector < const Function * > & matches@var1978 ) const ;
1203:
1204:
1205: void getVariableList ( const Settings * settings@var1979 , const Token * start@var1980 , const Token * end@var1981 ) ;
1206: } ;
1207:
1208: enum class Reference {
1209: None ,
1210: LValue ,
1211: RValue
1212: } ;
1213:
1214:
1215: class ValueType {
1216:
1217: enum Sign { UNKNOWN_SIGN , SIGNED , UNSIGNED } ; public: enum Sign sign@var1982 ;
1218: enum Type {
1219: UNKNOWN_TYPE ,
1220: POD ,
1221: NONSTD ,
1222: RECORD ,
1223: SMART_POINTER ,
1224: CONTAINER ,
1225: ITERATOR ,
1226: VOID ,
1227: BOOL ,
1228: CHAR ,
1229: SHORT ,
1230: WCHAR_T ,
1231: INT ,
1232: LONG ,
1233: LONGLONG ,
1234: UNKNOWN_INT ,
1235: FLOAT ,
1236: DOUBLE ,
1237: LONGDOUBLE
1238: } ; enum Type type@var1983 ;
1239: int bits@var1984 ;
1240: int pointer@var1985 ;
1241: int constness@var1986 ;
1242: Reference reference@var1987 ; reference@var1987 = Reference :: None ;
1243:
1244: const Scope * typeScope@var1988 ;
1245: const :: Type * smartPointerType@var1989 ;
1246: const Token * smartPointerTypeToken@var1990 ;
1247: const Library :: SmartPointer * smartPointer@var1991 ;
1248: const Library :: Container * container@var1992 ;
1249:
1250: const Token * containerTypeToken@var1993 ;
1251:
1252: std :: string originalTypeName@var1994 ;
1253:
1254:
1255: ValueType ( )
1256: : sign@var1982 ( UNKNOWN_SIGN ) ,
1257: type@var1983 ( UNKNOWN_TYPE ) ,
1258: bits@var1984 ( 0 ) ,
1259: pointer@var1985 ( 0U ) ,
1260: constness@var1986 ( 0U ) ,
1261: typeScope@var1988 ( nullptr ) ,
1262: smartPointerType@var1989 ( nullptr ) ,
1263: smartPointerTypeToken@var1990 ( nullptr ) ,
1264: smartPointer@var1991 ( nullptr ) ,
1265: container@var1992 ( nullptr ) ,
1266: containerTypeToken@var1993 ( nullptr )
1267: { }
1268: ValueType ( enum Sign s@var1995 , enum Type t@var1996 , int p@var1997 )
1269: : sign@var1982 ( s@var1995 ) ,
1270: type@var1983 ( t@var1996 ) ,
1271: bits@var1984 ( 0 ) ,
1272: pointer@var1985 ( p@var1997 ) ,
1273: constness@var1986 ( 0U ) ,
1274: typeScope@var1988 ( nullptr ) ,
1275: smartPointerType@var1989 ( nullptr ) ,
1276: smartPointerTypeToken@var1990 ( nullptr ) ,
1277: smartPointer@var1991 ( nullptr ) ,
1278: container@var1992 ( nullptr ) ,
1279: containerTypeToken@var1993 ( nullptr )
1280: { }
1281: ValueType ( enum Sign s@var1998 , enum Type t@var1999 , int p@var2000 , int c@var2001 )
1282: : sign@var1982 ( s@var1998 ) ,
1283: type@var1983 ( t@var1999 ) ,
1284: bits@var1984 ( 0 ) ,
1285: pointer@var1985 ( p@var2000 ) ,
1286: constness@var1986 ( c@var2001 ) ,
1287: typeScope@var1988 ( nullptr ) ,
1288: smartPointerType@var1989 ( nullptr ) ,
1289: smartPointerTypeToken@var1990 ( nullptr ) ,
1290: smartPointer@var1991 ( nullptr ) ,
1291: container@var1992 ( nullptr ) ,
1292: containerTypeToken@var1993 ( nullptr )
1293: { }
1294: ValueType ( enum Sign s@var2002 , enum Type t@var2003 , int p@var2004 , int c@var2005 , const std :: string & otn@var2006 )
1295: : sign@var1982 ( s@var2002 ) ,
1296: type@var1983 ( t@var2003 ) ,
1297: bits@var1984 ( 0 ) ,
1298: pointer@var1985 ( p@var2004 ) ,
1299: constness@var1986 ( c@var2005 ) ,
1300: typeScope@var1988 ( nullptr ) ,
1301: smartPointerType@var1989 ( nullptr ) ,
1302: smartPointerTypeToken@var1990 ( nullptr ) ,
1303: smartPointer@var1991 ( nullptr ) ,
1304: container@var1992 ( nullptr ) ,
1305: containerTypeToken@var1993 ( nullptr ) ,
1306: originalTypeName@var1994 ( otn@var2006 )
1307: { }
1308:
1309: static ValueType parseDecl ( const Token * type@var2007 , const Settings * settings@var2008 ) ;
1310:
1311: static Type typeFromString ( const std :: string & typestr@var2009 , bool longType@var2010 ) ;
1312:
1313: enum class MatchResult { UNKNOWN , SAME , FALLBACK1 , FALLBACK2 , NOMATCH } ;
1314: static MatchResult matchParameter ( const ValueType * call@var2011 , const ValueType * func@var2012 ) ;
1315: static MatchResult matchParameter ( const ValueType * call@var2013 , const Variable * callVar@var2014 , const Variable * funcVar@var2015 ) ;
1316:
1317: bool isPrimitive ( ) const {
1318: return (@expr1073747349 type@var1983 >=@expr1073747350 ValueType ::@expr1073747351 Type ::@expr1073747352 BOOL ) ;
1319: }
1320:
1321: bool isIntegral ( ) const {
1322: return (@expr1073747353 type@var1983 >=@expr1073747354 ValueType ::@expr5531 Type ::@expr1073747356 BOOL &&@expr1073747357 type@var1983 <=@expr1073747358 ValueType ::@expr5531 Type ::@expr1073747360 UNKNOWN_INT ) ;
1323: }
1324:
1325: bool isFloat ( ) const {
1326: return (@expr1073747361 type@var1983 >=@expr1073747362 ValueType ::@expr5539 Type ::@expr1073747364 FLOAT &&@expr1073747365 type@var1983 <=@expr1073747366 ValueType ::@expr5539 Type ::@expr1073747368 LONGDOUBLE ) ;
1327: }
1328:
1329: bool fromLibraryType ( const std :: string & typestr@var2016 , const Settings * settings@var2017 ) ;
1330:
1331: bool isEnum ( ) const {
1332: return typeScope@var1988 &&@expr1073747369 typeScope@var1988 .@expr1073747370 type@var2018 ==@expr1073747371 Scope ::@expr1073747372 eEnum ;
1333: }
1334:
1335: long long typeSize ( const cppcheck :: Platform & platform@var2019 , bool p@var2020 = false ) const ;
1336:
1337:
1338: bool isTypeEqual ( const ValueType * that@var2021 ) const ;
1339:
1340: std :: string str ( ) const ;
1341: std :: string dump ( ) const ;
1342: } ;
1343:
1344:
1345: class SymbolDatabase {
1346: friend class TestSymbolDatabase ;
1347: public:
1348: SymbolDatabase ( const Tokenizer * tokenizer@var2022 , const Settings * settings@var2023 , ErrorLogger * errorLogger@var2024 ) ;
1349: ~ SymbolDatabase ( ) ;
1350:
1351:
1352: std :: list < Scope > scopeList@var2025 ;
1353:
1354:
1355: std :: vector < const Scope * > functionScopes@var2026 ;
1356:
1357:
1358: std :: vector < const Scope * > classAndStructScopes@var2027 ;
1359:
1360:
1361: std :: list < Type > typeList@var2028 ;
1362:
|
1368:
1369: const Type * findVariableType ( const Scope * start@var2029 , const Token * typeTok@var2030 ) const ;
1370:
|
1375:
1376: const Function * findFunction ( const Token * tok@var2031 ) const ;
1377:
1378:
1379: const Scope * findScopeByName ( const std :: string & name@var2032 ) const ;
1380:
1381: const Type * findType ( const Token * startTok@var2033 , const Scope * startScope@var2034 , bool lookOutside@var2035 = false ) const ;
1382: Type * findType ( const Token * startTok@var2036 , Scope * startScope@var2037 , bool lookOutside@var2038 = false ) const {
1383: return const_cast < Type *@expr5549 > (@expr1073747374 this@expr1073747375 .@expr1073747376 findType (@expr1073747377 startTok@var2036 , const_cast < const Scope *@expr5549 > (@expr1073747379 startScope@var2037 ) , lookOutside@var2038 ) ) ;
1384: }
1385:
1386: const Scope * findScope ( const Token * tok@var2039 , const Scope * startScope@var2040 ) const ;
1387: Scope * findScope ( const Token * tok@var2041 , Scope * startScope@var2042 ) const {
1388: return const_cast < Scope *@expr5556 > (@expr1073747381 this@expr1073747382 .@expr1073747383 findScope (@expr1073747384 tok@var2041 , const_cast < const Scope *@expr5556 > (@expr1073747386 startScope@var2042 ) ) ) ;
1389: }
1390:
1391: bool isVarId ( int varid@var2043 ) const {
1392: return varid@var2043 <@expr1073747387 mVariableList@var2100 .@expr1073747388 size (@expr1073747389 ) ;
1393: }
1394:
1395: const Variable * getVariableFromVarId ( int varId@var2044 ) const {
1396: return mVariableList@var2100 .@expr1073747390 at (@expr1073747391 varId@var2044 ) ;
1397: }
1398:
1399: const std :: vector < const Variable * > & variableList ( ) const {
1400: return mVariableList@var2100 ;
1401: }
1402:
|
1405:
1406: void debugMessage ( const Token * tok@var2045 , const std :: string & type@var2046 , const std :: string & msg@var2047 ) const ;
1407:
1408: void printOut ( const char * title@var2048 = nullptr ) const ;
1409: void printVariable ( const Variable * var@var2049 , const char * indent@var2050 ) const ;
1410: void printXml ( std :: ostream & out@var2051 ) const ;
1411:
1412: bool isCPP ( ) const ;
1413:
|
1416:
1417: void validate ( ) const ;
1418:
1419: void validateExecutableScopes ( ) const ;
1420:
1421:
1422:
1423: void validateVariables ( ) const ;
1424:
1425:
1426: void setValueTypeInTokenList ( bool reportDebugWarnings@var2052 , Token * tokens@var2053 = nullptr ) ;
1427:
|
1432:
1433: int sizeOfType ( const Token * type@var2054 ) const ;
1434:
1435:
1436: void setArrayDimensionsUsingValueFlow ( ) ;
1437:
1438: void clangSetVariables ( const std :: vector < const Variable * > & variableList@var2055 ) ;
1439: void createSymbolDatabaseExprIds ( ) ;
1440:
1441: private:
1442: friend class Scope ;
1443: friend class Function ;
1444:
1445:
1446: void createSymbolDatabaseFindAllScopes ( ) ;
1447: void createSymbolDatabaseClassInfo ( ) ;
1448: void createSymbolDatabaseVariableInfo ( ) ;
1449: void createSymbolDatabaseCopyAndMoveConstructors ( ) ;
1450: void createSymbolDatabaseFunctionScopes ( ) ;
1451: void createSymbolDatabaseClassAndStructScopes ( ) ;
1452: void createSymbolDatabaseFunctionReturnTypes ( ) ;
1453: void createSymbolDatabaseNeedInitialization ( ) ;
1454: void createSymbolDatabaseVariableSymbolTable ( ) ;
1455: void createSymbolDatabaseSetScopePointers ( ) ;
1456: void createSymbolDatabaseSetFunctionPointers ( bool firstPass@var2056 ) ;
1457: void createSymbolDatabaseSetVariablePointers ( ) ;
1458:
1459: void createSymbolDatabaseSetTypePointers ( ) ;
1460: void createSymbolDatabaseSetSmartPointerType ( ) ;
1461: void createSymbolDatabaseEnums ( ) ;
1462: void createSymbolDatabaseEscapeFunctions ( ) ;
1463:
1464: void createSymbolDatabaseIncompleteVars ( ) ;
1465:
1466: void addClassFunction ( Scope * * scope@var2057 , const Token * * tok@var2058 , const Token * argStart@var2059 ) ;
1467: Function * addGlobalFunctionDecl ( Scope * & scope@var2060 , const Token * tok@var2061 , const Token * argStart@var2062 , const Token * funcStart@var2063 ) ;
1468: Function * addGlobalFunction ( Scope * & scope@var2064 , const Token * & tok@var2065 , const Token * argStart@var2066 , const Token * funcStart@var2067 ) ;
1469: void addNewFunction ( Scope * * scope@var2068 , const Token * * tok@var2069 ) ;
1470: bool isFunction ( const Token * tok@var2070 , const Scope * outerScope@var2071 , const Token * * funcStart@var2072 , const Token * * argStart@var2073 , const Token * * declEnd@var2074 ) const ;
1471: const Type * findTypeInNested ( const Token * startTok@var2075 , const Scope * startScope@var2076 ) const ;
1472: const Scope * findNamespace ( const Token * tok@var2077 , const Scope * scope@var2078 ) const ;
1473: Function * findFunctionInScope ( const Token * func@var2079 , const Scope * ns@var2080 , const std :: string & path@var2081 , int path_length@var2082 ) ;
1474: const Type * findVariableTypeInBase ( const Scope * scope@var2083 , const Token * typeTok@var2084 ) const ;
1475:
|
1478:
1479: void fixVarId ( std :: map < unsigned int , std :: map < unsigned int , unsigned int > > & varIds@var2085 , const Token * vartok@var2086 , Token * membertok@var2087 , const Variable * membervar@var2088 ) ;
1480:
1481:
1482: bool isReservedName ( const std :: string & iName@var2089 ) const ;
1483:
1484: const Enumerator * findEnumerator ( const Token * tok@var2090 ) const ;
1485:
1486: void setValueType ( Token * tok@var2091 , const ValueType & valuetype@var2092 ) ;
1487: void setValueType ( Token * tok@var2093 , const Variable & var@var2094 ) ;
1488: void setValueType ( Token * tok@var2095 , const Enumerator & enumerator@var2096 ) ;
1489:
1490: const Tokenizer * mTokenizer@var2097 ;
1491: const Settings * mSettings@var2098 ;
1492: ErrorLogger * mErrorLogger@var2099 ;
1493:
1494:
1495: std :: vector < const Variable * > mVariableList@var2100 ;
1496:
1497:
1498: std :: list < Type > mBlankTypes@var2101 ;
1499:
1500: bool mIsCpp@var2102 ;
1501: ValueType :: Sign mDefaultSignedness@var2103 ;
1502:
1503:
1504: mutable std :: set < std :: string > mTokensThatAreNotEnumeratorValues@var2104 ;
1505: } ;

##file cppcheck-2.8/lib/tokenize.cpp

1:
|
59:
60: namespace {
61:
62:
63: struct VarIdScopeInfo {
64: VarIdScopeInfo ( )
65: : isExecutable@var2109 ( false ) , isStructInit@var2110 ( false ) , isEnum@var2111 ( false ) , startVarid@var2112 ( 0 ) { }
66: VarIdScopeInfo ( bool isExecutable@var2105 , bool isStructInit@var2106 , bool isEnum@var2107 , int startVarid@var2108 )
67: : isExecutable@var2109 ( isExecutable@var2105 ) , isStructInit@var2110 ( isStructInit@var2106 ) , isEnum@var2111 ( isEnum@var2107 ) , startVarid@var2112 ( startVarid@var2108 ) { }
68:
69: const bool isExecutable@var2109 ;
70: const bool isStructInit@var2110 ;
71: const bool isEnum@var2111 ;
72: const int startVarid@var2112 ;
73: } ;
74: }
75:
76:
77: static bool isEnumStart ( const Token * tok@var2113 )
78: {
79: if (@expr1073747392 !@expr1073747393 tok@var2113 ||@expr1073747394 tok@var2113 .@expr1073747395 str (@expr1073747396 ) !=@expr1073747397 "{" ) {
80: return false ; }
81: return (@expr5574 tok@var2113 .@expr5575 strAt (@expr1073747400 -1 ) ==@expr1073747401 "enum" ) ||@expr1073747402 (@expr5574 tok@var2113 .@expr5575 strAt (@expr1073747405 -2 ) ==@expr1073747406 "enum" ) ||@expr1073747407 Token ::@expr1073747408 Match (@expr1073747409 tok@var2113 .@expr1073747410 tokAt (@expr1073747411 -3 ) , "enum class %name%" ) ;
82: }
83:
84: template < typename T >
85: static void skipEnumBody ( T * * tok@var2114 )
86: {
87: T * defStart@var2115 ; defStart@var2115 =@expr1073747412 *@expr5589 tok@var2114 ;
88: while (@expr1073747414 Token ::@expr1073747415 Match (@expr1073747416 defStart@var2115 , "%name%|::|:" ) ) {
89: defStart@var2115 =@expr1073747417 defStart@var2115 .@expr1073747418 next (@expr1073747419 ) ; }
90: if (@expr1073747420 defStart@var2115 &&@expr1073747421 defStart@var2115 .@expr1073747422 str (@expr1073747423 ) ==@expr1073747424 "{" ) {
91: *@expr5589 tok@var2114 =@expr1073747426 defStart@var2115 .@expr1073747427 link (@expr1073747428 ) .@expr1073747429 next (@expr1073747430 ) ; }
92: }
93:
94: const Token * Tokenizer :: isFunctionHead ( const Token * tok@var2116 , const std :: string & endsWith@var2117 ) const
95: {
96: return Tokenizer ::@expr1073747431 isFunctionHead (@expr1073747432 tok@var2116 , endsWith@var2117 , isCPP (@expr1073747433 ) ) ;
97: }
98:
99: const Token * Tokenizer :: isFunctionHead ( const Token * tok@var2118 , const std :: string & endsWith@var2119 , bool cpp@var2120 )
100: {
101: if (@expr1073747435 !@expr1073747436 tok@var2118 ) {
102: return nullptr ; }
103: if (@expr1073747437 tok@var2118 .@expr5614 str (@expr5615 ) ==@expr1073747440 "(" ) {
104: tok@var2118 =@expr1073747441 tok@var2118 .@expr5618 link (@expr5619 ) ; }
105: if (@expr1073747444 Token ::@expr5621 Match (@expr1073747446 tok@var2118 , ") ;|{|[" ) ) {
106: tok@var2118 =@expr1073747447 tok@var2118 .@expr5624 next (@expr5625 ) ;
107: while (@expr1073747450 tok@var2118 &&@expr5627 tok@var2118 .@expr5614 str (@expr5615 ) ==@expr5630 "[" &&@expr1073747455 tok@var2118 .@expr5618 link (@expr5619 ) ) {
108: if (@expr1073747458 endsWith@var2119 .@expr5635 find (@expr5636 tok@var2118 .@expr5614 str (@expr5615 ) ) !=@expr5639 std ::@expr5640 string ::@expr5641 npos@expr5610 ) {
109: return tok@var2118 ; }
110: tok@var2118 =@expr1073747466 tok@var2118 .@expr5618 link (@expr5619 ) .@expr5645 next (@expr5646 ) ;
111: }
112: return (@expr5647 tok@var2118 &&@expr5648 endsWith@var2119 .@expr5635 find (@expr5636 tok@var2118 .@expr5614 str (@expr5615 ) ) !=@expr5639 std ::@expr5640 string ::@expr5641 npos@expr5610 ) ?@expr5656 tok@var2118 :@expr5657 nullptr ;
113: }
114: if (@expr1073747482 cpp@var2120 &&@expr1073747483 tok@var2118 .@expr5614 str (@expr5615 ) ==@expr5662 ")" ) {
115: tok@var2118 =@expr1073747487 tok@var2118 .@expr5624 next (@expr5625 ) ;
116: while (@expr1073747490 Token ::@expr5621 Match (@expr1073747492 tok@var2118 , "const|noexcept|override|final|volatile|mutable|&|&& !!(" ) ||@expr1073747493
117: (@expr5647 Token ::@expr5621 Match (@expr5672 tok@var2118 , "%name% !!(" ) &&@expr5673 tok@var2118 .@expr5674 isUpperCaseName (@expr5675 ) ) ) {
118: tok@var2118 =@expr1073747500 tok@var2118 .@expr5624 next (@expr5625 ) ; }
119: if (@expr1073747503 tok@var2118 &&@expr1073747504 tok@var2118 .@expr5614 str (@expr5615 ) ==@expr5662 ")" ) {
120: tok@var2118 =@expr1073747508 tok@var2118 .@expr5624 next (@expr5625 ) ; }
121: while (@expr1073747511 tok@var2118 &&@expr5627 tok@var2118 .@expr5614 str (@expr5615 ) ==@expr5630 "[" ) {
122: tok@var2118 =@expr1073747516 tok@var2118 .@expr5618 link (@expr5619 ) .@expr5645 next (@expr5646 ) ; }
123: if (@expr1073747521 Token ::@expr5621 Match (@expr1073747523 tok@var2118 , "throw|noexcept (" ) ) {
124: tok@var2118 =@expr1073747524 tok@var2118 .@expr5701 linkAt (@expr5702 1 ) .@expr5703 next (@expr5704 ) ; }
125: if (@expr1073747529 Token ::@expr5621 Match (@expr1073747531 tok@var2118 , "%name% (" ) &&@expr1073747532 tok@var2118 .@expr5674 isUpperCaseName (@expr5675 ) ) {
126: tok@var2118 =@expr1073747535 tok@var2118 .@expr5701 linkAt (@expr5702 1 ) .@expr5703 next (@expr5704 ) ; }
127: if (@expr1073747540 tok@var2118 &&@expr1073747541 tok@var2118 .@expr1073747542 originalName (@expr1073747543 ) ==@expr1073747544 "->" ) {
128: for (@expr1073747545 tok@var2118 =@expr1073747546 tok@var2118 .@expr5624 next (@expr5625 ) ; tok@var2118 &&@expr1073747549 !@expr1073747550 Token ::@expr5621 Match (@expr1073747552 tok@var2118 , ";|{|override|final" ) ; tok@var2118 =@expr1073747553 tok@var2118 .@expr5624 next (@expr5625 ) ) {
129: if (@expr1073747556 tok@var2118 .@expr5618 link (@expr5619 ) &&@expr1073747559 Token ::@expr5621 Match (@expr1073747561 tok@var2118 , "<|[|(" ) ) {
130: tok@var2118 =@expr1073747562 tok@var2118 .@expr5618 link (@expr5619 ) ; } }
131: }
132: while (@expr1073747565 Token ::@expr5621 Match (@expr1073747567 tok@var2118 , "override|final !!(" ) ||@expr1073747568
133: (@expr5647 Token ::@expr5621 Match (@expr5672 tok@var2118 , "%name% !!(" ) &&@expr5673 tok@var2118 .@expr5674 isUpperCaseName (@expr5675 ) ) ) {
134: tok@var2118 =@expr1073747575 tok@var2118 .@expr5624 next (@expr5625 ) ; }
135: if (@expr1073747578 Token ::@expr5621 Match (@expr1073747580 tok@var2118 , "= 0|default|delete ;" ) ) {
136: tok@var2118 =@expr1073747581 tok@var2118 .@expr1073747582 tokAt (@expr1073747583 2 ) ; }
137:
138: return (@expr5647 tok@var2118 &&@expr5648 endsWith@var2119 .@expr5635 find (@expr5636 tok@var2118 .@expr5614 str (@expr5615 ) ) !=@expr5639 std ::@expr5640 string ::@expr5641 npos@expr5610 ) ?@expr5656 tok@var2118 :@expr5657 nullptr ;
139: }
140: return nullptr ;
141: }
142:
|
145:
146: static bool isClassStructUnionEnumStart ( const Token * tok@var2121 )
147: {
148: if (@expr1073747595 !@expr1073747596 Token ::@expr5773 Match (@expr1073747598 tok@var2121 .@expr5775 previous (@expr5776 ) , "class|struct|union|enum|%name%|>|>> {" ) ) {
149: return false ; }
150: const Token * tok2@var2122 ; tok2@var2122 =@expr1073747601 tok@var2121 .@expr5775 previous (@expr5776 ) ;
151: while (@expr1073747604 tok2@var2122 &&@expr1073747605 !@expr1073747606 Token ::@expr5773 Match (@expr1073747608 tok2@var2122 , "class|struct|union|enum|{|}|;" ) ) {
152: tok2@var2122 =@expr1073747609 tok2@var2122 .@expr1073747610 previous (@expr1073747611 ) ; }
153: return Token ::@expr5773 Match (@expr1073747613 tok2@var2122 , "class|struct|union|enum" ) ;
154: }
155:
156:
157:
158: Tokenizer :: Tokenizer ( ) :
159: list@var872 ( nullptr ) ,
160: mSettings@var879 ( nullptr ) ,
161: mErrorLogger@var880 ( nullptr ) ,
162: mSymbolDatabase@var881 ( nullptr ) ,
163: mTemplateSimplifier@var882 ( nullptr ) ,
164: mVarId@var891 ( 0 ) ,
165: mUnnamedCount@var892 ( 0 ) ,
166: mCodeWithTemplates@var893 ( false ) ,
167: mTimerResults@var894 ( nullptr )
168:
169:
170:
171: , mPreprocessor@var895 ( nullptr )
172: { }
173:
174: Tokenizer :: Tokenizer ( const Settings * settings@var2123 , ErrorLogger * errorLogger@var2124 ) :
175: list@var872 ( settings@var2123 ) ,
176: mSettings@var879 ( settings@var2123 ) ,
177: mErrorLogger@var880 ( errorLogger@var2124 ) ,
178: mSymbolDatabase@var881 ( nullptr ) ,
179: mTemplateSimplifier@var882 ( nullptr ) ,
180: mVarId@var891 ( 0 ) ,
181: mUnnamedCount@var892 ( 0 ) ,
182: mCodeWithTemplates@var893 ( false ) ,
183: mTimerResults@var894 ( nullptr )
184:
185:
186:
187: , mPreprocessor@var895 ( nullptr )
188: {
189:
190: assert (@expr1073747614 mSettings@var879 ) ;
191:
192: mTemplateSimplifier@var882 =@expr1073747615 new TemplateSimplifier (@expr1073747616 this@expr1073747617 ) ;
193: }
194:
195: Tokenizer :: ~ Tokenizer ( )
196: {
197: delete mSymbolDatabase@var881 ;
198: delete mTemplateSimplifier@var882 ;
199: }
200:
|
205:
206: int Tokenizer :: sizeOfType ( const Token * type@var2125 ) const
207: {
208: if (@expr1073747618 !@expr1073747619 type@var2125 ||@expr1073747620 type@var2125 .@expr5797 str (@expr5798 ) .@expr1073747623 empty (@expr1073747624 ) ) {
209: return 0 ; }
210:
211: if (@expr1073747625 type@var2125 .@expr1073747626 tokType (@expr1073747627 ) ==@expr1073747628 Token ::@expr1073747629 eString ) {
212: return Token ::@expr1073747630 getStrLength (@expr1073747631 type@var2125 ) +@expr1073747632 1U ; }
213:
214: const std ::@expr1073747633 map < std ::@expr1073747634 string , int > ::@expr1073747635 const_iterator it@var2126 =@expr1073747636 mTypeSize@var884 .@expr1073747637 find (@expr1073747638 type@var2125 .@expr5797 str (@expr5798 ) ) ;
215: if (@expr1073747641 it@var2126 ==@expr1073747642 mTypeSize@var884 .@expr1073747643 end (@expr1073747644 ) ) {
216: const Library ::@expr1073747645 PodType * podtype@var2127 ; podtype@var2127 =@expr1073747646 mSettings@var879 .@expr1073747647 library@var3563 .@expr1073747648 podtype (@expr1073747649 type@var2125 .@expr5797 str (@expr5798 ) ) ;
217: if (@expr1073747652 !@expr1073747653 podtype@var2127 ) {
218: return 0 ; }
219:
220: return podtype@var2127 .@expr1073747654 size@var2128 ;
221: } else { if (@expr1073747655 type@var2125 .@expr1073747656 isLong (@expr1073747657 ) ) {
222: if (@expr1073747658 type@var2125 .@expr5797 str (@expr5798 ) ==@expr1073747661 "double" ) {
223: return mSettings@var879 .@expr1073747662 sizeof_long_double@var3564 ; }
224: else { if (@expr1073747663 type@var2125 .@expr5797 str (@expr5798 ) ==@expr1073747666 "long" ) {
225: return mSettings@var879 .@expr1073747667 sizeof_long_long@var3565 ; } }
226: } }
227:
228: return it@var2126 .@expr1073747668 second@var2129 ;
229: }
230:
231:
232:
233: bool Tokenizer :: duplicateTypedef ( Token * * tokPtr@var2130 , const Token * name@var2131 , const Token * typeDef@var2132 ) const
234: {
235:
236: const Token * tok@var2133 ; tok@var2133 =@expr1073747669 *@expr5846 tokPtr@var2130 ;
237: if (@expr1073747671 tok@var2133 &&@expr1073747672 Token ::@expr5849 Match (@expr1073747674 tok@var2133 .@expr5851 next (@expr5852 ) , ";|,|[|=|)|>|(|{" ) ) {
238: const Token * end@var2134 ; end@var2134 =@expr1073747677 tok@var2133 .@expr5851 next (@expr5852 ) ;
239:
240: if (@expr1073747680 end@var2134 .@expr5857 str (@expr5858 ) ==@expr1073747683 "[" ) {
241: if (@expr1073747684 !@expr1073747685 end@var2134 .@expr5862 link (@expr5863 ) ) {
242: syntaxError (@expr1073747688 end@var2134 ) ; }
243: end@var2134 =@expr1073747689 end@var2134 .@expr5862 link (@expr5863 ) .@expr1073747692 next (@expr1073747693 ) ;
244: } else { if (@expr1073747694 end@var2134 .@expr5857 str (@expr5858 ) ==@expr1073747697 "," ) {
245:
246: if (@expr1073747698 Token ::@expr5849 Match (@expr1073747700 tok@var2133 .@expr5877 previous (@expr5878 ) , "public|private|protected" ) ) {
247: return false ; }
248:
249:
250: while (@expr1073747703 end@var2134 &&@expr1073747704 end@var2134 .@expr5881 next (@expr5882 ) &&@expr1073747707 !@expr1073747708 Token ::@expr5849 Match (@expr1073747710 end@var2134 .@expr5881 next (@expr5882 ) , ";|)|>" ) ) {
251: if (@expr1073747713 end@var2134 .@expr5881 next (@expr5882 ) .@expr1073747716 str (@expr1073747717 ) ==@expr1073747718 "(" ) {
252: end@var2134 =@expr1073747719 end@var2134 .@expr1073747720 linkAt (@expr1073747721 1 ) ; }
253:
254: end@var2134 =@expr1073747722 (@expr1073747723 end@var2134 ) ?@expr1073747724 end@var2134 .@expr5881 next (@expr5882 ) :@expr1073747727 nullptr ;
255: }
256: if (@expr5904 end@var2134 ) {
257: end@var2134 =@expr1073747729 end@var2134 .@expr5881 next (@expr5882 ) ; }
258: } else { if (@expr1073747732 end@var2134 .@expr5857 str (@expr5858 ) ==@expr1073747735 "(" ) {
259: if (@expr1073747736 tok@var2133 .@expr5877 previous (@expr5878 ) .@expr5915 str (@expr5916 ) .@expr1073747741 compare (@expr1073747742 0 , 8 , "operator" ) ==@expr1073747743 0 ) {
260:
261: return false ;
262: } else { if (@expr5920 tok@var2133 .@expr5877 previous (@expr5878 ) .@expr5915 str (@expr5916 ) ==@expr5925 "typedef" ) {
263:
264: return false ;
265: } else { if (@expr1073747750 Token ::@expr5849 Match (@expr1073747752 tok@var2133 .@expr5877 previous (@expr5878 ) , "public:|private:|protected:" ) ) {
266: return false ;
267: } else { if (@expr1073747755 tok@var2133 .@expr5877 previous (@expr5878 ) .@expr5915 str (@expr5916 ) ==@expr1073747760 ">" ) {
268: if (@expr1073747761 !@expr1073747762 Token ::@expr5849 Match (@expr1073747764 tok@var2133 .@expr5941 tokAt (@expr5942 -2 ) , "%type%" ) ) {
269: return false ; }
270:
271: if (@expr1073747767 !@expr1073747768 Token ::@expr5849 Match (@expr1073747770 tok@var2133 .@expr5941 tokAt (@expr1073747772 -3 ) , ",|<" ) ) {
272: return false ; }
273:
274: *@expr5846 tokPtr@var2130 =@expr1073747774 end@var2134 .@expr5862 link (@expr5863 ) ;
275: return true ;
276: } } } }
277: } } }
278:
279: if (@expr5904 end@var2134 ) {
280: if (@expr1073747778 Token ::@expr5955 simpleMatch (@expr1073747780 end@var2134 , ") {" ) ) {
281:
282: if (@expr1073747781 Token ::@expr5849 Match (@expr5959 tok@var2133 .@expr5877 previous (@expr5878 ) , "%type%" ) &&@expr1073747786
283: !@expr1073747787 Token ::@expr5849 Match (@expr1073747789 tok@var2133 .@expr5877 previous (@expr5878 ) , "return|new|const|struct" ) ) {
284:
285: *@expr5846 tokPtr@var2130 =@expr1073747793 end@var2134 .@expr5881 next (@expr5882 ) .@expr1073747796 link (@expr1073747797 ) ;
286: return true ;
287: }
288: } else { if (@expr1073747798 end@var2134 .@expr5857 str (@expr5858 ) ==@expr1073747801 ">" ) {
289:
290: if (@expr1073747802 Token ::@expr5849 Match (@expr5959 tok@var2133 .@expr5877 previous (@expr5878 ) , "%type%" ) &&@expr1073747807
291: !@expr1073747808 Token ::@expr5849 Match (@expr1073747810 tok@var2133 .@expr5877 previous (@expr5878 ) , "return|new|const|volatile" ) ) {
292:
293: while (@expr1073747813 end@var2134 &&@expr1073747814 end@var2134 .@expr5857 str (@expr5858 ) !=@expr1073747817 "{" ) {
294: end@var2134 =@expr1073747818 end@var2134 .@expr5881 next (@expr5882 ) ; }
295: if (@expr5904 end@var2134 ) {
296: *@expr5846 tokPtr@var2130 =@expr1073747823 end@var2134 .@expr5862 link (@expr5863 ) ;
297: return true ;
298: }
299: }
300: } else {
301:
302: if (@expr1073747826 Token ::@expr5849 Match (@expr1073747828 tok@var2133 .@expr5877 previous (@expr5878 ) , "typedef|}|>" ) ||@expr1073747831
303: (@expr1073747832 end@var2134 .@expr5857 str (@expr5858 ) ==@expr1073747835 ";" &&@expr1073747836 tok@var2133 .@expr5877 previous (@expr5878 ) .@expr5915 str (@expr5916 ) ==@expr1073747841 "," ) ||@expr1073747842
304: (@expr1073747843 tok@var2133 .@expr5877 previous (@expr5878 ) .@expr5915 str (@expr5916 ) ==@expr1073747848 "*" &&@expr1073747849 tok@var2133 .@expr5851 next (@expr5852 ) .@expr6028 str (@expr6029 ) !=@expr1073747854 "(" ) ||@expr1073747855
305: (@expr1073747856 Token ::@expr5849 Match (@expr5959 tok@var2133 .@expr5877 previous (@expr5878 ) , "%type%" ) &&@expr1073747861
306: (@expr1073747862 !@expr1073747863 Token ::@expr5849 Match (@expr1073747865 tok@var2133 .@expr5877 previous (@expr5878 ) , "return|new|const|friend|public|private|protected|throw|extern" ) &&@expr1073747868
307: !@expr1073747869 Token ::@expr5955 simpleMatch (@expr1073747871 tok@var2133 .@expr5941 tokAt (@expr5942 -2 ) , "friend class" ) ) ) ) {
308:
309: while (@expr1073747874 tok@var2133 &&@expr1073747875 tok@var2133 .@expr5877 previous (@expr5878 ) &&@expr1073747878 !@expr1073747879 Token ::@expr5849 Match (@expr1073747881 tok@var2133 .@expr5877 previous (@expr5878 ) , ";|{" ) ) {
310: if (@expr1073747884 tok@var2133 .@expr5877 previous (@expr5878 ) .@expr5915 str (@expr5916 ) ==@expr1073747889 "}" ) {
311: tok@var2133 =@expr1073747890 tok@var2133 .@expr5877 previous (@expr5878 ) .@expr1073747893 link (@expr1073747894 ) ;
312: } else { if (@expr5920 tok@var2133 .@expr5877 previous (@expr5878 ) .@expr5915 str (@expr5916 ) ==@expr5925 "typedef" ) {
313: return true ;
314: } else { if (@expr1073747901 tok@var2133 .@expr5877 previous (@expr5878 ) .@expr5915 str (@expr5916 ) ==@expr1073747906 "enum" ) {
315: return true ;
316: } else { if (@expr1073747907 tok@var2133 .@expr5877 previous (@expr5878 ) .@expr5915 str (@expr5916 ) ==@expr1073747912 "struct" ) {
317: if (@expr1073747913 tok@var2133 .@expr1073747914 strAt (@expr1073747915 -2 ) ==@expr1073747916 "typedef" &&@expr1073747917
318: tok@var2133 .@expr5851 next (@expr5852 ) .@expr6028 str (@expr6029 ) ==@expr6098 "{" &&@expr1073747923
319: typeDef@var2132 .@expr1073747924 strAt (@expr1073747925 3 ) !=@expr1073747926 "{" ) {
320:
321: return true ;
322: } else { if (@expr1073747927 tok@var2133 .@expr5851 next (@expr5852 ) .@expr6028 str (@expr6029 ) ==@expr6098 "{" ) {
323: return true ;
324: } else { if (@expr1073747933 Token ::@expr5849 Match (@expr1073747935 tok@var2133 .@expr5851 next (@expr5852 ) , ")|*" ) ) {
325: return true ;
326: } else { if (@expr1073747938 tok@var2133 .@expr5851 next (@expr5852 ) .@expr6028 str (@expr6029 ) ==@expr1073747943 name@var2131 .@expr1073747944 str (@expr1073747945 ) ) {
327: return true ;
328: } else { if (@expr6122 tok@var2133 .@expr5851 next (@expr5852 ) .@expr6028 str (@expr6029 ) !=@expr6127 ";" ) {
329: return true ;
330: } else {
331: return false ;
332: } } } } }
333: } else { if (@expr1073747952 tok@var2133 .@expr5877 previous (@expr5878 ) .@expr5915 str (@expr5916 ) ==@expr1073747957 "union" ) {
334: if (@expr6122 tok@var2133 .@expr5851 next (@expr5852 ) .@expr6028 str (@expr6029 ) !=@expr6127 ";" ) {
335: return true ;
336: } else {
337: return false ;
338: }
339: } else { if (@expr1073747964 isCPP (@expr1073747965 ) &&@expr1073747966 tok@var2133 .@expr5877 previous (@expr5878 ) .@expr5915 str (@expr5916 ) ==@expr1073747971 "class" ) {
340: if (@expr6122 tok@var2133 .@expr5851 next (@expr5852 ) .@expr6028 str (@expr6029 ) !=@expr6127 ";" ) {
341: return true ;
342: } else {
343: return false ;
344: }
345: } } } } } }
346: if (@expr1073747978 tok@var2133 ) {
347: tok@var2133 =@expr1073747979 tok@var2133 .@expr5877 previous (@expr5878 ) ; }
348: }
349:
350: if (@expr1073747982 (@expr6159 *@expr5846 tokPtr@var2130 ) .@expr1073747985 strAt (@expr1073747986 1 ) !=@expr1073747987 "(" ||@expr1073747988 !@expr1073747989 Token ::@expr5849 Match (@expr1073747991 (@expr6159 *@expr5846 tokPtr@var2130 ) .@expr1073747994 linkAt (@expr1073747995 1 ) , ") .|(|[" ) ) {
351: return true ; }
352: }
353: } }
354: }
355: }
356:
357: return false ;
358: }
359:
360: void Tokenizer :: unsupportedTypedef ( const Token * tok@var2135 ) const
361: {
362: if (@expr1073747996 !@expr1073747997 mSettings@var879 .@expr1073747998 debugwarnings@var3566 ) {
363: return ; }
364:
365: std ::@expr1073747999 ostringstream str@var2136 ;
366: const Token * tok1@var2137 ; tok1@var2137 =@expr1073748000 tok@var2135 ;
367: int level@var2138 ; level@var2138 =@expr1073748001 0 ;
368: while (@expr1073748002 tok@var2135 ) {
369: if (@expr1073748003 level@var2138 ==@expr6180 0 &&@expr1073748005 tok@var2135 .@expr6182 str (@expr6183 ) ==@expr1073748008 ";" ) {
370: break ; }
371: else { if (@expr1073748009 tok@var2135 .@expr6182 str (@expr6183 ) ==@expr1073748012 "{" ) {
372: ++@expr1073748013 level@var2138 ; }
373: else { if (@expr1073748014 tok@var2135 .@expr6182 str (@expr6183 ) ==@expr1073748017 "}" ) {
374: if (@expr1073748018 level@var2138 ==@expr6180 0 ) {
375: break ; }
376: --@expr1073748020 level@var2138 ;
377: } } }
378:
379: if (@expr1073748021 tok@var2135 !=@expr1073748022 tok1@var2137 ) {
380: str@var2136 <<@expr1073748023 " " ; }
381: str@var2136 <<@expr1073748024 tok@var2135 .@expr6182 str (@expr6183 ) ;
382: tok@var2135 =@expr1073748027 tok@var2135 .@expr1073748028 next (@expr1073748029 ) ;
383: }
384: if (@expr1073748030 tok@var2135 ) {
385: str@var2136 <<@expr1073748031 " ;" ; }
386:
387: reportError (@expr1073748032 tok1@var2137 , Severity ::@expr1073748033 debug , "simplifyTypedef" ,
388: "Failed to parse \'" +@expr1073748034 str@var2136 .@expr1073748035 str (@expr1073748036 ) +@expr1073748037 "\'. The checking continues anyway." ) ;
389: }
390:
391: Token * Tokenizer :: deleteInvalidTypedef ( Token * typeDef@var2139 )
392: {
393: Token * tok@var2140 ; tok@var2140 =@expr1073748038 nullptr ;
394:
395:
396: while (@expr1073748039 typeDef@var2139 .@expr6216 next (@expr6217 ) ) {
397: if (@expr1073748042 typeDef@var2139 .@expr6216 next (@expr6217 ) .@expr6221 str (@expr6222 ) ==@expr1073748047 ";" ) {
398: typeDef@var2139 .@expr6224 deleteNext (@expr6225 ) ;
399: break ;
400: } else { if (@expr1073748050 typeDef@var2139 .@expr6216 next (@expr6217 ) .@expr6221 str (@expr6222 ) ==@expr1073748055 "{" ) {
401: Token ::@expr1073748056 eraseTokens (@expr1073748057 typeDef@var2139 , typeDef@var2139 .@expr1073748058 linkAt (@expr1073748059 1 ) ) ; }
402: else { if (@expr1073748060 typeDef@var2139 .@expr6216 next (@expr6217 ) .@expr6221 str (@expr6222 ) ==@expr1073748065 "}" ) {
403: break ; } } }
404: typeDef@var2139 .@expr6224 deleteNext (@expr6225 ) ;
405: }
406:
407: if (@expr1073748068 typeDef@var2139 !=@expr1073748069 list@var872 .@expr6246 front (@expr6247 ) ) {
408: tok@var2140 =@expr1073748072 typeDef@var2139 .@expr1073748073 previous (@expr1073748074 ) ;
409: tok@var2140 .@expr1073748075 deleteNext (@expr1073748076 ) ;
410: } else {
411: list@var872 .@expr6246 front (@expr6247 ) .@expr1073748079 deleteThis (@expr1073748080 ) ;
412: tok@var2140 =@expr1073748081 list@var872 .@expr6246 front (@expr6247 ) ;
413: }
414:
415: return tok@var2140 ;
416: }
417:
418: namespace {
419: struct Space {
420: Space ( ) : bodyEnd@var2142 ( nullptr ) , bodyEnd2@var2143 ( nullptr ) , isNamespace@var2144 ( false ) { }
421: std :: string className@var2141 ;
422: const Token * bodyEnd@var2142 ;
423: const Token * bodyEnd2@var2143 ;
424: bool isNamespace@var2144 ;
425: std :: set < std :: string > recordTypes@var2145 ;
426: } ;
427: }
428:
429: static Token * splitDefinitionFromTypedef ( Token * tok@var2146 , int * unnamedCount@var2147 )
430: {
431: std ::@expr1073748084 string name@var2148 ;
432: bool isConst@var2149 ; isConst@var2149 =@expr1073748085 false ;
433: Token * tok1@var2150 ; tok1@var2150 =@expr1073748086 tok@var2146 .@expr6263 next (@expr6264 ) ;
434:
435:
436: if (@expr1073748089 tok1@var2150 .@expr6266 str (@expr6267 ) ==@expr1073748092 "const" ) {
437: tok1@var2150 .@expr6269 deleteThis (@expr6270 ) ;
438: isConst@var2149 =@expr1073748095 true ;
439: }
440:
441:
442: tok1@var2150 =@expr1073748096 tok1@var2150 .@expr6273 next (@expr6274 ) ;
443:
444: const bool hasName@var2151 =@expr1073748099 Token ::@expr6276 Match (@expr1073748101 tok1@var2150 , "%name%" ) ;
445:
446:
447: if (@expr1073748102 hasName@var2151 ) {
448: name@var2148 =@expr1073748103 tok1@var2150 .@expr6266 str (@expr6267 ) ;
449: tok1@var2150 =@expr1073748106 tok1@var2150 .@expr6273 next (@expr6274 ) ;
450: }
451:
452:
453: if (@expr1073748109 tok1@var2150 .@expr6266 str (@expr6267 ) ==@expr1073748112 ":" ) {
454: tok1@var2150 =@expr1073748113 tok1@var2150 .@expr6273 next (@expr6274 ) ;
455: while (@expr1073748116 tok1@var2150 &&@expr1073748117 tok1@var2150 .@expr6266 str (@expr6267 ) !=@expr1073748120 "{" ) {
456: tok1@var2150 =@expr1073748121 tok1@var2150 .@expr6273 next (@expr6274 ) ; }
457: if (@expr1073748124 !@expr1073748125 tok1@var2150 ) {
458: return nullptr ; }
459: }
460:
461:
462: tok1@var2150 =@expr1073748126 tok1@var2150 .@expr1073748127 link (@expr1073748128 ) ;
463:
464: if (@expr1073748129 !@expr1073748130 hasName@var2151 ) {
465: if (@expr1073748131 tok1@var2150 .@expr6273 next (@expr6274 ) ) {
466:
467: if (@expr1073748134 Token ::@expr6276 Match (@expr1073748136 tok1@var2150 .@expr6273 next (@expr6274 ) , "%type%" ) ) {
468: name@var2148 =@expr1073748139 tok1@var2150 .@expr6273 next (@expr6274 ) .@expr6318 str (@expr6319 ) ; }
469: else {
470: name@var2148 =@expr1073748144 "Unnamed" +@expr1073748145 MathLib ::@expr1073748146 toString (@expr1073748147 (@expr1073748148 *@expr1073748149 unnamedCount@var2147 ) ++@expr1073748150 ) ; }
471: tok@var2146 .@expr6263 next (@expr6264 ) .@expr1073748153 insertToken (@expr1073748154 name@var2148 ) ;
472: } else {
473: return nullptr ; }
474: }
475:
476: tok1@var2150 .@expr6331 insertToken (@expr1073748156 ";" ) ;
477: tok1@var2150 =@expr1073748157 tok1@var2150 .@expr6273 next (@expr6274 ) ;
478:
479: if (@expr1073748160 tok1@var2150 .@expr6273 next (@expr6274 ) &&@expr1073748163 tok1@var2150 .@expr6273 next (@expr6274 ) .@expr6318 str (@expr6319 ) ==@expr1073748168 ";" &&@expr1073748169 tok1@var2150 .@expr1073748170 previous (@expr1073748171 ) .@expr1073748172 str (@expr1073748173 ) ==@expr1073748174 "}" ) {
480: tok@var2146 .@expr6351 deleteThis (@expr6352 ) ;
481: tok1@var2150 .@expr6269 deleteThis (@expr6270 ) ;
482: return nullptr ;
483: } else {
484: tok1@var2150 .@expr6331 insertToken (@expr1073748180 "typedef" ) ;
485: tok1@var2150 =@expr1073748181 tok1@var2150 .@expr6273 next (@expr6274 ) ;
486: Token * tok3@var2152 ; tok3@var2152 =@expr1073748184 tok1@var2150 ;
487: if (@expr1073748185 isConst@var2149 ) {
488: tok1@var2150 .@expr6331 insertToken (@expr1073748187 "const" ) ;
489: tok1@var2150 =@expr1073748188 tok1@var2150 .@expr6273 next (@expr6274 ) ;
490: }
491: tok1@var2150 .@expr6331 insertToken (@expr1073748192 tok@var2146 .@expr6263 next (@expr6264 ) .@expr1073748195 str (@expr1073748196 ) ) ;
492: tok1@var2150 =@expr1073748197 tok1@var2150 .@expr6273 next (@expr6274 ) ;
493: tok1@var2150 .@expr6331 insertToken (@expr1073748201 name@var2148 ) ;
494: tok@var2146 .@expr6351 deleteThis (@expr6352 ) ;
495: tok@var2146 =@expr1073748204 tok3@var2152 ;
496: }
497:
498: return tok@var2146 ;
499: }
500:
|
505:
506: Token * Tokenizer :: processFunc ( Token * tok2@var2153 , bool inOperator@var2154 ) const
507: {
508: if (@expr1073748205 tok2@var2153 .@expr6382 next (@expr6383 ) &&@expr1073748208 tok2@var2153 .@expr6382 next (@expr6383 ) .@expr6387 str (@expr6388 ) !=@expr1073748213 ")" &&@expr1073748214
509: tok2@var2153 .@expr6382 next (@expr6383 ) .@expr6387 str (@expr6388 ) !=@expr1073748219 "," ) {
510:
511: if (@expr1073748220 Token ::@expr6397 Match (@expr1073748222 tok2@var2153 .@expr6382 next (@expr6383 ) , "( * %type% ) (" ) ) {
512: tok2@var2153 =@expr1073748225 tok2@var2153 .@expr6402 linkAt (@expr6403 5 ) ; }
513: else { if (@expr1073748228 Token ::@expr6397 Match (@expr1073748230 tok2@var2153 .@expr6382 next (@expr6383 ) , "* ( * %type% ) (" ) ) {
514: tok2@var2153 =@expr1073748233 tok2@var2153 .@expr6402 linkAt (@expr1073748235 6 ) ; }
515: else { if (@expr1073748236 Token ::@expr6397 Match (@expr1073748238 tok2@var2153 .@expr6382 next (@expr6383 ) , "* ( * %type% ) ;" ) ) {
516: tok2@var2153 =@expr1073748241 tok2@var2153 .@expr6418 tokAt (@expr1073748243 5 ) ; }
517: else { if (@expr1073748244 Token ::@expr6397 Match (@expr1073748246 tok2@var2153 .@expr6382 next (@expr6383 ) , "* ( %type% [" ) &&@expr1073748249
518: Token ::@expr6397 Match (@expr1073748251 tok2@var2153 .@expr6402 linkAt (@expr6429 4 ) , "] ) ;|=" ) ) {
519: tok2@var2153 =@expr1073748254 tok2@var2153 .@expr6402 linkAt (@expr6429 4 ) .@expr1073748257 next (@expr1073748258 ) ; }
520: else { if (@expr1073748259 Token ::@expr6397 Match (@expr1073748261 tok2@var2153 .@expr6382 next (@expr6383 ) , "* ( * %type% (" ) ) {
521: tok2@var2153 =@expr1073748264 tok2@var2153 .@expr6402 linkAt (@expr6403 5 ) .@expr1073748267 next (@expr1073748268 ) ; }
522: else { if (@expr1073748269 Token ::@expr6446 simpleMatch (@expr1073748271 tok2@var2153 .@expr6382 next (@expr6383 ) , "* [" ) &&@expr1073748274
523: Token ::@expr6446 simpleMatch (@expr1073748276 tok2@var2153 .@expr6402 linkAt (@expr1073748278 2 ) , "] ;" ) ) {
524: tok2@var2153 =@expr1073748279 tok2@var2153 .@expr6382 next (@expr6383 ) ; }
525: else {
526: if (@expr6458 tok2@var2153 .@expr6382 next (@expr6383 ) .@expr6387 str (@expr6388 ) ==@expr6463 "(" ) {
527: tok2@var2153 =@expr1073748288 tok2@var2153 .@expr6382 next (@expr6383 ) .@expr6467 link (@expr6468 ) ; }
528: else { if (@expr1073748293 !@expr1073748294 inOperator@var2154 &&@expr1073748295 !@expr1073748296 Token ::@expr6397 Match (@expr1073748298 tok2@var2153 .@expr6382 next (@expr6383 ) , "[|>|;" ) ) {
529: tok2@var2153 =@expr1073748301 tok2@var2153 .@expr6382 next (@expr6383 ) ;
530:
531: while (@expr1073748304 Token ::@expr6397 Match (@expr1073748306 tok2@var2153 , "*|&" ) &&@expr1073748307
532: !@expr1073748308 Token ::@expr6397 Match (@expr1073748310 tok2@var2153 .@expr6382 next (@expr6383 ) , ")|>" ) ) {
533: tok2@var2153 =@expr1073748313 tok2@var2153 .@expr6382 next (@expr6383 ) ; }
534:
535:
536: while (@expr1073748316 Token ::@expr6397 Match (@expr1073748318 tok2@var2153 , "%name% ::" ) ) {
537: tok2@var2153 =@expr1073748319 tok2@var2153 .@expr6418 tokAt (@expr1073748321 2 ) ; }
538:
539: if (@expr1073748322 !@expr1073748323 tok2@var2153 ) {
540: return nullptr ; }
541:
542: if (@expr1073748324 tok2@var2153 .@expr1073748325 str (@expr1073748326 ) ==@expr1073748327 "(" &&@expr1073748328
543: tok2@var2153 .@expr6505 link (@expr6506 ) .@expr6507 next (@expr6508 ) &&@expr1073748333
544: tok2@var2153 .@expr6505 link (@expr6506 ) .@expr6507 next (@expr6508 ) .@expr1073748338 str (@expr1073748339 ) ==@expr1073748340 "(" ) {
545: tok2@var2153 =@expr1073748341 tok2@var2153 .@expr6505 link (@expr6506 ) ;
546:
547: if (@expr6458 tok2@var2153 .@expr6382 next (@expr6383 ) .@expr6387 str (@expr6388 ) ==@expr6463 "(" ) {
548: tok2@var2153 =@expr1073748350 tok2@var2153 .@expr6382 next (@expr6383 ) .@expr6467 link (@expr6468 ) ; }
549: }
550:
551:
552: if (@expr1073748355 tok2@var2153 .@expr6382 next (@expr6383 ) &&@expr1073748358 tok2@var2153 .@expr6382 next (@expr6383 ) .@expr6387 str (@expr6388 ) ==@expr6463 "(" ) {
553: tok2@var2153 =@expr1073748364 tok2@var2153 .@expr6382 next (@expr6383 ) .@expr6467 link (@expr6468 ) ;
554: if (@expr1073748369 !@expr1073748370 tok2@var2153 .@expr6382 next (@expr6383 ) ) {
555: syntaxError (@expr1073748373 tok2@var2153 ) ; }
556:
557: if (@expr6458 tok2@var2153 .@expr6382 next (@expr6383 ) .@expr6387 str (@expr6388 ) ==@expr6463 "(" ) {
558: tok2@var2153 =@expr1073748380 tok2@var2153 .@expr6382 next (@expr6383 ) .@expr6467 link (@expr6468 ) ; }
559: }
560: } }
561: } } } } } }
562: }
563: return tok2@var2153 ;
564: }
565:
566: void Tokenizer :: simplifyUsingToTypedef ( )
567: {
568: if (@expr1073748385 !@expr1073748386 isCPP (@expr1073748387 ) ||@expr1073748388 mSettings@var879 .@expr1073748389 standards@var3567 .@expr1073748390 cpp@var3568 <@expr1073748391 Standards ::@expr1073748392 CPP11 ) {
569: return ; }
570:
571: for (@expr1073748393 Token *@expr1073748394 tok@var2155 =@expr1073748395 list@var872 .@expr1073748396 front (@expr1073748397 ) ; tok@var2155 ; tok@var2155 =@expr1073748398 tok@var2155 .@expr6575 next (@expr6576 ) ) {
572:
573: if (@expr1073748401 (@expr1073748402 Token ::@expr6579 Match (@expr1073748404 tok@var2155 , "[;{}] using %name% :: %name% ::|;" ) &&@expr1073748405 !@expr1073748406 tok@var2155 .@expr6583 tokAt (@expr1073748408 2 ) .@expr1073748409 isKeyword (@expr1073748410 ) ) ||@expr1073748411
574: (@expr1073748412 Token ::@expr6579 Match (@expr1073748414 tok@var2155 , "[;{}] using :: %name% :: %name% ::|;" ) &&@expr1073748415 !@expr1073748416 tok@var2155 .@expr6583 tokAt (@expr1073748418 3 ) .@expr1073748419 isKeyword (@expr1073748420 ) ) ) {
575: Token * endtok@var2156 ; endtok@var2156 =@expr1073748421 tok@var2155 .@expr6583 tokAt (@expr1073748423 5 ) ;
576: if (@expr1073748424 Token ::@expr6579 Match (@expr1073748426 endtok@var2156 , "%name%" ) ) {
577: endtok@var2156 =@expr1073748427 endtok@var2156 .@expr1073748428 next (@expr1073748429 ) ; }
578: while (@expr1073748430 Token ::@expr6579 Match (@expr1073748432 endtok@var2156 , ":: %name%" ) ) {
579: endtok@var2156 =@expr1073748433 endtok@var2156 .@expr1073748434 tokAt (@expr1073748435 2 ) ; }
580: if (@expr1073748436 endtok@var2156 &&@expr1073748437 endtok@var2156 .@expr6614 str (@expr6615 ) ==@expr1073748440 ";" ) {
581: tok@var2155 .@expr6575 next (@expr6576 ) .@expr1073748443 str (@expr1073748444 "typedef" ) ;
582: endtok@var2156 =@expr1073748445 endtok@var2156 .@expr1073748446 previous (@expr1073748447 ) ;
583: endtok@var2156 .@expr1073748448 insertToken (@expr1073748449 endtok@var2156 .@expr6614 str (@expr6615 ) ) ;
584: }
585: }
586: }
587: }
588:
589: void Tokenizer :: simplifyTypedef ( )
590: {
591: std ::@expr1073748453 vector < Space > spaceInfo@var2157 ;
592: bool isNamespace@var2158 ; isNamespace@var2158 =@expr1073748454 false ;
593: std ::@expr1073748455 string className@var2159 ;
594: std ::@expr1073748456 string fullClassName@var2160 ;
595: bool hasClass@var2161 ; hasClass@var2161 =@expr1073748457 false ;
596: bool goback@var2162 ; goback@var2162 =@expr1073748458 false ;
597:
598:
599: spaceInfo@var2157 .@expr1073748459 emplace_back (@expr1073748460 Space {@expr1073748461 } ) ;
600:
601:
602: simplifyUsingToTypedef (@expr1073748462 ) ;
603:
604: for (@expr1073748463 Token *@expr6640 tok@var2163 =@expr1073748465 list@var872 .@expr6642 front (@expr6643 ) ; tok@var2163 ; tok@var2163 =@expr1073748468 tok@var2163 .@expr6645 next (@expr6646 ) ) {
605: if (@expr1073748471 mErrorLogger@var880 &&@expr1073748472 !@expr1073748473 list@var872 .@expr6650 getFiles (@expr6651 ) .@expr1073748476 empty (@expr1073748477 ) ) {
606: mErrorLogger@var880 .@expr1073748478 reportProgress (@expr1073748479 list@var872 .@expr6650 getFiles (@expr6651 ) [@expr1073748482 0 ] , "Tokenize (typedef)" , tok@var2163 .@expr1073748483 progressValue (@expr1073748484 ) ) ; }
607:
608: if (@expr6661 Settings ::@expr6662 terminated (@expr6663 ) ) {
609: return ; }
610:
611: if (@expr1073748488 isMaxTime (@expr1073748489 ) ) {
612: return ; }
613:
614: if (@expr1073748490 goback@var2162 ) {
615:
616: goback@var2162 =@expr1073748491 false ;
617: tok@var2163 =@expr1073748492 tok@var2163 .@expr6669 previous (@expr6670 ) ;
618: }
619:
620: if (@expr1073748495 tok@var2163 .@expr6672 str (@expr6673 ) !=@expr1073748498 "typedef" ) {
621: if (@expr1073748499 Token ::@expr6676 simpleMatch (@expr1073748501 tok@var2163 , "( typedef" ) ) {
622:
623: tok@var2163 =@expr1073748502 tok@var2163 .@expr6645 next (@expr6646 ) ;
624: } else { if (@expr1073748505 Token ::@expr6682 Match (@expr1073748507 tok@var2163 , "class|struct|namespace %any%" ) &&@expr1073748508
625: (@expr1073748509 !@expr1073748510 tok@var2163 .@expr6669 previous (@expr6670 ) ||@expr1073748513 tok@var2163 .@expr6669 previous (@expr6670 ) .@expr1073748516 str (@expr1073748517 ) !=@expr1073748518 "enum" ) ) {
626: isNamespace@var2158 =@expr1073748519 tok@var2163 .@expr6672 str (@expr6673 ) ==@expr1073748522 "namespace" ;
627: hasClass@var2161 =@expr1073748523 true ;
628: className@var2159 =@expr1073748524 tok@var2163 .@expr6645 next (@expr6646 ) .@expr1073748527 str (@expr1073748528 ) ;
629: const Token * tok1@var2164 ; tok1@var2164 =@expr1073748529 tok@var2163 .@expr6645 next (@expr6646 ) ;
630: fullClassName@var2160 =@expr1073748532 className@var2159 ;
631: while (@expr1073748533 Token ::@expr6682 Match (@expr1073748535 tok1@var2164 , "%name% :: %name%" ) ) {
632: tok1@var2164 =@expr1073748536 tok1@var2164 .@expr1073748537 tokAt (@expr1073748538 2 ) ;
633: fullClassName@var2160 +=@expr1073748539 " :: " +@expr1073748540 tok1@var2164 .@expr1073748541 str (@expr1073748542 ) ;
634: }
635: } else { if (@expr1073748543 hasClass@var2161 &&@expr1073748544 tok@var2163 .@expr6672 str (@expr6673 ) ==@expr6723 ";" ) {
636: hasClass@var2161 =@expr1073748548 false ;
637: } else { if (@expr1073748549 hasClass@var2161 &&@expr1073748550 tok@var2163 .@expr6672 str (@expr6673 ) ==@expr1073748553 "{" ) {
638: if (@expr1073748554 !@expr1073748555 isNamespace@var2158 ) {
639: spaceInfo@var2157 .@expr6732 back (@expr6733 ) .@expr1073748558 recordTypes@var3603 .@expr1073748559 insert (@expr1073748560 fullClassName@var2160 ) ; }
640:
641: Space info@var2165 ;
642: info@var2165 .@expr1073748561 isNamespace@var2166 =@expr1073748562 isNamespace@var2158 ;
643: info@var2165 .@expr1073748563 className@var2167 =@expr1073748564 className@var2159 ;
644: info@var2165 .@expr1073748565 bodyEnd@var2168 =@expr1073748566 tok@var2163 .@expr6743 link (@expr6744 ) ;
645: info@var2165 .@expr1073748569 bodyEnd2@var2169 =@expr1073748570 tok@var2163 .@expr6743 link (@expr6744 ) ;
646: spaceInfo@var2157 .@expr1073748573 push_back (@expr1073748574 info@var2165 ) ;
647:
648: hasClass@var2161 =@expr1073748575 false ;
649: } else { if (@expr1073748576 spaceInfo@var2157 .@expr6753 size (@expr6754 ) >@expr6755 1 &&@expr1073748580 tok@var2163 .@expr6672 str (@expr6673 ) ==@expr1073748583 "}" &&@expr1073748584 spaceInfo@var2157 .@expr6732 back (@expr6733 ) .@expr1073748587 bodyEnd@var3604 ==@expr1073748588 tok@var2163 ) {
650: spaceInfo@var2157 .@expr1073748589 pop_back (@expr1073748590 ) ;
651: } } } } }
652: continue ;
653: }
654:
655:
656:
657: if (@expr1073748591 Token ::@expr6682 Match (@expr1073748593 tok@var2163 .@expr6645 next (@expr6646 ) , "const| struct|enum|union|class %type%| {|:" ) ) {
658: Token * tok1@var2170 ; tok1@var2170 =@expr1073748596 splitDefinitionFromTypedef (@expr1073748597 tok@var2163 , &@expr1073748598 mUnnamedCount@var892 ) ;
659: if (@expr1073748599 !@expr1073748600 tok1@var2170 ) {
660: continue ; }
661: tok@var2163 =@expr1073748601 tok1@var2170 ;
662: }
663:
664:
665: if (@expr1073748602 Token ::@expr6682 Match (@expr1073748604 tok@var2163 .@expr6645 next (@expr6646 ) , "enum %type% %type% ;" ) &&@expr1073748607 tok@var2163 .@expr6784 strAt (@expr1073748609 2 ) ==@expr1073748610 tok@var2163 .@expr6784 strAt (@expr1073748612 3 ) ) {
666: tok@var2163 .@expr6789 deleteNext (@expr1073748614 3 ) ;
667: tok@var2163 .@expr6791 deleteThis (@expr6792 ) ;
668: if (@expr1073748617 tok@var2163 .@expr6645 next (@expr6646 ) ) {
669: tok@var2163 .@expr6791 deleteThis (@expr6792 ) ; }
670:
671: goback@var2162 =@expr1073748622 true ;
672: continue ;
673: }
674:
675: Token * typeName@var2171 ;
676: Token * typeStart@var2172 ; typeStart@var2172 =@expr1073748623 nullptr ;
677: Token * typeEnd@var2173 ; typeEnd@var2173 =@expr1073748624 nullptr ;
678: Token * argStart@var2174 ; argStart@var2174 =@expr1073748625 nullptr ;
679: Token * argEnd@var2175 ; argEnd@var2175 =@expr1073748626 nullptr ;
680: Token * arrayStart@var2176 ; arrayStart@var2176 =@expr1073748627 nullptr ;
681: Token * arrayEnd@var2177 ; arrayEnd@var2177 =@expr1073748628 nullptr ;
682: Token * specStart@var2178 ; specStart@var2178 =@expr1073748629 nullptr ;
683: Token * specEnd@var2179 ; specEnd@var2179 =@expr1073748630 nullptr ;
684: Token * typeDef@var2180 ; typeDef@var2180 =@expr1073748631 tok@var2163 ;
685: Token * argFuncRetStart@var2181 ; argFuncRetStart@var2181 =@expr1073748632 nullptr ;
686: Token * argFuncRetEnd@var2182 ; argFuncRetEnd@var2182 =@expr1073748633 nullptr ;
687: Token * funcStart@var2183 ; funcStart@var2183 =@expr1073748634 nullptr ;
688: Token * funcEnd@var2184 ; funcEnd@var2184 =@expr1073748635 nullptr ;
689: Token * tokOffset@var2185 ; tokOffset@var2185 =@expr1073748636 tok@var2163 .@expr6645 next (@expr6646 ) ;
690: bool function@var2186 ; function@var2186 =@expr1073748639 false ;
691: bool functionPtr@var2187 ; functionPtr@var2187 =@expr1073748640 false ;
692: bool functionRetFuncPtr@var2188 ; functionRetFuncPtr@var2188 =@expr1073748641 false ;
693: bool functionPtrRetFuncPtr@var2189 ; functionPtrRetFuncPtr@var2189 =@expr1073748642 false ;
694: bool ptrToArray@var2190 ; ptrToArray@var2190 =@expr1073748643 false ;
695: bool refToArray@var2191 ; refToArray@var2191 =@expr1073748644 false ;
696: bool ptrMember@var2192 ; ptrMember@var2192 =@expr1073748645 false ;
697: bool typeOf@var2193 ; typeOf@var2193 =@expr1073748646 false ;
698: Token * namespaceStart@var2194 ; namespaceStart@var2194 =@expr1073748647 nullptr ;
699: Token * namespaceEnd@var2195 ; namespaceEnd@var2195 =@expr1073748648 nullptr ;
700:
701:
702: if (@expr6825 !@expr6826 tokOffset@var2185 ) {
703: syntaxError (@expr6827 tok@var2163 ) ; }
704:
705:
706: if (@expr1073748652 tokOffset@var2185 .@expr6829 str (@expr6830 ) ==@expr6831 "::" ) {
707: typeStart@var2172 =@expr1073748656 tokOffset@var2185 ;
708: tokOffset@var2185 =@expr1073748657 tokOffset@var2185 .@expr6834 next (@expr6835 ) ;
709:
710: while (@expr6836 Token ::@expr6682 Match (@expr6838 tokOffset@var2185 , "%type% ::" ) ) {
711: tokOffset@var2185 =@expr1073748663 tokOffset@var2185 .@expr6840 tokAt (@expr6841 2 ) ; }
712:
713: typeEnd@var2173 =@expr1073748666 tokOffset@var2185 ;
714:
715: if (@expr6843 Token ::@expr6682 Match (@expr6845 tokOffset@var2185 , "%type%" ) ) {
716: tokOffset@var2185 =@expr1073748670 tokOffset@var2185 .@expr6834 next (@expr6835 ) ; }
717: } else { if (@expr1073748673 Token ::@expr6682 Match (@expr6838 tokOffset@var2185 , "%type% ::" ) ) {
718: typeStart@var2172 =@expr1073748676 tokOffset@var2185 ;
719:
720: do {
721: tokOffset@var2185 =@expr1073748677 tokOffset@var2185 .@expr6840 tokAt (@expr6841 2 ) ;
722: } while (@expr6836 Token ::@expr6682 Match (@expr6838 tokOffset@var2185 , "%type% ::" ) ) ;
723:
724: typeEnd@var2173 =@expr1073748683 tokOffset@var2185 ;
725:
726: if (@expr6843 Token ::@expr6682 Match (@expr6845 tokOffset@var2185 , "%type%" ) ) {
727: tokOffset@var2185 =@expr1073748687 tokOffset@var2185 .@expr6834 next (@expr6835 ) ; }
728: } else { if (@expr6843 Token ::@expr6682 Match (@expr6845 tokOffset@var2185 , "%type%" ) ) {
729: typeStart@var2172 =@expr1073748693 tokOffset@var2185 ;
730:
731: while (@expr1073748694 Token ::@expr6682 Match (@expr1073748696 tokOffset@var2185 , "const|struct|enum %type%" ) ||@expr1073748697
732: (@expr1073748698 tokOffset@var2185 .@expr6834 next (@expr6835 ) &&@expr1073748701 tokOffset@var2185 .@expr6834 next (@expr6835 ) .@expr1073748704 isStandardType (@expr1073748705 ) ) ) {
733: tokOffset@var2185 =@expr1073748706 tokOffset@var2185 .@expr6834 next (@expr6835 ) ; }
734:
735: typeEnd@var2173 =@expr1073748709 tokOffset@var2185 ;
736: tokOffset@var2185 =@expr1073748710 tokOffset@var2185 .@expr6834 next (@expr6835 ) ;
737:
738: while (@expr1073748713 Token ::@expr6682 Match (@expr6845 tokOffset@var2185 , "%type%" ) &&@expr1073748716
739: (@expr1073748717 tokOffset@var2185 .@expr1073748718 isStandardType (@expr1073748719 ) ||@expr1073748720 Token ::@expr6682 Match (@expr1073748722 tokOffset@var2185 , "unsigned|signed" ) ) ) {
740: typeEnd@var2173 =@expr1073748723 tokOffset@var2185 ;
741: tokOffset@var2185 =@expr1073748724 tokOffset@var2185 .@expr6834 next (@expr6835 ) ;
742: }
743:
744: bool atEnd@var2196 ; atEnd@var2196 =@expr1073748727 false ;
745: while (@expr1073748728 !@expr1073748729 atEnd@var2196 ) {
746: if (@expr1073748730 tokOffset@var2185 &&@expr1073748731 tokOffset@var2185 .@expr6829 str (@expr6830 ) ==@expr6831 "::" ) {
747: typeEnd@var2173 =@expr1073748735 tokOffset@var2185 ;
748: tokOffset@var2185 =@expr1073748736 tokOffset@var2185 .@expr6834 next (@expr6835 ) ;
749: }
750:
751: if (@expr1073748739 Token ::@expr6682 Match (@expr6845 tokOffset@var2185 , "%type%" ) &&@expr1073748742
752: tokOffset@var2185 .@expr6834 next (@expr6835 ) &&@expr1073748745 !@expr1073748746 Token ::@expr6682 Match (@expr1073748748 tokOffset@var2185 .@expr6834 next (@expr6835 ) , "[|;|,|(" ) ) {
753: typeEnd@var2173 =@expr1073748751 tokOffset@var2185 ;
754: tokOffset@var2185 =@expr1073748752 tokOffset@var2185 .@expr6834 next (@expr6835 ) ;
755: } else { if (@expr1073748755 Token ::@expr6676 simpleMatch (@expr1073748757 tokOffset@var2185 , "const (" ) ) {
756: typeEnd@var2173 =@expr1073748758 tokOffset@var2185 ;
757: tokOffset@var2185 =@expr1073748759 tokOffset@var2185 .@expr6834 next (@expr6835 ) ;
758: atEnd@var2196 =@expr1073748762 true ;
759: } else {
760: atEnd@var2196 =@expr1073748763 true ; } }
761: }
762: } else {
763: continue ; } } }
764:
765:
766: if (@expr6825 !@expr6826 tokOffset@var2185 ) {
767: syntaxError (@expr6827 tok@var2163 ) ; }
768:
769:
770: if (@expr1073748767 !@expr1073748768 isC (@expr1073748769 ) &&@expr1073748770 tokOffset@var2185 .@expr6829 str (@expr6830 ) ==@expr1073748773 "<" ) {
771: typeEnd@var2173 =@expr1073748774 tokOffset@var2185 .@expr1073748775 findClosingBracket (@expr1073748776 ) ;
772:
773: while (@expr1073748777 typeEnd@var2173 &&@expr1073748778 Token ::@expr6682 Match (@expr1073748780 typeEnd@var2173 .@expr6957 next (@expr6958 ) , ":: %type%" ) ) {
774: typeEnd@var2173 =@expr1073748783 typeEnd@var2173 .@expr1073748784 tokAt (@expr1073748785 2 ) ; }
775:
776: if (@expr1073748786 !@expr1073748787 typeEnd@var2173 ) {
777:
778: return ;
779: }
780:
781: while (@expr1073748788 Token ::@expr6682 Match (@expr1073748790 typeEnd@var2173 .@expr6957 next (@expr6958 ) , "const|volatile" ) ) {
782: typeEnd@var2173 =@expr1073748793 typeEnd@var2173 .@expr6957 next (@expr6958 ) ; }
783:
784: tok@var2163 =@expr1073748796 typeEnd@var2173 ;
785: tokOffset@var2185 =@expr1073748797 tok@var2163 .@expr6645 next (@expr6646 ) ;
786: }
787:
788: std ::@expr1073748800 list < std ::@expr6977 string > pointers@var2197 ;
789:
790: while (@expr1073748802 Token ::@expr6682 Match (@expr1073748804 tokOffset@var2185 , "*|&|&&|const" ) ) {
791: pointers@var2197 .@expr6981 push_back (@expr6982 tokOffset@var2185 .@expr6829 str (@expr6830 ) ) ;
792: tokOffset@var2185 =@expr1073748809 tokOffset@var2185 .@expr6834 next (@expr6835 ) ;
793: }
794:
795:
796: if (@expr6825 !@expr6826 tokOffset@var2185 ) {
797: syntaxError (@expr6827 tok@var2163 ) ; }
798:
799: if (@expr1073748815 tokOffset@var2185 .@expr1073748816 isName (@expr1073748817 ) &&@expr1073748818 !@expr1073748819 tokOffset@var2185 .@expr1073748820 isKeyword (@expr1073748821 ) ) {
800:
801: typeName@var2171 =@expr1073748822 tokOffset@var2185 ;
802: tokOffset@var2185 =@expr1073748823 tokOffset@var2185 .@expr6834 next (@expr6835 ) ;
803:
804:
805: while (@expr1073748826 tokOffset@var2185 &&@expr7003 tokOffset@var2185 .@expr6829 str (@expr6830 ) ==@expr7006 "[" ) {
806: if (@expr1073748831 !@expr1073748832 arrayStart@var2176 ) {
807: arrayStart@var2176 =@expr1073748833 tokOffset@var2185 ; }
808: arrayEnd@var2177 =@expr1073748834 tokOffset@var2185 .@expr7011 link (@expr7012 ) ;
809: tokOffset@var2185 =@expr1073748837 arrayEnd@var2177 .@expr7014 next (@expr7015 ) ;
810: }
811:
812:
813: if (@expr7016 Token ::@expr6682 Match (@expr7018 tokOffset@var2185 , ";|," ) ) {
814: tok@var2163 =@expr1073748843 tokOffset@var2185 ; }
815:
816:
817: else { if (@expr1073748844 tokOffset@var2185 &&@expr1073748845 tokOffset@var2185 .@expr6829 str (@expr6830 ) ==@expr7024 "(" ) {
818: Token * tokOffset2@var2198 ; tokOffset2@var2198 =@expr1073748849 nullptr ;
819: if (@expr1073748850 Token ::@expr6682 Match (@expr1073748852 tokOffset@var2185 , "( *|%name%" ) ) {
820: tokOffset2@var2198 =@expr1073748853 tokOffset@var2185 .@expr6834 next (@expr6835 ) ;
821: if (@expr1073748856 tokOffset2@var2198 .@expr1073748857 str (@expr1073748858 ) ==@expr1073748859 "typename" ) {
822: tokOffset2@var2198 =@expr1073748860 tokOffset2@var2198 .@expr1073748861 next (@expr1073748862 ) ; }
823: while (@expr1073748863 Token ::@expr6682 Match (@expr1073748865 tokOffset2@var2198 , "%type% ::" ) ) {
824: tokOffset2@var2198 =@expr1073748866 tokOffset2@var2198 .@expr7043 tokAt (@expr1073748868 2 ) ; }
825: }
826:
827:
828: if (@expr1073748869 typeName@var2171 .@expr7046 str (@expr7047 ) ==@expr1073748872 "void" ) {
829: unsupportedTypedef (@expr7049 typeDef@var2180 ) ;
830: tok@var2163 =@expr1073748874 deleteInvalidTypedef (@expr7051 typeDef@var2180 ) ;
831: if (@expr7052 tok@var2163 ==@expr7053 list@var872 .@expr6642 front (@expr6643 ) ) {
832:
833: goback@var2162 =@expr1073748880 true ; }
834: continue ;
835: }
836:
837:
838: else { if (@expr1073748881 Token ::@expr6682 Match (@expr1073748883 tokOffset2@var2198 , "* %name% ) (" ) ) {
839:
840: typeEnd@var2173 =@expr1073748884 typeEnd@var2173 .@expr6957 next (@expr6958 ) ;
841: functionPtr@var2187 =@expr1073748887 true ;
842: funcStart@var2183 =@expr1073748888 tokOffset2@var2198 ; funcEnd@var2184 =@expr1073748889 tokOffset2@var2198 ;
843: tokOffset@var2185 =@expr1073748890 tokOffset2@var2198 .@expr7043 tokAt (@expr1073748892 3 ) ;
844: typeName@var2171 =@expr1073748893 tokOffset@var2185 .@expr6840 tokAt (@expr7071 -2 ) ;
845: argStart@var2174 =@expr1073748896 tokOffset@var2185 ;
846: argEnd@var2175 =@expr1073748897 tokOffset@var2185 .@expr7011 link (@expr7012 ) ;
847: tok@var2163 =@expr1073748900 argEnd@var2175 .@expr7077 next (@expr7078 ) ;
848: }
849:
850:
851: else { if (@expr1073748903 isFunctionHead (@expr1073748904 tokOffset@var2185 .@expr7011 link (@expr7012 ) , ";," ) ) {
852: function@var2186 =@expr1073748907 true ;
853: if (@expr1073748908 tokOffset@var2185 .@expr7011 link (@expr7012 ) .@expr7087 next (@expr7088 ) .@expr1073748913 str (@expr1073748914 ) ==@expr1073748915 "const" ) {
854: specStart@var2178 =@expr1073748916 tokOffset@var2185 .@expr7011 link (@expr7012 ) .@expr7087 next (@expr7088 ) ;
855: specEnd@var2179 =@expr1073748921 specStart@var2178 ;
856: }
857: argStart@var2174 =@expr1073748922 tokOffset@var2185 ;
858: argEnd@var2175 =@expr1073748923 tokOffset@var2185 .@expr7011 link (@expr7012 ) ;
859: tok@var2163 =@expr1073748926 argEnd@var2175 .@expr7077 next (@expr7078 ) ;
860: if (@expr7105 specStart@var2178 ) {
861: tok@var2163 =@expr1073748930 tok@var2163 .@expr6645 next (@expr6646 ) ; }
862: }
863:
864:
865: else {
866: syntaxError (@expr6827 tok@var2163 ) ; } } }
867: }
868:
869:
870: else {
871: unsupportedTypedef (@expr7049 typeDef@var2180 ) ;
872: tok@var2163 =@expr1073748935 deleteInvalidTypedef (@expr7051 typeDef@var2180 ) ;
873: if (@expr7052 tok@var2163 ==@expr7053 list@var872 .@expr6642 front (@expr6643 ) ) {
874:
875: goback@var2162 =@expr1073748941 true ; }
876: continue ;
877: } }
878: }
879:
880:
881: else { if (@expr1073748942 Token ::@expr6676 simpleMatch (@expr1073748944 tokOffset@var2185 .@expr7121 previous (@expr7122 ) , "typeof (" ) &&@expr1073748947
882: Token ::@expr6682 Match (@expr1073748949 tokOffset@var2185 .@expr7011 link (@expr7012 ) , ") %type% ;" ) ) {
883: argStart@var2174 =@expr1073748952 tokOffset@var2185 ;
884: argEnd@var2175 =@expr1073748953 tokOffset@var2185 .@expr7011 link (@expr7012 ) ;
885: typeName@var2171 =@expr1073748956 tokOffset@var2185 .@expr7011 link (@expr7012 ) .@expr7087 next (@expr7088 ) ;
886: tok@var2163 =@expr1073748961 typeName@var2171 .@expr1073748962 next (@expr1073748963 ) ;
887: typeOf@var2193 =@expr1073748964 true ;
888: }
889:
|
892:
893: else { if (@expr1073748965 tokOffset@var2185 .@expr6829 str (@expr6830 ) ==@expr7024 "(" &&@expr1073748969 (@expr1073748970
894: (@expr1073748971 tokOffset@var2185 .@expr7011 link (@expr7012 ) &&@expr1073748974 Token ::@expr6682 Match (@expr1073748976 tokOffset@var2185 .@expr7011 link (@expr7012 ) .@expr1073748979 previous (@expr1073748980 ) , "%type% ) (" ) &&@expr1073748981
895: Token ::@expr6682 Match (@expr1073748983 tokOffset@var2185 .@expr7011 link (@expr7012 ) .@expr7087 next (@expr7088 ) .@expr1073748988 link (@expr1073748989 ) , ") const|volatile|;" ) ) ||@expr1073748990
896: (@expr1073748991 Token ::@expr6676 simpleMatch (@expr1073748993 tokOffset@var2185 , "( (" ) &&@expr1073748994
897: tokOffset@var2185 .@expr6834 next (@expr6835 ) &&@expr1073748997 Token ::@expr6682 Match (@expr1073748999 tokOffset@var2185 .@expr6834 next (@expr6835 ) .@expr7178 link (@expr7179 ) .@expr1073749004 previous (@expr1073749005 ) , "%type% ) (" ) &&@expr1073749006
898: Token ::@expr6682 Match (@expr1073749008 tokOffset@var2185 .@expr6834 next (@expr6835 ) .@expr7178 link (@expr7179 ) .@expr1073749013 next (@expr1073749014 ) .@expr1073749015 link (@expr1073749016 ) , ") const|volatile| ) ;|," ) ) ||@expr1073749017
899: (@expr1073749018 Token ::@expr6676 simpleMatch (@expr7196 tokOffset@var2185 , "( * (" ) &&@expr1073749021
900: tokOffset@var2185 .@expr7198 linkAt (@expr7199 2 ) &&@expr1073749024 Token ::@expr6682 Match (@expr1073749026 tokOffset@var2185 .@expr7198 linkAt (@expr7199 2 ) .@expr1073749029 previous (@expr1073749030 ) , "%type% ) (" ) &&@expr1073749031
901: Token ::@expr6682 Match (@expr1073749033 tokOffset@var2185 .@expr7198 linkAt (@expr7199 2 ) .@expr1073749036 next (@expr1073749037 ) .@expr1073749038 link (@expr1073749039 ) , ") const|volatile| ) ;|," ) ) ) ) {
902: if (@expr1073749040 tokOffset@var2185 .@expr6834 next (@expr6835 ) .@expr7219 str (@expr7220 ) ==@expr1073749045 "(" ) {
903: tokOffset@var2185 =@expr1073749046 tokOffset@var2185 .@expr6834 next (@expr6835 ) ; }
904: else { if (@expr1073749049 Token ::@expr6676 simpleMatch (@expr7196 tokOffset@var2185 , "( * (" ) ) {
905: pointers@var2197 .@expr1073749052 emplace_back (@expr1073749053 "*" ) ;
906: tokOffset@var2185 =@expr1073749054 tokOffset@var2185 .@expr6840 tokAt (@expr6841 2 ) ;
907: } }
908:
909: if (@expr1073749057 tokOffset@var2185 .@expr7011 link (@expr7012 ) .@expr1073749060 strAt (@expr1073749061 -2 ) ==@expr1073749062 "*" ) {
910: functionPtr@var2187 =@expr1073749063 true ; }
911: else {
912: function@var2186 =@expr1073749064 true ; }
913: funcStart@var2183 =@expr1073749065 tokOffset@var2185 .@expr6834 next (@expr6835 ) ;
914: tokOffset@var2185 =@expr1073749068 tokOffset@var2185 .@expr7011 link (@expr7012 ) ;
915: funcEnd@var2184 =@expr1073749071 tokOffset@var2185 .@expr6840 tokAt (@expr7071 -2 ) ;
916: typeName@var2171 =@expr1073749074 tokOffset@var2185 .@expr7121 previous (@expr7122 ) ;
917: argStart@var2174 =@expr1073749077 tokOffset@var2185 .@expr6834 next (@expr6835 ) ;
918: argEnd@var2175 =@expr1073749080 tokOffset@var2185 .@expr6834 next (@expr6835 ) .@expr7178 link (@expr7179 ) ;
919: if (@expr7261 !@expr7262 argEnd@var2175 ) {
920: syntaxError (@expr1073749087 argStart@var2174 ) ; }
921:
922: tok@var2163 =@expr1073749088 argEnd@var2175 .@expr7077 next (@expr7078 ) ;
923: Token * spec@var2199 ; spec@var2199 =@expr1073749091 tok@var2163 ;
924: if (@expr1073749092 Token ::@expr6682 Match (@expr1073749094 spec@var2199 , "const|volatile" ) ) {
925: specStart@var2178 =@expr1073749095 spec@var2199 ;
926: specEnd@var2179 =@expr1073749096 spec@var2199 ;
927: while (@expr1073749097 Token ::@expr6682 Match (@expr1073749099 spec@var2199 .@expr7276 next (@expr7277 ) , "const|volatile" ) ) {
928: specEnd@var2179 =@expr1073749102 spec@var2199 .@expr7276 next (@expr7277 ) ;
929: spec@var2199 =@expr1073749105 specEnd@var2179 ;
930: }
931: tok@var2163 =@expr1073749106 specEnd@var2179 .@expr1073749107 next (@expr1073749108 ) ;
932: }
933: if (@expr7285 !@expr7286 tok@var2163 ) {
934: syntaxError (@expr1073749111 specEnd@var2179 ) ; }
935:
936: if (@expr1073749112 tok@var2163 .@expr6672 str (@expr6673 ) ==@expr1073749115 ")" ) {
937: tok@var2163 =@expr1073749116 tok@var2163 .@expr6645 next (@expr6646 ) ; }
938: }
939:
940: else { if (@expr1073749119 Token ::@expr6682 Match (@expr1073749121 tokOffset@var2185 , "( %type% (" ) ) {
941: function@var2186 =@expr1073749122 true ;
942: if (@expr1073749123 tokOffset@var2185 .@expr7011 link (@expr7012 ) .@expr7087 next (@expr7088 ) ) {
943: tok@var2163 =@expr1073749128 tokOffset@var2185 .@expr7011 link (@expr7012 ) .@expr7087 next (@expr7088 ) ;
944: tokOffset@var2185 =@expr1073749133 tokOffset@var2185 .@expr6840 tokAt (@expr6841 2 ) ;
945: typeName@var2171 =@expr1073749136 tokOffset@var2185 .@expr7121 previous (@expr7122 ) ;
946: argStart@var2174 =@expr1073749139 tokOffset@var2185 ;
947: argEnd@var2175 =@expr1073749140 tokOffset@var2185 .@expr7011 link (@expr7012 ) ;
948: } else {
949:
950: continue ;
951: }
952: }
953:
954:
955: else { if (@expr1073749143 Token ::@expr6682 Match (@expr1073749145 tokOffset@var2185 , "( * ( * %type% ) (" ) &&@expr1073749146
956: Token ::@expr6676 simpleMatch (@expr1073749148 tokOffset@var2185 .@expr7198 linkAt (@expr7326 6 ) , ") ) (" ) &&@expr1073749151
957: Token ::@expr6682 Match (@expr1073749153 tokOffset@var2185 .@expr7198 linkAt (@expr7326 6 ) .@expr1073749156 linkAt (@expr1073749157 2 ) , ") ;|," ) ) {
958: functionPtrRetFuncPtr@var2189 =@expr1073749158 true ;
959:
960: tokOffset@var2185 =@expr1073749159 tokOffset@var2185 .@expr6840 tokAt (@expr1073749161 6 ) ;
961: typeName@var2171 =@expr1073749162 tokOffset@var2185 .@expr6840 tokAt (@expr7071 -2 ) ;
962: argStart@var2174 =@expr1073749165 tokOffset@var2185 ;
963: argEnd@var2175 =@expr1073749166 tokOffset@var2185 .@expr7011 link (@expr7012 ) ;
964: if (@expr7261 !@expr7262 argEnd@var2175 ) {
965: syntaxError (@expr7347 arrayStart@var2176 ) ; }
966:
967: argFuncRetStart@var2181 =@expr1073749172 argEnd@var2175 .@expr7349 tokAt (@expr7350 2 ) ;
968: argFuncRetEnd@var2182 =@expr1073749175 argFuncRetStart@var2181 .@expr7352 link (@expr7353 ) ;
969: if (@expr7354 !@expr7355 argFuncRetEnd@var2182 ) {
970: syntaxError (@expr1073749180 argFuncRetStart@var2181 ) ; }
971:
972: tok@var2163 =@expr1073749181 argFuncRetEnd@var2182 .@expr7358 next (@expr7359 ) ;
973: }
974:
975:
976: else { if (@expr1073749184 Token ::@expr6682 Match (@expr1073749186 tokOffset@var2185 , "( * %type% (" ) &&@expr1073749187
977: Token ::@expr6676 simpleMatch (@expr1073749189 tokOffset@var2185 .@expr7198 linkAt (@expr7367 3 ) , ") ) (" ) &&@expr1073749192
978: Token ::@expr6682 Match (@expr1073749194 tokOffset@var2185 .@expr7198 linkAt (@expr7367 3 ) .@expr1073749197 linkAt (@expr1073749198 2 ) , ") ;|," ) ) {
979: functionRetFuncPtr@var2188 =@expr1073749199 true ;
980:
981: tokOffset@var2185 =@expr1073749200 tokOffset@var2185 .@expr6840 tokAt (@expr1073749202 3 ) ;
982: typeName@var2171 =@expr1073749203 tokOffset@var2185 .@expr7121 previous (@expr7122 ) ;
983: argStart@var2174 =@expr1073749206 tokOffset@var2185 ;
984: argEnd@var2175 =@expr1073749207 tokOffset@var2185 .@expr7011 link (@expr7012 ) ;
985:
986: argFuncRetStart@var2181 =@expr1073749210 argEnd@var2175 .@expr7349 tokAt (@expr7350 2 ) ;
987: if (@expr7389 !@expr7390 argFuncRetStart@var2181 ) {
988: syntaxError (@expr7391 tokOffset@var2185 ) ; }
989:
990: argFuncRetEnd@var2182 =@expr1073749216 argFuncRetStart@var2181 .@expr7352 link (@expr7353 ) ;
991: if (@expr7354 !@expr7355 argFuncRetEnd@var2182 ) {
992: syntaxError (@expr7391 tokOffset@var2185 ) ; }
993:
994: tok@var2163 =@expr1073749222 argFuncRetEnd@var2182 .@expr7358 next (@expr7359 ) ;
995: } else { if (@expr1073749225 Token ::@expr6682 Match (@expr1073749227 tokOffset@var2185 , "( * ( %type% ) (" ) ) {
996: functionRetFuncPtr@var2188 =@expr1073749228 true ;
997:
998: tokOffset@var2185 =@expr1073749229 tokOffset@var2185 .@expr6840 tokAt (@expr1073749231 5 ) ;
999: typeName@var2171 =@expr1073749232 tokOffset@var2185 .@expr6840 tokAt (@expr7071 -2 ) ;
1000: argStart@var2174 =@expr1073749235 tokOffset@var2185 ;
1001: argEnd@var2175 =@expr1073749236 tokOffset@var2185 .@expr7011 link (@expr7012 ) ;
1002: if (@expr7261 !@expr7262 argEnd@var2175 ) {
1003: syntaxError (@expr7347 arrayStart@var2176 ) ; }
1004:
1005: argFuncRetStart@var2181 =@expr1073749242 argEnd@var2175 .@expr7349 tokAt (@expr7350 2 ) ;
1006: if (@expr7389 !@expr7390 argFuncRetStart@var2181 ) {
1007: syntaxError (@expr7391 tokOffset@var2185 ) ; }
1008:
1009: argFuncRetEnd@var2182 =@expr1073749248 argFuncRetStart@var2181 .@expr7352 link (@expr7353 ) ;
1010: if (@expr7354 !@expr7355 argFuncRetEnd@var2182 ) {
1011: syntaxError (@expr7391 tokOffset@var2185 ) ; }
1012:
1013: tok@var2163 =@expr1073749254 argFuncRetEnd@var2182 .@expr7358 next (@expr7359 ) ;
1014: }
1015:
1016:
1017: else { if (@expr1073749257 Token ::@expr6682 Match (@expr1073749259 tokOffset@var2185 , "( *|& %type% ) [" ) ) {
1018: ptrToArray@var2190 =@expr1073749260 tokOffset@var2185 .@expr6834 next (@expr6835 ) .@expr7219 str (@expr7220 ) ==@expr1073749265 "*" ;
1019: refToArray@var2191 =@expr1073749266 !@expr1073749267 ptrToArray@var2190 ;
1020: tokOffset@var2185 =@expr1073749268 tokOffset@var2185 .@expr6840 tokAt (@expr6841 2 ) ;
1021: typeName@var2171 =@expr1073749271 tokOffset@var2185 ;
1022: arrayStart@var2176 =@expr1073749272 tokOffset@var2185 .@expr6840 tokAt (@expr6841 2 ) ;
1023: arrayEnd@var2177 =@expr1073749275 arrayStart@var2176 .@expr1073749276 link (@expr1073749277 ) ;
1024: if (@expr1073749278 !@expr1073749279 arrayEnd@var2177 ) {
1025: syntaxError (@expr7347 arrayStart@var2176 ) ; }
1026:
1027: tok@var2163 =@expr1073749281 arrayEnd@var2177 .@expr7014 next (@expr7015 ) ;
1028: }
1029:
1030:
1031: else { if (@expr1073749284 Token ::@expr6682 Match (@expr1073749286 tokOffset@var2185 , "( %type% :: * %type% ) ;" ) ) {
1032: tokOffset@var2185 =@expr1073749287 tokOffset@var2185 .@expr6840 tokAt (@expr6841 2 ) ;
1033: namespaceStart@var2194 =@expr1073749290 tokOffset@var2185 .@expr7121 previous (@expr7122 ) ;
1034: namespaceEnd@var2195 =@expr1073749293 tokOffset@var2185 ;
1035: ptrMember@var2192 =@expr1073749294 true ;
1036: tokOffset@var2185 =@expr1073749295 tokOffset@var2185 .@expr6840 tokAt (@expr6841 2 ) ;
1037: typeName@var2171 =@expr1073749298 tokOffset@var2185 ;
1038: tok@var2163 =@expr1073749299 tokOffset@var2185 .@expr6840 tokAt (@expr6841 2 ) ;
1039: }
1040:
1041:
1042: else {
1043: unsupportedTypedef (@expr7049 typeDef@var2180 ) ;
1044: tok@var2163 =@expr1073749303 deleteInvalidTypedef (@expr7051 typeDef@var2180 ) ;
1045: if (@expr7052 tok@var2163 ==@expr7053 list@var872 .@expr6642 front (@expr6643 ) ) {
1046:
1047: goback@var2162 =@expr1073749309 true ; }
1048: continue ;
1049: } } } } } } } } }
1050:
1051: bool done@var2200 ; done@var2200 =@expr1073749310 false ;
1052: bool ok@var2201 ; ok@var2201 =@expr1073749311 true ;
1053:
1054: TypedefInfo typedefInfo@var2202 ;
1055: typedefInfo@var2202 .@expr1073749312 name@var2203 =@expr1073749313 typeName@var2171 .@expr7046 str (@expr7047 ) ;
1056: typedefInfo@var2202 .@expr1073749316 filename@var2204 =@expr1073749317 list@var872 .@expr1073749318 file (@expr1073749319 typeName@var2171 ) ;
1057: typedefInfo@var2202 .@expr1073749320 lineNumber@var2205 =@expr1073749321 typeName@var2171 .@expr1073749322 linenr (@expr1073749323 ) ;
1058: typedefInfo@var2202 .@expr1073749324 column@var2206 =@expr1073749325 typeName@var2171 .@expr1073749326 column (@expr1073749327 ) ;
1059: typedefInfo@var2202 .@expr1073749328 used@var2207 =@expr1073749329 false ;
1060: mTypedefInfo@var890 .@expr1073749330 push_back (@expr1073749331 typedefInfo@var2202 ) ;
1061:
1062: while (@expr1073749332 !@expr1073749333 done@var2200 ) {
1063: std ::@expr1073749334 string pattern@var2208 ; pattern@var2208 =@expr1073749335 typeName@var2171 .@expr7046 str (@expr7047 ) ;
1064: int scope@var2209 ; scope@var2209 =@expr1073749338 0 ;
1065: bool simplifyType@var2210 ; simplifyType@var2210 =@expr1073749339 false ;
1066: bool inMemberFunc@var2211 ; inMemberFunc@var2211 =@expr1073749340 false ;
1067: int memberScope@var2212 ; memberScope@var2212 =@expr1073749341 0 ;
1068: bool globalScope@var2213 ; globalScope@var2213 =@expr1073749342 false ;
1069: int classLevel@var2214 ; classLevel@var2214 =@expr1073749343 spaceInfo@var2157 .@expr6753 size (@expr6754 ) ;
1070: bool inTypeDef@var2215 ; inTypeDef@var2215 =@expr1073749346 false ;
1071: bool inEnumClass@var2216 ; inEnumClass@var2216 =@expr1073749347 false ;
1072: std ::@expr1073749348 string removed@var2217 ;
1073: std ::@expr1073749349 string classPath@var2218 ;
1074: for (@expr1073749350 unsigned long i@var2219 =@expr1073749351 1 ; i@var2219 <@expr1073749352 spaceInfo@var2157 .@expr6753 size (@expr6754 ) ; ++@expr1073749355 i@var2219 ) {
1075: if (@expr1073749356 !@expr1073749357 classPath@var2218 .@expr1073749358 empty (@expr1073749359 ) ) {
1076: classPath@var2218 +=@expr1073749360 " :: " ; }
1077: classPath@var2218 +=@expr1073749361 spaceInfo@var2157 [@expr1073749362 i@var2219 ] .@expr1073749363 className@var3605 ;
1078: }
1079:
1080: for (@expr1073749364 Token *@expr6640 tok2@var2220 =@expr1073749366 tok@var2163 ; tok2@var2220 ; tok2@var2220 =@expr1073749367 tok2@var2220 .@expr7544 next (@expr7545 ) ) {
1081: if (@expr6661 Settings ::@expr6662 terminated (@expr6663 ) ) {
1082: return ; }
1083:
1084: removed@var2217 .@expr1073749373 clear (@expr1073749374 ) ;
1085:
1086: if (@expr1073749375 Token ::@expr6676 simpleMatch (@expr1073749377 tok2@var2220 , "typedef" ) ) {
1087: inTypeDef@var2215 =@expr1073749378 true ; }
1088:
1089: if (@expr1073749379 inTypeDef@var2215 &&@expr1073749380 Token ::@expr6676 simpleMatch (@expr1073749382 tok2@var2220 , ";" ) ) {
1090: inTypeDef@var2215 =@expr1073749383 false ; }
1091:
1092:
1093: if (@expr1073749384 !@expr1073749385 inTypeDef@var2215 &&@expr1073749386 spaceInfo@var2157 .@expr6753 size (@expr6754 ) ==@expr1073749389 1 &&@expr1073749390 Token ::@expr6682 Match (@expr1073749392 tok2@var2220 .@expr7569 previous (@expr7570 ) , "%name%" ) &&@expr1073749395
1094: !@expr1073749396 tok2@var2220 .@expr7569 previous (@expr7570 ) .@expr1073749399 isKeyword (@expr1073749400 ) ) {
1095: Token * varDecl@var2221 ; varDecl@var2221 =@expr1073749401 tok2@var2220 ;
1096: while (@expr1073749402 Token ::@expr6682 Match (@expr1073749404 varDecl@var2221 , "*|&|&&|const" ) ) {
1097: varDecl@var2221 =@expr1073749405 varDecl@var2221 .@expr1073749406 next (@expr1073749407 ) ; }
1098: if (@expr1073749408 Token ::@expr6682 Match (@expr1073749410 varDecl@var2221 , "%name% ;|,|)|=" ) &&@expr1073749411 varDecl@var2221 .@expr1073749412 str (@expr1073749413 ) ==@expr1073749414 typeName@var2171 .@expr7046 str (@expr7047 ) ) {
1099:
1100: if (@expr1073749417 Token ::@expr6682 Match (@expr1073749419 varDecl@var2221 , "%name% ) {" ) ) {
1101: tok2@var2220 =@expr1073749420 varDecl@var2221 .@expr1073749421 linkAt (@expr1073749422 2 ) .@expr1073749423 next (@expr1073749424 ) ;
1102: } else {
1103: tok2@var2220 =@expr1073749425 varDecl@var2221 ;
1104: while (@expr1073749426 tok2@var2220 &&@expr1073749427 !@expr1073749428 Token ::@expr6676 simpleMatch (@expr1073749430 tok2@var2220 , "}" ) ) {
1105: if (@expr1073749431 Token ::@expr6682 Match (@expr1073749433 tok2@var2220 , "(|{|[" ) ) {
1106: tok2@var2220 =@expr1073749434 tok2@var2220 .@expr7611 link (@expr7612 ) ; }
1107: tok2@var2220 =@expr1073749437 tok2@var2220 .@expr7544 next (@expr7545 ) ;
1108: }
1109: }
1110: if (@expr7616 !@expr7617 tok2@var2220 ) {
1111: break ; }
1112: continue ;
1113: }
1114: }
1115:
1116: if (@expr1073749442 tok2@var2220 .@expr7611 link (@expr7612 ) ) {
1117:
1118: if (@expr1073749445 tok2@var2220 .@expr7622 str (@expr7623 ) ==@expr1073749448 "}" ) {
1119:
1120: if (@expr7625 inMemberFunc@var2211 ) {
1121: --@expr1073749450 memberScope@var2212 ;
1122: if (@expr1073749451 memberScope@var2212 ==@expr1073749452 0 ) {
1123: inMemberFunc@var2211 =@expr1073749453 false ; }
1124: }
1125: inEnumClass@var2216 =@expr1073749454 false ;
1126:
1127: if (@expr1073749455 classLevel@var2214 >@expr1073749456 1 &&@expr1073749457 tok2@var2220 ==@expr1073749458 spaceInfo@var2157 [@expr1073749459 classLevel@var2214 -@expr7636 1 ] .@expr1073749461 bodyEnd2@var3606 ) {
1128: --@expr1073749462 classLevel@var2214 ;
1129: pattern@var2208 .@expr7639 clear (@expr7640 ) ;
1130:
1131: for (@expr1073749465 int i@var2222 =@expr1073749466 classLevel@var2214 ; i@var2222 <@expr1073749467 spaceInfo@var2157 .@expr6753 size (@expr6754 ) ; ++@expr1073749470 i@var2222 ) {
1132: pattern@var2208 +=@expr1073749471 (@expr1073749472 spaceInfo@var2157 [@expr1073749473 i@var2222 ] .@expr1073749474 className@var3605 +@expr1073749475 " :: " ) ; }
1133:
1134: pattern@var2208 +=@expr1073749476 typeName@var2171 .@expr7046 str (@expr7047 ) ;
1135: } else {
1136: if (@expr1073749479 scope@var2209 ==@expr1073749480 0 ) {
1137: break ; }
1138: --@expr1073749481 scope@var2209 ;
1139: }
1140: }
1141:
1142:
1143: else { if (@expr1073749482 isCPP (@expr7659 ) &&@expr1073749484 tok2@var2220 .@expr7622 str (@expr7623 ) ==@expr7663 "(" &&@expr1073749488 isFunctionHead (@expr1073749489 tok2@var2220 , "{" ) ) {
1144: const Token * func@var2223 ; func@var2223 =@expr1073749490 tok2@var2220 .@expr7569 previous (@expr7570 ) ;
1145:
1146:
1147: if (@expr1073749493 func@var2223 .@expr7670 previous (@expr7671 ) .@expr1073749496 str (@expr1073749497 ) ==@expr1073749498 "operator" ) {
1148: func@var2223 =@expr1073749499 func@var2223 .@expr7670 previous (@expr7671 ) ; }
1149:
1150: if (@expr1073749502 !@expr1073749503 func@var2223 .@expr7670 previous (@expr7671 ) ) {
1151: syntaxError (@expr1073749506 func@var2223 ) ; }
1152:
1153:
1154: if (@expr1073749507 Token ::@expr6682 Match (@expr1073749509 func@var2223 .@expr7686 tokAt (@expr1073749511 -2 ) , "%name% ::" ) ) {
1155: int offset@var2224 ; offset@var2224 =@expr1073749512 -2 ;
1156: while (@expr1073749513 Token ::@expr6682 Match (@expr1073749515 func@var2223 .@expr7686 tokAt (@expr1073749517 offset@var2224 -@expr1073749518 2 ) , "%name% ::" ) ) {
1157: offset@var2224 -=@expr1073749519 2 ; }
1158:
1159: if (@expr1073749520 spaceInfo@var2157 .@expr6753 size (@expr6754 ) >@expr6755 1 &&@expr7700 classLevel@var2214 <@expr7701 spaceInfo@var2157 .@expr6753 size (@expr6754 ) &&@expr1073749528
1160: func@var2223 .@expr1073749529 strAt (@expr1073749530 offset@var2224 ) ==@expr1073749531 spaceInfo@var2157 [@expr7708 classLevel@var2214 ] .@expr7709 className@var3605 ) {
1161: memberScope@var2212 =@expr1073749534 0 ;
1162: inMemberFunc@var2211 =@expr1073749535 true ;
1163: }
1164: }
1165: }
1166:
1167:
1168: else { if (@expr1073749536 tok2@var2220 .@expr7622 str (@expr7623 ) ==@expr1073749539 "{" ) {
1169:
1170: if (@expr1073749540 isCPP (@expr7659 ) ) {
1171: if (@expr1073749542 tok2@var2220 .@expr7719 strAt (@expr7720 -2 ) ==@expr1073749545 "namespace" ) {
1172: if (@expr1073749546 classLevel@var2214 <@expr7701 spaceInfo@var2157 .@expr6753 size (@expr6754 ) &&@expr1073749550
1173: spaceInfo@var2157 [@expr7708 classLevel@var2214 ] .@expr1073749552 isNamespace@var3607 &&@expr1073749553
1174: spaceInfo@var2157 [@expr7708 classLevel@var2214 ] .@expr7709 className@var3605 ==@expr1073749556 tok2@var2220 .@expr7569 previous (@expr7570 ) .@expr7735 str (@expr7736 ) ) {
1175: spaceInfo@var2157 [@expr7708 classLevel@var2214 ] .@expr1073749562 bodyEnd2@var3606 =@expr1073749563 tok2@var2220 .@expr7611 link (@expr7612 ) ;
1176: ++@expr1073749566 classLevel@var2214 ;
1177: pattern@var2208 .@expr7639 clear (@expr7640 ) ;
1178: for (@expr1073749569 int i@var2225 =@expr1073749570 classLevel@var2214 ; i@var2225 <@expr1073749571 spaceInfo@var2157 .@expr6753 size (@expr6754 ) ; ++@expr1073749574 i@var2225 ) {
1179: pattern@var2208 +=@expr1073749575 spaceInfo@var2157 [@expr1073749576 i@var2225 ] .@expr1073749577 className@var3605 +@expr1073749578 " :: " ; }
1180:
1181: pattern@var2208 +=@expr1073749579 typeName@var2171 .@expr7046 str (@expr7047 ) ;
1182: }
1183: ++@expr1073749582 scope@var2209 ;
1184: }
1185: if (@expr1073749583 Token ::@expr6682 Match (@expr1073749585 tok2@var2220 .@expr7762 tokAt (@expr7763 -3 ) , "enum class %name%" ) ) {
1186: inEnumClass@var2216 =@expr1073749588 true ; }
1187: }
1188:
1189:
1190: if (@expr7625 inMemberFunc@var2211 ) {
1191: ++@expr1073749590 memberScope@var2212 ; }
1192:
1193: ++@expr1073749591 scope@var2209 ;
1194: } } }
1195: }
1196:
1197:
1198:
1199: else { if (@expr1073749592 isCPP (@expr7659 ) &&@expr1073749594
1200: tok2@var2220 .@expr7622 str (@expr7623 ) ==@expr1073749597 "operator" &&@expr1073749598
1201: tok2@var2220 .@expr7544 next (@expr7545 ) &&@expr1073749601
1202: tok2@var2220 .@expr7544 next (@expr7545 ) .@expr7780 str (@expr7781 ) ==@expr1073749606 typeName@var2171 .@expr7046 str (@expr7047 ) &&@expr1073749609
1203: tok2@var2220 .@expr7786 linkAt (@expr7787 2 ) &&@expr1073749612
1204: tok2@var2220 .@expr7719 strAt (@expr1073749614 2 ) ==@expr1073749615 "(" &&@expr1073749616
1205: Token ::@expr6682 Match (@expr1073749618 tok2@var2220 .@expr7786 linkAt (@expr7787 2 ) , ") const| {" ) ) {
1206:
1207: if (@expr1073749621 tok2@var2220 .@expr7569 previous (@expr7570 ) .@expr7735 str (@expr7736 ) ==@expr1073749626 "::" ) {
1208:
1209: if (@expr1073749627 spaceInfo@var2157 .@expr6753 size (@expr6754 ) >@expr6755 1 &&@expr7700 classLevel@var2214 <@expr7701 spaceInfo@var2157 .@expr6753 size (@expr6754 ) &&@expr1073749635
1210: tok2@var2220 .@expr7719 strAt (@expr7720 -2 ) ==@expr1073749638 spaceInfo@var2157 [@expr7708 classLevel@var2214 ] .@expr7709 className@var3605 ) {
1211: tok2@var2220 =@expr1073749641 tok2@var2220 .@expr7544 next (@expr7545 ) ;
1212: simplifyType@var2210 =@expr1073749644 true ;
1213: }
1214: }
1215: }
1216:
1217: else { if (@expr1073749645 Token ::@expr6682 Match (@expr1073749647 tok2@var2220 .@expr7569 previous (@expr7570 ) , "class|struct %name% [:{]" ) ) {
1218:
1219: }
1220:
1221:
1222: else { if (@expr1073749650 (@expr1073749651 tok2@var2220 .@expr1073749652 isNameOnly (@expr1073749653 ) ||@expr1073749654 (@expr1073749655 tok2@var2220 .@expr1073749656 isName (@expr1073749657 ) &&@expr1073749658 tok2@var2220 .@expr1073749659 isExpandedMacro (@expr1073749660 ) ) ) &&@expr1073749661
1223: (@expr1073749662 Token ::@expr6676 simpleMatch (@expr1073749664 tok2@var2220 , pattern@var2208 .@expr1073749665 c_str (@expr1073749666 ) , pattern@var2208 .@expr1073749667 size (@expr1073749668 ) ) ||@expr1073749669
1224: (@expr1073749670 inMemberFunc@var2211 &&@expr7847 tok2@var2220 .@expr7622 str (@expr7623 ) ==@expr7850 typeName@var2171 .@expr7046 str (@expr7047 ) ) ) ) {
1225:
1226: if (@expr1073749677 !@expr1073749678 (@expr1073749679 inMemberFunc@var2211 &&@expr7847 tok2@var2220 .@expr7622 str (@expr7623 ) ==@expr7850 typeName@var2171 .@expr7046 str (@expr7047 ) ) &&@expr1073749686 pattern@var2208 .@expr1073749687 find (@expr1073749688 "::" ) !=@expr1073749689 std ::@expr7866 string ::@expr7867 npos@expr6628 ) {
1227: Token * start@var2226 ; start@var2226 =@expr1073749692 tok2@var2220 ;
1228: int count@var2227 ; count@var2227 =@expr1073749693 0 ;
1229: int back@var2228 ; back@var2228 =@expr1073749694 classLevel@var2214 -@expr7636 1 ;
1230: bool good@var2229 ; good@var2229 =@expr1073749696 true ;
1231:
1232: while (@expr1073749697 back@var2228 >=@expr1073749698 1 ) {
1233: Token * qualificationTok@var2230 ; qualificationTok@var2230 =@expr1073749699 start@var2226 .@expr1073749700 tokAt (@expr1073749701 -2 ) ;
1234: if (@expr1073749702 !@expr1073749703 Token ::@expr6682 Match (@expr1073749705 qualificationTok@var2230 , "%type% ::" ) ) {
1235: break ; }
1236: if (@expr1073749706 qualificationTok@var2230 .@expr1073749707 str (@expr1073749708 ) ==@expr1073749709 spaceInfo@var2157 [@expr1073749710 back@var2228 ] .@expr1073749711 className@var3605 ) {
1237: start@var2226 =@expr1073749712 qualificationTok@var2230 ;
1238: back@var2228 --@expr1073749713 ;
1239: count@var2227 ++@expr1073749714 ;
1240: } else {
1241: good@var2229 =@expr1073749715 false ;
1242: break ;
1243: }
1244: }
1245:
1246: if (@expr1073749716 good@var2229 &&@expr1073749717 back@var2228 ==@expr1073749718 1 &&@expr1073749719 start@var2226 .@expr1073749720 strAt (@expr1073749721 -1 ) ==@expr1073749722 "::" ) {
1247: good@var2229 =@expr1073749723 false ; }
1248:
1249: if (@expr1073749724 good@var2229 ) {
1250:
1251: while (@expr1073749725 count@var2227 ) {
1252: if (@expr7902 !@expr7903 removed@var2217 .@expr7904 empty (@expr7905 ) ) {
1253: removed@var2217 .@expr7906 insert (@expr1073749731 0 , " " ) ; }
1254: removed@var2217 .@expr7906 insert (@expr1073749733 0 , tok2@var2220 .@expr7719 strAt (@expr7720 -2 ) +@expr1073749736 " " +@expr1073749737 tok2@var2220 .@expr7719 strAt (@expr7915 -1 ) ) ;
1255: tok2@var2220 .@expr7762 tokAt (@expr7763 -3 ) .@expr1073749742 deleteNext (@expr1073749743 2 ) ;
1256: --@expr1073749744 count@var2227 ;
1257: }
1258:
1259:
1260: if (@expr7921 tok2@var2220 .@expr7719 strAt (@expr7915 -1 ) ==@expr7924 "::" ) {
1261: removed@var2217 .@expr7906 insert (@expr1073749750 0 , ":: " ) ;
1262: tok2@var2220 .@expr7762 tokAt (@expr7928 -2 ) .@expr1073749753 deleteNext (@expr1073749754 ) ;
1263: globalScope@var2213 =@expr1073749755 true ;
1264: }
1265:
1266:
1267: for (@expr1073749756 int i@var2231 =@expr1073749757 classLevel@var2214 ; i@var2231 <@expr1073749758 spaceInfo@var2157 .@expr6753 size (@expr6754 ) ; ++@expr1073749761 i@var2231 ) {
1268: if (@expr7902 !@expr7903 removed@var2217 .@expr7904 empty (@expr7905 ) ) {
1269: removed@var2217 +=@expr1073749766 " " ; }
1270: removed@var2217 +=@expr1073749767 (@expr1073749768 tok2@var2220 .@expr7622 str (@expr7623 ) +@expr1073749771 " " +@expr1073749772 tok2@var2220 .@expr7719 strAt (@expr7950 1 ) ) ;
1271: tok2@var2220 .@expr7951 deleteThis (@expr7952 ) ;
1272: tok2@var2220 .@expr7951 deleteThis (@expr7952 ) ;
1273: }
1274: simplifyType@var2210 =@expr1073749779 true ;
1275: }
1276: } else {
1277: if (@expr7921 tok2@var2220 .@expr7719 strAt (@expr7915 -1 ) ==@expr7924 "::" ) {
1278: int relativeSpaceInfoSize@var2232 ; relativeSpaceInfoSize@var2232 =@expr1073749784 spaceInfo@var2157 .@expr6753 size (@expr6754 ) ;
1279: Token * tokBeforeType@var2233 ; tokBeforeType@var2233 =@expr1073749787 tok2@var2220 .@expr7569 previous (@expr7570 ) ;
1280: while (@expr1073749790 relativeSpaceInfoSize@var2232 >@expr1073749791 1 &&@expr1073749792
1281: tokBeforeType@var2233 &&@expr1073749793 tokBeforeType@var2233 .@expr7970 str (@expr7971 ) ==@expr1073749796 "::" &&@expr1073749797
1282: tokBeforeType@var2233 .@expr1073749798 strAt (@expr1073749799 -1 ) ==@expr1073749800 spaceInfo@var2157 [@expr1073749801 relativeSpaceInfoSize@var2232 -@expr1073749802 1 ] .@expr1073749803 className@var3605 ) {
1283: tokBeforeType@var2233 =@expr1073749804 tokBeforeType@var2233 .@expr1073749805 tokAt (@expr1073749806 -2 ) ;
1284: --@expr1073749807 relativeSpaceInfoSize@var2232 ;
1285: }
1286: if (@expr1073749808 tokBeforeType@var2233 &&@expr1073749809 tokBeforeType@var2233 .@expr7970 str (@expr7971 ) !=@expr1073749812 "::" ) {
1287: Token ::@expr7989 eraseTokens (@expr1073749814 tokBeforeType@var2233 , tok2@var2220 ) ;
1288: simplifyType@var2210 =@expr1073749815 true ;
1289: }
1290: } else { if (@expr1073749816 Token ::@expr6682 Match (@expr1073749818 tok2@var2220 .@expr7569 previous (@expr7570 ) , "case|;|{|} %type% :" ) ) {
1291: tok2@var2220 =@expr1073749821 tok2@var2220 .@expr7544 next (@expr7545 ) ;
1292: } else { if (@expr1073749824 duplicateTypedef (@expr1073749825 &@expr1073749826 tok2@var2220 , typeName@var2171 , typeDef@var2180 ) ) {
1293:
1294: if (@expr1073749827 tok2@var2220 .@expr7622 str (@expr7623 ) !=@expr1073749830 "}" ) {
1295: while (@expr1073749831 tok2@var2220 .@expr7544 next (@expr7545 ) ) {
1296: if (@expr8010 tok2@var2220 .@expr7544 next (@expr7545 ) .@expr7780 str (@expr7781 ) ==@expr8015 "{" ) {
1297: tok2@var2220 =@expr1073749840 tok2@var2220 .@expr7786 linkAt (@expr8018 1 ) .@expr1073749843 previous (@expr1073749844 ) ; }
1298: else { if (@expr1073749845 tok2@var2220 .@expr7544 next (@expr7545 ) .@expr7780 str (@expr7781 ) ==@expr1073749850 "}" ) {
1299: break ; } }
1300:
1301: tok2@var2220 =@expr1073749851 tok2@var2220 .@expr7544 next (@expr7545 ) ;
1302: }
1303: }
1304: } else { if (@expr1073749854 Token ::@expr6682 Match (@expr1073749856 tok2@var2220 .@expr7762 tokAt (@expr7928 -2 ) , "%type% *|&" ) ) {
1305:
1306: } else { if (@expr1073749859 tok2@var2220 .@expr7569 previous (@expr7570 ) .@expr7735 str (@expr7736 ) !=@expr1073749864 "." ) {
1307: simplifyType@var2210 =@expr1073749865 true ;
1308: } } } } }
1309: }
1310: } } } }
1311:
1312: simplifyType@var2210 =@expr1073749866 simplifyType@var2210 &&@expr1073749867 !@expr1073749868 inEnumClass@var2216 ;
1313:
1314: if (@expr1073749869 simplifyType@var2210 ) {
1315: mTypedefInfo@var890 .@expr1073749870 back (@expr1073749871 ) .@expr1073749872 used@var3608 =@expr1073749873 true ;
1316:
1317:
1318: if (@expr1073749874 functionPtr@var2187 &&@expr1073749875 (@expr1073749876 tok2@var2220 .@expr7569 previous (@expr7570 ) .@expr7735 str (@expr7736 ) ==@expr1073749881 "operator" ||@expr1073749882
1319: (@expr1073749883 tok2@var2220 .@expr7544 next (@expr7545 ) &&@expr1073749886 tok2@var2220 .@expr7544 next (@expr7545 ) .@expr7780 str (@expr7781 ) ==@expr1073749891 "operator" ) ) ) {
1320: simplifyType@var2210 =@expr1073749892 false ;
1321: tok2@var2220 =@expr1073749893 tok2@var2220 .@expr7544 next (@expr7545 ) ;
1322: continue ;
1323: }
1324:
|
1331:
1332: bool inCast@var2234 ; inCast@var2234 =@expr1073749896 false ;
1333: bool inTemplate@var2235 ; inTemplate@var2235 =@expr1073749897 false ;
1334: bool inOperator@var2236 ; inOperator@var2236 =@expr1073749898 false ;
1335: bool inSizeof@var2237 ; inSizeof@var2237 =@expr1073749899 false ;
1336:
1337: const bool sameStartEnd@var2238 =@expr1073749900 typeStart@var2172 ==@expr1073749901 typeEnd@var2173 ;
1338:
1339:
1340: const bool isDerived@var2239 =@expr1073749902 Token ::@expr6682 Match (@expr1073749904 tok2@var2220 .@expr7569 previous (@expr7570 ) , "public|protected|private %type% {|," ) ;
1341:
1342:
1343:
1344: if (@expr1073749907 (@expr1073749908 tok2@var2220 .@expr7569 previous (@expr7570 ) .@expr7735 str (@expr7736 ) ==@expr1073749913 "(" &&@expr1073749914 tok2@var2220 .@expr7544 next (@expr7545 ) .@expr7780 str (@expr7781 ) ==@expr1073749919 ")" &&@expr1073749920 tok2@var2220 .@expr7719 strAt (@expr7720 -2 ) !=@expr1073749923 "sizeof" ) ||@expr1073749924
1345: (@expr1073749925 tok2@var2220 .@expr7569 previous (@expr7570 ) .@expr7735 str (@expr7736 ) ==@expr1073749930 "<" &&@expr1073749931 Token ::@expr6676 simpleMatch (@expr1073749933 tok2@var2220 .@expr7544 next (@expr7545 ) , "> (" ) ) ||@expr1073749936
1346: Token ::@expr6682 Match (@expr1073749938 tok2@var2220 .@expr7762 tokAt (@expr7928 -2 ) , "( const %name% )" ) ) {
1347: inCast@var2234 =@expr1073749941 true ; }
1348:
1349:
1350: else { if (@expr1073749942 Token ::@expr6682 Match (@expr1073749944 tok2@var2220 .@expr7569 previous (@expr7570 ) , "<|," ) &&@expr1073749947
1351: Token ::@expr6682 Match (@expr1073749949 tok2@var2220 .@expr7544 next (@expr7545 ) , "&|*| &|*| >|," ) ) {
1352: inTemplate@var2235 =@expr1073749952 true ; }
1353:
1354: else { if (@expr1073749953 Token ::@expr6682 Match (@expr1073749955 tok2@var2220 .@expr7762 tokAt (@expr7928 -2 ) , "sizeof ( %type% )" ) ) {
1355: inSizeof@var2237 =@expr1073749958 true ; } } }
1356:
1357:
1358: if (@expr1073749959 tok2@var2220 .@expr7719 strAt (@expr7915 -1 ) ==@expr1073749962 "operator" ||@expr1073749963
1359: Token ::@expr6676 simpleMatch (@expr1073749965 tok2@var2220 .@expr7762 tokAt (@expr7928 -2 ) , "operator const" ) ) {
1360: inOperator@var2236 =@expr1073749968 true ; }
1361:
1362: if (@expr1073749969 typeStart@var2172 .@expr8146 str (@expr8147 ) ==@expr1073749972 "typename" &&@expr1073749973 tok2@var2220 .@expr7719 strAt (@expr7915 -1 ) ==@expr1073749976 "typename" ) {
1363:
1364: typeStart@var2172 =@expr1073749977 typeStart@var2172 .@expr8154 next (@expr8155 ) ;
1365: }
1366:
1367:
1368: bool structRemoved@var2240 ; structRemoved@var2240 =@expr1073749980 false ;
1369: if (@expr1073749981 isDerived@var2239 &&@expr1073749982 Token ::@expr6682 Match (@expr1073749984 typeStart@var2172 , "class|struct" ) ) {
1370: if (@expr1073749985 typeStart@var2172 .@expr8146 str (@expr8147 ) ==@expr8164 "struct" ) {
1371: structRemoved@var2240 =@expr1073749989 true ; }
1372: typeStart@var2172 =@expr1073749990 typeStart@var2172 .@expr8154 next (@expr8155 ) ;
1373: }
1374: if (@expr1073749993 Token ::@expr6682 Match (@expr1073749995 typeStart@var2172 , "struct|class|union" ) &&@expr1073749996 Token ::@expr6682 Match (@expr1073749998 tok2@var2220 , "%name% ::" ) ) {
1375: typeStart@var2172 =@expr1073749999 typeStart@var2172 .@expr8154 next (@expr8155 ) ; }
1376:
1377: if (@expr1073750002 sameStartEnd@var2238 ) {
1378: typeEnd@var2173 =@expr1073750003 typeStart@var2172 ; }
1379:
1380:
1381: tok2@var2220 .@expr7622 str (@expr1073750005 typeStart@var2172 .@expr8146 str (@expr8147 ) ) ;
1382:
1383:
1384: if (@expr1073750008 typeStart@var2172 .@expr8146 str (@expr8147 ) ==@expr8164 "struct" ||@expr1073750012 structRemoved@var2240 ) {
1385: if (@expr1073750013 structRemoved@var2240 ) {
1386: tok2@var2220 =@expr1073750014 tok2@var2220 .@expr7569 previous (@expr7570 ) ; }
1387:
1388: if (@expr1073750017 globalScope@var2213 ) {
1389: tok2@var2220 .@expr8194 insertToken (@expr8195 "::" ) ;
1390: tok2@var2220 =@expr1073750020 tok2@var2220 .@expr7544 next (@expr7545 ) ;
1391: }
1392:
1393: for (@expr1073750023 int i@var2241 =@expr1073750024 classLevel@var2214 ; i@var2241 <@expr1073750025 spaceInfo@var2157 .@expr6753 size (@expr6754 ) ; ++@expr1073750028 i@var2241 ) {
1394: tok2@var2220 .@expr8194 insertToken (@expr1073750030 spaceInfo@var2157 [@expr1073750031 i@var2241 ] .@expr1073750032 className@var3605 ) ;
1395: tok2@var2220 =@expr1073750033 tok2@var2220 .@expr7544 next (@expr7545 ) ;
1396: tok2@var2220 .@expr8194 insertToken (@expr8195 "::" ) ;
1397: tok2@var2220 =@expr1073750038 tok2@var2220 .@expr7544 next (@expr7545 ) ;
1398: }
1399: }
1400:
1401:
1402: Token * start@var2242 ; start@var2242 =@expr1073750041 tok2@var2220 ;
1403: std ::@expr1073750042 string removed1@var2243 ; removed1@var2243 =@expr1073750043 removed@var2217 ;
1404: std ::@expr7866 string ::@expr1073750045 size_type idx@var2244 ; idx@var2244 =@expr1073750046 removed1@var2243 .@expr8223 rfind (@expr8224 " ::" ) ;
1405:
1406: if (@expr1073750049 idx@var2244 !=@expr1073750050 std ::@expr7866 string ::@expr7867 npos@expr6628 ) {
1407: removed1@var2243 .@expr8229 resize (@expr8230 idx@var2244 ) ; }
1408: if (@expr1073750055 removed1@var2243 ==@expr1073750056 classPath@var2218 &&@expr1073750057 !@expr1073750058 removed1@var2243 .@expr1073750059 empty (@expr1073750060 ) ) {
1409: for (@expr1073750061 std ::@expr6977 vector < Space > ::@expr6977 const_reverse_iterator it@var2245 =@expr1073750064 spaceInfo@var2157 .@expr1073750065 crbegin (@expr1073750066 ) ; it@var2245 !=@expr1073750067 spaceInfo@var2157 .@expr1073750068 crend (@expr1073750069 ) ; ++@expr1073750070 it@var2245 ) {
1410: if (@expr1073750071 it@var2245 .@expr8248 recordTypes@var2246 .@expr1073750073 find (@expr1073750074 start@var2242 .@expr1073750075 str (@expr1073750076 ) ) !=@expr1073750077 it@var2245 .@expr8248 recordTypes@var2246 .@expr1073750079 end (@expr1073750080 ) ) {
1411: std ::@expr7866 string ::@expr1073750082 size_type spaceIdx@var2247 ; spaceIdx@var2247 =@expr1073750083 0 ;
1412: std ::@expr7866 string ::@expr1073750085 size_type startIdx@var2248 ; startIdx@var2248 =@expr1073750086 0 ;
1413: while (@expr1073750087 (@expr1073750088 spaceIdx@var2247 =@expr1073750089 removed1@var2243 .@expr1073750090 find (@expr1073750091 " " , startIdx@var2248 ) ) !=@expr1073750092 std ::@expr7866 string ::@expr7867 npos@expr6628 ) {
1414: tok2@var2220 .@expr7569 previous (@expr7570 ) .@expr8273 insertToken (@expr1073750098 removed1@var2243 .@expr8275 substr (@expr1073750100 startIdx@var2248 , spaceIdx@var2247 -@expr1073750101 startIdx@var2248 ) ) ;
1415: startIdx@var2248 =@expr1073750102 spaceIdx@var2247 +@expr1073750103 1 ;
1416: }
1417: tok2@var2220 .@expr7569 previous (@expr7570 ) .@expr8273 insertToken (@expr1073750107 removed1@var2243 .@expr8275 substr (@expr1073750109 startIdx@var2248 ) ) ;
1418: tok2@var2220 .@expr7569 previous (@expr7570 ) .@expr8273 insertToken (@expr1073750113 "::" ) ;
1419: break ;
1420: }
1421: idx@var2244 =@expr1073750114 removed1@var2243 .@expr8223 rfind (@expr8224 " ::" ) ;
1422: if (@expr1073750117 idx@var2244 ==@expr1073750118 std ::@expr7866 string ::@expr7867 npos@expr6628 ) {
1423: break ; }
1424:
1425: removed1@var2243 .@expr8229 resize (@expr8230 idx@var2244 ) ;
1426: }
1427: }
1428:
1429: tok2@var2220 =@expr1073750123 TokenList ::@expr8300 copyTokens (@expr1073750125 tok2@var2220 , typeStart@var2172 .@expr8154 next (@expr8155 ) , typeEnd@var2173 ) ;
1430:
1431: if (@expr1073750128 !@expr1073750129 pointers@var2197 .@expr1073750130 empty (@expr1073750131 ) ) {
1432: for (@expr1073750132 const std ::@expr6977 string &@expr1073750134 p@var2249 :@expr1073750135 pointers@var2197 ) {
1433: tok2@var2220 .@expr8194 insertToken (@expr1073750137 p@var2249 ) ;
1434: tok2@var2220 =@expr1073750138 tok2@var2220 .@expr7544 next (@expr7545 ) ;
1435: }
1436: }
1437:
1438: if (@expr1073750141 funcStart@var2183 &&@expr1073750142 funcEnd@var2184 ) {
1439: tok2@var2220 .@expr8194 insertToken (@expr8320 "(" ) ;
1440: tok2@var2220 =@expr1073750145 tok2@var2220 .@expr7544 next (@expr7545 ) ;
1441: Token * paren@var2250 ; paren@var2250 =@expr1073750148 tok2@var2220 ;
1442: tok2@var2220 =@expr1073750149 TokenList ::@expr8300 copyTokens (@expr1073750151 tok2@var2220 , funcStart@var2183 , funcEnd@var2184 ) ;
1443:
1444: if (@expr8328 !@expr8329 inCast@var2234 ) {
1445: tok2@var2220 =@expr1073750154 processFunc (@expr8331 tok2@var2220 , inOperator@var2236 ) ; }
1446:
1447: if (@expr7616 !@expr7617 tok2@var2220 ) {
1448: break ; }
1449:
1450: while (@expr8334 Token ::@expr6682 Match (@expr8336 tok2@var2220 , "%name%|] [" ) ) {
1451: tok2@var2220 =@expr1073750161 tok2@var2220 .@expr7786 linkAt (@expr8018 1 ) ; }
1452:
1453: tok2@var2220 .@expr8194 insertToken (@expr8341 ")" ) ;
1454: tok2@var2220 =@expr1073750166 tok2@var2220 .@expr7544 next (@expr7545 ) ;
1455: Token ::@expr8345 createMutualLinks (@expr1073750170 tok2@var2220 , paren@var2250 ) ;
1456:
1457: tok2@var2220 =@expr1073750171 TokenList ::@expr8300 copyTokens (@expr8349 tok2@var2220 , argStart@var2174 , argEnd@var2175 ) ;
1458:
1459: if (@expr7105 specStart@var2178 ) {
1460: Token * spec@var2251 ; spec@var2251 =@expr1073750175 specStart@var2178 ;
1461: tok2@var2220 .@expr8194 insertToken (@expr8353 spec@var2251 .@expr8354 str (@expr8355 ) ) ;
1462: tok2@var2220 =@expr1073750180 tok2@var2220 .@expr7544 next (@expr7545 ) ;
1463: while (@expr1073750183 spec@var2251 !=@expr1073750184 specEnd@var2179 ) {
1464: spec@var2251 =@expr1073750185 spec@var2251 .@expr1073750186 next (@expr1073750187 ) ;
1465: tok2@var2220 .@expr8194 insertToken (@expr8353 spec@var2251 .@expr8354 str (@expr8355 ) ) ;
1466: tok2@var2220 =@expr1073750192 tok2@var2220 .@expr7544 next (@expr7545 ) ;
1467: }
1468: }
1469: }
1470:
1471: else { if (@expr1073750195 functionPtr@var2187 ||@expr1073750196 function@var2186 ) {
1472:
1473:
1474: bool needParen@var2252 ; needParen@var2252 =@expr1073750197 true ;
1475: if (@expr1073750198 !@expr8375 inTemplate@var2235 &&@expr1073750200 function@var2186 &&@expr1073750201 tok2@var2220 .@expr7544 next (@expr7545 ) &&@expr1073750204 tok2@var2220 .@expr7544 next (@expr7545 ) .@expr7780 str (@expr7781 ) !=@expr1073750209 "*" ) {
1476: needParen@var2252 =@expr1073750210 false ; }
1477: if (@expr8387 needParen@var2252 ) {
1478: tok2@var2220 .@expr8194 insertToken (@expr8320 "(" ) ;
1479: tok2@var2220 =@expr1073750214 tok2@var2220 .@expr7544 next (@expr7545 ) ;
1480: }
1481: Token * tok3@var2253 ; tok3@var2253 =@expr1073750217 tok2@var2220 ;
1482: if (@expr1073750218 namespaceStart@var2194 ) {
1483: const Token * tok4@var2254 ; tok4@var2254 =@expr1073750219 namespaceStart@var2194 ;
1484:
1485: while (@expr1073750220 tok4@var2254 !=@expr1073750221 namespaceEnd@var2195 ) {
1486: tok2@var2220 .@expr8194 insertToken (@expr1073750223 tok4@var2254 .@expr1073750224 str (@expr1073750225 ) ) ;
1487: tok2@var2220 =@expr1073750226 tok2@var2220 .@expr7544 next (@expr7545 ) ;
1488: tok4@var2254 =@expr1073750229 tok4@var2254 .@expr1073750230 next (@expr1073750231 ) ;
1489: }
1490: tok2@var2220 .@expr8194 insertToken (@expr8409 namespaceEnd@var2195 .@expr8410 str (@expr8411 ) ) ;
1491: tok2@var2220 =@expr1073750236 tok2@var2220 .@expr7544 next (@expr7545 ) ;
1492: }
1493: if (@expr1073750239 functionPtr@var2187 ) {
1494: tok2@var2220 .@expr8194 insertToken (@expr8417 "*" ) ;
1495: tok2@var2220 =@expr1073750242 tok2@var2220 .@expr7544 next (@expr7545 ) ;
1496: }
1497:
1498: if (@expr8328 !@expr8329 inCast@var2234 ) {
1499: tok2@var2220 =@expr1073750247 processFunc (@expr8331 tok2@var2220 , inOperator@var2236 ) ; }
1500:
1501: if (@expr8387 needParen@var2252 ) {
1502: if (@expr7616 !@expr7617 tok2@var2220 ) {
1503: syntaxError (@expr8428 nullptr ) ; }
1504:
1505: tok2@var2220 .@expr8194 insertToken (@expr8341 ")" ) ;
1506: tok2@var2220 =@expr1073750255 tok2@var2220 .@expr7544 next (@expr7545 ) ;
1507: Token ::@expr8345 createMutualLinks (@expr1073750259 tok2@var2220 , tok3@var2253 ) ;
1508: }
1509: if (@expr7616 !@expr7617 tok2@var2220 ) {
1510: syntaxError (@expr8428 nullptr ) ; }
1511:
1512: tok2@var2220 =@expr1073750263 TokenList ::@expr8300 copyTokens (@expr8349 tok2@var2220 , argStart@var2174 , argEnd@var2175 ) ;
1513: if (@expr1073750266 inTemplate@var2235 ) {
1514: if (@expr7616 !@expr7617 tok2@var2220 ) {
1515: syntaxError (@expr8428 nullptr ) ; }
1516:
1517: tok2@var2220 =@expr1073750270 tok2@var2220 .@expr7544 next (@expr7545 ) ;
1518: }
1519:
1520: if (@expr7105 specStart@var2178 ) {
1521: Token * spec@var2255 ; spec@var2255 =@expr1073750274 specStart@var2178 ;
1522: tok2@var2220 .@expr8194 insertToken (@expr8452 spec@var2255 .@expr8453 str (@expr8454 ) ) ;
1523: tok2@var2220 =@expr1073750279 tok2@var2220 .@expr7544 next (@expr7545 ) ;
1524: while (@expr1073750282 spec@var2255 !=@expr1073750283 specEnd@var2179 ) {
1525: spec@var2255 =@expr1073750284 spec@var2255 .@expr1073750285 next (@expr1073750286 ) ;
1526: tok2@var2220 .@expr8194 insertToken (@expr8452 spec@var2255 .@expr8453 str (@expr8454 ) ) ;
1527: tok2@var2220 =@expr1073750291 tok2@var2220 .@expr7544 next (@expr7545 ) ;
1528: }
1529: }
1530: } else { if (@expr1073750294 functionRetFuncPtr@var2188 ||@expr1073750295 functionPtrRetFuncPtr@var2189 ) {
1531: tok2@var2220 .@expr8194 insertToken (@expr8320 "(" ) ;
1532: tok2@var2220 =@expr1073750298 tok2@var2220 .@expr7544 next (@expr7545 ) ;
1533: Token * tok3@var2256 ; tok3@var2256 =@expr1073750301 tok2@var2220 ;
1534: tok2@var2220 .@expr8194 insertToken (@expr8417 "*" ) ;
1535: tok2@var2220 =@expr1073750304 tok2@var2220 .@expr7544 next (@expr7545 ) ;
1536:
1537: Token * tok4@var2257 ; tok4@var2257 =@expr1073750307 nullptr ;
1538: if (@expr1073750308 functionPtrRetFuncPtr@var2189 ) {
1539: tok2@var2220 .@expr8194 insertToken (@expr8320 "(" ) ;
1540: tok2@var2220 =@expr1073750311 tok2@var2220 .@expr7544 next (@expr7545 ) ;
1541: tok4@var2257 =@expr1073750314 tok2@var2220 ;
1542: tok2@var2220 .@expr8194 insertToken (@expr8417 "*" ) ;
1543: tok2@var2220 =@expr1073750317 tok2@var2220 .@expr7544 next (@expr7545 ) ;
1544: }
1545:
1546:
1547: if (@expr8328 !@expr8329 inCast@var2234 ) {
1548: if (@expr1073750322 !@expr7617 tok2@var2220 ||@expr1073750324 !@expr8501 tok2@var2220 .@expr7544 next (@expr7545 ) ) {
1549: syntaxError (@expr8428 nullptr ) ; }
1550:
1551: if (@expr1073750329 tok2@var2220 .@expr7544 next (@expr7545 ) .@expr7780 str (@expr7781 ) !=@expr8510 ")" ) {
1552: tok2@var2220 =@expr1073750335 tok2@var2220 .@expr7544 next (@expr7545 ) ; }
1553: }
1554:
1555: if (@expr1073750338 tok4@var2257 &&@expr1073750339 functionPtrRetFuncPtr@var2189 ) {
1556: tok2@var2220 .@expr8194 insertToken (@expr8341 ")" ) ;
1557: tok2@var2220 =@expr1073750342 tok2@var2220 .@expr7544 next (@expr7545 ) ;
1558: Token ::@expr8345 createMutualLinks (@expr1073750346 tok2@var2220 , tok4@var2257 ) ;
1559: }
1560:
1561: tok2@var2220 =@expr1073750347 TokenList ::@expr8300 copyTokens (@expr8349 tok2@var2220 , argStart@var2174 , argEnd@var2175 ) ;
1562:
1563: tok2@var2220 .@expr8194 insertToken (@expr8341 ")" ) ;
1564: tok2@var2220 =@expr1073750352 tok2@var2220 .@expr7544 next (@expr7545 ) ;
1565: Token ::@expr8345 createMutualLinks (@expr1073750356 tok2@var2220 , tok3@var2256 ) ;
1566:
1567: tok2@var2220 =@expr1073750357 TokenList ::@expr8300 copyTokens (@expr1073750359 tok2@var2220 , argFuncRetStart@var2181 , argFuncRetEnd@var2182 ) ;
1568: } else { if (@expr1073750360 ptrToArray@var2190 ||@expr1073750361 refToArray@var2191 ) {
1569: tok2@var2220 .@expr8194 insertToken (@expr8320 "(" ) ;
1570: tok2@var2220 =@expr1073750364 tok2@var2220 .@expr7544 next (@expr7545 ) ;
1571: Token * tok3@var2258 ; tok3@var2258 =@expr1073750367 tok2@var2220 ;
1572:
1573: if (@expr1073750368 ptrToArray@var2190 ) {
1574: tok2@var2220 .@expr8194 insertToken (@expr8417 "*" ) ; }
1575: else {
1576: tok2@var2220 .@expr8194 insertToken (@expr1073750372 "&" ) ; }
1577: tok2@var2220 =@expr1073750373 tok2@var2220 .@expr7544 next (@expr7545 ) ;
1578:
1579: bool hasName@var2259 ; hasName@var2259 =@expr1073750376 false ;
1580:
1581: if (@expr1073750377 tok2@var2220 .@expr7544 next (@expr7545 ) &&@expr1073750380 tok2@var2220 .@expr7544 next (@expr7545 ) .@expr7780 str (@expr7781 ) !=@expr8510 ")" &&@expr1073750386 tok2@var2220 .@expr7544 next (@expr7545 ) .@expr7780 str (@expr7781 ) !=@expr1073750391 "," &&@expr1073750392
1582: tok2@var2220 .@expr7544 next (@expr7545 ) .@expr7780 str (@expr7781 ) !=@expr1073750397 ">" ) {
1583: hasName@var2259 =@expr1073750398 true ;
1584: if (@expr1073750399 tok2@var2220 .@expr7544 next (@expr7545 ) .@expr7780 str (@expr7781 ) !=@expr1073750404 "(" ) {
1585: tok2@var2220 =@expr1073750405 tok2@var2220 .@expr7544 next (@expr7545 ) ; }
1586:
1587:
1588: if (@expr1073750408 tok2@var2220 &&@expr8585 tok2@var2220 .@expr7544 next (@expr7545 ) &&@expr1073750412 tok2@var2220 .@expr7544 next (@expr7545 ) .@expr7780 str (@expr7781 ) ==@expr1073750417 "(" ) {
1589: tok2@var2220 =@expr1073750418 tok2@var2220 .@expr7544 next (@expr7545 ) .@expr8597 link (@expr8598 ) ; }
1590:
1591:
1592: if (@expr1073750423 tok2@var2220 &&@expr8585 tok2@var2220 .@expr7544 next (@expr7545 ) &&@expr1073750427 tok2@var2220 .@expr7544 next (@expr7545 ) .@expr7780 str (@expr7781 ) ==@expr8608 "[" ) {
1593: tok2@var2220 =@expr1073750433 tok2@var2220 .@expr7544 next (@expr7545 ) .@expr8597 link (@expr8598 ) ; }
1594: }
1595:
1596: tok2@var2220 .@expr8194 insertToken (@expr8341 ")" ) ;
1597: Token ::@expr8345 createMutualLinks (@expr1073750441 tok2@var2220 .@expr7544 next (@expr7545 ) , tok3@var2258 ) ;
1598:
1599: if (@expr1073750444 !@expr1073750445 hasName@var2259 ) {
1600: tok2@var2220 =@expr1073750446 tok2@var2220 .@expr7544 next (@expr7545 ) ; }
1601: } else { if (@expr1073750449 ptrMember@var2192 ) {
1602: if (@expr1073750450 Token ::@expr6676 simpleMatch (@expr1073750452 tok2@var2220 , "* (" ) ) {
1603: tok2@var2220 .@expr8194 insertToken (@expr8417 "*" ) ;
1604: tok2@var2220 =@expr1073750455 tok2@var2220 .@expr7544 next (@expr7545 ) ;
1605: } else {
1606:
1607:
1608:
1609: const bool castOperator@var2260 =@expr1073750458 inOperator@var2236 &&@expr1073750459 Token ::@expr6682 Match (@expr1073750461 tok2@var2220 , "%type% (" ) ;
1610: Token * openParenthesis@var2261 ; openParenthesis@var2261 =@expr1073750462 nullptr ;
1611:
1612: if (@expr1073750463 !@expr1073750464 castOperator@var2260 ) {
1613: tok2@var2220 .@expr8194 insertToken (@expr8320 "(" ) ;
1614: tok2@var2220 =@expr1073750467 tok2@var2220 .@expr7544 next (@expr7545 ) ;
1615:
1616: openParenthesis@var2261 =@expr1073750470 tok2@var2220 ;
1617: }
1618:
1619: const Token * tok4@var2262 ; tok4@var2262 =@expr1073750471 namespaceStart@var2194 ;
1620:
1621: while (@expr1073750472 tok4@var2262 !=@expr1073750473 namespaceEnd@var2195 ) {
1622: tok2@var2220 .@expr8194 insertToken (@expr1073750475 tok4@var2262 .@expr1073750476 str (@expr1073750477 ) ) ;
1623: tok2@var2220 =@expr1073750478 tok2@var2220 .@expr7544 next (@expr7545 ) ;
1624: tok4@var2262 =@expr1073750481 tok4@var2262 .@expr1073750482 next (@expr1073750483 ) ;
1625: }
1626: tok2@var2220 .@expr8194 insertToken (@expr8409 namespaceEnd@var2195 .@expr8410 str (@expr8411 ) ) ;
1627: tok2@var2220 =@expr1073750488 tok2@var2220 .@expr7544 next (@expr7545 ) ;
1628:
1629: tok2@var2220 .@expr8194 insertToken (@expr8417 "*" ) ;
1630: tok2@var2220 =@expr1073750493 tok2@var2220 .@expr7544 next (@expr7545 ) ;
1631:
1632: if (@expr1073750496 openParenthesis@var2261 ) {
1633:
1634: if (@expr1073750497 Token ::@expr6682 Match (@expr1073750499 tok2@var2220 .@expr7544 next (@expr7545 ) , "%name%" ) ) {
1635: tok2@var2220 =@expr1073750502 tok2@var2220 .@expr7544 next (@expr7545 ) ; }
1636:
1637: tok2@var2220 .@expr8194 insertToken (@expr8341 ")" ) ;
1638: tok2@var2220 =@expr1073750507 tok2@var2220 .@expr7544 next (@expr7545 ) ;
1639:
1640: Token ::@expr8345 createMutualLinks (@expr1073750511 tok2@var2220 , openParenthesis@var2261 ) ;
1641: }
1642: }
1643: } else { if (@expr1073750512 typeOf@var2193 ) {
1644: tok2@var2220 =@expr1073750513 TokenList ::@expr8300 copyTokens (@expr8349 tok2@var2220 , argStart@var2174 , argEnd@var2175 ) ;
1645: } else { if (@expr1073750516 Token ::@expr6682 Match (@expr1073750518 tok2@var2220 , "%name% [" ) ) {
1646: while (@expr8334 Token ::@expr6682 Match (@expr8336 tok2@var2220 , "%name%|] [" ) ) {
1647: tok2@var2220 =@expr1073750522 tok2@var2220 .@expr7786 linkAt (@expr8018 1 ) ;
1648: }
1649: tok2@var2220 =@expr1073750525 tok2@var2220 .@expr7569 previous (@expr7570 ) ;
1650: } } } } } } }
1651:
1652: if (@expr1073750528 arrayStart@var2176 &&@expr1073750529 arrayEnd@var2177 ) {
1653: do {
1654: if (@expr8706 !@expr8501 tok2@var2220 .@expr7544 next (@expr7545 ) ) {
1655: syntaxError (@expr8710 tok2@var2220 ) ; }
1656:
1657: if (@expr1073750535 !@expr8329 inCast@var2234 &&@expr1073750537 !@expr1073750538 inSizeof@var2237 &&@expr1073750539 !@expr8375 inTemplate@var2235 ) {
1658: tok2@var2220 =@expr1073750541 tok2@var2220 .@expr7544 next (@expr7545 ) ; }
1659:
1660: if (@expr1073750544 tok2@var2220 .@expr7622 str (@expr7623 ) ==@expr1073750547 "const" ) {
1661: tok2@var2220 =@expr1073750548 tok2@var2220 .@expr7544 next (@expr7545 ) ; }
1662:
1663:
1664: if (@expr1073750551 Token ::@expr6682 Match (@expr1073750553 tok2@var2220 , "&|*|&&" ) ) {
1665: tok2@var2220 =@expr1073750554 tok2@var2220 .@expr7569 previous (@expr7570 ) ;
1666: tok2@var2220 .@expr8194 insertToken (@expr8320 "(" ) ;
1667: Token * tok3@var2263 ; tok3@var2263 =@expr1073750559 tok2@var2220 .@expr7544 next (@expr7545 ) ;
1668:
1669:
1670: if (@expr1073750562 Token ::@expr6682 Match (@expr1073750564 tok3@var2263 , "( *|&|&& *|&|&& %name%" ) ) {
1671: tok2@var2220 =@expr1073750565 tok3@var2263 .@expr1073750566 tokAt (@expr1073750567 3 ) ; }
1672: else { if (@expr1073750568 Token ::@expr6682 Match (@expr1073750570 tok2@var2220 .@expr7762 tokAt (@expr8748 3 ) , "[(),;]" ) ) {
1673: tok2@var2220 =@expr1073750573 tok2@var2220 .@expr7762 tokAt (@expr8751 2 ) ; }
1674: else {
1675: tok2@var2220 =@expr1073750576 tok2@var2220 .@expr7762 tokAt (@expr8748 3 ) ; } }
1676: if (@expr7616 !@expr7617 tok2@var2220 ) {
1677: syntaxError (@expr8428 nullptr ) ; }
1678:
1679: while (@expr1073750582 tok2@var2220 .@expr7719 strAt (@expr7950 1 ) ==@expr1073750585 "::" ) {
1680: tok2@var2220 =@expr1073750586 tok2@var2220 .@expr7762 tokAt (@expr8751 2 ) ; }
1681:
1682:
1683: if (@expr1073750589 tok2@var2220 .@expr7622 str (@expr7623 ) ==@expr7663 "(" ) {
1684: tok2@var2220 =@expr1073750593 tok2@var2220 .@expr7611 link (@expr7612 ) ; }
1685:
1686: if (@expr1073750596 tok2@var2220 .@expr7719 strAt (@expr7950 1 ) ==@expr1073750599 "(" ) {
1687: tok2@var2220 =@expr1073750600 tok2@var2220 .@expr7786 linkAt (@expr8018 1 ) ; }
1688:
1689:
1690: while (@expr1073750603 Token ::@expr6682 Match (@expr1073750605 tok2@var2220 .@expr7544 next (@expr7545 ) , "const|noexcept" ) ) {
1691: tok2@var2220 =@expr1073750608 tok2@var2220 .@expr7544 next (@expr7545 ) ; }
1692:
1693: tok2@var2220 .@expr8194 insertToken (@expr8341 ")" ) ;
1694: tok2@var2220 =@expr1073750613 tok2@var2220 .@expr7544 next (@expr7545 ) ;
1695: Token ::@expr8345 createMutualLinks (@expr1073750617 tok2@var2220 , tok3@var2263 ) ;
1696: }
1697:
1698: if (@expr8706 !@expr8501 tok2@var2220 .@expr7544 next (@expr7545 ) ) {
1699: syntaxError (@expr8710 tok2@var2220 ) ; }
1700:
1701:
1702: while (@expr1073750623 tok2@var2220 .@expr7544 next (@expr7545 ) .@expr7780 str (@expr7781 ) ==@expr8608 "[" ) {
1703: tok2@var2220 =@expr1073750629 tok2@var2220 .@expr7786 linkAt (@expr8018 1 ) ; }
1704:
1705: tok2@var2220 =@expr1073750632 TokenList ::@expr8300 copyTokens (@expr1073750634 tok2@var2220 , arrayStart@var2176 , arrayEnd@var2177 ) ;
1706: if (@expr8706 !@expr8501 tok2@var2220 .@expr7544 next (@expr7545 ) ) {
1707: syntaxError (@expr8710 tok2@var2220 ) ; }
1708:
1709: if (@expr1073750640 tok2@var2220 .@expr7622 str (@expr7623 ) ==@expr1073750643 "=" ) {
1710: if (@expr8706 !@expr8501 tok2@var2220 .@expr7544 next (@expr7545 ) ) {
1711: syntaxError (@expr8710 tok2@var2220 ) ; }
1712: if (@expr8010 tok2@var2220 .@expr7544 next (@expr7545 ) .@expr7780 str (@expr7781 ) ==@expr8015 "{" ) {
1713: tok2@var2220 =@expr1073750655 tok2@var2220 .@expr7544 next (@expr7545 ) .@expr8597 link (@expr8598 ) .@expr1073750660 next (@expr1073750661 ) ; }
1714: else { if (@expr1073750662 tok2@var2220 .@expr7544 next (@expr7545 ) .@expr7780 str (@expr7781 ) .@expr1073750667 at (@expr1073750668 0 ) ==@expr1073750669 '\"' ) {
1715: tok2@var2220 =@expr1073750670 tok2@var2220 .@expr7762 tokAt (@expr8751 2 ) ; } }
1716: }
1717: } while (@expr1073750673 Token ::@expr6682 Match (@expr1073750675 tok2@var2220 , ", %name% ;|=|," ) ) ;
1718: }
1719:
1720: simplifyType@var2210 =@expr1073750676 false ;
1721: }
1722: if (@expr7616 !@expr7617 tok2@var2220 ) {
1723: break ; }
1724: }
1725:
1726: if (@expr7285 !@expr7286 tok@var2163 ) {
1727: syntaxError (@expr8428 nullptr ) ; }
1728:
1729: if (@expr1073750682 tok@var2163 .@expr6672 str (@expr6673 ) ==@expr6723 ";" ) {
1730: done@var2200 =@expr1073750686 true ; }
1731: else { if (@expr1073750687 tok@var2163 .@expr6672 str (@expr6673 ) ==@expr1073750690 "," ) {
1732: arrayStart@var2176 =@expr1073750691 nullptr ;
1733: arrayEnd@var2177 =@expr1073750692 nullptr ;
1734: tokOffset@var2185 =@expr1073750693 tok@var2163 .@expr6645 next (@expr6646 ) ;
1735: pointers@var2197 .@expr1073750696 clear (@expr1073750697 ) ;
1736:
1737: while (@expr1073750698 Token ::@expr6682 Match (@expr1073750700 tokOffset@var2185 , "*|&" ) ) {
1738: pointers@var2197 .@expr6981 push_back (@expr6982 tokOffset@var2185 .@expr6829 str (@expr6830 ) ) ;
1739: tokOffset@var2185 =@expr1073750705 tokOffset@var2185 .@expr6834 next (@expr6835 ) ;
1740: }
1741:
1742: if (@expr6843 Token ::@expr6682 Match (@expr6845 tokOffset@var2185 , "%type%" ) ) {
1743: typeName@var2171 =@expr1073750711 tokOffset@var2185 ;
1744: tokOffset@var2185 =@expr1073750712 tokOffset@var2185 .@expr6834 next (@expr6835 ) ;
1745:
1746: if (@expr1073750715 tokOffset@var2185 &&@expr7003 tokOffset@var2185 .@expr6829 str (@expr6830 ) ==@expr7006 "[" ) {
1747: arrayStart@var2176 =@expr1073750720 tokOffset@var2185 ;
1748:
1749: for (@expr1073750721 ; ; ) {
1750: while (@expr1073750722 tokOffset@var2185 .@expr6834 next (@expr6835 ) &&@expr1073750725 !@expr1073750726 Token ::@expr6682 Match (@expr1073750728 tokOffset@var2185 .@expr6834 next (@expr6835 ) , ";|," ) ) {
1751: tokOffset@var2185 =@expr1073750731 tokOffset@var2185 .@expr6834 next (@expr6835 ) ; }
1752:
1753: if (@expr1073750734 !@expr1073750735 tokOffset@var2185 .@expr6834 next (@expr6835 ) ) {
1754: return ; }
1755: else { if (@expr1073750738 tokOffset@var2185 .@expr6834 next (@expr6835 ) .@expr7219 str (@expr7220 ) ==@expr1073750743 ";" ) {
1756: break ; }
1757: else { if (@expr1073750744 tokOffset@var2185 .@expr6829 str (@expr6830 ) ==@expr1073750747 "]" ) {
1758: break ; }
1759: else {
1760: tokOffset@var2185 =@expr1073750748 tokOffset@var2185 .@expr6834 next (@expr6835 ) ; } } }
1761: }
1762:
1763: arrayEnd@var2177 =@expr1073750751 tokOffset@var2185 ;
1764: tokOffset@var2185 =@expr1073750752 tokOffset@var2185 .@expr6834 next (@expr6835 ) ;
1765: }
1766:
1767: if (@expr7016 Token ::@expr6682 Match (@expr7018 tokOffset@var2185 , ";|," ) ) {
1768: tok@var2163 =@expr1073750758 tokOffset@var2185 ; }
1769: else {
1770:
1771: done@var2200 =@expr1073750759 true ;
1772: ok@var2201 =@expr1073750760 false ;
1773: }
1774: } else {
1775:
1776: done@var2200 =@expr1073750761 true ;
1777: ok@var2201 =@expr1073750762 false ;
1778: }
1779: } else {
1780:
1781: done@var2200 =@expr1073750763 true ;
1782: ok@var2201 =@expr1073750764 false ;
1783: } }
1784: }
1785:
1786: if (@expr1073750765 ok@var2201 ) {
1787:
1788: Token ::@expr7989 eraseTokens (@expr1073750767 typeDef@var2180 , tok@var2163 ) ;
1789:
1790: if (@expr1073750768 typeDef@var2180 !=@expr1073750769 list@var872 .@expr6642 front (@expr6643 ) ) {
1791: tok@var2163 =@expr1073750772 typeDef@var2180 .@expr1073750773 previous (@expr1073750774 ) ;
1792: tok@var2163 .@expr6789 deleteNext (@expr8952 ) ;
1793:
1794: if (@expr1073750777 tok@var2163 .@expr1073750778 tokAt (@expr1073750779 2 ) ) {
1795: tok@var2163 .@expr6789 deleteNext (@expr8952 ) ; }
1796: } else {
1797: list@var872 .@expr6642 front (@expr6643 ) .@expr8960 deleteThis (@expr8961 ) ;
1798:
1799: if (@expr1073750786 list@var872 .@expr6642 front (@expr6643 ) .@expr1073750789 next (@expr1073750790 ) ) {
1800: list@var872 .@expr6642 front (@expr6643 ) .@expr8960 deleteThis (@expr8961 ) ; }
1801: tok@var2163 =@expr1073750795 list@var872 .@expr6642 front (@expr6643 ) ;
1802:
1803: goback@var2162 =@expr1073750798 true ;
1804: }
1805: }
1806: }
1807: }
1808:
1809: namespace {
1810: struct ScopeInfo3 {
1811: enum Type { Global , Namespace , Record , MemberFunction , Other } ;
1812: ScopeInfo3 ( ) : parent@var2272 ( nullptr ) , type@var2274 ( Global ) , bodyStart@var2277 ( nullptr ) , bodyEnd@var2278 ( nullptr ) { }
1813: ScopeInfo3 ( ScopeInfo3 * parent_@var2264 , Type type_@var2265 , const std :: string & name_@var2266 , const Token * bodyStart_@var2267 , const Token * bodyEnd_@var2268 )
1814: : parent@var2272 ( parent_@var2264 ) , type@var2274 ( type_@var2265 ) , name@var2276 ( name_@var2266 ) , bodyStart@var2277 ( bodyStart_@var2267 ) , bodyEnd@var2278 ( bodyEnd_@var2268 ) {
1815: if (@expr1073750799 name@var2276 .@expr1073750800 empty (@expr1073750801 ) ) {
1816: return ; }
1817: fullName@var2275 =@expr1073750802 name@var2276 ;
1818: ScopeInfo3 * scope@var2269 ; scope@var2269 =@expr1073750803 parent@var2272 ;
1819: while (@expr1073750804 scope@var2269 &&@expr1073750805 scope@var2269 .@expr8982 parent@var2270 ) {
1820: if (@expr1073750807 scope@var2269 .@expr8984 name@var2271 .@expr1073750809 empty (@expr1073750810 ) ) {
1821: break ; }
1822: fullName@var2275 =@expr1073750811 scope@var2269 .@expr8984 name@var2271 +@expr1073750813 " :: " +@expr1073750814 fullName@var2275 ;
1823: scope@var2269 =@expr1073750815 scope@var2269 .@expr8982 parent@var2270 ;
1824: }
1825: }
1826: ScopeInfo3 * parent@var2272 ;
1827: std :: list < ScopeInfo3 > children@var2273 ;
1828: Type type@var2274 ;
1829: std :: string fullName@var2275 ;
1830: std :: string name@var2276 ;
1831: const Token * bodyStart@var2277 ;
1832: const Token * bodyEnd@var2278 ;
1833: std :: set < std :: string > usingNamespaces@var2279 ;
1834: std :: set < std :: string > recordTypes@var2280 ;
1835: std :: set < std :: string > baseTypes@var2281 ;
1836:
1837: ScopeInfo3 * addChild ( Type scopeType@var2282 , const std :: string & scopeName@var2283 , const Token * bodyStartToken@var2284 , const Token * bodyEndToken@var2285 ) {
1838: children@var2273 .@expr1073750817 emplace_back (@expr1073750818 this@expr1073750819 , scopeType@var2282 , scopeName@var2283 , bodyStartToken@var2284 , bodyEndToken@var2285 ) ;
1839: return &@expr1073750820 children@var2273 .@expr1073750821 back (@expr1073750822 ) ;
1840: }
1841:
1842: bool hasChild ( const std :: string & childName@var2286 ) const {
1843: for (@expr1073750823 const auto &@expr1073750824 child@var2287 :@expr1073750825 children@var2273 ) {
1844: if (@expr1073750826 child@var2287 .@expr1073750827 name@var2288 ==@expr1073750828 childName@var2286 ) {
1845: return true ; }
1846: }
1847: return false ;
1848: }
1849:
1850: const ScopeInfo3 * findInChildren ( const std :: string & scope@var2289 ) const {
1851: for (@expr1073750829 const auto &@expr1073750830 child@var2290 :@expr1073750831 children@var2273 ) {
1852: if (@expr1073750832 child@var2290 .@expr1073750833 type@var2291 ==@expr1073750834 Record &&@expr1073750835 (@expr1073750836 child@var2290 .@expr1073750837 name@var2292 ==@expr1073750838 scope@var2289 ||@expr1073750839 child@var2290 .@expr1073750840 fullName@var2293 ==@expr1073750841 scope@var2289 ) ) {
1853: return &@expr1073750842 child@var2290 ; }
1854: else {
1855: const ScopeInfo3 * temp@var2294 ; temp@var2294 =@expr1073750843 child@var2290 .@expr1073750844 findInChildren (@expr1073750845 scope@var2289 ) ;
1856: if (@expr1073750846 temp@var2294 ) {
1857: return temp@var2294 ; }
1858: }
1859: }
1860: return nullptr ;
1861: }
1862:
1863: const ScopeInfo3 * findScope ( const std :: string & scope@var2295 ) const {
1864: const ScopeInfo3 * tempScope@var2296 ; tempScope@var2296 =@expr1073750847 this@expr9024 ;
1865: while (@expr1073750849 tempScope@var2296 ) {
1866:
1867: for (@expr1073750850 const auto &@expr9027 child@var2297 :@expr1073750852 tempScope@var2296 .@expr1073750853 children@var2298 ) {
1868: if (@expr1073750854 &@expr9031 child@var2297 !=@expr1073750856 this@expr9024 &&@expr1073750857 child@var2297 .@expr1073750858 type@var2299 ==@expr1073750859 Record &&@expr1073750860 (@expr1073750861 child@var2297 .@expr1073750862 name@var2300 ==@expr1073750863 scope@var2295 ||@expr1073750864 child@var2297 .@expr1073750865 fullName@var2301 ==@expr1073750866 scope@var2295 ) ) {
1869: return &@expr9031 child@var2297 ; }
1870: }
1871:
1872: if (@expr1073750868 tempScope@var2296 .@expr9045 parent@var2302 ) {
1873: for (@expr1073750870 const auto &@expr9027 sibling@var2303 :@expr1073750872 tempScope@var2296 .@expr9045 parent@var2302 .@expr1073750874 children@var2304 ) {
1874: if (@expr1073750875 sibling@var2303 .@expr1073750876 name@var2305 ==@expr1073750877 tempScope@var2296 .@expr1073750878 name@var2306 &&@expr1073750879 &@expr1073750880 sibling@var2303 !=@expr1073750881 this@expr9024 ) {
1875: const ScopeInfo3 * temp@var2307 ; temp@var2307 =@expr1073750882 sibling@var2303 .@expr1073750883 findInChildren (@expr1073750884 scope@var2295 ) ;
1876: if (@expr1073750885 temp@var2307 ) {
1877: return temp@var2307 ; }
1878: }
1879: }
1880: }
1881: tempScope@var2296 =@expr1073750886 tempScope@var2296 .@expr9045 parent@var2302 ;
1882: }
1883: return nullptr ;
1884: }
1885:
1886: bool findTypeInBase ( const std :: string & scope@var2308 ) const {
1887: if (@expr1073750888 scope@var2308 .@expr1073750889 empty (@expr1073750890 ) ) {
1888: return false ; }
1889:
1890: if (@expr1073750891 baseTypes@var2281 .@expr1073750892 find (@expr1073750893 scope@var2308 ) !=@expr1073750894 baseTypes@var2281 .@expr1073750895 end (@expr1073750896 ) ) {
1891: return true ; }
1892:
1893: for (@expr1073750897 const std ::@expr1073750898 string &@expr1073750899 base@var2309 :@expr1073750900 baseTypes@var2281 ) {
1894: const ScopeInfo3 * baseScope@var2310 ; baseScope@var2310 =@expr1073750901 findScope (@expr1073750902 base@var2309 ) ;
1895:
1896: if (@expr1073750903 baseScope@var2310 ==@expr1073750904 this@expr1073750905 ) {
1897: return false ; }
1898: if (@expr1073750906 baseScope@var2310 &&@expr1073750907 baseScope@var2310 .@expr1073750908 fullName@var2311 ==@expr1073750909 scope@var2308 ) {
1899: return true ; }
1900: if (@expr1073750910 baseScope@var2310 &&@expr1073750911 baseScope@var2310 .@expr1073750912 findTypeInBase (@expr1073750913 scope@var2308 ) ) {
1901: return true ; }
1902: }
1903: return false ;
1904: }
1905:
1906: ScopeInfo3 * findScope ( const ScopeInfo3 * scope@var2312 ) {
1907: if (@expr1073750914 scope@var2312 .@expr1073750915 bodyStart@var2313 ==@expr1073750916 bodyStart@var2277 ) {
1908: return this@expr1073750917 ; }
1909: for (@expr1073750918 auto &@expr1073750919 child@var2314 :@expr1073750920 children@var2273 ) {
1910: ScopeInfo3 * temp@var2315 ; temp@var2315 =@expr1073750921 child@var2314 .@expr1073750922 findScope (@expr1073750923 scope@var2312 ) ;
1911: if (@expr1073750924 temp@var2315 ) {
1912: return temp@var2315 ; }
1913: }
1914: return nullptr ;
1915: }
1916: } ;
1917:
1918: void setScopeInfo ( Token * tok@var2316 , ScopeInfo3 * * scopeInfo@var2317 , bool debug@var2318 = false )
1919: {
1920: if (@expr1073750925 !@expr1073750926 tok@var2316 ) {
1921: return ; }
1922: if (@expr1073750927 tok@var2316 .@expr9104 str (@expr9105 ) ==@expr9106 "{" &&@expr1073750931 (@expr9108 *@expr9109 scopeInfo@var2317 ) .@expr9110 parent@var2319 &&@expr1073750935 tok@var2316 ==@expr1073750936 (@expr9108 *@expr9109 scopeInfo@var2317 ) .@expr1073750939 bodyStart@var2320 ) {
1923: return ; }
1924: if (@expr1073750940 tok@var2316 .@expr9104 str (@expr9105 ) ==@expr1073750943 "}" ) {
1925: if (@expr1073750944 (@expr9108 *@expr9109 scopeInfo@var2317 ) .@expr9110 parent@var2319 &&@expr1073750948 tok@var2316 ==@expr1073750949 (@expr9108 *@expr9109 scopeInfo@var2317 ) .@expr1073750952 bodyEnd@var2321 ) {
1926: *@expr9109 scopeInfo@var2317 =@expr1073750954 (@expr9108 *@expr9109 scopeInfo@var2317 ) .@expr9110 parent@var2319 ; }
1927: else {
1928:
1929: ScopeInfo3 * parent@var2322 ; parent@var2322 =@expr1073750958 (@expr9108 *@expr9109 scopeInfo@var2317 ) .@expr9110 parent@var2319 ;
1930: while (@expr1073750962 parent@var2322 &&@expr1073750963 parent@var2322 .@expr1073750964 bodyEnd@var2323 !=@expr1073750965 tok@var2316 ) {
1931: parent@var2322 =@expr1073750966 parent@var2322 .@expr1073750967 parent@var2324 ; }
1932: if (@expr1073750968 parent@var2322 ) {
1933: *@expr9109 scopeInfo@var2317 =@expr1073750970 parent@var2322 ;
1934: if (@expr1073750971 debug@var2318 ) {
1935: throw std ::@expr1073750972 runtime_error (@expr1073750973 "Internal error: unmatched }" ) ; }
1936: }
1937: }
1938: return ;
1939: }
1940: if (@expr1073750974 !@expr1073750975 Token ::@expr9152 Match (@expr1073750977 tok@var2316 , "namespace|class|struct|union %name% {|:|::|<" ) ) {
1941:
1942: if (@expr1073750978 Token ::@expr9152 Match (@expr1073750980 tok@var2316 , "using namespace %name% ;|::" ) ) {
1943: const Token * tok1@var2325 ; tok1@var2325 =@expr1073750981 tok@var2316 .@expr9158 tokAt (@expr9159 2 ) ;
1944: std ::@expr1073750984 string nameSpace@var2326 ;
1945: while (@expr1073750985 tok1@var2325 &&@expr1073750986 tok1@var2325 .@expr9163 str (@expr9164 ) !=@expr1073750989 ";" ) {
1946: if (@expr1073750990 !@expr1073750991 nameSpace@var2326 .@expr1073750992 empty (@expr1073750993 ) ) {
1947: nameSpace@var2326 +=@expr1073750994 " " ; }
1948: nameSpace@var2326 +=@expr1073750995 tok1@var2325 .@expr9163 str (@expr9164 ) ;
1949: tok1@var2325 =@expr1073750998 tok1@var2325 .@expr1073750999 next (@expr1073751000 ) ;
1950: }
1951: (@expr9108 *@expr9109 scopeInfo@var2317 ) .@expr1073751003 usingNamespaces@var2327 .@expr1073751004 insert (@expr1073751005 nameSpace@var2326 ) ;
1952: }
1953:
1954: else { if (@expr1073751006 tok@var2316 .@expr9104 str (@expr9105 ) ==@expr9106 "{" ) {
1955: bool added@var2328 ; added@var2328 =@expr1073751010 false ;
1956: Token * tok1@var2329 ; tok1@var2329 =@expr1073751011 tok@var2316 ;
1957: while (@expr9188 Token ::@expr9152 Match (@expr9190 tok1@var2329 .@expr9191 previous (@expr9192 ) , "const|volatile|final|override|&|&&|noexcept" ) ) {
1958: tok1@var2329 =@expr1073751017 tok1@var2329 .@expr9191 previous (@expr9192 ) ; }
1959: if (@expr1073751020 tok1@var2329 .@expr9191 previous (@expr9192 ) &&@expr1073751023 (@expr1073751024 tok1@var2329 .@expr9201 strAt (@expr9202 -1 ) ==@expr1073751027 ")" ||@expr1073751028 tok@var2316 .@expr1073751029 strAt (@expr1073751030 -1 ) ==@expr1073751031 "}" ) ) {
1960: tok1@var2329 =@expr1073751032 tok1@var2329 .@expr9209 linkAt (@expr9210 -1 ) ;
1961: if (@expr1073751035 Token ::@expr9152 Match (@expr1073751037 tok1@var2329 .@expr9191 previous (@expr9192 ) , "throw|noexcept (" ) ) {
1962: tok1@var2329 =@expr1073751040 tok1@var2329 .@expr9191 previous (@expr9192 ) ;
1963: while (@expr9188 Token ::@expr9152 Match (@expr9190 tok1@var2329 .@expr9191 previous (@expr9192 ) , "const|volatile|final|override|&|&&|noexcept" ) ) {
1964: tok1@var2329 =@expr1073751048 tok1@var2329 .@expr9191 previous (@expr9192 ) ; }
1965: if (@expr1073751051 tok1@var2329 .@expr9201 strAt (@expr9202 -1 ) !=@expr9230 ")" ) {
1966: return ; }
1967: tok1@var2329 =@expr1073751055 tok1@var2329 .@expr9209 linkAt (@expr9210 -1 ) ;
1968: } else {
1969: while (@expr1073751058 Token ::@expr9152 Match (@expr1073751060 tok1@var2329 .@expr9237 tokAt (@expr9238 -2 ) , ":|, %name%" ) ) {
1970: tok1@var2329 =@expr1073751063 tok1@var2329 .@expr9237 tokAt (@expr9238 -2 ) ;
1971: if (@expr1073751066 tok1@var2329 .@expr9201 strAt (@expr9202 -1 ) !=@expr9230 ")" &&@expr1073751070 tok1@var2329 .@expr9201 strAt (@expr9202 -1 ) !=@expr1073751073 "}" ) {
1972: return ; }
1973: tok1@var2329 =@expr1073751074 tok1@var2329 .@expr9209 linkAt (@expr9210 -1 ) ;
1974: }
1975: }
1976: if (@expr1073751077 tok1@var2329 .@expr9201 strAt (@expr9202 -1 ) ==@expr1073751080 ">" ) {
1977: tok1@var2329 =@expr1073751081 tok1@var2329 .@expr9191 previous (@expr9192 ) .@expr1073751084 findOpeningBracket (@expr1073751085 ) ; }
1978: if (@expr1073751086 tok1@var2329 &&@expr1073751087 (@expr1073751088 Token ::@expr9152 Match (@expr1073751090 tok1@var2329 .@expr9237 tokAt (@expr1073751092 -3 ) , "%name% :: %name%" ) ||@expr1073751093
1979: Token ::@expr9152 Match (@expr1073751095 tok1@var2329 .@expr9237 tokAt (@expr1073751097 -4 ) , "%name% :: ~ %name%" ) ) ) {
1980: tok1@var2329 =@expr1073751098 tok1@var2329 .@expr9237 tokAt (@expr9238 -2 ) ;
1981: if (@expr1073751101 tok1@var2329 .@expr1073751102 str (@expr1073751103 ) ==@expr1073751104 "~" ) {
1982: tok1@var2329 =@expr1073751105 tok1@var2329 .@expr9191 previous (@expr9192 ) ; }
1983: std ::@expr1073751108 string scope@var2330 ; scope@var2330 =@expr1073751109 tok1@var2329 .@expr9201 strAt (@expr9202 -1 ) ;
1984: while (@expr1073751112 Token ::@expr9152 Match (@expr1073751114 tok1@var2329 .@expr9237 tokAt (@expr9238 -2 ) , ":: %name%" ) ) {
1985: scope@var2330 =@expr1073751117 tok1@var2329 .@expr9201 strAt (@expr1073751119 -3 ) +@expr1073751120 " :: " +@expr1073751121 scope@var2330 ;
1986: tok1@var2329 =@expr1073751122 tok1@var2329 .@expr9237 tokAt (@expr9238 -2 ) ;
1987: }
1988: *@expr9109 scopeInfo@var2317 =@expr1073751126 (@expr9108 *@expr9109 scopeInfo@var2317 ) .@expr9305 addChild (@expr1073751130 ScopeInfo3 ::@expr1073751131 MemberFunction , scope@var2330 , tok@var2316 , tok@var2316 .@expr9308 link (@expr9309 ) ) ;
1989: added@var2328 =@expr1073751134 true ;
1990: }
1991: }
1992:
1993: if (@expr1073751135 !@expr1073751136 added@var2328 ) {
1994: *@expr9109 scopeInfo@var2317 =@expr1073751138 (@expr9108 *@expr9109 scopeInfo@var2317 ) .@expr9305 addChild (@expr1073751142 ScopeInfo3 ::@expr1073751143 Other , "" , tok@var2316 , tok@var2316 .@expr9308 link (@expr9309 ) ) ; }
1995: } }
1996: return ;
1997: }
1998:
1999: const bool record@var2331 =@expr1073751146 Token ::@expr9152 Match (@expr1073751148 tok@var2316 , "class|struct|union %name%" ) ;
2000: tok@var2316 =@expr1073751149 tok@var2316 .@expr9326 next (@expr9327 ) ;
2001: std ::@expr1073751152 string classname@var2332 ; classname@var2332 =@expr1073751153 tok@var2316 .@expr9104 str (@expr9105 ) ;
2002: while (@expr1073751156 Token ::@expr9152 Match (@expr1073751158 tok@var2316 , "%name% :: %name%" ) ) {
2003: tok@var2316 =@expr1073751159 tok@var2316 .@expr9158 tokAt (@expr9159 2 ) ;
2004: classname@var2332 +=@expr1073751162 " :: " +@expr1073751163 tok@var2316 .@expr9104 str (@expr9105 ) ;
2005: }
2006:
2007:
2008: if (@expr1073751166 record@var2331 ) {
2009: (@expr9108 *@expr9109 scopeInfo@var2317 ) .@expr1073751169 recordTypes@var2333 .@expr1073751170 insert (@expr1073751171 classname@var2332 ) ; }
2010: tok@var2316 =@expr1073751172 tok@var2316 .@expr9326 next (@expr9327 ) ;
2011:
2012:
2013: if (@expr9351 tok@var2316 &&@expr9352 tok@var2316 .@expr9104 str (@expr9105 ) ==@expr9355 "<" ) {
2014: tok@var2316 =@expr1073751180 tok@var2316 .@expr9357 findClosingBracket (@expr9358 ) ;
2015: if (@expr9359 tok@var2316 ) {
2016: tok@var2316 =@expr1073751184 tok@var2316 .@expr9326 next (@expr9327 ) ; }
2017: }
2018:
2019:
2020: std ::@expr1073751187 set < std ::@expr1073751188 string > baseTypes@var2334 ;
2021: if (@expr1073751189 tok@var2316 &&@expr1073751190 tok@var2316 .@expr9104 str (@expr9105 ) ==@expr1073751193 ":" ) {
2022: do {
2023: tok@var2316 =@expr1073751194 tok@var2316 .@expr9326 next (@expr9327 ) ;
2024: while (@expr1073751197 Token ::@expr9152 Match (@expr1073751199 tok@var2316 , "public|protected|private|virtual" ) ) {
2025: tok@var2316 =@expr1073751200 tok@var2316 .@expr9326 next (@expr9327 ) ; }
2026: std ::@expr1073751203 string base@var2335 ;
2027: while (@expr1073751204 tok@var2316 &&@expr1073751205 !@expr1073751206 Token ::@expr9152 Match (@expr1073751208 tok@var2316 , ";|,|{" ) ) {
2028: if (@expr1073751209 !@expr1073751210 base@var2335 .@expr1073751211 empty (@expr1073751212 ) ) {
2029: base@var2335 +=@expr1073751213 ' ' ; }
2030: base@var2335 +=@expr1073751214 tok@var2316 .@expr9104 str (@expr9105 ) ;
2031: tok@var2316 =@expr1073751217 tok@var2316 .@expr9326 next (@expr9327 ) ;
2032:
2033: if (@expr9351 tok@var2316 &&@expr9352 tok@var2316 .@expr9104 str (@expr9105 ) ==@expr9355 "<" ) {
2034: tok@var2316 =@expr1073751225 tok@var2316 .@expr9357 findClosingBracket (@expr9358 ) ;
2035: if (@expr9359 tok@var2316 ) {
2036: tok@var2316 =@expr1073751229 tok@var2316 .@expr9326 next (@expr9327 ) ; }
2037: }
2038: }
2039: baseTypes@var2334 .@expr1073751232 insert (@expr1073751233 base@var2335 ) ;
2040: } while (@expr1073751234 tok@var2316 &&@expr1073751235 !@expr1073751236 Token ::@expr9152 Match (@expr1073751238 tok@var2316 , ";|{" ) ) ;
2041: }
2042:
2043: if (@expr1073751239 tok@var2316 &&@expr1073751240 tok@var2316 .@expr9104 str (@expr9105 ) ==@expr9106 "{" ) {
2044: *@expr9109 scopeInfo@var2317 =@expr1073751245 (@expr9108 *@expr9109 scopeInfo@var2317 ) .@expr9305 addChild (@expr1073751249 record@var2331 ?@expr1073751250 ScopeInfo3 ::@expr1073751251 Record :@expr1073751252 ScopeInfo3 ::@expr1073751253 Namespace , classname@var2332 , tok@var2316 , tok@var2316 .@expr9308 link (@expr9309 ) ) ;
2045: (@expr9108 *@expr9109 scopeInfo@var2317 ) .@expr1073751258 baseTypes@var2336 =@expr1073751259 baseTypes@var2334 ;
2046: }
2047: }
2048:
2049: Token * findSemicolon ( Token * tok@var2337 )
2050: {
2051: int level@var2338 ; level@var2338 =@expr1073751260 0 ;
2052:
2053: for (@expr1073751261 ; tok@var2337 &&@expr1073751262 (@expr1073751263 level@var2338 >@expr9440 0 ||@expr1073751265 tok@var2337 .@expr9442 str (@expr9443 ) !=@expr1073751268 ";" ) ; tok@var2337 =@expr1073751269 tok@var2337 .@expr1073751270 next (@expr1073751271 ) ) {
2054: if (@expr1073751272 tok@var2337 .@expr9442 str (@expr9443 ) ==@expr1073751275 "{" ) {
2055: ++@expr1073751276 level@var2338 ; }
2056: else { if (@expr1073751277 level@var2338 >@expr9440 0 &&@expr1073751279 tok@var2337 .@expr9442 str (@expr9443 ) ==@expr1073751282 "}" ) {
2057: --@expr1073751283 level@var2338 ; } }
2058: }
2059:
2060: return tok@var2337 ;
2061: }
2062:
2063: bool usingMatch (
2064: const Token * nameToken@var2339 ,
2065: const std :: string & scope@var2340 ,
2066: Token * * tok@var2341 ,
2067: const std :: string & scope1@var2342 ,
2068: const ScopeInfo3 * currentScope@var2343 ,
2069: const ScopeInfo3 * memberClassScope@var2344 )
2070: {
2071: Token * tok1@var2345 ; tok1@var2345 =@expr1073751285 *@expr9462 tok@var2341 ;
2072:
2073: if (@expr1073751287 tok1@var2345 &&@expr1073751288 tok1@var2345 .@expr1073751289 str (@expr1073751290 ) !=@expr1073751291 nameToken@var2339 .@expr1073751292 str (@expr1073751293 ) ) {
2074: return false ; }
2075:
2076:
2077: if (@expr1073751294 tok1@var2345 ==@expr1073751295 nameToken@var2339 ) {
2078: *@expr9462 tok@var2341 =@expr1073751297 findSemicolon (@expr1073751298 tok1@var2345 ) ;
2079: return false ;
2080: }
2081:
2082:
2083: if (@expr1073751299 tok1@var2345 .@expr1073751300 strAt (@expr1073751301 -1 ) ==@expr1073751302 "using" ) {
2084:
2085:
2086: if (@expr1073751303 currentScope@var2343 .@expr9480 bodyEnd@var2346 ) {
2087: *@expr9462 tok@var2341 =@expr1073751306 currentScope@var2343 .@expr9480 bodyEnd@var2346 .@expr1073751308 previous (@expr1073751309 ) ; }
2088: return false ;
2089: }
2090:
2091: if (@expr1073751310 Token ::@expr9487 Match (@expr1073751312 tok1@var2345 .@expr1073751313 tokAt (@expr1073751314 -1 ) , "class|struct|union|enum|namespace" ) ) {
2092:
2093: return false ;
2094: }
2095:
2096:
2097: std ::@expr1073751315 string qualification@var2347 ;
2098: const Token * tok2@var2348 ; tok2@var2348 =@expr1073751316 tok1@var2345 ;
2099: std ::@expr9493 string ::@expr1073751318 size_type index@var2349 ; index@var2349 =@expr1073751319 scope@var2340 .@expr1073751320 size (@expr1073751321 ) ;
2100: std ::@expr9493 string ::@expr1073751323 size_type new_index@var2350 ; new_index@var2350 =@expr1073751324 std ::@expr9493 string ::@expr9502 npos@expr9460 ;
2101: bool match@var2351 ; match@var2351 =@expr1073751327 true ;
2102: while (@expr1073751328 Token ::@expr9487 Match (@expr1073751330 tok2@var2348 .@expr9507 tokAt (@expr9508 -2 ) , "%name% ::" ) &&@expr1073751333 !@expr1073751334 tok2@var2348 .@expr9507 tokAt (@expr9508 -2 ) .@expr1073751337 isKeyword (@expr1073751338 ) ) {
2103: std ::@expr1073751339 string last@var2352 ;
2104: if (@expr1073751340 match@var2351 &&@expr1073751341 !@expr9518 scope1@var2342 .@expr9519 empty (@expr9520 ) ) {
2105: new_index@var2350 =@expr1073751345 scope1@var2342 .@expr1073751346 rfind (@expr1073751347 ' ' , index@var2349 -@expr9524 1 ) ;
2106: if (@expr1073751349 new_index@var2350 !=@expr1073751350 std ::@expr9493 string ::@expr9502 npos@expr9460 ) {
2107: last@var2352 =@expr1073751353 scope1@var2342 .@expr1073751354 substr (@expr1073751355 new_index@var2350 , index@var2349 -@expr1073751356 new_index@var2350 ) ; }
2108: else { if (@expr9533 !@expr9534 qualification@var2347 .@expr9535 empty (@expr9536 ) ) {
2109: last@var2352 .@expr1073751361 clear (@expr1073751362 ) ; }
2110: else {
2111: last@var2352 =@expr1073751363 scope1@var2342 ; } }
2112: } else {
2113: match@var2351 =@expr1073751364 false ; }
2114: if (@expr1073751365 match@var2351 &&@expr1073751366 tok2@var2348 .@expr9543 strAt (@expr9544 -2 ) ==@expr1073751369 last@var2352 ) {
2115: index@var2349 =@expr1073751370 new_index@var2350 ; }
2116: else {
2117: if (@expr9533 !@expr9534 qualification@var2347 .@expr9535 empty (@expr9536 ) ) {
2118: qualification@var2347 =@expr1073751375 " :: " +@expr1073751376 qualification@var2347 ; }
2119: qualification@var2347 =@expr1073751377 tok2@var2348 .@expr9543 strAt (@expr9544 -2 ) +@expr1073751380 qualification@var2347 ;
2120: }
2121: tok2@var2348 =@expr1073751381 tok2@var2348 .@expr9507 tokAt (@expr9508 -2 ) ;
2122: }
2123:
2124: std ::@expr1073751384 string fullScope1@var2353 ; fullScope1@var2353 =@expr1073751385 scope1@var2342 ;
2125: if (@expr1073751386 !@expr9518 scope1@var2342 .@expr9519 empty (@expr9520 ) &&@expr1073751390 !@expr9534 qualification@var2347 .@expr9535 empty (@expr9536 ) ) {
2126: fullScope1@var2353 +=@expr1073751394 " :: " ; }
2127: fullScope1@var2353 +=@expr1073751395 qualification@var2347 ;
2128:
2129: if (@expr1073751396 scope@var2340 ==@expr1073751397 fullScope1@var2353 ) {
2130: return true ; }
2131:
2132: const ScopeInfo3 * scopeInfo@var2354 ; scopeInfo@var2354 =@expr1073751398 memberClassScope@var2344 ?@expr1073751399 memberClassScope@var2344 :@expr1073751400 currentScope@var2343 ;
2133:
2134:
2135: if (@expr1073751401 qualification@var2347 .@expr9535 empty (@expr9536 ) &&@expr1073751404 scopeInfo@var2354 .@expr1073751405 findTypeInBase (@expr1073751406 scope@var2340 ) ) {
2136: return true ; }
2137:
2138:
2139: const ScopeInfo3 * tempScope@var2355 ; tempScope@var2355 =@expr1073751407 scopeInfo@var2354 ;
2140: while (@expr1073751408 tempScope@var2355 ) {
2141:
2142: if (@expr1073751409 !@expr1073751410 tempScope@var2355 .@expr9587 usingNamespaces@var2356 .@expr1073751412 empty (@expr1073751413 ) ) {
2143: if (@expr1073751414 qualification@var2347 .@expr9535 empty (@expr9536 ) ) {
2144: if (@expr1073751417 tempScope@var2355 .@expr9587 usingNamespaces@var2356 .@expr1073751419 find (@expr1073751420 scope@var2340 ) !=@expr1073751421 tempScope@var2355 .@expr9587 usingNamespaces@var2356 .@expr1073751423 end (@expr1073751424 ) ) {
2145: return true ; }
2146: } else {
2147: for (@expr1073751425 const auto &@expr1073751426 ns@var2357 :@expr1073751427 tempScope@var2355 .@expr9587 usingNamespaces@var2356 ) {
2148: if (@expr1073751429 scope@var2340 ==@expr1073751430 ns@var2357 +@expr1073751431 " :: " +@expr1073751432 qualification@var2347 ) {
2149: return true ; }
2150: }
2151: }
2152: }
2153: tempScope@var2355 =@expr1073751433 tempScope@var2355 .@expr1073751434 parent@var2358 ;
2154: }
2155:
2156: std ::@expr1073751435 string newScope1@var2359 ; newScope1@var2359 =@expr1073751436 scope1@var2342 ;
2157:
2158:
2159: index@var2349 =@expr1073751437 newScope1@var2359 .@expr1073751438 size (@expr1073751439 ) ;
2160: while (@expr1073751440 !@expr9617 newScope1@var2359 .@expr9618 empty (@expr9619 ) ) {
2161: std ::@expr9493 string ::@expr1073751445 size_type separator@var2360 ; separator@var2360 =@expr1073751446 newScope1@var2359 .@expr1073751447 rfind (@expr1073751448 " :: " , index@var2349 -@expr9524 1 ) ;
2162: if (@expr1073751450 separator@var2360 !=@expr1073751451 std ::@expr9493 string ::@expr9502 npos@expr9460 ) {
2163: newScope1@var2359 =@expr1073751454 newScope1@var2359 .@expr1073751455 substr (@expr1073751456 0 , separator@var2360 ) ; }
2164: else {
2165: newScope1@var2359 .@expr1073751457 clear (@expr1073751458 ) ; }
2166:
2167: std ::@expr1073751459 string newFullScope1@var2361 ; newFullScope1@var2361 =@expr1073751460 newScope1@var2359 ;
2168: if (@expr1073751461 !@expr9617 newScope1@var2359 .@expr9618 empty (@expr9619 ) &&@expr1073751465 !@expr9534 qualification@var2347 .@expr9535 empty (@expr9536 ) ) {
2169: newFullScope1@var2361 +=@expr1073751469 " :: " ; }
2170: newFullScope1@var2361 +=@expr1073751470 qualification@var2347 ;
2171:
2172: if (@expr1073751471 scope@var2340 ==@expr1073751472 newFullScope1@var2361 ) {
2173: return true ; }
2174: }
2175:
2176: return false ;
2177: }
2178:
2179: std :: string memberFunctionScope ( const Token * tok@var2362 )
2180: {
2181: std ::@expr1073751473 string qualification@var2363 ;
2182: const Token * qualTok@var2364 ; qualTok@var2364 =@expr1073751474 tok@var2362 .@expr1073751475 strAt (@expr1073751476 -2 ) ==@expr1073751477 "~" ?@expr1073751478 tok@var2362 .@expr9655 tokAt (@expr1073751480 -4 ) :@expr1073751481 tok@var2362 .@expr9655 tokAt (@expr1073751483 -3 ) ;
2183: while (@expr1073751484 Token ::@expr1073751485 Match (@expr1073751486 qualTok@var2364 , "%type% ::" ) ) {
2184: if (@expr1073751487 !@expr1073751488 qualification@var2363 .@expr1073751489 empty (@expr1073751490 ) ) {
2185: qualification@var2363 =@expr1073751491 " :: " +@expr1073751492 qualification@var2363 ; }
2186: qualification@var2363 =@expr1073751493 qualTok@var2364 .@expr1073751494 str (@expr1073751495 ) +@expr1073751496 qualification@var2363 ;
2187: qualTok@var2364 =@expr1073751497 qualTok@var2364 .@expr1073751498 tokAt (@expr1073751499 -2 ) ;
2188: }
2189: return qualification@var2363 ;
2190: }
2191:
2192: const Token * memberFunctionEnd ( const Token * tok@var2365 )
2193: {
2194: if (@expr1073751500 tok@var2365 .@expr1073751501 str (@expr1073751502 ) !=@expr1073751503 "(" ) {
2195: return nullptr ; }
2196: const Token * end@var2366 ; end@var2366 =@expr1073751504 tok@var2365 .@expr1073751505 link (@expr1073751506 ) .@expr1073751507 next (@expr1073751508 ) ;
2197: while (@expr1073751509 end@var2366 ) {
2198: if (@expr1073751510 end@var2366 .@expr9687 str (@expr9688 ) ==@expr1073751513 "{" &&@expr1073751514 !@expr1073751515 Token ::@expr1073751516 Match (@expr1073751517 end@var2366 .@expr1073751518 tokAt (@expr1073751519 -2 ) , ":|, %name%" ) ) {
2199: return end@var2366 ; }
2200: else { if (@expr1073751520 end@var2366 .@expr9687 str (@expr9688 ) ==@expr1073751523 ";" ) {
2201: break ; } }
2202: end@var2366 =@expr1073751524 end@var2366 .@expr1073751525 next (@expr1073751526 ) ;
2203: }
2204: return nullptr ;
2205: }
2206: }
2207:
2208: bool Tokenizer :: isMemberFunction ( const Token * openParen@var2367 ) const
2209: {
2210: return (@expr1073751527 Token ::@expr9704 Match (@expr1073751529 openParen@var2367 .@expr9706 tokAt (@expr1073751531 -2 ) , ":: %name% (" ) ||@expr1073751532
2211: Token ::@expr9704 Match (@expr1073751534 openParen@var2367 .@expr9706 tokAt (@expr1073751536 -3 ) , ":: ~ %name% (" ) ) &&@expr1073751537
2212: isFunctionHead (@expr1073751538 openParen@var2367 , "{|:" ) ;
2213: }
2214:
2215: static bool scopesMatch ( const std :: string & scope1@var2368 , const std :: string & scope2@var2369 , const ScopeInfo3 * globalScope@var2370 )
2216: {
2217: if (@expr1073751540 scope1@var2368 .@expr1073751541 empty (@expr1073751542 ) ||@expr1073751543 scope2@var2369 .@expr1073751544 empty (@expr1073751545 ) ) {
2218: return false ; }
2219:
2220:
2221: if (@expr1073751546 scope1@var2368 ==@expr1073751547 scope2@var2369 ) {
2222: return true ; }
2223:
2224:
2225: if (@expr1073751548 scope1@var2368 ==@expr1073751549 (@expr1073751550 ":: " +@expr1073751551 scope2@var2369 ) ) {
2226: std ::@expr9728 string ::@expr1073751553 size_type end@var2371 ; end@var2371 =@expr1073751554 scope2@var2369 .@expr1073751555 find_first_of (@expr1073751556 ' ' ) ;
2227: if (@expr1073751557 end@var2371 ==@expr1073751558 std ::@expr9728 string ::@expr9736 npos@expr9715 ) {
2228: end@var2371 =@expr1073751561 scope2@var2369 .@expr1073751562 size (@expr1073751563 ) ; }
2229: if (@expr1073751564 globalScope@var2370 .@expr9741 hasChild (@expr1073751566 scope2@var2369 .@expr1073751567 substr (@expr1073751568 0 , end@var2371 ) ) ) {
2230: return true ; }
2231: } else { if (@expr1073751569 scope2@var2369 ==@expr1073751570 (@expr1073751571 ":: " +@expr1073751572 scope1@var2368 ) ) {
2232: std ::@expr9728 string ::@expr1073751574 size_type end@var2372 ; end@var2372 =@expr1073751575 scope1@var2368 .@expr1073751576 find_first_of (@expr1073751577 ' ' ) ;
2233: if (@expr1073751578 end@var2372 ==@expr1073751579 std ::@expr9728 string ::@expr9736 npos@expr9715 ) {
2234: end@var2372 =@expr1073751582 scope1@var2368 .@expr1073751583 size (@expr1073751584 ) ; }
2235: if (@expr1073751585 globalScope@var2370 .@expr9741 hasChild (@expr1073751587 scope1@var2368 .@expr1073751588 substr (@expr1073751589 0 , end@var2372 ) ) ) {
2236: return true ; }
2237: } }
2238:
2239: return false ;
2240: }
2241:
2242: bool Tokenizer :: simplifyUsing ( )
2243: {
2244: if (@expr1073751591 !@expr1073751592 isCPP (@expr1073751593 ) ||@expr1073751594 mSettings@var879 .@expr1073751595 standards@var3567 .@expr1073751596 cpp@var3568 <@expr1073751597 Standards ::@expr1073751598 CPP11 ) {
2245: return false ; }
2246:
2247: bool substitute@var2373 ; substitute@var2373 =@expr1073751599 false ;
2248: ScopeInfo3 scopeInfo@var2374 ;
2249: ScopeInfo3 * currentScope@var2375 ; currentScope@var2375 =@expr1073751600 &@expr1073751601 scopeInfo@var2374 ;
2250: struct Using {
2251: Using (@expr1073751602 Token * start@var2376 , Token * end@var2377 ) :@expr1073751603 startTok@var2378 (@expr1073751604 start@var2376 ) , endTok@var2379 (@expr1073751605 end@var2377 ) { }
2252: Token * startTok@var2378 ;
2253: Token * endTok@var2379 ;
2254: } ;
2255: std ::@expr1073751606 list < Using > usingList@var2380 ;
2256:
2257: for (@expr1073751607 Token *@expr9784 tok@var2381 =@expr1073751609 list@var872 .@expr9786 front (@expr9787 ) ; tok@var2381 ; tok@var2381 =@expr1073751612 tok@var2381 .@expr9789 next (@expr9790 ) ) {
2258: if (@expr1073751615 mErrorLogger@var880 &&@expr1073751616 !@expr1073751617 list@var872 .@expr9794 getFiles (@expr9795 ) .@expr1073751620 empty (@expr1073751621 ) ) {
2259: mErrorLogger@var880 .@expr1073751622 reportProgress (@expr1073751623 list@var872 .@expr9794 getFiles (@expr9795 ) [@expr1073751626 0 ] , "Tokenize (using)" , tok@var2381 .@expr1073751627 progressValue (@expr1073751628 ) ) ; }
2260:
2261: if (@expr1073751629 Settings ::@expr1073751630 terminated (@expr1073751631 ) ) {
2262: return substitute@var2373 ; }
2263:
2264: if (@expr1073751632 Token ::@expr9809 Match (@expr1073751634 tok@var2381 , "enum class|struct" ) ) {
2265: Token * bodyStart@var2382 ; bodyStart@var2382 =@expr1073751635 tok@var2381 ;
2266: while (@expr1073751636 Token ::@expr9809 Match (@expr1073751638 bodyStart@var2382 , "%name%|:|::|<" ) ) {
2267: if (@expr1073751639 bodyStart@var2382 .@expr1073751640 str (@expr1073751641 ) ==@expr1073751642 "<" ) {
2268: bodyStart@var2382 =@expr1073751643 bodyStart@var2382 .@expr1073751644 findClosingBracket (@expr1073751645 ) ; }
2269: bodyStart@var2382 =@expr1073751646 bodyStart@var2382 ?@expr1073751647 bodyStart@var2382 .@expr1073751648 next (@expr1073751649 ) :@expr1073751650 nullptr ;
2270: }
2271: if (@expr1073751651 Token ::@expr9828 simpleMatch (@expr1073751653 bodyStart@var2382 , "{" ) ) {
2272: tok@var2381 =@expr1073751654 bodyStart@var2382 .@expr1073751655 link (@expr1073751656 ) ; }
2273: continue ;
2274: }
2275:
2276: if (@expr1073751657 Token ::@expr9809 Match (@expr1073751659 tok@var2381 , "{|}|namespace|class|struct|union" ) ||@expr1073751660
2277: Token ::@expr9809 Match (@expr1073751662 tok@var2381 , "using namespace %name% ;|::" ) ) {
2278: try {
2279: setScopeInfo (@expr1073751663 tok@var2381 , &@expr1073751664 currentScope@var2375 , mSettings@var879 .@expr9841 debugwarnings@var3566 ) ;
2280: } catch (@expr9842 const std ::@expr9843 runtime_error &@expr9844 ) {
2281: reportError (@expr1073751669 tok@var2381 , Severity ::@expr9846 debug , "simplifyUsingUnmatchedBodyEnd" ,
2282: "simplifyUsing: unmatched body end" ) ;
2283: }
2284: continue ;
2285: }
2286:
2287:
2288: if (@expr1073751671 Token ::@expr9809 Match (@expr1073751673 tok@var2381 , "template < !!>" ) ) {
2289:
2290: const Token * end@var2383 ; end@var2383 =@expr1073751674 tok@var2381 .@expr9789 next (@expr9790 ) .@expr1073751677 findClosingBracket (@expr1073751678 ) ;
2291: if (@expr1073751679 end@var2383 &&@expr1073751680 Token ::@expr9809 Match (@expr1073751682 end@var2383 .@expr1073751683 next (@expr1073751684 ) , "class|struct|union %name%" ) ) {
2292: currentScope@var2375 .@expr1073751685 recordTypes@var2384 .@expr1073751686 insert (@expr1073751687 end@var2383 .@expr1073751688 strAt (@expr1073751689 2 ) ) ; }
2293:
2294: Token * declEndToken@var2385 ; declEndToken@var2385 =@expr1073751690 TemplateSimplifier ::@expr9867 findTemplateDeclarationEnd (@expr1073751692 tok@var2381 ) ;
2295: if (@expr1073751693 declEndToken@var2385 ) {
2296: tok@var2381 =@expr1073751694 declEndToken@var2385 ; }
2297: continue ;
2298: }
2299:
2300:
2301: if (@expr1073751695 !@expr1073751696 (@expr1073751697 tok@var2381 .@expr9874 strAt (@expr1073751699 -1 ) !=@expr1073751700 ">" &&@expr1073751701
2302: (@expr1073751702 Token ::@expr9809 Match (@expr1073751704 tok@var2381 , "using %name% = ::| %name%" ) ||@expr1073751705
2303: (@expr1073751706 Token ::@expr9809 Match (@expr1073751708 tok@var2381 , "using %name% [ [" ) &&@expr1073751709
2304: Token ::@expr9809 Match (@expr1073751711 tok@var2381 .@expr9888 linkAt (@expr9889 2 ) , "] ] = ::| %name%" ) ) ) ) ) {
2305: continue ; }
2306:
2307: std ::@expr1073751714 string name@var2386 ; name@var2386 =@expr1073751715 tok@var2381 .@expr9874 strAt (@expr1073751717 1 ) ;
2308: const Token * nameToken@var2387 ; nameToken@var2387 =@expr1073751718 tok@var2381 .@expr9789 next (@expr9790 ) ;
2309: std ::@expr1073751721 string scope@var2388 ; scope@var2388 =@expr1073751722 currentScope@var2375 .@expr9899 fullName@var2389 ;
2310: Token * usingStart@var2390 ; usingStart@var2390 =@expr1073751724 tok@var2381 ;
2311: Token * start@var2391 ;
2312: if (@expr1073751725 tok@var2381 .@expr9874 strAt (@expr1073751727 2 ) ==@expr1073751728 "=" ) {
2313: start@var2391 =@expr1073751729 tok@var2381 .@expr1073751730 tokAt (@expr1073751731 3 ) ; }
2314: else {
2315: start@var2391 =@expr1073751732 tok@var2381 .@expr9888 linkAt (@expr9889 2 ) .@expr1073751735 tokAt (@expr1073751736 3 ) ; }
2316: Token * usingEnd@var2392 ; usingEnd@var2392 =@expr1073751737 findSemicolon (@expr9914 start@var2391 ) ;
2317: if (@expr1073751739 !@expr1073751740 usingEnd@var2392 ) {
2318: continue ; }
2319:
|
2322:
2323: if (@expr1073751741 Token ::@expr9809 Match (@expr1073751743 start@var2391 , "class|struct|union|enum %name%| {|:" ) ) {
2324: Token * structEnd@var2393 ; structEnd@var2393 =@expr1073751744 start@var2391 .@expr1073751745 tokAt (@expr1073751746 1 ) ;
2325: const bool hasName@var2394 =@expr1073751747 Token ::@expr9809 Match (@expr1073751749 structEnd@var2393 , "%name%" ) ;
2326:
2327:
2328: if (@expr1073751750 hasName@var2394 ) {
2329: structEnd@var2393 =@expr1073751751 structEnd@var2393 .@expr9928 next (@expr9929 ) ; }
2330:
2331:
2332: if (@expr1073751754 structEnd@var2393 .@expr9931 str (@expr9932 ) ==@expr1073751757 ":" ) {
2333: structEnd@var2393 =@expr1073751758 structEnd@var2393 .@expr9928 next (@expr9929 ) ;
2334: while (@expr1073751761 structEnd@var2393 &&@expr1073751762 structEnd@var2393 .@expr9931 str (@expr9932 ) !=@expr1073751765 "{" ) {
2335: structEnd@var2393 =@expr1073751766 structEnd@var2393 .@expr9928 next (@expr9929 ) ; }
2336: if (@expr1073751769 !@expr1073751770 structEnd@var2393 ) {
2337: continue ; }
2338: }
2339:
2340:
2341: structEnd@var2393 =@expr1073751771 structEnd@var2393 .@expr1073751772 link (@expr1073751773 ) ;
2342:
2343:
2344: structEnd@var2393 .@expr1073751774 insertToken (@expr1073751775 ";" , "" ) ;
2345:
2346:
2347: if (@expr1073751776 !@expr1073751777 hasName@var2394 ) {
2348: std ::@expr1073751778 string newName@var2395 ;
2349: if (@expr1073751779 structEnd@var2393 .@expr1073751780 strAt (@expr1073751781 2 ) ==@expr1073751782 ";" ) {
2350: newName@var2395 =@expr1073751783 name@var2386 ; }
2351: else {
2352: newName@var2395 =@expr1073751784 "Unnamed" +@expr1073751785 MathLib ::@expr1073751786 toString (@expr1073751787 mUnnamedCount@var892 ++@expr1073751788 ) ; }
2353: TokenList ::@expr9965 copyTokens (@expr1073751790 structEnd@var2393 .@expr9928 next (@expr9929 ) , tok@var2381 , start@var2391 ) ;
2354: structEnd@var2393 .@expr9969 tokAt (@expr1073751794 5 ) .@expr1073751795 insertToken (@expr1073751796 newName@var2395 , "" ) ;
2355: start@var2391 .@expr1073751797 insertToken (@expr1073751798 newName@var2395 , "" ) ;
2356: } else {
2357: TokenList ::@expr9965 copyTokens (@expr1073751800 structEnd@var2393 .@expr9928 next (@expr9929 ) , tok@var2381 , start@var2391 .@expr1073751803 next (@expr1073751804 ) ) ; }
2358:
2359:
2360: usingStart@var2390 =@expr1073751805 structEnd@var2393 .@expr9969 tokAt (@expr1073751807 2 ) ;
2361: nameToken@var2387 =@expr1073751808 usingStart@var2390 .@expr1073751809 next (@expr1073751810 ) ;
2362: if (@expr1073751811 usingStart@var2390 .@expr1073751812 strAt (@expr1073751813 2 ) ==@expr1073751814 "=" ) {
2363: start@var2391 =@expr1073751815 usingStart@var2390 .@expr1073751816 tokAt (@expr1073751817 3 ) ; }
2364: else {
2365: start@var2391 =@expr1073751818 usingStart@var2390 .@expr1073751819 linkAt (@expr1073751820 2 ) .@expr1073751821 tokAt (@expr1073751822 3 ) ; }
2366: usingEnd@var2392 =@expr1073751823 findSemicolon (@expr9914 start@var2391 ) ;
2367:
2368:
2369: tok@var2381 .@expr10001 deleteThis (@expr10002 ) ;
2370: tok@var2381 .@expr10001 deleteThis (@expr10002 ) ;
2371: tok@var2381 .@expr10001 deleteThis (@expr10002 ) ;
2372: tok@var2381 =@expr1073751831 usingStart@var2390 ;
2373: }
2374:
2375:
2376: else { if (@expr1073751832 start@var2391 .@expr10009 str (@expr10010 ) ==@expr1073751835 "typename" ) {
2377: start@var2391 .@expr1073751836 deleteThis (@expr1073751837 ) ;
2378: Token * temp@var2396 ; temp@var2396 =@expr1073751838 start@var2391 ;
2379: while (@expr1073751839 Token ::@expr9809 Match (@expr1073751841 temp@var2396 , "%name% ::" ) ) {
2380: temp@var2396 =@expr1073751842 temp@var2396 .@expr1073751843 tokAt (@expr1073751844 2 ) ; }
2381: if (@expr1073751845 Token ::@expr9809 Match (@expr1073751847 temp@var2396 , "template %name%" ) ) {
2382: temp@var2396 .@expr1073751848 deleteThis (@expr1073751849 ) ; }
2383: } }
2384:
2385: if (@expr1073751850 usingEnd@var2392 ) {
2386: tok@var2381 =@expr1073751851 usingEnd@var2392 ; }
2387:
|
2390:
2391: ScopeInfo3 scopeInfo1@var2397 ;
2392: ScopeInfo3 * currentScope1@var2398 ; currentScope1@var2398 =@expr1073751852 &@expr10029 scopeInfo1@var2397 ;
2393: Token * startToken@var2399 ; startToken@var2399 =@expr1073751854 list@var872 .@expr9786 front (@expr9787 ) ;
2394: Token * endToken@var2400 ; endToken@var2400 =@expr1073751857 nullptr ;
2395: bool inMemberFunc@var2401 ; inMemberFunc@var2401 =@expr1073751858 false ;
2396: const ScopeInfo3 * memberFuncScope@var2402 ; memberFuncScope@var2402 =@expr1073751859 nullptr ;
2397: const Token * memberFuncEnd@var2403 ; memberFuncEnd@var2403 =@expr1073751860 nullptr ;
2398:
2399:
2400:
2401: if (@expr1073751861 currentScope@var2375 .@expr10038 type@var2404 ==@expr1073751863 ScopeInfo3 ::@expr1073751864 Other ||@expr1073751865
2402: currentScope@var2375 .@expr10038 type@var2404 ==@expr10043 ScopeInfo3 ::@expr10044 MemberFunction ) {
2403: scopeInfo1@var2397 =@expr1073751869 scopeInfo@var2374 ;
2404: currentScope1@var2398 =@expr1073751870 scopeInfo1@var2397 .@expr1073751871 findScope (@expr1073751872 currentScope@var2375 ) ;
2405: if (@expr1073751873 !@expr1073751874 currentScope1@var2398 ) {
2406: return substitute@var2373 ; }
2407: startToken@var2399 =@expr1073751875 usingEnd@var2392 .@expr1073751876 next (@expr1073751877 ) ;
2408: endToken@var2400 =@expr1073751878 currentScope@var2375 .@expr1073751879 bodyEnd@var2405 .@expr1073751880 next (@expr1073751881 ) ;
2409: if (@expr1073751882 currentScope@var2375 .@expr10038 type@var2404 ==@expr10043 ScopeInfo3 ::@expr10044 MemberFunction ) {
2410: const ScopeInfo3 * temp@var2406 ; temp@var2406 =@expr1073751886 currentScope@var2375 .@expr1073751887 findScope (@expr1073751888 currentScope@var2375 .@expr9899 fullName@var2389 ) ;
2411: if (@expr1073751890 temp@var2406 ) {
2412: inMemberFunc@var2401 =@expr1073751891 true ;
2413: memberFuncScope@var2402 =@expr1073751892 temp@var2406 ;
2414: memberFuncEnd@var2403 =@expr1073751893 endToken@var2400 ;
2415: }
2416: }
2417: }
2418:
2419: std ::@expr1073751894 string scope1@var2407 ; scope1@var2407 =@expr1073751895 currentScope1@var2398 .@expr10072 fullName@var2408 ;
2420: bool skip@var2409 ; skip@var2409 =@expr1073751897 false ;
2421: Token * enumOpenBrace@var2410 ; enumOpenBrace@var2410 =@expr1073751898 nullptr ;
2422: for (@expr1073751899 Token *@expr9784 tok1@var2411 =@expr1073751901 startToken@var2399 ; !@expr10078 skip@var2409 &&@expr1073751903 tok1@var2411 &&@expr1073751904 tok1@var2411 !=@expr1073751905 endToken@var2400 ; tok1@var2411 =@expr1073751906 tok1@var2411 .@expr10083 next (@expr10084 ) ) {
2423:
2424: if (@expr1073751909 tok1@var2411 &&@expr1073751910 tok1@var2411 ==@expr1073751911 enumOpenBrace@var2410 ) {
2425: tok1@var2411 =@expr1073751912 tok1@var2411 .@expr1073751913 link (@expr1073751914 ) ;
2426: enumOpenBrace@var2410 =@expr1073751915 nullptr ;
2427: continue ;
2428: }
2429:
2430: if (@expr1073751916 (@expr1073751917 Token ::@expr9809 Match (@expr1073751919 tok1@var2411 , "{|}|namespace|class|struct|union" ) &&@expr1073751920 tok1@var2411 .@expr10097 strAt (@expr10098 -1 ) !=@expr1073751923 "using" ) ||@expr1073751924
2431: Token ::@expr9809 Match (@expr1073751926 tok1@var2411 , "using namespace %name% ;|::" ) ) {
2432: try {
2433: setScopeInfo (@expr1073751927 tok1@var2411 , &@expr1073751928 currentScope1@var2398 , mSettings@var879 .@expr9841 debugwarnings@var3566 ) ;
2434: } catch (@expr9842 const std ::@expr9843 runtime_error &@expr9844 ) {
2435: reportError (@expr1073751933 tok1@var2411 , Severity ::@expr9846 debug , "simplifyUsingUnmatchedBodyEnd" ,
2436: "simplifyUsing: unmatched body end" ) ;
2437: }
2438: scope1@var2407 =@expr1073751935 currentScope1@var2398 .@expr10072 fullName@var2408 ;
2439: if (@expr1073751937 inMemberFunc@var2401 &&@expr1073751938 memberFuncEnd@var2403 &&@expr1073751939 tok1@var2411 ==@expr1073751940 memberFuncEnd@var2403 ) {
2440: inMemberFunc@var2401 =@expr1073751941 false ;
2441: memberFuncScope@var2402 =@expr1073751942 nullptr ;
2442: memberFuncEnd@var2403 =@expr1073751943 nullptr ;
2443: }
2444: continue ;
2445: }
2446:
2447:
2448: if (@expr1073751944 Token ::@expr9809 Match (@expr1073751946 tok1@var2411 , "template < !!>" ) ) {
2449: Token * declEndToken@var2412 ; declEndToken@var2412 =@expr1073751947 TemplateSimplifier ::@expr9867 findTemplateDeclarationEnd (@expr1073751949 tok1@var2411 ) ;
2450: if (@expr1073751950 declEndToken@var2412 ) {
2451: tok1@var2411 =@expr1073751951 declEndToken@var2412 ; }
2452: continue ;
2453: }
2454:
2455:
2456: if (@expr1073751952 tok1@var2411 .@expr1073751953 str (@expr1073751954 ) ==@expr1073751955 "enum" ) {
2457: if (@expr1073751956 Token ::@expr9809 Match (@expr1073751958 tok1@var2411 , "enum class|struct" ) ) {
2458: tok1@var2411 =@expr1073751959 tok1@var2411 .@expr10083 next (@expr10084 ) ; }
2459: Token * defStart@var2413 ; defStart@var2413 =@expr1073751962 tok1@var2411 ;
2460: while (@expr1073751963 Token ::@expr9809 Match (@expr1073751965 defStart@var2413 , "%name%|::|:" ) ) {
2461: defStart@var2413 =@expr1073751966 defStart@var2413 .@expr1073751967 next (@expr1073751968 ) ; }
2462: if (@expr1073751969 Token ::@expr9828 simpleMatch (@expr1073751971 defStart@var2413 , "{" ) ) {
2463: enumOpenBrace@var2410 =@expr1073751972 defStart@var2413 ; }
2464: continue ;
2465: }
2466:
2467:
2468: if (@expr1073751973 isMemberFunction (@expr1073751974 tok1@var2411 ) ) {
2469: if (@expr1073751975 !@expr1073751976 scope1@var2407 .@expr1073751977 empty (@expr1073751978 ) ) {
2470: scope1@var2407 +=@expr1073751979 " :: " ; }
2471: scope1@var2407 +=@expr1073751980 memberFunctionScope (@expr1073751981 tok1@var2411 ) ;
2472: const ScopeInfo3 * temp@var2414 ; temp@var2414 =@expr1073751982 currentScope1@var2398 .@expr1073751983 findScope (@expr1073751984 scope1@var2407 ) ;
2473: if (@expr1073751985 temp@var2414 ) {
2474: const Token * end@var2415 ; end@var2415 =@expr1073751986 memberFunctionEnd (@expr1073751987 tok1@var2411 ) ;
2475: if (@expr1073751988 end@var2415 ) {
2476: inMemberFunc@var2401 =@expr1073751989 true ;
2477: memberFuncScope@var2402 =@expr1073751990 temp@var2414 ;
2478: memberFuncEnd@var2403 =@expr1073751991 end@var2415 ;
2479: }
2480: }
2481: continue ;
2482: } else { if (@expr1073751992 inMemberFunc@var2401 &&@expr1073751993 memberFuncScope@var2402 ) {
2483: if (@expr1073751994 !@expr1073751995 usingMatch (@expr1073751996 nameToken@var2387 , scope@var2388 , &@expr10173 tok1@var2411 , scope1@var2407 , currentScope1@var2398 , memberFuncScope@var2402 ) ) {
2484: continue ; }
2485: } else { if (@expr1073751998 !@expr1073751999 usingMatch (@expr1073752000 nameToken@var2387 , scope@var2388 , &@expr10173 tok1@var2411 , scope1@var2407 , currentScope1@var2398 , nullptr ) ) {
2486: continue ; } } }
2487:
2488:
2489: std ::@expr1073752002 string fullScope@var2416 ; fullScope@var2416 =@expr1073752003 scope@var2388 ;
2490: std ::@expr1073752004 string removed@var2417 ;
2491: while (@expr1073752005 Token ::@expr9809 Match (@expr1073752007 tok1@var2411 .@expr10184 tokAt (@expr10185 -2 ) , "%name% ::" ) &&@expr1073752010 !@expr1073752011 tok1@var2411 .@expr10184 tokAt (@expr10185 -2 ) .@expr1073752014 isKeyword (@expr1073752015 ) ) {
2492: removed@var2417 =@expr1073752016 (@expr1073752017 tok1@var2411 .@expr10097 strAt (@expr10195 -2 ) +@expr1073752020 " :: " ) +@expr1073752021 removed@var2417 ;
2493: if (@expr1073752022 fullScope@var2416 ==@expr1073752023 tok1@var2411 .@expr10097 strAt (@expr10195 -2 ) ) {
2494: tok1@var2411 .@expr10202 deletePrevious (@expr10203 ) ;
2495: tok1@var2411 .@expr10202 deletePrevious (@expr10203 ) ;
2496: break ;
2497: } else {
2498: const std ::@expr10206 string ::@expr10206 size_type idx@var2418 =@expr1073752032 fullScope@var2416 .@expr1073752033 rfind (@expr1073752034 " " ) ;
2499:
2500: if (@expr1073752035 idx@var2418 ==@expr1073752036 std ::@expr10213 string ::@expr10214 npos@expr9766 ) {
2501: break ; }
2502:
2503: if (@expr1073752039 tok1@var2411 .@expr10097 strAt (@expr10195 -2 ) ==@expr1073752042 fullScope@var2416 .@expr1073752043 substr (@expr1073752044 idx@var2418 +@expr1073752045 1 ) ) {
2504: tok1@var2411 .@expr10202 deletePrevious (@expr10203 ) ;
2505: tok1@var2411 .@expr10202 deletePrevious (@expr10203 ) ;
2506: fullScope@var2416 .@expr1073752050 resize (@expr1073752051 idx@var2418 -@expr1073752052 3 ) ;
2507: } else {
2508: break ; }
2509: }
2510: }
2511:
2512:
2513: if (@expr1073752053 tok1@var2411 .@expr10097 strAt (@expr10098 -1 ) ==@expr1073752056 "::" ) {
2514: removed@var2417 .@expr1073752057 insert (@expr1073752058 0 , ":: " ) ;
2515: tok1@var2411 .@expr10202 deletePrevious (@expr10203 ) ;
2516: }
2517:
2518: Token * arrayStart@var2419 ; arrayStart@var2419 =@expr1073752061 nullptr ;
2519:
2520:
2521: Token * type@var2420 ; type@var2420 =@expr1073752062 start@var2391 ;
2522: if (@expr1073752063 type@var2420 .@expr10240 str (@expr10241 ) ==@expr10242 "::" ) {
2523: type@var2420 =@expr1073752067 type@var2420 .@expr10244 next (@expr10245 ) ;
2524: while (@expr10246 Token ::@expr9809 Match (@expr10248 type@var2420 , "%type% ::" ) ) {
2525: type@var2420 =@expr1073752073 type@var2420 .@expr10250 tokAt (@expr10251 2 ) ; }
2526: if (@expr10252 Token ::@expr9809 Match (@expr10254 type@var2420 , "%type%" ) ) {
2527: type@var2420 =@expr1073752079 type@var2420 .@expr10244 next (@expr10245 ) ; }
2528: } else { if (@expr1073752082 Token ::@expr9809 Match (@expr10248 type@var2420 , "%type% ::" ) ) {
2529: do {
2530: type@var2420 =@expr1073752085 type@var2420 .@expr10250 tokAt (@expr10251 2 ) ;
2531: } while (@expr10246 Token ::@expr9809 Match (@expr10248 type@var2420 , "%type% ::" ) ) ;
2532: if (@expr10252 Token ::@expr9809 Match (@expr10254 type@var2420 , "%type%" ) ) {
2533: type@var2420 =@expr1073752094 type@var2420 .@expr10244 next (@expr10245 ) ; }
2534: } else { if (@expr10252 Token ::@expr9809 Match (@expr10254 type@var2420 , "%type%" ) ) {
2535: while (@expr1073752100 Token ::@expr9809 Match (@expr1073752102 type@var2420 , "const|class|struct|union|enum %type%" ) ||@expr1073752103
2536: (@expr1073752104 type@var2420 .@expr10244 next (@expr10245 ) &&@expr1073752107 type@var2420 .@expr10244 next (@expr10245 ) .@expr1073752110 isStandardType (@expr1073752111 ) ) ) {
2537: type@var2420 =@expr1073752112 type@var2420 .@expr10244 next (@expr10245 ) ; }
2538:
2539: type@var2420 =@expr1073752115 type@var2420 .@expr10244 next (@expr10245 ) ;
2540:
2541: while (@expr1073752118 Token ::@expr9809 Match (@expr10254 type@var2420 , "%type%" ) &&@expr1073752121
2542: (@expr1073752122 type@var2420 .@expr1073752123 isStandardType (@expr1073752124 ) ||@expr1073752125 Token ::@expr9809 Match (@expr1073752127 type@var2420 , "unsigned|signed" ) ) ) {
2543: type@var2420 =@expr1073752128 type@var2420 .@expr10244 next (@expr10245 ) ;
2544: }
2545:
2546: bool atEnd@var2421 ; atEnd@var2421 =@expr1073752131 false ;
2547: while (@expr1073752132 !@expr1073752133 atEnd@var2421 ) {
2548: if (@expr1073752134 type@var2420 &&@expr1073752135 type@var2420 .@expr10240 str (@expr10241 ) ==@expr10242 "::" ) {
2549: type@var2420 =@expr1073752139 type@var2420 .@expr10244 next (@expr10245 ) ;
2550: }
2551:
2552: if (@expr1073752142 Token ::@expr9809 Match (@expr10254 type@var2420 , "%type%" ) &&@expr1073752145
2553: type@var2420 .@expr10244 next (@expr10245 ) &&@expr1073752148 !@expr1073752149 Token ::@expr9809 Match (@expr1073752151 type@var2420 .@expr10244 next (@expr10245 ) , "[|,|(" ) ) {
2554: type@var2420 =@expr1073752154 type@var2420 .@expr10244 next (@expr10245 ) ;
2555: } else { if (@expr1073752157 Token ::@expr9828 simpleMatch (@expr1073752159 type@var2420 , "const (" ) ) {
2556: type@var2420 =@expr1073752160 type@var2420 .@expr10244 next (@expr10245 ) ;
2557: atEnd@var2421 =@expr1073752163 true ;
2558: } else {
2559: atEnd@var2421 =@expr1073752164 true ; } }
2560: }
2561: } else {
2562: syntaxError (@expr10341 type@var2420 ) ; } } }
2563:
2564:
2565: if (@expr10342 !@expr10343 type@var2420 ) {
2566: syntaxError (@expr10344 tok1@var2411 ) ; }
2567:
2568:
2569: if (@expr1073752169 type@var2420 .@expr10240 str (@expr10241 ) ==@expr1073752172 "<" ) {
2570: type@var2420 =@expr1073752173 type@var2420 .@expr1073752174 findClosingBracket (@expr1073752175 ) ;
2571:
2572: while (@expr1073752176 type@var2420 &&@expr1073752177 Token ::@expr9809 Match (@expr1073752179 type@var2420 .@expr10244 next (@expr10245 ) , ":: %type%" ) ) {
2573: type@var2420 =@expr1073752182 type@var2420 .@expr10250 tokAt (@expr10251 2 ) ; }
2574:
2575: if (@expr10342 !@expr10343 type@var2420 ) {
2576: syntaxError (@expr10344 tok1@var2411 ) ;
2577: }
2578:
2579: while (@expr1073752188 Token ::@expr9809 Match (@expr1073752190 type@var2420 .@expr10244 next (@expr10245 ) , "const|volatile" ) ) {
2580: type@var2420 =@expr1073752193 type@var2420 .@expr10244 next (@expr10245 ) ; }
2581:
2582: type@var2420 =@expr1073752196 type@var2420 .@expr10244 next (@expr10245 ) ;
2583: }
2584:
2585:
2586: std ::@expr1073752199 list < std ::@expr10206 string > pointers@var2422 ;
2587: while (@expr1073752201 Token ::@expr9809 Match (@expr1073752203 type@var2420 , "*|&|&&|const" ) ) {
2588: pointers@var2422 .@expr1073752204 push_back (@expr1073752205 type@var2420 .@expr10240 str (@expr10241 ) ) ;
2589: type@var2420 =@expr1073752208 type@var2420 .@expr10244 next (@expr10245 ) ;
2590: }
2591:
2592:
2593: if (@expr1073752211 type@var2420 &&@expr10388 type@var2420 .@expr10240 str (@expr10241 ) ==@expr10391 "[" ) {
2594: do {
2595: if (@expr1073752216 !@expr1073752217 arrayStart@var2419 ) {
2596: arrayStart@var2419 =@expr1073752218 type@var2420 ; }
2597:
2598: bool atEnd@var2423 ; atEnd@var2423 =@expr1073752219 false ;
2599: while (@expr1073752220 !@expr1073752221 atEnd@var2423 ) {
2600: while (@expr1073752222 type@var2420 .@expr10244 next (@expr10245 ) &&@expr1073752225 !@expr1073752226 Token ::@expr9809 Match (@expr1073752228 type@var2420 .@expr10244 next (@expr10245 ) , ";|," ) ) {
2601: type@var2420 =@expr1073752231 type@var2420 .@expr10244 next (@expr10245 ) ;
2602: }
2603:
2604: if (@expr1073752234 !@expr1073752235 type@var2420 .@expr10244 next (@expr10245 ) ) {
2605: syntaxError (@expr10341 type@var2420 ) ; }
2606: else { if (@expr1073752239 type@var2420 .@expr10244 next (@expr10245 ) .@expr1073752242 str (@expr1073752243 ) ==@expr1073752244 ";" ) {
2607: atEnd@var2423 =@expr1073752245 true ; }
2608: else { if (@expr1073752246 type@var2420 .@expr10240 str (@expr10241 ) ==@expr1073752249 "]" ) {
2609: atEnd@var2423 =@expr1073752250 true ; }
2610: else {
2611: type@var2420 =@expr1073752251 type@var2420 .@expr10244 next (@expr10245 ) ; } } }
2612: }
2613:
2614: type@var2420 =@expr1073752254 type@var2420 .@expr10244 next (@expr10245 ) ;
2615: } while (@expr1073752257 type@var2420 &&@expr10388 type@var2420 .@expr10240 str (@expr10241 ) ==@expr10391 "[" ) ;
2616: }
2617:
2618:
2619: if (@expr1073752262 !@expr1073752263 tok1@var2411 ||@expr1073752264 !@expr1073752265 tok1@var2411 .@expr10083 next (@expr10084 ) ) {
2620: break ; }
2621:
2622: Token * after@var2424 ; after@var2424 =@expr1073752268 tok1@var2411 .@expr10083 next (@expr10084 ) ;
2623:
2624: if (@expr1073752271 type@var2420 &&@expr1073752272 type@var2420 ==@expr1073752273 usingEnd@var2392 ) {
2625:
2626: if (@expr1073752274 arrayStart@var2419 ) {
2627: if (@expr1073752275 Token ::@expr9809 Match (@expr1073752277 tok1@var2411 .@expr10083 next (@expr10084 ) , "%name%" ) ) {
2628: TokenList ::@expr9965 copyTokens (@expr1073752281 tok1@var2411 .@expr10083 next (@expr10084 ) , arrayStart@var2419 , usingEnd@var2392 .@expr10460 previous (@expr10461 ) ) ;
2629: TokenList ::@expr9965 copyTokens (@expr1073752287 tok1@var2411 , start@var2391 , arrayStart@var2419 .@expr1073752288 previous (@expr1073752289 ) ) ;
2630: tok1@var2411 .@expr10466 deleteThis (@expr10467 ) ;
2631: substitute@var2373 =@expr1073752292 true ;
2632: }
2633: } else {
2634:
2635: std ::@expr1073752293 string removed1@var2425 ; removed1@var2425 =@expr1073752294 removed@var2417 ;
2636: std ::@expr10213 string ::@expr1073752296 size_type idx@var2426 ; idx@var2426 =@expr1073752297 removed1@var2425 .@expr10474 rfind (@expr10475 " ::" ) ;
2637: if (@expr1073752300 idx@var2426 !=@expr1073752301 std ::@expr10213 string ::@expr10214 npos@expr9766 ) {
2638: removed1@var2425 .@expr10480 resize (@expr10481 idx@var2426 ) ; }
2639: if (@expr1073752306 scopesMatch (@expr1073752307 removed1@var2425 , scope@var2388 , &@expr10029 scopeInfo1@var2397 ) ) {
2640: ScopeInfo3 * tempScope@var2427 ; tempScope@var2427 =@expr1073752309 currentScope@var2375 ;
2641: while (@expr1073752310 tempScope@var2427 .@expr10487 parent@var2428 ) {
2642: if (@expr1073752312 tempScope@var2427 .@expr10489 recordTypes@var2429 .@expr1073752314 find (@expr1073752315 start@var2391 .@expr10009 str (@expr10010 ) ) !=@expr1073752318 tempScope@var2427 .@expr10489 recordTypes@var2429 .@expr1073752320 end (@expr1073752321 ) ) {
2643: std ::@expr10213 string ::@expr1073752323 size_type spaceIdx@var2430 ; spaceIdx@var2430 =@expr1073752324 0 ;
2644: std ::@expr10213 string ::@expr1073752326 size_type startIdx@var2431 ; startIdx@var2431 =@expr1073752327 0 ;
2645: while (@expr1073752328 (@expr1073752329 spaceIdx@var2430 =@expr1073752330 removed1@var2425 .@expr1073752331 find (@expr1073752332 " " , startIdx@var2431 ) ) !=@expr1073752333 std ::@expr10213 string ::@expr10214 npos@expr9766 ) {
2646: tok1@var2411 .@expr10512 previous (@expr10513 ) .@expr10514 insertToken (@expr1073752339 removed1@var2425 .@expr10516 substr (@expr1073752341 startIdx@var2431 , spaceIdx@var2430 -@expr1073752342 startIdx@var2431 ) ) ;
2647: startIdx@var2431 =@expr1073752343 spaceIdx@var2430 +@expr1073752344 1 ;
2648: }
2649: tok1@var2411 .@expr10512 previous (@expr10513 ) .@expr10514 insertToken (@expr1073752348 removed1@var2425 .@expr10516 substr (@expr1073752350 startIdx@var2431 ) ) ;
2650: tok1@var2411 .@expr10512 previous (@expr10513 ) .@expr10514 insertToken (@expr1073752354 "::" ) ;
2651: break ;
2652: }
2653: idx@var2426 =@expr1073752355 removed1@var2425 .@expr10474 rfind (@expr10475 " ::" ) ;
2654: if (@expr1073752358 idx@var2426 ==@expr1073752359 std ::@expr10213 string ::@expr10214 npos@expr9766 ) {
2655: break ; }
2656:
2657: removed1@var2425 .@expr10480 resize (@expr10481 idx@var2426 ) ;
2658: tempScope@var2427 =@expr1073752364 tempScope@var2427 .@expr10487 parent@var2428 ;
2659: }
2660: }
2661:
2662:
2663: TokenList ::@expr9965 copyTokens (@expr1073752367 tok1@var2411 , start@var2391 , usingEnd@var2392 .@expr10460 previous (@expr10461 ) ) ;
2664: tok1@var2411 .@expr10466 deleteThis (@expr10467 ) ;
2665: substitute@var2373 =@expr1073752372 true ;
2666: }
2667: } else {
2668: skip@var2409 =@expr1073752373 true ;
2669: if (@expr1073752374 mSettings@var879 .@expr9841 debugwarnings@var3566 &&@expr1073752376 mErrorLogger@var880 ) {
2670: std ::@expr1073752377 string str@var2432 ;
2671: for (@expr1073752378 Token *@expr9784 tok3@var2433 =@expr1073752380 usingStart@var2390 ; tok3@var2433 &&@expr1073752381 tok3@var2433 !=@expr1073752382 usingEnd@var2392 ; tok3@var2433 =@expr1073752383 tok3@var2433 .@expr1073752384 next (@expr1073752385 ) ) {
2672: if (@expr1073752386 !@expr1073752387 str@var2432 .@expr1073752388 empty (@expr1073752389 ) ) {
2673: str@var2432 +=@expr1073752390 ' ' ; }
2674: str@var2432 +=@expr1073752391 tok3@var2433 .@expr1073752392 str (@expr1073752393 ) ;
2675: }
2676: str@var2432 +=@expr1073752394 " ;" ;
2677: std ::@expr1073752395 list < const Token *@expr9784 > callstack@var2434 (@expr1073752397 1 , usingStart@var2390 ) ;
2678: mErrorLogger@var880 .@expr1073752398 reportErr (@expr1073752399 ErrorMessage (@expr1073752400 callstack@var2434 , &@expr1073752401 list@var872 , Severity ::@expr9846 debug , "simplifyUsing" ,
2679: "Failed to parse \'" +@expr1073752403 str@var2432 +@expr1073752404 "\'. The checking continues anyway." , Certainty ::@expr1073752405 normal ) ) ;
2680: }
2681: }
2682: tok1@var2411 =@expr1073752406 after@var2424 ;
2683: }
2684:
2685: if (@expr1073752407 !@expr10078 skip@var2409 ) {
2686: usingList@var2380 .@expr1073752409 emplace_back (@expr1073752410 usingStart@var2390 , usingEnd@var2392 ) ; }
2687: }
2688:
2689:
2690: for (@expr1073752411 std ::@expr10206 list < Using > ::@expr10206 reverse_iterator it@var2435 =@expr1073752414 usingList@var2380 .@expr1073752415 rbegin (@expr1073752416 ) ; it@var2435 !=@expr1073752417 usingList@var2380 .@expr1073752418 rend (@expr1073752419 ) ; ++@expr1073752420 it@var2435 ) {
2691: Token * usingStart@var2436 ; usingStart@var2436 =@expr1073752421 it@var2435 .@expr1073752422 startTok@var2437 ;
2692: Token * usingEnd@var2438 ; usingEnd@var2438 =@expr1073752423 it@var2435 .@expr1073752424 endTok@var2439 ;
2693: if (@expr1073752425 usingStart@var2436 .@expr10602 previous (@expr10603 ) ) {
2694: if (@expr10604 usingEnd@var2438 .@expr10605 next (@expr10606 ) ) {
2695: Token ::@expr10607 eraseTokens (@expr1073752432 usingStart@var2436 .@expr10602 previous (@expr10603 ) , usingEnd@var2438 .@expr10605 next (@expr10606 ) ) ; }
2696: else {
2697: Token ::@expr10607 eraseTokens (@expr1073752438 usingStart@var2436 .@expr10602 previous (@expr10603 ) , usingEnd@var2438 ) ;
2698: usingEnd@var2438 .@expr1073752441 deleteThis (@expr1073752442 ) ;
2699: }
2700: } else {
2701: if (@expr10604 usingEnd@var2438 .@expr10605 next (@expr10606 ) ) {
2702: Token ::@expr10607 eraseTokens (@expr1073752447 usingStart@var2436 , usingEnd@var2438 .@expr10605 next (@expr10606 ) ) ;
2703: usingStart@var2436 .@expr10626 deleteThis (@expr10627 ) ;
2704: } else {
2705:
2706: Token ::@expr10607 eraseTokens (@expr1073752453 usingStart@var2436 , usingEnd@var2438 ) ;
2707: usingStart@var2436 .@expr10626 deleteThis (@expr10627 ) ;
2708: }
2709: }
2710: }
2711:
2712: return substitute@var2373 ;
2713: }
2714:
2715: bool Tokenizer :: createTokens ( std :: istream & code@var2440 ,
2716: const std :: string & FileName@var2441 )
2717: {
2718:
2719: assert (@expr1073752456 mSettings@var879 ) ;
2720:
2721: return list@var872 .@expr1073752457 createTokens (@expr1073752458 code@var2440 , FileName@var2441 ) ;
2722: }
2723:
2724: void Tokenizer :: createTokens ( simplecpp :: TokenList && tokenList@var2442 )
2725: {
2726:
2727: assert (@expr1073752459 mSettings@var879 ) ;
2728: list@var872 .@expr1073752460 createTokens (@expr1073752461 std ::@expr1073752462 move (@expr1073752463 tokenList@var2442 ) ) ;
2729: }
2730:
2731: bool Tokenizer :: simplifyTokens1 ( const std :: string & configuration@var2443 )
2732: {
2733:
2734: fillTypeSizes (@expr1073752464 ) ;
2735:
2736: mConfiguration@var883 =@expr1073752465 configuration@var2443 ;
2737:
2738: if (@expr1073752466 !@expr1073752467 simplifyTokenList1 (@expr1073752468 list@var872 .@expr1073752469 getFiles (@expr1073752470 ) .@expr1073752471 front (@expr1073752472 ) .@expr1073752473 c_str (@expr1073752474 ) ) ) {
2739: return false ; }
2740:
2741: if (@expr10651 mTimerResults@var894 ) {
2742: Timer t@var2444 (@expr1073752476 "Tokenizer::simplifyTokens1::createAst" , mSettings@var879 .@expr10653 showtime@var3569 , mTimerResults@var894 ) ;
2743: list@var872 .@expr10654 createAst (@expr10655 ) ;
2744: list@var872 .@expr10656 validateAst (@expr10657 ) ;
2745: } else {
2746: list@var872 .@expr10654 createAst (@expr10655 ) ;
2747: list@var872 .@expr10656 validateAst (@expr10657 ) ;
2748: }
2749:
2750: if (@expr10651 mTimerResults@var894 ) {
2751: Timer t@var2445 (@expr1073752487 "Tokenizer::simplifyTokens1::createSymbolDatabase" , mSettings@var879 .@expr10653 showtime@var3569 , mTimerResults@var894 ) ;
2752: createSymbolDatabase (@expr10665 ) ;
2753: } else {
2754: createSymbolDatabase (@expr10665 ) ;
2755: }
2756:
2757: if (@expr10651 mTimerResults@var894 ) {
2758: Timer t@var2446 (@expr1073752492 "Tokenizer::simplifyTokens1::setValueType" , mSettings@var879 .@expr10653 showtime@var3569 , mTimerResults@var894 ) ;
2759: mSymbolDatabase@var881 .@expr10670 setValueTypeInTokenList (@expr10671 true ) ;
2760: } else {
2761: mSymbolDatabase@var881 .@expr10670 setValueTypeInTokenList (@expr10671 true ) ;
2762: }
2763:
2764: if (@expr1073752498 !@expr1073752499 mSettings@var879 .@expr1073752500 buildDir@var3570 .@expr1073752501 empty (@expr1073752502 ) ) {
2765: Summaries ::@expr1073752503 create (@expr1073752504 this@expr1073752505 , configuration@var2443 ) ; }
2766:
2767:
2768: const char * disableValueflowEnv@var2447 ; disableValueflowEnv@var2447 =@expr1073752506 std ::@expr1073752507 getenv (@expr1073752508 "DISABLE_VALUEFLOW" ) ;
2769: const bool doValueFlow@var2448 =@expr1073752509 !@expr1073752510 disableValueflowEnv@var2447 ||@expr1073752511 (@expr1073752512 std ::@expr1073752513 strcmp (@expr1073752514 disableValueflowEnv@var2447 , "1" ) !=@expr1073752515 0 ) ;
2770:
2771: if (@expr10692 doValueFlow@var2448 ) {
2772: if (@expr10651 mTimerResults@var894 ) {
2773: Timer t@var2449 (@expr1073752518 "Tokenizer::simplifyTokens1::ValueFlow" , mSettings@var879 .@expr10653 showtime@var3569 , mTimerResults@var894 ) ;
2774: ValueFlow ::@expr10696 setValues (@expr10697 &@expr10698 list@var872 , mSymbolDatabase@var881 , mErrorLogger@var880 , mSettings@var879 ) ;
2775: } else {
2776: ValueFlow ::@expr10696 setValues (@expr10697 &@expr10698 list@var872 , mSymbolDatabase@var881 , mErrorLogger@var880 , mSettings@var879 ) ;
2777: }
2778: }
2779:
2780:
2781: if (@expr1073752526 mSettings@var879 .@expr1073752527 severity@var3571 .@expr1073752528 isEnabled (@expr1073752529 Severity ::@expr1073752530 portability ) ) {
2782: for (@expr1073752531 const Token *@expr1073752532 tok@var2450 =@expr1073752533 tokens (@expr1073752534 ) ; tok@var2450 ; tok@var2450 =@expr1073752535 tok@var2450 .@expr1073752536 next (@expr1073752537 ) ) {
2783: if (@expr1073752538 tok@var2450 .@expr1073752539 tokType (@expr1073752540 ) ==@expr1073752541 Token ::@expr1073752542 eChar &&@expr1073752543 tok@var2450 .@expr1073752544 values (@expr1073752545 ) .@expr1073752546 empty (@expr1073752547 ) ) {
2784: try {
2785: simplecpp ::@expr1073752548 characterLiteralToLL (@expr1073752549 tok@var2450 .@expr1073752550 str (@expr1073752551 ) ) ;
2786: } catch (@expr1073752552 const std ::@expr1073752553 exception & e@var2451 ) {
2787: unhandledCharLiteral (@expr1073752554 tok@var2450 , e@var2451 .@expr1073752555 what (@expr1073752556 ) ) ;
2788: }
2789: }
2790: }
2791: }
2792:
2793: if (@expr10692 doValueFlow@var2448 ) {
2794: mSymbolDatabase@var881 .@expr1073752558 setArrayDimensionsUsingValueFlow (@expr1073752559 ) ;
2795: }
2796:
2797: printDebugOutput (@expr1073752560 1 ) ;
2798:
2799: return true ;
2800: }
2801:
2802: bool Tokenizer :: tokenize ( std :: istream & code@var2452 ,
2803: const char FileName@var2453 [ ] ,
2804: const std :: string & configuration@var2454 )
2805: {
2806: if (@expr1073752561 !@expr1073752562 createTokens (@expr1073752563 code@var2452 , FileName@var2453 ) ) {
2807: return false ; }
2808:
2809: return simplifyTokens1 (@expr1073752564 configuration@var2454 ) ;
2810: }
2811:
2812:
2813: void Tokenizer :: findComplicatedSyntaxErrorsInTemplates ( )
2814: {
2815: validate (@expr1073752565 ) ;
2816: mTemplateSimplifier@var882 .@expr1073752566 checkComplicatedSyntaxErrorsInTemplates (@expr1073752567 ) ;
2817: }
2818:
2819: void Tokenizer :: checkForEnumsWithTypedef ( )
2820: {
2821: for (@expr1073752568 const Token *@expr1073752569 tok@var2455 =@expr1073752570 list@var872 .@expr1073752571 front (@expr1073752572 ) ; tok@var2455 ; tok@var2455 =@expr1073752573 tok@var2455 .@expr1073752574 next (@expr1073752575 ) ) {
2822: if (@expr1073752576 Token ::@expr1073752577 Match (@expr1073752578 tok@var2455 , "enum %name% {" ) ) {
2823: tok@var2455 =@expr1073752579 tok@var2455 .@expr1073752580 tokAt (@expr1073752581 2 ) ;
2824: const Token * tok2@var2456 ; tok2@var2456 =@expr1073752582 Token ::@expr1073752583 findsimplematch (@expr1073752584 tok@var2455 , "typedef" , tok@var2455 .@expr10761 link (@expr10762 ) ) ;
2825: if (@expr1073752587 tok2@var2456 ) {
2826: syntaxError (@expr1073752588 tok2@var2456 ) ; }
2827: tok@var2455 =@expr1073752589 tok@var2455 .@expr10761 link (@expr10762 ) ;
2828: }
2829: }
2830: }
2831:
2832: void Tokenizer :: fillTypeSizes ( )
2833: {
2834: mTypeSize@var884 .@expr1073752592 clear (@expr1073752593 ) ;
2835: mTypeSize@var884 [@expr1073752594 "char" ] =@expr1073752595 1 ;
2836: mTypeSize@var884 [@expr1073752596 "_Bool" ] =@expr1073752597 mSettings@var879 .@expr10774 sizeof_bool@var3572 ;
2837: mTypeSize@var884 [@expr1073752599 "bool" ] =@expr1073752600 mSettings@var879 .@expr10774 sizeof_bool@var3572 ;
2838: mTypeSize@var884 [@expr1073752602 "short" ] =@expr1073752603 mSettings@var879 .@expr1073752604 sizeof_short@var3573 ;
2839: mTypeSize@var884 [@expr1073752605 "int" ] =@expr1073752606 mSettings@var879 .@expr1073752607 sizeof_int@var3574 ;
2840: mTypeSize@var884 [@expr1073752608 "long" ] =@expr1073752609 mSettings@var879 .@expr1073752610 sizeof_long@var3575 ;
2841: mTypeSize@var884 [@expr1073752611 "float" ] =@expr1073752612 mSettings@var879 .@expr1073752613 sizeof_float@var3576 ;
2842: mTypeSize@var884 [@expr1073752614 "double" ] =@expr1073752615 mSettings@var879 .@expr1073752616 sizeof_double@var3577 ;
2843: mTypeSize@var884 [@expr1073752617 "wchar_t" ] =@expr1073752618 mSettings@var879 .@expr1073752619 sizeof_wchar_t@var3578 ;
2844: mTypeSize@var884 [@expr1073752620 "size_t" ] =@expr1073752621 mSettings@var879 .@expr1073752622 sizeof_size_t@var3579 ;
2845: mTypeSize@var884 [@expr1073752623 "*" ] =@expr1073752624 mSettings@var879 .@expr1073752625 sizeof_pointer@var3580 ;
2846: }
2847:
2848: void Tokenizer :: combineOperators ( )
2849: {
2850: const bool cpp@var2457 =@expr1073752626 isCPP (@expr1073752627 ) ;
2851:
2852:
2853: for (@expr1073752628 Token *@expr10805 tok@var2458 =@expr1073752630 list@var872 .@expr1073752631 front (@expr1073752632 ) ; tok@var2458 &&@expr1073752633 tok@var2458 .@expr10810 next (@expr10811 ) ; tok@var2458 =@expr1073752636 tok@var2458 .@expr10810 next (@expr10811 ) ) {
2854: const char c1@var2459 =@expr1073752639 tok@var2458 .@expr10816 str (@expr10817 ) [@expr1073752642 0 ] ;
2855:
2856: if (@expr1073752643 tok@var2458 .@expr10816 str (@expr10817 ) .@expr1073752646 length (@expr1073752647 ) ==@expr1073752648 1 &&@expr1073752649 tok@var2458 .@expr10810 next (@expr10811 ) .@expr10828 str (@expr10829 ) .@expr1073752654 length (@expr1073752655 ) ==@expr1073752656 1 ) {
2857: const char c2@var2460 =@expr1073752657 tok@var2458 .@expr10810 next (@expr10811 ) .@expr10828 str (@expr10829 ) [@expr1073752662 0 ] ;
2858:
2859:
2860: if (@expr1073752663 c2@var2460 ==@expr1073752664 '=' &&@expr1073752665 (@expr1073752666 std ::@expr1073752667 strchr (@expr1073752668 "+-*/%|^=!<>" , c1@var2459 ) ) &&@expr1073752669 !@expr1073752670 Token ::@expr10847 Match (@expr1073752672 tok@var2458 .@expr10849 previous (@expr10850 ) , "%type% *" ) ) {
2861:
2862: if (@expr1073752675 cpp@var2457 &&@expr1073752676 (@expr1073752677 tok@var2458 .@expr10816 str (@expr10817 ) ==@expr10856 ">" ||@expr1073752681 Token ::@expr10858 simpleMatch (@expr1073752683 tok@var2458 .@expr10849 previous (@expr10850 ) , "> *" ) ) ) {
2863: const Token * opening@var2461 ; opening@var2461 =@expr1073752686
2864: tok@var2458 .@expr10816 str (@expr10817 ) ==@expr10856 ">" ?@expr1073752690 tok@var2458 .@expr1073752691 findOpeningBracket (@expr1073752692 ) :@expr1073752693 tok@var2458 .@expr10849 previous (@expr10850 ) .@expr1073752696 findOpeningBracket (@expr1073752697 ) ;
2865: if (@expr1073752698 opening@var2461 &&@expr1073752699 Token ::@expr10847 Match (@expr1073752701 opening@var2461 .@expr1073752702 previous (@expr1073752703 ) , "%name%" ) ) {
2866: continue ; }
2867: }
2868: tok@var2458 .@expr10816 str (@expr1073752705 tok@var2458 .@expr10816 str (@expr10817 ) +@expr1073752708 c2@var2460 ) ;
2869: tok@var2458 .@expr10885 deleteNext (@expr10886 ) ;
2870: continue ;
2871: }
2872: } else { if (@expr1073752711 tok@var2458 .@expr10810 next (@expr10811 ) .@expr10828 str (@expr10829 ) ==@expr1073752716 "=" ) {
2873: if (@expr1073752717 tok@var2458 .@expr10816 str (@expr10817 ) ==@expr1073752720 ">>" ) {
2874: tok@var2458 .@expr10816 str (@expr1073752722 ">>=" ) ;
2875: tok@var2458 .@expr10885 deleteNext (@expr10886 ) ;
2876: } else { if (@expr1073752725 tok@var2458 .@expr10816 str (@expr10817 ) ==@expr1073752728 "<<" ) {
2877: tok@var2458 .@expr10816 str (@expr1073752730 "<<=" ) ;
2878: tok@var2458 .@expr10885 deleteNext (@expr10886 ) ;
2879: } }
2880: } else { if (@expr1073752733 cpp@var2457 &&@expr1073752734 (@expr1073752735 c1@var2459 ==@expr1073752736 'p' ||@expr1073752737 c1@var2459 ==@expr1073752738 '_' ) &&@expr1073752739
2881: Token ::@expr10847 Match (@expr1073752741 tok@var2458 , "private|protected|public|__published : !!:" ) ) {
2882: bool simplify@var2462 ; simplify@var2462 =@expr1073752742 false ;
2883: int par@var2463 ; par@var2463 =@expr1073752743 0 ;
2884: for (@expr1073752744 const Token *@expr10805 prev@var2464 =@expr1073752746 tok@var2458 .@expr10849 previous (@expr10850 ) ; prev@var2464 ; prev@var2464 =@expr1073752749 prev@var2464 .@expr1073752750 previous (@expr1073752751 ) ) {
2885: if (@expr1073752752 prev@var2464 .@expr10929 str (@expr10930 ) ==@expr1073752755 ")" ) {
2886: ++@expr1073752756 par@var2463 ;
2887: } else { if (@expr1073752757 prev@var2464 .@expr10929 str (@expr10930 ) ==@expr10936 "(" ) {
2888: if (@expr1073752761 par@var2463 ==@expr1073752762 0U ) {
2889: break ; }
2890: --@expr1073752763 par@var2463 ;
2891: } }
2892: if (@expr1073752764 par@var2463 !=@expr1073752765 0U ||@expr1073752766 prev@var2464 .@expr10929 str (@expr10930 ) ==@expr10936 "(" ) {
2893: continue ; }
2894: if (@expr1073752770 Token ::@expr10847 Match (@expr1073752772 prev@var2464 , "[;{}]" ) ) {
2895: simplify@var2462 =@expr1073752773 true ;
2896: break ;
2897: }
2898: if (@expr1073752774 prev@var2464 .@expr10951 isName (@expr10952 ) &&@expr1073752777 prev@var2464 .@expr1073752778 isUpperCaseName (@expr1073752779 ) ) {
2899: continue ; }
2900: if (@expr1073752780 prev@var2464 .@expr10951 isName (@expr10952 ) &&@expr1073752783 endsWith (@expr1073752784 prev@var2464 .@expr10929 str (@expr10930 ) , ':' ) ) {
2901: simplify@var2462 =@expr1073752787 true ; }
2902: break ;
2903: }
2904: if (@expr1073752788 simplify@var2462 ) {
2905: tok@var2458 .@expr10816 str (@expr1073752790 tok@var2458 .@expr10816 str (@expr10817 ) +@expr1073752793 ":" ) ;
2906: tok@var2458 .@expr10885 deleteNext (@expr10886 ) ;
2907: }
2908: } else { if (@expr1073752796 tok@var2458 .@expr10816 str (@expr10817 ) ==@expr1073752799 "->" ) {
2909:
2910: Token * t@var2465 ; t@var2465 =@expr1073752800 tok@var2458 .@expr1073752801 tokAt (@expr1073752802 -4 ) ;
2911: if (@expr1073752803 Token ::@expr10847 Match (@expr1073752805 t@var2465 , "( & %name% )" ) &&@expr1073752806 !@expr1073752807 Token ::@expr10858 simpleMatch (@expr1073752809 t@var2465 .@expr1073752810 previous (@expr1073752811 ) , ">" ) ) {
2912: t@var2465 .@expr10988 deleteThis (@expr10989 ) ;
2913: t@var2465 .@expr10988 deleteThis (@expr10989 ) ;
2914: t@var2465 .@expr1073752816 deleteNext (@expr1073752817 ) ;
2915: tok@var2458 .@expr10816 str (@expr10995 "." ) ;
2916: } else {
2917: tok@var2458 .@expr10816 str (@expr10995 "." ) ;
2918: tok@var2458 .@expr1073752822 originalName (@expr1073752823 "->" ) ;
2919: }
2920: } } } }
2921: }
2922: }
2923:
2924: void Tokenizer :: combineStringAndCharLiterals ( )
2925: {
2926:
2927: for (@expr1073752824 Token *@expr1073752825 tok@var2466 =@expr1073752826 list@var872 .@expr1073752827 front (@expr1073752828 ) ; tok@var2466 ; tok@var2466 =@expr1073752829 tok@var2466 .@expr11006 next (@expr11007 ) ) {
2928: if (@expr1073752832 !@expr1073752833 isStringLiteral (@expr1073752834 tok@var2466 .@expr11011 str (@expr11012 ) ) ) {
2929: continue ; }
2930:
2931: tok@var2466 .@expr11011 str (@expr1073752838 simplifyString (@expr1073752839 tok@var2466 .@expr11011 str (@expr11012 ) ) ) ;
2932:
2933: while (@expr1073752842 Token ::@expr11019 Match (@expr1073752844 tok@var2466 .@expr11006 next (@expr11007 ) , "%str%" ) ||@expr1073752847 Token ::@expr11019 Match (@expr1073752849 tok@var2466 .@expr11006 next (@expr11007 ) , "_T|_TEXT|TEXT ( %str% )" ) ) {
2934: if (@expr1073752852 tok@var2466 .@expr11006 next (@expr11007 ) .@expr1073752855 isName (@expr1073752856 ) ) {
2935: if (@expr1073752857 !@expr1073752858 mSettings@var879 .@expr1073752859 isWindowsPlatform (@expr1073752860 ) ) {
2936: break ; }
2937: tok@var2466 .@expr11037 deleteNext (@expr1073752862 2 ) ;
2938: tok@var2466 .@expr11006 next (@expr11007 ) .@expr1073752865 deleteNext (@expr1073752866 ) ;
2939: }
2940:
2941: tok@var2466 .@expr1073752867 concatStr (@expr1073752868 simplifyString (@expr1073752869 tok@var2466 .@expr11006 next (@expr11007 ) .@expr1073752872 str (@expr1073752873 ) ) ) ;
2942: tok@var2466 .@expr11037 deleteNext (@expr1073752875 ) ;
2943: }
2944: }
2945: }
2946:
2947: void Tokenizer :: concatenateNegativeNumberAndAnyPositive ( )
2948: {
2949: for (@expr1073752876 Token *@expr1073752877 tok@var2467 =@expr1073752878 list@var872 .@expr1073752879 front (@expr1073752880 ) ; tok@var2467 ; tok@var2467 =@expr1073752881 tok@var2467 .@expr11058 next (@expr11059 ) ) {
2950: if (@expr1073752884 !@expr1073752885 Token ::@expr11062 Match (@expr1073752887 tok@var2467 , "?|:|,|(|[|{|return|case|sizeof|%op% +|-" ) ||@expr1073752888 tok@var2467 .@expr1073752889 tokType (@expr1073752890 ) ==@expr1073752891 Token ::@expr1073752892 eIncDecOp ) {
2951: continue ; }
2952:
2953: while (@expr1073752893 tok@var2467 .@expr1073752894 str (@expr1073752895 ) !=@expr1073752896 ">" &&@expr1073752897 tok@var2467 .@expr11058 next (@expr11059 ) &&@expr1073752900 tok@var2467 .@expr11058 next (@expr11059 ) .@expr11079 str (@expr11080 ) ==@expr1073752905 "+" &&@expr1073752906 (@expr1073752907 !@expr1073752908 Token ::@expr11062 Match (@expr1073752910 tok@var2467 .@expr1073752911 tokAt (@expr1073752912 2 ) , "%name% (|;" ) ||@expr1073752913 Token ::@expr11062 Match (@expr1073752915 tok@var2467 , "%op%" ) ) ) {
2954: tok@var2467 .@expr11092 deleteNext (@expr11093 ) ; }
2955:
2956: if (@expr1073752918 Token ::@expr11062 Match (@expr1073752920 tok@var2467 .@expr11058 next (@expr11059 ) , "- %num%" ) ) {
2957: tok@var2467 .@expr11092 deleteNext (@expr11093 ) ;
2958: tok@var2467 .@expr11058 next (@expr11059 ) .@expr11079 str (@expr1073752928 "-" +@expr1073752929 tok@var2467 .@expr11058 next (@expr11059 ) .@expr11079 str (@expr11080 ) ) ;
2959: }
2960: }
2961: }
2962:
2963: void Tokenizer :: simplifyExternC ( )
2964: {
2965: if (@expr1073752934 isC (@expr1073752935 ) ) {
2966: return ; }
2967:
2968:
2969: for (@expr1073752936 Token *@expr1073752937 tok@var2468 =@expr1073752938 list@var872 .@expr1073752939 front (@expr1073752940 ) ; tok@var2468 ; tok@var2468 =@expr1073752941 tok@var2468 .@expr11118 next (@expr11119 ) ) {
2970: if (@expr1073752944 Token ::@expr11121 simpleMatch (@expr1073752946 tok@var2468 , "extern \"C\"" ) ) {
2971: Token * tok2@var2469 ; tok2@var2469 =@expr1073752947 tok@var2468 .@expr11118 next (@expr11119 ) ;
2972: if (@expr1073752950 tok@var2468 .@expr1073752951 strAt (@expr1073752952 2 ) ==@expr1073752953 "{" ) {
2973: tok2@var2469 =@expr1073752954 tok2@var2469 .@expr11131 next (@expr11132 ) ;
2974: while (@expr1073752957 (@expr1073752958 tok2@var2469 =@expr1073752959 tok2@var2469 .@expr11131 next (@expr11132 ) ) &&@expr1073752962 tok2@var2469 !=@expr1073752963 tok@var2468 .@expr11140 linkAt (@expr11141 2 ) ) {
2975: tok2@var2469 .@expr11142 isExternC (@expr11143 true ) ; }
2976: tok@var2468 .@expr11140 linkAt (@expr11141 2 ) .@expr1073752970 deleteThis (@expr1073752971 ) ;
2977: tok@var2468 .@expr11148 deleteNext (@expr1073752973 2 ) ;
2978: } else {
2979: while (@expr1073752974 (@expr1073752975 tok2@var2469 =@expr1073752976 tok2@var2469 .@expr11131 next (@expr11132 ) ) &&@expr1073752979 !@expr1073752980 Token ::@expr11121 simpleMatch (@expr1073752982 tok2@var2469 , ";" ) ) {
2980: tok2@var2469 .@expr11142 isExternC (@expr11143 true ) ; }
2981: tok@var2468 .@expr11148 deleteNext (@expr1073752986 ) ;
2982: }
2983: tok@var2468 .@expr1073752987 deleteThis (@expr1073752988 ) ;
2984: }
2985: }
2986: }
2987:
2988: void Tokenizer :: simplifyRoundCurlyParentheses ( )
2989: {
2990: for (@expr1073752989 Token *@expr1073752990 tok@var2470 =@expr1073752991 list@var872 .@expr1073752992 front (@expr1073752993 ) ; tok@var2470 ; tok@var2470 =@expr1073752994 tok@var2470 .@expr1073752995 next (@expr1073752996 ) ) {
2991: while (@expr1073752997 Token ::@expr11174 Match (@expr1073752999 tok@var2470 , "[;{}:] ( {" ) &&@expr1073753000
2992: Token ::@expr1073753001 simpleMatch (@expr1073753002 tok@var2470 .@expr11179 linkAt (@expr11180 2 ) , "} ) ;" ) ) {
2993: if (@expr1073753005 tok@var2470 .@expr1073753006 str (@expr1073753007 ) ==@expr1073753008 ":" &&@expr1073753009 !@expr1073753010 Token ::@expr11174 Match (@expr1073753012 tok@var2470 .@expr1073753013 tokAt (@expr1073753014 -2 ) , "[;{}] %type% :" ) ) {
2994: break ; }
2995: Token * end@var2471 ; end@var2471 =@expr1073753015 tok@var2470 .@expr11179 linkAt (@expr11180 2 ) .@expr1073753018 tokAt (@expr1073753019 -3 ) ;
2996: if (@expr1073753020 Token ::@expr11174 Match (@expr1073753022 end@var2471 , "[;{}] %num%|%str% ;" ) ) {
2997: end@var2471 .@expr1073753023 deleteNext (@expr1073753024 2 ) ; }
2998: tok@var2470 .@expr11179 linkAt (@expr11180 2 ) .@expr1073753027 previous (@expr1073753028 ) .@expr1073753029 deleteNext (@expr1073753030 3 ) ;
2999: tok@var2470 .@expr11207 deleteNext (@expr1073753032 2 ) ;
3000: }
3001: if (@expr1073753033 Token ::@expr11174 Match (@expr1073753035 tok@var2470 , "( { %bool%|%char%|%num%|%str%|%name% ; } )" ) ) {
3002: tok@var2470 .@expr11207 deleteNext (@expr1073753037 ) ;
3003: tok@var2470 .@expr1073753038 deleteThis (@expr1073753039 ) ;
3004: tok@var2470 .@expr11207 deleteNext (@expr1073753041 3 ) ;
3005: }
3006: }
3007: }
3008:
3009: void Tokenizer :: simplifySQL ( )
3010: {
3011: for (@expr1073753042 Token *@expr1073753043 tok@var2472 =@expr1073753044 list@var872 .@expr1073753045 front (@expr1073753046 ) ; tok@var2472 ; tok@var2472 =@expr1073753047 tok@var2472 .@expr11224 next (@expr11225 ) ) {
3012: if (@expr1073753050 !@expr1073753051 Token ::@expr1073753052 simpleMatch (@expr1073753053 tok@var2472 , "__CPPCHECK_EMBEDDED_SQL_EXEC__ SQL" ) ) {
3013: continue ; }
3014:
3015: const Token * end@var2473 ; end@var2473 =@expr1073753054 findSQLBlockEnd (@expr1073753055 tok@var2472 ) ;
3016: if (@expr1073753056 end@var2473 ==@expr1073753057 nullptr ) {
3017: syntaxError (@expr1073753058 nullptr ) ; }
3018:
3019: const std ::@expr1073753059 string instruction@var2474 =@expr1073753060 tok@var2472 .@expr1073753061 stringifyList (@expr1073753062 end@var2473 ) ;
3020:
3021: Token ::@expr1073753063 eraseTokens (@expr1073753064 tok@var2472 , end@var2473 ) ;
3022:
3023:
3024: tok@var2472 .@expr1073753065 str (@expr1073753066 "asm" ) ;
3025:
3026: if (@expr1073753067 !@expr1073753068 tok@var2472 .@expr11224 next (@expr11225 ) ) {
3027: tok@var2472 .@expr11247 insertToken (@expr1073753072 ";" ) ; }
3028: tok@var2472 .@expr11247 insertToken (@expr1073753074 ")" ) ;
3029: tok@var2472 .@expr11247 insertToken (@expr1073753076 "\"" +@expr1073753077 instruction@var2474 +@expr1073753078 "\"" ) ;
3030: tok@var2472 .@expr11247 insertToken (@expr1073753080 "(" ) ;
3031:
3032: tok@var2472 =@expr1073753081 tok@var2472 .@expr1073753082 tokAt (@expr1073753083 3 ) ;
3033: }
3034: }
3035:
3036: void Tokenizer :: simplifyArrayAccessSyntax ( )
3037: {
3038:
3039: for (@expr1073753084 Token *@expr1073753085 tok@var2475 =@expr1073753086 list@var872 .@expr1073753087 front (@expr1073753088 ) ; tok@var2475 ; tok@var2475 =@expr1073753089 tok@var2475 .@expr1073753090 next (@expr1073753091 ) ) {
3040: if (@expr1073753092 tok@var2475 .@expr1073753093 isNumber (@expr1073753094 ) &&@expr1073753095 Token ::@expr1073753096 Match (@expr1073753097 tok@var2475 , "%num% [ %name% ]" ) ) {
3041: const std ::@expr1073753098 string number@var2476 (@expr1073753099 tok@var2475 .@expr11276 str (@expr1073753101 ) ) ;
3042: Token * indexTok@var2477 ; indexTok@var2477 =@expr1073753102 tok@var2475 .@expr1073753103 tokAt (@expr1073753104 2 ) ;
3043: tok@var2475 .@expr11276 str (@expr1073753106 indexTok@var2477 .@expr11283 str (@expr1073753108 ) ) ;
3044: tok@var2475 .@expr1073753109 varId (@expr1073753110 indexTok@var2477 .@expr1073753111 varId (@expr1073753112 ) ) ;
3045: indexTok@var2477 .@expr11283 str (@expr1073753114 number@var2476 ) ;
3046: }
3047: }
3048: }
3049:
3050: void Tokenizer :: simplifyParameterVoid ( )
3051: {
3052: for (@expr1073753115 Token *@expr1073753116 tok@var2478 =@expr1073753117 list@var872 .@expr1073753118 front (@expr1073753119 ) ; tok@var2478 ; tok@var2478 =@expr1073753120 tok@var2478 .@expr11297 next (@expr11298 ) ) {
3053: if (@expr1073753123 Token ::@expr11300 Match (@expr1073753125 tok@var2478 , "%name% ( void )" ) &&@expr1073753126 !@expr1073753127 Token ::@expr11300 Match (@expr1073753129 tok@var2478 , "sizeof|decltype|typeof|return" ) ) {
3054: tok@var2478 .@expr11297 next (@expr11298 ) .@expr1073753132 deleteNext (@expr1073753133 ) ;
3055: tok@var2478 .@expr11297 next (@expr11298 ) .@expr1073753136 setRemovedVoidParameter (@expr1073753137 true ) ;
3056: }
3057: }
3058: }
3059:
3060: void Tokenizer :: simplifyRedundantConsecutiveBraces ( )
3061: {
3062:
3063: for (@expr1073753138 Token *@expr1073753139 tok@var2479 =@expr1073753140 list@var872 .@expr1073753141 front (@expr1073753142 ) ; tok@var2479 ; ) {
3064: if (@expr1073753143 Token ::@expr11320 simpleMatch (@expr1073753145 tok@var2479 , "= {" ) ) {
3065: tok@var2479 =@expr1073753146 tok@var2479 .@expr1073753147 linkAt (@expr1073753148 1 ) ;
3066: } else { if (@expr1073753149 Token ::@expr11320 simpleMatch (@expr1073753151 tok@var2479 , "{ {" ) &&@expr1073753152 Token ::@expr11320 simpleMatch (@expr1073753154 tok@var2479 .@expr11331 next (@expr11332 ) .@expr11333 link (@expr11334 ) , "} }" ) ) {
3067:
3068: tok@var2479 .@expr11331 next (@expr11332 ) .@expr11333 link (@expr11334 ) .@expr1073753163 deleteThis (@expr1073753164 ) ;
3069: tok@var2479 .@expr1073753165 deleteNext (@expr1073753166 ) ;
3070: } else {
3071: tok@var2479 =@expr1073753167 tok@var2479 .@expr11331 next (@expr11332 ) ; } }
3072: }
3073: }
3074:
3075: void Tokenizer :: simplifyDoublePlusAndDoubleMinus ( )
3076: {
3077:
3078: for (@expr1073753170 Token *@expr1073753171 tok@var2480 =@expr1073753172 list@var872 .@expr1073753173 front (@expr1073753174 ) ; tok@var2480 ; tok@var2480 =@expr1073753175 tok@var2480 .@expr11352 next (@expr11353 ) ) {
3079: while (@expr1073753178 tok@var2480 .@expr11352 next (@expr11353 ) ) {
3080: if (@expr1073753181 tok@var2480 .@expr11358 str (@expr11359 ) ==@expr1073753184 "+" ) {
3081: if (@expr11361 tok@var2480 .@expr11352 next (@expr11353 ) .@expr11364 str (@expr11365 ) [@expr11366 0 ] ==@expr11367 '-' ) {
3082: tok@var2480 =@expr1073753192 tok@var2480 .@expr11352 next (@expr11353 ) ;
3083: if (@expr11371 tok@var2480 .@expr11358 str (@expr11359 ) .@expr11374 size (@expr11375 ) ==@expr11376 1 ) {
3084: tok@var2480 =@expr1073753201 tok@var2480 .@expr11378 previous (@expr11379 ) ;
3085: tok@var2480 .@expr11358 str (@expr11381 "-" ) ;
3086: tok@var2480 .@expr11382 deleteNext (@expr11383 ) ;
3087: } else { if (@expr11384 tok@var2480 .@expr11385 isNumber (@expr11386 ) ) {
3088: tok@var2480 .@expr11358 str (@expr11388 tok@var2480 .@expr11358 str (@expr11359 ) .@expr11391 substr (@expr11392 1 ) ) ;
3089: tok@var2480 =@expr1073753217 tok@var2480 .@expr11378 previous (@expr11379 ) ;
3090: tok@var2480 .@expr11358 str (@expr11381 "-" ) ;
3091: } }
3092: continue ;
3093: }
3094: } else { if (@expr1073753222 tok@var2480 .@expr11358 str (@expr11359 ) ==@expr1073753225 "-" ) {
3095: if (@expr11361 tok@var2480 .@expr11352 next (@expr11353 ) .@expr11364 str (@expr11365 ) [@expr11366 0 ] ==@expr11367 '-' ) {
3096: tok@var2480 =@expr1073753233 tok@var2480 .@expr11352 next (@expr11353 ) ;
3097: if (@expr11371 tok@var2480 .@expr11358 str (@expr11359 ) .@expr11374 size (@expr11375 ) ==@expr11376 1 ) {
3098: tok@var2480 =@expr1073753242 tok@var2480 .@expr11378 previous (@expr11379 ) ;
3099: tok@var2480 .@expr11358 str (@expr11422 "+" ) ;
3100: tok@var2480 .@expr11382 deleteNext (@expr11383 ) ;
3101: } else { if (@expr11384 tok@var2480 .@expr11385 isNumber (@expr11386 ) ) {
3102: tok@var2480 .@expr11358 str (@expr11388 tok@var2480 .@expr11358 str (@expr11359 ) .@expr11391 substr (@expr11392 1 ) ) ;
3103: tok@var2480 =@expr1073753258 tok@var2480 .@expr11378 previous (@expr11379 ) ;
3104: tok@var2480 .@expr11358 str (@expr11422 "+" ) ;
3105: } }
3106: continue ;
3107: }
3108: } }
3109:
3110: break ;
3111: }
3112: }
3113: }
3114:
3115:
3116:
3117: void Tokenizer :: arraySize ( )
3118: {
3119: for (@expr1073753263 Token *@expr11440 tok@var2481 =@expr1073753265 list@var872 .@expr1073753266 front (@expr1073753267 ) ; tok@var2481 ; tok@var2481 =@expr1073753268 tok@var2481 .@expr11445 next (@expr11446 ) ) {
3120: if (@expr1073753271 !@expr1073753272 tok@var2481 .@expr1073753273 isName (@expr1073753274 ) ||@expr1073753275 !@expr1073753276 Token ::@expr11453 Match (@expr1073753278 tok@var2481 , "%var% [ ] =" ) ) {
3121: continue ; }
3122: bool addlength@var2482 ; addlength@var2482 =@expr1073753279 false ;
3123: if (@expr1073753280 Token ::@expr11453 Match (@expr1073753282 tok@var2481 , "%var% [ ] = { %str% } ;" ) ) {
3124: Token * t@var2483 ; t@var2483 =@expr1073753283 tok@var2481 .@expr11460 tokAt (@expr11461 3 ) ;
3125: t@var2483 .@expr1073753286 deleteNext (@expr1073753287 ) ;
3126: t@var2483 .@expr1073753288 next (@expr1073753289 ) .@expr1073753290 deleteNext (@expr1073753291 ) ;
3127: addlength@var2482 =@expr1073753292 true ;
3128: }
3129:
3130: if (@expr1073753293 addlength@var2482 ||@expr1073753294 Token ::@expr11453 Match (@expr1073753296 tok@var2481 , "%var% [ ] = %str% ;" ) ) {
3131: tok@var2481 =@expr1073753297 tok@var2481 .@expr11445 next (@expr11446 ) ;
3132: const int sz@var2484 =@expr1073753300 Token ::@expr1073753301 getStrArraySize (@expr1073753302 tok@var2481 .@expr11460 tokAt (@expr11461 3 ) ) ;
3133: tok@var2481 .@expr11481 insertToken (@expr1073753306 MathLib ::@expr11483 toString (@expr1073753308 sz@var2484 ) ) ;
3134: tok@var2481 =@expr1073753309 tok@var2481 .@expr11460 tokAt (@expr1073753311 5 ) ;
3135: }
3136:
3137: else { if (@expr1073753312 Token ::@expr11453 Match (@expr1073753314 tok@var2481 , "%var% [ ] = {" ) ) {
3138: unsigned long long sz@var2485 ; sz@var2485 =@expr1073753315 1 ;
3139: tok@var2481 =@expr1073753316 tok@var2481 .@expr11445 next (@expr11446 ) ;
3140: Token * end@var2486 ; end@var2486 =@expr1073753319 tok@var2481 .@expr1073753320 linkAt (@expr1073753321 3 ) ;
3141: for (@expr1073753322 Token *@expr11440 tok2@var2487 =@expr1073753324 tok@var2481 .@expr11460 tokAt (@expr1073753326 4 ) ; tok2@var2487 &&@expr1073753327 tok2@var2487 !=@expr1073753328 end@var2486 ; tok2@var2487 =@expr1073753329 tok2@var2487 .@expr11506 next (@expr11507 ) ) {
3142: if (@expr1073753332 tok2@var2487 .@expr11509 link (@expr11510 ) &&@expr1073753335 Token ::@expr11453 Match (@expr1073753337 tok2@var2487 , "{|(|[|<" ) ) {
3143: if (@expr1073753338 tok2@var2487 .@expr11515 str (@expr11516 ) ==@expr1073753341 "[" &&@expr1073753342 tok2@var2487 .@expr11509 link (@expr11510 ) .@expr1073753345 strAt (@expr1073753346 1 ) ==@expr1073753347 "=" ) {
3144: if (@expr1073753348 Token ::@expr11453 Match (@expr1073753350 tok2@var2487 , "[ %num% ]" ) ) {
3145: sz@var2485 =@expr1073753351 std ::@expr1073753352 max (@expr1073753353 sz@var2485 , MathLib ::@expr1073753354 toULongNumber (@expr1073753355 tok2@var2487 .@expr1073753356 strAt (@expr1073753357 1 ) ) +@expr1073753358 1U ) ; }
3146: else {
3147: sz@var2485 =@expr1073753359 0 ;
3148: break ;
3149: }
3150: }
3151: tok2@var2487 =@expr1073753360 tok2@var2487 .@expr11509 link (@expr11510 ) ;
3152: } else { if (@expr1073753363 tok2@var2487 .@expr11515 str (@expr11516 ) ==@expr1073753366 "," ) {
3153: if (@expr1073753367 !@expr1073753368 Token ::@expr11453 Match (@expr1073753370 tok2@var2487 .@expr11506 next (@expr11507 ) , "[},]" ) ) {
3154: ++@expr1073753373 sz@var2485 ; }
3155: else {
3156: tok2@var2487 =@expr1073753374 tok2@var2487 .@expr1073753375 previous (@expr1073753376 ) ;
3157: tok2@var2487 .@expr1073753377 deleteNext (@expr1073753378 ) ;
3158: }
3159: } }
3160: }
3161:
3162: if (@expr1073753379 sz@var2485 !=@expr1073753380 0 ) {
3163: tok@var2481 .@expr11481 insertToken (@expr1073753382 MathLib ::@expr11483 toString (@expr1073753384 sz@var2485 ) ) ; }
3164:
3165: tok@var2481 =@expr1073753385 end@var2486 .@expr11562 next (@expr11563 ) ?@expr1073753388 end@var2486 .@expr11562 next (@expr11563 ) :@expr1073753391 end@var2486 ;
3166: } }
3167: }
3168: }
3169:
3170: static Token * skipTernaryOp ( Token * tok@var2488 )
3171: {
3172: int colonLevel@var2489 ; colonLevel@var2489 =@expr1073753392 1 ;
3173: while (@expr1073753393 nullptr !=@expr1073753394 (@expr1073753395 tok@var2488 =@expr1073753396 tok@var2488 .@expr11573 next (@expr11574 ) ) ) {
3174: if (@expr1073753399 tok@var2488 .@expr11576 str (@expr11577 ) ==@expr1073753402 "?" ) {
3175: ++@expr1073753403 colonLevel@var2489 ;
3176: } else { if (@expr1073753404 tok@var2488 .@expr11576 str (@expr11577 ) ==@expr1073753407 ":" ) {
3177: --@expr1073753408 colonLevel@var2489 ;
3178: if (@expr1073753409 colonLevel@var2489 ==@expr1073753410 0 ) {
3179: tok@var2488 =@expr1073753411 tok@var2488 .@expr11573 next (@expr11574 ) ;
3180: break ;
3181: }
3182: } }
3183: if (@expr1073753414 tok@var2488 .@expr11591 link (@expr11592 ) &&@expr1073753417 Token ::@expr11594 Match (@expr1073753419 tok@var2488 , "[(<]" ) ) {
3184: tok@var2488 =@expr1073753420 tok@var2488 .@expr11591 link (@expr11592 ) ; }
3185: else { if (@expr1073753423 Token ::@expr11594 Match (@expr1073753425 tok@var2488 .@expr11573 next (@expr11574 ) , "[{};)]" ) ) {
3186: break ; } }
3187: }
3188: if (@expr1073753428 colonLevel@var2489 >@expr1073753429 0 ) {
3189: return nullptr ; }
3190: return tok@var2488 ;
3191: }
3192:
|
3195:
3196: static Token * skipCaseLabel ( Token * tok@var2490 )
3197: {
3198: assert (@expr1073753430 tok@var2490 .@expr11607 str (@expr11608 ) ==@expr1073753433 "case" ) ;
3199: while (@expr1073753434 nullptr !=@expr1073753435 (@expr1073753436 tok@var2490 =@expr1073753437 tok@var2490 .@expr1073753438 next (@expr1073753439 ) ) ) {
3200: if (@expr1073753440 Token ::@expr11617 Match (@expr1073753442 tok@var2490 , "(|[" ) ) {
3201: tok@var2490 =@expr1073753443 tok@var2490 .@expr1073753444 link (@expr1073753445 ) ; }
3202: else { if (@expr1073753446 tok@var2490 .@expr11607 str (@expr11608 ) ==@expr1073753449 "?" ) {
3203: Token * tok1@var2491 ; tok1@var2491 =@expr1073753450 skipTernaryOp (@expr1073753451 tok@var2490 ) ;
3204: if (@expr1073753452 !@expr1073753453 tok1@var2491 ) {
3205: return tok@var2490 ; }
3206: tok@var2490 =@expr1073753454 tok1@var2491 ;
3207: } }
3208: if (@expr1073753455 Token ::@expr11617 Match (@expr1073753457 tok@var2490 , "[:{};]" ) ) {
3209: return tok@var2490 ; }
3210: }
3211: return nullptr ;
3212: }
3213:
3214: const Token * Tokenizer :: startOfExecutableScope ( const Token * tok@var2492 )
3215: {
3216: if (@expr1073753458 tok@var2492 .@expr11635 str (@expr11636 ) !=@expr1073753461 ")" ) {
3217: return nullptr ; }
3218:
3219: tok@var2492 =@expr1073753462 isFunctionHead (@expr1073753463 tok@var2492 , ":{" , true ) ;
3220:
3221: if (@expr1073753464 Token ::@expr11641 Match (@expr1073753466 tok@var2492 , ": %name% [({]" ) ) {
3222: while (@expr1073753467 Token ::@expr11641 Match (@expr1073753469 tok@var2492 , "[:,] %name% [({]" ) ) {
3223: tok@var2492 =@expr1073753470 tok@var2492 .@expr1073753471 linkAt (@expr1073753472 2 ) .@expr1073753473 next (@expr1073753474 ) ; }
3224: }
3225:
3226: return (@expr1073753475 tok@var2492 &&@expr1073753476 tok@var2492 .@expr11635 str (@expr11636 ) ==@expr1073753479 "{" ) ?@expr1073753480 tok@var2492 :@expr1073753481 nullptr ;
3227: }
3228:
|
3231:
3232: void Tokenizer :: simplifyLabelsCaseDefault ( )
3233: {
3234: const bool cpp@var2493 =@expr1073753482 isCPP (@expr1073753483 ) ;
3235: bool executablescope@var2494 ; executablescope@var2494 =@expr1073753484 false ;
3236: int indentLevel@var2495 ; indentLevel@var2495 =@expr1073753485 0 ;
3237: for (@expr1073753486 Token *@expr11663 tok@var2496 =@expr1073753488 list@var872 .@expr1073753489 front (@expr1073753490 ) ; tok@var2496 ; tok@var2496 =@expr1073753491 tok@var2496 .@expr11668 next (@expr11669 ) ) {
3238:
3239: Token * start@var2497 ; start@var2497 =@expr1073753494 const_cast < Token *@expr11663 > (@expr1073753496 startOfExecutableScope (@expr1073753497 tok@var2496 ) ) ;
3240: if (@expr1073753498 start@var2497 ) {
3241: tok@var2496 =@expr1073753499 start@var2497 ;
3242: executablescope@var2494 =@expr1073753500 true ;
3243: }
3244:
3245: if (@expr1073753501 !@expr1073753502 executablescope@var2494 ) {
3246: continue ; }
3247:
3248: if (@expr1073753503 tok@var2496 .@expr11680 str (@expr11681 ) ==@expr1073753506 "{" ) {
3249: if (@expr1073753507 tok@var2496 .@expr11684 previous (@expr11685 ) .@expr1073753510 str (@expr1073753511 ) ==@expr1073753512 "=" ) {
3250: tok@var2496 =@expr1073753513 tok@var2496 .@expr11690 link (@expr11691 ) ; }
3251: else {
3252: ++@expr1073753516 indentLevel@var2495 ; }
3253: } else { if (@expr1073753517 tok@var2496 .@expr11680 str (@expr11681 ) ==@expr1073753520 "}" ) {
3254: --@expr1073753521 indentLevel@var2495 ;
3255: if (@expr1073753522 indentLevel@var2495 ==@expr1073753523 0 ) {
3256: executablescope@var2494 =@expr1073753524 false ;
3257: continue ;
3258: }
3259: } else { if (@expr1073753525 Token ::@expr11702 Match (@expr1073753527 tok@var2496 , "(|[" ) ) {
3260: tok@var2496 =@expr1073753528 tok@var2496 .@expr11690 link (@expr11691 ) ; } } }
3261:
3262: if (@expr1073753531 Token ::@expr11702 Match (@expr1073753533 tok@var2496 , "[;{}:] case" ) ) {
3263: tok@var2496 =@expr1073753534 skipCaseLabel (@expr1073753535 tok@var2496 .@expr11668 next (@expr11669 ) ) ;
3264: if (@expr1073753538 !@expr1073753539 tok@var2496 ) {
3265: break ; }
3266: if (@expr1073753540 tok@var2496 .@expr11680 str (@expr11681 ) !=@expr1073753543 ":" ||@expr1073753544 tok@var2496 .@expr1073753545 strAt (@expr1073753546 -1 ) ==@expr1073753547 "case" ||@expr1073753548 !@expr1073753549 tok@var2496 .@expr11668 next (@expr11669 ) ) {
3267: syntaxError (@expr1073753552 tok@var2496 ) ; }
3268: if (@expr1073753553 tok@var2496 .@expr11668 next (@expr11669 ) .@expr11732 str (@expr11733 ) !=@expr1073753558 ";" &&@expr1073753559 tok@var2496 .@expr11668 next (@expr11669 ) .@expr11732 str (@expr11733 ) !=@expr1073753564 "case" ) {
3269: tok@var2496 .@expr11741 insertToken (@expr11742 ";" ) ; }
3270: else {
3271: tok@var2496 =@expr1073753567 tok@var2496 .@expr11684 previous (@expr11685 ) ; }
3272: } else { if (@expr1073753570 Token ::@expr11702 Match (@expr1073753572 tok@var2496 , "[;{}] %name% : !!;" ) ) {
3273: if (@expr1073753573 !@expr1073753574 cpp@var2493 ||@expr1073753575 !@expr1073753576 Token ::@expr11702 Match (@expr1073753578 tok@var2496 .@expr11668 next (@expr11669 ) , "class|struct|enum" ) ) {
3274: tok@var2496 =@expr1073753581 tok@var2496 .@expr1073753582 tokAt (@expr1073753583 2 ) ;
3275: tok@var2496 .@expr11741 insertToken (@expr11742 ";" ) ;
3276: }
3277: } }
3278: }
3279: }
3280:
3281:
3282: void Tokenizer :: simplifyCaseRange ( )
3283: {
3284: for (@expr1073753586 Token *@expr1073753587 tok@var2498 =@expr1073753588 list@var872 .@expr1073753589 front (@expr1073753590 ) ; tok@var2498 ; tok@var2498 =@expr1073753591 tok@var2498 .@expr1073753592 next (@expr1073753593 ) ) {
3285: if (@expr1073753594 Token ::@expr1073753595 Match (@expr1073753596 tok@var2498 , "case %num%|%char% ... %num%|%char% :" ) ) {
3286: const long long start@var2499 =@expr1073753597 MathLib ::@expr11774 toLongNumber (@expr1073753599 tok@var2498 .@expr11776 strAt (@expr1073753601 1 ) ) ;
3287: long long end@var2500 ; end@var2500 =@expr1073753602 MathLib ::@expr11774 toLongNumber (@expr1073753604 tok@var2498 .@expr11776 strAt (@expr1073753606 3 ) ) ;
3288: end@var2500 =@expr1073753607 std ::@expr1073753608 min (@expr1073753609 start@var2499 +@expr1073753610 50 , end@var2500 ) ;
3289: if (@expr1073753611 start@var2499 <@expr1073753612 end@var2500 ) {
3290: tok@var2498 =@expr1073753613 tok@var2498 .@expr1073753614 tokAt (@expr1073753615 2 ) ;
3291: tok@var2498 .@expr1073753616 str (@expr1073753617 ":" ) ;
3292: tok@var2498 .@expr11794 insertToken (@expr11795 "case" ) ;
3293: for (@expr1073753620 long long i@var2501 =@expr1073753621 end@var2500 -@expr1073753622 1 ; i@var2501 >@expr1073753623 start@var2499 ; i@var2501 --@expr1073753624 ) {
3294: tok@var2498 .@expr11794 insertToken (@expr1073753626 ":" ) ;
3295: tok@var2498 .@expr11794 insertToken (@expr1073753628 MathLib ::@expr1073753629 toString (@expr1073753630 i@var2501 ) ) ;
3296: tok@var2498 .@expr11794 insertToken (@expr11795 "case" ) ;
3297: }
3298: }
3299: }
3300: }
3301: }
3302:
3303: void Tokenizer :: calculateScopes ( )
3304: {
3305: for (@expr1073753633 auto *@expr11810 tok@var2502 =@expr1073753635 list@var872 .@expr11812 front (@expr11813 ) ; tok@var2502 ; tok@var2502 =@expr1073753638 tok@var2502 .@expr1073753639 next (@expr1073753640 ) ) {
3306: tok@var2502 .@expr1073753641 scopeInfo (@expr1073753642 nullptr ) ; }
3307:
3308: std ::@expr1073753643 string nextScopeNameAddition@var2503 ;
3309: std ::@expr1073753644 shared_ptr < ScopeInfo2 > primaryScope@var2504 ; primaryScope@var2504 =@expr1073753645 std ::@expr11822 make_shared < ScopeInfo2 > (@expr1073753647 "" , nullptr ) ;
3310: list@var872 .@expr11812 front (@expr11813 ) .@expr1073753650 scopeInfo (@expr1073753651 primaryScope@var2504 ) ;
3311:
3312: for (@expr1073753652 Token *@expr11810 tok@var2505 =@expr1073753654 list@var872 .@expr11812 front (@expr11813 ) ; tok@var2505 ; tok@var2505 =@expr1073753657 tok@var2505 .@expr11834 next (@expr11835 ) ) {
3313: if (@expr1073753660 tok@var2505 ==@expr1073753661 list@var872 .@expr11812 front (@expr11813 ) ||@expr1073753664 !@expr1073753665 tok@var2505 .@expr11842 scopeInfo (@expr11843 ) ) {
3314: if (@expr1073753668 tok@var2505 !=@expr1073753669 list@var872 .@expr11812 front (@expr11813 ) ) {
3315: tok@var2505 .@expr11842 scopeInfo (@expr1073753673 tok@var2505 .@expr1073753674 previous (@expr1073753675 ) .@expr1073753676 scopeInfo (@expr1073753677 ) ) ; }
3316:
3317: if (@expr1073753678 Token ::@expr11855 Match (@expr1073753680 tok@var2505 , "using namespace %name% ::|<|;" ) ) {
3318: std ::@expr1073753681 string usingNamespaceName@var2506 ;
3319: for (@expr1073753682 const Token *@expr11810 namespaceNameToken@var2507 =@expr1073753684 tok@var2505 .@expr11861 tokAt (@expr1073753686 2 ) ;
3320: namespaceNameToken@var2507 &&@expr1073753687 namespaceNameToken@var2507 .@expr11864 str (@expr11865 ) !=@expr1073753690 ";" ;
3321: namespaceNameToken@var2507 =@expr1073753691 namespaceNameToken@var2507 .@expr1073753692 next (@expr1073753693 ) ) {
3322: usingNamespaceName@var2506 +=@expr1073753694 namespaceNameToken@var2507 .@expr11864 str (@expr11865 ) ;
3323: usingNamespaceName@var2506 +=@expr1073753697 " " ;
3324: }
3325: if (@expr1073753698 usingNamespaceName@var2506 .@expr11875 length (@expr11876 ) >@expr1073753701 0 ) {
3326: usingNamespaceName@var2506 =@expr1073753702 usingNamespaceName@var2506 .@expr1073753703 substr (@expr1073753704 0 , usingNamespaceName@var2506 .@expr11875 length (@expr11876 ) -@expr1073753707 1 ) ; }
3327: tok@var2505 .@expr11842 scopeInfo (@expr11843 ) .@expr11886 usingNamespaces@var3609 .@expr1073753711 insert (@expr1073753712 usingNamespaceName@var2506 ) ;
3328: } else { if (@expr1073753713 Token ::@expr11855 Match (@expr1073753715 tok@var2505 , "namespace|class|struct|union %name% {|::|:|<" ) ) {
3329: for (@expr1073753716 Token *@expr11810 nameTok@var2508 =@expr1073753718 tok@var2505 .@expr11834 next (@expr11835 ) ; nameTok@var2508 &&@expr1073753721 !@expr1073753722 Token ::@expr11855 Match (@expr1073753724 nameTok@var2508 , "{|:" ) ; nameTok@var2508 =@expr1073753725 nameTok@var2508 .@expr1073753726 next (@expr1073753727 ) ) {
3330: if (@expr1073753728 Token ::@expr11855 Match (@expr1073753730 nameTok@var2508 , ";|<" ) ) {
3331: nextScopeNameAddition@var2503 =@expr1073753731 "" ;
3332: break ;
3333: }
3334: nextScopeNameAddition@var2503 .@expr11908 append (@expr1073753733 nameTok@var2508 .@expr1073753734 str (@expr1073753735 ) ) ;
3335: nextScopeNameAddition@var2503 .@expr11908 append (@expr1073753737 " " ) ;
3336: }
3337: if (@expr1073753738 nextScopeNameAddition@var2503 .@expr11915 length (@expr11916 ) >@expr1073753741 0 ) {
3338: nextScopeNameAddition@var2503 =@expr1073753742 nextScopeNameAddition@var2503 .@expr1073753743 substr (@expr1073753744 0 , nextScopeNameAddition@var2503 .@expr11915 length (@expr11916 ) -@expr1073753747 1 ) ; }
3339: } }
3340:
3341: if (@expr1073753748 Token ::@expr1073753749 simpleMatch (@expr1073753750 tok@var2505 , "{" ) ) {
3342:
3343: Token * tok1@var2509 ; tok1@var2509 =@expr1073753751 tok@var2505 ;
3344: while (@expr11928 Token ::@expr11855 Match (@expr11930 tok1@var2509 .@expr11931 previous (@expr11932 ) , "const|volatile|final|override|&|&&|noexcept" ) ) {
3345: tok1@var2509 =@expr1073753757 tok1@var2509 .@expr11931 previous (@expr11932 ) ; }
3346: if (@expr1073753760 tok1@var2509 .@expr11931 previous (@expr11932 ) &&@expr1073753763 tok1@var2509 .@expr11940 strAt (@expr11941 -1 ) ==@expr1073753766 ")" ) {
3347: bool member@var2510 ; member@var2510 =@expr1073753767 true ;
3348: tok1@var2509 =@expr1073753768 tok1@var2509 .@expr1073753769 linkAt (@expr1073753770 -1 ) ;
3349: if (@expr1073753771 Token ::@expr11855 Match (@expr1073753773 tok1@var2509 .@expr11931 previous (@expr11932 ) , "throw|noexcept" ) ) {
3350: tok1@var2509 =@expr1073753776 tok1@var2509 .@expr11931 previous (@expr11932 ) ;
3351: while (@expr11928 Token ::@expr11855 Match (@expr11930 tok1@var2509 .@expr11931 previous (@expr11932 ) , "const|volatile|final|override|&|&&|noexcept" ) ) {
3352: tok1@var2509 =@expr1073753784 tok1@var2509 .@expr11931 previous (@expr11932 ) ; }
3353: if (@expr11963 tok1@var2509 .@expr11940 strAt (@expr11941 -1 ) !=@expr11966 ")" ) {
3354: member@var2510 =@expr1073753791 false ; }
3355: } else { if (@expr1073753792 Token ::@expr11855 Match (@expr1073753794 tok@var2505 .@expr11861 tokAt (@expr1073753796 -2 ) , ":|, %name%" ) ) {
3356: tok1@var2509 =@expr1073753797 tok1@var2509 .@expr11974 tokAt (@expr11975 -2 ) ;
3357: if (@expr11963 tok1@var2509 .@expr11940 strAt (@expr11941 -1 ) !=@expr11966 ")" ) {
3358: member@var2510 =@expr1073753804 false ; }
3359: } }
3360: if (@expr1073753805 member@var2510 ) {
3361: if (@expr1073753806 tok1@var2509 .@expr11940 strAt (@expr11941 -1 ) ==@expr1073753809 ">" ) {
3362: tok1@var2509 =@expr1073753810 tok1@var2509 .@expr11931 previous (@expr11932 ) .@expr1073753813 findOpeningBracket (@expr1073753814 ) ; }
3363: if (@expr1073753815 tok1@var2509 &&@expr1073753816 Token ::@expr11855 Match (@expr1073753818 tok1@var2509 .@expr11974 tokAt (@expr1073753820 -3 ) , "%name% :: %name%" ) ) {
3364: tok1@var2509 =@expr1073753821 tok1@var2509 .@expr11974 tokAt (@expr11975 -2 ) ;
3365: std ::@expr1073753824 string scope@var2511 ; scope@var2511 =@expr1073753825 tok1@var2509 .@expr11940 strAt (@expr11941 -1 ) ;
3366: while (@expr1073753828 Token ::@expr11855 Match (@expr1073753830 tok1@var2509 .@expr11974 tokAt (@expr11975 -2 ) , ":: %name%" ) ) {
3367: scope@var2511 =@expr1073753833 tok1@var2509 .@expr11940 strAt (@expr1073753835 -3 ) +@expr1073753836 " :: " +@expr1073753837 scope@var2511 ;
3368: tok1@var2509 =@expr1073753838 tok1@var2509 .@expr11974 tokAt (@expr11975 -2 ) ;
3369: }
3370:
3371: if (@expr1073753841 !@expr12018 nextScopeNameAddition@var2503 .@expr12019 empty (@expr12020 ) &&@expr1073753845 !@expr1073753846 scope@var2511 .@expr1073753847 empty (@expr1073753848 ) ) {
3372: nextScopeNameAddition@var2503 +=@expr1073753849 " :: " ; }
3373: nextScopeNameAddition@var2503 +=@expr1073753850 scope@var2511 ;
3374: }
3375: }
3376: }
3377:
3378:
3379: std ::@expr1073753851 shared_ptr < ScopeInfo2 > newScopeInfo@var2512 ; newScopeInfo@var2512 =@expr1073753852 std ::@expr11822 make_shared < ScopeInfo2 > (@expr1073753854 tok@var2505 .@expr11842 scopeInfo (@expr11843 ) .@expr1073753857 name@var3610 , tok@var2505 .@expr12034 link (@expr12035 ) , tok@var2505 .@expr11842 scopeInfo (@expr11843 ) .@expr11886 usingNamespaces@var3609 ) ;
3380:
3381: if (@expr1073753863 !@expr1073753864 newScopeInfo@var2512 .@expr12041 name@var2513 .@expr1073753866 empty (@expr1073753867 ) &&@expr1073753868 !@expr12018 nextScopeNameAddition@var2503 .@expr12019 empty (@expr12020 ) ) {
3382: newScopeInfo@var2512 .@expr12041 name@var2513 .@expr12049 append (@expr1073753874 " :: " ) ; }
3383: newScopeInfo@var2512 .@expr12041 name@var2513 .@expr12049 append (@expr1073753877 nextScopeNameAddition@var2503 ) ;
3384: nextScopeNameAddition@var2503 =@expr1073753878 "" ;
3385:
3386: if (@expr1073753879 tok@var2505 .@expr12034 link (@expr12035 ) ) {
3387: tok@var2505 .@expr12034 link (@expr12035 ) .@expr1073753884 scopeInfo (@expr1073753885 tok@var2505 .@expr11842 scopeInfo (@expr11843 ) ) ; }
3388: tok@var2505 .@expr11842 scopeInfo (@expr1073753889 newScopeInfo@var2512 ) ;
3389: }
3390: }
3391: }
3392: }
3393:
3394: void Tokenizer :: simplifyTemplates ( )
3395: {
3396: if (@expr1073753890 isC (@expr1073753891 ) ) {
3397: return ; }
3398:
3399: mTemplateSimplifier@var882 .@expr1073753892 simplifyTemplates (@expr1073753893
3400:
3401:
3402:
3403: 0 ,
3404:
3405: mCodeWithTemplates@var893 ) ;
3406: }
3407:
3408:
3409:
3410: static bool setVarIdParseDeclaration ( const Token * * tok@var2514 , const std :: map < std :: string , int > & variableId@var2515 , bool executableScope@var2516 , bool cpp@var2517 , bool c@var2518 )
3411: {
3412: const Token * tok2@var2519 ; tok2@var2519 =@expr1073753894 *@expr12071 tok@var2514 ;
3413: if (@expr1073753896 !@expr1073753897 tok2@var2519 .@expr12074 isName (@expr12075 ) ) {
3414: return false ; }
3415:
3416: int typeCount@var2520 ; typeCount@var2520 =@expr1073753900 0 ;
3417: int singleNameCount@var2521 ; singleNameCount@var2521 =@expr1073753901 0 ;
3418: bool hasstruct@var2522 ; hasstruct@var2522 =@expr1073753902 false ;
3419: bool bracket@var2523 ; bracket@var2523 =@expr1073753903 false ;
3420: bool ref@var2524 ; ref@var2524 =@expr1073753904 false ;
3421: while (@expr1073753905 tok2@var2519 ) {
3422: if (@expr1073753906 tok2@var2519 .@expr12074 isName (@expr12075 ) ) {
3423: if (@expr1073753909 cpp@var2517 &&@expr1073753910 Token ::@expr12087 Match (@expr1073753912 tok2@var2519 , "namespace|public|private|protected" ) ) {
3424: return false ; }
3425: if (@expr1073753913 cpp@var2517 &&@expr1073753914 Token ::@expr12091 simpleMatch (@expr1073753916 tok2@var2519 , "decltype (" ) ) {
3426: typeCount@var2520 =@expr1073753917 1 ;
3427: tok2@var2519 =@expr1073753918 tok2@var2519 .@expr12095 linkAt (@expr1073753920 1 ) .@expr1073753921 next (@expr1073753922 ) ;
3428: continue ;
3429: }
3430: if (@expr1073753923 Token ::@expr12087 Match (@expr1073753925 tok2@var2519 , "struct|union|enum" ) ||@expr1073753926 (@expr1073753927 !@expr12104 c@var2518 &&@expr1073753929 Token ::@expr12087 Match (@expr1073753931 tok2@var2519 , "class|typename" ) ) ) {
3431: hasstruct@var2522 =@expr1073753932 true ;
3432: typeCount@var2520 =@expr1073753933 0 ;
3433: singleNameCount@var2521 =@expr1073753934 0 ;
3434: } else { if (@expr1073753935 Token ::@expr12087 Match (@expr1073753937 tok2@var2519 , "const|extern" ) ) {
3435:
3436: } else { if (@expr1073753938 !@expr1073753939 hasstruct@var2522 &&@expr1073753940 variableId@var2515 .@expr1073753941 find (@expr1073753942 tok2@var2519 .@expr12119 str (@expr12120 ) ) !=@expr1073753945 variableId@var2515 .@expr1073753946 end (@expr1073753947 ) &&@expr1073753948 tok2@var2519 .@expr12125 previous (@expr12126 ) .@expr1073753951 str (@expr1073753952 ) !=@expr1073753953 "::" ) {
3437: ++@expr1073753954 typeCount@var2520 ;
3438: tok2@var2519 =@expr1073753955 tok2@var2519 .@expr12132 next (@expr12133 ) ;
3439: if (@expr1073753958 !@expr1073753959 tok2@var2519 ||@expr1073753960 tok2@var2519 .@expr12119 str (@expr12120 ) !=@expr12139 "::" ) {
3440: break ; }
3441: } else {
3442: if (@expr1073753964 tok2@var2519 .@expr12119 str (@expr12120 ) !=@expr1073753967 "void" ||@expr1073753968 Token ::@expr12087 Match (@expr1073753970 tok2@var2519 , "void const| *|(" ) ) {
3443: ++@expr1073753971 typeCount@var2520 ; }
3444: ++@expr1073753972 singleNameCount@var2521 ;
3445: } } }
3446: } else { if (@expr1073753973 !@expr12104 c@var2518 &&@expr1073753975 (@expr1073753976 (@expr1073753977 TemplateSimplifier ::@expr1073753978 templateParameters (@expr1073753979 tok2@var2519 ) >@expr1073753980 0 ) ||@expr1073753981
3447: Token ::@expr12091 simpleMatch (@expr1073753983 tok2@var2519 , "< >" ) ) ) {
3448: const Token * start@var2525 ; start@var2525 =@expr1073753984 *@expr12071 tok@var2514 ;
3449: if (@expr1073753986 Token ::@expr12087 Match (@expr1073753988 start@var2525 .@expr1073753989 previous (@expr1073753990 ) , "%or%|%oror%|&&|&|^|+|-|*|/" ) ) {
3450: return false ; }
3451: const Token * const closingBracket@var2526 ; closingBracket@var2526 =@expr1073753991 tok2@var2519 .@expr1073753992 findClosingBracket (@expr1073753993 ) ;
3452: if (@expr1073753994 closingBracket@var2526 ==@expr1073753995 nullptr ) {
3453: throw tok2@var2519 ;
3454: }
3455: tok2@var2519 =@expr1073753996 closingBracket@var2526 ;
3456: if (@expr1073753997 tok2@var2519 .@expr12119 str (@expr12120 ) !=@expr1073754000 ">" ) {
3457: break ; }
3458: singleNameCount@var2521 =@expr1073754001 1 ;
3459: if (@expr1073754002 Token ::@expr12087 Match (@expr1073754004 tok2@var2519 , "> %name% %or%|%oror%|&&|&|^|+|-|*|/" ) &&@expr1073754005 !@expr1073754006 Token ::@expr12087 Match (@expr1073754008 tok2@var2519 , "> const [*&]" ) ) {
3460: return false ; }
3461: if (@expr1073754009 Token ::@expr12087 Match (@expr1073754011 tok2@var2519 , "> %name% )" ) ) {
3462: if (@expr1073754012 Token ::@expr12087 Match (@expr1073754014 tok2@var2519 .@expr12095 linkAt (@expr12192 2 ) .@expr12193 previous (@expr12194 ) , "if|for|while (" ) ) {
3463: return false ; }
3464: if (@expr1073754019 !@expr1073754020 Token ::@expr12087 Match (@expr1073754022 tok2@var2519 .@expr12095 linkAt (@expr12192 2 ) .@expr12193 previous (@expr12194 ) , "%name%|] (" ) ) {
3465: return false ; }
3466: }
3467: } else { if (@expr1073754027 Token ::@expr12087 Match (@expr1073754029 tok2@var2519 , "&|&&" ) ) {
3468: ref@var2524 =@expr1073754030 !@expr1073754031 bracket@var2523 ;
3469: } else { if (@expr1073754032 singleNameCount@var2521 >=@expr12209 1 &&@expr1073754034 Token ::@expr12087 Match (@expr1073754036 tok2@var2519 , "( [*&]" ) &&@expr1073754037 Token ::@expr12087 Match (@expr1073754039 tok2@var2519 .@expr12216 link (@expr12217 ) .@expr12218 next (@expr12219 ) , "(|[" ) ) {
3470: bracket@var2523 =@expr1073754044 true ;
3471: } else { if (@expr1073754045 singleNameCount@var2521 >=@expr12209 1 &&@expr1073754047 Token ::@expr12087 Match (@expr1073754049 tok2@var2519 , "( * %name% [" ) &&@expr1073754050 Token ::@expr12087 Match (@expr1073754052 tok2@var2519 .@expr12095 linkAt (@expr1073754054 3 ) , "] ) [;,]" ) ) {
3472: bracket@var2523 =@expr1073754055 true ;
3473: } else { if (@expr1073754056 singleNameCount@var2521 >=@expr12209 1 &&@expr1073754058 tok2@var2519 .@expr12125 previous (@expr12126 ) &&@expr1073754061 tok2@var2519 .@expr12125 previous (@expr12126 ) .@expr1073754064 isStandardType (@expr1073754065 ) &&@expr1073754066 Token ::@expr12087 Match (@expr1073754068 tok2@var2519 , "( *|&| %name% ) ;" ) ) {
3474: bracket@var2523 =@expr1073754069 true ;
3475: } else { if (@expr1073754070 tok2@var2519 .@expr12119 str (@expr12120 ) ==@expr1073754073 "::" ) {
3476: singleNameCount@var2521 =@expr1073754074 0 ;
3477: } else { if (@expr1073754075 tok2@var2519 .@expr12119 str (@expr12120 ) !=@expr1073754078 "*" &&@expr1073754079 tok2@var2519 .@expr12119 str (@expr12120 ) !=@expr12139 "::" &&@expr1073754083 tok2@var2519 .@expr12119 str (@expr12120 ) !=@expr1073754086 "..." ) {
3478: break ;
3479: } } } } } } } }
3480: tok2@var2519 =@expr1073754087 tok2@var2519 .@expr12132 next (@expr12133 ) ;
3481: }
3482:
3483: if (@expr1073754090 tok2@var2519 ) {
3484: bool isLambdaArg@var2527 ; isLambdaArg@var2527 =@expr1073754091 false ;
3485: {
3486: const Token * tok3@var2528 ; tok3@var2528 =@expr1073754092 (@expr1073754093 *@expr12071 tok@var2514 ) .@expr1073754095 previous (@expr1073754096 ) ;
3487: if (@expr1073754097 tok3@var2528 &&@expr1073754098 tok3@var2528 .@expr1073754099 str (@expr1073754100 ) ==@expr1073754101 "," ) {
3488: while (@expr1073754102 tok3@var2528 &&@expr1073754103 !@expr1073754104 Token ::@expr12087 Match (@expr1073754106 tok3@var2528 , ";|(|[|{" ) ) {
3489: if (@expr1073754107 Token ::@expr12087 Match (@expr1073754109 tok3@var2528 , ")|]" ) ) {
3490: tok3@var2528 =@expr1073754110 tok3@var2528 .@expr12287 link (@expr12288 ) ; }
3491: tok3@var2528 =@expr1073754113 tok3@var2528 .@expr12290 previous (@expr12291 ) ;
3492: }
3493:
3494: if (@expr1073754116 tok3@var2528 &&@expr1073754117 executableScope@var2516 &&@expr1073754118 Token ::@expr12087 Match (@expr1073754120 tok3@var2528 .@expr12290 previous (@expr12291 ) , "%name% (" ) ) {
3495: const Token * fdecl@var2529 ; fdecl@var2529 =@expr1073754123 tok3@var2528 .@expr12290 previous (@expr12291 ) ;
3496: int count@var2530 ; count@var2530 =@expr1073754126 0 ;
3497: while (@expr1073754127 Token ::@expr12087 Match (@expr1073754129 fdecl@var2529 , "%name%|*" ) ) {
3498: fdecl@var2529 =@expr1073754130 fdecl@var2529 .@expr1073754131 previous (@expr1073754132 ) ;
3499: count@var2530 ++@expr1073754133 ;
3500: }
3501: if (@expr1073754134 !@expr1073754135 Token ::@expr12087 Match (@expr1073754137 fdecl@var2529 , "[;{}] %name%" ) ||@expr1073754138 count@var2530 <=@expr1073754139 1 ) {
3502: return false ; }
3503: }
3504: }
3505:
3506: if (@expr1073754140 cpp@var2517 &&@expr1073754141 tok3@var2528 &&@expr1073754142 Token ::@expr12091 simpleMatch (@expr1073754144 tok3@var2528 .@expr12290 previous (@expr12291 ) , "] (" ) &&@expr1073754147
3507: (@expr1073754148 Token ::@expr12091 simpleMatch (@expr1073754150 tok3@var2528 .@expr12287 link (@expr12288 ) , ") {" ) ||@expr1073754153 Token ::@expr12087 Match (@expr1073754155 tok3@var2528 .@expr12287 link (@expr12288 ) , ") . %name%" ) ) ) {
3508: isLambdaArg@var2527 =@expr1073754158 true ; }
3509: }
3510:
3511:
3512: *@expr12071 tok@var2514 =@expr1073754160 tok2@var2519 ;
3513:
3514:
3515:
3516: if (@expr1073754161 executableScope@var2516 &&@expr1073754162 ref@var2524 &&@expr1073754163 !@expr1073754164 isLambdaArg@var2527 ) {
3517: if (@expr1073754165 Token ::@expr12087 Match (@expr1073754167 tok2@var2519 , "(|=|{|:" ) ) {
3518: ; }
3519: else { if (@expr1073754168 tok2@var2519 .@expr12119 str (@expr12120 ) !=@expr1073754171 ")" ||@expr1073754172 tok2@var2519 .@expr12216 link (@expr12217 ) .@expr1073754175 strAt (@expr1073754176 -1 ) !=@expr1073754177 "catch" ) {
3520: return false ; } }
3521: }
3522: }
3523:
3524:
3525:
3526: if (@expr1073754178 typeCount@var2520 >=@expr12355 2 &&@expr1073754180 executableScope@var2516 &&@expr1073754181 tok2@var2519 &&@expr1073754182 tok2@var2519 .@expr12119 str (@expr12120 ) ==@expr1073754185 "[" ) {
3527: const Token * tok3@var2531 ; tok3@var2531 =@expr1073754186 tok2@var2519 .@expr12216 link (@expr12217 ) .@expr12218 next (@expr12219 ) ;
3528: while (@expr1073754191 tok3@var2531 &&@expr1073754192 tok3@var2531 .@expr1073754193 str (@expr1073754194 ) ==@expr1073754195 "[" ) {
3529: tok3@var2531 =@expr1073754196 tok3@var2531 .@expr1073754197 link (@expr1073754198 ) .@expr1073754199 next (@expr1073754200 ) ;
3530: }
3531: if (@expr1073754201 Token ::@expr12087 Match (@expr1073754203 tok3@var2531 , "= %num%" ) ) {
3532: return false ; }
3533: }
3534:
3535: return (@expr1073754204 typeCount@var2520 >=@expr12355 2 &&@expr1073754206 tok2@var2519 &&@expr1073754207 Token ::@expr12087 Match (@expr1073754209 tok2@var2519 .@expr1073754210 tokAt (@expr1073754211 -2 ) , "!!:: %type%" ) ) ;
3536: }
3537:
3538:
3539: void Tokenizer :: setVarIdStructMembers ( Token * * tok1@var2532 ,
3540: std :: map < int , std :: map < std :: string , int > > & structMembers@var2533 ,
3541: int * varId@var2534 ) const
3542: {
3543: Token * tok@var2535 ; tok@var2535 =@expr1073754212 *@expr12389 tok1@var2532 ;
3544:
3545: if (@expr1073754214 Token ::@expr12391 Match (@expr1073754216 tok@var2535 , "%name% = { . %name% =|{" ) ) {
3546: const int struct_varid@var2536 =@expr1073754217 tok@var2535 .@expr12394 varId (@expr12395 ) ;
3547: if (@expr1073754220 struct_varid@var2536 ==@expr1073754221 0 ) {
3548: return ; }
3549:
3550: std ::@expr12398 map < std ::@expr12399 string , int > & members@var2537 =@expr1073754224 structMembers@var2533 [@expr1073754225 struct_varid@var2536 ] ;
3551:
3552: tok@var2535 =@expr1073754226 tok@var2535 .@expr12403 tokAt (@expr12404 3 ) ;
3553: while (@expr1073754229 tok@var2535 .@expr12406 str (@expr12407 ) !=@expr1073754232 "}" ) {
3554: if (@expr1073754233 Token ::@expr12391 Match (@expr1073754235 tok@var2535 , "{|[|(" ) ) {
3555: tok@var2535 =@expr1073754236 tok@var2535 .@expr1073754237 link (@expr1073754238 ) ; }
3556: if (@expr1073754239 Token ::@expr12391 Match (@expr1073754241 tok@var2535 .@expr1073754242 previous (@expr1073754243 ) , "[,{] . %name% =|{" ) ) {
3557: tok@var2535 =@expr1073754244 tok@var2535 .@expr12421 next (@expr12422 ) ;
3558: const std ::@expr12398 map < std ::@expr12399 string , int > ::@expr1073754249 iterator it@var2538 =@expr1073754250 members@var2537 .@expr1073754251 find (@expr1073754252 tok@var2535 .@expr12406 str (@expr12407 ) ) ;
3559: if (@expr1073754255 it@var2538 ==@expr1073754256 members@var2537 .@expr1073754257 end (@expr1073754258 ) ) {
3560: members@var2537 [@expr1073754259 tok@var2535 .@expr12406 str (@expr12407 ) ] =@expr1073754262 ++@expr1073754263 (@expr12440 *@expr12441 varId@var2534 ) ;
3561: tok@var2535 .@expr12394 varId (@expr12443 *@expr12441 varId@var2534 ) ;
3562: } else {
3563: tok@var2535 .@expr12394 varId (@expr1073754270 it@var2538 .@expr1073754271 second@var2539 ) ;
3564: }
3565: }
3566: tok@var2535 =@expr1073754272 tok@var2535 .@expr12421 next (@expr12422 ) ;
3567: }
3568:
3569: return ;
3570: }
3571:
3572: while (@expr1073754275 Token ::@expr12391 Match (@expr1073754277 tok@var2535 .@expr12421 next (@expr12422 ) , ")| . %name% !!(" ) ) {
3573:
3574: if (@expr1073754280 tok@var2535 .@expr1073754281 strAt (@expr1073754282 1 ) ==@expr1073754283 ")" &&@expr1073754284 (@expr1073754285 tok@var2535 .@expr12462 linkAt (@expr12463 1 ) .@expr1073754288 previous (@expr1073754289 ) .@expr1073754290 isName (@expr1073754291 ) ||@expr1073754292 tok@var2535 .@expr12462 linkAt (@expr12463 1 ) .@expr1073754295 strAt (@expr1073754296 -1 ) ==@expr1073754297 "]" ) &&@expr1073754298
3575: isFunctionHead (@expr1073754299 tok@var2535 .@expr12462 linkAt (@expr12463 1 ) , "{|;" ) ) {
3576: tok@var2535 =@expr1073754302 tok@var2535 .@expr12403 tokAt (@expr12404 3 ) ;
3577: continue ;
3578: }
3579: const int struct_varid@var2540 =@expr1073754305 tok@var2535 .@expr12394 varId (@expr12395 ) ;
3580: tok@var2535 =@expr1073754308 tok@var2535 .@expr12403 tokAt (@expr1073754310 2 ) ;
3581: if (@expr1073754311 struct_varid@var2540 ==@expr1073754312 0 ) {
3582: continue ; }
3583:
3584: if (@expr1073754313 tok@var2535 .@expr12406 str (@expr12407 ) ==@expr1073754316 "." ) {
3585: tok@var2535 =@expr1073754317 tok@var2535 .@expr12421 next (@expr12422 ) ; }
3586:
3587:
3588: if (@expr1073754320 TemplateSimplifier ::@expr1073754321 templateParameters (@expr1073754322 tok@var2535 .@expr12421 next (@expr12422 ) ) >@expr1073754325 0 ) {
3589: break ; }
3590:
3591: std ::@expr12398 map < std ::@expr12399 string , int > & members@var2541 =@expr1073754328 structMembers@var2533 [@expr1073754329 struct_varid@var2540 ] ;
3592: const std ::@expr12398 map < std ::@expr12399 string , int > ::@expr1073754332 iterator it@var2542 =@expr1073754333 members@var2541 .@expr1073754334 find (@expr1073754335 tok@var2535 .@expr12406 str (@expr12407 ) ) ;
3593: if (@expr1073754338 it@var2542 ==@expr1073754339 members@var2541 .@expr1073754340 end (@expr1073754341 ) ) {
3594: members@var2541 [@expr1073754342 tok@var2535 .@expr12406 str (@expr12407 ) ] =@expr1073754345 ++@expr1073754346 (@expr12440 *@expr12441 varId@var2534 ) ;
3595: tok@var2535 .@expr12394 varId (@expr12443 *@expr12441 varId@var2534 ) ;
3596: } else {
3597: tok@var2535 .@expr12394 varId (@expr1073754353 it@var2542 .@expr1073754354 second@var2543 ) ;
3598: }
3599: }
3600:
3601: *@expr12389 tok1@var2532 =@expr1073754356 tok@var2535 ;
3602: }
3603:
3604:
3605: void Tokenizer :: setVarIdClassDeclaration ( const Token * const startToken@var2544 ,
3606: const VariableMap & variableMap@var2545 ,
3607: const int scopeStartVarId@var2546 ,
3608: std :: map < int , std :: map < std :: string , int > > & structMembers@var2547 )
3609: {
3610:
3611: const Token * const endToken@var2548 ; endToken@var2548 =@expr1073754357 startToken@var2544 .@expr1073754358 link (@expr1073754359 ) ;
3612:
3613:
3614: std ::@expr1073754360 string className@var2549 ;
3615: for (@expr1073754361 const Token *@expr12538 tok@var2550 =@expr1073754363 startToken@var2544 .@expr1073754364 previous (@expr1073754365 ) ; tok@var2550 ; tok@var2550 =@expr1073754366 tok@var2550 .@expr1073754367 previous (@expr1073754368 ) ) {
3616: if (@expr1073754369 !@expr1073754370 tok@var2550 .@expr1073754371 isName (@expr1073754372 ) &&@expr1073754373 tok@var2550 .@expr1073754374 str (@expr1073754375 ) !=@expr1073754376 ":" ) {
3617: break ; }
3618: if (@expr1073754377 Token ::@expr12554 Match (@expr1073754379 tok@var2550 , "class|struct|enum %type% [:{]" ) ) {
3619: className@var2549 =@expr1073754380 tok@var2550 .@expr1073754381 next (@expr1073754382 ) .@expr1073754383 str (@expr1073754384 ) ;
3620: break ;
3621: }
3622: }
3623:
3624:
3625: int indentlevel@var2551 ; indentlevel@var2551 =@expr1073754385 0 ;
3626: bool initList@var2552 ; initList@var2552 =@expr1073754386 false ;
3627: bool inEnum@var2553 ; inEnum@var2553 =@expr1073754387 false ;
3628: const Token * initListArgLastToken@var2554 ; initListArgLastToken@var2554 =@expr1073754388 nullptr ;
3629: for (@expr1073754389 Token *@expr12538 tok@var2555 =@expr1073754391 startToken@var2544 .@expr1073754392 next (@expr1073754393 ) ; tok@var2555 !=@expr1073754394 endToken@var2548 ; tok@var2555 =@expr1073754395 tok@var2555 .@expr12572 next (@expr12573 ) ) {
3630: if (@expr1073754398 !@expr1073754399 tok@var2555 ) {
3631: syntaxError (@expr12576 nullptr ) ; }
3632: if (@expr1073754401 initList@var2552 ) {
3633: if (@expr1073754402 tok@var2555 ==@expr1073754403 initListArgLastToken@var2554 ) {
3634: initListArgLastToken@var2554 =@expr1073754404 nullptr ; }
3635: else { if (@expr1073754405 !@expr12582 initListArgLastToken@var2554 &&@expr1073754407
3636: Token ::@expr12554 Match (@expr1073754409 tok@var2555 .@expr12586 previous (@expr12587 ) , "%name%|>|>> {|(" ) &&@expr1073754412
3637: Token ::@expr12554 Match (@expr1073754414 tok@var2555 .@expr12591 link (@expr12592 ) , "}|) ,|{" ) ) {
3638: initListArgLastToken@var2554 =@expr1073754417 tok@var2555 .@expr12591 link (@expr12592 ) ; } }
3639: }
3640: if (@expr1073754420 tok@var2555 .@expr12597 str (@expr12598 ) ==@expr1073754423 "{" ) {
3641: inEnum@var2553 =@expr1073754424 isEnumStart (@expr1073754425 tok@var2555 ) ;
3642: if (@expr1073754426 initList@var2552 &&@expr1073754427 !@expr12582 initListArgLastToken@var2554 ) {
3643: initList@var2552 =@expr1073754429 false ; }
3644: ++@expr1073754430 indentlevel@var2551 ;
3645: } else { if (@expr1073754431 tok@var2555 .@expr12597 str (@expr12598 ) ==@expr1073754434 "}" ) {
3646: --@expr1073754435 indentlevel@var2551 ;
3647: inEnum@var2553 =@expr1073754436 false ;
3648: } else { if (@expr1073754437 initList@var2552 &&@expr1073754438 indentlevel@var2551 ==@expr12615 0 &&@expr1073754440 Token ::@expr12554 Match (@expr1073754442 tok@var2555 .@expr12586 previous (@expr12587 ) , "[,:] %name% [({]" ) ) {
3649: const std ::@expr12621 map < std ::@expr12622 string , int > ::@expr1073754447 const_iterator it@var2556 =@expr1073754448 variableMap@var2545 .@expr12625 find (@expr12626 tok@var2555 .@expr12597 str (@expr12598 ) ) ;
3650: if (@expr1073754453 it@var2556 !=@expr1073754454 variableMap@var2545 .@expr12631 end (@expr12632 ) ) {
3651: tok@var2555 .@expr12633 varId (@expr1073754458 it@var2556 .@expr1073754459 second@var2557 ) ;
3652: }
3653: } else { if (@expr1073754460 tok@var2555 .@expr1073754461 isName (@expr1073754462 ) &&@expr1073754463 tok@var2555 .@expr12633 varId (@expr1073754465 ) <=@expr1073754466 scopeStartVarId@var2546 ) {
3654: if (@expr1073754467 indentlevel@var2551 >@expr1073754468 0 ||@expr1073754469 initList@var2552 ) {
3655: if (@expr1073754470 Token ::@expr12554 Match (@expr1073754472 tok@var2555 .@expr12586 previous (@expr12587 ) , "::|." ) &&@expr1073754475 tok@var2555 .@expr1073754476 strAt (@expr1073754477 -2 ) !=@expr1073754478 "this" &&@expr1073754479 !@expr1073754480 Token ::@expr1073754481 simpleMatch (@expr1073754482 tok@var2555 .@expr12659 tokAt (@expr1073754484 -5 ) , "( * this ) ." ) ) {
3656: continue ; }
3657: if (@expr1073754485 !@expr1073754486 tok@var2555 .@expr12572 next (@expr12573 ) ) {
3658: syntaxError (@expr12576 nullptr ) ; }
3659: if (@expr1073754490 tok@var2555 .@expr12572 next (@expr12573 ) .@expr1073754493 str (@expr1073754494 ) ==@expr1073754495 "::" ) {
3660: if (@expr1073754496 tok@var2555 .@expr12597 str (@expr12598 ) ==@expr1073754499 className@var2549 ) {
3661: tok@var2555 =@expr1073754500 tok@var2555 .@expr12659 tokAt (@expr1073754502 2 ) ; }
3662: else {
3663: continue ; }
3664: }
3665:
3666: if (@expr1073754503 !@expr1073754504 inEnum@var2553 ) {
3667: const std ::@expr12621 map < std ::@expr12622 string , int > ::@expr1073754507 const_iterator it@var2558 =@expr1073754508 variableMap@var2545 .@expr12625 find (@expr12626 tok@var2555 .@expr12597 str (@expr12598 ) ) ;
3668: if (@expr1073754513 it@var2558 !=@expr1073754514 variableMap@var2545 .@expr12631 end (@expr12632 ) ) {
3669: tok@var2555 .@expr12633 varId (@expr1073754518 it@var2558 .@expr1073754519 second@var2559 ) ;
3670: setVarIdStructMembers (@expr1073754520 &@expr1073754521 tok@var2555 , structMembers@var2547 , variableMap@var2545 .@expr1073754522 getVarId (@expr1073754523 ) ) ;
3671: }
3672: }
3673: }
3674: } else { if (@expr1073754524 indentlevel@var2551 ==@expr12615 0 &&@expr1073754526 tok@var2555 .@expr12597 str (@expr12598 ) ==@expr1073754529 ":" &&@expr1073754530 !@expr12582 initListArgLastToken@var2554 ) {
3675: initList@var2552 =@expr1073754532 true ; } } } } }
3676: }
3677: }
3678:
|
3682:
3683: void Tokenizer :: setVarIdClassFunction ( const std :: string & classname@var2560 ,
3684: Token * const startToken@var2561 ,
3685: const Token * const endToken@var2562 ,
3686: const std :: map < std :: string , int > & varlist@var2563 ,
3687: std :: map < int , std :: map < std :: string , int > > & structMembers@var2564 ,
3688: int * varId_@var2565 )
3689: {
3690: for (@expr1073754533 Token *@expr1073754534 tok2@var2566 =@expr1073754535 startToken@var2561 ; tok2@var2566 &&@expr1073754536 tok2@var2566 !=@expr1073754537 endToken@var2562 ; tok2@var2566 =@expr1073754538 tok2@var2566 .@expr1073754539 next (@expr1073754540 ) ) {
3691: if (@expr1073754541 tok2@var2566 .@expr12718 varId (@expr1073754543 ) !=@expr1073754544 0 ||@expr1073754545 !@expr1073754546 tok2@var2566 .@expr1073754547 isName (@expr1073754548 ) ) {
3692: continue ; }
3693: if (@expr1073754549 Token ::@expr12726 Match (@expr1073754551 tok2@var2566 .@expr12728 tokAt (@expr12729 -2 ) , (@expr1073754554 "!!" +@expr1073754555 classname@var2560 +@expr1073754556 " ::" ) .@expr1073754557 c_str (@expr1073754558 ) ) ) {
3694: continue ; }
3695: if (@expr1073754559 Token ::@expr12726 Match (@expr1073754561 tok2@var2566 .@expr12728 tokAt (@expr1073754563 -4 ) , "%name% :: %name% ::" ) ) {
3696: continue ; }
3697: if (@expr1073754564 Token ::@expr12726 Match (@expr1073754566 tok2@var2566 .@expr12728 tokAt (@expr12729 -2 ) , "!!this ." ) &&@expr1073754569 !@expr1073754570 Token ::@expr1073754571 simpleMatch (@expr1073754572 tok2@var2566 .@expr12728 tokAt (@expr1073754574 -5 ) , "( * this ) ." ) ) {
3698: continue ; }
3699: if (@expr1073754575 Token ::@expr12726 Match (@expr1073754577 tok2@var2566 , "%name% ::" ) ) {
3700: continue ; }
3701:
3702: const std ::@expr1073754578 map < std ::@expr1073754579 string , int > ::@expr1073754580 const_iterator it@var2567 =@expr1073754581 varlist@var2563 .@expr1073754582 find (@expr1073754583 tok2@var2566 .@expr1073754584 str (@expr1073754585 ) ) ;
3703: if (@expr1073754586 it@var2567 !=@expr1073754587 varlist@var2563 .@expr1073754588 end (@expr1073754589 ) ) {
3704: tok2@var2566 .@expr12718 varId (@expr1073754591 it@var2567 .@expr1073754592 second@var2568 ) ;
3705: setVarIdStructMembers (@expr1073754593 &@expr1073754594 tok2@var2566 , structMembers@var2564 , varId_@var2565 ) ;
3706: }
3707: }
3708: }
3709:
3710:
3711:
3712: void Tokenizer :: setVarId ( )
3713: {
3714:
3715: for (@expr1073754595 Token *@expr1073754596 tok@var2569 =@expr1073754597 list@var872 .@expr1073754598 front (@expr1073754599 ) ; tok@var2569 ; tok@var2569 =@expr1073754600 tok@var2569 .@expr1073754601 next (@expr1073754602 ) ) {
3716: if (@expr1073754603 tok@var2569 .@expr1073754604 isName (@expr1073754605 ) ) {
3717: tok@var2569 .@expr1073754606 varId (@expr1073754607 0 ) ; }
3718: }
3719:
3720: setPodTypes (@expr1073754608 ) ;
3721:
3722: setVarIdPass1 (@expr1073754609 ) ;
3723:
3724: setVarIdPass2 (@expr1073754610 ) ;
3725: }
3726:
|
3729:
3730: static const std :: unordered_set < std :: string > notstart_c@var2570 = { $"NOT" $, $"case" $, $"default" $, $"goto" $, $"not" $, $"return" $, $"sizeof" $, $"typedef" } ;
3731: static const std :: unordered_set < std :: string > notstart_cpp@var2571 = { $"NOT" $, $"case" $, $"default" $, $"goto" $, $"not" $, $"return" $, $"sizeof" $, $"typedef" ,
3732: "delete" , "friend" , "new" , "throw" , "using" , "virtual" , "explicit" , "const_cast" , "dynamic_cast" , "reinterpret_cast" , "static_cast" , "template"
3733: } ;
3734:
3735: void Tokenizer :: setVarIdPass1 ( )
3736: {
3737:
3738: const std ::@expr1073754612 unordered_set < std ::@expr12789 string > & notstart@var2572 =@expr1073754614 (@expr1073754615 isC (@expr12792 ) ) ?@expr1073754617 notstart_c@var2570 :@expr1073754618 notstart_cpp@var2571 ;
3739:
3740: VariableMap variableMap@var2573 ;
3741: std ::@expr1073754619 map < int , std ::@expr12789 map < std ::@expr12789 string , int > > structMembers@var2574 ;
3742:
3743: std ::@expr1073754622 stack < VarIdScopeInfo > scopeStack@var2575 ;
3744:
3745: scopeStack@var2575 .@expr12799 push (@expr12800 VarIdScopeInfo (@expr12801 ) ) ;
3746: std ::@expr1073754626 stack < const Token *@expr12803 > functionDeclEndStack@var2576 ;
3747: const Token * functionDeclEndToken@var2577 ; functionDeclEndToken@var2577 =@expr1073754628 nullptr ;
3748: bool initlist@var2578 ; initlist@var2578 =@expr1073754629 false ;
3749: bool inlineFunction@var2579 ; inlineFunction@var2579 =@expr1073754630 false ;
3750: for (@expr1073754631 Token *@expr12803 tok@var2580 =@expr1073754633 list@var872 .@expr12810 front (@expr12811 ) ; tok@var2580 ; tok@var2580 =@expr1073754636 tok@var2580 .@expr12813 next (@expr12814 ) ) {
3751: if (@expr1073754639 tok@var2580 .@expr1073754640 isOp (@expr1073754641 ) ) {
3752: continue ; }
3753: if (@expr1073754642 tok@var2580 ==@expr1073754643 functionDeclEndToken@var2577 ) {
3754: functionDeclEndStack@var2576 .@expr1073754644 pop (@expr1073754645 ) ;
3755: functionDeclEndToken@var2577 =@expr1073754646 functionDeclEndStack@var2576 .@expr1073754647 empty (@expr1073754648 ) ?@expr1073754649 nullptr :@expr1073754650 functionDeclEndStack@var2576 .@expr1073754651 top (@expr1073754652 ) ;
3756: if (@expr1073754653 tok@var2580 .@expr12830 str (@expr12831 ) ==@expr12832 ":" ) {
3757: initlist@var2578 =@expr1073754657 true ; }
3758: else { if (@expr1073754658 tok@var2580 .@expr12830 str (@expr12831 ) ==@expr1073754661 ";" ) {
3759: if (@expr1073754662 !@expr1073754663 variableMap@var2573 .@expr12840 leaveScope (@expr12841 ) ) {
3760: cppcheckError (@expr1073754666 tok@var2580 ) ; }
3761: } else { if (@expr12843 tok@var2580 .@expr12830 str (@expr12831 ) ==@expr12846 "{" ) {
3762: scopeStack@var2575 .@expr12799 push (@expr1073754672 VarIdScopeInfo (@expr1073754673 true , scopeStack@var2575 .@expr12850 top (@expr12851 ) .@expr12852 isStructInit@var3611 ||@expr12853 tok@var2580 .@expr12854 strAt (@expr12855 -1 ) ==@expr12856 "=" , false , *@expr12857 variableMap@var2573 .@expr12858 getVarId (@expr12859 ) ) ) ;
3763:
3764:
3765: const Token * ifToken@var2581 ; ifToken@var2581 =@expr1073754684 tok@var2580 .@expr12861 previous (@expr12862 ) ;
3766: if (@expr1073754687 ifToken@var2581 &&@expr1073754688 ifToken@var2581 .@expr12865 str (@expr12866 ) ==@expr1073754691 ")" ) {
3767: ifToken@var2581 =@expr1073754692 ifToken@var2581 .@expr1073754693 link (@expr1073754694 ) ; }
3768: else {
3769: ifToken@var2581 =@expr1073754695 nullptr ; }
3770: if (@expr1073754696 ifToken@var2581 ) {
3771: ifToken@var2581 =@expr1073754697 ifToken@var2581 .@expr1073754698 previous (@expr1073754699 ) ; }
3772: if (@expr1073754700 ifToken@var2581 &&@expr1073754701 ifToken@var2581 .@expr12865 str (@expr12866 ) ==@expr1073754704 "if" ) {
3773:
3774: variableMap@var2573 .@expr12881 enterScope (@expr12882 ) ;
3775: }
3776: } } }
3777: } else { if (@expr1073754707 !@expr12884 initlist@var2578 &&@expr1073754709 tok@var2580 .@expr12830 str (@expr12831 ) ==@expr12888 "(" ) {
3778: const Token * newFunctionDeclEnd@var2582 ; newFunctionDeclEnd@var2582 =@expr1073754713 nullptr ;
3779: if (@expr12890 !@expr12891 scopeStack@var2575 .@expr12850 top (@expr12851 ) .@expr12894 isExecutable@var3612 ) {
3780: newFunctionDeclEnd@var2582 =@expr1073754719 isFunctionHead (@expr1073754720 tok@var2580 , "{:;" ) ; }
3781: else {
3782: const Token * const tokenLinkNext@var2583 ; tokenLinkNext@var2583 =@expr1073754721 tok@var2580 .@expr12898 link (@expr12899 ) .@expr1073754724 next (@expr1073754725 ) ;
3783: if (@expr1073754726 tokenLinkNext@var2583 &&@expr1073754727 tokenLinkNext@var2583 .@expr1073754728 str (@expr1073754729 ) ==@expr1073754730 "{" ) {
3784: newFunctionDeclEnd@var2582 =@expr1073754731 tokenLinkNext@var2583 ; }
3785: }
3786: if (@expr1073754732 newFunctionDeclEnd@var2582 &&@expr1073754733 newFunctionDeclEnd@var2582 !=@expr1073754734 functionDeclEndToken@var2577 ) {
3787: functionDeclEndStack@var2576 .@expr1073754735 push (@expr1073754736 newFunctionDeclEnd@var2582 ) ;
3788: functionDeclEndToken@var2577 =@expr1073754737 newFunctionDeclEnd@var2582 ;
3789: variableMap@var2573 .@expr12881 enterScope (@expr12882 ) ;
3790: }
3791: } else { if (@expr1073754740 Token ::@expr12917 Match (@expr1073754742 tok@var2580 , "{|}" ) ) {
3792: inlineFunction@var2579 =@expr1073754743 false ;
3793:
3794: const Token * const startToken@var2584 ; startToken@var2584 =@expr1073754744 (@expr1073754745 tok@var2580 .@expr12830 str (@expr12831 ) ==@expr12846 "{" ) ?@expr1073754749 tok@var2580 :@expr1073754750 tok@var2580 .@expr12898 link (@expr12899 ) ;
3795:
3796:
3797: if (@expr1073754753 !@expr1073754754 Token ::@expr12917 Match (@expr1073754756 startToken@var2584 .@expr12933 previous (@expr12934 ) , "union|struct|enum {" ) &&@expr1073754759
3798: !@expr1073754760 (@expr1073754761 initlist@var2578 &&@expr1073754762 Token ::@expr12917 Match (@expr1073754764 startToken@var2584 .@expr12933 previous (@expr12934 ) , "%name%|>|>>" ) &&@expr1073754767 Token ::@expr12917 Match (@expr1073754769 startToken@var2584 .@expr1073754770 link (@expr1073754771 ) , "} ,|{" ) ) ) {
3799:
3800: if (@expr12843 tok@var2580 .@expr12830 str (@expr12831 ) ==@expr12846 "{" ) {
3801: bool isExecutable@var2585 ;
3802: const Token * prev@var2586 ; prev@var2586 =@expr1073754776 tok@var2580 .@expr12861 previous (@expr12862 ) ;
3803: while (@expr1073754779 Token ::@expr12917 Match (@expr1073754781 prev@var2586 , "%name%|." ) ) {
3804: prev@var2586 =@expr1073754782 prev@var2586 .@expr1073754783 previous (@expr1073754784 ) ; }
3805: const bool isLambda@var2587 =@expr1073754785 prev@var2586 &&@expr1073754786 prev@var2586 .@expr1073754787 str (@expr1073754788 ) ==@expr1073754789 ")" &&@expr1073754790 Token ::@expr12967 simpleMatch (@expr1073754792 prev@var2586 .@expr1073754793 link (@expr1073754794 ) .@expr1073754795 previous (@expr1073754796 ) , "] (" ) ;
3806: if (@expr1073754797 (@expr1073754798 !@expr1073754799 isLambda@var2587 &&@expr1073754800 (@expr1073754801 tok@var2580 .@expr12854 strAt (@expr12855 -1 ) ==@expr1073754804 ")" ||@expr1073754805 Token ::@expr12917 Match (@expr1073754807 tok@var2580 .@expr12984 tokAt (@expr12985 -2 ) , ") %type%" ) ) ) ||@expr1073754810
3807: (@expr1073754811 initlist@var2578 &&@expr1073754812 tok@var2580 .@expr12854 strAt (@expr12855 -1 ) ==@expr1073754815 "}" ) ) {
3808: isExecutable@var2585 =@expr1073754816 true ;
3809: } else {
3810: isExecutable@var2585 =@expr1073754817 (@expr1073754818 scopeStack@var2575 .@expr12850 top (@expr12851 ) .@expr12894 isExecutable@var3612 ||@expr1073754822 initlist@var2578 ||@expr1073754823 tok@var2580 .@expr12854 strAt (@expr12855 -1 ) ==@expr1073754826 "else" ) &&@expr1073754827
3811: !@expr1073754828 isClassStructUnionEnumStart (@expr1073754829 tok@var2580 ) ;
3812: if (@expr1073754830 !@expr1073754831 (@expr1073754832 scopeStack@var2575 .@expr12850 top (@expr12851 ) .@expr12852 isStructInit@var3611 ||@expr12853 tok@var2580 .@expr12854 strAt (@expr12855 -1 ) ==@expr12856 "=" ) ) {
3813: variableMap@var2573 .@expr12881 enterScope (@expr12882 ) ; }
3814: }
3815: initlist@var2578 =@expr1073754842 false ;
3816: scopeStack@var2575 .@expr12799 push (@expr1073754844 VarIdScopeInfo (@expr1073754845 isExecutable@var2585 , scopeStack@var2575 .@expr12850 top (@expr12851 ) .@expr12852 isStructInit@var3611 ||@expr12853 tok@var2580 .@expr12854 strAt (@expr12855 -1 ) ==@expr12856 "=" , isEnumStart (@expr1073754853 tok@var2580 ) , *@expr12857 variableMap@var2573 .@expr12858 getVarId (@expr12859 ) ) ) ;
3817: } else {
3818: bool isNamespace@var2588 ; isNamespace@var2588 =@expr1073754857 false ;
3819: for (@expr1073754858 const Token *@expr12803 tok1@var2589 =@expr1073754860 tok@var2580 .@expr12898 link (@expr12899 ) .@expr1073754863 previous (@expr1073754864 ) ; tok1@var2589 &&@expr1073754865 tok1@var2589 .@expr1073754866 isName (@expr1073754867 ) ; tok1@var2589 =@expr1073754868 tok1@var2589 .@expr1073754869 previous (@expr1073754870 ) ) {
3820: if (@expr1073754871 tok1@var2589 .@expr1073754872 str (@expr1073754873 ) ==@expr1073754874 "namespace" ) {
3821: isNamespace@var2588 =@expr1073754875 true ;
3822: break ;
3823: }
3824: }
3825:
3826: if (@expr1073754876 !@expr12884 initlist@var2578 &&@expr1073754878 !@expr13055 isC (@expr12792 ) &&@expr1073754881 !@expr12891 scopeStack@var2575 .@expr12850 top (@expr12851 ) .@expr12894 isExecutable@var3612 &&@expr1073754886 tok@var2580 .@expr12898 link (@expr12899 ) &&@expr1073754889 !@expr1073754890 isNamespace@var2588 ) {
3827: setVarIdClassDeclaration (@expr1073754891 tok@var2580 .@expr12898 link (@expr12899 ) ,
3828: variableMap@var2573 ,
3829: scopeStack@var2575 .@expr12850 top (@expr12851 ) .@expr1073754896 startVarid@var3613 ,
3830: structMembers@var2574 ) ;
3831: }
3832:
3833: if (@expr1073754897 !@expr13074 scopeStack@var2575 .@expr12850 top (@expr12851 ) .@expr12852 isStructInit@var3611 ) {
3834: variableMap@var2573 .@expr12840 leaveScope (@expr12841 ) ;
3835:
3836:
3837: const Token * ifToken@var2590 ; ifToken@var2590 =@expr1073754904 startToken@var2584 .@expr12933 previous (@expr12934 ) ;
3838: if (@expr1073754907 ifToken@var2590 &&@expr1073754908 ifToken@var2590 .@expr13085 str (@expr13086 ) ==@expr1073754911 ")" ) {
3839: ifToken@var2590 =@expr1073754912 ifToken@var2590 .@expr1073754913 link (@expr1073754914 ) .@expr1073754915 previous (@expr1073754916 ) ; }
3840: else {
3841: ifToken@var2590 =@expr1073754917 nullptr ; }
3842: if (@expr1073754918 startToken@var2584 .@expr1073754919 strAt (@expr1073754920 -1 ) ==@expr1073754921 "else" ||@expr1073754922 (@expr1073754923 ifToken@var2590 &&@expr1073754924 ifToken@var2590 .@expr13085 str (@expr13086 ) ==@expr1073754927 "if" &&@expr1073754928 tok@var2580 .@expr12854 strAt (@expr1073754930 1 ) !=@expr1073754931 "else" ) ) {
3843:
3844: variableMap@var2573 .@expr12840 leaveScope (@expr12841 ) ;
3845: }
3846: }
3847:
3848: scopeStack@var2575 .@expr1073754934 pop (@expr1073754935 ) ;
3849: if (@expr1073754936 scopeStack@var2575 .@expr1073754937 empty (@expr1073754938 ) ) {
3850: scopeStack@var2575 .@expr12799 push (@expr12800 VarIdScopeInfo (@expr12801 ) ) ;
3851: }
3852: }
3853: }
3854: } } }
3855:
3856: if (@expr1073754942 !@expr13074 scopeStack@var2575 .@expr12850 top (@expr12851 ) .@expr12852 isStructInit@var3611 &&@expr1073754947
3857: (@expr1073754948 tok@var2580 ==@expr1073754949 list@var872 .@expr12810 front (@expr12811 ) ||@expr1073754952
3858: Token ::@expr12917 Match (@expr1073754954 tok@var2580 , "[;{}]" ) ||@expr1073754955
3859: (@expr1073754956 tok@var2580 .@expr12830 str (@expr12831 ) ==@expr12888 "(" &&@expr13136 isFunctionHead (@expr13137 tok@var2580 , "{" ) ) ||@expr1073754962
3860: (@expr1073754963 tok@var2580 .@expr12830 str (@expr12831 ) ==@expr12888 "(" &&@expr1073754967 !@expr12891 scopeStack@var2575 .@expr12850 top (@expr12851 ) .@expr12894 isExecutable@var3612 &&@expr1073754972 isFunctionHead (@expr1073754973 tok@var2580 , ";:" ) ) ||@expr1073754974
3861: (@expr1073754975 tok@var2580 .@expr12830 str (@expr12831 ) ==@expr13154 "," &&@expr1073754979 (@expr1073754980 !@expr12891 scopeStack@var2575 .@expr12850 top (@expr12851 ) .@expr12894 isExecutable@var3612 ||@expr1073754985 inlineFunction@var2579 ) ) ||@expr1073754986
3862: (@expr1073754987 tok@var2580 .@expr13164 isName (@expr13165 ) &&@expr1073754990 endsWith (@expr1073754991 tok@var2580 .@expr12830 str (@expr12831 ) , ':' ) ) ) ) {
3863:
3864:
3865: if (@expr1073754994 Token ::@expr12967 simpleMatch (@expr1073754996 tok@var2580 .@expr12861 previous (@expr12862 ) , "sizeof (" ) ) {
3866: continue ;
3867: }
3868:
3869: if (@expr1073754999 Settings ::@expr1073755000 terminated (@expr1073755001 ) ) {
3870: return ; }
3871:
3872:
3873: const Token * tok2@var2591 ; tok2@var2591 =@expr1073755002 (@expr1073755003 tok@var2580 .@expr13164 isName (@expr13165 ) ) ?@expr1073755006 tok@var2580 :@expr1073755007 tok@var2580 .@expr12813 next (@expr12814 ) ;
3874:
3875:
3876: while (@expr1073755010 tok2@var2591 &&@expr1073755011 endsWith (@expr1073755012 tok2@var2591 .@expr13189 str (@expr13190 ) , ':' ) ) {
3877: tok2@var2591 =@expr1073755015 tok2@var2591 .@expr13192 next (@expr13193 ) ;
3878: }
3879: if (@expr1073755018 !@expr1073755019 tok2@var2591 ) {
3880: break ; }
3881:
3882:
3883: if (@expr1073755020 notstart@var2572 .@expr13197 find (@expr1073755022 tok2@var2591 .@expr13189 str (@expr13190 ) ) !=@expr1073755025 notstart@var2572 .@expr13202 end (@expr13203 ) ) {
3884: continue ; }
3885:
3886: if (@expr1073755028 !@expr13055 isC (@expr12792 ) &&@expr1073755031 Token ::@expr12967 simpleMatch (@expr1073755033 tok2@var2591 , "const new" ) ) {
3887: continue ; }
3888:
3889: bool decl@var2592 ;
3890: if (@expr1073755034 isCPP (@expr13211 ) &&@expr1073755036 mSettings@var879 .@expr1073755037 standards@var3567 .@expr1073755038 cpp@var3568 >=@expr1073755039 Standards ::@expr1073755040 CPP17 &&@expr1073755041 Token ::@expr12917 Match (@expr1073755043 tok@var2580 , "[(;{}] const| auto &|&&| [" ) ) {
3891:
3892: tok2@var2591 =@expr1073755044 Token ::@expr13221 findsimplematch (@expr1073755046 tok@var2580 , "[" ) ;
3893: if (@expr1073755047 (@expr1073755048 Token ::@expr12967 simpleMatch (@expr13226 tok@var2580 .@expr12861 previous (@expr12862 ) , "for (" ) &&@expr1073755053 Token ::@expr12967 simpleMatch (@expr1073755055 tok2@var2591 .@expr13232 link (@expr13233 ) , "] :" ) ) ||@expr1073755058
3894: Token ::@expr12967 simpleMatch (@expr1073755060 tok2@var2591 .@expr13232 link (@expr13233 ) , "] =" ) ) {
3895: while (@expr1073755063 tok2@var2591 &&@expr1073755064 tok2@var2591 .@expr13189 str (@expr13190 ) !=@expr1073755067 "]" ) {
3896: if (@expr1073755068 Token ::@expr12917 Match (@expr1073755070 tok2@var2591 , "%name% [,]]" ) ) {
3897: variableMap@var2573 .@expr13247 addVariable (@expr1073755072 tok2@var2591 .@expr13189 str (@expr13190 ) ) ; }
3898: tok2@var2591 =@expr1073755075 tok2@var2591 .@expr13192 next (@expr13193 ) ;
3899: }
3900: continue ;
3901: }
3902: }
3903:
3904: try {
3905: decl@var2592 =@expr1073755078 setVarIdParseDeclaration (@expr1073755079 &@expr1073755080 tok2@var2591 , variableMap@var2573 .@expr1073755081 map (@expr1073755082 ) , scopeStack@var2575 .@expr12850 top (@expr12851 ) .@expr12894 isExecutable@var3612 , isCPP (@expr13211 ) , isC (@expr12792 ) ) ;
3906: } catch (@expr1073755088 const Token * errTok@var2593 ) {
3907: syntaxError (@expr1073755089 errTok@var2593 ) ;
3908: }
3909: if (@expr13266 decl@var2592 ) {
3910: if (@expr1073755091 isCPP (@expr13211 ) ) {
3911: if (@expr1073755093 Token *@expr12803 declTypeTok@var2594 =@expr1073755095 Token ::@expr13221 findsimplematch (@expr1073755097 tok@var2580 , "decltype (" , tok2@var2591 ) ) {
3912: for (@expr1073755098 Token *@expr12803 declTok@var2595 =@expr1073755100 declTypeTok@var2594 .@expr1073755101 linkAt (@expr1073755102 1 ) ; declTok@var2595 !=@expr1073755103 declTypeTok@var2594 ; declTok@var2595 =@expr1073755104 declTok@var2595 .@expr13281 previous (@expr13282 ) ) {
3913: if (@expr1073755107 declTok@var2595 .@expr1073755108 isName (@expr1073755109 ) &&@expr1073755110 !@expr1073755111 Token ::@expr12917 Match (@expr1073755113 declTok@var2595 .@expr13281 previous (@expr13282 ) , "::|." ) &&@expr1073755116 variableMap@var2573 .@expr13293 hasVariable (@expr1073755118 declTok@var2595 .@expr13295 str (@expr13296 ) ) ) {
3914: declTok@var2595 .@expr1073755121 varId (@expr1073755122 variableMap@var2573 .@expr13299 find (@expr1073755124 declTok@var2595 .@expr13295 str (@expr13296 ) ) .@expr1073755127 second@expr1073754611 ) ; }
3915: }
3916: }
3917: }
3918:
3919: if (@expr1073755128 tok@var2580 .@expr12830 str (@expr12831 ) ==@expr12888 "(" &&@expr13136 isFunctionHead (@expr13137 tok@var2580 , "{" ) &&@expr1073755134 scopeStack@var2575 .@expr12850 top (@expr12851 ) .@expr12894 isExecutable@var3612 ) {
3920: inlineFunction@var2579 =@expr1073755138 true ; }
3921:
3922: const Token * prev2@var2596 ; prev2@var2596 =@expr1073755139 tok2@var2591 .@expr13316 previous (@expr13317 ) ;
3923: if (@expr1073755142 Token ::@expr12917 Match (@expr1073755144 prev2@var2596 , "%type% [;[=,)]" ) &&@expr1073755145 tok2@var2591 .@expr13316 previous (@expr13317 ) .@expr1073755148 str (@expr1073755149 ) !=@expr1073755150 "const" ) {
3924: ; }
3925: else { if (@expr1073755151 Token ::@expr12917 Match (@expr1073755153 prev2@var2596 , "%type% :" ) &&@expr1073755154 tok@var2580 .@expr12854 strAt (@expr12855 -1 ) ==@expr1073755157 "for" ) {
3926: ; }
3927: else { if (@expr1073755158 Token ::@expr12917 Match (@expr1073755160 prev2@var2596 , "%type% ( !!)" ) &&@expr1073755161 Token ::@expr12967 simpleMatch (@expr1073755163 tok2@var2591 .@expr13232 link (@expr13233 ) , ") ;" ) ) {
3928:
3929: if (@expr1073755166 isCPP (@expr13211 ) &&@expr1073755168
3930: prev2@var2596 .@expr1073755169 isOperatorKeyword (@expr1073755170 ) ) {
3931: continue ; }
3932:
3933: const Token * tok3@var2597 ; tok3@var2597 =@expr1073755171 tok2@var2591 .@expr13192 next (@expr13193 ) ;
3934: if (@expr1073755174 !@expr1073755175 tok3@var2597 .@expr1073755176 isStandardType (@expr1073755177 ) &&@expr1073755178 tok3@var2597 .@expr13355 str (@expr13356 ) !=@expr1073755181 "void" &&@expr1073755182 !@expr1073755183 Token ::@expr12917 Match (@expr1073755185 tok3@var2597 , "struct|union|class %type%" ) &&@expr1073755186 tok3@var2597 .@expr13355 str (@expr13356 ) !=@expr1073755189 "." &&@expr1073755190 !@expr1073755191 Token ::@expr12917 Match (@expr1073755193 tok2@var2591 .@expr13232 link (@expr13233 ) .@expr1073755196 previous (@expr1073755197 ) , "[&*]" ) ) {
3935: if (@expr12890 !@expr12891 scopeStack@var2575 .@expr12850 top (@expr12851 ) .@expr12894 isExecutable@var3612 ) {
3936:
3937: decl@var2592 =@expr1073755203 false ;
3938: bool rhs@var2598 ; rhs@var2598 =@expr1073755204 false ;
3939: for (@expr1073755205 ; tok3@var2597 ; tok3@var2597 =@expr1073755206 tok3@var2597 .@expr1073755207 nextArgumentBeforeCreateLinks2 (@expr1073755208 ) ) {
3940: if (@expr1073755209 tok3@var2597 .@expr13355 str (@expr13356 ) ==@expr1073755212 "=" ) {
3941: rhs@var2598 =@expr1073755213 true ;
3942: continue ;
3943: }
3944:
3945: if (@expr1073755214 tok3@var2597 .@expr13355 str (@expr13356 ) ==@expr1073755217 "," ) {
3946: rhs@var2598 =@expr1073755218 false ;
3947: continue ;
3948: }
3949:
3950: if (@expr1073755219 rhs@var2598 ) {
3951: continue ; }
3952:
3953: if (@expr1073755220 tok3@var2597 .@expr1073755221 isLiteral (@expr1073755222 ) ||@expr1073755223
3954: (@expr1073755224 tok3@var2597 .@expr1073755225 isName (@expr1073755226 ) &&@expr1073755227 variableMap@var2573 .@expr13293 hasVariable (@expr1073755229 tok3@var2597 .@expr13355 str (@expr13356 ) ) ) ||@expr1073755232
3955: tok3@var2597 .@expr1073755233 isOp (@expr1073755234 ) ||@expr1073755235
3956: tok3@var2597 .@expr13355 str (@expr13356 ) ==@expr1073755238 "(" ||@expr1073755239
3957: notstart@var2572 .@expr13197 find (@expr1073755241 tok3@var2597 .@expr13355 str (@expr13356 ) ) !=@expr1073755244 notstart@var2572 .@expr13202 end (@expr13203 ) ) {
3958: decl@var2592 =@expr1073755247 true ;
3959: break ;
3960: }
3961: }
3962: }
3963: } else {
3964: decl@var2592 =@expr1073755248 false ; }
3965: } else { if (@expr1073755249 isCPP (@expr13211 ) &&@expr1073755251 Token ::@expr12917 Match (@expr1073755253 prev2@var2596 , "%type% {" ) &&@expr1073755254 Token ::@expr12967 simpleMatch (@expr1073755256 tok2@var2591 .@expr13232 link (@expr13233 ) , "} ;" ) ) {
3966: if (@expr1073755259 tok2@var2591 .@expr13232 link (@expr13233 ) !=@expr1073755262 tok2@var2591 .@expr13192 next (@expr13193 ) &&@expr1073755265
3967: (@expr1073755266 Token ::@expr12917 Match (@expr1073755268 prev2@var2596 , "do|try|else" ) ||@expr1073755269 Token ::@expr12917 Match (@expr1073755271 prev2@var2596 .@expr1073755272 tokAt (@expr1073755273 -2 ) , "struct|class|:" ) ) ) {
3968: continue ; }
3969: } else {
3970: decl@var2592 =@expr1073755274 false ; } } } }
3971:
3972: if (@expr13266 decl@var2592 ) {
3973: variableMap@var2573 .@expr13247 addVariable (@expr1073755277 prev2@var2596 .@expr1073755278 str (@expr1073755279 ) ) ;
3974:
3975: if (@expr1073755280 Token ::@expr12967 simpleMatch (@expr13226 tok@var2580 .@expr12861 previous (@expr12862 ) , "for (" ) &&@expr1073755285 Token ::@expr12917 Match (@expr1073755287 prev2@var2596 , "%name% [=,]" ) ) {
3976: for (@expr1073755288 const Token *@expr12803 tok3@var2599 =@expr1073755290 prev2@var2596 .@expr1073755291 next (@expr1073755292 ) ; tok3@var2599 &&@expr1073755293 tok3@var2599 .@expr1073755294 str (@expr1073755295 ) !=@expr1073755296 ";" ; tok3@var2599 =@expr1073755297 tok3@var2599 .@expr13474 next (@expr13475 ) ) {
3977: if (@expr1073755300 Token ::@expr12917 Match (@expr1073755302 tok3@var2599 , "[([]" ) ) {
3978: tok3@var2599 =@expr1073755303 tok3@var2599 .@expr1073755304 link (@expr1073755305 ) ; }
3979: if (@expr1073755306 Token ::@expr12917 Match (@expr1073755308 tok3@var2599 , ", %name% [,=;]" ) ) {
3980: variableMap@var2573 .@expr13247 addVariable (@expr1073755310 tok3@var2599 .@expr13474 next (@expr13475 ) .@expr1073755313 str (@expr1073755314 ) ) ; }
3981: }
3982: }
3983:
3984:
3985: tok@var2580 =@expr1073755315 tok@var2580 .@expr12813 next (@expr12814 ) ;
3986: while (@expr1073755318 Token ::@expr12917 Match (@expr1073755320 tok@var2580 , "%name%|::" ) ) {
3987: tok@var2580 =@expr1073755321 tok@var2580 .@expr12813 next (@expr12814 ) ; }
3988: if (@expr1073755324 tok@var2580 &&@expr1073755325 tok@var2580 .@expr12830 str (@expr12831 ) ==@expr1073755328 "<" ) {
3989: const Token * end@var2600 ; end@var2600 =@expr1073755329 tok@var2580 .@expr1073755330 findClosingBracket (@expr1073755331 ) ;
3990: while (@expr1073755332 tok@var2580 !=@expr1073755333 end@var2600 ) {
3991: if (@expr1073755334 tok@var2580 .@expr13164 isName (@expr13165 ) &&@expr1073755337 !@expr1073755338 (@expr1073755339 Token ::@expr12967 simpleMatch (@expr1073755341 tok@var2580 .@expr12813 next (@expr12814 ) , "<" ) &&@expr1073755344
3992: Token ::@expr12917 Match (@expr1073755346 tok@var2580 .@expr12984 tokAt (@expr1073755348 -1 ) , ":: %name%" ) ) ) {
3993: const std ::@expr13525 map < std ::@expr12789 string , int > ::@expr1073755351 const_iterator it@var2601 =@expr1073755352 variableMap@var2573 .@expr13299 find (@expr13530 tok@var2580 .@expr12830 str (@expr12831 ) ) ;
3994: if (@expr1073755357 it@var2601 !=@expr1073755358 variableMap@var2573 .@expr13535 end (@expr13536 ) ) {
3995: tok@var2580 .@expr13537 varId (@expr1073755362 it@var2601 .@expr1073755363 second@var2602 ) ; }
3996: }
3997: tok@var2580 =@expr1073755364 tok@var2580 .@expr12813 next (@expr12814 ) ;
3998: }
3999: }
4000:
4001: tok@var2580 =@expr1073755367 tok2@var2591 .@expr13316 previous (@expr13317 ) ;
4002: }
4003: }
4004: }
4005:
4006: if (@expr1073755370 tok@var2580 .@expr13164 isName (@expr13165 ) ) {
4007:
4008: if (@expr1073755373 Token ::@expr12917 Match (@expr1073755375 tok@var2580 .@expr12861 previous (@expr12862 ) , "struct|enum|union" ) ||@expr1073755378 (@expr1073755379 isCPP (@expr13211 ) &&@expr1073755381 tok@var2580 .@expr12854 strAt (@expr12855 -1 ) ==@expr1073755384 "class" ) ) {
4009: continue ; }
4010:
4011: if (@expr1073755385 !@expr13055 isC (@expr12792 ) ) {
4012: if (@expr1073755388 tok@var2580 .@expr12861 previous (@expr12862 ) &&@expr1073755391 tok@var2580 .@expr12861 previous (@expr12862 ) .@expr1073755394 str (@expr1073755395 ) ==@expr1073755396 "::" ) {
4013: continue ; }
4014: if (@expr1073755397 tok@var2580 .@expr12813 next (@expr12814 ) &&@expr1073755400 tok@var2580 .@expr12813 next (@expr12814 ) .@expr1073755403 str (@expr1073755404 ) ==@expr1073755405 "::" ) {
4015: continue ; }
4016: if (@expr1073755406 Token ::@expr12967 simpleMatch (@expr1073755408 tok@var2580 .@expr12984 tokAt (@expr12985 -2 ) , ":: template" ) ) {
4017: continue ; }
4018: }
4019:
4020:
4021: if (@expr1073755411 scopeStack@var2575 .@expr12850 top (@expr12851 ) .@expr12894 isExecutable@var3612 &&@expr1073755415 Token ::@expr12917 Match (@expr1073755417 tok@var2580 , "%name% [,)]" ) ) {
4022: bool par@var2603 ; par@var2603 =@expr1073755418 false ;
4023: const Token * start@var2604 ; const Token * end@var2605 ;
4024:
4025:
4026: for (@expr1073755419 start@var2604 =@expr1073755420 tok@var2580 ; Token ::@expr12917 Match (@expr1073755422 start@var2604 , "%name%|*|&|,|(" ) ; start@var2604 =@expr1073755423 start@var2604 .@expr1073755424 previous (@expr1073755425 ) ) {
4027: if (@expr1073755426 start@var2604 .@expr1073755427 str (@expr1073755428 ) ==@expr1073755429 "(" ) {
4028: if (@expr1073755430 par@var2603 ) {
4029: break ; }
4030: par@var2603 =@expr1073755431 true ;
4031: }
4032: if (@expr1073755432 Token ::@expr12917 Match (@expr1073755434 start@var2604 , "[(,]" ) ) {
4033: if (@expr1073755435 !@expr1073755436 Token ::@expr12917 Match (@expr1073755438 start@var2604 , "[(,] %type% %name%|*|&" ) ) {
4034: break ; }
4035: }
4036: if (@expr1073755439 start@var2604 .@expr1073755440 varId (@expr1073755441 ) >@expr1073755442 0 ) {
4037: break ; }
4038: }
4039:
4040:
4041: for (@expr1073755443 end@var2605 =@expr1073755444 tok@var2580 .@expr12813 next (@expr12814 ) ; Token ::@expr12917 Match (@expr1073755448 end@var2605 , "%name%|*|&|," ) ; end@var2605 =@expr1073755449 end@var2605 .@expr1073755450 next (@expr1073755451 ) ) { }
4042:
4043:
4044: const bool isNotstartKeyword@var2606 =@expr1073755452 start@var2604 .@expr13629 next (@expr13630 ) &&@expr1073755455 notstart@var2572 .@expr13197 find (@expr1073755457 start@var2604 .@expr13629 next (@expr13630 ) .@expr1073755460 str (@expr1073755461 ) ) !=@expr1073755462 notstart@var2572 .@expr13202 end (@expr13203 ) ;
4045:
4046:
4047: if (@expr1073755465 Token ::@expr12917 Match (@expr1073755467 start@var2604 , "[;{}] %type% %name%|*" ) &&@expr1073755468 par@var2603 &&@expr1073755469 Token ::@expr12967 simpleMatch (@expr1073755471 end@var2605 , ") ;" ) &&@expr1073755472 !@expr1073755473 isNotstartKeyword@var2606 ) {
4048:
4049: continue ; }
4050: }
4051:
4052: if (@expr1073755474 !@expr1073755475 scopeStack@var2575 .@expr12850 top (@expr12851 ) .@expr1073755478 isEnum@var3614 ||@expr1073755479 !@expr1073755480 (@expr1073755481 Token ::@expr12917 Match (@expr1073755483 tok@var2580 .@expr12861 previous (@expr12862 ) , "{|," ) &&@expr1073755486 Token ::@expr12917 Match (@expr1073755488 tok@var2580 .@expr12813 next (@expr12814 ) , ",|=|}" ) ) ) {
4053: const std ::@expr13525 map < std ::@expr12789 string , int > ::@expr1073755493 const_iterator it@var2607 =@expr1073755494 variableMap@var2573 .@expr13299 find (@expr13530 tok@var2580 .@expr12830 str (@expr12831 ) ) ;
4054: if (@expr1073755499 it@var2607 !=@expr1073755500 variableMap@var2573 .@expr13535 end (@expr13536 ) ) {
4055: tok@var2580 .@expr13537 varId (@expr1073755504 it@var2607 .@expr1073755505 second@var2608 ) ;
4056: setVarIdStructMembers (@expr1073755506 &@expr1073755507 tok@var2580 , structMembers@var2574 , variableMap@var2573 .@expr12858 getVarId (@expr12859 ) ) ;
4057: }
4058: }
4059: } else { if (@expr1073755510 Token ::@expr12917 Match (@expr1073755512 tok@var2580 , "::|. %name%" ) ) {
4060:
4061: tok@var2580 =@expr1073755513 tok@var2580 .@expr12813 next (@expr12814 ) ;
4062: } else { if (@expr1073755516 tok@var2580 .@expr12830 str (@expr12831 ) ==@expr12832 ":" &&@expr1073755520 Token ::@expr12917 Match (@expr1073755522 tok@var2580 .@expr12984 tokAt (@expr12985 -2 ) , "class %type%" ) ) {
4063: do {
4064: tok@var2580 =@expr1073755525 tok@var2580 .@expr12813 next (@expr12814 ) ;
4065: } while (@expr1073755528 tok@var2580 &&@expr1073755529 (@expr1073755530 tok@var2580 .@expr13164 isName (@expr13165 ) ||@expr1073755533 tok@var2580 .@expr12830 str (@expr12831 ) ==@expr13154 "," ) ) ;
4066: if (@expr1073755537 !@expr1073755538 tok@var2580 ) {
4067: break ; }
4068: tok@var2580 =@expr1073755539 tok@var2580 .@expr12861 previous (@expr12862 ) ;
4069: } } }
4070: }
4071:
4072: mVarId@var891 =@expr1073755542 *@expr12857 variableMap@var2573 .@expr12858 getVarId (@expr12859 ) ;
4073: }
4074:
4075: namespace {
4076: struct Member {
4077: Member ( const std :: list < std :: string > & s@var2609 , const std :: list < const Token * > & ns@var2610 , Token * t@var2611 ) : usingnamespaces@var2612 ( ns@var2610 ) , scope@var2613 ( s@var2609 ) , tok@var2614 ( t@var2611 ) { }
4078: std :: list < const Token * > usingnamespaces@var2612 ;
4079: std :: list < std :: string > scope@var2613 ;
4080: Token * tok@var2614 ;
4081: } ;
4082: }
4083:
4084: static std :: string getScopeName ( const std :: list < ScopeInfo2 > & scopeInfo@var2615 )
4085: {
4086: std ::@expr1073755546 string ret@var2616 ;
4087: for (@expr1073755547 const ScopeInfo2 &@expr1073755548 si@var2617 :@expr1073755549 scopeInfo@var2615 ) {
4088: ret@var2616 +=@expr1073755550 (@expr1073755551 ret@var2616 .@expr1073755552 empty (@expr1073755553 ) ?@expr1073755554 "" :@expr1073755555 " :: " ) +@expr1073755556 (@expr1073755557 si@var2617 .@expr1073755558 name@var2618 ) ; }
4089: return ret@var2616 ;
4090: }
4091:
4092: static Token * matchMemberName ( const std :: list < std :: string > & scope@var2619 , const Token * nsToken@var2620 , Token * memberToken@var2621 , const std :: list < ScopeInfo2 > & scopeInfo@var2622 )
4093: {
4094: std ::@expr1073755559 list < ScopeInfo2 > ::@expr1073755560 const_iterator scopeIt@var2623 ; scopeIt@var2623 =@expr1073755561 scopeInfo@var2622 .@expr1073755562 begin (@expr1073755563 ) ;
4095:
4096:
4097: for (@expr1073755564 std ::@expr13741 list < std ::@expr13741 string > ::@expr13741 const_iterator it@var2624 =@expr1073755568 scope@var2619 .@expr1073755569 begin (@expr1073755570 ) ; it@var2624 !=@expr1073755571 scope@var2619 .@expr1073755572 end (@expr1073755573 ) ; ++@expr1073755574 it@var2624 ) {
4098: if (@expr1073755575 scopeIt@var2623 ==@expr13752 scopeInfo@var2622 .@expr13753 end (@expr13754 ) ||@expr1073755579 scopeIt@var2623 .@expr13756 name@var2625 !=@expr1073755581 *@expr1073755582 it@var2624 ) {
4099: return nullptr ; }
4100: ++@expr1073755583 scopeIt@var2623 ;
4101: }
4102:
4103:
4104: if (@expr1073755584 nsToken@var2620 ) {
4105: while (@expr1073755585 Token ::@expr13762 Match (@expr1073755587 nsToken@var2620 , "%name% ::" ) ) {
4106: if (@expr1073755588 scopeIt@var2623 !=@expr13765 scopeInfo@var2622 .@expr13753 end (@expr13754 ) &&@expr1073755592 nsToken@var2620 .@expr13769 str (@expr13770 ) ==@expr1073755595 scopeIt@var2623 .@expr13756 name@var2625 ) {
4107: nsToken@var2620 =@expr1073755597 nsToken@var2620 .@expr1073755598 tokAt (@expr1073755599 2 ) ;
4108: ++@expr1073755600 scopeIt@var2623 ;
4109: } else {
4110: return nullptr ;
4111: }
4112: }
4113: if (@expr1073755601 !@expr1073755602 Token ::@expr13762 Match (@expr1073755604 nsToken@var2620 , "%name% ;" ) ) {
4114: return nullptr ; }
4115: if (@expr1073755605 scopeIt@var2623 ==@expr13752 scopeInfo@var2622 .@expr13753 end (@expr13754 ) ||@expr1073755609 nsToken@var2620 .@expr13769 str (@expr13770 ) !=@expr1073755612 scopeIt@var2623 .@expr13756 name@var2625 ) {
4116: return nullptr ; }
4117: ++@expr1073755614 scopeIt@var2623 ;
4118: }
4119:
4120:
4121: while (@expr1073755615 scopeIt@var2623 !=@expr13765 scopeInfo@var2622 .@expr13753 end (@expr13754 ) ) {
4122: if (@expr1073755619 !@expr1073755620 Token ::@expr13762 Match (@expr1073755622 memberToken@var2621 , "%name% ::|<" ) ) {
4123: return nullptr ; }
4124: if (@expr1073755623 memberToken@var2621 .@expr1073755624 str (@expr1073755625 ) !=@expr1073755626 scopeIt@var2623 .@expr13756 name@var2625 ) {
4125: return nullptr ; }
4126: if (@expr1073755628 memberToken@var2621 .@expr13805 next (@expr13806 ) .@expr1073755631 str (@expr1073755632 ) ==@expr1073755633 "<" ) {
4127: memberToken@var2621 =@expr1073755634 memberToken@var2621 .@expr13805 next (@expr13806 ) .@expr1073755637 findClosingBracket (@expr1073755638 ) ;
4128: if (@expr1073755639 !@expr1073755640 Token ::@expr1073755641 simpleMatch (@expr1073755642 memberToken@var2621 , "> ::" ) ) {
4129: return nullptr ; }
4130: }
4131: memberToken@var2621 =@expr1073755643 memberToken@var2621 .@expr1073755644 tokAt (@expr1073755645 2 ) ;
4132: ++@expr1073755646 scopeIt@var2623 ;
4133: }
4134:
4135: return Token ::@expr13762 Match (@expr1073755648 memberToken@var2621 , "~| %name%" ) ?@expr1073755649 memberToken@var2621 :@expr1073755650 nullptr ;
4136: }
4137:
4138: static Token * matchMemberName ( const Member & member@var2626 , const std :: list < ScopeInfo2 > & scopeInfo@var2627 )
4139: {
4140: if (@expr1073755651 scopeInfo@var2627 .@expr1073755652 empty (@expr1073755653 ) ) {
4141: return nullptr ; }
4142:
4143:
4144: Token * ret@var2628 ; ret@var2628 =@expr1073755654 matchMemberName (@expr1073755655 member@var2626 .@expr13832 scope@var2629 , nullptr , member@var2626 .@expr13833 tok@var2630 , scopeInfo@var2627 ) ;
4145: if (@expr13834 ret@var2628 ) {
4146: return ret@var2628 ; }
4147:
4148:
4149: for (@expr1073755659 const Token *@expr1073755660 ns@var2631 :@expr1073755661 member@var2626 .@expr1073755662 usingnamespaces@var2632 ) {
4150: ret@var2628 =@expr1073755663 matchMemberName (@expr1073755664 member@var2626 .@expr13832 scope@var2629 , ns@var2631 , member@var2626 .@expr13833 tok@var2630 , scopeInfo@var2627 ) ;
4151: if (@expr13834 ret@var2628 ) {
4152: return ret@var2628 ; }
4153: }
4154:
4155: return nullptr ;
4156: }
4157:
4158: static Token * matchMemberVarName ( const Member & var@var2633 , const std :: list < ScopeInfo2 > & scopeInfo@var2634 )
4159: {
4160: Token * tok@var2635 ; tok@var2635 =@expr1073755668 matchMemberName (@expr1073755669 var@var2633 , scopeInfo@var2634 ) ;
4161: return Token ::@expr1073755670 Match (@expr1073755671 tok@var2635 , "%name% !!(" ) ?@expr1073755672 tok@var2635 :@expr1073755673 nullptr ;
4162: }
4163:
4164: static Token * matchMemberFunctionName ( const Member & func@var2636 , const std :: list < ScopeInfo2 > & scopeInfo@var2637 )
4165: {
4166: Token * tok@var2638 ; tok@var2638 =@expr1073755674 matchMemberName (@expr1073755675 func@var2636 , scopeInfo@var2637 ) ;
4167: return Token ::@expr1073755676 Match (@expr1073755677 tok@var2638 , "~| %name% (" ) ?@expr1073755678 tok@var2638 :@expr1073755679 nullptr ;
4168: }
4169:
4170: void Tokenizer :: setVarIdPass2 ( )
4171: {
4172: std ::@expr1073755681 map < int , std ::@expr13858 map < std ::@expr13858 string , int > > structMembers@var2639 ;
4173:
4174:
4175: std ::@expr1073755684 list < Member > allMemberFunctions@var2640 ;
4176: std ::@expr1073755685 list < Member > allMemberVars@var2641 ;
4177: if (@expr1073755686 !@expr1073755687 isC (@expr13864 ) ) {
4178: std ::@expr1073755689 map < const Token *@expr13866 , std ::@expr13858 string > endOfScope@var2642 ;
4179: std ::@expr1073755692 list < std ::@expr13858 string > scope@var2643 ;
4180: std ::@expr1073755694 list < const Token *@expr13866 > usingnamespaces@var2644 ;
4181: for (@expr1073755696 Token *@expr13866 tok@var2645 =@expr1073755698 list@var872 .@expr13875 front (@expr13876 ) ; tok@var2645 ; tok@var2645 =@expr1073755701 tok@var2645 .@expr13878 next (@expr13879 ) ) {
4182: if (@expr1073755704 !@expr1073755705 tok@var2645 .@expr13882 previous (@expr13883 ) ||@expr1073755708 Token ::@expr13885 Match (@expr1073755710 tok@var2645 .@expr13882 previous (@expr13883 ) , "[;{}]" ) ) {
4183: if (@expr1073755713 Token ::@expr13885 Match (@expr1073755715 tok@var2645 , "using namespace %name% ::|;" ) ) {
4184: Token * endtok@var2646 ; endtok@var2646 =@expr1073755716 tok@var2645 .@expr13893 tokAt (@expr13894 2 ) ;
4185: while (@expr1073755719 Token ::@expr13885 Match (@expr1073755721 endtok@var2646 , "%name% ::" ) ) {
4186: endtok@var2646 =@expr1073755722 endtok@var2646 .@expr1073755723 tokAt (@expr1073755724 2 ) ; }
4187: if (@expr1073755725 Token ::@expr13885 Match (@expr1073755727 endtok@var2646 , "%name% ;" ) ) {
4188: usingnamespaces@var2644 .@expr1073755728 push_back (@expr1073755729 tok@var2645 .@expr13893 tokAt (@expr13894 2 ) ) ; }
4189: tok@var2645 =@expr1073755732 endtok@var2646 ;
4190: continue ;
4191: } else { if (@expr1073755733 Token ::@expr13885 Match (@expr1073755735 tok@var2645 , "namespace %name% {" ) ) {
4192: scope@var2643 .@expr1073755736 push_back (@expr1073755737 tok@var2645 .@expr13914 strAt (@expr13915 1 ) ) ;
4193: endOfScope@var2642 [@expr1073755740 tok@var2645 .@expr1073755741 linkAt (@expr1073755742 2 ) ] =@expr1073755743 tok@var2645 .@expr13914 strAt (@expr13915 1 ) ;
4194: } }
4195: }
4196:
4197: if (@expr1073755746 tok@var2645 .@expr13923 str (@expr13924 ) ==@expr1073755749 "}" ) {
4198: const std ::@expr1073755750 map < const Token *@expr13866 , std ::@expr13858 string > ::@expr1073755753 iterator it@var2647 =@expr1073755754 endOfScope@var2642 .@expr1073755755 find (@expr1073755756 tok@var2645 ) ;
4199: if (@expr1073755757 it@var2647 !=@expr1073755758 endOfScope@var2642 .@expr1073755759 end (@expr1073755760 ) ) {
4200: scope@var2643 .@expr1073755761 remove (@expr1073755762 it@var2647 .@expr1073755763 second@var2648 ) ; }
4201: }
4202:
4203: Token * const tok1@var2649 ; tok1@var2649 =@expr1073755764 tok@var2645 ;
4204: if (@expr1073755765 Token ::@expr13885 Match (@expr1073755767 tok@var2645 .@expr13882 previous (@expr13883 ) , "!!:: %name% :: ~| %name%" ) ) {
4205: tok@var2645 =@expr1073755770 tok@var2645 .@expr13878 next (@expr13879 ) ; }
4206: else { if (@expr1073755773 Token ::@expr13885 Match (@expr1073755775 tok@var2645 .@expr13882 previous (@expr13883 ) , "!!:: %name% <" ) &&@expr1073755778 Token ::@expr13885 Match (@expr13956 tok@var2645 .@expr13878 next (@expr13879 ) .@expr13959 findClosingBracket (@expr13960 ) , "> :: ~| %name%" ) ) {
4207: tok@var2645 =@expr1073755785 tok@var2645 .@expr13878 next (@expr13879 ) .@expr13959 findClosingBracket (@expr13960 ) .@expr13966 next (@expr13967 ) ; }
4208: else { if (@expr1073755792 usingnamespaces@var2644 .@expr1073755793 empty (@expr1073755794 ) ||@expr1073755795 tok@var2645 .@expr1073755796 varId (@expr1073755797 ) ||@expr1073755798 !@expr1073755799 tok@var2645 .@expr1073755800 isName (@expr1073755801 ) ||@expr1073755802 tok@var2645 .@expr1073755803 isStandardType (@expr1073755804 ) ||@expr1073755805 tok@var2645 .@expr13982 tokType (@expr13983 ) ==@expr1073755808 Token ::@expr1073755809 eKeyword ||@expr1073755810 tok@var2645 .@expr13982 tokType (@expr13983 ) ==@expr1073755813 Token ::@expr1073755814 eBoolean ||@expr1073755815
4209: Token ::@expr13885 Match (@expr1073755817 tok@var2645 .@expr13882 previous (@expr13883 ) , ".|namespace|class|struct|&|&&|*|> %name%" ) ||@expr1073755820 Token ::@expr13885 Match (@expr1073755822 tok@var2645 .@expr13882 previous (@expr13883 ) , "%type%| %name% ( %type%|)" ) ||@expr1073755825 Token ::@expr13885 Match (@expr1073755827 tok@var2645 , "public:|private:|protected:" ) ||@expr1073755828
4210: (@expr1073755829 !@expr14006 tok@var2645 .@expr13878 next (@expr13879 ) &&@expr1073755833 Token ::@expr13885 Match (@expr1073755835 tok@var2645 .@expr13882 previous (@expr13883 ) , "}|; %name%" ) ) ) {
4211: continue ; } } }
4212:
4213: while (@expr1073755838 Token ::@expr13885 Match (@expr1073755840 tok@var2645 , ":: ~| %name%" ) ) {
4214: tok@var2645 =@expr1073755841 tok@var2645 .@expr13878 next (@expr13879 ) ;
4215: if (@expr1073755844 tok@var2645 .@expr13923 str (@expr13924 ) ==@expr1073755847 "~" ) {
4216: tok@var2645 =@expr1073755848 tok@var2645 .@expr13878 next (@expr13879 ) ; }
4217: else { if (@expr1073755851 Token ::@expr13885 Match (@expr1073755853 tok@var2645 , "%name% <" ) &&@expr1073755854 Token ::@expr13885 Match (@expr13956 tok@var2645 .@expr13878 next (@expr13879 ) .@expr13959 findClosingBracket (@expr13960 ) , "> :: ~| %name%" ) ) {
4218: tok@var2645 =@expr1073755861 tok@var2645 .@expr13878 next (@expr13879 ) .@expr13959 findClosingBracket (@expr13960 ) .@expr13966 next (@expr13967 ) ; }
4219: else { if (@expr1073755868 Token ::@expr13885 Match (@expr1073755870 tok@var2645 , "%name% ::" ) ) {
4220: tok@var2645 =@expr1073755871 tok@var2645 .@expr13878 next (@expr13879 ) ; }
4221: else {
4222: break ; } } }
4223: }
4224: if (@expr1073755874 !@expr14006 tok@var2645 .@expr13878 next (@expr13879 ) ) {
4225: syntaxError (@expr1073755878 tok@var2645 ) ; }
4226: if (@expr1073755879 Token ::@expr13885 Match (@expr1073755881 tok@var2645 , "%name% (" ) ) {
4227: allMemberFunctions@var2640 .@expr1073755882 emplace_back (@expr1073755883 scope@var2643 , usingnamespaces@var2644 , tok1@var2649 ) ; }
4228: else {
4229: allMemberVars@var2641 .@expr1073755884 emplace_back (@expr1073755885 scope@var2643 , usingnamespaces@var2644 , tok1@var2649 ) ; }
4230: }
4231: }
4232:
4233: std ::@expr1073755886 list < ScopeInfo2 > scopeInfo@var2650 ;
4234:
4235:
4236: std ::@expr1073755887 map < std ::@expr13858 string , std ::@expr13858 map < std ::@expr13858 string , int > > varsByClass@var2651 ;
4237: for (@expr1073755891 Token *@expr13866 tok@var2652 =@expr1073755893 list@var872 .@expr13875 front (@expr13876 ) ; tok@var2652 ; tok@var2652 =@expr1073755896 tok@var2652 .@expr14073 next (@expr14074 ) ) {
4238: while (@expr1073755899 tok@var2652 .@expr14076 str (@expr14077 ) ==@expr1073755902 "}" &&@expr1073755903 !@expr1073755904 scopeInfo@var2650 .@expr1073755905 empty (@expr1073755906 ) &&@expr1073755907 tok@var2652 ==@expr1073755908 scopeInfo@var2650 .@expr1073755909 back (@expr1073755910 ) .@expr1073755911 bodyEnd@var3615 ) {
4239: scopeInfo@var2650 .@expr1073755912 pop_back (@expr1073755913 ) ; }
4240:
4241: if (@expr1073755914 !@expr1073755915 Token ::@expr13885 Match (@expr1073755917 tok@var2652 , "namespace|class|struct %name% {|:|::|<" ) ) {
4242: continue ; }
4243:
4244: const std ::@expr14094 string & scopeName@var2653 (@expr1073755919 getScopeName (@expr1073755920 scopeInfo@var2650 ) ) ;
4245: const std ::@expr1073755921 string scopeName2@var2654 (@expr1073755922 scopeName@var2653 .@expr1073755923 empty (@expr1073755924 ) ?@expr1073755925 std ::@expr14094 string (@expr1073755927 ) :@expr1073755928 (@expr1073755929 scopeName@var2653 +@expr1073755930 " :: " ) ) ;
4246:
4247: std ::@expr1073755931 list < const Token *@expr13866 > classnameTokens@var2655 ;
4248: classnameTokens@var2655 .@expr14109 push_back (@expr1073755934 tok@var2652 .@expr14073 next (@expr14074 ) ) ;
4249: const Token * tokStart@var2656 ; tokStart@var2656 =@expr1073755937 tok@var2652 .@expr1073755938 tokAt (@expr1073755939 2 ) ;
4250: while (@expr1073755940 Token ::@expr13885 Match (@expr1073755942 tokStart@var2656 , ":: %name%" ) ||@expr1073755943 tokStart@var2656 .@expr14120 str (@expr14121 ) ==@expr14122 "<" ) {
4251: if (@expr1073755947 tokStart@var2656 .@expr14120 str (@expr14121 ) ==@expr14122 "<" ) {
4252:
4253: const Token * closeTok@var2657 ; closeTok@var2657 =@expr1073755951 tokStart@var2656 .@expr1073755952 findClosingBracket (@expr1073755953 ) ;
4254: if (@expr1073755954 !@expr1073755955 closeTok@var2657 ) {
4255: syntaxError (@expr1073755956 tok@var2652 ) ; }
4256: tokStart@var2656 =@expr1073755957 closeTok@var2657 .@expr1073755958 next (@expr1073755959 ) ;
4257: } else {
4258: classnameTokens@var2655 .@expr14109 push_back (@expr1073755961 tokStart@var2656 .@expr14138 next (@expr14139 ) ) ;
4259: tokStart@var2656 =@expr1073755964 tokStart@var2656 .@expr1073755965 tokAt (@expr1073755966 2 ) ;
4260: }
4261: }
4262:
4263: std ::@expr1073755967 string classname@var2658 ;
4264: for (@expr1073755968 const Token *@expr13866 it@var2659 :@expr1073755970 classnameTokens@var2655 ) {
4265: classname@var2658 +=@expr1073755971 (@expr1073755972 classname@var2658 .@expr1073755973 empty (@expr1073755974 ) ?@expr1073755975 "" :@expr1073755976 " :: " ) +@expr1073755977 it@var2659 .@expr1073755978 str (@expr1073755979 ) ; }
4266:
4267: std ::@expr14156 map < std ::@expr13858 string , int > & thisClassVars@var2660 =@expr1073755982 varsByClass@var2651 [@expr1073755983 scopeName2@var2654 +@expr14160 classname@var2658 ] ;
4268: while (@expr1073755985 Token ::@expr13885 Match (@expr1073755987 tokStart@var2656 , ":|::|,|%name%" ) ) {
4269: if (@expr1073755988 Token ::@expr13885 Match (@expr1073755990 tokStart@var2656 , "%name% <" ) ) {
4270: tokStart@var2656 =@expr1073755991 tokStart@var2656 .@expr14138 next (@expr14139 ) .@expr1073755994 findClosingBracket (@expr1073755995 ) ;
4271: if (@expr1073755996 tokStart@var2656 ) {
4272: tokStart@var2656 =@expr1073755997 tokStart@var2656 .@expr14138 next (@expr14139 ) ; }
4273: continue ;
4274: }
4275: if (@expr1073756000 Token ::@expr13885 Match (@expr1073756002 tokStart@var2656 , "%name% ,|{" ) ) {
4276: std ::@expr1073756003 string baseClassName@var2661 ; baseClassName@var2661 =@expr1073756004 tokStart@var2656 .@expr14120 str (@expr14121 ) ;
4277: std ::@expr1073756007 string scopeName3@var2662 (@expr1073756008 scopeName2@var2654 ) ;
4278: while (@expr1073756009 !@expr1073756010 scopeName3@var2662 .@expr1073756011 empty (@expr1073756012 ) ) {
4279: const std ::@expr13858 string name@var2663 =@expr1073756014 scopeName3@var2662 +@expr1073756015 baseClassName@var2661 ;
4280: if (@expr1073756016 varsByClass@var2651 .@expr1073756017 find (@expr1073756018 name@var2663 ) !=@expr1073756019 varsByClass@var2651 .@expr1073756020 end (@expr1073756021 ) ) {
4281: baseClassName@var2661 =@expr1073756022 name@var2663 ;
4282: break ;
4283: }
4284:
4285: if (@expr1073756023 scopeName3@var2662 .@expr14200 size (@expr14201 ) <=@expr1073756026 8 ) {
4286: break ; }
4287: scopeName3@var2662 .@expr14203 erase (@expr1073756028 scopeName3@var2662 .@expr14200 size (@expr14201 ) -@expr1073756031 4 ) ;
4288: const std ::@expr13858 string ::@expr13858 size_type pos@var2664 =@expr1073756034 scopeName3@var2662 .@expr1073756035 rfind (@expr1073756036 " :: " ) ;
4289: if (@expr1073756037 pos@var2664 ==@expr1073756038 std ::@expr14094 string ::@expr1073756040 npos@expr1073755680 ) {
4290: break ; }
4291: scopeName3@var2662 .@expr14203 erase (@expr1073756042 pos@var2664 +@expr1073756043 4 ) ;
4292: }
4293: const std ::@expr14156 map < std ::@expr13858 string , int > & baseClassVars@var2665 =@expr1073756046 varsByClass@var2651 [@expr1073756047 baseClassName@var2661 ] ;
4294: thisClassVars@var2660 .@expr1073756048 insert (@expr1073756049 baseClassVars@var2665 .@expr1073756050 begin (@expr1073756051 ) , baseClassVars@var2665 .@expr1073756052 end (@expr1073756053 ) ) ;
4295: }
4296: tokStart@var2656 =@expr1073756054 tokStart@var2656 .@expr14138 next (@expr14139 ) ;
4297: }
4298: if (@expr1073756057 !@expr1073756058 Token ::@expr1073756059 simpleMatch (@expr1073756060 tokStart@var2656 , "{" ) ) {
4299: continue ; }
4300:
4301:
4302: for (@expr1073756061 const Token *@expr13866 it@var2666 :@expr1073756063 classnameTokens@var2655 ) {
4303: scopeInfo@var2650 .@expr1073756064 emplace_back (@expr1073756065 it@var2666 .@expr1073756066 str (@expr1073756067 ) , tokStart@var2656 .@expr14244 link (@expr14245 ) ) ; }
4304:
4305: for (@expr1073756070 Token *@expr13866 tok2@var2667 =@expr1073756072 tokStart@var2656 .@expr14138 next (@expr14139 ) ; tok2@var2667 &&@expr1073756075 tok2@var2667 !=@expr1073756076 tokStart@var2656 .@expr14244 link (@expr14245 ) ; tok2@var2667 =@expr1073756079 tok2@var2667 .@expr1073756080 next (@expr1073756081 ) ) {
4306:
4307: if (@expr1073756082 tok2@var2667 .@expr14259 link (@expr14260 ) ) {
4308: if (@expr1073756085 tok2@var2667 .@expr14262 str (@expr14263 ) ==@expr1073756088 "(" ) {
4309: Token * funcstart@var2668 ; funcstart@var2668 =@expr1073756089 const_cast < Token *@expr13866 > (@expr1073756091 isFunctionHead (@expr1073756092 tok2@var2667 , "{" ) ) ;
4310: if (@expr1073756093 funcstart@var2668 ) {
4311: setVarIdClassFunction (@expr1073756094 scopeName2@var2654 +@expr14160 classname@var2658 , funcstart@var2668 , funcstart@var2668 .@expr14272 link (@expr14273 ) , thisClassVars@var2660 , structMembers@var2639 , &@expr14274 mVarId@var891 ) ;
4312: tok2@var2667 =@expr1073756099 funcstart@var2668 .@expr14272 link (@expr14273 ) ;
4313: continue ;
4314: }
4315: }
4316: if (@expr1073756102 tok2@var2667 .@expr14262 str (@expr14263 ) ==@expr1073756105 "{" ) {
4317: if (@expr1073756106 tok2@var2667 .@expr1073756107 strAt (@expr1073756108 -1 ) ==@expr1073756109 ")" ) {
4318: setVarIdClassFunction (@expr1073756110 scopeName2@var2654 +@expr14160 classname@var2658 , tok2@var2667 , tok2@var2667 .@expr14259 link (@expr14260 ) , thisClassVars@var2660 , structMembers@var2639 , &@expr14274 mVarId@var891 ) ; }
4319: tok2@var2667 =@expr1073756115 tok2@var2667 .@expr14259 link (@expr14260 ) ;
4320: } else { if (@expr1073756118 Token ::@expr13885 Match (@expr1073756120 tok2@var2667 , "( %name%|)" ) &&@expr1073756121 !@expr1073756122 Token ::@expr13885 Match (@expr1073756124 tok2@var2667 .@expr14259 link (@expr14260 ) , "(|[" ) ) {
4321: tok2@var2667 =@expr1073756127 tok2@var2667 .@expr14259 link (@expr14260 ) ;
4322:
4323:
4324: while (@expr1073756130 Token ::@expr13885 Match (@expr1073756132 tok2@var2667 , ") [:,] %name% (" ) ) {
4325: tok2@var2667 =@expr1073756133 tok2@var2667 .@expr1073756134 linkAt (@expr1073756135 3 ) ; }
4326: } }
4327: }
4328:
4329:
4330: else { if (@expr1073756136 tok2@var2667 .@expr14313 varId (@expr14314 ) >@expr1073756139 0 ) {
4331: thisClassVars@var2660 [@expr1073756140 tok2@var2667 .@expr14262 str (@expr14263 ) ] =@expr1073756143 tok2@var2667 .@expr14313 varId (@expr14314 ) ; } }
4332: }
4333:
4334:
4335: if (@expr1073756146 thisClassVars@var2660 .@expr1073756147 empty (@expr1073756148 ) ) {
4336: continue ; }
4337:
4338:
4339: for (@expr1073756149 const Member &@expr14326 var@var2669 :@expr1073756151 allMemberVars@var2641 ) {
4340: Token * tok2@var2670 ; tok2@var2670 =@expr1073756152 matchMemberVarName (@expr1073756153 var@var2669 , scopeInfo@var2650 ) ;
4341: if (@expr1073756154 !@expr1073756155 tok2@var2670 ) {
4342: continue ; }
4343: if (@expr1073756156 tok2@var2670 .@expr14333 varId (@expr1073756158 ) ==@expr1073756159 0 ) {
4344: tok2@var2670 .@expr14333 varId (@expr1073756161 thisClassVars@var2660 [@expr1073756162 tok2@var2670 .@expr1073756163 str (@expr1073756164 ) ] ) ; }
4345: }
4346:
4347: if (@expr1073756165 isC (@expr13864 ) ||@expr1073756167 tok@var2652 .@expr14076 str (@expr14077 ) ==@expr1073756170 "namespace" ) {
4348: continue ; }
4349:
4350:
4351: for (@expr1073756171 const Member &@expr14326 func@var2671 :@expr1073756173 allMemberFunctions@var2640 ) {
4352: Token * tok2@var2672 ; tok2@var2672 =@expr1073756174 matchMemberFunctionName (@expr1073756175 func@var2671 , scopeInfo@var2650 ) ;
4353: if (@expr1073756176 !@expr1073756177 tok2@var2672 ) {
4354: continue ; }
4355:
4356: if (@expr1073756178 tok2@var2672 .@expr1073756179 str (@expr1073756180 ) ==@expr1073756181 "~" ) {
4357: tok2@var2672 =@expr1073756182 tok2@var2672 .@expr14359 linkAt (@expr14360 2 ) ; }
4358: else {
4359: tok2@var2672 =@expr1073756185 tok2@var2672 .@expr14359 linkAt (@expr1073756187 1 ) ; }
4360:
4361:
4362: Token * start@var2673 ; start@var2673 =@expr1073756188 const_cast < Token *@expr13866 > (@expr1073756190 isFunctionHead (@expr1073756191 tok2@var2672 , "{" ) ) ;
4363: if (@expr1073756192 start@var2673 ) {
4364: setVarIdClassFunction (@expr1073756193 classname@var2658 , start@var2673 , start@var2673 .@expr1073756194 link (@expr1073756195 ) , thisClassVars@var2660 , structMembers@var2639 , &@expr14274 mVarId@var891 ) ;
4365: }
4366:
4367: if (@expr1073756197 Token ::@expr13885 Match (@expr1073756199 tok2@var2672 , ") %name% (" ) ) {
4368: tok2@var2672 =@expr1073756200 tok2@var2672 .@expr14359 linkAt (@expr14360 2 ) ; }
4369:
4370:
4371: if (@expr1073756203 !@expr1073756204 Token ::@expr13885 Match (@expr1073756206 tok2@var2672 , ") : ::| %name%" ) ) {
4372: continue ; }
4373:
4374: Token * tok3@var2674 ; tok3@var2674 =@expr1073756207 tok2@var2672 ;
4375: while (@expr1073756208 Token ::@expr13885 Match (@expr1073756210 tok3@var2674 , "[)}] [,:]" ) ) {
4376: tok3@var2674 =@expr1073756211 tok3@var2674 .@expr14388 tokAt (@expr14389 2 ) ;
4377: if (@expr1073756214 Token ::@expr13885 Match (@expr1073756216 tok3@var2674 , ":: %name%" ) ) {
4378: tok3@var2674 =@expr1073756217 tok3@var2674 .@expr14394 next (@expr14395 ) ; }
4379: while (@expr1073756220 Token ::@expr13885 Match (@expr1073756222 tok3@var2674 , "%name% :: %name%" ) ) {
4380: tok3@var2674 =@expr1073756223 tok3@var2674 .@expr14388 tokAt (@expr14389 2 ) ; }
4381: if (@expr1073756226 !@expr1073756227 Token ::@expr13885 Match (@expr1073756229 tok3@var2674 , "%name% (|{|<" ) ) {
4382: break ; }
4383:
4384:
4385: const std ::@expr14156 map < std ::@expr13858 string , int > ::@expr1073756232 const_iterator varpos@var2675 =@expr1073756233 thisClassVars@var2660 .@expr1073756234 find (@expr1073756235 tok3@var2674 .@expr1073756236 str (@expr1073756237 ) ) ;
4386: if (@expr1073756238 varpos@var2675 !=@expr1073756239 thisClassVars@var2660 .@expr1073756240 end (@expr1073756241 ) ) {
4387: tok3@var2674 .@expr1073756242 varId (@expr1073756243 varpos@var2675 .@expr1073756244 second@var2676 ) ; }
4388:
4389:
4390: if (@expr1073756245 tok3@var2674 .@expr1073756246 strAt (@expr1073756247 1 ) ==@expr1073756248 "<" ) {
4391: tok3@var2674 =@expr1073756249 tok3@var2674 .@expr14394 next (@expr14395 ) .@expr1073756252 findClosingBracket (@expr1073756253 ) ;
4392: if (@expr1073756254 tok3@var2674 &&@expr1073756255 tok3@var2674 .@expr14394 next (@expr14395 ) &&@expr1073756258 tok3@var2674 .@expr14394 next (@expr14395 ) .@expr14437 link (@expr14438 ) ) {
4393: tok3@var2674 =@expr1073756263 tok3@var2674 .@expr14394 next (@expr14395 ) .@expr14437 link (@expr14438 ) ; }
4394: } else {
4395: tok3@var2674 =@expr1073756268 tok3@var2674 .@expr1073756269 linkAt (@expr1073756270 1 ) ; }
4396: }
4397: if (@expr1073756271 Token ::@expr13885 Match (@expr1073756273 tok3@var2674 , ")|} {" ) ) {
4398: setVarIdClassFunction (@expr1073756274 classname@var2658 , tok2@var2672 , tok3@var2674 .@expr14394 next (@expr14395 ) .@expr14437 link (@expr14438 ) , thisClassVars@var2660 , structMembers@var2639 , &@expr14274 mVarId@var891 ) ;
4399: }
4400: }
4401: }
4402: }
4403:
4404: static void linkBrackets ( const Tokenizer * const tokenizer@var2677 , std :: stack < const Token * > & type@var2678 , std :: stack < Token * > & links@var2679 , Token * const token@var2680 , const char open@var2681 , const char close@var2682 )
4405: {
4406: if (@expr1073756280 token@var2680 .@expr14457 str (@expr14458 ) [@expr14459 0 ] ==@expr1073756284 open@var2681 ) {
4407: links@var2679 .@expr1073756285 push (@expr1073756286 token@var2680 ) ;
4408: type@var2678 .@expr1073756287 push (@expr1073756288 token@var2680 ) ;
4409: } else { if (@expr1073756289 token@var2680 .@expr14457 str (@expr14458 ) [@expr14459 0 ] ==@expr1073756293 close@var2682 ) {
4410: if (@expr1073756294 links@var2679 .@expr1073756295 empty (@expr1073756296 ) ) {
4411:
4412: tokenizer@var2677 .@expr14473 unmatchedToken (@expr1073756298 token@var2680 ) ;
4413: }
4414: if (@expr1073756299 type@var2678 .@expr14476 top (@expr14477 ) .@expr1073756302 str (@expr1073756303 ) [@expr1073756304 0 ] !=@expr1073756305 open@var2681 ) {
4415: tokenizer@var2677 .@expr14473 unmatchedToken (@expr1073756307 type@var2678 .@expr14476 top (@expr14477 ) ) ;
4416: }
4417: type@var2678 .@expr1073756310 pop (@expr1073756311 ) ;
4418:
4419: Token ::@expr1073756312 createMutualLinks (@expr1073756313 links@var2679 .@expr1073756314 top (@expr1073756315 ) , token@var2680 ) ;
4420: links@var2679 .@expr1073756316 pop (@expr1073756317 ) ;
4421: } }
4422: }
4423:
4424: void Tokenizer :: createLinks ( )
4425: {
4426: std ::@expr1073756318 stack < const Token *@expr14495 > type@var2683 ;
4427: std ::@expr1073756320 stack < Token *@expr14495 > links1@var2684 ;
4428: std ::@expr1073756322 stack < Token *@expr14495 > links2@var2685 ;
4429: std ::@expr1073756324 stack < Token *@expr14495 > links3@var2686 ;
4430: for (@expr1073756326 Token *@expr14495 token@var2687 =@expr1073756328 list@var872 .@expr1073756329 front (@expr1073756330 ) ; token@var2687 ; token@var2687 =@expr1073756331 token@var2687 .@expr1073756332 next (@expr1073756333 ) ) {
4431: if (@expr1073756334 token@var2687 .@expr14511 link (@expr1073756336 ) ) {
4432: token@var2687 .@expr14511 link (@expr1073756338 nullptr ) ;
4433: }
4434:
4435: linkBrackets (@expr1073756339 this@expr14516 , type@var2683 , links1@var2684 , token@var2687 , '{' , '}' ) ;
4436:
4437: linkBrackets (@expr1073756341 this@expr14516 , type@var2683 , links2@var2685 , token@var2687 , '(' , ')' ) ;
4438:
4439: linkBrackets (@expr1073756342 this@expr14516 , type@var2683 , links3@var2686 , token@var2687 , '[' , ']' ) ;
4440: }
4441:
4442: if (@expr1073756343 !@expr1073756344 links1@var2684 .@expr1073756345 empty (@expr1073756346 ) ) {
4443:
4444: unmatchedToken (@expr1073756347 links1@var2684 .@expr1073756348 top (@expr1073756349 ) ) ;
4445: }
4446:
4447: if (@expr1073756350 !@expr1073756351 links2@var2685 .@expr1073756352 empty (@expr1073756353 ) ) {
4448:
4449: unmatchedToken (@expr1073756354 links2@var2685 .@expr1073756355 top (@expr1073756356 ) ) ;
4450: }
4451:
4452: if (@expr1073756357 !@expr1073756358 links3@var2686 .@expr1073756359 empty (@expr1073756360 ) ) {
4453:
4454: unmatchedToken (@expr1073756361 links3@var2686 .@expr1073756362 top (@expr1073756363 ) ) ;
4455: }
4456: }
4457:
4458: void Tokenizer :: createLinks2 ( )
4459: {
4460: if (@expr1073756364 isC (@expr1073756365 ) ) {
4461: return ; }
4462:
4463: bool isStruct@var2688 ; isStruct@var2688 =@expr1073756366 false ;
4464:
4465: std ::@expr1073756367 stack < Token *@expr14544 > type@var2689 ;
4466: std ::@expr1073756369 stack < Token *@expr14544 > templateTokens@var2690 ;
4467: for (@expr1073756371 Token *@expr14544 token@var2691 =@expr1073756373 list@var872 .@expr1073756374 front (@expr1073756375 ) ; token@var2691 ; token@var2691 =@expr1073756376 token@var2691 .@expr14553 next (@expr14554 ) ) {
4468: if (@expr1073756379 Token ::@expr14556 Match (@expr1073756381 token@var2691 , "%name%|> %name% [:<]" ) ) {
4469: isStruct@var2688 =@expr1073756382 true ; }
4470: else { if (@expr1073756383 Token ::@expr14556 Match (@expr1073756385 token@var2691 , "[;{}]" ) ) {
4471: isStruct@var2688 =@expr1073756386 false ; } }
4472:
4473: if (@expr1073756387 token@var2691 .@expr1073756388 link (@expr1073756389 ) ) {
4474: if (@expr1073756390 Token ::@expr14556 Match (@expr1073756392 token@var2691 , "{|[|(" ) ) {
4475: type@var2689 .@expr14569 push (@expr14570 token@var2691 ) ; }
4476: else { if (@expr1073756395 !@expr14572 type@var2689 .@expr14573 empty (@expr14574 ) &&@expr1073756399 Token ::@expr14556 Match (@expr1073756401 token@var2691 , "}|]|)" ) ) {
4477: while (@expr1073756402 type@var2689 .@expr14579 top (@expr14580 ) .@expr14581 str (@expr14582 ) ==@expr14583 "<" ) {
4478: if (@expr1073756408 !@expr14585 templateTokens@var2690 .@expr14586 empty (@expr14587 ) &&@expr1073756412 templateTokens@var2690 .@expr14589 top (@expr14590 ) .@expr1073756415 next (@expr1073756416 ) ==@expr1073756417 type@var2689 .@expr14579 top (@expr14580 ) ) {
4479: templateTokens@var2690 .@expr14596 pop (@expr14597 ) ; }
4480: type@var2689 .@expr14598 pop (@expr14599 ) ;
4481: }
4482: type@var2689 .@expr14598 pop (@expr14599 ) ;
4483: } }
4484: } else { if (@expr1073756426 templateTokens@var2690 .@expr14586 empty (@expr14587 ) &&@expr1073756429 !@expr1073756430 isStruct@var2688 &&@expr1073756431 Token ::@expr14556 Match (@expr1073756433 token@var2691 , "%oror%|&&|;" ) ) {
4485: if (@expr1073756434 Token ::@expr14556 Match (@expr1073756436 token@var2691 , "&& [,>]" ) ) {
4486: continue ; }
4487:
4488:
4489: if (@expr1073756437 token@var2691 .@expr1073756438 tokType (@expr1073756439 ) ==@expr1073756440 Token ::@expr14617 eLogicalOp &&@expr1073756442 !@expr14572 type@var2689 .@expr14573 empty (@expr14574 ) &&@expr1073756446 type@var2689 .@expr14579 top (@expr14580 ) .@expr14581 str (@expr14582 ) ==@expr14583 "<" ) {
4490: const Token * prev@var2692 ; prev@var2692 =@expr1073756452 token@var2691 .@expr14629 previous (@expr14630 ) ;
4491: bool foundComparison@var2693 ; foundComparison@var2693 =@expr1073756455 false ;
4492: while (@expr1073756456 Token ::@expr14556 Match (@expr1073756458 prev@var2692 , "%name%|%num%|%str%|%cop%|)|]" ) &&@expr1073756459 prev@var2692 !=@expr1073756460 type@var2689 .@expr14579 top (@expr14580 ) ) {
4493: if (@expr1073756463 prev@var2692 .@expr14640 str (@expr14641 ) ==@expr1073756466 ")" ||@expr1073756467 prev@var2692 .@expr14640 str (@expr14641 ) ==@expr1073756470 "]" ) {
4494: prev@var2692 =@expr1073756471 prev@var2692 .@expr1073756472 link (@expr1073756473 ) ; }
4495: else { if (@expr1073756474 prev@var2692 .@expr1073756475 tokType (@expr1073756476 ) ==@expr1073756477 Token ::@expr14617 eLogicalOp ) {
4496: break ; }
4497: else { if (@expr1073756479 prev@var2692 .@expr1073756480 isComparisonOp (@expr1073756481 ) ) {
4498: foundComparison@var2693 =@expr1073756482 true ; } } }
4499: prev@var2692 =@expr1073756483 prev@var2692 .@expr1073756484 previous (@expr1073756485 ) ;
4500: }
4501: if (@expr1073756486 prev@var2692 ==@expr1073756487 type@var2689 .@expr14579 top (@expr14580 ) &&@expr1073756490 foundComparison@var2693 ) {
4502: continue ; }
4503: const Token * next@var2694 ; next@var2694 =@expr1073756491 token@var2691 .@expr14553 next (@expr14554 ) ;
4504: foundComparison@var2693 =@expr1073756494 false ;
4505: while (@expr1073756495 Token ::@expr14556 Match (@expr1073756497 next@var2694 , "%name%|%num%|%str%|%cop%|(|[" ) &&@expr1073756498 next@var2694 .@expr14675 str (@expr14676 ) !=@expr1073756501 ">" ) {
4506: if (@expr1073756502 next@var2694 .@expr14675 str (@expr14676 ) ==@expr1073756505 "(" ||@expr1073756506 next@var2694 .@expr14675 str (@expr14676 ) ==@expr1073756509 "[" ) {
4507: next@var2694 =@expr1073756510 next@var2694 .@expr1073756511 link (@expr1073756512 ) ; }
4508: else { if (@expr1073756513 next@var2694 .@expr1073756514 tokType (@expr1073756515 ) ==@expr1073756516 Token ::@expr14617 eLogicalOp ) {
4509: break ; }
4510: else { if (@expr1073756518 next@var2694 .@expr1073756519 isComparisonOp (@expr1073756520 ) ) {
4511: foundComparison@var2693 =@expr1073756521 true ; } } }
4512: next@var2694 =@expr1073756522 next@var2694 .@expr1073756523 next (@expr1073756524 ) ;
4513: }
4514: if (@expr1073756525 next@var2694 &&@expr1073756526 next@var2694 .@expr14675 str (@expr14676 ) ==@expr1073756529 ">" &&@expr1073756530 foundComparison@var2693 ) {
4515: continue ; }
4516: }
4517:
4518: while (@expr1073756531 !@expr14572 type@var2689 .@expr14573 empty (@expr14574 ) &&@expr1073756535 type@var2689 .@expr14579 top (@expr14580 ) .@expr14581 str (@expr14582 ) ==@expr14583 "<" ) {
4519: const Token * end@var2695 ; end@var2695 =@expr1073756541 type@var2689 .@expr14579 top (@expr14580 ) .@expr1073756544 findClosingBracket (@expr1073756545 ) ;
4520: if (@expr1073756546 Token ::@expr14556 Match (@expr1073756548 end@var2695 , "> %comp%|;|.|=|{|::" ) ) {
4521: break ; }
4522:
4523: if (@expr1073756549 Token ::@expr14556 Match (@expr1073756551 end@var2695 , "> %var% ;" ) &&@expr1073756552 (@expr1073756553 type@var2689 .@expr14579 top (@expr14580 ) .@expr14732 tokAt (@expr14733 -2 ) ==@expr1073756558 nullptr ||@expr1073756559 Token ::@expr14556 Match (@expr1073756561 type@var2689 .@expr14579 top (@expr14580 ) .@expr14732 tokAt (@expr14733 -2 ) , ";|}|{" ) ) ) {
4524: break ; }
4525: type@var2689 .@expr14598 pop (@expr14599 ) ;
4526: }
4527: } else { if (@expr1073756568 token@var2691 .@expr14745 str (@expr14746 ) ==@expr1073756571 "<" &&@expr1073756572
4528: (@expr1073756573 (@expr1073756574 token@var2691 .@expr14629 previous (@expr14630 ) &&@expr1073756577 (@expr1073756578 token@var2691 .@expr14629 previous (@expr14630 ) .@expr1073756581 isTemplate (@expr1073756582 ) ||@expr1073756583
4529: (@expr1073756584 token@var2691 .@expr14629 previous (@expr14630 ) .@expr1073756587 isName (@expr1073756588 ) &&@expr1073756589 !@expr1073756590 token@var2691 .@expr14629 previous (@expr14630 ) .@expr1073756593 varId (@expr1073756594 ) ) ) ) ||@expr1073756595
4530: Token ::@expr14556 Match (@expr1073756597 token@var2691 .@expr14553 next (@expr14554 ) , ">|>>" ) ) ) {
4531: type@var2689 .@expr14569 push (@expr14570 token@var2691 ) ;
4532: if (@expr1073756602 token@var2691 .@expr14629 previous (@expr14630 ) .@expr1073756605 str (@expr1073756606 ) ==@expr1073756607 "template" ) {
4533: templateTokens@var2690 .@expr1073756608 push (@expr1073756609 token@var2691 ) ; }
4534: } else { if (@expr1073756610 token@var2691 .@expr14745 str (@expr14746 ) ==@expr1073756613 ">" ||@expr1073756614 token@var2691 .@expr14745 str (@expr14746 ) ==@expr14793 ">>" ) {
4535: if (@expr1073756618 type@var2689 .@expr14573 empty (@expr14574 ) ||@expr1073756621 type@var2689 .@expr14579 top (@expr14580 ) .@expr14581 str (@expr14582 ) !=@expr1073756626 "<" ) {
4536: continue ; }
4537: Token * const top1@var2696 ; top1@var2696 =@expr1073756627 type@var2689 .@expr14579 top (@expr14580 ) ;
4538: type@var2689 .@expr14598 pop (@expr14599 ) ;
4539: Token * const top2@var2697 ; top2@var2697 =@expr1073756632 type@var2689 .@expr14573 empty (@expr14574 ) ?@expr1073756635 nullptr :@expr1073756636 type@var2689 .@expr14579 top (@expr14580 ) ;
4540: type@var2689 .@expr14569 push (@expr1073756640 top1@var2696 ) ;
4541: if (@expr1073756641 !@expr1073756642 top2@var2697 ||@expr1073756643 top2@var2697 .@expr1073756644 str (@expr1073756645 ) !=@expr1073756646 "<" ) {
4542: if (@expr1073756647 token@var2691 .@expr14745 str (@expr14746 ) ==@expr14793 ">>" ) {
4543: continue ; }
4544: if (@expr1073756651 !@expr1073756652 Token ::@expr14556 Match (@expr1073756654 token@var2691 .@expr14553 next (@expr14554 ) , "%name%|%cop%|%assign%|::|,|(|)|{|}|;|[|:|.|=|..." ) &&@expr1073756657
4545: !@expr1073756658 Token ::@expr14556 Match (@expr1073756660 token@var2691 .@expr14553 next (@expr14554 ) , "&& %name% =" ) ) {
4546: continue ; }
4547: }
4548:
4549:
4550: if (@expr1073756663 token@var2691 .@expr1073756664 strAt (@expr1073756665 1 ) ==@expr1073756666 "[" &&@expr1073756667 !@expr1073756668 Token ::@expr1073756669 simpleMatch (@expr1073756670 token@var2691 .@expr14847 tokAt (@expr1073756672 -1 ) , "... >" ) &&@expr1073756673
4551: !@expr1073756674 Token ::@expr14556 Match (@expr1073756676 token@var2691 .@expr14847 tokAt (@expr1073756678 1 ) , "[ ]" ) ) {
4552: Token * prev@var2698 ; prev@var2698 =@expr1073756679 type@var2689 .@expr14579 top (@expr14580 ) .@expr1073756682 previous (@expr1073756683 ) ;
4553: while (@expr1073756684 prev@var2698 &&@expr1073756685 Token ::@expr14556 Match (@expr1073756687 prev@var2698 .@expr14864 previous (@expr14865 ) , ":: %name%" ) ) {
4554: prev@var2698 =@expr1073756690 prev@var2698 .@expr1073756691 tokAt (@expr1073756692 -2 ) ; }
4555: if (@expr1073756693 prev@var2698 &&@expr1073756694 prev@var2698 .@expr14871 str (@expr14872 ) !=@expr14873 "new" ) {
4556: prev@var2698 =@expr1073756698 prev@var2698 .@expr14864 previous (@expr14865 ) ; }
4557: if (@expr1073756701 !@expr1073756702 prev@var2698 ||@expr1073756703 prev@var2698 .@expr14871 str (@expr14872 ) !=@expr14873 "new" ) {
4558: continue ; }
4559: }
4560:
4561: if (@expr1073756707 token@var2691 .@expr14745 str (@expr14746 ) ==@expr14793 ">>" &&@expr1073756711 top1@var2696 &&@expr1073756712 top2@var2697 ) {
4562: type@var2689 .@expr14598 pop (@expr14599 ) ;
4563: type@var2689 .@expr14598 pop (@expr14599 ) ;
4564:
4565: token@var2691 .@expr14745 str (@expr1073756718 ">" ) ;
4566: Token ::@expr14895 createMutualLinks (@expr1073756720 top1@var2696 , token@var2691 .@expr1073756721 insertTokenBefore (@expr1073756722 ">" ) ) ;
4567: Token ::@expr14895 createMutualLinks (@expr1073756724 top2@var2697 , token@var2691 ) ;
4568: if (@expr1073756725 templateTokens@var2690 .@expr1073756726 size (@expr1073756727 ) ==@expr1073756728 2 &&@expr1073756729 (@expr1073756730 top1@var2696 ==@expr14907 templateTokens@var2690 .@expr14589 top (@expr14590 ) ||@expr1073756734 top2@var2697 ==@expr1073756735 templateTokens@var2690 .@expr14589 top (@expr14590 ) ) ) {
4569: templateTokens@var2690 .@expr14596 pop (@expr14597 ) ;
4570: templateTokens@var2690 .@expr14596 pop (@expr14597 ) ;
4571: }
4572: } else {
4573: type@var2689 .@expr14598 pop (@expr14599 ) ;
4574: if (@expr1073756744 Token ::@expr14556 Match (@expr1073756746 token@var2691 , "> %name%" ) &&@expr1073756747 !@expr1073756748 token@var2691 .@expr14553 next (@expr14554 ) .@expr1073756751 isKeyword (@expr1073756752 ) &&@expr1073756753
4575: Token ::@expr14556 Match (@expr1073756755 top1@var2696 .@expr1073756756 tokAt (@expr1073756757 -2 ) , "%op% %name% <" ) &&@expr1073756758
4576: (@expr1073756759 templateTokens@var2690 .@expr14586 empty (@expr14587 ) ||@expr1073756762 top1@var2696 !=@expr1073756763 templateTokens@var2690 .@expr14589 top (@expr14590 ) ) ) {
4577: continue ; }
4578: Token ::@expr14895 createMutualLinks (@expr1073756767 top1@var2696 , token@var2691 ) ;
4579: if (@expr1073756768 !@expr14585 templateTokens@var2690 .@expr14586 empty (@expr14587 ) &&@expr1073756772 top1@var2696 ==@expr14907 templateTokens@var2690 .@expr14589 top (@expr14590 ) ) {
4580: templateTokens@var2690 .@expr14596 pop (@expr14597 ) ; }
4581: }
4582: } } } }
4583: }
4584: }
4585:
4586: void Tokenizer :: sizeofAddParentheses ( )
4587: {
4588: for (@expr1073756778 Token *@expr1073756779 tok@var2699 =@expr1073756780 list@var872 .@expr1073756781 front (@expr1073756782 ) ; tok@var2699 ; tok@var2699 =@expr1073756783 tok@var2699 .@expr14960 next (@expr14961 ) ) {
4589: if (@expr1073756786 !@expr1073756787 Token ::@expr14964 Match (@expr1073756789 tok@var2699 , "sizeof !!(" ) ) {
4590: continue ; }
4591: if (@expr1073756790 tok@var2699 .@expr14960 next (@expr14961 ) .@expr1073756793 isLiteral (@expr1073756794 ) ||@expr1073756795 Token ::@expr14964 Match (@expr1073756797 tok@var2699 .@expr14960 next (@expr14961 ) , "%name%|*|~|!|&" ) ) {
4592: Token * endToken@var2700 ; endToken@var2700 =@expr1073756800 tok@var2699 .@expr14960 next (@expr14961 ) ;
4593: while (@expr1073756803 Token ::@expr1073756804 simpleMatch (@expr1073756805 endToken@var2700 , "* *" ) ) {
4594: endToken@var2700 =@expr1073756806 endToken@var2700 .@expr14983 next (@expr14984 ) ; }
4595: while (@expr1073756809 Token ::@expr14964 Match (@expr1073756811 endToken@var2700 .@expr14983 next (@expr14984 ) , "%name%|%num%|%str%|[|(|.|::|++|--|!|~" ) ||@expr1073756814 (@expr1073756815 Token ::@expr14964 Match (@expr1073756817 endToken@var2700 , "%type% * %op%|?|:|const|;|," ) ) ) {
4596: if (@expr1073756818 Token ::@expr14964 Match (@expr1073756820 endToken@var2700 .@expr14983 next (@expr14984 ) , "(|[" ) ) {
4597: endToken@var2700 =@expr1073756823 endToken@var2700 .@expr1073756824 linkAt (@expr1073756825 1 ) ; }
4598: else {
4599: endToken@var2700 =@expr1073756826 endToken@var2700 .@expr14983 next (@expr14984 ) ; }
4600: }
4601:
4602:
4603: tok@var2699 .@expr1073756829 insertToken (@expr1073756830 "(" ) ;
4604: endToken@var2700 .@expr1073756831 insertToken (@expr1073756832 ")" ) ;
4605: Token ::@expr1073756833 createMutualLinks (@expr1073756834 tok@var2699 .@expr14960 next (@expr14961 ) , endToken@var2700 .@expr14983 next (@expr14984 ) ) ;
4606: }
4607: }
4608: }
4609:
4610: bool Tokenizer :: simplifySizeof ( )
4611: {
4612:
4613: std ::@expr1073756839 map < int , int > sizeOfVar@var2701 ;
4614: std ::@expr1073756840 map < int , const Token *@expr15017 > declTokOfVar@var2702 ;
4615: for (@expr1073756842 const Token *@expr15017 tok@var2703 =@expr1073756844 list@var872 .@expr15021 front (@expr15022 ) ; tok@var2703 ; tok@var2703 =@expr1073756847 tok@var2703 .@expr15024 next (@expr15025 ) ) {
4616: if (@expr1073756850 tok@var2703 .@expr15027 varId (@expr15028 ) !=@expr1073756853 0 &&@expr1073756854 sizeOfVar@var2701 .@expr15031 find (@expr1073756856 tok@var2703 .@expr15027 varId (@expr15028 ) ) ==@expr1073756859 sizeOfVar@var2701 .@expr15036 end (@expr15037 ) ) {
4617: const int varId@var2704 =@expr1073756862 tok@var2703 .@expr15027 varId (@expr15028 ) ;
4618: if (@expr1073756865 Token ::@expr15042 Match (@expr1073756867 tok@var2703 .@expr15044 tokAt (@expr15045 -3 ) , "[;{}(,] %type% * %name% [;,)]" ) ||@expr1073756870
4619: Token ::@expr15042 Match (@expr1073756872 tok@var2703 .@expr15044 tokAt (@expr1073756874 -4 ) , "[;{}(,] const %type% * %name% [;),]" ) ||@expr1073756875
4620: Token ::@expr15042 Match (@expr1073756877 tok@var2703 .@expr15044 tokAt (@expr15055 -2 ) , "[;{}(,] %type% %name% [;),]" ) ||@expr1073756880
4621: Token ::@expr15042 Match (@expr1073756882 tok@var2703 .@expr15044 tokAt (@expr15045 -3 ) , "[;{}(,] const %type% %name% [;),]" ) ) {
4622: const int size@var2705 =@expr1073756885 sizeOfType (@expr15062 tok@var2703 .@expr15063 previous (@expr15064 ) ) ;
4623: if (@expr1073756889 size@var2705 ==@expr1073756890 0 ) {
4624: continue ;
4625: }
4626:
4627: sizeOfVar@var2701 [@expr15067 varId@var2704 ] =@expr1073756892 size@var2705 ;
4628: declTokOfVar@var2702 [@expr15069 varId@var2704 ] =@expr1073756894 tok@var2703 ;
4629: }
4630:
4631: else { if (@expr1073756895 Token ::@expr15042 Match (@expr1073756897 tok@var2703 .@expr15063 previous (@expr15064 ) , "%type% %name% [ %num% ] [[;=]" ) ||@expr1073756900
4632: Token ::@expr15042 Match (@expr1073756902 tok@var2703 .@expr15044 tokAt (@expr15055 -2 ) , "%type% * %name% [ %num% ] [[;=]" ) ) {
4633: int size@var2706 ; size@var2706 =@expr1073756905 sizeOfType (@expr15062 tok@var2703 .@expr15063 previous (@expr15064 ) ) ;
4634: if (@expr1073756909 size@var2706 ==@expr1073756910 0 ) {
4635: continue ; }
4636:
4637: const Token * tok2@var2707 ; tok2@var2707 =@expr1073756911 tok@var2703 .@expr15024 next (@expr15025 ) ;
4638: do {
4639: const long long num@var2708 =@expr1073756914 MathLib ::@expr1073756915 toLongNumber (@expr1073756916 tok2@var2707 .@expr1073756917 strAt (@expr1073756918 1 ) ) ;
4640: if (@expr1073756919 num@var2708 <@expr1073756920 0 ) {
4641: break ; }
4642: size@var2706 *=@expr1073756921 num@var2708 ;
4643: tok2@var2707 =@expr1073756922 tok2@var2707 .@expr1073756923 tokAt (@expr1073756924 3 ) ;
4644: } while (@expr1073756925 Token ::@expr15042 Match (@expr1073756927 tok2@var2707 , "[ %num% ]" ) ) ;
4645: if (@expr1073756928 Token ::@expr15042 Match (@expr1073756930 tok2@var2707 , "[;=]" ) ) {
4646: sizeOfVar@var2701 [@expr15067 varId@var2704 ] =@expr1073756932 size@var2706 ;
4647: declTokOfVar@var2702 [@expr15069 varId@var2704 ] =@expr1073756934 tok@var2703 ;
4648: }
4649: if (@expr1073756935 !@expr1073756936 tok2@var2707 ) {
4650: syntaxError (@expr1073756937 tok@var2703 ) ;
4651: }
4652: tok@var2703 =@expr1073756938 tok2@var2707 ;
4653: }
4654:
4655: else { if (@expr1073756939 Token ::@expr15042 Match (@expr1073756941 tok@var2703 .@expr15063 previous (@expr15064 ) , "%type% %name% [ %num% ] [,)]" ) ||@expr1073756944
4656: Token ::@expr15042 Match (@expr1073756946 tok@var2703 .@expr15044 tokAt (@expr15055 -2 ) , "%type% * %name% [ %num% ] [,)]" ) ) {
4657: Token tempTok@var2709 ;
4658: tempTok@var2709 .@expr1073756949 str (@expr1073756950 "*" ) ;
4659: sizeOfVar@var2701 [@expr15067 varId@var2704 ] =@expr1073756952 sizeOfType (@expr1073756953 &@expr1073756954 tempTok@var2709 ) ;
4660: declTokOfVar@var2702 [@expr15069 varId@var2704 ] =@expr1073756956 tok@var2703 ;
4661: } } }
4662: }
4663: }
4664:
4665: bool ret@var2710 ; ret@var2710 =@expr1073756957 false ;
4666: for (@expr1073756958 Token *@expr15017 tok@var2711 =@expr1073756960 list@var872 .@expr15021 front (@expr15022 ) ; tok@var2711 ; tok@var2711 =@expr1073756963 tok@var2711 .@expr15140 next (@expr15141 ) ) {
4667: if (@expr1073756966 tok@var2711 .@expr15143 str (@expr1073756968 ) !=@expr1073756969 "sizeof" ) {
4668: continue ; }
4669:
4670: if (@expr1073756970 Token ::@expr15147 simpleMatch (@expr1073756972 tok@var2711 .@expr15140 next (@expr15141 ) , "..." ) ) {
4671:
4672: tok@var2711 .@expr15151 deleteNext (@expr15152 ) ;
4673: }
4674:
4675:
4676: if (@expr1073756977 Token ::@expr15042 Match (@expr1073756979 tok@var2711 .@expr15140 next (@expr15141 ) , "( %char% )" ) ) {
4677: tok@var2711 .@expr15151 deleteNext (@expr15152 ) ;
4678: tok@var2711 .@expr15160 deleteThis (@expr15161 ) ;
4679: tok@var2711 .@expr15151 deleteNext (@expr15152 ) ;
4680: std ::@expr1073756988 ostringstream sz@var2712 ;
4681: sz@var2712 <<@expr1073756989 (@expr1073756990 isC (@expr1073756991 ) ?@expr1073756992 mSettings@var879 .@expr1073756993 sizeof_int@var3574 :@expr1073756994 1 ) ;
4682: tok@var2711 .@expr15143 str (@expr1073756996 sz@var2712 .@expr1073756997 str (@expr1073756998 ) ) ;
4683: ret@var2710 =@expr1073756999 true ;
4684: continue ;
4685: }
4686:
4687:
4688: if (@expr1073757000 Token ::@expr15042 Match (@expr1073757002 tok@var2711 .@expr15140 next (@expr15141 ) , "( %str% )" ) ) {
4689: tok@var2711 .@expr15151 deleteNext (@expr15152 ) ;
4690: tok@var2711 .@expr15160 deleteThis (@expr15161 ) ;
4691: tok@var2711 .@expr15151 deleteNext (@expr15152 ) ;
4692: std ::@expr1073757011 ostringstream ostr@var2713 ;
4693: ostr@var2713 <<@expr1073757012 (@expr1073757013 Token ::@expr1073757014 getStrLength (@expr1073757015 tok@var2711 ) +@expr1073757016 1 ) ;
4694: tok@var2711 .@expr15143 str (@expr1073757018 ostr@var2713 .@expr1073757019 str (@expr1073757020 ) ) ;
4695: ret@var2710 =@expr1073757021 true ;
4696: continue ;
4697: }
4698:
4699:
4700: if (@expr1073757022 Token ::@expr15042 Match (@expr1073757024 tok@var2711 .@expr15140 next (@expr15141 ) , "( %type% * )" ) ) {
4701: tok@var2711 .@expr15140 next (@expr15141 ) .@expr1073757029 deleteNext (@expr1073757030 ) ;
4702: }
4703:
4704: if (@expr1073757031 Token ::@expr15147 simpleMatch (@expr1073757033 tok@var2711 .@expr15140 next (@expr15141 ) , "( * )" ) ) {
4705: tok@var2711 .@expr15143 str (@expr1073757037 MathLib ::@expr15214 toString (@expr1073757039 sizeOfType (@expr15216 tok@var2711 .@expr15217 tokAt (@expr15218 2 ) ) ) ) ;
4706: tok@var2711 .@expr15151 deleteNext (@expr15220 3 ) ;
4707: ret@var2710 =@expr1073757045 true ;
4708: }
4709:
4710:
4711: else { if (@expr1073757046 Token ::@expr15042 Match (@expr1073757048 tok@var2711 .@expr15140 next (@expr15141 ) , "( %var% )" ) ) {
4712: const std ::@expr1073757051 map < int , int > ::@expr1073757052 const_iterator sizeOfVarPos@var2714 =@expr1073757053 sizeOfVar@var2701 .@expr15031 find (@expr1073757055 tok@var2711 .@expr15217 tokAt (@expr15218 2 ) .@expr1073757058 varId (@expr1073757059 ) ) ;
4713: if (@expr1073757060 sizeOfVarPos@var2714 !=@expr1073757061 sizeOfVar@var2701 .@expr15036 end (@expr15037 ) ) {
4714: tok@var2711 .@expr15151 deleteNext (@expr15152 ) ;
4715: tok@var2711 .@expr15160 deleteThis (@expr15161 ) ;
4716: tok@var2711 .@expr15151 deleteNext (@expr15152 ) ;
4717: tok@var2711 .@expr15143 str (@expr1073757071 MathLib ::@expr15214 toString (@expr1073757073 sizeOfVarPos@var2714 .@expr1073757074 second@var2715 ) ) ;
4718: ret@var2710 =@expr1073757075 true ;
4719: } else {
4720:
4721:
4722: }
4723: }
4724:
4725: else { if (@expr1073757076 Token ::@expr15042 Match (@expr1073757078 tok@var2711 .@expr15140 next (@expr15141 ) , "( %type% )" ) ) {
4726: const int size@var2716 =@expr1073757081 sizeOfType (@expr15216 tok@var2711 .@expr15217 tokAt (@expr15218 2 ) ) ;
4727: if (@expr1073757085 size@var2716 >@expr1073757086 0 ) {
4728: tok@var2711 .@expr15143 str (@expr1073757088 MathLib ::@expr15214 toString (@expr1073757090 size@var2716 ) ) ;
4729: tok@var2711 .@expr15151 deleteNext (@expr15220 3 ) ;
4730: ret@var2710 =@expr1073757093 true ;
4731: }
4732: }
4733:
4734: else { if (@expr1073757094 Token ::@expr15147 simpleMatch (@expr1073757096 tok@var2711 .@expr15140 next (@expr15141 ) , "( *" ) ||@expr1073757099 Token ::@expr15042 Match (@expr1073757101 tok@var2711 .@expr15140 next (@expr15141 ) , "( %name% [" ) ) {
4735: int derefs@var2717 ; derefs@var2717 =@expr1073757104 0 ;
4736:
4737: const Token * nametok@var2718 ; nametok@var2718 =@expr1073757105 tok@var2711 .@expr15217 tokAt (@expr15218 2 ) ;
4738: if (@expr1073757108 nametok@var2718 .@expr15285 str (@expr15286 ) ==@expr15287 "*" ) {
4739: do {
4740: nametok@var2718 =@expr1073757112 nametok@var2718 .@expr15289 next (@expr15290 ) ;
4741: derefs@var2717 ++@expr1073757115 ;
4742: } while (@expr1073757116 nametok@var2718 &&@expr1073757117 nametok@var2718 .@expr15285 str (@expr15286 ) ==@expr15287 "*" ) ;
4743:
4744: if (@expr1073757121 !@expr1073757122 Token ::@expr15042 Match (@expr1073757124 nametok@var2718 , "%name% )" ) ) {
4745: continue ; }
4746: } else {
4747: const Token * tok2@var2719 ; tok2@var2719 =@expr1073757125 nametok@var2718 .@expr15289 next (@expr15290 ) ;
4748: do {
4749: tok2@var2719 =@expr1073757128 tok2@var2719 .@expr1073757129 link (@expr1073757130 ) .@expr1073757131 next (@expr1073757132 ) ;
4750: derefs@var2717 ++@expr1073757133 ;
4751: } while (@expr1073757134 tok2@var2719 &&@expr1073757135 tok2@var2719 .@expr15312 str (@expr15313 ) ==@expr1073757138 "[" ) ;
4752:
4753: if (@expr1073757139 !@expr1073757140 tok2@var2719 ||@expr1073757141 tok2@var2719 .@expr15312 str (@expr15313 ) !=@expr1073757144 ")" ) {
4754: continue ; }
4755: }
4756:
4757:
4758: unsigned long long size@var2720 ; size@var2720 =@expr1073757145 0 ;
4759:
4760: const int varid@var2721 =@expr1073757146 nametok@var2718 .@expr1073757147 varId (@expr1073757148 ) ;
4761: if (@expr1073757149 derefs@var2717 !=@expr1073757150 0 &&@expr1073757151 varid@var2721 !=@expr1073757152 0 &&@expr1073757153 declTokOfVar@var2702 .@expr1073757154 find (@expr1073757155 varid@var2721 ) !=@expr1073757156 declTokOfVar@var2702 .@expr1073757157 end (@expr1073757158 ) ) {
4762:
4763: const Token * decltok@var2722 ; decltok@var2722 =@expr1073757159 declTokOfVar@var2702 [@expr1073757160 varid@var2721 ] ;
4764: if (@expr1073757161 Token ::@expr15042 Match (@expr1073757163 decltok@var2722 .@expr15340 previous (@expr15341 ) , "%type%|* %name% [" ) ) {
4765: size@var2720 =@expr1073757166 sizeOfType (@expr1073757167 decltok@var2722 .@expr15340 previous (@expr15341 ) ) ;
4766: } else { if (@expr1073757170 Token ::@expr15042 Match (@expr1073757172 decltok@var2722 .@expr15349 tokAt (@expr15350 -2 ) , "%type% * %name%" ) ) {
4767: size@var2720 =@expr1073757175 sizeOfType (@expr1073757176 decltok@var2722 .@expr15349 tokAt (@expr15350 -2 ) ) ;
4768: } }
4769:
4770: if (@expr1073757179 Token ::@expr15042 Match (@expr1073757181 decltok@var2722 , "%name% [" ) &&@expr1073757182 Token ::@expr15147 simpleMatch (@expr1073757184 decltok@var2722 .@expr1073757185 linkAt (@expr1073757186 1 ) , "] [" ) ) {
4771: const Token * tok2@var2723 ; tok2@var2723 =@expr1073757187 decltok@var2722 ;
4772: for (@expr1073757188 int i@var2724 =@expr1073757189 0 ; i@var2724 <@expr1073757190 derefs@var2717 ; i@var2724 ++@expr1073757191 ) {
4773: tok2@var2723 =@expr1073757192 tok2@var2723 .@expr15369 linkAt (@expr15370 1 ) ; }
4774: while (@expr1073757195 Token ::@expr15042 Match (@expr1073757197 tok2@var2723 , "] [ %num% ]" ) ) {
4775: size@var2720 *=@expr1073757198 MathLib ::@expr15375 toULongNumber (@expr1073757200 tok2@var2723 .@expr1073757201 strAt (@expr1073757202 2 ) ) ;
4776: tok2@var2723 =@expr1073757203 tok2@var2723 .@expr15369 linkAt (@expr15370 1 ) ;
4777: }
4778: if (@expr1073757206 Token ::@expr15147 simpleMatch (@expr1073757208 tok2@var2723 , "] [" ) ) {
4779: continue ; }
4780: }
4781: } else { if (@expr1073757209 nametok@var2718 .@expr1073757210 strAt (@expr1073757211 1 ) ==@expr1073757212 "[" &&@expr1073757213 nametok@var2718 .@expr1073757214 isStandardType (@expr1073757215 ) ) {
4782: size@var2720 =@expr1073757216 sizeOfType (@expr1073757217 nametok@var2718 ) ;
4783: if (@expr1073757218 size@var2720 ==@expr1073757219 0 ) {
4784: continue ; }
4785: const Token * tok2@var2725 ; tok2@var2725 =@expr1073757220 nametok@var2718 .@expr15289 next (@expr15290 ) ;
4786: while (@expr1073757223 Token ::@expr15042 Match (@expr1073757225 tok2@var2725 , "[ %num% ]" ) ) {
4787: size@var2720 *=@expr1073757226 MathLib ::@expr15375 toULongNumber (@expr1073757228 tok2@var2725 .@expr1073757229 strAt (@expr1073757230 1 ) ) ;
4788: tok2@var2725 =@expr1073757231 tok2@var2725 .@expr1073757232 link (@expr1073757233 ) .@expr1073757234 next (@expr1073757235 ) ;
4789: }
4790: if (@expr1073757236 !@expr1073757237 tok2@var2725 ||@expr1073757238 tok2@var2725 .@expr1073757239 str (@expr1073757240 ) !=@expr1073757241 ")" ) {
4791: continue ; }
4792: } }
4793:
4794: if (@expr1073757242 size@var2720 >@expr1073757243 0 ) {
4795: tok@var2711 .@expr15143 str (@expr1073757245 MathLib ::@expr15214 toString (@expr1073757247 size@var2720 ) ) ;
4796: Token ::@expr1073757248 eraseTokens (@expr1073757249 tok@var2711 , tok@var2711 .@expr15140 next (@expr15141 ) .@expr1073757252 link (@expr1073757253 ) .@expr1073757254 next (@expr1073757255 ) ) ;
4797: ret@var2710 =@expr1073757256 true ;
4798: }
4799: } } } }
4800: }
4801: return ret@var2710 ;
4802: }
4803:
4804: bool Tokenizer :: simplifyTokenList1 ( const char FileName@var2726 [ ] )
4805: {
4806: if (@expr15433 Settings ::@expr15434 terminated (@expr15435 ) ) {
4807: return false ; }
4808:
4809:
4810: for (@expr1073757260 Token *@expr15437 tok@var2727 =@expr1073757262 list@var872 .@expr15439 front (@expr15440 ) ; tok@var2727 ; tok@var2727 =@expr1073757265 tok@var2727 .@expr1073757266 next (@expr1073757267 ) ) {
4811: if (@expr1073757268 Token ::@expr15445 Match (@expr1073757270 tok@var2727 , "if|for|while|BOOST_FOREACH %name% (" ) ) {
4812: if (@expr1073757271 Token ::@expr15448 simpleMatch (@expr1073757273 tok@var2727 , "for each" ) ) {
4813:
4814: tok@var2727 .@expr1073757274 str (@expr1073757275 "asm" ) ;
4815: tok@var2727 .@expr15452 deleteNext (@expr15453 ) ;
4816: } else { if (@expr1073757278 tok@var2727 .@expr1073757279 strAt (@expr1073757280 1 ) ==@expr1073757281 "constexpr" ) {
4817: tok@var2727 .@expr15452 deleteNext (@expr15453 ) ;
4818: tok@var2727 .@expr1073757284 isConstexpr (@expr1073757285 true ) ;
4819: } else {
4820: syntaxError (@expr1073757286 tok@var2727 ) ;
4821: } }
4822: }
4823: }
4824:
4825:
4826: validateC (@expr1073757287 ) ;
4827:
4828:
4829: removeMacroInVarDecl (@expr1073757288 ) ;
4830:
4831:
4832: combineStringAndCharLiterals (@expr1073757289 ) ;
4833:
4834:
4835: simplifySQL (@expr1073757290 ) ;
4836:
4837: createLinks (@expr1073757291 ) ;
4838:
4839: removePragma (@expr1073757292 ) ;
4840:
4841:
4842: simplifyCAlternativeTokens (@expr1073757293 ) ;
4843:
4844: simplifyFunctionTryCatch (@expr1073757294 ) ;
4845:
4846: simplifyHeadersAndUnusedTemplates (@expr1073757295 ) ;
4847:
4848:
4849: simplifyAsm (@expr1073757296 ) ;
4850:
4851:
4852: if (@expr1073757297 isCPP (@expr15474 ) ||@expr1073757299 mSettings@var879 .@expr1073757300 daca@var3581 ) {
4853: splitTemplateRightAngleBrackets (@expr1073757301 !@expr1073757302 isCPP (@expr15474 ) ) ; }
4854:
4855:
4856: removeExtraTemplateKeywords (@expr1073757304 ) ;
4857:
4858: removeAlignas (@expr1073757305 ) ;
4859:
4860: simplifySpaceshipOperator (@expr1073757306 ) ;
4861:
4862:
4863: if (@expr15483 mTimerResults@var894 ) {
4864: Timer t@var2728 (@expr1073757308 "Tokenizer::tokenize::findGarbageCode" , mSettings@var879 .@expr15485 showtime@var3569 , mTimerResults@var894 ) ;
4865: findGarbageCode (@expr15486 ) ;
4866: } else {
4867: findGarbageCode (@expr15486 ) ;
4868: }
4869:
4870: checkConfiguration (@expr1073757312 ) ;
4871:
4872:
4873: for (@expr1073757313 const Token *@expr15437 tok@var2729 =@expr1073757315 list@var872 .@expr15439 front (@expr15440 ) ; tok@var2729 ; tok@var2729 =@expr1073757318 tok@var2729 .@expr15495 next (@expr15496 ) ) {
4874: if (@expr1073757321 Token ::@expr15448 simpleMatch (@expr1073757323 tok@var2729 , "if (" ) ) {
4875: tok@var2729 =@expr1073757324 tok@var2729 .@expr15495 next (@expr15496 ) .@expr1073757327 link (@expr1073757328 ) ;
4876: if (@expr1073757329 Token ::@expr15445 Match (@expr1073757331 tok@var2729 , ") %name% (" ) &&@expr1073757332
4877: tok@var2729 .@expr15495 next (@expr15496 ) .@expr1073757335 isUpperCaseName (@expr1073757336 ) &&@expr1073757337
4878: Token ::@expr15445 Match (@expr1073757339 tok@var2729 .@expr1073757340 linkAt (@expr1073757341 2 ) , ") {|else" ) ) {
4879: syntaxError (@expr1073757342 tok@var2729 .@expr15495 next (@expr15496 ) ) ;
4880: }
4881: }
4882: }
4883:
4884: if (@expr15433 Settings ::@expr15434 terminated (@expr15435 ) ) {
4885: return false ; }
4886:
4887:
4888: simplifyNestedNamespace (@expr1073757348 ) ;
4889:
4890:
4891: simplifyCoroutines (@expr1073757349 ) ;
4892:
4893:
4894: simplifyNamespaceAliases (@expr1073757350 ) ;
4895:
4896:
4897: simplifyCPPAttribute (@expr1073757351 ) ;
4898:
4899:
4900: simplifyAttribute (@expr1073757352 ) ;
4901:
4902:
4903: simplifyCppcheckAttribute (@expr1073757353 ) ;
4904:
4905:
4906: combineOperators (@expr1073757354 ) ;
4907:
4908:
4909: simplifyMathExpressions (@expr1073757355 ) ;
4910:
4911:
4912: concatenateNegativeNumberAndAnyPositive (@expr1073757356 ) ;
4913:
4914:
4915: if (@expr15533 isCPP (@expr15474 ) ) {
4916: simplifyExternC (@expr1073757359 ) ; }
4917:
4918:
4919: simplifyRoundCurlyParentheses (@expr1073757360 ) ;
4920:
4921:
4922: for (@expr1073757361 const Token *@expr15437 tok@var2730 =@expr1073757363 list@var872 .@expr15439 front (@expr15440 ) ; tok@var2730 ; tok@var2730 =@expr1073757366 tok@var2730 .@expr1073757367 next (@expr1073757368 ) ) {
4923: if (@expr1073757369 Token ::@expr15448 simpleMatch (@expr1073757371 tok@var2730 , "> struct {" ) &&@expr1073757372
4924: Token ::@expr15448 simpleMatch (@expr1073757374 tok@var2730 .@expr1073757375 linkAt (@expr1073757376 2 ) , "} ;" ) ) {
4925: syntaxError (@expr1073757377 tok@var2730 ) ;
4926: }
4927: }
4928:
4929: if (@expr1073757378 !@expr1073757379 simplifyAddBraces (@expr1073757380 ) ) {
4930: return false ; }
4931:
4932: sizeofAddParentheses (@expr1073757381 ) ;
4933:
4934:
4935: for (@expr1073757382 Token *@expr15437 tok@var2731 =@expr1073757384 list@var872 .@expr15439 front (@expr15440 ) ; tok@var2731 ; tok@var2731 =@expr1073757387 tok@var2731 .@expr15564 next (@expr15565 ) ) {
4936: if (@expr1073757390 Token ::@expr15448 simpleMatch (@expr1073757392 tok@var2731 , "0 [" ) &&@expr1073757393 tok@var2731 .@expr15570 linkAt (@expr15571 1 ) ) {
4937: tok@var2731 .@expr1073757396 str (@expr1073757397 "*" ) ;
4938: tok@var2731 .@expr15564 next (@expr15565 ) .@expr1073757400 str (@expr1073757401 "(" ) ;
4939: tok@var2731 .@expr15570 linkAt (@expr15571 1 ) .@expr1073757404 str (@expr1073757405 ")" ) ;
4940: }
4941: }
4942:
4943: if (@expr15433 Settings ::@expr15434 terminated (@expr15435 ) ) {
4944: return false ; }
4945:
4946:
4947: simplifyDeclspec (@expr1073757409 ) ;
4948: validate (@expr15586 ) ;
4949:
4950:
4951: simplifyKeyword (@expr1073757411 ) ;
4952:
4953:
4954: if (@expr15533 isCPP (@expr15474 ) ) {
4955: Token * lt@var2732 ; lt@var2732 =@expr1073757414 nullptr ;
4956: for (@expr1073757415 Token *@expr15437 tok@var2733 =@expr1073757417 list@var872 .@expr15439 front (@expr15440 ) ; tok@var2733 ; tok@var2733 =@expr1073757420 tok@var2733 .@expr15597 next (@expr15598 ) ) {
4957: if (@expr1073757423 Token ::@expr15445 Match (@expr1073757425 tok@var2733 , "[;{}]" ) ) {
4958: lt@var2732 =@expr1073757426 nullptr ; }
4959: else { if (@expr1073757427 Token ::@expr15445 Match (@expr1073757429 tok@var2733 , "%type% <" ) ) {
4960: lt@var2732 =@expr1073757430 tok@var2733 .@expr15597 next (@expr15598 ) ; }
4961: else { if (@expr1073757433 lt@var2732 &&@expr1073757434 Token ::@expr15445 Match (@expr1073757436 tok@var2733 , ">|>> %name%|::|(" ) ) {
4962: const Token * const end@var2734 ; end@var2734 =@expr1073757437 tok@var2733 ;
4963: for (@expr1073757438 tok@var2733 =@expr1073757439 lt@var2732 ; tok@var2733 !=@expr1073757440 end@var2734 ; tok@var2733 =@expr1073757441 tok@var2733 .@expr15597 next (@expr15598 ) ) {
4964: if (@expr1073757444 tok@var2733 .@expr1073757445 isNumber (@expr1073757446 ) ) {
4965: TemplateSimplifier ::@expr1073757447 simplifyNumericCalculations (@expr1073757448 tok@var2733 ) ; }
4966: }
4967: lt@var2732 =@expr1073757449 tok@var2733 .@expr15597 next (@expr15598 ) ;
4968: } } }
4969: }
4970: }
4971:
4972:
4973: simplifyVarDecl (@expr1073757452 true ) ;
4974: simplifyFunctionParameters (@expr1073757453 ) ;
4975:
4976:
4977: simplifyCaseRange (@expr1073757454 ) ;
4978:
4979:
4980: simplifyLabelsCaseDefault (@expr1073757455 ) ;
4981:
4982: if (@expr1073757456 !@expr15633 isC (@expr15634 ) &&@expr1073757459 !@expr1073757460 mSettings@var879 .@expr1073757461 library@var3563 .@expr1073757462 markupFile (@expr1073757463 FileName@var2726 ) ) {
4983: findComplicatedSyntaxErrorsInTemplates (@expr1073757464 ) ;
4984: }
4985:
4986: if (@expr15433 Settings ::@expr15434 terminated (@expr15435 ) ) {
4987: return false ; }
4988:
4989:
4990: simplifyCallingConvention (@expr1073757468 ) ;
4991:
4992: addSemicolonAfterUnknownMacro (@expr1073757469 ) ;
4993:
4994:
4995: removeMacrosInGlobalScope (@expr1073757470 ) ;
4996:
|
4999:
5000: removeMacroInClassDef (@expr1073757471 ) ;
5001:
5002:
5003: validate (@expr15586 ) ;
5004:
5005:
5006: removeUnnecessaryQualification (@expr1073757473 ) ;
5007:
5008:
5009: simplifyMicrosoftMemoryFunctions (@expr1073757474 ) ;
5010:
5011:
5012: simplifyMicrosoftStringFunctions (@expr1073757475 ) ;
5013:
5014: if (@expr15433 Settings ::@expr15434 terminated (@expr15435 ) ) {
5015: return false ; }
5016:
5017:
5018: simplifyQtSignalsSlots (@expr1073757479 ) ;
5019:
5020:
5021: simplifyBorland (@expr1073757480 ) ;
5022:
5023:
5024: checkForEnumsWithTypedef (@expr1073757481 ) ;
5025:
5026:
5027: prepareTernaryOpForAST (@expr15658 ) ;
5028:
5029:
5030: simplifyInitVar (@expr15659 ) ;
5031:
5032:
5033: simplifyVarDecl (@expr15660 false ) ;
5034:
5035: reportUnknownMacros (@expr1073757485 ) ;
5036:
5037:
5038: if (@expr15483 mTimerResults@var894 ) {
5039: Timer t@var2735 (@expr1073757487 "Tokenizer::tokenize::simplifyTypedef" , mSettings@var879 .@expr15485 showtime@var3569 , mTimerResults@var894 ) ;
5040: simplifyTypedef (@expr15665 ) ;
5041: } else {
5042: simplifyTypedef (@expr15665 ) ;
5043: }
5044:
5045:
5046: while (@expr1073757491 simplifyUsing (@expr1073757492 ) ) {
5047: ; }
5048:
|
5051:
5052: prepareTernaryOpForAST (@expr15658 ) ;
5053:
5054: for (@expr1073757494 Token *@expr15437 tok@var2736 =@expr1073757496 list@var872 .@expr15439 front (@expr15440 ) ; tok@var2736 ; ) {
5055: if (@expr1073757499 Token ::@expr15445 Match (@expr1073757501 tok@var2736 , "union|struct|class union|struct|class" ) ) {
5056: tok@var2736 .@expr1073757502 deleteNext (@expr1073757503 ) ; }
5057: else {
5058: tok@var2736 =@expr1073757504 tok@var2736 .@expr1073757505 next (@expr1073757506 ) ; }
5059: }
5060:
5061:
5062: if (@expr1073757507 isCPP (@expr15474 ) &&@expr1073757509 mSettings@var879 .@expr1073757510 severity@var3571 .@expr1073757511 isEnabled (@expr1073757512 Severity ::@expr1073757513 information ) ) {
5063: for (@expr1073757514 const Token *@expr15437 tok@var2737 =@expr1073757516 list@var872 .@expr15439 front (@expr15440 ) ; tok@var2737 ; tok@var2737 =@expr1073757519 tok@var2737 .@expr1073757520 next (@expr1073757521 ) ) {
5064: if (@expr1073757522 Token ::@expr15445 Match (@expr1073757524 tok@var2737 , "class %type% %type% [:{]" ) ) {
5065: unhandled_macro_class_x_y (@expr1073757525 tok@var2737 ) ;
5066: }
5067: }
5068: }
5069:
|
5074:
5075: validate (@expr15586 ) ;
5076:
5077:
5078: if (@expr15433 Settings ::@expr15434 terminated (@expr15435 ) ) {
5079: return false ; }
5080:
5081:
5082: simplifyAsm2 (@expr1073757530 ) ;
5083:
5084:
5085: simplifyAt (@expr1073757531 ) ;
5086:
5087:
5088: for (@expr1073757532 const Token *@expr15437 tok@var2738 =@expr1073757534 list@var872 .@expr15439 front (@expr15440 ) ; tok@var2738 ; tok@var2738 =@expr1073757537 tok@var2738 .@expr1073757538 next (@expr1073757539 ) ) {
5089: if (@expr1073757540 tok@var2738 .@expr15717 str (@expr15718 ) ==@expr1073757543 "(" ) {
5090: const Token * tok1@var2739 ; tok1@var2739 =@expr1073757544 tok@var2738 ;
5091: tok@var2738 =@expr1073757545 tok@var2738 .@expr1073757546 link (@expr1073757547 ) ;
5092: if (@expr1073757548 !@expr1073757549 tok@var2738 ) {
5093: syntaxError (@expr1073757550 tok1@var2739 ) ; }
5094: } else { if (@expr1073757551 tok@var2738 .@expr15717 str (@expr15718 ) ==@expr1073757554 "@" ) {
5095: syntaxError (@expr1073757555 tok@var2738 ) ;
5096: } }
5097: }
5098:
5099:
5100: simplifyStaticConst (@expr1073757556 ) ;
5101:
|
5104:
5105: list@var872 .@expr1073757557 simplifyPlatformTypes (@expr1073757558 ) ;
5106:
5107:
5108:
5109: list@var872 .@expr1073757559 simplifyStdType (@expr1073757560 ) ;
5110:
5111: if (@expr15433 Settings ::@expr15434 terminated (@expr15435 ) ) {
5112: return false ; }
5113:
5114:
5115: simplifyBitfields (@expr1073757564 ) ;
5116:
5117: if (@expr15433 Settings ::@expr15434 terminated (@expr15435 ) ) {
5118: return false ; }
5119:
5120:
5121: simplifyStructDecl (@expr1073757568 ) ;
5122:
5123: if (@expr15433 Settings ::@expr15434 terminated (@expr15435 ) ) {
5124: return false ; }
5125:
5126:
5127: simplifyAssignmentBlock (@expr1073757572 ) ;
5128:
5129: if (@expr15433 Settings ::@expr15434 terminated (@expr15435 ) ) {
5130: return false ; }
5131:
5132: simplifyVariableMultipleAssign (@expr1073757576 ) ;
5133:
5134:
5135:
5136: simplifyOperatorName (@expr1073757577 ) ;
5137:
5138:
5139: simplifyRedundantParentheses (@expr1073757578 ) ;
5140:
5141: if (@expr15533 isCPP (@expr15474 ) ) {
5142: simplifyTypeIntrinsics (@expr1073757581 ) ; }
5143:
5144: if (@expr1073757582 !@expr15633 isC (@expr15634 ) ) {
5145:
5146: if (@expr15483 mTimerResults@var894 ) {
5147: Timer t@var2740 (@expr1073757586 "Tokenizer::tokenize::simplifyTemplates" , mSettings@var879 .@expr15485 showtime@var3569 , mTimerResults@var894 ) ;
5148: simplifyTemplates (@expr15764 ) ;
5149: } else {
5150: simplifyTemplates (@expr15764 ) ;
5151: }
5152:
5153:
5154: if (@expr15433 Settings ::@expr15434 terminated (@expr15435 ) ) {
5155: return false ; }
5156:
5157: validate (@expr15586 ) ;
5158: }
5159:
5160:
5161: simplifyPointerToStandardType (@expr1073757594 ) ;
5162:
5163:
5164: simplifyFunctionPointers (@expr1073757595 ) ;
5165:
5166:
5167: simplifyInitVar (@expr15659 ) ;
5168:
5169:
5170: simplifyVarDecl (@expr15660 false ) ;
5171:
5172: elseif (@expr1073757598 ) ;
5173:
5174: validate (@expr15586 ) ;
5175:
5176: if (@expr15483 mTimerResults@var894 ) {
5177: Timer t@var2741 (@expr1073757601 "Tokenizer::tokenize::setVarId" , mSettings@var879 .@expr15485 showtime@var3569 , mTimerResults@var894 ) ;
5178: setVarId (@expr15779 ) ;
5179: } else {
5180: setVarId (@expr15779 ) ;
5181: }
5182:
5183:
5184: createLinks2 (@expr1073757605 ) ;
5185:
5186: if (@expr15483 mTimerResults@var894 ) {
5187: Timer t@var2742 (@expr1073757607 "Tokenizer::tokenize::setVarId (2)" , mSettings@var879 .@expr15485 showtime@var3569 , mTimerResults@var894 ) ;
5188: setVarId (@expr15779 ) ;
5189: }
5190: else {
5191: setVarId (@expr15779 ) ;
5192: }
5193:
5194:
5195: for (@expr1073757611 Token *@expr15437 tok@var2743 =@expr1073757613 list@var872 .@expr15439 front (@expr15440 ) ; tok@var2743 ; tok@var2743 =@expr1073757616 tok@var2743 .@expr1073757617 next (@expr1073757618 ) ) {
5196: if (@expr1073757619 Token ::@expr15445 Match (@expr1073757621 tok@var2743 , "const_cast|dynamic_cast|reinterpret_cast|static_cast <" ) &&@expr1073757622 Token ::@expr15448 simpleMatch (@expr1073757624 tok@var2743 .@expr15801 linkAt (@expr15802 1 ) , "> (" ) ) {
5197: tok@var2743 =@expr1073757627 tok@var2743 .@expr15801 linkAt (@expr15802 1 ) .@expr1073757630 next (@expr1073757631 ) ;
5198: tok@var2743 .@expr1073757632 isCast (@expr1073757633 true ) ;
5199: }
5200: }
5201:
5202:
5203: arraySize (@expr1073757634 ) ;
5204:
5205:
5206: if (@expr15433 Settings ::@expr15434 terminated (@expr15435 ) ) {
5207: return false ; }
5208:
5209:
5210: simplifyNamespaceStd (@expr1073757638 ) ;
5211:
5212:
5213: simplifyInitVar (@expr15659 ) ;
5214:
5215: simplifyDoublePlusAndDoubleMinus (@expr1073757640 ) ;
5216:
5217: simplifyArrayAccessSyntax (@expr1073757641 ) ;
5218:
5219: Token ::@expr1073757642 assignProgressValues (@expr1073757643 list@var872 .@expr15439 front (@expr15440 ) ) ;
5220:
5221: removeRedundantSemicolons (@expr1073757646 ) ;
5222:
5223: simplifyParameterVoid (@expr1073757647 ) ;
5224:
5225: simplifyRedundantConsecutiveBraces (@expr1073757648 ) ;
5226:
5227: simplifyEmptyNamespaces (@expr1073757649 ) ;
5228:
5229: simplifyIfSwitchForInit (@expr1073757650 ) ;
5230:
5231: simplifyOverloadedOperators (@expr1073757651 ) ;
5232:
5233: validate (@expr15586 ) ;
5234:
5235: list@var872 .@expr15439 front (@expr15440 ) .@expr1073757655 assignIndexes (@expr1073757656 ) ;
5236:
5237: return true ;
5238: }
5239:
5240: bool Tokenizer :: simplifyTokenList2 ( )
5241: {
5242:
5243: deleteSymbolDatabase (@expr1073757657 ) ;
5244:
5245:
5246: for (@expr1073757658 Token *@expr15835 tok@var2744 =@expr1073757660 list@var872 .@expr15837 front (@expr15838 ) ; tok@var2744 ; tok@var2744 =@expr1073757663 tok@var2744 .@expr1073757664 next (@expr1073757665 ) ) {
5247: tok@var2744 .@expr1073757666 clearAst (@expr1073757667 ) ;
5248: tok@var2744 .@expr1073757668 clearValueFlow (@expr1073757669 ) ;
5249: }
5250:
5251:
5252: simplifyMathFunctions (@expr15846 ) ;
5253:
5254:
5255: simplifyAssignmentInFunctionCall (@expr1073757671 ) ;
5256:
5257:
5258: simplifyCompoundAssignment (@expr1073757672 ) ;
5259:
5260: simplifyCharAt (@expr1073757673 ) ;
5261:
5262:
5263: simplifyReference (@expr1073757674 ) ;
5264:
5265: simplifyStd (@expr1073757675 ) ;
5266:
5267: if (@expr15852 Settings ::@expr15853 terminated (@expr15854 ) ) {
5268: return false ; }
5269:
5270: simplifySizeof (@expr1073757679 ) ;
5271:
5272: simplifyUndefinedSizeArray (@expr1073757680 ) ;
5273:
5274: simplifyCasts (@expr1073757681 ) ;
5275:
5276:
5277:
5278: simplifyCalculations (@expr15858 ) ;
5279:
5280: if (@expr15852 Settings ::@expr15853 terminated (@expr15854 ) ) {
5281: return false ; }
5282:
5283:
5284: simplifyOffsetPointerDereference (@expr1073757686 ) ;
5285:
5286:
5287: simplifyOffsetPointerReference (@expr1073757687 ) ;
5288:
5289: removeRedundantAssignment (@expr15864 ) ;
5290:
5291: simplifyRealloc (@expr1073757689 ) ;
5292:
5293:
5294: simplifyInitVar (@expr1073757690 ) ;
5295:
5296:
5297: simplifyVarDecl (@expr1073757691 false ) ;
5298:
5299: simplifyErrNoInWhile (@expr1073757692 ) ;
5300: simplifyIfAndWhileAssign (@expr15869 ) ;
5301: simplifyRedundantParentheses (@expr15870 ) ;
5302: simplifyNestedStrcat (@expr1073757695 ) ;
5303: simplifyFuncInWhile (@expr1073757696 ) ;
5304:
5305: simplifyIfAndWhileAssign (@expr15869 ) ;
5306:
5307:
5308: for (@expr1073757698 Token *@expr15835 tok@var2745 =@expr1073757700 list@var872 .@expr15837 front (@expr15838 ) ; tok@var2745 ; tok@var2745 =@expr1073757703 tok@var2745 .@expr1073757704 next (@expr1073757705 ) ) {
5309: if (@expr1073757706 Token ::@expr1073757707 Match (@expr1073757708 tok@var2745 , "strlen ( %str% )" ) ) {
5310: tok@var2745 .@expr1073757709 str (@expr1073757710 MathLib ::@expr1073757711 toString (@expr1073757712 Token ::@expr1073757713 getStrLength (@expr1073757714 tok@var2745 .@expr1073757715 tokAt (@expr1073757716 2 ) ) ) ) ;
5311: tok@var2745 .@expr1073757717 deleteNext (@expr1073757718 3 ) ;
5312: }
5313: }
5314:
5315: bool modified@var2746 ; modified@var2746 =@expr1073757719 true ;
5316: while (@expr1073757720 modified@var2746 ) {
5317: if (@expr15852 Settings ::@expr15853 terminated (@expr15854 ) ) {
5318: return false ; }
5319:
5320: modified@var2746 =@expr1073757724 false ;
5321: modified@var2746 |=@expr1073757725 simplifyConditions (@expr1073757726 ) ;
5322: modified@var2746 |=@expr1073757727 simplifyFunctionReturn (@expr1073757728 ) ;
5323: modified@var2746 |=@expr1073757729 simplifyKnownVariables (@expr1073757730 ) ;
5324: modified@var2746 |=@expr1073757731 simplifyStrlen (@expr1073757732 ) ;
5325:
5326: modified@var2746 |=@expr1073757733 removeRedundantConditions (@expr1073757734 ) ;
5327: modified@var2746 |=@expr1073757735 simplifyRedundantParentheses (@expr15870 ) ;
5328: modified@var2746 |=@expr1073757737 simplifyConstTernaryOp (@expr1073757738 ) ;
5329: modified@var2746 |=@expr1073757739 simplifyCalculations (@expr15858 ) ;
5330: validate (@expr15917 ) ;
5331: }
5332:
5333:
5334: simplifyWhile0 (@expr1073757742 ) ;
5335: removeRedundantFor (@expr1073757743 ) ;
5336:
5337:
5338: for (@expr1073757744 Token *@expr15835 tok@var2747 =@expr1073757746 list@var872 .@expr15837 front (@expr15838 ) ; tok@var2747 ; tok@var2747 =@expr1073757749 tok@var2747 .@expr15926 next (@expr15927 ) ) {
5339: while (@expr1073757752 Token ::@expr15929 simpleMatch (@expr1073757754 tok@var2747 , "return (" ) ) {
5340: Token * tok2@var2748 ; tok2@var2748 =@expr1073757755 tok@var2747 .@expr15926 next (@expr15927 ) .@expr1073757758 link (@expr1073757759 ) ;
5341: if (@expr1073757760 Token ::@expr15929 simpleMatch (@expr1073757762 tok2@var2748 , ") ;" ) ) {
5342: tok@var2747 .@expr1073757763 deleteNext (@expr1073757764 ) ;
5343: tok2@var2748 .@expr1073757765 deleteThis (@expr1073757766 ) ;
5344: } else {
5345: break ;
5346: }
5347: }
5348: }
5349:
5350: simplifyReturnStrncat (@expr1073757767 ) ;
5351:
5352: removeRedundantAssignment (@expr15864 ) ;
5353:
5354: simplifyComma (@expr1073757769 ) ;
5355:
5356: removeRedundantSemicolons (@expr1073757770 ) ;
5357:
5358: simplifyFlowControl (@expr1073757771 ) ;
5359:
5360: simplifyRedundantConsecutiveBraces (@expr1073757772 ) ;
5361:
5362: simplifyEmptyNamespaces (@expr1073757773 ) ;
5363:
5364: simplifyMathFunctions (@expr15846 ) ;
5365:
5366: validate (@expr15917 ) ;
5367:
5368: Token ::@expr1073757776 assignProgressValues (@expr1073757777 list@var872 .@expr15837 front (@expr15838 ) ) ;
5369:
5370: list@var872 .@expr15837 front (@expr15838 ) .@expr1073757782 assignIndexes (@expr1073757783 ) ;
5371:
5372: list@var872 .@expr1073757784 createAst (@expr1073757785 ) ;
5373:
5374: list@var872 .@expr1073757786 validateAst (@expr1073757787 ) ;
5375:
5376:
5377: createSymbolDatabase (@expr1073757788 ) ;
5378: mSymbolDatabase@var881 .@expr1073757789 setValueTypeInTokenList (@expr1073757790 true ) ;
5379:
5380: ValueFlow ::@expr1073757791 setValues (@expr1073757792 &@expr1073757793 list@var872 , mSymbolDatabase@var881 , mErrorLogger@var880 , mSettings@var879 ) ;
5381:
5382: if (@expr15852 Settings ::@expr15853 terminated (@expr15854 ) ) {
5383: return false ; }
5384:
5385: printDebugOutput (@expr1073757797 2 ) ;
5386:
5387: return true ;
5388: }
5389:
5390:
5391: void Tokenizer :: printDebugOutput ( int simplification@var2749 ) const
5392: {
5393: const bool debug@var2750 =@expr1073757800 (@expr1073757801 simplification@var2749 !=@expr1073757802 1U &&@expr1073757803 mSettings@var879 .@expr1073757804 debugSimplified@var3582 ) ||@expr1073757805
5394: (@expr1073757806 simplification@var2749 !=@expr1073757807 2U &&@expr1073757808 mSettings@var879 .@expr1073757809 debugnormal@var3583 ) ;
5395:
5396: if (@expr1073757810 debug@var2750 &&@expr1073757811 list@var872 .@expr15988 front (@expr15989 ) ) {
5397: list@var872 .@expr15988 front (@expr15989 ) .@expr1073757816 printOut (@expr1073757817 nullptr , list@var872 .@expr15994 getFiles (@expr15995 ) ) ;
5398:
5399: if (@expr15996 mSettings@var879 .@expr15997 xml@var3584 ) {
5400: std ::@expr15998 cout@expr15974 <<@expr1073757823 "<debug>" <<@expr1073757824 std ::@expr16001 endl@expr15975 ; }
5401:
5402: if (@expr1073757826 mSymbolDatabase@var881 ) {
5403: if (@expr15996 mSettings@var879 .@expr15997 xml@var3584 ) {
5404: mSymbolDatabase@var881 .@expr1073757829 printXml (@expr1073757830 std ::@expr15998 cout@expr15974 ) ; }
5405: else { if (@expr16008 mSettings@var879 .@expr16009 verbose@var3585 ) {
5406: mSymbolDatabase@var881 .@expr1073757834 printOut (@expr1073757835 "Symbol database" ) ;
5407: } }
5408: }
5409:
5410: if (@expr16008 mSettings@var879 .@expr16009 verbose@var3585 ) {
5411: list@var872 .@expr15988 front (@expr15989 ) .@expr1073757840 printAst (@expr1073757841 mSettings@var879 .@expr16009 verbose@var3585 , mSettings@var879 .@expr15997 xml@var3584 , list@var872 .@expr15994 getFiles (@expr15995 ) , std ::@expr15998 cout@expr15974 ) ; }
5412:
5413: list@var872 .@expr15988 front (@expr15989 ) .@expr1073757849 printValueFlow (@expr1073757850 mSettings@var879 .@expr15997 xml@var3584 , std ::@expr15998 cout@expr15974 ) ;
5414:
5415: if (@expr15996 mSettings@var879 .@expr15997 xml@var3584 ) {
5416: std ::@expr15998 cout@expr15974 <<@expr1073757856 "</debug>" <<@expr1073757857 std ::@expr16001 endl@expr15975 ; }
5417: }
5418:
5419: if (@expr1073757859 mSymbolDatabase@var881 &&@expr1073757860 simplification@var2749 ==@expr1073757861 2U &&@expr1073757862 mSettings@var879 .@expr1073757863 debugwarnings@var3566 ) {
5420: printUnknownTypes (@expr1073757864 ) ;
5421:
5422:
5423: for (@expr1073757865 const Variable *@expr1073757866 var@var2751 :@expr1073757867 mSymbolDatabase@var881 .@expr1073757868 variableList (@expr1073757869 ) ) {
5424: if (@expr1073757870 !@expr1073757871 var@var2751 ) {
5425: continue ; }
5426:
5427: const Token * typetok@var2752 ; typetok@var2752 =@expr1073757872 var@var2751 .@expr16049 typeStartToken (@expr16050 ) ;
5428: while (@expr1073757875 typetok@var2752 &&@expr1073757876 typetok@var2752 !=@expr16053 var@var2751 .@expr16054 typeEndToken (@expr16055 ) ) {
5429: typetok@var2752 =@expr1073757880 typetok@var2752 .@expr1073757881 next (@expr1073757882 ) ; }
5430:
5431: if (@expr1073757883 typetok@var2752 !=@expr16053 var@var2751 .@expr16054 typeEndToken (@expr16055 ) ) {
5432: reportError (@expr1073757887 var@var2751 .@expr16049 typeStartToken (@expr16050 ) ,
5433: Severity ::@expr1073757890 debug ,
5434: "debug" ,
5435: "Variable::typeStartToken() of variable '" +@expr1073757891 var@var2751 .@expr1073757892 name (@expr1073757893 ) +@expr1073757894 "' is not located before Variable::typeEndToken(). The location of the typeStartToken() is '" +@expr1073757895 var@var2751 .@expr16049 typeStartToken (@expr16050 ) .@expr1073757898 str (@expr1073757899 ) +@expr1073757900 "' at line " +@expr1073757901 MathLib ::@expr1073757902 toString (@expr1073757903 var@var2751 .@expr16049 typeStartToken (@expr16050 ) .@expr1073757906 linenr (@expr1073757907 ) ) ) ;
5436: }
5437: }
5438: }
5439: }
5440:
5441: void Tokenizer :: dump ( std :: ostream & out@var2753 ) const
5442: {
5443:
|
5447:
5448: out@var2753 <<@expr1073757909 "  <tokenlist>" <<@expr1073757910 std ::@expr16087 endl@expr16084 ;
5449: for (@expr1073757912 const Token *@expr1073757913 tok@var2754 =@expr1073757914 list@var872 .@expr16091 front (@expr16092 ) ; tok@var2754 ; tok@var2754 =@expr1073757917 tok@var2754 .@expr1073757918 next (@expr1073757919 ) ) {
5450: out@var2753 <<@expr1073757920 "    <token id=\"" <<@expr1073757921 tok@var2754 <<@expr1073757922 "\" file=\"" <<@expr1073757923 ErrorLogger ::@expr16100 toxml (@expr1073757925 list@var872 .@expr1073757926 file (@expr1073757927 tok@var2754 ) ) <<@expr1073757928 "\" linenr=\"" <<@expr1073757929 tok@var2754 .@expr1073757930 linenr (@expr1073757931 ) <<@expr1073757932 "\" column=\"" <<@expr1073757933 tok@var2754 .@expr1073757934 column (@expr1073757935 ) <<@expr1073757936 "\"" ;
5451: out@var2753 <<@expr1073757937 " str=\"" <<@expr1073757938 ErrorLogger ::@expr16100 toxml (@expr1073757940 tok@var2754 .@expr16117 str (@expr16118 ) ) <<@expr1073757943 '\"' ;
5452: out@var2753 <<@expr1073757944 " scope=\"" <<@expr1073757945 tok@var2754 .@expr16122 scope (@expr16123 ) <<@expr1073757948 '\"' ;
5453: if (@expr1073757949 tok@var2754 .@expr1073757950 isName (@expr1073757951 ) ) {
5454: out@var2753 <<@expr1073757952 " type=\"name\"" ;
5455: if (@expr1073757953 tok@var2754 .@expr1073757954 isUnsigned (@expr1073757955 ) ) {
5456: out@var2753 <<@expr1073757956 " isUnsigned=\"true\"" ; }
5457: else { if (@expr1073757957 tok@var2754 .@expr1073757958 isSigned (@expr1073757959 ) ) {
5458: out@var2753 <<@expr1073757960 " isSigned=\"true\"" ; } }
5459: } else { if (@expr1073757961 tok@var2754 .@expr1073757962 isNumber (@expr1073757963 ) ) {
5460: out@var2753 <<@expr1073757964 " type=\"number\"" ;
5461: if (@expr1073757965 MathLib ::@expr1073757966 isInt (@expr1073757967 tok@var2754 .@expr16117 str (@expr16118 ) ) ) {
5462: out@var2753 <<@expr1073757970 " isInt=\"true\"" ; }
5463: if (@expr1073757971 MathLib ::@expr1073757972 isFloat (@expr1073757973 tok@var2754 .@expr16117 str (@expr16118 ) ) ) {
5464: out@var2753 <<@expr1073757976 " isFloat=\"true\"" ; }
5465: } else { if (@expr1073757977 tok@var2754 .@expr16154 tokType (@expr16155 ) ==@expr1073757980 Token ::@expr1073757981 eString ) {
5466: out@var2753 <<@expr1073757982 " type=\"string\" strlen=\"" <<@expr1073757983 Token ::@expr1073757984 getStrLength (@expr1073757985 tok@var2754 ) <<@expr1073757986 '\"' ; }
5467: else { if (@expr1073757987 tok@var2754 .@expr16154 tokType (@expr16155 ) ==@expr1073757990 Token ::@expr1073757991 eChar ) {
5468: out@var2753 <<@expr1073757992 " type=\"char\"" ; }
5469: else { if (@expr1073757993 tok@var2754 .@expr1073757994 isBoolean (@expr1073757995 ) ) {
5470: out@var2753 <<@expr1073757996 " type=\"boolean\"" ; }
5471: else { if (@expr1073757997 tok@var2754 .@expr1073757998 isOp (@expr1073757999 ) ) {
5472: out@var2753 <<@expr1073758000 " type=\"op\"" ;
5473: if (@expr1073758001 tok@var2754 .@expr1073758002 isArithmeticalOp (@expr1073758003 ) ) {
5474: out@var2753 <<@expr1073758004 " isArithmeticalOp=\"true\"" ; }
5475: else { if (@expr1073758005 tok@var2754 .@expr1073758006 isAssignmentOp (@expr1073758007 ) ) {
5476: out@var2753 <<@expr1073758008 " isAssignmentOp=\"true\"" ; }
5477: else { if (@expr1073758009 tok@var2754 .@expr1073758010 isComparisonOp (@expr1073758011 ) ) {
5478: out@var2753 <<@expr1073758012 " isComparisonOp=\"true\"" ; }
5479: else { if (@expr1073758013 tok@var2754 .@expr16154 tokType (@expr16155 ) ==@expr1073758016 Token ::@expr1073758017 eLogicalOp ) {
5480: out@var2753 <<@expr1073758018 " isLogicalOp=\"true\"" ; } } } }
5481: } } } } } }
5482: if (@expr1073758019 tok@var2754 .@expr1073758020 isExpandedMacro (@expr1073758021 ) ) {
5483: out@var2753 <<@expr1073758022 " isExpandedMacro=\"true\"" ; }
5484: if (@expr1073758023 tok@var2754 .@expr1073758024 isRemovedVoidParameter (@expr1073758025 ) ) {
5485: out@var2753 <<@expr1073758026 " isRemovedVoidParameter=\"true\"" ; }
5486: if (@expr1073758027 tok@var2754 .@expr1073758028 isSplittedVarDeclComma (@expr1073758029 ) ) {
5487: out@var2753 <<@expr1073758030 " isSplittedVarDeclComma=\"true\"" ; }
5488: if (@expr1073758031 tok@var2754 .@expr1073758032 isSplittedVarDeclEq (@expr1073758033 ) ) {
5489: out@var2753 <<@expr1073758034 " isSplittedVarDeclEq=\"true\"" ; }
5490: if (@expr1073758035 tok@var2754 .@expr1073758036 isImplicitInt (@expr1073758037 ) ) {
5491: out@var2753 <<@expr1073758038 " isImplicitInt=\"true\"" ; }
5492: if (@expr1073758039 tok@var2754 .@expr1073758040 isComplex (@expr1073758041 ) ) {
5493: out@var2753 <<@expr1073758042 " isComplex=\"true\"" ; }
5494: if (@expr1073758043 tok@var2754 .@expr16220 link (@expr16221 ) ) {
5495: out@var2753 <<@expr1073758046 " link=\"" <<@expr1073758047 tok@var2754 .@expr16220 link (@expr16221 ) <<@expr1073758050 '\"' ; }
5496: if (@expr1073758051 tok@var2754 .@expr16228 varId (@expr16229 ) >@expr1073758054 0 ) {
5497: out@var2753 <<@expr1073758055 " varId=\"" <<@expr1073758056 MathLib ::@expr1073758057 toString (@expr1073758058 tok@var2754 .@expr16228 varId (@expr16229 ) ) <<@expr1073758061 '\"' ; }
5498: if (@expr1073758062 tok@var2754 .@expr16239 variable (@expr16240 ) ) {
5499: out@var2753 <<@expr1073758065 " variable=\"" <<@expr1073758066 tok@var2754 .@expr16239 variable (@expr16240 ) <<@expr1073758069 '\"' ; }
5500: if (@expr1073758070 tok@var2754 .@expr16247 function (@expr16248 ) ) {
5501: out@var2753 <<@expr1073758073 " function=\"" <<@expr1073758074 tok@var2754 .@expr16247 function (@expr16248 ) <<@expr1073758077 '\"' ; }
5502: if (@expr1073758078 !@expr1073758079 tok@var2754 .@expr16256 values (@expr16257 ) .@expr1073758082 empty (@expr1073758083 ) ) {
5503: out@var2753 <<@expr1073758084 " values=\"" <<@expr1073758085 &@expr1073758086 tok@var2754 .@expr16256 values (@expr16257 ) <<@expr1073758089 '\"' ; }
5504: if (@expr1073758090 tok@var2754 .@expr16267 type (@expr16268 ) ) {
5505: out@var2753 <<@expr1073758093 " type-scope=\"" <<@expr1073758094 tok@var2754 .@expr16267 type (@expr16268 ) .@expr1073758097 classScope@var3616 <<@expr1073758098 '\"' ; }
5506: if (@expr1073758099 tok@var2754 .@expr16276 astParent (@expr16277 ) ) {
5507: out@var2753 <<@expr1073758102 " astParent=\"" <<@expr1073758103 tok@var2754 .@expr16276 astParent (@expr16277 ) <<@expr1073758106 '\"' ; }
5508: if (@expr1073758107 tok@var2754 .@expr16284 astOperand1 (@expr16285 ) ) {
5509: out@var2753 <<@expr1073758110 " astOperand1=\"" <<@expr1073758111 tok@var2754 .@expr16284 astOperand1 (@expr16285 ) <<@expr1073758114 '\"' ; }
5510: if (@expr1073758115 tok@var2754 .@expr16292 astOperand2 (@expr16293 ) ) {
5511: out@var2753 <<@expr1073758118 " astOperand2=\"" <<@expr1073758119 tok@var2754 .@expr16292 astOperand2 (@expr16293 ) <<@expr1073758122 '\"' ; }
5512: if (@expr1073758123 !@expr1073758124 tok@var2754 .@expr16301 originalName (@expr16302 ) .@expr1073758127 empty (@expr1073758128 ) ) {
5513: out@var2753 <<@expr1073758129 " originalName=\"" <<@expr1073758130 tok@var2754 .@expr16301 originalName (@expr16302 ) <<@expr1073758133 '\"' ; }
5514: if (@expr1073758134 tok@var2754 .@expr16311 valueType (@expr16312 ) ) {
5515: const std ::@expr1073758137 string vt@var2755 =@expr1073758138 tok@var2754 .@expr16311 valueType (@expr16312 ) .@expr1073758141 dump (@expr1073758142 ) ;
5516: if (@expr1073758143 !@expr1073758144 vt@var2755 .@expr1073758145 empty (@expr1073758146 ) ) {
5517: out@var2753 <<@expr1073758147 ' ' <<@expr1073758148 vt@var2755 ; }
5518: }
5519: if (@expr1073758149 !@expr1073758150 tok@var2754 .@expr16228 varId (@expr16229 ) &&@expr1073758153 tok@var2754 .@expr16122 scope (@expr16123 ) .@expr1073758156 isExecutable (@expr1073758157 ) &&@expr1073758158 Token ::@expr1073758159 Match (@expr1073758160 tok@var2754 , "%name% (" ) ) {
5520: if (@expr1073758161 mSettings@var879 .@expr1073758162 library@var3563 .@expr1073758163 isnoreturn (@expr1073758164 tok@var2754 ) ) {
5521: out@var2753 <<@expr1073758165 " noreturn=\"true\"" ; }
5522: }
5523:
5524: out@var2753 <<@expr1073758166 "/>" <<@expr1073758167 std ::@expr16087 endl@expr16084 ;
5525: }
5526: out@var2753 <<@expr1073758169 "  </tokenlist>" <<@expr1073758170 std ::@expr16087 endl@expr16084 ;
5527:
5528: mSymbolDatabase@var881 .@expr1073758172 printXml (@expr1073758173 out@var2753 ) ;
5529: if (@expr1073758174 list@var872 .@expr16091 front (@expr16092 ) ) {
5530: list@var872 .@expr16091 front (@expr16092 ) .@expr1073758179 printValueFlow (@expr1073758180 true , out@var2753 ) ; }
5531:
5532: if (@expr1073758181 !@expr1073758182 mTypedefInfo@var890 .@expr1073758183 empty (@expr1073758184 ) ) {
5533: out@var2753 <<@expr1073758185 "  <typedef-info>" <<@expr1073758186 std ::@expr16087 endl@expr16084 ;
5534: for (@expr1073758188 const TypedefInfo &@expr1073758189 typedefInfo@var2756 :@expr1073758190 mTypedefInfo@var890 ) {
5535: out@var2753 <<@expr1073758191 "    <info"
5536: <<@expr1073758192 " name=\"" <<@expr1073758193 typedefInfo@var2756 .@expr1073758194 name@var2757 <<@expr1073758195 "\""
5537: <<@expr1073758196 " file=\"" <<@expr1073758197 typedefInfo@var2756 .@expr1073758198 filename@var2758 <<@expr1073758199 "\""
5538: <<@expr1073758200 " line=\"" <<@expr1073758201 typedefInfo@var2756 .@expr1073758202 lineNumber@var2759 <<@expr1073758203 "\""
5539: <<@expr1073758204 " column=\"" <<@expr1073758205 typedefInfo@var2756 .@expr1073758206 column@var2760 <<@expr1073758207 "\""
5540: <<@expr1073758208 " used=\"" <<@expr1073758209 (@expr1073758210 typedefInfo@var2756 .@expr1073758211 used@var2761 ?@expr1073758212 1 :@expr1073758213 0 ) <<@expr1073758214 "\""
5541: <<@expr1073758215 "/>" <<@expr1073758216 std ::@expr16087 endl@expr16084 ;
5542: }
5543: out@var2753 <<@expr1073758218 "  </typedef-info>" <<@expr1073758219 std ::@expr16087 endl@expr16084 ;
5544: }
5545: }
5546:
5547: void Tokenizer :: simplifyHeadersAndUnusedTemplates ( )
5548: {
5549: if (@expr1073758221 mSettings@var879 .@expr16398 checkHeaders@var3586 &&@expr1073758223 mSettings@var879 .@expr16400 checkUnusedTemplates@var3587 ) {
5550:
5551: return ; }
5552:
5553: const bool checkHeaders@var2762 =@expr1073758225 mSettings@var879 .@expr16398 checkHeaders@var3586 ;
5554: const bool removeUnusedIncludedFunctions@var2763 =@expr1073758227 !@expr16404 mSettings@var879 .@expr16398 checkHeaders@var3586 ;
5555: const bool removeUnusedIncludedClasses@var2764 =@expr1073758230 !@expr16404 mSettings@var879 .@expr16398 checkHeaders@var3586 ;
5556: const bool removeUnusedIncludedTemplates@var2765 =@expr1073758233 !@expr16410 mSettings@var879 .@expr16400 checkUnusedTemplates@var3587 ||@expr1073758236 !@expr16404 mSettings@var879 .@expr16398 checkHeaders@var3586 ;
5557: const bool removeUnusedTemplates@var2766 =@expr1073758239 !@expr16410 mSettings@var879 .@expr16400 checkUnusedTemplates@var3587 ;
5558:
|
5570:
5571: std ::@expr1073758242 set < std ::@expr16419 string > keep@var2767 ;
5572: for (@expr1073758244 const Token *@expr16421 tok@var2768 =@expr1073758246 list@var872 .@expr16423 front (@expr16424 ) ; tok@var2768 ; tok@var2768 =@expr1073758249 tok@var2768 .@expr16426 next (@expr16427 ) ) {
5573: if (@expr1073758252 isCPP (@expr1073758253 ) &&@expr1073758254 Token ::@expr16431 simpleMatch (@expr1073758256 tok@var2768 , "template <" ) ) {
5574: const Token * closingBracket@var2769 ; closingBracket@var2769 =@expr1073758257 tok@var2768 .@expr16426 next (@expr16427 ) .@expr1073758260 findClosingBracket (@expr1073758261 ) ;
5575: if (@expr1073758262 Token ::@expr16439 Match (@expr1073758264 closingBracket@var2769 , "> class|struct %name% {" ) ) {
5576: tok@var2768 =@expr1073758265 closingBracket@var2769 .@expr1073758266 linkAt (@expr1073758267 3 ) ; }
5577: }
5578:
5579: if (@expr1073758268 !@expr1073758269 tok@var2768 .@expr1073758270 isName (@expr1073758271 ) ||@expr1073758272 tok@var2768 .@expr1073758273 isKeyword (@expr1073758274 ) ) {
5580: continue ; }
5581:
5582: if (@expr1073758275 !@expr1073758276 checkHeaders@var2762 &&@expr1073758277 tok@var2768 .@expr1073758278 fileIndex (@expr1073758279 ) !=@expr1073758280 0 ) {
5583: continue ; }
5584:
5585: if (@expr1073758281 Token ::@expr16439 Match (@expr1073758283 tok@var2768 , "%name% (" ) &&@expr1073758284 !@expr1073758285 Token ::@expr16431 simpleMatch (@expr1073758287 tok@var2768 .@expr1073758288 linkAt (@expr1073758289 1 ) , ") {" ) ) {
5586: keep@var2767 .@expr16466 insert (@expr16467 tok@var2768 .@expr16468 str (@expr16469 ) ) ;
5587: continue ;
5588: }
5589:
5590: if (@expr1073758294 Token ::@expr16439 Match (@expr1073758296 tok@var2768 , "%name% %name%|::|*|&|<" ) ) {
5591: keep@var2767 .@expr16466 insert (@expr16467 tok@var2768 .@expr16468 str (@expr16469 ) ) ;
5592: }
5593: }
5594:
5595: const std ::@expr16419 set < std ::@expr16419 string > functionStart@var2770 {@expr1073758303 "static" , "const" , "unsigned" , "signed" , "void" , "bool" , "char" , "short" , "int" , "long" , "float" , "*" } ;
5596:
5597: for (@expr1073758304 Token *@expr16421 tok@var2771 =@expr1073758306 list@var872 .@expr16423 front (@expr16424 ) ; tok@var2771 ; tok@var2771 =@expr1073758309 tok@var2771 .@expr16486 next (@expr16487 ) ) {
5598: const bool isIncluded@var2772 =@expr1073758312 tok@var2771 .@expr1073758313 fileIndex (@expr1073758314 ) !=@expr1073758315 0 ;
5599:
5600:
5601: if (@expr1073758316 isIncluded@var2772 &&@expr1073758317 !@expr16404 mSettings@var879 .@expr16398 checkHeaders@var3586 &&@expr1073758320 tok@var2771 .@expr16497 str (@expr1073758322 ) ==@expr1073758323 "{" ) {
5602:
5603: const Token * prev@var2773 ; prev@var2773 =@expr1073758324 tok@var2771 .@expr16501 previous (@expr16502 ) ;
5604: while (@expr1073758327 prev@var2773 &&@expr1073758328 prev@var2773 .@expr1073758329 isName (@expr1073758330 ) ) {
5605: prev@var2773 =@expr1073758331 prev@var2773 .@expr1073758332 previous (@expr1073758333 ) ; }
5606: if (@expr1073758334 Token ::@expr16431 simpleMatch (@expr1073758336 prev@var2773 , ")" ) ) {
5607:
5608: Token ::@expr16513 eraseTokens (@expr1073758338 tok@var2771 , tok@var2771 .@expr16515 link (@expr1073758340 ) .@expr1073758341 next (@expr1073758342 ) ) ;
5609: tok@var2771 .@expr16497 str (@expr1073758344 ";" ) ;
5610: tok@var2771 .@expr16515 link (@expr1073758346 nullptr ) ;
5611: }
5612: }
5613:
5614: if (@expr1073758347 !@expr1073758348 tok@var2771 .@expr16501 previous (@expr16502 ) ||@expr1073758351 Token ::@expr16439 Match (@expr1073758353 tok@var2771 .@expr16501 previous (@expr16502 ) , "[;{}]" ) ) {
5615:
5616: if (@expr1073758356 isIncluded@var2772 &&@expr1073758357 removeUnusedIncludedFunctions@var2763 ) {
5617: while (@expr1073758358 true ) {
5618: Token * start@var2774 ; start@var2774 =@expr1073758359 tok@var2771 ;
5619: while (@expr1073758360 start@var2774 &&@expr1073758361 functionStart@var2770 .@expr1073758362 find (@expr1073758363 start@var2774 .@expr16540 str (@expr16541 ) ) !=@expr1073758366 functionStart@var2770 .@expr1073758367 end (@expr1073758368 ) ) {
5620: start@var2774 =@expr1073758369 start@var2774 .@expr1073758370 next (@expr1073758371 ) ; }
5621: if (@expr1073758372 Token ::@expr16439 Match (@expr1073758374 start@var2774 , "%name% (" ) &&@expr1073758375 Token ::@expr16439 Match (@expr1073758377 start@var2774 .@expr16554 linkAt (@expr16555 1 ) , ") const| ;" ) &&@expr1073758380 keep@var2767 .@expr16557 find (@expr1073758382 start@var2774 .@expr16540 str (@expr16541 ) ) ==@expr1073758385 keep@var2767 .@expr16562 end (@expr16563 ) ) {
5622: Token ::@expr16513 eraseTokens (@expr1073758389 tok@var2771 , start@var2774 .@expr16554 linkAt (@expr16555 1 ) .@expr1073758392 tokAt (@expr1073758393 2 ) ) ;
5623: tok@var2771 .@expr16570 deleteThis (@expr16571 ) ;
5624: } else {
5625: break ; }
5626: }
5627: }
5628:
5629: if (@expr1073758396 isIncluded@var2772 &&@expr1073758397 removeUnusedIncludedClasses@var2764 ) {
5630: if (@expr1073758398 Token ::@expr16439 Match (@expr1073758400 tok@var2771 , "class|struct %name% [:{]" ) &&@expr1073758401 keep@var2767 .@expr16557 find (@expr1073758403 tok@var2771 .@expr1073758404 strAt (@expr1073758405 1 ) ) ==@expr1073758406 keep@var2767 .@expr16562 end (@expr16563 ) ) {
5631:
5632: const Token * endToken@var2775 ; endToken@var2775 =@expr1073758409 tok@var2771 .@expr1073758410 tokAt (@expr1073758411 2 ) ;
5633: if (@expr1073758412 endToken@var2775 .@expr16589 str (@expr16590 ) ==@expr1073758415 ":" ) {
5634: endToken@var2775 =@expr1073758416 endToken@var2775 .@expr16593 next (@expr16594 ) ;
5635: while (@expr1073758419 Token ::@expr16439 Match (@expr1073758421 endToken@var2775 , "%name%|," ) ) {
5636: endToken@var2775 =@expr1073758422 endToken@var2775 .@expr16593 next (@expr16594 ) ; }
5637: }
5638: if (@expr1073758425 endToken@var2775 &&@expr1073758426 endToken@var2775 .@expr16589 str (@expr16590 ) ==@expr1073758429 "{" &&@expr1073758430 Token ::@expr16431 simpleMatch (@expr1073758432 endToken@var2775 .@expr16609 link (@expr16610 ) , "} ;" ) ) {
5639: Token ::@expr16513 eraseTokens (@expr1073758436 tok@var2771 , endToken@var2775 .@expr16609 link (@expr16610 ) .@expr1073758439 next (@expr1073758440 ) ) ;
5640: tok@var2771 .@expr16570 deleteThis (@expr16571 ) ;
5641: }
5642: }
5643: }
5644:
5645: if (@expr1073758443 removeUnusedTemplates@var2766 ||@expr1073758444 (@expr1073758445 isIncluded@var2772 &&@expr1073758446 removeUnusedIncludedTemplates@var2765 ) ) {
5646: if (@expr1073758447 Token ::@expr16439 Match (@expr1073758449 tok@var2771 , "template < %name%" ) ) {
5647: const Token * closingBracket@var2776 ; closingBracket@var2776 =@expr1073758450 tok@var2771 .@expr16486 next (@expr16487 ) .@expr1073758453 findClosingBracket (@expr1073758454 ) ;
5648: if (@expr1073758455 Token ::@expr16439 Match (@expr1073758457 closingBracket@var2776 , "> class|struct %name% [;:{]" ) &&@expr1073758458 keep@var2767 .@expr16557 find (@expr16636 closingBracket@var2776 .@expr16637 strAt (@expr16638 2 ) ) ==@expr16639 keep@var2767 .@expr16562 end (@expr16563 ) ) {
5649: const Token * endToken@var2777 ; endToken@var2777 =@expr1073758466 closingBracket@var2776 .@expr1073758467 tokAt (@expr1073758468 3 ) ;
5650: if (@expr1073758469 endToken@var2777 .@expr16646 str (@expr16647 ) ==@expr1073758472 ":" ) {
5651: endToken@var2777 =@expr1073758473 endToken@var2777 .@expr16650 next (@expr16651 ) ;
5652: while (@expr1073758476 Token ::@expr16439 Match (@expr1073758478 endToken@var2777 , "%name%|," ) ) {
5653: endToken@var2777 =@expr1073758479 endToken@var2777 .@expr16650 next (@expr16651 ) ; }
5654: }
5655: if (@expr1073758482 endToken@var2777 &&@expr1073758483 endToken@var2777 .@expr16646 str (@expr16647 ) ==@expr1073758486 "{" ) {
5656: endToken@var2777 =@expr1073758487 endToken@var2777 .@expr1073758488 link (@expr1073758489 ) .@expr1073758490 next (@expr1073758491 ) ; }
5657: if (@expr1073758492 endToken@var2777 &&@expr1073758493 endToken@var2777 .@expr16646 str (@expr16647 ) ==@expr1073758496 ";" ) {
5658: Token ::@expr16513 eraseTokens (@expr1073758498 tok@var2771 , endToken@var2777 ) ;
5659: tok@var2771 .@expr16570 deleteThis (@expr16571 ) ;
5660: }
5661: } else { if (@expr1073758501 Token ::@expr16439 Match (@expr1073758503 closingBracket@var2776 , "> %type% %name% (" ) &&@expr1073758504 Token ::@expr16431 simpleMatch (@expr1073758506 closingBracket@var2776 .@expr16683 linkAt (@expr16684 3 ) , ") {" ) &&@expr1073758509 keep@var2767 .@expr16557 find (@expr16636 closingBracket@var2776 .@expr16637 strAt (@expr16638 2 ) ) ==@expr16639 keep@var2767 .@expr16562 end (@expr16563 ) ) {
5662: const Token * endToken@var2778 ; endToken@var2778 =@expr1073758517 closingBracket@var2776 .@expr16683 linkAt (@expr16684 3 ) .@expr1073758520 linkAt (@expr1073758521 1 ) .@expr1073758522 next (@expr1073758523 ) ;
5663: Token ::@expr16513 eraseTokens (@expr1073758525 tok@var2771 , endToken@var2778 ) ;
5664: tok@var2771 .@expr16570 deleteThis (@expr16571 ) ;
5665: } }
5666: }
5667: }
5668: }
5669: }
5670: }
5671:
5672: void Tokenizer :: removeExtraTemplateKeywords ( )
5673: {
5674: if (@expr1073758528 isCPP (@expr1073758529 ) ) {
5675: for (@expr1073758530 Token *@expr1073758531 tok@var2779 =@expr1073758532 list@var872 .@expr1073758533 front (@expr1073758534 ) ; tok@var2779 ; tok@var2779 =@expr1073758535 tok@var2779 .@expr16712 next (@expr16713 ) ) {
5676: if (@expr1073758538 Token ::@expr16715 Match (@expr1073758540 tok@var2779 , "%name%|>|) .|:: template %name%" ) ) {
5677: tok@var2779 .@expr16712 next (@expr16713 ) .@expr1073758543 deleteNext (@expr1073758544 ) ;
5678: Token * templateName@var2780 ; templateName@var2780 =@expr1073758545 tok@var2779 .@expr1073758546 tokAt (@expr1073758547 2 ) ;
5679: while (@expr1073758548 Token ::@expr16715 Match (@expr1073758550 templateName@var2780 , "%name%|::" ) ) {
5680: templateName@var2780 .@expr16727 isTemplate (@expr16728 true ) ;
5681: templateName@var2780 =@expr1073758553 templateName@var2780 .@expr1073758554 next (@expr1073758555 ) ;
5682: }
5683: if (@expr1073758556 Token ::@expr16715 Match (@expr1073758558 templateName@var2780 .@expr1073758559 previous (@expr1073758560 ) , "operator %op%|(" ) ) {
5684: templateName@var2780 .@expr16727 isTemplate (@expr16728 true ) ;
5685: if (@expr1073758563 templateName@var2780 .@expr1073758564 str (@expr1073758565 ) ==@expr1073758566 "(" &&@expr1073758567 templateName@var2780 .@expr16744 link (@expr16745 ) ) {
5686: templateName@var2780 .@expr16744 link (@expr16745 ) .@expr1073758572 isTemplate (@expr1073758573 true ) ; }
5687: }
5688: }
5689: }
5690: }
5691: }
5692:
5693: static std :: string getExpression ( const Token * tok@var2781 )
5694: {
5695: std ::@expr1073758574 string line@var2782 ;
5696: for (@expr1073758575 const Token *@expr16752 prev@var2783 =@expr1073758577 tok@var2781 .@expr1073758578 previous (@expr1073758579 ) ; prev@var2783 &&@expr1073758580 !@expr1073758581 Token ::@expr16758 Match (@expr1073758583 prev@var2783 , "[;{}]" ) ; prev@var2783 =@expr1073758584 prev@var2783 .@expr1073758585 previous (@expr1073758586 ) ) {
5697: line@var2782 =@expr1073758587 prev@var2783 .@expr1073758588 str (@expr1073758589 ) +@expr1073758590 " " +@expr1073758591 line@var2782 ; }
5698: line@var2782 +=@expr1073758592 "!!!" +@expr1073758593 tok@var2781 .@expr1073758594 str (@expr1073758595 ) +@expr1073758596 "!!!" ;
5699: for (@expr1073758597 const Token *@expr16752 next@var2784 =@expr1073758599 tok@var2781 .@expr1073758600 next (@expr1073758601 ) ; next@var2784 &&@expr1073758602 !@expr1073758603 Token ::@expr16758 Match (@expr1073758605 next@var2784 , "[;{}]" ) ; next@var2784 =@expr1073758606 next@var2784 .@expr1073758607 next (@expr1073758608 ) ) {
5700: line@var2782 =@expr1073758609 line@var2782 +@expr1073758610 " " +@expr1073758611 next@var2784 .@expr1073758612 str (@expr1073758613 ) ; }
5701: return line@var2782 ;
5702: }
5703:
5704: void Tokenizer :: splitTemplateRightAngleBrackets ( bool check@var2785 )
5705: {
5706: std ::@expr1073758614 set < std ::@expr1073758615 string > vars@var2786 ;
5707:
5708: for (@expr1073758616 Token *@expr1073758617 tok@var2787 =@expr1073758618 list@var872 .@expr1073758619 front (@expr1073758620 ) ; tok@var2787 ; tok@var2787 =@expr1073758621 tok@var2787 .@expr16798 next (@expr16799 ) ) {
5709: if (@expr1073758624 Token ::@expr16801 Match (@expr1073758626 tok@var2787 , "[;{}] %type% %type% [;,=]" ) &&@expr1073758627 tok@var2787 .@expr16798 next (@expr16799 ) .@expr1073758630 isStandardType (@expr1073758631 ) ) {
5710: vars@var2786 .@expr1073758632 insert (@expr1073758633 tok@var2787 .@expr1073758634 strAt (@expr1073758635 2 ) ) ; }
5711:
5712:
5713: if (@expr1073758636 tok@var2787 .@expr16813 previous (@expr16814 ) &&@expr1073758639 tok@var2787 .@expr1073758640 str (@expr1073758641 ) ==@expr1073758642 "<" &&@expr1073758643 TemplateSimplifier ::@expr1073758644 templateParameters (@expr1073758645 tok@var2787 ) &&@expr1073758646 vars@var2786 .@expr16823 find (@expr1073758648 tok@var2787 .@expr16813 previous (@expr16814 ) .@expr1073758651 str (@expr1073758652 ) ) ==@expr1073758653 vars@var2786 .@expr16830 end (@expr16831 ) ) {
5714: Token * endTok@var2788 ; endTok@var2788 =@expr1073758656 tok@var2787 .@expr1073758657 findClosingBracket (@expr1073758658 ) ;
5715: if (@expr16835 check@var2785 ) {
5716: if (@expr1073758660 Token ::@expr16801 Match (@expr1073758662 endTok@var2788 , ">>|>>=" ) ) {
5717: reportError (@expr16839 tok@var2787 , Severity ::@expr16840 debug , "dacaWrongSplitTemplateRightAngleBrackets" , "bad closing bracket for !!!<!!!: " +@expr16841 getExpression (@expr16842 tok@var2787 ) , false ) ; }
5718: continue ;
5719: }
5720: if (@expr1073758667 endTok@var2788 &&@expr1073758668 endTok@var2788 .@expr16845 str (@expr16846 ) ==@expr1073758671 ">>" ) {
5721: endTok@var2788 .@expr16845 str (@expr16849 ">" ) ;
5722: endTok@var2788 .@expr16850 insertToken (@expr16851 ">" ) ;
5723: } else { if (@expr1073758676 endTok@var2788 &&@expr1073758677 endTok@var2788 .@expr16845 str (@expr16846 ) ==@expr1073758680 ">>=" ) {
5724: endTok@var2788 .@expr16845 str (@expr16849 ">" ) ;
5725: endTok@var2788 .@expr16850 insertToken (@expr1073758684 "=" ) ;
5726: endTok@var2788 .@expr16850 insertToken (@expr16851 ">" ) ;
5727: } }
5728: } else { if (@expr1073758687 Token ::@expr16801 Match (@expr1073758689 tok@var2787 , "class|struct|union|=|:|public|protected|private %name% <" ) &&@expr1073758690 vars@var2786 .@expr16823 find (@expr1073758692 tok@var2787 .@expr16798 next (@expr16799 ) .@expr1073758695 str (@expr1073758696 ) ) ==@expr1073758697 vars@var2786 .@expr16830 end (@expr16831 ) ) {
5729: Token * endTok@var2789 ; endTok@var2789 =@expr1073758700 tok@var2787 .@expr1073758701 tokAt (@expr1073758702 2 ) .@expr1073758703 findClosingBracket (@expr1073758704 ) ;
5730: if (@expr16835 check@var2785 ) {
5731: if (@expr1073758706 Token ::@expr1073758707 simpleMatch (@expr1073758708 endTok@var2789 , ">>" ) ) {
5732: reportError (@expr16839 tok@var2787 , Severity ::@expr16840 debug , "dacaWrongSplitTemplateRightAngleBrackets" , "bad closing bracket for !!!<!!!: " +@expr16841 getExpression (@expr16842 tok@var2787 ) , false ) ; }
5733: continue ;
5734: }
5735: if (@expr1073758713 Token ::@expr16801 Match (@expr1073758715 endTok@var2789 , ">> ;|{|%type%" ) ) {
5736: endTok@var2789 .@expr1073758716 str (@expr1073758717 ">" ) ;
5737: endTok@var2789 .@expr1073758718 insertToken (@expr1073758719 ">" ) ;
5738: }
5739: } }
5740: }
5741: }
5742:
5743: void Tokenizer :: removeMacrosInGlobalScope ( )
5744: {
5745: for (@expr1073758720 Token *@expr1073758721 tok@var2790 =@expr1073758722 list@var872 .@expr1073758723 front (@expr1073758724 ) ; tok@var2790 ; tok@var2790 =@expr1073758725 tok@var2790 .@expr16902 next (@expr16903 ) ) {
5746: if (@expr1073758728 tok@var2790 .@expr16905 str (@expr16906 ) ==@expr1073758731 "(" ) {
5747: tok@var2790 =@expr1073758732 tok@var2790 .@expr16909 link (@expr16910 ) ;
5748: if (@expr1073758735 Token ::@expr16912 Match (@expr1073758737 tok@var2790 , ") %type% {" ) &&@expr1073758738
5749: !@expr1073758739 Token ::@expr16912 Match (@expr1073758741 tok@var2790 .@expr16902 next (@expr16903 ) , "const|namespace|class|struct|union|noexcept|override|final|volatile|mutable" ) ) {
5750: tok@var2790 .@expr1073758744 deleteNext (@expr1073758745 ) ; }
5751: }
5752:
5753: if (@expr1073758746 Token ::@expr16912 Match (@expr1073758748 tok@var2790 , "%type%" ) &&@expr1073758749 tok@var2790 .@expr1073758750 isUpperCaseName (@expr1073758751 ) &&@expr1073758752
5754: (@expr1073758753 !@expr1073758754 tok@var2790 .@expr16931 previous (@expr16932 ) ||@expr1073758757 Token ::@expr16912 Match (@expr1073758759 tok@var2790 .@expr16931 previous (@expr16932 ) , "[;{}]" ) ||@expr1073758762 (@expr1073758763 tok@var2790 .@expr16931 previous (@expr16932 ) .@expr1073758766 isName (@expr1073758767 ) &&@expr1073758768 endsWith (@expr1073758769 tok@var2790 .@expr16931 previous (@expr16932 ) .@expr1073758772 str (@expr1073758773 ) , ':' ) ) ) ) {
5755: const Token * tok2@var2791 ; tok2@var2791 =@expr1073758774 tok@var2790 .@expr16902 next (@expr16903 ) ;
5756: if (@expr1073758777 tok2@var2791 &&@expr1073758778 tok2@var2791 .@expr1073758779 str (@expr1073758780 ) ==@expr1073758781 "(" ) {
5757: tok2@var2791 =@expr1073758782 tok2@var2791 .@expr1073758783 link (@expr1073758784 ) .@expr1073758785 next (@expr1073758786 ) ; }
5758:
5759:
5760: while (@expr1073758787 Token ::@expr16912 Match (@expr16965 tok2@var2791 , "%type% (" ) &&@expr1073758790 tok2@var2791 .@expr1073758791 isUpperCaseName (@expr1073758792 ) ) {
5761: tok2@var2791 =@expr1073758793 tok2@var2791 .@expr1073758794 linkAt (@expr1073758795 1 ) .@expr1073758796 next (@expr1073758797 ) ; }
5762:
5763: if (@expr1073758798 Token ::@expr16912 Match (@expr1073758800 tok@var2790 , "%name% (" ) &&@expr1073758801 Token ::@expr16912 Match (@expr1073758803 tok2@var2791 , "%name% *|&|::|<| %name%" ) &&@expr1073758804 !@expr1073758805 Token ::@expr16912 Match (@expr1073758807 tok2@var2791 , "namespace|class|struct|union|private:|protected:|public:" ) ) {
5764: unknownMacroError (@expr16984 tok@var2790 ) ; }
5765:
5766: if (@expr1073758809 Token ::@expr16912 Match (@expr1073758811 tok@var2790 , "%type% (" ) &&@expr1073758812 Token ::@expr16912 Match (@expr16965 tok2@var2791 , "%type% (" ) &&@expr1073758815 !@expr1073758816 Token ::@expr16912 Match (@expr1073758818 tok2@var2791 , "noexcept|throw" ) &&@expr1073758819 isFunctionHead (@expr1073758820 tok2@var2791 .@expr1073758821 next (@expr1073758822 ) , ":;{" ) ) {
5767: unknownMacroError (@expr16984 tok@var2790 ) ; }
5768:
5769:
5770: if (@expr1073758824 Token ::@expr16912 Match (@expr1073758826 tok2@var2791 , "namespace|class|struct|union" ) ) {
5771:
5772: const Token * tok3@var2792 ; tok3@var2792 =@expr1073758827 tok2@var2791 ;
5773: while (@expr1073758828 tok3@var2792 &&@expr1073758829 !@expr1073758830 Token ::@expr16912 Match (@expr1073758832 tok3@var2792 , "[;{}()]" ) ) {
5774: tok3@var2792 =@expr1073758833 tok3@var2792 .@expr1073758834 next (@expr1073758835 ) ; }
5775: if (@expr1073758836 tok3@var2792 &&@expr1073758837 tok3@var2792 .@expr1073758838 str (@expr1073758839 ) ==@expr1073758840 "{" ) {
5776: Token ::@expr17017 eraseTokens (@expr17018 tok@var2790 , tok2@var2791 ) ;
5777: tok@var2790 .@expr17019 deleteThis (@expr17020 ) ;
5778: }
5779: continue ;
5780: }
5781:
|
5792:
5793: if (@expr1073758845 Token ::@expr16912 Match (@expr1073758847 tok2@var2791 , "%type% :: %type%" ) ) {
5794: const Token * tok3@var2793 ; tok3@var2793 =@expr1073758848 tok2@var2791 ;
5795: while (@expr1073758849 Token ::@expr16912 Match (@expr1073758851 tok3@var2793 , "%type% :: %type% ::" ) ) {
5796: tok3@var2793 =@expr1073758852 tok3@var2793 .@expr1073758853 tokAt (@expr1073758854 2 ) ; }
5797: if (@expr1073758855 Token ::@expr16912 Match (@expr1073758857 tok3@var2793 , "%type% :: %type% (" ) &&@expr1073758858 tok3@var2793 .@expr1073758859 str (@expr1073758860 ) ==@expr1073758861 tok3@var2793 .@expr1073758862 strAt (@expr1073758863 2 ) ) {
5798: Token ::@expr17017 eraseTokens (@expr17018 tok@var2790 , tok2@var2791 ) ;
5799: tok@var2790 .@expr17019 deleteThis (@expr17020 ) ;
5800: }
5801: continue ;
5802: }
5803: }
5804:
5805:
5806: if (@expr1073758868 tok@var2790 .@expr16905 str (@expr16906 ) ==@expr1073758871 "{" ) {
5807: const Token * prev@var2794 ; prev@var2794 =@expr1073758872 tok@var2790 .@expr16931 previous (@expr16932 ) ;
5808: while (@expr1073758875 prev@var2794 &&@expr1073758876 prev@var2794 .@expr1073758877 isName (@expr1073758878 ) ) {
5809: prev@var2794 =@expr1073758879 prev@var2794 .@expr1073758880 previous (@expr1073758881 ) ; }
5810: if (@expr1073758882 prev@var2794 &&@expr1073758883 prev@var2794 .@expr1073758884 str (@expr1073758885 ) ==@expr1073758886 ")" ) {
5811: tok@var2790 =@expr1073758887 tok@var2790 .@expr16909 link (@expr16910 ) ; }
5812: }
5813: }
5814: }
5815:
5816:
5817:
5818: void Tokenizer :: removePragma ( )
5819: {
5820: if (@expr1073758890 isC (@expr1073758891 ) &&@expr1073758892 mSettings@var879 .@expr17069 standards@var3567 .@expr1073758894 c@var3588 ==@expr1073758895 Standards ::@expr1073758896 C89 ) {
5821: return ; }
5822: if (@expr1073758897 isCPP (@expr1073758898 ) &&@expr1073758899 mSettings@var879 .@expr17069 standards@var3567 .@expr1073758901 cpp@var3568 ==@expr1073758902 Standards ::@expr1073758903 CPP03 ) {
5823: return ; }
5824: for (@expr1073758904 Token *@expr1073758905 tok@var2795 =@expr1073758906 list@var872 .@expr1073758907 front (@expr1073758908 ) ; tok@var2795 ; tok@var2795 =@expr1073758909 tok@var2795 .@expr1073758910 next (@expr1073758911 ) ) {
5825: while (@expr1073758912 Token ::@expr1073758913 simpleMatch (@expr1073758914 tok@var2795 , "_Pragma (" ) ) {
5826: Token ::@expr1073758915 eraseTokens (@expr1073758916 tok@var2795 , tok@var2795 .@expr1073758917 linkAt (@expr1073758918 1 ) .@expr1073758919 next (@expr1073758920 ) ) ;
5827: tok@var2795 .@expr1073758921 deleteThis (@expr1073758922 ) ;
5828: }
5829: }
5830: }
5831:
5832:
5833:
5834: void Tokenizer :: removeMacroInClassDef ( )
5835: {
5836: for (@expr1073758923 Token *@expr1073758924 tok@var2796 =@expr1073758925 list@var872 .@expr1073758926 front (@expr1073758927 ) ; tok@var2796 ; tok@var2796 =@expr1073758928 tok@var2796 .@expr17105 next (@expr17106 ) ) {
5837: if (@expr1073758931 !@expr1073758932 Token ::@expr1073758933 Match (@expr1073758934 tok@var2796 , "class|struct %name% %name% {|:" ) ) {
5838: continue ; }
5839:
5840: const bool nextIsUppercase@var2797 =@expr1073758935 tok@var2796 .@expr17105 next (@expr17106 ) .@expr1073758938 isUpperCaseName (@expr1073758939 ) ;
5841: const bool afterNextIsUppercase@var2798 =@expr1073758940 tok@var2796 .@expr1073758941 tokAt (@expr1073758942 2 ) .@expr1073758943 isUpperCaseName (@expr1073758944 ) ;
5842: if (@expr1073758945 nextIsUppercase@var2797 &&@expr1073758946 !@expr1073758947 afterNextIsUppercase@var2798 ) {
5843: tok@var2796 .@expr1073758948 deleteNext (@expr1073758949 ) ; }
5844: else { if (@expr1073758950 !@expr1073758951 nextIsUppercase@var2797 &&@expr1073758952 afterNextIsUppercase@var2798 ) {
5845: tok@var2796 .@expr17105 next (@expr17106 ) .@expr1073758955 deleteNext (@expr1073758956 ) ; } }
5846: }
5847: }
5848:
5849:
5850:
5851: void Tokenizer :: removeMacroInVarDecl ( )
5852: {
5853: for (@expr1073758957 Token *@expr1073758958 tok@var2799 =@expr1073758959 list@var872 .@expr1073758960 front (@expr1073758961 ) ; tok@var2799 ; tok@var2799 =@expr1073758962 tok@var2799 .@expr17139 next (@expr17140 ) ) {
5854: if (@expr1073758965 Token ::@expr17142 Match (@expr1073758967 tok@var2799 , "[;{}] %name% (" ) &&@expr1073758968 tok@var2799 .@expr17139 next (@expr17140 ) .@expr1073758971 isUpperCaseName (@expr1073758972 ) ) {
5855:
5856: const Token * tok2@var2800 ; tok2@var2800 =@expr1073758973 tok@var2799 ;
5857: int parlevel@var2801 ; parlevel@var2801 =@expr1073758974 0 ;
5858: while (@expr1073758975 tok2@var2800 ) {
5859: if (@expr1073758976 tok2@var2800 .@expr17153 str (@expr17154 ) ==@expr1073758979 "(" ) {
5860: ++@expr1073758980 parlevel@var2801 ; }
5861: else { if (@expr1073758981 tok2@var2800 .@expr17153 str (@expr17154 ) ==@expr1073758984 ")" ) {
5862: if (@expr1073758985 --@expr1073758986 parlevel@var2801 <=@expr1073758987 0 ) {
5863: break ; }
5864: } }
5865: tok2@var2800 =@expr1073758988 tok2@var2800 .@expr17165 next (@expr17166 ) ;
5866: }
5867: tok2@var2800 =@expr1073758991 tok2@var2800 ?@expr1073758992 tok2@var2800 .@expr17165 next (@expr17166 ) :@expr1073758995 nullptr ;
5868:
5869:
5870: const Token * tok3@var2802 ; tok3@var2802 =@expr1073758996 tok2@var2800 ;
5871: while (@expr1073758997 tok3@var2802 &&@expr1073758998 tok3@var2802 .@expr1073758999 isUpperCaseName (@expr1073759000 ) ) {
5872: tok3@var2802 =@expr1073759001 tok3@var2802 .@expr1073759002 next (@expr1073759003 ) ; }
5873: if (@expr1073759004 tok3@var2802 &&@expr1073759005 (@expr1073759006 tok3@var2802 .@expr1073759007 isStandardType (@expr1073759008 ) ||@expr1073759009 Token ::@expr17142 Match (@expr1073759011 tok3@var2802 , "const|static|struct|union|class" ) ) ) {
5874: Token ::@expr1073759012 eraseTokens (@expr1073759013 tok@var2799 , tok2@var2800 ) ; }
5875: }
5876: }
5877: }
5878:
5879:
5880: void Tokenizer :: addSemicolonAfterUnknownMacro ( )
5881: {
5882: if (@expr1073759014 !@expr1073759015 isCPP (@expr1073759016 ) ) {
5883: return ; }
5884: for (@expr1073759017 Token *@expr1073759018 tok@var2803 =@expr1073759019 list@var872 .@expr1073759020 front (@expr1073759021 ) ; tok@var2803 ; tok@var2803 =@expr1073759022 tok@var2803 .@expr1073759023 next (@expr1073759024 ) ) {
5885: if (@expr1073759025 tok@var2803 .@expr1073759026 str (@expr1073759027 ) !=@expr1073759028 ")" ) {
5886: continue ; }
5887: const Token * macro@var2804 ; macro@var2804 =@expr1073759029 tok@var2803 .@expr17206 link (@expr17207 ) ?@expr1073759032 tok@var2803 .@expr17206 link (@expr17207 ) .@expr1073759035 previous (@expr1073759036 ) :@expr1073759037 nullptr ;
5888: if (@expr1073759038 !@expr1073759039 macro@var2804 ||@expr1073759040 !@expr1073759041 macro@var2804 .@expr1073759042 isName (@expr1073759043 ) ) {
5889: continue ; }
5890: if (@expr1073759044 Token ::@expr17221 simpleMatch (@expr1073759046 tok@var2803 , ") try" ) &&@expr1073759047 !@expr1073759048 Token ::@expr1073759049 Match (@expr1073759050 macro@var2804 , "if|for|while" ) ) {
5891: tok@var2803 .@expr17227 insertToken (@expr17228 ";" ) ; }
5892: else { if (@expr1073759053 Token ::@expr17221 simpleMatch (@expr1073759055 tok@var2803 , ") using" ) ) {
5893: tok@var2803 .@expr17227 insertToken (@expr17228 ";" ) ; } }
5894: }
5895: }
5896:
5897:
5898: void Tokenizer :: removeRedundantAssignment ( )
5899: {
5900: for (@expr1073759058 Token *@expr17235 tok@var2805 =@expr1073759060 list@var872 .@expr1073759061 front (@expr1073759062 ) ; tok@var2805 ; tok@var2805 =@expr1073759063 tok@var2805 .@expr17240 next (@expr17241 ) ) {
5901: if (@expr1073759066 tok@var2805 .@expr1073759067 str (@expr1073759068 ) ==@expr1073759069 "{" ) {
5902: tok@var2805 =@expr1073759070 tok@var2805 .@expr1073759071 link (@expr1073759072 ) ; }
5903:
5904: const Token * const start@var2806 ; start@var2806 =@expr1073759073 const_cast < Token *@expr17235 > (@expr1073759075 startOfExecutableScope (@expr1073759076 tok@var2805 ) ) ;
5905: if (@expr1073759077 start@var2806 ) {
5906: tok@var2805 =@expr1073759078 start@var2806 .@expr1073759079 previous (@expr1073759080 ) ;
5907:
5908: std ::@expr1073759081 set < int > localvars@var2807 ;
5909: const Token * const end@var2808 ; end@var2808 =@expr1073759082 tok@var2805 .@expr17240 next (@expr17241 ) .@expr1073759085 link (@expr1073759086 ) ;
5910: for (@expr1073759087 Token *@expr17235 tok2@var2809 =@expr1073759089 tok@var2805 .@expr17240 next (@expr17241 ) ; tok2@var2809 &&@expr1073759092 tok2@var2809 !=@expr1073759093 end@var2808 ; tok2@var2809 =@expr1073759094 tok2@var2809 .@expr17271 next (@expr17272 ) ) {
5911:
5912: if (@expr1073759097 Token ::@expr17274 Match (@expr1073759099 tok2@var2809 , "class|struct %type% {|:" ) ) {
5913:
5914: tok2@var2809 =@expr1073759100 tok2@var2809 .@expr17277 tokAt (@expr17278 2 ) ;
5915: while (@expr1073759103 tok2@var2809 &&@expr1073759104 tok2@var2809 .@expr1073759105 str (@expr1073759106 ) !=@expr1073759107 "{" ) {
5916: tok2@var2809 =@expr1073759108 tok2@var2809 .@expr17271 next (@expr17272 ) ; }
5917:
5918: if (@expr1073759111 tok2@var2809 ) {
5919: tok2@var2809 =@expr1073759112 tok2@var2809 .@expr1073759113 link (@expr1073759114 ) ; }
5920: else {
5921: return ; }
5922: } else { if (@expr1073759115 Token ::@expr17274 Match (@expr1073759117 tok2@var2809 , "[;{}] %type% * %name% ;" ) &&@expr1073759118 tok2@var2809 .@expr17271 next (@expr17272 ) .@expr1073759121 str (@expr1073759122 ) !=@expr1073759123 "return" ) {
5923: tok2@var2809 =@expr1073759124 tok2@var2809 .@expr17277 tokAt (@expr1073759126 3 ) ;
5924: localvars@var2807 .@expr17303 insert (@expr17304 tok2@var2809 .@expr17305 varId (@expr17306 ) ) ;
5925: } else { if (@expr1073759131 Token ::@expr17274 Match (@expr1073759133 tok2@var2809 , "[;{}] %type% %name% ;" ) &&@expr1073759134 tok2@var2809 .@expr17271 next (@expr17272 ) .@expr1073759137 isStandardType (@expr1073759138 ) ) {
5926: tok2@var2809 =@expr1073759139 tok2@var2809 .@expr17277 tokAt (@expr17278 2 ) ;
5927: localvars@var2807 .@expr17303 insert (@expr17304 tok2@var2809 .@expr17305 varId (@expr17306 ) ) ;
5928: } else { if (@expr1073759146 tok2@var2809 .@expr17305 varId (@expr17306 ) &&@expr1073759149
5929: !@expr1073759150 Token ::@expr17274 Match (@expr1073759152 tok2@var2809 .@expr1073759153 previous (@expr1073759154 ) , "[;{}] %name% = %char%|%num%|%name% ;" ) ) {
5930: localvars@var2807 .@expr17331 erase (@expr1073759156 tok2@var2809 .@expr17305 varId (@expr17306 ) ) ;
5931: } } } }
5932: }
5933: localvars@var2807 .@expr17331 erase (@expr1073759160 0 ) ;
5934: if (@expr1073759161 !@expr1073759162 localvars@var2807 .@expr1073759163 empty (@expr1073759164 ) ) {
5935: for (@expr1073759165 Token *@expr17235 tok2@var2810 =@expr1073759167 tok@var2805 .@expr17240 next (@expr17241 ) ; tok2@var2810 &&@expr1073759170 tok2@var2810 !=@expr1073759171 end@var2808 ; ) {
5936: if (@expr1073759172 Token ::@expr17274 Match (@expr1073759174 tok2@var2810 , "[;{}] %type% %name% ;" ) &&@expr1073759175 localvars@var2807 .@expr17352 find (@expr1073759177 tok2@var2810 .@expr17354 tokAt (@expr1073759179 2 ) .@expr1073759180 varId (@expr1073759181 ) ) !=@expr1073759182 localvars@var2807 .@expr17359 end (@expr17360 ) ) {
5937: tok2@var2810 .@expr17361 deleteNext (@expr1073759186 3 ) ;
5938: } else { if (@expr1073759187 (@expr1073759188 Token ::@expr17274 Match (@expr1073759190 tok2@var2810 , "[;{}] %type% * %name% ;" ) &&@expr1073759191
5939: localvars@var2807 .@expr17352 find (@expr1073759193 tok2@var2810 .@expr17354 tokAt (@expr1073759195 3 ) .@expr1073759196 varId (@expr1073759197 ) ) !=@expr1073759198 localvars@var2807 .@expr17359 end (@expr17360 ) ) ||@expr1073759201
5940: (@expr1073759202 Token ::@expr17274 Match (@expr1073759204 tok2@var2810 , "[;{}] %name% = %any% ;" ) &&@expr1073759205
5941: localvars@var2807 .@expr17352 find (@expr1073759207 tok2@var2810 .@expr17384 next (@expr17385 ) .@expr1073759210 varId (@expr1073759211 ) ) !=@expr1073759212 localvars@var2807 .@expr17359 end (@expr17360 ) ) ) {
5942: tok2@var2810 .@expr17361 deleteNext (@expr1073759216 4 ) ;
5943: } else {
5944: tok2@var2810 =@expr1073759217 tok2@var2810 .@expr17384 next (@expr17385 ) ; } }
5945: }
5946: }
5947: }
5948: }
5949: }
5950:
5951: void Tokenizer :: simplifyRealloc ( )
5952: {
5953: for (@expr1073759220 Token *@expr1073759221 tok@var2811 =@expr1073759222 list@var872 .@expr1073759223 front (@expr1073759224 ) ; tok@var2811 ; tok@var2811 =@expr1073759225 tok@var2811 .@expr17402 next (@expr17403 ) ) {
5954: if (@expr1073759228 Token ::@expr17405 Match (@expr1073759230 tok@var2811 , "(|[" ) ||@expr1073759231
5955: (@expr1073759232 tok@var2811 .@expr17409 str (@expr1073759234 ) ==@expr1073759235 "{" &&@expr1073759236 tok@var2811 .@expr17413 previous (@expr17414 ) &&@expr1073759239 tok@var2811 .@expr17413 previous (@expr17414 ) .@expr1073759242 str (@expr1073759243 ) ==@expr1073759244 "=" ) ) {
5956: tok@var2811 =@expr1073759245 tok@var2811 .@expr1073759246 link (@expr1073759247 ) ; }
5957: else { if (@expr1073759248 Token ::@expr17405 Match (@expr1073759250 tok@var2811 , "[;{}] %name% = realloc (" ) ) {
5958: tok@var2811 =@expr1073759251 tok@var2811 .@expr17428 tokAt (@expr17429 3 ) ;
5959: if (@expr1073759254 Token ::@expr17431 simpleMatch (@expr1073759256 tok@var2811 .@expr17402 next (@expr17403 ) , "( 0 ," ) ) {
5960:
5961: if (@expr1073759259 !@expr1073759260 Token ::@expr17431 simpleMatch (@expr1073759262 tok@var2811 .@expr17402 next (@expr17403 ) .@expr17441 link (@expr17442 ) , ") ;" ) ||@expr1073759267 tok@var2811 .@expr17402 next (@expr17403 ) .@expr17441 link (@expr17442 ) .@expr1073759272 previous (@expr1073759273 ) ==@expr1073759274 tok@var2811 .@expr17428 tokAt (@expr17429 3 ) ) {
5962: continue ; }
5963:
5964:
5965: tok@var2811 .@expr17402 next (@expr17403 ) .@expr1073759279 deleteNext (@expr1073759280 2 ) ;
5966:
5967:
5968: tok@var2811 .@expr17409 str (@expr1073759282 "malloc" ) ;
5969: tok@var2811 =@expr1073759283 tok@var2811 .@expr17402 next (@expr17403 ) .@expr17441 link (@expr17442 ) ;
5970: } else {
5971: Token * tok2@var2812 ; tok2@var2812 =@expr1073759288 tok@var2811 .@expr17402 next (@expr17403 ) .@expr17441 link (@expr17442 ) .@expr1073759293 tokAt (@expr1073759294 -2 ) ;
5972:
5973: if (@expr1073759295 !@expr1073759296 Token ::@expr17431 simpleMatch (@expr1073759298 tok2@var2812 , ", 0 ) ;" ) ||@expr1073759299 tok2@var2812 ==@expr1073759300 tok@var2811 .@expr17428 tokAt (@expr1073759302 2 ) ) {
5974: continue ; }
5975:
5976:
5977: tok2@var2812 =@expr1073759303 tok2@var2812 .@expr1073759304 previous (@expr1073759305 ) ;
5978: tok2@var2812 .@expr1073759306 deleteNext (@expr1073759307 2 ) ;
5979:
5980: tok@var2811 .@expr17409 str (@expr1073759309 "free" ) ;
5981:
5982: tok@var2811 =@expr1073759310 tok@var2811 .@expr17413 previous (@expr17414 ) ;
5983: tok@var2811 .@expr1073759313 insertToken (@expr1073759314 "0" ) ;
5984:
5985: tok2@var2812 =@expr1073759315 tok2@var2812 .@expr1073759316 next (@expr1073759317 ) ;
5986: Token ::@expr1073759318 move (@expr1073759319 tok@var2811 .@expr17413 previous (@expr17414 ) , tok@var2811 .@expr17402 next (@expr17403 ) , tok2@var2812 ) ;
5987:
5988: tok2@var2812 .@expr1073759324 insertToken (@expr1073759325 ";" ) ;
5989:
5990: tok@var2811 =@expr1073759326 tok@var2811 .@expr17402 next (@expr17403 ) ;
5991: }
5992: } }
5993: }
5994: }
5995:
5996: void Tokenizer :: simplifyEmptyNamespaces ( )
5997: {
5998: if (@expr1073759329 isC (@expr1073759330 ) ) {
5999: return ; }
6000:
6001: bool goback@var2813 ; goback@var2813 =@expr1073759331 false ;
6002: for (@expr1073759332 Token *@expr1073759333 tok@var2814 =@expr1073759334 list@var872 .@expr1073759335 front (@expr1073759336 ) ; tok@var2814 ; tok@var2814 =@expr1073759337 tok@var2814 ?@expr1073759338 tok@var2814 .@expr1073759339 next (@expr1073759340 ) :@expr1073759341 nullptr ) {
6003: if (@expr1073759342 goback@var2813 ) {
6004: tok@var2814 =@expr1073759343 tok@var2814 .@expr17520 previous (@expr17521 ) ;
6005: goback@var2813 =@expr1073759346 false ;
6006: }
6007: if (@expr1073759347 Token ::@expr17524 Match (@expr1073759349 tok@var2814 , "(|[|{" ) ) {
6008: tok@var2814 =@expr1073759350 tok@var2814 .@expr1073759351 link (@expr1073759352 ) ;
6009: continue ;
6010: }
6011: if (@expr1073759353 !@expr1073759354 Token ::@expr17524 Match (@expr1073759356 tok@var2814 , "namespace %name%| {" ) ) {
6012: continue ; }
6013: bool isAnonymousNS@var2815 ; isAnonymousNS@var2815 =@expr1073759357 tok@var2814 .@expr17534 strAt (@expr1073759359 1 ) ==@expr1073759360 "{" ;
6014: if (@expr1073759361 tok@var2814 .@expr17534 strAt (@expr1073759363 3 -@expr17540 isAnonymousNS@var2815 ) ==@expr1073759365 "}" ) {
6015: tok@var2814 .@expr17542 deleteNext (@expr1073759367 3 -@expr17540 isAnonymousNS@var2815 ) ;
6016: if (@expr1073759369 !@expr1073759370 tok@var2814 .@expr17520 previous (@expr17521 ) ) {
6017:
6018: tok@var2814 .@expr1073759373 deleteThis (@expr1073759374 ) ;
6019: goback@var2813 =@expr1073759375 true ;
6020: } else {
6021: tok@var2814 =@expr1073759376 tok@var2814 .@expr17520 previous (@expr17521 ) ;
6022: tok@var2814 .@expr17542 deleteNext (@expr1073759380 ) ;
6023: if (@expr1073759381 tok@var2814 .@expr1073759382 str (@expr1073759383 ) ==@expr1073759384 "{" ) {
6024:
6025: tok@var2814 =@expr1073759385 tok@var2814 .@expr17562 tokAt (@expr17563 -2 ) ?@expr1073759388 tok@var2814 .@expr17562 tokAt (@expr17563 -2 ) :@expr1073759391 tok@var2814 .@expr17520 previous (@expr17521 ) ;
6026: goback@var2813 =@expr1073759394 true ;
6027: }
6028: }
6029: } else {
6030: tok@var2814 =@expr1073759395 tok@var2814 .@expr17562 tokAt (@expr1073759397 2 -@expr1073759398 isAnonymousNS@var2815 ) ;
6031: }
6032: }
6033: }
6034:
6035: void Tokenizer :: simplifyFlowControl ( )
6036: {
6037: for (@expr1073759399 Token *@expr17576 begin@var2816 =@expr1073759401 list@var872 .@expr1073759402 front (@expr1073759403 ) ; begin@var2816 ; begin@var2816 =@expr1073759404 begin@var2816 .@expr17581 next (@expr17582 ) ) {
6038:
6039: if (@expr1073759407 Token ::@expr17584 Match (@expr1073759409 begin@var2816 , "(|[" ) ||@expr1073759410
6040: (@expr1073759411 begin@var2816 .@expr1073759412 str (@expr1073759413 ) ==@expr1073759414 "{" &&@expr1073759415 begin@var2816 .@expr1073759416 previous (@expr1073759417 ) &&@expr1073759418 begin@var2816 .@expr1073759419 strAt (@expr1073759420 -1 ) ==@expr1073759421 "=" ) ) {
6041: begin@var2816 =@expr1073759422 begin@var2816 .@expr1073759423 link (@expr1073759424 ) ; }
6042:
6043:
6044: if (@expr1073759425 !@expr1073759426 Token ::@expr1073759427 simpleMatch (@expr1073759428 begin@var2816 , ") {" ) &&@expr1073759429 !@expr1073759430 Token ::@expr17584 Match (@expr1073759432 begin@var2816 , ") %name% {" ) ) {
6045: continue ; }
6046:
6047: Token * end@var2817 ; end@var2817 =@expr1073759433 begin@var2816 .@expr1073759434 linkAt (@expr1073759435 1 +@expr1073759436 (@expr1073759437 begin@var2816 .@expr17581 next (@expr17582 ) .@expr1073759440 str (@expr1073759441 ) ==@expr1073759442 "{" ?@expr1073759443 0 :@expr1073759444 1 ) ) ;
6048: int indentLevel@var2818 ; indentLevel@var2818 =@expr1073759445 0 ;
6049: bool stilldead@var2819 ; stilldead@var2819 =@expr1073759446 false ;
6050:
6051: for (@expr1073759447 Token *@expr17576 tok@var2820 =@expr1073759449 begin@var2816 ; tok@var2820 &&@expr1073759450 tok@var2820 !=@expr1073759451 end@var2817 ; tok@var2820 =@expr1073759452 tok@var2820 .@expr17629 next (@expr17630 ) ) {
6052: if (@expr1073759455 Token ::@expr17584 Match (@expr1073759457 tok@var2820 , "(|[" ) ) {
6053: tok@var2820 =@expr1073759458 tok@var2820 .@expr17635 link (@expr17636 ) ;
6054: continue ;
6055: }
6056:
6057: if (@expr1073759461 tok@var2820 .@expr17638 str (@expr17639 ) ==@expr1073759464 "{" ) {
6058: if (@expr1073759465 tok@var2820 .@expr17642 previous (@expr17643 ) &&@expr1073759468 tok@var2820 .@expr17642 previous (@expr17643 ) .@expr1073759471 str (@expr1073759472 ) ==@expr1073759473 "=" ) {
6059: tok@var2820 =@expr1073759474 tok@var2820 .@expr17635 link (@expr17636 ) ;
6060: continue ;
6061: }
6062: ++@expr1073759477 indentLevel@var2818 ;
6063: } else { if (@expr1073759478 tok@var2820 .@expr17638 str (@expr17639 ) ==@expr1073759481 "}" ) {
6064: if (@expr17658 indentLevel@var2818 ==@expr17659 0 ) {
6065: break ; }
6066: --@expr1073759484 indentLevel@var2818 ;
6067: if (@expr1073759485 stilldead@var2819 ) {
6068: eraseDeadCode (@expr17662 tok@var2820 , nullptr ) ;
6069: if (@expr1073759487 indentLevel@var2818 ==@expr1073759488 1 ||@expr1073759489 tok@var2820 .@expr17629 next (@expr17630 ) .@expr17668 str (@expr17669 ) !=@expr1073759494 "}" ||@expr1073759495 !@expr1073759496 Token ::@expr17584 Match (@expr17674 tok@var2820 .@expr17629 next (@expr17630 ) .@expr17677 link (@expr17678 ) .@expr17679 previous (@expr17680 ) , ";|{|}|do {" ) ) {
6070: stilldead@var2819 =@expr1073759505 false ; }
6071: continue ;
6072: }
6073: } }
6074:
6075: if (@expr17658 indentLevel@var2818 ==@expr17659 0 ) {
6076: continue ; }
6077:
6078: if (@expr1073759508 Token ::@expr17584 Match (@expr1073759510 tok@var2820 , "continue|break ;" ) ) {
6079: tok@var2820 =@expr1073759511 tok@var2820 .@expr17629 next (@expr17630 ) ;
6080: eraseDeadCode (@expr17662 tok@var2820 , nullptr ) ;
6081:
6082: } else { if (@expr1073759515 Token ::@expr17584 Match (@expr1073759517 tok@var2820 , "return|goto" ) ||@expr1073759518
6083: (@expr1073759519 Token ::@expr17584 Match (@expr1073759521 tok@var2820 .@expr17642 previous (@expr17643 ) , "[;{}] %name% (" ) &&@expr1073759524
6084: mSettings@var879 .@expr1073759525 library@var3563 .@expr1073759526 isnoreturn (@expr1073759527 tok@var2820 ) ) ||@expr1073759528
6085: (@expr1073759529 isCPP (@expr1073759530 ) &&@expr1073759531 tok@var2820 .@expr17638 str (@expr17639 ) ==@expr1073759534 "throw" ) ) {
6086: if (@expr1073759535 tok@var2820 .@expr17629 next (@expr17630 ) .@expr17668 str (@expr17669 ) ==@expr17716 "}" ) {
6087: syntaxError (@expr1073759541 tok@var2820 .@expr17629 next (@expr17630 ) ) ; }
6088:
6089:
6090: for (@expr1073759544 Token *@expr17576 tok2@var2821 =@expr1073759546 tok@var2820 .@expr17629 next (@expr17630 ) ; tok2@var2821 ; tok2@var2821 =@expr1073759549 tok2@var2821 .@expr1073759550 next (@expr1073759551 ) ) {
6091: if (@expr1073759552 Token ::@expr17584 Match (@expr1073759554 tok2@var2821 , "(|[" ) ) {
6092: tok2@var2821 =@expr1073759555 tok2@var2821 .@expr1073759556 link (@expr1073759557 ) ;
6093: } else { if (@expr1073759558 tok2@var2821 .@expr1073759559 str (@expr1073759560 ) ==@expr1073759561 ";" ) {
6094: tok@var2820 =@expr1073759562 tok2@var2821 ;
6095: eraseDeadCode (@expr17662 tok@var2820 , nullptr ) ;
6096: break ;
6097: } else { if (@expr1073759564 Token ::@expr17584 Match (@expr1073759566 tok2@var2821 , "[{}]" ) ) {
6098: break ; } } }
6099: }
6100:
6101:
6102: if (@expr1073759567 indentLevel@var2818 >@expr1073759568 1 &&@expr1073759569 tok@var2820 .@expr17629 next (@expr17630 ) .@expr17668 str (@expr17669 ) ==@expr17716 "}" &&@expr1073759575 Token ::@expr17584 Match (@expr17674 tok@var2820 .@expr17629 next (@expr17630 ) .@expr17677 link (@expr17678 ) .@expr17679 previous (@expr17680 ) , ";|{|}|do {" ) ) {
6103: stilldead@var2819 =@expr1073759584 true ; }
6104: } }
6105: }
6106: begin@var2816 =@expr1073759585 end@var2817 ;
6107: }
6108: }
6109:
6110:
6111: bool Tokenizer :: removeRedundantConditions ( )
6112: {
6113:
6114: bool ret@var2822 ; ret@var2822 =@expr1073759586 false ;
6115:
6116: for (@expr1073759587 Token *@expr1073759588 tok@var2823 =@expr1073759589 list@var872 .@expr1073759590 front (@expr1073759591 ) ; tok@var2823 ; tok@var2823 =@expr1073759592 tok@var2823 .@expr1073759593 next (@expr1073759594 ) ) {
6117: if (@expr1073759595 !@expr1073759596 Token ::@expr1073759597 Match (@expr1073759598 tok@var2823 , "if ( %bool% ) {" ) ) {
6118: continue ; }
6119:
6120:
6121: Token * elseTag@var2824 ; elseTag@var2824 =@expr1073759599 tok@var2823 .@expr1073759600 linkAt (@expr1073759601 4 ) .@expr1073759602 next (@expr1073759603 ) ;
6122:
6123: const bool boolValue@var2825 =@expr1073759604 tok@var2823 .@expr1073759605 strAt (@expr1073759606 2 ) ==@expr1073759607 "true" ;
6124:
6125:
6126: if (@expr1073759608 Token ::@expr1073759609 simpleMatch (@expr1073759610 elseTag@var2824 , "else {" ) ) {
6127:
6128: if (@expr17787 !@expr17788 boolValue@var2825 ) {
6129:
6130:
6131:
6132: tok@var2823 .@expr17789 deleteNext (@expr17790 3 ) ;
6133:
6134: eraseDeadCode (@expr17791 tok@var2823 , elseTag@var2824 ) ;
6135:
6136: elseTag@var2824 .@expr1073759616 deleteThis (@expr1073759617 ) ;
6137:
6138: tok@var2823 .@expr17794 deleteThis (@expr17795 ) ;
6139: } else {
6140:
6141: const Token * end@var2826 ; end@var2826 =@expr1073759620 elseTag@var2824 .@expr1073759621 next (@expr1073759622 ) .@expr1073759623 link (@expr1073759624 ) .@expr1073759625 next (@expr1073759626 ) ;
6142:
6143:
6144: elseTag@var2824 =@expr1073759627 elseTag@var2824 .@expr1073759628 previous (@expr1073759629 ) ;
6145: eraseDeadCode (@expr1073759630 elseTag@var2824 , end@var2826 ) ;
6146:
6147:
6148: tok@var2823 .@expr17789 deleteNext (@expr17790 3 ) ;
6149: tok@var2823 .@expr17794 deleteThis (@expr17795 ) ;
6150: }
6151:
6152: ret@var2822 =@expr1073759635 true ;
6153: }
6154:
6155:
6156: else {
6157: if (@expr17787 !@expr17788 boolValue@var2825 ) {
6158:
6159: tok@var2823 .@expr17789 deleteNext (@expr17790 3 ) ;
6160:
6161: eraseDeadCode (@expr17791 tok@var2823 , elseTag@var2824 ) ;
6162:
6163: tok@var2823 .@expr17794 deleteThis (@expr17795 ) ;
6164: } else {
6165:
6166: tok@var2823 .@expr17789 deleteNext (@expr17790 3 ) ;
6167: tok@var2823 .@expr17794 deleteThis (@expr17795 ) ;
6168: }
6169:
6170: ret@var2822 =@expr1073759647 true ;
6171: }
6172: }
6173:
6174: return ret@var2822 ;
6175: }
6176:
6177: void Tokenizer :: removeRedundantFor ( )
6178: {
6179: for (@expr1073759648 Token *@expr17825 tok@var2827 =@expr1073759650 list@var872 .@expr1073759651 front (@expr1073759652 ) ; tok@var2827 ; tok@var2827 =@expr1073759653 tok@var2827 .@expr17830 next (@expr17831 ) ) {
6180: if (@expr1073759656 Token ::@expr17833 Match (@expr1073759658 tok@var2827 , "[;{}] for ( %name% = %num% ; %name% < %num% ; ++| %name% ++| ) {" ) ||@expr1073759659
6181: Token ::@expr17833 Match (@expr1073759661 tok@var2827 , "[;{}] for ( %type% %name% = %num% ; %name% < %num% ; ++| %name% ++| ) {" ) ) {
6182:
6183: const Token * varTok@var2828 ; varTok@var2828 =@expr1073759662 tok@var2827 .@expr17839 tokAt (@expr1073759664 3 ) ;
6184: const bool type@var2829 =@expr1073759665 varTok@var2828 .@expr17842 next (@expr17843 ) .@expr1073759668 isName (@expr1073759669 ) ;
6185: if (@expr17846 type@var2829 ) {
6186: varTok@var2828 =@expr1073759671 varTok@var2828 .@expr17842 next (@expr17843 ) ; }
6187: const std ::@expr1073759674 string varname@var2830 (@expr1073759675 varTok@var2828 .@expr1073759676 str (@expr1073759677 ) ) ;
6188: const int varid@var2831 (@expr1073759678 varTok@var2828 .@expr1073759679 varId (@expr1073759680 ) ) ;
6189: if (@expr1073759681 varname@var2830 !=@expr1073759682 varTok@var2828 .@expr17859 strAt (@expr1073759684 4 ) ) {
6190: continue ; }
6191: const Token * vartok2@var2832 ; vartok2@var2832 =@expr1073759685 tok@var2827 .@expr17862 linkAt (@expr17863 2 ) .@expr1073759688 previous (@expr1073759689 ) ;
6192: if (@expr1073759690 vartok2@var2832 .@expr17867 str (@expr17868 ) ==@expr1073759693 "++" ) {
6193: vartok2@var2832 =@expr1073759694 vartok2@var2832 .@expr1073759695 previous (@expr1073759696 ) ; }
6194: else { if (@expr1073759697 vartok2@var2832 .@expr1073759698 strAt (@expr1073759699 -1 ) !=@expr1073759700 "++" ) {
6195: continue ; } }
6196: if (@expr1073759701 varname@var2830 !=@expr1073759702 vartok2@var2832 .@expr17867 str (@expr17868 ) ) {
6197: continue ; }
6198:
6199:
6200: const long long num1@var2833 (@expr1073759705 MathLib ::@expr17882 toLongNumber (@expr1073759707 varTok@var2828 .@expr17859 strAt (@expr1073759709 2 ) ) ) ;
6201: const long long num2@var2834 (@expr1073759710 MathLib ::@expr17882 toLongNumber (@expr1073759712 varTok@var2828 .@expr17859 strAt (@expr1073759714 6 ) ) ) ;
6202: if (@expr1073759715 num1@var2833 +@expr1073759716 1 !=@expr1073759717 num2@var2834 ) {
6203: continue ; }
6204:
6205:
6206: bool read@var2835 ; read@var2835 =@expr1073759718 false ;
6207: bool write@var2836 ; write@var2836 =@expr1073759719 false ;
6208: const Token * end@var2837 ; end@var2837 =@expr1073759720 tok@var2827 .@expr17862 linkAt (@expr17863 2 ) .@expr17899 next (@expr17900 ) .@expr1073759725 link (@expr1073759726 ) ;
6209: for (@expr1073759727 const Token *@expr17825 tok2@var2838 =@expr1073759729 tok@var2827 .@expr17862 linkAt (@expr17863 2 ) ; tok2@var2838 !=@expr1073759732 end@var2837 ; tok2@var2838 =@expr1073759733 tok2@var2838 .@expr17910 next (@expr17911 ) ) {
6210: if (@expr1073759736 tok2@var2838 .@expr1073759737 str (@expr1073759738 ) ==@expr1073759739 varname@var2830 ) {
6211: if (@expr1073759740 tok2@var2838 .@expr1073759741 previous (@expr1073759742 ) .@expr1073759743 isArithmeticalOp (@expr1073759744 ) &&@expr1073759745
6212: tok2@var2838 .@expr17910 next (@expr17911 ) &&@expr1073759748
6213: (@expr1073759749 tok2@var2838 .@expr17910 next (@expr17911 ) .@expr1073759752 isArithmeticalOp (@expr1073759753 ) ||@expr1073759754 tok2@var2838 .@expr17910 next (@expr17911 ) .@expr1073759757 str (@expr1073759758 ) ==@expr1073759759 ";" ) ) {
6214: read@var2835 =@expr1073759760 true ;
6215: } else {
6216: read@var2835 =@expr1073759761 write@var2836 =@expr1073759762 true ;
6217: break ;
6218: }
6219: }
6220: }
6221:
6222:
6223: if (@expr1073759763 !@expr1073759764 write@var2836 ) {
6224: Token * bodyBegin@var2839 ; bodyBegin@var2839 =@expr1073759765 tok@var2827 .@expr17862 linkAt (@expr17863 2 ) .@expr17899 next (@expr17900 ) ;
6225:
6226: tok@var2827 .@expr17946 deleteNext (@expr1073759771 2 ) ;
6227:
6228:
6229:
6230: if (@expr17846 type@var2829 ) {
6231: tok@var2827 .@expr1073759773 insertToken (@expr1073759774 "{" ) ;
6232: Token ::@expr1073759775 createMutualLinks (@expr1073759776 tok@var2827 .@expr17830 next (@expr17831 ) , bodyBegin@var2839 .@expr1073759779 link (@expr1073759780 ) ) ;
6233: bodyBegin@var2839 .@expr1073759781 deleteThis (@expr1073759782 ) ;
6234: tok@var2827 =@expr1073759783 tok@var2827 .@expr17839 tokAt (@expr1073759785 6 ) ;
6235: } else { if (@expr1073759786 read@var2835 ) {
6236:
6237: tok@var2827 =@expr1073759787 tok@var2827 .@expr17839 tokAt (@expr1073759789 4 ) ;
6238: } else {
6239:
6240: tok@var2827 .@expr17946 deleteNext (@expr1073759791 4 ) ;
6241: } }
6242:
6243:
6244: tok@var2827 .@expr17946 deleteNext (@expr1073759793 7 ) ;
6245:
6246: if (@expr1073759794 !@expr1073759795 type@var2829 ) {
6247:
6248:
6249: Token * tok2@var2840 ; tok2@var2840 =@expr1073759796 tok@var2827 .@expr17830 next (@expr17831 ) .@expr1073759799 link (@expr1073759800 ) ;
6250: tok2@var2840 .@expr17977 insertToken (@expr1073759802 ";" ) ;
6251: tok2@var2840 .@expr17977 insertToken (@expr1073759804 MathLib ::@expr1073759805 toString (@expr1073759806 num2@var2834 ) ) ;
6252: tok2@var2840 .@expr17977 insertToken (@expr1073759808 "=" ) ;
6253: tok2@var2840 .@expr17977 insertToken (@expr1073759810 varname@var2830 ) ;
6254: tok2@var2840 .@expr1073759811 next (@expr1073759812 ) .@expr1073759813 varId (@expr1073759814 varid@var2831 ) ;
6255: }
6256: }
6257: }
6258: }
6259: }
6260:
6261:
6262: void Tokenizer :: removeRedundantSemicolons ( )
6263: {
6264: for (@expr1073759815 Token *@expr1073759816 tok@var2841 =@expr1073759817 list@var872 .@expr1073759818 front (@expr1073759819 ) ; tok@var2841 ; tok@var2841 =@expr1073759820 tok@var2841 .@expr1073759821 next (@expr1073759822 ) ) {
6265: if (@expr1073759823 tok@var2841 .@expr18000 link (@expr18001 ) &&@expr1073759826 tok@var2841 .@expr1073759827 str (@expr1073759828 ) ==@expr1073759829 "(" ) {
6266: tok@var2841 =@expr1073759830 tok@var2841 .@expr18000 link (@expr18001 ) ;
6267: continue ;
6268: }
6269: for (@expr1073759833 ; ; ) {
6270: if (@expr1073759834 Token ::@expr18011 simpleMatch (@expr1073759836 tok@var2841 , "; ;" ) ) {
6271: tok@var2841 .@expr18013 deleteNext (@expr1073759838 ) ;
6272: } else { if (@expr1073759839 Token ::@expr18011 simpleMatch (@expr1073759841 tok@var2841 , "; { ; }" ) ) {
6273: tok@var2841 .@expr18013 deleteNext (@expr1073759843 3 ) ;
6274: } else {
6275: break ;
6276: } }
6277: }
6278: }
6279: }
6280:
6281:
6282: bool Tokenizer :: simplifyAddBraces ( )
6283: {
6284: for (@expr1073759844 Token *@expr1073759845 tok@var2842 =@expr1073759846 list@var872 .@expr1073759847 front (@expr1073759848 ) ; tok@var2842 ; tok@var2842 =@expr1073759849 tok@var2842 .@expr1073759850 next (@expr1073759851 ) ) {
6285: const Token * tokRet@var2843 ; tokRet@var2843 =@expr1073759852 simplifyAddBracesToCommand (@expr1073759853 tok@var2842 ) ;
6286: if (@expr1073759854 !@expr1073759855 tokRet@var2843 ) {
6287: return false ; }
6288: }
6289: return true ;
6290: }
6291:
6292: Token * Tokenizer :: simplifyAddBracesToCommand ( Token * tok@var2844 )
6293: {
6294: Token * tokEnd@var2845 ; tokEnd@var2845 =@expr1073759856 tok@var2844 ;
6295: if (@expr1073759857 Token ::@expr1073759858 Match (@expr1073759859 tok@var2844 , "for|switch|BOOST_FOREACH" ) ) {
6296: tokEnd@var2845 =@expr1073759860 simplifyAddBracesPair (@expr18037 tok@var2844 , true ) ;
6297: } else { if (@expr1073759862 tok@var2844 .@expr18039 str (@expr18040 ) ==@expr1073759865 "while" ) {
6298: Token * tokPossibleDo@var2846 ; tokPossibleDo@var2846 =@expr1073759866 tok@var2844 .@expr18043 previous (@expr18044 ) ;
6299: if (@expr1073759869 Token ::@expr18046 simpleMatch (@expr1073759871 tok@var2844 .@expr18043 previous (@expr18044 ) , "{" ) ) {
6300: tokPossibleDo@var2846 =@expr1073759874 nullptr ; }
6301: else { if (@expr1073759875 Token ::@expr18046 simpleMatch (@expr1073759877 tokPossibleDo@var2846 , "}" ) ) {
6302: tokPossibleDo@var2846 =@expr1073759878 tokPossibleDo@var2846 .@expr1073759879 link (@expr1073759880 ) ; } }
6303: if (@expr1073759881 !@expr1073759882 tokPossibleDo@var2846 ||@expr1073759883 tokPossibleDo@var2846 .@expr1073759884 strAt (@expr1073759885 -1 ) !=@expr1073759886 "do" ) {
6304: tokEnd@var2845 =@expr1073759887 simplifyAddBracesPair (@expr18037 tok@var2844 , true ) ; }
6305: } else { if (@expr1073759889 tok@var2844 .@expr18039 str (@expr18040 ) ==@expr1073759892 "do" ) {
6306: tokEnd@var2845 =@expr1073759893 simplifyAddBracesPair (@expr1073759894 tok@var2844 , false ) ;
6307: if (@expr1073759895 tokEnd@var2845 !=@expr1073759896 tok@var2844 ) {
6308:
6309:
6310:
6311: if (@expr1073759897 tokEnd@var2845 ) {
6312: tokEnd@var2845 =@expr1073759898 tokEnd@var2845 .@expr18075 next (@expr18076 ) ;
6313: if (@expr1073759901 !@expr18078 tokEnd@var2845 ||@expr1073759903 tokEnd@var2845 .@expr1073759904 str (@expr1073759905 ) !=@expr1073759906 "while" ) {
6314: syntaxError (@expr1073759907 tok@var2844 ) ; }
6315: }
6316: }
6317: } else { if (@expr1073759908 tok@var2844 .@expr18039 str (@expr18040 ) ==@expr1073759911 "if" &&@expr1073759912 !@expr1073759913 Token ::@expr18046 simpleMatch (@expr1073759915 tok@var2844 .@expr1073759916 tokAt (@expr1073759917 -2 ) , "operator \"\"" ) ) {
6318: tokEnd@var2845 =@expr1073759918 simplifyAddBracesPair (@expr18037 tok@var2844 , true ) ;
6319: if (@expr1073759920 !@expr18078 tokEnd@var2845 ) {
6320: return nullptr ; }
6321: if (@expr1073759922 tokEnd@var2845 .@expr1073759923 strAt (@expr1073759924 1 ) ==@expr1073759925 "else" ) {
6322: Token * tokEndNextNext@var2847 ; tokEndNextNext@var2847 =@expr1073759926 tokEnd@var2845 .@expr1073759927 tokAt (@expr1073759928 2 ) ;
6323: if (@expr1073759929 !@expr1073759930 tokEndNextNext@var2847 ||@expr1073759931 tokEndNextNext@var2847 .@expr18108 str (@expr18109 ) ==@expr1073759934 "}" ) {
6324: syntaxError (@expr1073759935 tokEndNextNext@var2847 ) ; }
6325: if (@expr1073759936 tokEndNextNext@var2847 .@expr18108 str (@expr18109 ) ==@expr1073759939 "if" ) {
6326:
6327: tokEnd@var2845 =@expr1073759940 simplifyAddBracesToCommand (@expr1073759941 tokEndNextNext@var2847 ) ; }
6328: else {
6329: tokEnd@var2845 =@expr1073759942 simplifyAddBracesPair (@expr1073759943 tokEnd@var2845 .@expr18075 next (@expr18076 ) , false ) ; }
6330: }
6331: } } } }
6332:
6333: return tokEnd@var2845 ;
6334: }
6335:
6336: Token * Tokenizer :: simplifyAddBracesPair ( Token * tok@var2848 , bool commandWithCondition@var2849 )
6337: {
6338: Token * tokCondition@var2850 ; tokCondition@var2850 =@expr1073759946 tok@var2848 .@expr1073759947 next (@expr1073759948 ) ;
6339: if (@expr1073759949 !@expr1073759950 tokCondition@var2850 ) {
6340: return tok@var2848 ; }
6341:
6342: Token * tokAfterCondition@var2851 ; tokAfterCondition@var2851 =@expr1073759951 tokCondition@var2850 ;
6343: if (@expr1073759952 commandWithCondition@var2849 ) {
6344: if (@expr1073759953 tokCondition@var2850 .@expr1073759954 str (@expr1073759955 ) ==@expr1073759956 "(" ) {
6345: tokAfterCondition@var2851 =@expr1073759957 tokCondition@var2850 .@expr1073759958 link (@expr1073759959 ) ; }
6346: else {
6347: syntaxError (@expr18136 tok@var2848 ) ; }
6348:
6349: if (@expr1073759961 !@expr18138 tokAfterCondition@var2851 ||@expr1073759963 tokAfterCondition@var2851 .@expr1073759964 strAt (@expr1073759965 1 ) ==@expr1073759966 "]" ) {
6350: syntaxError (@expr18136 tok@var2848 ) ; }
6351:
6352: tokAfterCondition@var2851 =@expr1073759968 tokAfterCondition@var2851 .@expr1073759969 next (@expr1073759970 ) ;
6353: if (@expr1073759971 !@expr18138 tokAfterCondition@var2851 ||@expr1073759973 Token ::@expr18150 Match (@expr1073759975 tokAfterCondition@var2851 , ")|}|," ) ) {
6354:
6355: return tok@var2848 ;
6356: }
6357: }
6358:
6359: Token * tokStatement@var2852 ; tokStatement@var2852 =@expr1073759976 tokAfterCondition@var2851 ;
6360: while (@expr1073759977 true ) {
6361: if (@expr1073759978 Token ::@expr18150 Match (@expr1073759980 tokStatement@var2852 , "%name% :" ) ) {
6362: tokStatement@var2852 =@expr1073759981 tokStatement@var2852 .@expr1073759982 tokAt (@expr1073759983 2 ) ; }
6363: else { if (@expr1073759984 tokStatement@var2852 .@expr18161 str (@expr18162 ) ==@expr1073759987 "case" ) {
6364: tokStatement@var2852 =@expr1073759988 skipCaseLabel (@expr1073759989 tokStatement@var2852 ) ;
6365: if (@expr18166 !@expr18167 tokStatement@var2852 ) {
6366: return tok@var2848 ; }
6367: if (@expr1073759992 tokStatement@var2852 .@expr18161 str (@expr18162 ) !=@expr1073759995 ":" ) {
6368: syntaxError (@expr18172 tokStatement@var2852 ) ; }
6369: tokStatement@var2852 =@expr1073759997 tokStatement@var2852 .@expr1073759998 next (@expr1073759999 ) ;
6370: } else {
6371: break ; } }
6372: if (@expr18166 !@expr18167 tokStatement@var2852 ) {
6373: return tok@var2848 ; }
6374: }
6375: Token * tokBracesEnd@var2853 ; tokBracesEnd@var2853 =@expr1073760002 nullptr ;
6376: if (@expr1073760003 tokStatement@var2852 .@expr18161 str (@expr18162 ) ==@expr1073760006 "{" ) {
6377:
6378: if (@expr1073760007 tokStatement@var2852 !=@expr1073760008 tokAfterCondition@var2851 ) {
6379:
6380: Token ::@expr1073760009 move (@expr1073760010 tokStatement@var2852 , tokStatement@var2852 , tokAfterCondition@var2851 .@expr18187 previous (@expr18188 ) ) ;
6381: }
6382: tokBracesEnd@var2853 =@expr1073760013 tokStatement@var2852 .@expr1073760014 link (@expr1073760015 ) ;
6383: } else { if (@expr1073760016 Token ::@expr18193 simpleMatch (@expr1073760018 tokStatement@var2852 , "try {" ) &&@expr1073760019
6384: Token ::@expr18193 simpleMatch (@expr1073760021 tokStatement@var2852 .@expr18198 linkAt (@expr18199 1 ) , "} catch (" ) ) {
6385: tokAfterCondition@var2851 .@expr18187 previous (@expr18188 ) .@expr18202 insertToken (@expr18203 "{" ) ;
6386: Token * tokOpenBrace@var2854 ; tokOpenBrace@var2854 =@expr1073760028 tokAfterCondition@var2851 .@expr18187 previous (@expr18188 ) ;
6387: Token * tokEnd@var2855 ; tokEnd@var2855 =@expr1073760031 tokStatement@var2852 .@expr18198 linkAt (@expr18199 1 ) .@expr1073760034 linkAt (@expr1073760035 2 ) .@expr1073760036 linkAt (@expr1073760037 1 ) ;
6388: if (@expr1073760038 !@expr1073760039 tokEnd@var2855 ) {
6389: syntaxError (@expr18172 tokStatement@var2852 ) ;
6390: }
6391: tokEnd@var2855 .@expr1073760041 insertToken (@expr1073760042 "}" ) ;
6392: Token * tokCloseBrace@var2856 ; tokCloseBrace@var2856 =@expr1073760043 tokEnd@var2855 .@expr1073760044 next (@expr1073760045 ) ;
6393:
6394: Token ::@expr18222 createMutualLinks (@expr1073760047 tokOpenBrace@var2854 , tokCloseBrace@var2856 ) ;
6395: tokBracesEnd@var2853 =@expr1073760048 tokCloseBrace@var2856 ;
6396: } else {
6397: Token * tokEnd@var2857 ; tokEnd@var2857 =@expr1073760049 simplifyAddBracesToCommand (@expr1073760050 tokStatement@var2852 ) ;
6398: if (@expr18227 !@expr18228 tokEnd@var2857 ) {
6399: return tok@var2848 ; }
6400: if (@expr1073760053 tokEnd@var2857 .@expr18230 str (@expr18231 ) !=@expr1073760056 "}" ) {
6401:
6402:
6403: while (@expr1073760057 tokEnd@var2857 &&@expr1073760058 !@expr1073760059 Token ::@expr18150 Match (@expr1073760061 tokEnd@var2857 , ";|)|}" ) ) {
6404: if (@expr1073760062 tokEnd@var2857 .@expr1073760063 tokType (@expr1073760064 ) ==@expr1073760065 Token ::@expr1073760066 eBracket ||@expr1073760067 tokEnd@var2857 .@expr18230 str (@expr18231 ) ==@expr1073760070 "(" ) {
6405: tokEnd@var2857 =@expr1073760071 tokEnd@var2857 .@expr1073760072 link (@expr1073760073 ) ;
6406: if (@expr18227 !@expr18228 tokEnd@var2857 ) {
6407:
6408: return tok@var2848 ;
6409: }
6410: }
6411: tokEnd@var2857 =@expr1073760076 tokEnd@var2857 .@expr18253 next (@expr18254 ) ;
6412: }
6413: if (@expr1073760079 !@expr18228 tokEnd@var2857 ||@expr1073760081 tokEnd@var2857 .@expr18230 str (@expr18231 ) !=@expr1073760084 ";" ) {
6414:
6415: return tok@var2848 ;
6416: }
6417: }
6418:
6419: tokAfterCondition@var2851 .@expr18187 previous (@expr18188 ) .@expr18202 insertToken (@expr18203 "{" ) ;
6420: Token * tokOpenBrace@var2858 ; tokOpenBrace@var2858 =@expr1073760089 tokAfterCondition@var2851 .@expr18187 previous (@expr18188 ) ;
6421:
6422: tokEnd@var2857 .@expr1073760092 insertToken (@expr1073760093 "}" ) ;
6423: Token * tokCloseBrace@var2859 ; tokCloseBrace@var2859 =@expr1073760094 tokEnd@var2857 .@expr18253 next (@expr18254 ) ;
6424:
6425: Token ::@expr18222 createMutualLinks (@expr1073760098 tokOpenBrace@var2858 , tokCloseBrace@var2859 ) ;
6426: tokBracesEnd@var2853 =@expr1073760099 tokCloseBrace@var2859 ;
6427: } }
6428:
6429: return tokBracesEnd@var2853 ;
6430: }
6431:
6432: void Tokenizer :: simplifyCompoundAssignment ( )
6433: {
6434:
6435:
6436: for (@expr1073760100 Token *@expr18277 tok@var2860 =@expr1073760102 list@var872 .@expr1073760103 front (@expr1073760104 ) ; tok@var2860 ; tok@var2860 =@expr1073760105 tok@var2860 .@expr18282 next (@expr18283 ) ) {
6437: if (@expr1073760108 !@expr1073760109 Token ::@expr18286 Match (@expr1073760111 tok@var2860 , "[;{}] (| *| (| %name%" ) ) {
6438: continue ; }
6439: if (@expr1073760112 tok@var2860 .@expr18282 next (@expr18283 ) .@expr18291 str (@expr18292 ) ==@expr1073760117 "return" ) {
6440: continue ; }
6441:
6442: Token * const tok1@var2861 ; tok1@var2861 =@expr1073760118 tok@var2860 ;
6443:
6444: if (@expr1073760119 tok@var2860 .@expr18282 next (@expr18283 ) .@expr18291 str (@expr18292 ) ==@expr1073760124 "*" ) {
6445: tok@var2860 =@expr1073760125 tok@var2860 .@expr18282 next (@expr18283 ) ; }
6446:
6447: if (@expr1073760128 tok@var2860 .@expr18282 next (@expr18283 ) &&@expr1073760131 tok@var2860 .@expr18282 next (@expr18283 ) .@expr18291 str (@expr18292 ) ==@expr1073760136 "(" ) {
6448: tok@var2860 =@expr1073760137 tok@var2860 .@expr18282 next (@expr18283 ) .@expr1073760140 link (@expr1073760141 ) .@expr1073760142 next (@expr1073760143 ) ;
6449: } else {
6450:
6451: tok@var2860 =@expr1073760144 tok@var2860 .@expr18321 tokAt (@expr18322 2 ) ;
6452: while (@expr1073760147 Token ::@expr18286 Match (@expr1073760149 tok@var2860 , ". %name%" ) ||@expr1073760150
6453: Token ::@expr18286 Match (@expr1073760152 tok@var2860 , "[|(" ) ) {
6454: if (@expr1073760153 tok@var2860 .@expr18330 str (@expr18331 ) ==@expr1073760156 "." ) {
6455: tok@var2860 =@expr1073760157 tok@var2860 .@expr18321 tokAt (@expr18322 2 ) ; }
6456: else {
6457:
6458: tok@var2860 =@expr1073760160 tok@var2860 .@expr1073760161 link (@expr1073760162 ) ;
6459:
6460:
6461: tok@var2860 =@expr1073760163 tok@var2860 ?@expr1073760164 tok@var2860 .@expr18282 next (@expr18283 ) :@expr1073760167 nullptr ;
6462: }
6463: }
6464: }
6465: if (@expr1073760168 !@expr1073760169 tok@var2860 ) {
6466: break ; }
6467:
6468:
6469: const std ::@expr1073760170 string &@expr1073760171 str@var2862 =@expr1073760172 tok@var2860 .@expr18330 str (@expr18331 ) ;
6470: std ::@expr1073760175 string op@var2863 ;
6471: if (@expr1073760176 tok@var2860 .@expr18353 isAssignmentOp (@expr18354 ) &&@expr1073760179 str@var2862 .@expr18356 size (@expr18357 ) ==@expr1073760182 2 ) {
6472: op@var2863 =@expr1073760183 str@var2862 .@expr18360 substr (@expr1073760185 0 , 1 ) ; }
6473: else { if (@expr1073760186 tok@var2860 .@expr18353 isAssignmentOp (@expr18354 ) &&@expr1073760189 str@var2862 .@expr18356 size (@expr18357 ) ==@expr1073760192 3 ) {
6474: op@var2863 =@expr1073760193 str@var2862 .@expr18360 substr (@expr1073760195 0 , 2 ) ; }
6475: else {
6476: tok@var2860 =@expr1073760196 tok1@var2861 ;
6477: continue ;
6478: } }
6479:
6480:
6481: if (@expr1073760197 Token ::@expr18286 Match (@expr1073760199 tok@var2860 , "+=|-= 0 ;" ) ||@expr1073760200
6482: Token ::@expr1073760201 simpleMatch (@expr1073760202 tok@var2860 , "|= 0 ;" ) ||@expr1073760203
6483: Token ::@expr18286 Match (@expr1073760205 tok@var2860 , "*=|/= 1 ;" ) ) {
6484: tok@var2860 =@expr1073760206 tok1@var2861 ;
6485: while (@expr1073760207 tok@var2860 .@expr18282 next (@expr18283 ) .@expr18291 str (@expr18292 ) !=@expr1073760212 ";" ) {
6486: tok@var2860 .@expr1073760213 deleteNext (@expr1073760214 ) ; }
6487: } else {
6488:
6489: if (@expr1073760215 !@expr1073760216 Token ::@expr18286 Match (@expr1073760218 tok@var2860 .@expr18321 tokAt (@expr18322 2 ) , "[;)]" ) ) {
6490:
6491: bool someOperator@var2864 ; someOperator@var2864 =@expr1073760221 false ;
6492: for (@expr1073760222 Token *@expr18277 tok2@var2865 =@expr1073760224 tok@var2860 .@expr18282 next (@expr18283 ) ; tok2@var2865 ; tok2@var2865 =@expr1073760227 tok2@var2865 .@expr18404 next (@expr18405 ) ) {
6493: if (@expr1073760230 tok2@var2865 .@expr18407 link (@expr18408 ) &&@expr1073760233 Token ::@expr18286 Match (@expr1073760235 tok2@var2865 , "{|[|(" ) ) {
6494: tok2@var2865 =@expr1073760236 tok2@var2865 .@expr18407 link (@expr18408 ) ; }
6495:
6496: if (@expr1073760239 Token ::@expr18286 Match (@expr1073760241 tok2@var2865 .@expr18404 next (@expr18405 ) , "[;)]" ) ) {
6497: if (@expr1073760244 someOperator@var2864 ) {
6498: tok@var2860 .@expr18421 insertToken (@expr1073760246 "(" ) ;
6499: tok2@var2865 .@expr1073760247 insertToken (@expr1073760248 ")" ) ;
6500: Token ::@expr18425 createMutualLinks (@expr1073760250 tok@var2860 .@expr18282 next (@expr18283 ) , tok2@var2865 .@expr18404 next (@expr18405 ) ) ;
6501: }
6502: break ;
6503: }
6504:
6505: someOperator@var2864 |=@expr1073760255 (@expr1073760256 tok2@var2865 .@expr1073760257 isOp (@expr1073760258 ) ||@expr1073760259 tok2@var2865 .@expr1073760260 str (@expr1073760261 ) ==@expr1073760262 "?" ) ;
6506: }
6507: }
6508:
6509:
6510: tok@var2860 .@expr18330 str (@expr1073760264 "=" ) ;
6511: tok@var2860 .@expr18421 insertToken (@expr1073760266 op@var2863 ) ;
6512:
6513: std ::@expr1073760267 stack < Token *@expr18277 > tokend@var2866 ;
6514: for (@expr1073760269 Token *@expr18277 tok2@var2867 =@expr1073760271 tok@var2860 .@expr1073760272 previous (@expr1073760273 ) ; tok2@var2867 &&@expr1073760274 tok2@var2867 !=@expr1073760275 tok1@var2861 ; tok2@var2867 =@expr1073760276 tok2@var2867 .@expr1073760277 previous (@expr1073760278 ) ) {
6515:
6516:
6517: if (@expr1073760279 tok2@var2867 .@expr1073760280 tokType (@expr1073760281 ) ==@expr1073760282 Token ::@expr1073760283 eIncDecOp ) {
6518:
6519: if (@expr1073760284 tok2@var2867 .@expr1073760285 next (@expr1073760286 ) .@expr1073760287 isName (@expr1073760288 ) ) {
6520: continue ;
6521: }
6522:
6523:
6524: tok@var2860 .@expr18421 insertToken (@expr18466 tok2@var2867 .@expr18467 str (@expr18468 ) ) ;
6525: tok2@var2867 .@expr1073760293 deleteThis (@expr1073760294 ) ;
6526: continue ;
6527: }
6528:
6529:
6530: tok@var2860 .@expr18421 insertToken (@expr18466 tok2@var2867 .@expr18467 str (@expr18468 ) ) ;
6531: tok@var2860 .@expr18282 next (@expr18283 ) .@expr1073760301 varId (@expr1073760302 tok2@var2867 .@expr1073760303 varId (@expr1073760304 ) ) ;
6532: if (@expr1073760305 Token ::@expr18286 Match (@expr1073760307 tok@var2860 .@expr18282 next (@expr18283 ) , "]|)|}" ) ) {
6533: tokend@var2866 .@expr1073760310 push (@expr1073760311 tok@var2860 .@expr18282 next (@expr18283 ) ) ; }
6534: else { if (@expr1073760314 Token ::@expr18286 Match (@expr1073760316 tok@var2860 .@expr18282 next (@expr18283 ) , "(|[|{" ) ) {
6535: Token ::@expr18425 createMutualLinks (@expr1073760320 tok@var2860 .@expr18282 next (@expr18283 ) , tokend@var2866 .@expr1073760323 top (@expr1073760324 ) ) ;
6536: tokend@var2866 .@expr1073760325 pop (@expr1073760326 ) ;
6537: } }
6538: }
6539: }
6540: }
6541: }
6542:
6543: bool Tokenizer :: simplifyConditions ( )
6544: {
6545: bool ret@var2868 ; ret@var2868 =@expr1073760327 false ;
6546:
6547: for (@expr1073760328 Token *@expr1073760329 tok@var2869 =@expr1073760330 list@var872 .@expr1073760331 front (@expr1073760332 ) ; tok@var2869 ; tok@var2869 =@expr1073760333 tok@var2869 .@expr18510 next (@expr18511 ) ) {
6548: if (@expr1073760336 Token ::@expr18513 Match (@expr1073760338 tok@var2869 , "! %bool%|%num%" ) ) {
6549: tok@var2869 .@expr1073760339 deleteThis (@expr1073760340 ) ;
6550: if (@expr1073760341 Token ::@expr18513 Match (@expr1073760343 tok@var2869 , "0|false" ) ) {
6551: tok@var2869 .@expr18520 str (@expr1073760345 "true" ) ; }
6552: else {
6553: tok@var2869 .@expr18520 str (@expr1073760347 "false" ) ; }
6554:
6555: ret@var2868 =@expr1073760348 true ;
6556: }
6557:
6558: if (@expr1073760349 Token ::@expr18526 simpleMatch (@expr1073760351 tok@var2869 , "&& true &&" ) ) {
6559: tok@var2869 .@expr18528 deleteNext (@expr18529 2 ) ;
6560: ret@var2868 =@expr1073760354 true ;
6561: }
6562:
6563: else { if (@expr1073760355 Token ::@expr18526 simpleMatch (@expr1073760357 tok@var2869 , "|| false ||" ) ) {
6564: tok@var2869 .@expr18528 deleteNext (@expr18529 2 ) ;
6565: ret@var2868 =@expr1073760360 true ;
6566: }
6567:
6568: else { if (@expr1073760361 Token ::@expr18513 Match (@expr1073760363 tok@var2869 , "(|&& true && true &&|)" ) ) {
6569: tok@var2869 .@expr18528 deleteNext (@expr18529 2 ) ;
6570: ret@var2868 =@expr1073760366 true ;
6571: }
6572:
6573: else { if (@expr1073760367 Token ::@expr18513 Match (@expr1073760369 tok@var2869 , "%oror%|( false %oror% false %oror%|)" ) ) {
6574: tok@var2869 .@expr18528 deleteNext (@expr18529 2 ) ;
6575: ret@var2868 =@expr1073760372 true ;
6576: }
6577:
6578: else { if (@expr1073760373 Token ::@expr18526 simpleMatch (@expr1073760375 tok@var2869 , "( true ||" ) ||@expr1073760376
6579: Token ::@expr18526 simpleMatch (@expr1073760378 tok@var2869 , "( false &&" ) ) {
6580: Token ::@expr18555 eraseTokens (@expr1073760380 tok@var2869 .@expr18510 next (@expr18511 ) , tok@var2869 .@expr1073760383 link (@expr1073760384 ) ) ;
6581: ret@var2868 =@expr1073760385 true ;
6582: }
6583:
6584: else { if (@expr1073760386 Token ::@expr18526 simpleMatch (@expr1073760388 tok@var2869 , "|| true )" ) ||@expr1073760389
6585: Token ::@expr18526 simpleMatch (@expr1073760391 tok@var2869 , "&& false )" ) ) {
6586: tok@var2869 =@expr1073760392 tok@var2869 .@expr18510 next (@expr18511 ) ;
6587: Token ::@expr18555 eraseTokens (@expr1073760396 tok@var2869 .@expr18510 next (@expr18511 ) .@expr1073760399 link (@expr1073760400 ) , tok@var2869 ) ;
6588: ret@var2868 =@expr1073760401 true ;
6589: }
6590:
6591: else { if (@expr1073760402 Token ::@expr18526 simpleMatch (@expr1073760404 tok@var2869 , "&& false &&" ) ||@expr1073760405
6592: Token ::@expr18526 simpleMatch (@expr1073760407 tok@var2869 , "|| true ||" ) ) {
6593:
6594: Token * tok2@var2870 ; tok2@var2870 =@expr1073760408 tok@var2869 ;
6595: while (@expr1073760409 tok2@var2870 &&@expr1073760410 tok2@var2870 .@expr18587 previous (@expr18588 ) ) {
6596: if (@expr1073760413 tok2@var2870 .@expr18587 previous (@expr18588 ) .@expr1073760416 str (@expr1073760417 ) ==@expr1073760418 ")" ) {
6597: tok2@var2870 =@expr1073760419 tok2@var2870 .@expr18587 previous (@expr18588 ) .@expr1073760422 link (@expr1073760423 ) ; }
6598: else {
6599: tok2@var2870 =@expr1073760424 tok2@var2870 .@expr18587 previous (@expr18588 ) ;
6600: if (@expr1073760427 tok2@var2870 .@expr1073760428 str (@expr1073760429 ) ==@expr1073760430 "(" ) {
6601: break ; }
6602: }
6603: }
6604: if (@expr1073760431 !@expr1073760432 tok2@var2870 ) {
6605: continue ; }
6606:
6607: tok@var2869 =@expr1073760433 tok@var2869 .@expr18510 next (@expr18511 ) ;
6608:
6609: Token ::@expr18555 eraseTokens (@expr1073760437 tok2@var2870 , tok@var2869 ) ;
6610:
6611: Token ::@expr18555 eraseTokens (@expr1073760439 tok@var2869 , tok2@var2870 .@expr1073760440 link (@expr1073760441 ) ) ;
6612: ret@var2868 =@expr1073760442 true ;
6613: } } } } } } }
6614:
6615:
6616: if (@expr1073760443 Token ::@expr18513 Match (@expr1073760445 tok@var2869 , "if|while ( %num% )|%oror%|&&" ) ) {
6617: tok@var2869 .@expr18622 tokAt (@expr1073760447 2 ) .@expr1073760448 str (@expr1073760449 (@expr1073760450 tok@var2869 .@expr18627 strAt (@expr18628 2 ) !=@expr1073760453 "0" ) ?@expr1073760454 "true" :@expr18631 "false" ) ;
6618: ret@var2868 =@expr1073760456 true ;
6619: }
6620: if (@expr1073760457 Token ::@expr18513 Match (@expr1073760459 tok@var2869 , "&&|%oror% %num% )|%oror%|&&" ) ) {
6621: tok@var2869 .@expr18510 next (@expr18511 ) .@expr18638 str (@expr1073760463 (@expr1073760464 tok@var2869 .@expr18510 next (@expr18511 ) .@expr18638 str (@expr18644 ) !=@expr1073760469 "0" ) ?@expr1073760470 "true" :@expr18631 "false" ) ;
6622: ret@var2868 =@expr1073760472 true ;
6623: }
6624:
6625:
6626: if (@expr1073760473 Token ::@expr18513 Match (@expr1073760475 tok@var2869 , "&&|%oror%|(" ) &&@expr1073760476
6627: (@expr1073760477 Token ::@expr18513 Match (@expr1073760479 tok@var2869 .@expr18510 next (@expr18511 ) , "%num% %any% %num%" ) ||@expr1073760482
6628: Token ::@expr18513 Match (@expr1073760484 tok@var2869 .@expr18510 next (@expr18511 ) , "%bool% %any% %bool%" ) ) &&@expr1073760487
6629: Token ::@expr18513 Match (@expr1073760489 tok@var2869 .@expr18622 tokAt (@expr1073760491 4 ) , "&&|%oror%|)|?" ) ) {
6630: std ::@expr1073760492 string cmp@var2871 ; cmp@var2871 =@expr1073760493 tok@var2869 .@expr18627 strAt (@expr18628 2 ) ;
6631: bool result@var2872 ; result@var2872 =@expr1073760496 false ;
6632: if (@expr1073760497 tok@var2869 .@expr18510 next (@expr18511 ) .@expr1073760500 isNumber (@expr1073760501 ) ) {
6633:
6634:
6635: if (@expr1073760502 cmp@var2871 ==@expr18679 "==" ||@expr1073760504 cmp@var2871 ==@expr18681 "!=" ) {
6636: const std ::@expr18682 string & op1@var2873 (@expr1073760507 tok@var2869 .@expr18510 next (@expr18511 ) .@expr18638 str (@expr18644 ) ) ;
6637: const std ::@expr18682 string & op2@var2874 (@expr1073760513 tok@var2869 .@expr18627 strAt (@expr18691 3 ) ) ;
6638:
6639: bool eq@var2875 ; eq@var2875 =@expr1073760516 false ;
6640: if (@expr1073760517 MathLib ::@expr18694 isInt (@expr1073760519 op1@var2873 ) &&@expr1073760520 MathLib ::@expr18694 isInt (@expr1073760522 op2@var2874 ) ) {
6641: eq@var2875 =@expr1073760523 MathLib ::@expr18700 toLongNumber (@expr1073760525 op1@var2873 ) ==@expr1073760526 MathLib ::@expr18700 toLongNumber (@expr1073760528 op2@var2874 ) ; }
6642: else {
6643: eq@var2875 =@expr1073760529 op1@var2873 ==@expr1073760530 op2@var2874 ;
6644:
6645:
6646: if (@expr1073760531 !@expr18708 eq@var2875 &&@expr1073760533 MathLib ::@expr1073760534 isFloat (@expr1073760535 op1@var2873 ) ) {
6647: cmp@var2871 .@expr18712 clear (@expr18713 ) ; }
6648: }
6649:
6650: if (@expr18714 cmp@var2871 ==@expr18679 "==" ) {
6651: result@var2872 =@expr1073760540 eq@var2875 ; }
6652: else {
6653: result@var2872 =@expr1073760541 !@expr18708 eq@var2875 ; }
6654: } else {
6655: const double op1@var2876 =@expr1073760543 MathLib ::@expr18720 toDoubleNumber (@expr1073760545 tok@var2869 .@expr18510 next (@expr18511 ) .@expr18638 str (@expr18644 ) ) ;
6656: const double op2@var2877 =@expr1073760550 MathLib ::@expr18720 toDoubleNumber (@expr1073760552 tok@var2869 .@expr18627 strAt (@expr18691 3 ) ) ;
6657: if (@expr18731 cmp@var2871 ==@expr18732 ">=" ) {
6658: result@var2872 =@expr1073760557 op1@var2876 >=@expr1073760558 op2@var2877 ; }
6659: else { if (@expr18735 cmp@var2871 ==@expr18736 ">" ) {
6660: result@var2872 =@expr1073760561 op1@var2876 >@expr1073760562 op2@var2877 ; }
6661: else { if (@expr18739 cmp@var2871 ==@expr18740 "<=" ) {
6662: result@var2872 =@expr1073760565 op1@var2876 <=@expr1073760566 op2@var2877 ; }
6663: else { if (@expr18743 cmp@var2871 ==@expr18744 "<" ) {
6664: result@var2872 =@expr1073760569 op1@var2876 <@expr1073760570 op2@var2877 ; }
6665: else {
6666: cmp@var2871 .@expr18712 clear (@expr18713 ) ; } } } }
6667: }
6668: } else {
6669:
6670: const bool op1@var2878 =@expr1073760573 tok@var2869 .@expr18510 next (@expr18511 ) .@expr18638 str (@expr18644 ) ==@expr1073760578 std ::@expr18682 string (@expr18756 "true" ) ;
6671: const bool op2@var2879 =@expr1073760581 tok@var2869 .@expr18627 strAt (@expr18691 3 ) ==@expr1073760584 std ::@expr18682 string (@expr18756 "true" ) ;
6672:
6673: if (@expr18714 cmp@var2871 ==@expr18679 "==" ) {
6674: result@var2872 =@expr1073760589 op1@var2878 ==@expr1073760590 op2@var2879 ; }
6675: else { if (@expr1073760591 cmp@var2871 ==@expr18681 "!=" ) {
6676: result@var2872 =@expr1073760593 op1@var2878 !=@expr1073760594 op2@var2879 ; }
6677: else { if (@expr18731 cmp@var2871 ==@expr18732 ">=" ) {
6678: result@var2872 =@expr1073760597 op1@var2878 ||@expr1073760598 !@expr18775 op2@var2879 ; }
6679: else { if (@expr18735 cmp@var2871 ==@expr18736 ">" ) {
6680: result@var2872 =@expr1073760602 op1@var2878 &&@expr1073760603 !@expr18775 op2@var2879 ; }
6681: else { if (@expr18739 cmp@var2871 ==@expr18740 "<=" ) {
6682: result@var2872 =@expr1073760607 !@expr18784 op1@var2878 ||@expr1073760609 op2@var2879 ; }
6683: else { if (@expr18743 cmp@var2871 ==@expr18744 "<" ) {
6684: result@var2872 =@expr1073760612 !@expr18784 op1@var2878 &&@expr1073760614 op2@var2879 ; }
6685: else {
6686: cmp@var2871 .@expr18712 clear (@expr18713 ) ; } } } } } }
6687: }
6688:
6689: if (@expr1073760617 !@expr1073760618 cmp@var2871 .@expr1073760619 empty (@expr1073760620 ) ) {
6690: tok@var2869 =@expr1073760621 tok@var2869 .@expr18510 next (@expr18511 ) ;
6691: tok@var2869 .@expr18528 deleteNext (@expr18529 2 ) ;
6692:
6693: tok@var2869 .@expr18520 str (@expr1073760627 result@var2872 ?@expr1073760628 "true" :@expr18631 "false" ) ;
6694: ret@var2868 =@expr1073760630 true ;
6695: }
6696: }
6697: }
6698:
6699: return ret@var2868 ;
6700: }
6701:
6702: bool Tokenizer :: simplifyConstTernaryOp ( )
6703: {
6704: bool ret@var2880 ; ret@var2880 =@expr1073760631 false ;
6705: const Token * templateParameterEnd@var2881 ; templateParameterEnd@var2881 =@expr1073760632 nullptr ;
6706: for (@expr1073760633 Token *@expr18810 tok@var2882 =@expr1073760635 list@var872 .@expr1073760636 front (@expr1073760637 ) ; tok@var2882 ; tok@var2882 =@expr1073760638 tok@var2882 .@expr18815 next (@expr18816 ) ) {
6707: if (@expr1073760641 tok@var2882 .@expr18818 str (@expr18819 ) ==@expr1073760644 "<" &&@expr1073760645 TemplateSimplifier ::@expr18822 templateParameters (@expr1073760647 tok@var2882 ) ) {
6708: templateParameterEnd@var2881 =@expr1073760648 tok@var2882 .@expr1073760649 findClosingBracket (@expr1073760650 ) ; }
6709: if (@expr1073760651 tok@var2882 ==@expr1073760652 templateParameterEnd@var2881 ) {
6710: templateParameterEnd@var2881 =@expr1073760653 nullptr ; }
6711: if (@expr1073760654 tok@var2882 .@expr18818 str (@expr18819 ) !=@expr1073760657 "?" ) {
6712: continue ; }
6713:
6714: if (@expr1073760658 !@expr1073760659 Token ::@expr18836 Match (@expr1073760661 tok@var2882 .@expr18838 tokAt (@expr18839 -2 ) , "<|=|,|(|[|{|}|;|case|return %bool%|%num%" ) &&@expr1073760664
6715: !@expr1073760665 Token ::@expr18836 Match (@expr1073760667 tok@var2882 .@expr18838 tokAt (@expr1073760669 -4 ) , "<|=|,|(|[|{|}|;|case|return ( %bool%|%num% )" ) ) {
6716: continue ; }
6717:
6718: const int offset@var2883 =@expr1073760670 (@expr1073760671 tok@var2882 .@expr1073760672 previous (@expr1073760673 ) .@expr1073760674 str (@expr1073760675 ) ==@expr1073760676 ")" ) ?@expr1073760677 2 :@expr1073760678 1 ;
6719:
6720: if (@expr1073760679 tok@var2882 .@expr18856 strAt (@expr1073760681 -2 *@expr18858 offset@var2883 ) ==@expr1073760683 "<" ) {
6721: if (@expr1073760684 isC (@expr1073760685 ) ||@expr1073760686 !@expr1073760687 TemplateSimplifier ::@expr18822 templateParameters (@expr1073760689 tok@var2882 .@expr18838 tokAt (@expr1073760691 -2 *@expr18858 offset@var2883 ) ) ) {
6722: continue ; }
6723: }
6724:
6725:
6726: Token * colon@var2884 ; colon@var2884 =@expr1073760693 skipTernaryOp (@expr1073760694 tok@var2882 ) ;
6727: if (@expr1073760695 !@expr1073760696 colon@var2884 ||@expr1073760697 colon@var2884 .@expr18874 previous (@expr18875 ) .@expr1073760700 str (@expr1073760701 ) !=@expr1073760702 ":" ||@expr1073760703 !@expr1073760704 colon@var2884 .@expr1073760705 next (@expr1073760706 ) ) {
6728: continue ; }
6729:
6730:
6731: if (@expr1073760707 colon@var2884 .@expr18874 previous (@expr18875 ) ==@expr1073760710 tok@var2882 .@expr18815 next (@expr18816 ) ) {
6732: tok@var2882 .@expr1073760713 insertToken (@expr1073760714 tok@var2882 .@expr18856 strAt (@expr1073760716 -@expr1073760717 offset@var2883 ) ) ; }
6733:
6734:
6735: tok@var2882 =@expr1073760718 tok@var2882 .@expr18838 tokAt (@expr18839 -2 ) ;
6736: if (@expr1073760721 offset@var2883 ==@expr1073760722 2 ) {
6737:
6738: tok@var2882 =@expr1073760723 tok@var2882 .@expr18838 tokAt (@expr18839 -2 ) ;
6739:
6740: tok@var2882 .@expr18902 deleteNext (@expr1073760727 ) ;
6741: tok@var2882 .@expr18815 next (@expr18816 ) .@expr1073760730 deleteNext (@expr1073760731 ) ;
6742: }
6743:
6744: if (@expr1073760732 Token ::@expr18836 Match (@expr1073760734 tok@var2882 .@expr18815 next (@expr18816 ) , "false|0" ) ) {
6745:
6746: Token ::@expr18913 eraseTokens (@expr1073760738 tok@var2882 , colon@var2884 ) ;
6747:
6748: tok@var2882 =@expr1073760739 tok@var2882 .@expr18815 next (@expr18816 ) ;
6749: ret@var2880 =@expr1073760742 true ;
6750: }
6751:
6752:
6753: else {
6754:
6755: tok@var2882 .@expr18902 deleteNext (@expr1073760744 2 ) ;
6756:
6757: int ternaryOplevel@var2885 ; ternaryOplevel@var2885 =@expr1073760745 0 ;
6758: for (@expr1073760746 const Token *@expr18810 endTok@var2886 =@expr1073760748 colon@var2884 ; endTok@var2886 ; endTok@var2886 =@expr1073760749 endTok@var2886 .@expr1073760750 next (@expr1073760751 ) ) {
6759: if (@expr1073760752 Token ::@expr18836 Match (@expr1073760754 endTok@var2886 , "(|[|{" ) ) {
6760: endTok@var2886 =@expr1073760755 endTok@var2886 .@expr1073760756 link (@expr1073760757 ) ; }
6761: else { if (@expr1073760758 endTok@var2886 .@expr18935 str (@expr18936 ) ==@expr1073760761 "<" &&@expr1073760762 (@expr1073760763 endTok@var2886 .@expr1073760764 strAt (@expr1073760765 1 ) ==@expr1073760766 ">" ||@expr1073760767 TemplateSimplifier ::@expr18822 templateParameters (@expr1073760769 endTok@var2886 ) ) ) {
6762: endTok@var2886 =@expr1073760770 endTok@var2886 .@expr1073760771 findClosingBracket (@expr1073760772 ) ; }
6763: else { if (@expr1073760773 endTok@var2886 .@expr18935 str (@expr18936 ) ==@expr1073760776 "?" ) {
6764: ++@expr1073760777 ternaryOplevel@var2885 ; }
6765: else { if (@expr1073760778 Token ::@expr18836 Match (@expr1073760780 endTok@var2886 , ")|}|]|;|,|:|>" ) ) {
6766: if (@expr1073760781 endTok@var2886 .@expr18935 str (@expr18936 ) ==@expr1073760784 ":" &&@expr1073760785 ternaryOplevel@var2885 ) {
6767: --@expr1073760786 ternaryOplevel@var2885 ; }
6768: else { if (@expr1073760787 endTok@var2886 .@expr18935 str (@expr18936 ) ==@expr1073760790 ">" &&@expr1073760791 !@expr1073760792 templateParameterEnd@var2881 ) {
6769: ; }
6770: else {
6771: Token ::@expr18913 eraseTokens (@expr1073760794 colon@var2884 .@expr1073760795 tokAt (@expr1073760796 -2 ) , endTok@var2886 ) ;
6772: ret@var2880 =@expr1073760797 true ;
6773: break ;
6774: } }
6775: } } } }
6776: }
6777: }
6778: }
6779: return ret@var2880 ;
6780: }
6781:
6782: void Tokenizer :: simplifyUndefinedSizeArray ( )
6783: {
6784: for (@expr1073760798 Token *@expr1073760799 tok@var2887 =@expr1073760800 list@var872 .@expr1073760801 front (@expr1073760802 ) ; tok@var2887 ; tok@var2887 =@expr1073760803 tok@var2887 .@expr18980 next (@expr18981 ) ) {
6785: if (@expr1073760806 Token ::@expr18983 Match (@expr1073760808 tok@var2887 , "%type%" ) ) {
6786: Token * tok2@var2888 ; tok2@var2888 =@expr1073760809 tok@var2887 .@expr18980 next (@expr18981 ) ;
6787: while (@expr1073760812 tok2@var2888 &&@expr1073760813 tok2@var2888 .@expr1073760814 str (@expr1073760815 ) ==@expr1073760816 "*" ) {
6788: tok2@var2888 =@expr1073760817 tok2@var2888 .@expr18994 next (@expr18995 ) ; }
6789: if (@expr1073760820 !@expr1073760821 Token ::@expr18983 Match (@expr1073760823 tok2@var2888 , "%name% [ ] ;|[" ) ) {
6790: continue ; }
6791:
6792: tok@var2887 =@expr1073760824 tok2@var2888 .@expr1073760825 previous (@expr1073760826 ) ;
6793: Token * end@var2889 ; end@var2889 =@expr1073760827 tok2@var2888 .@expr18994 next (@expr18995 ) ;
6794: int count@var2890 ; count@var2890 =@expr1073760830 0 ;
6795: do {
6796: end@var2889 =@expr1073760831 end@var2889 .@expr1073760832 tokAt (@expr1073760833 2 ) ;
6797: ++@expr1073760834 count@var2890 ;
6798: } while (@expr1073760835 Token ::@expr18983 Match (@expr1073760837 end@var2889 , "[ ] [;=[]" ) ) ;
6799: if (@expr1073760838 Token ::@expr18983 Match (@expr1073760840 end@var2889 , "[;=]" ) ) {
6800: do {
6801: tok2@var2888 .@expr1073760841 deleteNext (@expr1073760842 2 ) ;
6802: tok@var2887 .@expr1073760843 insertToken (@expr1073760844 "*" ) ;
6803: } while (@expr1073760845 --@expr1073760846 count@var2890 ) ;
6804: tok@var2887 =@expr1073760847 end@var2889 ;
6805: } else {
6806: tok@var2887 =@expr1073760848 tok@var2887 .@expr1073760849 tokAt (@expr1073760850 3 ) ; }
6807: }
6808: }
6809: }
6810:
6811: void Tokenizer :: simplifyCasts ( )
6812: {
6813: for (@expr1073760851 Token *@expr1073760852 tok@var2891 =@expr1073760853 list@var872 .@expr1073760854 front (@expr1073760855 ) ; tok@var2891 ; tok@var2891 =@expr1073760856 tok@var2891 .@expr19033 next (@expr19034 ) ) {
6814:
|
6817:
6818: if (@expr1073760859 !@expr19036 tok@var2891 .@expr19037 isName (@expr19038 ) &&@expr1073760863
6819: Token ::@expr19040 simpleMatch (@expr1073760865 tok@var2891 .@expr19033 next (@expr19034 ) , "* (" ) &&@expr1073760868
6820: !@expr1073760869 Token ::@expr19046 Match (@expr1073760871 tok@var2891 .@expr19048 linkAt (@expr19049 2 ) , ") %name%|&" ) ) {
6821: tok@var2891 =@expr1073760874 tok@var2891 .@expr19048 linkAt (@expr19049 2 ) ;
6822: continue ;
6823: }
6824:
6825:
6826: if (@expr1073760877 tok@var2891 .@expr19054 str (@expr19055 ) ==@expr1073760880 "(" &&@expr1073760881 Token ::@expr19040 simpleMatch (@expr1073760883 tok@var2891 .@expr19060 link (@expr19061 ) , ") [" ) ) {
6827: tok@var2891 =@expr1073760886 tok@var2891 .@expr19060 link (@expr19061 ) ;
6828: continue ;
6829: }
6830:
6831: if (@expr1073760889 Token ::@expr19046 Match (@expr1073760891 tok@var2891 .@expr19033 next (@expr19034 ) , "( %type% ) %num%" ) &&@expr1073760894 tok@var2891 .@expr19033 next (@expr19034 ) .@expr19073 link (@expr19074 ) .@expr19075 previous (@expr19076 ) .@expr1073760901 isStandardType (@expr1073760902 ) ) {
6832: const long long value@var2892 =@expr1073760903 MathLib ::@expr1073760904 toLongNumber (@expr1073760905 tok@var2891 .@expr19033 next (@expr19034 ) .@expr19073 link (@expr19074 ) .@expr19086 next (@expr19087 ) .@expr1073760912 str (@expr1073760913 ) ) ;
6833: int bits@var2893 ; bits@var2893 =@expr1073760914 mSettings@var879 .@expr1073760915 char_bit@var3589 *@expr1073760916 mTypeSize@var884 [@expr1073760917 tok@var2891 .@expr19033 next (@expr19034 ) .@expr19073 link (@expr19074 ) .@expr19075 previous (@expr19076 ) .@expr1073760924 str (@expr1073760925 ) ] ;
6834: if (@expr1073760926 !@expr1073760927 tok@var2891 .@expr19104 tokAt (@expr19105 2 ) .@expr1073760930 isUnsigned (@expr1073760931 ) &&@expr1073760932 bits@var2893 >@expr1073760933 0 ) {
6835: bits@var2893 --@expr1073760934 ; }
6836: if (@expr1073760935 bits@var2893 <@expr1073760936 31 &&@expr1073760937 value@var2892 >=@expr1073760938 0 &&@expr1073760939 value@var2892 <@expr1073760940 (@expr1073760941 1LL <<@expr1073760942 bits@var2893 ) ) {
6837: tok@var2891 .@expr19048 linkAt (@expr19120 1 ) .@expr19121 next (@expr19122 ) .@expr19123 isCast (@expr19124 true ) ;
6838: Token ::@expr19125 eraseTokens (@expr19126 tok@var2891 , tok@var2891 .@expr19033 next (@expr19034 ) .@expr19073 link (@expr19074 ) .@expr19086 next (@expr19087 ) ) ;
6839: }
6840: continue ;
6841: }
6842:
6843: while (@expr1073760957 (@expr1073760958 Token ::@expr19046 Match (@expr1073760960 tok@var2891 .@expr19033 next (@expr19034 ) , "( %type% *| *| *|&| ) *|&| %name%" ) &&@expr1073760963 (@expr1073760964 tok@var2891 .@expr19054 str (@expr19055 ) !=@expr1073760967 ")" ||@expr1073760968 tok@var2891 .@expr19104 tokAt (@expr19105 2 ) .@expr1073760971 isStandardType (@expr1073760972 ) ) ) ||@expr1073760973
6844: Token ::@expr19046 Match (@expr1073760975 tok@var2891 .@expr19033 next (@expr19034 ) , "( const| %type% * *| *|&| ) *|&| %name%" ) ||@expr1073760978
6845: Token ::@expr19046 Match (@expr1073760980 tok@var2891 .@expr19033 next (@expr19034 ) , "( const| %type% %type% *| *| *|&| ) *|&| %name%" ) ||@expr1073760983
6846: (@expr1073760984 !@expr19036 tok@var2891 .@expr19037 isName (@expr19038 ) &&@expr1073760988 (@expr1073760989 Token ::@expr19046 Match (@expr1073760991 tok@var2891 .@expr19033 next (@expr19034 ) , "( %type% * *| *|&| ) (" ) ||@expr1073760994
6847: Token ::@expr19046 Match (@expr1073760996 tok@var2891 .@expr19033 next (@expr19034 ) , "( const| %type% %type% * *| *|&| ) (" ) ) ) ) {
6848: if (@expr1073760999 tok@var2891 .@expr19037 isName (@expr19038 ) &&@expr1073761002 tok@var2891 .@expr19054 str (@expr19055 ) !=@expr1073761005 "return" ) {
6849: break ; }
6850:
6851: if (@expr1073761006 isCPP (@expr1073761007 ) &&@expr1073761008 tok@var2891 .@expr1073761009 strAt (@expr1073761010 -1 ) ==@expr1073761011 "operator" ) {
6852: break ; }
6853:
6854:
6855: Token ::@expr19125 eraseTokens (@expr19126 tok@var2891 , tok@var2891 .@expr19033 next (@expr19034 ) .@expr19073 link (@expr19074 ) .@expr19086 next (@expr19087 ) ) ;
6856:
6857:
6858: Token * tok2@var2894 ; tok2@var2894 =@expr1073761020 tok@var2891 .@expr19033 next (@expr19034 ) ;
6859: if (@expr1073761023 !@expr1073761024 Token ::@expr19046 Match (@expr1073761026 tok2@var2894 , "%name% [|." ) ) {
6860: tok2@var2894 .@expr1073761027 isCast (@expr1073761028 true ) ; }
6861: else {
6862:
6863: tok2@var2894 .@expr1073761029 next (@expr1073761030 ) .@expr1073761031 isCast (@expr1073761032 true ) ;
6864: }
6865:
6866:
6867: if (@expr1073761033 Token ::@expr19040 simpleMatch (@expr1073761035 tok@var2891 , "* &" ) ) {
6868: tok@var2891 .@expr1073761036 deleteNext (@expr1073761037 ) ;
6869: tok@var2891 .@expr1073761038 deleteThis (@expr1073761039 ) ;
6870: }
6871:
6872: if (@expr19216 tok@var2891 .@expr19054 str (@expr19055 ) ==@expr19219 ")" &&@expr19220 tok@var2891 .@expr19060 link (@expr19061 ) .@expr19223 previous (@expr19224 ) ) {
6873:
6874:
6875: tok@var2891 =@expr1073761049 tok@var2891 .@expr19060 link (@expr19061 ) .@expr19223 previous (@expr19224 ) ;
6876: }
6877: }
6878:
6879:
6880: while (@expr1073761054 Token ::@expr19046 Match (@expr1073761056 tok@var2891 .@expr19033 next (@expr19034 ) , "( %type% %type%| * *| ) 0" ) ) {
6881: tok@var2891 .@expr19048 linkAt (@expr19120 1 ) .@expr19121 next (@expr19122 ) .@expr19123 isCast (@expr19124 true ) ;
6882: Token ::@expr19125 eraseTokens (@expr19126 tok@var2891 , tok@var2891 .@expr19033 next (@expr19034 ) .@expr19073 link (@expr19074 ) .@expr19086 next (@expr19087 ) ) ;
6883: if (@expr19216 tok@var2891 .@expr19054 str (@expr19055 ) ==@expr19219 ")" &&@expr19220 tok@var2891 .@expr19060 link (@expr19061 ) .@expr19223 previous (@expr19224 ) ) {
6884:
6885:
6886: tok@var2891 =@expr1073761082 tok@var2891 .@expr19060 link (@expr19061 ) .@expr19223 previous (@expr19224 ) ;
6887: }
6888: }
6889:
6890: if (@expr1073761087 Token ::@expr19046 Match (@expr1073761089 tok@var2891 .@expr19033 next (@expr19034 ) , "dynamic_cast|reinterpret_cast|const_cast|static_cast <" ) ) {
6891: Token * tok2@var2895 ; tok2@var2895 =@expr1073761092 tok@var2891 .@expr19048 linkAt (@expr19049 2 ) ;
6892: if (@expr1073761095 !@expr1073761096 Token ::@expr19040 simpleMatch (@expr1073761098 tok2@var2895 , "> (" ) ) {
6893: break ; }
6894:
6895: tok2@var2895 .@expr1073761099 tokAt (@expr1073761100 2 ) .@expr1073761101 isCast (@expr1073761102 true ) ;
6896: Token ::@expr19125 eraseTokens (@expr1073761104 tok@var2891 , tok2@var2895 .@expr1073761105 next (@expr1073761106 ) ) ;
6897: }
6898: }
6899: }
6900:
6901:
6902: void Tokenizer :: simplifyFunctionParameters ( )
6903: {
6904: for (@expr1073761107 Token *@expr19284 tok@var2896 =@expr1073761109 list@var872 .@expr1073761110 front (@expr1073761111 ) ; tok@var2896 ; tok@var2896 =@expr1073761112 tok@var2896 .@expr19289 next (@expr19290 ) ) {
6905: if (@expr1073761115 tok@var2896 .@expr19292 link (@expr19293 ) &&@expr1073761118 Token ::@expr19295 Match (@expr1073761120 tok@var2896 , "{|[|(" ) ) {
6906: tok@var2896 =@expr1073761121 tok@var2896 .@expr19292 link (@expr19293 ) ;
6907: }
6908:
6909:
6910: else { if (@expr1073761124 Token ::@expr19295 Match (@expr1073761126 tok@var2896 , "%name% ( %name% [,)]" ) &&@expr1073761127
6911: !@expr1073761128 (@expr1073761129 tok@var2896 .@expr19306 strAt (@expr19307 -1 ) ==@expr1073761132 ":" ||@expr1073761133 tok@var2896 .@expr19306 strAt (@expr19307 -1 ) ==@expr1073761136 "," ||@expr1073761137 tok@var2896 .@expr19306 strAt (@expr19307 -1 ) ==@expr1073761140 "::" ) ) {
6912:
6913:
6914:
6915: std ::@expr1073761141 map < std ::@expr19318 string , Token *@expr19284 > argumentNames@var2897 ;
6916: bool bailOut@var2898 ; bailOut@var2898 =@expr1073761144 false ;
6917: Token * tokparam@var2899 ; tokparam@var2899 =@expr1073761145 nullptr ;
6918:
6919:
6920: const std ::@expr1073761146 string & funcName@var2900 (@expr1073761147 tok@var2896 .@expr19324 str (@expr19325 ) ) ;
6921:
6922:
6923: Token * tok1@var2901 ; tok1@var2901 =@expr1073761150 tok@var2896 ;
6924:
6925: while (@expr1073761151 nullptr !=@expr1073761152 (@expr1073761153 tok1@var2901 =@expr1073761154 tok1@var2901 .@expr19331 tokAt (@expr19332 2 ) ) ) {
6926: if (@expr1073761157 !@expr1073761158 Token ::@expr19295 Match (@expr1073761160 tok1@var2901 , "%name% [,)]" ) ) {
6927: bailOut@var2898 =@expr1073761161 true ;
6928: break ;
6929: }
6930:
6931:
6932: if (@expr1073761162 argumentNames@var2897 .@expr19339 find (@expr1073761164 tok1@var2901 .@expr19341 str (@expr19342 ) ) !=@expr1073761167 argumentNames@var2897 .@expr19344 end (@expr19345 ) ) {
6933: tokparam@var2899 =@expr1073761170 tok1@var2901 ; }
6934: else { if (@expr1073761171 tok1@var2901 .@expr19341 str (@expr19342 ) !=@expr1073761174 funcName@var2900 ) {
6935: argumentNames@var2897 [@expr1073761175 tok1@var2901 .@expr19341 str (@expr19342 ) ] =@expr1073761178 tok1@var2901 ; }
6936: else {
6937: if (@expr19355 tok1@var2901 .@expr19356 next (@expr19357 ) .@expr19358 str (@expr19359 ) ==@expr19360 ")" ) {
6938: if (@expr1073761185 tok1@var2901 .@expr19362 previous (@expr19363 ) .@expr1073761188 str (@expr1073761189 ) ==@expr1073761190 "," ) {
6939: tok1@var2901 =@expr1073761191 tok1@var2901 .@expr19331 tokAt (@expr19369 -2 ) ;
6940: tok1@var2901 .@expr19370 deleteNext (@expr1073761195 2 ) ;
6941: } else {
6942: tok1@var2901 =@expr1073761196 tok1@var2901 .@expr19362 previous (@expr19363 ) ;
6943: tok1@var2901 .@expr19370 deleteNext (@expr1073761200 ) ;
6944: bailOut@var2898 =@expr1073761201 true ;
6945: break ;
6946: }
6947: } else {
6948: tok1@var2901 =@expr1073761202 tok1@var2901 .@expr19331 tokAt (@expr19369 -2 ) ;
6949: tok1@var2901 .@expr19356 next (@expr19357 ) .@expr1073761207 deleteNext (@expr1073761208 2 ) ;
6950: }
6951: } }
6952:
6953: if (@expr19355 tok1@var2901 .@expr19356 next (@expr19357 ) .@expr19358 str (@expr19359 ) ==@expr19360 ")" ) {
6954: tok1@var2901 =@expr1073761215 tok1@var2901 .@expr19331 tokAt (@expr19332 2 ) ;
6955:
6956: if (@expr1073761218 !@expr19395 tok1@var2901 ||@expr1073761220 !@expr1073761221 tok1@var2901 .@expr1073761222 isName (@expr1073761223 ) ) {
6957: bailOut@var2898 =@expr1073761224 true ; }
6958: break ;
6959: }
6960: }
6961:
6962:
6963: tok@var2896 =@expr1073761225 tok@var2896 .@expr19289 next (@expr19290 ) ;
6964:
6965: if (@expr19404 bailOut@var2898 ) {
6966: tok@var2896 =@expr1073761229 tok@var2896 .@expr19292 link (@expr19293 ) ;
6967: continue ;
6968: }
6969:
6970: tok1@var2901 =@expr1073761232 tok@var2896 .@expr19292 link (@expr19293 ) .@expr1073761235 next (@expr1073761236 ) ;
6971:
6972:
6973: for (@expr1073761237 const Token *@expr19284 tok2@var2902 =@expr1073761239 tok1@var2901 ; tok2@var2902 ; tok2@var2902 =@expr1073761240 tok2@var2902 .@expr1073761241 next (@expr1073761242 ) ) {
6974: if (@expr1073761243 Token ::@expr1073761244 simpleMatch (@expr1073761245 tok2@var2902 , "; {" ) ) {
6975: break ; }
6976: else { if (@expr1073761246 tok2@var2902 .@expr1073761247 str (@expr1073761248 ) ==@expr1073761249 "{" ) {
6977: bailOut@var2898 =@expr1073761250 true ;
6978: break ;
6979: } }
6980: }
6981:
6982: if (@expr19404 bailOut@var2898 ) {
6983: tok@var2896 =@expr1073761252 tok@var2896 .@expr19292 link (@expr19293 ) ;
6984: continue ;
6985: }
6986:
6987:
6988: std ::@expr1073761255 map < std ::@expr19318 string , Token *@expr19284 > argumentNames2@var2903 ;
6989:
6990: while (@expr1073761258 tok1@var2901 &&@expr1073761259 tok1@var2901 .@expr19341 str (@expr19342 ) !=@expr1073761262 "{" ) {
6991: if (@expr1073761263 Token ::@expr19295 Match (@expr1073761265 tok1@var2901 , "(|)" ) ) {
6992: bailOut@var2898 =@expr1073761266 true ;
6993: break ;
6994: }
6995: if (@expr1073761267 tok1@var2901 .@expr19341 str (@expr19342 ) ==@expr1073761270 ";" ) {
6996: if (@expr1073761271 tokparam@var2899 ) {
6997: syntaxError (@expr1073761272 tokparam@var2899 ) ;
6998: }
6999: Token * tok2@var2904 ; tok2@var2904 =@expr1073761273 tok1@var2901 .@expr19362 previous (@expr19363 ) ;
7000: while (@expr1073761276 tok2@var2904 .@expr19453 str (@expr19454 ) ==@expr1073761279 "]" ) {
7001: tok2@var2904 =@expr1073761280 tok2@var2904 .@expr1073761281 link (@expr1073761282 ) .@expr1073761283 previous (@expr1073761284 ) ; }
7002:
7003:
7004: if (@expr1073761285 !@expr1073761286 tok2@var2904 .@expr1073761287 isName (@expr1073761288 ) ) {
7005: bailOut@var2898 =@expr1073761289 true ;
7006: break ;
7007: }
7008:
7009: if (@expr1073761290 argumentNames2@var2903 .@expr19467 find (@expr1073761292 tok2@var2904 .@expr19453 str (@expr19454 ) ) !=@expr1073761295 argumentNames2@var2903 .@expr19472 end (@expr19473 ) ) {
7010:
7011: syntaxError (@expr1073761298 tok1@var2901 ) ;
7012: } else {
7013: argumentNames2@var2903 [@expr1073761299 tok2@var2904 .@expr19453 str (@expr19454 ) ] =@expr1073761302 tok2@var2904 ; }
7014:
7015: if (@expr1073761303 argumentNames@var2897 .@expr19339 find (@expr1073761305 tok2@var2904 .@expr19453 str (@expr19454 ) ) ==@expr1073761308 argumentNames@var2897 .@expr19344 end (@expr19345 ) ) {
7016:
7017: bailOut@var2898 =@expr1073761311 true ;
7018: break ;
7019: }
7020: }
7021: tok1@var2901 =@expr1073761312 tok1@var2901 .@expr19356 next (@expr19357 ) ;
7022: }
7023:
7024: if (@expr1073761315 bailOut@var2898 ||@expr1073761316 !@expr19395 tok1@var2901 ) {
7025: tok@var2896 =@expr1073761318 tok@var2896 .@expr19292 link (@expr19293 ) ;
7026: continue ;
7027: }
7028:
7029:
7030:
7031: if (@expr1073761321 argumentNames@var2897 .@expr1073761322 size (@expr1073761323 ) !=@expr1073761324 argumentNames2@var2903 .@expr1073761325 size (@expr1073761326 ) ) {
7032:
7033: tok1@var2901 =@expr1073761327 tok1@var2901 .@expr19362 previous (@expr19363 ) ;
7034: for (@expr1073761330 std ::@expr19318 pair < const std ::@expr19318 string , Token *@expr19284 > &@expr1073761334 argumentName@var2905 :@expr1073761335 argumentNames@var2897 ) {
7035: if (@expr1073761336 argumentNames2@var2903 .@expr19467 find (@expr1073761338 argumentName@var2905 .@expr19515 first@var2906 ) ==@expr1073761340 argumentNames2@var2903 .@expr19472 end (@expr19473 ) ) {
7036:
7037: tok1@var2901 .@expr19519 insertToken (@expr1073761344 ";" ) ;
7038: tok1@var2901 .@expr19519 insertToken (@expr1073761346 argumentName@var2905 .@expr19515 first@var2906 ) ;
7039:
7040: argumentNames2@var2903 [@expr1073761348 argumentName@var2905 .@expr19515 first@var2906 ] =@expr1073761350 tok1@var2901 .@expr19356 next (@expr19357 ) ;
7041: tok1@var2901 .@expr19519 insertToken (@expr1073761354 "int" ) ;
7042: }
7043: }
7044: }
7045:
7046: while (@expr1073761355 tok@var2896 .@expr19324 str (@expr19325 ) !=@expr1073761358 ")" ) {
7047:
7048: Token * declStart@var2907 ; declStart@var2907 =@expr1073761359 argumentNames2@var2903 [@expr1073761360 tok@var2896 .@expr19289 next (@expr19290 ) .@expr1073761363 str (@expr1073761364 ) ] ;
7049: Token * declEnd@var2908 ; declEnd@var2908 =@expr1073761365 declStart@var2907 ;
7050: while (@expr1073761366 declStart@var2907 .@expr19543 previous (@expr19544 ) .@expr19545 str (@expr19546 ) !=@expr1073761371 ";" &&@expr1073761372 declStart@var2907 .@expr19543 previous (@expr19544 ) .@expr19545 str (@expr19546 ) !=@expr1073761377 ")" ) {
7051: declStart@var2907 =@expr1073761378 declStart@var2907 .@expr19543 previous (@expr19544 ) ; }
7052: while (@expr1073761381 declEnd@var2908 .@expr19558 next (@expr19559 ) .@expr19560 str (@expr19561 ) !=@expr1073761386 ";" &&@expr1073761387 declEnd@var2908 .@expr19558 next (@expr19559 ) .@expr19560 str (@expr19561 ) !=@expr1073761392 "{" ) {
7053: declEnd@var2908 =@expr1073761393 declEnd@var2908 .@expr19558 next (@expr19559 ) ; }
7054:
7055:
7056: declEnd@var2908 .@expr1073761396 deleteNext (@expr1073761397 ) ;
7057:
7058:
7059: Token ::@expr1073761398 replace (@expr1073761399 tok@var2896 .@expr19289 next (@expr19290 ) , declStart@var2907 , declEnd@var2908 ) ;
7060:
7061:
7062: tok@var2896 =@expr1073761402 declEnd@var2908 .@expr19558 next (@expr19559 ) ;
7063:
7064:
7065: if (@expr1073761405 tok@var2896 .@expr19324 str (@expr19325 ) ==@expr1073761408 "," ) {
7066: tok@var2896 .@expr1073761409 linenr (@expr1073761410 tok@var2896 .@expr1073761411 previous (@expr1073761412 ) .@expr1073761413 linenr (@expr1073761414 ) ) ; }
7067: }
7068:
7069: tok@var2896 =@expr1073761415 tok@var2896 .@expr19289 next (@expr19290 ) .@expr1073761418 link (@expr1073761419 ) ;
7070: } }
7071: }
7072: }
7073:
7074: void Tokenizer :: simplifyPointerToStandardType ( )
7075: {
7076: if (@expr1073761420 !@expr1073761421 isC (@expr1073761422 ) ) {
7077: return ; }
7078:
7079: for (@expr1073761423 Token *@expr1073761424 tok@var2909 =@expr1073761425 list@var872 .@expr1073761426 front (@expr1073761427 ) ; tok@var2909 ; tok@var2909 =@expr1073761428 tok@var2909 .@expr19605 next (@expr19606 ) ) {
7080: if (@expr1073761431 !@expr1073761432 Token ::@expr19609 Match (@expr1073761434 tok@var2909 , "& %name% [ 0 ] !![" ) ) {
7081: continue ; }
7082:
7083: if (@expr1073761435 !@expr1073761436 Token ::@expr19609 Match (@expr1073761438 tok@var2909 .@expr19615 previous (@expr19616 ) , "[,(=]" ) ) {
7084: continue ; }
7085:
7086:
7087: Token ::@expr1073761441 eraseTokens (@expr1073761442 tok@var2909 .@expr19605 next (@expr19606 ) , tok@var2909 .@expr1073761445 tokAt (@expr1073761446 5 ) ) ;
7088:
7089: tok@var2909 =@expr1073761447 tok@var2909 .@expr19615 previous (@expr19616 ) ;
7090: if (@expr1073761450 !@expr1073761451 tok@var2909 ) {
7091: break ; }
7092: tok@var2909 .@expr1073761452 deleteNext (@expr1073761453 ) ;
7093: }
7094: }
7095:
7096: void Tokenizer :: simplifyFunctionPointers ( )
7097: {
7098: for (@expr1073761454 Token *@expr1073761455 tok@var2910 =@expr1073761456 list@var872 .@expr1073761457 front (@expr1073761458 ) ; tok@var2910 ; tok@var2910 =@expr1073761459 tok@var2910 .@expr19636 next (@expr19637 ) ) {
7099:
7100:
7101: if (@expr1073761462 Token ::@expr19639 simpleMatch (@expr1073761464 tok@var2910 , ") (" ) ) {
7102: tok@var2910 =@expr1073761465 tok@var2910 .@expr19636 next (@expr19637 ) .@expr1073761468 link (@expr1073761469 ) ;
7103: continue ;
7104: }
7105:
7106:
7107: if (@expr1073761470 Token ::@expr19647 Match (@expr1073761472 tok@var2910 , "( %type% %type%| *| *| ( * ) (" ) ||@expr1073761473
7108: Token ::@expr19647 Match (@expr1073761475 tok@var2910 , "static_cast < %type% %type%| *| *| ( * ) (" ) ) {
7109: Token * tok1@var2911 ; tok1@var2911 =@expr1073761476 tok@var2910 ;
7110:
7111: if (@expr1073761477 isCPP (@expr1073761478 ) &&@expr1073761479 tok1@var2911 .@expr1073761480 str (@expr1073761481 ) ==@expr1073761482 "static_cast" ) {
7112: tok1@var2911 =@expr1073761483 tok1@var2911 .@expr19660 next (@expr19661 ) ; }
7113:
7114: tok1@var2911 =@expr1073761486 tok1@var2911 .@expr19660 next (@expr19661 ) ;
7115:
7116: if (@expr1073761489 Token ::@expr19647 Match (@expr1073761491 tok1@var2911 .@expr19660 next (@expr19661 ) , "%type%" ) ) {
7117: tok1@var2911 =@expr1073761494 tok1@var2911 .@expr19660 next (@expr19661 ) ; }
7118:
7119: while (@expr1073761497 tok1@var2911 .@expr19660 next (@expr19661 ) .@expr1073761500 str (@expr1073761501 ) ==@expr1073761502 "*" ) {
7120: tok1@var2911 =@expr1073761503 tok1@var2911 .@expr19660 next (@expr19661 ) ; }
7121:
7122:
7123: if (@expr1073761506 !@expr1073761507 Token ::@expr19647 Match (@expr1073761509 tok1@var2911 .@expr19686 linkAt (@expr1073761511 4 ) , ") )|>" ) ) {
7124: continue ; }
7125:
7126:
7127: tok1@var2911 .@expr1073761512 deleteNext (@expr1073761513 ) ;
7128: tok1@var2911 .@expr19660 next (@expr19661 ) .@expr1073761516 deleteNext (@expr1073761517 ) ;
7129: Token ::@expr19694 eraseTokens (@expr1073761519 tok1@var2911 .@expr19660 next (@expr19661 ) , tok1@var2911 .@expr19686 linkAt (@expr1073761523 2 ) .@expr1073761524 next (@expr1073761525 ) ) ;
7130: continue ;
7131: }
7132:
7133:
7134: else { if (@expr1073761526 tok@var2910 .@expr19703 previous (@expr19704 ) &&@expr1073761529 !@expr1073761530 Token ::@expr19647 Match (@expr1073761532 tok@var2910 .@expr19703 previous (@expr19704 ) , "{|}|;|,|(|public:|protected:|private:" ) ) {
7135: continue ; } }
7136:
7137: if (@expr1073761535 Token ::@expr19647 Match (@expr1073761537 tok@var2910 , "delete|else|return|throw|typedef" ) ) {
7138: continue ; }
7139:
7140: while (@expr1073761538 Token ::@expr19647 Match (@expr1073761540 tok@var2910 , "%type%|:: %type%|::" ) ) {
7141: tok@var2910 =@expr1073761541 tok@var2910 .@expr19636 next (@expr19637 ) ; }
7142:
7143: Token * tok2@var2912 ; tok2@var2912 =@expr1073761544 (@expr1073761545 tok@var2910 &&@expr1073761546 tok@var2910 .@expr1073761547 isName (@expr1073761548 ) ) ?@expr1073761549 tok@var2910 .@expr19636 next (@expr19637 ) :@expr1073761552 nullptr ;
7144: while (@expr1073761553 Token ::@expr19647 Match (@expr1073761555 tok2@var2912 , "*|&" ) ) {
7145: tok2@var2912 =@expr1073761556 tok2@var2912 .@expr19733 next (@expr19734 ) ; }
7146: if (@expr1073761559 !@expr1073761560 tok2@var2912 ||@expr1073761561 tok2@var2912 .@expr19738 str (@expr19739 ) !=@expr1073761564 "(" ) {
7147: continue ; }
7148: while (@expr1073761565 Token ::@expr19647 Match (@expr1073761567 tok2@var2912 , "(|:: %type%" ) ) {
7149: tok2@var2912 =@expr1073761568 tok2@var2912 .@expr19745 tokAt (@expr19746 2 ) ; }
7150: if (@expr1073761571 !@expr1073761572 Token ::@expr19647 Match (@expr1073761574 tok2@var2912 , "(|:: * *| %name%" ) ) {
7151: continue ; }
7152: tok2@var2912 =@expr1073761575 tok2@var2912 .@expr19745 tokAt (@expr19746 2 ) ;
7153: if (@expr1073761578 tok2@var2912 .@expr19738 str (@expr19739 ) ==@expr1073761581 "*" ) {
7154: tok2@var2912 =@expr1073761582 tok2@var2912 .@expr19733 next (@expr19734 ) ; }
7155: while (@expr1073761585 Token ::@expr19647 Match (@expr1073761587 tok2@var2912 , "%type%|:: %type%|::" ) ) {
7156: tok2@var2912 =@expr1073761588 tok2@var2912 .@expr19733 next (@expr19734 ) ; }
7157:
7158: if (@expr1073761591 !@expr1073761592 Token ::@expr19647 Match (@expr1073761594 tok2@var2912 , "%name% ) (" ) &&@expr1073761595
7159: !@expr1073761596 Token ::@expr19647 Match (@expr1073761598 tok2@var2912 , "%name% [ ] ) (" ) &&@expr1073761599
7160: !@expr1073761600 (@expr1073761601 Token ::@expr19647 Match (@expr1073761603 tok2@var2912 , "%name% (" ) &&@expr1073761604 Token ::@expr19639 simpleMatch (@expr1073761606 tok2@var2912 .@expr1073761607 linkAt (@expr1073761608 1 ) , ") ) (" ) ) ) {
7161: continue ; }
7162:
7163: while (@expr1073761609 tok@var2910 &&@expr1073761610 tok@var2910 .@expr1073761611 str (@expr1073761612 ) !=@expr1073761613 "(" ) {
7164: tok@var2910 =@expr1073761614 tok@var2910 .@expr19636 next (@expr19637 ) ; }
7165:
7166:
7167: if (@expr1073761617 !@expr1073761618 tok@var2910 ||@expr1073761619 !@expr1073761620 tok@var2910 .@expr19797 link (@expr19798 ) ||@expr1073761623 !@expr1073761624 tok@var2910 .@expr19797 link (@expr19798 ) .@expr19803 next (@expr19804 ) ) {
7168: syntaxError (@expr1073761629 nullptr ) ;
7169: }
7170: Token * endTok@var2913 ; endTok@var2913 =@expr1073761630 tok@var2910 .@expr19797 link (@expr19798 ) .@expr19803 next (@expr19804 ) .@expr1073761635 link (@expr1073761636 ) ;
7171: if (@expr1073761637 Token ::@expr19639 simpleMatch (@expr1073761639 endTok@var2913 , ") throw (" ) ) {
7172: endTok@var2913 =@expr1073761640 endTok@var2913 .@expr1073761641 linkAt (@expr1073761642 2 ) ; }
7173: if (@expr1073761643 !@expr1073761644 Token ::@expr19647 Match (@expr1073761646 endTok@var2913 , ") const|volatile| const|volatile| ;|,|)|=|[|{" ) ) {
7174: continue ; }
7175:
7176: while (@expr1073761647 Token ::@expr19647 Match (@expr1073761649 endTok@var2913 .@expr19826 next (@expr19827 ) , "const|volatile" ) ) {
7177: endTok@var2913 .@expr1073761652 deleteNext (@expr1073761653 ) ; }
7178:
7179:
7180: Token ::@expr19694 eraseTokens (@expr1073761655 tok@var2910 .@expr19797 link (@expr19798 ) , endTok@var2913 .@expr19826 next (@expr19827 ) ) ;
7181: if (@expr1073761660 Token ::@expr19639 simpleMatch (@expr1073761662 tok@var2910 .@expr19797 link (@expr19798 ) .@expr1073761665 previous (@expr1073761666 ) , ") )" ) ) {
7182:
7183:
7184: tok@var2910 .@expr19797 link (@expr19798 ) .@expr1073761669 deleteThis (@expr1073761670 ) ;
7185: tok@var2910 .@expr1073761671 deleteThis (@expr1073761672 ) ;
7186: } else {
7187:
7188:
7189: tok@var2910 .@expr19797 link (@expr19798 ) .@expr1073761675 insertToken (@expr1073761676 "(" ) ;
7190: Token * par1@var2914 ; par1@var2914 =@expr1073761677 tok@var2910 .@expr19797 link (@expr19798 ) .@expr19803 next (@expr19804 ) ;
7191: par1@var2914 .@expr1073761682 insertToken (@expr1073761683 ")" ) ;
7192: par1@var2914 .@expr1073761684 link (@expr1073761685 par1@var2914 .@expr19862 next (@expr19863 ) ) ;
7193: par1@var2914 .@expr19862 next (@expr19863 ) .@expr1073761690 link (@expr1073761691 par1@var2914 ) ;
7194: while (@expr1073761692 Token ::@expr19647 Match (@expr1073761694 tok@var2910 , "( %type% ::" ) ) {
7195: tok@var2910 .@expr1073761695 deleteNext (@expr1073761696 2 ) ; }
7196: }
7197: }
7198: }
7199:
7200:
7201: bool Tokenizer :: simplifyFunctionReturn ( )
7202: {
7203: std ::@expr1073761697 map < std ::@expr1073761698 string , const Token *@expr19875 > functions@var2915 ;
7204:
7205: for (@expr1073761700 const Token *@expr19875 tok@var2916 =@expr1073761702 tokens (@expr1073761703 ) ; tok@var2916 ; tok@var2916 =@expr1073761704 tok@var2916 .@expr1073761705 next (@expr1073761706 ) ) {
7206: if (@expr1073761707 tok@var2916 .@expr19884 str (@expr19885 ) ==@expr1073761710 "{" ) {
7207: tok@var2916 =@expr1073761711 tok@var2916 .@expr1073761712 link (@expr1073761713 ) ; }
7208:
7209: else { if (@expr1073761714 Token ::@expr19891 Match (@expr1073761716 tok@var2916 , "%name% ( ) { return %bool%|%char%|%num%|%str% ; }" ) &&@expr1073761717 tok@var2916 .@expr1073761718 strAt (@expr1073761719 -1 ) !=@expr1073761720 "::" ) {
7210: const Token * const any@var2917 ; any@var2917 =@expr1073761721 tok@var2916 .@expr1073761722 tokAt (@expr1073761723 5 ) ;
7211: functions@var2915 [@expr1073761724 tok@var2916 .@expr19884 str (@expr19885 ) ] =@expr1073761727 any@var2917 ;
7212: tok@var2916 =@expr1073761728 any@var2917 ;
7213: } }
7214: }
7215:
7216: if (@expr1073761729 functions@var2915 .@expr1073761730 empty (@expr1073761731 ) ) {
7217: return false ; }
7218:
7219: bool ret@var2918 ; ret@var2918 =@expr1073761732 false ;
7220: for (@expr1073761733 Token *@expr19875 tok@var2919 =@expr1073761735 list@var872 .@expr1073761736 front (@expr1073761737 ) ; tok@var2919 ; tok@var2919 =@expr1073761738 tok@var2919 .@expr19915 next (@expr19916 ) ) {
7221: if (@expr1073761741 Token ::@expr19891 Match (@expr1073761743 tok@var2919 , "(|[|=|return|%op% %name% ( ) ;|]|)|%cop%" ) ) {
7222: tok@var2919 =@expr1073761744 tok@var2919 .@expr19915 next (@expr19916 ) ;
7223: auto it@var2920 ; it@var2920 =@expr1073761747 functions@var2915 .@expr1073761748 find (@expr1073761749 tok@var2919 .@expr19926 str (@expr1073761751 ) ) ;
7224: if (@expr1073761752 it@var2920 !=@expr1073761753 functions@var2915 .@expr1073761754 cend (@expr1073761755 ) ) {
7225: tok@var2919 .@expr19926 str (@expr1073761757 it@var2920 .@expr1073761758 second@var2921 .@expr1073761759 str (@expr1073761760 ) ) ;
7226: tok@var2919 .@expr1073761761 deleteNext (@expr1073761762 2 ) ;
7227: ret@var2918 =@expr1073761763 true ;
7228: }
7229: }
7230: }
7231:
7232: return ret@var2918 ;
7233: }
7234:
7235: void Tokenizer :: simplifyVarDecl ( const bool only_k_r_fpar@var2922 )
7236: {
7237: simplifyVarDecl (@expr1073761764 list@var872 .@expr1073761765 front (@expr1073761766 ) , nullptr , only_k_r_fpar@var2922 ) ;
7238: }
7239:
7240: void Tokenizer :: simplifyVarDecl ( Token * tokBegin@var2923 , const Token * const tokEnd@var2924 , const bool only_k_r_fpar@var2925 )
7241: {
7242: const bool isCPP11@var2926 =@expr1073761767 mSettings@var879 .@expr1073761768 standards@var3567 .@expr1073761769 cpp@var3568 >=@expr1073761770 Standards ::@expr1073761771 CPP11 ;
7243:
7244:
7245:
7246: bool finishedwithkr@var2927 ; finishedwithkr@var2927 =@expr1073761772 true ;
7247: bool scopeDecl@var2928 ; scopeDecl@var2928 =@expr1073761773 false ;
7248: for (@expr1073761774 Token *@expr19951 tok@var2929 =@expr1073761776 tokBegin@var2923 ; tok@var2929 !=@expr1073761777 tokEnd@var2924 ; tok@var2929 =@expr1073761778 tok@var2929 .@expr19955 next (@expr19956 ) ) {
7249: if (@expr1073761781 Token ::@expr19958 Match (@expr1073761783 tok@var2929 , "{|;" ) ) {
7250: scopeDecl@var2928 =@expr1073761784 false ; }
7251: if (@expr19961 isCPP (@expr19962 ) ) {
7252: if (@expr1073761787 Token ::@expr19958 Match (@expr1073761789 tok@var2929 , "class|struct|namespace|union" ) ) {
7253: scopeDecl@var2928 =@expr1073761790 true ; }
7254: if (@expr1073761791 Token ::@expr19958 Match (@expr1073761793 tok@var2929 , "decltype|noexcept (" ) ) {
7255: tok@var2929 =@expr1073761794 tok@var2929 .@expr19955 next (@expr19956 ) .@expr19973 link (@expr19974 ) ;
7256:
7257: if (@expr1073761799 tok@var2929 &&@expr1073761800 Token ::@expr19977 simpleMatch (@expr1073761802 tok@var2929 .@expr19979 previous (@expr19980 ) , ") {" ) ) {
7258: tok@var2929 =@expr1073761805 tok@var2929 .@expr19982 link (@expr19983 ) ; }
7259: } else { if (@expr1073761808 Token ::@expr19977 simpleMatch (@expr19986 tok@var2929 , "= {" ) ||@expr1073761811
7260: (@expr1073761812 !@expr1073761813 scopeDecl@var2928 &&@expr1073761814 Token ::@expr19958 Match (@expr1073761816 tok@var2929 , "%name%|> {" ) &&@expr1073761817
7261: !@expr1073761818 Token ::@expr19958 Match (@expr1073761820 tok@var2929 , "else|try|do|const|constexpr|override|volatile|noexcept" ) ) ) {
7262: if (@expr1073761821 !@expr1073761822 tok@var2929 .@expr19955 next (@expr19956 ) .@expr19973 link (@expr19974 ) ) {
7263: syntaxError (@expr20003 tokBegin@var2923 ) ; }
7264:
7265: if (@expr1073761828 Token ::@expr19958 Match (@expr1073761830 tok@var2929 .@expr1073761831 tokAt (@expr1073761832 -2 ) , ") . %name%" ) ) {
7266:
7267: Token * lambdaStart@var2930 ; lambdaStart@var2930 =@expr1073761833 tok@var2929 .@expr1073761834 linkAt (@expr1073761835 -2 ) .@expr1073761836 previous (@expr1073761837 ) ;
7268: if (@expr1073761838 Token ::@expr19977 simpleMatch (@expr1073761840 lambdaStart@var2930 , "]" ) ) {
7269: lambdaStart@var2930 =@expr1073761841 lambdaStart@var2930 .@expr1073761842 link (@expr1073761843 ) ; }
7270: Token * lambdaEnd@var2931 ; lambdaEnd@var2931 =@expr1073761844 findLambdaEndScope (@expr1073761845 lambdaStart@var2930 ) ;
7271: if (@expr1073761846 lambdaEnd@var2931 ) {
7272: simplifyVarDecl (@expr1073761847 lambdaEnd@var2931 .@expr1073761848 link (@expr1073761849 ) .@expr1073761850 next (@expr1073761851 ) , lambdaEnd@var2931 , only_k_r_fpar@var2925 ) ; }
7273: } else {
7274: for (@expr1073761852 Token *@expr19951 tok2@var2932 =@expr1073761854 tok@var2929 .@expr19955 next (@expr19956 ) ; tok2@var2932 !=@expr1073761857 tok@var2929 .@expr19955 next (@expr19956 ) .@expr19973 link (@expr19974 ) ; tok2@var2932 =@expr1073761862 tok2@var2932 .@expr1073761863 next (@expr1073761864 ) ) {
7275: Token * lambdaEnd@var2933 ; lambdaEnd@var2933 =@expr1073761865 findLambdaEndScope (@expr1073761866 tok2@var2932 ) ;
7276: if (@expr1073761867 !@expr1073761868 lambdaEnd@var2933 ) {
7277: continue ; }
7278: simplifyVarDecl (@expr1073761869 lambdaEnd@var2933 .@expr1073761870 link (@expr1073761871 ) .@expr1073761872 next (@expr1073761873 ) , lambdaEnd@var2933 , only_k_r_fpar@var2925 ) ;
7279: }
7280: }
7281: tok@var2929 =@expr1073761874 tok@var2929 .@expr19955 next (@expr19956 ) .@expr19973 link (@expr19974 ) ;
7282: } }
7283:
7284: } else { if (@expr1073761879 Token ::@expr19977 simpleMatch (@expr19986 tok@var2929 , "= {" ) ) {
7285: tok@var2929 =@expr1073761882 tok@var2929 .@expr19955 next (@expr19956 ) .@expr19973 link (@expr19974 ) ;
7286: } }
7287: if (@expr20063 !@expr20064 tok@var2929 ) {
7288: syntaxError (@expr20003 tokBegin@var2923 ) ;
7289: }
7290: if (@expr1073761890 only_k_r_fpar@var2925 &&@expr1073761891 finishedwithkr@var2927 ) {
7291: if (@expr1073761892 Token ::@expr19958 Match (@expr1073761894 tok@var2929 , "(|[|{" ) ) {
7292: tok@var2929 =@expr1073761895 tok@var2929 .@expr19982 link (@expr19983 ) ;
7293: if (@expr1073761898 tok@var2929 .@expr19955 next (@expr19956 ) &&@expr1073761901 Token ::@expr19958 Match (@expr1073761903 tok@var2929 , ") !!{" ) ) {
7294: tok@var2929 =@expr1073761904 tok@var2929 .@expr19955 next (@expr19956 ) ; }
7295: else {
7296: continue ; }
7297: } else {
7298: continue ; }
7299: } else { if (@expr1073761907 tok@var2929 .@expr1073761908 str (@expr1073761909 ) ==@expr1073761910 "(" ) {
7300: if (@expr19961 isCPP (@expr19962 ) ) {
7301: for (@expr1073761913 Token *@expr19951 tok2@var2934 =@expr1073761915 tok@var2929 ; tok2@var2934 &&@expr1073761916 tok2@var2934 !=@expr1073761917 tok@var2929 .@expr19982 link (@expr19983 ) ; tok2@var2934 =@expr1073761920 tok2@var2934 .@expr1073761921 next (@expr1073761922 ) ) {
7302: if (@expr1073761923 Token ::@expr19958 Match (@expr1073761925 tok2@var2934 , "[(,] [" ) ) {
7303:
7304:
7305: Token * lambdaBody@var2935 ; lambdaBody@var2935 =@expr1073761926 tok2@var2934 ;
7306: while (@expr1073761927 lambdaBody@var2935 &&@expr20104 lambdaBody@var2935 !=@expr20105 tok2@var2934 .@expr20106 link (@expr20107 ) &&@expr1073761932 lambdaBody@var2935 .@expr1073761933 str (@expr1073761934 ) !=@expr1073761935 "{" ) {
7307: lambdaBody@var2935 =@expr1073761936 lambdaBody@var2935 .@expr1073761937 next (@expr1073761938 ) ; }
7308: if (@expr1073761939 lambdaBody@var2935 &&@expr20104 lambdaBody@var2935 !=@expr20105 tok2@var2934 .@expr20106 link (@expr20107 ) &&@expr1073761944 lambdaBody@var2935 .@expr20121 link (@expr20122 ) ) {
7309: simplifyVarDecl (@expr1073761947 lambdaBody@var2935 , lambdaBody@var2935 .@expr20121 link (@expr20122 ) .@expr1073761950 next (@expr1073761951 ) , only_k_r_fpar@var2925 ) ; }
7310: }
7311: }
7312: }
7313: tok@var2929 =@expr1073761952 tok@var2929 .@expr19982 link (@expr19983 ) ;
7314: } }
7315:
7316: if (@expr20063 !@expr20064 tok@var2929 ) {
7317: syntaxError (@expr1073761957 nullptr ) ; }
7318: if (@expr1073761958 tok@var2929 .@expr19979 previous (@expr19980 ) &&@expr1073761961 !@expr1073761962 Token ::@expr19958 Match (@expr1073761964 tok@var2929 .@expr19979 previous (@expr19980 ) , "{|}|;|)|public:|protected:|private:" ) ) {
7319: continue ; }
7320: if (@expr1073761967 Token ::@expr19977 simpleMatch (@expr1073761969 tok@var2929 , "template <" ) ) {
7321: continue ; }
7322:
7323: Token * type0@var2936 ; type0@var2936 =@expr1073761970 tok@var2929 ;
7324: if (@expr1073761971 !@expr1073761972 Token ::@expr19958 Match (@expr1073761974 type0@var2936 , "::|extern| %type%" ) ) {
7325: continue ; }
7326: if (@expr1073761975 Token ::@expr19958 Match (@expr1073761977 type0@var2936 , "else|return|public:|protected:|private:" ) ) {
7327: continue ; }
7328: if (@expr1073761978 isCPP11@var2926 &&@expr1073761979 type0@var2936 .@expr20156 str (@expr20157 ) ==@expr1073761982 "using" ) {
7329: continue ; }
7330: if (@expr1073761983 isCPP (@expr19962 ) &&@expr1073761985 type0@var2936 .@expr20156 str (@expr20157 ) ==@expr1073761988 "namespace" ) {
7331: continue ; }
7332:
7333: bool isconst@var2937 ; isconst@var2937 =@expr1073761989 false ;
7334: bool isstatic@var2938 ; isstatic@var2938 =@expr1073761990 false ;
7335: Token * tok2@var2939 ; tok2@var2939 =@expr1073761991 type0@var2936 ;
7336: int typelen@var2940 ; typelen@var2940 =@expr1073761992 1 ;
7337:
7338: if (@expr1073761993 Token ::@expr19958 Match (@expr1073761995 tok2@var2939 , "::|extern" ) ) {
7339: tok2@var2939 =@expr1073761996 tok2@var2939 .@expr20173 next (@expr20174 ) ;
7340: typelen@var2940 ++@expr1073761999 ;
7341: }
7342:
7343:
7344: while (@expr20176 tok2@var2939 ) {
7345: if (@expr1073762001 !@expr1073762002 Token ::@expr19958 Match (@expr1073762004 tok2@var2939 , "const|static|constexpr" ) &&@expr1073762005 Token ::@expr19958 Match (@expr1073762007 tok2@var2939 , "%type% const|static" ) ) {
7346: tok2@var2939 =@expr1073762008 tok2@var2939 .@expr20173 next (@expr20174 ) ;
7347: ++@expr1073762011 typelen@var2940 ;
7348: }
7349:
7350: if (@expr1073762012 Token ::@expr19958 Match (@expr1073762014 tok2@var2939 , "const|constexpr" ) ) {
7351: isconst@var2937 =@expr1073762015 true ; }
7352:
7353: else { if (@expr1073762016 Token ::@expr19958 Match (@expr1073762018 tok2@var2939 , "static|constexpr" ) ) {
7354: isstatic@var2938 =@expr1073762019 true ; }
7355:
7356: else { if (@expr1073762020 Token ::@expr19958 Match (@expr1073762022 tok2@var2939 , "%type% :: %type%" ) ) {
7357: tok2@var2939 =@expr1073762023 tok2@var2939 .@expr20173 next (@expr20174 ) ;
7358: ++@expr1073762026 typelen@var2940 ;
7359: }
7360:
7361: else {
7362: break ; } } }
7363:
7364: if (@expr1073762027 tok2@var2939 .@expr20204 strAt (@expr20205 1 ) ==@expr1073762030 "*" ) {
7365: break ; }
7366:
7367: if (@expr1073762031 Token ::@expr19958 Match (@expr1073762033 tok2@var2939 .@expr20173 next (@expr20174 ) , "& %name% ," ) ) {
7368: break ; }
7369:
7370: tok2@var2939 =@expr1073762036 tok2@var2939 .@expr20173 next (@expr20174 ) ;
7371: ++@expr1073762039 typelen@var2940 ;
7372: }
7373:
7374:
7375: if (@expr1073762040 Token ::@expr19958 Match (@expr1073762042 tok2@var2939 , "%type% *|&| %name% , %type% *|&| %name%" ) ) {
7376: continue ; }
7377:
7378: if (@expr1073762043 Token ::@expr19958 Match (@expr1073762045 tok2@var2939 , "struct|union|class %type%" ) ) {
7379: tok2@var2939 =@expr1073762046 tok2@var2939 .@expr20173 next (@expr20174 ) ;
7380: ++@expr1073762049 typelen@var2940 ;
7381: }
7382:
7383:
7384: if (@expr20226 Token ::@expr19958 Match (@expr20228 tok2@var2939 , ":: %type%" ) ) {
7385: ++@expr1073762053 typelen@var2940 ;
7386: tok2@var2939 =@expr1073762054 tok2@var2939 .@expr20173 next (@expr20174 ) ;
7387: }
7388:
7389:
7390: while (@expr1073762057 !@expr20234 isC (@expr20235 ) &&@expr1073762060 (@expr1073762061 Token ::@expr19958 Match (@expr1073762063 tok2@var2939 , "%type% <" ) ||@expr1073762064 Token ::@expr19958 Match (@expr1073762066 tok2@var2939 , "%type% ::" ) ) ) {
7391: if (@expr1073762067 tok2@var2939 .@expr20173 next (@expr20174 ) .@expr1073762070 str (@expr1073762071 ) ==@expr1073762072 "<" &&@expr1073762073 !@expr1073762074 TemplateSimplifier ::@expr20251 templateParameters (@expr1073762076 tok2@var2939 .@expr20173 next (@expr20174 ) ) ) {
7392: tok2@var2939 =@expr1073762079 nullptr ;
7393: break ;
7394: }
7395: typelen@var2940 +=@expr1073762080 2 ;
7396: tok2@var2939 =@expr1073762081 tok2@var2939 .@expr1073762082 tokAt (@expr1073762083 2 ) ;
7397: if (@expr1073762084 tok2@var2939 &&@expr1073762085 tok2@var2939 .@expr20262 previous (@expr20263 ) .@expr20264 str (@expr20265 ) ==@expr1073762090 "::" ) {
7398: continue ; }
7399: int indentlevel@var2941 ; indentlevel@var2941 =@expr1073762091 0 ;
7400: int parens@var2942 ; parens@var2942 =@expr1073762092 0 ;
7401:
7402: for (@expr1073762093 Token *@expr19951 tok3@var2943 =@expr1073762095 tok2@var2939 ; tok3@var2943 ; tok3@var2943 =@expr1073762096 tok3@var2943 .@expr20273 next (@expr20274 ) ) {
7403: ++@expr1073762099 typelen@var2940 ;
7404:
7405: if (@expr1073762100 !@expr20277 parens@var2942 &&@expr1073762102 tok3@var2943 .@expr20279 str (@expr20280 ) ==@expr1073762105 "<" ) {
7406: ++@expr1073762106 indentlevel@var2941 ;
7407: } else { if (@expr1073762107 !@expr20277 parens@var2942 &&@expr1073762109 tok3@var2943 .@expr20279 str (@expr20280 ) ==@expr1073762112 ">" ) {
7408: if (@expr1073762113 indentlevel@var2941 ==@expr1073762114 0 ) {
7409: tok2@var2939 =@expr1073762115 tok3@var2943 .@expr20273 next (@expr20274 ) ;
7410: break ;
7411: }
7412: --@expr1073762118 indentlevel@var2941 ;
7413: } else { if (@expr1073762119 !@expr20277 parens@var2942 &&@expr1073762121 tok3@var2943 .@expr20279 str (@expr20280 ) ==@expr1073762124 ">>" ) {
7414: if (@expr1073762125 indentlevel@var2941 <=@expr1073762126 1 ) {
7415: tok2@var2939 =@expr1073762127 tok3@var2943 .@expr20273 next (@expr20274 ) ;
7416: break ;
7417: }
7418: indentlevel@var2941 -=@expr1073762130 2 ;
7419: } else { if (@expr1073762131 tok3@var2943 .@expr20279 str (@expr20280 ) ==@expr1073762134 "(" ) {
7420: ++@expr1073762135 parens@var2942 ;
7421: } else { if (@expr1073762136 tok3@var2943 .@expr20279 str (@expr20280 ) ==@expr1073762139 ")" ) {
7422: if (@expr1073762140 !@expr20277 parens@var2942 ) {
7423: tok2@var2939 =@expr1073762142 nullptr ;
7424: break ;
7425: }
7426: --@expr1073762143 parens@var2942 ;
7427: } else { if (@expr1073762144 tok3@var2943 .@expr20279 str (@expr20280 ) ==@expr1073762147 ";" ) {
7428: break ;
7429: } } } } } }
7430: }
7431:
7432: if (@expr20226 Token ::@expr19958 Match (@expr20228 tok2@var2939 , ":: %type%" ) ) {
7433: ++@expr1073762151 typelen@var2940 ;
7434: tok2@var2939 =@expr1073762152 tok2@var2939 .@expr20173 next (@expr20174 ) ;
7435: }
7436:
7437:
7438: if (@expr1073762155 Token ::@expr19977 simpleMatch (@expr1073762157 tok2@var2939 , "const" ) ) {
7439: isconst@var2937 =@expr1073762158 true ; }
7440: }
7441:
7442:
7443: if (@expr1073762159 Token ::@expr19958 Match (@expr1073762161 tok2@var2939 , "%type%" ) ||@expr1073762162
7444: (@expr1073762163 tok2@var2939 &&@expr1073762164 tok2@var2939 .@expr20262 previous (@expr20263 ) &&@expr1073762167 tok2@var2939 .@expr20262 previous (@expr20263 ) .@expr20264 str (@expr20265 ) ==@expr1073762172 ">" ) ) {
7445: Token * varName@var2944 ; varName@var2944 =@expr1073762173 tok2@var2939 ;
7446: if (@expr1073762174 !@expr1073762175 tok2@var2939 .@expr20262 previous (@expr20263 ) ||@expr1073762178 tok2@var2939 .@expr20262 previous (@expr20263 ) .@expr20264 str (@expr20265 ) !=@expr1073762183 ">" ) {
7447: varName@var2944 =@expr1073762184 varName@var2944 .@expr20361 next (@expr20362 ) ; }
7448: else {
7449: --@expr1073762187 typelen@var2940 ; }
7450:
7451: bool isPointerOrRef@var2945 ; isPointerOrRef@var2945 =@expr1073762188 false ;
7452: while (@expr1073762189 Token ::@expr19977 simpleMatch (@expr1073762191 varName@var2944 , "*" ) ||@expr1073762192 Token ::@expr19958 Match (@expr1073762194 varName@var2944 , "& %name% ," ) ) {
7453: isPointerOrRef@var2945 =@expr1073762195 true ;
7454: varName@var2944 =@expr1073762196 varName@var2944 .@expr20361 next (@expr20362 ) ;
7455: }
7456:
7457: while (@expr1073762199 Token ::@expr19958 Match (@expr1073762201 varName@var2944 , "%type% %type%" ) ) {
7458: if (@expr1073762202 varName@var2944 .@expr20379 str (@expr20380 ) !=@expr1073762205 "const" &&@expr1073762206 varName@var2944 .@expr20379 str (@expr20380 ) !=@expr1073762209 "volatile" ) {
7459: ++@expr1073762210 typelen@var2940 ;
7460: }
7461: varName@var2944 =@expr1073762211 varName@var2944 .@expr20361 next (@expr20362 ) ;
7462: }
7463:
7464: if (@expr1073762214 Token ::@expr19977 simpleMatch (@expr1073762216 varName@var2944 , "( *" ) &&@expr1073762217 Token ::@expr19958 Match (@expr1073762219 varName@var2944 .@expr20396 link (@expr20397 ) .@expr20398 previous (@expr20399 ) , "%name% ) ( ) =" ) ) {
7465: Token * endDecl@var2946 ; endDecl@var2946 =@expr1073762224 varName@var2944 .@expr20396 link (@expr20397 ) .@expr1073762227 tokAt (@expr1073762228 2 ) ;
7466: varName@var2944 =@expr1073762229 varName@var2944 .@expr20396 link (@expr20397 ) .@expr20398 previous (@expr20399 ) ;
7467: endDecl@var2946 .@expr20410 insertToken (@expr1073762235 ";" ) ;
7468: endDecl@var2946 =@expr1073762236 endDecl@var2946 .@expr20413 next (@expr20414 ) ;
7469: endDecl@var2946 .@expr20413 next (@expr20414 ) .@expr1073762241 isSplittedVarDeclEq (@expr1073762242 true ) ;
7470: endDecl@var2946 .@expr20410 insertToken (@expr1073762244 varName@var2944 .@expr20379 str (@expr20380 ) ) ;
7471: continue ;
7472: }
7473:
7474: else { if (@expr1073762247 Token ::@expr19958 Match (@expr1073762249 varName@var2944 , "%name% ,|=" ) ) {
7475: if (@expr1073762250 varName@var2944 .@expr20379 str (@expr20380 ) !=@expr1073762253 "operator" ) {
7476: tok2@var2939 =@expr1073762254 varName@var2944 .@expr20361 next (@expr20362 ) ;
7477:
7478: if (@expr1073762257 tok2@var2939 .@expr20434 str (@expr20435 ) ==@expr20436 "=" &&@expr1073762261 (@expr1073762262 isstatic@var2938 ||@expr1073762263 (@expr1073762264 isconst@var2937 &&@expr1073762265 !@expr1073762266 isPointerOrRef@var2945 ) ) ) {
7479:
7480: while (@expr20443 tok2@var2939 &&@expr20444 tok2@var2939 .@expr20434 str (@expr20435 ) !=@expr20447 "," &&@expr20448 tok2@var2939 .@expr20434 str (@expr20435 ) !=@expr20451 ";" ) {
7481: if (@expr20452 Token ::@expr19958 Match (@expr20454 tok2@var2939 , "{|(|[" ) ) {
7482: tok2@var2939 =@expr1073762279 tok2@var2939 .@expr20456 link (@expr20457 ) ; }
7483: const Token * tok3@var2947 ; tok3@var2947 =@expr1073762282 tok2@var2939 ;
7484: if (@expr1073762283 !@expr20234 isC (@expr20235 ) &&@expr20462 tok2@var2939 .@expr20434 str (@expr20435 ) ==@expr20465 "<" &&@expr1073762290 TemplateSimplifier ::@expr20251 templateParameters (@expr1073762292 tok2@var2939 ) >@expr1073762293 0 ) {
7485: tok2@var2939 =@expr1073762294 tok2@var2939 .@expr20471 findClosingBracket (@expr20472 ) ;
7486: }
7487: if (@expr20473 !@expr20474 tok2@var2939 ) {
7488: syntaxError (@expr1073762299 tok3@var2947 ) ; }
7489: tok2@var2939 =@expr1073762300 tok2@var2939 .@expr20173 next (@expr20174 ) ;
7490: }
7491: if (@expr20479 tok2@var2939 &&@expr20480 tok2@var2939 .@expr20434 str (@expr20435 ) ==@expr20483 ";" ) {
7492: tok2@var2939 =@expr1073762308 nullptr ; }
7493: }
7494: } else {
7495: tok2@var2939 =@expr1073762309 nullptr ; }
7496: }
7497:
7498:
7499: else { if (@expr1073762310 Token ::@expr19958 Match (@expr1073762312 varName@var2944 , "%name% [" ) ) {
7500: tok2@var2939 =@expr1073762313 varName@var2944 .@expr20361 next (@expr20362 ) ;
7501:
7502: while (@expr1073762316 Token ::@expr19958 Match (@expr1073762318 tok2@var2939 .@expr20456 link (@expr20457 ) , "] ,|=|[" ) ) {
7503: tok2@var2939 =@expr1073762321 tok2@var2939 .@expr20456 link (@expr20457 ) .@expr1073762324 next (@expr1073762325 ) ; }
7504: if (@expr1073762326 !@expr1073762327 Token ::@expr19958 Match (@expr1073762329 tok2@var2939 , "=|," ) ) {
7505: tok2@var2939 =@expr1073762330 nullptr ; }
7506: if (@expr1073762331 tok2@var2939 &&@expr1073762332 tok2@var2939 .@expr20434 str (@expr20435 ) ==@expr20436 "=" ) {
7507: while (@expr20443 tok2@var2939 &&@expr20444 tok2@var2939 .@expr20434 str (@expr20435 ) !=@expr20447 "," &&@expr20448 tok2@var2939 .@expr20434 str (@expr20435 ) !=@expr20451 ";" ) {
7508: if (@expr20452 Token ::@expr19958 Match (@expr20454 tok2@var2939 , "{|(|[" ) ) {
7509: tok2@var2939 =@expr1073762348 tok2@var2939 .@expr20456 link (@expr20457 ) ; }
7510: tok2@var2939 =@expr1073762351 tok2@var2939 .@expr20173 next (@expr20174 ) ;
7511: }
7512: if (@expr20479 tok2@var2939 &&@expr20480 tok2@var2939 .@expr20434 str (@expr20435 ) ==@expr20483 ";" ) {
7513: tok2@var2939 =@expr1073762359 nullptr ; }
7514: }
7515: }
7516:
7517:
7518: else { if (@expr1073762360 Token ::@expr19958 Match (@expr1073762362 varName@var2944 , "%name% {" ) ) {
7519: tok2@var2939 =@expr1073762363 varName@var2944 .@expr20361 next (@expr20362 ) ;
7520: tok2@var2939 =@expr1073762366 tok2@var2939 .@expr20456 link (@expr20457 ) ;
7521: if (@expr20545 tok2@var2939 ) {
7522: tok2@var2939 =@expr1073762370 tok2@var2939 .@expr20173 next (@expr20174 ) ; }
7523: if (@expr1073762373 tok2@var2939 &&@expr20444 tok2@var2939 .@expr20434 str (@expr20435 ) !=@expr20447 "," ) {
7524: tok2@var2939 =@expr1073762378 nullptr ; }
7525: }
7526:
|
7529:
7530: else { if (@expr1073762379 Token ::@expr19958 Match (@expr1073762381 varName@var2944 , "%name% (" ) &&@expr1073762382 Token ::@expr19977 simpleMatch (@expr1073762384 varName@var2944 .@expr20561 linkAt (@expr20562 1 ) , ") ," ) ) {
7531: tok2@var2939 =@expr1073762387 varName@var2944 .@expr20561 linkAt (@expr20562 1 ) .@expr1073762390 next (@expr1073762391 ) ;
7532: }
7533:
7534: else {
7535: tok2@var2939 =@expr1073762392 nullptr ; } } } } }
7536: } else {
7537: tok2@var2939 =@expr1073762393 nullptr ;
7538: }
7539:
7540: if (@expr20473 !@expr20474 tok2@var2939 ) {
7541: if (@expr1073762396 only_k_r_fpar@var2925 ) {
7542: finishedwithkr@var2927 =@expr1073762397 false ; }
7543: continue ;
7544: }
7545:
7546: if (@expr20574 tok2@var2939 .@expr20434 str (@expr20435 ) ==@expr20577 "," ) {
7547: tok2@var2939 .@expr20434 str (@expr20579 ";" ) ;
7548: tok2@var2939 .@expr20580 isSplittedVarDeclComma (@expr20581 true ) ;
7549:
7550: TokenList ::@expr20582 insertTokens (@expr20583 tok2@var2939 , type0@var2936 , typelen@var2940 ) ;
7551: }
7552:
7553: else {
7554: Token * eq@var2948 ; eq@var2948 =@expr1073762408 tok2@var2939 ;
7555:
7556: while (@expr20176 tok2@var2939 ) {
7557: if (@expr20452 Token ::@expr19958 Match (@expr20454 tok2@var2939 , "{|(|[" ) ) {
7558: tok2@var2939 =@expr1073762413 tok2@var2939 .@expr20456 link (@expr20457 ) ; }
7559:
7560: else { if (@expr1073762416 !@expr20234 isC (@expr20235 ) &&@expr20462 tok2@var2939 .@expr20434 str (@expr20435 ) ==@expr20465 "<" &&@expr1073762423 tok2@var2939 .@expr20262 previous (@expr20263 ) .@expr1073762426 isName (@expr1073762427 ) &&@expr1073762428 !@expr1073762429 tok2@var2939 .@expr20262 previous (@expr20263 ) .@expr1073762432 varId (@expr1073762433 ) ) {
7561: tok2@var2939 =@expr1073762434 tok2@var2939 .@expr20471 findClosingBracket (@expr20472 ) ; }
7562:
7563: else { if (@expr1073762437 std ::@expr1073762438 strchr (@expr1073762439 ";," , tok2@var2939 .@expr20434 str (@expr20435 ) [@expr1073762442 0 ] ) ) {
7564:
7565: const Token * varTok@var2949 ; varTok@var2949 =@expr1073762443 type0@var2936 .@expr1073762444 tokAt (@expr1073762445 typelen@var2940 ) ;
7566: while (@expr1073762446 Token ::@expr19958 Match (@expr1073762448 varTok@var2949 , "%name%|*|& %name%|*|&" ) ) {
7567: varTok@var2949 =@expr1073762449 varTok@var2949 .@expr1073762450 next (@expr1073762451 ) ; }
7568: if (@expr1073762452 !@expr1073762453 varTok@var2949 ) {
7569: syntaxError (@expr1073762454 tok2@var2939 ) ; }
7570: TokenList ::@expr20582 insertTokens (@expr1073762456 eq@var2948 , varTok@var2949 , 2 ) ;
7571: eq@var2948 .@expr1073762457 str (@expr1073762458 ";" ) ;
7572: eq@var2948 .@expr1073762459 isSplittedVarDeclEq (@expr1073762460 true ) ;
7573:
7574:
7575: if (@expr20574 tok2@var2939 .@expr20434 str (@expr20435 ) ==@expr20577 "," ) {
7576: tok2@var2939 .@expr20434 str (@expr20579 ";" ) ;
7577: tok2@var2939 .@expr20580 isSplittedVarDeclComma (@expr20581 true ) ;
7578: TokenList ::@expr20582 insertTokens (@expr20583 tok2@var2939 , type0@var2936 , typelen@var2940 ) ;
7579: }
7580: break ;
7581: } } }
7582: if (@expr20545 tok2@var2939 ) {
7583: tok2@var2939 =@expr1073762472 tok2@var2939 .@expr20173 next (@expr20174 ) ; }
7584: }
7585: }
7586: finishedwithkr@var2927 =@expr1073762475 only_k_r_fpar@var2925 &&@expr1073762476 tok2@var2939 &&@expr1073762477 tok2@var2939 .@expr20204 strAt (@expr20205 1 ) ==@expr1073762480 "{" ;
7587: }
7588: }
7589:
7590: void Tokenizer :: simplifyStaticConst ( )
7591: {
7592:
7593:
7594: const std ::@expr1073762481 string qualifiers@var2950 [@expr1073762482 3 ] =@expr1073762483 {@expr1073762484 "extern" , "static" , "const" } ;
7595:
7596:
7597:
7598: for (@expr1073762485 Token *@expr1073762486 tok@var2951 =@expr1073762487 list@var872 .@expr20664 front (@expr20665 ) ; tok@var2951 ; tok@var2951 =@expr1073762490 tok@var2951 .@expr20667 next (@expr20668 ) ) {
7599: bool continue2@var2952 ; continue2@var2952 =@expr1073762493 false ;
7600: for (@expr1073762494 int i@var2953 =@expr1073762495 0 ; i@var2953 <@expr1073762496 sizeof (@expr1073762497 qualifiers@var2950 ) /@expr1073762498 sizeof (@expr1073762499 qualifiers@var2950 [@expr1073762500 0 ] ) ; i@var2953 ++@expr1073762501 ) {
7601:
7602:
7603: if (@expr1073762502 !@expr1073762503 tok@var2951 .@expr20667 next (@expr20668 ) ||@expr1073762506 tok@var2951 .@expr20667 next (@expr20668 ) .@expr1073762509 str (@expr1073762510 ) !=@expr1073762511 qualifiers@var2950 [@expr20688 i@var2953 ] ) {
7604: continue ; }
7605:
7606:
7607: Token * leftTok@var2954 ; leftTok@var2954 =@expr1073762513 tok@var2951 ;
7608: bool behindOther@var2955 ; behindOther@var2955 =@expr1073762514 false ;
7609: for (@expr1073762515 ; leftTok@var2954 ; leftTok@var2954 =@expr1073762516 leftTok@var2954 .@expr1073762517 previous (@expr1073762518 ) ) {
7610: for (@expr1073762519 int j@var2956 =@expr1073762520 0 ; j@var2956 <=@expr1073762521 i@var2953 ; j@var2956 ++@expr1073762522 ) {
7611: if (@expr1073762523 leftTok@var2954 .@expr1073762524 str (@expr1073762525 ) ==@expr1073762526 qualifiers@var2950 [@expr1073762527 j@var2956 ] ) {
7612: behindOther@var2955 =@expr1073762528 true ;
7613: break ;
7614: }
7615: }
7616: if (@expr1073762529 behindOther@var2955 ) {
7617: break ; }
7618: if (@expr1073762530 isCPP (@expr20707 ) &&@expr1073762532 Token ::@expr1073762533 simpleMatch (@expr1073762534 leftTok@var2954 , ">" ) ) {
7619: Token * opening@var2957 ; opening@var2957 =@expr1073762535 leftTok@var2954 .@expr1073762536 findOpeningBracket (@expr1073762537 ) ;
7620: if (@expr1073762538 opening@var2957 ) {
7621: leftTok@var2954 =@expr1073762539 opening@var2957 ;
7622: continue ;
7623: }
7624: }
7625: if (@expr1073762540 !@expr1073762541 Token ::@expr20718 Match (@expr1073762543 leftTok@var2954 , "%type%|struct|::" ) ||@expr1073762544
7626: (@expr1073762545 isCPP (@expr20707 ) &&@expr1073762547 Token ::@expr20718 Match (@expr1073762549 leftTok@var2954 , "private:|protected:|public:|operator|template" ) ) ) {
7627: break ;
7628: }
7629: }
7630:
7631:
7632: if (@expr1073762550 leftTok@var2954 ==@expr1073762551 tok@var2951 ) {
7633: continue ; }
7634:
7635: if (@expr1073762552 leftTok@var2954 &&@expr1073762553 !@expr1073762554 behindOther@var2955 &&@expr1073762555 !@expr1073762556 Token ::@expr20718 Match (@expr1073762558 leftTok@var2954 , ";|{|}|(|,|private:|protected:|public:" ) ) {
7636: continue2@var2952 =@expr1073762559 true ;
7637: break ;
7638: }
7639:
7640:
7641: tok@var2951 .@expr1073762560 deleteNext (@expr1073762561 ) ;
7642: if (@expr1073762562 !@expr1073762563 leftTok@var2954 ) {
7643: list@var872 .@expr20664 front (@expr20665 ) .@expr1073762566 insertToken (@expr1073762567 qualifiers@var2950 [@expr20688 i@var2953 ] , emptyString@var1 , false ) ;
7644: list@var872 .@expr20664 front (@expr20665 ) .@expr1073762571 swapWithNext (@expr1073762572 ) ;
7645: tok@var2951 =@expr1073762573 list@var872 .@expr20664 front (@expr20665 ) ;
7646: } else { if (@expr1073762576 leftTok@var2954 .@expr20753 next (@expr20754 ) ) {
7647: leftTok@var2954 .@expr20753 next (@expr20754 ) .@expr1073762581 insertToken (@expr1073762582 qualifiers@var2950 [@expr20688 i@var2953 ] , emptyString@var1 , true ) ;
7648: tok@var2951 =@expr1073762584 leftTok@var2954 .@expr20753 next (@expr20754 ) ;
7649: } else {
7650: leftTok@var2954 .@expr1073762587 insertToken (@expr1073762588 qualifiers@var2950 [@expr20688 i@var2953 ] ) ;
7651: tok@var2951 =@expr1073762590 leftTok@var2954 ;
7652: } }
7653: }
7654: if (@expr1073762591 continue2@var2952 ) {
7655: continue ; }
7656: }
7657: }
7658:
7659: void Tokenizer :: simplifyIfAndWhileAssign ( )
7660: {
7661: for (@expr1073762592 Token *@expr20769 tok@var2958 =@expr1073762594 list@var872 .@expr1073762595 front (@expr1073762596 ) ; tok@var2958 ; tok@var2958 =@expr1073762597 tok@var2958 .@expr20774 next (@expr20775 ) ) {
7662: if (@expr1073762600 !@expr1073762601 Token ::@expr20778 Match (@expr1073762603 tok@var2958 .@expr20774 next (@expr20775 ) , "if|while (" ) ) {
7663: continue ; }
7664:
7665: const Token * tokAt3@var2959 ; tokAt3@var2959 =@expr1073762606 tok@var2958 .@expr20783 tokAt (@expr20784 3 ) ;
7666: if (@expr1073762609 !@expr1073762610 Token ::@expr20778 Match (@expr1073762612 tokAt3@var2959 , "!| (| %name% =" ) &&@expr1073762613
7667: !@expr1073762614 Token ::@expr20778 Match (@expr1073762616 tokAt3@var2959 , "!| (| %name% . %name% =" ) &&@expr1073762617
7668: !@expr1073762618 Token ::@expr20778 Match (@expr1073762620 tokAt3@var2959 , "0 == (| %name% =" ) &&@expr1073762621
7669: !@expr1073762622 Token ::@expr20778 Match (@expr1073762624 tokAt3@var2959 , "0 == (| %name% . %name% =" ) ) {
7670: continue ; }
7671:
7672:
7673: const bool iswhile@var2960 (@expr1073762625 tok@var2958 .@expr20774 next (@expr20775 ) .@expr20804 str (@expr20805 ) ==@expr1073762630 "while" ) ;
7674:
7675:
7676: const bool isDoWhile@var2961 =@expr1073762631 iswhile@var2960 &&@expr1073762632 Token ::@expr20809 simpleMatch (@expr1073762634 tok@var2958 , "}" ) &&@expr1073762635 Token ::@expr20809 simpleMatch (@expr1073762637 tok@var2958 .@expr20814 link (@expr20815 ) .@expr1073762640 previous (@expr1073762641 ) , "do" ) ;
7677: Token * openBraceTok@var2962 ; openBraceTok@var2962 =@expr1073762642 tok@var2958 .@expr20814 link (@expr20815 ) ;
7678:
7679:
7680: tok@var2958 .@expr20821 deleteNext (@expr20822 ) ;
7681:
7682:
7683: const bool isNot@var2963 (@expr1073762647 Token ::@expr20778 Match (@expr1073762649 tok@var2958 .@expr20783 tokAt (@expr1073762651 2 ) , "!|0" ) ) ;
7684: if (@expr20828 isNot@var2963 ) {
7685: tok@var2958 .@expr20774 next (@expr20775 ) .@expr1073762655 deleteNext (@expr1073762656 (@expr1073762657 tok@var2958 .@expr20834 strAt (@expr20835 2 ) ==@expr1073762660 "0" ) ?@expr1073762661 2 :@expr1073762662 1 ) ; }
7686:
7687:
7688:
7689: std ::@expr1073762663 stack < Token *@expr20769 > braces@var2964 ;
7690: while (@expr1073762665 tok@var2958 .@expr20774 next (@expr20775 ) .@expr20804 str (@expr20805 ) ==@expr1073762670 "(" ) {
7691: braces@var2964 .@expr1073762671 push (@expr1073762672 tok@var2958 .@expr20774 next (@expr20775 ) .@expr1073762675 link (@expr1073762676 ) ) ;
7692: tok@var2958 .@expr20821 deleteNext (@expr20822 ) ;
7693: }
7694:
7695:
7696: Token * tok2@var2965 ;
7697: for (@expr1073762679 tok2@var2965 =@expr1073762680 tok@var2958 .@expr20774 next (@expr20775 ) ; tok2@var2965 ; tok2@var2965 =@expr1073762683 tok2@var2965 .@expr20860 next (@expr20861 ) ) {
7698: if (@expr1073762686 tok2@var2965 .@expr20863 str (@expr20864 ) ==@expr1073762689 "(" ) {
7699: tok2@var2965 =@expr1073762690 tok2@var2965 .@expr20867 link (@expr20868 ) ; }
7700: else { if (@expr1073762693 tok2@var2965 .@expr20863 str (@expr20864 ) ==@expr1073762696 ")" ) {
7701: break ; } }
7702: }
7703:
7704:
7705: tok2@var2965 =@expr1073762697 tok2@var2965 .@expr20874 previous (@expr20875 ) ;
7706: if (@expr1073762700 tok@var2958 .@expr20834 strAt (@expr20835 2 ) ==@expr1073762703 "." ) {
7707: tok2@var2965 .@expr20880 insertToken (@expr1073762705 tok@var2958 .@expr20834 strAt (@expr1073762707 3 ) ) ;
7708: tok2@var2965 .@expr20860 next (@expr20861 ) .@expr20886 varId (@expr1073762711 tok@var2958 .@expr20783 tokAt (@expr20784 3 ) .@expr1073762714 varId (@expr1073762715 ) ) ;
7709: tok2@var2965 .@expr20880 insertToken (@expr1073762717 "." ) ;
7710: }
7711: tok2@var2965 .@expr20880 insertToken (@expr1073762719 tok@var2958 .@expr20774 next (@expr20775 ) .@expr20804 str (@expr20805 ) ) ;
7712: tok2@var2965 .@expr20860 next (@expr20861 ) .@expr20886 varId (@expr1073762727 tok@var2958 .@expr20774 next (@expr20775 ) .@expr1073762730 varId (@expr1073762731 ) ) ;
7713:
7714: while (@expr1073762732 !@expr1073762733 braces@var2964 .@expr1073762734 empty (@expr1073762735 ) ) {
7715: tok2@var2965 .@expr20880 insertToken (@expr1073762737 "(" ) ;
7716: Token ::@expr20914 createMutualLinks (@expr1073762739 tok2@var2965 .@expr20860 next (@expr20861 ) , braces@var2964 .@expr1073762742 top (@expr1073762743 ) ) ;
7717: braces@var2964 .@expr1073762744 pop (@expr1073762745 ) ;
7718: }
7719:
7720: if (@expr20828 isNot@var2963 ) {
7721: tok2@var2965 .@expr20860 next (@expr20861 ) .@expr1073762749 insertToken (@expr1073762750 "!" ) ; }
7722: tok2@var2965 .@expr20880 insertToken (@expr1073762752 iswhile@var2960 ?@expr1073762753 "while" :@expr1073762754 "if" ) ;
7723: if (@expr20931 isDoWhile@var2961 ) {
7724: tok2@var2965 .@expr20880 insertToken (@expr1073762757 "}" ) ;
7725: Token ::@expr20914 createMutualLinks (@expr1073762759 openBraceTok@var2962 , tok2@var2965 .@expr20860 next (@expr20861 ) ) ;
7726: }
7727:
7728: tok2@var2965 .@expr20880 insertToken (@expr1073762763 ";" ) ;
7729:
7730:
7731: if (@expr20931 isDoWhile@var2961 ) {
7732: tok@var2958 .@expr1073762765 deleteThis (@expr1073762766 ) ; }
7733:
7734:
7735: if (@expr1073762767 iswhile@var2960 &&@expr1073762768 !@expr1073762769 isDoWhile@var2961 ) {
7736: int indentlevel@var2966 ; indentlevel@var2966 =@expr1073762770 0 ;
7737: Token * tok3@var2967 ; tok3@var2967 =@expr1073762771 tok2@var2965 ;
7738:
7739: for (@expr1073762772 ; tok3@var2967 ; tok3@var2967 =@expr1073762773 tok3@var2967 .@expr20950 next (@expr20951 ) ) {
7740: if (@expr1073762776 tok3@var2967 .@expr20953 str (@expr20954 ) ==@expr1073762779 "{" ) {
7741: ++@expr1073762780 indentlevel@var2966 ; }
7742: else { if (@expr1073762781 tok3@var2967 .@expr20953 str (@expr20954 ) ==@expr1073762784 "}" ) {
7743: if (@expr1073762785 indentlevel@var2966 <=@expr1073762786 1 ) {
7744: break ; }
7745: --@expr1073762787 indentlevel@var2966 ;
7746: } }
7747: }
7748:
7749: if (@expr1073762788 tok3@var2967 &&@expr1073762789 indentlevel@var2966 ==@expr1073762790 1 ) {
7750: tok3@var2967 =@expr1073762791 tok3@var2967 .@expr1073762792 previous (@expr1073762793 ) ;
7751: std ::@expr1073762794 stack < Token *@expr20769 > braces2@var2968 ;
7752:
7753: for (@expr1073762796 tok2@var2965 =@expr1073762797 tok2@var2965 .@expr20860 next (@expr20861 ) ; tok2@var2965 &&@expr1073762800 tok2@var2965 !=@expr1073762801 tok@var2958 ; tok2@var2965 =@expr1073762802 tok2@var2965 .@expr20874 previous (@expr20875 ) ) {
7754: tok3@var2967 .@expr1073762805 insertToken (@expr1073762806 tok2@var2965 .@expr20863 str (@expr20864 ) ) ;
7755: Token * newTok@var2969 ; newTok@var2969 =@expr1073762809 tok3@var2967 .@expr20950 next (@expr20951 ) ;
7756:
7757: newTok@var2969 .@expr1073762812 varId (@expr1073762813 tok2@var2965 .@expr1073762814 varId (@expr1073762815 ) ) ;
7758: newTok@var2969 .@expr1073762816 fileIndex (@expr1073762817 tok2@var2965 .@expr1073762818 fileIndex (@expr1073762819 ) ) ;
7759: newTok@var2969 .@expr1073762820 linenr (@expr1073762821 tok2@var2965 .@expr1073762822 linenr (@expr1073762823 ) ) ;
7760:
7761:
7762: if (@expr1073762824 tok2@var2965 .@expr20867 link (@expr20868 ) ) {
7763: if (@expr1073762827 Token ::@expr20778 Match (@expr1073762829 newTok@var2969 , "}|)|]|>" ) ) {
7764: braces2@var2968 .@expr1073762830 push (@expr1073762831 newTok@var2969 ) ;
7765: } else {
7766: Token ::@expr20914 createMutualLinks (@expr1073762833 newTok@var2969 , braces2@var2968 .@expr1073762834 top (@expr1073762835 ) ) ;
7767: braces2@var2968 .@expr1073762836 pop (@expr1073762837 ) ;
7768: }
7769: }
7770: }
7771: }
7772: }
7773: }
7774: }
7775:
7776: void Tokenizer :: simplifyVariableMultipleAssign ( )
7777: {
7778: for (@expr1073762838 Token *@expr1073762839 tok@var2970 =@expr1073762840 list@var872 .@expr1073762841 front (@expr1073762842 ) ; tok@var2970 ; tok@var2970 =@expr1073762843 tok@var2970 .@expr1073762844 next (@expr1073762845 ) ) {
7779: if (@expr1073762846 Token ::@expr21023 Match (@expr1073762848 tok@var2970 , "%name% = %name% = %num%|%name% ;" ) ) {
7780:
7781: Token * tok2@var2971 ; tok2@var2971 =@expr1073762849 tok@var2970 .@expr1073762850 previous (@expr1073762851 ) ;
7782: while (@expr1073762852 tok2@var2971 &&@expr1073762853
7783: tok2@var2971 .@expr21030 str (@expr21031 ) ==@expr1073762856 "=" &&@expr1073762857
7784: Token ::@expr21023 Match (@expr1073762859 tok2@var2971 .@expr1073762860 previous (@expr1073762861 ) , "%name%" ) ) {
7785: tok2@var2971 =@expr1073762862 tok2@var2971 .@expr21039 tokAt (@expr1073762864 -2 ) ;
7786: }
7787:
7788: if (@expr1073762865 !@expr1073762866 tok2@var2971 ||@expr1073762867 tok2@var2971 .@expr21030 str (@expr21031 ) !=@expr1073762870 ";" ) {
7789: continue ;
7790: }
7791:
7792: Token * stopAt@var2972 ; stopAt@var2972 =@expr1073762871 tok@var2970 .@expr1073762872 tokAt (@expr1073762873 2 ) ;
7793: const Token * valueTok@var2973 ; valueTok@var2973 =@expr1073762874 stopAt@var2972 .@expr1073762875 tokAt (@expr1073762876 2 ) ;
7794: const std ::@expr1073762877 string & value@var2974 (@expr1073762878 valueTok@var2973 .@expr1073762879 str (@expr1073762880 ) ) ;
7795: tok2@var2971 =@expr1073762881 tok2@var2971 .@expr21058 next (@expr21059 ) ;
7796:
7797: while (@expr1073762884 tok2@var2971 !=@expr1073762885 stopAt@var2972 ) {
7798: tok2@var2971 .@expr21058 next (@expr21059 ) .@expr21064 insertToken (@expr1073762889 ";" ) ;
7799: tok2@var2971 .@expr21058 next (@expr21059 ) .@expr21064 insertToken (@expr1073762893 value@var2974 ) ;
7800: tok2@var2971 =@expr1073762894 tok2@var2971 .@expr21039 tokAt (@expr1073762896 4 ) ;
7801: }
7802: }
7803: }
7804: }
7805:
7806:
7807: static const std :: unordered_map < std :: string , std :: string > cAlternativeTokens@var2975 = {
7808: std :: make_pair ( "and" , "&&" )
7809: , std :: make_pair ( "and_eq" , "&=" )
7810: , std :: make_pair ( "bitand" , "&" )
7811: , std :: make_pair ( "bitor" , "|" )
7812: , std :: make_pair ( "not_eq" , "!=" )
7813: , std :: make_pair ( "or" , "||" )
7814: , std :: make_pair ( "or_eq" , "|=" )
7815: , std :: make_pair ( "xor" , "^" )
7816: , std :: make_pair ( "xor_eq" , "^=" )
7817: } ;
7818:
|
7830:
7831: bool Tokenizer :: simplifyCAlternativeTokens ( )
7832: {
7833:
7834: int executableScopeLevel@var2976 ; executableScopeLevel@var2976 =@expr1073762897 0 ;
7835:
7836: std ::@expr1073762898 vector < Token *@expr21075 > alt@var2977 ;
7837: bool replaceAll@var2978 ; replaceAll@var2978 =@expr1073762900 false ;
7838:
7839: for (@expr1073762901 Token *@expr21075 tok@var2979 =@expr1073762903 list@var872 .@expr1073762904 front (@expr1073762905 ) ; tok@var2979 ; tok@var2979 =@expr1073762906 tok@var2979 .@expr21083 next (@expr21084 ) ) {
7840: if (@expr1073762909 tok@var2979 .@expr21086 str (@expr21087 ) ==@expr1073762912 ")" ) {
7841: if (@expr1073762913 const Token *@expr21075 end@var2980 =@expr1073762915 isFunctionHead (@expr1073762916 tok@var2979 , "{" ) ) {
7842: ++@expr1073762917 executableScopeLevel@var2976 ;
7843: tok@var2979 =@expr1073762918 const_cast < Token *@expr21075 > (@expr1073762920 end@var2980 ) ;
7844: continue ;
7845: }
7846: }
7847:
7848: if (@expr1073762921 tok@var2979 .@expr21086 str (@expr21087 ) ==@expr1073762924 "{" ) {
7849: if (@expr21101 executableScopeLevel@var2976 >@expr21102 0 ) {
7850: ++@expr1073762927 executableScopeLevel@var2976 ; }
7851: continue ;
7852: }
7853:
7854: if (@expr1073762928 tok@var2979 .@expr21086 str (@expr21087 ) ==@expr1073762931 "}" ) {
7855: if (@expr21101 executableScopeLevel@var2976 >@expr21102 0 ) {
7856: --@expr1073762934 executableScopeLevel@var2976 ; }
7857: continue ;
7858: }
7859:
7860: if (@expr1073762935 !@expr1073762936 tok@var2979 .@expr1073762937 isName (@expr1073762938 ) ) {
7861: continue ; }
7862:
7863: const std ::@expr21115 unordered_map < std ::@expr21116 string , std ::@expr21116 string > ::@expr1073762942 const_iterator cOpIt@var2981 =@expr1073762943 cAlternativeTokens@var2975 .@expr21120 find (@expr1073762945 tok@var2979 .@expr21086 str (@expr21087 ) ) ;
7864: if (@expr1073762948 cOpIt@var2981 !=@expr1073762949 cAlternativeTokens@var2975 .@expr21126 end (@expr21127 ) ) {
7865: alt@var2977 .@expr21128 push_back (@expr21129 tok@var2979 ) ;
7866:
7867:
7868: if (@expr1073762954 isC (@expr1073762955 ) &&@expr1073762956 Token ::@expr21133 Match (@expr1073762958 tok@var2979 .@expr21135 previous (@expr21136 ) , "%type%|* %name% [;,=]" ) ) {
7869: return false ; }
7870:
7871: if (@expr1073762961 !@expr1073762962 Token ::@expr21133 Match (@expr1073762964 tok@var2979 .@expr21135 previous (@expr21136 ) , "%name%|%num%|%char%|)|]|> %name% %name%|%num%|%char%|%op%|(" ) ) {
7872: continue ; }
7873: if (@expr1073762967 Token ::@expr21133 Match (@expr1073762969 tok@var2979 .@expr21083 next (@expr21084 ) , "%assign%|%or%|%oror%|&&|*|/|%|^" ) &&@expr1073762972 !@expr1073762973 Token ::@expr21133 Match (@expr1073762975 tok@var2979 .@expr21135 previous (@expr21136 ) , "%num%|%char%|) %name% *" ) ) {
7874: continue ; }
7875: if (@expr1073762978 executableScopeLevel@var2976 ==@expr1073762979 0 &&@expr1073762980 Token ::@expr21133 Match (@expr1073762982 tok@var2979 , "%name% (" ) ) {
7876: const Token * start@var2982 ; start@var2982 =@expr1073762983 tok@var2979 ;
7877: while (@expr1073762984 Token ::@expr21133 Match (@expr1073762986 start@var2982 , "%name%|*" ) ) {
7878: start@var2982 =@expr1073762987 start@var2982 .@expr1073762988 previous (@expr1073762989 ) ; }
7879: if (@expr1073762990 !@expr1073762991 start@var2982 ||@expr1073762992 Token ::@expr21133 Match (@expr1073762994 start@var2982 , "[;}]" ) ) {
7880: continue ; }
7881: }
7882: replaceAll@var2978 =@expr1073762995 true ;
7883: } else { if (@expr1073762996 Token ::@expr21133 Match (@expr1073762998 tok@var2979 , "not|compl" ) ) {
7884: alt@var2977 .@expr21128 push_back (@expr21129 tok@var2979 ) ;
7885:
7886: if (@expr1073763001 Token ::@expr21133 Match (@expr1073763003 tok@var2979 .@expr21135 previous (@expr21136 ) , "%assign%" ) ||@expr1073763006 Token ::@expr21133 Match (@expr1073763008 tok@var2979 .@expr21083 next (@expr21084 ) , "%num%" ) ) {
7887: replaceAll@var2978 =@expr1073763011 true ;
7888: continue ;
7889: }
7890:
7891:
7892: if (@expr1073763012 !@expr1073763013 Token ::@expr21133 Match (@expr1073763015 tok@var2979 .@expr21083 next (@expr21084 ) , "%name%|(" ) ||@expr1073763018
7893: Token ::@expr21133 Match (@expr1073763020 tok@var2979 .@expr21135 previous (@expr21136 ) , "[;{}]" ) ||@expr1073763023
7894: (@expr1073763024 executableScopeLevel@var2976 ==@expr1073763025 0U &&@expr1073763026 tok@var2979 .@expr1073763027 strAt (@expr1073763028 -1 ) ==@expr1073763029 "(" ) ) {
7895: continue ; }
7896:
7897: replaceAll@var2978 =@expr1073763030 true ;
7898: } }
7899: }
7900:
7901: if (@expr1073763031 !@expr1073763032 replaceAll@var2978 ) {
7902: return false ; }
7903:
7904: for (@expr1073763033 Token *@expr21075 tok@var2983 :@expr1073763035 alt@var2977 ) {
7905: const std ::@expr21115 unordered_map < std ::@expr21116 string , std ::@expr21116 string > ::@expr1073763039 const_iterator cOpIt@var2984 =@expr1073763040 cAlternativeTokens@var2975 .@expr21120 find (@expr1073763042 tok@var2983 .@expr21219 str (@expr21220 ) ) ;
7906: if (@expr1073763045 cOpIt@var2984 !=@expr1073763046 cAlternativeTokens@var2975 .@expr21126 end (@expr21127 ) ) {
7907: tok@var2983 .@expr21219 str (@expr1073763050 cOpIt@var2984 .@expr1073763051 second@var2985 ) ; }
7908: else { if (@expr1073763052 tok@var2983 .@expr21219 str (@expr21220 ) ==@expr1073763055 "not" ) {
7909: tok@var2983 .@expr21219 str (@expr1073763057 "!" ) ; }
7910: else {
7911: tok@var2983 .@expr21219 str (@expr1073763059 "~" ) ; } }
7912: }
7913:
7914: return !@expr1073763060 alt@var2977 .@expr1073763061 empty (@expr1073763062 ) ;
7915: }
7916:
7917:
7918:
7919: void Tokenizer :: simplifyInitVar ( )
7920: {
7921: if (@expr1073763063 isC (@expr1073763064 ) ) {
7922: return ; }
7923:
7924: for (@expr1073763065 Token *@expr1073763066 tok@var2986 =@expr1073763067 list@var872 .@expr1073763068 front (@expr1073763069 ) ; tok@var2986 ; tok@var2986 =@expr1073763070 tok@var2986 .@expr1073763071 next (@expr1073763072 ) ) {
7925: if (@expr1073763073 !@expr1073763074 tok@var2986 .@expr1073763075 isName (@expr1073763076 ) ||@expr1073763077 (@expr1073763078 tok@var2986 .@expr21255 previous (@expr21256 ) &&@expr1073763081 !@expr1073763082 Token ::@expr21259 Match (@expr1073763084 tok@var2986 .@expr21255 previous (@expr21256 ) , "[;{}]" ) ) ) {
7926: continue ; }
7927:
7928: if (@expr1073763087 tok@var2986 .@expr21264 str (@expr21265 ) ==@expr1073763090 "return" ) {
7929: continue ; }
7930:
7931: if (@expr1073763091 Token ::@expr21259 Match (@expr1073763093 tok@var2986 , "class|struct|union| %type% *| %name% ( &| %any% ) ;" ) ) {
7932: tok@var2986 =@expr1073763094 initVar (@expr21271 tok@var2986 ) ;
7933: } else { if (@expr1073763096 Token ::@expr21259 Match (@expr1073763098 tok@var2986 , "%type% *| %name% ( %type% (" ) ) {
7934: const Token * tok2@var2987 ; tok2@var2987 =@expr1073763099 tok@var2986 .@expr21276 tokAt (@expr1073763101 2 ) ;
7935: if (@expr1073763102 !@expr21279 tok2@var2987 .@expr21280 link (@expr21281 ) ) {
7936: tok2@var2987 =@expr1073763106 tok2@var2987 .@expr1073763107 next (@expr1073763108 ) ; }
7937: if (@expr1073763109 !@expr21279 tok2@var2987 .@expr21280 link (@expr21281 ) ||@expr1073763113 (@expr1073763114 tok2@var2987 .@expr21280 link (@expr21281 ) .@expr1073763117 strAt (@expr1073763118 1 ) ==@expr1073763119 ";" &&@expr1073763120 !@expr1073763121 Token ::@expr1073763122 simpleMatch (@expr1073763123 tok2@var2987 .@expr1073763124 linkAt (@expr1073763125 2 ) , ") (" ) ) ) {
7938: tok@var2986 =@expr1073763126 initVar (@expr21271 tok@var2986 ) ; }
7939: } else { if (@expr1073763128 Token ::@expr21259 Match (@expr1073763130 tok@var2986 , "class|struct|union| %type% *| %name% ( &| %any% ) ," ) &&@expr1073763131 tok@var2986 .@expr21264 str (@expr21265 ) !=@expr1073763134 "new" ) {
7940: Token * tok1@var2988 ; tok1@var2988 =@expr1073763135 tok@var2986 .@expr21276 tokAt (@expr1073763137 5 ) ;
7941: while (@expr1073763138 tok1@var2988 .@expr21315 str (@expr1073763140 ) !=@expr1073763141 "," ) {
7942: tok1@var2988 =@expr1073763142 tok1@var2988 .@expr1073763143 next (@expr1073763144 ) ; }
7943: tok1@var2988 .@expr21315 str (@expr1073763146 ";" ) ;
7944:
7945: const int numTokens@var2989 =@expr1073763147 (@expr1073763148 Token ::@expr21259 Match (@expr1073763150 tok@var2986 , "class|struct|union" ) ) ?@expr1073763151 2U :@expr1073763152 1U ;
7946: TokenList ::@expr1073763153 insertTokens (@expr1073763154 tok1@var2988 , tok@var2986 , numTokens@var2989 ) ;
7947: tok@var2986 =@expr1073763155 initVar (@expr21271 tok@var2986 ) ;
7948: } } }
7949: }
7950: }
7951:
7952: Token * Tokenizer :: initVar ( Token * tok@var2990 )
7953: {
7954:
7955: if (@expr1073763157 Token ::@expr21334 Match (@expr1073763159 tok@var2990 , "class|struct|union" ) ) {
7956: if (@expr1073763160 tok@var2990 .@expr21337 strAt (@expr21338 2 ) !=@expr1073763163 "*" ) {
7957: return tok@var2990 ; }
7958:
7959: tok@var2990 =@expr1073763164 tok@var2990 .@expr21341 next (@expr21342 ) ;
7960: } else { if (@expr1073763167 !@expr1073763168 tok@var2990 .@expr1073763169 isStandardType (@expr1073763170 ) &&@expr1073763171 tok@var2990 .@expr21348 str (@expr21349 ) !=@expr1073763174 "auto" &&@expr1073763175 tok@var2990 .@expr21341 next (@expr21342 ) .@expr1073763178 str (@expr1073763179 ) !=@expr1073763180 "*" ) {
7961: return tok@var2990 ; } }
7962:
7963:
7964: tok@var2990 =@expr1073763181 tok@var2990 .@expr21341 next (@expr21342 ) ;
7965: if (@expr1073763184 tok@var2990 .@expr21348 str (@expr21349 ) ==@expr1073763187 "*" ) {
7966: tok@var2990 =@expr1073763188 tok@var2990 .@expr21341 next (@expr21342 ) ; }
7967:
7968:
7969: if (@expr1073763191 tok@var2990 .@expr21348 str (@expr21349 ) ==@expr1073763194 "sizeof" ) {
7970: return tok@var2990 ; }
7971:
7972:
7973: if (@expr1073763195 tok@var2990 .@expr21372 tokAt (@expr21373 2 ) .@expr1073763198 isStandardType (@expr1073763199 ) ||@expr1073763200 tok@var2990 .@expr21337 strAt (@expr21338 2 ) ==@expr1073763203 "void" ) {
7974: return tok@var2990 ; }
7975: else { if (@expr1073763204 !@expr1073763205 tok@var2990 .@expr21372 tokAt (@expr21373 2 ) .@expr1073763208 isNumber (@expr1073763209 ) &&@expr1073763210 !@expr1073763211 Token ::@expr21334 Match (@expr1073763213 tok@var2990 .@expr21372 tokAt (@expr21373 2 ) , "%type% (" ) &&@expr1073763216 tok@var2990 .@expr21337 strAt (@expr21338 2 ) !=@expr1073763219 "&" &&@expr1073763220 tok@var2990 .@expr21372 tokAt (@expr21373 2 ) .@expr21399 varId (@expr1073763224 ) ==@expr1073763225 0 ) {
7976: return tok@var2990 ; } }
7977:
7978:
7979: tok@var2990 .@expr21402 insertToken (@expr1073763227 ";" ) ;
7980: tok@var2990 .@expr21341 next (@expr21342 ) .@expr1073763230 insertToken (@expr1073763231 tok@var2990 .@expr21348 str (@expr21349 ) ) ;
7981: tok@var2990 .@expr21372 tokAt (@expr21373 2 ) .@expr21399 varId (@expr1073763237 tok@var2990 .@expr1073763238 varId (@expr1073763239 ) ) ;
7982: tok@var2990 =@expr1073763240 tok@var2990 .@expr21372 tokAt (@expr21373 2 ) ;
7983: tok@var2990 .@expr21402 insertToken (@expr1073763244 "=" ) ;
7984:
7985:
7986: tok@var2990 =@expr1073763245 tok@var2990 .@expr21372 tokAt (@expr21373 2 ) ;
7987:
7988:
7989: tok@var2990 .@expr1073763248 link (@expr1073763249 ) .@expr1073763250 deleteThis (@expr1073763251 ) ;
7990:
7991:
7992: tok@var2990 .@expr1073763252 deleteThis (@expr1073763253 ) ;
7993:
7994: return tok@var2990 ;
7995: }
7996:
7997:
7998: bool Tokenizer :: simplifyKnownVariables ( )
7999: {
8000:
8001: bool ret@var2991 ; ret@var2991 =@expr1073763255 false ;
8002:
8003:
8004: {
8005: std ::@expr1073763256 unordered_map < int , std ::@expr21433 string > constantValues@var2992 ;
8006: std ::@expr1073763258 map < int , Token *@expr21435 > constantVars@var2993 ;
8007: std ::@expr1073763260 unordered_map < int , std ::@expr21433 list < Token *@expr21435 > > constantValueUsages@var2994 ;
8008: for (@expr1073763263 Token *@expr21435 tok@var2995 =@expr1073763265 list@var872 .@expr21442 front (@expr21443 ) ; tok@var2995 ; tok@var2995 =@expr1073763268 tok@var2995 .@expr21445 next (@expr21446 ) ) {
8009:
8010: if (@expr1073763271 Token ::@expr21448 Match (@expr1073763273 tok@var2995 , "%type%|* & %name% = %name% ;" ) ) {
8011: Token * start@var2996 ; start@var2996 =@expr1073763274 tok@var2995 .@expr21451 previous (@expr21452 ) ;
8012: while (@expr1073763277 Token ::@expr21448 Match (@expr1073763279 start@var2996 , "%type%|*|&" ) ) {
8013: start@var2996 =@expr1073763280 start@var2996 .@expr1073763281 previous (@expr1073763282 ) ; }
8014: if (@expr1073763283 !@expr1073763284 Token ::@expr21448 Match (@expr1073763286 start@var2996 , "[;{}]" ) ) {
8015: continue ; }
8016: const Token * reftok@var2997 ; reftok@var2997 =@expr1073763287 tok@var2995 .@expr21464 tokAt (@expr21465 2 ) ;
8017: const Token * vartok@var2998 ; vartok@var2998 =@expr1073763290 reftok@var2997 .@expr1073763291 tokAt (@expr1073763292 2 ) ;
8018: int level@var2999 ; level@var2999 =@expr1073763293 0 ;
8019: for (@expr1073763294 Token *@expr21435 tok2@var3000 =@expr1073763296 tok@var2995 .@expr21464 tokAt (@expr21474 6 ) ; tok2@var3000 ; tok2@var3000 =@expr1073763299 tok2@var3000 .@expr1073763300 next (@expr1073763301 ) ) {
8020: if (@expr1073763302 tok2@var3000 .@expr21479 str (@expr21480 ) ==@expr1073763305 "{" ) {
8021: ++@expr1073763306 level@var2999 ;
8022: } else { if (@expr1073763307 tok2@var3000 .@expr21479 str (@expr21480 ) ==@expr1073763310 "}" ) {
8023: if (@expr1073763311 level@var2999 <=@expr1073763312 0 ) {
8024: break ; }
8025: --@expr1073763313 level@var2999 ;
8026: } else { if (@expr1073763314 tok2@var3000 .@expr21491 varId (@expr1073763316 ) ==@expr1073763317 reftok@var2997 .@expr1073763318 varId (@expr1073763319 ) ) {
8027: tok2@var3000 .@expr21479 str (@expr1073763321 vartok@var2998 .@expr1073763322 str (@expr1073763323 ) ) ;
8028: tok2@var3000 .@expr21491 varId (@expr1073763325 vartok@var2998 .@expr1073763326 varId (@expr1073763327 ) ) ;
8029: } } }
8030: }
8031: Token ::@expr1073763328 eraseTokens (@expr1073763329 start@var2996 , tok@var2995 .@expr21464 tokAt (@expr21474 6 ) ) ;
8032: tok@var2995 =@expr1073763332 start@var2996 ;
8033: }
8034:
8035: if (@expr1073763333 tok@var2995 .@expr1073763334 isName (@expr1073763335 ) &&@expr1073763336 (@expr1073763337 Token ::@expr21448 Match (@expr1073763339 tok@var2995 , "static| const| static| %type% const| %name% = %any% ;" ) ||@expr1073763340
8036: Token ::@expr21448 Match (@expr1073763342 tok@var2995 , "static| const| static| %type% const| %name% ( %any% ) ;" ) ) ) {
8037: bool isconst@var3001 ; isconst@var3001 =@expr1073763343 false ;
8038: for (@expr1073763344 const Token *@expr21435 tok2@var3002 =@expr1073763346 tok@var2995 ; (@expr1073763347 tok2@var3002 .@expr21524 str (@expr21525 ) !=@expr1073763350 "=" ) &&@expr1073763351 (@expr1073763352 tok2@var3002 .@expr21524 str (@expr21525 ) !=@expr1073763355 "(" ) ; tok2@var3002 =@expr1073763356 tok2@var3002 .@expr1073763357 next (@expr1073763358 ) ) {
8039: if (@expr1073763359 tok2@var3002 .@expr21524 str (@expr21525 ) ==@expr1073763362 "const" ) {
8040: isconst@var3001 =@expr1073763363 true ;
8041: break ;
8042: }
8043: }
8044: if (@expr1073763364 !@expr1073763365 isconst@var3001 ) {
8045: continue ; }
8046:
8047: Token * tok1@var3003 ; tok1@var3003 =@expr1073763366 tok@var2995 ;
8048:
8049:
8050: if (@expr1073763367 tok@var2995 !=@expr1073763368 list@var872 .@expr21442 front (@expr21443 ) &&@expr1073763371 !@expr1073763372 Token ::@expr21448 Match (@expr1073763374 tok@var2995 .@expr21451 previous (@expr21452 ) , ";|{|}|private:|protected:|public:" ) ) {
8051: continue ; }
8052:
8053: while (@expr1073763377 Token ::@expr21448 Match (@expr1073763379 tok@var2995 , "const|static" ) ) {
8054: tok@var2995 =@expr1073763380 tok@var2995 .@expr21445 next (@expr21446 ) ; }
8055:
8056: if (@expr1073763383 !@expr1073763384 tok@var2995 .@expr1073763385 isStandardType (@expr1073763386 ) ) {
8057: continue ; }
8058:
8059: Token * const vartok@var3004 ; vartok@var3004 =@expr1073763387 (@expr1073763388 tok@var2995 .@expr21445 next (@expr21446 ) &&@expr1073763391 tok@var2995 .@expr21445 next (@expr21446 ) .@expr21570 str (@expr21571 ) ==@expr1073763396 "const" ) ?@expr1073763397 tok@var2995 .@expr21464 tokAt (@expr21465 2 ) :@expr1073763400 tok@var2995 .@expr21445 next (@expr21446 ) ;
8060: const Token * const valuetok@var3005 ; valuetok@var3005 =@expr1073763403 vartok@var3004 .@expr1073763404 tokAt (@expr1073763405 2 ) ;
8061: if (@expr1073763406 Token ::@expr21448 Match (@expr1073763408 valuetok@var3005 , "%bool%|%char%|%num%|%str% )| ;" ) ) {
8062:
8063: constantValues@var2992 [@expr1073763409 vartok@var3004 .@expr21586 varId (@expr21587 ) ] =@expr1073763412 valuetok@var3005 .@expr1073763413 str (@expr1073763414 ) ;
8064: constantVars@var2993 [@expr1073763415 vartok@var3004 .@expr21586 varId (@expr21587 ) ] =@expr1073763418 tok1@var3003 ;
8065: }
8066: } else { if (@expr1073763419 tok@var2995 .@expr21596 varId (@expr21597 ) ) {
8067:
8068: if (@expr1073763422 constantValues@var2992 .@expr1073763423 find (@expr1073763424 tok@var2995 .@expr21596 varId (@expr21597 ) ) !=@expr1073763427 constantValues@var2992 .@expr1073763428 end (@expr1073763429 ) &&@expr1073763430 tok@var2995 .@expr21445 next (@expr21446 ) .@expr21570 str (@expr21571 ) !=@expr1073763435 "=" ) {
8069: constantValueUsages@var2994 [@expr1073763436 tok@var2995 .@expr21596 varId (@expr21597 ) ] .@expr1073763439 push_back (@expr1073763440 tok@var2995 ) ;
8070: }
8071: } }
8072: }
8073:
8074: for (@expr1073763441 auto constantVar@var3006 =@expr1073763442 constantVars@var2993 .@expr1073763443 rbegin (@expr1073763444 ) ; constantVar@var3006 !=@expr1073763445 constantVars@var2993 .@expr1073763446 rend (@expr1073763447 ) ; constantVar@var3006 ++@expr1073763448 ) {
8075: bool referenceFound@var3007 ; referenceFound@var3007 =@expr1073763449 false ;
8076: std ::@expr1073763450 list < Token *@expr21435 > usageList@var3008 ; usageList@var3008 =@expr1073763452 constantValueUsages@var2994 [@expr1073763453 constantVar@var3006 .@expr21630 first@var3009 ] ;
8077: for (@expr1073763455 Token *@expr21435 usage@var3010 :@expr1073763457 usageList@var3008 ) {
8078:
8079: if (@expr1073763458 Token ::@expr21448 Match (@expr1073763460 usage@var3010 .@expr1073763461 tokAt (@expr1073763462 -2 ) , "(|[|,|{|return|%op% & %varid%" , constantVar@var3006 .@expr21630 first@var3009 ) ) {
8080: referenceFound@var3007 =@expr1073763464 true ;
8081: break ;
8082: }
8083: }
8084:
8085: if (@expr1073763465 !@expr1073763466 referenceFound@var3007 ) {
8086:
8087: for (@expr1073763467 Token *@expr21435 usage@var3011 :@expr1073763469 usageList@var3008 ) {
8088: usage@var3011 .@expr1073763470 str (@expr1073763471 constantValues@var2992 [@expr1073763472 constantVar@var3006 .@expr21630 first@var3009 ] ) ;
8089: }
8090:
8091: Token * startTok@var3012 ; startTok@var3012 =@expr1073763474 constantVar@var3006 .@expr21651 second@var3013 ;
8092:
8093: while (@expr1073763476 startTok@var3012 .@expr21653 next (@expr21654 ) .@expr1073763479 str (@expr1073763480 ) !=@expr1073763481 ";" ) {
8094: startTok@var3012 .@expr21658 deleteNext (@expr21659 ) ; }
8095: startTok@var3012 .@expr21658 deleteNext (@expr21659 ) ;
8096:
8097:
8098: if (@expr1073763486 startTok@var3012 .@expr21663 previous (@expr21664 ) ) {
8099: startTok@var3012 .@expr21663 previous (@expr21664 ) .@expr1073763491 deleteNext (@expr1073763492 ) ;
8100: } else { if (@expr1073763493 startTok@var3012 .@expr21653 next (@expr21654 ) ) {
8101: startTok@var3012 .@expr21653 next (@expr21654 ) .@expr1073763498 deletePrevious (@expr1073763499 ) ;
8102: } else {
8103: startTok@var3012 .@expr1073763500 deleteThis (@expr1073763501 ) ;
8104: } }
8105: startTok@var3012 =@expr1073763502 nullptr ;
8106:
8107: constantVar@var3006 .@expr21651 second@var3013 =@expr1073763504 nullptr ;
8108: ret@var2991 =@expr1073763505 true ;
8109: }
8110: }
8111: }
8112:
8113:
8114: std ::@expr1073763506 set < int > localvars@var3014 ;
8115: std ::@expr1073763507 set < int > floatvars@var3015 ;
8116: std ::@expr1073763508 set < int > arrays@var3016 ;
8117:
8118:
8119: for (@expr1073763509 Token *@expr21435 tok@var3017 =@expr1073763511 list@var872 .@expr21442 front (@expr21443 ) ; tok@var3017 ; tok@var3017 =@expr1073763514 tok@var3017 .@expr1073763515 next (@expr1073763516 ) ) {
8120:
8121: Token * const start@var3018 ; start@var3018 =@expr1073763517 const_cast < Token *@expr21435 > (@expr1073763519 startOfExecutableScope (@expr1073763520 tok@var3017 ) ) ;
8122: if (@expr1073763521 !@expr1073763522 start@var3018 ) {
8123: continue ; }
8124:
8125: for (@expr1073763523 const Token *@expr21435 tok2@var3019 =@expr1073763525 start@var3018 .@expr1073763526 previous (@expr1073763527 ) ; tok2@var3019 &&@expr1073763528 !@expr1073763529 Token ::@expr21448 Match (@expr1073763531 tok2@var3019 , "[;{}]" ) ; tok2@var3019 =@expr1073763532 tok2@var3019 .@expr1073763533 previous (@expr1073763534 ) ) {
8126: if (@expr1073763535 tok2@var3019 .@expr21712 varId (@expr21713 ) !=@expr1073763538 0 ) {
8127: localvars@var3014 .@expr21715 insert (@expr1073763540 tok2@var3019 .@expr21712 varId (@expr21713 ) ) ; }
8128: }
8129:
8130: tok@var3017 =@expr1073763543 start@var3018 ;
8131:
8132: int indentlevel@var3020 ; indentlevel@var3020 =@expr1073763544 0 ;
8133: Token * tok2@var3021 ; tok2@var3021 =@expr1073763545 tok@var3017 ;
8134: for (@expr1073763546 ; tok2@var3021 ; tok2@var3021 =@expr1073763547 tok2@var3021 .@expr21724 next (@expr21725 ) ) {
8135: if (@expr1073763550 Token ::@expr21448 Match (@expr1073763552 tok2@var3021 , "[;{}] %type% %name%|*" ) ) {
8136: bool isfloat@var3022 ; isfloat@var3022 =@expr1073763553 false ;
8137: bool ispointer@var3023 ; ispointer@var3023 =@expr1073763554 false ;
8138: const Token * vartok@var3024 ; vartok@var3024 =@expr1073763555 tok2@var3021 .@expr21724 next (@expr21725 ) ;
8139: while (@expr1073763558 Token ::@expr21448 Match (@expr1073763560 vartok@var3024 , "%name%|* %name%|*" ) ) {
8140: if (@expr1073763561 Token ::@expr21448 Match (@expr1073763563 vartok@var3024 , "float|double" ) ) {
8141: isfloat@var3022 =@expr1073763564 true ; }
8142: if (@expr1073763565 vartok@var3024 .@expr1073763566 str (@expr1073763567 ) ==@expr1073763568 "*" ) {
8143: ispointer@var3023 =@expr1073763569 true ; }
8144: vartok@var3024 =@expr1073763570 vartok@var3024 .@expr1073763571 next (@expr1073763572 ) ;
8145: }
8146: if (@expr1073763573 Token ::@expr21448 Match (@expr1073763575 vartok@var3024 , "%var% ;|[" ) ) {
8147: localvars@var3014 .@expr21715 insert (@expr1073763577 vartok@var3024 .@expr21754 varId (@expr21755 ) ) ; }
8148: if (@expr1073763580 isfloat@var3022 &&@expr1073763581 !@expr1073763582 ispointer@var3023 &&@expr1073763583 Token ::@expr21448 Match (@expr1073763585 vartok@var3024 , "%var% ;" ) ) {
8149: floatvars@var3015 .@expr1073763586 insert (@expr1073763587 vartok@var3024 .@expr21754 varId (@expr21755 ) ) ; }
8150: if (@expr1073763590 Token ::@expr21448 Match (@expr1073763592 vartok@var3024 , "%var% [" ) ) {
8151: arrays@var3016 .@expr1073763593 insert (@expr1073763594 vartok@var3024 .@expr21754 varId (@expr21755 ) ) ; }
8152: }
8153:
8154: if (@expr1073763597 tok2@var3021 .@expr21774 str (@expr21775 ) ==@expr1073763600 "{" ) {
8155: ++@expr1073763601 indentlevel@var3020 ; }
8156:
8157: else { if (@expr1073763602 tok2@var3021 .@expr21774 str (@expr21775 ) ==@expr1073763605 "}" ) {
8158: --@expr1073763606 indentlevel@var3020 ;
8159: if (@expr1073763607 indentlevel@var3020 <=@expr1073763608 0 ) {
8160: break ; }
8161: }
8162:
8163: else { if (@expr1073763609 Token ::@expr1073763610 simpleMatch (@expr1073763611 tok2@var3021 , "for (" ) ) {
8164: tok2@var3021 =@expr1073763612 tok2@var3021 .@expr21724 next (@expr21725 ) .@expr1073763615 link (@expr1073763616 ) ; }
8165:
8166: else { if (@expr1073763617 tok2@var3021 .@expr21794 previous (@expr21795 ) .@expr1073763620 str (@expr1073763621 ) !=@expr1073763622 "*" &&@expr1073763623 !@expr1073763624 Token ::@expr21448 Match (@expr1073763626 tok2@var3021 .@expr21803 tokAt (@expr21804 -2 ) , "* --|++" ) &&@expr1073763629
8167: (@expr1073763630 Token ::@expr21448 Match (@expr1073763632 tok2@var3021 , "%name% = %bool%|%char%|%num%|%str%|%name% ;" ) ||@expr1073763633
8168: Token ::@expr21448 Match (@expr1073763635 tok2@var3021 , "%name% [ %num%| ] = %str% ;" ) ||@expr1073763636
8169: Token ::@expr21448 Match (@expr1073763638 tok2@var3021 , "%name% = & %name% ;" ) ||@expr1073763639
8170: (@expr1073763640 Token ::@expr21448 Match (@expr1073763642 tok2@var3021 , "%name% = & %name% [ 0 ] ;" ) &&@expr1073763643 arrays@var3016 .@expr21820 find (@expr1073763645 tok2@var3021 .@expr21803 tokAt (@expr1073763647 3 ) .@expr1073763648 varId (@expr1073763649 ) ) !=@expr1073763650 arrays@var3016 .@expr21827 end (@expr21828 ) ) ) ) {
8171: const int varid@var3025 =@expr1073763653 tok2@var3021 .@expr21830 varId (@expr21831 ) ;
8172: if (@expr1073763656 varid@var3025 ==@expr1073763657 0 ) {
8173: continue ; }
8174:
8175: if (@expr1073763658 Token ::@expr21448 Match (@expr1073763660 tok2@var3021 .@expr21794 previous (@expr21795 ) , "[;{}]" ) &&@expr1073763663 localvars@var3014 .@expr1073763664 find (@expr1073763665 varid@var3025 ) ==@expr1073763666 localvars@var3014 .@expr1073763667 end (@expr1073763668 ) ) {
8176: continue ; }
8177:
8178:
8179: {
8180: bool isstatic@var3026 ; isstatic@var3026 =@expr1073763669 false ;
8181: const Token * decl@var3027 ; decl@var3027 =@expr1073763670 tok2@var3021 .@expr21794 previous (@expr21795 ) ;
8182: while (@expr1073763673 decl@var3027 &&@expr1073763674 (@expr1073763675 decl@var3027 .@expr1073763676 isName (@expr1073763677 ) ||@expr1073763678 decl@var3027 .@expr21855 str (@expr21856 ) ==@expr1073763681 "*" ) ) {
8183: if (@expr1073763682 decl@var3027 .@expr21855 str (@expr21856 ) ==@expr1073763685 "static" ) {
8184: isstatic@var3026 =@expr1073763686 true ;
8185: break ;
8186: }
8187: decl@var3027 =@expr1073763687 decl@var3027 .@expr1073763688 previous (@expr1073763689 ) ;
8188: }
8189: if (@expr1073763690 isstatic@var3026 ) {
8190: continue ; }
8191: }
8192:
8193:
8194: if (@expr1073763691 Token ::@expr21448 Match (@expr1073763693 tok2@var3021 .@expr21803 tokAt (@expr21804 -2 ) , "(|:: %type%" ) ) {
8195: const Token * tok3@var3028 ; tok3@var3028 =@expr1073763696 tok2@var3021 .@expr21794 previous (@expr21795 ) ;
8196: do {
8197: tok3@var3028 =@expr1073763699 tok3@var3028 .@expr21876 tokAt (@expr21877 -2 ) ;
8198: } while (@expr1073763702 Token ::@expr21448 Match (@expr1073763704 tok3@var3028 .@expr1073763705 previous (@expr1073763706 ) , ":: %type%" ) ) ;
8199: if (@expr1073763707 Token ::@expr21448 Match (@expr1073763709 tok3@var3028 .@expr21876 tokAt (@expr21877 -2 ) , "for ( %type%" ) ) {
8200: continue ; }
8201: }
8202:
8203:
8204: if (@expr1073763712 Token ::@expr21448 Match (@expr1073763714 tok2@var3021 , "%varid% = &| %varid%" , tok2@var3021 .@expr21830 varId (@expr21831 ) ) ) {
8205: continue ; }
8206:
8207: const std ::@expr21433 string structname@var3029 =@expr1073763718 Token ::@expr21448 Match (@expr1073763720 tok2@var3021 .@expr21803 tokAt (@expr1073763722 -3 ) , "[;{}] %name% ." ) ?@expr1073763723
8208: std ::@expr21900 string (@expr1073763725 tok2@var3021 .@expr1073763726 strAt (@expr1073763727 -2 ) +@expr1073763728 " ." ) :@expr1073763729
8209: std ::@expr21900 string (@expr1073763731 ) ;
8210:
8211: const Token * const valueToken@var3030 ; valueToken@var3030 =@expr1073763732 tok2@var3021 .@expr21803 tokAt (@expr21910 2 ) ;
8212:
8213: std ::@expr1073763735 string value@var3031 ;
8214: int valueVarId@var3032 ; valueVarId@var3032 =@expr1073763736 0 ;
8215:
8216: Token * tok3@var3033 ; tok3@var3033 =@expr1073763737 nullptr ;
8217: bool valueIsPointer@var3034 ; valueIsPointer@var3034 =@expr1073763738 false ;
8218:
8219:
8220: if (@expr21915 Settings ::@expr21916 terminated (@expr21917 ) ) {
8221: return false ; }
8222:
8223: if (@expr1073763742 !@expr1073763743 simplifyKnownVariablesGetData (@expr1073763744 varid@var3025 , &@expr21921 tok2@var3021 , &@expr1073763746 tok3@var3033 , value@var3031 , valueVarId@var3032 , valueIsPointer@var3034 , floatvars@var3015 .@expr1073763747 find (@expr1073763748 tok2@var3021 .@expr21830 varId (@expr21831 ) ) !=@expr1073763751 floatvars@var3015 .@expr1073763752 end (@expr1073763753 ) ) ) {
8224: continue ; }
8225:
8226: if (@expr1073763754 valueVarId@var3032 >@expr1073763755 0 &&@expr1073763756 arrays@var3016 .@expr21820 find (@expr1073763758 valueVarId@var3032 ) !=@expr1073763759 arrays@var3016 .@expr21827 end (@expr21828 ) ) {
8227: continue ; }
8228:
8229: ret@var2991 |=@expr1073763762 simplifyKnownVariablesSimplify (@expr1073763763 &@expr21921 tok2@var3021 , tok3@var3033 , varid@var3025 , structname@var3029 , value@var3031 , valueVarId@var3032 , valueIsPointer@var3034 , valueToken@var3030 , indentlevel@var3020 ) ;
8230: }
8231:
8232: else { if (@expr1073763765 Token ::@expr21448 Match (@expr1073763767 tok2@var3021 , "strcpy|sprintf ( %name% , %str% ) ;" ) ) {
8233: const int varid@var3035 (@expr1073763768 tok2@var3021 .@expr21803 tokAt (@expr21910 2 ) .@expr1073763771 varId (@expr1073763772 ) ) ;
8234: if (@expr1073763773 varid@var3035 ==@expr1073763774 0 ) {
8235: continue ; }
8236:
8237: const Token * const valueToken@var3036 ; valueToken@var3036 =@expr1073763775 tok2@var3021 .@expr21803 tokAt (@expr1073763777 4 ) ;
8238: std ::@expr1073763778 string value@var3037 (@expr1073763779 valueToken@var3036 .@expr1073763780 str (@expr1073763781 ) ) ;
8239: if (@expr1073763782 tok2@var3021 .@expr21774 str (@expr21775 ) ==@expr1073763785 "sprintf" ) {
8240: std ::@expr21900 string ::@expr1073763787 size_type n@var3038 ; n@var3038 =@expr1073763788 0 ;
8241: while (@expr1073763789 (@expr1073763790 n@var3038 =@expr1073763791 value@var3037 .@expr1073763792 find (@expr1073763793 "%%" , n@var3038 ) ) !=@expr1073763794 std ::@expr21900 string ::@expr1073763796 npos@expr1073763254 ) {
8242:
8243: value@var3037 .@expr1073763797 erase (@expr1073763798 n@var3038 , 1 ) ;
8244: ++@expr1073763799 n@var3038 ;
8245: }
8246: }
8247: const int valueVarId@var3039 (@expr1073763800 0 ) ;
8248: const bool valueIsPointer@var3040 (@expr1073763801 false ) ;
8249: Token * tok3@var3041 ; tok3@var3041 =@expr1073763802 tok2@var3021 .@expr21803 tokAt (@expr1073763804 6 ) ;
8250: ret@var2991 |=@expr1073763805 simplifyKnownVariablesSimplify (@expr1073763806 &@expr21921 tok2@var3021 , tok3@var3041 , varid@var3035 , emptyString@var1 , value@var3037 , valueVarId@var3039 , valueIsPointer@var3040 , valueToken@var3036 , indentlevel@var3020 ) ;
8251:
8252:
8253: if (@expr21915 Settings ::@expr21916 terminated (@expr21917 ) ) {
8254: return false ; }
8255: } } } } }
8256: }
8257:
8258: if (@expr1073763811 tok2@var3021 ) {
8259: tok@var3017 =@expr1073763812 tok2@var3021 .@expr21794 previous (@expr21795 ) ; }
8260: }
8261:
8262: return ret@var2991 ;
8263: }
8264:
8265: bool Tokenizer :: simplifyKnownVariablesGetData ( int varid@var3042 , Token * * _tok2@var3043 , Token * * _tok3@var3044 , std :: string & value@var3045 , int & valueVarId@var3046 , bool & valueIsPointer@var3047 , bool floatvar@var3048 )
8266: {
8267: Token * tok2@var3049 ; tok2@var3049 =@expr1073763815 *@expr21992 _tok2@var3043 ;
8268: Token * tok3@var3050 ; tok3@var3050 =@expr1073763817 nullptr ;
8269:
8270: if (@expr1073763818 Token ::@expr21995 simpleMatch (@expr1073763820 tok2@var3049 .@expr21997 tokAt (@expr1073763822 -2 ) , "for (" ) ) {
8271:
8272: if (@expr1073763823 !@expr1073763824 Token ::@expr1073763825 Match (@expr1073763826 tok2@var3049 , "%varid% = %num% ; %varid% <|<= %num% ; ++| %varid% ++| ) {" , varid@var3042 ) ) {
8273: return false ; }
8274:
8275:
8276: bool hasbreak@var3051 ; hasbreak@var3051 =@expr1073763827 false ;
8277: const Token * end4@var3052 ; end4@var3052 =@expr1073763828 tok2@var3049 .@expr1073763829 linkAt (@expr1073763830 -1 ) .@expr1073763831 linkAt (@expr1073763832 1 ) ;
8278: for (@expr1073763833 const Token *@expr1073763834 tok4@var3053 =@expr1073763835 tok2@var3049 .@expr22012 previous (@expr22013 ) .@expr22014 link (@expr22015 ) ; tok4@var3053 !=@expr1073763840 end4@var3052 ; tok4@var3053 =@expr1073763841 tok4@var3053 .@expr1073763842 next (@expr1073763843 ) ) {
8279: if (@expr1073763844 tok4@var3053 .@expr1073763845 str (@expr1073763846 ) ==@expr1073763847 "break" ) {
8280: hasbreak@var3051 =@expr1073763848 true ;
8281: break ;
8282: }
8283: }
8284: if (@expr1073763849 hasbreak@var3051 ) {
8285: return false ; }
8286:
8287:
8288: const Token * compareTok@var3054 ; compareTok@var3054 =@expr1073763850 tok2@var3049 .@expr21997 tokAt (@expr1073763852 5 ) ;
8289: if (@expr1073763853 compareTok@var3054 .@expr1073763854 str (@expr1073763855 ) ==@expr1073763856 "<" ) {
8290: value@var3045 =@expr1073763857 compareTok@var3054 .@expr22034 next (@expr22035 ) .@expr22036 str (@expr22037 ) ;
8291: valueVarId@var3046 =@expr1073763862 compareTok@var3054 .@expr22034 next (@expr22035 ) .@expr1073763865 varId (@expr1073763866 ) ;
8292: } else {
8293: value@var3045 =@expr1073763867 MathLib ::@expr1073763868 toString (@expr1073763869 MathLib ::@expr1073763870 toLongNumber (@expr1073763871 compareTok@var3054 .@expr22034 next (@expr22035 ) .@expr22036 str (@expr22037 ) ) +@expr1073763876 1 ) ; }
8294:
8295:
8296: tok3@var3050 =@expr1073763877 tok2@var3049 .@expr22012 previous (@expr22013 ) .@expr22014 link (@expr22015 ) .@expr1073763882 next (@expr1073763883 ) .@expr1073763884 link (@expr1073763885 ) .@expr1073763886 next (@expr1073763887 ) ;
8297: } else {
8298: value@var3045 =@expr1073763888 tok2@var3049 .@expr22065 strAt (@expr22066 2 ) ;
8299: valueVarId@var3046 =@expr1073763891 tok2@var3049 .@expr21997 tokAt (@expr22069 2 ) .@expr1073763894 varId (@expr1073763895 ) ;
8300: if (@expr1073763896 tok2@var3049 .@expr22065 strAt (@expr1073763898 1 ) ==@expr1073763899 "[" ) {
8301: value@var3045 =@expr1073763900 tok2@var3049 .@expr22077 next (@expr22078 ) .@expr1073763903 link (@expr1073763904 ) .@expr1073763905 strAt (@expr1073763906 2 ) ;
8302: valueVarId@var3046 =@expr1073763907 0 ;
8303: } else { if (@expr1073763908 value@var3045 ==@expr1073763909 "&" ) {
8304: value@var3045 =@expr1073763910 tok2@var3049 .@expr22065 strAt (@expr1073763912 3 ) ;
8305: valueVarId@var3046 =@expr1073763913 tok2@var3049 .@expr21997 tokAt (@expr22091 3 ) .@expr1073763916 varId (@expr1073763917 ) ;
8306:
|
8309:
8310: if (@expr1073763918 tok2@var3049 .@expr22065 strAt (@expr1073763920 4 ) ==@expr1073763921 ";" ) {
8311: valueIsPointer@var3047 =@expr1073763922 true ; }
8312: }
8313:
8314:
8315: else { if (@expr1073763923 MathLib ::@expr1073763924 isDec (@expr1073763925 tok2@var3049 .@expr22065 strAt (@expr22066 2 ) ) &&@expr1073763928 floatvar@var3048 ) {
8316: value@var3045 +=@expr1073763929 ".0" ;
8317: }
8318:
8319:
8320: else { if (@expr1073763930 tok2@var3049 .@expr21997 tokAt (@expr22069 2 ) .@expr1073763933 isBoolean (@expr1073763934 ) &&@expr1073763935 floatvar@var3048 ) {
8321: value@var3045 =@expr1073763936 (@expr1073763937 value@var3045 ==@expr1073763938 "true" ) ?@expr1073763939 "1.0" :@expr1073763940 "0.0" ;
8322: } } } }
8323:
8324: if (@expr1073763941 Token ::@expr21995 simpleMatch (@expr1073763943 tok2@var3049 .@expr22077 next (@expr22078 ) , "= &" ) ) {
8325: tok2@var3049 =@expr1073763946 tok2@var3049 .@expr21997 tokAt (@expr22091 3 ) ; }
8326:
8327: tok3@var3050 =@expr1073763949 tok2@var3049 .@expr22077 next (@expr22078 ) ;
8328: }
8329: *@expr21992 _tok2@var3043 =@expr1073763953 tok2@var3049 ;
8330: *@expr1073763954 _tok3@var3044 =@expr1073763955 tok3@var3050 ;
8331: return true ;
8332: }
8333:
8334: bool Tokenizer :: simplifyKnownVariablesSimplify ( Token * * tok2@var3055 , Token * tok3@var3056 , int varid@var3057 , const std :: string & structname@var3058 , std :: string & value@var3059 , int valueVarId@var3060 , bool valueIsPointer@var3061 , const Token * const valueToken@var3062 , int indentlevel@var3063 ) const
8335: {
8336: const bool pointeralias@var3064 (@expr1073763956 valueToken@var3062 .@expr1073763957 isName (@expr1073763958 ) ||@expr1073763959 Token ::@expr22136 Match (@expr1073763961 valueToken@var3062 , "& %name% [" ) ) ;
8337: const bool varIsGlobal@var3065 =@expr1073763962 indentlevel@var3063 ==@expr1073763963 0 ;
8338: const bool printDebug@var3066 =@expr1073763964 mSettings@var879 .@expr1073763965 debugwarnings@var3566 ;
8339:
8340: if (@expr1073763966 mErrorLogger@var880 &&@expr1073763967 !@expr1073763968 list@var872 .@expr22145 getFiles (@expr22146 ) .@expr1073763971 empty (@expr1073763972 ) ) {
8341: mErrorLogger@var880 .@expr1073763973 reportProgress (@expr1073763974 list@var872 .@expr22145 getFiles (@expr22146 ) [@expr1073763977 0 ] , "Tokenize (simplifyKnownVariables)" , tok3@var3056 .@expr1073763978 progressValue (@expr1073763979 ) ) ; }
8342:
8343: if (@expr1073763980 isMaxTime (@expr1073763981 ) ) {
8344: return false ; }
8345:
8346: bool ret@var3067 ; ret@var3067 =@expr1073763982 false ;
8347:
8348: Token * bailOutFromLoop@var3068 ; bailOutFromLoop@var3068 =@expr1073763983 nullptr ;
8349: int indentlevel3@var3069 ; indentlevel3@var3069 =@expr1073763984 indentlevel@var3063 ;
8350: bool ret3@var3070 ; ret3@var3070 =@expr1073763985 false ;
8351: for (@expr1073763986 ; tok3@var3056 ; tok3@var3056 =@expr1073763987 tok3@var3056 .@expr22164 next (@expr22165 ) ) {
8352: if (@expr1073763990 tok3@var3056 .@expr22167 str (@expr22168 ) ==@expr22169 "{" ) {
8353: ++@expr1073763994 indentlevel3@var3069 ;
8354: } else { if (@expr1073763995 tok3@var3056 .@expr22167 str (@expr22168 ) ==@expr1073763998 "}" ) {
8355: --@expr1073763999 indentlevel3@var3069 ;
8356: if (@expr1073764000 indentlevel3@var3069 <@expr1073764001 indentlevel@var3063 ) {
8357: if (@expr1073764002 Token ::@expr22136 Match (@expr1073764004 (@expr22181 *@expr22182 tok2@var3055 ) .@expr22183 tokAt (@expr1073764008 -7 ) , "%type% * %name% ; %name% = & %name% ;" ) &&@expr1073764009
8358: (@expr22181 *@expr22182 tok2@var3055 ) .@expr22188 strAt (@expr1073764013 -5 ) ==@expr1073764014 (@expr22181 *@expr22182 tok2@var3055 ) .@expr22188 strAt (@expr1073764018 -3 ) ) {
8359: (@expr22181 *@expr22182 tok2@var3055 ) =@expr1073764021 (@expr22181 *@expr22182 tok2@var3055 ) .@expr22183 tokAt (@expr1073764025 -4 ) ;
8360: Token ::@expr1073764026 eraseTokens (@expr1073764027 *@expr22182 tok2@var3055 , (@expr22181 *@expr22182 tok2@var3055 ) .@expr22183 tokAt (@expr1073764032 6 ) ) ;
8361: }
8362: break ;
8363: }
8364: } }
8365:
8366:
8367:
8368: if (@expr1073764033 valueIsPointer@var3061 &&@expr1073764034 tok3@var3056 .@expr22211 varId (@expr22212 ) >@expr1073764037 0 &&@expr1073764038
8369: tok3@var3056 .@expr22215 previous (@expr22216 ) &&@expr1073764041 (@expr1073764042 tok3@var3056 .@expr22215 previous (@expr22216 ) .@expr1073764045 isName (@expr1073764046 ) ||@expr1073764047 tok3@var3056 .@expr22215 previous (@expr22216 ) .@expr22226 str (@expr22227 ) ==@expr22228 "*" ) &&@expr1073764053
8370: valueToken@var3062 .@expr22230 str (@expr22231 ) ==@expr1073764056 "&" &&@expr1073764057
8371: valueToken@var3062 .@expr22234 next (@expr22235 ) &&@expr1073764060
8372: valueToken@var3062 .@expr22234 next (@expr22235 ) .@expr1073764063 isName (@expr1073764064 ) &&@expr1073764065
8373: tok3@var3056 .@expr22167 str (@expr22168 ) ==@expr1073764068 valueToken@var3062 .@expr22234 next (@expr22235 ) .@expr1073764071 str (@expr1073764072 ) &&@expr1073764073
8374: tok3@var3056 .@expr22211 varId (@expr22212 ) >@expr1073764076 valueToken@var3062 .@expr22234 next (@expr22235 ) .@expr1073764079 varId (@expr1073764080 ) ) {
8375:
8376: bool decl@var3071 ; decl@var3071 =@expr1073764081 true ;
8377: for (@expr1073764082 const Token *@expr22259 tok4@var3072 =@expr1073764084 tok3@var3056 .@expr22215 previous (@expr22216 ) ; tok4@var3072 ; tok4@var3072 =@expr1073764087 tok4@var3072 .@expr1073764088 previous (@expr1073764089 ) ) {
8378: if (@expr1073764090 Token ::@expr22136 Match (@expr1073764092 tok4@var3072 , "[;{}]" ) ) {
8379: break ; }
8380:
8381: else { if (@expr1073764093 tok4@var3072 .@expr1073764094 isName (@expr1073764095 ) ) {
8382: if (@expr1073764096 tok4@var3072 .@expr1073764097 varId (@expr1073764098 ) >@expr1073764099 0 ) {
8383: decl@var3071 =@expr1073764100 false ;
8384: break ;
8385: }
8386: }
8387:
8388: else { if (@expr1073764101 !@expr1073764102 Token ::@expr22136 Match (@expr1073764104 tok4@var3072 , "[&*]" ) ) {
8389: decl@var3071 =@expr1073764105 false ;
8390: break ;
8391: } } }
8392: }
8393: if (@expr1073764106 decl@var3071 ) {
8394: break ; }
8395: }
8396:
8397:
8398: if (@expr1073764107 Token ::@expr22136 Match (@expr1073764109 tok3@var3056 , "; %type% : ;" ) ) {
8399: break ; }
8400:
8401:
8402: if (@expr1073764110 Token ::@expr22136 Match (@expr1073764112 tok3@var3056 , "break|continue" ) ) {
8403: break ; }
8404: if (@expr1073764113 (@expr1073764114 indentlevel3@var3069 >@expr1073764115 1 ||@expr1073764116 !@expr1073764117 Token ::@expr22294 simpleMatch (@expr1073764119 Token ::@expr1073764120 findsimplematch (@expr1073764121 tok3@var3056 , ";" ) , "; }" ) ) &&@expr1073764122 tok3@var3056 .@expr22167 str (@expr22168 ) ==@expr1073764125 "return" ) {
8405: ret3@var3070 =@expr1073764126 true ; }
8406: if (@expr1073764127 ret3@var3070 &&@expr1073764128 tok3@var3056 .@expr22167 str (@expr22168 ) ==@expr1073764131 ";" ) {
8407: break ; }
8408:
8409: if (@expr1073764132 pointeralias@var3064 &&@expr1073764133 Token ::@expr22136 Match (@expr1073764135 tok3@var3056 , (@expr1073764136 "!!= " +@expr1073764137 value@var3059 ) .@expr1073764138 c_str (@expr1073764139 ) ) ) {
8410: break ; }
8411:
8412:
8413: if (@expr1073764140 pointeralias@var3064 &&@expr1073764141 Token ::@expr22136 Match (@expr1073764143 tok3@var3056 , "do|for|while" ) ) {
8414: break ; }
8415:
8416:
8417:
8418: if (@expr1073764144 varIsGlobal@var3065 &&@expr1073764145 tok3@var3056 .@expr22167 str (@expr22168 ) ==@expr1073764148 ")" &&@expr1073764149 tok3@var3056 .@expr22326 link (@expr22327 ) &&@expr1073764152
8419: Token ::@expr22136 Match (@expr1073764154 tok3@var3056 .@expr22326 link (@expr22327 ) .@expr1073764157 tokAt (@expr1073764158 -2 ) , "[;{}] %name% (" ) &&@expr1073764159
8420: !@expr1073764160 Token ::@expr22136 Match (@expr1073764162 tok3@var3056 .@expr22326 link (@expr22327 ) .@expr1073764165 previous (@expr1073764166 ) , "if|for|while|switch|BOOST_FOREACH" ) ) {
8421: break ; }
8422:
8423:
8424: if (@expr1073764167 Token ::@expr22136 Match (@expr1073764169 tok3@var3056 , "for|while|do" ) ) {
8425: const Token * endpar@var3073 ; endpar@var3073 =@expr1073764170 tok3@var3056 .@expr22164 next (@expr22165 ) .@expr1073764173 link (@expr1073764174 ) ;
8426: if (@expr1073764175 Token ::@expr22294 simpleMatch (@expr1073764177 endpar@var3073 , ") {" ) ) {
8427: endpar@var3073 =@expr1073764178 endpar@var3073 .@expr1073764179 next (@expr1073764180 ) .@expr1073764181 link (@expr1073764182 ) ; }
8428: bool bailout@var3074 ; bailout@var3074 =@expr1073764183 false ;
8429: for (@expr1073764184 const Token *@expr22259 tok4@var3075 =@expr1073764186 tok3@var3056 ; tok4@var3075 &&@expr1073764187 tok4@var3075 !=@expr1073764188 endpar@var3073 ; tok4@var3075 =@expr1073764189 tok4@var3075 .@expr1073764190 next (@expr1073764191 ) ) {
8430: if (@expr1073764192 Token ::@expr22136 Match (@expr1073764194 tok4@var3075 , "++|-- %varid%" , varid@var3057 ) ||@expr1073764195
8431: Token ::@expr22136 Match (@expr1073764197 tok4@var3075 , "%varid% ++|--|=" , varid@var3057 ) ) {
8432: bailout@var3074 =@expr1073764198 true ;
8433: break ;
8434: }
8435: }
8436: if (@expr1073764199 bailout@var3074 ) {
8437: break ; }
8438: }
8439:
8440: if (@expr1073764200 bailOutFromLoop@var3068 ) {
8441:
8442:
8443:
8444: if (@expr22377 tok3@var3056 .@expr22211 varId (@expr22212 ) ==@expr22380 varid@var3057 ) {
8445:
8446:
8447: break ;
8448: } else { if (@expr1073764205 tok3@var3056 ==@expr1073764206 bailOutFromLoop@var3068 ) {
8449:
8450: bailOutFromLoop@var3068 =@expr1073764207 nullptr ;
8451: continue ;
8452: } }
8453:
8454: continue ;
8455: } else { if (@expr1073764208 tok3@var3056 .@expr22167 str (@expr22168 ) ==@expr22169 "{" &&@expr1073764212 tok3@var3056 .@expr22215 previous (@expr22216 ) .@expr22226 str (@expr22227 ) ==@expr1073764217 ")" ) {
8456:
8457: if (@expr1073764218 tok3@var3056 .@expr22215 previous (@expr22216 ) .@expr22397 link (@expr22398 ) &&@expr1073764223
8458: tok3@var3056 .@expr22215 previous (@expr22216 ) .@expr22397 link (@expr22398 ) .@expr1073764228 strAt (@expr1073764229 -1 ) !=@expr1073764230 "if" ) {
8459: bailOutFromLoop@var3068 =@expr1073764231 tok3@var3056 .@expr22326 link (@expr22327 ) ; }
8460: continue ;
8461: } }
8462:
8463:
8464: if (@expr1073764234 Token ::@expr22136 Match (@expr1073764236 tok3@var3056 , "%name% = realloc ( %name% ," ) &&@expr1073764237
8465: tok3@var3056 .@expr22211 varId (@expr22212 ) ==@expr22380 varid@var3057 &&@expr1073764241
8466: tok3@var3056 .@expr22418 tokAt (@expr22419 4 ) .@expr1073764244 varId (@expr1073764245 ) ==@expr1073764246 varid@var3057 ) {
8467: tok3@var3056 .@expr22418 tokAt (@expr22419 4 ) .@expr1073764249 str (@expr1073764250 value@var3059 ) ;
8468: ret@var3067 =@expr1073764251 true ;
8469: }
8470:
8471:
8472: if (@expr1073764252 !@expr1073764253 Token ::@expr22136 Match (@expr1073764255 tok3@var3056 .@expr22215 previous (@expr22216 ) , "( %name% )" ) &&@expr1073764258
8473: Token ::@expr22136 Match (@expr1073764260 tok3@var3056 .@expr22215 previous (@expr22216 ) , "&&|(|%oror% %varid% &&|%oror%|)|;" , varid@var3057 ) ) {
8474: tok3@var3056 .@expr22167 str (@expr22440 value@var3059 ) ;
8475: tok3@var3056 .@expr22211 varId (@expr22442 valueVarId@var3060 ) ;
8476: ret@var3067 =@expr1073764267 true ;
8477: }
8478:
8479:
8480: if (@expr1073764268 tok3@var3056 .@expr22211 varId (@expr22212 ) ==@expr22380 varid@var3057 &&@expr1073764272 Token ::@expr22136 Match (@expr1073764274 tok3@var3056 .@expr22215 previous (@expr22216 ) , "[(,] %name% [,)]" ) ) {
8481:
8482: if (@expr1073764277 isFunctionParameterPassedByValue (@expr1073764278 tok3@var3056 ) ) {
8483: tok3@var3056 .@expr22167 str (@expr22440 value@var3059 ) ;
8484: tok3@var3056 .@expr22211 varId (@expr22442 valueVarId@var3060 ) ;
8485: ret@var3067 =@expr1073764283 true ;
8486: }
8487: }
8488:
8489:
8490: if (@expr22377 tok3@var3056 .@expr22211 varId (@expr22212 ) ==@expr22380 varid@var3057 ) {
8491:
8492:
8493: if (@expr1073764288 printDebug@var3066 ) {
8494:
8495:
8496: if (@expr1073764289 pointeralias@var3064 ) {
8497: break ; }
8498:
8499:
8500: if (@expr1073764290 Token ::@expr22136 Match (@expr1073764292 tok3@var3056 .@expr22164 next (@expr22165 ) , ". %name% (" ) ) {
8501: break ; }
8502:
8503:
8504: if (@expr1073764295 tok3@var3056 .@expr22472 strAt (@expr1073764297 1 ) ==@expr1073764298 "=" ) {
8505: break ; }
8506:
8507:
8508: if (@expr1073764299 Token ::@expr22136 Match (@expr1073764301 tok3@var3056 .@expr22418 tokAt (@expr22479 -2 ) , "return|= & %name% ;" ) ) {
8509: break ; }
8510:
8511:
8512: if (@expr1073764304 Token ::@expr22136 Match (@expr1073764306 tok3@var3056 .@expr22418 tokAt (@expr22479 -2 ) , "%name% ( %name% ,|)" ) ||@expr1073764309
8513: Token ::@expr22136 Match (@expr1073764311 tok3@var3056 .@expr22215 previous (@expr22216 ) , ", %name% ,|)" ) ) {
8514: break ; }
8515:
8516:
8517: if (@expr1073764314 Token ::@expr22136 Match (@expr1073764316 tok3@var3056 .@expr22418 tokAt (@expr1073764318 -3 ) , ") { ++|--" ) ||@expr1073764319
8518: Token ::@expr22136 Match (@expr1073764321 tok3@var3056 .@expr22418 tokAt (@expr22479 -2 ) , ") { %name% ++|--" ) ) {
8519: break ; }
8520:
8521: reportError (@expr1073764324 tok3@var3056 , Severity ::@expr1073764325 debug , "debug" ,
8522: "simplifyKnownVariables: bailing out (variable=" +@expr1073764326 tok3@var3056 .@expr22167 str (@expr22168 ) +@expr1073764329 ", value=" +@expr1073764330 value@var3059 +@expr1073764331 ")" ) ;
8523: }
8524:
8525: break ;
8526: }
8527:
8528:
8529: if (@expr1073764332 Token ::@expr22136 Match (@expr1073764334 tok3@var3056 .@expr22215 previous (@expr22216 ) , (@expr1073764337 "if ( " +@expr1073764338 structname@var3058 +@expr1073764339 " %varid% %cop%|)" ) .@expr1073764340 c_str (@expr1073764341 ) , varid@var3057 ) ||@expr1073764342
8530: Token ::@expr22136 Match (@expr1073764344 tok3@var3056 , (@expr1073764345 "( " +@expr1073764346 structname@var3058 +@expr1073764347 " %varid% %comp%" ) .@expr1073764348 c_str (@expr1073764349 ) , varid@var3057 ) ||@expr1073764350
8531: Token ::@expr22136 Match (@expr1073764352 tok3@var3056 , (@expr1073764353 "%comp%|!|= " +@expr1073764354 structname@var3058 +@expr1073764355 " %varid% %cop%|)|;" ) .@expr1073764356 c_str (@expr1073764357 ) , varid@var3057 ) ||@expr1073764358
8532: Token ::@expr22136 Match (@expr1073764360 tok3@var3056 .@expr22215 previous (@expr22216 ) , "strlen|free ( %varid% )" , varid@var3057 ) ) {
8533: if (@expr1073764363 value@var3059 [@expr22540 0 ] ==@expr22541 '\"' &&@expr1073764366 tok3@var3056 .@expr22215 previous (@expr22216 ) .@expr22226 str (@expr22227 ) !=@expr1073764371 "strlen" ) {
8534:
8535:
8536: break ;
8537: }
8538: if (@expr22548 !@expr22549 structname@var3058 .@expr22550 empty (@expr22551 ) ) {
8539: tok3@var3056 .@expr22552 deleteNext (@expr22553 2 ) ;
8540: }
8541: if (@expr22554 Token ::@expr22136 Match (@expr22556 valueToken@var3062 , "& %name% ;" ) ) {
8542: tok3@var3056 .@expr22557 insertToken (@expr1073764382 "&" ) ;
8543: tok3@var3056 =@expr1073764383 tok3@var3056 .@expr22164 next (@expr22165 ) ;
8544: }
8545: tok3@var3056 =@expr1073764386 tok3@var3056 .@expr22164 next (@expr22165 ) ;
8546: tok3@var3056 .@expr22167 str (@expr22440 value@var3059 ) ;
8547: tok3@var3056 .@expr22211 varId (@expr22442 valueVarId@var3060 ) ;
8548: ret@var3067 =@expr1073764393 true ;
8549: }
8550:
8551:
8552: if (@expr1073764394 Token ::@expr22136 Match (@expr22556 valueToken@var3062 , "& %name% ;" ) &&@expr1073764397 Token ::@expr22136 Match (@expr1073764399 tok3@var3056 , (@expr1073764400 "( * " +@expr1073764401 structname@var3058 +@expr1073764402 " %varid% %cop%" ) .@expr1073764403 c_str (@expr1073764404 ) , varid@var3057 ) ) {
8553: tok3@var3056 .@expr22552 deleteNext (@expr22582 ) ;
8554: if (@expr22548 !@expr22549 structname@var3058 .@expr22550 empty (@expr22551 ) ) {
8555: tok3@var3056 .@expr22552 deleteNext (@expr22553 2 ) ; }
8556: tok3@var3056 =@expr1073764413 tok3@var3056 .@expr22164 next (@expr22165 ) ;
8557: tok3@var3056 .@expr22167 str (@expr22440 value@var3059 ) ;
8558: tok3@var3056 .@expr22211 varId (@expr22442 valueVarId@var3060 ) ;
8559: ret@var3067 =@expr1073764420 true ;
8560: }
8561:
8562:
8563: if (@expr1073764421 isCPP (@expr22598 ) &&@expr1073764423 pointeralias@var3064 &&@expr1073764424 (@expr1073764425 tok3@var3056 .@expr22167 str (@expr22168 ) ==@expr1073764428 "delete" ) &&@expr1073764429 tok3@var3056 .@expr22164 next (@expr22165 ) &&@expr1073764432
8564: (@expr1073764433 Token ::@expr22136 Match (@expr1073764435 tok3@var3056 .@expr22164 next (@expr22165 ) , "%varid% ;" , varid@var3057 ) ||@expr1073764438
8565: Token ::@expr22136 Match (@expr1073764440 tok3@var3056 .@expr22164 next (@expr22165 ) , "[ ] %varid%" , varid@var3057 ) ) ) {
8566: tok3@var3056 =@expr1073764443 (@expr1073764444 tok3@var3056 .@expr22164 next (@expr22165 ) .@expr22623 str (@expr22624 ) ==@expr1073764449 "[" ) ?@expr1073764450 tok3@var3056 .@expr22418 tokAt (@expr22628 3 ) :@expr1073764453 tok3@var3056 .@expr22164 next (@expr22165 ) ;
8567: tok3@var3056 .@expr22167 str (@expr22440 value@var3059 ) ;
8568: tok3@var3056 .@expr22211 varId (@expr22442 valueVarId@var3060 ) ;
8569: ret@var3067 =@expr1073764460 true ;
8570: }
8571:
8572:
8573: if (@expr1073764461 Token ::@expr22136 Match (@expr1073764463 tok3@var3056 , (@expr1073764464 "%name% ( " +@expr1073764465 structname@var3058 +@expr1073764466 " %varid% ," ) .@expr1073764467 c_str (@expr1073764468 ) , varid@var3057 ) ) {
8574: static const char * const functionName@var3076 [@expr1073764469 9 ] =@expr1073764470 {@expr1073764471
8575:
8576: "strcmp" , "strdup" ,
8577:
8578: "memcmp" , "memcpy" , "memmove" , "memset" , "strcpy" , "strncmp" , "strncpy"
8579: } ;
8580: for (@expr1073764472 int i@var3077 =@expr1073764473 0 ; i@var3077 <@expr1073764474 (@expr1073764475 sizeof (@expr1073764476 functionName@var3076 ) /@expr1073764477 sizeof (@expr1073764478 *@expr1073764479 functionName@var3076 ) ) ; ++@expr1073764480 i@var3077 ) {
8581: if (@expr1073764481 valueVarId@var3060 ==@expr22658 0U &&@expr1073764483 i@var3077 >=@expr1073764484 2 ) {
8582: break ; }
8583: if (@expr1073764485 tok3@var3056 .@expr22167 str (@expr22168 ) ==@expr1073764488 functionName@var3076 [@expr1073764489 i@var3077 ] ) {
8584: Token * par1@var3078 ; par1@var3078 =@expr1073764490 tok3@var3056 .@expr22418 tokAt (@expr22668 2 ) ;
8585: if (@expr22548 !@expr22549 structname@var3058 .@expr22550 empty (@expr22551 ) ) {
8586: par1@var3078 .@expr1073764497 deleteNext (@expr1073764498 ) ;
8587: par1@var3078 .@expr1073764499 deleteThis (@expr1073764500 ) ;
8588: }
8589: par1@var3078 .@expr1073764501 str (@expr1073764502 value@var3059 ) ;
8590: par1@var3078 .@expr1073764503 varId (@expr1073764504 valueVarId@var3060 ) ;
8591: break ;
8592: }
8593: }
8594: }
8595:
8596:
8597: if (@expr1073764505 Token ::@expr22136 Match (@expr1073764507 tok3@var3056 , (@expr1073764508 "%name% ( %any% , " +@expr1073764509 structname@var3058 +@expr1073764510 " %varid% ,|)" ) .@expr1073764511 c_str (@expr1073764512 ) , varid@var3057 ) ) {
8598: static const char * const functionName@var3079 [@expr1073764513 7 ] =@expr1073764514 {@expr1073764515
8599:
8600: "strcmp" , "strcpy" , "strncmp" , "strncpy" ,
8601:
8602: "memcmp" , "memcpy" , "memmove"
8603: } ;
8604: for (@expr1073764516 int i@var3080 =@expr1073764517 0 ; i@var3080 <@expr1073764518 (@expr1073764519 sizeof (@expr1073764520 functionName@var3079 ) /@expr1073764521 sizeof (@expr1073764522 *@expr1073764523 functionName@var3079 ) ) ; ++@expr1073764524 i@var3080 ) {
8605: if (@expr1073764525 valueVarId@var3060 ==@expr22658 0U &&@expr1073764527 i@var3080 >=@expr1073764528 4 ) {
8606: break ; }
8607: if (@expr1073764529 tok3@var3056 .@expr22167 str (@expr22168 ) ==@expr1073764532 functionName@var3079 [@expr1073764533 i@var3080 ] ) {
8608: Token * par@var3081 ; par@var3081 =@expr1073764534 tok3@var3056 .@expr22418 tokAt (@expr22419 4 ) ;
8609: if (@expr22548 !@expr22549 structname@var3058 .@expr22550 empty (@expr22551 ) ) {
8610: par@var3081 .@expr1073764541 deleteNext (@expr1073764542 ) ;
8611: par@var3081 .@expr1073764543 deleteThis (@expr1073764544 ) ;
8612: }
8613: par@var3081 .@expr1073764545 str (@expr1073764546 value@var3059 ) ;
8614: par@var3081 .@expr1073764547 varId (@expr1073764548 valueVarId@var3060 ) ;
8615: break ;
8616: }
8617: }
8618: }
8619:
8620:
8621: if (@expr1073764549 value@var3059 [@expr22540 0 ] !=@expr22727 '\"' &&@expr1073764552 Token ::@expr22136 Match (@expr1073764554 tok3@var3056 , (@expr1073764555 "[(,] " +@expr1073764556 structname@var3058 +@expr1073764557 " %varid% [|%cop%" ) .@expr1073764558 c_str (@expr1073764559 ) , varid@var3057 ) ) {
8622: if (@expr22548 !@expr22549 structname@var3058 .@expr22550 empty (@expr22551 ) ) {
8623: tok3@var3056 .@expr22552 deleteNext (@expr22553 2 ) ;
8624: }
8625: tok3@var3056 =@expr1073764566 tok3@var3056 .@expr22164 next (@expr22165 ) ;
8626: tok3@var3056 .@expr22167 str (@expr22440 value@var3059 ) ;
8627: tok3@var3056 .@expr22211 varId (@expr22442 valueVarId@var3060 ) ;
8628: ret@var3067 =@expr1073764573 true ;
8629: }
8630:
8631:
8632: if (@expr1073764574 isCPP (@expr22598 ) &&@expr1073764576 Token ::@expr22136 Match (@expr1073764578 tok3@var3056 , (@expr1073764579 ">> " +@expr1073764580 structname@var3058 +@expr1073764581 " %varid%" ) .@expr1073764582 c_str (@expr1073764583 ) , varid@var3057 ) ) {
8633:
8634: const Token * prev@var3082 ; prev@var3082 =@expr1073764584 tok3@var3056 .@expr22215 previous (@expr22216 ) ;
8635: while (@expr1073764587 prev@var3082 &&@expr1073764588 prev@var3082 .@expr1073764589 str (@expr1073764590 ) !=@expr1073764591 "return" &&@expr1073764592 Token ::@expr22136 Match (@expr1073764594 prev@var3082 , "%name%|::|*" ) ) {
8636: prev@var3082 =@expr1073764595 prev@var3082 .@expr1073764596 previous (@expr1073764597 ) ; }
8637: if (@expr1073764598 Token ::@expr22136 Match (@expr1073764600 prev@var3082 , ";|{|}|>>" ) ) {
8638: break ; }
8639: }
8640:
8641:
8642: if (@expr1073764601 (@expr1073764602 (@expr1073764603 tok3@var3056 .@expr22215 previous (@expr22216 ) .@expr1073764606 varId (@expr1073764607 ) >@expr1073764608 0 ) &&@expr1073764609 Token ::@expr22136 Match (@expr1073764611 tok3@var3056 , (@expr1073764612 "& " +@expr1073764613 structname@var3058 +@expr1073764614 " %varid%" ) .@expr1073764615 c_str (@expr1073764616 ) , varid@var3057 ) ) ||@expr1073764617
8643: (@expr1073764618 Token ::@expr22136 Match (@expr1073764620 tok3@var3056 , (@expr1073764621 "[=+-*/%^|[] " +@expr1073764622 structname@var3058 +@expr1073764623 " %varid% [=?+-*/%^|;])]" ) .@expr1073764624 c_str (@expr1073764625 ) , varid@var3057 ) &&@expr1073764626 !@expr1073764627 Token ::@expr22136 Match (@expr1073764629 tok3@var3056 , (@expr1073764630 "= " +@expr1073764631 structname@var3058 +@expr1073764632 " %name% =" ) .@expr1073764633 c_str (@expr1073764634 ) ) ) ||@expr1073764635
8644: Token ::@expr22136 Match (@expr1073764637 tok3@var3056 , (@expr1073764638 "[(=+-*/%^|[] " +@expr1073764639 structname@var3058 +@expr1073764640 " %varid% <<|>>" ) .@expr1073764641 c_str (@expr1073764642 ) , varid@var3057 ) ||@expr1073764643
8645: Token ::@expr22136 Match (@expr1073764645 tok3@var3056 , (@expr1073764646 "<<|>> " +@expr1073764647 structname@var3058 +@expr1073764648 " %varid% %cop%|;|]|)" ) .@expr1073764649 c_str (@expr1073764650 ) , varid@var3057 ) ||@expr1073764651
8646: Token ::@expr22136 Match (@expr1073764653 tok3@var3056 .@expr22215 previous (@expr22216 ) , (@expr1073764656 "[=+-*/%^|[] ( " +@expr1073764657 structname@var3058 +@expr1073764658 " %varid% !!=" ) .@expr1073764659 c_str (@expr1073764660 ) , varid@var3057 ) ) {
8647: if (@expr1073764661 value@var3059 [@expr22540 0 ] ==@expr22541 '\"' ) {
8648: break ; }
8649: if (@expr22548 !@expr22549 structname@var3058 .@expr22550 empty (@expr22551 ) ) {
8650: tok3@var3056 .@expr22552 deleteNext (@expr22553 2 ) ;
8651: ret@var3067 =@expr1073764670 true ;
8652: }
8653: tok3@var3056 =@expr1073764671 tok3@var3056 .@expr22164 next (@expr22165 ) ;
8654: if (@expr1073764674 tok3@var3056 .@expr22167 str (@expr22168 ) !=@expr1073764677 value@var3059 ) {
8655: ret@var3067 =@expr1073764678 true ; }
8656: tok3@var3056 .@expr22167 str (@expr22440 value@var3059 ) ;
8657: tok3@var3056 .@expr22211 varId (@expr22442 valueVarId@var3060 ) ;
8658: if (@expr1073764683 tok3@var3056 .@expr22215 previous (@expr22216 ) .@expr22226 str (@expr22227 ) ==@expr22228 "*" &&@expr1073764689 (@expr1073764690 valueIsPointer@var3061 ||@expr1073764691 Token ::@expr22136 Match (@expr22556 valueToken@var3062 , "& %name% ;" ) ) ) {
8659: tok3@var3056 =@expr1073764694 tok3@var3056 .@expr22215 previous (@expr22216 ) ;
8660: tok3@var3056 .@expr1073764697 deleteThis (@expr1073764698 ) ;
8661: ret@var3067 =@expr1073764699 true ;
8662: } else { if (@expr22554 Token ::@expr22136 Match (@expr22556 valueToken@var3062 , "& %name% ;" ) ) {
8663: tok3@var3056 .@expr22557 insertToken (@expr1073764704 "&" , emptyString@var1 , true ) ; } }
8664: }
8665:
8666: if (@expr1073764705 Token ::@expr22294 simpleMatch (@expr1073764707 tok3@var3056 , "= {" ) ) {
8667: const Token * const end4@var3083 ; end4@var3083 =@expr1073764708 tok3@var3056 .@expr1073764709 linkAt (@expr1073764710 1 ) ;
8668: for (@expr1073764711 const Token *@expr22259 tok4@var3084 =@expr1073764713 tok3@var3056 ; tok4@var3084 !=@expr1073764714 end4@var3083 ; tok4@var3084 =@expr1073764715 tok4@var3084 .@expr22892 next (@expr22893 ) ) {
8669: if (@expr1073764718 Token ::@expr22136 Match (@expr1073764720 tok4@var3084 , "{|, %varid% ,|}" , varid@var3057 ) ) {
8670: tok4@var3084 .@expr22892 next (@expr22893 ) .@expr1073764723 str (@expr1073764724 value@var3059 ) ;
8671: tok4@var3084 .@expr22892 next (@expr22893 ) .@expr1073764727 varId (@expr1073764728 valueVarId@var3060 ) ;
8672: ret@var3067 =@expr1073764729 true ;
8673: }
8674: }
8675: }
8676:
8677:
8678: if (@expr1073764730 Token ::@expr22294 simpleMatch (@expr1073764732 tok3@var3056 , "for (" ) ) {
8679: for (@expr1073764733 Token *@expr22259 tok4@var3085 =@expr1073764735 tok3@var3056 .@expr22418 tokAt (@expr22668 2 ) ; tok4@var3085 ; tok4@var3085 =@expr1073764738 tok4@var3085 .@expr22915 next (@expr22916 ) ) {
8680: if (@expr1073764741 Token ::@expr22136 Match (@expr1073764743 tok4@var3085 , "(|)" ) ) {
8681: break ; }
8682:
8683:
8684: if (@expr1073764744 Token ::@expr22136 Match (@expr1073764746 tok4@var3085 , "; %name% <|<=|!= %name% ; ++| %name% ++| )" ) ) {
8685: const Token * inctok@var3086 ; inctok@var3086 =@expr1073764747 tok4@var3085 .@expr22924 tokAt (@expr1073764749 5 ) ;
8686: if (@expr1073764750 inctok@var3086 .@expr1073764751 str (@expr1073764752 ) ==@expr1073764753 "++" ) {
8687: inctok@var3086 =@expr1073764754 inctok@var3086 .@expr1073764755 next (@expr1073764756 ) ; }
8688: if (@expr1073764757 inctok@var3086 .@expr1073764758 varId (@expr1073764759 ) ==@expr1073764760 varid@var3057 ) {
8689: break ; }
8690:
8691: if (@expr1073764761 tok4@var3085 .@expr22915 next (@expr22916 ) .@expr22940 varId (@expr1073764765 ) ==@expr1073764766 varid@var3057 ) {
8692: tok4@var3085 .@expr22915 next (@expr22916 ) .@expr1073764769 str (@expr1073764770 value@var3059 ) ;
8693: tok4@var3085 .@expr22915 next (@expr22916 ) .@expr22940 varId (@expr1073764774 valueVarId@var3060 ) ;
8694: ret@var3067 =@expr1073764775 true ;
8695: }
8696: if (@expr1073764776 tok4@var3085 .@expr22924 tokAt (@expr22954 3 ) .@expr22955 varId (@expr1073764780 ) ==@expr1073764781 varid@var3057 ) {
8697: tok4@var3085 .@expr22924 tokAt (@expr22954 3 ) .@expr1073764784 str (@expr1073764785 value@var3059 ) ;
8698: tok4@var3085 .@expr22924 tokAt (@expr22954 3 ) .@expr22955 varId (@expr1073764789 valueVarId@var3060 ) ;
8699: ret@var3067 =@expr1073764790 true ;
8700: }
8701: }
8702: }
8703: }
8704:
8705: if (@expr1073764791 indentlevel@var3063 ==@expr22968 indentlevel3@var3069 &&@expr1073764793 Token ::@expr22136 Match (@expr1073764795 tok3@var3056 .@expr22164 next (@expr22165 ) , "%varid% ++|--" , varid@var3057 ) &&@expr1073764798 MathLib ::@expr22975 isInt (@expr22976 value@var3059 ) ) {
8706: const std ::@expr1073764801 string op@var3087 (@expr1073764802 tok3@var3056 .@expr22472 strAt (@expr22980 2 ) ) ;
8707: if (@expr1073764805 Token ::@expr22136 Match (@expr1073764807 tok3@var3056 , "[{};] %any% %any% ;" ) ) {
8708: tok3@var3056 .@expr22552 deleteNext (@expr22985 3 ) ;
8709: } else {
8710: tok3@var3056 =@expr1073764810 tok3@var3056 .@expr22164 next (@expr22165 ) ;
8711: tok3@var3056 .@expr22167 str (@expr22440 value@var3059 ) ;
8712: tok3@var3056 .@expr22211 varId (@expr22442 valueVarId@var3060 ) ;
8713: tok3@var3056 .@expr22552 deleteNext (@expr22582 ) ;
8714: }
8715: value@var3059 =@expr1073764819 MathLib ::@expr22996 incdec (@expr1073764821 value@var3059 , op@var3087 ) ;
8716: if (@expr1073764822 !@expr1073764823 Token ::@expr22294 simpleMatch (@expr1073764825 (@expr22181 *@expr22182 tok2@var3055 ) .@expr22183 tokAt (@expr1073764829 -2 ) , "for (" ) ) {
8717: (@expr22181 *@expr22182 tok2@var3055 ) .@expr22183 tokAt (@expr23009 2 ) .@expr23010 str (@expr23011 value@var3059 ) ;
8718: (@expr22181 *@expr22182 tok2@var3055 ) .@expr22183 tokAt (@expr23009 2 ) .@expr23016 varId (@expr23017 valueVarId@var3060 ) ;
8719: }
8720: ret@var3067 =@expr1073764842 true ;
8721: }
8722:
8723: if (@expr1073764843 indentlevel@var3063 ==@expr22968 indentlevel3@var3069 &&@expr1073764845 Token ::@expr22136 Match (@expr1073764847 tok3@var3056 .@expr22164 next (@expr22165 ) , "++|-- %varid%" , varid@var3057 ) &&@expr1073764850 MathLib ::@expr22975 isInt (@expr22976 value@var3059 ) &&@expr1073764853
8724: !@expr1073764854 Token ::@expr22136 Match (@expr1073764856 tok3@var3056 .@expr22418 tokAt (@expr22628 3 ) , "[.[]" ) ) {
8725: value@var3059 =@expr1073764859 MathLib ::@expr22996 incdec (@expr1073764861 value@var3059 , tok3@var3056 .@expr22164 next (@expr22165 ) .@expr22623 str (@expr22624 ) ) ;
8726: (@expr22181 *@expr22182 tok2@var3055 ) .@expr22183 tokAt (@expr23009 2 ) .@expr23010 str (@expr23011 value@var3059 ) ;
8727: (@expr22181 *@expr22182 tok2@var3055 ) .@expr22183 tokAt (@expr23009 2 ) .@expr23016 varId (@expr23017 valueVarId@var3060 ) ;
8728: if (@expr1073764878 Token ::@expr22136 Match (@expr1073764880 tok3@var3056 , "[;{}] %any% %any% ;" ) ) {
8729: tok3@var3056 .@expr22552 deleteNext (@expr22985 3 ) ;
8730: } else {
8731: tok3@var3056 .@expr22552 deleteNext (@expr22582 ) ;
8732: tok3@var3056 .@expr22164 next (@expr22165 ) .@expr22623 str (@expr23064 value@var3059 ) ;
8733: tok3@var3056 .@expr22164 next (@expr22165 ) .@expr23067 varId (@expr23068 valueVarId@var3060 ) ;
8734: }
8735: tok3@var3056 =@expr1073764893 tok3@var3056 .@expr22164 next (@expr22165 ) ;
8736: ret@var3067 =@expr1073764896 true ;
8737: }
8738:
8739:
8740: if (@expr1073764897 Token ::@expr22136 Match (@expr1073764899 tok3@var3056 , "return %varid% %any%" , varid@var3057 ) &&@expr1073764900
8741: valueToken@var3062 .@expr22230 str (@expr22231 ) !=@expr1073764903 "&" &&@expr1073764904
8742: (@expr1073764905 tok3@var3056 .@expr22418 tokAt (@expr22668 2 ) .@expr1073764908 isExtendedOp (@expr1073764909 ) ||@expr1073764910 tok3@var3056 .@expr22472 strAt (@expr22980 2 ) ==@expr1073764913 ";" ) &&@expr1073764914
8743: value@var3059 [@expr22540 0 ] !=@expr22727 '\"' ) {
8744: tok3@var3056 .@expr22164 next (@expr22165 ) .@expr22623 str (@expr23064 value@var3059 ) ;
8745: tok3@var3056 .@expr22164 next (@expr22165 ) .@expr23067 varId (@expr23068 valueVarId@var3060 ) ;
8746: }
8747:
8748: else { if (@expr1073764925 pointeralias@var3064 &&@expr1073764926 Token ::@expr22136 Match (@expr1073764928 tok3@var3056 , "return * %varid% ;" , varid@var3057 ) &&@expr1073764929 value@var3059 [@expr22540 0 ] !=@expr22727 '\"' ) {
8749: tok3@var3056 .@expr22552 deleteNext (@expr22582 ) ;
8750: tok3@var3056 .@expr22164 next (@expr22165 ) .@expr22623 str (@expr23064 value@var3059 ) ;
8751: tok3@var3056 .@expr22164 next (@expr22165 ) .@expr23067 varId (@expr23068 valueVarId@var3060 ) ;
8752: } }
8753: }
8754: return ret@var3067 ;
8755: }
8756:
8757:
8758: void Tokenizer :: elseif ( )
8759: {
8760: for (@expr1073764942 Token *@expr23119 tok@var3088 =@expr1073764944 list@var872 .@expr1073764945 front (@expr1073764946 ) ; tok@var3088 ; tok@var3088 =@expr1073764947 tok@var3088 .@expr23124 next (@expr23125 ) ) {
8761: if (@expr1073764950 !@expr1073764951 Token ::@expr1073764952 simpleMatch (@expr1073764953 tok@var3088 , "else if" ) ) {
8762: continue ; }
8763:
8764: for (@expr1073764954 Token *@expr23119 tok2@var3089 =@expr1073764956 tok@var3088 ; tok2@var3089 ; tok2@var3089 =@expr1073764957 tok2@var3089 .@expr23134 next (@expr23135 ) ) {
8765: if (@expr1073764960 Token ::@expr23137 Match (@expr1073764962 tok2@var3089 , "(|{|[" ) ) {
8766: tok2@var3089 =@expr1073764963 tok2@var3089 .@expr1073764964 link (@expr1073764965 ) ; }
8767:
8768: if (@expr1073764966 Token ::@expr23137 Match (@expr1073764968 tok2@var3089 , "}|;" ) ) {
8769: if (@expr1073764969 tok2@var3089 .@expr23134 next (@expr23135 ) &&@expr1073764972 tok2@var3089 .@expr23134 next (@expr23135 ) .@expr1073764975 str (@expr1073764976 ) !=@expr1073764977 "else" ) {
8770: tok@var3088 .@expr1073764978 insertToken (@expr1073764979 "{" ) ;
8771: tok2@var3089 .@expr1073764980 insertToken (@expr1073764981 "}" ) ;
8772: Token ::@expr1073764982 createMutualLinks (@expr1073764983 tok@var3088 .@expr23124 next (@expr23125 ) , tok2@var3089 .@expr23134 next (@expr23135 ) ) ;
8773: break ;
8774: }
8775: }
8776: }
8777: }
8778: }
8779:
8780:
8781: void Tokenizer :: simplifyIfSwitchForInit ( )
8782: {
8783: if (@expr1073764988 !@expr1073764989 isCPP (@expr1073764990 ) ||@expr1073764991 mSettings@var879 .@expr23168 standards@var3567 .@expr23169 cpp@var3568 <@expr1073764994 Standards ::@expr1073764995 CPP17 ) {
8784: return ; }
8785:
8786: const bool forInit@var3090 =@expr1073764996 mSettings@var879 .@expr23168 standards@var3567 .@expr23169 cpp@var3568 >=@expr1073764999 Standards ::@expr1073765000 CPP20 ;
8787:
8788: for (@expr1073765001 Token *@expr1073765002 tok@var3091 =@expr1073765003 list@var872 .@expr1073765004 front (@expr1073765005 ) ; tok@var3091 ; tok@var3091 =@expr1073765006 tok@var3091 .@expr1073765007 next (@expr1073765008 ) ) {
8789: if (@expr1073765009 !@expr1073765010 Token ::@expr23187 Match (@expr1073765012 tok@var3091 , "if|switch|for (" ) ) {
8790: continue ; }
8791:
8792: Token * semicolon@var3092 ; semicolon@var3092 =@expr1073765013 tok@var3091 .@expr1073765014 tokAt (@expr1073765015 2 ) ;
8793: while (@expr1073765016 !@expr1073765017 Token ::@expr23187 Match (@expr1073765019 semicolon@var3092 , "[;)]" ) ) {
8794: if (@expr1073765020 Token ::@expr23187 Match (@expr1073765022 semicolon@var3092 , "(|{|[" ) &&@expr1073765023 semicolon@var3092 .@expr23200 link (@expr23201 ) ) {
8795: semicolon@var3092 =@expr1073765026 semicolon@var3092 .@expr23200 link (@expr23201 ) ; }
8796: semicolon@var3092 =@expr1073765029 semicolon@var3092 .@expr23206 next (@expr23207 ) ;
8797: }
8798: if (@expr1073765032 semicolon@var3092 .@expr1073765033 str (@expr1073765034 ) !=@expr1073765035 ";" ) {
8799: continue ; }
8800:
8801: if (@expr1073765036 tok@var3091 .@expr23213 str (@expr23214 ) ==@expr1073765039 "for" ) {
8802: if (@expr1073765040 !@expr1073765041 forInit@var3090 ) {
8803: continue ; }
8804:
8805:
8806: const Token * tok2@var3093 ; tok2@var3093 =@expr1073765042 semicolon@var3092 .@expr23206 next (@expr23207 ) ;
8807: bool rangeFor@var3094 ; rangeFor@var3094 =@expr1073765045 false ;
8808: while (@expr1073765046 !@expr1073765047 Token ::@expr23187 Match (@expr1073765049 tok2@var3093 , "[;)]" ) ) {
8809: if (@expr1073765050 tok2@var3093 .@expr23227 str (@expr23228 ) ==@expr1073765053 "(" ) {
8810: tok2@var3093 =@expr1073765054 tok2@var3093 .@expr1073765055 link (@expr1073765056 ) ; }
8811: else { if (@expr1073765057 !@expr23234 rangeFor@var3094 &&@expr1073765059 tok2@var3093 .@expr23227 str (@expr23228 ) ==@expr1073765062 "?" ) {
8812: break ; }
8813: else { if (@expr1073765063 tok2@var3093 .@expr23227 str (@expr23228 ) ==@expr1073765066 ":" ) {
8814: rangeFor@var3094 =@expr1073765067 true ; } } }
8815: tok2@var3093 =@expr1073765068 tok2@var3093 .@expr1073765069 next (@expr1073765070 ) ;
8816: }
8817: if (@expr1073765071 !@expr23234 rangeFor@var3094 ||@expr1073765073 tok2@var3093 .@expr23227 str (@expr23228 ) !=@expr1073765076 ")" ) {
8818: continue ; }
8819: }
8820:
8821: Token * endpar@var3095 ; endpar@var3095 =@expr1073765077 tok@var3091 .@expr1073765078 linkAt (@expr1073765079 1 ) ;
8822: if (@expr1073765080 !@expr1073765081 Token ::@expr23258 simpleMatch (@expr1073765083 endpar@var3095 , ") {" ) ) {
8823: continue ; }
8824:
8825: Token * endscope@var3096 ; endscope@var3096 =@expr1073765084 endpar@var3095 .@expr1073765085 linkAt (@expr1073765086 1 ) ;
8826: if (@expr1073765087 Token ::@expr23258 simpleMatch (@expr1073765089 endscope@var3096 , "} else {" ) ) {
8827: endscope@var3096 =@expr1073765090 endscope@var3096 .@expr1073765091 linkAt (@expr1073765092 2 ) ; }
8828:
8829:
8830: semicolon@var3092 .@expr1073765093 insertToken (@expr1073765094 tok@var3091 .@expr23213 str (@expr23214 ) ) ;
8831: semicolon@var3092 .@expr23206 next (@expr23207 ) .@expr1073765099 insertToken (@expr1073765100 "(" ) ;
8832: Token ::@expr23277 createMutualLinks (@expr1073765102 semicolon@var3092 .@expr23206 next (@expr23207 ) .@expr1073765105 next (@expr1073765106 ) , endpar@var3095 ) ;
8833: tok@var3091 .@expr1073765107 deleteNext (@expr1073765108 ) ;
8834: tok@var3091 .@expr23213 str (@expr1073765110 "{" ) ;
8835: endscope@var3096 .@expr1073765111 insertToken (@expr1073765112 "}" ) ;
8836: Token ::@expr23277 createMutualLinks (@expr1073765114 tok@var3091 , endscope@var3096 .@expr1073765115 next (@expr1073765116 ) ) ;
8837: tok@var3091 .@expr1073765117 isSimplifiedScope (@expr1073765118 true ) ;
8838: }
8839: }
8840:
8841:
8842: bool Tokenizer :: simplifyRedundantParentheses ( )
8843: {
8844: bool ret@var3097 ; ret@var3097 =@expr1073765119 false ;
8845: for (@expr1073765120 Token *@expr23297 tok@var3098 =@expr1073765122 list@var872 .@expr1073765123 front (@expr1073765124 ) ; tok@var3098 ; tok@var3098 =@expr1073765125 tok@var3098 .@expr23302 next (@expr23303 ) ) {
8846: if (@expr1073765128 tok@var3098 .@expr1073765129 str (@expr1073765130 ) !=@expr1073765131 "(" ) {
8847: continue ; }
8848:
8849: if (@expr1073765132 isCPP (@expr23309 ) &&@expr1073765134 Token ::@expr23311 simpleMatch (@expr1073765136 tok@var3098 .@expr23313 previous (@expr23314 ) , "} (" ) ) {
8850: const Token * plp@var3099 ; plp@var3099 =@expr1073765139 tok@var3098 .@expr23313 previous (@expr23314 ) .@expr1073765142 link (@expr1073765143 ) .@expr1073765144 previous (@expr1073765145 ) ;
8851: if (@expr1073765146 Token ::@expr23323 Match (@expr1073765148 plp@var3099 , "%name%|>|] {" ) ||@expr1073765149 (@expr1073765150 Token ::@expr23311 simpleMatch (@expr1073765152 plp@var3099 , ")" ) &&@expr1073765153 Token ::@expr23311 simpleMatch (@expr1073765155 plp@var3099 .@expr1073765156 link (@expr1073765157 ) .@expr1073765158 previous (@expr1073765159 ) , "]" ) ) ) {
8852: continue ; }
8853: }
8854:
8855: if (@expr1073765160 Token ::@expr23311 simpleMatch (@expr1073765162 tok@var3098 , "( {" ) ) {
8856: continue ; }
8857:
8858: if (@expr1073765163 Token ::@expr23323 Match (@expr1073765165 tok@var3098 .@expr23342 link (@expr23343 ) , ") %num%" ) ) {
8859: tok@var3098 =@expr1073765168 tok@var3098 .@expr23342 link (@expr23343 ) ;
8860: continue ;
8861: }
8862:
8863:
8864: if (@expr1073765171 Token ::@expr23323 Match (@expr1073765173 tok@var3098 .@expr23313 previous (@expr23314 ) , "%op% (" ) ||@expr1073765176 Token ::@expr23323 Match (@expr1073765178 tok@var3098 .@expr23342 link (@expr23343 ) , ") %op%" ) ) {
8865: bool innerComma@var3100 ; innerComma@var3100 =@expr1073765181 false ;
8866: for (@expr1073765182 const Token *@expr23297 inner@var3101 =@expr1073765184 tok@var3098 .@expr23342 link (@expr23343 ) .@expr23363 previous (@expr23364 ) ; inner@var3101 !=@expr1073765189 tok@var3098 ; inner@var3101 =@expr1073765190 inner@var3101 .@expr1073765191 previous (@expr1073765192 ) ) {
8867: if (@expr1073765193 inner@var3101 .@expr23370 str (@expr23371 ) ==@expr1073765196 ")" ) {
8868: inner@var3101 =@expr1073765197 inner@var3101 .@expr1073765198 link (@expr1073765199 ) ; }
8869: if (@expr1073765200 inner@var3101 .@expr23370 str (@expr23371 ) ==@expr1073765203 "," ) {
8870: innerComma@var3100 =@expr1073765204 true ;
8871: break ;
8872: }
8873: }
8874: if (@expr1073765205 innerComma@var3100 ) {
8875: continue ; }
8876: }
8877:
8878:
8879: if (@expr1073765206 tok@var3098 .@expr23383 strAt (@expr23384 -2 ) !=@expr23385 "operator" &&@expr1073765210
8880: tok@var3098 .@expr23313 previous (@expr23314 ) &&@expr1073765213 tok@var3098 .@expr23313 previous (@expr23314 ) .@expr23392 str (@expr23393 ) ==@expr1073765218 "=" &&@expr1073765219
8881: tok@var3098 .@expr23302 next (@expr23303 ) &&@expr1073765222 tok@var3098 .@expr23302 next (@expr23303 ) .@expr1073765225 str (@expr1073765226 ) !=@expr1073765227 "{" &&@expr1073765228
8882: Token ::@expr23311 simpleMatch (@expr1073765230 tok@var3098 .@expr23342 link (@expr23343 ) , ") ;" ) ) {
8883: tok@var3098 .@expr23342 link (@expr23343 ) .@expr23411 deleteThis (@expr23412 ) ;
8884: tok@var3098 .@expr23413 deleteThis (@expr23414 ) ;
8885: continue ;
8886: }
8887:
8888: while (@expr1073765239 Token ::@expr23311 simpleMatch (@expr1073765241 tok@var3098 , "( (" ) &&@expr1073765242
8889: tok@var3098 .@expr23342 link (@expr23343 ) &&@expr1073765245 tok@var3098 .@expr23342 link (@expr23343 ) .@expr23363 previous (@expr23364 ) ==@expr1073765250 tok@var3098 .@expr23302 next (@expr23303 ) .@expr1073765253 link (@expr1073765254 ) ) {
8890:
8891:
8892: tok@var3098 .@expr23431 deleteNext (@expr23432 ) ;
8893: tok@var3098 .@expr23342 link (@expr23343 ) .@expr1073765259 tokAt (@expr1073765260 -2 ) .@expr1073765261 deleteNext (@expr1073765262 ) ;
8894: ret@var3097 =@expr1073765263 true ;
8895: }
8896:
8897: if (@expr1073765264 isCPP (@expr23309 ) &&@expr1073765266 Token ::@expr23323 Match (@expr1073765268 tok@var3098 .@expr23445 tokAt (@expr23446 -2 ) , "[;{}=(] new (" ) &&@expr1073765271 Token ::@expr23323 Match (@expr1073765273 tok@var3098 .@expr23342 link (@expr23343 ) , ") [;,{}[]" ) ) {
8898:
8899: tok@var3098 .@expr23342 link (@expr23343 ) .@expr23411 deleteThis (@expr23412 ) ;
8900: tok@var3098 .@expr23413 deleteThis (@expr23414 ) ;
8901: ret@var3097 =@expr1073765282 true ;
8902: }
8903:
8904: if (@expr1073765283 Token ::@expr23323 Match (@expr1073765285 tok@var3098 .@expr23313 previous (@expr23314 ) , "! ( %name% )" ) ) {
8905:
8906: tok@var3098 .@expr23413 deleteThis (@expr23414 ) ;
8907: tok@var3098 .@expr23431 deleteNext (@expr23432 ) ;
8908: ret@var3097 =@expr1073765292 true ;
8909: }
8910:
8911: if (@expr1073765293 Token ::@expr23323 Match (@expr1073765295 tok@var3098 .@expr23313 previous (@expr23314 ) , "[(,;{}] ( %name% ) ." ) ) {
8912:
8913: tok@var3098 .@expr23413 deleteThis (@expr23414 ) ;
8914: tok@var3098 .@expr23431 deleteNext (@expr23432 ) ;
8915: ret@var3097 =@expr1073765302 true ;
8916: }
8917:
8918: if (@expr1073765303 Token ::@expr23323 Match (@expr1073765305 tok@var3098 .@expr23313 previous (@expr23314 ) , "[(,;{}] ( %name% (" ) &&@expr1073765308
8919: tok@var3098 .@expr23342 link (@expr23343 ) .@expr23363 previous (@expr23364 ) ==@expr1073765313 tok@var3098 .@expr1073765314 linkAt (@expr1073765315 2 ) ) {
8920:
8921:
8922: tok@var3098 .@expr23342 link (@expr23343 ) .@expr23411 deleteThis (@expr23412 ) ;
8923: tok@var3098 .@expr23413 deleteThis (@expr23414 ) ;
8924: ret@var3097 =@expr1073765322 true ;
8925: }
8926:
8927: if (@expr1073765323 Token ::@expr23323 Match (@expr1073765325 tok@var3098 .@expr23313 previous (@expr23314 ) , "[,;{}] ( delete [| ]| %name% ) ;" ) ) {
8928:
8929:
8930: tok@var3098 .@expr23342 link (@expr23343 ) .@expr23411 deleteThis (@expr23412 ) ;
8931: tok@var3098 .@expr23413 deleteThis (@expr23414 ) ;
8932: ret@var3097 =@expr1073765334 true ;
8933: }
8934:
8935: if (@expr1073765335 !@expr1073765336 Token ::@expr23311 simpleMatch (@expr1073765338 tok@var3098 .@expr23445 tokAt (@expr23446 -2 ) , "operator delete" ) &&@expr1073765341
8936: Token ::@expr23323 Match (@expr1073765343 tok@var3098 .@expr23313 previous (@expr23314 ) , "delete|; (" ) &&@expr1073765346
8937: (@expr1073765347 tok@var3098 .@expr23313 previous (@expr23314 ) .@expr23392 str (@expr23393 ) !=@expr1073765352 "delete" ||@expr1073765353 tok@var3098 .@expr23302 next (@expr23303 ) .@expr23532 varId (@expr23533 ) >@expr1073765358 0 ) &&@expr1073765359
8938: Token ::@expr23323 Match (@expr1073765361 tok@var3098 .@expr23342 link (@expr23343 ) , ") ;|," ) ) {
8939: tok@var3098 .@expr23342 link (@expr23343 ) .@expr23411 deleteThis (@expr23412 ) ;
8940: tok@var3098 .@expr23413 deleteThis (@expr23414 ) ;
8941: ret@var3097 =@expr1073765370 true ;
8942: }
8943:
8944: if (@expr1073765371 Token ::@expr23323 Match (@expr1073765373 tok@var3098 .@expr23313 previous (@expr23314 ) , "[(!*;{}] ( %name% )" ) &&@expr1073765376
8945: (@expr1073765377 tok@var3098 .@expr23302 next (@expr23303 ) .@expr23532 varId (@expr23533 ) !=@expr1073765382 0 ||@expr1073765383 Token ::@expr23323 Match (@expr1073765385 tok@var3098 .@expr23445 tokAt (@expr1073765387 3 ) , "[+-/=]" ) ) &&@expr1073765388 !@expr1073765389 tok@var3098 .@expr23302 next (@expr23303 ) .@expr1073765392 isStandardType (@expr1073765393 ) ) {
8946:
8947: tok@var3098 .@expr23413 deleteThis (@expr23414 ) ;
8948: tok@var3098 .@expr23431 deleteNext (@expr23432 ) ;
8949: ret@var3097 =@expr1073765398 true ;
8950: }
8951:
8952: while (@expr1073765399 Token ::@expr23323 Match (@expr1073765401 tok@var3098 .@expr23313 previous (@expr23314 ) , "[;{}[(,!*] ( %name% ." ) ) {
8953: Token * tok2@var3102 ; tok2@var3102 =@expr1073765404 tok@var3098 .@expr23445 tokAt (@expr1073765406 2 ) ;
8954: while (@expr1073765407 Token ::@expr23323 Match (@expr1073765409 tok2@var3102 , ". %name%" ) ) {
8955: tok2@var3102 =@expr1073765410 tok2@var3102 .@expr1073765411 tokAt (@expr1073765412 2 ) ;
8956: }
8957: if (@expr1073765413 tok2@var3102 !=@expr1073765414 tok@var3098 .@expr23342 link (@expr23343 ) ) {
8958: break ; }
8959:
8960: tok@var3098 =@expr1073765417 tok@var3098 .@expr23313 previous (@expr23314 ) ;
8961: tok@var3098 .@expr23431 deleteNext (@expr23432 ) ;
8962: tok2@var3102 .@expr1073765422 deleteThis (@expr1073765423 ) ;
8963: ret@var3097 =@expr1073765424 true ;
8964: }
8965:
8966: if (@expr1073765425 Token ::@expr23311 simpleMatch (@expr1073765427 tok@var3098 .@expr23313 previous (@expr23314 ) , "? (" ) &&@expr1073765430 Token ::@expr23311 simpleMatch (@expr1073765432 tok@var3098 .@expr23342 link (@expr23343 ) , ") :" ) ) {
8967: const Token * tok2@var3103 ; tok2@var3103 =@expr1073765435 tok@var3098 .@expr23302 next (@expr23303 ) ;
8968: while (@expr1073765438 tok2@var3103 &&@expr1073765439 (@expr1073765440 Token ::@expr23323 Match (@expr1073765442 tok2@var3103 , "%bool%|%num%|%name%" ) ||@expr1073765443 tok2@var3103 .@expr1073765444 isArithmeticalOp (@expr1073765445 ) ) ) {
8969: tok2@var3103 =@expr1073765446 tok2@var3103 .@expr1073765447 next (@expr1073765448 ) ; }
8970: if (@expr1073765449 tok2@var3103 &&@expr1073765450 tok2@var3103 .@expr1073765451 str (@expr1073765452 ) ==@expr1073765453 ")" ) {
8971: tok@var3098 .@expr23342 link (@expr23343 ) .@expr23411 deleteThis (@expr23412 ) ;
8972: tok@var3098 .@expr23413 deleteThis (@expr23414 ) ;
8973: ret@var3097 =@expr1073765460 true ;
8974: continue ;
8975: }
8976: }
8977:
8978: while (@expr1073765461 Token ::@expr23323 Match (@expr1073765463 tok@var3098 .@expr23313 previous (@expr23314 ) , "[{([,] ( !!{" ) &&@expr1073765466
8979: Token ::@expr23323 Match (@expr1073765468 tok@var3098 .@expr23342 link (@expr23343 ) , ") [;,])]" ) &&@expr1073765471
8980: !@expr1073765472 Token ::@expr23311 simpleMatch (@expr1073765474 tok@var3098 .@expr23445 tokAt (@expr23446 -2 ) , "operator ," ) &&@expr1073765477
8981: !@expr1073765478 Token ::@expr1073765479 findsimplematch (@expr1073765480 tok@var3098 , "," , tok@var3098 .@expr23342 link (@expr23343 ) ) ) {
8982:
8983: tok@var3098 .@expr23342 link (@expr23343 ) .@expr23411 deleteThis (@expr23412 ) ;
8984: tok@var3098 .@expr23413 deleteThis (@expr23414 ) ;
8985: ret@var3097 =@expr1073765489 true ;
8986: }
8987:
8988: if (@expr1073765490 Token ::@expr23311 simpleMatch (@expr1073765492 tok@var3098 .@expr23313 previous (@expr23314 ) , ", (" ) &&@expr1073765495
8989: Token ::@expr23311 simpleMatch (@expr1073765497 tok@var3098 .@expr23342 link (@expr23343 ) , ") =" ) ) {
8990: tok@var3098 .@expr23342 link (@expr23343 ) .@expr23411 deleteThis (@expr23412 ) ;
8991: tok@var3098 .@expr23413 deleteThis (@expr23414 ) ;
8992: ret@var3097 =@expr1073765506 true ;
8993: }
8994:
8995:
8996: if (@expr1073765507 Token ::@expr23323 Match (@expr1073765509 tok@var3098 , "( %bool%|%num% ) %cop%|;|,|)" ) &&@expr1073765510
8997: tok@var3098 .@expr23383 strAt (@expr23384 -2 ) !=@expr23385 "operator" &&@expr1073765514
8998: tok@var3098 .@expr23313 previous (@expr23314 ) &&@expr1073765517
8999: !@expr1073765518 Token ::@expr23323 Match (@expr1073765520 tok@var3098 .@expr23313 previous (@expr23314 ) , "%name%|)|]" ) &&@expr1073765523
9000: (@expr1073765524 !@expr1073765525 (@expr1073765526 isCPP (@expr23309 ) &&@expr1073765528 Token ::@expr23323 Match (@expr1073765530 tok@var3098 .@expr23313 previous (@expr23314 ) , ">|>>" ) ) ) ) {
9001: tok@var3098 .@expr23342 link (@expr23343 ) .@expr23411 deleteThis (@expr23412 ) ;
9002: tok@var3098 .@expr23413 deleteThis (@expr23414 ) ;
9003: ret@var3097 =@expr1073765539 true ;
9004: }
9005:
9006: if (@expr1073765540 Token ::@expr23323 Match (@expr1073765542 tok@var3098 .@expr23313 previous (@expr23314 ) , "*|& ( %name% )" ) ) {
9007:
9008: Token * tok2@var3104 ; tok2@var3104 =@expr1073765545 tok@var3098 .@expr23445 tokAt (@expr23446 -2 ) ;
9009: while (@expr1073765548 Token ::@expr23323 Match (@expr1073765550 tok2@var3104 , "%type%|static|const|extern" ) &&@expr1073765551 tok2@var3104 .@expr1073765552 str (@expr1073765553 ) !=@expr1073765554 "operator" ) {
9010: tok2@var3104 =@expr1073765555 tok2@var3104 .@expr1073765556 previous (@expr1073765557 ) ;
9011: }
9012: if (@expr1073765558 tok2@var3104 &&@expr1073765559 !@expr1073765560 Token ::@expr23323 Match (@expr1073765562 tok2@var3104 , "[;,{]" ) ) {
9013:
9014: } else {
9015: tok@var3098 .@expr23413 deleteThis (@expr23414 ) ;
9016: tok@var3098 .@expr23431 deleteNext (@expr23432 ) ;
9017: }
9018: }
9019: }
9020: return ret@var3097 ;
9021: }
9022:
9023: void Tokenizer :: simplifyTypeIntrinsics ( )
9024: {
9025: static const std ::@expr1073765567 unordered_map < std ::@expr23744 string , std ::@expr23744 string > intrinsics@var3105 =@expr1073765570 {@expr1073765571
9026: {@expr1073765572 "__has_nothrow_assign" , "has_nothrow_assign" } ,
9027: {@expr1073765573 "__has_nothrow_constructor" , "has_nothrow_constructor" } ,
9028: {@expr1073765574 "__has_nothrow_copy" , "has_nothrow_copy" } ,
9029: {@expr1073765575 "__has_trivial_assign" , "has_trivial_assign" } ,
9030: {@expr1073765576 "__has_trivial_constructor" , "has_trivial_constructor" } ,
9031: {@expr1073765577 "__has_trivial_copy" , "has_trivial_copy" } ,
9032: {@expr1073765578 "__has_trivial_destructor" , "has_trivial_destructor" } ,
9033: {@expr1073765579 "__has_virtual_destructor" , "has_virtual_destructor" } ,
9034: {@expr1073765580 "__is_abstract" , "is_abstract" } ,
9035: {@expr1073765581 "__is_aggregate" , "is_aggregate" } ,
9036: {@expr1073765582 "__is_assignable" , "is_assignable" } ,
9037: {@expr1073765583 "__is_base_of" , "is_base_of" } ,
9038: {@expr1073765584 "__is_class" , "is_class" } ,
9039: {@expr1073765585 "__is_constructible" , "is_constructible" } ,
9040: {@expr1073765586 "__is_convertible_to" , "is_convertible_to" } ,
9041: {@expr1073765587 "__is_destructible" , "is_destructible" } ,
9042: {@expr1073765588 "__is_empty" , "is_empty" } ,
9043: {@expr1073765589 "__is_enum" , "is_enum" } ,
9044: {@expr1073765590 "__is_final" , "is_final" } ,
9045: {@expr1073765591 "__is_nothrow_assignable" , "is_nothrow_assignable" } ,
9046: {@expr1073765592 "__is_nothrow_constructible" , "is_nothrow_constructible" } ,
9047: {@expr1073765593 "__is_nothrow_destructible" , "is_nothrow_destructible" } ,
9048: {@expr1073765594 "__is_pod" , "is_pod" } ,
9049: {@expr1073765595 "__is_polymorphic" , "is_polymorphic" } ,
9050: {@expr1073765596 "__is_trivially_assignable" , "is_trivially_assignable" } ,
9051: {@expr1073765597 "__is_trivially_constructible" , "is_trivially_constructible" } ,
9052: {@expr1073765598 "__is_union" , "is_union" } ,
9053: } ;
9054: for (@expr1073765599 Token *@expr1073765600 tok@var3106 =@expr1073765601 list@var872 .@expr1073765602 front (@expr1073765603 ) ; tok@var3106 ; tok@var3106 =@expr1073765604 tok@var3106 .@expr23781 next (@expr23782 ) ) {
9055: if (@expr1073765607 !@expr1073765608 Token ::@expr1073765609 Match (@expr1073765610 tok@var3106 , "%name% (" ) ) {
9056: continue ; }
9057: auto p@var3107 ; p@var3107 =@expr1073765611 intrinsics@var3105 .@expr1073765612 find (@expr1073765613 tok@var3106 .@expr23790 str (@expr1073765615 ) ) ;
9058: if (@expr1073765616 p@var3107 ==@expr1073765617 intrinsics@var3105 .@expr1073765618 end (@expr1073765619 ) ) {
9059: continue ; }
9060: Token * end@var3108 ; end@var3108 =@expr1073765620 tok@var3106 .@expr23781 next (@expr23782 ) .@expr1073765623 link (@expr1073765624 ) ;
9061: Token * prev@var3109 ; prev@var3109 =@expr1073765625 tok@var3106 .@expr1073765626 previous (@expr1073765627 ) ;
9062: tok@var3106 .@expr23790 str (@expr1073765629 p@var3107 .@expr1073765630 second@var3110 ) ;
9063: prev@var3109 .@expr23807 insertToken (@expr1073765632 "::" ) ;
9064: prev@var3109 .@expr23807 insertToken (@expr1073765634 "std" ) ;
9065: tok@var3106 .@expr23781 next (@expr23782 ) .@expr1073765637 str (@expr1073765638 "<" ) ;
9066: end@var3108 .@expr1073765639 str (@expr1073765640 ">" ) ;
9067: end@var3108 .@expr23817 insertToken (@expr1073765642 "}" ) ;
9068: end@var3108 .@expr23817 insertToken (@expr1073765644 "{" ) ;
9069: Token ::@expr1073765645 createMutualLinks (@expr1073765646 end@var3108 .@expr23823 tokAt (@expr1073765648 1 ) , end@var3108 .@expr23823 tokAt (@expr1073765650 2 ) ) ;
9070: }
9071: }
9072:
9073: void Tokenizer :: simplifyCharAt ( )
9074: {
9075:
9076: for (@expr1073765651 Token *@expr1073765652 tok@var3111 =@expr1073765653 list@var872 .@expr1073765654 front (@expr1073765655 ) ; tok@var3111 ; tok@var3111 =@expr1073765656 tok@var3111 .@expr1073765657 next (@expr1073765658 ) ) {
9077: if (@expr1073765659 Token ::@expr1073765660 Match (@expr1073765661 tok@var3111 , "%str% [ %num% ]" ) ) {
9078: const long long index@var3112 =@expr1073765662 MathLib ::@expr1073765663 toLongNumber (@expr1073765664 tok@var3111 .@expr1073765665 strAt (@expr1073765666 2 ) ) ;
9079:
9080: if (@expr1073765667 index@var3112 >=@expr1073765668 0 &&@expr1073765669 index@var3112 <=@expr1073765670 Token ::@expr1073765671 getStrLength (@expr1073765672 tok@var3111 ) ) {
9081: tok@var3111 .@expr1073765673 str (@expr1073765674 "'" +@expr1073765675 Token ::@expr1073765676 getCharAt (@expr1073765677 tok@var3111 , index@var3112 ) +@expr1073765678 "'" ) ;
9082: tok@var3111 .@expr1073765679 deleteNext (@expr1073765680 3 ) ;
9083: }
9084: }
9085: }
9086: }
9087:
9088: void Tokenizer :: simplifyReference ( )
9089: {
9090: if (@expr1073765681 isC (@expr1073765682 ) ) {
9091: return ; }
9092:
9093: for (@expr1073765683 Token *@expr23860 tok@var3113 =@expr1073765685 list@var872 .@expr1073765686 front (@expr1073765687 ) ; tok@var3113 ; tok@var3113 =@expr1073765688 tok@var3113 .@expr1073765689 next (@expr1073765690 ) ) {
9094:
9095: Token * start@var3114 ; start@var3114 =@expr1073765691 const_cast < Token *@expr23860 > (@expr1073765693 startOfExecutableScope (@expr1073765694 tok@var3113 ) ) ;
9096: if (@expr1073765695 start@var3114 ) {
9097: tok@var3113 =@expr1073765696 start@var3114 ;
9098:
9099: Token * const end@var3115 ; end@var3115 =@expr1073765697 tok@var3113 .@expr1073765698 link (@expr1073765699 ) ;
9100: for (@expr1073765700 Token *@expr23860 tok2@var3116 =@expr1073765702 tok@var3113 ; tok2@var3116 &&@expr1073765703 tok2@var3116 !=@expr1073765704 end@var3115 ; tok2@var3116 =@expr1073765705 tok2@var3116 .@expr1073765706 next (@expr1073765707 ) ) {
9101:
9102: if (@expr1073765708 Token ::@expr1073765709 Match (@expr1073765710 tok2@var3116 , "[;{}] %type% & %name% (|= %name% )| ;" ) ) {
9103: const int refId@var3117 =@expr1073765711 tok2@var3116 .@expr23888 tokAt (@expr1073765713 3 ) .@expr1073765714 varId (@expr1073765715 ) ;
9104: if (@expr1073765716 !@expr1073765717 refId@var3117 ) {
9105: continue ; }
9106:
9107:
9108: for (@expr1073765718 Token *@expr23860 tok3@var3118 =@expr1073765720 tok2@var3116 .@expr23888 tokAt (@expr1073765722 7 ) ; tok3@var3118 &&@expr1073765723 tok3@var3118 !=@expr1073765724 end@var3115 ; tok3@var3118 =@expr1073765725 tok3@var3118 .@expr1073765726 next (@expr1073765727 ) ) {
9109: if (@expr1073765728 tok3@var3118 .@expr23905 varId (@expr1073765730 ) ==@expr1073765731 refId@var3117 ) {
9110: tok3@var3118 .@expr1073765732 str (@expr1073765733 tok2@var3116 .@expr23910 strAt (@expr1073765735 5 ) ) ;
9111: tok3@var3118 .@expr23905 varId (@expr1073765737 tok2@var3116 .@expr23888 tokAt (@expr1073765739 5 ) .@expr1073765740 varId (@expr1073765741 ) ) ;
9112: }
9113: }
9114:
9115: tok2@var3116 .@expr1073765742 deleteNext (@expr1073765743 6 +@expr1073765744 (@expr1073765745 tok2@var3116 .@expr23910 strAt (@expr1073765747 6 ) ==@expr1073765748 ")" ?@expr1073765749 1 :@expr1073765750 0 ) ) ;
9116: }
9117: }
9118: tok@var3113 =@expr1073765751 end@var3115 ;
9119: }
9120: }
9121: }
9122:
9123: bool Tokenizer :: simplifyCalculations ( )
9124: {
9125: return mTemplateSimplifier@var882 .@expr1073765752 simplifyCalculations (@expr1073765753 nullptr , nullptr , false ) ;
9126: }
9127:
9128: void Tokenizer :: simplifyOffsetPointerDereference ( )
9129: {
9130:
9131:
9132: for (@expr1073765754 Token *@expr1073765755 tok@var3119 =@expr1073765756 list@var872 .@expr1073765757 front (@expr1073765758 ) ; tok@var3119 ; tok@var3119 =@expr1073765759 tok@var3119 .@expr23936 next (@expr23937 ) ) {
9133: if (@expr1073765762 !@expr1073765763 tok@var3119 .@expr1073765764 isName (@expr1073765765 ) &&@expr1073765766 !@expr1073765767 tok@var3119 .@expr1073765768 isLiteral (@expr1073765769 )
9134: &&@expr1073765770 !@expr1073765771 Token ::@expr23948 Match (@expr1073765773 tok@var3119 , "]|)|++|--" )
9135: &&@expr1073765774 Token ::@expr23948 Match (@expr1073765776 tok@var3119 .@expr23936 next (@expr23937 ) , "* ( %name% +|- %num%|%name% )" ) ) {
9136:
9137:
9138: tok@var3119 .@expr1073765779 deleteNext (@expr1073765780 2 ) ;
9139:
9140:
9141: tok@var3119 =@expr1073765781 tok@var3119 .@expr23958 tokAt (@expr23959 2 ) ;
9142: Token * const openBraceTok@var3120 ; openBraceTok@var3120 =@expr1073765784 tok@var3119 ;
9143: const bool isNegativeIndex@var3121 =@expr1073765785 tok@var3119 .@expr23962 str (@expr1073765787 ) ==@expr1073765788 "-" ;
9144: tok@var3119 .@expr23962 str (@expr1073765790 "[" ) ;
9145:
9146:
9147: if (@expr1073765791 isNegativeIndex@var3121 ) {
9148: if (@expr1073765792 tok@var3119 .@expr23936 next (@expr23937 ) .@expr1073765795 isName (@expr1073765796 ) ) {
9149: tok@var3119 .@expr1073765797 insertToken (@expr1073765798 "-" ) ;
9150: tok@var3119 =@expr1073765799 tok@var3119 .@expr23936 next (@expr23937 ) ;
9151: } else {
9152: tok@var3119 .@expr23936 next (@expr23937 ) .@expr23980 str (@expr1073765805 std ::@expr1073765806 string (@expr1073765807 "-" ) +@expr1073765808 tok@var3119 .@expr23936 next (@expr23937 ) .@expr23980 str (@expr1073765812 ) ) ; }
9153: }
9154:
9155: tok@var3119 =@expr1073765813 tok@var3119 .@expr23958 tokAt (@expr23959 2 ) ;
9156: tok@var3119 .@expr23962 str (@expr1073765817 "]" ) ;
9157: Token ::@expr1073765818 createMutualLinks (@expr1073765819 openBraceTok@var3120 , tok@var3119 ) ;
9158: }
9159: }
9160: }
9161:
9162: void Tokenizer :: simplifyOffsetPointerReference ( )
9163: {
9164: std ::@expr1073765820 set < int > pod@var3122 ;
9165: for (@expr1073765821 const Token *@expr23998 tok@var3123 =@expr1073765823 list@var872 .@expr24000 front (@expr24001 ) ; tok@var3123 ; tok@var3123 =@expr1073765826 tok@var3123 .@expr24003 next (@expr24004 ) ) {
9166: if (@expr1073765829 tok@var3123 .@expr1073765830 isStandardType (@expr1073765831 ) ) {
9167: tok@var3123 =@expr1073765832 tok@var3123 .@expr24003 next (@expr24004 ) ;
9168: while (@expr1073765835 tok@var3123 &&@expr1073765836 (@expr1073765837 tok@var3123 .@expr1073765838 str (@expr1073765839 ) ==@expr1073765840 "*" ||@expr1073765841 tok@var3123 .@expr1073765842 isName (@expr1073765843 ) ) ) {
9169: if (@expr1073765844 tok@var3123 .@expr24021 varId (@expr24022 ) >@expr1073765847 0 ) {
9170: pod@var3122 .@expr1073765848 insert (@expr1073765849 tok@var3123 .@expr24021 varId (@expr24022 ) ) ;
9171: break ;
9172: }
9173: tok@var3123 =@expr1073765852 tok@var3123 .@expr24003 next (@expr24004 ) ;
9174: }
9175: if (@expr1073765855 !@expr1073765856 tok@var3123 ) {
9176: break ; }
9177: }
9178: }
9179:
9180: for (@expr1073765857 Token *@expr23998 tok@var3124 =@expr1073765859 list@var872 .@expr24000 front (@expr24001 ) ; tok@var3124 ; tok@var3124 =@expr1073765862 tok@var3124 .@expr24039 next (@expr24040 ) ) {
9181: if (@expr1073765865 !@expr1073765866 Token ::@expr24043 Match (@expr1073765868 tok@var3124 , "%num%|%name%|]|)" ) &&@expr1073765869
9182: (@expr1073765870 Token ::@expr24043 Match (@expr1073765872 tok@var3124 .@expr24039 next (@expr24040 ) , "& %name% [ %num%|%name% ] !![" ) ) ) {
9183: tok@var3124 =@expr1073765875 tok@var3124 .@expr24039 next (@expr24040 ) ;
9184:
9185: if (@expr1073765878 tok@var3124 .@expr24039 next (@expr24040 ) .@expr24057 varId (@expr24058 ) ) {
9186: if (@expr1073765883 pod@var3122 .@expr1073765884 find (@expr1073765885 tok@var3124 .@expr24039 next (@expr24040 ) .@expr24057 varId (@expr24058 ) ) ==@expr1073765890 pod@var3122 .@expr1073765891 end (@expr1073765892 ) ) {
9187: tok@var3124 =@expr1073765893 tok@var3124 .@expr24070 tokAt (@expr1073765895 5 ) ;
9188: if (@expr1073765896 !@expr1073765897 tok@var3124 ) {
9189: syntaxError (@expr1073765898 tok@var3124 ) ; }
9190: continue ;
9191: }
9192: }
9193:
9194:
9195: tok@var3124 .@expr24075 str (@expr1073765900 "(" ) ;
9196:
9197: tok@var3124 =@expr1073765901 tok@var3124 .@expr24039 next (@expr24040 ) ;
9198:
9199: tok@var3124 .@expr1073765904 deleteNext (@expr1073765905 ) ;
9200: tok@var3124 .@expr1073765906 insertToken (@expr1073765907 "+" ) ;
9201:
9202: tok@var3124 =@expr1073765908 tok@var3124 .@expr24070 tokAt (@expr1073765910 3 ) ;
9203:
9204: tok@var3124 .@expr24075 str (@expr1073765912 ")" ) ;
9205: Token ::@expr1073765913 createMutualLinks (@expr1073765914 tok@var3124 .@expr24070 tokAt (@expr1073765916 -4 ) , tok@var3124 ) ;
9206: }
9207: }
9208: }
9209:
9210: void Tokenizer :: simplifyNestedStrcat ( )
9211: {
9212: for (@expr1073765917 Token *@expr1073765918 tok@var3125 =@expr1073765919 list@var872 .@expr1073765920 front (@expr1073765921 ) ; tok@var3125 ; tok@var3125 =@expr1073765922 tok@var3125 .@expr1073765923 next (@expr1073765924 ) ) {
9213: if (@expr1073765925 !@expr1073765926 Token ::@expr1073765927 Match (@expr1073765928 tok@var3125 , "[;{}] strcat ( strcat (" ) ) {
9214: continue ;
9215: }
9216:
9217:
9218: Token * tok2@var3126 ; tok2@var3126 =@expr1073765929 tok@var3125 .@expr1073765930 tokAt (@expr1073765931 3 ) ;
9219: while (@expr1073765932 Token ::@expr1073765933 simpleMatch (@expr1073765934 tok2@var3126 , "strcat ( strcat" ) ) {
9220: tok2@var3126 =@expr1073765935 tok2@var3126 .@expr24112 tokAt (@expr24113 2 ) ; }
9221:
9222: if (@expr1073765938 tok2@var3126 .@expr24115 strAt (@expr1073765940 3 ) !=@expr1073765941 "," ) {
9223: continue ; }
9224:
|
9228:
9229: Token * prevTok@var3127 ; prevTok@var3127 =@expr1073765942 tok2@var3126 .@expr1073765943 previous (@expr1073765944 ) ;
9230:
9231:
9232: Token ::@expr1073765945 move (@expr1073765946 tok2@var3126 , tok2@var3126 .@expr24123 next (@expr24124 ) .@expr24125 link (@expr24126 ) , tok@var3125 ) ;
9233: tok@var3125 =@expr1073765951 tok2@var3126 .@expr24123 next (@expr24124 ) .@expr24125 link (@expr24126 ) ;
9234:
9235:
9236: prevTok@var3127 .@expr1073765956 insertToken (@expr1073765957 tok2@var3126 .@expr24115 strAt (@expr1073765959 2 ) ) ;
9237: prevTok@var3127 .@expr1073765960 next (@expr1073765961 ) .@expr1073765962 varId (@expr1073765963 tok2@var3126 .@expr24112 tokAt (@expr24113 2 ) .@expr1073765966 varId (@expr1073765967 ) ) ;
9238:
9239:
9240: tok@var3125 .@expr1073765968 insertToken (@expr1073765969 ";" ) ;
9241: }
9242: }
9243:
9244: static const std :: set < std :: string > stdFunctionsPresentInC@var3128 = {
9245: "strcat" ,
9246: "strcpy" ,
9247: "strncat" ,
9248: "strncpy" ,
9249: "free" ,
9250: "malloc" ,
9251: "strdup"
9252: } ;
9253:
9254: void Tokenizer :: simplifyStd ( )
9255: {
9256: if (@expr1073765970 isC (@expr1073765971 ) ) {
9257: return ; }
9258:
9259: for (@expr1073765972 Token *@expr1073765973 tok@var3129 =@expr1073765974 list@var872 .@expr1073765975 front (@expr1073765976 ) ; tok@var3129 ; tok@var3129 =@expr1073765977 tok@var3129 .@expr1073765978 next (@expr1073765979 ) ) {
9260: if (@expr1073765980 tok@var3129 .@expr1073765981 str (@expr1073765982 ) !=@expr1073765983 "std" ) {
9261: continue ; }
9262:
9263: if (@expr1073765984 Token ::@expr1073765985 Match (@expr1073765986 tok@var3129 .@expr1073765987 previous (@expr1073765988 ) , "[(,{};] std :: %name% (" ) &&@expr1073765989
9264: stdFunctionsPresentInC@var3128 .@expr1073765990 find (@expr1073765991 tok@var3129 .@expr1073765992 strAt (@expr1073765993 2 ) ) !=@expr1073765994 stdFunctionsPresentInC@var3128 .@expr1073765995 end (@expr1073765996 ) ) {
9265: tok@var3129 .@expr1073765997 deleteNext (@expr1073765998 ) ;
9266: tok@var3129 .@expr1073765999 deleteThis (@expr1073766000 ) ;
9267: }
9268: }
9269: }
9270:
|
9276:
9277: bool Tokenizer :: isScopeNoReturn ( const Token * endScopeToken@var3130 , bool * unknown@var3131 ) const
9278: {
9279: std ::@expr1073766001 string unknownFunc@var3132 ;
9280: const bool ret@var3133 =@expr1073766002 mSettings@var879 .@expr1073766003 library@var3563 .@expr1073766004 isScopeNoReturn (@expr1073766005 endScopeToken@var3130 , &@expr1073766006 unknownFunc@var3132 ) ;
9281: if (@expr1073766007 !@expr24184 unknownFunc@var3132 .@expr24185 empty (@expr24186 ) &&@expr1073766011 mSettings@var879 .@expr24188 summaryReturn@var3590 .@expr1073766013 find (@expr1073766014 unknownFunc@var3132 ) !=@expr1073766015 mSettings@var879 .@expr24188 summaryReturn@var3590 .@expr1073766017 end (@expr1073766018 ) ) {
9282: return false ;
9283: }
9284: if (@expr1073766019 unknown@var3131 ) {
9285: *@expr1073766020 unknown@var3131 =@expr1073766021 !@expr24184 unknownFunc@var3132 .@expr24185 empty (@expr24186 ) ; }
9286: if (@expr1073766025 !@expr24184 unknownFunc@var3132 .@expr24185 empty (@expr24186 ) &&@expr1073766029 mSettings@var879 .@expr1073766030 checkLibrary@var3591 &&@expr1073766031 mSettings@var879 .@expr1073766032 severity@var3571 .@expr1073766033 isEnabled (@expr1073766034 Severity ::@expr24211 information ) ) {
9287:
9288: bool globalFunction@var3134 ; globalFunction@var3134 =@expr1073766036 true ;
9289: if (@expr1073766037 Token ::@expr1073766038 simpleMatch (@expr1073766039 endScopeToken@var3130 .@expr1073766040 tokAt (@expr1073766041 -2 ) , ") ; }" ) ) {
9290: const Token * const ftok@var3135 ; ftok@var3135 =@expr1073766042 endScopeToken@var3130 .@expr1073766043 linkAt (@expr1073766044 -2 ) .@expr1073766045 previous (@expr1073766046 ) ;
9291: if (@expr1073766047 ftok@var3135 &&@expr1073766048
9292: ftok@var3135 .@expr1073766049 isName (@expr1073766050 ) &&@expr1073766051
9293: ftok@var3135 .@expr24228 function (@expr24229 ) &&@expr1073766054
9294: ftok@var3135 .@expr24228 function (@expr24229 ) .@expr24233 nestedIn@var3617 &&@expr1073766058
9295: ftok@var3135 .@expr24228 function (@expr24229 ) .@expr24233 nestedIn@var3617 .@expr1073766062 type@var3618 !=@expr1073766063 Scope ::@expr1073766064 eGlobal ) {
9296: globalFunction@var3134 =@expr1073766065 false ;
9297: }
9298: }
9299:
9300:
9301:
9302: if (@expr1073766066 globalFunction@var3134 ) {
9303: reportError (@expr1073766067 endScopeToken@var3130 .@expr1073766068 previous (@expr1073766069 ) ,
9304: Severity ::@expr24211 information ,
9305: "checkLibraryNoReturn" ,
9306: "--check-library: Function " +@expr1073766071 unknownFunc@var3132 +@expr1073766072 "() should have <noreturn> configuration" ) ;
9307: }
9308: }
9309: return ret@var3133 ;
9310: }
9311:
9312:
9313:
9314: bool Tokenizer :: isFunctionParameterPassedByValue ( const Token * fpar@var3136 ) const
9315: {
9316:
9317: const Token * ftok@var3137 ;
9318:
9319:
9320: int parameter@var3138 ; parameter@var3138 =@expr1073766073 1 ;
9321: for (@expr1073766074 ftok@var3137 =@expr1073766075 fpar@var3136 .@expr1073766076 previous (@expr1073766077 ) ; ftok@var3137 ; ftok@var3137 =@expr1073766078 ftok@var3137 .@expr24255 previous (@expr24256 ) ) {
9322: if (@expr1073766081 ftok@var3137 .@expr24258 str (@expr24259 ) ==@expr1073766084 "(" ) {
9323: break ; }
9324: else { if (@expr1073766085 ftok@var3137 .@expr24258 str (@expr24259 ) ==@expr1073766088 ")" ) {
9325: ftok@var3137 =@expr1073766089 ftok@var3137 .@expr1073766090 link (@expr1073766091 ) ; }
9326: else { if (@expr1073766092 ftok@var3137 .@expr24258 str (@expr24259 ) ==@expr1073766095 "," ) {
9327: ++@expr1073766096 parameter@var3138 ; }
9328: else { if (@expr1073766097 Token ::@expr24274 Match (@expr1073766099 ftok@var3137 , "[;{}]" ) ) {
9329: break ; } } } }
9330: }
9331:
9332:
9333: if (@expr1073766100 ftok@var3137 &&@expr1073766101 Token ::@expr24274 Match (@expr1073766103 ftok@var3137 .@expr1073766104 tokAt (@expr1073766105 -2 ) , "[;{}=] %name% (" ) ) {
9334: const std ::@expr1073766106 string & functionName@var3139 (@expr1073766107 ftok@var3137 .@expr24255 previous (@expr24256 ) .@expr1073766110 str (@expr1073766111 ) ) ;
9335:
9336: if (@expr1073766112 functionName@var3139 ==@expr1073766113 "return" ) {
9337: return true ; }
9338:
9339:
9340: for (@expr1073766114 const Token *@expr1073766115 tok@var3140 =@expr1073766116 tokens (@expr1073766117 ) ; tok@var3140 ; tok@var3140 =@expr1073766118 tok@var3140 .@expr24295 next (@expr24296 ) ) {
9341: if (@expr1073766121 tok@var3140 .@expr24298 str (@expr24299 ) ==@expr1073766124 "{" ) {
9342: tok@var3140 =@expr1073766125 tok@var3140 .@expr1073766126 link (@expr1073766127 ) ; }
9343: else { if (@expr1073766128 Token ::@expr24274 Match (@expr1073766130 tok@var3140 , "%type% (" ) &&@expr1073766131 tok@var3140 .@expr24298 str (@expr24299 ) ==@expr1073766134 functionName@var3139 ) {
9344:
9345: tok@var3140 =@expr1073766135 tok@var3140 .@expr1073766136 tokAt (@expr1073766137 2 ) ;
9346: int par@var3141 ; par@var3141 =@expr1073766138 1 ;
9347: while (@expr1073766139 tok@var3140 &&@expr1073766140 par@var3141 <@expr1073766141 parameter@var3138 ) {
9348: if (@expr1073766142 tok@var3140 .@expr24298 str (@expr24299 ) ==@expr1073766145 ")" ) {
9349: break ; }
9350: if (@expr1073766146 tok@var3140 .@expr24298 str (@expr24299 ) ==@expr1073766149 "," ) {
9351: ++@expr1073766150 par@var3141 ; }
9352: tok@var3140 =@expr1073766151 tok@var3140 .@expr24295 next (@expr24296 ) ;
9353: }
9354: if (@expr1073766154 !@expr24331 tok@var3140 ) {
9355: return false ; }
9356:
9357:
9358: if (@expr1073766156 par@var3141 ==@expr1073766157 parameter@var3138 ) {
9359: bool knowntype@var3142 ; knowntype@var3142 =@expr1073766158 false ;
9360: while (@expr1073766159 tok@var3140 &&@expr1073766160 tok@var3140 .@expr1073766161 isName (@expr1073766162 ) ) {
9361: knowntype@var3142 |=@expr1073766163 tok@var3140 .@expr1073766164 isStandardType (@expr1073766165 ) ;
9362: knowntype@var3142 |=@expr1073766166 (@expr1073766167 tok@var3140 .@expr24298 str (@expr24299 ) ==@expr1073766170 "struct" ) ;
9363: tok@var3140 =@expr1073766171 tok@var3140 .@expr24295 next (@expr24296 ) ;
9364: }
9365: if (@expr1073766174 !@expr24331 tok@var3140 ||@expr1073766176 !@expr1073766177 knowntype@var3142 ) {
9366: return false ; }
9367: if (@expr1073766178 tok@var3140 .@expr24298 str (@expr24299 ) !=@expr1073766181 "," &&@expr1073766182 tok@var3140 .@expr24298 str (@expr24299 ) !=@expr1073766185 ")" ) {
9368: return false ; }
9369: return true ;
9370: }
9371: } }
9372: }
9373: }
9374: return false ;
9375: }
9376:
9377:
9378:
9379: void Tokenizer :: eraseDeadCode ( Token * begin@var3143 , const Token * end@var3144 )
9380: {
9381: if (@expr1073766186 !@expr1073766187 begin@var3143 ) {
9382: return ; }
9383: const bool isgoto@var3145 =@expr1073766188 Token ::@expr24365 Match (@expr1073766190 begin@var3143 .@expr1073766191 tokAt (@expr1073766192 -2 ) , "goto %name% ;" ) ;
9384: int indentlevel@var3146 ; indentlevel@var3146 =@expr1073766193 1 ;
9385: int indentcase@var3147 ; indentcase@var3147 =@expr1073766194 0 ;
9386: int indentswitch@var3148 ; indentswitch@var3148 =@expr1073766195 0 ;
9387: int indentlabel@var3149 ; indentlabel@var3149 =@expr1073766196 0 ;
9388: int roundbraces@var3150 ; roundbraces@var3150 =@expr1073766197 0 ;
9389: int indentcheck@var3151 ; indentcheck@var3151 =@expr1073766198 0 ;
9390: std ::@expr1073766199 vector < int > switchindents@var3152 ;
9391: bool checklabel@var3153 ; checklabel@var3153 =@expr1073766200 false ;
9392: Token * tok@var3154 ; tok@var3154 =@expr1073766201 begin@var3143 ;
9393: Token * tokcheck@var3155 ; tokcheck@var3155 =@expr1073766202 nullptr ;
9394: while (@expr1073766203 tok@var3154 .@expr24380 next (@expr24381 ) &&@expr1073766206 tok@var3154 .@expr24380 next (@expr24381 ) !=@expr1073766209 end@var3144 ) {
9395: if (@expr1073766210 tok@var3154 .@expr24380 next (@expr24381 ) .@expr24389 str (@expr24390 ) ==@expr1073766215 "(" ) {
9396: ++@expr1073766216 roundbraces@var3150 ;
9397: tok@var3154 .@expr24393 deleteNext (@expr24394 ) ;
9398: continue ;
9399: } else { if (@expr1073766219 tok@var3154 .@expr24380 next (@expr24381 ) .@expr24389 str (@expr24390 ) ==@expr1073766224 ")" ) {
9400: if (@expr1073766225 !@expr1073766226 roundbraces@var3150 ) {
9401: break ; }
9402: --@expr1073766227 roundbraces@var3150 ;
9403: tok@var3154 .@expr24393 deleteNext (@expr24394 ) ;
9404: continue ;
9405: } }
9406:
9407: if (@expr1073766230 roundbraces@var3150 ) {
9408: tok@var3154 .@expr24393 deleteNext (@expr24394 ) ;
9409: continue ;
9410: }
9411:
9412: if (@expr1073766233 Token ::@expr24365 Match (@expr1073766235 tok@var3154 , "[{};] switch (" ) ) {
9413: if (@expr24412 !@expr24413 checklabel@var3153 ) {
9414: if (@expr1073766238 !@expr1073766239 indentlabel@var3149 ) {
9415:
9416: Token ::@expr24416 eraseTokens (@expr1073766241 tok@var3154 , tok@var3154 .@expr24418 linkAt (@expr24419 2 ) .@expr1073766244 next (@expr1073766245 ) ) ;
9417: } else {
9418: tok@var3154 =@expr1073766246 tok@var3154 .@expr24418 linkAt (@expr24419 2 ) ;
9419: }
9420: if (@expr24425 tok@var3154 .@expr24380 next (@expr24381 ) .@expr24389 str (@expr24390 ) ==@expr24430 "{" ) {
9421: ++@expr1073766255 indentswitch@var3148 ;
9422: indentcase@var3147 =@expr1073766256 indentlevel@var3146 +@expr24433 1 ;
9423: switchindents@var3152 .@expr24434 push_back (@expr24435 indentcase@var3147 ) ;
9424: }
9425: } else {
9426: tok@var3154 =@expr1073766260 tok@var3154 .@expr24418 linkAt (@expr24419 2 ) ;
9427: if (@expr1073766263 Token ::@expr24440 simpleMatch (@expr24441 tok@var3154 , ") {" ) ) {
9428: ++@expr1073766266 indentswitch@var3148 ;
9429: indentcase@var3147 =@expr1073766267 indentlevel@var3146 +@expr24433 1 ;
9430: switchindents@var3152 .@expr24434 push_back (@expr24435 indentcase@var3147 ) ;
9431: }
9432: }
9433: } else { if (@expr24425 tok@var3154 .@expr24380 next (@expr24381 ) .@expr24389 str (@expr24390 ) ==@expr24430 "{" ) {
9434: ++@expr1073766277 indentlevel@var3146 ;
9435: if (@expr24412 !@expr24413 checklabel@var3153 ) {
9436: checklabel@var3153 =@expr1073766280 true ;
9437: tokcheck@var3155 =@expr1073766281 tok@var3154 ;
9438: indentcheck@var3151 =@expr1073766282 indentlevel@var3146 ;
9439: indentlabel@var3149 =@expr1073766283 0 ;
9440: }
9441: tok@var3154 =@expr1073766284 tok@var3154 .@expr24380 next (@expr24381 ) ;
9442: } else { if (@expr1073766287 tok@var3154 .@expr24380 next (@expr24381 ) .@expr24389 str (@expr24390 ) ==@expr1073766292 "}" ) {
9443: --@expr1073766293 indentlevel@var3146 ;
9444: if (@expr1073766294 !@expr1073766295 indentlevel@var3146 ) {
9445: break ; }
9446:
9447: if (@expr24412 !@expr24413 checklabel@var3153 ) {
9448: tok@var3154 .@expr24393 deleteNext (@expr24394 ) ;
9449: } else {
9450: if (@expr1073766300 indentswitch@var3148 &&@expr1073766301 indentlevel@var3146 ==@expr24478 indentcase@var3147 ) {
9451: --@expr1073766303 indentlevel@var3146 ; }
9452: if (@expr1073766304 indentlevel@var3146 <@expr1073766305 indentcheck@var3151 ) {
9453: const Token * end2@var3156 ; end2@var3156 =@expr1073766306 tok@var3154 .@expr24380 next (@expr24381 ) ;
9454: tok@var3154 =@expr1073766309 end2@var3156 .@expr1073766310 link (@expr1073766311 ) .@expr1073766312 previous (@expr1073766313 ) ;
9455: if (@expr1073766314 indentswitch@var3148 &&@expr1073766315 Token ::@expr24440 simpleMatch (@expr24441 tok@var3154 , ") {" ) &&@expr1073766318 Token ::@expr24365 Match (@expr1073766320 tok@var3154 .@expr24497 link (@expr24498 ) .@expr24499 tokAt (@expr24500 -2 ) , "[{};] switch (" ) ) {
9456: tok@var3154 =@expr1073766325 tok@var3154 .@expr24497 link (@expr24498 ) .@expr24499 tokAt (@expr24500 -2 ) ; }
9457: Token ::@expr24416 eraseTokens (@expr1073766331 tok@var3154 , end2@var3156 .@expr1073766332 next (@expr1073766333 ) ) ;
9458: checklabel@var3153 =@expr1073766334 false ;
9459: tokcheck@var3155 =@expr1073766335 nullptr ;
9460: indentcheck@var3151 =@expr1073766336 0 ;
9461: } else {
9462: tok@var3154 =@expr1073766337 tok@var3154 .@expr24380 next (@expr24381 ) ;
9463: }
9464: }
9465: if (@expr1073766340 indentswitch@var3148 &&@expr1073766341 indentlevel@var3146 <=@expr1073766342 indentcase@var3147 ) {
9466: --@expr1073766343 indentswitch@var3148 ;
9467: switchindents@var3152 .@expr1073766344 pop_back (@expr1073766345 ) ;
9468: if (@expr1073766346 !@expr24523 indentswitch@var3148 ) {
9469: indentcase@var3147 =@expr1073766348 0 ; }
9470: else {
9471: indentcase@var3147 =@expr1073766349 switchindents@var3152 [@expr1073766350 indentswitch@var3148 -@expr1073766351 1 ] ; }
9472: }
9473: } else { if (@expr1073766352 Token ::@expr24365 Match (@expr1073766354 tok@var3154 , "[{};:] case" ) ) {
9474: const Token * tok2@var3157 ; tok2@var3157 =@expr1073766355 Token ::@expr24532 findsimplematch (@expr1073766357 tok@var3154 .@expr24380 next (@expr24381 ) , ": ;" , end@var3144 ) ;
9475: if (@expr1073766360 !@expr1073766361 tok2@var3157 ) {
9476: tok@var3154 .@expr24393 deleteNext (@expr24394 ) ;
9477: continue ;
9478: }
9479: if (@expr24540 indentlevel@var3146 ==@expr24541 1 ) {
9480: break ; }
9481: if (@expr24542 indentlevel@var3146 ==@expr24478 indentcase@var3147 ) {
9482: ++@expr1073766368 indentlevel@var3146 ; }
9483: tok2@var3157 =@expr1073766369 tok2@var3157 .@expr24546 next (@expr24547 ) ;
9484: if (@expr24548 !@expr24413 checklabel@var3153 ||@expr24550 !@expr24523 indentswitch@var3148 ) {
9485: Token ::@expr24416 eraseTokens (@expr1073766377 tok@var3154 , tok2@var3157 .@expr24546 next (@expr24547 ) ) ;
9486: } else {
9487: tok@var3154 =@expr1073766380 const_cast < Token *@expr24557 > (@expr1073766382 tok2@var3157 ) ;
9488: }
9489: } else { if (@expr1073766383 Token ::@expr24365 Match (@expr1073766385 tok@var3154 , "[{};] default : ;" ) ) {
9490: if (@expr24540 indentlevel@var3146 ==@expr24541 1 ) {
9491: break ; }
9492: if (@expr24542 indentlevel@var3146 ==@expr24478 indentcase@var3147 ) {
9493: ++@expr1073766390 indentlevel@var3146 ; }
9494: if (@expr24548 !@expr24413 checklabel@var3153 ||@expr24550 !@expr24523 indentswitch@var3148 ) {
9495: tok@var3154 .@expr24393 deleteNext (@expr1073766396 3 ) ;
9496: } else {
9497: tok@var3154 =@expr1073766397 tok@var3154 .@expr24574 tokAt (@expr24575 3 ) ;
9498: }
9499: } else { if (@expr1073766400 Token ::@expr24365 Match (@expr1073766402 tok@var3154 , "[{};] %name% : ;" ) &&@expr1073766403 tok@var3154 .@expr24380 next (@expr24381 ) .@expr24389 str (@expr24390 ) !=@expr1073766408 "default" ) {
9500: if (@expr1073766409 checklabel@var3153 ) {
9501: indentlabel@var3149 =@expr1073766410 indentlevel@var3146 ;
9502: tok@var3154 =@expr1073766411 tokcheck@var3155 .@expr1073766412 next (@expr1073766413 ) ;
9503: checklabel@var3153 =@expr1073766414 false ;
9504: indentlevel@var3146 =@expr1073766415 indentcheck@var3151 ;
9505: } else {
9506: if (@expr1073766416 indentswitch@var3148 ) {
9507:
9508:
9509:
9510: Token * tok2@var3158 ; tok2@var3158 =@expr1073766417 tok@var3154 .@expr24574 tokAt (@expr24575 3 ) ;
9511: int indentlevel2@var3159 ; indentlevel2@var3159 =@expr1073766420 indentlevel@var3146 ;
9512: while (@expr1073766421 tok2@var3158 .@expr24598 next (@expr24599 ) &&@expr1073766424 tok2@var3158 .@expr24598 next (@expr24599 ) !=@expr1073766427 end@var3144 ) {
9513: if (@expr1073766428 Token ::@expr24365 Match (@expr1073766430 tok2@var3158 .@expr24598 next (@expr24599 ) , "{|[|(" ) ) {
9514: tok2@var3158 =@expr1073766433 tok2@var3158 .@expr24598 next (@expr24599 ) .@expr1073766436 link (@expr1073766437 ) ;
9515: } else { if (@expr1073766438 Token ::@expr24365 Match (@expr1073766440 tok2@var3158 , "[{};:] case" ) ) {
9516: const Token * tok3@var3160 ; tok3@var3160 =@expr1073766441 Token ::@expr24532 findsimplematch (@expr1073766443 tok2@var3158 .@expr24598 next (@expr24599 ) , ": ;" , end@var3144 ) ;
9517: if (@expr1073766446 !@expr1073766447 tok3@var3160 ) {
9518: tok2@var3158 =@expr1073766448 tok2@var3158 .@expr24598 next (@expr24599 ) ;
9519: continue ;
9520: }
9521: Token ::@expr24416 eraseTokens (@expr1073766452 tok2@var3158 , tok3@var3160 .@expr1073766453 next (@expr1073766454 ) ) ;
9522: } else { if (@expr1073766455 Token ::@expr24365 Match (@expr1073766457 tok2@var3158 , "[{};] default : ;" ) ) {
9523: tok2@var3158 .@expr1073766458 deleteNext (@expr1073766459 3 ) ;
9524: } else { if (@expr1073766460 tok2@var3158 .@expr24598 next (@expr24599 ) .@expr1073766463 str (@expr1073766464 ) ==@expr1073766465 "}" ) {
9525: --@expr1073766466 indentlevel2@var3159 ;
9526: if (@expr1073766467 indentlevel2@var3159 <=@expr1073766468 indentcase@var3147 ) {
9527: break ; }
9528: tok2@var3158 =@expr1073766469 tok2@var3158 .@expr24598 next (@expr24599 ) ;
9529: } else {
9530: tok2@var3158 =@expr1073766472 tok2@var3158 .@expr24598 next (@expr24599 ) ;
9531: } } } }
9532: }
9533: }
9534: break ;
9535: }
9536: } else { if (@expr1073766475 isgoto@var3145 &&@expr1073766476 Token ::@expr24365 Match (@expr1073766478 tok@var3154 , "[{};] do|while|for|BOOST_FOREACH" ) ) {
9537:
9538:
9539: const Token * start@var3161 ; start@var3161 =@expr1073766479 tok@var3154 .@expr24574 tokAt (@expr1073766481 2 ) ;
9540: if (@expr1073766482 start@var3161 &&@expr1073766483 start@var3161 .@expr24660 str (@expr24661 ) ==@expr1073766486 "(" ) {
9541: start@var3161 =@expr1073766487 start@var3161 .@expr24664 link (@expr24665 ) .@expr1073766490 next (@expr1073766491 ) ; }
9542: if (@expr1073766492 start@var3161 &&@expr1073766493 start@var3161 .@expr24660 str (@expr24661 ) ==@expr1073766496 "{" ) {
9543: std ::@expr1073766497 string labelpattern@var3162 ; labelpattern@var3162 =@expr1073766498 "[{};] " +@expr1073766499 begin@var3143 .@expr1073766500 previous (@expr1073766501 ) .@expr1073766502 str (@expr1073766503 ) +@expr1073766504 " : ;" ;
9544: bool simplify@var3163 ; simplify@var3163 =@expr1073766505 true ;
9545: for (@expr1073766506 Token *@expr24557 tok2@var3164 =@expr1073766508 start@var3161 .@expr1073766509 next (@expr1073766510 ) ; tok2@var3164 !=@expr1073766511 start@var3161 .@expr24664 link (@expr24665 ) ; tok2@var3164 =@expr1073766514 tok2@var3164 .@expr1073766515 next (@expr1073766516 ) ) {
9546: if (@expr1073766517 Token ::@expr24365 Match (@expr1073766519 tok2@var3164 , labelpattern@var3162 .@expr1073766520 c_str (@expr1073766521 ) ) ) {
9547: simplify@var3163 =@expr1073766522 false ;
9548: break ;
9549: }
9550: }
9551:
9552: if (@expr1073766523 !@expr1073766524 simplify@var3163 ) {
9553: break ; }
9554: }
9555: tok@var3154 .@expr24393 deleteNext (@expr24394 ) ;
9556: } else {
9557:
9558: if (@expr1073766527 tok@var3154 .@expr1073766528 strAt (@expr1073766529 1 ) ==@expr1073766530 "while" ) {
9559: if (@expr1073766531 tok@var3154 .@expr1073766532 str (@expr1073766533 ) ==@expr1073766534 "}" &&@expr1073766535 tok@var3154 .@expr24497 link (@expr24498 ) .@expr1073766538 strAt (@expr1073766539 -1 ) ==@expr1073766540 "do" ) {
9560: tok@var3154 .@expr24497 link (@expr24498 ) .@expr1073766543 previous (@expr1073766544 ) .@expr1073766545 deleteThis (@expr1073766546 ) ; }
9561: }
9562: tok@var3154 .@expr24393 deleteNext (@expr24394 ) ;
9563: } } } } } } }
9564: }
9565: }
9566:
9567:
9568:
9569: void Tokenizer :: syntaxError ( const Token * tok@var3165 , const std :: string & code@var3166 ) const
9570: {
9571: printDebugOutput (@expr1073766549 0 ) ;
9572: throw InternalError (@expr1073766550 tok@var3165 , code@var3166 .@expr1073766551 empty (@expr1073766552 ) ?@expr1073766553 "syntax error" :@expr1073766554 "syntax error: " +@expr1073766555 code@var3166 , InternalError ::@expr1073766556 SYNTAX ) ;
9573: }
9574:
9575: void Tokenizer :: unmatchedToken ( const Token * tok@var3167 ) const
9576: {
9577: printDebugOutput (@expr1073766557 0 ) ;
9578: throw InternalError (@expr1073766558 tok@var3167 ,
9579: "Unmatched '" +@expr1073766559 tok@var3167 .@expr1073766560 str (@expr1073766561 ) +@expr1073766562 "'. Configuration: '" +@expr1073766563 mConfiguration@var883 +@expr1073766564 "'." ,
9580: InternalError ::@expr1073766565 SYNTAX ) ;
9581: }
9582:
9583: void Tokenizer :: syntaxErrorC ( const Token * tok@var3168 , const std :: string & what@var3169 ) const
9584: {
9585: printDebugOutput (@expr1073766566 0 ) ;
9586: throw InternalError (@expr1073766567 tok@var3168 , "Code '" +@expr1073766568 what@var3169 +@expr1073766569 "' is invalid C code. Use --std or --language to configure the language." , InternalError ::@expr1073766570 SYNTAX ) ;
9587: }
9588:
9589: void Tokenizer :: unknownMacroError ( const Token * tok1@var3170 ) const
9590: {
9591: printDebugOutput (@expr1073766571 0 ) ;
9592: throw InternalError (@expr1073766572 tok1@var3170 , "There is an unknown macro here somewhere. Configuration is required. If " +@expr1073766573 tok1@var3170 .@expr1073766574 str (@expr1073766575 ) +@expr1073766576 " is a macro then please configure it." , InternalError ::@expr1073766577 UNKNOWN_MACRO ) ;
9593: }
9594:
9595: void Tokenizer :: unhandled_macro_class_x_y ( const Token * tok@var3171 ) const
9596: {
9597: reportError (@expr1073766578 tok@var3171 ,
9598: Severity ::@expr1073766579 information ,
9599: "class_X_Y" ,
9600: "The code '" +@expr1073766580
9601: tok@var3171 .@expr1073766581 str (@expr1073766582 ) +@expr1073766583 " " +@expr1073766584
9602: tok@var3171 .@expr24761 strAt (@expr1073766586 1 ) +@expr1073766587 " " +@expr1073766588
9603: tok@var3171 .@expr24761 strAt (@expr1073766590 2 ) +@expr1073766591 " " +@expr1073766592
9604: tok@var3171 .@expr24761 strAt (@expr1073766594 3 ) +@expr1073766595 "' is not handled. You can use -I or --include to add handling of this code." ) ;
9605: }
9606:
9607: void Tokenizer :: macroWithSemicolonError ( const Token * tok@var3172 , const std :: string & macroName@var3173 ) const
9608: {
9609: reportError (@expr1073766596 tok@var3172 ,
9610: Severity ::@expr1073766597 information ,
9611: "macroWithSemicolon" ,
9612: "Ensure that '" +@expr1073766598 macroName@var3173 +@expr1073766599 "' is defined either using -I, --include or -D." ) ;
9613: }
9614:
9615: void Tokenizer :: cppcheckError ( const Token * tok@var3174 ) const
9616: {
9617: printDebugOutput (@expr1073766600 0 ) ;
9618: throw InternalError (@expr1073766601 tok@var3174 , "Analysis failed. If the code is valid then please report this failure." , InternalError ::@expr1073766602 INTERNAL ) ;
9619: }
9620:
9621: void Tokenizer :: unhandledCharLiteral ( const Token * tok@var3175 , const std :: string & msg@var3176 ) const
9622: {
9623: std ::@expr1073766603 string s@var3177 ; s@var3177 =@expr1073766604 tok@var3175 ?@expr1073766605 (@expr1073766606 " " +@expr1073766607 tok@var3175 .@expr1073766608 str (@expr1073766609 ) ) :@expr1073766610 "" ;
9624: for (@expr1073766611 int i@var3178 =@expr1073766612 0 ; i@var3178 <@expr1073766613 s@var3177 .@expr1073766614 size (@expr1073766615 ) ; ++@expr1073766616 i@var3178 ) {
9625: if (@expr1073766617 (@expr1073766618 unsigned char ) s@var3177 [@expr1073766619 i@var3178 ] >=@expr1073766620 0x80 ) {
9626: s@var3177 .@expr1073766621 clear (@expr1073766622 ) ; }
9627: }
9628:
9629: reportError (@expr1073766623 tok@var3175 ,
9630: Severity ::@expr1073766624 portability ,
9631: "nonStandardCharLiteral" ,
9632: "Non-standard character literal" +@expr1073766625 s@var3177 +@expr1073766626 ". " +@expr1073766627 msg@var3176 ) ;
9633: }
9634:
|
9642:
9643: static bool isNumberOneOf ( const std :: string & s@var3179 , const long long & intConstant@var3180 , const char * floatConstant@var3181 )
9644: {
9645: if (@expr1073766628 MathLib ::@expr1073766629 isInt (@expr1073766630 s@var3179 ) ) {
9646: if (@expr1073766631 MathLib ::@expr1073766632 toLongNumber (@expr1073766633 s@var3179 ) ==@expr1073766634 intConstant@var3180 ) {
9647: return true ; }
9648: } else { if (@expr1073766635 MathLib ::@expr1073766636 isFloat (@expr1073766637 s@var3179 ) ) {
9649: if (@expr1073766638 MathLib ::@expr1073766639 toString (@expr1073766640 MathLib ::@expr1073766641 toDoubleNumber (@expr1073766642 s@var3179 ) ) ==@expr1073766643 floatConstant@var3181 ) {
9650: return true ; }
9651: } }
9652: return false ;
9653: }
9654:
|
9659:
9660: bool Tokenizer :: isZeroNumber ( const std :: string & s@var3182 )
9661: {
9662: return isNumberOneOf (@expr1073766644 s@var3182 , 0L , "0.0" ) ;
9663: }
9664:
|
9669:
9670: bool Tokenizer :: isOneNumber ( const std :: string & s@var3183 )
9671: {
9672: if (@expr1073766645 !@expr1073766646 MathLib ::@expr1073766647 isPositive (@expr1073766648 s@var3183 ) ) {
9673: return false ; }
9674: return isNumberOneOf (@expr1073766649 s@var3183 , 1L , "1.0" ) ;
9675: }
9676:
|
9681:
9682: bool Tokenizer :: isTwoNumber ( const std :: string & s@var3184 )
9683: {
9684: if (@expr1073766650 !@expr1073766651 MathLib ::@expr1073766652 isPositive (@expr1073766653 s@var3184 ) ) {
9685: return false ; }
9686: return isNumberOneOf (@expr1073766654 s@var3184 , 2L , "2.0" ) ;
9687: }
9688:
|
9710:
9711: void Tokenizer :: simplifyMathFunctions ( )
9712: {
9713: for (@expr1073766655 Token *@expr1073766656 tok@var3185 =@expr1073766657 list@var872 .@expr1073766658 front (@expr1073766659 ) ; tok@var3185 ; tok@var3185 =@expr1073766660 tok@var3185 .@expr1073766661 next (@expr1073766662 ) ) {
9714: if (@expr1073766663 tok@var3185 .@expr1073766664 isName (@expr1073766665 ) &&@expr1073766666 !@expr1073766667 tok@var3185 .@expr1073766668 varId (@expr1073766669 ) &&@expr1073766670 tok@var3185 .@expr24847 strAt (@expr1073766672 1 ) ==@expr1073766673 "(" ) {
9715: bool simplifcationMade@var3186 ; simplifcationMade@var3186 =@expr1073766674 false ;
9716: if (@expr1073766675 Token ::@expr24852 Match (@expr1073766677 tok@var3185 , "atol ( %str% )" ) ) {
9717: if (@expr1073766678 Token ::@expr1073766679 simpleMatch (@expr1073766680 tok@var3185 .@expr24857 tokAt (@expr24858 -2 ) , "std ::" ) ) {
9718: tok@var3185 =@expr1073766683 tok@var3185 .@expr24857 tokAt (@expr24858 -2 ) ;
9719: tok@var3185 .@expr24862 deleteNext (@expr1073766687 2 ) ;
9720: }
9721: const std ::@expr1073766688 string &@expr1073766689 strNumber@var3187 =@expr1073766690 tok@var3185 .@expr24857 tokAt (@expr24868 2 ) .@expr1073766693 strValue (@expr1073766694 ) ;
9722: const bool isNotAnInteger@var3188 =@expr1073766695 !@expr1073766696 MathLib ::@expr1073766697 isInt (@expr1073766698 strNumber@var3187 ) ;
9723: if (@expr1073766699 strNumber@var3187 .@expr1073766700 empty (@expr1073766701 ) ||@expr1073766702 isNotAnInteger@var3188 ) {
9724:
9725: continue ;
9726: }
9727:
9728: tok@var3185 .@expr24879 str (@expr1073766704 MathLib ::@expr1073766705 toString (@expr1073766706 MathLib ::@expr1073766707 toLongNumber (@expr1073766708 strNumber@var3187 ) ) ) ;
9729:
9730: tok@var3185 .@expr24862 deleteNext (@expr24886 3 ) ;
9731: simplifcationMade@var3186 =@expr1073766711 true ;
9732: } else { if (@expr1073766712 Token ::@expr24852 Match (@expr1073766714 tok@var3185 , "sqrt|sqrtf|sqrtl|cbrt|cbrtf|cbrtl ( %num% )" ) ) {
9733:
9734:
9735:
9736: const std ::@expr24891 string & parameter@var3189 (@expr1073766716 tok@var3185 .@expr24847 strAt (@expr24894 2 ) ) ;
9737:
9738: if (@expr1073766719 isZeroNumber (@expr1073766720 parameter@var3189 ) ) {
9739: tok@var3185 .@expr24862 deleteNext (@expr24886 3 ) ;
9740: tok@var3185 .@expr24879 str (@expr24900 "0" ) ;
9741: simplifcationMade@var3186 =@expr1073766725 true ;
9742: } else { if (@expr1073766726 isOneNumber (@expr1073766727 parameter@var3189 ) ) {
9743: tok@var3185 .@expr24862 deleteNext (@expr24886 3 ) ;
9744: tok@var3185 .@expr24879 str (@expr24907 "1" ) ;
9745: simplifcationMade@var3186 =@expr1073766732 true ;
9746: } }
9747: } else { if (@expr1073766733 Token ::@expr24852 Match (@expr1073766735 tok@var3185 , "exp|expf|expl|exp2|exp2f|exp2l|cos|cosf|cosl|cosh|coshf|coshl|erfc|erfcf|erfcl ( %num% )" ) ) {
9748:
|
9751:
9752: const std ::@expr24891 string & parameter@var3190 (@expr1073766737 tok@var3185 .@expr24847 strAt (@expr24894 2 ) ) ;
9753:
9754: if (@expr1073766740 isZeroNumber (@expr1073766741 parameter@var3190 ) ) {
9755: tok@var3185 .@expr24862 deleteNext (@expr24886 3 ) ;
9756: tok@var3185 .@expr24879 str (@expr24907 "1" ) ;
9757: simplifcationMade@var3186 =@expr1073766746 true ;
9758: }
9759: } else { if (@expr1073766747 Token ::@expr24852 Match (@expr1073766749 tok@var3185 , "log1p|log1pf|log1pl|sin|sinf|sinl|sinh|sinhf|sinhl|erf|erff|erfl|asin|asinf|asinl|asinh|asinhf|asinhl|tan|tanf|tanl|tanh|tanhf|tanhl|atan|atanf|atanl|atanh|atanhf|atanhl|expm1|expm1f|expm1l ( %num% )" ) ) {
9760:
|
9766:
9767: const std ::@expr24891 string & parameter@var3191 (@expr1073766751 tok@var3185 .@expr24847 strAt (@expr24894 2 ) ) ;
9768:
9769: if (@expr1073766754 isZeroNumber (@expr1073766755 parameter@var3191 ) ) {
9770: tok@var3185 .@expr24862 deleteNext (@expr24886 3 ) ;
9771: tok@var3185 .@expr24879 str (@expr24900 "0" ) ;
9772: simplifcationMade@var3186 =@expr1073766760 true ;
9773: }
9774: } else { if (@expr1073766761 Token ::@expr24852 Match (@expr1073766763 tok@var3185 , "log2|log2f|log2l|log|logf|logl|log10|log10f|log10l|logb|logbf|logbl|acosh|acoshf|acoshl|acos|acosf|acosl|ilogb|ilogbf|ilogbl ( %num% )" ) ) {
9775:
|
9779:
9780: const std ::@expr24891 string & parameter@var3192 (@expr1073766765 tok@var3185 .@expr24847 strAt (@expr24894 2 ) ) ;
9781:
9782: if (@expr1073766768 isOneNumber (@expr1073766769 parameter@var3192 ) ) {
9783: tok@var3185 .@expr24862 deleteNext (@expr24886 3 ) ;
9784: tok@var3185 .@expr24879 str (@expr24900 "0" ) ;
9785: simplifcationMade@var3186 =@expr1073766774 true ;
9786: }
9787: } else { if (@expr1073766775 Token ::@expr24852 Match (@expr1073766777 tok@var3185 , "fmin|fminl|fminf ( %num% , %num% )" ) ) {
9788:
9789:
9790:
9791: const std ::@expr24891 string & strLeftNumber@var3193 (@expr1073766779 tok@var3185 .@expr24847 strAt (@expr24894 2 ) ) ;
9792: const std ::@expr24891 string & strRightNumber@var3194 (@expr1073766783 tok@var3185 .@expr24847 strAt (@expr24961 4 ) ) ;
9793: const bool isLessEqual@var3195 =@expr1073766786 MathLib ::@expr24963 isLessEqual (@expr1073766788 strLeftNumber@var3193 , strRightNumber@var3194 ) ;
9794:
9795: if (@expr1073766789 isLessEqual@var3195 ) {
9796: tok@var3185 .@expr24879 str (@expr1073766791 strLeftNumber@var3193 ) ;
9797: tok@var3185 .@expr24862 deleteNext (@expr24969 5 ) ;
9798: simplifcationMade@var3186 =@expr1073766794 true ;
9799: } else {
9800: tok@var3185 .@expr24879 str (@expr1073766796 strRightNumber@var3194 ) ;
9801: tok@var3185 .@expr24862 deleteNext (@expr24969 5 ) ;
9802: simplifcationMade@var3186 =@expr1073766799 true ;
9803: }
9804: } else { if (@expr1073766800 Token ::@expr24852 Match (@expr1073766802 tok@var3185 , "fmax|fmaxl|fmaxf ( %num% , %num% )" ) ) {
9805:
9806:
9807:
9808: const std ::@expr24891 string & strLeftNumber@var3196 (@expr1073766804 tok@var3185 .@expr24847 strAt (@expr24894 2 ) ) ;
9809: const std ::@expr24891 string & strRightNumber@var3197 (@expr1073766808 tok@var3185 .@expr24847 strAt (@expr24961 4 ) ) ;
9810: const bool isLessEqual@var3198 =@expr1073766811 MathLib ::@expr24963 isLessEqual (@expr1073766813 strLeftNumber@var3196 , strRightNumber@var3197 ) ;
9811:
9812: if (@expr1073766814 isLessEqual@var3198 ) {
9813: tok@var3185 .@expr24879 str (@expr1073766816 strRightNumber@var3197 ) ;
9814: tok@var3185 .@expr24862 deleteNext (@expr24969 5 ) ;
9815: simplifcationMade@var3186 =@expr1073766819 true ;
9816: } else {
9817: tok@var3185 .@expr24879 str (@expr1073766821 strLeftNumber@var3196 ) ;
9818: tok@var3185 .@expr24862 deleteNext (@expr24969 5 ) ;
9819: simplifcationMade@var3186 =@expr1073766824 true ;
9820: }
9821: } else { if (@expr1073766825 Token ::@expr24852 Match (@expr1073766827 tok@var3185 , "pow|powf|powl (" ) ) {
9822: if (@expr1073766828 Token ::@expr24852 Match (@expr1073766830 tok@var3185 .@expr24857 tokAt (@expr24868 2 ) , "%num% , %num% )" ) ) {
9823:
9824:
9825:
9826: const std ::@expr24891 string & leftNumber@var3199 (@expr1073766834 tok@var3185 .@expr24847 strAt (@expr24894 2 ) ) ;
9827: const std ::@expr24891 string & rightNumber@var3200 (@expr1073766838 tok@var3185 .@expr24847 strAt (@expr24961 4 ) ) ;
9828: const bool isLeftNumberZero@var3201 =@expr1073766841 isZeroNumber (@expr1073766842 leftNumber@var3199 ) ;
9829: const bool isLeftNumberOne@var3202 =@expr1073766843 isOneNumber (@expr1073766844 leftNumber@var3199 ) ;
9830: const bool isRightNumberZero@var3203 =@expr1073766845 isZeroNumber (@expr1073766846 rightNumber@var3200 ) ;
9831: if (@expr1073766847 isLeftNumberZero@var3201 &&@expr1073766848 !@expr1073766849 isRightNumberZero@var3203 &&@expr1073766850 MathLib ::@expr1073766851 isPositive (@expr1073766852 rightNumber@var3200 ) ) {
9832: tok@var3185 .@expr24862 deleteNext (@expr24969 5 ) ;
9833: tok@var3185 .@expr24879 str (@expr24900 "0" ) ;
9834: simplifcationMade@var3186 =@expr1073766857 true ;
9835: } else { if (@expr1073766858 isLeftNumberZero@var3201 &&@expr1073766859 isRightNumberZero@var3203 ) {
9836: tok@var3185 .@expr24862 deleteNext (@expr24969 5 ) ;
9837: tok@var3185 .@expr24879 str (@expr24907 "1" ) ;
9838: simplifcationMade@var3186 =@expr1073766864 true ;
9839: } else { if (@expr1073766865 isLeftNumberOne@var3202 ) {
9840: tok@var3185 .@expr24862 deleteNext (@expr24969 5 ) ;
9841: tok@var3185 .@expr24879 str (@expr24907 "1" ) ;
9842: simplifcationMade@var3186 =@expr1073766870 true ;
9843: } } }
9844: }
9845: if (@expr1073766871 Token ::@expr24852 Match (@expr1073766873 tok@var3185 .@expr24857 tokAt (@expr24868 2 ) , "%any% , %num% )" ) ) {
9846:
9847: const std ::@expr24891 string & leftParameter@var3204 (@expr1073766877 tok@var3185 .@expr24847 strAt (@expr24894 2 ) ) ;
9848: const std ::@expr24891 string & rightNumber@var3205 (@expr1073766881 tok@var3185 .@expr24847 strAt (@expr24961 4 ) ) ;
9849: if (@expr1073766884 isOneNumber (@expr1073766885 rightNumber@var3205 ) ) {
9850: tok@var3185 .@expr24879 str (@expr1073766887 leftParameter@var3204 ) ;
9851: tok@var3185 .@expr24862 deleteNext (@expr24969 5 ) ;
9852: simplifcationMade@var3186 =@expr1073766890 true ;
9853: } else { if (@expr1073766891 isZeroNumber (@expr1073766892 rightNumber@var3205 ) ) {
9854: tok@var3185 .@expr24862 deleteNext (@expr24969 5 ) ;
9855: tok@var3185 .@expr24879 str (@expr24907 "1" ) ;
9856: simplifcationMade@var3186 =@expr1073766897 true ;
9857: } }
9858: }
9859: } } } } } } } }
9860:
9861: if (@expr1073766898 simplifcationMade@var3186 ) {
9862: while (@expr1073766899 tok@var3185 .@expr25076 previous (@expr25077 ) &&@expr1073766902 tok@var3185 .@expr24879 str (@expr1073766904 ) !=@expr1073766905 ";" ) {
9863: tok@var3185 =@expr1073766906 tok@var3185 .@expr25076 previous (@expr25077 ) ;
9864: }
9865: }
9866: }
9867: }
9868: }
9869:
9870: void Tokenizer :: simplifyComma ( )
9871: {
9872: bool inReturn@var3206 ; inReturn@var3206 =@expr1073766909 false ;
9873:
9874: for (@expr1073766910 Token *@expr25087 tok@var3207 =@expr1073766912 list@var872 .@expr1073766913 front (@expr1073766914 ) ; tok@var3207 ; tok@var3207 =@expr1073766915 tok@var3207 .@expr25092 next (@expr25093 ) ) {
9875:
9876:
9877: if (@expr1073766918 Token ::@expr25095 Match (@expr1073766920 tok@var3207 , "enum class|struct| %name%| :|{" ) ) {
9878: skipEnumBody (@expr1073766921 &@expr1073766922 tok@var3207 ) ;
9879: }
9880: if (@expr1073766923 !@expr1073766924 tok@var3207 ) {
9881: syntaxError (@expr1073766925 nullptr ) ; }
9882:
9883: if (@expr1073766926 Token ::@expr25095 Match (@expr1073766928 tok@var3207 , "(|[" ) ||@expr1073766929 Token ::@expr25095 Match (@expr1073766931 tok@var3207 .@expr25108 previous (@expr25109 ) , "%name%|= {" ) ) {
9884: tok@var3207 =@expr1073766934 tok@var3207 .@expr25111 link (@expr25112 ) ;
9885: continue ;
9886: }
9887:
9888: if (@expr1073766937 Token ::@expr25114 simpleMatch (@expr1073766939 tok@var3207 , "= (" ) &&@expr1073766940 Token ::@expr25114 simpleMatch (@expr1073766942 tok@var3207 .@expr25119 linkAt (@expr25120 1 ) , ") {" ) ) {
9889: tok@var3207 =@expr1073766945 tok@var3207 .@expr25119 linkAt (@expr25120 1 ) .@expr1073766948 linkAt (@expr1073766949 1 ) ;
9890: continue ;
9891: }
9892:
9893:
9894: if (@expr1073766950 tok@var3207 .@expr25111 link (@expr25112 ) &&@expr1073766953 tok@var3207 .@expr25130 str (@expr25131 ) ==@expr1073766956 "<" ) {
9895: tok@var3207 =@expr1073766957 tok@var3207 .@expr25111 link (@expr25112 ) ; }
9896:
9897: if (@expr1073766960 tok@var3207 .@expr25130 str (@expr25131 ) ==@expr1073766963 "return" &&@expr1073766964 Token ::@expr25095 Match (@expr1073766966 tok@var3207 .@expr25108 previous (@expr25109 ) , "[;{}]" ) ) {
9898: inReturn@var3206 =@expr1073766969 true ; }
9899:
9900: if (@expr1073766970 inReturn@var3206 &&@expr1073766971 Token ::@expr25095 Match (@expr1073766973 tok@var3207 , "[;{}?:]" ) ) {
9901: inReturn@var3206 =@expr1073766974 false ; }
9902:
9903: if (@expr1073766975 !@expr1073766976 tok@var3207 .@expr25092 next (@expr25093 ) ||@expr1073766979 tok@var3207 .@expr25130 str (@expr25131 ) !=@expr1073766982 "," ) {
9904: continue ; }
9905:
9906:
9907:
9908: if (@expr1073766983 isCPP (@expr25160 ) &&@expr1073766985 tok@var3207 .@expr1073766986 strAt (@expr1073766987 1 ) ==@expr1073766988 "delete" ) {
9909:
9910: tok@var3207 .@expr25130 str (@expr25166 ";" ) ;
9911: }
9912:
9913: if (@expr1073766991 isCPP (@expr25160 ) &&@expr1073766993 Token ::@expr25095 Match (@expr1073766995 tok@var3207 .@expr25172 tokAt (@expr25173 -2 ) , "delete %name% , %name% ;" ) &&@expr1073766998
9914: tok@var3207 .@expr25092 next (@expr25093 ) .@expr1073767001 varId (@expr1073767002 ) !=@expr1073767003 0 ) {
9915:
9916: tok@var3207 .@expr25130 str (@expr25166 ";" ) ;
9917: } else { if (@expr1073767006 !@expr1073767007 inReturn@var3206 &&@expr1073767008 tok@var3207 .@expr25172 tokAt (@expr25173 -2 ) ) {
9918: bool replace@var3208 ; replace@var3208 =@expr1073767011 false ;
9919: for (@expr1073767012 Token *@expr25087 tok2@var3209 =@expr1073767014 tok@var3207 .@expr25108 previous (@expr25109 ) ; tok2@var3209 ; tok2@var3209 =@expr1073767017 tok2@var3209 .@expr1073767018 previous (@expr1073767019 ) ) {
9920: if (@expr1073767020 tok2@var3209 .@expr1073767021 str (@expr1073767022 ) ==@expr1073767023 "=" ) {
9921:
9922: replace@var3208 =@expr1073767024 true ;
9923: } else { if (@expr1073767025 isCPP (@expr25160 ) &&@expr1073767027 (@expr1073767028 Token ::@expr25095 Match (@expr1073767030 tok2@var3209 , "delete %name%" ) ||@expr1073767031
9924: Token ::@expr25095 Match (@expr1073767033 tok2@var3209 , "delete [ ] %name%" ) ) ) {
9925:
9926: replace@var3208 =@expr1073767034 true ;
9927: } else { if (@expr1073767035 Token ::@expr25095 Match (@expr1073767037 tok2@var3209 , "[?:;,{}()]" ) ) {
9928: if (@expr1073767038 replace@var3208 &&@expr1073767039 Token ::@expr25095 Match (@expr1073767041 tok2@var3209 , "[;{}]" ) ) {
9929: tok@var3207 .@expr25130 str (@expr25166 ";" ) ; }
9930: break ;
9931: } } }
9932: }
9933: } }
9934:
9935:
9936: if (@expr1073767044 inReturn@var3206 ) {
9937: Token * startFrom@var3210 ; startFrom@var3210 =@expr1073767045 nullptr ;
9938: Token * endAt@var3211 ; endAt@var3211 =@expr1073767046 nullptr ;
9939:
9940:
9941: for (@expr1073767047 Token *@expr25087 tok2@var3212 =@expr1073767049 tok@var3207 .@expr25108 previous (@expr25109 ) ; tok2@var3212 ; tok2@var3212 =@expr1073767052 tok2@var3212 .@expr25229 previous (@expr25230 ) ) {
9942: if (@expr1073767055 tok2@var3212 .@expr1073767056 str (@expr1073767057 ) ==@expr1073767058 "return" ) {
9943: startFrom@var3210 =@expr1073767059 tok2@var3212 .@expr25229 previous (@expr25230 ) ;
9944: break ;
9945: }
9946: }
9947: if (@expr1073767062 !@expr1073767063 startFrom@var3210 ) {
9948:
9949: return ; }
9950: int commaCounter@var3213 ; commaCounter@var3213 =@expr1073767064 0 ;
9951: for (@expr1073767065 Token *@expr25087 tok2@var3214 =@expr1073767067 startFrom@var3210 .@expr25244 next (@expr25245 ) ; tok2@var3214 ; tok2@var3214 =@expr1073767070 tok2@var3214 .@expr1073767071 next (@expr1073767072 ) ) {
9952: if (@expr1073767073 tok2@var3214 .@expr25250 str (@expr25251 ) ==@expr1073767076 ";" ) {
9953: endAt@var3211 =@expr1073767077 tok2@var3214 ;
9954: break ;
9955:
9956: } else { if (@expr1073767078 Token ::@expr25095 Match (@expr1073767080 tok2@var3214 , "(|[" ) ||@expr1073767081
9957: (@expr1073767082 tok2@var3214 .@expr25250 str (@expr25251 ) ==@expr1073767085 "{" &&@expr1073767086 tok2@var3214 .@expr25263 previous (@expr25264 ) &&@expr1073767089 tok2@var3214 .@expr25263 previous (@expr25264 ) .@expr1073767092 str (@expr1073767093 ) ==@expr1073767094 "=" ) ) {
9958: tok2@var3214 =@expr1073767095 tok2@var3214 .@expr1073767096 link (@expr1073767097 ) ;
9959:
9960: } else { if (@expr1073767098 tok2@var3214 .@expr25250 str (@expr25251 ) ==@expr1073767101 "," ) {
9961: ++@expr1073767102 commaCounter@var3213 ;
9962: } } }
9963: }
9964:
9965: if (@expr1073767103 !@expr1073767104 endAt@var3211 ) {
9966:
9967: return ; }
9968:
9969: if (@expr1073767105 commaCounter@var3213 ) {
9970:
|
9975:
9976: startFrom@var3210 .@expr1073767106 deleteNext (@expr1073767107 ) ;
9977: for (@expr1073767108 Token *@expr25087 tok2@var3215 =@expr1073767110 startFrom@var3210 .@expr25244 next (@expr25245 ) ; tok2@var3215 !=@expr1073767113 endAt@var3211 ; tok2@var3215 =@expr1073767114 tok2@var3215 .@expr1073767115 next (@expr1073767116 ) ) {
9978: if (@expr1073767117 Token ::@expr25095 Match (@expr1073767119 tok2@var3215 , "(|[" ) ||@expr1073767120
9979: (@expr1073767121 tok2@var3215 .@expr25298 str (@expr25299 ) ==@expr1073767124 "{" &&@expr1073767125 tok2@var3215 .@expr25302 previous (@expr25303 ) &&@expr1073767128 tok2@var3215 .@expr25302 previous (@expr25303 ) .@expr1073767131 str (@expr1073767132 ) ==@expr1073767133 "=" ) ) {
9980: tok2@var3215 =@expr1073767134 tok2@var3215 .@expr1073767135 link (@expr1073767136 ) ;
9981:
9982: } else { if (@expr1073767137 tok2@var3215 .@expr25298 str (@expr25299 ) ==@expr1073767140 "," ) {
9983: tok2@var3215 .@expr25298 str (@expr1073767142 ";" ) ;
9984: --@expr1073767143 commaCounter@var3213 ;
9985: if (@expr1073767144 commaCounter@var3213 ==@expr1073767145 0 ) {
9986: tok2@var3215 .@expr1073767146 insertToken (@expr1073767147 "return" ) ;
9987: }
9988: } }
9989: }
9990: tok@var3207 =@expr1073767148 endAt@var3211 ;
9991: }
9992: }
9993: }
9994: }
9995:
9996: void Tokenizer :: checkConfiguration ( ) const
9997: {
9998: if (@expr1073767149 !@expr1073767150 mSettings@var879 .@expr1073767151 checkConfiguration@var3592 ) {
9999: return ; }
10000: for (@expr1073767152 const Token *@expr25329 tok@var3216 =@expr1073767154 tokens (@expr1073767155 ) ; tok@var3216 ; tok@var3216 =@expr1073767156 tok@var3216 .@expr1073767157 next (@expr1073767158 ) ) {
10001: if (@expr1073767159 !@expr1073767160 Token ::@expr25337 Match (@expr1073767162 tok@var3216 , "%name% (" ) ) {
10002: continue ; }
10003: if (@expr1073767163 tok@var3216 .@expr1073767164 isControlFlowKeyword (@expr1073767165 ) ) {
10004: continue ; }
10005: for (@expr1073767166 const Token *@expr25329 tok2@var3217 =@expr1073767168 tok@var3216 .@expr1073767169 tokAt (@expr1073767170 2 ) ; tok2@var3217 &&@expr1073767171 tok2@var3217 .@expr25348 str (@expr25349 ) !=@expr1073767174 ")" ; tok2@var3217 =@expr1073767175 tok2@var3217 .@expr1073767176 next (@expr1073767177 ) ) {
10006: if (@expr1073767178 tok2@var3217 .@expr25348 str (@expr25349 ) ==@expr1073767181 ";" ) {
10007: macroWithSemicolonError (@expr1073767182 tok@var3216 , tok@var3216 .@expr1073767183 str (@expr1073767184 ) ) ;
10008: break ;
10009: }
10010: if (@expr1073767185 Token ::@expr25337 Match (@expr1073767187 tok2@var3217 , "(|{" ) ) {
10011: tok2@var3217 =@expr1073767188 tok2@var3217 .@expr1073767189 link (@expr1073767190 ) ; }
10012: }
10013: }
10014: }
10015:
10016: void Tokenizer :: validateC ( ) const
10017: {
10018: if (@expr1073767191 isCPP (@expr1073767192 ) ) {
10019: return ; }
10020: for (@expr1073767193 const Token *@expr1073767194 tok@var3218 =@expr1073767195 tokens (@expr1073767196 ) ; tok@var3218 ; tok@var3218 =@expr1073767197 tok@var3218 .@expr1073767198 next (@expr1073767199 ) ) {
10021:
10022: if (@expr1073767200 Token ::@expr25377 Match (@expr1073767202 tok@var3218 , "const_cast|dynamic_cast|reinterpret_cast|static_cast <" ) ) {
10023: syntaxErrorC (@expr1073767203 tok@var3218 , "C++ cast <..." ) ; }
10024:
10025: if (@expr1073767204 Token ::@expr25377 Match (@expr1073767206 tok@var3218 , "%name% < %name% > (" ) ) {
10026: const Token * tok2@var3219 ; tok2@var3219 =@expr1073767207 tok@var3218 .@expr1073767208 tokAt (@expr1073767209 5 ) ;
10027: while (@expr1073767210 tok2@var3219 &&@expr1073767211 !@expr1073767212 Token ::@expr25377 Match (@expr1073767214 tok2@var3219 , "[()]" ) ) {
10028: tok2@var3219 =@expr1073767215 tok2@var3219 .@expr1073767216 next (@expr1073767217 ) ; }
10029: if (@expr1073767218 Token ::@expr1073767219 simpleMatch (@expr1073767220 tok2@var3219 , ") {" ) ) {
10030: syntaxErrorC (@expr1073767221 tok@var3218 , tok@var3218 .@expr25398 str (@expr25399 ) +@expr1073767224 '<' +@expr1073767225 tok@var3218 .@expr25402 strAt (@expr25403 2 ) +@expr1073767228 ">() {}" ) ; }
10031: }
10032: if (@expr1073767229 tok@var3218 .@expr25406 previous (@expr25407 ) &&@expr1073767232 !@expr1073767233 Token ::@expr25377 Match (@expr1073767235 tok@var3218 .@expr25406 previous (@expr25407 ) , "[;{}]" ) ) {
10033: continue ; }
10034: if (@expr1073767238 Token ::@expr25377 Match (@expr1073767240 tok@var3218 , "using namespace %name% ;" ) ) {
10035: syntaxErrorC (@expr1073767241 tok@var3218 , "using namespace " +@expr1073767242 tok@var3218 .@expr25402 strAt (@expr25403 2 ) ) ; }
10036: if (@expr1073767245 Token ::@expr25377 Match (@expr1073767247 tok@var3218 , "template < class|typename %name% [,>]" ) ) {
10037: syntaxErrorC (@expr1073767248 tok@var3218 , "template<..." ) ; }
10038: if (@expr1073767249 Token ::@expr25377 Match (@expr1073767251 tok@var3218 , "%name% :: %name%" ) ) {
10039: syntaxErrorC (@expr25428 tok@var3218 , tok@var3218 .@expr25398 str (@expr25399 ) +@expr25431 tok@var3218 .@expr25402 strAt (@expr25433 1 ) +@expr25434 tok@var3218 .@expr25402 strAt (@expr25403 2 ) ) ; }
10040: if (@expr1073767261 Token ::@expr25377 Match (@expr1073767263 tok@var3218 , "class|namespace %name% [:{]" ) ) {
10041: syntaxErrorC (@expr25428 tok@var3218 , tok@var3218 .@expr25398 str (@expr25399 ) +@expr25431 tok@var3218 .@expr25402 strAt (@expr25433 1 ) +@expr25434 tok@var3218 .@expr25402 strAt (@expr25403 2 ) ) ; }
10042: }
10043: }
10044:
10045: void Tokenizer :: validate ( ) const
10046: {
10047: std ::@expr1073767273 stack < const Token *@expr25450 > linkTokens@var3220 ;
10048: const Token * lastTok@var3221 ; lastTok@var3221 =@expr1073767275 nullptr ;
10049: for (@expr1073767276 const Token *@expr25450 tok@var3222 =@expr1073767278 tokens (@expr1073767279 ) ; tok@var3222 ; tok@var3222 =@expr1073767280 tok@var3222 .@expr1073767281 next (@expr1073767282 ) ) {
10050: lastTok@var3221 =@expr1073767283 tok@var3222 ;
10051: if (@expr1073767284 Token ::@expr25461 Match (@expr1073767286 tok@var3222 , "[{([]" ) ||@expr1073767287 (@expr1073767288 tok@var3222 .@expr1073767289 str (@expr1073767290 ) ==@expr1073767291 "<" &&@expr1073767292 tok@var3222 .@expr25469 link (@expr25470 ) ) ) {
10052: if (@expr25471 tok@var3222 .@expr25469 link (@expr25470 ) ==@expr25474 nullptr ) {
10053: cppcheckError (@expr25475 tok@var3222 ) ; }
10054:
10055: linkTokens@var3220 .@expr1073767300 push (@expr1073767301 tok@var3222 ) ;
10056: }
10057:
10058: else { if (@expr1073767302 Token ::@expr25461 Match (@expr1073767304 tok@var3222 , "[})]]" ) ||@expr1073767305 (@expr1073767306 Token ::@expr25461 Match (@expr1073767308 tok@var3222 , ">|>>" ) &&@expr1073767309 tok@var3222 .@expr25469 link (@expr25470 ) ) ) {
10059: if (@expr25471 tok@var3222 .@expr25469 link (@expr25470 ) ==@expr25474 nullptr ) {
10060: cppcheckError (@expr25475 tok@var3222 ) ; }
10061:
10062: if (@expr1073767317 linkTokens@var3220 .@expr25494 empty (@expr25495 ) ==@expr1073767320 true ) {
10063: cppcheckError (@expr25475 tok@var3222 ) ; }
10064:
10065: if (@expr1073767322 tok@var3222 .@expr25469 link (@expr25470 ) !=@expr1073767325 linkTokens@var3220 .@expr25502 top (@expr25503 ) ) {
10066: cppcheckError (@expr25475 tok@var3222 ) ; }
10067:
10068: if (@expr1073767329 tok@var3222 !=@expr1073767330 tok@var3222 .@expr25469 link (@expr25470 ) .@expr1073767333 link (@expr1073767334 ) ) {
10069: cppcheckError (@expr25475 tok@var3222 ) ; }
10070:
10071: linkTokens@var3220 .@expr1073767336 pop (@expr1073767337 ) ;
10072: }
10073:
10074: else { if (@expr1073767338 tok@var3222 .@expr25469 link (@expr25470 ) !=@expr1073767341 nullptr ) {
10075: cppcheckError (@expr25475 tok@var3222 ) ; } } }
10076: }
10077:
10078: if (@expr1073767343 !@expr1073767344 linkTokens@var3220 .@expr25494 empty (@expr25495 ) ) {
10079: cppcheckError (@expr1073767347 linkTokens@var3220 .@expr25502 top (@expr25503 ) ) ; }
10080:
10081:
10082: if (@expr1073767350 lastTok@var3221 !=@expr1073767351 list@var872 .@expr1073767352 back (@expr1073767353 ) ) {
10083: cppcheckError (@expr1073767354 lastTok@var3221 ) ; }
10084: }
10085:
10086: static const Token * findUnmatchedTernaryOp ( const Token * const begin@var3223 , const Token * const end@var3224 , int depth@var3225 = 0 )
10087: {
10088: std ::@expr1073767355 stack < const Token *@expr25532 > ternaryOp@var3226 ;
10089: for (@expr1073767357 const Token *@expr25532 tok@var3227 =@expr1073767359 begin@var3223 ; tok@var3227 !=@expr1073767360 end@var3224 &&@expr1073767361 tok@var3227 .@expr25538 str (@expr25539 ) !=@expr1073767364 ";" ; tok@var3227 =@expr1073767365 tok@var3227 .@expr25542 next (@expr25543 ) ) {
10090: if (@expr1073767368 tok@var3227 .@expr25538 str (@expr25539 ) ==@expr1073767371 "?" ) {
10091: ternaryOp@var3226 .@expr1073767372 push (@expr1073767373 tok@var3227 ) ; }
10092: else { if (@expr1073767374 !@expr1073767375 ternaryOp@var3226 .@expr25552 empty (@expr25553 ) &&@expr1073767378 tok@var3227 .@expr25538 str (@expr25539 ) ==@expr1073767381 ":" ) {
10093: ternaryOp@var3226 .@expr1073767382 pop (@expr1073767383 ) ; }
10094: else { if (@expr1073767384 depth@var3225 <@expr1073767385 100 &&@expr1073767386 Token ::@expr1073767387 Match (@expr1073767388 tok@var3227 , "(|[" ) ) {
10095: const Token * inner@var3228 ; inner@var3228 =@expr1073767389 findUnmatchedTernaryOp (@expr1073767390 tok@var3227 .@expr25542 next (@expr25543 ) , tok@var3227 .@expr25569 link (@expr25570 ) , depth@var3225 +@expr1073767395 1 ) ;
10096: if (@expr1073767396 inner@var3228 ) {
10097: return inner@var3228 ; }
10098: tok@var3227 =@expr1073767397 tok@var3227 .@expr25569 link (@expr25570 ) ;
10099: } } }
10100: }
10101: return ternaryOp@var3226 .@expr25552 empty (@expr25553 ) ?@expr1073767402 nullptr :@expr1073767403 ternaryOp@var3226 .@expr1073767404 top (@expr1073767405 ) ;
10102: }
10103:
10104: static bool isCPPAttribute ( const Token * tok@var3229 )
10105: {
10106: return Token ::@expr1073767406 simpleMatch (@expr1073767407 tok@var3229 , "[ [" ) &&@expr1073767408 tok@var3229 .@expr25585 link (@expr25586 ) &&@expr1073767411 tok@var3229 .@expr25585 link (@expr25586 ) .@expr1073767414 previous (@expr1073767415 ) ==@expr1073767416 tok@var3229 .@expr1073767417 linkAt (@expr1073767418 1 ) ;
10107: }
10108:
10109: static bool isAlignAttribute ( const Token * tok@var3230 )
10110: {
10111: return Token ::@expr1073767419 simpleMatch (@expr1073767420 tok@var3230 , "alignas (" ) &&@expr1073767421 tok@var3230 .@expr1073767422 next (@expr1073767423 ) .@expr1073767424 link (@expr1073767425 ) ;
10112: }
10113:
10114: static const Token * skipCPPOrAlignAttribute ( const Token * tok@var3231 )
10115: {
10116: if (@expr1073767426 isCPPAttribute (@expr1073767427 tok@var3231 ) ) {
10117: return tok@var3231 .@expr1073767428 link (@expr1073767429 ) ;
10118: } else { if (@expr1073767430 isAlignAttribute (@expr1073767431 tok@var3231 ) ) {
10119: return tok@var3231 .@expr1073767432 next (@expr1073767433 ) .@expr1073767434 link (@expr1073767435 ) ;
10120: } }
10121: return tok@var3231 ;
10122: }
10123:
10124: static bool isNonMacro ( const Token * tok@var3232 )
10125: {
10126: if (@expr1073767436 tok@var3232 .@expr1073767437 isKeyword (@expr1073767438 ) ) {
10127: return true ; }
10128: if (@expr1073767439 cAlternativeTokens@var2975 .@expr1073767440 count (@expr1073767441 tok@var3232 .@expr25618 str (@expr25619 ) ) >@expr1073767444 0 ) {
10129: return true ; }
10130: if (@expr1073767445 tok@var3232 .@expr25618 str (@expr25619 ) .@expr1073767448 compare (@expr1073767449 0 , 2 , "__" ) ==@expr1073767450 0 ) {
10131: return true ; }
10132: return false ;
10133: }
10134:
10135: void Tokenizer :: reportUnknownMacros ( ) const
10136: {
10137:
10138: for (@expr1073767451 const Token *@expr25628 tok@var3233 =@expr1073767453 tokens (@expr25630 ) ; tok@var3233 ; tok@var3233 =@expr1073767455 tok@var3233 .@expr1073767456 next (@expr1073767457 ) ) {
10139: if (@expr1073767458 Token ::@expr25635 Match (@expr1073767460 tok@var3233 , "%name% %num%" ) ) {
10140:
10141: if (@expr1073767461 tok@var3233 .@expr1073767462 isKeyword (@expr1073767463 ) ) {
10142: continue ; }
10143:
10144: if (@expr1073767464 Token ::@expr25635 Match (@expr1073767466 tok@var3233 .@expr1073767467 previous (@expr1073767468 ) , "%op%|(" ) ) {
10145: unknownMacroError (@expr1073767469 tok@var3233 ) ; }
10146: }
10147: }
10148:
10149:
10150: for (@expr1073767470 const Token *@expr25628 tok@var3234 =@expr1073767472 tokens (@expr25630 ) ; tok@var3234 ; tok@var3234 =@expr1073767474 tok@var3234 .@expr1073767475 next (@expr1073767476 ) ) {
10151: if (@expr1073767477 !@expr1073767478 Token ::@expr25635 Match (@expr1073767480 tok@var3234 , "%name% (" ) ) {
10152: continue ; }
10153: if (@expr1073767481 !@expr1073767482 tok@var3234 .@expr1073767483 isUpperCaseName (@expr1073767484 ) ) {
10154: continue ; }
10155: const Token * endTok@var3235 ; endTok@var3235 =@expr1073767485 tok@var3234 .@expr1073767486 linkAt (@expr1073767487 1 ) ;
10156: for (@expr1073767488 const Token *@expr25628 inner@var3236 =@expr1073767490 tok@var3234 .@expr1073767491 tokAt (@expr1073767492 2 ) ; inner@var3236 !=@expr1073767493 endTok@var3235 ; inner@var3236 =@expr1073767494 inner@var3236 .@expr1073767495 next (@expr1073767496 ) ) {
10157: if (@expr1073767497 Token ::@expr25635 Match (@expr1073767499 inner@var3236 , "[[({]" ) ) {
10158: inner@var3236 =@expr1073767500 inner@var3236 .@expr1073767501 link (@expr1073767502 ) ; }
10159: else { if (@expr1073767503 inner@var3236 .@expr1073767504 str (@expr1073767505 ) ==@expr1073767506 ";" ) {
10160: unknownMacroError (@expr1073767507 inner@var3236 ) ; } }
10161: }
10162: }
10163:
10164:
10165: for (@expr1073767508 const Token *@expr25628 tok@var3237 =@expr1073767510 tokens (@expr25630 ) ; tok@var3237 ; tok@var3237 =@expr1073767512 tok@var3237 .@expr1073767513 next (@expr1073767514 ) ) {
10166: if (@expr1073767515 !@expr1073767516 Token ::@expr25635 Match (@expr1073767518 tok@var3237 , "%name% (" ) ) {
10167: continue ; }
10168: const Token * endTok@var3238 ; endTok@var3238 =@expr1073767519 tok@var3237 .@expr1073767520 linkAt (@expr1073767521 1 ) ;
10169: for (@expr1073767522 const Token *@expr25628 inner@var3239 =@expr1073767524 tok@var3237 .@expr1073767525 tokAt (@expr1073767526 2 ) ; inner@var3239 !=@expr1073767527 endTok@var3238 ; inner@var3239 =@expr1073767528 inner@var3239 .@expr1073767529 next (@expr1073767530 ) ) {
10170: if (@expr1073767531 Token ::@expr25635 Match (@expr1073767533 inner@var3239 , "[[({]" ) ) {
10171: inner@var3239 =@expr1073767534 inner@var3239 .@expr1073767535 link (@expr1073767536 ) ; }
10172: else { if (@expr1073767537 Token ::@expr25635 Match (@expr1073767539 inner@var3239 .@expr1073767540 previous (@expr1073767541 ) , "[,(] . %name% =|{" ) ) {
10173: unknownMacroError (@expr1073767542 tok@var3237 ) ; } }
10174: }
10175: }
10176:
10177:
10178: std ::@expr1073767543 set < std ::@expr1073767544 string > possible@var3240 ;
10179: for (@expr1073767545 const Token *@expr25628 tok@var3241 =@expr1073767547 tokens (@expr25630 ) ; tok@var3241 ; tok@var3241 =@expr1073767549 tok@var3241 .@expr1073767550 next (@expr1073767551 ) ) {
10180:
10181: if (@expr1073767552 tok@var3241 .@expr25729 str (@expr25730 ) ==@expr1073767555 "{" ) {
10182: const Token * prev@var3242 ; prev@var3242 =@expr1073767556 tok@var3241 .@expr1073767557 previous (@expr1073767558 ) ;
10183: while (@expr1073767559 prev@var3242 &&@expr1073767560 prev@var3242 .@expr1073767561 isName (@expr1073767562 ) ) {
10184: prev@var3242 =@expr1073767563 prev@var3242 .@expr1073767564 previous (@expr1073767565 ) ; }
10185: if (@expr1073767566 prev@var3242 &&@expr1073767567 prev@var3242 .@expr1073767568 str (@expr1073767569 ) ==@expr1073767570 ")" ) {
10186: tok@var3241 =@expr1073767571 tok@var3241 .@expr25748 link (@expr25749 ) ; }
10187: else {
10188: possible@var3240 .@expr25750 clear (@expr25751 ) ; }
10189: } else { if (@expr1073767576 tok@var3241 .@expr25729 str (@expr25730 ) ==@expr1073767579 "}" ) {
10190: possible@var3240 .@expr25750 clear (@expr25751 ) ; } }
10191:
10192: if (@expr1073767582 Token ::@expr25635 Match (@expr25760 tok@var3241 , "%name% (" ) &&@expr25761 tok@var3241 .@expr25762 isUpperCaseName (@expr25763 ) &&@expr1073767588 Token ::@expr25765 simpleMatch (@expr1073767590 tok@var3241 .@expr25767 linkAt (@expr25768 1 ) , ") (" ) &&@expr1073767593 Token ::@expr25765 simpleMatch (@expr1073767595 tok@var3241 .@expr25767 linkAt (@expr25768 1 ) .@expr25774 linkAt (@expr25775 1 ) , ") {" ) ) {
10193:
10194: if (@expr1073767600 tok@var3241 .@expr1073767601 isKeyword (@expr1073767602 ) ) {
10195: continue ; }
10196:
10197: const Token * bodyStart@var3243 ; bodyStart@var3243 =@expr1073767603 tok@var3241 .@expr25767 linkAt (@expr25768 1 ) .@expr25774 linkAt (@expr25775 1 ) .@expr1073767608 tokAt (@expr1073767609 2 ) ;
10198: const Token * bodyEnd@var3244 ; bodyEnd@var3244 =@expr1073767610 tok@var3241 .@expr25748 link (@expr25749 ) ;
10199: for (@expr1073767613 const Token *@expr25628 tok2@var3245 =@expr1073767615 bodyStart@var3243 ; tok2@var3245 &&@expr1073767616 tok2@var3245 !=@expr1073767617 bodyEnd@var3244 ; tok2@var3245 =@expr1073767618 tok2@var3245 .@expr1073767619 next (@expr1073767620 ) ) {
10200: if (@expr1073767621 Token ::@expr25635 Match (@expr1073767623 tok2@var3245 , "if|switch|for|while|return" ) ) {
10201: unknownMacroError (@expr25800 tok@var3241 ) ; }
10202: }
10203: } else { if (@expr1073767625 Token ::@expr25635 Match (@expr25760 tok@var3241 , "%name% (" ) &&@expr25761 tok@var3241 .@expr25762 isUpperCaseName (@expr25763 ) &&@expr1073767631 Token ::@expr25635 Match (@expr1073767633 tok@var3241 .@expr25767 linkAt (@expr25768 1 ) , ") %name% (" ) &&@expr1073767636 Token ::@expr25635 Match (@expr1073767638 tok@var3241 .@expr25767 linkAt (@expr25768 1 ) .@expr25774 linkAt (@expr1073767642 2 ) , ") [;{]" ) ) {
10204: if (@expr1073767643 !@expr1073767644 (@expr1073767645 tok@var3241 .@expr25767 linkAt (@expr25768 1 ) .@expr25824 next (@expr25825 ) &&@expr1073767650 tok@var3241 .@expr25767 linkAt (@expr25768 1 ) .@expr25824 next (@expr25825 ) .@expr1073767655 isKeyword (@expr1073767656 ) ) ) {
10205: if (@expr1073767657 possible@var3240 .@expr1073767658 count (@expr1073767659 tok@var3241 .@expr25729 str (@expr25730 ) ) ==@expr1073767662 0 ) {
10206: possible@var3240 .@expr1073767663 insert (@expr1073767664 tok@var3241 .@expr25729 str (@expr25730 ) ) ; }
10207: else {
10208: unknownMacroError (@expr25800 tok@var3241 ) ; }
10209: }
10210: } }
10211: }
10212:
10213:
10214: for (@expr1073767668 const Token *@expr25628 tok@var3246 =@expr1073767670 tokens (@expr25630 ) ; tok@var3246 ; tok@var3246 =@expr1073767672 tok@var3246 .@expr25849 next (@expr25850 ) ) {
10215: if (@expr1073767675 Token ::@expr25635 Match (@expr1073767677 tok@var3246 , "%str% %name% (" ) &&@expr1073767678 Token ::@expr25635 Match (@expr1073767680 tok@var3246 .@expr25857 linkAt (@expr25858 2 ) , ") %str%" ) ) {
10216: if (@expr1073767683 tok@var3246 .@expr25849 next (@expr25850 ) .@expr25862 isKeyword (@expr25863 ) ) {
10217: continue ; }
10218: unknownMacroError (@expr25864 tok@var3246 .@expr25849 next (@expr25850 ) ) ;
10219: }
10220: if (@expr1073767691 Token ::@expr25635 Match (@expr1073767693 tok@var3246 , "[(,] %name% (" ) &&@expr1073767694 Token ::@expr25635 Match (@expr1073767696 tok@var3246 .@expr25857 linkAt (@expr25858 2 ) , ") %name% %name%|,|)" ) ) {
10221: if (@expr1073767699 tok@var3246 .@expr25849 next (@expr25850 ) .@expr25862 isKeyword (@expr25863 ) ||@expr1073767704 tok@var3246 .@expr25857 linkAt (@expr25858 2 ) .@expr25883 next (@expr25884 ) .@expr1073767709 isKeyword (@expr1073767710 ) ) {
10222: continue ; }
10223: if (@expr1073767711 cAlternativeTokens@var2975 .@expr1073767712 count (@expr1073767713 tok@var3246 .@expr25857 linkAt (@expr25858 2 ) .@expr25883 next (@expr25884 ) .@expr1073767718 str (@expr1073767719 ) ) >@expr1073767720 0 ) {
10224: continue ; }
10225: if (@expr1073767721 tok@var3246 .@expr25849 next (@expr25850 ) .@expr1073767724 str (@expr1073767725 ) .@expr1073767726 compare (@expr1073767727 0 , 2 , "__" ) ==@expr1073767728 0 ) {
10226: continue ; }
10227: unknownMacroError (@expr25864 tok@var3246 .@expr25849 next (@expr25850 ) ) ;
10228: }
10229: }
10230:
10231:
10232: for (@expr1073767732 const Token *@expr25628 tok@var3247 =@expr1073767734 tokens (@expr25630 ) ; tok@var3247 ; tok@var3247 =@expr1073767736 tok@var3247 .@expr1073767737 next (@expr1073767738 ) ) {
10233: if (@expr1073767739 !@expr1073767740 Token ::@expr25635 Match (@expr1073767742 tok@var3247 , "%name% (" ) ) {
10234: continue ; }
10235: if (@expr1073767743 isNonMacro (@expr1073767744 tok@var3247 ) ) {
10236: continue ; }
10237:
10238: const Token * endTok@var3248 ; endTok@var3248 =@expr1073767745 tok@var3247 .@expr1073767746 linkAt (@expr1073767747 1 ) ;
10239: if (@expr1073767748 !@expr1073767749 Token ::@expr25635 Match (@expr1073767751 endTok@var3248 , ") %name% (|." ) ) {
10240: continue ; }
10241:
10242: const Token * tok2@var3249 ; tok2@var3249 =@expr1073767752 endTok@var3248 .@expr1073767753 next (@expr1073767754 ) ;
10243: if (@expr1073767755 isNonMacro (@expr1073767756 tok2@var3249 ) ) {
10244: continue ; }
10245:
10246: if (@expr1073767757 tok2@var3249 .@expr1073767758 next (@expr1073767759 ) .@expr1073767760 str (@expr1073767761 ) ==@expr1073767762 "(" ) {
10247: if (@expr1073767763 Token ::@expr25635 Match (@expr1073767765 tok@var3247 .@expr1073767766 previous (@expr1073767767 ) , "%name%|::|>" ) ) {
10248: continue ; }
10249: }
10250:
10251: unknownMacroError (@expr1073767768 tok@var3247 ) ;
10252: }
10253: }
10254:
10255: void Tokenizer :: findGarbageCode ( ) const
10256: {
10257: const bool isCPP11@var3250 =@expr1073767769 isCPP (@expr25946 ) &&@expr1073767771 mSettings@var879 .@expr25948 standards@var3567 .@expr25949 cpp@var3568 >=@expr1073767774 Standards ::@expr1073767775 CPP11 ;
10258:
10259: static const std ::@expr25952 unordered_set < std ::@expr25952 string > nonConsecutiveKeywords@var3251 {@expr1073767778 "break" ,
10260: "continue" ,
10261: "for" ,
10262: "goto" ,
10263: "if" ,
10264: "return" ,
10265: "switch" ,
10266: "throw" ,
10267: "typedef" ,
10268: "while" } ;
10269:
10270: for (@expr1073767779 const Token *@expr25956 tok@var3252 =@expr1073767781 tokens (@expr25958 ) ; tok@var3252 ; tok@var3252 =@expr1073767783 tok@var3252 .@expr25960 next (@expr25961 ) ) {
10271:
10272: if (@expr1073767786 Token ::@expr25963 simpleMatch (@expr1073767788 tok@var3252 , "= {" ) &&@expr1073767789 Token ::@expr25963 simpleMatch (@expr1073767791 tok@var3252 .@expr25968 linkAt (@expr25969 1 ) , "} (" ) ) {
10273: syntaxError (@expr1073767794 tok@var3252 .@expr25968 linkAt (@expr25969 1 ) ) ; }
10274:
10275:
10276: else { if (@expr1073767797 tok@var3252 .@expr25974 str (@expr25975 ) ==@expr1073767800 "[" ) {
10277: for (@expr1073767801 const Token *@expr25956 inner@var3253 =@expr1073767803 tok@var3252 .@expr25960 next (@expr25961 ) ; inner@var3253 !=@expr1073767806 tok@var3252 .@expr1073767807 link (@expr1073767808 ) ; inner@var3253 =@expr1073767809 inner@var3253 .@expr1073767810 next (@expr1073767811 ) ) {
10278: if (@expr1073767812 Token ::@expr25989 Match (@expr1073767814 inner@var3253 , "(|[|{" ) ) {
10279: inner@var3253 =@expr1073767815 inner@var3253 .@expr1073767816 link (@expr1073767817 ) ; }
10280: else { if (@expr1073767818 Token ::@expr25989 Match (@expr1073767820 inner@var3253 , ";|goto|return|typedef" ) ) {
10281: syntaxError (@expr1073767821 inner@var3253 ) ; } }
10282: }
10283: }
10284:
10285:
10286: else { if (@expr1073767822 Token ::@expr25989 Match (@expr1073767824 tok@var3252 , "%assign% [" ) &&@expr1073767825 Token ::@expr25963 simpleMatch (@expr1073767827 tok@var3252 .@expr25968 linkAt (@expr25969 1 ) , "] ;" ) ) {
10287: syntaxError (@expr1073767830 tok@var3252 , tok@var3252 .@expr25974 str (@expr25975 ) +@expr1073767833 "[...];" ) ; } } }
10288:
10289:
10290: if (@expr1073767834 tok@var3252 .@expr26011 isKeyword (@expr26012 ) &&@expr1073767837 Token ::@expr25989 Match (@expr1073767839 tok@var3252 , "throw|return )" ) &&@expr1073767840 Token ::@expr25989 Match (@expr1073767842 tok@var3252 .@expr25968 linkAt (@expr25969 1 ) .@expr26021 previous (@expr26022 ) , "%name% (" ) ) {
10291: unknownMacroError (@expr1073767847 tok@var3252 .@expr25968 linkAt (@expr25969 1 ) .@expr26021 previous (@expr26022 ) ) ; }
10292:
10293:
10294: else { if (@expr1073767852 Token ::@expr25989 Match (@expr1073767854 tok@var3252 , "%name% throw|return" ) &&@expr1073767855 std ::@expr1073767856 isupper (@expr1073767857 tok@var3252 .@expr25974 str (@expr25975 ) [@expr1073767860 0 ] ) ) {
10295: unknownMacroError (@expr1073767861 tok@var3252 ) ; }
10296:
10297:
10298: else { if (@expr1073767862 Token ::@expr25989 Match (@expr1073767864 tok@var3252 , "!!) %num%|%str%|%char% %assign%|++|--" ) ) {
10299: if (@expr1073767865 !@expr1073767866 isCPP (@expr25946 ) ||@expr1073767868 mSettings@var879 .@expr25948 standards@var3567 .@expr25949 cpp@var3568 <@expr1073767871 Standards ::@expr26048 CPP20 ||@expr1073767873 !@expr1073767874 Token ::@expr25989 Match (@expr1073767876 tok@var3252 .@expr26053 previous (@expr26054 ) , "%name% : %num% =" ) ) {
10300: syntaxError (@expr1073767879 tok@var3252 , tok@var3252 .@expr25960 next (@expr25961 ) .@expr26058 str (@expr26059 ) +@expr1073767884 " " +@expr1073767885 tok@var3252 .@expr1073767886 strAt (@expr1073767887 2 ) ) ; }
10301: } } }
10302:
10303: if (@expr1073767888 tok@var3252 .@expr1073767889 isControlFlowKeyword (@expr1073767890 ) &&@expr1073767891 Token ::@expr25989 Match (@expr1073767893 tok@var3252 , "if|while|for|switch" ) ) {
10304: if (@expr1073767894 tok@var3252 .@expr26053 previous (@expr26054 ) &&@expr1073767897 !@expr1073767898 Token ::@expr25989 Match (@expr1073767900 tok@var3252 .@expr26053 previous (@expr26054 ) , "%name%|:|;|{|}|)" ) ) {
10305: if (@expr1073767903 Token ::@expr25989 Match (@expr1073767905 tok@var3252 .@expr26053 previous (@expr26054 ) , "[,(]" ) ) {
10306: const Token * prev@var3254 ; prev@var3254 =@expr1073767908 tok@var3252 .@expr26053 previous (@expr26054 ) ;
10307: while (@expr1073767911 prev@var3254 &&@expr1073767912 prev@var3254 .@expr26089 str (@expr26090 ) !=@expr1073767915 "(" ) {
10308: if (@expr1073767916 prev@var3254 .@expr26089 str (@expr26090 ) ==@expr1073767919 ")" ) {
10309: prev@var3254 =@expr1073767920 prev@var3254 .@expr1073767921 link (@expr1073767922 ) ; }
10310: prev@var3254 =@expr1073767923 prev@var3254 .@expr26100 previous (@expr26101 ) ;
10311: }
10312: if (@expr1073767926 prev@var3254 &&@expr1073767927 Token ::@expr25989 Match (@expr1073767929 prev@var3254 .@expr26100 previous (@expr26101 ) , "%name% (" ) ) {
10313: unknownMacroError (@expr1073767932 prev@var3254 .@expr26100 previous (@expr26101 ) ) ; }
10314: }
10315: if (@expr1073767935 !@expr26112 Token ::@expr25963 simpleMatch (@expr26114 tok@var3252 .@expr26115 tokAt (@expr26116 -2 ) , "operator \"\" if" ) ) {
10316: syntaxError (@expr26117 tok@var3252 ) ; }
10317: }
10318: if (@expr1073767942 !@expr1073767943 Token ::@expr25989 Match (@expr1073767945 tok@var3252 .@expr25960 next (@expr25961 ) , "( !!)" ) ) {
10319: syntaxError (@expr26117 tok@var3252 ) ; }
10320: if (@expr1073767949 tok@var3252 .@expr25974 str (@expr25975 ) !=@expr1073767952 "for" ) {
10321: if (@expr1073767953 isGarbageExpr (@expr1073767954 tok@var3252 .@expr25960 next (@expr25961 ) , tok@var3252 .@expr25968 linkAt (@expr25969 1 ) , mSettings@var879 .@expr25948 standards@var3567 .@expr25949 cpp@var3568 >=@expr1073767961 Standards ::@expr1073767962 cppstd_t ::@expr1073767963 CPP17 ) ) {
10322: syntaxError (@expr26117 tok@var3252 ) ; }
10323: }
10324: }
10325:
10326:
10327: if (@expr1073767965 tok@var3252 .@expr26011 isKeyword (@expr26012 ) &&@expr1073767968 nonConsecutiveKeywords@var3251 .@expr26145 count (@expr1073767970 tok@var3252 .@expr25974 str (@expr25975 ) ) !=@expr1073767973 0 ) {
10328: if (@expr1073767974 Token ::@expr25989 Match (@expr1073767976 tok@var3252 , "%name% %name%" ) &&@expr1073767977 nonConsecutiveKeywords@var3251 .@expr26145 count (@expr1073767979 tok@var3252 .@expr25960 next (@expr25961 ) .@expr26058 str (@expr26059 ) ) ==@expr1073767984 1 ) {
10329: syntaxError (@expr26117 tok@var3252 ) ; }
10330: const Token * prev@var3255 ; prev@var3255 =@expr1073767986 tok@var3252 ;
10331: while (@expr1073767987 prev@var3255 &&@expr1073767988 prev@var3255 .@expr1073767989 isName (@expr1073767990 ) ) {
10332: prev@var3255 =@expr1073767991 prev@var3255 .@expr1073767992 previous (@expr1073767993 ) ; }
10333: if (@expr1073767994 Token ::@expr25989 Match (@expr1073767996 prev@var3255 , "%op%|%num%|%str%|%char%" ) ) {
10334: if (@expr1073767997 !@expr26112 Token ::@expr25963 simpleMatch (@expr26114 tok@var3252 .@expr26115 tokAt (@expr26116 -2 ) , "operator \"\" if" ) &&@expr1073768003
10335: !@expr1073768004 Token ::@expr25963 simpleMatch (@expr1073768006 tok@var3252 .@expr26115 tokAt (@expr26116 -2 ) , "extern \"C\"" ) ) {
10336: syntaxError (@expr1073768009 tok@var3252 , prev@var3255 ==@expr1073768010 tok@var3252 .@expr26053 previous (@expr26054 ) ?@expr1073768013 (@expr1073768014 prev@var3255 .@expr26191 str (@expr26192 ) +@expr1073768017 " " +@expr1073768018 tok@var3252 .@expr25974 str (@expr25975 ) ) :@expr1073768021 (@expr1073768022 prev@var3255 .@expr26191 str (@expr26192 ) +@expr1073768025 " .. " +@expr1073768026 tok@var3252 .@expr25974 str (@expr25975 ) ) ) ; }
10337: }
10338: }
10339: }
10340:
10341:
10342: for (@expr1073768029 const Token *@expr25956 tok@var3256 =@expr1073768031 tokens (@expr25958 ) ; tok@var3256 ; tok@var3256 =@expr1073768033 tok@var3256 .@expr26210 next (@expr26211 ) ) {
10343: if (@expr1073768036 Token ::@expr25989 Match (@expr1073768038 tok@var3256 , "struct|class|enum %name%| {" ) &&@expr1073768039 (@expr1073768040 !@expr1073768041 tok@var3256 .@expr26218 previous (@expr26219 ) ||@expr1073768044 Token ::@expr25989 Match (@expr1073768046 tok@var3256 .@expr26218 previous (@expr26219 ) , "[;{}]" ) ) ) {
10344: const Token * tok2@var3257 ; tok2@var3257 =@expr1073768049 tok@var3256 .@expr1073768050 linkAt (@expr1073768051 tok@var3256 .@expr26210 next (@expr26211 ) .@expr1073768054 isName (@expr1073768055 ) ?@expr1073768056 2 :@expr1073768057 1 ) ;
10345: if (@expr1073768058 Token ::@expr25989 Match (@expr1073768060 tok2@var3257 , "} %op%" ) ) {
10346: tok2@var3257 =@expr1073768061 tok2@var3257 .@expr26238 next (@expr26239 ) ;
10347: if (@expr1073768064 !@expr1073768065 Token ::@expr25989 Match (@expr26243 tok2@var3257 , "*|&|&&" ) ) {
10348: syntaxError (@expr26244 tok2@var3257 , "Unexpected token '" +@expr26245 tok2@var3257 .@expr26246 str (@expr26247 ) +@expr26248 "'" ) ; }
10349: while (@expr1073768073 Token ::@expr25989 Match (@expr26243 tok2@var3257 , "*|&|&&" ) ) {
10350: tok2@var3257 =@expr1073768076 tok2@var3257 .@expr26238 next (@expr26239 ) ; }
10351: if (@expr1073768079 !@expr1073768080 Token ::@expr25989 Match (@expr1073768082 tok2@var3257 , "%name%" ) ) {
10352: syntaxError (@expr26244 tok2@var3257 , "Unexpected token '" +@expr26245 tok2@var3257 .@expr26246 str (@expr26247 ) +@expr26248 "'" ) ; }
10353: }
10354: }
10355: }
10356:
10357:
10358: static const std ::@expr25952 unordered_set < std ::@expr25952 string > nonGlobalKeywords@var3258 {@expr1073768090 "break" ,
10359: "continue" ,
10360: "for" ,
10361: "goto" ,
10362: "if" ,
10363: "return" ,
10364: "switch" ,
10365: "while" ,
10366: "try" ,
10367: "catch" } ;
10368: for (@expr1073768091 const Token *@expr25956 tok@var3259 =@expr1073768093 tokens (@expr25958 ) ; tok@var3259 ; tok@var3259 =@expr1073768095 tok@var3259 .@expr1073768096 next (@expr1073768097 ) ) {
10369: if (@expr1073768098 tok@var3259 .@expr26275 str (@expr26276 ) ==@expr1073768101 "{" ) {
10370: tok@var3259 =@expr1073768102 tok@var3259 .@expr1073768103 link (@expr1073768104 ) ; }
10371: else { if (@expr1073768105 tok@var3259 .@expr1073768106 isKeyword (@expr1073768107 ) &&@expr1073768108 nonGlobalKeywords@var3258 .@expr1073768109 count (@expr1073768110 tok@var3259 .@expr26275 str (@expr26276 ) ) &&@expr1073768113 !@expr1073768114 Token ::@expr25989 Match (@expr1073768116 tok@var3259 .@expr1073768117 tokAt (@expr1073768118 -2 ) , "operator %str%" ) ) {
10372: syntaxError (@expr1073768119 tok@var3259 , "keyword '" +@expr1073768120 tok@var3259 .@expr26275 str (@expr26276 ) +@expr1073768123 "' is not allowed in global scope" ) ; } }
10373: }
10374:
10375:
10376: for (@expr1073768124 const Token *@expr25956 tok@var3260 =@expr1073768126 tokens (@expr25958 ) ; tok@var3260 ; tok@var3260 =@expr1073768128 tok@var3260 .@expr26305 next (@expr26306 ) ) {
10377: if (@expr1073768131 Token ::@expr25963 simpleMatch (@expr1073768133 tok@var3260 , "switch (" ) ) {
10378: if (@expr1073768134 Token ::@expr25963 simpleMatch (@expr1073768136 tok@var3260 .@expr26313 linkAt (@expr26314 1 ) , ") {" ) ) {
10379: tok@var3260 =@expr1073768139 tok@var3260 .@expr26313 linkAt (@expr26314 1 ) .@expr1073768142 linkAt (@expr1073768143 1 ) ;
10380: continue ;
10381: }
10382: const Token * switchToken@var3261 ; switchToken@var3261 =@expr1073768144 tok@var3260 ;
10383: tok@var3260 =@expr1073768145 tok@var3260 .@expr26313 linkAt (@expr26314 1 ) ;
10384: if (@expr26324 !@expr26325 tok@var3260 ) {
10385: syntaxError (@expr26326 switchToken@var3261 ) ; }
10386:
10387: for (@expr1073768151 ; tok@var3260 ; tok@var3260 =@expr1073768152 tok@var3260 .@expr26305 next (@expr26306 ) ) {
10388: if (@expr1073768155 tok@var3260 .@expr26332 str (@expr26333 ) ==@expr1073768158 "{" ) {
10389: tok@var3260 =@expr1073768159 tok@var3260 .@expr26336 link (@expr26337 ) ;
10390: }
10391: if (@expr1073768162 Token ::@expr25989 Match (@expr1073768164 tok@var3260 , ";|}" ) ) {
10392:
10393: if (@expr1073768165 tok@var3260 .@expr26332 str (@expr26333 ) ==@expr1073768168 "}" &&@expr1073768169 tok@var3260 .@expr1073768170 strAt (@expr1073768171 -1 ) ==@expr1073768172 ":" ) {
10394: syntaxError (@expr26326 switchToken@var3261 ) ; }
10395: break ;
10396: }
10397: }
10398: if (@expr26324 !@expr26325 tok@var3260 ) {
10399: break ; }
10400: } else { if (@expr1073768176 tok@var3260 .@expr26332 str (@expr26333 ) ==@expr1073768179 "(" ) {
10401: tok@var3260 =@expr1073768180 tok@var3260 .@expr26336 link (@expr26337 ) ;
10402: } else { if (@expr1073768183 tok@var3260 .@expr26332 str (@expr26333 ) ==@expr1073768186 "case" ) {
10403: syntaxError (@expr1073768187 tok@var3260 ) ;
10404: } } }
10405: }
10406:
10407: for (@expr1073768188 const Token *@expr25956 tok@var3262 =@expr1073768190 tokens (@expr25958 ) ; tok@var3262 ; tok@var3262 =@expr1073768192 tok@var3262 .@expr26369 next (@expr26370 ) ) {
10408: if (@expr1073768195 !@expr1073768196 Token ::@expr25963 simpleMatch (@expr1073768198 tok@var3262 , "for (" ) ) {
10409: continue ; }
10410:
10411: int semicolons@var3263 ; semicolons@var3263 =@expr1073768199 0 ;
10412: const Token * const startTok@var3264 ; startTok@var3264 =@expr1073768200 tok@var3262 ;
10413: tok@var3262 =@expr1073768201 tok@var3262 .@expr26369 next (@expr26370 ) .@expr1073768204 link (@expr1073768205 ) .@expr1073768206 previous (@expr1073768207 ) ;
10414:
10415: for (@expr1073768208 ; tok@var3262 !=@expr1073768209 startTok@var3264 ; tok@var3262 =@expr1073768210 tok@var3262 .@expr1073768211 previous (@expr1073768212 ) ) {
10416: if (@expr1073768213 tok@var3262 .@expr26390 str (@expr26391 ) ==@expr1073768216 ";" ) {
10417: semicolons@var3263 ++@expr1073768217 ;
10418: } else { if (@expr1073768218 tok@var3262 .@expr26390 str (@expr26391 ) ==@expr1073768221 ")" ) {
10419: tok@var3262 =@expr1073768222 tok@var3262 .@expr1073768223 link (@expr1073768224 ) ;
10420: } }
10421: }
10422:
10423: if (@expr1073768225 semicolons@var3263 >@expr1073768226 2 ) {
10424: syntaxError (@expr26403 tok@var3262 ) ; }
10425: if (@expr1073768228 semicolons@var3263 ==@expr1073768229 1 &&@expr1073768230 !@expr1073768231 (@expr1073768232 isCPP (@expr25946 ) &&@expr1073768234 mSettings@var879 .@expr25948 standards@var3567 .@expr25949 cpp@var3568 >=@expr1073768237 Standards ::@expr26048 CPP20 ) ) {
10426: syntaxError (@expr26403 tok@var3262 ) ; }
10427: }
10428:
10429:
10430: const Token * templateEndToken@var3265 ; templateEndToken@var3265 =@expr1073768240 nullptr ;
10431: for (@expr1073768241 const Token *@expr25956 tok@var3266 =@expr1073768243 tokens (@expr25958 ) ; tok@var3266 ; tok@var3266 =@expr1073768245 tok@var3266 .@expr26422 next (@expr26423 ) ) {
10432: if (@expr1073768248 !@expr1073768249 templateEndToken@var3265 ) {
10433: if (@expr1073768250 tok@var3266 .@expr26427 str (@expr26428 ) ==@expr1073768253 "<" &&@expr1073768254 isCPP (@expr25946 ) ) {
10434: templateEndToken@var3265 =@expr1073768256 tok@var3266 .@expr1073768257 findClosingBracket (@expr1073768258 ) ; }
10435: } else {
10436: if (@expr1073768259 templateEndToken@var3265 ==@expr1073768260 tok@var3266 ) {
10437: templateEndToken@var3265 =@expr1073768261 nullptr ; }
10438: if (@expr1073768262 Token ::@expr25989 Match (@expr1073768264 tok@var3266 , "> %cop%" ) ) {
10439: continue ; }
10440: }
10441:
10442: if (@expr1073768265 isCPP11@var3250 &&@expr1073768266 (@expr1073768267 isCPPAttribute (@expr1073768268 tok@var3266 ) ||@expr1073768269 isAlignAttribute (@expr1073768270 tok@var3266 ) ) ) {
10443: tok@var3266 =@expr1073768271 skipCPPOrAlignAttribute (@expr1073768272 tok@var3266 ) ;
10444: continue ;
10445: }
10446: {
10447: bool match1@var3267 ; match1@var3267 =@expr1073768273 Token ::@expr25989 Match (@expr1073768275 tok@var3266 , "%or%|%oror%|==|!=|+|-|/|!|>=|<=|~|^|++|--|::|sizeof" ) ;
10448: bool match2@var3268 ; match2@var3268 =@expr1073768276 Token ::@expr25989 Match (@expr1073768278 tok@var3266 .@expr26422 next (@expr26423 ) , "{|if|else|while|do|for|return|switch|break" ) ;
10449: if (@expr26457 isCPP (@expr25946 ) ) {
10450: match1@var3267 =@expr1073768283 match1@var3267 ||@expr1073768284 Token ::@expr25989 Match (@expr1073768286 tok@var3266 , "::|throw|decltype|typeof" ) ;
10451: match2@var3268 =@expr1073768287 match2@var3268 ||@expr1073768288 Token ::@expr25989 Match (@expr1073768290 tok@var3266 .@expr26422 next (@expr26423 ) , "try|catch|namespace" ) ;
10452: }
10453: if (@expr1073768293 match1@var3267 &&@expr1073768294 match2@var3268 ) {
10454: syntaxError (@expr26471 tok@var3266 ) ; }
10455: }
10456: if (@expr1073768296 Token ::@expr25989 Match (@expr1073768298 tok@var3266 , "%or%|%oror%|~|^|!|%comp%|+|-|/|%" ) ) {
10457: std ::@expr1073768299 string code@var3269 ;
10458: if (@expr1073768300 Token ::@expr25989 Match (@expr1073768302 tok@var3266 .@expr26422 next (@expr26423 ) , ")|]|}" ) ) {
10459: code@var3269 =@expr1073768305 tok@var3266 .@expr26427 str (@expr26428 ) +@expr1073768308 tok@var3266 .@expr26422 next (@expr26423 ) .@expr1073768311 str (@expr1073768312 ) ; }
10460: if (@expr1073768313 Token ::@expr25963 simpleMatch (@expr1073768315 tok@var3266 .@expr26422 next (@expr26423 ) , "( )" ) ) {
10461: code@var3269 =@expr1073768318 tok@var3266 .@expr26427 str (@expr26428 ) +@expr1073768321 "()" ; }
10462: if (@expr1073768322 !@expr1073768323 code@var3269 .@expr1073768324 empty (@expr1073768325 ) ) {
10463: if (@expr1073768326 isC (@expr1073768327 ) ||@expr1073768328 (@expr1073768329 tok@var3266 .@expr26427 str (@expr26428 ) !=@expr1073768332 ">" &&@expr1073768333 !@expr1073768334 Token ::@expr25963 simpleMatch (@expr1073768336 tok@var3266 .@expr26513 previous (@expr26514 ) , "operator" ) ) ) {
10464: syntaxError (@expr1073768339 tok@var3266 , code@var3269 ) ; }
10465: }
10466: }
10467: if (@expr1073768340 Token ::@expr25989 Match (@expr1073768342 tok@var3266 , "%num%|%bool%|%char%|%str% %num%|%bool%|%char%|%str%" ) &&@expr1073768343 !@expr1073768344 Token ::@expr25989 Match (@expr1073768346 tok@var3266 , "%str% %str%" ) ) {
10468: syntaxError (@expr26471 tok@var3266 ) ; }
10469: if (@expr1073768348 Token ::@expr25989 Match (@expr1073768350 tok@var3266 , "%assign% typename|class %assign%" ) ) {
10470: syntaxError (@expr26471 tok@var3266 ) ; }
10471: if (@expr1073768352 Token ::@expr25989 Match (@expr1073768354 tok@var3266 , "%cop%|=|,|[ %or%|%oror%|/|%" ) ) {
10472: syntaxError (@expr26471 tok@var3266 ) ; }
10473: if (@expr1073768356 Token ::@expr25989 Match (@expr1073768358 tok@var3266 , ";|(|[ %comp%" ) ) {
10474: syntaxError (@expr26471 tok@var3266 ) ; }
10475: if (@expr1073768360 Token ::@expr25989 Match (@expr1073768362 tok@var3266 , "%cop%|= ]" ) &&@expr1073768363 !@expr1073768364 (@expr1073768365 isCPP (@expr25946 ) &&@expr1073768367 Token ::@expr25989 Match (@expr1073768369 tok@var3266 .@expr26513 previous (@expr26514 ) , "[|,|%num% &|=|> ]" ) ) ) {
10476: syntaxError (@expr26471 tok@var3266 ) ; }
10477: if (@expr1073768373 Token ::@expr25989 Match (@expr1073768375 tok@var3266 , "[+-] [;,)]}]" ) &&@expr1073768376 !@expr1073768377 (@expr1073768378 isCPP (@expr25946 ) &&@expr1073768380 Token ::@expr25989 Match (@expr1073768382 tok@var3266 .@expr26513 previous (@expr26514 ) , "operator [+-] ;" ) ) ) {
10478: syntaxError (@expr26471 tok@var3266 ) ; }
10479: if (@expr1073768386 Token ::@expr25963 simpleMatch (@expr1073768388 tok@var3266 , "," ) &&@expr1073768389
10480: !@expr1073768390 Token ::@expr25989 Match (@expr1073768392 tok@var3266 .@expr1073768393 tokAt (@expr1073768394 -2 ) , "[ = , &|%name%" ) ) {
10481: if (@expr1073768395 Token ::@expr25989 Match (@expr1073768397 tok@var3266 .@expr26513 previous (@expr26514 ) , "(|[|{|<|%assign%|%or%|%oror%|==|!=|+|-|/|!|>=|<=|~|^|::|sizeof" ) ) {
10482: syntaxError (@expr26471 tok@var3266 ) ; }
10483: if (@expr1073768401 isCPP (@expr25946 ) &&@expr1073768403 Token ::@expr25989 Match (@expr1073768405 tok@var3266 .@expr26513 previous (@expr26514 ) , "throw|decltype|typeof" ) ) {
10484: syntaxError (@expr26471 tok@var3266 ) ; }
10485: if (@expr1073768409 Token ::@expr25989 Match (@expr1073768411 tok@var3266 .@expr26422 next (@expr26423 ) , ")|]|>|%assign%|%or%|%oror%|==|!=|/|>=|<=|&&" ) ) {
10486: syntaxError (@expr26471 tok@var3266 ) ; }
10487: }
10488: if (@expr1073768415 Token ::@expr25963 simpleMatch (@expr1073768417 tok@var3266 , "." ) &&@expr1073768418
10489: !@expr1073768419 Token ::@expr25963 simpleMatch (@expr1073768421 tok@var3266 .@expr26513 previous (@expr26514 ) , "." ) &&@expr1073768424
10490: !@expr1073768425 Token ::@expr25963 simpleMatch (@expr1073768427 tok@var3266 .@expr26422 next (@expr26423 ) , "." ) &&@expr1073768430
10491: !@expr1073768431 Token ::@expr25989 Match (@expr1073768433 tok@var3266 .@expr26513 previous (@expr26514 ) , "{|, . %name% =|.|[|{" ) &&@expr1073768436
10492: !@expr1073768437 Token ::@expr25989 Match (@expr1073768439 tok@var3266 .@expr26513 previous (@expr26514 ) , ", . %name%" ) ) {
10493: if (@expr1073768442 !@expr1073768443 Token ::@expr25989 Match (@expr1073768445 tok@var3266 .@expr26513 previous (@expr26514 ) , "%name%|)|]|>|}" ) ) {
10494: syntaxError (@expr26624 tok@var3266 , tok@var3266 .@expr26625 strAt (@expr26626 -1 ) +@expr26627 " " +@expr26628 tok@var3266 .@expr26427 str (@expr26428 ) +@expr26631 " " +@expr26632 tok@var3266 .@expr26625 strAt (@expr26634 1 ) ) ; }
10495: if (@expr1073768459 !@expr1073768460 Token ::@expr25989 Match (@expr1073768462 tok@var3266 .@expr26422 next (@expr26423 ) , "%name%|*|~" ) ) {
10496: syntaxError (@expr26624 tok@var3266 , tok@var3266 .@expr26625 strAt (@expr26626 -1 ) +@expr26627 " " +@expr26628 tok@var3266 .@expr26427 str (@expr26428 ) +@expr26631 " " +@expr26632 tok@var3266 .@expr26625 strAt (@expr26634 1 ) ) ; }
10497: }
10498: if (@expr1073768476 Token ::@expr25989 Match (@expr1073768478 tok@var3266 , "[!|+-/%^~] )|]" ) ) {
10499: syntaxError (@expr26471 tok@var3266 ) ; }
10500: if (@expr1073768480 Token ::@expr25989 Match (@expr1073768482 tok@var3266 , "==|!=|<=|>= %comp%" ) &&@expr1073768483 tok@var3266 .@expr26625 strAt (@expr26626 -1 ) !=@expr1073768486 "operator" ) {
10501: syntaxError (@expr1073768487 tok@var3266 , tok@var3266 .@expr26427 str (@expr26428 ) +@expr1073768490 " " +@expr1073768491 tok@var3266 .@expr26625 strAt (@expr26634 1 ) ) ; }
10502: }
10503:
10504:
10505: if (@expr1073768494 const Token *@expr25956 ternaryOp@var3270 =@expr1073768496 findUnmatchedTernaryOp (@expr1073768497 tokens (@expr25958 ) , nullptr ) ) {
10506: syntaxError (@expr1073768499 ternaryOp@var3270 ) ; }
10507:
10508:
10509: if (@expr1073768500 Token ::@expr25989 Match (@expr1073768502 list@var872 .@expr26679 front (@expr26680 ) , "%cop%" ) ) {
10510: syntaxError (@expr1073768505 list@var872 .@expr26679 front (@expr26680 ) ) ; }
10511:
10512:
10513: if (@expr1073768508 !@expr1073768509 Token ::@expr25989 Match (@expr1073768511 list@var872 .@expr26688 back (@expr26689 ) , "%name%|;|}|)" ) ) {
10514: syntaxError (@expr26690 list@var872 .@expr26688 back (@expr26689 ) ) ; }
10515: if (@expr1073768517 list@var872 .@expr26688 back (@expr26689 ) .@expr26696 str (@expr26697 ) ==@expr26698 ")" &&@expr1073768523 !@expr1073768524 Token ::@expr25989 Match (@expr1073768526 list@var872 .@expr26688 back (@expr26689 ) .@expr1073768529 link (@expr1073768530 ) .@expr1073768531 previous (@expr1073768532 ) , "%name%|> (" ) ) {
10516: syntaxError (@expr26690 list@var872 .@expr26688 back (@expr26689 ) ) ; }
10517: for (@expr1073768536 const Token *@expr25956 end@var3271 =@expr1073768538 list@var872 .@expr26688 back (@expr26689 ) ; end@var3271 &&@expr1073768541 end@var3271 .@expr1073768542 isName (@expr1073768543 ) ; end@var3271 =@expr1073768544 end@var3271 .@expr1073768545 previous (@expr1073768546 ) ) {
10518: if (@expr1073768547 Token ::@expr25989 Match (@expr1073768549 end@var3271 , "void|char|short|int|long|float|double|const|volatile|static|inline|struct|class|enum|union|template|sizeof|case|break|continue|typedef" ) ) {
10519: syntaxError (@expr26690 list@var872 .@expr26688 back (@expr26689 ) ) ; }
10520: }
10521: if (@expr1073768553 (@expr1073768554 list@var872 .@expr26688 back (@expr26689 ) .@expr26696 str (@expr26697 ) ==@expr26698 ")" ||@expr1073768560 list@var872 .@expr26688 back (@expr26689 ) .@expr26696 str (@expr26697 ) ==@expr1073768565 "}" ) &&@expr1073768566 list@var872 .@expr26688 back (@expr26689 ) .@expr26745 previous (@expr26746 ) &&@expr1073768571 list@var872 .@expr26688 back (@expr26689 ) .@expr26745 previous (@expr26746 ) .@expr1073768576 isControlFlowKeyword (@expr1073768577 ) ) {
10522: syntaxError (@expr1073768578 list@var872 .@expr26688 back (@expr26689 ) .@expr26745 previous (@expr26746 ) ) ; }
10523:
10524:
10525: if (@expr26457 isCPP (@expr25946 ) ) {
10526: for (@expr1073768585 const Token *@expr25956 tok@var3272 =@expr1073768587 tokens (@expr25958 ) ; tok@var3272 ; tok@var3272 =@expr1073768589 tok@var3272 .@expr26766 next (@expr26767 ) ) {
10527: if (@expr1073768592 !@expr1073768593 Token ::@expr25963 simpleMatch (@expr1073768595 tok@var3272 , "template <" ) ) {
10528: continue ; }
10529: if (@expr1073768596 tok@var3272 .@expr26773 previous (@expr26774 ) &&@expr1073768599 !@expr1073768600 Token ::@expr25989 Match (@expr1073768602 tok@var3272 .@expr26773 previous (@expr26774 ) , ":|;|{|}|)|>|\"C++\"" ) ) {
10530: if (@expr1073768605 tok@var3272 .@expr26773 previous (@expr26774 ) .@expr1073768608 isUpperCaseName (@expr1073768609 ) ) {
10531: unknownMacroError (@expr1073768610 tok@var3272 .@expr26773 previous (@expr26774 ) ) ; }
10532: else {
10533: syntaxError (@expr1073768613 tok@var3272 ) ; }
10534: }
10535: const Token * const tok1@var3273 ; tok1@var3273 =@expr1073768614 tok@var3272 ;
10536: tok@var3272 =@expr1073768615 tok@var3272 .@expr26766 next (@expr26767 ) .@expr1073768618 findClosingBracket (@expr1073768619 ) ;
10537: if (@expr1073768620 !@expr1073768621 tok@var3272 ) {
10538: syntaxError (@expr1073768622 tok1@var3273 ) ; }
10539: if (@expr1073768623 !@expr1073768624 Token ::@expr25989 Match (@expr1073768626 tok@var3272 , ">|>> ::|...| %name%" ) &&@expr1073768627
10540: !@expr1073768628 Token ::@expr25989 Match (@expr1073768630 tok@var3272 , ">|>> [ [ %name%" ) &&@expr1073768631
10541: !@expr1073768632 Token ::@expr25989 Match (@expr1073768634 tok@var3272 , "> >|*" ) ) {
10542: syntaxError (@expr1073768635 tok@var3272 .@expr26766 next (@expr26767 ) ?@expr1073768638 tok@var3272 .@expr26766 next (@expr26767 ) :@expr1073768641 tok1@var3273 ) ; }
10543: }
10544: }
10545:
10546:
10547: for (@expr1073768642 const Token *@expr25956 tok@var3274 =@expr1073768644 tokens (@expr25958 ) ; tok@var3274 ; tok@var3274 =@expr1073768646 tok@var3274 .@expr26823 next (@expr26824 ) ) {
10548: if (@expr1073768649 Token ::@expr25989 Match (@expr1073768651 tok@var3274 , "[;{}] [ %name% %name% ] ;" ) ) {
10549: syntaxError (@expr1073768652 tok@var3274 .@expr26823 next (@expr26824 ) ) ; }
10550: }
10551: }
10552:
10553:
10554: bool Tokenizer :: isGarbageExpr ( const Token * start@var3275 , const Token * end@var3276 , bool allowSemicolon@var3277 )
10555: {
10556: for (@expr1073768655 const Token *@expr1073768656 tok@var3278 =@expr1073768657 start@var3275 ; tok@var3278 !=@expr1073768658 end@var3276 ; tok@var3278 =@expr1073768659 tok@var3278 .@expr1073768660 next (@expr1073768661 ) ) {
10557: if (@expr1073768662 tok@var3278 .@expr1073768663 isControlFlowKeyword (@expr1073768664 ) ) {
10558: return true ; }
10559: if (@expr1073768665 !@expr1073768666 allowSemicolon@var3277 &&@expr1073768667 tok@var3278 .@expr26844 str (@expr26845 ) ==@expr1073768670 ";" ) {
10560: return true ; }
10561: if (@expr1073768671 tok@var3278 .@expr26844 str (@expr26845 ) ==@expr1073768674 "{" ) {
10562: tok@var3278 =@expr1073768675 tok@var3278 .@expr1073768676 link (@expr1073768677 ) ; }
10563: }
10564: return false ;
10565: }
10566:
10567: std :: string Tokenizer :: simplifyString ( const std :: string & source@var3279 )
10568: {
10569: std ::@expr1073768680 string str@var3280 ; str@var3280 =@expr1073768681 source@var3279 ;
10570:
10571: for (@expr1073768682 std ::@expr26859 string ::@expr26859 size_type i@var3281 =@expr1073768685 0 ; i@var3281 +@expr1073768686 1U <@expr1073768687 str@var3280 .@expr26864 size (@expr26865 ) ; ++@expr1073768690 i@var3281 ) {
10572: if (@expr1073768691 str@var3280 [@expr1073768692 i@var3281 ] !=@expr1073768693 '\\' ) {
10573: continue ; }
10574:
10575: int c@var3282 ; c@var3282 =@expr1073768694 'a' ;
10576: int sz@var3283 ; sz@var3283 =@expr1073768695 0 ;
10577: if (@expr1073768696 str@var3280 [@expr26873 i@var3281 +@expr26874 1 ] ==@expr1073768699 'x' ) {
10578: sz@var3283 =@expr1073768700 2 ;
10579: while (@expr1073768701 sz@var3283 <@expr26878 4 &&@expr1073768703 std ::@expr1073768704 isxdigit (@expr1073768705 (@expr1073768706 unsigned char ) str@var3280 [@expr26883 i@var3281 +@expr26884 sz@var3283 ] ) ) {
10580: sz@var3283 ++@expr1073768709 ; }
10581: if (@expr1073768710 sz@var3283 >@expr1073768711 2 ) {
10582: std ::@expr1073768712 istringstream istr@var3284 (@expr1073768713 str@var3280 .@expr26890 substr (@expr1073768715 i@var3281 +@expr1073768716 2 , sz@var3283 -@expr1073768717 2 ) ) ;
10583: istr@var3284 >>@expr1073768718 std ::@expr1073768719 hex@expr1073768678 >>@expr1073768720 c@var3282 ;
10584: }
10585: } else { if (@expr1073768721 MathLib ::@expr26898 isOctalDigit (@expr1073768723 str@var3280 [@expr26873 i@var3281 +@expr26874 1 ] ) ) {
10586: sz@var3283 =@expr1073768726 2 ;
10587: while (@expr1073768727 sz@var3283 <@expr26878 4 &&@expr1073768729 MathLib ::@expr26898 isOctalDigit (@expr1073768731 str@var3280 [@expr26883 i@var3281 +@expr26884 sz@var3283 ] ) ) {
10588: sz@var3283 ++@expr1073768734 ; }
10589: std ::@expr1073768735 istringstream istr@var3285 (@expr1073768736 str@var3280 .@expr26890 substr (@expr1073768738 i@var3281 +@expr26874 1 , sz@var3283 -@expr1073768740 1 ) ) ;
10590: istr@var3285 >>@expr1073768741 std ::@expr1073768742 oct@expr1073768679 >>@expr1073768743 c@var3282 ;
10591: str@var3280 =@expr1073768744 str@var3280 .@expr26890 substr (@expr1073768746 0 , i@var3281 ) +@expr1073768747 (@expr26924 char ) c@var3282 +@expr1073768749 str@var3280 .@expr26890 substr (@expr1073768751 i@var3281 +@expr26884 sz@var3283 ) ;
10592: continue ;
10593: } }
10594:
10595: if (@expr1073768753 sz@var3283 <=@expr1073768754 2 ) {
10596: i@var3281 ++@expr1073768755 ; }
10597: else { if (@expr1073768756 i@var3281 +@expr26884 sz@var3283 <@expr1073768758 str@var3280 .@expr26864 size (@expr26865 ) ) {
10598: str@var3280 .@expr26937 replace (@expr1073768762 i@var3281 , sz@var3283 , std ::@expr1073768763 string (@expr1073768764 1U , (@expr26924 char ) c@var3282 ) ) ; }
10599: else {
10600: str@var3280 .@expr26937 replace (@expr1073768767 i@var3281 , str@var3280 .@expr26864 size (@expr26865 ) -@expr1073768770 i@var3281 -@expr1073768771 1U , "a" ) ; } }
10601: }
10602:
10603: return str@var3280 ;
10604: }
10605:
10606: void Tokenizer :: simplifyWhile0 ( )
10607: {
10608: for (@expr1073768772 Token *@expr1073768773 tok@var3286 =@expr1073768774 list@var872 .@expr1073768775 front (@expr1073768776 ) ; tok@var3286 ; tok@var3286 =@expr1073768777 tok@var3286 .@expr26954 next (@expr26955 ) ) {
10609:
10610: const bool while0@var3287 (@expr1073768780 Token ::@expr26957 Match (@expr1073768782 tok@var3286 .@expr26959 previous (@expr26960 ) , "[{};] while ( 0|false )" ) ) ;
10611:
10612:
10613: const bool for0@var3288 (@expr1073768785 (@expr1073768786 Token ::@expr26957 Match (@expr1073768788 tok@var3286 .@expr26959 previous (@expr26960 ) , "[{};] for ( %name% = %num% ; %name% < %num% ;" ) &&@expr1073768791
10614: tok@var3286 .@expr26968 strAt (@expr1073768793 2 ) ==@expr1073768794 tok@var3286 .@expr26968 strAt (@expr1073768796 6 ) &&@expr1073768797 tok@var3286 .@expr26968 strAt (@expr1073768799 4 ) ==@expr1073768800 tok@var3286 .@expr26968 strAt (@expr1073768802 8 ) ) ||@expr1073768803
10615: (@expr1073768804 Token ::@expr26957 Match (@expr1073768806 tok@var3286 .@expr26959 previous (@expr26960 ) , "[{};] for ( %type% %name% = %num% ; %name% < %num% ;" ) &&@expr1073768809
10616: tok@var3286 .@expr26968 strAt (@expr1073768811 3 ) ==@expr1073768812 tok@var3286 .@expr26968 strAt (@expr1073768814 7 ) &&@expr1073768815 tok@var3286 .@expr26968 strAt (@expr1073768817 5 ) ==@expr1073768818 tok@var3286 .@expr26968 strAt (@expr1073768820 9 ) ) ) ;
10617:
10618: if (@expr1073768821 !@expr1073768822 while0@var3287 &&@expr1073768823 !@expr1073768824 for0@var3288 ) {
10619: continue ; }
10620:
10621: if (@expr1073768825 while0@var3287 &&@expr1073768826 tok@var3286 .@expr26959 previous (@expr26960 ) .@expr1073768829 str (@expr1073768830 ) ==@expr1073768831 "}" ) {
10622:
10623: Token * tok2@var3289 ; tok2@var3289 =@expr1073768832 tok@var3286 .@expr26959 previous (@expr26960 ) .@expr1073768835 link (@expr1073768836 ) ;
10624: tok2@var3289 =@expr1073768837 tok2@var3289 .@expr1073768838 previous (@expr1073768839 ) ;
10625: if (@expr1073768840 tok2@var3289 &&@expr1073768841 tok2@var3289 .@expr1073768842 str (@expr1073768843 ) ==@expr1073768844 "do" ) {
10626: const bool flowmatch@var3290 =@expr1073768845 Token ::@expr1073768846 findmatch (@expr1073768847 tok2@var3289 , "continue|break" , tok@var3286 ) !=@expr1073768848 nullptr ;
10627:
10628: tok2@var3289 .@expr27025 deleteThis (@expr27026 ) ;
10629: if (@expr27027 !@expr27028 flowmatch@var3290 ) {
10630: tok2@var3289 .@expr27025 deleteThis (@expr27026 ) ; }
10631:
10632:
10633: tok@var3286 =@expr1073768855 tok@var3286 .@expr26959 previous (@expr26960 ) ;
10634: tok@var3286 .@expr27034 deleteNext (@expr1073768859 4 ) ;
10635: if (@expr1073768860 tok@var3286 .@expr26954 next (@expr26955 ) &&@expr1073768863 tok@var3286 .@expr26954 next (@expr26955 ) .@expr1073768866 str (@expr1073768867 ) ==@expr1073768868 ";" ) {
10636: tok@var3286 .@expr27034 deleteNext (@expr1073768870 ) ; }
10637: if (@expr27027 !@expr27028 flowmatch@var3290 ) {
10638: tok@var3286 .@expr1073768873 deleteThis (@expr1073768874 ) ; }
10639:
10640: continue ;
10641: }
10642: }
10643:
10644:
10645: if (@expr1073768875 Token ::@expr1073768876 simpleMatch (@expr1073768877 tok@var3286 .@expr26954 next (@expr26955 ) .@expr27056 link (@expr27057 ) , ") {" ) ) {
10646: Token * end@var3291 ; end@var3291 =@expr1073768882 tok@var3286 .@expr26954 next (@expr26955 ) .@expr27056 link (@expr27057 ) ; Token * old_prev@var3292 ; old_prev@var3292 =@expr1073768887 tok@var3286 .@expr26959 previous (@expr26960 ) ;
10647: end@var3291 =@expr1073768890 end@var3291 .@expr27067 next (@expr27068 ) .@expr1073768893 link (@expr1073768894 ) ;
10648: if (@expr1073768895 Token ::@expr26957 Match (@expr1073768897 tok@var3286 , "for ( %name% =" ) ) {
10649: old_prev@var3292 =@expr1073768898 end@var3291 .@expr1073768899 link (@expr1073768900 ) ; }
10650: eraseDeadCode (@expr1073768901 old_prev@var3292 , end@var3291 .@expr27067 next (@expr27068 ) ) ;
10651: if (@expr1073768904 old_prev@var3292 &&@expr1073768905 old_prev@var3292 .@expr27082 next (@expr27083 ) ) {
10652: tok@var3286 =@expr1073768908 old_prev@var3292 .@expr27082 next (@expr27083 ) ; }
10653: else {
10654: break ; }
10655: }
10656: }
10657: }
10658:
10659: void Tokenizer :: simplifyFunctionTryCatch ( )
10660: {
10661: if (@expr1073768911 !@expr1073768912 isCPP (@expr1073768913 ) ) {
10662: return ; }
10663:
10664: for (@expr1073768914 Token *@expr1073768915 tok@var3293 =@expr1073768916 list@var872 .@expr1073768917 front (@expr1073768918 ) ; tok@var3293 ; tok@var3293 =@expr1073768919 tok@var3293 .@expr1073768920 next (@expr1073768921 ) ) {
10665: if (@expr1073768922 !@expr1073768923 Token ::@expr27100 simpleMatch (@expr1073768925 tok@var3293 , "try {" ) ) {
10666: continue ; }
10667: if (@expr1073768926 !@expr1073768927 isFunctionHead (@expr1073768928 tok@var3293 .@expr27105 previous (@expr27106 ) , "try" ) ) {
10668: continue ; }
10669:
10670:
10671: Token * const tryEndToken@var3294 ; tryEndToken@var3294 =@expr1073768931 tok@var3293 .@expr1073768932 linkAt (@expr1073768933 1 ) ;
10672: Token * endToken@var3295 ; endToken@var3295 =@expr1073768934 tryEndToken@var3294 ;
10673: while (@expr1073768935 Token ::@expr27100 simpleMatch (@expr1073768937 endToken@var3295 , "} catch (" ) ) {
10674: endToken@var3295 =@expr1073768938 endToken@var3295 .@expr1073768939 linkAt (@expr1073768940 2 ) .@expr1073768941 next (@expr1073768942 ) ;
10675: if (@expr1073768943 !@expr27120 endToken@var3295 ) {
10676: break ; }
10677: if (@expr1073768945 endToken@var3295 .@expr1073768946 str (@expr1073768947 ) !=@expr1073768948 "{" ) {
10678: endToken@var3295 =@expr1073768949 nullptr ;
10679: break ;
10680: }
10681: endToken@var3295 =@expr1073768950 endToken@var3295 .@expr1073768951 link (@expr1073768952 ) ;
10682: }
10683: if (@expr1073768953 !@expr27120 endToken@var3295 ||@expr1073768955 endToken@var3295 ==@expr1073768956 tryEndToken@var3294 ) {
10684: continue ; }
10685:
10686: tok@var3293 .@expr27105 previous (@expr27106 ) .@expr1073768959 insertToken (@expr1073768960 "{" ) ;
10687: endToken@var3295 .@expr1073768961 insertToken (@expr1073768962 "}" ) ;
10688: Token ::@expr1073768963 createMutualLinks (@expr1073768964 tok@var3293 .@expr27105 previous (@expr27106 ) , endToken@var3295 .@expr1073768967 next (@expr1073768968 ) ) ;
10689: }
10690: }
10691:
10692: void Tokenizer :: simplifyErrNoInWhile ( )
10693: {
10694: for (@expr1073768969 Token *@expr1073768970 tok@var3296 =@expr1073768971 list@var872 .@expr1073768972 front (@expr1073768973 ) ; tok@var3296 ; tok@var3296 =@expr1073768974 tok@var3296 .@expr1073768975 next (@expr1073768976 ) ) {
10695: if (@expr1073768977 tok@var3296 .@expr1073768978 str (@expr1073768979 ) !=@expr1073768980 "errno" ) {
10696: continue ; }
10697:
10698: Token * endpar@var3297 ; endpar@var3297 =@expr1073768981 nullptr ;
10699: if (@expr1073768982 Token ::@expr27159 Match (@expr1073768984 tok@var3296 .@expr27161 previous (@expr27162 ) , "&& errno == EINTR ) { ;| }" ) ) {
10700: endpar@var3297 =@expr1073768987 tok@var3296 .@expr27164 tokAt (@expr1073768989 3 ) ; }
10701: else { if (@expr1073768990 Token ::@expr27159 Match (@expr1073768992 tok@var3296 .@expr27164 tokAt (@expr1073768994 -2 ) , "&& ( errno == EINTR ) ) { ;| }" ) ) {
10702: endpar@var3297 =@expr1073768995 tok@var3296 .@expr27164 tokAt (@expr1073768997 4 ) ; }
10703: else {
10704: continue ; } }
10705:
10706: if (@expr1073768998 Token ::@expr1073768999 simpleMatch (@expr1073769000 endpar@var3297 .@expr1073769001 link (@expr1073769002 ) .@expr1073769003 previous (@expr1073769004 ) , "while (" ) ) {
10707: Token * tok1@var3298 ; tok1@var3298 =@expr1073769005 tok@var3296 .@expr27161 previous (@expr27162 ) ;
10708: if (@expr1073769008 tok1@var3298 .@expr1073769009 str (@expr1073769010 ) ==@expr1073769011 "(" ) {
10709: tok1@var3298 =@expr1073769012 tok1@var3298 .@expr27189 previous (@expr27190 ) ; }
10710:
10711:
10712: tok1@var3298 =@expr1073769015 tok1@var3298 .@expr27189 previous (@expr27190 ) ;
10713: Token ::@expr1073769018 eraseTokens (@expr1073769019 tok1@var3298 , endpar@var3297 ) ;
10714:
10715:
10716: tok@var3296 =@expr1073769020 endpar@var3297 ;
10717: }
10718: }
10719: }
10720:
10721:
10722: void Tokenizer :: simplifyFuncInWhile ( )
10723: {
10724: int count@var3299 ; count@var3299 =@expr1073769021 0 ;
10725: for (@expr1073769022 Token *@expr1073769023 tok@var3300 =@expr1073769024 list@var872 .@expr1073769025 front (@expr1073769026 ) ; tok@var3300 ; tok@var3300 =@expr1073769027 tok@var3300 .@expr27204 next (@expr27205 ) ) {
10726: if (@expr1073769030 !@expr1073769031 Token ::@expr1073769032 Match (@expr1073769033 tok@var3300 , "while ( %name% ( %name% ) ) {" ) ) {
10727: continue ; }
10728:
10729: Token * func@var3301 ; func@var3301 =@expr1073769034 tok@var3300 .@expr27211 tokAt (@expr27212 2 ) ;
10730: const Token * const var@var3302 ; var@var3302 =@expr1073769037 tok@var3300 .@expr27211 tokAt (@expr27215 4 ) ;
10731: Token * const end@var3303 ; end@var3303 =@expr1073769040 tok@var3300 .@expr27204 next (@expr27205 ) .@expr1073769043 link (@expr1073769044 ) .@expr1073769045 next (@expr1073769046 ) .@expr1073769047 link (@expr1073769048 ) ;
10732:
10733: const int varid@var3304 =@expr1073769049 ++@expr1073769050 mVarId@var891 ;
10734: const std ::@expr1073769051 string varname@var3305 (@expr1073769052 "cppcheck:r" +@expr1073769053 MathLib ::@expr1073769054 toString (@expr1073769055 ++@expr1073769056 count@var3299 ) ) ;
10735: tok@var3300 .@expr1073769057 str (@expr1073769058 "int" ) ;
10736: tok@var3300 .@expr27204 next (@expr27205 ) .@expr1073769061 insertToken (@expr1073769062 varname@var3305 ) ;
10737: tok@var3300 .@expr27211 tokAt (@expr27212 2 ) .@expr1073769065 varId (@expr1073769066 varid@var3304 ) ;
10738: tok@var3300 .@expr27243 insertToken (@expr1073769068 "while" ) ;
10739: tok@var3300 .@expr27243 insertToken (@expr1073769070 ";" ) ;
10740: tok@var3300 .@expr27243 insertToken (@expr1073769072 ")" ) ;
10741: tok@var3300 .@expr27243 insertToken (@expr1073769074 var@var3302 .@expr1073769075 str (@expr1073769076 ) ) ;
10742: tok@var3300 .@expr27204 next (@expr27205 ) .@expr27255 varId (@expr1073769080 var@var3302 .@expr1073769081 varId (@expr1073769082 ) ) ;
10743: tok@var3300 .@expr27243 insertToken (@expr1073769084 "(" ) ;
10744: tok@var3300 .@expr27243 insertToken (@expr1073769086 func@var3301 .@expr1073769087 str (@expr1073769088 ) ) ;
10745: tok@var3300 .@expr27243 insertToken (@expr1073769090 "=" ) ;
10746: tok@var3300 .@expr27243 insertToken (@expr1073769092 varname@var3305 ) ;
10747: tok@var3300 .@expr27204 next (@expr27205 ) .@expr27255 varId (@expr1073769096 varid@var3304 ) ;
10748: Token ::@expr1073769097 createMutualLinks (@expr1073769098 tok@var3300 .@expr27211 tokAt (@expr27215 4 ) , tok@var3300 .@expr27211 tokAt (@expr1073769102 6 ) ) ;
10749: end@var3303 .@expr27279 previous (@expr27280 ) .@expr27281 insertToken (@expr1073769106 varname@var3305 ) ;
10750: end@var3303 .@expr27279 previous (@expr27280 ) .@expr1073769109 varId (@expr1073769110 varid@var3304 ) ;
10751: end@var3303 .@expr27279 previous (@expr27280 ) .@expr27281 insertToken (@expr1073769114 "=" ) ;
10752: Token ::@expr1073769115 move (@expr1073769116 func@var3301 , func@var3301 .@expr1073769117 tokAt (@expr1073769118 3 ) , end@var3303 .@expr27279 previous (@expr27280 ) ) ;
10753: end@var3303 .@expr27279 previous (@expr27280 ) .@expr27281 insertToken (@expr1073769124 ";" ) ;
10754:
10755: tok@var3300 =@expr1073769125 end@var3303 ;
10756: }
10757: }
10758:
10759: void Tokenizer :: simplifyStructDecl ( )
10760: {
10761: const bool cpp@var3306 =@expr1073769126 isCPP (@expr1073769127 ) ;
10762:
10763:
10764: int count@var3307 ; count@var3307 =@expr1073769128 0 ;
10765:
10766:
10767: std ::@expr1073769129 stack < bool > skip@var3308 ;
10768: skip@var3308 .@expr27306 push (@expr27307 false ) ;
10769:
10770:
10771: for (@expr1073769132 Token *@expr27309 tok@var3309 =@expr1073769134 list@var872 .@expr27311 front (@expr27312 ) ; tok@var3309 ; tok@var3309 =@expr1073769137 tok@var3309 .@expr27314 next (@expr27315 ) ) {
10772: if (@expr1073769140 !@expr1073769141 tok@var3309 .@expr1073769142 isName (@expr1073769143 ) ) {
10773: continue ; }
10774:
10775: if (@expr1073769144 Token ::@expr27321 Match (@expr1073769146 tok@var3309 , "struct|union {" ) ) {
10776: if (@expr1073769147 Token ::@expr27321 Match (@expr1073769149 tok@var3309 .@expr27314 next (@expr27315 ) .@expr27328 link (@expr27329 ) , "} const| *|&| const| %type% ,|;|[|(|{|=" ) ) {
10777: tok@var3309 .@expr27330 insertToken (@expr1073769155 "Anonymous" +@expr1073769156 MathLib ::@expr27333 toString (@expr1073769158 count@var3307 ++@expr1073769159 ) ) ;
10778: }
10779: }
10780:
10781: else { if (@expr1073769160 cpp@var3306 &&@expr1073769161 Token ::@expr27321 Match (@expr1073769163 tok@var3309 , "class|struct :" ) ) {
10782: const Token * tok1@var3310 ; tok1@var3310 =@expr1073769164 Token ::@expr1073769165 findsimplematch (@expr1073769166 tok@var3309 , "{" ) ;
10783: if (@expr1073769167 tok1@var3310 &&@expr1073769168 Token ::@expr27321 Match (@expr1073769170 tok1@var3310 .@expr1073769171 link (@expr1073769172 ) , "} const| *|&| const| %type% ,|;|[|(|{" ) ) {
10784: tok@var3309 .@expr27330 insertToken (@expr1073769174 "Anonymous" +@expr1073769175 MathLib ::@expr27333 toString (@expr1073769177 count@var3307 ++@expr1073769178 ) ) ;
10785: }
10786: }
10787:
10788: else { if (@expr1073769179 (@expr1073769180 Token ::@expr27357 simpleMatch (@expr1073769182 tok@var3309 , "enum {" ) &&@expr1073769183
10789: !@expr1073769184 Token ::@expr27321 Match (@expr1073769186 tok@var3309 .@expr1073769187 tokAt (@expr1073769188 -3 ) , "using %name% =" ) &&@expr1073769189
10790: Token ::@expr27321 Match (@expr1073769191 tok@var3309 .@expr27314 next (@expr27315 ) .@expr27328 link (@expr27329 ) , "} (| %type%| )| ,|;|[|(|{" ) ) ||@expr1073769196
10791: (@expr1073769197 Token ::@expr27321 Match (@expr1073769199 tok@var3309 , "enum : %type% {" ) &&@expr1073769200 Token ::@expr27321 Match (@expr1073769202 tok@var3309 .@expr27379 linkAt (@expr27380 3 ) , "} (| %type%| )| ,|;|[|(|{" ) ) ) {
10792: Token * start@var3311 ; start@var3311 =@expr1073769205 tok@var3309 .@expr1073769206 strAt (@expr1073769207 1 ) ==@expr1073769208 ":" ?@expr1073769209 tok@var3309 .@expr27379 linkAt (@expr27380 3 ) :@expr1073769212 tok@var3309 .@expr27379 linkAt (@expr1073769214 1 ) ;
10793: if (@expr1073769215 start@var3311 &&@expr1073769216 Token ::@expr27321 Match (@expr1073769218 start@var3311 .@expr27395 next (@expr27396 ) , "( %type% )" ) ) {
10794: start@var3311 .@expr27395 next (@expr27396 ) .@expr1073769223 link (@expr1073769224 ) .@expr1073769225 deleteThis (@expr1073769226 ) ;
10795: start@var3311 .@expr27395 next (@expr27396 ) .@expr1073769229 deleteThis (@expr1073769230 ) ;
10796: }
10797: tok@var3309 .@expr27330 insertToken (@expr1073769232 "Anonymous" +@expr1073769233 MathLib ::@expr27333 toString (@expr1073769235 count@var3307 ++@expr1073769236 ) ) ;
10798: } } }
10799: }
10800:
10801: for (@expr1073769237 Token *@expr27309 tok@var3312 =@expr1073769239 list@var872 .@expr27311 front (@expr27312 ) ; tok@var3312 ; tok@var3312 =@expr1073769242 tok@var3312 .@expr27419 next (@expr27420 ) ) {
10802:
10803:
10804: if (@expr1073769245 tok@var3312 .@expr27422 str (@expr27423 ) ==@expr1073769248 "{" ) {
10805: skip@var3308 .@expr27306 push (@expr1073769250 Token ::@expr27321 Match (@expr1073769252 tok@var3312 .@expr1073769253 previous (@expr1073769254 ) , "const|)" ) ) ; }
10806:
10807:
10808: else { if (@expr1073769255 tok@var3312 .@expr27422 str (@expr27423 ) ==@expr1073769258 "}" &&@expr1073769259 !@expr1073769260 skip@var3308 .@expr1073769261 empty (@expr1073769262 ) ) {
10809: skip@var3308 .@expr27439 pop (@expr27440 ) ; }
10810:
10811:
10812: else { if (@expr1073769265 Token ::@expr27321 Match (@expr1073769267 tok@var3312 , "class|struct|union|enum %type% :|{" ) ) {
10813: Token * start@var3313 ; start@var3313 =@expr1073769268 tok@var3312 ;
10814: while (@expr1073769269 Token ::@expr27321 Match (@expr1073769271 start@var3313 .@expr27448 previous (@expr27449 ) , "%type%" ) ) {
10815: start@var3313 =@expr1073769274 start@var3313 .@expr27448 previous (@expr27449 ) ; }
10816: const Token * const type@var3314 ; type@var3314 =@expr1073769277 tok@var3312 .@expr27419 next (@expr27420 ) ;
10817: Token * next@var3315 ; next@var3315 =@expr1073769280 tok@var3312 .@expr27457 tokAt (@expr27458 2 ) ;
10818:
10819: while (@expr1073769283 next@var3315 &&@expr1073769284 next@var3315 .@expr1073769285 str (@expr1073769286 ) !=@expr1073769287 "{" ) {
10820: next@var3315 =@expr1073769288 next@var3315 .@expr1073769289 next (@expr1073769290 ) ; }
10821: if (@expr1073769291 !@expr1073769292 next@var3315 ) {
10822: continue ; }
10823: skip@var3308 .@expr27306 push (@expr27307 false ) ;
10824: tok@var3312 =@expr1073769295 next@var3315 .@expr1073769296 link (@expr1073769297 ) ;
10825: if (@expr27474 !@expr27475 tok@var3312 ) {
10826: break ; }
10827: Token * restart@var3316 ; restart@var3316 =@expr1073769300 next@var3315 ;
10828:
10829:
10830: if (@expr1073769301 Token ::@expr27321 Match (@expr1073769303 tok@var3312 .@expr27419 next (@expr27420 ) , "const|static|volatile| *|&| const| (| %type% )| ,|;|[|=|(|{" ) ) {
10831: tok@var3312 .@expr27482 insertToken (@expr1073769307 ";" ) ;
10832: tok@var3312 =@expr1073769308 tok@var3312 .@expr27419 next (@expr27420 ) ;
10833: while (@expr1073769311 !@expr1073769312 Token ::@expr27321 Match (@expr1073769314 start@var3313 , "struct|class|union|enum" ) ) {
10834: tok@var3312 .@expr27482 insertToken (@expr27492 start@var3313 .@expr27493 str (@expr27494 ) ) ;
10835: tok@var3312 =@expr1073769319 tok@var3312 .@expr27419 next (@expr27420 ) ;
10836: start@var3313 .@expr1073769322 deleteThis (@expr1073769323 ) ;
10837: }
10838: if (@expr27474 !@expr27475 tok@var3312 ) {
10839: break ; }
10840: tok@var3312 .@expr27482 insertToken (@expr1073769327 type@var3314 .@expr1073769328 str (@expr1073769329 ) ) ;
10841: if (@expr1073769330 start@var3313 .@expr27493 str (@expr27494 ) !=@expr1073769333 "class" ) {
10842: tok@var3312 .@expr27482 insertToken (@expr27492 start@var3313 .@expr27493 str (@expr27494 ) ) ;
10843: tok@var3312 =@expr1073769338 tok@var3312 .@expr27419 next (@expr27420 ) ;
10844: }
10845:
10846: tok@var3312 =@expr1073769341 tok@var3312 .@expr27457 tokAt (@expr27458 2 ) ;
10847:
10848: if (@expr1073769344 Token ::@expr27321 Match (@expr1073769346 tok@var3312 , "( %type% )" ) ) {
10849: tok@var3312 .@expr1073769347 link (@expr1073769348 ) .@expr1073769349 deleteThis (@expr1073769350 ) ;
10850: tok@var3312 .@expr27527 deleteThis (@expr27528 ) ;
10851: }
10852:
10853:
10854: if (@expr1073769353 tok@var3312 &&@expr1073769354 (@expr1073769355 tok@var3312 .@expr27419 next (@expr27420 ) .@expr27534 str (@expr27535 ) ==@expr1073769360 "(" ||@expr1073769361 tok@var3312 .@expr27419 next (@expr27420 ) .@expr27534 str (@expr27535 ) ==@expr27542 "{" ) ) {
10855: tok@var3312 .@expr27482 insertToken (@expr1073769368 "=" ) ;
10856: tok@var3312 =@expr1073769369 tok@var3312 .@expr27419 next (@expr27420 ) ;
10857:
10858: if (@expr1073769372 start@var3313 .@expr27493 str (@expr27494 ) ==@expr1073769375 "enum" ) {
10859: if (@expr1073769376 tok@var3312 .@expr27419 next (@expr27420 ) .@expr27534 str (@expr27535 ) ==@expr27542 "{" ) {
10860: tok@var3312 .@expr27419 next (@expr27420 ) .@expr27534 str (@expr1073769385 "(" ) ;
10861: tok@var3312 .@expr1073769386 linkAt (@expr1073769387 1 ) .@expr1073769388 str (@expr1073769389 ")" ) ;
10862: }
10863: }
10864: }
10865: }
10866:
10867: tok@var3312 =@expr1073769390 restart@var3316 ;
10868: }
10869:
10870:
10871: else { if (@expr1073769391 Token ::@expr27321 Match (@expr1073769393 tok@var3312 , "struct|union {" ) ) {
10872: const bool inFunction@var3317 =@expr1073769394 skip@var3308 .@expr1073769395 top (@expr1073769396 ) ;
10873: skip@var3308 .@expr27306 push (@expr27307 false ) ;
10874: Token * tok1@var3318 ; tok1@var3318 =@expr1073769399 tok@var3312 ;
10875:
10876: Token * restart@var3319 ; restart@var3319 =@expr1073769400 tok@var3312 .@expr27419 next (@expr27420 ) ;
10877: tok@var3312 =@expr1073769403 tok@var3312 .@expr27419 next (@expr27420 ) .@expr1073769406 link (@expr1073769407 ) ;
10878:
10879:
10880: if (@expr1073769408 tok@var3312 &&@expr1073769409 tok@var3312 .@expr27419 next (@expr27420 ) &&@expr1073769412 tok@var3312 .@expr27419 next (@expr27420 ) .@expr27534 str (@expr27535 ) ==@expr1073769417 ";" ) {
10881: if (@expr1073769418 inFunction@var3317 &&@expr1073769419 tok1@var3318 .@expr27596 str (@expr27597 ) ==@expr27598 "union" ) {
10882:
10883: Token * tok2@var3320 ; tok2@var3320 =@expr1073769423 tok1@var3318 .@expr27600 tokAt (@expr27601 2 ) ;
10884: while (@expr1073769426 tok2@var3320 ) {
10885: if (@expr1073769427 Token ::@expr27321 Match (@expr27605 tok2@var3320 , "%type% %name% ;" ) ) {
10886: tok2@var3320 =@expr1073769430 tok2@var3320 .@expr27607 tokAt (@expr27608 3 ) ; }
10887: else {
10888: break ; }
10889: }
10890: if (@expr1073769433 !@expr1073769434 Token ::@expr27357 simpleMatch (@expr1073769436 tok2@var3320 , "} ;" ) ) {
10891: continue ; }
10892: Token * vartok@var3321 ; vartok@var3321 =@expr1073769437 nullptr ;
10893: tok2@var3320 =@expr1073769438 tok1@var3318 .@expr27600 tokAt (@expr27601 2 ) ;
10894: while (@expr1073769441 Token ::@expr27321 Match (@expr27605 tok2@var3320 , "%type% %name% ;" ) ) {
10895: if (@expr1073769444 !@expr1073769445 vartok@var3321 ) {
10896: vartok@var3321 =@expr1073769446 tok2@var3320 .@expr27623 next (@expr27624 ) ;
10897: tok2@var3320 =@expr1073769449 tok2@var3320 .@expr27607 tokAt (@expr27608 3 ) ;
10898: } else {
10899: tok2@var3320 .@expr27628 insertToken (@expr1073769453 "&" ) ;
10900: tok2@var3320 =@expr1073769454 tok2@var3320 .@expr27607 tokAt (@expr1073769456 2 ) ;
10901: tok2@var3320 .@expr27628 insertToken (@expr1073769458 vartok@var3321 .@expr1073769459 str (@expr1073769460 ) ) ;
10902: tok2@var3320 .@expr27623 next (@expr27624 ) .@expr1073769463 varId (@expr1073769464 vartok@var3321 .@expr1073769465 varId (@expr1073769466 ) ) ;
10903: tok2@var3320 .@expr27628 insertToken (@expr1073769468 "=" ) ;
10904: tok2@var3320 =@expr1073769469 tok2@var3320 .@expr27607 tokAt (@expr1073769471 4 ) ;
10905: }
10906: }
10907: }
10908:
10909:
10910: if (@expr1073769472 !@expr1073769473 (@expr1073769474 !@expr1073769475 inFunction@var3317 &&@expr1073769476 tok1@var3318 .@expr27596 str (@expr27597 ) ==@expr27598 "union" ) &&@expr1073769480 !@expr1073769481 Token ::@expr27321 Match (@expr1073769483 tok1@var3318 .@expr27600 tokAt (@expr1073769485 -3 ) , "using %name% =" ) ) {
10911: skip@var3308 .@expr27439 pop (@expr27440 ) ;
10912: tok1@var3318 .@expr27664 deleteThis (@expr27665 ) ;
10913: if (@expr1073769490 tok1@var3318 .@expr1073769491 next (@expr1073769492 ) ==@expr1073769493 tok@var3312 ) {
10914: tok1@var3318 .@expr27664 deleteThis (@expr27665 ) ;
10915: tok@var3312 =@expr1073769496 tok1@var3318 ;
10916: } else {
10917: tok1@var3318 .@expr27664 deleteThis (@expr27665 ) ; }
10918: restart@var3319 =@expr1073769499 tok1@var3318 .@expr1073769500 previous (@expr1073769501 ) ;
10919: tok@var3312 .@expr27527 deleteThis (@expr27528 ) ;
10920: if (@expr1073769504 tok@var3312 .@expr27419 next (@expr27420 ) ) {
10921: tok@var3312 .@expr27527 deleteThis (@expr27528 ) ; }
10922: }
10923: }
10924:
10925: if (@expr1073769509 !@expr1073769510 restart@var3319 ) {
10926: simplifyStructDecl (@expr1073769511 ) ;
10927: return ;
10928: } else { if (@expr1073769512 !@expr1073769513 restart@var3319 .@expr1073769514 next (@expr1073769515 ) ) {
10929: return ; } }
10930:
10931: tok@var3312 =@expr1073769516 restart@var3319 ;
10932: } } } }
10933: }
10934: }
10935:
10936: void Tokenizer :: simplifyCallingConvention ( )
10937: {
10938: const bool windows@var3322 =@expr1073769517 mSettings@var879 .@expr1073769518 isWindowsPlatform (@expr1073769519 ) ;
10939:
10940: for (@expr1073769520 Token *@expr1073769521 tok@var3323 =@expr1073769522 list@var872 .@expr1073769523 front (@expr1073769524 ) ; tok@var3323 ; tok@var3323 =@expr1073769525 tok@var3323 .@expr1073769526 next (@expr1073769527 ) ) {
10941: while (@expr1073769528 Token ::@expr27705 Match (@expr1073769530 tok@var3323 , "__cdecl|__stdcall|__fastcall|__thiscall|__clrcall|__syscall|__pascal|__fortran|__far|__near" ) ||@expr1073769531 (@expr1073769532 windows@var3322 &&@expr1073769533 Token ::@expr27705 Match (@expr1073769535 tok@var3323 , "WINAPI|APIENTRY|CALLBACK" ) ) ) {
10942: tok@var3323 .@expr1073769536 deleteThis (@expr1073769537 ) ;
10943: }
10944: }
10945: }
10946:
10947: void Tokenizer :: simplifyDeclspec ( )
10948: {
10949: for (@expr1073769538 Token *@expr1073769539 tok@var3324 =@expr1073769540 list@var872 .@expr1073769541 front (@expr1073769542 ) ; tok@var3324 ; tok@var3324 =@expr1073769543 tok@var3324 .@expr27720 next (@expr27721 ) ) {
10950: while (@expr1073769546 Token ::@expr27723 Match (@expr1073769548 tok@var3324 , "__declspec|_declspec (" ) &&@expr1073769549 tok@var3324 .@expr27720 next (@expr27721 ) .@expr27728 link (@expr27729 ) &&@expr1073769554 tok@var3324 .@expr27720 next (@expr27721 ) .@expr27728 link (@expr27729 ) .@expr27735 next (@expr27736 ) ) {
10951: if (@expr1073769561 Token ::@expr27723 Match (@expr1073769563 tok@var3324 .@expr1073769564 tokAt (@expr1073769565 2 ) , "noreturn|nothrow" ) ) {
10952: Token * tok1@var3325 ; tok1@var3325 =@expr1073769566 tok@var3324 .@expr27720 next (@expr27721 ) .@expr27728 link (@expr27729 ) .@expr27735 next (@expr27736 ) ;
10953: while (@expr1073769573 tok1@var3325 &&@expr1073769574 !@expr1073769575 Token ::@expr27723 Match (@expr1073769577 tok1@var3325 , "%name%" ) ) {
10954: tok1@var3325 =@expr1073769578 tok1@var3325 .@expr1073769579 next (@expr1073769580 ) ;
10955: }
10956: if (@expr1073769581 tok1@var3325 ) {
10957: if (@expr1073769582 tok@var3324 .@expr27759 strAt (@expr27760 2 ) ==@expr1073769585 "noreturn" ) {
10958: tok1@var3325 .@expr1073769586 isAttributeNoreturn (@expr1073769587 true ) ; }
10959: else {
10960: tok1@var3325 .@expr1073769588 isAttributeNothrow (@expr1073769589 true ) ; }
10961: }
10962: } else { if (@expr1073769590 tok@var3324 .@expr27759 strAt (@expr27760 2 ) ==@expr1073769593 "property" ) {
10963: tok@var3324 .@expr27720 next (@expr27721 ) .@expr27728 link (@expr27729 ) .@expr1073769598 insertToken (@expr1073769599 "__property" ) ; } }
10964:
10965: Token ::@expr1073769600 eraseTokens (@expr1073769601 tok@var3324 , tok@var3324 .@expr27720 next (@expr27721 ) .@expr27728 link (@expr27729 ) .@expr27735 next (@expr27736 ) ) ;
10966: tok@var3324 .@expr1073769608 deleteThis (@expr1073769609 ) ;
10967: }
10968: }
10969: }
10970:
10971: void Tokenizer :: simplifyAttribute ( )
10972: {
10973: for (@expr1073769611 Token *@expr27788 tok@var3326 =@expr1073769613 list@var872 .@expr1073769614 front (@expr1073769615 ) ; tok@var3326 ; tok@var3326 =@expr1073769616 tok@var3326 .@expr1073769617 next (@expr1073769618 ) ) {
10974: if (@expr1073769619 Token ::@expr27796 Match (@expr1073769621 tok@var3326 , "%type% (" ) &&@expr1073769622 !@expr1073769623 mSettings@var879 .@expr27800 library@var3563 .@expr1073769625 isNotLibraryFunction (@expr1073769626 tok@var3326 ) ) {
10975: if (@expr1073769627 mSettings@var879 .@expr27800 library@var3563 .@expr27805 isFunctionConst (@expr1073769630 tok@var3326 .@expr27807 str (@expr27808 ) , true ) ) {
10976: tok@var3326 .@expr1073769633 isAttributePure (@expr1073769634 true ) ; }
10977: if (@expr1073769635 mSettings@var879 .@expr27800 library@var3563 .@expr27805 isFunctionConst (@expr1073769638 tok@var3326 .@expr27807 str (@expr27808 ) , false ) ) {
10978: tok@var3326 .@expr1073769641 isAttributeConst (@expr1073769642 true ) ; }
10979: }
10980: while (@expr1073769643 Token ::@expr27796 Match (@expr1073769645 tok@var3326 , "__attribute__|__attribute (" ) ) {
10981: Token * after@var3327 ; after@var3327 =@expr1073769646 tok@var3326 ;
10982: while (@expr1073769647 Token ::@expr27796 Match (@expr1073769649 after@var3327 , "__attribute__|__attribute (" ) ) {
10983: after@var3327 =@expr1073769650 after@var3327 .@expr1073769651 linkAt (@expr1073769652 1 ) .@expr1073769653 next (@expr1073769654 ) ; }
10984: if (@expr1073769655 !@expr1073769656 after@var3327 ) {
10985: syntaxError (@expr27833 tok@var3326 ) ; }
10986:
10987: Token * functok@var3328 ; functok@var3328 =@expr1073769658 nullptr ;
10988: if (@expr1073769659 Token ::@expr27796 Match (@expr1073769661 after@var3327 , "%name%|*|&|(" ) ) {
10989: Token * ftok@var3329 ; ftok@var3329 =@expr1073769662 after@var3327 ;
10990: while (@expr1073769663 Token ::@expr27796 Match (@expr1073769665 ftok@var3329 , "%name%|::|<|*|& !!(" ) ) {
10991: if (@expr1073769666 ftok@var3329 .@expr1073769667 str (@expr1073769668 ) ==@expr1073769669 "<" ) {
10992: ftok@var3329 =@expr1073769670 ftok@var3329 .@expr1073769671 findClosingBracket (@expr1073769672 ) ;
10993: if (@expr1073769673 !@expr1073769674 ftok@var3329 ) {
10994: break ; }
10995: }
10996: ftok@var3329 =@expr1073769675 ftok@var3329 .@expr1073769676 next (@expr1073769677 ) ;
10997: }
10998: if (@expr1073769678 Token ::@expr27855 simpleMatch (@expr1073769680 ftok@var3329 , "( *" ) ) {
10999: ftok@var3329 =@expr1073769681 ftok@var3329 .@expr1073769682 tokAt (@expr1073769683 2 ) ; }
11000: if (@expr1073769684 Token ::@expr27796 Match (@expr1073769686 ftok@var3329 , "%name% (|)" ) ) {
11001: functok@var3328 =@expr1073769687 ftok@var3329 ; }
11002: } else { if (@expr1073769688 Token ::@expr27796 Match (@expr1073769690 after@var3327 , "[;{=:]" ) ) {
11003: Token * prev@var3330 ; prev@var3330 =@expr1073769691 tok@var3326 .@expr27868 previous (@expr27869 ) ;
11004: while (@expr1073769694 Token ::@expr27796 Match (@expr1073769696 prev@var3330 , "%name%" ) ) {
11005: prev@var3330 =@expr1073769697 prev@var3330 .@expr1073769698 previous (@expr1073769699 ) ; }
11006: if (@expr1073769700 Token ::@expr27855 simpleMatch (@expr27878 prev@var3330 , ")" ) &&@expr1073769703 Token ::@expr27796 Match (@expr1073769705 prev@var3330 .@expr27882 link (@expr27883 ) .@expr27884 previous (@expr27885 ) , "%name% (" ) ) {
11007: functok@var3328 =@expr1073769710 prev@var3330 .@expr27882 link (@expr27883 ) .@expr27884 previous (@expr27885 ) ; }
11008: else { if (@expr1073769715 Token ::@expr27855 simpleMatch (@expr27878 prev@var3330 , ")" ) &&@expr1073769718 Token ::@expr27796 Match (@expr1073769720 prev@var3330 .@expr27882 link (@expr27883 ) .@expr27899 tokAt (@expr27900 -2 ) , "operator %op% (" ) &&@expr1073769725 isCPP (@expr1073769726 ) ) {
11009: functok@var3328 =@expr1073769727 prev@var3330 .@expr27882 link (@expr27883 ) .@expr27899 tokAt (@expr27900 -2 ) ; }
11010: else { if (@expr1073769732 (@expr1073769733 !@expr1073769734 prev@var3330 ||@expr1073769735 Token ::@expr27796 Match (@expr1073769737 prev@var3330 , "[;{}*]" ) ) &&@expr1073769738 Token ::@expr27796 Match (@expr1073769740 tok@var3326 .@expr27868 previous (@expr27869 ) , "%name%" ) ) {
11011: functok@var3328 =@expr1073769743 tok@var3326 .@expr27868 previous (@expr27869 ) ; } } }
11012: } }
11013:
11014: for (@expr1073769746 Token *@expr27788 attr@var3331 =@expr1073769748 tok@var3326 .@expr1073769749 tokAt (@expr1073769750 2 ) ; attr@var3331 .@expr1073769751 str (@expr1073769752 ) !=@expr1073769753 ")" ; attr@var3331 =@expr1073769754 attr@var3331 .@expr27931 next (@expr27932 ) ) {
11015: if (@expr1073769757 Token ::@expr27796 Match (@expr1073769759 attr@var3331 , "%name% (" ) ) {
11016: attr@var3331 =@expr1073769760 attr@var3331 .@expr1073769761 linkAt (@expr1073769762 1 ) ; }
11017:
11018: if (@expr1073769763 Token ::@expr27796 Match (@expr1073769765 attr@var3331 , "[(,] constructor|__constructor__ [,()]" ) ) {
11019: if (@expr27942 !@expr27943 functok@var3328 ) {
11020: syntaxError (@expr27833 tok@var3326 ) ; }
11021: functok@var3328 .@expr1073769769 isAttributeConstructor (@expr1073769770 true ) ;
11022: }
11023:
11024: else { if (@expr1073769771 Token ::@expr27796 Match (@expr1073769773 attr@var3331 , "[(,] destructor|__destructor__ [,()]" ) ) {
11025: if (@expr27942 !@expr27943 functok@var3328 ) {
11026: syntaxError (@expr27833 tok@var3326 ) ; }
11027: functok@var3328 .@expr1073769777 isAttributeDestructor (@expr1073769778 true ) ;
11028: }
11029:
11030: else { if (@expr1073769779 Token ::@expr27796 Match (@expr1073769781 attr@var3331 , "[(,] unused|__unused__|used|__used__ [,)]" ) ) {
11031: Token * vartok@var3332 ; vartok@var3332 =@expr1073769782 nullptr ;
11032:
11033:
11034: if (@expr1073769783 Token ::@expr27796 Match (@expr1073769785 after@var3327 , ";|=" ) ) {
11035: if (@expr1073769786 Token ::@expr27796 Match (@expr1073769788 tok@var3326 .@expr27868 previous (@expr27869 ) , "%type%" ) ) {
11036: vartok@var3332 =@expr1073769791 tok@var3326 .@expr27868 previous (@expr27869 ) ; }
11037: }
11038:
11039:
11040: else { if (@expr1073769794 Token ::@expr27796 Match (@expr1073769796 after@var3327 , "%type%" ) ) {
11041: vartok@var3332 =@expr1073769797 after@var3327 ; } }
11042:
11043: if (@expr1073769798 vartok@var3332 ) {
11044: const std ::@expr27975 string & attribute@var3333 (@expr1073769800 attr@var3331 .@expr27931 next (@expr27932 ) .@expr27979 str (@expr27980 ) ) ;
11045: if (@expr1073769805 attribute@var3333 .@expr1073769806 find (@expr1073769807 "unused" ) !=@expr1073769808 std ::@expr27975 string ::@expr27986 npos@expr27786 ) {
11046: vartok@var3332 .@expr1073769811 isAttributeUnused (@expr1073769812 true ) ; }
11047: else {
11048: vartok@var3332 .@expr1073769813 isAttributeUsed (@expr1073769814 true ) ; }
11049: }
11050: }
11051:
11052: else { if (@expr1073769815 Token ::@expr27796 Match (@expr1073769817 attr@var3331 , "[(,] pure|__pure__|const|__const__|noreturn|__noreturn__|nothrow|__nothrow__|warn_unused_result [,)]" ) ) {
11053: if (@expr27942 !@expr27943 functok@var3328 ) {
11054: syntaxError (@expr27833 tok@var3326 ) ; }
11055:
11056: const std ::@expr27975 string & attribute@var3334 (@expr1073769822 attr@var3331 .@expr27931 next (@expr27932 ) .@expr27979 str (@expr27980 ) ) ;
11057: if (@expr1073769827 attribute@var3334 .@expr28004 find (@expr1073769829 "pure" ) !=@expr1073769830 std ::@expr27975 string ::@expr27986 npos@expr27786 ) {
11058: functok@var3328 .@expr1073769833 isAttributePure (@expr1073769834 true ) ; }
11059: else { if (@expr1073769835 attribute@var3334 .@expr28004 find (@expr1073769837 "const" ) !=@expr1073769838 std ::@expr27975 string ::@expr27986 npos@expr27786 ) {
11060: functok@var3328 .@expr1073769841 isAttributeConst (@expr1073769842 true ) ; }
11061: else { if (@expr1073769843 attribute@var3334 .@expr28004 find (@expr1073769845 "noreturn" ) !=@expr1073769846 std ::@expr27975 string ::@expr27986 npos@expr27786 ) {
11062: functok@var3328 .@expr1073769849 isAttributeNoreturn (@expr1073769850 true ) ; }
11063: else { if (@expr1073769851 attribute@var3334 .@expr28004 find (@expr1073769853 "nothrow" ) !=@expr1073769854 std ::@expr27975 string ::@expr27986 npos@expr27786 ) {
11064: functok@var3328 .@expr1073769857 isAttributeNothrow (@expr1073769858 true ) ; }
11065: else { if (@expr1073769859 attribute@var3334 .@expr28004 find (@expr1073769861 "warn_unused_result" ) !=@expr1073769862 std ::@expr27975 string ::@expr27986 npos@expr27786 ) {
11066: functok@var3328 .@expr1073769865 isAttributeNodiscard (@expr1073769866 true ) ; } } } } }
11067: }
11068:
11069: else { if (@expr1073769867 Token ::@expr27796 Match (@expr1073769869 attr@var3331 , "[(,] packed [,)]" ) &&@expr1073769870 Token ::@expr27855 simpleMatch (@expr1073769872 tok@var3326 .@expr27868 previous (@expr27869 ) , "}" ) ) {
11070: tok@var3326 .@expr27868 previous (@expr27869 ) .@expr1073769877 isAttributePacked (@expr1073769878 true ) ; } } } } }
11071: }
11072:
11073: Token ::@expr1073769879 eraseTokens (@expr1073769880 tok@var3326 , tok@var3326 .@expr1073769881 linkAt (@expr1073769882 1 ) .@expr1073769883 next (@expr1073769884 ) ) ;
11074: tok@var3326 .@expr1073769885 deleteThis (@expr1073769886 ) ;
11075: }
11076: }
11077: }
11078:
11079: void Tokenizer :: simplifyCppcheckAttribute ( )
11080: {
11081: for (@expr1073769887 Token *@expr1073769888 tok@var3335 =@expr1073769889 list@var872 .@expr1073769890 front (@expr1073769891 ) ; tok@var3335 ; tok@var3335 =@expr1073769892 tok@var3335 .@expr28069 next (@expr28070 ) ) {
11082: if (@expr1073769895 tok@var3335 .@expr28072 str (@expr1073769897 ) !=@expr1073769898 "(" ) {
11083: continue ; }
11084: if (@expr1073769899 !@expr1073769900 tok@var3335 .@expr28077 previous (@expr28078 ) ) {
11085: continue ; }
11086: const std ::@expr1073769903 string &@expr1073769904 attr@var3336 =@expr1073769905 tok@var3335 .@expr28077 previous (@expr28078 ) .@expr1073769908 str (@expr1073769909 ) ;
11087: if (@expr1073769910 attr@var3336 .@expr28087 compare (@expr1073769912 0 , 11 , "__cppcheck_" ) !=@expr1073769913 0 ) {
11088: continue ; }
11089: if (@expr1073769914 attr@var3336 .@expr28087 compare (@expr1073769916 attr@var3336 .@expr1073769917 size (@expr1073769918 ) -@expr1073769919 2 , 2 , "__" ) !=@expr1073769920 0 ) {
11090: continue ; }
11091:
11092: Token * vartok@var3337 ; vartok@var3337 =@expr1073769921 tok@var3335 .@expr1073769922 link (@expr1073769923 ) ;
11093: while (@expr1073769924 Token ::@expr28101 Match (@expr1073769926 vartok@var3337 .@expr28103 next (@expr28104 ) , "%name%|*|&|::" ) ) {
11094: vartok@var3337 =@expr1073769929 vartok@var3337 .@expr28103 next (@expr28104 ) ;
11095: if (@expr1073769932 Token ::@expr28101 Match (@expr1073769934 vartok@var3337 , "%name% (" ) &&@expr1073769935 vartok@var3337 .@expr1073769936 str (@expr1073769937 ) .@expr1073769938 compare (@expr1073769939 0 , 11 , "__cppcheck_" ) ==@expr1073769940 0 ) {
11096: vartok@var3337 =@expr1073769941 vartok@var3337 .@expr1073769942 linkAt (@expr1073769943 1 ) ; }
11097: }
11098:
11099: if (@expr1073769944 vartok@var3337 .@expr1073769945 isName (@expr1073769946 ) ) {
11100: if (@expr1073769947 Token ::@expr28101 Match (@expr1073769949 tok@var3335 .@expr28077 previous (@expr28078 ) , "__cppcheck_low__ ( %num% )" ) ) {
11101: vartok@var3337 .@expr28128 setCppcheckAttribute (@expr1073769953 TokenImpl ::@expr28130 CppcheckAttributes ::@expr28131 Type ::@expr1073769956 LOW , MathLib ::@expr28133 toLongNumber (@expr28134 tok@var3335 .@expr28069 next (@expr28070 ) .@expr28137 str (@expr28138 ) ) ) ; }
11102: else { if (@expr1073769963 Token ::@expr28101 Match (@expr1073769965 tok@var3335 .@expr28077 previous (@expr28078 ) , "__cppcheck_high__ ( %num% )" ) ) {
11103: vartok@var3337 .@expr28128 setCppcheckAttribute (@expr1073769969 TokenImpl ::@expr28130 CppcheckAttributes ::@expr28131 Type ::@expr1073769972 HIGH , MathLib ::@expr28133 toLongNumber (@expr28134 tok@var3335 .@expr28069 next (@expr28070 ) .@expr28137 str (@expr28138 ) ) ) ; } }
11104: }
11105:
11106:
11107: if (@expr1073769979 tok@var3335 .@expr28156 tokAt (@expr28157 -2 ) ) {
11108: tok@var3335 =@expr1073769982 tok@var3335 .@expr28156 tokAt (@expr28157 -2 ) ;
11109: Token ::@expr28161 eraseTokens (@expr1073769986 tok@var3335 , tok@var3335 .@expr28163 linkAt (@expr1073769988 2 ) .@expr1073769989 next (@expr1073769990 ) ) ;
11110: } else {
11111: tok@var3335 =@expr1073769991 tok@var3335 .@expr28077 previous (@expr28078 ) ;
11112: Token ::@expr28161 eraseTokens (@expr1073769995 tok@var3335 , tok@var3335 .@expr28163 linkAt (@expr1073769997 1 ) .@expr1073769998 next (@expr1073769999 ) ) ;
11113: tok@var3335 .@expr28072 str (@expr1073770001 ";" ) ;
11114: }
11115: }
11116: }
11117:
11118: void Tokenizer :: simplifyCPPAttribute ( )
11119: {
11120: if (@expr1073770002 mSettings@var879 .@expr1073770003 standards@var3567 .@expr1073770004 cpp@var3568 <@expr1073770005 Standards ::@expr1073770006 CPP11 ||@expr1073770007 isC (@expr1073770008 ) ) {
11121: return ; }
11122:
11123: for (@expr1073770009 Token *@expr1073770010 tok@var3338 =@expr1073770011 list@var872 .@expr28188 front (@expr28189 ) ; tok@var3338 ; tok@var3338 =@expr1073770014 tok@var3338 .@expr28191 next (@expr28192 ) ) {
11124: if (@expr1073770017 !@expr1073770018 isCPPAttribute (@expr28195 tok@var3338 ) &&@expr1073770020 !@expr1073770021 isAlignAttribute (@expr1073770022 tok@var3338 ) ) {
11125: continue ;
11126: }
11127: if (@expr1073770023 isCPPAttribute (@expr28195 tok@var3338 ) ) {
11128: if (@expr1073770025 Token ::@expr28202 findsimplematch (@expr1073770027 tok@var3338 .@expr28204 tokAt (@expr28205 2 ) , "noreturn" , tok@var3338 .@expr28206 link (@expr28207 ) ) ) {
11129: const Token * head@var3339 ; head@var3339 =@expr1073770032 skipCPPOrAlignAttribute (@expr28209 tok@var3338 ) ;
11130: while (@expr1073770034 isCPPAttribute (@expr1073770035 head@var3339 ) ||@expr1073770036 isAlignAttribute (@expr1073770037 head@var3339 ) ) {
11131: head@var3339 =@expr1073770038 skipCPPOrAlignAttribute (@expr1073770039 head@var3339 ) ; }
11132: head@var3339 =@expr1073770040 head@var3339 .@expr28217 next (@expr28218 ) ;
11133: while (@expr1073770043 Token ::@expr28220 Match (@expr1073770045 head@var3339 , "%name%|::|*|&|<|>|," ) ) {
11134: head@var3339 =@expr1073770046 head@var3339 .@expr28217 next (@expr28218 ) ; }
11135: if (@expr1073770049 head@var3339 &&@expr1073770050 head@var3339 .@expr1073770051 str (@expr1073770052 ) ==@expr1073770053 "(" &&@expr1073770054 isFunctionHead (@expr1073770055 head@var3339 , "{|;" ) ) {
11136: head@var3339 .@expr1073770056 previous (@expr1073770057 ) .@expr1073770058 isAttributeNoreturn (@expr1073770059 true ) ;
11137: }
11138: } else { if (@expr1073770060 Token ::@expr28202 findsimplematch (@expr1073770062 tok@var3338 .@expr28204 tokAt (@expr28205 2 ) , "nodiscard" , tok@var3338 .@expr28206 link (@expr28207 ) ) ) {
11139: const Token * head@var3340 ; head@var3340 =@expr1073770067 skipCPPOrAlignAttribute (@expr28209 tok@var3338 ) ;
11140: while (@expr1073770069 isCPPAttribute (@expr1073770070 head@var3340 ) ||@expr1073770071 isAlignAttribute (@expr1073770072 head@var3340 ) ) {
11141: head@var3340 =@expr1073770073 skipCPPOrAlignAttribute (@expr1073770074 head@var3340 ) ; }
11142: head@var3340 =@expr1073770075 head@var3340 .@expr28252 next (@expr28253 ) ;
11143: while (@expr1073770078 Token ::@expr28220 Match (@expr1073770080 head@var3340 , "%name%|::|*|&|<|>|," ) ) {
11144: head@var3340 =@expr1073770081 head@var3340 .@expr28252 next (@expr28253 ) ; }
11145: if (@expr1073770084 head@var3340 &&@expr1073770085 head@var3340 .@expr1073770086 str (@expr1073770087 ) ==@expr1073770088 "(" &&@expr1073770089 isFunctionHead (@expr1073770090 head@var3340 , "{|;" ) ) {
11146: head@var3340 .@expr1073770091 previous (@expr1073770092 ) .@expr1073770093 isAttributeNodiscard (@expr1073770094 true ) ;
11147: }
11148: } else { if (@expr1073770095 Token ::@expr28202 findsimplematch (@expr1073770097 tok@var3338 .@expr28204 tokAt (@expr28205 2 ) , "maybe_unused" , tok@var3338 .@expr28206 link (@expr28207 ) ) ) {
11149: const Token * head@var3341 ; head@var3341 =@expr1073770102 skipCPPOrAlignAttribute (@expr28209 tok@var3338 ) ;
11150: while (@expr1073770104 isCPPAttribute (@expr1073770105 head@var3341 ) ||@expr1073770106 isAlignAttribute (@expr1073770107 head@var3341 ) ) {
11151: head@var3341 =@expr1073770108 skipCPPOrAlignAttribute (@expr1073770109 head@var3341 ) ; }
11152: head@var3341 .@expr1073770110 next (@expr1073770111 ) .@expr1073770112 isAttributeMaybeUnused (@expr1073770113 true ) ;
11153: } else { if (@expr1073770114 Token ::@expr28220 Match (@expr1073770116 tok@var3338 .@expr28293 previous (@expr28294 ) , ") [ [ expects|ensures|assert default|audit|axiom| : %name% <|<=|>|>= %num% ] ]" ) ) {
11154: const Token * vartok@var3342 ; vartok@var3342 =@expr1073770119 tok@var3338 .@expr28204 tokAt (@expr1073770121 4 ) ;
11155: if (@expr1073770122 vartok@var3342 .@expr28299 str (@expr28300 ) ==@expr1073770125 ":" ) {
11156: vartok@var3342 =@expr1073770126 vartok@var3342 .@expr28303 next (@expr28304 ) ; }
11157: Token * argtok@var3343 ; argtok@var3343 =@expr1073770129 tok@var3338 .@expr28204 tokAt (@expr1073770131 -2 ) ;
11158: while (@expr1073770132 argtok@var3343 &&@expr1073770133 argtok@var3343 .@expr28310 str (@expr28311 ) !=@expr1073770136 "(" ) {
11159: if (@expr1073770137 argtok@var3343 .@expr28310 str (@expr28311 ) ==@expr28316 vartok@var3342 .@expr28299 str (@expr28300 ) ) {
11160: break ; }
11161: if (@expr1073770143 argtok@var3343 .@expr28310 str (@expr28311 ) ==@expr1073770146 ")" ) {
11162: argtok@var3343 =@expr1073770147 argtok@var3343 .@expr1073770148 link (@expr1073770149 ) ; }
11163: argtok@var3343 =@expr1073770150 argtok@var3343 .@expr1073770151 previous (@expr1073770152 ) ;
11164: }
11165: if (@expr1073770153 argtok@var3343 &&@expr1073770154 argtok@var3343 .@expr28310 str (@expr28311 ) ==@expr28316 vartok@var3342 .@expr28299 str (@expr28300 ) ) {
11166: if (@expr1073770160 vartok@var3342 .@expr28303 next (@expr28304 ) .@expr28339 str (@expr28340 ) ==@expr1073770165 ">=" ) {
11167: argtok@var3343 .@expr28342 setCppcheckAttribute (@expr1073770167 TokenImpl ::@expr28344 CppcheckAttributes ::@expr28345 Type ::@expr28346 LOW , MathLib ::@expr28347 toLongNumber (@expr28348 vartok@var3342 .@expr28349 strAt (@expr28350 2 ) ) ) ; }
11168: else { if (@expr1073770175 vartok@var3342 .@expr28303 next (@expr28304 ) .@expr28339 str (@expr28340 ) ==@expr1073770180 ">" ) {
11169: argtok@var3343 .@expr28342 setCppcheckAttribute (@expr1073770182 TokenImpl ::@expr28344 CppcheckAttributes ::@expr28345 Type ::@expr28346 LOW , MathLib ::@expr28347 toLongNumber (@expr28348 vartok@var3342 .@expr28349 strAt (@expr28350 2 ) ) +@expr1073770190 1 ) ; }
11170: else { if (@expr1073770191 vartok@var3342 .@expr28303 next (@expr28304 ) .@expr28339 str (@expr28340 ) ==@expr1073770196 "<=" ) {
11171: argtok@var3343 .@expr28342 setCppcheckAttribute (@expr1073770198 TokenImpl ::@expr28344 CppcheckAttributes ::@expr28345 Type ::@expr28377 HIGH , MathLib ::@expr28347 toLongNumber (@expr28348 vartok@var3342 .@expr28349 strAt (@expr28350 2 ) ) ) ; }
11172: else { if (@expr1073770206 vartok@var3342 .@expr28303 next (@expr28304 ) .@expr28339 str (@expr28340 ) ==@expr1073770211 "<" ) {
11173: argtok@var3343 .@expr28342 setCppcheckAttribute (@expr1073770213 TokenImpl ::@expr28344 CppcheckAttributes ::@expr28345 Type ::@expr28377 HIGH , MathLib ::@expr28347 toLongNumber (@expr28348 vartok@var3342 .@expr28349 strAt (@expr28350 2 ) ) -@expr1073770221 1 ) ; } } } }
11174: }
11175: } } } }
11176: } else {
11177: if (@expr1073770222 Token ::@expr1073770223 simpleMatch (@expr1073770224 tok@var3338 , "alignas (" ) ) {
11178:
11179: }
11180: }
11181: Token ::@expr1073770225 eraseTokens (@expr1073770226 tok@var3338 , skipCPPOrAlignAttribute (@expr28209 tok@var3338 ) .@expr1073770228 next (@expr1073770229 ) ) ;
11182:
11183: if (@expr1073770230 tok@var3338 .@expr28293 previous (@expr28294 ) ) {
11184: tok@var3338 =@expr1073770233 tok@var3338 .@expr28293 previous (@expr28294 ) ;
11185: tok@var3338 .@expr28191 next (@expr28192 ) .@expr1073770238 deleteThis (@expr1073770239 ) ;
11186: } else {
11187: tok@var3338 .@expr1073770240 deleteThis (@expr1073770241 ) ;
11188: tok@var3338 =@expr1073770242 list@var872 .@expr28188 front (@expr28189 ) ;
11189: }
11190: }
11191: }
11192:
11193: void Tokenizer :: removeAlignas ( )
11194: {
11195: if (@expr1073770245 !@expr1073770246 isCPP (@expr1073770247 ) ||@expr1073770248 mSettings@var879 .@expr1073770249 standards@var3567 .@expr1073770250 cpp@var3568 <@expr1073770251 Standards ::@expr1073770252 CPP11 ) {
11196: return ; }
11197:
11198: for (@expr1073770253 Token *@expr1073770254 tok@var3344 =@expr1073770255 list@var872 .@expr1073770256 front (@expr1073770257 ) ; tok@var3344 ; tok@var3344 =@expr1073770258 tok@var3344 .@expr1073770259 next (@expr1073770260 ) ) {
11199: if (@expr1073770261 Token ::@expr28438 Match (@expr1073770263 tok@var3344 , "[;{}] alignas (" ) &&@expr1073770264 Token ::@expr28438 Match (@expr1073770266 tok@var3344 .@expr28443 linkAt (@expr28444 2 ) , ") %name%" ) ) {
11200: Token ::@expr1073770269 eraseTokens (@expr1073770270 tok@var3344 , tok@var3344 .@expr28443 linkAt (@expr28444 2 ) .@expr1073770273 next (@expr1073770274 ) ) ; }
11201: }
11202: }
11203:
11204: void Tokenizer :: simplifySpaceshipOperator ( )
11205: {
11206: if (@expr1073770275 isCPP (@expr1073770276 ) &&@expr1073770277 mSettings@var879 .@expr1073770278 standards@var3567 .@expr1073770279 cpp@var3568 >=@expr1073770280 Standards ::@expr1073770281 CPP20 ) {
11207: for (@expr1073770282 Token *@expr1073770283 tok@var3345 =@expr1073770284 list@var872 .@expr1073770285 front (@expr1073770286 ) ; tok@var3345 &&@expr1073770287 tok@var3345 .@expr28464 next (@expr28465 ) ; tok@var3345 =@expr1073770290 tok@var3345 .@expr28464 next (@expr28465 ) ) {
11208: if (@expr1073770293 Token ::@expr1073770294 simpleMatch (@expr1073770295 tok@var3345 , "<= >" ) ) {
11209: tok@var3345 .@expr1073770296 str (@expr1073770297 "<=>" ) ;
11210: tok@var3345 .@expr1073770298 deleteNext (@expr1073770299 ) ;
11211: }
11212: }
11213: }
11214: }
11215:
11216: static const std :: unordered_set < std :: string > keywords@var3346 = {
11217: "inline"
11218: , "_inline"
11219: , "__inline"
11220: , "__forceinline"
11221: , "register"
11222: , "__restrict"
11223: , "__restrict__"
11224: , "__thread"
11225: } ;
11226:
|
11229:
11230: void Tokenizer :: simplifyKeyword ( )
11231: {
11232:
|
11237:
11238: const bool c99@var3347 =@expr1073770301 isC (@expr28478 ) &&@expr1073770303 mSettings@var879 .@expr28480 standards@var3567 .@expr28481 c@var3588 >=@expr1073770306 Standards ::@expr1073770307 C99 ;
11239: const bool cpp11@var3348 =@expr1073770308 isCPP (@expr1073770309 ) &&@expr1073770310 mSettings@var879 .@expr28480 standards@var3567 .@expr28488 cpp@var3568 >=@expr1073770313 Standards ::@expr1073770314 CPP11 ;
11240:
11241: for (@expr1073770315 Token *@expr1073770316 tok@var3349 =@expr1073770317 list@var872 .@expr1073770318 front (@expr1073770319 ) ; tok@var3349 ; tok@var3349 =@expr1073770320 tok@var3349 .@expr28497 next (@expr28498 ) ) {
11242: if (@expr1073770323 keywords@var3346 .@expr1073770324 find (@expr1073770325 tok@var3349 .@expr28502 str (@expr28503 ) ) !=@expr1073770328 keywords@var3346 .@expr1073770329 end (@expr1073770330 ) ) {
11243:
11244: if (@expr1073770331 !@expr1073770332 Token ::@expr1073770333 simpleMatch (@expr1073770334 tok@var3349 .@expr28511 previous (@expr28512 ) , "." ) ) {
11245: if (@expr1073770337 tok@var3349 .@expr28502 str (@expr28503 ) .@expr1073770340 find (@expr1073770341 "inline" ) !=@expr1073770342 std ::@expr1073770343 string ::@expr1073770344 npos@expr1073770300 ) {
11246: Token * temp@var3350 ; temp@var3350 =@expr1073770345 tok@var3349 .@expr28497 next (@expr28498 ) ;
11247: while (@expr1073770348 temp@var3350 !=@expr1073770349 nullptr &&@expr1073770350 Token ::@expr28527 Match (@expr1073770352 temp@var3350 , "%name%" ) ) {
11248: temp@var3350 .@expr1073770353 isInline (@expr1073770354 true ) ;
11249: temp@var3350 =@expr1073770355 temp@var3350 .@expr1073770356 next (@expr1073770357 ) ;
11250: }
11251: }
11252: tok@var3349 .@expr28534 deleteThis (@expr28535 ) ;
11253: }
11254: }
11255:
11256: if (@expr1073770360 isC (@expr28478 ) ||@expr1073770362 mSettings@var879 .@expr28480 standards@var3567 .@expr28488 cpp@var3568 ==@expr1073770365 Standards ::@expr1073770366 CPP03 ) {
11257: if (@expr1073770367 tok@var3349 .@expr28502 str (@expr28503 ) ==@expr1073770370 "auto" ) {
11258: tok@var3349 .@expr28534 deleteThis (@expr28535 ) ; }
11259: }
11260:
11261:
11262:
11263: if (@expr1073770373 Token ::@expr28527 Match (@expr1073770375 tok@var3349 , "[ static %num%" ) ) {
11264: tok@var3349 .@expr28552 deleteNext (@expr28553 ) ; }
11265:
11266: if (@expr1073770378 c99@var3347 ) {
11267: while (@expr1073770379 tok@var3349 .@expr28502 str (@expr28503 ) ==@expr1073770382 "restrict" ) {
11268: tok@var3349 .@expr28534 deleteThis (@expr28535 ) ; }
11269:
11270: if (@expr1073770385 mSettings@var879 .@expr28480 standards@var3567 .@expr28481 c@var3588 >=@expr1073770388 Standards ::@expr1073770389 C11 ) {
11271: while (@expr1073770390 tok@var3349 .@expr28502 str (@expr28503 ) ==@expr1073770393 "_Atomic" ) {
11272: tok@var3349 .@expr28534 deleteThis (@expr28535 ) ; }
11273: }
11274: }
11275:
11276: else { if (@expr1073770396 cpp11@var3348 ) {
11277:
11278:
11279: if (@expr1073770397 Token ::@expr28527 Match (@expr1073770399 tok@var3349 .@expr28511 previous (@expr28512 ) , "struct|class|union %type% final [:{]" ) ) {
11280: tok@var3349 .@expr28552 deleteNext (@expr28553 ) ;
11281: }
11282:
11283:
11284:
11285: else { if (@expr1073770404 Token ::@expr28527 Match (@expr1073770406 tok@var3349 , ") noexcept :|{|;|const|override|final" ) ) {
11286:
11287:
11288: Token * tokNoExcept@var3351 ; tokNoExcept@var3351 =@expr1073770407 tok@var3349 .@expr28497 next (@expr28498 ) ;
11289: tokNoExcept@var3351 .@expr28586 insertToken (@expr1073770411 ")" ) ;
11290: Token * braceEnd@var3352 ; braceEnd@var3352 =@expr1073770412 tokNoExcept@var3351 .@expr28589 next (@expr28590 ) ;
11291: tokNoExcept@var3351 .@expr28586 insertToken (@expr1073770416 "true" ) ;
11292: tokNoExcept@var3351 .@expr28586 insertToken (@expr1073770418 "(" ) ;
11293: Token * braceStart@var3353 ; braceStart@var3353 =@expr1073770419 tokNoExcept@var3351 .@expr28589 next (@expr28590 ) ;
11294: tok@var3349 =@expr1073770422 tok@var3349 .@expr1073770423 tokAt (@expr1073770424 3 ) ;
11295: Token ::@expr1073770425 createMutualLinks (@expr1073770426 braceStart@var3353 , braceEnd@var3352 ) ;
11296: }
11297:
11298:
11299:
11300: else { if (@expr1073770427 tok@var3349 .@expr28502 str (@expr28503 ) ==@expr1073770430 "thread_local" ) {
11301: tok@var3349 .@expr1073770431 originalName (@expr1073770432 tok@var3349 .@expr28502 str (@expr28503 ) ) ;
11302: tok@var3349 .@expr28502 str (@expr1073770436 "static" ) ;
11303: } } }
11304: } }
11305: }
11306: }
11307:
11308: void Tokenizer :: simplifyAssignmentInFunctionCall ( )
11309: {
11310: for (@expr1073770437 Token *@expr28614 tok@var3354 =@expr1073770439 list@var872 .@expr1073770440 front (@expr1073770441 ) ; tok@var3354 ; tok@var3354 =@expr1073770442 tok@var3354 .@expr28619 next (@expr28620 ) ) {
11311: if (@expr1073770445 tok@var3354 .@expr1073770446 str (@expr1073770447 ) ==@expr1073770448 "(" ) {
11312: tok@var3354 =@expr1073770449 tok@var3354 .@expr1073770450 link (@expr1073770451 ) ; }
11313:
11314:
11315: else { if (@expr1073770452 Token ::@expr28629 Match (@expr1073770454 tok@var3354 , "[;{}] %name% ( %name% =" ) &&@expr1073770455
11316: Token ::@expr1073770456 simpleMatch (@expr1073770457 tok@var3354 .@expr28634 linkAt (@expr28635 2 ) , ") ;" ) &&@expr1073770460
11317: !@expr1073770461 Token ::@expr28629 Match (@expr1073770463 tok@var3354 .@expr28619 next (@expr28620 ) , "assert|while" ) ) {
11318: const std ::@expr1073770466 string & funcname@var3355 (@expr1073770467 tok@var3354 .@expr28619 next (@expr28620 ) .@expr1073770470 str (@expr1073770471 ) ) ;
11319: Token * const vartok@var3356 ; vartok@var3356 =@expr1073770472 tok@var3354 .@expr1073770473 tokAt (@expr1073770474 3 ) ;
11320:
11321:
11322: for (@expr1073770475 Token *@expr28614 tok2@var3357 =@expr1073770477 vartok@var3356 .@expr1073770478 tokAt (@expr1073770479 2 ) ; tok2@var3357 ; tok2@var3357 =@expr1073770480 tok2@var3357 .@expr28657 next (@expr28658 ) ) {
11323: if (@expr1073770483 tok2@var3357 .@expr28660 link (@expr28661 ) &&@expr1073770486 Token ::@expr28629 Match (@expr1073770488 tok2@var3357 , "(|[|{" ) ) {
11324: tok2@var3357 =@expr1073770489 tok2@var3357 .@expr28660 link (@expr28661 ) ; }
11325: else { if (@expr1073770492 tok2@var3357 .@expr1073770493 str (@expr1073770494 ) ==@expr1073770495 ";" ) {
11326: break ; }
11327: else { if (@expr1073770496 Token ::@expr28629 Match (@expr1073770498 tok2@var3357 , ")|," ) ) {
11328: tok2@var3357 =@expr1073770499 tok2@var3357 .@expr1073770500 previous (@expr1073770501 ) ;
11329:
11330: tok2@var3357 .@expr28678 insertToken (@expr1073770503 vartok@var3356 .@expr1073770504 str (@expr1073770505 ) ) ;
11331: tok2@var3357 .@expr28657 next (@expr28658 ) .@expr1073770508 varId (@expr1073770509 vartok@var3356 .@expr1073770510 varId (@expr1073770511 ) ) ;
11332:
11333: tok2@var3357 .@expr28678 insertToken (@expr1073770513 "(" ) ;
11334: Token ::@expr1073770514 createMutualLinks (@expr1073770515 tok2@var3357 .@expr28657 next (@expr28658 ) , tok@var3354 .@expr28634 linkAt (@expr28635 2 ) ) ;
11335:
11336: tok2@var3357 .@expr28678 insertToken (@expr1073770521 funcname@var3355 ) ;
11337: tok2@var3357 .@expr28678 insertToken (@expr1073770523 ";" ) ;
11338:
11339: Token ::@expr1073770524 eraseTokens (@expr1073770525 tok@var3354 , vartok@var3356 ) ;
11340: break ;
11341: } } }
11342: }
11343: } }
11344: }
11345: }
11346:
11347: void Tokenizer :: simplifyAssignmentBlock ( )
11348: {
11349: for (@expr1073770526 Token *@expr1073770527 tok@var3358 =@expr1073770528 list@var872 .@expr1073770529 front (@expr1073770530 ) ; tok@var3358 ; tok@var3358 =@expr1073770531 tok@var3358 .@expr28708 next (@expr28709 ) ) {
11350: if (@expr1073770534 Token ::@expr28711 Match (@expr1073770536 tok@var3358 , "[;{}] %name% = ( {" ) ) {
11351: const std ::@expr1073770537 string &@expr1073770538 varname@var3359 =@expr1073770539 tok@var3358 .@expr28708 next (@expr28709 ) .@expr28718 str (@expr28719 ) ;
11352:
11353:
11354: int indentlevel@var3360 ; indentlevel@var3360 =@expr1073770544 0 ;
11355: Token * tok2@var3361 ; tok2@var3361 =@expr1073770545 tok@var3358 ;
11356: while (@expr1073770546 nullptr !=@expr1073770547 (@expr1073770548 tok2@var3361 =@expr1073770549 tok2@var3361 .@expr28726 next (@expr28727 ) ) ) {
11357: if (@expr1073770552 Token ::@expr28711 Match (@expr1073770554 tok2@var3361 , "(|{" ) ) {
11358: ++@expr1073770555 indentlevel@var3360 ; }
11359: else { if (@expr1073770556 Token ::@expr28711 Match (@expr1073770558 tok2@var3361 , ")|}" ) ) {
11360: if (@expr1073770559 indentlevel@var3360 <=@expr1073770560 2 ) {
11361: break ; }
11362: --@expr1073770561 indentlevel@var3360 ;
11363: } else { if (@expr1073770562 indentlevel@var3360 ==@expr28739 2 &&@expr1073770564 tok2@var3361 .@expr1073770565 str (@expr1073770566 ) ==@expr1073770567 varname@var3359 &&@expr1073770568 Token ::@expr28711 Match (@expr1073770570 tok2@var3361 .@expr1073770571 previous (@expr1073770572 ) , "%type%|*" ) ) {
11364:
11365: break ; } } }
11366: }
11367: if (@expr1073770573 indentlevel@var3360 ==@expr28739 2 &&@expr1073770575 Token ::@expr1073770576 simpleMatch (@expr1073770577 tok2@var3361 , "} )" ) ) {
11368: tok2@var3361 =@expr1073770578 tok2@var3361 .@expr28755 tokAt (@expr1073770580 -3 ) ;
11369: if (@expr1073770581 Token ::@expr28711 Match (@expr1073770583 tok2@var3361 , "[;{}] %num%|%name% ;" ) ) {
11370: tok2@var3361 .@expr28760 insertToken (@expr1073770585 "=" ) ;
11371: tok2@var3361 .@expr28760 insertToken (@expr1073770587 tok@var3358 .@expr28708 next (@expr28709 ) .@expr28718 str (@expr28719 ) ) ;
11372: tok2@var3361 .@expr28726 next (@expr28727 ) .@expr1073770594 varId (@expr1073770595 tok@var3358 .@expr28708 next (@expr28709 ) .@expr1073770598 varId (@expr1073770599 ) ) ;
11373: tok@var3358 .@expr1073770600 deleteNext (@expr1073770601 3 ) ;
11374: tok2@var3361 .@expr28755 tokAt (@expr1073770603 5 ) .@expr1073770604 deleteNext (@expr1073770605 ) ;
11375: }
11376: }
11377: }
11378: }
11379: }
11380:
11381:
11382: void Tokenizer :: simplifyAsm ( )
11383: {
11384: std ::@expr1073770606 string instruction@var3362 ;
11385: for (@expr1073770607 Token *@expr1073770608 tok@var3363 =@expr1073770609 list@var872 .@expr1073770610 front (@expr1073770611 ) ; tok@var3363 ; tok@var3363 =@expr1073770612 tok@var3363 .@expr28789 next (@expr28790 ) ) {
11386: if (@expr1073770615 Token ::@expr28792 Match (@expr1073770617 tok@var3363 , "__asm|_asm|asm {" ) &&@expr1073770618
11387: tok@var3363 .@expr28789 next (@expr28790 ) .@expr28797 link (@expr28798 ) .@expr28799 next (@expr28800 ) ) {
11388: instruction@var3362 =@expr1073770625 tok@var3363 .@expr28802 tokAt (@expr28803 2 ) .@expr1073770628 stringifyList (@expr1073770629 tok@var3363 .@expr28789 next (@expr28790 ) .@expr28797 link (@expr28798 ) ) ;
11389: Token ::@expr28810 eraseTokens (@expr1073770635 tok@var3363 , tok@var3363 .@expr28789 next (@expr28790 ) .@expr28797 link (@expr28798 ) .@expr28799 next (@expr28800 ) ) ;
11390: }
11391:
11392: else { if (@expr1073770642 Token ::@expr28792 Match (@expr1073770644 tok@var3363 , "asm|__asm|__asm__ volatile|__volatile|__volatile__| (" ) ) {
11393:
11394: Token * partok@var3364 ; partok@var3364 =@expr1073770645 tok@var3363 .@expr28789 next (@expr28790 ) ;
11395: if (@expr1073770648 partok@var3364 .@expr1073770649 str (@expr1073770650 ) !=@expr1073770651 "(" ) {
11396: partok@var3364 =@expr1073770652 partok@var3364 .@expr28829 next (@expr28830 ) ; }
11397: instruction@var3362 =@expr1073770655 partok@var3364 .@expr28829 next (@expr28830 ) .@expr1073770658 stringifyList (@expr1073770659 partok@var3364 .@expr28836 link (@expr28837 ) ) ;
11398: Token ::@expr28810 eraseTokens (@expr1073770663 tok@var3363 , partok@var3364 .@expr28836 link (@expr28837 ) .@expr1073770666 next (@expr1073770667 ) ) ;
11399: }
11400:
11401: else { if (@expr1073770668 Token ::@expr28792 Match (@expr1073770670 tok@var3363 , "_asm|__asm" ) ) {
11402: Token * endasm@var3365 ; endasm@var3365 =@expr1073770671 tok@var3363 .@expr28789 next (@expr28790 ) ;
11403: const Token * firstSemiColon@var3366 ; firstSemiColon@var3366 =@expr1073770674 nullptr ;
11404: int comment@var3367 ; comment@var3367 =@expr1073770675 0 ;
11405: while (@expr1073770676 Token ::@expr28792 Match (@expr1073770678 endasm@var3365 , "%num%|%name%|,|:|;" ) ||@expr1073770679 (@expr1073770680 endasm@var3365 &&@expr1073770681 endasm@var3365 .@expr28858 linenr (@expr28859 ) ==@expr1073770684 comment@var3367 ) ) {
11406: if (@expr1073770685 Token ::@expr28792 Match (@expr1073770687 endasm@var3365 , "_asm|__asm|__endasm" ) ) {
11407: break ; }
11408: if (@expr1073770688 endasm@var3365 .@expr1073770689 str (@expr1073770690 ) ==@expr1073770691 ";" ) {
11409: comment@var3367 =@expr1073770692 endasm@var3365 .@expr28858 linenr (@expr28859 ) ;
11410: if (@expr1073770695 !@expr1073770696 firstSemiColon@var3366 ) {
11411: firstSemiColon@var3366 =@expr1073770697 endasm@var3365 ; }
11412: }
11413: endasm@var3365 =@expr1073770698 endasm@var3365 .@expr28875 next (@expr28876 ) ;
11414: }
11415: if (@expr1073770701 Token ::@expr28878 simpleMatch (@expr1073770703 endasm@var3365 , "__endasm" ) ) {
11416: instruction@var3362 =@expr1073770704 tok@var3363 .@expr28789 next (@expr28790 ) .@expr28883 stringifyList (@expr28884 endasm@var3365 ) ;
11417: Token ::@expr28810 eraseTokens (@expr1073770710 tok@var3363 , endasm@var3365 .@expr28875 next (@expr28876 ) ) ;
11418: if (@expr1073770713 !@expr1073770714 Token ::@expr28878 simpleMatch (@expr1073770716 tok@var3363 .@expr28789 next (@expr28790 ) , ";" ) ) {
11419: tok@var3363 .@expr28895 insertToken (@expr28896 ";" ) ; }
11420: } else { if (@expr1073770721 firstSemiColon@var3366 ) {
11421: instruction@var3362 =@expr1073770722 tok@var3363 .@expr28789 next (@expr28790 ) .@expr28883 stringifyList (@expr1073770726 firstSemiColon@var3366 ) ;
11422: Token ::@expr28810 eraseTokens (@expr1073770728 tok@var3363 , firstSemiColon@var3366 ) ;
11423: } else { if (@expr1073770729 !@expr1073770730 endasm@var3365 ) {
11424: instruction@var3362 =@expr1073770731 tok@var3363 .@expr28789 next (@expr28790 ) .@expr28883 stringifyList (@expr28884 endasm@var3365 ) ;
11425: Token ::@expr28810 eraseTokens (@expr1073770737 tok@var3363 , endasm@var3365 ) ;
11426: tok@var3363 .@expr28895 insertToken (@expr28896 ";" ) ;
11427: } else {
11428: continue ; } } }
11429: }
11430:
11431: else {
11432: continue ; } } }
11433:
11434: if (@expr1073770740 Token ::@expr28792 Match (@expr1073770742 tok@var3363 .@expr1073770743 previous (@expr1073770744 ) , ") %name% %name% (" ) ) {
11435: tok@var3363 .@expr1073770745 deleteThis (@expr1073770746 ) ;
11436: continue ;
11437: }
11438:
11439:
11440: tok@var3363 .@expr1073770747 str (@expr1073770748 "asm" ) ;
11441: if (@expr1073770749 tok@var3363 .@expr28926 strAt (@expr28927 1 ) !=@expr1073770752 ";" &&@expr1073770753 tok@var3363 .@expr28926 strAt (@expr28927 1 ) !=@expr1073770756 "{" ) {
11442: tok@var3363 .@expr28895 insertToken (@expr28896 ";" ) ; }
11443: tok@var3363 .@expr28895 insertToken (@expr1073770760 ")" ) ;
11444: tok@var3363 .@expr28895 insertToken (@expr1073770762 "\"" +@expr1073770763 instruction@var3362 +@expr1073770764 "\"" ) ;
11445: tok@var3363 .@expr28895 insertToken (@expr1073770766 "(" ) ;
11446:
11447: tok@var3363 =@expr1073770767 tok@var3363 .@expr28789 next (@expr28790 ) ;
11448: Token ::@expr1073770770 createMutualLinks (@expr1073770771 tok@var3363 , tok@var3363 .@expr28802 tokAt (@expr28803 2 ) ) ;
11449:
11450:
11451: tok@var3363 =@expr1073770774 tok@var3363 .@expr28802 tokAt (@expr28803 2 ) ;
11452: if (@expr1073770777 tok@var3363 .@expr28789 next (@expr28790 ) &&@expr1073770780 tok@var3363 .@expr28789 next (@expr28790 ) .@expr1073770783 str (@expr1073770784 ) ==@expr1073770785 ";" &&@expr1073770786
11453: tok@var3363 .@expr28789 next (@expr28790 ) .@expr28965 linenr (@expr28966 ) !=@expr1073770791 tok@var3363 .@expr28968 linenr (@expr1073770793 ) ) {
11454: const int endposition@var3368 =@expr1073770794 tok@var3363 .@expr28789 next (@expr28790 ) .@expr28965 linenr (@expr28966 ) ;
11455: tok@var3363 =@expr1073770799 tok@var3363 .@expr28802 tokAt (@expr1073770801 -3 ) ;
11456: for (@expr1073770802 int i@var3369 =@expr1073770803 0 ; i@var3369 <@expr1073770804 4 ; ++@expr1073770805 i@var3369 ) {
11457: tok@var3363 =@expr1073770806 tok@var3363 .@expr28789 next (@expr28790 ) ;
11458: tok@var3363 .@expr28968 linenr (@expr1073770810 endposition@var3368 ) ;
11459: }
11460: }
11461: }
11462: }
11463:
11464: void Tokenizer :: simplifyAsm2 ( )
11465: {
11466:
|
11469:
11470: for (@expr1073770811 Token *@expr1073770812 tok@var3370 =@expr1073770813 list@var872 .@expr1073770814 front (@expr1073770815 ) ; tok@var3370 ; tok@var3370 =@expr1073770816 tok@var3370 .@expr28993 next (@expr28994 ) ) {
11471: if (@expr1073770819 tok@var3370 .@expr1073770820 str (@expr1073770821 ) !=@expr1073770822 "^" ) {
11472: continue ; }
11473:
11474: if (@expr1073770823 Token ::@expr29000 simpleMatch (@expr1073770825 tok@var3370 , "^ {" ) ||@expr1073770826 (@expr1073770827 Token ::@expr29000 simpleMatch (@expr1073770829 tok@var3370 .@expr1073770830 linkAt (@expr1073770831 1 ) , ") {" ) &&@expr1073770832 tok@var3370 .@expr1073770833 strAt (@expr1073770834 -1 ) !=@expr1073770835 "operator" ) ) {
11475: Token * start@var3371 ; start@var3371 =@expr1073770836 tok@var3370 ;
11476: while (@expr1073770837 start@var3371 &&@expr1073770838 !@expr1073770839 Token ::@expr29016 Match (@expr1073770841 start@var3371 , "[,(;{}=]" ) ) {
11477: if (@expr1073770842 start@var3371 .@expr29019 link (@expr29020 ) &&@expr1073770845 Token ::@expr29016 Match (@expr1073770847 start@var3371 , ")|]|>" ) ) {
11478: start@var3371 =@expr1073770848 start@var3371 .@expr29019 link (@expr29020 ) ; }
11479: start@var3371 =@expr1073770851 start@var3371 .@expr1073770852 previous (@expr1073770853 ) ;
11480: }
11481:
11482: const Token * last@var3372 ; last@var3372 =@expr1073770854 tok@var3370 .@expr28993 next (@expr28994 ) .@expr1073770857 link (@expr1073770858 ) ;
11483: if (@expr1073770859 Token ::@expr29000 simpleMatch (@expr1073770861 last@var3372 , ") {" ) ) {
11484: last@var3372 =@expr1073770862 last@var3372 .@expr1073770863 linkAt (@expr1073770864 1 ) ; }
11485: last@var3372 =@expr1073770865 last@var3372 .@expr29042 next (@expr29043 ) ;
11486: while (@expr1073770868 last@var3372 &&@expr1073770869 !@expr1073770870 Token ::@expr29016 Match (@expr1073770872 last@var3372 , "%cop%|,|;|{|}|)" ) ) {
11487: if (@expr1073770873 Token ::@expr29016 Match (@expr1073770875 last@var3372 , "(|[" ) ) {
11488: last@var3372 =@expr1073770876 last@var3372 .@expr1073770877 link (@expr1073770878 ) ; }
11489: last@var3372 =@expr1073770879 last@var3372 .@expr29042 next (@expr29043 ) ;
11490: }
11491:
11492: if (@expr1073770882 start@var3371 &&@expr1073770883 last@var3372 ) {
11493: std ::@expr1073770884 string asmcode@var3373 ;
11494: while (@expr1073770885 start@var3371 .@expr29062 next (@expr29063 ) !=@expr1073770888 last@var3372 ) {
11495: asmcode@var3373 +=@expr1073770889 start@var3371 .@expr29062 next (@expr29063 ) .@expr1073770892 str (@expr1073770893 ) ;
11496: start@var3371 .@expr1073770894 deleteNext (@expr1073770895 ) ;
11497: }
11498: if (@expr1073770896 last@var3372 .@expr1073770897 str (@expr1073770898 ) ==@expr1073770899 "}" ) {
11499: start@var3371 .@expr29076 insertToken (@expr1073770901 ";" ) ; }
11500: start@var3371 .@expr29076 insertToken (@expr1073770903 ")" ) ;
11501: start@var3371 .@expr29076 insertToken (@expr1073770905 "\"" +@expr1073770906 asmcode@var3373 +@expr1073770907 "\"" ) ;
11502: start@var3371 .@expr29076 insertToken (@expr1073770909 "(" ) ;
11503: start@var3371 .@expr29076 insertToken (@expr1073770911 "asm" ) ;
11504: start@var3371 .@expr29088 tokAt (@expr29089 2 ) .@expr1073770914 link (@expr1073770915 start@var3371 .@expr29088 tokAt (@expr29093 4 ) ) ;
11505: start@var3371 .@expr29088 tokAt (@expr29093 4 ) .@expr1073770920 link (@expr1073770921 start@var3371 .@expr29088 tokAt (@expr29089 2 ) ) ;
11506: tok@var3370 =@expr1073770924 start@var3371 .@expr29088 tokAt (@expr29093 4 ) ;
11507: }
11508: }
11509: }
11510: }
11511:
11512: void Tokenizer :: simplifyAt ( )
11513: {
11514: std ::@expr1073770927 set < std ::@expr1073770928 string > var@var3374 ;
11515:
11516: for (@expr1073770929 Token *@expr1073770930 tok@var3375 =@expr1073770931 list@var872 .@expr1073770932 front (@expr1073770933 ) ; tok@var3375 ; tok@var3375 =@expr1073770934 tok@var3375 .@expr29111 next (@expr29112 ) ) {
11517: if (@expr1073770937 Token ::@expr29114 Match (@expr1073770939 tok@var3375 , "%name%|] @ %num%|%name%|(" ) ) {
11518: const Token * end@var3376 ; end@var3376 =@expr1073770940 tok@var3375 .@expr1073770941 tokAt (@expr1073770942 2 ) ;
11519: if (@expr1073770943 end@var3376 .@expr1073770944 isNumber (@expr1073770945 ) ) {
11520: end@var3376 =@expr1073770946 end@var3376 .@expr29123 next (@expr29124 ) ; }
11521: else { if (@expr29125 end@var3376 .@expr29126 str (@expr29127 ) ==@expr29128 "(" ) {
11522: int par@var3377 ; par@var3377 =@expr1073770953 0 ;
11523: while (@expr1073770954 (@expr1073770955 end@var3376 =@expr1073770956 end@var3376 .@expr29123 next (@expr29124 ) ) !=@expr1073770959 nullptr ) {
11524: if (@expr29125 end@var3376 .@expr29126 str (@expr29127 ) ==@expr29128 "(" ) {
11525: par@var3377 ++@expr1073770964 ; }
11526: else { if (@expr1073770965 end@var3376 .@expr29126 str (@expr29127 ) ==@expr1073770968 ")" ) {
11527: if (@expr1073770969 --@expr1073770970 par@var3377 <@expr1073770971 0 ) {
11528: break ; }
11529: } }
11530: }
11531: end@var3376 =@expr1073770972 end@var3376 ?@expr1073770973 end@var3376 .@expr29123 next (@expr29124 ) :@expr1073770976 nullptr ;
11532: } else { if (@expr1073770977 var@var3374 .@expr1073770978 find (@expr1073770979 end@var3376 .@expr29126 str (@expr29127 ) ) !=@expr1073770982 var@var3374 .@expr1073770983 end (@expr1073770984 ) ) {
11533: end@var3376 =@expr1073770985 end@var3376 .@expr29123 next (@expr29124 ) ; }
11534: else {
11535: continue ; } } }
11536:
11537: if (@expr1073770988 Token ::@expr29114 Match (@expr1073770990 end@var3376 , ": %num% ;" ) ) {
11538: end@var3376 =@expr1073770991 end@var3376 .@expr1073770992 tokAt (@expr1073770993 2 ) ; }
11539:
11540: if (@expr1073770994 end@var3376 &&@expr1073770995 end@var3376 .@expr29126 str (@expr29127 ) ==@expr1073770998 ";" ) {
11541: if (@expr1073770999 tok@var3375 .@expr1073771000 isName (@expr1073771001 ) ) {
11542: var@var3374 .@expr1073771002 insert (@expr1073771003 tok@var3375 .@expr29180 str (@expr1073771005 ) ) ; }
11543: tok@var3375 .@expr1073771006 isAtAddress (@expr1073771007 true ) ;
11544: Token ::@expr1073771008 eraseTokens (@expr1073771009 tok@var3375 , end@var3376 ) ;
11545: }
11546: }
11547:
11548:
11549:
11550: if (@expr1073771010 Token ::@expr29114 Match (@expr1073771012 tok@var3375 , "@ builtin|eeprom|far|inline|interrupt|near|noprd|nostack|nosvf|packed|stack|svlreg|tiny|vector" ) ) {
11551: tok@var3375 .@expr29180 str (@expr1073771014 tok@var3375 .@expr29111 next (@expr29112 ) .@expr1073771017 str (@expr1073771018 ) +@expr1073771019 "@" ) ;
11552: tok@var3375 .@expr1073771020 deleteNext (@expr1073771021 ) ;
11553: }
11554: }
11555: }
11556:
11557:
11558: void Tokenizer :: simplifyBitfields ( )
11559: {
11560: bool goback@var3378 ; goback@var3378 =@expr1073771022 false ;
11561: for (@expr1073771023 Token *@expr1073771024 tok@var3379 =@expr1073771025 list@var872 .@expr1073771026 front (@expr1073771027 ) ; tok@var3379 ; tok@var3379 =@expr1073771028 tok@var3379 .@expr29205 next (@expr29206 ) ) {
11562: if (@expr1073771031 goback@var3378 ) {
11563: goback@var3378 =@expr1073771032 false ;
11564: tok@var3379 =@expr1073771033 tok@var3379 .@expr1073771034 previous (@expr1073771035 ) ;
11565: }
11566: Token * last@var3380 ; last@var3380 =@expr1073771036 nullptr ;
11567:
11568: if (@expr1073771037 Token ::@expr29214 simpleMatch (@expr1073771039 tok@var3379 , "for (" ) ) {
11569: tok@var3379 =@expr1073771040 tok@var3379 .@expr1073771041 linkAt (@expr1073771042 1 ) ; }
11570:
11571: if (@expr1073771043 !@expr1073771044 Token ::@expr29221 Match (@expr1073771046 tok@var3379 , ";|{|}|public:|protected:|private:" ) ) {
11572: continue ; }
11573:
11574: bool isEnum@var3381 ; isEnum@var3381 =@expr1073771047 false ;
11575: if (@expr1073771048 tok@var3379 .@expr1073771049 str (@expr1073771050 ) ==@expr1073771051 "}" ) {
11576: const Token * type@var3382 ; type@var3382 =@expr1073771052 tok@var3379 .@expr1073771053 link (@expr1073771054 ) .@expr1073771055 previous (@expr1073771056 ) ;
11577: while (@expr1073771057 type@var3382 &&@expr1073771058 type@var3382 .@expr1073771059 isName (@expr1073771060 ) ) {
11578: if (@expr1073771061 type@var3382 .@expr1073771062 str (@expr1073771063 ) ==@expr1073771064 "enum" ) {
11579: isEnum@var3381 =@expr1073771065 true ;
11580: break ;
11581: }
11582: type@var3382 =@expr1073771066 type@var3382 .@expr1073771067 previous (@expr1073771068 ) ;
11583: }
11584: }
11585:
11586: if (@expr1073771069 Token ::@expr29221 Match (@expr1073771071 tok@var3379 .@expr29205 next (@expr29206 ) , "const| %type% %name% :" ) &&@expr1073771074
11587: !@expr1073771075 Token ::@expr29221 Match (@expr1073771077 tok@var3379 .@expr29205 next (@expr29206 ) , "case|public|protected|private|class|struct" ) &&@expr1073771080
11588: !@expr1073771081 Token ::@expr29214 simpleMatch (@expr1073771083 tok@var3379 .@expr29260 tokAt (@expr29261 2 ) , "default :" ) ) {
11589: Token * tok1@var3383 ; tok1@var3383 =@expr1073771086 (@expr1073771087 tok@var3379 .@expr29205 next (@expr29206 ) .@expr29266 str (@expr29267 ) ==@expr29268 "const" ) ?@expr1073771093 tok@var3379 .@expr29260 tokAt (@expr1073771095 3 ) :@expr1073771096 tok@var3379 .@expr29260 tokAt (@expr29261 2 ) ;
11590: if (@expr1073771099 Token ::@expr29221 Match (@expr1073771101 tok1@var3383 , "%name% : %num% [;=]" ) ) {
11591: tok1@var3383 .@expr1073771102 setBits (@expr1073771103 MathLib ::@expr1073771104 toLongNumber (@expr1073771105 tok1@var3383 .@expr1073771106 strAt (@expr1073771107 2 ) ) ) ; }
11592: if (@expr1073771108 tok1@var3383 &&@expr1073771109 tok1@var3383 .@expr29286 tokAt (@expr29287 2 ) &&@expr1073771112
11593: (@expr1073771113 Token ::@expr29221 Match (@expr1073771115 tok1@var3383 .@expr29286 tokAt (@expr29287 2 ) , "%bool%|%num%" ) ||@expr1073771118
11594: !@expr1073771119 Token ::@expr29221 Match (@expr1073771121 tok1@var3383 .@expr29286 tokAt (@expr29287 2 ) , "public|protected|private| %type% ::|<|,|{|;" ) ) ) {
11595: while (@expr1073771124 tok1@var3383 .@expr29301 next (@expr29302 ) &&@expr1073771127 !@expr1073771128 Token ::@expr29221 Match (@expr1073771130 tok1@var3383 .@expr29301 next (@expr29302 ) , "[;,)]{}=]" ) ) {
11596: if (@expr1073771133 Token ::@expr29221 Match (@expr1073771135 tok1@var3383 .@expr29301 next (@expr29302 ) , "[([]" ) ) {
11597: Token ::@expr1073771138 eraseTokens (@expr1073771139 tok1@var3383 , tok1@var3383 .@expr29301 next (@expr29302 ) .@expr1073771142 link (@expr1073771143 ) ) ; }
11598: tok1@var3383 .@expr1073771144 deleteNext (@expr1073771145 ) ;
11599: }
11600:
11601: last@var3380 =@expr1073771146 tok1@var3383 .@expr29301 next (@expr29302 ) ;
11602: }
11603: } else { if (@expr1073771149 isEnum@var3381 &&@expr1073771150 Token ::@expr29221 Match (@expr1073771152 tok@var3379 , "} %name%| : %num% ;" ) ) {
11604: if (@expr1073771153 tok@var3379 .@expr29205 next (@expr29206 ) .@expr29266 str (@expr29267 ) ==@expr1073771158 ":" ) {
11605: tok@var3379 .@expr29335 deleteNext (@expr1073771160 2 ) ;
11606: tok@var3379 .@expr1073771161 insertToken (@expr1073771162 "Anonymous" ) ;
11607: } else {
11608: tok@var3379 .@expr29205 next (@expr29206 ) .@expr1073771165 deleteNext (@expr1073771166 2 ) ;
11609: }
11610: } else { if (@expr1073771167 Token ::@expr29221 Match (@expr1073771169 tok@var3379 .@expr29205 next (@expr29206 ) , "const| %type% : %num%|%bool% ;" ) &&@expr1073771172
11611: tok@var3379 .@expr29205 next (@expr29206 ) .@expr29266 str (@expr29267 ) !=@expr1073771177 "default" ) {
11612: const int offset@var3384 =@expr1073771178 (@expr1073771179 tok@var3379 .@expr29205 next (@expr29206 ) .@expr29266 str (@expr29267 ) ==@expr29268 "const" ) ?@expr1073771185 1 :@expr1073771186 0 ;
11613: if (@expr1073771187 !@expr1073771188 Token ::@expr29221 Match (@expr1073771190 tok@var3379 .@expr29260 tokAt (@expr1073771192 3 +@expr1073771193 offset@var3384 ) , "[{};()]" ) ) {
11614: tok@var3379 .@expr29335 deleteNext (@expr1073771195 4 +@expr1073771196 offset@var3384 ) ;
11615: goback@var3378 =@expr1073771197 true ;
11616: }
11617: } } }
11618:
11619: if (@expr1073771198 last@var3380 &&@expr1073771199 last@var3380 .@expr1073771200 str (@expr1073771201 ) ==@expr1073771202 "," ) {
11620: Token * tok1@var3385 ; tok1@var3385 =@expr1073771203 last@var3380 ;
11621: tok1@var3385 .@expr1073771204 str (@expr1073771205 ";" ) ;
11622:
11623: const Token * const tok2@var3386 ; tok2@var3386 =@expr1073771206 tok@var3379 .@expr29205 next (@expr29206 ) ;
11624: tok1@var3385 .@expr1073771209 insertToken (@expr1073771210 tok2@var3386 .@expr1073771211 str (@expr1073771212 ) ) ;
11625: tok1@var3385 =@expr1073771213 tok1@var3385 .@expr1073771214 next (@expr1073771215 ) ;
11626: tok1@var3385 .@expr1073771216 isSigned (@expr1073771217 tok2@var3386 .@expr1073771218 isSigned (@expr1073771219 ) ) ;
11627: tok1@var3385 .@expr1073771220 isUnsigned (@expr1073771221 tok2@var3386 .@expr1073771222 isUnsigned (@expr1073771223 ) ) ;
11628: tok1@var3385 .@expr1073771224 isLong (@expr1073771225 tok2@var3386 .@expr1073771226 isLong (@expr1073771227 ) ) ;
11629: }
11630: }
11631: }
11632:
11633:
11634:
11635: static const std :: set < std :: string > stdTypes@var3387 = {
11636: "string" , "wstring" , "u16string" , "u32string" ,
11637: "iostream" , "ostream" , "ofstream" , "ostringstream" ,
11638: "istream" , "ifstream" , "istringstream" , "fstream" , "stringstream" ,
11639: "wstringstream" , "wistringstream" , "wostringstream" , "wstringbuf" ,
11640: "stringbuf" , "streambuf" , "ios" , "filebuf" , "ios_base" ,
11641: "exception" , "bad_exception" , "bad_alloc" ,
11642: "logic_error" , "domain_error" , "invalid_argument_" , "length_error" ,
11643: "out_of_range" , "runtime_error" , "range_error" , "overflow_error" , "underflow_error" ,
11644: "locale" ,
11645: "cout" , "cerr" , "clog" , "cin" ,
11646: "wcerr" , "wcin" , "wclog" , "wcout" ,
11647: "endl" , "ends" , "flush" ,
11648: "boolalpha" , "noboolalpha" , "showbase" , "noshowbase" ,
11649: "showpoint" , "noshowpoint" , "showpos" , "noshowpos" ,
11650: "skipws" , "noskipws" , "unitbuf" , "nounitbuf" , "uppercase" , "nouppercase" ,
11651: "dec" , "hex" , "oct" ,
11652: "fixed" , "scientific" ,
11653: "internal" , "left" , "right" ,
11654: "fpos" , "streamoff" , "streampos" , "streamsize"
11655: } ;
11656:
11657: static const std :: set < std :: string > stdTemplates@var3388 = {
11658: "array" , "basic_string" , "bitset" , "deque" , "list" , "map" , "multimap" ,
11659: "priority_queue" , "queue" , "set" , "multiset" , "stack" , "vector" , "pair" ,
11660: "iterator" , "iterator_traits" ,
11661: "unordered_map" , "unordered_multimap" , "unordered_set" , "unordered_multiset" ,
11662: "tuple" , "function"
11663: } ;
11664: static const std :: set < std :: string > stdFunctions@var3389 = {
11665: "getline" ,
11666: "for_each" , "find" , "find_if" , "find_end" , "find_first_of" ,
11667: "adjacent_find" , "count" , "count_if" , "mismatch" , "equal" , "search" , "search_n" ,
11668: "copy" , "copy_backward" , "swap" , "swap_ranges" , "iter_swap" , "transform" , "replace" ,
11669: "replace_if" , "replace_copy" , "replace_copy_if" , "fill" , "fill_n" , "generate" , "generate_n" , "remove" ,
11670: "remove_if" , "remove_copy" , "remove_copy_if" ,
11671: "unique" , "unique_copy" , "reverse" , "reverse_copy" ,
11672: "rotate" , "rotate_copy" , "random_shuffle" , "partition" , "stable_partition" ,
11673: "sort" , "stable_sort" , "partial_sort" , "partial_sort_copy" , "nth_element" ,
11674: "lower_bound" , "upper_bound" , "equal_range" , "binary_search" , "merge" , "inplace_merge" , "includes" ,
11675: "set_union" , "set_intersection" , "set_difference" ,
11676: "set_symmetric_difference" , "push_heap" , "pop_heap" , "make_heap" , "sort_heap" ,
11677: "min" , "max" , "min_element" , "max_element" , "lexicographical_compare" , "next_permutation" , "prev_permutation" ,
11678: "advance" , "back_inserter" , "distance" , "front_inserter" , "inserter" ,
11679: "make_pair" , "make_shared" , "make_tuple"
11680: } ;
11681:
11682:
11683:
11684: void Tokenizer :: simplifyNamespaceStd ( )
11685: {
11686: if (@expr1073771228 !@expr1073771229 isCPP (@expr1073771230 ) ) {
11687: return ; }
11688:
11689: const bool isCPP11@var3390 =@expr1073771231 mSettings@var879 .@expr1073771232 standards@var3567 .@expr1073771233 cpp@var3568 ==@expr1073771234 Standards ::@expr1073771235 CPP11 ;
11690:
11691: std ::@expr1073771236 set < std ::@expr1073771237 string > userFunctions@var3391 ;
11692:
11693: for (@expr1073771238 const Token *@expr29415 tok@var3392 =@expr1073771240 Token ::@expr1073771241 findsimplematch (@expr1073771242 list@var872 .@expr29419 front (@expr29420 ) , "using namespace std ;" ) ; tok@var3392 ; tok@var3392 =@expr1073771245 tok@var3392 .@expr29422 next (@expr29423 ) ) {
11694: bool insert@var3393 ; insert@var3393 =@expr1073771248 false ;
11695: if (@expr1073771249 Token ::@expr29426 Match (@expr1073771251 tok@var3392 , "enum class|struct| %name%| :|{" ) ) {
11696: skipEnumBody (@expr1073771252 &@expr1073771253 tok@var3392 ) ;
11697: }
11698: if (@expr1073771254 !@expr1073771255 Token ::@expr29426 Match (@expr1073771257 tok@var3392 .@expr29434 previous (@expr29435 ) , ".|::" ) ) {
11699: if (@expr1073771260 Token ::@expr29426 Match (@expr1073771262 tok@var3392 , "%name% (" ) ) {
11700: if (@expr1073771263 isFunctionHead (@expr1073771264 tok@var3392 .@expr29422 next (@expr29423 ) , "{" ) ) {
11701: userFunctions@var3391 .@expr29443 insert (@expr29444 tok@var3392 .@expr29445 str (@expr29446 ) ) ; }
11702: else { if (@expr1073771271 isFunctionHead (@expr1073771272 tok@var3392 .@expr29422 next (@expr29423 ) , ";" ) ) {
11703: const Token * start@var3394 ; start@var3394 =@expr1073771275 tok@var3392 ;
11704: while (@expr1073771276 Token ::@expr29426 Match (@expr1073771278 start@var3394 .@expr29455 previous (@expr29456 ) , "%type%|*|&" ) ) {
11705: start@var3394 =@expr1073771281 start@var3394 .@expr29455 previous (@expr29456 ) ; }
11706: if (@expr1073771284 start@var3394 !=@expr1073771285 tok@var3392 &&@expr1073771286 start@var3394 .@expr1073771287 isName (@expr1073771288 ) &&@expr1073771289 (@expr1073771290 !@expr1073771291 start@var3394 .@expr29455 previous (@expr29456 ) ||@expr1073771294 Token ::@expr29426 Match (@expr1073771296 start@var3394 .@expr29455 previous (@expr29456 ) , "[;{}]" ) ) ) {
11707: userFunctions@var3391 .@expr29443 insert (@expr29444 tok@var3392 .@expr29445 str (@expr29446 ) ) ; }
11708: } }
11709: if (@expr1073771303 userFunctions@var3391 .@expr1073771304 find (@expr1073771305 tok@var3392 .@expr29445 str (@expr29446 ) ) ==@expr1073771308 userFunctions@var3391 .@expr1073771309 end (@expr1073771310 ) &&@expr1073771311 stdFunctions@var3389 .@expr1073771312 find (@expr1073771313 tok@var3392 .@expr29445 str (@expr29446 ) ) !=@expr1073771316 stdFunctions@var3389 .@expr1073771317 end (@expr1073771318 ) ) {
11710: insert@var3393 =@expr1073771319 true ; }
11711: } else { if (@expr1073771320 Token ::@expr29426 Match (@expr1073771322 tok@var3392 , "%name% <" ) &&@expr1073771323 stdTemplates@var3388 .@expr1073771324 find (@expr1073771325 tok@var3392 .@expr29445 str (@expr29446 ) ) !=@expr1073771328 stdTemplates@var3388 .@expr1073771329 end (@expr1073771330 ) ) {
11712: insert@var3393 =@expr1073771331 true ; }
11713: else { if (@expr1073771332 tok@var3392 .@expr1073771333 isName (@expr1073771334 ) &&@expr1073771335 !@expr1073771336 tok@var3392 .@expr1073771337 varId (@expr1073771338 ) &&@expr1073771339 !@expr1073771340 Token ::@expr29426 Match (@expr1073771342 tok@var3392 .@expr29422 next (@expr29423 ) , "(|<" ) &&@expr1073771345 stdTypes@var3387 .@expr1073771346 find (@expr1073771347 tok@var3392 .@expr29445 str (@expr29446 ) ) !=@expr1073771350 stdTypes@var3387 .@expr1073771351 end (@expr1073771352 ) ) {
11714: insert@var3393 =@expr1073771353 true ; } } }
11715: }
11716:
11717: if (@expr1073771354 insert@var3393 ) {
11718: tok@var3392 .@expr29434 previous (@expr29435 ) .@expr29533 insertToken (@expr1073771358 "std" ) ;
11719: tok@var3392 .@expr29434 previous (@expr29435 ) .@expr1073771361 linenr (@expr1073771362 tok@var3392 .@expr1073771363 linenr (@expr1073771364 ) ) ;
11720: tok@var3392 .@expr29434 previous (@expr29435 ) .@expr1073771367 fileIndex (@expr1073771368 tok@var3392 .@expr1073771369 fileIndex (@expr1073771370 ) ) ;
11721: tok@var3392 .@expr29434 previous (@expr29435 ) .@expr29533 insertToken (@expr1073771374 "::" ) ;
11722: } else { if (@expr1073771375 isCPP11@var3390 &&@expr1073771376 Token ::@expr29426 Match (@expr1073771378 tok@var3392 , "!!:: tr1 ::" ) ) {
11723: tok@var3392 .@expr29422 next (@expr29423 ) .@expr1073771381 str (@expr1073771382 "std" ) ; } }
11724: }
11725:
11726: for (@expr1073771383 Token *@expr29415 tok@var3395 =@expr1073771385 list@var872 .@expr29419 front (@expr29420 ) ; tok@var3395 ; tok@var3395 =@expr1073771388 tok@var3395 .@expr1073771389 next (@expr1073771390 ) ) {
11727: if (@expr1073771391 isCPP11@var3390 &&@expr1073771392 Token ::@expr29569 simpleMatch (@expr1073771394 tok@var3395 , "std :: tr1 ::" ) ) {
11728: Token ::@expr29571 eraseTokens (@expr1073771396 tok@var3395 , tok@var3395 .@expr29573 tokAt (@expr1073771398 3 ) ) ; }
11729:
11730: else { if (@expr1073771399 Token ::@expr29569 simpleMatch (@expr1073771401 tok@var3395 , "using namespace std ;" ) ) {
11731: Token ::@expr29571 eraseTokens (@expr1073771403 tok@var3395 , tok@var3395 .@expr29573 tokAt (@expr1073771405 4 ) ) ;
11732: tok@var3395 .@expr1073771406 deleteThis (@expr1073771407 ) ;
11733: } }
11734: }
11735: }
11736:
11737:
11738: void Tokenizer :: simplifyMicrosoftMemoryFunctions ( )
11739: {
11740:
11741: if (@expr1073771408 !@expr1073771409 mSettings@var879 .@expr1073771410 isWindowsPlatform (@expr1073771411 ) ) {
11742: return ; }
11743:
11744: for (@expr1073771412 Token *@expr1073771413 tok@var3396 =@expr1073771414 list@var872 .@expr1073771415 front (@expr1073771416 ) ; tok@var3396 ; tok@var3396 =@expr1073771417 tok@var3396 .@expr29594 next (@expr29595 ) ) {
11745: if (@expr1073771420 tok@var3396 .@expr1073771421 strAt (@expr1073771422 1 ) !=@expr1073771423 "(" ) {
11746: continue ; }
11747:
11748: if (@expr1073771424 Token ::@expr29601 Match (@expr1073771426 tok@var3396 , "CopyMemory|RtlCopyMemory|RtlCopyBytes" ) ) {
11749: tok@var3396 .@expr29603 str (@expr1073771428 "memcpy" ) ;
11750: } else { if (@expr1073771429 Token ::@expr29601 Match (@expr1073771431 tok@var3396 , "MoveMemory|RtlMoveMemory" ) ) {
11751: tok@var3396 .@expr29603 str (@expr1073771433 "memmove" ) ;
11752: } else { if (@expr1073771434 Token ::@expr29601 Match (@expr1073771436 tok@var3396 , "FillMemory|RtlFillMemory|RtlFillBytes" ) ) {
11753:
11754: tok@var3396 .@expr29603 str (@expr29614 "memset" ) ;
11755:
11756: Token * tok1@var3397 ; tok1@var3397 =@expr1073771439 tok@var3396 .@expr29616 tokAt (@expr29617 2 ) ;
11757: if (@expr29618 tok1@var3397 ) {
11758: tok1@var3397 =@expr1073771443 tok1@var3397 .@expr29620 nextArgument (@expr29621 ) ; }
11759: if (@expr29618 tok1@var3397 ) {
11760: Token * tok2@var3398 ; tok2@var3398 =@expr1073771447 tok1@var3397 .@expr29620 nextArgument (@expr29621 ) ;
11761:
11762: if (@expr1073771450 tok2@var3398 ) {
11763: Token ::@expr1073771451 move (@expr1073771452 tok1@var3397 .@expr1073771453 previous (@expr1073771454 ) , tok2@var3398 .@expr1073771455 tokAt (@expr1073771456 -2 ) , tok@var3396 .@expr29594 next (@expr29595 ) .@expr1073771459 link (@expr1073771460 ) .@expr1073771461 previous (@expr1073771462 ) ) ; }
11764: }
11765: } else { if (@expr1073771463 Token ::@expr29601 Match (@expr1073771465 tok@var3396 , "ZeroMemory|RtlZeroMemory|RtlZeroBytes|RtlSecureZeroMemory" ) ) {
11766:
11767: tok@var3396 .@expr29603 str (@expr29614 "memset" ) ;
11768:
11769: Token * tok1@var3399 ; tok1@var3399 =@expr1073771468 tok@var3396 .@expr29616 tokAt (@expr29617 2 ) ;
11770: if (@expr29647 tok1@var3399 ) {
11771: tok1@var3399 =@expr1073771472 tok1@var3399 .@expr1073771473 nextArgument (@expr1073771474 ) ; }
11772:
11773: if (@expr29647 tok1@var3399 ) {
11774: tok1@var3399 =@expr1073771476 tok1@var3399 .@expr1073771477 previous (@expr1073771478 ) ;
11775: tok1@var3399 .@expr29655 insertToken (@expr1073771480 "0" ) ;
11776: tok1@var3399 =@expr1073771481 tok1@var3399 .@expr1073771482 next (@expr1073771483 ) ;
11777: tok1@var3399 .@expr29655 insertToken (@expr1073771485 "," ) ;
11778: }
11779: } else { if (@expr1073771486 Token ::@expr1073771487 simpleMatch (@expr1073771488 tok@var3396 , "RtlCompareMemory" ) ) {
11780:
11781: tok@var3396 .@expr29603 str (@expr1073771490 "memcmp" ) ;
11782:
|
11786:
11787: } } } } }
11788: }
11789: }
11790:
11791: namespace {
11792: struct triplet {
11793: triplet ( const char * m@var3400 , const char * u@var3401 ) : mbcs@var3402 ( m@var3400 ) , unicode@var3403 ( u@var3401 ) { }
11794: std :: string mbcs@var3402 ; std :: string unicode@var3403 ;
11795: } ;
11796:
11797: const std :: map < std :: string , triplet > apis@var3404 = {
11798: std :: make_pair ( "_topen" , triplet ( "open" , "_wopen" ) ) ,
11799: std :: make_pair ( "_tsopen_s" , triplet ( "_sopen_s" , "_wsopen_s" ) ) ,
11800: std :: make_pair ( "_tfopen" , triplet ( "fopen" , "_wfopen" ) ) ,
11801: std :: make_pair ( "_tfopen_s" , triplet ( "fopen_s" , "_wfopen_s" ) ) ,
11802: std :: make_pair ( "_tfreopen" , triplet ( "freopen" , "_wfreopen" ) ) ,
11803: std :: make_pair ( "_tfreopen_s" , triplet ( "freopen_s" , "_wfreopen_s" ) ) ,
11804: std :: make_pair ( "_tcscat" , triplet ( "strcat" , "wcscat" ) ) ,
11805: std :: make_pair ( "_tcschr" , triplet ( "strchr" , "wcschr" ) ) ,
11806: std :: make_pair ( "_tcscmp" , triplet ( "strcmp" , "wcscmp" ) ) ,
11807: std :: make_pair ( "_tcsdup" , triplet ( "strdup" , "wcsdup" ) ) ,
11808: std :: make_pair ( "_tcscpy" , triplet ( "strcpy" , "wcscpy" ) ) ,
11809: std :: make_pair ( "_tcslen" , triplet ( "strlen" , "wcslen" ) ) ,
11810: std :: make_pair ( "_tcsncat" , triplet ( "strncat" , "wcsncat" ) ) ,
11811: std :: make_pair ( "_tcsncpy" , triplet ( "strncpy" , "wcsncpy" ) ) ,
11812: std :: make_pair ( "_tcsnlen" , triplet ( "strnlen" , "wcsnlen" ) ) ,
11813: std :: make_pair ( "_tcsrchr" , triplet ( "strrchr" , "wcsrchr" ) ) ,
11814: std :: make_pair ( "_tcsstr" , triplet ( "strstr" , "wcsstr" ) ) ,
11815: std :: make_pair ( "_tcstok" , triplet ( "strtok" , "wcstok" ) ) ,
11816: std :: make_pair ( "_ftprintf" , triplet ( "fprintf" , "fwprintf" ) ) ,
11817: std :: make_pair ( "_tprintf" , triplet ( "printf" , "wprintf" ) ) ,
11818: std :: make_pair ( "_stprintf" , triplet ( "sprintf" , "swprintf" ) ) ,
11819: std :: make_pair ( "_sntprintf" , triplet ( "_snprintf" , "_snwprintf" ) ) ,
11820: std :: make_pair ( "_ftscanf" , triplet ( "fscanf" , "fwscanf" ) ) ,
11821: std :: make_pair ( "_tscanf" , triplet ( "scanf" , "wscanf" ) ) ,
11822: std :: make_pair ( "_stscanf" , triplet ( "sscanf" , "swscanf" ) ) ,
11823: std :: make_pair ( "_ftprintf_s" , triplet ( "fprintf_s" , "fwprintf_s" ) ) ,
11824: std :: make_pair ( "_tprintf_s" , triplet ( "printf_s" , "wprintf_s" ) ) ,
11825: std :: make_pair ( "_stprintf_s" , triplet ( "sprintf_s" , "swprintf_s" ) ) ,
11826: std :: make_pair ( "_sntprintf_s" , triplet ( "_snprintf_s" , "_snwprintf_s" ) ) ,
11827: std :: make_pair ( "_ftscanf_s" , triplet ( "fscanf_s" , "fwscanf_s" ) ) ,
11828: std :: make_pair ( "_tscanf_s" , triplet ( "scanf_s" , "wscanf_s" ) ) ,
11829: std :: make_pair ( "_stscanf_s" , triplet ( "sscanf_s" , "swscanf_s" ) )
11830: } ;
11831: }
11832:
11833: void Tokenizer :: simplifyMicrosoftStringFunctions ( )
11834: {
11835:
11836: if (@expr1073771492 !@expr1073771493 mSettings@var879 .@expr1073771494 isWindowsPlatform (@expr1073771495 ) ) {
11837: return ; }
11838:
11839: const bool ansi@var3405 =@expr1073771496 mSettings@var879 .@expr1073771497 platformType@var3593 ==@expr1073771498 Settings ::@expr1073771499 Win32A@expr1073771491 ;
11840: for (@expr1073771500 Token *@expr1073771501 tok@var3406 =@expr1073771502 list@var872 .@expr1073771503 front (@expr1073771504 ) ; tok@var3406 ; tok@var3406 =@expr1073771505 tok@var3406 .@expr29682 next (@expr29683 ) ) {
11841: if (@expr1073771508 tok@var3406 .@expr1073771509 strAt (@expr1073771510 1 ) !=@expr1073771511 "(" ) {
11842: continue ; }
11843:
11844: const std ::@expr1073771512 map < std ::@expr1073771513 string , triplet > ::@expr1073771514 const_iterator match@var3407 =@expr1073771515 apis@var3404 .@expr1073771516 find (@expr1073771517 tok@var3406 .@expr29694 str (@expr29695 ) ) ;
11845: if (@expr1073771520 match@var3407 !=@expr1073771521 apis@var3404 .@expr1073771522 end (@expr1073771523 ) ) {
11846: tok@var3406 .@expr29694 str (@expr1073771525 ansi@var3405 ?@expr1073771526 match@var3407 .@expr29703 second@var3408 .@expr1073771528 mbcs@var3409 :@expr1073771529 match@var3407 .@expr29703 second@var3408 .@expr1073771531 unicode@var3410 ) ;
11847: tok@var3406 .@expr1073771532 originalName (@expr1073771533 match@var3407 .@expr1073771534 first@var3411 ) ;
11848: } else { if (@expr1073771535 Token ::@expr29712 Match (@expr1073771537 tok@var3406 , "_T|_TEXT|TEXT ( %char%|%str% )" ) ) {
11849: tok@var3406 .@expr29714 deleteNext (@expr29715 ) ;
11850: tok@var3406 .@expr1073771540 deleteThis (@expr1073771541 ) ;
11851: tok@var3406 .@expr29714 deleteNext (@expr29715 ) ;
11852: if (@expr1073771544 !@expr1073771545 ansi@var3405 ) {
11853: tok@var3406 .@expr1073771546 isLong (@expr1073771547 true ) ;
11854: if (@expr1073771548 tok@var3406 .@expr29694 str (@expr29695 ) [@expr1073771551 0 ] !=@expr1073771552 'L' ) {
11855: tok@var3406 .@expr29694 str (@expr1073771554 "L" +@expr1073771555 tok@var3406 .@expr29694 str (@expr29695 ) ) ; }
11856: }
11857: while (@expr1073771558 Token ::@expr29712 Match (@expr1073771560 tok@var3406 .@expr29682 next (@expr29683 ) , "_T|_TEXT|TEXT ( %char%|%str% )" ) ) {
11858: tok@var3406 .@expr29682 next (@expr29683 ) .@expr29741 deleteNext (@expr29742 ) ;
11859: tok@var3406 .@expr29682 next (@expr29683 ) .@expr1073771569 deleteThis (@expr1073771570 ) ;
11860: tok@var3406 .@expr29682 next (@expr29683 ) .@expr29741 deleteNext (@expr29742 ) ;
11861: tok@var3406 .@expr1073771575 concatStr (@expr1073771576 tok@var3406 .@expr29682 next (@expr29683 ) .@expr1073771579 str (@expr1073771580 ) ) ;
11862: tok@var3406 .@expr29714 deleteNext (@expr29715 ) ;
11863: }
11864: } }
11865: }
11866: }
11867:
11868:
11869: void Tokenizer :: simplifyBorland ( )
11870: {
11871:
11872: if (@expr1073771583 !@expr1073771584 mSettings@var879 .@expr1073771585 isWindowsPlatform (@expr1073771586 ) ) {
11873: return ; }
11874: if (@expr1073771587 isC (@expr1073771588 ) ) {
11875: return ; }
11876: for (@expr1073771589 Token *@expr29766 tok@var3412 =@expr1073771591 list@var872 .@expr29768 front (@expr29769 ) ; tok@var3412 ; tok@var3412 =@expr1073771594 tok@var3412 .@expr1073771595 next (@expr1073771596 ) ) {
11877: if (@expr1073771597 Token ::@expr29774 Match (@expr1073771599 tok@var3412 , "( __closure * %name% )" ) ) {
11878: tok@var3412 .@expr1073771600 deleteNext (@expr1073771601 ) ;
11879: }
11880: }
11881:
11882:
11883:
11884: for (@expr1073771602 Token *@expr29766 tok@var3413 =@expr1073771604 list@var872 .@expr29768 front (@expr29769 ) ; tok@var3413 ; tok@var3413 =@expr1073771607 tok@var3413 .@expr29784 next (@expr29785 ) ) {
11885: if (@expr1073771610 tok@var3413 .@expr29787 str (@expr29788 ) ==@expr1073771613 "{" &&@expr1073771614 !@expr1073771615 Token ::@expr29774 Match (@expr1073771617 tok@var3413 .@expr1073771618 tokAt (@expr1073771619 -2 ) , "namespace %type%" ) ) {
11886: tok@var3413 =@expr1073771620 tok@var3413 .@expr29797 link (@expr29798 ) ;
11887: if (@expr29799 !@expr29800 tok@var3413 ) {
11888: break ; }
11889: } else { if (@expr1073771625 Token ::@expr29774 Match (@expr1073771627 tok@var3413 , "class %name% :|{" ) ) {
11890: while (@expr1073771628 tok@var3413 &&@expr1073771629 tok@var3413 .@expr29787 str (@expr29788 ) !=@expr1073771632 "{" &&@expr1073771633 tok@var3413 .@expr29787 str (@expr29788 ) !=@expr1073771636 ";" ) {
11891: tok@var3413 =@expr1073771637 tok@var3413 .@expr29784 next (@expr29785 ) ; }
11892: if (@expr29799 !@expr29800 tok@var3413 ) {
11893: break ; }
11894: if (@expr1073771642 tok@var3413 .@expr29787 str (@expr29788 ) ==@expr1073771645 ";" ) {
11895: continue ; }
11896:
11897: const Token * end@var3414 ; end@var3414 =@expr1073771646 tok@var3413 .@expr29797 link (@expr29798 ) .@expr1073771649 next (@expr1073771650 ) ;
11898: for (@expr1073771651 Token *@expr29766 tok2@var3415 =@expr1073771653 tok@var3413 .@expr29784 next (@expr29785 ) ; tok2@var3415 !=@expr1073771656 end@var3414 ; tok2@var3415 =@expr1073771657 tok2@var3415 .@expr29834 next (@expr29835 ) ) {
11899: if (@expr1073771660 tok2@var3415 .@expr29837 str (@expr29838 ) ==@expr1073771663 "__property" &&@expr1073771664
11900: Token ::@expr29774 Match (@expr1073771666 tok2@var3415 .@expr29843 previous (@expr29844 ) , ";|{|}|protected:|public:|__published:" ) ) {
11901: while (@expr1073771669 tok2@var3415 .@expr29834 next (@expr29835 ) &&@expr1073771672 !@expr1073771673 Token ::@expr29774 Match (@expr1073771675 tok2@var3415 .@expr29834 next (@expr29835 ) , "{|;" ) ) {
11902: tok2@var3415 .@expr29854 deleteNext (@expr29855 ) ; }
11903: tok2@var3415 .@expr29856 deleteThis (@expr29857 ) ;
11904: if (@expr1073771682 tok2@var3415 .@expr29837 str (@expr29838 ) ==@expr1073771685 "{" ) {
11905: Token ::@expr1073771686 eraseTokens (@expr1073771687 tok2@var3415 , tok2@var3415 .@expr1073771688 link (@expr1073771689 ) ) ;
11906: tok2@var3415 .@expr29854 deleteNext (@expr29855 ) ;
11907: tok2@var3415 .@expr29856 deleteThis (@expr29857 ) ;
11908:
11909:
11910: tok2@var3415 .@expr29843 previous (@expr29844 ) .@expr29872 insertToken (@expr29873 ";" ) ;
11911: tok2@var3415 .@expr29843 previous (@expr29844 ) .@expr29872 insertToken (@expr1073771701 "__property" ) ;
11912: tok2@var3415 .@expr29843 previous (@expr29844 ) .@expr29872 insertToken (@expr29873 ";" ) ;
11913: }
11914: }
11915: }
11916: } }
11917: }
11918: }
11919:
11920:
11921: void Tokenizer :: simplifyQtSignalsSlots ( )
11922: {
11923: if (@expr1073771706 isC (@expr1073771707 ) ) {
11924: return ; }
11925: for (@expr1073771708 Token *@expr29885 tok@var3416 =@expr1073771710 list@var872 .@expr1073771711 front (@expr1073771712 ) ; tok@var3416 ; tok@var3416 =@expr1073771713 tok@var3416 .@expr1073771714 next (@expr1073771715 ) ) {
11926:
11927: if (@expr1073771716 Token ::@expr29893 Match (@expr1073771718 tok@var3416 , "emit|Q_EMIT %name% (" ) &&@expr1073771719
11928: Token ::@expr29896 simpleMatch (@expr1073771721 tok@var3416 .@expr1073771722 linkAt (@expr1073771723 2 ) , ") ;" ) ) {
11929: tok@var3416 .@expr1073771724 deleteThis (@expr1073771725 ) ;
11930: } else { if (@expr1073771726 !@expr1073771727 Token ::@expr29893 Match (@expr1073771729 tok@var3416 , "class %name% :|::|{" ) ) {
11931: continue ; } }
11932:
11933: if (@expr1073771730 tok@var3416 .@expr29907 previous (@expr29908 ) &&@expr1073771733 tok@var3416 .@expr29907 previous (@expr29908 ) .@expr1073771736 str (@expr1073771737 ) ==@expr1073771738 "enum" ) {
11934: tok@var3416 =@expr1073771739 tok@var3416 .@expr1073771740 tokAt (@expr1073771741 2 ) ;
11935: continue ;
11936: }
11937:
11938:
11939: int indentlevel@var3417 ; indentlevel@var3417 =@expr1073771742 0 ;
11940: for (@expr1073771743 Token *@expr29885 tok2@var3418 =@expr1073771745 tok@var3416 ; tok2@var3418 ; tok2@var3418 =@expr1073771746 tok2@var3418 .@expr29923 next (@expr29924 ) ) {
11941: if (@expr1073771749 tok2@var3418 .@expr29926 str (@expr29927 ) ==@expr1073771752 "{" ) {
11942: ++@expr1073771753 indentlevel@var3417 ;
11943: if (@expr1073771754 indentlevel@var3417 ==@expr1073771755 1 ) {
11944: tok@var3416 =@expr1073771756 tok2@var3418 ; }
11945: else {
11946: tok2@var3418 =@expr1073771757 tok2@var3418 .@expr1073771758 link (@expr1073771759 ) ; }
11947: } else { if (@expr1073771760 tok2@var3418 .@expr29926 str (@expr29927 ) ==@expr1073771763 "}" ) {
11948: if (@expr1073771764 indentlevel@var3417 <@expr1073771765 2 ) {
11949: break ; }
11950: else {
11951: --@expr1073771766 indentlevel@var3417 ; }
11952: } else { if (@expr1073771767 tok2@var3418 .@expr29926 str (@expr29927 ) ==@expr1073771770 ";" &&@expr1073771771 indentlevel@var3417 ==@expr1073771772 0 ) {
11953: break ; } } }
11954:
11955: if (@expr1073771773 tok2@var3418 .@expr1073771774 strAt (@expr1073771775 1 ) ==@expr1073771776 "Q_OBJECT" ) {
11956: tok2@var3418 .@expr29953 deleteNext (@expr29954 ) ; }
11957:
11958: if (@expr1073771779 Token ::@expr29893 Match (@expr1073771781 tok2@var3418 .@expr29923 next (@expr29924 ) , "public|protected|private slots|Q_SLOTS :" ) ) {
11959: tok2@var3418 =@expr1073771784 tok2@var3418 .@expr29923 next (@expr29924 ) ;
11960: tok2@var3418 .@expr29926 str (@expr1073771788 tok2@var3418 .@expr29926 str (@expr29927 ) +@expr1073771791 ":" ) ;
11961: tok2@var3418 .@expr29953 deleteNext (@expr1073771793 2 ) ;
11962: tok2@var3418 =@expr1073771794 tok2@var3418 .@expr1073771795 previous (@expr1073771796 ) ;
11963: } else { if (@expr1073771797 Token ::@expr29893 Match (@expr1073771799 tok2@var3418 .@expr29923 next (@expr29924 ) , "signals|Q_SIGNALS :" ) ) {
11964: tok2@var3418 =@expr1073771802 tok2@var3418 .@expr29923 next (@expr29924 ) ;
11965: tok2@var3418 .@expr29926 str (@expr1073771806 "protected:" ) ;
11966: tok2@var3418 .@expr29953 deleteNext (@expr29954 ) ;
11967: } else { if (@expr1073771809 Token ::@expr29893 Match (@expr1073771811 tok2@var3418 .@expr29923 next (@expr29924 ) , "emit|Q_EMIT %name% (" ) &&@expr1073771814
11968: Token ::@expr29896 simpleMatch (@expr1073771816 tok2@var3418 .@expr1073771817 linkAt (@expr1073771818 3 ) , ") ;" ) ) {
11969: tok2@var3418 .@expr29953 deleteNext (@expr29954 ) ;
11970: } } }
11971: }
11972: }
11973: }
11974:
11975: void Tokenizer :: createSymbolDatabase ( )
11976: {
11977: if (@expr1073771821 !@expr1073771822 mSymbolDatabase@var881 ) {
11978: mSymbolDatabase@var881 =@expr1073771823 new SymbolDatabase (@expr1073771824 this@expr1073771825 , mSettings@var879 , mErrorLogger@var880 ) ; }
11979: mSymbolDatabase@var881 .@expr1073771826 validate (@expr1073771827 ) ;
11980: }
11981:
11982: void Tokenizer :: deleteSymbolDatabase ( )
11983: {
11984: delete mSymbolDatabase@var881 ;
11985: mSymbolDatabase@var881 =@expr1073771828 nullptr ;
11986: }
11987:
11988: bool Tokenizer :: operatorEnd ( const Token * tok@var3419 ) const
11989: {
11990: if (@expr1073771829 tok@var3419 &&@expr1073771830 tok@var3419 .@expr30007 str (@expr30008 ) ==@expr1073771833 ")" ) {
11991: if (@expr1073771834 isFunctionHead (@expr1073771835 tok@var3419 , "{|;|?|:|[" ) ) {
11992: return true ; }
11993:
11994: tok@var3419 =@expr1073771836 tok@var3419 .@expr30013 next (@expr30014 ) ;
11995: while (@expr1073771839 tok@var3419 &&@expr1073771840 !@expr1073771841 Token ::@expr30018 Match (@expr1073771843 tok@var3419 , "[=;{),]" ) ) {
11996: if (@expr1073771844 Token ::@expr30018 Match (@expr1073771846 tok@var3419 , "const|volatile|override" ) ) {
11997: tok@var3419 =@expr1073771847 tok@var3419 .@expr30013 next (@expr30014 ) ;
11998: } else { if (@expr1073771850 tok@var3419 .@expr30007 str (@expr30008 ) ==@expr1073771853 "noexcept" ) {
11999: tok@var3419 =@expr1073771854 tok@var3419 .@expr30013 next (@expr30014 ) ;
12000: if (@expr30033 tok@var3419 &&@expr30034 tok@var3419 .@expr30007 str (@expr30008 ) ==@expr30037 "(" ) {
12001: tok@var3419 =@expr1073771862 tok@var3419 .@expr30039 link (@expr30040 ) .@expr30041 next (@expr30042 ) ;
12002: }
12003: } else { if (@expr1073771867 tok@var3419 .@expr30007 str (@expr30008 ) ==@expr1073771870 "throw" &&@expr1073771871 tok@var3419 .@expr30013 next (@expr30014 ) &&@expr1073771874 tok@var3419 .@expr30013 next (@expr30014 ) .@expr1073771877 str (@expr1073771878 ) ==@expr1073771879 "(" ) {
12004: tok@var3419 =@expr1073771880 tok@var3419 .@expr30013 next (@expr30014 ) .@expr1073771883 link (@expr1073771884 ) .@expr1073771885 next (@expr1073771886 ) ;
12005: }
12006:
12007: else { if (@expr1073771887 tok@var3419 .@expr1073771888 isUpperCaseName (@expr1073771889 ) ) {
12008: tok@var3419 =@expr1073771890 tok@var3419 .@expr30013 next (@expr30014 ) ;
12009: if (@expr30033 tok@var3419 &&@expr30034 tok@var3419 .@expr30007 str (@expr30008 ) ==@expr30037 "(" ) {
12010: tok@var3419 =@expr1073771898 tok@var3419 .@expr30039 link (@expr30040 ) .@expr30041 next (@expr30042 ) ;
12011: }
12012: } else { if (@expr1073771903 Token ::@expr30018 Match (@expr1073771905 tok@var3419 , "%op% !!(" ) ||@expr1073771906
12013: (@expr1073771907 Token ::@expr30018 Match (@expr1073771909 tok@var3419 , "%op% (" ) &&@expr1073771910 !@expr1073771911 isFunctionHead (@expr1073771912 tok@var3419 .@expr30013 next (@expr30014 ) , "{" ) ) ) {
12014: break ; }
12015: else {
12016: return false ; } } } } }
12017: }
12018:
12019: return true ;
12020: }
12021:
12022: return false ;
12023: }
12024:
12025: void Tokenizer :: simplifyOperatorName ( )
12026: {
12027: if (@expr1073771915 isC (@expr1073771916 ) ) {
12028: return ; }
12029:
12030: for (@expr1073771917 Token *@expr30094 tok@var3420 =@expr1073771919 list@var872 .@expr30096 front (@expr30097 ) ; tok@var3420 ; tok@var3420 =@expr1073771922 tok@var3420 .@expr30099 next (@expr30100 ) ) {
12031: if (@expr1073771925 Token ::@expr30102 Match (@expr1073771927 tok@var3420 , "using|:: operator %op%|%name% ;" ) ) {
12032: tok@var3420 .@expr30099 next (@expr30100 ) .@expr30106 str (@expr1073771931 "operator" +@expr1073771932 tok@var3420 .@expr1073771933 strAt (@expr1073771934 2 ) ) ;
12033: tok@var3420 .@expr30099 next (@expr30100 ) .@expr1073771937 deleteNext (@expr1073771938 ) ;
12034: continue ;
12035: }
12036:
12037: if (@expr1073771939 tok@var3420 .@expr30116 str (@expr30117 ) !=@expr1073771942 "operator" ) {
12038: continue ; }
12039:
12040: if (@expr1073771943 Token ::@expr30102 Match (@expr1073771945 tok@var3420 , "operator %op% (" ) &&@expr1073771946 !@expr1073771947 operatorEnd (@expr1073771948 tok@var3420 .@expr1073771949 linkAt (@expr1073771950 2 ) ) ) {
12041: tok@var3420 .@expr30116 str (@expr1073771952 tok@var3420 .@expr30116 str (@expr30117 ) +@expr1073771955 tok@var3420 .@expr30099 next (@expr30100 ) .@expr30106 str (@expr1073771959 ) ) ;
12042: tok@var3420 .@expr1073771960 deleteNext (@expr1073771961 ) ;
12043: continue ;
12044: }
12045: std ::@expr1073771962 string op@var3421 ;
12046: Token * par@var3422 ; par@var3422 =@expr1073771963 tok@var3420 .@expr30099 next (@expr30100 ) ;
12047: bool done@var3423 ; done@var3423 =@expr1073771966 false ;
12048: while (@expr1073771967 !@expr1073771968 done@var3423 &&@expr1073771969 par@var3422 ) {
12049: done@var3423 =@expr1073771970 true ;
12050: if (@expr1073771971 par@var3422 .@expr1073771972 isName (@expr1073771973 ) ) {
12051: op@var3421 +=@expr1073771974 par@var3422 .@expr30151 str (@expr30152 ) ;
12052: par@var3422 =@expr1073771977 par@var3422 .@expr30154 next (@expr30155 ) ;
12053:
12054: if (@expr1073771980 Token ::@expr30102 Match (@expr1073771982 par@var3422 , ":: %name%|%op%|." ) ) {
12055: op@var3421 +=@expr1073771983 par@var3422 .@expr30151 str (@expr30152 ) ;
12056: par@var3422 =@expr1073771986 par@var3422 .@expr30154 next (@expr30155 ) ;
12057: }
12058: done@var3423 =@expr1073771989 false ;
12059: } else { if (@expr1073771990 Token ::@expr30102 Match (@expr1073771992 par@var3422 , ".|%op%|," ) ) {
12060:
12061: if (@expr1073771993 par@var3422 .@expr30151 str (@expr30152 ) ==@expr1073771996 "," &&@expr1073771997 !@expr30174 op@var3421 .@expr30175 empty (@expr30176 ) ) {
12062: break ; }
12063: if (@expr1073772001 !@expr1073772002 (@expr1073772003 Token ::@expr30102 Match (@expr1073772005 par@var3422 , "<|>" ) &&@expr1073772006 !@expr30174 op@var3421 .@expr30175 empty (@expr30176 ) ) ) {
12064: op@var3421 +=@expr1073772010 par@var3422 .@expr30151 str (@expr30152 ) ;
12065: par@var3422 =@expr1073772013 par@var3422 .@expr30154 next (@expr30155 ) ;
12066: done@var3423 =@expr1073772016 false ;
12067: }
12068: } else { if (@expr1073772017 Token ::@expr30194 simpleMatch (@expr1073772019 par@var3422 , "[ ]" ) ) {
12069: op@var3421 +=@expr1073772020 "[]" ;
12070: par@var3422 =@expr1073772021 par@var3422 .@expr30198 tokAt (@expr30199 2 ) ;
12071: done@var3423 =@expr1073772024 false ;
12072: } else { if (@expr1073772025 Token ::@expr30102 Match (@expr1073772027 par@var3422 , "( *| )" ) ) {
12073:
12074: if (@expr1073772028 operatorEnd (@expr1073772029 par@var3422 .@expr30154 next (@expr30155 ) ) ) {
12075: break ; }
12076:
12077: while (@expr1073772032 par@var3422 .@expr30151 str (@expr30152 ) !=@expr1073772035 ")" ) {
12078: op@var3421 +=@expr1073772036 par@var3422 .@expr30151 str (@expr30152 ) ;
12079: par@var3422 =@expr1073772039 par@var3422 .@expr30154 next (@expr30155 ) ;
12080: }
12081: op@var3421 +=@expr1073772042 ")" ;
12082: par@var3422 =@expr1073772043 par@var3422 .@expr30154 next (@expr30155 ) ;
12083: if (@expr1073772046 Token ::@expr30194 simpleMatch (@expr1073772048 par@var3422 , "..." ) ) {
12084: op@var3421 .@expr1073772049 clear (@expr1073772050 ) ;
12085: par@var3422 =@expr1073772051 nullptr ;
12086: break ;
12087: }
12088: done@var3423 =@expr1073772052 false ;
12089: } else { if (@expr1073772053 Token ::@expr30102 Match (@expr1073772055 par@var3422 , "\"\" %name% (|;|<" ) ) {
12090: op@var3421 +=@expr1073772056 "\"\"" ;
12091: op@var3421 +=@expr1073772057 par@var3422 .@expr1073772058 strAt (@expr1073772059 1 ) ;
12092: par@var3422 =@expr1073772060 par@var3422 .@expr30198 tokAt (@expr30199 2 ) ;
12093: done@var3423 =@expr1073772063 true ;
12094: } else { if (@expr1073772064 par@var3422 .@expr30151 str (@expr30152 ) ==@expr1073772067 "::" ) {
12095: op@var3421 +=@expr1073772068 par@var3422 .@expr30151 str (@expr30152 ) ;
12096: par@var3422 =@expr1073772071 par@var3422 .@expr30154 next (@expr30155 ) ;
12097: done@var3423 =@expr1073772074 false ;
12098: } else { if (@expr1073772075 par@var3422 .@expr30151 str (@expr30152 ) ==@expr1073772078 ";" ||@expr1073772079 par@var3422 .@expr30151 str (@expr30152 ) ==@expr1073772082 ")" ) {
12099: done@var3423 =@expr1073772083 true ;
12100: } else { if (@expr1073772084 par@var3422 .@expr30151 str (@expr30152 ) !=@expr1073772087 "(" ) {
12101: syntaxError (@expr1073772088 par@var3422 , "operator" ) ;
12102: } } } } } } } }
12103: }
12104:
12105: if (@expr1073772089 par@var3422 &&@expr1073772090 !@expr30174 op@var3421 .@expr30175 empty (@expr30176 ) ) {
12106: tok@var3420 .@expr30116 str (@expr1073772095 "operator" +@expr1073772096 op@var3421 ) ;
12107: Token ::@expr1073772097 eraseTokens (@expr1073772098 tok@var3420 , par@var3422 ) ;
12108: }
12109:
12110: if (@expr1073772099 !@expr30174 op@var3421 .@expr30175 empty (@expr30176 ) ) {
12111: tok@var3420 .@expr1073772103 isOperatorKeyword (@expr1073772104 true ) ; }
12112: }
12113:
12114: for (@expr1073772105 Token *@expr30094 tok@var3424 =@expr1073772107 list@var872 .@expr30096 front (@expr30097 ) ; tok@var3424 ; tok@var3424 =@expr1073772110 tok@var3424 .@expr30287 next (@expr30288 ) ) {
12115: if (@expr1073772113 Token ::@expr30102 Match (@expr1073772115 tok@var3424 , "%op% %str% %name%" ) ) {
12116: std ::@expr1073772116 string name@var3425 ; name@var3425 =@expr1073772117 tok@var3424 .@expr1073772118 strAt (@expr1073772119 2 ) ;
12117: Token * const str@var3426 ; str@var3426 =@expr1073772120 tok@var3424 .@expr30287 next (@expr30288 ) ;
12118: str@var3426 .@expr1073772123 deleteNext (@expr1073772124 ) ;
12119: tok@var3424 .@expr30301 insertToken (@expr1073772126 "operator\"\"" +@expr1073772127 name@var3425 ) ;
12120: tok@var3424 =@expr1073772128 tok@var3424 .@expr30287 next (@expr30288 ) ;
12121: tok@var3424 .@expr1073772131 isOperatorKeyword (@expr1073772132 true ) ;
12122: tok@var3424 .@expr30301 insertToken (@expr1073772134 "(" ) ;
12123: str@var3426 .@expr30311 insertToken (@expr1073772136 ")" ) ;
12124: Token ::@expr1073772137 createMutualLinks (@expr1073772138 tok@var3424 .@expr30287 next (@expr30288 ) , str@var3426 .@expr1073772141 next (@expr1073772142 ) ) ;
12125: str@var3426 .@expr30311 insertToken (@expr1073772144 MathLib ::@expr1073772145 toString (@expr1073772146 Token ::@expr1073772147 getStrLength (@expr1073772148 str@var3426 ) ) ) ;
12126: str@var3426 .@expr30311 insertToken (@expr1073772150 "," ) ;
12127: }
12128: }
12129:
12130: if (@expr1073772151 mSettings@var879 .@expr1073772152 debugwarnings@var3566 ) {
12131: const Token * tok@var3427 ; tok@var3427 =@expr1073772153 list@var872 .@expr30096 front (@expr30097 ) ;
12132:
12133: while (@expr1073772156 (@expr1073772157 tok@var3427 =@expr1073772158 Token ::@expr1073772159 findsimplematch (@expr1073772160 tok@var3427 , "operator" ) ) !=@expr1073772161 nullptr ) {
12134: reportError (@expr1073772162 tok@var3427 , Severity ::@expr1073772163 debug , "debug" ,
12135: "simplifyOperatorName: found unsimplified operator name" ) ;
12136: tok@var3427 =@expr1073772164 tok@var3427 .@expr1073772165 next (@expr1073772166 ) ;
12137: }
12138: }
12139: }
12140:
12141: void Tokenizer :: simplifyOverloadedOperators ( )
12142: {
12143: if (@expr1073772167 isC (@expr1073772168 ) ) {
12144: return ; }
12145: std ::@expr1073772169 set < std ::@expr1073772170 string > classNames@var3428 ;
12146: std ::@expr1073772171 set < int > classVars@var3429 ;
12147: for (@expr1073772172 Token *@expr30349 tok@var3430 =@expr1073772174 list@var872 .@expr1073772175 front (@expr1073772176 ) ; tok@var3430 ; tok@var3430 =@expr1073772177 tok@var3430 .@expr30354 next (@expr30355 ) ) {
12148: if (@expr1073772180 !@expr30357 tok@var3430 .@expr30358 isName (@expr30359 ) ) {
12149: continue ; }
12150:
12151: if (@expr1073772184 Token ::@expr30361 simpleMatch (@expr1073772186 tok@var3430 , "this ) (" ) &&@expr1073772187 Token ::@expr30361 simpleMatch (@expr1073772189 tok@var3430 .@expr1073772190 tokAt (@expr1073772191 -2 ) , "( *" ) ) {
12152: tok@var3430 =@expr1073772192 tok@var3430 .@expr30354 next (@expr30355 ) ;
12153: tok@var3430 .@expr30371 insertToken (@expr30372 "operator()" ) ;
12154: tok@var3430 .@expr30371 insertToken (@expr30374 "." ) ;
12155: continue ;
12156: }
12157:
12158:
12159: if (@expr1073772199 Token ::@expr30376 Match (@expr1073772201 tok@var3430 , "class|struct %name% [:{]" ) ) {
12160: int indent@var3431 ; indent@var3431 =@expr1073772202 0 ;
12161: for (@expr1073772203 const Token *@expr30349 tok2@var3432 =@expr1073772205 tok@var3430 .@expr30354 next (@expr30355 ) ; tok2@var3432 ; tok2@var3432 =@expr1073772208 tok2@var3432 .@expr30385 next (@expr30386 ) ) {
12162: if (@expr1073772211 tok2@var3432 .@expr30388 str (@expr30389 ) ==@expr1073772214 "}" ) {
12163: break ; }
12164: else { if (@expr1073772215 indent@var3431 ==@expr30392 0 &&@expr1073772217 tok2@var3432 .@expr30388 str (@expr30389 ) ==@expr1073772220 ";" ) {
12165: break ; }
12166: else { if (@expr1073772221 tok2@var3432 .@expr30388 str (@expr30389 ) ==@expr1073772224 "{" ) {
12167: if (@expr1073772225 indent@var3431 ==@expr30392 0 ) {
12168: ++@expr1073772227 indent@var3431 ; }
12169: else {
12170: tok2@var3432 =@expr1073772228 tok2@var3432 .@expr1073772229 link (@expr1073772230 ) ; }
12171: } else { if (@expr1073772231 indent@var3431 ==@expr1073772232 1 &&@expr1073772233 Token ::@expr30361 simpleMatch (@expr1073772235 tok2@var3432 , "operator() (" ) &&@expr1073772236 isFunctionHead (@expr1073772237 tok2@var3432 .@expr30385 next (@expr30386 ) , ";{" ) ) {
12172: classNames@var3428 .@expr1073772240 insert (@expr1073772241 tok@var3430 .@expr1073772242 strAt (@expr1073772243 1 ) ) ;
12173: break ;
12174: } } } }
12175: }
12176: }
12177:
12178:
12179: if (@expr1073772244 Token ::@expr30376 Match (@expr1073772246 tok@var3430 , "%type% &| %var%" ) &&@expr1073772247 classNames@var3428 .@expr1073772248 find (@expr1073772249 tok@var3430 .@expr1073772250 str (@expr1073772251 ) ) !=@expr1073772252 classNames@var3428 .@expr1073772253 end (@expr1073772254 ) ) {
12180: tok@var3430 =@expr1073772255 tok@var3430 .@expr30354 next (@expr30355 ) ;
12181: while (@expr1073772258 !@expr30357 tok@var3430 .@expr30358 isName (@expr30359 ) ) {
12182: tok@var3430 =@expr1073772262 tok@var3430 .@expr30354 next (@expr30355 ) ; }
12183: classVars@var3429 .@expr1073772265 insert (@expr1073772266 tok@var3430 .@expr30443 varId (@expr30444 ) ) ;
12184: }
12185:
12186:
12187: if (@expr1073772269 Token ::@expr30376 Match (@expr1073772271 tok@var3430 , "%var% (" ) &&@expr1073772272 classVars@var3429 .@expr1073772273 find (@expr1073772274 tok@var3430 .@expr30443 varId (@expr30444 ) ) !=@expr1073772277 classVars@var3429 .@expr1073772278 end (@expr1073772279 ) ) {
12188:
12189: if (@expr1073772280 Token ::@expr30376 Match (@expr1073772282 tok@var3430 .@expr30459 previous (@expr30460 ) , "[:,]" ) ) {
12190: const Token * start@var3433 ; start@var3433 =@expr1073772285 tok@var3430 .@expr30459 previous (@expr30460 ) ;
12191: while (@expr1073772288 Token ::@expr30361 simpleMatch (@expr1073772290 start@var3433 , "," ) ) {
12192: if (@expr1073772291 Token ::@expr30361 simpleMatch (@expr1073772293 start@var3433 .@expr30470 previous (@expr30471 ) , ")" ) ) {
12193: start@var3433 =@expr1073772296 start@var3433 .@expr1073772297 linkAt (@expr1073772298 -1 ) ; }
12194: else {
12195: break ; }
12196: if (@expr1073772299 Token ::@expr30376 Match (@expr1073772301 start@var3433 .@expr30470 previous (@expr30471 ) , "%name%" ) ) {
12197: start@var3433 =@expr1073772304 start@var3433 .@expr1073772305 tokAt (@expr1073772306 -2 ) ; }
12198: else {
12199: break ; }
12200: }
12201: const Token * after@var3434 ; after@var3434 =@expr1073772307 tok@var3430 .@expr1073772308 linkAt (@expr1073772309 1 ) ;
12202: while (@expr1073772310 Token ::@expr30376 Match (@expr1073772312 after@var3434 , ")|} , %name% (|{" ) ) {
12203: after@var3434 =@expr1073772313 after@var3434 .@expr1073772314 linkAt (@expr1073772315 3 ) ; }
12204:
12205:
12206: if (@expr1073772316 Token ::@expr30361 simpleMatch (@expr1073772318 start@var3433 , ":" ) &&@expr1073772319 Token ::@expr30361 simpleMatch (@expr1073772321 after@var3434 , ") {" ) ) {
12207: continue ; }
12208: }
12209:
12210: tok@var3430 .@expr30371 insertToken (@expr30372 "operator()" ) ;
12211: tok@var3430 .@expr30371 insertToken (@expr30374 "." ) ;
12212: }
12213: }
12214: }
12215:
12216:
12217: void Tokenizer :: removeUnnecessaryQualification ( )
12218: {
12219: if (@expr1073772326 isC (@expr1073772327 ) ) {
12220: return ; }
12221:
12222: std ::@expr1073772328 vector < Space > classInfo@var3435 ;
12223: for (@expr1073772329 Token *@expr1073772330 tok@var3436 =@expr1073772331 list@var872 .@expr1073772332 front (@expr1073772333 ) ; tok@var3436 ; tok@var3436 =@expr1073772334 tok@var3436 .@expr30511 next (@expr30512 ) ) {
12224: if (@expr1073772337 Token ::@expr30514 Match (@expr1073772339 tok@var3436 , "class|struct|namespace %type% :|{" ) &&@expr1073772340
12225: (@expr1073772341 !@expr1073772342 tok@var3436 .@expr30519 previous (@expr30520 ) ||@expr1073772345 tok@var3436 .@expr30519 previous (@expr30520 ) .@expr30524 str (@expr30525 ) !=@expr1073772350 "enum" ) ) {
12226: Space info@var3437 ;
12227: info@var3437 .@expr1073772351 isNamespace@var3438 =@expr1073772352 tok@var3436 .@expr30529 str (@expr30530 ) ==@expr1073772355 "namespace" ;
12228: tok@var3436 =@expr1073772356 tok@var3436 .@expr30511 next (@expr30512 ) ;
12229: info@var3437 .@expr1073772359 className@var3439 =@expr1073772360 tok@var3436 .@expr30529 str (@expr30530 ) ;
12230: tok@var3436 =@expr1073772363 tok@var3436 .@expr30511 next (@expr30512 ) ;
12231: while (@expr1073772366 tok@var3436 &&@expr1073772367 tok@var3436 .@expr30529 str (@expr30530 ) !=@expr1073772370 "{" ) {
12232: tok@var3436 =@expr1073772371 tok@var3436 .@expr30511 next (@expr30512 ) ; }
12233: if (@expr1073772374 !@expr1073772375 tok@var3436 ) {
12234: return ; }
12235: info@var3437 .@expr1073772376 bodyEnd@var3440 =@expr1073772377 tok@var3436 .@expr1073772378 link (@expr1073772379 ) ;
12236: classInfo@var3435 .@expr1073772380 push_back (@expr1073772381 info@var3437 ) ;
12237: } else { if (@expr1073772382 !@expr1073772383 classInfo@var3435 .@expr1073772384 empty (@expr1073772385 ) ) {
12238: if (@expr1073772386 tok@var3436 ==@expr1073772387 classInfo@var3435 .@expr30564 back (@expr30565 ) .@expr1073772390 bodyEnd@var3604 ) {
12239: classInfo@var3435 .@expr1073772391 pop_back (@expr1073772392 ) ; }
12240: else { if (@expr1073772393 tok@var3436 .@expr30529 str (@expr30530 ) ==@expr1073772396 classInfo@var3435 .@expr30564 back (@expr30565 ) .@expr1073772399 className@var3619 &&@expr1073772400
12241: !@expr1073772401 classInfo@var3435 .@expr30564 back (@expr30565 ) .@expr1073772404 isNamespace@var3620 &&@expr1073772405 tok@var3436 .@expr30519 previous (@expr30520 ) .@expr30524 str (@expr30525 ) !=@expr1073772410 ":" &&@expr1073772411
12242: (@expr1073772412 Token ::@expr30514 Match (@expr1073772414 tok@var3436 , "%type% :: ~| %type% (" ) ||@expr1073772415
12243: Token ::@expr30514 Match (@expr1073772417 tok@var3436 , "%type% :: operator" ) ) ) {
12244: const Token * tok1@var3441 ; tok1@var3441 =@expr1073772418 tok@var3436 .@expr30595 tokAt (@expr1073772420 3 ) ;
12245: if (@expr1073772421 tok@var3436 .@expr30598 strAt (@expr30599 2 ) ==@expr1073772424 "operator" ) {
12246:
12247: if (@expr1073772425 tok1@var3441 .@expr30602 str (@expr30603 ) ==@expr1073772428 "(" ) {
12248: tok1@var3441 =@expr1073772429 tok1@var3441 .@expr30606 next (@expr30607 ) ; }
12249:
12250: while (@expr1073772432 tok1@var3441 &&@expr1073772433 tok1@var3441 .@expr30602 str (@expr30603 ) !=@expr30612 "(" ) {
12251: if (@expr1073772437 tok1@var3441 .@expr30602 str (@expr30603 ) ==@expr1073772440 ";" ) {
12252: break ; }
12253: tok1@var3441 =@expr1073772441 tok1@var3441 .@expr30606 next (@expr30607 ) ;
12254: }
12255: if (@expr1073772444 !@expr30621 tok1@var3441 ||@expr1073772446 tok1@var3441 .@expr30602 str (@expr30603 ) !=@expr30612 "(" ) {
12256: continue ; }
12257: } else { if (@expr1073772450 tok@var3436 .@expr30598 strAt (@expr30599 2 ) ==@expr30629 "~" ) {
12258: tok1@var3441 =@expr1073772454 tok1@var3441 .@expr30606 next (@expr30607 ) ; } }
12259:
12260: if (@expr1073772457 !@expr30621 tok1@var3441 ||@expr1073772459 !@expr1073772460 Token ::@expr30514 Match (@expr1073772462 tok1@var3441 .@expr1073772463 link (@expr1073772464 ) , ") const| {|;|:" ) ) {
12261: continue ;
12262: }
12263:
12264: const bool isConstructorOrDestructor@var3442 =@expr1073772465
12265: Token ::@expr30514 Match (@expr1073772467 tok@var3436 , "%type% :: ~| %type%" ) &&@expr1073772468 (@expr1073772469 tok@var3436 .@expr30598 strAt (@expr30599 2 ) ==@expr1073772472 tok@var3436 .@expr30529 str (@expr30530 ) ||@expr1073772475 (@expr1073772476 tok@var3436 .@expr30598 strAt (@expr30599 2 ) ==@expr30629 "~" &&@expr1073772480 tok@var3436 .@expr30598 strAt (@expr1073772482 3 ) ==@expr1073772483 tok@var3436 .@expr30529 str (@expr30530 ) ) ) ;
12266: if (@expr1073772486 !@expr1073772487 isConstructorOrDestructor@var3442 ) {
12267: bool isPrependedByType@var3443 ; isPrependedByType@var3443 =@expr1073772488 Token ::@expr30514 Match (@expr1073772490 tok@var3436 .@expr30519 previous (@expr30520 ) , "%type%" ) ;
12268: if (@expr30669 !@expr30670 isPrependedByType@var3443 ) {
12269: const Token * tok2@var3444 ; tok2@var3444 =@expr1073772495 tok@var3436 .@expr30595 tokAt (@expr1073772497 -2 ) ;
12270: isPrependedByType@var3443 =@expr1073772498 Token ::@expr30514 Match (@expr1073772500 tok2@var3444 , "%type% *|&" ) ;
12271: }
12272: if (@expr30669 !@expr30670 isPrependedByType@var3443 ) {
12273: const Token * tok3@var3445 ; tok3@var3445 =@expr1073772503 tok@var3436 .@expr30595 tokAt (@expr1073772505 -3 ) ;
12274: isPrependedByType@var3443 =@expr1073772506 Token ::@expr30514 Match (@expr1073772508 tok3@var3445 , "%type% * *|&" ) ;
12275: }
12276: if (@expr30669 !@expr30670 isPrependedByType@var3443 ) {
12277:
12278:
12279: continue ;
12280: }
12281: }
12282: } }
12283: } }
12284: }
12285: }
12286:
12287: void Tokenizer :: simplifyReturnStrncat ( )
12288: {
12289: for (@expr1073772511 Token *@expr1073772512 tok@var3446 =@expr1073772513 list@var872 .@expr1073772514 front (@expr1073772515 ) ; tok@var3446 ; tok@var3446 =@expr1073772516 tok@var3446 .@expr30693 next (@expr30694 ) ) {
12290: if (@expr1073772519 Token ::@expr30696 simpleMatch (@expr1073772521 tok@var3446 , "return strncat (" ) &&@expr1073772522
12291: Token ::@expr30696 simpleMatch (@expr1073772524 tok@var3446 .@expr30701 linkAt (@expr30702 2 ) , ") ;" ) &&@expr1073772527
12292: tok@var3446 .@expr30704 strAt (@expr30705 3 ) !=@expr1073772530 ")" &&@expr1073772531 tok@var3446 .@expr30704 strAt (@expr30705 3 ) !=@expr1073772534 "," ) {
12293:
12294:
12295: Token * tok2@var3447 ; tok2@var3447 =@expr1073772535 tok@var3446 .@expr1073772536 tokAt (@expr1073772537 3 ) ;
12296:
12297:
12298: for (@expr1073772538 int i@var3448 =@expr1073772539 0 ; i@var3448 <@expr1073772540 2 ; ++@expr1073772541 i@var3448 ) {
12299: tok2@var3447 =@expr1073772542 tok2@var3447 .@expr30719 nextArgument (@expr30720 ) ;
12300: if (@expr30721 !@expr30722 tok2@var3447 ) {
12301: tok@var3446 =@expr1073772547 tok@var3446 .@expr30701 linkAt (@expr30702 2 ) .@expr30726 next (@expr30727 ) ;
12302: break ;
12303: }
12304: }
12305: if (@expr30721 !@expr30722 tok2@var3447 ) {
12306: continue ; }
12307:
12308: tok2@var3447 =@expr1073772554 tok2@var3447 .@expr30719 nextArgument (@expr30720 ) ;
12309:
12310: if (@expr1073772557 tok2@var3447 ) {
12311: tok@var3446 =@expr1073772558 tok@var3446 .@expr30701 linkAt (@expr30702 2 ) .@expr30726 next (@expr30727 ) ;
12312: continue ;
12313: }
12314:
12315:
12316: tok@var3446 .@expr1073772563 deleteThis (@expr1073772564 ) ;
12317:
12318:
12319: tok@var3446 =@expr1073772565 tok@var3446 .@expr30693 next (@expr30694 ) ;
12320:
12321: tok2@var3447 =@expr1073772568 tok@var3446 .@expr1073772569 link (@expr1073772570 ) .@expr1073772571 next (@expr1073772572 ) ;
12322: tok2@var3447 .@expr30749 insertToken (@expr1073772574 ";" ) ;
12323:
12324:
12325: const Token * const end@var3449 ; end@var3449 =@expr1073772575 tok@var3446 .@expr30693 next (@expr30694 ) .@expr1073772578 nextArgument (@expr1073772579 ) .@expr1073772580 tokAt (@expr1073772581 -2 ) ;
12326:
12327:
12328: TokenList ::@expr1073772582 copyTokens (@expr1073772583 tok2@var3447 , tok@var3446 .@expr30693 next (@expr30694 ) , end@var3449 ) ;
12329: tok2@var3447 .@expr30749 insertToken (@expr1073772587 "return" ) ;
12330: }
12331: }
12332: }
12333:
12334: void Tokenizer :: printUnknownTypes ( ) const
12335: {
12336: if (@expr1073772588 !@expr1073772589 mSymbolDatabase@var881 ) {
12337: return ; }
12338:
12339: std ::@expr1073772590 multimap < std ::@expr30767 string , const Token *@expr30768 > unknowns@var3450 ;
12340:
12341: for (@expr1073772593 int i@var3451 =@expr1073772594 1 ; i@var3451 <=@expr1073772595 mVarId@var891 ; ++@expr1073772596 i@var3451 ) {
12342: const Variable * var@var3452 ; var@var3452 =@expr1073772597 mSymbolDatabase@var881 .@expr1073772598 getVariableFromVarId (@expr1073772599 i@var3451 ) ;
12343: if (@expr1073772600 !@expr1073772601 var@var3452 ) {
12344: continue ; }
12345:
12346: if (@expr1073772602 var@var3452 .@expr1073772603 type (@expr1073772604 ) ||@expr1073772605 var@var3452 .@expr30782 typeStartToken (@expr30783 ) .@expr1073772608 isStandardType (@expr1073772609 ) ) {
12347: continue ; }
12348:
12349: std ::@expr1073772610 string name@var3453 ;
12350: const Token * nameTok@var3454 ;
12351:
12352:
12353: if (@expr1073772611 var@var3452 .@expr30782 typeStartToken (@expr30783 ) ==@expr1073772614 var@var3452 .@expr30791 typeEndToken (@expr30792 ) ) {
12354: nameTok@var3454 =@expr1073772617 var@var3452 .@expr30782 typeStartToken (@expr30783 ) ;
12355: name@var3453 =@expr1073772620 nameTok@var3454 .@expr1073772621 str (@expr1073772622 ) ;
12356: }
12357:
12358:
12359: else {
12360: const Token * tok@var3455 ; tok@var3455 =@expr1073772623 var@var3452 .@expr30782 typeStartToken (@expr30783 ) ;
12361: int level@var3456 ; level@var3456 =@expr1073772626 0 ;
12362:
12363: nameTok@var3454 =@expr1073772627 tok@var3455 ;
12364:
12365: while (@expr1073772628 tok@var3455 ) {
12366:
12367: if (@expr1073772629 level@var3456 ==@expr1073772630 0 &&@expr1073772631 Token ::@expr30808 Match (@expr1073772633 tok@var3455 , "*|&" ) ) {
12368: break ; }
12369:
12370: name@var3453 +=@expr1073772634 tok@var3455 .@expr30811 str (@expr30812 ) ;
12371:
12372: if (@expr1073772637 Token ::@expr30808 Match (@expr1073772639 tok@var3455 , "struct|union|enum" ) ) {
12373: name@var3453 +=@expr1073772640 " " ; }
12374:
12375:
12376: else { if (@expr1073772641 tok@var3455 .@expr30811 str (@expr30812 ) ==@expr1073772644 "<" ) {
12377: ++@expr1073772645 level@var3456 ; }
12378: else { if (@expr1073772646 tok@var3455 .@expr30811 str (@expr30812 ) ==@expr1073772649 ">" ) {
12379: --@expr1073772650 level@var3456 ; } } }
12380:
12381: if (@expr1073772651 tok@var3455 ==@expr1073772652 var@var3452 .@expr30791 typeEndToken (@expr30792 ) ) {
12382: break ; }
12383:
12384: tok@var3455 =@expr1073772655 tok@var3455 .@expr1073772656 next (@expr1073772657 ) ;
12385: }
12386: }
12387:
12388: unknowns@var3450 .@expr1073772658 insert (@expr1073772659 std ::@expr1073772660 pair < std ::@expr30767 string , const Token *@expr30768 > (@expr1073772663 name@var3453 , nameTok@var3454 ) ) ;
12389: }
12390:
12391: if (@expr1073772664 !@expr1073772665 unknowns@var3450 .@expr1073772666 empty (@expr1073772667 ) ) {
12392: std ::@expr1073772668 string last@var3457 ;
12393: int count@var3458 ; count@var3458 =@expr1073772669 0 ;
12394:
12395: for (@expr1073772670 std ::@expr30767 multimap < std ::@expr30767 string , const Token *@expr30768 > ::@expr30767 const_iterator it@var3459 =@expr1073772675 unknowns@var3450 .@expr1073772676 begin (@expr1073772677 ) ; it@var3459 !=@expr1073772678 unknowns@var3450 .@expr1073772679 end (@expr1073772680 ) ; ++@expr1073772681 it@var3459 ) {
12396:
12397: if (@expr1073772682 it@var3459 .@expr30859 first@var3460 .@expr1073772684 find (@expr1073772685 "std::" ) !=@expr1073772686 0 ) {
12398: if (@expr1073772687 it@var3459 .@expr30859 first@var3460 !=@expr1073772689 last@var3457 ) {
12399: last@var3457 =@expr1073772690 it@var3459 .@expr30859 first@var3460 ;
12400: count@var3458 =@expr1073772692 1 ;
12401: reportError (@expr30869 it@var3459 .@expr30870 second@var3461 , Severity ::@expr30871 debug , "debug" , "Unknown type \'" +@expr30872 it@var3459 .@expr30859 first@var3460 +@expr30874 "\'." ) ;
12402: } else {
12403: if (@expr1073772699 count@var3458 <@expr1073772700 3 ) {
12404: reportError (@expr30869 it@var3459 .@expr30870 second@var3461 , Severity ::@expr30871 debug , "debug" , "Unknown type \'" +@expr30872 it@var3459 .@expr30859 first@var3460 +@expr30874 "\'." ) ; }
12405: count@var3458 ++@expr1073772707 ;
12406: }
12407: }
12408: }
12409: }
12410: }
12411:
12412: void Tokenizer :: simplifyMathExpressions ( )
12413: {
12414: for (@expr1073772708 Token *@expr1073772709 tok@var3462 =@expr1073772710 list@var872 .@expr1073772711 front (@expr1073772712 ) ; tok@var3462 ; tok@var3462 =@expr1073772713 tok@var3462 .@expr1073772714 next (@expr1073772715 ) ) {
12415:
|
12423:
12424: if (@expr1073772716 Token ::@expr30893 Match (@expr1073772718 tok@var3462 , "pow|powf|powl (" ) ) {
12425: if (@expr1073772719 Token ::@expr30893 Match (@expr1073772721 tok@var3462 .@expr30898 tokAt (@expr30899 2 ) , "sin|sinf|sinl (" ) ) {
12426: Token * const tok2@var3463 ; tok2@var3463 =@expr1073772724 tok@var3462 .@expr30901 linkAt (@expr30902 3 ) ;
12427: if (@expr1073772727 !@expr1073772728 Token ::@expr30893 Match (@expr1073772730 tok2@var3463 , ") , %num% ) + pow|powf|powl ( cos|cosf|cosl (" ) ) {
12428: continue ; }
12429: const std ::@expr30907 string &@expr30908 leftExponent@var3464 =@expr1073772733 tok2@var3463 .@expr1073772734 strAt (@expr1073772735 2 ) ;
12430: if (@expr1073772736 !@expr1073772737 isTwoNumber (@expr1073772738 leftExponent@var3464 ) ) {
12431: continue ; }
12432: const Token * const tok3@var3465 ; tok3@var3465 =@expr1073772739 tok2@var3463 .@expr1073772740 tokAt (@expr1073772741 8 ) ;
12433: Token * const tok4@var3466 ; tok4@var3466 =@expr1073772742 tok3@var3465 .@expr1073772743 link (@expr1073772744 ) ;
12434: if (@expr1073772745 !@expr1073772746 Token ::@expr30893 Match (@expr1073772748 tok4@var3466 , ") , %num% )" ) ) {
12435: continue ; }
12436: const std ::@expr30907 string &@expr30908 rightExponent@var3467 =@expr1073772751 tok4@var3466 .@expr1073772752 strAt (@expr1073772753 2 ) ;
12437: if (@expr1073772754 !@expr1073772755 isTwoNumber (@expr1073772756 rightExponent@var3467 ) ) {
12438: continue ; }
12439: if (@expr1073772757 tok@var3462 .@expr30898 tokAt (@expr30935 3 ) .@expr30936 stringifyList (@expr1073772761 tok2@var3463 .@expr1073772762 next (@expr1073772763 ) ) ==@expr1073772764 tok3@var3465 .@expr1073772765 stringifyList (@expr1073772766 tok4@var3466 .@expr1073772767 next (@expr1073772768 ) ) ) {
12440: Token ::@expr30945 eraseTokens (@expr1073772770 tok@var3462 , tok4@var3466 .@expr1073772771 tokAt (@expr1073772772 4 ) ) ;
12441: tok@var3462 .@expr30949 str (@expr30950 "1" ) ;
12442: }
12443: } else { if (@expr1073772775 Token ::@expr30893 Match (@expr1073772777 tok@var3462 .@expr30898 tokAt (@expr30899 2 ) , "cos|cosf|cosl (" ) ) {
12444: Token * const tok2@var3468 ; tok2@var3468 =@expr1073772780 tok@var3462 .@expr30901 linkAt (@expr30902 3 ) ;
12445: if (@expr1073772783 !@expr1073772784 Token ::@expr30893 Match (@expr1073772786 tok2@var3468 , ") , %num% ) + pow|powf|powl ( sin|sinf|sinl (" ) ) {
12446: continue ; }
12447: const std ::@expr30907 string &@expr30908 leftExponent@var3469 =@expr1073772789 tok2@var3468 .@expr1073772790 strAt (@expr1073772791 2 ) ;
12448: if (@expr1073772792 !@expr1073772793 isTwoNumber (@expr1073772794 leftExponent@var3469 ) ) {
12449: continue ; }
12450: const Token * const tok3@var3470 ; tok3@var3470 =@expr1073772795 tok2@var3468 .@expr1073772796 tokAt (@expr1073772797 8 ) ;
12451: Token * const tok4@var3471 ; tok4@var3471 =@expr1073772798 tok3@var3470 .@expr1073772799 link (@expr1073772800 ) ;
12452: if (@expr1073772801 !@expr1073772802 Token ::@expr30893 Match (@expr1073772804 tok4@var3471 , ") , %num% )" ) ) {
12453: continue ; }
12454: const std ::@expr30907 string &@expr30908 rightExponent@var3472 =@expr1073772807 tok4@var3471 .@expr1073772808 strAt (@expr1073772809 2 ) ;
12455: if (@expr1073772810 !@expr1073772811 isTwoNumber (@expr1073772812 rightExponent@var3472 ) ) {
12456: continue ; }
12457: if (@expr1073772813 tok@var3462 .@expr30898 tokAt (@expr30935 3 ) .@expr30936 stringifyList (@expr1073772817 tok2@var3468 .@expr1073772818 next (@expr1073772819 ) ) ==@expr1073772820 tok3@var3470 .@expr1073772821 stringifyList (@expr1073772822 tok4@var3471 .@expr1073772823 next (@expr1073772824 ) ) ) {
12458: Token ::@expr30945 eraseTokens (@expr1073772826 tok@var3462 , tok4@var3471 .@expr1073772827 tokAt (@expr1073772828 4 ) ) ;
12459: tok@var3462 .@expr30949 str (@expr30950 "1" ) ;
12460: }
12461: } else { if (@expr1073772831 Token ::@expr30893 Match (@expr1073772833 tok@var3462 .@expr30898 tokAt (@expr30899 2 ) , "sinh|sinhf|sinhl (" ) ) {
12462: Token * const tok2@var3473 ; tok2@var3473 =@expr1073772836 tok@var3462 .@expr30901 linkAt (@expr30902 3 ) ;
12463: if (@expr1073772839 !@expr1073772840 Token ::@expr30893 Match (@expr1073772842 tok2@var3473 , ") , %num% ) - pow|powf|powl ( cosh|coshf|coshl (" ) ) {
12464: continue ; }
12465: const std ::@expr30907 string &@expr30908 leftExponent@var3474 =@expr1073772845 tok2@var3473 .@expr1073772846 strAt (@expr1073772847 2 ) ;
12466: if (@expr1073772848 !@expr1073772849 isTwoNumber (@expr1073772850 leftExponent@var3474 ) ) {
12467: continue ; }
12468: const Token * const tok3@var3475 ; tok3@var3475 =@expr1073772851 tok2@var3473 .@expr1073772852 tokAt (@expr1073772853 8 ) ;
12469: Token * const tok4@var3476 ; tok4@var3476 =@expr1073772854 tok3@var3475 .@expr1073772855 link (@expr1073772856 ) ;
12470: if (@expr1073772857 !@expr1073772858 Token ::@expr30893 Match (@expr1073772860 tok4@var3476 , ") , %num% )" ) ) {
12471: continue ; }
12472: const std ::@expr30907 string &@expr30908 rightExponent@var3477 =@expr1073772863 tok4@var3476 .@expr1073772864 strAt (@expr1073772865 2 ) ;
12473: if (@expr1073772866 !@expr1073772867 isTwoNumber (@expr1073772868 rightExponent@var3477 ) ) {
12474: continue ; }
12475: if (@expr1073772869 tok@var3462 .@expr30898 tokAt (@expr30935 3 ) .@expr30936 stringifyList (@expr1073772873 tok2@var3473 .@expr1073772874 next (@expr1073772875 ) ) ==@expr1073772876 tok3@var3475 .@expr1073772877 stringifyList (@expr1073772878 tok4@var3476 .@expr1073772879 next (@expr1073772880 ) ) ) {
12476: Token ::@expr30945 eraseTokens (@expr1073772882 tok@var3462 , tok4@var3476 .@expr1073772883 tokAt (@expr1073772884 4 ) ) ;
12477: tok@var3462 .@expr30949 str (@expr31062 "-1" ) ;
12478: }
12479: } else { if (@expr1073772887 Token ::@expr30893 Match (@expr1073772889 tok@var3462 .@expr30898 tokAt (@expr30899 2 ) , "cosh|coshf|coshl (" ) ) {
12480: Token * const tok2@var3478 ; tok2@var3478 =@expr1073772892 tok@var3462 .@expr30901 linkAt (@expr30902 3 ) ;
12481: if (@expr1073772895 !@expr1073772896 Token ::@expr30893 Match (@expr1073772898 tok2@var3478 , ") , %num% ) - pow|powf|powl ( sinh|sinhf|sinhl (" ) ) {
12482: continue ; }
12483: const std ::@expr30907 string &@expr30908 leftExponent@var3479 =@expr1073772901 tok2@var3478 .@expr1073772902 strAt (@expr1073772903 2 ) ;
12484: if (@expr1073772904 !@expr1073772905 isTwoNumber (@expr1073772906 leftExponent@var3479 ) ) {
12485: continue ; }
12486: const Token * const tok3@var3480 ; tok3@var3480 =@expr1073772907 tok2@var3478 .@expr1073772908 tokAt (@expr1073772909 8 ) ;
12487: Token * const tok4@var3481 ; tok4@var3481 =@expr1073772910 tok3@var3480 .@expr1073772911 link (@expr1073772912 ) ;
12488: if (@expr1073772913 !@expr1073772914 Token ::@expr30893 Match (@expr1073772916 tok4@var3481 , ") , %num% )" ) ) {
12489: continue ; }
12490: const std ::@expr30907 string &@expr30908 rightExponent@var3482 =@expr1073772919 tok4@var3481 .@expr1073772920 strAt (@expr1073772921 2 ) ;
12491: if (@expr1073772922 !@expr1073772923 isTwoNumber (@expr1073772924 rightExponent@var3482 ) ) {
12492: continue ; }
12493: if (@expr1073772925 tok@var3462 .@expr30898 tokAt (@expr30935 3 ) .@expr30936 stringifyList (@expr1073772929 tok2@var3478 .@expr1073772930 next (@expr1073772931 ) ) ==@expr1073772932 tok3@var3480 .@expr1073772933 stringifyList (@expr1073772934 tok4@var3481 .@expr1073772935 next (@expr1073772936 ) ) ) {
12494: Token ::@expr30945 eraseTokens (@expr1073772938 tok@var3462 , tok4@var3481 .@expr1073772939 tokAt (@expr1073772940 4 ) ) ;
12495: tok@var3462 .@expr30949 str (@expr31062 "-1" ) ;
12496: }
12497: } } } }
12498: }
12499: }
12500: }
12501:
12502: bool Tokenizer :: simplifyStrlen ( )
12503: {
12504:
12505: bool modified@var3483 ; modified@var3483 =@expr1073772943 false ;
12506: for (@expr1073772944 Token *@expr1073772945 tok@var3484 =@expr1073772946 list@var872 .@expr1073772947 front (@expr1073772948 ) ; tok@var3484 ; tok@var3484 =@expr1073772949 tok@var3484 .@expr1073772950 next (@expr1073772951 ) ) {
12507: if (@expr1073772952 Token ::@expr1073772953 Match (@expr1073772954 tok@var3484 , "strlen ( %str% )" ) ) {
12508: tok@var3484 .@expr1073772955 str (@expr1073772956 MathLib ::@expr1073772957 toString (@expr1073772958 Token ::@expr1073772959 getStrLength (@expr1073772960 tok@var3484 .@expr1073772961 tokAt (@expr1073772962 2 ) ) ) ) ;
12509: tok@var3484 .@expr1073772963 deleteNext (@expr1073772964 3 ) ;
12510: modified@var3483 =@expr1073772965 true ;
12511: }
12512: }
12513: return modified@var3483 ;
12514: }
12515:
12516: void Tokenizer :: prepareTernaryOpForAST ( )
12517: {
12518:
12519:
12520:
12521: for (@expr1073772966 Token *@expr1073772967 tok@var3485 =@expr1073772968 list@var872 .@expr1073772969 front (@expr1073772970 ) ; tok@var3485 ; tok@var3485 =@expr1073772971 tok@var3485 .@expr31148 next (@expr31149 ) ) {
12522: if (@expr1073772974 tok@var3485 .@expr1073772975 str (@expr1073772976 ) ==@expr1073772977 "?" ) {
12523: bool parenthesesNeeded@var3486 ; parenthesesNeeded@var3486 =@expr1073772978 false ;
12524: int depth@var3487 ; depth@var3487 =@expr1073772979 0 ;
12525: Token * tok2@var3488 ; tok2@var3488 =@expr1073772980 tok@var3485 .@expr31148 next (@expr31149 ) ;
12526: for (@expr1073772983 ; tok2@var3488 ; tok2@var3488 =@expr1073772984 tok2@var3488 .@expr1073772985 next (@expr1073772986 ) ) {
12527: if (@expr1073772987 tok2@var3488 .@expr31164 link (@expr31165 ) &&@expr1073772990 Token ::@expr1073772991 Match (@expr1073772992 tok2@var3488 , "[|(|<" ) ) {
12528: tok2@var3488 =@expr1073772993 tok2@var3488 .@expr31164 link (@expr31165 ) ; }
12529: else { if (@expr1073772996 tok2@var3488 .@expr31173 str (@expr31174 ) ==@expr31175 ":" ) {
12530: if (@expr1073773000 depth@var3487 ==@expr1073773001 0 ) {
12531: break ; }
12532: depth@var3487 --@expr1073773002 ;
12533: } else { if (@expr1073773003 tok2@var3488 .@expr31173 str (@expr31174 ) ==@expr1073773006 ";" ||@expr1073773007 (@expr1073773008 tok2@var3488 .@expr31164 link (@expr31165 ) &&@expr1073773011 tok2@var3488 .@expr31173 str (@expr31174 ) !=@expr1073773014 "{" &&@expr1073773015 tok2@var3488 .@expr31173 str (@expr31174 ) !=@expr1073773018 "}" ) ) {
12534: break ; }
12535: else { if (@expr1073773019 tok2@var3488 .@expr31173 str (@expr31174 ) ==@expr1073773022 "," ) {
12536: parenthesesNeeded@var3486 =@expr1073773023 true ; }
12537: else { if (@expr1073773024 tok2@var3488 .@expr31173 str (@expr31174 ) ==@expr1073773027 "<" ) {
12538: parenthesesNeeded@var3486 =@expr1073773028 true ; }
12539: else { if (@expr1073773029 tok2@var3488 .@expr31173 str (@expr31174 ) ==@expr1073773032 "?" ) {
12540: depth@var3487 ++@expr1073773033 ;
12541: parenthesesNeeded@var3486 =@expr1073773034 true ;
12542: } } } } } }
12543: }
12544: if (@expr1073773035 parenthesesNeeded@var3486 &&@expr1073773036 tok2@var3488 &&@expr1073773037 tok2@var3488 .@expr31173 str (@expr31174 ) ==@expr31175 ":" ) {
12545: tok@var3485 .@expr1073773041 insertToken (@expr1073773042 "(" ) ;
12546: tok2@var3488 .@expr1073773043 insertToken (@expr1073773044 ")" , emptyString@var1 , true ) ;
12547: Token ::@expr1073773045 createMutualLinks (@expr1073773046 tok@var3485 .@expr31148 next (@expr31149 ) , tok2@var3488 .@expr1073773049 previous (@expr1073773050 ) ) ;
12548: }
12549: }
12550: }
12551: }
12552:
12553: void Tokenizer :: reportError ( const Token * tok@var3489 , const Severity :: SeverityType severity@var3490 , const std :: string & id@var3491 , const std :: string & msg@var3492 , bool inconclusive@var3493 ) const
12554: {
12555: const std ::@expr1073773051 list < const Token *@expr1073773052 > callstack@var3494 (@expr1073773053 1 , tok@var3489 ) ;
12556: reportError (@expr1073773054 callstack@var3494 , severity@var3490 , id@var3491 , msg@var3492 , inconclusive@var3493 ) ;
12557: }
12558:
12559: void Tokenizer :: reportError ( const std :: list < const Token * > & callstack@var3495 , Severity :: SeverityType severity@var3496 , const std :: string & id@var3497 , const std :: string & msg@var3498 , bool inconclusive@var3499 ) const
12560: {
12561: const ErrorMessage errmsg@var3500 (@expr1073773055 callstack@var3495 , &@expr1073773056 list@var872 , severity@var3496 , id@var3497 , msg@var3498 , inconclusive@var3499 ?@expr1073773057 Certainty ::@expr1073773058 inconclusive :@expr1073773059 Certainty ::@expr1073773060 normal ) ;
12562: if (@expr1073773061 mErrorLogger@var880 ) {
12563: mErrorLogger@var880 .@expr1073773062 reportErr (@expr1073773063 errmsg@var3500 ) ; }
12564: else {
12565: Check ::@expr1073773064 reportError (@expr1073773065 errmsg@var3500 ) ; }
12566: }
12567:
12568: void Tokenizer :: setPodTypes ( )
12569: {
12570: if (@expr1073773066 !@expr1073773067 mSettings@var879 ) {
12571: return ; }
12572: for (@expr1073773068 Token *@expr1073773069 tok@var3501 =@expr1073773070 list@var872 .@expr1073773071 front (@expr1073773072 ) ; tok@var3501 ; tok@var3501 =@expr1073773073 tok@var3501 .@expr1073773074 next (@expr1073773075 ) ) {
12573: if (@expr1073773076 !@expr1073773077 tok@var3501 .@expr1073773078 isName (@expr1073773079 ) ) {
12574: continue ; }
12575:
12576:
12577: const struct Library ::@expr1073773080 PodType * podType@var3502 ; podType@var3502 =@expr1073773081 mSettings@var879 .@expr1073773082 library@var3563 .@expr1073773083 podtype (@expr1073773084 tok@var3501 .@expr1073773085 str (@expr1073773086 ) ) ;
12578: if (@expr1073773087 podType@var3502 ) {
12579: const Token * prev@var3503 ; prev@var3503 =@expr1073773088 tok@var3501 .@expr1073773089 previous (@expr1073773090 ) ;
12580: while (@expr1073773091 prev@var3503 &&@expr1073773092 prev@var3503 .@expr1073773093 isName (@expr1073773094 ) ) {
12581: prev@var3503 =@expr1073773095 prev@var3503 .@expr1073773096 previous (@expr1073773097 ) ; }
12582: if (@expr1073773098 prev@var3503 &&@expr1073773099 !@expr1073773100 Token ::@expr1073773101 Match (@expr1073773102 prev@var3503 , ";|{|}|,|(" ) ) {
12583: continue ; }
12584: tok@var3501 .@expr1073773103 isStandardType (@expr1073773104 true ) ;
12585: }
12586: }
12587: }
12588:
12589: const Token * Tokenizer :: findSQLBlockEnd ( const Token * tokSQLStart@var3504 )
12590: {
12591: const Token * tokLastEnd@var3505 ; tokLastEnd@var3505 =@expr1073773105 nullptr ;
12592: for (@expr1073773106 const Token *@expr1073773107 tok@var3506 =@expr1073773108 tokSQLStart@var3504 .@expr1073773109 tokAt (@expr1073773110 2 ) ; tok@var3506 !=@expr1073773111 nullptr ; tok@var3506 =@expr1073773112 tok@var3506 .@expr31289 next (@expr31290 ) ) {
12593: if (@expr1073773115 tokLastEnd@var3505 ==@expr1073773116 nullptr &&@expr1073773117 tok@var3506 .@expr31294 str (@expr31295 ) ==@expr1073773120 ";" ) {
12594: tokLastEnd@var3505 =@expr1073773121 tok@var3506 ; }
12595: else { if (@expr1073773122 tok@var3506 .@expr31294 str (@expr31295 ) ==@expr1073773125 "__CPPCHECK_EMBEDDED_SQL_EXEC__" ) {
12596: if (@expr1073773126 Token ::@expr1073773127 simpleMatch (@expr1073773128 tok@var3506 .@expr1073773129 tokAt (@expr1073773130 -2 ) , "END - __CPPCHECK_EMBEDDED_SQL_EXEC__ ;" ) ) {
12597: return tok@var3506 .@expr31289 next (@expr31290 ) ; }
12598: return tokLastEnd@var3505 ;
12599: } else { if (@expr1073773133 Token ::@expr1073773134 Match (@expr1073773135 tok@var3506 , "{|}|==|&&|!|^|<<|>>|++|+=|-=|/=|*=|>>=|<<=|~" ) ) {
12600: break ; } } }
12601: }
12602:
12603: return tokLastEnd@var3505 ;
12604: }
12605:
12606: void Tokenizer :: simplifyNestedNamespace ( )
12607: {
12608: if (@expr1073773136 !@expr1073773137 isCPP (@expr1073773138 ) ) {
12609: return ; }
12610:
12611: for (@expr1073773139 Token *@expr31316 tok@var3507 =@expr1073773141 list@var872 .@expr1073773142 front (@expr1073773143 ) ; tok@var3507 ; tok@var3507 =@expr1073773144 tok@var3507 .@expr1073773145 next (@expr1073773146 ) ) {
12612: if (@expr1073773147 Token ::@expr31324 Match (@expr1073773149 tok@var3507 , "namespace %name% ::" ) &&@expr1073773150 tok@var3507 .@expr1073773151 strAt (@expr1073773152 -1 ) !=@expr1073773153 "using" ) {
12613: Token * tok2@var3508 ; tok2@var3508 =@expr1073773154 tok@var3507 .@expr31331 tokAt (@expr31332 2 ) ;
12614:
12615:
12616: while (@expr1073773157 Token ::@expr31324 Match (@expr1073773159 tok2@var3508 , ":: %name%" ) ) {
12617: tok2@var3508 =@expr1073773160 tok2@var3508 .@expr31337 tokAt (@expr1073773162 2 ) ; }
12618:
12619: if (@expr1073773163 !@expr1073773164 tok2@var3508 ||@expr1073773165 tok2@var3508 .@expr31342 str (@expr31343 ) !=@expr1073773168 "{" ) {
12620: return ; }
12621:
12622: std ::@expr1073773169 stack < Token *@expr31316 > links@var3509 ;
12623: tok2@var3508 =@expr1073773171 tok@var3507 .@expr31331 tokAt (@expr31332 2 ) ;
12624:
12625: while (@expr1073773174 tok2@var3508 .@expr31342 str (@expr31343 ) ==@expr1073773177 "::" ) {
12626: links@var3509 .@expr1073773178 push (@expr1073773179 tok2@var3508 ) ;
12627: tok2@var3508 .@expr31342 str (@expr1073773181 "{" ) ;
12628: tok2@var3508 .@expr31358 insertToken (@expr1073773183 "namespace" ) ;
12629: tok2@var3508 =@expr1073773184 tok2@var3508 .@expr31337 tokAt (@expr1073773186 3 ) ;
12630: }
12631:
12632: tok@var3507 =@expr1073773187 tok2@var3508 ;
12633:
12634: if (@expr1073773188 !@expr31365 links@var3509 .@expr31366 empty (@expr31367 ) &&@expr1073773192 tok2@var3508 .@expr31342 str (@expr31343 ) ==@expr1073773195 "{" ) {
12635: tok2@var3508 =@expr1073773196 tok2@var3508 .@expr1073773197 link (@expr1073773198 ) ;
12636: while (@expr1073773199 !@expr31365 links@var3509 .@expr31366 empty (@expr31367 ) ) {
12637: tok2@var3508 .@expr31358 insertToken (@expr1073773204 "}" ) ;
12638: tok2@var3508 =@expr1073773205 tok2@var3508 .@expr1073773206 next (@expr1073773207 ) ;
12639: Token ::@expr1073773208 createMutualLinks (@expr1073773209 links@var3509 .@expr1073773210 top (@expr1073773211 ) , tok2@var3508 ) ;
12640: links@var3509 .@expr1073773212 pop (@expr1073773213 ) ;
12641: }
12642: }
12643: }
12644: }
12645: }
12646:
12647: void Tokenizer :: simplifyCoroutines ( )
12648: {
12649: if (@expr1073773214 !@expr1073773215 isCPP (@expr1073773216 ) ||@expr1073773217 mSettings@var879 .@expr1073773218 standards@var3567 .@expr1073773219 cpp@var3568 <@expr1073773220 Standards ::@expr1073773221 CPP20 ) {
12650: return ; }
12651: for (@expr1073773222 Token *@expr1073773223 tok@var3510 =@expr1073773224 list@var872 .@expr1073773225 front (@expr1073773226 ) ; tok@var3510 ; tok@var3510 =@expr1073773227 tok@var3510 .@expr31404 next (@expr31405 ) ) {
12652: if (@expr1073773230 !@expr1073773231 tok@var3510 .@expr1073773232 isName (@expr1073773233 ) ||@expr1073773234 !@expr1073773235 Token ::@expr31412 Match (@expr1073773237 tok@var3510 , "co_return|co_yield|co_await" ) ) {
12653: continue ; }
12654: Token * end@var3511 ; end@var3511 =@expr1073773238 tok@var3510 .@expr31404 next (@expr31405 ) ;
12655: while (@expr1073773241 end@var3511 &&@expr1073773242 end@var3511 .@expr1073773243 str (@expr1073773244 ) !=@expr1073773245 ";" ) {
12656: if (@expr1073773246 Token ::@expr31412 Match (@expr1073773248 end@var3511 , "[({[]" ) ) {
12657: end@var3511 =@expr1073773249 end@var3511 .@expr1073773250 link (@expr1073773251 ) ; }
12658: else { if (@expr1073773252 Token ::@expr31412 Match (@expr1073773254 end@var3511 , "[)]}]" ) ) {
12659: break ; } }
12660: end@var3511 =@expr1073773255 end@var3511 .@expr1073773256 next (@expr1073773257 ) ;
12661: }
12662: if (@expr1073773258 Token ::@expr1073773259 simpleMatch (@expr1073773260 end@var3511 , ";" ) ) {
12663: tok@var3510 .@expr1073773261 insertToken (@expr1073773262 "(" ) ;
12664: end@var3511 .@expr31439 previous (@expr31440 ) .@expr1073773265 insertToken (@expr1073773266 ")" ) ;
12665: Token ::@expr1073773267 createMutualLinks (@expr1073773268 tok@var3510 .@expr31404 next (@expr31405 ) , end@var3511 .@expr31439 previous (@expr31440 ) ) ;
12666: }
12667: }
12668: }
12669:
12670: static bool sameTokens ( const Token * first@var3512 , const Token * last@var3513 , const Token * other@var3514 )
12671: {
12672: while (@expr1073773273 other@var3514 &&@expr1073773274 first@var3512 .@expr1073773275 str (@expr1073773276 ) ==@expr1073773277 other@var3514 .@expr1073773278 str (@expr1073773279 ) ) {
12673: if (@expr1073773280 first@var3512 ==@expr1073773281 last@var3513 ) {
12674: return true ; }
12675: first@var3512 =@expr1073773282 first@var3512 .@expr1073773283 next (@expr1073773284 ) ;
12676: other@var3514 =@expr1073773285 other@var3514 .@expr1073773286 next (@expr1073773287 ) ;
12677: }
12678:
12679: return false ;
12680: }
12681:
12682: static bool alreadyHasNamespace ( const Token * first@var3515 , const Token * last@var3516 , const Token * end@var3517 )
12683: {
12684: while (@expr1073773288 end@var3517 &&@expr1073773289 last@var3516 .@expr1073773290 str (@expr1073773291 ) ==@expr1073773292 end@var3517 .@expr1073773293 str (@expr1073773294 ) ) {
12685: if (@expr1073773295 first@var3515 ==@expr1073773296 last@var3516 ) {
12686: return true ; }
12687: last@var3516 =@expr1073773297 last@var3516 .@expr1073773298 previous (@expr1073773299 ) ;
12688: end@var3517 =@expr1073773300 end@var3517 .@expr1073773301 previous (@expr1073773302 ) ;
12689: }
12690:
12691: return false ;
12692: }
12693:
12694: static Token * deleteAlias ( Token * tok@var3518 )
12695: {
12696: Token ::@expr1073773303 eraseTokens (@expr1073773304 tok@var3518 , Token ::@expr1073773305 findsimplematch (@expr1073773306 tok@var3518 , ";" ) ) ;
12697:
12698:
12699: tok@var3518 .@expr31483 deleteThis (@expr31484 ) ;
12700:
12701:
12702: tok@var3518 .@expr31483 deleteThis (@expr31484 ) ;
12703:
12704: return tok@var3518 ;
12705: }
12706:
12707: void Tokenizer :: simplifyNamespaceAliases ( )
12708: {
12709: if (@expr1073773311 !@expr1073773312 isCPP (@expr1073773313 ) ) {
12710: return ; }
12711:
12712: int scope@var3519 ; scope@var3519 =@expr1073773314 0 ;
12713:
12714: for (@expr1073773315 Token *@expr1073773316 tok@var3520 =@expr1073773317 list@var872 .@expr1073773318 front (@expr1073773319 ) ; tok@var3520 ; tok@var3520 =@expr1073773320 tok@var3520 .@expr31497 next (@expr31498 ) ) {
12715: if (@expr1073773323 tok@var3520 .@expr31500 str (@expr31501 ) ==@expr1073773326 "{" ) {
12716: scope@var3519 ++@expr1073773327 ; }
12717: else { if (@expr1073773328 tok@var3520 .@expr31500 str (@expr31501 ) ==@expr1073773331 "}" ) {
12718: scope@var3519 --@expr1073773332 ; }
12719: else { if (@expr1073773333 Token ::@expr31510 Match (@expr1073773335 tok@var3520 , "namespace %name% =" ) ) {
12720: const std ::@expr1073773336 string name@var3521 (@expr1073773337 tok@var3520 .@expr31497 next (@expr31498 ) .@expr1073773340 str (@expr1073773341 ) ) ;
12721: Token * tokNameStart@var3522 ; tokNameStart@var3522 =@expr1073773342 tok@var3520 .@expr1073773343 tokAt (@expr1073773344 3 ) ;
12722: Token * tokNameEnd@var3523 ; tokNameEnd@var3523 =@expr1073773345 tokNameStart@var3522 ;
12723:
12724: while (@expr1073773346 tokNameEnd@var3523 &&@expr1073773347 tokNameEnd@var3523 .@expr31524 next (@expr31525 ) &&@expr1073773350 tokNameEnd@var3523 .@expr31524 next (@expr31525 ) .@expr1073773353 str (@expr1073773354 ) !=@expr1073773355 ";" ) {
12725: tokNameEnd@var3523 =@expr1073773356 tokNameEnd@var3523 .@expr31524 next (@expr31525 ) ; }
12726:
12727: if (@expr1073773359 !@expr1073773360 tokNameEnd@var3523 ) {
12728: return ; }
12729:
12730: int endScope@var3524 ; endScope@var3524 =@expr1073773361 scope@var3519 ;
12731: Token * tokLast@var3525 ; tokLast@var3525 =@expr1073773362 tokNameEnd@var3523 .@expr31524 next (@expr31525 ) ;
12732: Token * tokNext@var3526 ; tokNext@var3526 =@expr1073773365 tokLast@var3525 .@expr1073773366 next (@expr1073773367 ) ;
12733: Token * tok2@var3527 ; tok2@var3527 =@expr1073773368 tokNext@var3526 ;
12734:
12735: while (@expr1073773369 tok2@var3527 &&@expr1073773370 endScope@var3524 >=@expr1073773371 scope@var3519 ) {
12736: if (@expr1073773372 Token ::@expr31549 simpleMatch (@expr1073773374 tok2@var3527 , "{" ) ) {
12737: endScope@var3524 ++@expr1073773375 ; }
12738: else { if (@expr1073773376 Token ::@expr31549 simpleMatch (@expr1073773378 tok2@var3527 , "}" ) ) {
12739: endScope@var3524 --@expr1073773379 ; }
12740: else { if (@expr1073773380 tok2@var3527 .@expr31557 str (@expr1073773382 ) ==@expr1073773383 name@var3521 ) {
12741: if (@expr1073773384 Token ::@expr31510 Match (@expr1073773386 tok2@var3527 .@expr31563 previous (@expr31564 ) , "namespace %name% =" ) ) {
12742:
12743: if (@expr1073773389 sameTokens (@expr1073773390 tokNameStart@var3522 , tokNameEnd@var3523 , tok2@var3527 .@expr1073773391 tokAt (@expr1073773392 2 ) ) ) {
12744:
12745: tok2@var3527 =@expr1073773393 deleteAlias (@expr31570 tok2@var3527 .@expr31563 previous (@expr31564 ) ) ;
12746: continue ;
12747: } else {
12748:
12749:
12750: if (@expr1073773397 endScope@var3524 ==@expr1073773398 scope@var3519 ) {
12751:
12752: tok2@var3527 =@expr1073773399 deleteAlias (@expr31570 tok2@var3527 .@expr31563 previous (@expr31564 ) ) ;
12753: }
12754:
12755:
12756: else {
12757:
12758: tok2@var3527 =@expr1073773403 deleteAlias (@expr31570 tok2@var3527 .@expr31563 previous (@expr31564 ) ) ;
12759: }
12760: continue ;
12761: }
12762: }
12763:
12764: if (@expr1073773407 tok2@var3527 .@expr1073773408 strAt (@expr1073773409 1 ) ==@expr1073773410 "::" &&@expr1073773411 !@expr1073773412 alreadyHasNamespace (@expr1073773413 tokNameStart@var3522 , tokNameEnd@var3523 , tok2@var3527 ) ) {
12765: tok2@var3527 .@expr31557 str (@expr1073773415 tokNameStart@var3522 .@expr1073773416 str (@expr1073773417 ) ) ;
12766: Token * tok3@var3528 ; tok3@var3528 =@expr1073773418 tokNameStart@var3522 ;
12767: while (@expr1073773419 tok3@var3528 !=@expr1073773420 tokNameEnd@var3523 ) {
12768: tok2@var3527 .@expr1073773421 insertToken (@expr1073773422 tok3@var3528 .@expr31599 next (@expr31600 ) .@expr1073773425 str (@expr1073773426 ) ) ;
12769: tok2@var3527 =@expr1073773427 tok2@var3527 .@expr31604 next (@expr31605 ) ;
12770: tok3@var3528 =@expr1073773430 tok3@var3528 .@expr31599 next (@expr31600 ) ;
12771: }
12772: }
12773: } } }
12774: tok2@var3527 =@expr1073773433 tok2@var3527 .@expr31604 next (@expr31605 ) ;
12775: }
12776:
12777: if (@expr1073773436 tok@var3520 .@expr31613 previous (@expr31614 ) &&@expr1073773439 tokNext@var3526 ) {
12778: Token ::@expr31616 eraseTokens (@expr1073773441 tok@var3520 .@expr31613 previous (@expr31614 ) , tokNext@var3526 ) ;
12779: tok@var3520 =@expr1073773444 tokNext@var3526 .@expr1073773445 previous (@expr1073773446 ) ;
12780: } else { if (@expr1073773447 tok@var3520 .@expr31613 previous (@expr31614 ) ) {
12781: Token ::@expr31616 eraseTokens (@expr1073773451 tok@var3520 .@expr31613 previous (@expr31614 ) , tokLast@var3525 ) ;
12782: tok@var3520 =@expr1073773454 tokLast@var3525 ;
12783: } else { if (@expr1073773455 tokNext@var3526 ) {
12784: Token ::@expr31616 eraseTokens (@expr1073773457 tok@var3520 , tokNext@var3526 ) ;
12785: tok@var3520 .@expr31634 deleteThis (@expr31635 ) ;
12786: } else {
12787: Token ::@expr31616 eraseTokens (@expr1073773461 tok@var3520 , tokLast@var3525 ) ;
12788: tok@var3520 .@expr31634 deleteThis (@expr31635 ) ;
12789: } } }
12790: } } }
12791: }
12792: }
12793:
12794:
12795: Tokenizer :: VariableMap :: VariableMap ( ) : mVarId@var768 ( 0 ) { }
12796:
12797: void Tokenizer :: VariableMap :: enterScope ( )
12798: {
12799: mScopeInfo@var767 .@expr1073773464 push (@expr1073773465 std ::@expr1073773466 list < std ::@expr31643 pair < std ::@expr31643 string , int > > (@expr1073773469 ) ) ;
12800: }
12801:
12802: bool Tokenizer :: VariableMap :: leaveScope ( )
12803: {
12804: if (@expr1073773470 mScopeInfo@var767 .@expr1073773471 empty (@expr1073773472 ) ) {
12805: return false ; }
12806:
12807: for (@expr1073773473 const std ::@expr31650 pair < std ::@expr31650 string , int > &@expr1073773476 outerVariable@var3529 :@expr1073773477 mScopeInfo@var767 .@expr1073773478 top (@expr1073773479 ) ) {
12808: if (@expr1073773480 outerVariable@var3529 .@expr31657 second@var3530 !=@expr1073773482 0 ) {
12809: mVariableId@var766 [@expr1073773483 outerVariable@var3529 .@expr31660 first@var3531 ] =@expr1073773485 outerVariable@var3529 .@expr31657 second@var3530 ; }
12810: else {
12811: mVariableId@var766 .@expr1073773487 erase (@expr1073773488 outerVariable@var3529 .@expr31660 first@var3531 ) ; }
12812: }
12813: mScopeInfo@var767 .@expr1073773490 pop (@expr1073773491 ) ;
12814: return true ;
12815: }
12816:
12817: void Tokenizer :: VariableMap :: addVariable ( const std :: string & varname@var3532 )
12818: {
12819: if (@expr1073773492 mScopeInfo@var767 .@expr1073773493 empty (@expr1073773494 ) ) {
12820: mVariableId@var766 [@expr31671 varname@var3532 ] =@expr1073773496 ++@expr1073773497 mVarId@var768 ;
12821: return ;
12822: }
12823: std ::@expr1073773498 map < std ::@expr31675 string , int > ::@expr1073773500 iterator it@var3533 ; it@var3533 =@expr1073773501 mVariableId@var766 .@expr1073773502 find (@expr1073773503 varname@var3532 ) ;
12824: if (@expr1073773504 it@var3533 ==@expr1073773505 mVariableId@var766 .@expr1073773506 end (@expr1073773507 ) ) {
12825: mScopeInfo@var767 .@expr31684 top (@expr31685 ) .@expr31686 push_back (@expr1073773511 std ::@expr31688 pair < std ::@expr31675 string , int > (@expr1073773514 varname@var3532 , 0 ) ) ;
12826: mVariableId@var766 [@expr31671 varname@var3532 ] =@expr1073773516 ++@expr1073773517 mVarId@var768 ;
12827: return ;
12828: }
12829: mScopeInfo@var767 .@expr31684 top (@expr31685 ) .@expr31686 push_back (@expr1073773521 std ::@expr31688 pair < std ::@expr31675 string , int > (@expr1073773524 varname@var3532 , it@var3533 .@expr31701 second@var3534 ) ) ;
12830: it@var3533 .@expr31701 second@var3534 =@expr1073773527 ++@expr1073773528 mVarId@var768 ;
12831: }
12832:
12833: bool Tokenizer :: VariableMap :: hasVariable ( const std :: string & varname@var3535 ) const
12834: {
12835: return mVariableId@var766 .@expr1073773529 find (@expr1073773530 varname@var3535 ) !=@expr1073773531 mVariableId@var766 .@expr1073773532 end (@expr1073773533 ) ;
12836: }
12837:
12838: bool Tokenizer :: hasIfdef ( const Token * start@var3536 , const Token * end@var3537 ) const
12839: {
12840: if (@expr1073773534 !@expr1073773535 mPreprocessor@var895 ) {
12841: return false ; }
12842: for (@expr1073773536 const Directive &@expr1073773537 d@var3538 :@expr1073773538 mPreprocessor@var895 .@expr1073773539 getDirectives (@expr1073773540 ) ) {
12843: if (@expr1073773541 d@var3538 .@expr1073773542 str@var3539 .@expr1073773543 compare (@expr1073773544 0 , 3 , "#if" ) ==@expr1073773545 0 &&@expr1073773546
12844: d@var3538 .@expr31723 linenr@var3540 >=@expr1073773548 start@var3536 .@expr1073773549 linenr (@expr1073773550 ) &&@expr1073773551
12845: d@var3538 .@expr31723 linenr@var3540 <=@expr1073773553 end@var3537 .@expr1073773554 linenr (@expr1073773555 ) &&@expr1073773556
12846: start@var3536 .@expr31733 fileIndex (@expr31734 ) <@expr1073773559 list@var872 .@expr31736 getFiles (@expr31737 ) .@expr1073773562 size (@expr1073773563 ) &&@expr1073773564
12847: d@var3538 .@expr1073773565 file@var3541 ==@expr1073773566 list@var872 .@expr31736 getFiles (@expr31737 ) [@expr1073773569 start@var3536 .@expr31733 fileIndex (@expr31734 ) ] ) {
12848: return true ; }
12849: }
12850: return false ;
12851: }

##file cppcheck-2.8/lib/settings.h

11:
|
48:
49: class SimpleEnableGroup<Severity::SeverityType> {
50: uint32_t mFlags@var3542 ; mFlags@var3542 = 0 ;
51: public:
52: uint32_t intValue ( ) const {
53: return mFlags@var3542 ;
54: }
55: void clear ( ) {
56: mFlags@var3542 =@expr1073773572 0 ;
57: }
58: void fill ( ) {
59: mFlags@var3542 =@expr1073773573 0xFFFFFFFF ;
60: }
61: void setEnabledAll ( bool enabled@var3543 ) {
62: if (@expr1073773574 enabled@var3543 ) {
63: fill (@expr1073773575 ) ; }
64: else {
65: clear (@expr1073773576 ) ; }
66: }
67: bool isEnabled ( Severity :: SeverityType flag@var3544 ) const {
68: return (@expr31753 mFlags@var3542 &@expr1073773578 (@expr31753 1U <<@expr1073773580 (@expr1073773581 uint32_t ) flag@var3544 ) ) !=@expr1073773582 0 ;
69: }
70: void enable ( Severity :: SeverityType flag@var3545 ) {
71: mFlags@var3542 |=@expr1073773583 (@expr1073773584 1U <<@expr1073773585 (@expr1073773586 uint32_t ) flag@var3545 ) ;
72: }
73: void disable ( Severity :: SeverityType flag@var3546 ) {
74: mFlags@var3542 &=@expr1073773587 ~@expr1073773588 (@expr1073773589 1U <<@expr1073773590 (@expr1073773591 uint32_t ) flag@var3546 ) ;
75: }
76: void setEnabled ( Severity :: SeverityType flag@var3547 , bool enabled@var3548 ) {
77: if (@expr1073773592 enabled@var3548 ) {
78: enable (@expr1073773593 flag@var3547 ) ; }
79: else {
80: disable (@expr1073773594 flag@var3547 ) ; }
81: }
82: } ;
49: class SimpleEnableGroup<Certainty::CertaintyLevel> {
50: uint32_t mFlags@var3549 ; mFlags@var3549 = 0 ;
51: public:
52: uint32_t intValue ( ) const {
53: return mFlags@var3549 ;
54: }
55: void clear ( ) {
56: mFlags@var3549 =@expr1073773595 0 ;
57: }
58: void fill ( ) {
59: mFlags@var3549 =@expr1073773596 0xFFFFFFFF ;
60: }
61: void setEnabledAll ( bool enabled@var3550 ) {
62: if (@expr1073773597 enabled@var3550 ) {
63: fill (@expr1073773598 ) ; }
64: else {
65: clear (@expr1073773599 ) ; }
66: }
67: bool isEnabled ( Certainty :: CertaintyLevel flag@var3551 ) const {
68: return (@expr31776 mFlags@var3549 &@expr1073773601 (@expr31776 1U <<@expr1073773603 (@expr1073773604 uint32_t ) flag@var3551 ) ) !=@expr1073773605 0 ;
69: }
70: void enable ( Certainty :: CertaintyLevel flag@var3552 ) {
71: mFlags@var3549 |=@expr1073773606 (@expr1073773607 1U <<@expr1073773608 (@expr1073773609 uint32_t ) flag@var3552 ) ;
72: }
73: void disable ( Certainty :: CertaintyLevel flag@var3553 ) {
74: mFlags@var3549 &=@expr1073773610 ~@expr1073773611 (@expr1073773612 1U <<@expr1073773613 (@expr1073773614 uint32_t ) flag@var3553 ) ;
75: }
76: void setEnabled ( Certainty :: CertaintyLevel flag@var3554 , bool enabled@var3555 ) {
77: if (@expr1073773615 enabled@var3555 ) {
78: enable (@expr1073773616 flag@var3554 ) ; }
79: else {
80: disable (@expr1073773617 flag@var3554 ) ; }
81: }
82: } ;
49: class SimpleEnableGroup<Checks::CheckList> {
50: uint32_t mFlags@var3556 ; mFlags@var3556 = 0 ;
51: public:
52: uint32_t intValue ( ) const {
53: return mFlags@var3556 ;
54: }
55: void clear ( ) {
56: mFlags@var3556 =@expr1073773618 0 ;
57: }
58: void fill ( ) {
59: mFlags@var3556 =@expr1073773619 0xFFFFFFFF ;
60: }
61: void setEnabledAll ( bool enabled@var3557 ) {
62: if (@expr1073773620 enabled@var3557 ) {
63: fill (@expr1073773621 ) ; }
64: else {
65: clear (@expr1073773622 ) ; }
66: }
67: bool isEnabled ( Checks :: CheckList flag@var3558 ) const {
68: return (@expr31799 mFlags@var3556 &@expr1073773624 (@expr31799 1U <<@expr1073773626 (@expr1073773627 uint32_t ) flag@var3558 ) ) !=@expr1073773628 0 ;
69: }
70: void enable ( Checks :: CheckList flag@var3559 ) {
71: mFlags@var3556 |=@expr1073773629 (@expr1073773630 1U <<@expr1073773631 (@expr1073773632 uint32_t ) flag@var3559 ) ;
72: }
73: void disable ( Checks :: CheckList flag@var3560 ) {
74: mFlags@var3556 &=@expr1073773633 ~@expr1073773634 (@expr1073773635 1U <<@expr1073773636 (@expr1073773637 uint32_t ) flag@var3560 ) ;
75: }
76: void setEnabled ( Checks :: CheckList flag@var3561 , bool enabled@var3562 ) {
77: if (@expr1073773638 enabled@var3562 ) {
78: enable (@expr1073773639 flag@var3561 ) ; }
79: else {
80: disable (@expr1073773640 flag@var3561 ) ; }
81: }
82: } ;



##Value flow
Line 36
  AST always 0
  SYNTAX always 1
  UNKNOWN_MACRO always 2
  INTERNAL always 3
  LIMIT always 4
  INSTANTIATION always 5
Line 37
  = always 3
  INTERNAL always 3
Line 47
  normal always 0
  inconclusive always 1
  safe always 2
  experimental always 3
Line 54
  unusedFunction always 0
  missingInclude always 1
  internalCheck always 2
Line 68
  none always 0
Line 74
  error always 1
Line 80
  warning always 2
Line 87
  style always 3
Line 93
  performance always 4
Line 101
  portability always 5
Line 108
  information always 6
Line 113
  debug always 7
Line 121
  ( possible lifetime[SubObject]=(cweId)
  cweId always !<=-1
  id always !<=-1
  cweId always !<=-1
Line 122
  id always !<=-1
Line 43
  INT always 0
  LONG always 1
  LONGLONG always 2
  FLOAT always 3
Line 44
  mIsUnsigned always {!<=-1,!>=2}
Line 51
  ( always {!<=-1,!>=2}
Line 52
  return always {!<=-1,!>=2}
  != always {!<=-1,!>=2}
  :: always 3
  FLOAT always 3
Line 54
  ( always {!<=-1,!>=2}
Line 55
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 3
  FLOAT always 3
Line 59
  ( always {!<=-1,!>=2}
Line 74
  ( always !<=-1
Line 78
  value possible {symbolic=(num1+1)@21,>=1@75,>=symbolic=(start+1)@220}
Line 83
  ( always {!<=-1,!>=2}
Line 84
  ( always {!<=-1,!>=2}
Line 85
  ( always {!<=-1,!>=2}
Line 86
  ( always {!<=-1,!>=2}
Line 87
  ( always {!<=-1,!>=2}
Line 88
  ( always {!<=-1,!>=2}
Line 89
  ( always {!<=-1,!>=2}
Line 90
  ( always {!<=-1,!>=2}
Line 91
  ( always {!<=-1,!>=2}
Line 92
  ( always {!<=-1,!>=2}
Line 102
  ( always {!<=-1,!>=2}
  , always 1
  supportMicrosoftExtensions always {!<=-1,!>=2}
  = always 1
  true always 1
Line 115
  ( always !<=-1
Line 116
  ( always {!<=-1,!>=2}
Line 117
  ( always {!<=-1,!>=2}
Line 118
  ( always {!<=-1,!>=2}
Line 119
  ( always {!<=-1,!>=2}
Line 120
  ( always {!<=-1,!>=2}
Line 121
  ( always {!<=-1,!>=2}
Line 122
  ( always {!<=-1,!>=2}
Line 128
  ( always {!<=-1,!>=2}
Line 130
  ( always !<=-1
Line 137
  ( always {!<=-1,!>=2}
  , always !<=-1
  :: always !<=-1
  iPos always !<=-1
Line 66
  ( always {!<=-1,!>=2}
Line 67
  return always {!<=-1,!>=2}
  < always {!<=-1,!>=2}
Line 73
  ( always {!<=-1,!>=2}
Line 74
  return always {!<=-1,!>=2}
  ( always !<=-1
  == always {!<=-1,!>=2}
  1 always 1
Line 80
  result always {!<=-1,!>=2}
Line 81
  result always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  > always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  x {!>=symbolic=(y+1),<=symbolic=(y)}
  < always {!<=-1,!>=2}
  y {!<=symbolic=(x-1),>=symbolic=(x)}
Line 88
  Upper always 0
  Lower always 1
  Point always 2
Line 90
  = always 0
  0 always 0
Line 91
  :: always 12
  INT always 12
Line 94
  nullptr always 0
Line 95
  0.0 always 0
Line 98
  nullptr always 0
Line 99
  0U always 0
Line 100
  safe always {!<=-1,!>=2}
  false always 0
Line 101
  conditional always {!<=-1,!>=2}
  false always 0
Line 102
  macro always {!<=-1,!>=2}
  false always 0
Line 103
  defaultArg always {!<=-1,!>=2}
  false always 0
Line 104
  0 always 0
Line 105
  0 always 0
Line 108
  nullptr always 0
Line 117
  ( always {!<=-1,!>=2}
Line 118
  != always {!<=-1,!>=2}
Line 119
  return always {!<=-1,!>=2}
  false always 0
Line 120
  valueType always symbolic=(rhs.valueType)
Line 121
  :: always 0
  INT always 0
Line 122
  :: always 5
  CONTAINER_SIZE always 5
Line 123
  :: always 7
  BUFFER_SIZE always 7
Line 124
  :: always 8
  ITERATOR_START always 8
Line 125
  :: always 9
  ITERATOR_END always 9
Line 126
  != always {!<=-1,!>=2}
Line 127
  return always {!<=-1,!>=2}
  false always 0
Line 129
  :: always 1
  TOK always 1
Line 130
  != always {!<=-1,!>=2}
Line 131
  return always {!<=-1,!>=2}
  false always 0
Line 133
  :: always 2
  FLOAT always 2
Line 135
  > always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  floatValue possible <=symbolic=(rhs.floatValue)
  < always {!<=-1,!>=2}
  . possible >=symbolic=(floatValue)
Line 136
  return always {!<=-1,!>=2}
  false always 0
Line 138
  :: always 3
  MOVED always 3
Line 139
  != always {!<=-1,!>=2}
Line 140
  return always {!<=-1,!>=2}
  false always 0
Line 142
  :: always 4
  UNINIT always 4
Line 144
  :: always 6
  LIFETIME always 6
Line 145
  != always {!<=-1,!>=2}
Line 146
  return always {!<=-1,!>=2}
  false always 0
Line 148
  :: always 10
  SYMBOLIC always 10
Line 149
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 150
  return always {!<=-1,!>=2}
  false always 0
Line 151
  != always {!<=-1,!>=2}
Line 152
  return always {!<=-1,!>=2}
  false always 0
Line 155
  return always {!<=-1,!>=2}
  true always 1
Line 161
  :: always 0
  INT always 0
Line 162
  :: always 10
  SYMBOLIC always 10
Line 163
  :: always 7
  BUFFER_SIZE always 7
Line 164
  :: always 5
  CONTAINER_SIZE always 5
Line 165
  :: always 8
  ITERATOR_START always 8
Line 166
  :: always 9
  ITERATOR_END always 9
Line 170
  :: always 2
  FLOAT always 2
Line 174
  :: always 4
  UNINIT always 4
Line 175
  :: always 1
  TOK always 1
Line 176
  :: always 6
  LIFETIME always 6
Line 177
  :: always 3
  MOVED always 3
Line 185
  result always {!<=-1,!>=2}
Line 186
  result always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
Line 190
  result always {!<=-1,!>=2}
Line 192
  ( possible {lifetime[Object]=(x),lifetime[Object]=(result),lifetime[Object]=(compare)}
  ( possible lifetime[Object]=(result)
  result always {!<=-1,!>=2}
  ( possible lifetime[Object]=(compare)
Line 197
  ( always {!<=-1,!>=2}
Line 198
  ! always {!<=-1,!>=2}
  this always !0
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
Line 199
  this always !0
  == always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  this always !0
Line 200
  result always {!<=-1,!>=2}
  result always {!<=-1,!>=2}
  = always 0
  false always 0
Line 202
  this always !0
Line 203
  ( possible {lifetime[Object]=(result),lifetime[Object]=(rhs),lifetime[Object]=(compare)}
  ( possible lifetime[Object]=(result)
  result always 0
  ( possible lifetime[Object]=(rhs)
  ( possible lifetime[Object]=(compare)
Line 204
  return always {!<=-1,!>=2}
  result {!<=-1,!>=2,0}
Line 207
  ( always {!<=-1,!>=2}
Line 208
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 209
  return always {!<=-1,!>=2}
  false always 0
Line 211
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 212
  == always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 213
  == always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 214
  conditional always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  . always {!<=-1,!>=2}
  conditional always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 215
  defaultArg always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  . always {!<=-1,!>=2}
  defaultArg always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 216
  == always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 217
  == always {!<=-1,!>=2}
Line 220
  ( always {!<=-1,!>=2}
Line 221
  return always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  this always !0
  == always {!<=-1,!>=2}
Line 225
  ( always {!<=-1,!>=2}
Line 226
  result always {!<=-1,!>=2}
  result always {!<=-1,!>=2}
  = always 0
  false always 0
Line 227
  this always !0
  ( possible {lifetime[Object]=(x),lifetime[Object]=(result)}
  ( possible lifetime[Object]=(result)
  result always 0
Line 228
  return always {!<=-1,!>=2}
  result {!<=-1,!>=2,0}
Line 232
  bound possible 0
  == {!<=-1,!>=2,0}
  :: always 1
  Lower always 1
Line 233
  this always !0
Line 234
  bound always !1
  == always {!<=-1,!>=2}
  :: always 0
  Upper always 0
Line 235
  this always !0
Line 239
  bound possible 0
  == {!<=-1,!>=2,0}
  :: always 1
  Lower always 1
Line 240
  = always 0
  :: always 0
  Upper always 0
Line 241
  bound always !1
  == always {!<=-1,!>=2}
  :: always 0
  Upper always 0
Line 242
  = always 1
  :: always 1
  Lower always 1
Line 255
  INT always 0
Line 256
  TOK always 1
Line 257
  FLOAT always 2
Line 258
  MOVED always 3
Line 259
  UNINIT always 4
Line 260
  CONTAINER_SIZE always 5
Line 261
  LIFETIME always 6
Line 262
  BUFFER_SIZE always 7
Line 263
  ITERATOR_START always 8
Line 264
  ITERATOR_END always 9
Line 265
  SYMBOLIC always 10
Line 267
  ( always {!<=-1,!>=2}
Line 268
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 0
  INT always 0
Line 270
  ( always {!<=-1,!>=2}
Line 271
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 1
  TOK always 1
Line 273
  ( always {!<=-1,!>=2}
Line 274
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 2
  FLOAT always 2
Line 276
  ( always {!<=-1,!>=2}
Line 277
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 3
  MOVED always 3
Line 279
  ( always {!<=-1,!>=2}
Line 280
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 4
  UNINIT always 4
Line 282
  ( always {!<=-1,!>=2}
Line 283
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 5
  CONTAINER_SIZE always 5
Line 285
  ( always {!<=-1,!>=2}
Line 286
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 6
  LIFETIME always 6
Line 288
  ( always {!<=-1,!>=2}
Line 289
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 7
  BUFFER_SIZE always 7
Line 291
  ( always {!<=-1,!>=2}
Line 292
  return always {!<=-1,!>=2}
  valueType possible 9
  == {!<=-1,!>=2,0}
  :: always 8
  ITERATOR_START always 8
  || always {!<=-1,!>=2}
  valueType always !8
  == always {!<=-1,!>=2}
  :: always 9
  ITERATOR_END always 9
Line 294
  ( always {!<=-1,!>=2}
Line 295
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 8
  ITERATOR_START always 8
Line 297
  ( always {!<=-1,!>=2}
Line 298
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 9
  ITERATOR_END always 9
Line 300
  ( always {!<=-1,!>=2}
Line 301
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 10
  SYMBOLIC always 10
Line 304
  ( always {!<=-1,!>=2}
Line 305
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 6
  LIFETIME always 6
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
Line 308
  ( always {!<=-1,!>=2}
Line 309
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 6
  LIFETIME always 6
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 1
  Argument always 1
Line 312
  ( always {!<=-1,!>=2}
Line 313
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 6
  LIFETIME always 6
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 2
  SubFunction always 2
Line 316
  ( always {!<=-1,!>=2}
Line 317
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 333
  NonMovedVariable always 0
  MovedVariable always 1
  ForwardedVariable always 2
Line 347
  safe always {!<=-1,!>=2}
Line 350
  conditional always {!<=-1,!>=2}
Line 353
  macro always {!<=-1,!>=2}
Line 356
  defaultArg always {!<=-1,!>=2}
Line 373
  Object always 0
Line 375
  SubObject always 1
Line 377
  Lambda always 2
Line 379
  Iterator always 3
Line 381
  Address always 4
Line 384
  Local always 0
  Argument always 1
  SubFunction always 2
  ThisPointer always 3
  ThisValue always 4
Line 394
  Possible always 0
Line 396
  Known always 1
Line 398
  Inconclusive always 2
Line 400
  Impossible always 3
Line 404
  = always 1
  :: always 1
  Known always 1
Line 407
  ( always {!<=-1,!>=2}
Line 408
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 1
  Known always 1
Line 415
  ( always {!<=-1,!>=2}
Line 416
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
Line 419
  ( always {!<=-1,!>=2}
Line 420
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 3
  Impossible always 3
Line 424
  = always 3
  :: always 3
  Impossible always 3
Line 427
  inconclusive always {!<=-1,!>=2}
  = always 1
  true always 1
Line 428
  inconclusive always {!<=-1,!>=2}
Line 429
  = always 2
  :: always 2
  Inconclusive always 2
Line 432
  ( always {!<=-1,!>=2}
Line 433
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 2
  Inconclusive always 2
Line 437
  ( always {!<=-1,!>=2}
Line 441
  ( always {!<=-1,!>=2}
Line 442
  return always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  defaultArg always {!<=-1,!>=2}
Line 445
  ( always {!<=-1,!>=2}
Line 456
  ( always !<=-1
Line 460
  ( always {!<=-1,!>=2}
Line 462
  possible always {!<=-1,!>=2}
  = always 1
  true always 1
Line 467
  ( always {!<=-1,!>=2}
  , always 0
  = always 0
  nullptr always 0
  , always 20
  = always 20
  20 always 20
Line 471
  addressOf always {!<=-1,!>=2}
Line 473
  inconclusive always {!<=-1,!>=2}
Line 475
  nullptr always 0
  addressOf always {!<=-1,!>=2}
  false always 0
  inconclusive always {!<=-1,!>=2}
  false always 0
Line 478
  addressOf always {!<=-1,!>=2}
  false always 0
  ( possible lifetime[Object]=(errorPath)
  inconclusive always {!<=-1,!>=2}
  false always 0
Line 481
  addressOf always {!<=-1,!>=2}
Line 482
  addressOf always {!<=-1,!>=2}
  addressOf always {!<=-1,!>=2}
  ( possible lifetime[Object]=(errorPath)
  inconclusive always {!<=-1,!>=2}
  false always 0
Line 485
  b always {!<=-1,!>=2}
Line 487
  . always {!<=-1,!>=2}
  addressOf always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  b always {!<=-1,!>=2}
Line 491
  b always {!<=-1,!>=2}
Line 493
  . always {!<=-1,!>=2}
  inconclusive always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  b always {!<=-1,!>=2}
Line 511
  escape always {!<=-1,!>=2}
  = always 0
  false always 0
Line 514
  ( always {!<=-1,!>=2}
Line 516
  , always 0
  = always 0
  nullptr always 0
Line 520
  ( always {!<=-1,!>=2}
Line 526
  , always 0
  inconclusive always {!<=-1,!>=2}
  = always 0
  false always 0
Line 529
  inconclusive always {!<=-1,!>=2}
  = always 0
  false always 0
Line 530
  = always 0
  0 always 0
Line 532
  , always 0
  = always 0
  nullptr always 0
  , always 1
  smallest always {!<=-1,!>=2}
  = always 1
  true always 1
Line 62
  ( always !<=-1
Line 74
  mFlags always !<=-1
Line 77
  fIsClass always 1
  = always 1
  1 always 1
  << always 1
  0 always 0
  , always 2
Line 78
  fIsFunction always 2
  = always 2
  1 always 1
  << always 2
  1 always 1
  , always 4
Line 79
  fIsVariable always 4
  = always 4
  1 always 1
  << always 4
  2 always 2
  , always 8
Line 80
  fIsAlias always 8
  = always 8
  1 always 1
  << always 8
  3 always 3
  , always 16
Line 81
  fIsSpecialization always 16
  = always 16
  1 always 1
  << always 16
  4 always 4
  , always 32
Line 82
  fIsPartialSpecialization always 32
  = always 32
  1 always 1
  << always 32
  5 always 5
  , always 64
Line 83
  fIsForwardDeclaration always 64
  = always 64
  1 always 1
  << always 64
  6 always 6
  , always 128
Line 84
  fIsVariadic always 128
  = always 128
  1 always 1
  << always 128
  7 always 7
  , always 256
Line 85
  fIsFriend always 256
  = always 256
  1 always 1
  << always 256
  8 always 8
  , always 7
Line 86
  fFamilyMask always 7
  = always 7
  fIsClass always 1
  | always 3
  fIsFunction always 2
  | always 7
  fIsVariable always 4
Line 89
  state always {!<=-1,!>=2}
Line 90
  fIsClass always 1
  state always {!<=-1,!>=2}
Line 92
  state always {!<=-1,!>=2}
Line 93
  fIsFunction always 2
  state always {!<=-1,!>=2}
Line 95
  state always {!<=-1,!>=2}
Line 96
  fIsVariable always 4
  state always {!<=-1,!>=2}
Line 98
  state always {!<=-1,!>=2}
Line 99
  fIsAlias always 8
  state always {!<=-1,!>=2}
Line 101
  state always {!<=-1,!>=2}
Line 102
  fIsSpecialization always 16
  state always {!<=-1,!>=2}
Line 104
  state always {!<=-1,!>=2}
Line 105
  fIsPartialSpecialization always 32
  state always {!<=-1,!>=2}
Line 107
  state always {!<=-1,!>=2}
Line 108
  fIsForwardDeclaration always 64
  state always {!<=-1,!>=2}
Line 110
  state always {!<=-1,!>=2}
Line 111
  fIsVariadic always 128
  state always {!<=-1,!>=2}
Line 113
  state always {!<=-1,!>=2}
Line 114
  fIsFriend always 256
  state always {!<=-1,!>=2}
Line 122
  ( always {!<=-1,!>=2}
  flag always !<=-1
Line 123
  return always {!<=-1,!>=2}
  mFlags always !<=-1
  & always !<=-1
  flag {!<=-1,256@63,128@64,64@65,32@66,16@67,8@68,4@69,2@70,1@71}
  != always {!<=-1,!>=2}
  0 always 0
Line 131
  flag always !<=-1
  state always {!<=-1,!>=2}
Line 132
  mFlags always !<=-1
  = always !<=-1
  state always {!<=-1,!>=2}
  ? always !<=-1
  mFlags always !<=-1
  | always !<=-1
  flag {!<=-1,256@72,128@73,64@74,32@75,16@76,8@77,4@78,2@79,1@80}
  : always !<=-1
  mFlags always !<=-1
  & always !<=-1
  ~ {!<=0,4294967039@72,4294967167@73,4294967231@74,4294967263@75,4294967279@76,4294967287@77,4294967291@78,4294967293@79,4294967294@80}
  flag {!<=-1,256@72,128@73,64@74,32@75,16@76,8@77,4@78,2@79,1@80}
Line 153
  ( always {!<=-1,!>=2}
Line 154
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 155
  == always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  mFlags always !<=-1
  == always {!<=-1,!>=2}
  . always !<=-1
  mFlags always !<=-1
Line 183
  ( always {!<=-1,!>=2}
Line 184
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsClass always 1
Line 186
  ( always {!<=-1,!>=2}
Line 187
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsFunction always 2
Line 189
  ( always {!<=-1,!>=2}
Line 190
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsVariable always 4
Line 192
  ( always {!<=-1,!>=2}
Line 193
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsAlias always 8
Line 195
  ( always {!<=-1,!>=2}
Line 196
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsSpecialization always 16
Line 198
  ( always {!<=-1,!>=2}
Line 199
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsPartialSpecialization always 32
Line 201
  ( always {!<=-1,!>=2}
Line 202
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsForwardDeclaration always 64
Line 204
  ( always {!<=-1,!>=2}
Line 205
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsVariadic always 128
Line 207
  ( always {!<=-1,!>=2}
Line 208
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsFriend always 256
Line 234
  ( always {!<=-1,!>=2}
Line 242
  ( always {!<=-1,!>=2}
Line 245
  return always {!<=-1,!>=2}
  mFlags always !<=-1
  & always !<=-1
  fFamilyMask always 7
  & always !<=-1
  . always !<=-1
  mFlags always !<=-1
  & always !<=-1
  fFamilyMask always 7
  != always {!<=-1,!>=2}
  0 always 0
Line 265
  ( always {!<=-1,!>=2}
  , always !<=-1
  numberOfArguments always !<=-1
  , always {!<=-1,!>=2}
  variadic always {!<=-1,!>=2}
Line 281
  ( always {!<=-1,!>=2}
Line 289
  ( always {!<=-1,!>=2}
Line 297
  ( always {!<=-1,!>=2}
Line 306
  codeWithTemplates always {!<=-1,!>=2}
Line 314
  ( always {!<=-1,!>=2}
  , always 1
  isTemplate always {!<=-1,!>=2}
  = always 1
  true always 1
Line 322
  ( always {!<=-1,!>=2}
  = always 0
  nullptr always 0
  , always 0
  = always 0
  nullptr always 0
  , always 1
  isTemplate always {!<=-1,!>=2}
  = always 1
  true always 1
Line 335
  ( always {!<=-1,!>=2}
Line 391
  ( always {!<=-1,!>=2}
Line 410
  ( always {!<=-1,!>=2}
Line 424
  , always {!<=-1,!>=2}
Line 425
  copy always {!<=-1,!>=2}
Line 451
  ( always {!<=-1,!>=2}
Line 456
  ( always {!<=-1,!>=2}
Line 486
  , always "    "
Line 487
  = always "    "
  "    " always "    "
Line 488
  = always ""
  "" always ""
Line 494
  mChanged always {!<=-1,!>=2}
Line 47
  ( always {!<=-1,!>=2}
Line 49
  return always {!<=-1,!>=2}
  != always {!<=-1,!>=2}
Line 53
  ( always {!<=-1,!>=2}
Line 55
  return always {!<=-1,!>=2}
  != always {!<=-1,!>=2}
Line 59
  ( always {!<=-1,!>=2}
Line 61
  return always {!<=-1,!>=2}
  != always {!<=-1,!>=2}
Line 67
  ( always !<=-1
Line 69
  return always !<=-1
  ( always !<=-1
Line 73
  ( always {!<=-1,!>=2}
Line 75
  return always {!<=-1,!>=2}
  ! {!<=-1,!>=2,0}
  str possible size=0
  ( {!<=-1,!>=2,1}
  && always {!<=-1,!>=2}
  str always !size=0
  == always {!<=-1,!>=2}
  c possible {58@194,39@56381,34@56637}
Line 78
  ( always {!<=-1,!>=2}
  , always !<=-1
  endlen always !<=-1
Line 80
  return always {!<=-1,!>=2}
  ( always !<=-1
  >= always {!<=-1,!>=2}
  endlen always !<=-1
  && always {!<=-1,!>=2}
  ( {!<=-1,>=symbolic=(endlen),!<=symbolic=(endlen-1)}
  - always !<=-1
  endlen {!<=-1,<=symbolic=(str.size()),!>=symbolic=(str.size()+1)}
  endlen {!<=-1,<=symbolic=(str.size()),!>=symbolic=(str.size()+1)}
  == always {!<=-1,!>=2}
  0 always 0
Line 84
  ( always {!<=-1,!>=2}
  ( always !0
  & always !0
Line 86
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  1 always 1
Line 89
  ( always {!<=-1,!>=2}
Line 91
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  q possible {39@220,34@221}
Line 92
  return always {!<=-1,!>=2}
  false always 0
Line 93
  ( always !<=-1
  + always !<=0
  1 always 1
  > always {!<=-1,!>=2}
  p possible {""@220,""@221,""@222,"U"@223,"U"@224,"u"@225,"u"@226,"u8"@227,"u8"@228}
  ( always !<=-1
  && always {!<=-1,!>=2}
  0 always 0
  ( always !<=-1
  + always !<=0
  1 always 1
  == always {!<=-1,!>=2}
  0 always 0
Line 94
  return always {!<=-1,!>=2}
  true always 1
Line 95
  return always {!<=-1,!>=2}
  false always 0
Line 98
  ( always {!<=-1,!>=2}
Line 100
  "" always ""
  "u8" always "u8"
  "u" always "u"
  "U" always "U"
  "L" always "L"
Line 102
  ( always {!<=-1,!>=2}
  q possible {39@58,34@59}
Line 103
  return always {!<=-1,!>=2}
  true always 1
Line 105
  return always {!<=-1,!>=2}
  false always 0
Line 108
  ( always {!<=-1,!>=2}
Line 110
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  '"' always 34
Line 113
  ( always {!<=-1,!>=2}
Line 115
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  '\'' always 39
Line 120
  quotePos always !<=-1
  = always !<=-1
  ( always !<=-1
  q possible {39@55,34@57}
Line 121
  quotePos {symbolic=(str.find(q)),!<=-1}
  + always !<=0
  1U always 1
  ( always !<=-1
  - always !<=-1
  quotePos {symbolic=(str.find(q)),!<=-1}
  - always !<=-1
  2U always 2
Line 126
  ( always {!<=-1,!>=2}
Line 127
  '"' always 34
Line 128
  "" always ""
Line 133
  ( always {!<=-1,!>=2}
Line 134
  '\'' always 39
Line 135
  "" always ""
Line 140
  i possible {2,3}
  == {!<=-1,!>=2,0}
  1 always 1
Line 141
  "st" always "st"
Line 142
  i {3,!1}
  == {!<=-1,!>=2,0}
  2 always 2
Line 143
  "nd" always "nd"
Line 144
  i always {!1,!2}
  == always {!<=-1,!>=2}
  3 always 3
Line 145
  "rd" always "rd"
Line 146
  "th" always "th"
Line 151
  ( always {!<=-1,!>=2}
Line 153
  ( always {!<=-1,!>=2}
Line 155
  ( always {!<=-1,!>=2}
Line 118
  LOW always 0
  HIGH always 1
Line 125
  UNKNOWN always 0
  CPP11INIT always 1
  NOINIT always 2
Line 128
  mBits always !<=-1
Line 131
  ( always {!<=-1,!>=2}
Line 134
  0 always 0
Line 135
  0 always 0
Line 136
  0 always 0
Line 137
  0 always 0
Line 138
  0 always 0
Line 139
  nullptr always 0
Line 140
  nullptr always 0
Line 141
  nullptr always 0
Line 142
  nullptr always 0
Line 143
  nullptr always 0
Line 144
  0 always 0
Line 145
  0 always 0
Line 146
  nullptr always 0
Line 147
  nullptr always 0
Line 148
  nullptr always 0
Line 149
  nullptr always 0
Line 150
  nullptr always 0
Line 151
  nullptr always 0
Line 153
  mBits always !<=-1
  0 always 0
Line 182
  eVariable always 0
  eType always 1
  eFunction always 2
  eKeyword always 3
  eName always 4
Line 183
  eNumber always 5
  eString always 6
  eChar always 7
  eBoolean always 8
  eLiteral always 9
  eEnumerator always 10
Line 184
  eArithmeticalOp always 11
  eComparisonOp always 12
  eAssignmentOp always 13
  eLogicalOp always 14
  eBitOp always 15
  eIncDecOp always 16
  eExtendedOp always 17
Line 185
  eBracket always 18
Line 186
  eLambda always 19
Line 187
  eEllipsis always 20
Line 188
  eOther always 21
Line 189
  eNone always 22
Line 192
  = always 0
  nullptr always 0
Line 198
  && always {!<=-1,!>=2}
Line 200
  = always 0
  0 always 0
Line 218
  = always 1
  1 always 1
Line 223
  = always 1
  1 always 1
Line 237
  ( always !0
  this always !0
  index possible {3@27,2@39,8@135,4@141,-2@200,-3@231,5@97,6@176,-4@57,7@81}
Line 246
  ( always !0
  this always !0
  index possible {3@133,2@190,1@5,-1@175,-2@206,4@113,6@40,5@111}
Line 275
  ( always {!<=-1,!>=2}
  ( always !0
  & {lifetime[Address]=(pattern),!0}
Line 276
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  tok possible {symbolic=(tok->next())@76,symbolic=(tok->previous())@1,symbolic=(tok->next()->link())@22,symbolic=(tok->next())@60,0@60,symbolic=(after)@9,symbolic=(tok->previous())@13,symbolic=(tryEndToken)@205,symbolic=(end2->link()->previous())@199,symbolic=(tok->previous()->link()->previous())@110}
  pattern possible {"{"@34,"}"@35,";"@76,"END - __CPPCHECK_EMBEDDED_SQL_EXEC__ ;"@95,"return strncat ("@188,") ;"@189,"this ) ("@236,"( *"@237,"operator() ("@246,","@1}
  1 always 1
Line 279
  ( always {!<=-1,!>=2}
  , always !<=-1
  pattern_len always !<=-1
Line 324
  ( always {!<=-1,!>=2}
  , always 0
  = always 0
  0 always 0
Line 370
  = always !0
  this always !0
Line 371
  top possible {symbolic=(this),0}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  top {symbolic=(this),!0}
  ",|(" always ",|("
Line 372
  top always !0
Line 373
  top possible {symbolic=(this),0}
  ? possible 0
  top always !0
  : always 0
  nullptr always 0
Line 380
  = possible {10@209,4@210,0@211}
  t possible {10@209,4@210,0@211}
Line 382
  memoizedIsName always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  mTokType possible {10@209,4@210,0@211}
  == always {!<=-1,!>=2}
  eName always 4
  || always {!<=-1,!>=2}
  mTokType {!4,10@209,0@211}
  == always {!<=-1,!>=2}
  eType always 1
  || always {!<=-1,!>=2}
  mTokType {!4,!1,10@209,0@211}
  == always {!<=-1,!>=2}
  eVariable always 0
  || always {!<=-1,!>=2}
Line 383
  mTokType {!1,!0,10@209}
  == always {!<=-1,!>=2}
  eFunction always 2
  || always {!<=-1,!>=2}
  mTokType {!0,!2,10@209}
  == always {!<=-1,!>=2}
  eKeyword always 3
  || always {!<=-1,!>=2}
  mTokType {!2,!3,10@209}
  == always {!<=-1,!>=2}
  eBoolean always 8
  || always {!<=-1,!>=2}
Line 384
  mTokType {!3,!8,10@209}
  == always {!<=-1,!>=2}
  eEnumerator always 10
Line 385
  fIsName always 2097152
  memoizedIsName {symbolic=(mTokType==eName||mTokType==eType||mTokType==eVariable||mTokType==eFunction||mTokType==eKeyword||mTokType==eBoolean||mTokType==eEnumerator),!<=-1,!>=2,1@209}
Line 387
  memoizedIsLiteral always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  eNumber always 5
  || always {!<=-1,!>=2}
  mTokType always !5
  == always {!<=-1,!>=2}
  eString always 6
  || always {!<=-1,!>=2}
  mTokType always {!5,!6}
  == always {!<=-1,!>=2}
  eChar always 7
  || always {!<=-1,!>=2}
Line 388
  mTokType always {!6,!7}
  == always {!<=-1,!>=2}
  eBoolean always 8
  || always {!<=-1,!>=2}
  mTokType always {!7,!8}
  == always {!<=-1,!>=2}
  eLiteral always 9
  || always {!<=-1,!>=2}
  mTokType always {!8,!9}
  == always {!<=-1,!>=2}
  eEnumerator always 10
Line 389
  fIsLiteral always 4194304
  memoizedIsLiteral {symbolic=(mTokType==eNumber||mTokType==eString||mTokType==eChar||mTokType==eBoolean||mTokType==eLiteral||mTokType==eEnumerator),!<=-1,!>=2}
Line 391
  ( always {!<=-1,!>=2}
Line 392
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  eKeyword always 3
Line 394
  ( always {!<=-1,!>=2}
Line 395
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsName always 2097152
Line 397
  ( always {!<=-1,!>=2}
Line 398
  return always {!<=-1,!>=2}
  mFlags always !<=-1
  == always {!<=-1,!>=2}
  fIsName always 2097152
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  eName always 4
Line 400
  ( always {!<=-1,!>=2}
Line 401
  ( always {!<=-1,!>=2}
Line 402
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsLiteral always 4194304
Line 404
  ( always {!<=-1,!>=2}
Line 405
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  eNumber always 5
Line 407
  ( always {!<=-1,!>=2}
Line 408
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  eEnumerator always 10
Line 410
  ( always {!<=-1,!>=2}
Line 411
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
Line 412
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
Line 413
  == always {!<=-1,!>=2}
  eIncDecOp always 16
Line 415
  ( always {!<=-1,!>=2}
Line 416
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
Line 417
  == always {!<=-1,!>=2}
  eLogicalOp always 14
  || always {!<=-1,!>=2}
Line 418
  mTokType always !14
  == always {!<=-1,!>=2}
  eComparisonOp always 12
  || always {!<=-1,!>=2}
Line 419
  mTokType always {!14,!12}
  == always {!<=-1,!>=2}
  eBitOp always 15
Line 421
  ( always {!<=-1,!>=2}
Line 422
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
Line 423
  == always {!<=-1,!>=2}
  eExtendedOp always 17
Line 425
  ( always {!<=-1,!>=2}
Line 426
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  eArithmeticalOp always 11
Line 428
  ( always {!<=-1,!>=2}
Line 429
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  eComparisonOp always 12
Line 431
  ( always {!<=-1,!>=2}
Line 432
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  eAssignmentOp always 13
Line 434
  ( always {!<=-1,!>=2}
Line 435
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  eBoolean always 8
Line 437
  ( always {!<=-1,!>=2}
Line 438
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  eIncDecOp always 16
Line 440
  ( always {!<=-1,!>=2}
Line 441
  return always {!<=-1,!>=2}
  != always {!<=-1,!>=2}
  nullptr always 0
  && always {!<=-1,!>=2}
  != always {!<=-1,!>=2}
  nullptr always 0
Line 443
  ( always {!<=-1,!>=2}
Line 444
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  != always {!<=-1,!>=2}
  nullptr always 0
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  nullptr always 0
Line 446
  ( always {!<=-1,!>=2}
Line 448
  ( always !<=-1
Line 449
  return always !<=-1
  mFlags always !<=-1
Line 451
  flags_ always !<=-1
Line 452
  mFlags always !<=-1
  = always !<=-1
  flags_ always !<=-1
Line 454
  ( always {!<=-1,!>=2}
Line 455
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsUnsigned always 1
Line 457
  sign always {!<=-1,!>=2}
Line 458
  fIsUnsigned always 1
  sign always {!<=-1,!>=2}
Line 460
  ( always {!<=-1,!>=2}
Line 461
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsSigned always 2
Line 463
  sign always {!<=-1,!>=2}
Line 464
  fIsSigned always 2
  sign always {!<=-1,!>=2}
Line 466
  ( always {!<=-1,!>=2}
Line 467
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsPointerCompare always 4
Line 469
  b always {!<=-1,!>=2}
Line 470
  fIsPointerCompare always 4
  b always {!<=-1,!>=2}
Line 472
  ( always {!<=-1,!>=2}
Line 473
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsLong always 8
Line 475
  size always {!<=-1,!>=2}
Line 476
  fIsLong always 8
  size {!<=-1,!>=2,1@139}
Line 478
  ( always {!<=-1,!>=2}
Line 479
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsStandardType always 16
Line 481
  b always {!<=-1,!>=2}
Line 482
  fIsStandardType always 16
  b {!<=-1,!>=2,1@105,0@217}
Line 484
  ( always {!<=-1,!>=2}
Line 485
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsExpandedMacro always 32
Line 487
  m always {!<=-1,!>=2}
Line 488
  fIsExpandedMacro always 32
  m always {!<=-1,!>=2}
Line 490
  ( always {!<=-1,!>=2}
Line 491
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsCast always 64
Line 493
  c always {!<=-1,!>=2}
Line 494
  fIsCast always 64
  c {!<=-1,!>=2,1@2}
Line 496
  ( always {!<=-1,!>=2}
Line 497
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsAttributeConstructor always 128
Line 499
  ac always {!<=-1,!>=2}
Line 500
  fIsAttributeConstructor always 128
  ac {!<=-1,!>=2,1@31}
Line 502
  ( always {!<=-1,!>=2}
Line 503
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsAttributeDestructor always 256
Line 505
  value always {!<=-1,!>=2}
Line 506
  fIsAttributeDestructor always 256
  value {!<=-1,!>=2,1@33}
Line 508
  ( always {!<=-1,!>=2}
Line 509
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsAttributeUnused always 512
Line 511
  unused always {!<=-1,!>=2}
Line 512
  fIsAttributeUnused always 512
  unused {!<=-1,!>=2,1@38}
Line 514
  ( always {!<=-1,!>=2}
Line 515
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsAttributeUsed always 16384
Line 517
  unused always {!<=-1,!>=2}
Line 518
  fIsAttributeUsed always 16384
  unused {!<=-1,!>=2,1@39}
Line 520
  ( always {!<=-1,!>=2}
Line 521
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsAttributePure always 1024
Line 523
  value always {!<=-1,!>=2}
Line 524
  fIsAttributePure always 1024
  value {!<=-1,!>=2,1@1}
Line 526
  ( always {!<=-1,!>=2}
Line 527
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsAttributeConst always 2048
Line 529
  value always {!<=-1,!>=2}
Line 530
  fIsAttributeConst always 2048
  value {!<=-1,!>=2,1@3}
Line 532
  ( always {!<=-1,!>=2}
Line 533
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsAttributeNoreturn always 4096
Line 535
  value always {!<=-1,!>=2}
Line 536
  fIsAttributeNoreturn always 4096
  value {!<=-1,!>=2,1@172}
Line 538
  ( always {!<=-1,!>=2}
Line 539
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsAttributeNothrow always 8192
Line 541
  value always {!<=-1,!>=2}
Line 542
  fIsAttributeNothrow always 8192
  value {!<=-1,!>=2,1@46}
Line 544
  ( always {!<=-1,!>=2}
Line 545
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsAttributePacked always 32768
Line 547
  value always {!<=-1,!>=2}
Line 548
  fIsAttributePacked always 32768
  value {!<=-1,!>=2,1@51}
Line 550
  ( always {!<=-1,!>=2}
Line 551
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsAttributeNodiscard always 16777216
Line 553
  value always {!<=-1,!>=2}
Line 554
  fIsAttributeNodiscard always 16777216
  value {!<=-1,!>=2,1@185}
Line 556
  ( always {!<=-1,!>=2}
Line 557
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsAttributeMaybeUnused always 65536
Line 559
  value always {!<=-1,!>=2}
Line 560
  fIsAttributeMaybeUnused always 65536
  value {!<=-1,!>=2,1@194}
Line 563
  type possible {0@210,1@216}
Line 565
  ( always {!<=-1,!>=2}
Line 566
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 568
  ( always {!<=-1,!>=2}
Line 569
  return always {!<=-1,!>=2}
  nullptr always 0
  != always {!<=-1,!>=2}
Line 571
  ( always {!<=-1,!>=2}
Line 572
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsControlFlowKeyword always 131072
Line 574
  ( always {!<=-1,!>=2}
Line 575
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsOperatorKeyword always 262144
Line 577
  value always {!<=-1,!>=2}
Line 578
  fIsOperatorKeyword always 262144
  value {!<=-1,!>=2,1@48}
Line 580
  ( always {!<=-1,!>=2}
Line 581
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsComplex always 524288
Line 583
  value always {!<=-1,!>=2}
Line 584
  fIsComplex always 524288
  value always {!<=-1,!>=2}
Line 586
  ( always {!<=-1,!>=2}
Line 587
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsEnumType always 1048576
Line 589
  value always {!<=-1,!>=2}
Line 590
  fIsEnumType always 1048576
  value always {!<=-1,!>=2}
Line 592
  ( always {!<=-1,!>=2}
Line 593
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fAtAddress always 33554432
Line 595
  b always {!<=-1,!>=2}
Line 596
  fAtAddress always 33554432
  b {!<=-1,!>=2,1@7}
Line 598
  ( always {!<=-1,!>=2}
Line 599
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIncompleteVar always 67108864
Line 601
  b always {!<=-1,!>=2}
Line 602
  fIncompleteVar always 67108864
  b always {!<=-1,!>=2}
Line 605
  ( always {!<=-1,!>=2}
Line 606
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsIncompleteConstant always 68719476736
Line 608
  b always {!<=-1,!>=2}
Line 609
  fIsIncompleteConstant always 68719476736
  b always {!<=-1,!>=2}
Line 612
  ( always {!<=-1,!>=2}
Line 613
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fConstexpr always 134217728
Line 615
  b always {!<=-1,!>=2}
Line 616
  fConstexpr always 134217728
  b {!<=-1,!>=2,1@190}
Line 619
  ( always {!<=-1,!>=2}
Line 620
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fExternC always 268435456
Line 622
  b always {!<=-1,!>=2}
Line 623
  fExternC always 268435456
  b {!<=-1,!>=2,1@99}
Line 626
  ( always {!<=-1,!>=2}
Line 627
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsSplitVarDeclComma always 536870912
Line 629
  b always {!<=-1,!>=2}
Line 630
  fIsSplitVarDeclComma always 536870912
  b {!<=-1,!>=2,1@71}
Line 633
  ( always {!<=-1,!>=2}
Line 634
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsSplitVarDeclEq always 1073741824
Line 636
  b always {!<=-1,!>=2}
Line 637
  fIsSplitVarDeclEq always 1073741824
  b {!<=-1,!>=2,1@39}
Line 640
  ( always {!<=-1,!>=2}
Line 641
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsImplicitInt always 2147483648
Line 643
  b always {!<=-1,!>=2}
Line 644
  fIsImplicitInt always 2147483648
  b always {!<=-1,!>=2}
Line 647
  ( always {!<=-1,!>=2}
Line 648
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsInline always 4294967296
Line 650
  b always {!<=-1,!>=2}
Line 651
  fIsInline always 4294967296
  b {!<=-1,!>=2,1@129}
Line 654
  ( always {!<=-1,!>=2}
Line 655
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsRemovedVoidParameter always 34359738368
Line 657
  b always {!<=-1,!>=2}
Line 658
  fIsRemovedVoidParameter always 34359738368
  b {!<=-1,!>=2,1@63}
Line 661
  ( always {!<=-1,!>=2}
Line 662
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsTemplate always 8589934592
Line 664
  b always {!<=-1,!>=2}
Line 665
  fIsTemplate always 8589934592
  b {!<=-1,!>=2,1@245}
Line 668
  ( always {!<=-1,!>=2}
Line 669
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsSimplifedScope always 17179869184
Line 671
  b always {!<=-1,!>=2}
Line 672
  fIsSimplifedScope always 17179869184
  b {!<=-1,!>=2,1@231}
Line 675
  ( always {!<=-1,!>=2}
Line 676
  return always {!<=-1,!>=2}
  . always !<=-1
  mBits always !<=-1
  > always {!<=-1,!>=2}
  0 always 0
Line 678
  ( always !<=-1
Line 679
  return always !<=-1
  . always !<=-1
  mBits always !<=-1
Line 685
  ! always {!<=-1,!>=2}
Line 687
  . possible lifetime[Object]=(tokenAndName)
Line 689
  b always !<=-1
Line 690
  . always !<=-1
  mBits always !<=-1
  = always !<=-1
  b always !<=-1
Line 693
  ( always {!<=-1,!>=2}
Line 694
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  eString always 6
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  '"' always 34
  "u8" always "u8"
  || always {!<=-1,!>=2}
Line 695
  == always {!<=-1,!>=2}
  eChar always 7
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  '\'' always 39
  "u8" always "u8"
Line 698
  ( always {!<=-1,!>=2}
Line 699
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  eString always 6
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  '"' always 34
  "u" always "u"
  || always {!<=-1,!>=2}
Line 700
  == always {!<=-1,!>=2}
  eChar always 7
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  '\'' always 39
  "u" always "u"
Line 703
  ( always {!<=-1,!>=2}
Line 704
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  eString always 6
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  '"' always 34
  "U" always "U"
  || always {!<=-1,!>=2}
Line 705
  == always {!<=-1,!>=2}
  eChar always 7
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  '\'' always 39
  "U" always "U"
Line 708
  ( always {!<=-1,!>=2}
Line 709
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  eString always 6
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  '"' always 34
  "" always ""
  || always {!<=-1,!>=2}
Line 710
  == always {!<=-1,!>=2}
  eChar always 7
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  '\'' always 39
  "" always ""
  && always {!<=-1,!>=2}
  ( always !<=-1
  == always {!<=-1,!>=2}
  3 always 3
Line 713
  ( always {!<=-1,!>=2}
Line 714
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  eChar always 7
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  '\'' always 39
  "" always ""
  && always {!<=-1,!>=2}
Line 715
  ( always !<=-1
  > always {!<=-1,!>=2}
  3 always 3
Line 734
  ( always {!<=-1,!>=2}
Line 735
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsTemplateArg always 8388608
Line 737
  value always {!<=-1,!>=2}
Line 738
  fIsTemplateArg always 8388608
  value always {!<=-1,!>=2}
Line 742
  ( always !0
  & {lifetime[Address]=(pattern),!0}
Line 743
  startTok possible symbolic=(list.front())@58
  pattern {";"@59,"operator"@58,"using namespace std ;"@163,"{"@83,";"@19,"["@191}
  1 always 1
Line 745
  , always !<=-1
  pattern_len always !<=-1
Line 748
  ( always !0
  & {lifetime[Address]=(pattern),!0}
Line 749
  pattern possible {"noreturn"@160,"nodiscard"@173,"maybe_unused"@186,": ;"@206,": ;"@220,","@188,"decltype ("@208,"typedef"@173}
  1 always 1
Line 751
  , always !<=-1
  pattern_len always !<=-1
Line 753
  , always 0
  = always 0
  0 always 0
Line 754
  , always 0
  = always 0
  0 always 0
Line 757
  ( always !0
  & {lifetime[Address]=(pattern),!0}
Line 758
  1 always 1
Line 760
  , always !<=-1
  pattern_len always !<=-1
Line 761
  pattern_len always !<=-1
Line 764
  ( always !0
  & {lifetime[Address]=(pattern),!0}
Line 765
  1 always 1
Line 767
  , always !<=-1
  pattern_len always !<=-1
Line 768
  pattern_len always !<=-1
Line 771
  , always 0
  = always 0
  0 always 0
Line 772
  varId possible 0
Line 774
  , always 0
  = always 0
  0 always 0
Line 775
  varId possible 0
Line 837
  , always 0
  prepend always {!<=-1,!>=2}
  = always 0
  false always 0
Line 841
  tokenStr possible ">"@237
  true always 1
Line 853
  = possible 0
  id possible 0
Line 854
  id possible 0@55
  != {!<=-1,!>=2,0}
  0 always 0
Line 855
  eVariable always 0
Line 856
  false always 0
Line 864
  . always !0
Line 877
  = always 0
  nullptr always 0
Line 892
  = always 5
  5 always 5
Line 904
  varid always {!<=-1,!>=2}
  varid always {!<=-1,!>=2}
  = always 0
  false always 0
Line 905
  exprid always {!<=-1,!>=2}
  exprid always {!<=-1,!>=2}
  = always 0
  false always 0
Line 906
  idtype always {!<=-1,!>=2}
  idtype always {!<=-1,!>=2}
  = always 0
  false always 0
Line 907
  attributes always {!<=-1,!>=2}
  attributes always {!<=-1,!>=2}
  = always 0
  false always 0
Line 908
  macro always {!<=-1,!>=2}
  macro always {!<=-1,!>=2}
  = always 0
  false always 0
Line 909
  linenumbers always {!<=-1,!>=2}
  linenumbers always {!<=-1,!>=2}
  = always 0
  false always 0
Line 910
  linebreaks always {!<=-1,!>=2}
  linebreaks always {!<=-1,!>=2}
  = always 0
  false always 0
Line 911
  files always {!<=-1,!>=2}
  files always {!<=-1,!>=2}
  = always 0
  false always 0
Line 914
  . always {!<=-1,!>=2}
  attributes always {!<=-1,!>=2}
  = always 1
  true always 1
Line 915
  . always {!<=-1,!>=2}
  macro always {!<=-1,!>=2}
  = always 1
  true always 1
Line 916
  . always {!<=-1,!>=2}
  linenumbers always {!<=-1,!>=2}
  = always 1
  true always 1
Line 917
  . always {!<=-1,!>=2}
  linebreaks always {!<=-1,!>=2}
  = always 1
  true always 1
Line 918
  . always {!<=-1,!>=2}
  files always {!<=-1,!>=2}
  = always 1
  true always 1
Line 923
  . always {!<=-1,!>=2}
  varid always {!<=-1,!>=2}
  = always 1
  true always 1
Line 928
  . always {!<=-1,!>=2}
  exprid always {!<=-1,!>=2}
  = always 1
  true always 1
Line 933
  . always {!<=-1,!>=2}
  exprid always {!<=-1,!>=2}
  = always 1
  true always 1
Line 934
  . always {!<=-1,!>=2}
  varid always {!<=-1,!>=2}
  = always 1
  true always 1
Line 935
  . always {!<=-1,!>=2}
  idtype always {!<=-1,!>=2}
  = always 1
  true always 1
Line 948
  varid always {!<=-1,!>=2}
  attributes always {!<=-1,!>=2}
  macro always {!<=-1,!>=2}
Line 950
  , always 0
  = always 0
  nullptr always 0
  , always 0
  = always 0
  nullptr always 0
Line 951
  , always 1
  attributes always {!<=-1,!>=2}
  = always 1
  true always 1
Line 952
  varid always {!<=-1,!>=2}
  = always 0
  false always 0
Line 965
  varid always {!<=-1,!>=2}
  attributes always {!<=-1,!>=2}
  linenumbers always {!<=-1,!>=2}
  linebreaks always {!<=-1,!>=2}
  files always {!<=-1,!>=2}
  = always 0
  nullptr always 0
  , always 0
  = always 0
  nullptr always 0
Line 983
  = possible {symbolic=(tok->link()->next())@156,0@18}
  linkToToken possible {symbolic=(tok->link()->next())@156,0@18}
Line 984
  mStr possible size=1
  == always {!<=-1,!>=2}
  "<" always "<"
  || always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  ">" always ">"
Line 1026
  mTokType possible 19
  == {!<=-1,!>=2,0}
  eFunction always 2
  || always {!<=-1,!>=2}
  mTokType always !2
  == always {!<=-1,!>=2}
  eLambda always 19
  : always 0
  nullptr always 0
Line 1034
  = possible 0
  v possible 0
Line 1035
  || always {!<=-1,!>=2}
Line 1036
  eVariable always 0
Line 1037
  == always {!<=-1,!>=2}
  eVariable always 0
Line 1038
  eName always 4
Line 1045
  == always {!<=-1,!>=2}
  eVariable always 0
  ? possible 0
  : always 0
  nullptr always 0
Line 1058
  == always {!<=-1,!>=2}
  eType always 1
  ? possible 0
  : always 0
  nullptr always 0
Line 1061
  , always 0
  = always 0
  nullptr always 0
Line 1071
  == always {!<=-1,!>=2}
  eEnumerator always 10
  ? possible 0
  : always 0
  nullptr always 0
Line 1079
  = possible 0
  e possible 0
Line 1081
  eEnumerator always 10
Line 1082
  == always {!<=-1,!>=2}
  eEnumerator always 10
Line 1083
  eName always 4
Line 1152
  . always !0
Line 1156
  . always !0
Line 1163
  && always {!<=-1,!>=2}
Line 1164
  ! always {!<=-1,!>=2}
Line 1170
  ( always {!<=-1,!>=2}
Line 1171
  ( always {!<=-1,!>=2}
Line 1172
  ( always {!<=-1,!>=2}
Line 1173
  ( always {!<=-1,!>=2}
Line 1182
  condition always {!<=-1,!>=2}
  = always 0
  0 always 0
Line 1197
  ( always {!<=-1,!>=2}
Line 1199
  ( always {!<=-1,!>=2}
Line 1227
  ( always {!<=-1,!>=2}
Line 1243
  fIsUnsigned always 1
  = always 1
  1 always 1
  << always 1
  0 always 0
  , always 2
Line 1244
  fIsSigned always 2
  = always 2
  1 always 1
  << always 2
  1 always 1
  , always 4
Line 1245
  fIsPointerCompare always 4
  = always 4
  1 always 1
  << always 4
  2 always 2
  , always 8
Line 1246
  fIsLong always 8
  = always 8
  1 always 1
  << always 8
  3 always 3
  , always 16
Line 1247
  fIsStandardType always 16
  = always 16
  1 always 1
  << always 16
  4 always 4
  , always 32
Line 1248
  fIsExpandedMacro always 32
  = always 32
  1 always 1
  << always 32
  5 always 5
  , always 64
Line 1249
  fIsCast always 64
  = always 64
  1 always 1
  << always 64
  6 always 6
  , always 128
Line 1250
  fIsAttributeConstructor always 128
  = always 128
  1 always 1
  << always 128
  7 always 7
  , always 256
Line 1251
  fIsAttributeDestructor always 256
  = always 256
  1 always 1
  << always 256
  8 always 8
  , always 512
Line 1252
  fIsAttributeUnused always 512
  = always 512
  1 always 1
  << always 512
  9 always 9
  , always 1024
Line 1253
  fIsAttributePure always 1024
  = always 1024
  1 always 1
  << always 1024
  10 always 10
  , always 2048
Line 1254
  fIsAttributeConst always 2048
  = always 2048
  1 always 1
  << always 2048
  11 always 11
  , always 4096
Line 1255
  fIsAttributeNoreturn always 4096
  = always 4096
  1 always 1
  << always 4096
  12 always 12
  , always 8192
Line 1256
  fIsAttributeNothrow always 8192
  = always 8192
  1 always 1
  << always 8192
  13 always 13
  , always 16384
Line 1257
  fIsAttributeUsed always 16384
  = always 16384
  1 always 1
  << always 16384
  14 always 14
  , always 32768
Line 1258
  fIsAttributePacked always 32768
  = always 32768
  1 always 1
  << always 32768
  15 always 15
  , always 65536
Line 1259
  fIsAttributeMaybeUnused always 65536
  = always 65536
  1 always 1
  << always 65536
  16 always 16
  , always 131072
Line 1260
  fIsControlFlowKeyword always 131072
  = always 131072
  1 always 1
  << always 131072
  17 always 17
  , always 262144
Line 1261
  fIsOperatorKeyword always 262144
  = always 262144
  1 always 1
  << always 262144
  18 always 18
  , always 524288
Line 1262
  fIsComplex always 524288
  = always 524288
  1 always 1
  << always 524288
  19 always 19
  , always 1048576
Line 1263
  fIsEnumType always 1048576
  = always 1048576
  1 always 1
  << always 1048576
  20 always 20
  , always 2097152
Line 1264
  fIsName always 2097152
  = always 2097152
  1 always 1
  << always 2097152
  21 always 21
  , always 4194304
Line 1265
  fIsLiteral always 4194304
  = always 4194304
  1 always 1
  << always 4194304
  22 always 22
  , always 8388608
Line 1266
  fIsTemplateArg always 8388608
  = always 8388608
  1 always 1
  << always 8388608
  23 always 23
  , always 16777216
Line 1267
  fIsAttributeNodiscard always 16777216
  = always 16777216
  1 always 1
  << always 16777216
  24 always 24
  , always 33554432
Line 1268
  fAtAddress always 33554432
  = always 33554432
  1 always 1
  << always 33554432
  25 always 25
  , always 67108864
Line 1269
  fIncompleteVar always 67108864
  = always 67108864
  1 always 1
  << always 67108864
  26 always 26
  , always 134217728
Line 1270
  fConstexpr always 134217728
  = always 134217728
  1 always 1
  << always 134217728
  27 always 27
  , always 268435456
Line 1271
  fExternC always 268435456
  = always 268435456
  1 always 1
  << always 268435456
  28 always 28
  , always 536870912
Line 1272
  fIsSplitVarDeclComma always 536870912
  = always 536870912
  1 always 1
  << always 536870912
  29 always 29
  , always 1073741824
Line 1273
  fIsSplitVarDeclEq always 1073741824
  = always 1073741824
  1 always 1
  << always 1073741824
  30 always 30
  , always 2147483648
Line 1274
  fIsImplicitInt always 2147483648
  = always 2147483648
  1U always 1
  << always 2147483648
  31 always 31
  , always 4294967296
Line 1275
  fIsInline always 4294967296
  = always 4294967296
  1ULL always 1
  << always 4294967296
  32 always 32
  , always 8589934592
Line 1276
  fIsTemplate always 8589934592
  = always 8589934592
  1ULL always 1
  << always 8589934592
  33 always 33
  , always 17179869184
Line 1277
  fIsSimplifedScope always 17179869184
  = always 17179869184
  1ULL always 1
  << always 17179869184
  34 always 34
  , always 34359738368
Line 1278
  fIsRemovedVoidParameter always 34359738368
  = always 34359738368
  1ULL always 1
  << always 34359738368
  35 always 35
  , always 68719476736
Line 1279
  fIsIncompleteConstant always 68719476736
  = always 68719476736
  1ULL always 1
  << always 68719476736
  36 always 36
Line 1284
  mFlags always !<=-1
Line 1293
  ( always {!<=-1,!>=2}
  flag_ always !<=-1
Line 1294
  return always {!<=-1,!>=2}
  mFlags always !<=-1
  & always !<=-1
  flag_ {!<=-1,8388608@219,17179869184@230,8589934592@232,34359738368@234,4294967296@236,2147483648@238,1073741824@240,536870912@242,268435456@244}
  != always {!<=-1,!>=2}
  0 always 0
Line 1302
  flag_ always !<=-1
  state_ always {!<=-1,!>=2}
Line 1303
  mFlags always !<=-1
  = always !<=-1
  state_ {!<=-1,!>=2,symbolic=(mTokType==eName||mTokType==eType||mTokType==eVariable||mTokType==eFunction||mTokType==eKeyword||mTokType==eBoolean||mTokType==eEnumerator)@50,symbolic=(mTokType==eNumber||mTokType==eString||mTokType==eChar||mTokType==eBoolean||mTokType==eLiteral||mTokType==eEnumerator)@51}
  ? always !<=-1
  mFlags always !<=-1
  | always !<=-1
  flag_ {!<=-1,8388608@218,2147483648@237,68719476736@247,67108864@249,1048576@253,524288@255,32@28,4@34,2@36}
  : always !<=-1
  mFlags always !<=-1
  & always !<=-1
  ~ always !<=0
  flag_ {!<=-1,8388608@218,2147483648@237,68719476736@247,67108864@249,1048576@253,524288@255,32@28,4@34,2@36}
Line 1317
  , always 0
  = always 0
  0 always 0
  , always 0
  = always 0
  0 always 0
Line 1343
  ! always {!<=-1,!>=2}
Line 1344
  nullptr always 0
Line 1345
  this {!0,symbolic=(astParent()->astOperand2())}
  == always {!<=-1,!>=2}
  ( always !0
Line 1346
  ( always !0
Line 1347
  this always {!0,!symbolic=(astParent()->astOperand1())}
  == always {!<=-1,!>=2}
  ( always !0
Line 1348
  ( always !0
Line 1349
  nullptr always 0
Line 1353
  ! always {!<=-1,!>=2}
Line 1354
  nullptr always 0
Line 1355
  this {!0,symbolic=(astParent()->astOperand2())}
  == always {!<=-1,!>=2}
  ( always !0
Line 1356
  ( always !0
Line 1357
  this always {!0,!symbolic=(astParent()->astOperand1())}
  == always {!<=-1,!>=2}
  ( always !0
Line 1358
  ( always !0
Line 1359
  nullptr always 0
Line 1363
  = always !0
  this always !0
Line 1364
  ret possible symbolic=(this)
Line 1365
  = always !0
  . always !0
Line 1366
  ret possible symbolic=(this)
Line 1370
  = always !0
  this always !0
Line 1371
  ret possible symbolic=(this)
Line 1372
  = always !0
  . always !0
Line 1373
  ret possible symbolic=(this)
Line 1385
  ( always {!<=-1,!>=2}
Line 1388
  = always 0
  = always 0
  = always 0
  nullptr always 0
Line 1393
  = always 0
  nullptr always 0
Line 1396
  = always ""
  "" always ""
Line 1402
  sep possible ""
Line 1411
  verbose always {!<=-1,!>=2}
  xml always {!<=-1,!>=2}
Line 1413
  xml always {!<=-1,!>=2}
Line 1418
  cpp11init always {!<=-1,!>=2}
Line 1419
  = possible {1,2}
  cpp11init always {!<=-1,!>=2}
  ? possible {1,2}
  :: always 1
  CPP11INIT always 1
  : always 2
  :: always 2
  NOINIT always 2
Line 58
  ( always {!<=-1,!>=2}
Line 59
  return always {!<=-1,!>=2}
  mIsC always {!<=-1,!>=2}
Line 63
  ( always {!<=-1,!>=2}
Line 64
  return always {!<=-1,!>=2}
  mIsCpp always {!<=-1,!>=2}
Line 73
  , always 0
  split always {!<=-1,!>=2}
  = always 0
  false always 0
Line 90
  , always 1
  one_line always {!<=-1,!>=2}
  = always 1
  true always 1
Line 101
  ( always {!<=-1,!>=2}
Line 103
  && always {!<=-1,!>=2}
Line 156
  ( always !<=-1
Line 175
  ( always {!<=-1,!>=2}
Line 192
  ( always {!<=-1,!>=2}
Line 219
  mIsC always {!<=-1,!>=2}
Line 220
  mIsCpp always {!<=-1,!>=2}
Line 71
  ( always {!<=-1,!>=2}
Line 73
  ( always {!<=-1,!>=2}
Line 75
  return possible lifetime[Iterator]=(mVariableId)
  ( possible lifetime[Iterator]=(mVariableId)
Line 77
  ( always end=0
Line 78
  return possible lifetime[Iterator]=(mVariableId)
  ( {lifetime[Iterator]=(mVariableId),end=0}
Line 84
  & {lifetime[Address]=(mVarId),!0}
Line 99
  ( always {!<=-1,!>=2}
Line 100
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 104
  ( always {!<=-1,!>=2}
Line 105
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 114
  ( always {!<=-1,!>=2}
  , always 0
  = always 0
  nullptr always 0
Line 116
  ( always {!<=-1,!>=2}
Line 117
  && always {!<=-1,!>=2}
Line 119
  ( always {!<=-1,!>=2}
Line 141
  ( always {!<=-1,!>=2}
Line 159
  ( always {!<=-1,!>=2}
Line 167
  ( always {!<=-1,!>=2}
Line 218
  ( always {!<=-1,!>=2}
Line 232
  ( always {!<=-1,!>=2}
Line 292
  ( always {!<=-1,!>=2}
Line 314
  ( always {!<=-1,!>=2}
Line 351
  ( always {!<=-1,!>=2}
Line 364
  ( always {!<=-1,!>=2}
Line 397
  ( always {!<=-1,!>=2}
Line 401
  ( always {!<=-1,!>=2}
Line 420
  ( always {!<=-1,!>=2}
Line 426
  ( always {!<=-1,!>=2}
Line 432
  ( always {!<=-1,!>=2}
Line 455
  ( always {!<=-1,!>=2}
Line 462
  ( always {!<=-1,!>=2}
Line 480
  ( always {!<=-1,!>=2}
Line 497
  ( always {!<=-1,!>=2}
Line 591
  ( always {!<=-1,!>=2}
Line 640
  , always ""
  = always ""
  "" always ""
Line 680
  ( always {!<=-1,!>=2}
Line 786
  ( always {!<=-1,!>=2}
Line 813
  , always 0
  = always 0
  false always 0
Line 814
  , always 0
  = always 0
  false always 0
Line 816
  ( always {!<=-1,!>=2}
Line 850
  ( always {!<=-1,!>=2}
Line 855
  ( always {!<=-1,!>=2}
Line 856
  return always {!<=-1,!>=2}
  mCodeWithTemplates always {!<=-1,!>=2}
Line 904
  ( always {!<=-1,!>=2}
Line 911
  ( always {!<=-1,!>=2}
Line 918
  ( always {!<=-1,!>=2}
Line 932
  ( always {!<=-1,!>=2}
Line 933
  return always {!<=-1,!>=2}
  false always 0
Line 986
  used always {!<=-1,!>=2}
Line 1000
  mCodeWithTemplates always {!<=-1,!>=2}
Line 65
  , inconclusive lifetime[SubObject]=(errorLogger)
  ( inconclusive lifetime[SubObject]=(errorLogger)
Line 68
  ! always {!<=-1,!>=2}
Line 69
  this always !0
Line 76
  = always 0
  0 always 0
Line 79
  = always 0
  0 always 0
Line 87
  = always 0
  0 always 0
Line 109
  nullptr always 0
Line 114
  nullptr always 0
Line 118
  ( always {!<=-1,!>=2}
Line 123
  return always {!<=-1,!>=2}
  false always 0
Line 135
  0U always 0
  :: always 0
  normal always 0
Line 140
  1 always 1
Line 141
  callstack always size=1
  certainty possible 0@183
Line 146
  0U always 0
  :: always 0
  normal always 0
Line 160
  ( always {!<=-1,!>=2}
Line 42
  hash always !<=-1
Line 56
  NO_LINE always -1
  hash always !<=-1
  0 always 0
  thisAndNextLine always {!<=-1,!>=2}
  false always 0
  matched always {!<=-1,!>=2}
  false always 0
  checked always {!<=-1,!>=2}
  false always 0
Line 58
  this always !0
Line 60
  = always -1
  NO_LINE always -1
  hash always !<=-1
  0 always 0
  thisAndNextLine always {!<=-1,!>=2}
  false always 0
  matched always {!<=-1,!>=2}
  false always 0
  checked always {!<=-1,!>=2}
  false always 0
Line 67
  hash always !<=-1
  = always !<=-1
  . always !<=-1
  hash always !<=-1
Line 68
  thisAndNextLine always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  . always {!<=-1,!>=2}
  thisAndNextLine always {!<=-1,!>=2}
Line 69
  matched always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  . always {!<=-1,!>=2}
  matched always {!<=-1,!>=2}
Line 70
  checked always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  . always {!<=-1,!>=2}
  checked always {!<=-1,!>=2}
Line 71
  this always !0
Line 74
  ( always {!<=-1,!>=2}
Line 75
  != always {!<=-1,!>=2}
Line 76
  return always {!<=-1,!>=2}
  errorId always !symbolic=(other.errorId)
  < always {!<=-1,!>=2}
  . always !symbolic=(errorId)
Line 77
  < always {!<=-1,!>=2}
Line 78
  return always {!<=-1,!>=2}
  true always 1
Line 79
  != always {!<=-1,!>=2}
Line 80
  return always {!<=-1,!>=2}
  fileName always !symbolic=(other.fileName)
  < always {!<=-1,!>=2}
  . always !symbolic=(fileName)
Line 81
  != always {!<=-1,!>=2}
Line 82
  return always {!<=-1,!>=2}
  symbolName always !symbolic=(other.symbolName)
  < always {!<=-1,!>=2}
  . always !symbolic=(symbolName)
Line 83
  hash always !<=-1
  != always {!<=-1,!>=2}
  . always !<=-1
  hash always !<=-1
Line 84
  return always {!<=-1,!>=2}
  hash always {!<=-1,!symbolic=(other.hash)}
  < always {!<=-1,!>=2}
  . always {!<=-1,!symbolic=(hash)}
  hash always !<=-1
Line 85
  thisAndNextLine always {!<=-1,!>=2}
  != always {!<=-1,!>=2}
  . always {!<=-1,!>=2}
  thisAndNextLine always {!<=-1,!>=2}
Line 86
  return always {!<=-1,!>=2}
  thisAndNextLine always {!<=-1,!>=2,!symbolic=(other.thisAndNextLine)}
Line 87
  return always {!<=-1,!>=2}
  false always 0
Line 96
  ( always {!<=-1,!>=2}
Line 98
  ( always {!<=-1,!>=2}
Line 100
  ( always {!<=-1,!>=2}
Line 104
  ( always {!<=-1,!>=2}
Line 105
  return always {!<=-1,!>=2}
  ! {!<=-1,!>=2,0}
  fileName possible size=0
  ( {!<=-1,!>=2,1}
  && always {!<=-1,!>=2}
  fileName always !size=0
  ( always !<=-1
  "?*" always "?*"
  == always {!<=-1,!>=2}
Line 108
  ( always {!<=-1,!>=2}
Line 109
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 110
  == always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 111
  == always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 112
  == always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 113
  hash always !<=-1
  == always {!<=-1,!>=2}
  . always !<=-1
  hash always !<=-1
  && always {!<=-1,!>=2}
Line 114
  thisAndNextLine always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  . always {!<=-1,!>=2}
  thisAndNextLine always {!<=-1,!>=2}
Line 121
  hash always !<=-1
Line 122
  thisAndNextLine always {!<=-1,!>=2}
Line 123
  matched always {!<=-1,!>=2}
Line 124
  checked always {!<=-1,!>=2}
Line 126
  NO_LINE always -1
  = always -1
  -1 always -1
Line 178
  ( always {!<=-1,!>=2}
Line 185
  ( always {!<=-1,!>=2}
Line 197
  unusedFunctionChecking always {!<=-1,!>=2}
Line 203
  unusedFunctionChecking always {!<=-1,!>=2}
Line 28
  Reset always 0
  = always 0
  0 always 0
  , always 1
Line 29
  Bold always 1
  = always 1
  1 always 1
  , always 2
Line 30
  Dim always 2
  = always 2
  2 always 2
  , always 31
Line 31
  FgRed always 31
  = always 31
  31 always 31
  , always 32
Line 32
  FgGreen always 32
  = always 32
  32 always 32
  , always 34
Line 33
  FgBlue always 34
  = always 34
  34 always 34
  , always 35
Line 34
  FgMagenta always 35
  = always 35
  35 always 35
  , always 39
Line 35
  FgDefault always 39
  = always 39
  39 always 39
  , always 41
Line 36
  BgRed always 41
  = always 41
  41 always 41
  , always 42
Line 37
  BgGreen always 42
  = always 42
  42 always 42
  , always 44
Line 38
  BgBlue always 44
  = always 44
  44 always 44
  , always 49
Line 39
  BgDefault always 49
  = always 49
  49 always 49
Line 40
  457U always 457
Line 41
  476U always 476
Line 42
  676U always 676
Line 43
  682U always 682
Line 44
  825U always 825
Line 70
  fileIndex always !<=-1
  0 always 0
  0 always 0
  column always !<=-1
  0 always 0
Line 72
  column always !<=-1
Line 73
  fileIndex always !<=-1
  0 always 0
  column always !<=-1
  column always !<=-1
Line 75
  column always !<=-1
Line 76
  fileIndex always !<=-1
  0 always 0
  column always !<=-1
  column always !<=-1
Line 86
  convert always {!<=-1,!>=2}
  = always 1
  true always 1
Line 93
  convert always {!<=-1,!>=2}
  = always 1
  true always 1
Line 106
  fileIndex always !<=-1
Line 108
  column always !<=-1
Line 175
  verbose always {!<=-1,!>=2}
Line 180
  ( always {!<=-1,!>=2}
Line 190
  incomplete always {!<=-1,!>=2}
Line 197
  hash always !<=-1
Line 243
  ( always " </array>\r\n</dict>\r\n</plist>"
Line 254
  = always 0
  :: always 0
  Reset always 0
  = always 0
  0 always 0
Line 262
  = always 0
  0 always 0
Line 270
  , always !<=-1
  value always !<=-1
Line 272
  stage possible {"Tokenize (simplifyKnownVariables)"@244,"Tokenize (using)"@198,"Tokenize (typedef)"@144}
Line 273
  ( always !<=-1
  value always !<=-1
Line 289
  ( always {!<=-1,!>=2}
Line 303
  " </array>\r\n</dict>\r\n</plist>" always " </array>\r\n</dict>\r\n</plist>"
Line 38
  C89 always 0
  C99 always 1
  C11 always 2
  CLatest always 2
  = always 2
  C11 always 2
Line 41
  CPP03 always 0
  CPP11 always 1
  CPP14 always 2
  CPP17 always 3
  CPP20 always 4
  CPP23 always 5
  CPPLatest always 5
  = always 5
  CPP23 always 5
Line 47
  CLatest always 2
  CPPLatest always 5
Line 49
  ( always {!<=-1,!>=2}
Line 50
  = possible size=3
  str possible size=3
Line 51
  str possible size=3
  == always {!<=-1,!>=2}
  "c89" always "c89"
  || always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  "C89" always "C89"
Line 52
  = always 0
  C89 always 0
Line 53
  return always {!<=-1,!>=2}
  true always 1
Line 55
  str possible size=3
  == always {!<=-1,!>=2}
  "c99" always "c99"
  || always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  "C99" always "C99"
Line 56
  = always 1
  C99 always 1
Line 57
  return always {!<=-1,!>=2}
  true always 1
Line 59
  str possible size=3
  == always {!<=-1,!>=2}
  "c11" always "c11"
  || always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  "C11" always "C11"
Line 60
  = always 2
  C11 always 2
Line 61
  return always {!<=-1,!>=2}
  true always 1
Line 63
  return always {!<=-1,!>=2}
  false always 0
Line 67
  C89 always 0
Line 68
  "c89" always "c89"
Line 69
  C99 always 1
Line 70
  "c99" always "c99"
Line 71
  C11 always 2
Line 72
  "c11" always "c11"
Line 74
  "" always ""
Line 77
  std possible size=3
  == always {!<=-1,!>=2}
  "c89" always "c89"
Line 78
  :: always 0
  C89 always 0
Line 80
  std possible size=3
  == always {!<=-1,!>=2}
  "c99" always "c99"
Line 81
  :: always 1
  C99 always 1
Line 83
  == always {!<=-1,!>=2}
  "c11" always "c11"
Line 84
  :: always 2
  C11 always 2
Line 86
  :: always 2
  CLatest always 2
Line 88
  ( always {!<=-1,!>=2}
Line 92
  return always {!<=-1,!>=2}
  ! {!<=-1,!>=2,0}
  stdValue possible size=0
  ( {!<=-1,!>=2,1}
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
Line 99
  CPP03 always 0
Line 100
  "c++03" always "c++03"
Line 101
  CPP11 always 1
Line 102
  "c++11" always "c++11"
Line 103
  CPP14 always 2
Line 104
  "c++14" always "c++14"
Line 105
  CPP17 always 3
Line 106
  "c++17" always "c++17"
Line 107
  CPP20 always 4
Line 108
  "c++20" always "c++20"
Line 109
  CPP23 always 5
Line 110
  "c++23" always "c++23"
Line 112
  "" always ""
Line 115
  std possible size=5
  == always {!<=-1,!>=2}
  "c++03" always "c++03"
Line 116
  :: always 0
  CPP03 always 0
Line 118
  std possible size=5
  == always {!<=-1,!>=2}
  "c++11" always "c++11"
Line 119
  :: always 1
  CPP11 always 1
Line 121
  std possible size=5
  == always {!<=-1,!>=2}
  "c++14" always "c++14"
Line 122
  :: always 2
  CPP14 always 2
Line 124
  std possible size=5
  == always {!<=-1,!>=2}
  "c++17" always "c++17"
Line 125
  :: always 3
  CPP17 always 3
Line 127
  std possible size=5
  == always {!<=-1,!>=2}
  "c++20" always "c++20"
Line 128
  :: always 4
  CPP20 always 4
Line 130
  == always {!<=-1,!>=2}
  "c++23" always "c++23"
Line 131
  :: always 5
  CPP23 always 5
Line 133
  :: always 5
  CPPLatest always 5
Line 58
  OK always 0
  FILE_NOT_FOUND always 1
  BAD_XML always 2
  UNKNOWN_ELEMENT always 3
  MISSING_ATTRIBUTE always 4
  BAD_ATTRIBUTE_VALUE always 5
  UNSUPPORTED_FORMAT always 6
  DUPLICATE_PLATFORM_TYPE always 7
  PLATFORM_TYPE_REDEFINED always 8
Line 62
  :: always 0
  OK always 0
Line 63
  ( possible lifetime[SubObject]=(e)
Line 65
  ( possible lifetime[SubObject]=(e)
  && always {!<=-1,!>=2}
Line 74
  ( always {!<=-1,!>=2}
  , always !<=-1
  len always !<=-1
Line 79
  none always 0
  malloc always 1
  calloc always 2
  strdup always 3
Line 84
  initData always {!<=-1,!>=2}
Line 118
  ? possible 0
  af always !0
  : always 0
  0 always 0
Line 124
  ? possible 0
  af always !0
  : always 0
  0 always 0
Line 138
  , always 1
  = always 1
  1 always 1
Line 141
  = possible 1
  reallocArg possible 1
Line 145
  , always {!<=-1,!>=2}
  noreturn always {!<=-1,!>=2}
Line 146
  = possible {1,0}
  noreturn always {!<=-1,!>=2}
  ? possible {1,0}
  :: always 1
  True always 1
  : always 0
  :: always 0
  False always 0
Line 149
  ( always {!<=-1,!>=2}
Line 152
  ( always {!<=-1,!>=2}
Line 153
  return always {!<=-1,!>=2}
  > always {!<=-1,!>=2}
  0 always 0
  && always {!<=-1,!>=2}
  id {>=1,!<=0}
  & possible {0,1}
  1 always 1
  == {1,0,!<=-1,!>=2}
  0 always 0
Line 155
  ( always {!<=-1,!>=2}
Line 156
  return always {!<=-1,!>=2}
  > always {!<=-1,!>=2}
  0 always 0
  && always {!<=-1,!>=2}
  . {>=1,!<=0}
  & possible {0,1}
  1 always 1
  == {1,0,!<=-1,!>=2}
  0 always 0
Line 160
  ( always {!<=-1,!>=2}
Line 161
  return always {!<=-1,!>=2}
  > always {!<=-1,!>=2}
  0 always 0
  && always {!<=-1,!>=2}
  id {>=1,!<=0}
  & possible {0,1}
  1 always 1
  == {0,1,!<=-1,!>=2}
  1 always 1
Line 163
  ( always {!<=-1,!>=2}
Line 164
  return always {!<=-1,!>=2}
  > always {!<=-1,!>=2}
  0 always 0
  && always {!<=-1,!>=2}
  . {>=1,!<=0}
  & possible {0,1}
  1 always 1
  == {0,1,!<=-1,!>=2}
  1 always 1
Line 167
  ( always {!<=-1,!>=2}
Line 169
  ( always {!<=-1,!>=2}
Line 170
  ( always {!<=-1,!>=2}
Line 190
  ( always {!<=-1,!>=2}
Line 191
  ( always {!<=-1,!>=2}
Line 193
  NONE always 0
  DEFAULT always 1
  ERROR_CODE always 2
Line 201
  ( always {!<=-1,!>=2}
Line 202
  ( always {!<=-1,!>=2}
Line 204
  ( always {!<=-1,!>=2}
Line 209
  -1 always -1
Line 210
  -1 always -1
Line 211
  arrayLike_indexOp always {!<=-1,!>=2}
  false always 0
Line 212
  stdStringLike always {!<=-1,!>=2}
  false always 0
Line 213
  stdAssociativeLike always {!<=-1,!>=2}
  false always 0
Line 214
  opLessAllowed always {!<=-1,!>=2}
  true always 1
Line 215
  hasInitializerListConstructor always {!<=-1,!>=2}
  false always 0
Line 216
  unstableErase always {!<=-1,!>=2}
  false always 0
Line 217
  unstableInsert always {!<=-1,!>=2}
  false always 0
Line 218
  view always {!<=-1,!>=2}
  false always 0
Line 222
  RESIZE always 0
Line 223
  CLEAR always 1
Line 224
  PUSH always 2
Line 225
  POP always 3
Line 226
  FIND always 4
Line 227
  INSERT always 5
Line 228
  ERASE always 6
Line 229
  CHANGE_CONTENT always 7
Line 230
  CHANGE always 8
Line 231
  CHANGE_INTERNAL always 9
Line 232
  NO_ACTION always 10
Line 235
  AT_INDEX always 0
Line 236
  ITEM always 1
Line 237
  BUFFER always 2
Line 238
  BUFFER_NT always 3
Line 239
  START_ITERATOR always 4
Line 240
  END_ITERATOR always 5
Line 241
  ITERATOR always 6
Line 242
  SIZE always 7
Line 243
  EMPTY always 8
Line 244
  NO_YIELD always 9
Line 259
  arrayLike_indexOp always {!<=-1,!>=2}
Line 260
  stdStringLike always {!<=-1,!>=2}
Line 261
  stdAssociativeLike always {!<=-1,!>=2}
Line 262
  opLessAllowed always {!<=-1,!>=2}
Line 263
  hasInitializerListConstructor always {!<=-1,!>=2}
Line 264
  unstableErase always {!<=-1,!>=2}
Line 265
  unstableInsert always {!<=-1,!>=2}
Line 266
  view always {!<=-1,!>=2}
Line 269
  :: possible {symbolic=(functions.end()),end=0}
  i possible {symbolic=(functions.end()),end=0}
  = possible lifetime[Iterator]=(functions)
  ( possible lifetime[Iterator]=(functions)
Line 270
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(functions),end=0}
Line 271
  i always {!symbolic=(functions.end()),!end=0}
Line 272
  :: always 10
  NO_ACTION always 10
Line 276
  :: possible {symbolic=(functions.end()),end=0}
  i possible {symbolic=(functions.end()),end=0}
  = possible lifetime[Iterator]=(functions)
  ( possible lifetime[Iterator]=(functions)
Line 277
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(functions),end=0}
Line 278
  i always {!symbolic=(functions.end()),!end=0}
Line 279
  :: always 9
  NO_YIELD always 9
Line 286
  , always 0
  iterator always {!<=-1,!>=2}
  = always 0
  false always 0
Line 287
  , always 0
  = always 0
  nullptr always 0
Line 292
  notbool always {!<=-1,!>=2}
  false always 0
Line 293
  notnull always {!<=-1,!>=2}
  false always 0
Line 294
  -1 always -1
Line 295
  formatstr always {!<=-1,!>=2}
  false always 0
Line 296
  strz always {!<=-1,!>=2}
  false always 0
Line 297
  optional always {!<=-1,!>=2}
  false always 0
Line 298
  variadic always {!<=-1,!>=2}
  false always 0
Line 302
  notbool always {!<=-1,!>=2}
Line 303
  notnull always {!<=-1,!>=2}
Line 305
  formatstr always {!<=-1,!>=2}
Line 306
  strz always {!<=-1,!>=2}
Line 307
  optional always {!<=-1,!>=2}
Line 308
  variadic always {!<=-1,!>=2}
Line 313
  0 always 0
  it always {!<=-1,!>=2}
  false always 0
  first always {!<=-1,!>=2}
  false always 0
  last always {!<=-1,!>=2}
  false always 0
Line 316
  it always {!<=-1,!>=2}
Line 317
  first always {!<=-1,!>=2}
Line 318
  last always {!<=-1,!>=2}
Line 324
  NONE always 0
  STRLEN always 1
  ARGVALUE always 2
  SIZEOF always 3
  MUL always 4
  VALUE always 5
Line 325
  ( possible lifetime[SubObject]=(t)
  0 always 0
  0 always 0
Line 334
  DIR_IN always 0
Line 335
  DIR_OUT always 1
Line 336
  DIR_INOUT always 2
Line 337
  DIR_UNKNOWN always 3
Line 344
  use always {!<=-1,!>=2}
Line 345
  leakignore always {!<=-1,!>=2}
Line 346
  isconst always {!<=-1,!>=2}
Line 347
  ispure always {!<=-1,!>=2}
Line 349
  ignore always {!<=-1,!>=2}
Line 350
  formatstr always {!<=-1,!>=2}
Line 351
  formatstr_scan always {!<=-1,!>=2}
Line 352
  formatstr_secure always {!<=-1,!>=2}
Line 356
  use always {!<=-1,!>=2}
  false always 0
Line 357
  leakignore always {!<=-1,!>=2}
  false always 0
Line 358
  isconst always {!<=-1,!>=2}
  false always 0
Line 359
  ispure always {!<=-1,!>=2}
  false always 0
Line 360
  :: always 0
  NONE always 0
Line 361
  ignore always {!<=-1,!>=2}
  false always 0
Line 362
  formatstr always {!<=-1,!>=2}
  false always 0
Line 363
  formatstr_scan always {!<=-1,!>=2}
  false always 0
Line 364
  formatstr_secure always {!<=-1,!>=2}
  false always 0
Line 365
  :: always 10
  NO_ACTION always 10
Line 366
  :: always 9
  NO_YIELD always 9
Line 372
  ( always {!<=-1,!>=2}
Line 373
  ( always {!<=-1,!>=2}
Line 374
  ( always {!<=-1,!>=2}
  , always {!<=-1,!>=2}
  pure always {!<=-1,!>=2}
Line 375
  ( always {!<=-1,!>=2}
Line 377
  ( always {!<=-1,!>=2}
Line 379
  return always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  arg always !0
  . always {!<=-1,!>=2}
  notbool always {!<=-1,!>=2}
Line 382
  ( always {!<=-1,!>=2}
Line 383
  ( always {!<=-1,!>=2}
  , always 0
  = always 0
  0 always 0
  , always 0
  = always 0
  nullptr always 0
Line 385
  ( always {!<=-1,!>=2}
Line 387
  return always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  arg always !0
  . always {!<=-1,!>=2}
  formatstr always {!<=-1,!>=2}
Line 390
  ( always {!<=-1,!>=2}
Line 392
  return always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  arg always !0
  . always {!<=-1,!>=2}
  strz always {!<=-1,!>=2}
Line 395
  ( always {!<=-1,!>=2}
Line 396
  ( always {!<=-1,!>=2}
Line 400
  arg always !0
Line 404
  le always 0
  lt always 1
  eq always 2
  ge always 3
  gt always 4
  range always 5
Line 407
  ( always {!<=-1,!>=2}
Line 408
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 414
  && always {!<=-1,!>=2}
  arg always !0
  . always {!<=-1,!>=2}
  it always {!<=-1,!>=2}
  & {lifetime[Address]=(arg->iteratorInfo),!0}
  arg always !0
  nullptr always 0
Line 417
  ( always {!<=-1,!>=2}
Line 421
  ? possible 0
  & {lifetime[Address]=(arg->minsizes),!0}
  arg always !0
  nullptr always 0
Line 426
  ( always {!<=-1,!>=2}
Line 428
  ( always {!<=-1,!>=2}
Line 434
  ( always {!<=-1,!>=2}
Line 436
  ( always {!<=-1,!>=2}
Line 438
  ( always {!<=-1,!>=2}
Line 445
  ( always {!<=-1,!>=2}
Line 447
  ( always {!<=-1,!>=2}
Line 448
  return always {!<=-1,!>=2}
  ( possible lifetime[Iterator]=(mExporters)
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(mExporters),end=0}
Line 451
  ( always {!<=-1,!>=2}
Line 452
  = possible lifetime[Iterator]=(mExporters)
  ( possible lifetime[Iterator]=(mExporters)
Line 453
  return always {!<=-1,!>=2}
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(mExporters),end=0}
  && always {!<=-1,!>=2}
  it always {!symbolic=(mExporters.end()),!end=0}
Line 456
  ( always {!<=-1,!>=2}
Line 457
  = possible lifetime[Iterator]=(mExporters)
  ( possible lifetime[Iterator]=(mExporters)
Line 458
  return always {!<=-1,!>=2}
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(mExporters),end=0}
  && always {!<=-1,!>=2}
  it always {!symbolic=(mExporters.end()),!end=0}
Line 461
  ( always {!<=-1,!>=2}
Line 466
  ( always {!<=-1,!>=2}
Line 467
  return always {!<=-1,!>=2}
  ( possible lifetime[Iterator]=(mReflection)
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(mReflection),end=0}
Line 471
  :: possible {symbolic=(mReflection.end()),end=0}
  it possible {symbolic=(mReflection.end()),end=0}
  = possible lifetime[Iterator]=(mReflection)
  ( possible lifetime[Iterator]=(mReflection)
Line 472
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(mReflection),end=0}
Line 473
  it always {!symbolic=(mReflection.end()),!end=0}
Line 474
  -1 always -1
Line 480
  = always ""
  "" always ""
Line 481
  unique always {!<=-1,!>=2}
  unique always {!<=-1,!>=2}
  = always 0
  false always 0
Line 485
  ( always {!<=-1,!>=2}
Line 489
  size always !<=-1
Line 491
  NO always 0
  BOOL always 1
  CHAR always 2
  SHORT always 3
  INT always 4
  LONG always 5
  LONGLONG always 6
Line 494
  = possible lifetime[Iterator]=(mPodTypes)
  ( possible lifetime[Iterator]=(mPodTypes)
Line 495
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(mPodTypes),end=0}
  & {lifetime[Address]=(it->second),!0}
  it always {!symbolic=(mPodTypes.end()),!end=0}
  nullptr always 0
Line 500
  mSigned always {!<=-1,!>=2}
  false always 0
Line 501
  mUnsigned always {!<=-1,!>=2}
  false always 0
Line 502
  mLong always {!<=-1,!>=2}
  false always 0
Line 503
  mPointer always {!<=-1,!>=2}
  false always 0
Line 504
  mPtrPtr always {!<=-1,!>=2}
  false always 0
Line 505
  mConstPtr always {!<=-1,!>=2}
  false always 0
Line 506
  ( always {!<=-1,!>=2}
Line 507
  return always {!<=-1,!>=2}
  mSigned always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  . always {!<=-1,!>=2}
  mSigned always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 508
  mUnsigned always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  . always {!<=-1,!>=2}
  mUnsigned always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 509
  mLong always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  . always {!<=-1,!>=2}
  mLong always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 510
  mPointer always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  . always {!<=-1,!>=2}
  mPointer always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 511
  mPtrPtr always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  . always {!<=-1,!>=2}
  mPtrPtr always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 512
  mConstPtr always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  . always {!<=-1,!>=2}
  mConstPtr always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 513
  == always {!<=-1,!>=2}
Line 515
  ( always {!<=-1,!>=2}
Line 516
  return always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  this always !0
  == always {!<=-1,!>=2}
Line 519
  mSigned always {!<=-1,!>=2}
Line 520
  mUnsigned always {!<=-1,!>=2}
Line 521
  mLong always {!<=-1,!>=2}
Line 522
  mPointer always {!<=-1,!>=2}
Line 523
  mPtrPtr always {!<=-1,!>=2}
Line 524
  mConstPtr always {!<=-1,!>=2}
Line 529
  = possible lifetime[Iterator]=(mPlatformTypes)
  ( possible lifetime[Iterator]=(mPlatformTypes)
Line 530
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(mPlatformTypes),end=0}
  & {lifetime[Address]=(it->second),!0}
  it always {!symbolic=(mPlatformTypes.end()),!end=0}
  nullptr always 0
Line 536
  :: possible {symbolic=(mPlatforms.end()),end=0}
  it possible {symbolic=(mPlatforms.end()),end=0}
  = possible lifetime[Iterator]=(mPlatforms)
  ( possible lifetime[Iterator]=(mPlatforms)
Line 537
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(mPlatforms),end=0}
Line 538
  it always {!symbolic=(mPlatforms.end()),!end=0}
Line 540
  type always !0
Line 543
  = possible lifetime[Iterator]=(mPlatformTypes)
  ( possible lifetime[Iterator]=(mPlatformTypes)
Line 544
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(mPlatformTypes),end=0}
  & {lifetime[Address]=(it2->second),!0}
  it2 always {!symbolic=(mPlatformTypes.end()),!end=0}
  nullptr always 0
Line 552
  ( always {!<=-1,!>=2}
  , always ""
  = always ""
  "" always ""
Line 555
  def always 0
  check always 1
  suppress always 2
Line 570
  ( always {!<=-1,!>=2}
Line 571
  return always {!<=-1,!>=2}
  ( possible lifetime[Iterator]=(mPrefixes)
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(mPrefixes),end=0}
Line 573
  ( always {!<=-1,!>=2}
Line 574
  return always {!<=-1,!>=2}
  ( possible lifetime[Iterator]=(mSuffixes)
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(mSuffixes),end=0}
Line 583
  0 always 0
Line 606
  ( always {!<=-1,!>=2}
Line 607
  return always {!<=-1,!>=2}
  ( possible lifetime[Iterator]=(mBlocks)
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(mBlocks),end=0}
Line 616
  False always 0
  True always 1
  Maybe always 2
Line 646
  = possible lifetime[Iterator]=(data)
  ( possible lifetime[Iterator]=(data)
Line 647
  == always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(data),end=0}
  nullptr always 0
  & {lifetime[Address]=(it->second),!0}
  it always {!symbolic=(data.end()),!end=0}
Line 655
  = always 0
  nullptr always 0
Line 44
  >= always {!<=-1,!>=2}
  64 always 64
Line 46
  - possible >=-4611686018427387904
  1LL always 1
  << possible <=4611686018427387904
  bit {!>=64,<=63}
  - {!>=63,<=62}
  1 always 1
Line 50
  >= always {!<=-1,!>=2}
  64 always 64
Line 51
  ~ always !<=-1
  0ULL always 0
  >> always !<=-1
  1 always 1
Line 52
  1LL always 1
  << possible <=4611686018427387904
  bit {!>=64,<=63}
  - {!>=63,<=62}
  1 always 1
  - {<=4611686018427387903,!>=4611686018427387904}
  1LL always 1
Line 58
  ( always {!<=-1,!>=2}
Line 59
  return always {!<=-1,!>=2}
  >= always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  <= always {!<=-1,!>=2}
Line 62
  ( always {!<=-1,!>=2}
  value always !<=-1
Line 63
  intMax always !<=-1
  intMax always !<=-1
  = always !<=-1
Line 64
  return always {!<=-1,!>=2}
  value always !<=-1
  <= always {!<=-1,!>=2}
  intMax always !<=-1
Line 67
  ( always {!<=-1,!>=2}
Line 68
  return always {!<=-1,!>=2}
  >= always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  <= always {!<=-1,!>=2}
Line 71
  ( always {!<=-1,!>=2}
  value always !<=-1
Line 72
  longMax always !<=-1
  longMax always !<=-1
  = always !<=-1
Line 73
  return always {!<=-1,!>=2}
  value always !<=-1
  <= always {!<=-1,!>=2}
  longMax always !<=-1
Line 76
  ( always {!<=-1,!>=2}
  value always !<=-1
Line 77
  longLongMax always !<=-1
  longLongMax always !<=-1
  = always !<=-1
Line 78
  return always {!<=-1,!>=2}
  value always !<=-1
  <= always {!<=-1,!>=2}
  longLongMax always !<=-1
Line 103
  Unspecified always 0
Line 104
  Native always 1
Line 105
  Win32A always 2
Line 106
  Win32W always 3
Line 107
  Win64 always 4
Line 108
  Unix32 always 5
Line 109
  Unix64 always 6
Line 110
  PlatformFile always 7
Line 117
  ( always {!<=-1,!>=2}
Line 125
  ( always {!<=-1,!>=2}
Line 128
  ( always {!<=-1,!>=2}
Line 134
  ( always {!<=-1,!>=2}
Line 135
  return always {!<=-1,!>=2}
  platformType possible {3,4}
  == {!<=-1,!>=2,0}
  Win32A always 2
  || always {!<=-1,!>=2}
Line 136
  platformType {4,!2}
  == {!<=-1,!>=2,0}
  Win32W always 3
  || always {!<=-1,!>=2}
Line 137
  platformType always {!2,!3}
  == always {!<=-1,!>=2}
  Win64 always 4
Line 146
  Unspecified always 0
Line 147
  "Unspecified" always "Unspecified"
Line 148
  Native always 1
Line 149
  "Native" always "Native"
Line 150
  Win32A always 2
Line 151
  "win32A" always "win32A"
Line 152
  Win32W always 3
Line 153
  "win32W" always "win32W"
Line 154
  Win64 always 4
Line 155
  "win64" always "win64"
Line 156
  Unix32 always 5
Line 157
  "unix32" always "unix32"
Line 158
  Unix64 always 6
Line 159
  "unix64" always "unix64"
Line 160
  PlatformFile always 7
Line 161
  "platformFile" always "platformFile"
Line 163
  "unknown" always "unknown"
Line 168
  1 always 1
Line 53
  linenr always !<=-1
Line 77
  NoHeader always 0
  = always 0
  0 always 0
  , always 1
Line 78
  UserHeader always 1
  , always 2
Line 79
  SystemHeader always 2
Line 85
  , always 0
  = always 0
  nullptr always 0
Line 105
  , always {!<=-1,!>=2}
  throwError always {!<=-1,!>=2}
Line 107
  ( always {!<=-1,!>=2}
Line 145
  , always 0
  throwError always {!<=-1,!>=2}
  = always 0
  false always 0
Line 147
  , always {!<=-1,!>=2}
  writeLocations always {!<=-1,!>=2}
Line 163
  ( always {!<=-1,!>=2}
Line 164
  , always !<=-1
  line always !<=-1
Line 173
  ( always !<=-1
Line 195
  , always {!<=-1,!>=2}
  showerror always {!<=-1,!>=2}
Line 198
  , always !<=-1
  linenr always !<=-1
Line 199
  , always !<=-1
  linenr always !<=-1
Line 40
  ( always {!<=-1,!>=2}
Line 41
  return always {!<=-1,!>=2}
  < always {!<=-1,!>=2}
  0 always 0
Line 54
  UNKNOWN always 0
Line 55
  MISSING always 1
Line 56
  FAILURE always 2
Line 57
  COMPILE_DB always 3
Line 58
  VS_SLN always 4
Line 59
  VS_VCXPROJ always 5
Line 60
  BORLAND always 6
Line 61
  CPPCHECK_GUI always 7
Line 66
  :: always 0
  Unspecified always 0
  msc always {!<=-1,!>=2}
  false always 0
  useMfc always {!<=-1,!>=2}
  false always 0
Line 71
  msc always {!<=-1,!>=2}
  ? possible {";_MSC_VER=1900",""}
  ";_MSC_VER=1900" always ";_MSC_VER=1900"
  : always ""
  "" always ""
  useMfc always {!<=-1,!>=2}
  ? possible {";__AFXWIN_H__=1",""}
  ";__AFXWIN_H__=1" always ";__AFXWIN_H__=1"
  : always ""
  "" always ""
Line 78
  msc always {!<=-1,!>=2}
Line 79
  useMfc always {!<=-1,!>=2}
Line 108
  , always 0
  = always 0
  nullptr always 0
Line 110
  ( always {!<=-1,!>=2}
Line 111
  ( always {!<=-1,!>=2}
Line 112
  ( always {!<=-1,!>=2}
Line 114
  ( always {!<=-1,!>=2}
Line 115
  ( always {!<=-1,!>=2}
Line 116
  ( always {!<=-1,!>=2}
Line 128
  8 always 8
  = always "project"
  "project" always "project"
Line 129
  8 always 8
  = always "version"
  "version" always "version"
Line 130
  2 always 2
  = always "1"
  "1" always "1"
Line 131
  9 always 9
  = always "builddir"
  "builddir" always "builddir"
Line 132
  14 always 14
  = always "importproject"
  "importproject" always "importproject"
Line 133
  23 always 23
  = always "analyze-all-vs-configs"
  "analyze-all-vs-configs" always "analyze-all-vs-configs"
Line 134
  7 always 7
  = always "parser"
  "parser" always "parser"
Line 135
  12 always 12
  = always "bug-hunting"
  "bug-hunting" always "bug-hunting"
Line 136
  11 always 11
  = always "includedir"
  "includedir" always "includedir"
Line 137
  4 always 4
  = always "dir"
  "dir" always "dir"
Line 138
  5 always 5
  = always "name"
  "name" always "name"
Line 139
  8 always 8
  = always "defines"
  "defines" always "defines"
Line 140
  7 always 7
  = always "define"
  "define" always "define"
Line 141
  5 always 5
  = always "name"
  "name" always "name"
Line 142
  10 always 10
  = always "undefines"
  "undefines" always "undefines"
Line 143
  9 always 9
  = always "undefine"
  "undefine" always "undefine"
Line 144
  6 always 6
  = always "paths"
  "paths" always "paths"
Line 145
  4 always 4
  = always "dir"
  "dir" always "dir"
Line 146
  5 always 5
  = always "name"
  "name" always "name"
Line 147
  5 always 5
  = always "root"
  "root" always "root"
Line 148
  5 always 5
  = always "name"
  "name" always "name"
Line 149
  7 always 7
  = always "ignore"
  "ignore" always "ignore"
Line 150
  5 always 5
  = always "path"
  "path" always "path"
Line 151
  5 always 5
  = always "name"
  "name" always "name"
Line 152
  8 always 8
  = always "exclude"
  "exclude" always "exclude"
Line 153
  5 always 5
  = always "path"
  "path" always "path"
Line 154
  5 always 5
  = always "name"
  "name" always "name"
Line 155
  19 always 19
  = always "function-contracts"
  "function-contracts" always "function-contracts"
Line 156
  19 always 19
  = always "variable-contracts"
  "variable-contracts" always "variable-contracts"
Line 157
  10 always 10
  = always "libraries"
  "libraries" always "libraries"
Line 158
  8 always 8
  = always "library"
  "library" always "library"
Line 159
  9 always 9
  = always "platform"
  "platform" always "platform"
Line 160
  13 always 13
  = always "suppressions"
  "suppressions" always "suppressions"
Line 161
  12 always 12
  = always "suppression"
  "suppression" always "suppression"
Line 162
  6 always 6
  = always "addon"
  "addon" always "addon"
Line 163
  7 always 7
  = always "addons"
  "addons" always "addons"
Line 164
  5 always 5
  = always "tool"
  "tool" always "tool"
Line 165
  6 always 6
  = always "tools"
  "tools" always "tools"
Line 166
  5 always 5
  = always "tags"
  "tags" always "tags"
Line 167
  4 always 4
  = always "tag"
  "tag" always "tag"
Line 168
  13 always 13
  = always "tag-warnings"
  "tag-warnings" always "tag-warnings"
Line 169
  4 always 4
  = always "tag"
  "tag" always "tag"
Line 170
  8 always 8
  = always "warning"
  "warning" always "warning"
Line 171
  5 always 5
  = always "hash"
  "hash" always "hash"
Line 172
  14 always 14
  = always "check-headers"
  "check-headers" always "check-headers"
Line 173
  23 always 23
  = always "check-unused-templates"
  "check-unused-templates" always "check-unused-templates"
Line 174
  14 always 14
  = always "max-ctu-depth"
  "max-ctu-depth" always "max-ctu-depth"
Line 175
  23 always 23
  = always "max-template-recursion"
  "max-template-recursion" always "max-template-recursion"
Line 176
  37 always 37
  = always "check-unknown-function-return-values"
  "check-unknown-function-return-values" always "check-unknown-function-return-values"
Line 177
  11 always 11
  = always "clang-tidy"
  "clang-tidy" always "clang-tidy"
Line 178
  5 always 5
  = always "name"
  "name" always "name"
Line 179
  18 always 18
  = always "vs-configurations"
  "vs-configurations" always "vs-configurations"
Line 180
  7 always 7
  = always "config"
  "config" always "config"
Line 30
  SHOWTIME_NONE always 0
  = always 0
  0 always 0
  , always 1
Line 31
  SHOWTIME_FILE always 1
  , always 2
Line 32
  SHOWTIME_SUMMARY always 2
  , always 3
Line 33
  SHOWTIME_TOP5 always 3
Line 40
  = always 0
  0 always 0
Line 48
  0 always 0
Line 49
  0 always 0
Line 52
  ( always !<=-1
  ( always !<=-1
Line 70
  , always 0
  = always 0
  nullptr always 0
Line 82
  mStopped always {!<=-1,!>=2}
Line 114
  checkAllConfigurations always {!<=-1,!>=2}
Line 117
  checkConfiguration always {!<=-1,!>=2}
Line 122
  checkHeaders always {!<=-1,!>=2}
Line 125
  checkLibrary always {!<=-1,!>=2}
Line 131
  checkUnusedTemplates always {!<=-1,!>=2}
Line 134
  clang always {!<=-1,!>=2}
Line 140
  clangTidy always {!<=-1,!>=2}
Line 152
  daca always {!<=-1,!>=2}
Line 155
  debugnormal always {!<=-1,!>=2}
Line 158
  debugSimplified always {!<=-1,!>=2}
Line 161
  debugtemplate always {!<=-1,!>=2}
Line 164
  debugwarnings always {!<=-1,!>=2}
Line 167
  dump always {!<=-1,!>=2}
Line 171
  None always 0
  C always 1
  CPP always 2
Line 178
  exceptionHandling always {!<=-1,!>=2}
Line 191
  force always {!<=-1,!>=2}
Line 198
  inlineSuppressions always {!<=-1,!>=2}
Line 202
  jobs always !<=-1
Line 207
  jointSuppressionReport always {!<=-1,!>=2}
Line 243
  preprocessOnly always {!<=-1,!>=2}
Line 248
  quiet always {!<=-1,!>=2}
Line 251
  relativePaths always {!<=-1,!>=2}
Line 254
  reportProgress always {!<=-1,!>=2}
Line 260
  "simple" always "simple"
Line 261
  "rule" always "rule"
Line 262
  :: always 3
  style always 3
Line 280
  classes always {!<=-1,!>=2}
  false always 0
  externalFunctions always {!<=-1,!>=2}
  false always 0
  internalFunctions always {!<=-1,!>=2}
  false always 0
  externalVariables always {!<=-1,!>=2}
  false always 0
Line 289
  classes always {!<=-1,!>=2}
  = always 0
  externalFunctions always {!<=-1,!>=2}
  = always 0
  internalFunctions always {!<=-1,!>=2}
  = always 0
  externalVariables always {!<=-1,!>=2}
  = always 0
  false always 0
Line 298
  classes always {!<=-1,!>=2}
Line 305
  externalFunctions always {!<=-1,!>=2}
Line 311
  internalFunctions always {!<=-1,!>=2}
Line 317
  externalVariables always {!<=-1,!>=2}
Line 350
  verbose always {!<=-1,!>=2}
Line 353
  xml always {!<=-1,!>=2}
Line 362
  ( always {!<=-1,!>=2}
Line 364
  ( always !<=-1
  >= always {!<=-1,!>=2}
  ( always !<=-1
  && always {!<=-1,!>=2}
  0 always 0
  ( {!<=-1,<=symbolic=(file.length()),!>=symbolic=(file.length()+1)}
  == always {!<=-1,!>=2}
  0 always 0
Line 365
  return always {!<=-1,!>=2}
  true always 1
Line 368
  return always {!<=-1,!>=2}
  false always 0
Line 383
  ( always {!<=-1,!>=2}
  , always 0
  inconclusiveCheck always {!<=-1,!>=2}
  = always 0
  false always 0
Line 386
  ( always {!<=-1,!>=2}
Line 387
  return always {!<=-1,!>=2}
  ( possible lifetime[Iterator]=(libraries)
  ( {lifetime[Iterator]=(libraries),start=0}
  ( {lifetime[Iterator]=(libraries),end=0}
  "posix" always "posix"
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(libraries),end=0}
Line 391
  t always {!<=-1,!>=2}
  = always 1
  true always 1
Line 392
  = always {!<=-1,!>=2}
  t always {!<=-1,!>=2}
Line 396
  ( always {!<=-1,!>=2}
Line 397
  return always {!<=-1,!>=2}
Line 55
  Public always 0
  Protected always 1
  Private always 2
  Global always 3
  Namespace always 4
  Argument always 5
  Local always 6
  Throw always 7
Line 61
  nullptr always 0
  0 always 0
  known always {!<=-1,!>=2}
  true always 1
Line 65
  known always {!<=-1,!>=2}
Line 75
  Unknown always 0
  True always 1
  False always 2
Line 81
  nullptr always 0
  nullptr always 0
  :: always 0
  Public always 0
  isVirtual always {!<=-1,!>=2}
  false always 0
Line 87
  isVirtual always {!<=-1,!>=2}
Line 89
  ( always {!<=-1,!>=2}
Line 90
  return always {!<=-1,!>=2}
  this always !0
  < always {!<=-1,!>=2}
Line 96
  nullptr always 0
  nullptr always 0
  nullptr always 0
Line 110
  = always 0
  nullptr always 0
  = always 0
  nullptr always 0
  = always 0
  nullptr always 0
Line 111
  classDef_ inconclusive 0
Line 115
  nullptr always 0
Line 116
  nullptr always 0
Line 117
  0 always 0
Line 118
  classDef_ possible 0
  && always {!<=-1,!>=2}
  classDef_ always !0
  == always {!<=-1,!>=2}
  "enum" always "enum"
Line 119
  = always 1
  :: always 1
  True always 1
Line 120
  classDef_ possible 0
  && always {!<=-1,!>=2}
  classDef_ always !0
  == always {!<=-1,!>=2}
  "using" always "using"
Line 121
  3 always 3
Line 123
  && always {!<=-1,!>=2}
  ( always !0
  != always {!<=-1,!>=2}
  ";" always ";"
Line 124
  = always !0
  ( always !0
Line 131
  classDef always !0
Line 134
  ( always {!<=-1,!>=2}
Line 135
  ( always {!<=-1,!>=2}
Line 136
  ( always {!<=-1,!>=2}
Line 137
  ( always {!<=-1,!>=2}
Line 139
  ( always {!<=-1,!>=2}
Line 140
  return always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  classDef always !0
  == always {!<=-1,!>=2}
  "using" always "using"
Line 152
  ( always {!<=-1,!>=2}
  = always 0
  nullptr always 0
Line 159
  ( always {!<=-1,!>=2}
Line 161
  ( always {!<=-1,!>=2}
Line 166
  nullptr always 0
  0 always 0
  nullptr always 0
  nullptr always 0
  value_known always {!<=-1,!>=2}
  false always 0
Line 172
  value_known always {!<=-1,!>=2}
Line 179
  fIsMutable always 1
  = always 1
  1 always 1
  << always 1
  0 always 0
  , always 2
Line 180
  fIsStatic always 2
  = always 2
  1 always 1
  << always 2
  1 always 1
  , always 4
Line 181
  fIsConst always 4
  = always 4
  1 always 1
  << always 4
  2 always 2
  , always 8
Line 182
  fIsExtern always 8
  = always 8
  1 always 1
  << always 8
  3 always 3
  , always 16
Line 183
  fIsClass always 16
  = always 16
  1 always 1
  << always 16
  4 always 4
  , always 32
Line 184
  fIsArray always 32
  = always 32
  1 always 1
  << always 32
  5 always 5
  , always 64
Line 185
  fIsPointer always 64
  = always 64
  1 always 1
  << always 64
  6 always 6
  , always 128
Line 186
  fIsReference always 128
  = always 128
  1 always 1
  << always 128
  7 always 7
  , always 256
Line 187
  fIsRValueRef always 256
  = always 256
  1 always 1
  << always 256
  8 always 8
  , always 512
Line 188
  fHasDefault always 512
  = always 512
  1 always 1
  << always 512
  9 always 9
  , always 1024
Line 189
  fIsStlType always 1024
  = always 1024
  1 always 1
  << always 1024
  10 always 10
  , always 2048
Line 190
  fIsStlString always 2048
  = always 2048
  1 always 1
  << always 2048
  11 always 11
  , always 4096
Line 191
  fIsFloatType always 4096
  = always 4096
  1 always 1
  << always 4096
  12 always 12
  , always 8192
Line 192
  fIsVolatile always 8192
  = always 8192
  1 always 1
  << always 8192
  13 always 13
  , always 16384
Line 193
  fIsSmartPointer always 16384
  = always 16384
  1 always 1
  << always 16384
  14 always 14
  , always 32768
Line 194
  fIsMaybeUnused always 32768
  = always 32768
  1 always 1
  << always 32768
  15 always 15
  , always 65536
Line 195
  fIsInit always 65536
  = always 65536
  1 always 1
  << always 65536
  16 always 16
Line 203
  ( always {!<=-1,!>=2}
  flag_ always !<=-1
Line 204
  return always {!<=-1,!>=2}
  mFlags always !<=-1
  & always !<=-1
  flag_ {!<=-1,32768@127,4096@130,16384@133,2048@134,1024@135,65536@136,512@137,256@138,128@139}
  != always {!<=-1,!>=2}
  0 always 0
Line 212
  flag_ always !<=-1
  state_ always {!<=-1,!>=2}
Line 213
  mFlags always !<=-1
  = always !<=-1
  state_ always {!<=-1,!>=2}
  ? always !<=-1
  mFlags always !<=-1
  | always !<=-1
  flag_ always !<=-1
  : always !<=-1
  mFlags always !<=-1
  & always !<=-1
  ~ always !<=0
  flag_ always !<=-1
Line 222
  ( always {!<=-1,!>=2}
Line 233
  mFlags always !<=-1
  0 always 0
  , possible lifetime[SubObject]=(type_)
Line 234
  ( possible lifetime[SubObject]=(type_)
Line 236
  nullptr always 0
Line 300
  mNameToken always !0
Line 312
  mNameToken always !0
Line 314
  0 always 0
Line 329
  ( always {!<=-1,!>=2}
Line 330
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 0
  Public always 0
Line 337
  ( always {!<=-1,!>=2}
Line 338
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 1
  Protected always 1
Line 345
  ( always {!<=-1,!>=2}
Line 346
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 2
  Private always 2
Line 353
  ( always {!<=-1,!>=2}
Line 354
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 3
  Global always 3
Line 361
  ( always {!<=-1,!>=2}
Line 362
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 4
  Namespace always 4
Line 369
  ( always {!<=-1,!>=2}
Line 370
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 5
  Argument always 5
Line 377
  ( always {!<=-1,!>=2}
Line 378
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 385
  ( always {!<=-1,!>=2}
Line 386
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsMutable always 1
Line 393
  ( always {!<=-1,!>=2}
Line 394
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsVolatile always 8192
Line 401
  ( always {!<=-1,!>=2}
Line 402
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsStatic always 2
Line 409
  ( always {!<=-1,!>=2}
Line 410
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsExtern always 8
Line 417
  ( always {!<=-1,!>=2}
Line 418
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsConst always 4
Line 425
  ( always {!<=-1,!>=2}
Line 426
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 7
  Throw always 7
Line 433
  ( always {!<=-1,!>=2}
Line 434
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsClass always 16
Line 441
  ( always {!<=-1,!>=2}
Line 442
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsArray always 32
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsPointer always 64
Line 449
  ( always {!<=-1,!>=2}
Line 450
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsPointer always 64
Line 457
  ( always {!<=-1,!>=2}
Line 458
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsArray always 32
Line 465
  ( always {!<=-1,!>=2}
Line 471
  ( always {!<=-1,!>=2}
Line 472
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsArray always 32
  || always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsPointer always 64
Line 479
  ( always {!<=-1,!>=2}
Line 480
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsReference always 128
Line 487
  ( always {!<=-1,!>=2}
Line 488
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsRValueRef always 256
Line 495
  ( always {!<=-1,!>=2}
Line 501
  ( always {!<=-1,!>=2}
Line 502
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fHasDefault always 512
Line 509
  ( always {!<=-1,!>=2}
Line 510
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsInit always 65536
Line 526
  ? possible 0
  mType always !0
  : always 0
  nullptr always 0
Line 557
  ( always {!<=-1,!>=2}
Line 558
  return always {!<=-1,!>=2}
  . always {!<=-1,!>=2}
  known always {!<=-1,!>=2}
Line 569
  ( always {!<=-1,!>=2}
Line 570
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsStlType always 1024
Line 581
  ( always {!<=-1,!>=2}
Line 582
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsStlString always 2048
Line 585
  ( always {!<=-1,!>=2}
Line 586
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsSmartPointer always 16384
Line 601
  ( always {!<=-1,!>=2}
Line 602
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  2 always 2
Line 615
  ( always {!<=-1,!>=2}
Line 616
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( possible lifetime[Iterator]=(stlTypes)
  2 always 2
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(stlTypes),end=0}
Line 623
  ( always {!<=-1,!>=2}
Line 624
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsFloatType always 4096
Line 631
  ( always {!<=-1,!>=2}
Line 632
  return always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always !0
  ( always {!<=-1,!>=2}
Line 635
  ( always {!<=-1,!>=2}
Line 636
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsMaybeUnused always 32768
Line 679
  mFlags always !<=-1
Line 702
  fHasBody always 1
  = always 1
  1 always 1
  << always 1
  0 always 0
  , always 2
Line 703
  fIsInline always 2
  = always 2
  1 always 1
  << always 2
  1 always 1
  , always 4
Line 704
  fIsConst always 4
  = always 4
  1 always 1
  << always 4
  2 always 2
  , always 8
Line 705
  fHasVirtualSpecifier always 8
  = always 8
  1 always 1
  << always 8
  3 always 3
  , always 16
Line 706
  fIsPure always 16
  = always 16
  1 always 1
  << always 16
  4 always 4
  , always 32
Line 707
  fIsStatic always 32
  = always 32
  1 always 1
  << always 32
  5 always 5
  , always 64
Line 708
  fIsStaticLocal always 64
  = always 64
  1 always 1
  << always 64
  6 always 6
  , always 128
Line 709
  fIsExtern always 128
  = always 128
  1 always 1
  << always 128
  7 always 7
  , always 256
Line 710
  fIsFriend always 256
  = always 256
  1 always 1
  << always 256
  8 always 8
  , always 512
Line 711
  fIsExplicit always 512
  = always 512
  1 always 1
  << always 512
  9 always 9
  , always 1024
Line 712
  fIsDefault always 1024
  = always 1024
  1 always 1
  << always 1024
  10 always 10
  , always 2048
Line 713
  fIsDelete always 2048
  = always 2048
  1 always 1
  << always 2048
  11 always 11
  , always 4096
Line 714
  fHasOverrideSpecifier always 4096
  = always 4096
  1 always 1
  << always 4096
  12 always 12
  , always 8192
Line 715
  fHasFinalSpecifier always 8192
  = always 8192
  1 always 1
  << always 8192
  13 always 13
  , always 16384
Line 716
  fIsNoExcept always 16384
  = always 16384
  1 always 1
  << always 16384
  14 always 14
  , always 32768
Line 717
  fIsThrow always 32768
  = always 32768
  1 always 1
  << always 32768
  15 always 15
  , always 65536
Line 718
  fIsOperator always 65536
  = always 65536
  1 always 1
  << always 65536
  16 always 16
  , always 131072
Line 719
  fHasLvalRefQual always 131072
  = always 131072
  1 always 1
  << always 131072
  17 always 17
  , always 262144
Line 720
  fHasRvalRefQual always 262144
  = always 262144
  1 always 1
  << always 262144
  18 always 18
  , always 524288
Line 721
  fIsVariadic always 524288
  = always 524288
  1 always 1
  << always 524288
  19 always 19
  , always 1048576
Line 722
  fIsVolatile always 1048576
  = always 1048576
  1 always 1
  << always 1048576
  20 always 20
  , always 2097152
Line 723
  fHasTrailingReturnType always 2097152
  = always 2097152
  1 always 1
  << always 2097152
  21 always 21
  , always 4194304
Line 724
  fIsEscapeFunction always 4194304
  = always 4194304
  1 always 1
  << always 4194304
  22 always 22
  , always 8388608
Line 725
  fIsInlineKeyword always 8388608
  = always 8388608
  1 always 1
  << always 8388608
  23 always 23
  , always 16777216
Line 726
  fIsConstexpr always 16777216
  = always 16777216
  1 always 1
  << always 16777216
  24 always 24
Line 734
  ( always {!<=-1,!>=2}
  flag always !<=-1
Line 735
  return always {!<=-1,!>=2}
  mFlags always !<=-1
  & always !<=-1
  flag {!<=-1,16777216@92,4194304@94,8388608@95,2097152@97,1048576@98,524288@99,262144@100,131072@101,65536@102}
  != always {!<=-1,!>=2}
  0 always 0
Line 743
  flag always !<=-1
  state always {!<=-1,!>=2}
Line 744
  mFlags always !<=-1
  = always !<=-1
  state always {!<=-1,!>=2}
  ? always !<=-1
  mFlags always !<=-1
  | always !<=-1
  flag {!<=-1,8388608@70,2097152@71,1048576@72,524288@73,262144@74,131072@75,65536@76,32768@77,16384@78}
  : always !<=-1
  mFlags always !<=-1
  & always !<=-1
  ~ {!<=0,4286578687@70,4292870143@71,4293918719@72,4294443007@73,4294705151@74,4294836223@75,4294901759@76,4294934527@77,4294950911@78}
  flag {!<=-1,8388608@70,2097152@71,1048576@72,524288@73,262144@74,131072@75,65536@76,32768@77,16384@78}
Line 748
  eConstructor always 0
  eCopyConstructor always 1
  eMoveConstructor always 2
  eOperatorEqual always 3
  eDestructor always 4
  eFunction always 5
  eLambda always 6
Line 760
  ( always !<=-1
Line 763
  ( always !<=-1
  - always !<=-1
Line 772
  ( always {!<=-1,!>=2}
  defaultVal always {!<=-1,!>=2}
  = always 0
  false always 0
Line 777
  = always 0
  nullptr always 0
Line 779
  ( always {!<=-1,!>=2}
Line 780
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  eLambda always 6
Line 783
  ( always {!<=-1,!>=2}
Line 784
  return always {!<=-1,!>=2}
  type possible {1,2}
  == {!<=-1,!>=2,0}
  eConstructor always 0
  || always {!<=-1,!>=2}
Line 785
  type {2,!0}
  == {!<=-1,!>=2,0}
  eCopyConstructor always 1
  || always {!<=-1,!>=2}
Line 786
  type always {!0,!1}
  == always {!<=-1,!>=2}
  eMoveConstructor always 2
Line 789
  ( always {!<=-1,!>=2}
Line 790
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  eDestructor always 4
Line 792
  ( always {!<=-1,!>=2}
Line 793
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 795
  ( always {!<=-1,!>=2}
Line 796
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 798
  ( always {!<=-1,!>=2}
Line 799
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 801
  ( always {!<=-1,!>=2}
Line 802
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 804
  ( always {!<=-1,!>=2}
Line 805
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 807
  ( always {!<=-1,!>=2}
Line 808
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 810
  ( always {!<=-1,!>=2}
Line 811
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 814
  ( always {!<=-1,!>=2}
Line 815
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fHasBody always 1
Line 817
  ( always {!<=-1,!>=2}
Line 818
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsInline always 2
Line 820
  ( always {!<=-1,!>=2}
Line 821
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsConst always 4
Line 823
  ( always {!<=-1,!>=2}
Line 824
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fHasVirtualSpecifier always 8
Line 826
  ( always {!<=-1,!>=2}
Line 827
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsPure always 16
Line 829
  ( always {!<=-1,!>=2}
Line 830
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsStatic always 32
Line 832
  ( always {!<=-1,!>=2}
Line 833
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsStaticLocal always 64
Line 835
  ( always {!<=-1,!>=2}
Line 836
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsExtern always 128
Line 838
  ( always {!<=-1,!>=2}
Line 839
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsFriend always 256
Line 841
  ( always {!<=-1,!>=2}
Line 842
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsExplicit always 512
Line 844
  ( always {!<=-1,!>=2}
Line 845
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsDefault always 1024
Line 847
  ( always {!<=-1,!>=2}
Line 848
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsDelete always 2048
Line 850
  ( always {!<=-1,!>=2}
Line 851
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsNoExcept always 16384
Line 853
  ( always {!<=-1,!>=2}
Line 854
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsThrow always 32768
Line 856
  ( always {!<=-1,!>=2}
Line 857
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fHasOverrideSpecifier always 4096
Line 859
  ( always {!<=-1,!>=2}
Line 860
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fHasFinalSpecifier always 8192
Line 862
  ( always {!<=-1,!>=2}
Line 863
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsOperator always 65536
Line 865
  ( always {!<=-1,!>=2}
Line 866
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fHasLvalRefQual always 131072
Line 868
  ( always {!<=-1,!>=2}
Line 869
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fHasRvalRefQual always 262144
Line 871
  ( always {!<=-1,!>=2}
Line 872
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsVariadic always 524288
Line 874
  ( always {!<=-1,!>=2}
Line 875
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsVolatile always 1048576
Line 877
  ( always {!<=-1,!>=2}
Line 878
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fHasTrailingReturnType always 2097152
Line 880
  state always {!<=-1,!>=2}
Line 881
  fHasBody always 1
  state always {!<=-1,!>=2}
Line 883
  ( always {!<=-1,!>=2}
Line 884
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsInlineKeyword always 8388608
Line 887
  ( always {!<=-1,!>=2}
Line 888
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsEscapeFunction always 4194304
Line 890
  state always {!<=-1,!>=2}
Line 891
  fIsEscapeFunction always 4194304
  state always {!<=-1,!>=2}
Line 894
  ( always {!<=-1,!>=2}
Line 895
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsConstexpr always 16777216
Line 897
  state always {!<=-1,!>=2}
Line 898
  fIsConstexpr always 16777216
  state always {!<=-1,!>=2}
Line 900
  ( always {!<=-1,!>=2}
Line 919
  ( always {!<=-1,!>=2}
Line 921
  ( always {!<=-1,!>=2}
  , always 0
  unknown always {!<=-1,!>=2}
  = always 0
  false always 0
Line 923
  ( always {!<=-1,!>=2}
  , always 0
  unknown always {!<=-1,!>=2}
  = always 0
  false always 0
Line 925
  ( always {!<=-1,!>=2}
  , always 0
  unknown always {!<=-1,!>=2}
  = always 0
  false always 0
Line 930
  this always !0
  ( always {!<=-1,!>=2}
Line 931
  "{|;" always "{|;"
Line 947
  mFlags always !<=-1
Line 949
  state always {!<=-1,!>=2}
Line 950
  fIsInline always 2
  state always {!<=-1,!>=2}
Line 952
  state always {!<=-1,!>=2}
Line 953
  fIsConst always 4
  state always {!<=-1,!>=2}
Line 955
  state always {!<=-1,!>=2}
Line 956
  fHasVirtualSpecifier always 8
  state always {!<=-1,!>=2}
Line 958
  state always {!<=-1,!>=2}
Line 959
  fIsPure always 16
  state always {!<=-1,!>=2}
Line 961
  state always {!<=-1,!>=2}
Line 962
  fIsStatic always 32
  state always {!<=-1,!>=2}
Line 964
  state always {!<=-1,!>=2}
Line 965
  fIsStaticLocal always 64
  state always {!<=-1,!>=2}
Line 967
  state always {!<=-1,!>=2}
Line 968
  fIsExtern always 128
  state always {!<=-1,!>=2}
Line 970
  state always {!<=-1,!>=2}
Line 971
  fIsFriend always 256
  state always {!<=-1,!>=2}
Line 973
  state always {!<=-1,!>=2}
Line 974
  fIsExplicit always 512
  state always {!<=-1,!>=2}
Line 976
  state always {!<=-1,!>=2}
Line 977
  fIsDefault always 1024
  state always {!<=-1,!>=2}
Line 979
  state always {!<=-1,!>=2}
Line 980
  fIsDelete always 2048
  state always {!<=-1,!>=2}
Line 982
  state always {!<=-1,!>=2}
Line 983
  fIsNoExcept always 16384
  state always {!<=-1,!>=2}
Line 985
  state always {!<=-1,!>=2}
Line 986
  fIsThrow always 32768
  state always {!<=-1,!>=2}
Line 988
  state always {!<=-1,!>=2}
Line 989
  fIsOperator always 65536
  state always {!<=-1,!>=2}
Line 991
  state always {!<=-1,!>=2}
Line 992
  fHasLvalRefQual always 131072
  state always {!<=-1,!>=2}
Line 994
  state always {!<=-1,!>=2}
Line 995
  fHasRvalRefQual always 262144
  state always {!<=-1,!>=2}
Line 997
  state always {!<=-1,!>=2}
Line 998
  fIsVariadic always 524288
  state always {!<=-1,!>=2}
Line 1000
  state always {!<=-1,!>=2}
Line 1001
  fIsVolatile always 1048576
  state always {!<=-1,!>=2}
Line 1003
  state always {!<=-1,!>=2}
Line 1004
  fHasTrailingReturnType always 2097152
  state always {!<=-1,!>=2}
Line 1006
  state always {!<=-1,!>=2}
Line 1007
  fIsInlineKeyword always 8388608
  state always {!<=-1,!>=2}
Line 1022
  eGlobal always 0
  eClass always 1
  eStruct always 2
  eUnion always 3
  eNamespace always 4
  eFunction always 5
  eIf always 6
  eElse always 7
  eFor always 8
  eWhile always 9
  eDo always 10
  eSwitch always 11
  eUnconditional always 12
  eTry always 13
  eCatch always 14
  eLambda always 15
  eEnum always 16
Line 1051
  enumClass always {!<=-1,!>=2}
Line 1056
  = possible 0
  start possible 0
Line 1057
  = possible 0
  start possible 0
  ? possible 0
  start always !0
  : always 0
  nullptr always 0
Line 1059
  bodyStartList possible lifetime[Object]=(start)
  start always !0
Line 1062
  ( always {!<=-1,!>=2}
Line 1064
  return always {!<=-1,!>=2}
  ( always !<=-1
  > always {!<=-1,!>=2}
  9 always 9
  && always {!<=-1,!>=2}
  className {>=size=10,!<=size=9}
  0 always 0
  9 always 9
  "Anonymous" always "Anonymous"
  == always {!<=-1,!>=2}
  0 always 0
  && always {!<=-1,!>=2}
  9 always 9
Line 1069
  == always {!<=-1,!>=2}
Line 1070
  & {lifetime[Address]=(enumeratorList),!0}
Line 1072
  nullptr always 0
Line 1075
  ( always {!<=-1,!>=2}
Line 1076
  ! always {!<=-1,!>=2}
  outer possible symbolic=(this)
Line 1077
  return always {!<=-1,!>=2}
  false always 0
Line 1078
  outer always !0
  == always {!<=-1,!>=2}
  this always !0
Line 1079
  return always {!<=-1,!>=2}
  true always 1
Line 1081
  outer {symbolic=(parent),!symbolic=(this),!0}
  != {!<=-1,!>=2,0,1}
  parent possible {symbolic=(nestedIn),symbolic=(outer),0}
  && {!<=-1,!>=2,0}
  parent {symbolic=(nestedIn),!symbolic=(outer),0}
Line 1082
  parent {symbolic=(nestedIn),!symbolic=(outer),!0}
Line 1083
  parent possible {symbolic=(nestedIn),symbolic=(outer),0}
  && always {!<=-1,!>=2}
  parent always !0
  == always {!<=-1,!>=2}
  outer always {!symbolic=(this),!0}
Line 1084
  return always {!<=-1,!>=2}
  true always 1
Line 1085
  return always {!<=-1,!>=2}
  false always 0
Line 1090
  scope always !0
  == always {!<=-1,!>=2}
  :: always 5
  eFunction always 5
Line 1092
  scope always !0
Line 1094
  ! {!<=-1,!>=2,1}
  scope possible 0
Line 1095
  nullptr always 0
Line 1096
  scope always !0
Line 1099
  ( always {!<=-1,!>=2}
Line 1100
  return always {!<=-1,!>=2}
  type possible 2
  == {!<=-1,!>=2,0}
  eClass always 1
  || always {!<=-1,!>=2}
  type always !1
  == always {!<=-1,!>=2}
  eStruct always 2
Line 1103
  ( always {!<=-1,!>=2}
Line 1104
  return always {!<=-1,!>=2}
  type possible {2,3}
  == {!<=-1,!>=2,0}
  eClass always 1
  || always {!<=-1,!>=2}
  type {3,!1}
  == {!<=-1,!>=2,0}
  eStruct always 2
  || always {!<=-1,!>=2}
  type always {!1,!2}
  == always {!<=-1,!>=2}
  eUnion always 3
Line 1107
  ( always {!<=-1,!>=2}
Line 1108
  return always {!<=-1,!>=2}
  type possible {2,3,0,4,16}
  != {!<=-1,!>=2,1}
  eClass always 1
  && always {!<=-1,!>=2}
  type {3,0,4,16,!1}
  != {!<=-1,!>=2,1}
  eStruct always 2
  && always {!<=-1,!>=2}
  type {0,4,16,!1,!2}
  != {!<=-1,!>=2,1}
  eUnion always 3
  && always {!<=-1,!>=2}
  type {4,16,!2,!3}
  != {!<=-1,!>=2,1}
  eGlobal always 0
  && always {!<=-1,!>=2}
  type {16,!3,!0}
  != {!<=-1,!>=2,1}
  eNamespace always 4
  && always {!<=-1,!>=2}
  type always {!0,!4}
  != always {!<=-1,!>=2}
  eEnum always 16
Line 1111
  ( always {!<=-1,!>=2}
Line 1112
  return always {!<=-1,!>=2}
  type possible {9,10}
  == {!<=-1,!>=2,0}
  :: always 8
  eFor always 8
  || always {!<=-1,!>=2}
  type {10,!8}
  == {!<=-1,!>=2,0}
  :: always 9
  eWhile always 9
  || always {!<=-1,!>=2}
  type always {!8,!9}
  == always {!<=-1,!>=2}
  :: always 10
  eDo always 10
Line 1115
  ( always {!<=-1,!>=2}
Line 1116
  return always {!<=-1,!>=2}
  type possible {7,8,9,10,11,12,13,14}
  == {!<=-1,!>=2,0}
  eIf always 6
  || always {!<=-1,!>=2}
  type {8,9,10,11,12,13,14,!6}
  == {!<=-1,!>=2,0}
  eElse always 7
  || always {!<=-1,!>=2}
Line 1117
  type {9,10,11,12,13,14,!6,!7}
  == {!<=-1,!>=2,0}
  eFor always 8
  || always {!<=-1,!>=2}
  type {10,11,12,13,14,!7,!8}
  == {!<=-1,!>=2,0}
  eWhile always 9
  || always {!<=-1,!>=2}
  type {11,12,13,14,!8,!9}
  == {!<=-1,!>=2,0}
  eDo always 10
  || always {!<=-1,!>=2}
Line 1118
  type {12,13,14,!9,!10}
  == {!<=-1,!>=2,0}
  eSwitch always 11
  || always {!<=-1,!>=2}
  type {13,14,!10,!11}
  == {!<=-1,!>=2,0}
  eUnconditional always 12
  || always {!<=-1,!>=2}
Line 1119
  type {14,!11,!12}
  == {!<=-1,!>=2,0}
  eTry always 13
  || always {!<=-1,!>=2}
  type always {!12,!13}
  == always {!<=-1,!>=2}
  eCatch always 14
Line 1123
  ( always {!<=-1,!>=2}
Line 1131
  , always 0
  requireConst always {!<=-1,!>=2}
  = always 0
  false always 0
Line 1133
  , always 0
  isC always {!<=-1,!>=2}
  = always 0
  false always 0
Line 1135
  ( always !0
  this always !0
Line 1140
  ( always !0
  this always !0
Line 1159
  functionList possible lifetime[Object]=(func)
Line 1161
  = {lifetime[Object]=(functionList),!0}
  & {lifetime[Object]=(functionList),!0}
  functionList {lifetime[Object]=(func),!size=0}
Line 1163
  ( possible lifetime[Iterator]=(functionMap)
  back {lifetime[Object]=(functionList),symbolic=(&functionList.back()),!0}
  back {lifetime[Object]=(functionList),symbolic=(&functionList.back()),!0}
Line 1166
  ( always {!<=-1,!>=2}
Line 1186
  , always {!<=-1,!>=2}
  isCpp always {!<=-1,!>=2}
Line 1200
  ( always {!<=-1,!>=2}
  & {lifetime[Address]=(vartok),!0}
  & {lifetime[Address]=(typetok),!0}
Line 1209
  None always 0
Line 1210
  LValue always 1
Line 1211
  RValue always 2
Line 1217
  UNKNOWN_SIGN always 0
  SIGNED always 1
  UNSIGNED always 2
Line 1219
  UNKNOWN_TYPE always 0
Line 1220
  POD always 1
Line 1221
  NONSTD always 2
Line 1222
  RECORD always 3
Line 1223
  SMART_POINTER always 4
Line 1224
  CONTAINER always 5
Line 1225
  ITERATOR always 6
Line 1226
  VOID always 7
Line 1227
  BOOL always 8
Line 1228
  CHAR always 9
Line 1229
  SHORT always 10
Line 1230
  WCHAR_T always 11
Line 1231
  INT always 12
Line 1232
  LONG always 13
Line 1233
  LONGLONG always 14
Line 1234
  UNKNOWN_INT always 15
Line 1235
  FLOAT always 16
Line 1236
  DOUBLE always 17
Line 1237
  LONGDOUBLE always 18
Line 1242
  = always 0
  :: always 0
  None always 0
Line 1256
  UNKNOWN_SIGN always 0
Line 1257
  UNKNOWN_TYPE always 0
Line 1258
  0 always 0
Line 1259
  0U always 0
Line 1260
  0U always 0
Line 1261
  nullptr always 0
Line 1262
  nullptr always 0
Line 1263
  nullptr always 0
Line 1264
  nullptr always 0
Line 1265
  nullptr always 0
Line 1266
  nullptr always 0
Line 1268
  ( possible lifetime[SubObject]=(s)
Line 1271
  0 always 0
Line 1273
  0U always 0
Line 1274
  nullptr always 0
Line 1275
  nullptr always 0
Line 1276
  nullptr always 0
Line 1277
  nullptr always 0
Line 1278
  nullptr always 0
Line 1279
  nullptr always 0
Line 1281
  ( possible lifetime[SubObject]=(s)
Line 1284
  0 always 0
Line 1287
  nullptr always 0
Line 1288
  nullptr always 0
Line 1289
  nullptr always 0
Line 1290
  nullptr always 0
Line 1291
  nullptr always 0
Line 1292
  nullptr always 0
Line 1294
  ( possible lifetime[SubObject]=(s)
Line 1297
  0 always 0
Line 1300
  nullptr always 0
Line 1301
  nullptr always 0
Line 1302
  nullptr always 0
Line 1303
  nullptr always 0
Line 1304
  nullptr always 0
Line 1305
  nullptr always 0
Line 1311
  , always {!<=-1,!>=2}
  longType always {!<=-1,!>=2}
Line 1313
  UNKNOWN always 0
  SAME always 1
  FALLBACK1 always 2
  FALLBACK2 always 3
  NOMATCH always 4
Line 1317
  ( always {!<=-1,!>=2}
Line 1318
  return always {!<=-1,!>=2}
  >= always {!<=-1,!>=2}
  :: always 8
  BOOL always 8
Line 1321
  ( always {!<=-1,!>=2}
Line 1322
  return always {!<=-1,!>=2}
  type possible {<=15,>=16}
  >= {!<=-1,!>=2,<=1}
  :: always 8
  BOOL always 8
  && always {!<=-1,!>=2}
  type {>=8,!<=7}
  <= {!<=-1,!>=2,>=1}
  :: always 15
  UNKNOWN_INT always 15
Line 1325
  ( always {!<=-1,!>=2}
Line 1326
  return always {!<=-1,!>=2}
  type possible {<=18,>=19}
  >= {!<=-1,!>=2,<=1}
  :: always 16
  FLOAT always 16
  && always {!<=-1,!>=2}
  type {>=16,!<=15}
  <= {!<=-1,!>=2,>=1}
  :: always 18
  LONGDOUBLE always 18
Line 1329
  ( always {!<=-1,!>=2}
Line 1331
  ( always {!<=-1,!>=2}
Line 1332
  return always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  typeScope always !0
  == always {!<=-1,!>=2}
  :: always 16
  eEnum always 16
Line 1335
  , always 0
  p always {!<=-1,!>=2}
  = always 0
  false always 0
Line 1338
  ( always {!<=-1,!>=2}
Line 1381
  , always 0
  lookOutside always {!<=-1,!>=2}
  = always 0
  false always 0
Line 1382
  , always 0
  lookOutside always {!<=-1,!>=2}
  = always 0
  false always 0
Line 1383
  this always !0
  lookOutside always {!<=-1,!>=2}
Line 1388
  this always !0
Line 1391
  ( always {!<=-1,!>=2}
Line 1392
  return always {!<=-1,!>=2}
  < always {!<=-1,!>=2}
  ( always !<=-1
Line 1396
  varId possible {<=symbolic=(mVarId)@172,1@172}
Line 1408
  = always 0
  nullptr always 0
Line 1412
  ( always {!<=-1,!>=2}
Line 1426
  reportDebugWarnings always {!<=-1,!>=2}
  = always 0
  nullptr always 0
Line 1456
  firstPass always {!<=-1,!>=2}
Line 1467
  & {lifetime[Address]=(scope),!0}
Line 1468
  & {lifetime[Address]=(scope),!0}
  & {lifetime[Address]=(tok),!0}
Line 1470
  ( always {!<=-1,!>=2}
Line 1482
  ( always {!<=-1,!>=2}
Line 1500
  mIsCpp always {!<=-1,!>=2}
Line 65
  isExecutable always {!<=-1,!>=2}
  false always 0
  isStructInit always {!<=-1,!>=2}
  false always 0
  isEnum always {!<=-1,!>=2}
  false always 0
  0 always 0
Line 66
  ( possible lifetime[SubObject]=(isExecutable)
  isExecutable always {!<=-1,!>=2}
  isStructInit always {!<=-1,!>=2}
  isEnum always {!<=-1,!>=2}
Line 67
  isExecutable always {!<=-1,!>=2}
  isExecutable always {!<=-1,!>=2}
  isStructInit always {!<=-1,!>=2}
  isStructInit always {!<=-1,!>=2}
  isEnum always {!<=-1,!>=2}
  isEnum always {!<=-1,!>=2}
Line 69
  isExecutable always {!<=-1,!>=2}
Line 70
  isStructInit always {!<=-1,!>=2}
Line 71
  isEnum always {!<=-1,!>=2}
Line 77
  ( always {!<=-1,!>=2}
Line 79
  ! always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  tok always !0
  != always {!<=-1,!>=2}
  "{" always "{"
Line 80
  return always {!<=-1,!>=2}
  false always 0
Line 81
  return always {!<=-1,!>=2}
  tok always !0
  -1 always -1
  == always {!<=-1,!>=2}
  "enum" always "enum"
  || always {!<=-1,!>=2}
  tok always !0
  -2 always -2
  == always {!<=-1,!>=2}
  "enum" always "enum"
  || always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  tok always !0
  -3 always -3
  "enum class %name%" always "enum class %name%"
Line 87
  tok possible lifetime[Address]=(tok)@84
Line 88
  ( always {!<=-1,!>=2}
  defStart possible {symbolic=(*tok),0}
  "%name%|::|:" always "%name%|::|:"
Line 90
  && always {!<=-1,!>=2}
  defStart always !0
  == always {!<=-1,!>=2}
  "{" always "{"
Line 91
  tok possible lifetime[Address]=(tok)@84
  defStart always !0
Line 96
  endsWith possible {";{"@247,"{|;|?|:|["@62,"{"@81,"{"@167,";"@170,"{|;"@170,"{|;"@183,"try"@202,"{"@95,":;{"@203}
  ( always {!<=-1,!>=2}
Line 99
  , always {!<=-1,!>=2}
  cpp always {!<=-1,!>=2}
Line 101
  ! always {!<=-1,!>=2}
Line 102
  nullptr always 0
Line 103
  tok always !0
  == always {!<=-1,!>=2}
  "(" always "("
Line 104
  tok always !0
Line 105
  ( always {!<=-1,!>=2}
  ") ;|{|[" always ") ;|{|["
Line 107
  && always {!<=-1,!>=2}
  tok always !0
  == always {!<=-1,!>=2}
  "[" always "["
  && always {!<=-1,!>=2}
  tok always !0
Line 108
  ( always !<=-1
  tok always !0
  ( always size=1
  != always {!<=-1,!>=2}
Line 109
  tok always !0
Line 110
  tok always !0
  ( always !0
Line 112
  tok possible 0
  && always {!<=-1,!>=2}
  ( always !<=-1
  tok always !0
  != always {!<=-1,!>=2}
  tok always !0
  nullptr always 0
Line 114
  cpp always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  ")" always ")"
Line 116
  ( always {!<=-1,!>=2}
  tok possible 0
  "const|noexcept|override|final|volatile|mutable|&|&& !!(" always "const|noexcept|override|final|volatile|mutable|&|&& !!("
  || always {!<=-1,!>=2}
Line 117
  ( always {!<=-1,!>=2}
  "%name% !!(" always "%name% !!("
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 119
  && always {!<=-1,!>=2}
  tok always !0
  == always {!<=-1,!>=2}
  ")" always ")"
Line 120
  tok always !0
Line 121
  && always {!<=-1,!>=2}
  tok always !0
  == always {!<=-1,!>=2}
  "[" always "["
Line 122
  tok always !0
Line 123
  ( always {!<=-1,!>=2}
  tok possible 0
  "throw|noexcept (" always "throw|noexcept ("
Line 124
  1 always 1
Line 125
  ( always {!<=-1,!>=2}
  "%name% (" always "%name% ("
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 126
  1 always 1
Line 127
  && always {!<=-1,!>=2}
  tok always !0
  == always {!<=-1,!>=2}
  "->" always "->"
Line 128
  tok always !0
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  tok always !0
  ";|{|override|final" always ";|{|override|final"
Line 129
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "<|[|(" always "<|[|("
Line 130
  = always !0
  ( always !0
Line 132
  ( always {!<=-1,!>=2}
  "override|final !!(" always "override|final !!("
  || always {!<=-1,!>=2}
Line 133
  ( always {!<=-1,!>=2}
  "%name% !!(" always "%name% !!("
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 135
  ( always {!<=-1,!>=2}
  "= 0|default|delete ;" always "= 0|default|delete ;"
Line 136
  2 always 2
Line 138
  && always {!<=-1,!>=2}
  ( always !<=-1
  tok always !0
  != always {!<=-1,!>=2}
  tok always !0
  nullptr always 0
Line 140
  nullptr always 0
Line 146
  ( always {!<=-1,!>=2}
Line 148
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "class|struct|union|enum|%name%|>|>> {" always "class|struct|union|enum|%name%|>|>> {"
Line 149
  return always {!<=-1,!>=2}
  false always 0
Line 151
  tok2 possible symbolic=(tok->previous())
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  tok2 {symbolic=(tok->previous()),!0}
  "class|struct|union|enum|{|}|;" always "class|struct|union|enum|{|}|;"
Line 152
  tok2 always !0
Line 153
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  tok2 possible {symbolic=(tok->previous()),0}
  "class|struct|union|enum" always "class|struct|union|enum"
Line 159
  nullptr always 0
Line 160
  nullptr always 0
Line 161
  nullptr always 0
Line 162
  nullptr always 0
Line 163
  nullptr always 0
Line 164
  0 always 0
Line 165
  0 always 0
Line 166
  mCodeWithTemplates always {!<=-1,!>=2}
  false always 0
Line 167
  nullptr always 0
Line 171
  nullptr always 0
Line 178
  nullptr always 0
Line 179
  nullptr always 0
Line 180
  0 always 0
Line 181
  0 always 0
Line 182
  mCodeWithTemplates always {!<=-1,!>=2}
  false always 0
Line 183
  nullptr always 0
Line 187
  nullptr always 0
Line 192
  this always !0
Line 208
  ! always {!<=-1,!>=2}
  type possible lifetime[Address]=(tempTok)@109
  || always {!<=-1,!>=2}
  type {!0,lifetime[Address]=(tempTok)@109}
  ( always {!<=-1,!>=2}
Line 209
  0 always 0
Line 211
  type {!0,lifetime[Address]=(tempTok)@109}
  == always {!<=-1,!>=2}
  :: always 6
  eString always 6
Line 212
  type always !0
  + always !<=-1
  1U always 1
Line 214
  :: possible {symbolic=(mTypeSize.end()),end=0}
  it possible {symbolic=(mTypeSize.end()),end=0}
  = possible lifetime[Iterator]=(mTypeSize)
  ( possible lifetime[Iterator]=(mTypeSize)
  type always !0
  ( always !size=0
Line 215
  == always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(mTypeSize),end=0}
Line 216
  type always !0
Line 217
  ! always {!<=-1,!>=2}
  podtype always symbolic=(mSettings->library.podtype(type->str()))
Line 218
  0 always 0
Line 220
  podtype {symbolic=(mSettings->library.podtype(type->str())),!0}
  . always !<=-1
  size always !<=-1
Line 221
  type always !0
  ( always {!<=-1,!>=2}
Line 222
  type always !0
  ( possible size=4
  == {!<=-1,!>=2,0}
  "double" always "double"
Line 224
  type always !0
  == always {!<=-1,!>=2}
  "long" always "long"
Line 228
  it always {!symbolic=(mTypeSize.end()),!end=0}
Line 233
  ( always {!<=-1,!>=2}
Line 236
  tokPtr possible lifetime[Address]=(tok2)@154
Line 237
  tok {symbolic=(*tokPtr),0}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  tok {symbolic=(*tokPtr),!0}
  ";|,|[|=|)|>|(|{" always ";|,|[|=|)|>|(|{"
Line 238
  tok always !0
Line 240
  end always symbolic=(tok->next())
  ( possible size=1
  == always {!<=-1,!>=2}
  "[" always "["
Line 241
  ! always {!<=-1,!>=2}
  end always symbolic=(tok->next())
Line 242
  end always symbolic=(tok->next())
Line 243
  end always symbolic=(tok->next())
  ( always !0
Line 244
  end always symbolic=(tok->next())
  ( possible size=1
  == always {!<=-1,!>=2}
  "," always ","
Line 246
  ( always {!<=-1,!>=2}
  tok always !0
  "public|private|protected" always "public|private|protected"
Line 247
  return always {!<=-1,!>=2}
  false always 0
Line 250
  end possible {symbolic=(tok->next()),0}
  && always {!<=-1,!>=2}
  end always !0
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  end always !0
  ( always !0
  ";|)|>" always ";|)|>"
Line 251
  end always !0
  ( always !0
  == always {!<=-1,!>=2}
  "(" always "("
Line 252
  end always !0
  1 always 1
Line 254
  = possible 0
  end possible 0
  ? possible 0
  end always !0
  : always 0
  nullptr always 0
Line 256
  end possible 0
Line 257
  end always !0
Line 258
  end always symbolic=(tok->next())
  == always {!<=-1,!>=2}
  "(" always "("
Line 259
  tok always !0
  ( possible {size=7,size=1}
  0 always 0
  8 always 8
  "operator" always "operator"
  == always {!<=-1,!>=2}
  0 always 0
Line 261
  return always {!<=-1,!>=2}
  false always 0
Line 262
  tok always !0
  ( possible size=1
  == {!<=-1,!>=2,0}
  "typedef" always "typedef"
Line 264
  return always {!<=-1,!>=2}
  false always 0
Line 265
  ( always {!<=-1,!>=2}
  tok always !0
  "public:|private:|protected:" always "public:|private:|protected:"
Line 266
  return always {!<=-1,!>=2}
  false always 0
Line 267
  tok always !0
  == always {!<=-1,!>=2}
  ">" always ">"
Line 268
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  tok always !0
  -2 always -2
  "%type%" always "%type%"
Line 269
  return always {!<=-1,!>=2}
  false always 0
Line 271
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  tok always !0
  -3 always -3
  ",|<" always ",|<"
Line 272
  return always {!<=-1,!>=2}
  false always 0
Line 275
  return always {!<=-1,!>=2}
  true always 1
Line 279
  end possible 0
Line 280
  ( always {!<=-1,!>=2}
  end always !0
  ") {" always ") {"
Line 282
  ( always {!<=-1,!>=2}
  tok always !0
  "%type%" always "%type%"
  && always {!<=-1,!>=2}
Line 283
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  tok always !0
  "return|new|const|struct" always "return|new|const|struct"
Line 285
  tokPtr possible lifetime[Address]=(tok2)@154
  end always !0
Line 286
  return always {!<=-1,!>=2}
  true always 1
Line 288
  end always !0
  ( possible size=1
  == always {!<=-1,!>=2}
  ">" always ">"
Line 290
  ( always {!<=-1,!>=2}
  tok always !0
  "%type%" always "%type%"
  && always {!<=-1,!>=2}
Line 291
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  tok always !0
  "return|new|const|volatile" always "return|new|const|volatile"
Line 293
  end possible 0
  && always {!<=-1,!>=2}
  end always !0
  != always {!<=-1,!>=2}
  "{" always "{"
Line 294
  end always !0
Line 295
  end possible 0
Line 296
  tokPtr possible lifetime[Address]=(tok2)@154
  end always !0
Line 297
  return always {!<=-1,!>=2}
  true always 1
Line 302
  ( always {!<=-1,!>=2}
  tok always !0
  "typedef|}|>" always "typedef|}|>"
  || always {!<=-1,!>=2}
Line 303
  end always !0
  == always {!<=-1,!>=2}
  ";" always ";"
  && always {!<=-1,!>=2}
  tok always !0
  == always {!<=-1,!>=2}
  "," always ","
  || always {!<=-1,!>=2}
Line 304
  tok always !0
  == always {!<=-1,!>=2}
  "*" always "*"
  && always {!<=-1,!>=2}
  tok always !0
  != always {!<=-1,!>=2}
  "(" always "("
  || always {!<=-1,!>=2}
Line 305
  ( always {!<=-1,!>=2}
  tok always !0
  "%type%" always "%type%"
  && always {!<=-1,!>=2}
Line 306
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  tok always !0
  "return|new|const|friend|public|private|protected|throw|extern" always "return|new|const|friend|public|private|protected|throw|extern"
  && always {!<=-1,!>=2}
Line 307
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  tok always !0
  -2 always -2
  "friend class" always "friend class"
Line 309
  && always {!<=-1,!>=2}
  tok always !0
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  tok always !0
  ( always !0
  ";|{" always ";|{"
Line 310
  tok always !0
  ( always !0
  ( possible {size=7,size=4,size=6,size=5}
  == {!<=-1,!>=2,0}
  "}" always "}"
Line 311
  tok always !0
  ( always !0
Line 312
  tok always !0
  ( always !0
  ( possible {size=4,size=6,size=5}
  == {!<=-1,!>=2,0}
  "typedef" always "typedef"
Line 313
  return always {!<=-1,!>=2}
  true always 1
Line 314
  tok always !0
  ( always !0
  ( possible {size=6,size=5}
  == {!<=-1,!>=2,0}
  "enum" always "enum"
Line 315
  return always {!<=-1,!>=2}
  true always 1
Line 316
  tok always !0
  ( always !0
  ( possible size=5
  == {!<=-1,!>=2,0}
  "struct" always "struct"
Line 317
  tok always !0
  -2 always -2
  == always {!<=-1,!>=2}
  "typedef" always "typedef"
  && always {!<=-1,!>=2}
Line 318
  tok always !0
  == always {!<=-1,!>=2}
  "{" always "{"
  && always {!<=-1,!>=2}
Line 319
  3 always 3
  != always {!<=-1,!>=2}
  "{" always "{"
Line 321
  return always {!<=-1,!>=2}
  true always 1
Line 322
  tok always !0
  ( possible {symbolic=(name->str()),size=1}
  == always {!<=-1,!>=2}
  "{" always "{"
Line 323
  return always {!<=-1,!>=2}
  true always 1
Line 324
  ( always {!<=-1,!>=2}
  tok always !0
  ")|*" always ")|*"
Line 325
  return always {!<=-1,!>=2}
  true always 1
Line 326
  tok always !0
  ( possible size=1
  == always {!<=-1,!>=2}
Line 327
  return always {!<=-1,!>=2}
  true always 1
Line 328
  tok always !0
  ( always !symbolic=(name->str())
  != always {!<=-1,!>=2}
  ";" always ";"
Line 329
  return always {!<=-1,!>=2}
  true always 1
Line 331
  return always {!<=-1,!>=2}
  false always 0
Line 333
  tok always !0
  ( always !0
  ( possible size=5
  == always {!<=-1,!>=2}
  "union" always "union"
Line 334
  tok always !0
  != always {!<=-1,!>=2}
  ";" always ";"
Line 335
  return always {!<=-1,!>=2}
  true always 1
Line 337
  return always {!<=-1,!>=2}
  false always 0
Line 339
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  tok always !0
  ( always !0
  == always {!<=-1,!>=2}
  "class" always "class"
Line 340
  tok always !0
  != always {!<=-1,!>=2}
  ";" always ";"
Line 341
  return always {!<=-1,!>=2}
  true always 1
Line 343
  return always {!<=-1,!>=2}
  false always 0
Line 347
  tok always !0
Line 350
  tokPtr possible lifetime[Address]=(tok2)@154
  1 always 1
  != always {!<=-1,!>=2}
  "(" always "("
  || always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  tokPtr possible lifetime[Address]=(tok2)@154
  1 always 1
  ") .|(|[" always ") .|(|["
Line 351
  return always {!<=-1,!>=2}
  true always 1
Line 357
  return always {!<=-1,!>=2}
  false always 0
Line 362
  ! always {!<=-1,!>=2}
  . always {!<=-1,!>=2}
  debugwarnings always {!<=-1,!>=2}
Line 367
  = always 0
  0 always 0
Line 368
  tok possible symbolic=(tok1)
Line 369
  level possible 0
  == {!<=-1,!>=2,1}
  0 always 0
  && always {!<=-1,!>=2}
  tok {symbolic=(tok1),!0}
  ( possible size=1
  == always {!<=-1,!>=2}
  ";" always ";"
Line 371
  tok always !0
  ( possible size=1
  == always {!<=-1,!>=2}
  "{" always "{"
Line 373
  tok always !0
  == always {!<=-1,!>=2}
  "}" always "}"
Line 374
  == always {!<=-1,!>=2}
  0 always 0
Line 376
  -- always !-1
  level always !0
Line 379
  tok always !0
  != always {!<=-1,!>=2}
Line 380
  " " always " "
Line 381
  tok {symbolic=(tok1),!0}
Line 382
  tok {symbolic=(tok1),!0}
Line 384
  tok possible {symbolic=(tok1),0}
Line 385
  " ;" always " ;"
Line 387
  tok1 possible symbolic=(tok)
  :: always 7
  debug always 7
  "simplifyTypedef" always "simplifyTypedef"
Line 388
  "Failed to parse \'" always "Failed to parse \'"
  "\'. The checking continues anyway." always "\'. The checking continues anyway."
Line 393
  = always 0
  nullptr always 0
Line 397
  ( always !0
  ( possible size=1
  == always {!<=-1,!>=2}
  ";" always ";"
Line 400
  ( always !0
  ( possible size=1
  == always {!<=-1,!>=2}
  "{" always "{"
Line 401
  1 always 1
Line 402
  ( always !0
  == always {!<=-1,!>=2}
  "}" always "}"
Line 407
  != always {!<=-1,!>=2}
Line 408
  typeDef always !symbolic=(list.front())
Line 409
  tok always symbolic=(typeDef->previous())
Line 415
  tok possible {symbolic=(typeDef->previous()),symbolic=(list.front())}
Line 420
  nullptr always 0
  nullptr always 0
  isNamespace always {!<=-1,!>=2}
  false always 0
Line 424
  isNamespace always {!<=-1,!>=2}
Line 432
  isConst {!<=-1,!>=2,0}
  isConst always {!<=-1,!>=2}
  = always 0
  false always 0
Line 436
  tok1 always symbolic=(tok->next())
  == always {!<=-1,!>=2}
  "const" always "const"
Line 437
  tok1 always symbolic=(tok->next())
Line 438
  isConst always {!<=-1,!>=2}
  = always 1
  true always 1
Line 442
  tok1 always symbolic=(tok->next())
Line 444
  hasName always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "%name%" always "%name%"
Line 447
  hasName {!<=-1,!>=2,0}
Line 453
  == always {!<=-1,!>=2}
  ":" always ":"
Line 455
  tok1 possible 0
  && always {!<=-1,!>=2}
  tok1 always !0
  != always {!<=-1,!>=2}
  "{" always "{"
Line 456
  tok1 always !0
Line 457
  ! {!<=-1,!>=2,1}
  tok1 possible 0
Line 458
  nullptr always 0
Line 464
  ! always {!<=-1,!>=2}
  hasName always {!<=-1,!>=2}
Line 467
  ( always {!<=-1,!>=2}
  ( always !0
  "%type%" always "%type%"
Line 468
  ( always !0
Line 470
  "Unnamed" always "Unnamed"
  unnamedCount possible lifetime[Address]=(mUnnamedCount)@167
Line 471
  name possible symbolic=(tok1->next()->str())
Line 473
  nullptr always 0
Line 476
  ";" always ";"
Line 479
  && always {!<=-1,!>=2}
  ( always !0
  == always {!<=-1,!>=2}
  ";" always ";"
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  "}" always "}"
Line 482
  nullptr always 0
Line 484
  "typedef" always "typedef"
Line 487
  isConst always {!<=-1,!>=2}
Line 488
  tok1 always symbolic=(tok3)
  "const" always "const"
Line 489
  tok1 always symbolic=(tok3)
Line 491
  tok1 possible symbolic=(tok3)
Line 492
  tok1 possible symbolic=(tok3)
Line 498
  tok possible symbolic=(tok3)
Line 506
  , always {!<=-1,!>=2}
  inOperator always {!<=-1,!>=2}
Line 508
  && always {!<=-1,!>=2}
  ( always !0
  != always {!<=-1,!>=2}
  ")" always ")"
  && always {!<=-1,!>=2}
Line 509
  ( always !0
  != always {!<=-1,!>=2}
  "," always ","
Line 511
  ( always {!<=-1,!>=2}
  ( always !0
  "( * %type% ) (" always "( * %type% ) ("
Line 512
  5 always 5
Line 513
  ( always {!<=-1,!>=2}
  ( always !0
  "* ( * %type% ) (" always "* ( * %type% ) ("
Line 514
  6 always 6
Line 515
  ( always {!<=-1,!>=2}
  ( always !0
  "* ( * %type% ) ;" always "* ( * %type% ) ;"
Line 516
  5 always 5
Line 517
  ( always {!<=-1,!>=2}
  ( always !0
  "* ( %type% [" always "* ( %type% ["
  && always {!<=-1,!>=2}
Line 518
  ( always {!<=-1,!>=2}
  4 always 4
  "] ) ;|=" always "] ) ;|="
Line 519
  4 always 4
Line 520
  ( always {!<=-1,!>=2}
  "* ( * %type% (" always "* ( * %type% ("
Line 521
  5 always 5
Line 522
  ( always {!<=-1,!>=2}
  "* [" always "* ["
  && always {!<=-1,!>=2}
Line 523
  ( always {!<=-1,!>=2}
  2 always 2
  "] ;" always "] ;"
Line 526
  == always {!<=-1,!>=2}
  "(" always "("
Line 528
  ! always {!<=-1,!>=2}
  inOperator always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "[|>|;" always "[|>|;"
Line 531
  ( always {!<=-1,!>=2}
  "*|&" always "*|&"
  && always {!<=-1,!>=2}
Line 532
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  ")|>" always ")|>"
Line 536
  ( always {!<=-1,!>=2}
  tok2 possible 0
  "%name% ::" always "%name% ::"
Line 537
  2 always 2
Line 539
  ! always {!<=-1,!>=2}
Line 540
  nullptr always 0
Line 542
  tok2 always !0
  == always {!<=-1,!>=2}
  "(" always "("
  && always {!<=-1,!>=2}
Line 543
  tok2 always !0
  && always {!<=-1,!>=2}
Line 544
  tok2 always !0
  ( always !0
  == always {!<=-1,!>=2}
  "(" always "("
Line 545
  tok2 always !0
Line 547
  == always {!<=-1,!>=2}
  "(" always "("
Line 552
  && always {!<=-1,!>=2}
  ( always !0
  == always {!<=-1,!>=2}
  "(" always "("
Line 553
  ( always !0
Line 554
  ! always {!<=-1,!>=2}
Line 557
  ( always !0
  == always {!<=-1,!>=2}
  "(" always "("
Line 558
  ( always !0
Line 568
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  < always {!<=-1,!>=2}
  :: always 1
  CPP11 always 1
Line 573
  ( always {!<=-1,!>=2}
  "[;{}] using %name% :: %name% ::|;" always "[;{}] using %name% :: %name% ::|;"
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  2 always 2
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
Line 574
  ( always {!<=-1,!>=2}
  "[;{}] using :: %name% :: %name% ::|;" always "[;{}] using :: %name% :: %name% ::|;"
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  3 always 3
  ( always {!<=-1,!>=2}
Line 575
  5 always 5
Line 576
  ( always {!<=-1,!>=2}
  "%name%" always "%name%"
Line 578
  ( always {!<=-1,!>=2}
  endtok possible 0
  ":: %name%" always ":: %name%"
Line 579
  2 always 2
Line 580
  && always {!<=-1,!>=2}
  endtok always !0
  == always {!<=-1,!>=2}
  ";" always ";"
Line 581
  "typedef" always "typedef"
Line 582
  endtok always !0
Line 592
  isNamespace always {!<=-1,!>=2}
  isNamespace always {!<=-1,!>=2}
  = always 0
  false always 0
Line 595
  hasClass always {!<=-1,!>=2}
  hasClass always {!<=-1,!>=2}
  = always 0
  false always 0
Line 596
  goback always {!<=-1,!>=2}
  goback always {!<=-1,!>=2}
  = always 0
  false always 0
Line 604
  tok possible {symbolic=(typeDef->previous()),symbolic=(list.front())}
Line 605
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 606
  0 always 0
  "Tokenize (typedef)" always "Tokenize (typedef)"
Line 608
  ( always {!<=-1,!>=2}
Line 611
  ( always 0
Line 614
  goback always {!<=-1,!>=2}
Line 616
  goback always {!<=-1,!>=2}
  = always 0
  false always 0
Line 620
  != always {!<=-1,!>=2}
  "typedef" always "typedef"
Line 621
  ( always {!<=-1,!>=2}
  "( typedef" always "( typedef"
Line 624
  ( always {!<=-1,!>=2}
  "class|struct|namespace %any%" always "class|struct|namespace %any%"
  && always {!<=-1,!>=2}
Line 625
  ! always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  != always {!<=-1,!>=2}
  "enum" always "enum"
Line 626
  isNamespace always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  "namespace" always "namespace"
Line 627
  hasClass always {!<=-1,!>=2}
  = always 1
  true always 1
Line 630
  = always symbolic=(tok->next()->str())
  className always symbolic=(tok->next()->str())
Line 631
  ( always {!<=-1,!>=2}
  tok1 possible symbolic=(tok->next())
  "%name% :: %name%" always "%name% :: %name%"
Line 632
  2 always 2
Line 633
  " :: " always " :: "
Line 635
  hasClass always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  ";" always ";"
Line 636
  hasClass always {!<=-1,!>=2}
  = always 0
  false always 0
Line 637
  hasClass always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  "{" always "{"
Line 638
  ! always {!<=-1,!>=2}
  isNamespace always {!<=-1,!>=2}
Line 642
  . always {!<=-1,!>=2}
  isNamespace always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  isNamespace always {!<=-1,!>=2}
Line 648
  hasClass always {!<=-1,!>=2}
  = always 0
  false always 0
Line 649
  ( always !<=-1
  > always {!<=-1,!>=2}
  1 always 1
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  "}" always "}"
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
Line 657
  ( always {!<=-1,!>=2}
  "const| struct|enum|union|class %type%| {|:" always "const| struct|enum|union|class %type%| {|:"
Line 658
  & {lifetime[Address]=(mUnnamedCount),!0}
Line 659
  ! always {!<=-1,!>=2}
Line 665
  ( always {!<=-1,!>=2}
  tok possible symbolic=(tok1)
  "enum %type% %type% ;" always "enum %type% %type% ;"
  && always {!<=-1,!>=2}
  2 always 2
  == always {!<=-1,!>=2}
  3 always 3
Line 666
  3 always 3
Line 671
  goback always {!<=-1,!>=2}
  = always 1
  true always 1
Line 676
  = always 0
  nullptr always 0
Line 677
  = always 0
  nullptr always 0
Line 678
  = always 0
  nullptr always 0
Line 679
  = always 0
  nullptr always 0
Line 680
  = always 0
  nullptr always 0
Line 681
  = always 0
  nullptr always 0
Line 682
  = always 0
  nullptr always 0
Line 683
  = always 0
  nullptr always 0
Line 685
  = always 0
  nullptr always 0
Line 686
  = always 0
  nullptr always 0
Line 687
  = always 0
  nullptr always 0
Line 688
  = always 0
  nullptr always 0
Line 689
  tok always symbolic=(typeDef)
Line 690
  function always {!<=-1,!>=2}
  function always {!<=-1,!>=2}
  = always 0
  false always 0
Line 691
  functionPtr always {!<=-1,!>=2}
  functionPtr always {!<=-1,!>=2}
  = always 0
  false always 0
Line 692
  functionRetFuncPtr always {!<=-1,!>=2}
  functionRetFuncPtr always {!<=-1,!>=2}
  = always 0
  false always 0
Line 693
  functionPtrRetFuncPtr always {!<=-1,!>=2}
  functionPtrRetFuncPtr always {!<=-1,!>=2}
  = always 0
  false always 0
Line 694
  ptrToArray always {!<=-1,!>=2}
  ptrToArray always {!<=-1,!>=2}
  = always 0
  false always 0
Line 695
  refToArray always {!<=-1,!>=2}
  refToArray always {!<=-1,!>=2}
  = always 0
  false always 0
Line 696
  ptrMember always {!<=-1,!>=2}
  ptrMember always {!<=-1,!>=2}
  = always 0
  false always 0
Line 697
  typeOf always {!<=-1,!>=2}
  typeOf always {!<=-1,!>=2}
  = always 0
  false always 0
Line 698
  = always 0
  nullptr always 0
Line 699
  = always 0
  nullptr always 0
Line 702
  ! always {!<=-1,!>=2}
  tokOffset always symbolic=(tok->next())
Line 703
  tok always symbolic=(typeDef)
Line 706
  tokOffset always symbolic=(tok->next())
  == always {!<=-1,!>=2}
  "::" always "::"
Line 707
  = always symbolic=(tok->next())
  tokOffset always symbolic=(tok->next())
Line 708
  tokOffset always {symbolic=(tok->next()),symbolic=(typeStart)}
Line 710
  ( always {!<=-1,!>=2}
  "%type% ::" always "%type% ::"
Line 711
  2 always 2
Line 715
  ( always {!<=-1,!>=2}
  tokOffset always symbolic=(typeEnd)
  "%type%" always "%type%"
Line 716
  tokOffset always symbolic=(typeEnd)
Line 717
  ( always {!<=-1,!>=2}
  tokOffset always symbolic=(tok->next())
  "%type% ::" always "%type% ::"
Line 718
  = always symbolic=(tok->next())
  tokOffset always symbolic=(tok->next())
Line 721
  tokOffset possible {symbolic=(tok->next()),symbolic=(typeStart)}
  2 always 2
Line 722
  ( always {!<=-1,!>=2}
  "%type% ::" always "%type% ::"
Line 726
  ( always {!<=-1,!>=2}
  tokOffset always symbolic=(typeEnd)
  "%type%" always "%type%"
Line 727
  tokOffset always symbolic=(typeEnd)
Line 728
  ( always {!<=-1,!>=2}
  tokOffset always symbolic=(tok->next())
  "%type%" always "%type%"
Line 729
  = always symbolic=(tok->next())
  tokOffset always symbolic=(tok->next())
Line 731
  ( always {!<=-1,!>=2}
  tokOffset possible {symbolic=(tok->next()),symbolic=(typeStart)}
  "const|struct|enum %type%" always "const|struct|enum %type%"
  || always {!<=-1,!>=2}
Line 732
  tokOffset possible symbolic=(typeStart)
  && always {!<=-1,!>=2}
  tokOffset possible symbolic=(typeStart)
  ( always {!<=-1,!>=2}
Line 735
  = possible symbolic=(typeStart)
  tokOffset possible symbolic=(typeStart)
Line 736
  tokOffset {symbolic=(typeStart),symbolic=(typeEnd)}
Line 738
  ( always {!<=-1,!>=2}
  "%type%" always "%type%"
  && always {!<=-1,!>=2}
Line 739
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "unsigned|signed" always "unsigned|signed"
Line 741
  tokOffset always symbolic=(typeEnd)
Line 744
  atEnd always {!<=-1,!>=2}
  atEnd always {!<=-1,!>=2}
  = always 0
  false always 0
Line 745
  ! always {!<=-1,!>=2}
  atEnd always {!<=-1,!>=2}
Line 746
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  "::" always "::"
Line 748
  tokOffset always symbolic=(typeEnd)
Line 751
  ( always {!<=-1,!>=2}
  "%type%" always "%type%"
  && always {!<=-1,!>=2}
Line 752
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "[|;|,|(" always "[|;|,|("
Line 754
  tokOffset always symbolic=(typeEnd)
Line 755
  ( always {!<=-1,!>=2}
  "const (" always "const ("
Line 757
  tokOffset always symbolic=(typeEnd)
Line 758
  atEnd always {!<=-1,!>=2}
  = always 1
  true always 1
Line 760
  atEnd always {!<=-1,!>=2}
  = always 1
  true always 1
Line 766
  ! always {!<=-1,!>=2}
  tokOffset possible symbolic=(typeEnd)
Line 767
  tok always symbolic=(typeDef)
Line 770
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  "<" always "<"
Line 773
  typeEnd possible symbolic=(tokOffset->findClosingBracket())
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  typeEnd possible symbolic=(tokOffset->findClosingBracket())
  ":: %type%" always ":: %type%"
Line 774
  2 always 2
Line 776
  ! always {!<=-1,!>=2}
  typeEnd possible symbolic=(tokOffset->findClosingBracket())
Line 781
  ( always {!<=-1,!>=2}
  "const|volatile" always "const|volatile"
Line 785
  tok always symbolic=(typeEnd)
Line 790
  ( always {!<=-1,!>=2}
  tokOffset possible symbolic=(tok->next())
  "*|&|&&|const" always "*|&|&&|const"
Line 796
  ! always {!<=-1,!>=2}
Line 799
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 802
  tokOffset always symbolic=(typeName)
Line 805
  tokOffset possible symbolic=(arrayEnd->next())
  && always {!<=-1,!>=2}
  tokOffset possible symbolic=(arrayEnd->next())
  == always {!<=-1,!>=2}
  "[" always "["
Line 806
  ! always {!<=-1,!>=2}
Line 808
  tokOffset possible symbolic=(arrayStart)
Line 809
  arrayEnd always symbolic=(tokOffset->link())
Line 813
  ( always {!<=-1,!>=2}
  tokOffset possible symbolic=(arrayEnd->next())
  ";|," always ";|,"
Line 817
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  "(" always "("
Line 818
  = always 0
  nullptr always 0
Line 819
  ( always {!<=-1,!>=2}
  "( *|%name%" always "( *|%name%"
Line 821
  tokOffset2 always symbolic=(tokOffset->next())
  == always {!<=-1,!>=2}
  "typename" always "typename"
Line 822
  tokOffset2 always symbolic=(tokOffset->next())
Line 823
  ( always {!<=-1,!>=2}
  tokOffset2 possible symbolic=(tokOffset->next())
  "%type% ::" always "%type% ::"
Line 824
  2 always 2
Line 828
  == always {!<=-1,!>=2}
  "void" always "void"
Line 831
  == always {!<=-1,!>=2}
Line 833
  goback always {!<=-1,!>=2}
  = always 1
  true always 1
Line 838
  ( always {!<=-1,!>=2}
  "* %name% ) (" always "* %name% ) ("
Line 841
  functionPtr always {!<=-1,!>=2}
  = always 1
  true always 1
Line 842
  = always symbolic=(funcStart)
  tokOffset2 always symbolic=(funcStart)
Line 843
  tokOffset2 always {symbolic=(funcStart),symbolic=(funcEnd)}
  3 always 3
Line 844
  -2 always -2
Line 846
  tokOffset always symbolic=(argStart)
Line 847
  argEnd always symbolic=(tokOffset->link())
Line 851
  ";," always ";,"
Line 852
  function always {!<=-1,!>=2}
  = always 1
  true always 1
Line 853
  == always {!<=-1,!>=2}
  "const" always "const"
Line 855
  = always symbolic=(tokOffset->link()->next())
  specStart always symbolic=(tokOffset->link()->next())
Line 858
  tokOffset always symbolic=(argStart)
Line 859
  argEnd always symbolic=(tokOffset->link())
Line 860
  specStart possible {symbolic=(tokOffset->link()->next()),symbolic=(specEnd)}
Line 861
  tok always symbolic=(argEnd->next())
Line 873
  == always {!<=-1,!>=2}
Line 875
  goback always {!<=-1,!>=2}
  = always 1
  true always 1
Line 881
  ( always {!<=-1,!>=2}
  "typeof (" always "typeof ("
  && always {!<=-1,!>=2}
Line 882
  ( always {!<=-1,!>=2}
  ") %type% ;" always ") %type% ;"
Line 884
  tokOffset always symbolic=(argStart)
Line 885
  tokOffset always symbolic=(argStart)
  ( always symbolic=(argEnd)
Line 886
  typeName always symbolic=(tokOffset->link()->next())
Line 887
  typeOf always {!<=-1,!>=2}
  = always 1
  true always 1
Line 893
  == always {!<=-1,!>=2}
  "(" always "("
  && always {!<=-1,!>=2}
Line 894
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "%type% ) (" always "%type% ) ("
  && always {!<=-1,!>=2}
Line 895
  ( always {!<=-1,!>=2}
  ") const|volatile|;" always ") const|volatile|;"
  || always {!<=-1,!>=2}
Line 896
  ( always {!<=-1,!>=2}
  "( (" always "( ("
  && always {!<=-1,!>=2}
Line 897
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "%type% ) (" always "%type% ) ("
  && always {!<=-1,!>=2}
Line 898
  ( always {!<=-1,!>=2}
  ") const|volatile| ) ;|," always ") const|volatile| ) ;|,"
  || always {!<=-1,!>=2}
Line 899
  ( always {!<=-1,!>=2}
  "( * (" always "( * ("
  && always {!<=-1,!>=2}
Line 900
  2 always 2
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  2 always 2
  "%type% ) (" always "%type% ) ("
  && always {!<=-1,!>=2}
Line 901
  ( always {!<=-1,!>=2}
  2 always 2
  ") const|volatile| ) ;|," always ") const|volatile| ) ;|,"
Line 902
  == always {!<=-1,!>=2}
  "(" always "("
Line 904
  ( always {!<=-1,!>=2}
  "( * (" always "( * ("
Line 905
  "*" always "*"
Line 906
  2 always 2
Line 909
  -2 always -2
  == always {!<=-1,!>=2}
  "*" always "*"
Line 910
  functionPtr always {!<=-1,!>=2}
  = always 1
  true always 1
Line 912
  function always {!<=-1,!>=2}
  = always 1
  true always 1
Line 915
  -2 always -2
Line 918
  ( always symbolic=(argStart)
Line 919
  ! always {!<=-1,!>=2}
  argEnd always symbolic=(tokOffset->next()->link())
Line 920
  argStart always symbolic=(tokOffset->next())
Line 922
  argEnd always symbolic=(tokOffset->next()->link())
Line 923
  = always symbolic=(argEnd->next())
  tok always symbolic=(argEnd->next())
Line 924
  ( always {!<=-1,!>=2}
  spec always symbolic=(tok)
  "const|volatile" always "const|volatile"
Line 925
  = always symbolic=(tok)
  spec always symbolic=(tok)
Line 926
  = always {symbolic=(tok),symbolic=(specStart)}
  spec always {symbolic=(tok),symbolic=(specStart)}
Line 927
  ( always {!<=-1,!>=2}
  spec possible {symbolic=(tok),symbolic=(specStart),symbolic=(specEnd)}
  "const|volatile" always "const|volatile"
Line 929
  = always symbolic=(spec->next())
  specEnd always symbolic=(spec->next())
Line 931
  specEnd possible symbolic=(spec)
Line 933
  ! always {!<=-1,!>=2}
  tok possible {symbolic=(argEnd->next()),symbolic=(spec),symbolic=(specEnd->next())}
Line 936
  == always {!<=-1,!>=2}
  ")" always ")"
Line 940
  ( always {!<=-1,!>=2}
  "( %type% (" always "( %type% ("
Line 941
  function always {!<=-1,!>=2}
  = always 1
  true always 1
Line 944
  2 always 2
Line 947
  tokOffset always symbolic=(argStart)
Line 955
  ( always {!<=-1,!>=2}
  "( * ( * %type% ) (" always "( * ( * %type% ) ("
  && always {!<=-1,!>=2}
Line 956
  ( always {!<=-1,!>=2}
  6 always 6
  ") ) (" always ") ) ("
  && always {!<=-1,!>=2}
Line 957
  ( always {!<=-1,!>=2}
  6 always 6
  2 always 2
  ") ;|," always ") ;|,"
Line 958
  functionPtrRetFuncPtr always {!<=-1,!>=2}
  = always 1
  true always 1
Line 960
  6 always 6
Line 961
  -2 always -2
Line 963
  tokOffset always symbolic=(argStart)
Line 964
  ! always {!<=-1,!>=2}
  argEnd always symbolic=(tokOffset->link())
Line 967
  argEnd always symbolic=(tokOffset->link())
  2 always 2
Line 969
  ! always {!<=-1,!>=2}
  argFuncRetEnd always symbolic=(argFuncRetStart->link())
Line 972
  argFuncRetEnd always symbolic=(argFuncRetStart->link())
Line 976
  ( always {!<=-1,!>=2}
  "( * %type% (" always "( * %type% ("
  && always {!<=-1,!>=2}
Line 977
  ( always {!<=-1,!>=2}
  3 always 3
  ") ) (" always ") ) ("
  && always {!<=-1,!>=2}
Line 978
  ( always {!<=-1,!>=2}
  3 always 3
  2 always 2
  ") ;|," always ") ;|,"
Line 979
  functionRetFuncPtr always {!<=-1,!>=2}
  = always 1
  true always 1
Line 981
  3 always 3
Line 984
  tokOffset always symbolic=(argStart)
Line 986
  argEnd always symbolic=(tokOffset->link())
  2 always 2
Line 987
  ! always {!<=-1,!>=2}
Line 988
  tokOffset always symbolic=(argStart)
Line 991
  ! always {!<=-1,!>=2}
  argFuncRetEnd always symbolic=(argFuncRetStart->link())
Line 992
  tokOffset always symbolic=(argStart)
Line 994
  argFuncRetEnd always symbolic=(argFuncRetStart->link())
Line 995
  ( always {!<=-1,!>=2}
  "( * ( %type% ) (" always "( * ( %type% ) ("
Line 996
  functionRetFuncPtr always {!<=-1,!>=2}
  = always 1
  true always 1
Line 998
  5 always 5
Line 999
  -2 always -2
Line 1001
  tokOffset always symbolic=(argStart)
Line 1002
  ! always {!<=-1,!>=2}
  argEnd always symbolic=(tokOffset->link())
Line 1005
  argEnd always symbolic=(tokOffset->link())
  2 always 2
Line 1006
  ! always {!<=-1,!>=2}
Line 1007
  tokOffset always symbolic=(argStart)
Line 1010
  ! always {!<=-1,!>=2}
  argFuncRetEnd always symbolic=(argFuncRetStart->link())
Line 1013
  argFuncRetEnd always symbolic=(argFuncRetStart->link())
Line 1017
  ( always {!<=-1,!>=2}
  "( *|& %type% ) [" always "( *|& %type% ) ["
Line 1018
  ptrToArray always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  "*" always "*"
Line 1019
  refToArray always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ptrToArray {symbolic=(tokOffset->next()->str()=="*"),!<=-1,!>=2}
Line 1020
  2 always 2
Line 1022
  tokOffset always symbolic=(typeName)
  2 always 2
Line 1024
  ! always {!<=-1,!>=2}
  arrayEnd always symbolic=(arrayStart->link())
Line 1027
  arrayEnd always symbolic=(arrayStart->link())
Line 1031
  ( always {!<=-1,!>=2}
  "( %type% :: * %type% ) ;" always "( %type% :: * %type% ) ;"
Line 1032
  2 always 2
Line 1035
  ptrMember always {!<=-1,!>=2}
  = always 1
  true always 1
Line 1036
  tokOffset always symbolic=(namespaceEnd)
  2 always 2
Line 1038
  tokOffset always symbolic=(typeName)
  2 always 2
Line 1045
  == always {!<=-1,!>=2}
Line 1047
  goback always {!<=-1,!>=2}
  = always 1
  true always 1
Line 1051
  done always {!<=-1,!>=2}
  done always {!<=-1,!>=2}
  = always 0
  false always 0
Line 1052
  ok always {!<=-1,!>=2}
  ok always {!<=-1,!>=2}
  = always 1
  true always 1
Line 1055
  typeName possible {symbolic=(tokOffset->link()->next()),symbolic=(tokOffset->previous()),symbolic=(tokOffset)}
Line 1056
  typeName possible {symbolic=(tokOffset->link()->next()),symbolic=(tokOffset->previous()),symbolic=(tokOffset)}
Line 1057
  typeName possible {symbolic=(tokOffset->link()->next()),symbolic=(tokOffset->previous()),symbolic=(tokOffset)}
Line 1058
  typeName possible {symbolic=(tokOffset->link()->next()),symbolic=(tokOffset->previous()),symbolic=(tokOffset)}
Line 1059
  . always {!<=-1,!>=2}
  used always {!<=-1,!>=2}
  = always 0
  false always 0
Line 1062
  ! always {!<=-1,!>=2}
  done always {!<=-1,!>=2}
Line 1063
  typeName possible {symbolic=(tokOffset->link()->next()),symbolic=(tokOffset->previous()),symbolic=(tokOffset)}
Line 1064
  = always 0
  0 always 0
Line 1065
  simplifyType always {!<=-1,!>=2}
  simplifyType always {!<=-1,!>=2}
  = always 0
  false always 0
Line 1066
  inMemberFunc always {!<=-1,!>=2}
  inMemberFunc always {!<=-1,!>=2}
  = always 0
  false always 0
Line 1067
  = always 0
  0 always 0
Line 1068
  globalScope always {!<=-1,!>=2}
  globalScope always {!<=-1,!>=2}
  = always 0
  false always 0
Line 1069
  = always !<=-1
  ( always !<=-1
Line 1070
  inTypeDef always {!<=-1,!>=2}
  inTypeDef always {!<=-1,!>=2}
  = always 0
  false always 0
Line 1071
  inEnumClass always {!<=-1,!>=2}
  inEnumClass always {!<=-1,!>=2}
  = always 0
  false always 0
Line 1074
  i always !<=-1
  = always 1
  1 always 1
  i always !<=-1
  < always {!<=-1,!>=2}
  ( always !<=-1
  ++ always !<=0
  i always !<=-1
Line 1075
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 1076
  " :: " always " :: "
Line 1077
  i {!<=-1,1}
Line 1081
  ( always {!<=-1,!>=2}
Line 1084
  removed always NonMovedVariable
Line 1086
  ( always {!<=-1,!>=2}
  "typedef" always "typedef"
Line 1087
  inTypeDef always {!<=-1,!>=2}
  = always 1
  true always 1
Line 1089
  inTypeDef always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  ";" always ";"
Line 1090
  inTypeDef always {!<=-1,!>=2}
  = always 0
  false always 0
Line 1093
  ! always {!<=-1,!>=2}
  inTypeDef always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always !<=-1
  == always {!<=-1,!>=2}
  1 always 1
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "%name%" always "%name%"
  && always {!<=-1,!>=2}
Line 1094
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 1096
  ( always {!<=-1,!>=2}
  varDecl possible symbolic=(tok2)
  "*|&|&&|const" always "*|&|&&|const"
Line 1098
  ( always {!<=-1,!>=2}
  varDecl possible symbolic=(tok2)
  "%name% ;|,|)|=" always "%name% ;|,|)|="
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
Line 1100
  ( always {!<=-1,!>=2}
  "%name% ) {" always "%name% ) {"
Line 1101
  2 always 2
Line 1104
  tok2 possible symbolic=(varDecl)
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  tok2 possible symbolic=(varDecl)
  "}" always "}"
Line 1105
  ( always {!<=-1,!>=2}
  "(|{|[" always "(|{|["
Line 1110
  ! always {!<=-1,!>=2}
  tok2 possible symbolic=(varDecl)
Line 1118
  == always {!<=-1,!>=2}
  "}" always "}"
Line 1120
  inMemberFunc always {!<=-1,!>=2}
Line 1122
  == always {!<=-1,!>=2}
  0 always 0
Line 1123
  inMemberFunc always {!<=-1,!>=2}
  = always 0
  false always 0
Line 1125
  inEnumClass always {!<=-1,!>=2}
  = always 0
  false always 0
Line 1127
  > always {!<=-1,!>=2}
  1 always 1
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  1 always 1
Line 1129
  pattern always NonMovedVariable
Line 1131
  < always {!<=-1,!>=2}
  ( always !<=-1
Line 1132
  " :: " always " :: "
Line 1136
  == always {!<=-1,!>=2}
  0 always 0
Line 1143
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  "(" always "("
  && always {!<=-1,!>=2}
  "{" always "{"
Line 1147
  func always symbolic=(tok2->previous())
  == always {!<=-1,!>=2}
  "operator" always "operator"
Line 1148
  func always symbolic=(tok2->previous())
Line 1150
  ! always {!<=-1,!>=2}
  func possible symbolic=(tok2->previous())
Line 1154
  ( always {!<=-1,!>=2}
  -2 always -2
  "%name% ::" always "%name% ::"
Line 1155
  = always -2
  -2 always -2
Line 1156
  ( always {!<=-1,!>=2}
  2 always 2
  "%name% ::" always "%name% ::"
Line 1157
  2 always 2
Line 1159
  ( always !<=-1
  > always {!<=-1,!>=2}
  1 always 1
  && always {!<=-1,!>=2}
  < always {!<=-1,!>=2}
  ( always !<=-1
  && always {!<=-1,!>=2}
Line 1160
  == always {!<=-1,!>=2}
Line 1161
  = always 0
  0 always 0
Line 1162
  inMemberFunc always {!<=-1,!>=2}
  = always 1
  true always 1
Line 1168
  == always {!<=-1,!>=2}
  "{" always "{"
Line 1170
  ( always {!<=-1,!>=2}
Line 1171
  -2 always -2
  == always {!<=-1,!>=2}
  "namespace" always "namespace"
Line 1172
  < always {!<=-1,!>=2}
  ( always !<=-1
  && always {!<=-1,!>=2}
Line 1173
  . always {!<=-1,!>=2}
  isNamespace always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 1174
  == always {!<=-1,!>=2}
Line 1177
  pattern always NonMovedVariable
Line 1178
  < always {!<=-1,!>=2}
  ( always !<=-1
Line 1179
  " :: " always " :: "
Line 1185
  ( always {!<=-1,!>=2}
  -3 always -3
  "enum class %name%" always "enum class %name%"
Line 1186
  inEnumClass always {!<=-1,!>=2}
  = always 1
  true always 1
Line 1190
  inMemberFunc always {!<=-1,!>=2}
Line 1199
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 1200
  == always {!<=-1,!>=2}
  "operator" always "operator"
  && always {!<=-1,!>=2}
Line 1201
  && always {!<=-1,!>=2}
Line 1202
  == always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 1203
  2 always 2
  && always {!<=-1,!>=2}
Line 1204
  2 always 2
  == always {!<=-1,!>=2}
  "(" always "("
  && always {!<=-1,!>=2}
Line 1205
  ( always {!<=-1,!>=2}
  2 always 2
  ") const| {" always ") const| {"
Line 1207
  == always {!<=-1,!>=2}
  "::" always "::"
Line 1209
  ( always !<=-1
  > always {!<=-1,!>=2}
  1 always 1
  && always {!<=-1,!>=2}
  < always {!<=-1,!>=2}
  ( always !<=-1
  && always {!<=-1,!>=2}
Line 1210
  -2 always -2
  == always {!<=-1,!>=2}
Line 1212
  simplifyType always {!<=-1,!>=2}
  = always 1
  true always 1
Line 1217
  ( always {!<=-1,!>=2}
  "class|struct %name% [:{]" always "class|struct %name% [:{]"
Line 1222
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 1223
  ( always {!<=-1,!>=2}
  ( {lifetime[Object]=(pattern),!0}
  ( always !<=-1
  || always {!<=-1,!>=2}
Line 1224
  inMemberFunc always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
Line 1226
  ! always {!<=-1,!>=2}
  inMemberFunc always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always !<=-1
  "::" always "::"
  != always {!<=-1,!>=2}
Line 1228
  = always 0
  0 always 0
Line 1229
  1 always 1
Line 1230
  good always {!<=-1,!>=2}
  good always {!<=-1,!>=2}
  = always 1
  true always 1
Line 1232
  back possible symbolic=(classLevel-1)
  >= always {!<=-1,!>=2}
  1 always 1
Line 1233
  -2 always -2
Line 1234
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "%type% ::" always "%type% ::"
Line 1236
  == always {!<=-1,!>=2}
Line 1241
  good always {!<=-1,!>=2}
  = always 0
  false always 0
Line 1246
  good always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  1 always 1
  && always {!<=-1,!>=2}
  -1 always -1
  == always {!<=-1,!>=2}
  "::" always "::"
Line 1247
  good always {!<=-1,!>=2}
  = always 0
  false always 0
Line 1249
  good always {!<=-1,!>=2}
Line 1252
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 1253
  ( possible lifetime[Iterator]=(removed)
  0 always 0
  " " always " "
Line 1254
  ( possible lifetime[Iterator]=(removed)
  0 always 0
  -2 always -2
  " " always " "
  -1 always -1
Line 1255
  -3 always -3
  2 always 2
Line 1260
  -1 always -1
  == always {!<=-1,!>=2}
  "::" always "::"
Line 1261
  ( possible lifetime[Iterator]=(removed)
  0 always 0
  ":: " always ":: "
Line 1262
  -2 always -2
Line 1263
  globalScope always {!<=-1,!>=2}
  = always 1
  true always 1
Line 1267
  < always {!<=-1,!>=2}
  ( always !<=-1
Line 1268
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 1269
  " " always " "
Line 1270
  " " always " "
  1 always 1
Line 1274
  simplifyType always {!<=-1,!>=2}
  = always 1
  true always 1
Line 1277
  -1 always -1
  == always {!<=-1,!>=2}
  "::" always "::"
Line 1278
  = always !<=-1
  ( always !<=-1
Line 1280
  > always {!<=-1,!>=2}
  1 always 1
  && always {!<=-1,!>=2}
Line 1281
  tokBeforeType possible symbolic=(tok2->previous())
  && always {!<=-1,!>=2}
  tokBeforeType possible symbolic=(tok2->previous())
  == always {!<=-1,!>=2}
  "::" always "::"
  && always {!<=-1,!>=2}
Line 1282
  tokBeforeType possible symbolic=(tok2->previous())
  -1 always -1
  == always {!<=-1,!>=2}
  1 always 1
Line 1283
  -2 always -2
Line 1286
  tokBeforeType possible symbolic=(tok2->previous())
  && always {!<=-1,!>=2}
  != always {!<=-1,!>=2}
  "::" always "::"
Line 1288
  simplifyType always {!<=-1,!>=2}
  = always 1
  true always 1
Line 1290
  ( always {!<=-1,!>=2}
  "case|;|{|} %type% :" always "case|;|{|} %type% :"
Line 1292
  ( always {!<=-1,!>=2}
  & {lifetime[Address]=(tok2),!0}
Line 1294
  != always {!<=-1,!>=2}
  "}" always "}"
Line 1296
  == always {!<=-1,!>=2}
  "{" always "{"
Line 1297
  1 always 1
Line 1298
  == always {!<=-1,!>=2}
  "}" always "}"
Line 1304
  ( always {!<=-1,!>=2}
  -2 always -2
  "%type% *|&" always "%type% *|&"
Line 1306
  != always {!<=-1,!>=2}
  "." always "."
Line 1307
  simplifyType always {!<=-1,!>=2}
  = always 1
  true always 1
Line 1312
  simplifyType always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  simplifyType always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  inEnumClass always {!<=-1,!>=2}
Line 1314
  simplifyType always {!<=-1,!>=2}
Line 1315
  mTypedefInfo always !size=0
  . always {!<=-1,!>=2}
  used always {!<=-1,!>=2}
  = always 1
  true always 1
Line 1318
  functionPtr always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  "operator" always "operator"
  || always {!<=-1,!>=2}
Line 1319
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  "operator" always "operator"
Line 1320
  simplifyType always {!<=-1,!>=2}
  = always 0
  false always 0
Line 1332
  inCast always {!<=-1,!>=2}
  inCast always {!<=-1,!>=2}
  = always 0
  false always 0
Line 1333
  inTemplate always {!<=-1,!>=2}
  inTemplate always {!<=-1,!>=2}
  = always 0
  false always 0
Line 1334
  inOperator always {!<=-1,!>=2}
  inOperator always {!<=-1,!>=2}
  = always 0
  false always 0
Line 1335
  inSizeof always {!<=-1,!>=2}
  inSizeof always {!<=-1,!>=2}
  = always 0
  false always 0
Line 1337
  sameStartEnd always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
Line 1340
  isDerived always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "public|protected|private %type% {|," always "public|protected|private %type% {|,"
Line 1344
  == always {!<=-1,!>=2}
  "(" always "("
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  ")" always ")"
  && always {!<=-1,!>=2}
  -2 always -2
  != always {!<=-1,!>=2}
  "sizeof" always "sizeof"
  || always {!<=-1,!>=2}
Line 1345
  == always {!<=-1,!>=2}
  "<" always "<"
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "> (" always "> ("
  || always {!<=-1,!>=2}
Line 1346
  ( always {!<=-1,!>=2}
  -2 always -2
  "( const %name% )" always "( const %name% )"
Line 1347
  inCast always {!<=-1,!>=2}
  = always 1
  true always 1
Line 1350
  ( always {!<=-1,!>=2}
  "<|," always "<|,"
  && always {!<=-1,!>=2}
Line 1351
  ( always {!<=-1,!>=2}
  "&|*| &|*| >|," always "&|*| &|*| >|,"
Line 1352
  inTemplate always {!<=-1,!>=2}
  = always 1
  true always 1
Line 1354
  ( always {!<=-1,!>=2}
  -2 always -2
  "sizeof ( %type% )" always "sizeof ( %type% )"
Line 1355
  inSizeof always {!<=-1,!>=2}
  = always 1
  true always 1
Line 1358
  -1 always -1
  == always {!<=-1,!>=2}
  "operator" always "operator"
  || always {!<=-1,!>=2}
Line 1359
  ( always {!<=-1,!>=2}
  -2 always -2
  "operator const" always "operator const"
Line 1360
  inOperator always {!<=-1,!>=2}
  = always 1
  true always 1
Line 1362
  == always {!<=-1,!>=2}
  "typename" always "typename"
  && always {!<=-1,!>=2}
  -1 always -1
  == always {!<=-1,!>=2}
  "typename" always "typename"
Line 1368
  structRemoved always {!<=-1,!>=2}
  structRemoved always {!<=-1,!>=2}
  = always 0
  false always 0
Line 1369
  isDerived always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "class|struct" always "class|struct"
Line 1370
  == always {!<=-1,!>=2}
  "struct" always "struct"
Line 1371
  structRemoved always {!<=-1,!>=2}
  = always 1
  true always 1
Line 1374
  ( always {!<=-1,!>=2}
  "struct|class|union" always "struct|class|union"
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "%name% ::" always "%name% ::"
Line 1377
  sameStartEnd always {!<=-1,!>=2}
Line 1381
  typeStart possible symbolic=(typeEnd)
Line 1384
  typeStart possible symbolic=(typeEnd)
  == always {!<=-1,!>=2}
  "struct" always "struct"
  || always {!<=-1,!>=2}
  structRemoved always {!<=-1,!>=2}
Line 1385
  structRemoved always {!<=-1,!>=2}
Line 1388
  globalScope always {!<=-1,!>=2}
Line 1389
  "::" always "::"
Line 1393
  < always {!<=-1,!>=2}
  ( always !<=-1
Line 1396
  "::" always "::"
Line 1404
  :: always !<=-1
  idx always !<=-1
  idx always !<=-1
  = always !<=-1
  removed1 always symbolic=(removed)
  ( always !<=-1
  " ::" always " ::"
Line 1406
  idx always !<=-1
  != always {!<=-1,!>=2}
Line 1407
  removed1 always symbolic=(removed)
  idx always !<=-1
Line 1408
  removed1 possible symbolic=(removed)
  == always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 1409
  = {lifetime[Iterator]=(spaceInfo),start=0}
  ( {lifetime[Iterator]=(spaceInfo),start=0}
  it possible lifetime[Iterator]=(spaceInfo)
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(spaceInfo),end=0}
Line 1410
  it possible lifetime[Iterator]=(spaceInfo)
  ( possible {lifetime[Iterator]=(it->recordTypes),lifetime[Object]=(spaceInfo)}
  start always symbolic=(tok2)
  != always {!<=-1,!>=2}
  it possible lifetime[Iterator]=(spaceInfo)
  ( {lifetime[Iterator]=(it->recordTypes),lifetime[Object]=(spaceInfo),end=0}
Line 1411
  :: always !<=-1
  spaceIdx always !<=-1
  spaceIdx always !<=-1
  = always 0
  0 always 0
Line 1412
  :: always !<=-1
  startIdx always !<=-1
  startIdx always !<=-1
  = always 0
  0 always 0
Line 1413
  spaceIdx always !<=-1
  = always !<=-1
  ( always !<=-1
  " " always " "
  startIdx {symbolic=(spaceIdx+1),!<=-1}
  != always {!<=-1,!>=2}
Line 1414
  tok2 always symbolic=(start)
  startIdx always !<=-1
  spaceIdx always !<=-1
  - always !<=-1
  startIdx always !<=-1
Line 1415
  startIdx always !<=-1
  = always !<=0
  spaceIdx always !<=-1
  + always !<=0
  1 always 1
Line 1417
  tok2 always symbolic=(start)
  startIdx always !<=-1
Line 1418
  tok2 always symbolic=(start)
  "::" always "::"
Line 1421
  idx always !<=-1
  = always !<=-1
  ( always !<=-1
  " ::" always " ::"
Line 1422
  idx always !<=-1
  == always {!<=-1,!>=2}
Line 1425
  idx always !<=-1
Line 1429
  tok2 always symbolic=(start)
Line 1431
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 1438
  && always {!<=-1,!>=2}
Line 1439
  "(" always "("
Line 1442
  tok2 always symbolic=(paren)
Line 1444
  ! always {!<=-1,!>=2}
  inCast always {!<=-1,!>=2}
Line 1445
  inOperator always {!<=-1,!>=2}
Line 1447
  ! always {!<=-1,!>=2}
Line 1450
  ( always {!<=-1,!>=2}
  "%name%|] [" always "%name%|] ["
Line 1451
  1 always 1
Line 1453
  ")" always ")"
Line 1461
  spec always symbolic=(specStart)
Line 1463
  spec possible symbolic=(specStart)
  != always {!<=-1,!>=2}
Line 1471
  functionPtr always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  function always {!<=-1,!>=2}
Line 1474
  needParen always {!<=-1,!>=2}
  needParen always {!<=-1,!>=2}
  = always 1
  true always 1
Line 1475
  ! always {!<=-1,!>=2}
  inTemplate always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  function always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  != always {!<=-1,!>=2}
  "*" always "*"
Line 1476
  needParen always {!<=-1,!>=2}
  = always 0
  false always 0
Line 1477
  needParen always {!<=-1,!>=2}
Line 1478
  "(" always "("
Line 1485
  tok4 possible symbolic=(namespaceStart)
  != always {!<=-1,!>=2}
Line 1490
  tok2 possible symbolic=(tok3)
Line 1491
  tok2 possible symbolic=(tok3)
Line 1493
  functionPtr always {!<=-1,!>=2}
Line 1494
  "*" always "*"
Line 1498
  ! always {!<=-1,!>=2}
  inCast always {!<=-1,!>=2}
Line 1499
  inOperator always {!<=-1,!>=2}
Line 1501
  needParen always {!<=-1,!>=2}
Line 1502
  ! always {!<=-1,!>=2}
Line 1503
  nullptr always 0
Line 1505
  ")" always ")"
Line 1509
  ! always {!<=-1,!>=2}
Line 1510
  nullptr always 0
Line 1513
  inTemplate always {!<=-1,!>=2}
Line 1514
  ! always {!<=-1,!>=2}
Line 1515
  nullptr always 0
Line 1522
  spec always symbolic=(specStart)
Line 1524
  spec possible symbolic=(specStart)
  != always {!<=-1,!>=2}
Line 1530
  functionRetFuncPtr always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  functionPtrRetFuncPtr always {!<=-1,!>=2}
Line 1531
  "(" always "("
Line 1534
  tok2 always symbolic=(tok3)
  "*" always "*"
Line 1535
  tok2 always symbolic=(tok3)
Line 1537
  = always 0
  nullptr always 0
Line 1538
  functionPtrRetFuncPtr always {!<=-1,!>=2}
Line 1539
  "(" always "("
Line 1542
  tok2 always symbolic=(tok4)
  "*" always "*"
Line 1543
  tok2 always symbolic=(tok4)
Line 1547
  ! always {!<=-1,!>=2}
  inCast always {!<=-1,!>=2}
Line 1548
  ! always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
Line 1549
  nullptr always 0
Line 1551
  != always {!<=-1,!>=2}
  ")" always ")"
Line 1555
  && always {!<=-1,!>=2}
  functionPtrRetFuncPtr always {!<=-1,!>=2}
Line 1556
  ")" always ")"
Line 1563
  ")" always ")"
Line 1568
  ptrToArray always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  refToArray always {!<=-1,!>=2}
Line 1569
  "(" always "("
Line 1573
  ptrToArray always {!<=-1,!>=2}
Line 1574
  tok2 always symbolic=(tok3)
  "*" always "*"
Line 1576
  tok2 always symbolic=(tok3)
  "&" always "&"
Line 1577
  tok2 always symbolic=(tok3)
Line 1579
  hasName always {!<=-1,!>=2}
  hasName always {!<=-1,!>=2}
  = always 0
  false always 0
Line 1581
  && always {!<=-1,!>=2}
  != always {!<=-1,!>=2}
  ")" always ")"
  && always {!<=-1,!>=2}
  != always {!<=-1,!>=2}
  "," always ","
  && always {!<=-1,!>=2}
Line 1582
  != always {!<=-1,!>=2}
  ">" always ">"
Line 1583
  hasName always {!<=-1,!>=2}
  = always 1
  true always 1
Line 1584
  != always {!<=-1,!>=2}
  "(" always "("
Line 1588
  && always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  "(" always "("
Line 1592
  && always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  "[" always "["
Line 1596
  ")" always ")"
Line 1599
  ! always {!<=-1,!>=2}
  hasName always {!<=-1,!>=2}
Line 1601
  ptrMember always {!<=-1,!>=2}
Line 1602
  ( always {!<=-1,!>=2}
  "* (" always "* ("
Line 1603
  "*" always "*"
Line 1609
  castOperator always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  inOperator always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "%type% (" always "%type% ("
Line 1610
  = always 0
  nullptr always 0
Line 1612
  ! always {!<=-1,!>=2}
  castOperator always {!<=-1,!>=2}
Line 1613
  "(" always "("
Line 1621
  tok4 possible symbolic=(namespaceStart)
  != always {!<=-1,!>=2}
Line 1629
  "*" always "*"
Line 1634
  ( always {!<=-1,!>=2}
  "%name%" always "%name%"
Line 1637
  ")" always ")"
Line 1643
  typeOf always {!<=-1,!>=2}
Line 1645
  ( always {!<=-1,!>=2}
  "%name% [" always "%name% ["
Line 1646
  ( always {!<=-1,!>=2}
  "%name%|] [" always "%name%|] ["
Line 1647
  1 always 1
Line 1652
  && always {!<=-1,!>=2}
Line 1654
  ! always {!<=-1,!>=2}
Line 1657
  ! always {!<=-1,!>=2}
  inCast always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  inSizeof always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  inTemplate always {!<=-1,!>=2}
Line 1660
  == always {!<=-1,!>=2}
  "const" always "const"
Line 1664
  ( always {!<=-1,!>=2}
  "&|*|&&" always "&|*|&&"
Line 1666
  "(" always "("
Line 1670
  ( always {!<=-1,!>=2}
  tok3 always symbolic=(tok2->next())
  "( *|&|&& *|&|&& %name%" always "( *|&|&& *|&|&& %name%"
Line 1671
  tok3 always symbolic=(tok2->next())
  3 always 3
Line 1672
  ( always {!<=-1,!>=2}
  3 always 3
  "[(),;]" always "[(),;]"
Line 1673
  2 always 2
Line 1675
  3 always 3
Line 1676
  ! always {!<=-1,!>=2}
Line 1677
  nullptr always 0
Line 1679
  1 always 1
  == always {!<=-1,!>=2}
  "::" always "::"
Line 1680
  2 always 2
Line 1683
  == always {!<=-1,!>=2}
  "(" always "("
Line 1686
  1 always 1
  == always {!<=-1,!>=2}
  "(" always "("
Line 1687
  1 always 1
Line 1690
  ( always {!<=-1,!>=2}
  "const|noexcept" always "const|noexcept"
Line 1693
  ")" always ")"
Line 1698
  ! always {!<=-1,!>=2}
Line 1702
  == always {!<=-1,!>=2}
  "[" always "["
Line 1703
  1 always 1
Line 1706
  ! always {!<=-1,!>=2}
Line 1709
  == always {!<=-1,!>=2}
  "=" always "="
Line 1710
  ! always {!<=-1,!>=2}
Line 1712
  == always {!<=-1,!>=2}
  "{" always "{"
Line 1714
  0 always 0
  == always {!<=-1,!>=2}
  '\"' always 34
Line 1715
  2 always 2
Line 1717
  ( always {!<=-1,!>=2}
  ", %name% ;|=|," always ", %name% ;|=|,"
Line 1720
  simplifyType always {!<=-1,!>=2}
  = always 0
  false always 0
Line 1722
  ! always {!<=-1,!>=2}
Line 1726
  ! always {!<=-1,!>=2}
Line 1727
  nullptr always 0
Line 1729
  == always {!<=-1,!>=2}
  ";" always ";"
Line 1730
  done always {!<=-1,!>=2}
  = always 1
  true always 1
Line 1731
  == always {!<=-1,!>=2}
  "," always ","
Line 1732
  = always 0
  nullptr always 0
Line 1733
  = always 0
  nullptr always 0
Line 1735
  pointers always NonMovedVariable
Line 1737
  ( always {!<=-1,!>=2}
  tokOffset possible symbolic=(tok->next())
  "*|&" always "*|&"
Line 1742
  ( always {!<=-1,!>=2}
  tokOffset possible symbolic=(tok->next())
  "%type%" always "%type%"
Line 1744
  tokOffset always symbolic=(typeName)
Line 1746
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  "[" always "["
Line 1750
  tokOffset possible symbolic=(arrayStart)
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  tokOffset possible symbolic=(arrayStart)
  ";|," always ";|,"
Line 1753
  ! always {!<=-1,!>=2}
  tokOffset possible symbolic=(arrayStart)
Line 1755
  == always {!<=-1,!>=2}
  ";" always ";"
Line 1757
  == always {!<=-1,!>=2}
  "]" always "]"
Line 1764
  tokOffset always symbolic=(arrayEnd)
Line 1767
  ( always {!<=-1,!>=2}
  ";|," always ";|,"
Line 1771
  done always {!<=-1,!>=2}
  = always 1
  true always 1
Line 1772
  ok always {!<=-1,!>=2}
  = always 0
  false always 0
Line 1776
  done always {!<=-1,!>=2}
  = always 1
  true always 1
Line 1777
  ok always {!<=-1,!>=2}
  = always 0
  false always 0
Line 1781
  done always {!<=-1,!>=2}
  = always 1
  true always 1
Line 1782
  ok always {!<=-1,!>=2}
  = always 0
  false always 0
Line 1786
  ok always {!<=-1,!>=2}
Line 1790
  != always {!<=-1,!>=2}
Line 1792
  tok always symbolic=(typeDef->previous())
Line 1794
  tok always symbolic=(typeDef->previous())
  2 always 2
Line 1795
  tok always symbolic=(typeDef->previous())
Line 1803
  goback always {!<=-1,!>=2}
  = always 1
  true always 1
Line 1811
  Global always 0
  Namespace always 1
  Record always 2
  MemberFunction always 3
  Other always 4
Line 1812
  nullptr always 0
  Global always 0
  nullptr always 0
  nullptr always 0
Line 1814
  name possible size=0
Line 1815
  ( always {!<=-1,!>=2}
Line 1817
  = always !size=0
  name always !size=0
Line 1819
  scope possible symbolic=(parent)
  && always {!<=-1,!>=2}
  scope {symbolic=(parent),!0}
Line 1820
  scope always !0
  ( always {!<=-1,!>=2}
Line 1822
  scope always !0
  . always !size=0
  " :: " always " :: "
Line 1823
  scope always !0
Line 1838
  this always !0
  scopeType possible {3@114,4@116,2@133,1@133}
  scopeName inconclusive ""@116
Line 1839
  & {lifetime[Object]=(children),!0}
  children always !size=0
Line 1842
  ( always {!<=-1,!>=2}
Line 1844
  == always {!<=-1,!>=2}
Line 1845
  return always {!<=-1,!>=2}
  true always 1
Line 1847
  return always {!<=-1,!>=2}
  false always 0
Line 1852
  == always {!<=-1,!>=2}
  Record always 2
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  scope always !symbolic=(child.name)
Line 1853
  & {lifetime[Address]=(children),!0}
Line 1855
  = inconclusive lifetime[Object]=(children)
  ( inconclusive lifetime[Object]=(children)
Line 1856
  temp {lifetime[Object]=(children),symbolic=(child.findInChildren(scope))}
Line 1857
  temp {lifetime[Object]=(children),symbolic=(child.findInChildren(scope)),!0}
Line 1860
  nullptr always 0
Line 1864
  = {!0,symbolic=(&child)}
  this {!0,symbolic=(&child)}
Line 1865
  tempScope possible {symbolic=(this),symbolic=(&child)}
Line 1867
  tempScope {symbolic=(this),!0}
Line 1868
  & {lifetime[Address]=(tempScope->children),!0,symbolic=(tempScope)}
  != {!<=-1,!>=2,0}
  this {symbolic=(tempScope),!0,symbolic=(&child)}
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  Record always 2
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  scope always !symbolic=(child.name)
Line 1869
  & {lifetime[Address]=(tempScope->children),!0,!symbolic=(this)}
Line 1872
  . possible 0
Line 1873
  . always !0
Line 1874
  == always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  & {lifetime[Address]=(tempScope->parent->children),!0}
  != always {!<=-1,!>=2}
  this always !0
Line 1875
  = inconclusive lifetime[Object]=(tempScope->parent->children)
  ( inconclusive lifetime[Object]=(tempScope->parent->children)
Line 1876
  temp {lifetime[Object]=(tempScope->parent->children),symbolic=(sibling.findInChildren(scope))}
Line 1877
  temp {lifetime[Object]=(tempScope->parent->children),symbolic=(sibling.findInChildren(scope)),!0}
Line 1881
  = possible 0
  . possible 0
Line 1883
  nullptr always 0
Line 1886
  ( always {!<=-1,!>=2}
Line 1887
  ( always {!<=-1,!>=2}
Line 1888
  return always {!<=-1,!>=2}
  false always 0
Line 1890
  ( possible lifetime[Iterator]=(baseTypes)
  scope always !size=0
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(baseTypes),end=0}
Line 1891
  return always {!<=-1,!>=2}
  true always 1
Line 1896
  baseScope {symbolic=(findScope(base)),0}
  == {!<=-1,!>=2,0}
  this always !0
Line 1897
  return always {!<=-1,!>=2}
  false always 0
Line 1898
  baseScope {symbolic=(findScope(base)),!symbolic=(this),0}
  && always {!<=-1,!>=2}
  baseScope {symbolic=(findScope(base)),!symbolic=(this),!0}
  == always {!<=-1,!>=2}
Line 1899
  return always {!<=-1,!>=2}
  true always 1
Line 1900
  baseScope {!symbolic=(this),0}
  && always {!<=-1,!>=2}
  baseScope always {!symbolic=(this),!0}
  ( always {!<=-1,!>=2}
Line 1901
  return always {!<=-1,!>=2}
  true always 1
Line 1903
  return always {!<=-1,!>=2}
  false always 0
Line 1907
  == always {!<=-1,!>=2}
Line 1908
  this always !0
Line 1912
  temp always !0
Line 1914
  nullptr always 0
Line 1918
  , always 0
  debug always {!<=-1,!>=2}
  = always 0
  false always 0
Line 1920
  ! always {!<=-1,!>=2}
  tok possible {symbolic=((*scopeInfo)->bodyStart),symbolic=((*scopeInfo)->bodyEnd)}
Line 1922
  tok {symbolic=((*scopeInfo)->bodyStart),symbolic=((*scopeInfo)->bodyEnd),!0}
  ( possible size=1
  == always {!<=-1,!>=2}
  "{" always "{"
  && always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  tok always !0
  == always {!<=-1,!>=2}
Line 1924
  tok {symbolic=((*scopeInfo)->bodyEnd),!0}
  ( possible size=1
  == always {!<=-1,!>=2}
  "}" always "}"
Line 1925
  && always {!<=-1,!>=2}
  tok always !0
  == always {!<=-1,!>=2}
Line 1926
  = always !0
  . always !0
Line 1929
  = possible 0
  . possible 0
Line 1930
  parent possible {symbolic=((*scopeInfo)->parent),0}
  && always {!<=-1,!>=2}
  parent {symbolic=((*scopeInfo)->parent),!0}
  != always {!<=-1,!>=2}
  tok always !0
Line 1931
  parent always !0
Line 1932
  parent possible {symbolic=((*scopeInfo)->parent),0}
Line 1933
  = always !0
  parent always !0
Line 1934
  debug always {!<=-1,!>=2}
Line 1935
  "Internal error: unmatched }" always "Internal error: unmatched }"
Line 1940
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "namespace|class|struct|union %name% {|:|::|<" always "namespace|class|struct|union %name% {|:|::|<"
Line 1942
  ( always {!<=-1,!>=2}
  "using namespace %name% ;|::" always "using namespace %name% ;|::"
Line 1943
  2 always 2
Line 1945
  && always {!<=-1,!>=2}
  tok1 always !0
  != always {!<=-1,!>=2}
  ";" always ";"
Line 1946
  ! {!<=-1,!>=2,0}
  nameSpace possible size=0
  ( {!<=-1,!>=2,1}
Line 1947
  nameSpace always !size=0
  " " always " "
Line 1948
  tok1 always !0
Line 1949
  tok1 always !0
Line 1954
  == always {!<=-1,!>=2}
  "{" always "{"
Line 1955
  added {!<=-1,!>=2,0}
  added always {!<=-1,!>=2}
  = always 0
  false always 0
Line 1957
  ( always {!<=-1,!>=2}
  tok1 possible symbolic=(tok)
  ( possible 0
  "const|volatile|final|override|&|&&|noexcept" always "const|volatile|final|override|&|&&|noexcept"
Line 1959
  tok1 possible symbolic=(tok)
  && always {!<=-1,!>=2}
  -1 always -1
  == always {!<=-1,!>=2}
  ")" always ")"
  || always {!<=-1,!>=2}
  -1 always -1
  == always {!<=-1,!>=2}
  "}" always "}"
Line 1960
  -1 always -1
Line 1961
  ( always {!<=-1,!>=2}
  "throw|noexcept (" always "throw|noexcept ("
Line 1963
  ( always {!<=-1,!>=2}
  "const|volatile|final|override|&|&&|noexcept" always "const|volatile|final|override|&|&&|noexcept"
Line 1965
  -1 always -1
  != always {!<=-1,!>=2}
  ")" always ")"
Line 1967
  -1 always -1
Line 1969
  ( always {!<=-1,!>=2}
  -2 always -2
  ":|, %name%" always ":|, %name%"
Line 1970
  -2 always -2
Line 1971
  -1 always -1
  != always {!<=-1,!>=2}
  ")" always ")"
  && always {!<=-1,!>=2}
  -1 always -1
  != always {!<=-1,!>=2}
  "}" always "}"
Line 1973
  -1 always -1
Line 1976
  -1 always -1
  == always {!<=-1,!>=2}
  ">" always ">"
Line 1978
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  tok1 always !0
  -3 always -3
  "%name% :: %name%" always "%name% :: %name%"
  || always {!<=-1,!>=2}
Line 1979
  ( always {!<=-1,!>=2}
  tok1 always !0
  -4 always -4
  "%name% :: ~ %name%" always "%name% :: ~ %name%"
Line 1980
  tok1 always !0
  -2 always -2
Line 1981
  == always {!<=-1,!>=2}
  "~" always "~"
Line 1983
  -1 always -1
Line 1984
  ( always {!<=-1,!>=2}
  -2 always -2
  ":: %name%" always ":: %name%"
Line 1985
  -3 always -3
  " :: " always " :: "
Line 1986
  -2 always -2
Line 1988
  :: always 3
  MemberFunction always 3
Line 1989
  added always {!<=-1,!>=2}
  = always 1
  true always 1
Line 1993
  ! {!<=-1,!>=2,1,0}
  added {!<=-1,!>=2,0,1}
Line 1994
  :: always 4
  Other always 4
  "" always ""
Line 1999
  record always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "class|struct|union %name%" always "class|struct|union %name%"
Line 2002
  ( always {!<=-1,!>=2}
  "%name% :: %name%" always "%name% :: %name%"
Line 2003
  2 always 2
Line 2004
  " :: " always " :: "
Line 2008
  record always {!<=-1,!>=2}
Line 2013
  && always {!<=-1,!>=2}
  tok always !0
  == always {!<=-1,!>=2}
  "<" always "<"
Line 2014
  tok always !0
Line 2016
  tok always !0
Line 2021
  && always {!<=-1,!>=2}
  tok always !0
  == always {!<=-1,!>=2}
  ":" always ":"
Line 2024
  ( always {!<=-1,!>=2}
  "public|protected|private|virtual" always "public|protected|private|virtual"
Line 2027
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  tok always !0
  ";|,|{" always ";|,|{"
Line 2028
  ! {!<=-1,!>=2,0}
  base possible size=0
  ( {!<=-1,!>=2,1}
Line 2029
  ' ' always 32
Line 2030
  tok always !0
Line 2031
  tok always !0
Line 2033
  && always {!<=-1,!>=2}
  tok always !0
  == always {!<=-1,!>=2}
  "<" always "<"
Line 2034
  tok always !0
Line 2036
  tok always !0
Line 2040
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  tok always !0
  ";|{" always ";|{"
Line 2043
  tok possible 0
  && always {!<=-1,!>=2}
  tok always !0
  == always {!<=-1,!>=2}
  "{" always "{"
Line 2044
  record always {!<=-1,!>=2}
  ? possible {2,1}
  :: always 2
  Record always 2
  : always 1
  :: always 1
  Namespace always 1
  tok always !0
  tok always !0
Line 2051
  = always 0
  0 always 0
Line 2053
  tok possible {symbolic=(*tok)@78,symbolic=(nameToken)@78}
  && always {!<=-1,!>=2}
  level possible 0
  > {!<=-1,!>=2,0}
  0 always 0
  || always {!<=-1,!>=2}
  tok always !0
  != always {!<=-1,!>=2}
  ";" always ";"
Line 2054
  ( possible size=1
  == always {!<=-1,!>=2}
  "{" always "{"
Line 2056
  > always {!<=-1,!>=2}
  0 always 0
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  "}" always "}"
Line 2057
  -- {>=0,!<=-1}
  level {>=1,!<=0}
Line 2063
  ( always {!<=-1,!>=2}
Line 2071
  tok possible {lifetime[Address]=(tok1)@253,lifetime[Address]=(tok1)@254}
Line 2073
  tok1 {symbolic=(*tok),symbolic=(nameToken),0}
  && always {!<=-1,!>=2}
  tok1 {symbolic=(*tok),!0}
  != always {!<=-1,!>=2}
Line 2074
  return always {!<=-1,!>=2}
  false always 0
Line 2077
  tok1 {symbolic=(*tok),0}
  == always {!<=-1,!>=2}
Line 2078
  tok1 always {symbolic=(*tok),symbolic=(nameToken)}
Line 2079
  return always {!<=-1,!>=2}
  false always 0
Line 2083
  tok1 always !symbolic=(nameToken)
  -1 always -1
  == always {!<=-1,!>=2}
  "using" always "using"
Line 2087
  . always !0
Line 2088
  return always {!<=-1,!>=2}
  false always 0
Line 2091
  ( always {!<=-1,!>=2}
  tok1 always !symbolic=(nameToken)
  -1 always -1
  "class|struct|union|enum|namespace" always "class|struct|union|enum|namespace"
Line 2093
  return always {!<=-1,!>=2}
  false always 0
Line 2099
  :: always !<=-1
  index always !<=-1
  index always !<=-1
  = always !<=-1
  ( always !<=-1
Line 2100
  :: always !<=-1
  new_index always !<=-1
  new_index always !<=-1
  = always !<=-1
Line 2101
  match {!<=-1,!>=2,1}
  match always {!<=-1,!>=2}
  = always 1
  true always 1
Line 2102
  ( always {!<=-1,!>=2}
  tok2 possible symbolic=(tok1)
  -2 always -2
  "%name% ::" always "%name% ::"
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  tok2 possible symbolic=(tok1)
  -2 always -2
  ( always {!<=-1,!>=2}
Line 2104
  match always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ! {!<=-1,!>=2,0}
  scope1 possible size=0
  ( {!<=-1,!>=2,1}
Line 2105
  new_index always !<=-1
  = always !<=-1
  scope1 always !size=0
  ( always !<=-1
  ' ' always 32
  index always !<=-1
  - always !<=-1
  1 always 1
Line 2106
  new_index always !<=-1
  != always {!<=-1,!>=2}
Line 2107
  scope1 always !size=0
  new_index always !<=-1
  index always !<=-1
  - always !<=-1
  new_index always !<=-1
Line 2108
  ! {!<=-1,!>=2,0}
  qualification possible size=0
  ( {!<=-1,!>=2,1}
Line 2109
  last always NonMovedVariable
Line 2111
  = always !size=0
  scope1 always !size=0
Line 2113
  match always {!<=-1,!>=2}
  = always 0
  false always 0
Line 2114
  match {!<=-1,!>=2,0,1}
  && always {!<=-1,!>=2}
  -2 always -2
  == always {!<=-1,!>=2}
  last possible NonMovedVariable
Line 2115
  index always !<=-1
  = always !<=-1
  new_index always !<=-1
Line 2117
  ! {!<=-1,!>=2,0}
  qualification possible size=0
  ( {!<=-1,!>=2,1}
Line 2118
  " :: " always " :: "
  qualification always !size=0
Line 2119
  -2 always -2
Line 2121
  -2 always -2
Line 2124
  = possible size=0
  scope1 possible size=0
Line 2125
  ! {!<=-1,!>=2,0}
  scope1 {symbolic=(fullScope1),size=0}
  ( {!<=-1,!>=2,1}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 2126
  " :: " always " :: "
Line 2127
  qualification possible size=0
Line 2129
  scope possible symbolic=(ns+" :: "+qualification)
  == always {!<=-1,!>=2}
Line 2130
  return always {!<=-1,!>=2}
  true always 1
Line 2132
  = possible 1
  ? possible 1
  memberClassScope always !0
  : always 1
Line 2135
  qualification possible size=0
  ( {!<=-1,!>=2,0,1}
  && always {!<=-1,!>=2}
  scopeInfo always symbolic=(memberClassScope?memberClassScope:currentScope)
  ( always {!<=-1,!>=2}
  scope always !symbolic=(fullScope1)
Line 2136
  return always {!<=-1,!>=2}
  true always 1
Line 2139
  = always symbolic=(memberClassScope?memberClassScope:currentScope)
  scopeInfo always symbolic=(memberClassScope?memberClassScope:currentScope)
Line 2140
  tempScope possible {symbolic=(scopeInfo),symbolic=(memberClassScope?memberClassScope:currentScope)}
Line 2142
  ! {!<=-1,!>=2,0}
  tempScope {symbolic=(scopeInfo),!0}
  . possible size=0
  ( {!<=-1,!>=2,1}
Line 2143
  ( always {!<=-1,!>=2}
Line 2144
  tempScope always !0
  . always !size=0
  ( possible lifetime[Iterator]=(tempScope->usingNamespaces)
  != always {!<=-1,!>=2}
  tempScope always !0
  . always !size=0
  ( {lifetime[Iterator]=(tempScope->usingNamespaces),end=0}
Line 2145
  return always {!<=-1,!>=2}
  true always 1
Line 2147
  tempScope always !0
  . always !size=0
Line 2148
  == always {!<=-1,!>=2}
  " :: " always " :: "
  qualification always !size=0
Line 2149
  return always {!<=-1,!>=2}
  true always 1
Line 2153
  tempScope always !0
Line 2159
  index always !<=-1
  = always !<=-1
  newScope1 always symbolic=(scope1)
  ( always !<=-1
Line 2160
  ! always {!<=-1,!>=2}
  newScope1 possible symbolic=(scope1)
  ( always {!<=-1,!>=2}
Line 2161
  :: always !<=-1
  separator always !<=-1
  separator always !<=-1
  = always !<=-1
  newScope1 always !size=0
  ( always !<=-1
  " :: " always " :: "
  index always !<=-1
  - always !<=-1
  1 always 1
Line 2162
  separator always !<=-1
  != always {!<=-1,!>=2}
Line 2163
  newScope1 always !size=0
  0 always 0
  separator always !<=-1
Line 2165
  newScope1 {!size=0,NonMovedVariable}
Line 2167
  = possible {NonMovedVariable,size=0}
  newScope1 possible {NonMovedVariable,size=0}
Line 2168
  ! {!<=-1,!>=2,0}
  newScope1 {symbolic=(newFullScope1),NonMovedVariable,size=0}
  ( {!<=-1,!>=2,1}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 2169
  " :: " always " :: "
Line 2170
  qualification possible size=0
Line 2172
  == always {!<=-1,!>=2}
Line 2173
  return always {!<=-1,!>=2}
  true always 1
Line 2176
  return always {!<=-1,!>=2}
  false always 0
Line 2182
  -2 always -2
  == always {!<=-1,!>=2}
  "~" always "~"
  -4 always -4
  -3 always -3
Line 2183
  ( always {!<=-1,!>=2}
  "%type% ::" always "%type% ::"
Line 2184
  ! {!<=-1,!>=2,0}
  qualification possible size=0
  ( {!<=-1,!>=2,1}
Line 2185
  " :: " always " :: "
  qualification always !size=0
Line 2187
  -2 always -2
Line 2189
  qualification possible size=0
Line 2194
  != always {!<=-1,!>=2}
  "(" always "("
Line 2195
  nullptr always 0
Line 2197
  end possible symbolic=(tok->link()->next())
Line 2198
  end {symbolic=(tok->link()->next()),!0}
  ( possible size=1
  == always {!<=-1,!>=2}
  "{" always "{"
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  end always !0
  -2 always -2
  ":|, %name%" always ":|, %name%"
Line 2199
  end always !0
Line 2200
  end always !0
  == always {!<=-1,!>=2}
  ";" always ";"
Line 2202
  end always !0
Line 2204
  nullptr always 0
Line 2208
  ( always {!<=-1,!>=2}
Line 2210
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  -2 always -2
  ":: %name% (" always ":: %name% ("
  || always {!<=-1,!>=2}
Line 2211
  ( always {!<=-1,!>=2}
  -3 always -3
  ":: ~ %name% (" always ":: ~ %name% ("
  && always {!<=-1,!>=2}
Line 2212
  "{|:" always "{|:"
Line 2215
  ( always {!<=-1,!>=2}
Line 2217
  scope1 possible {symbolic=(scope2),symbolic=(":: "+scope2),symbolic=(removed)@51}
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 2218
  return always {!<=-1,!>=2}
  false always 0
Line 2221
  scope1 {symbolic=(":: "+scope2),!size=0}
  == always {!<=-1,!>=2}
  scope2 {symbolic=(":: "+scope1),!size=0}
Line 2222
  return always {!<=-1,!>=2}
  true always 1
Line 2225
  scope1 always {!symbolic=(scope2),!size=0}
  == always {!<=-1,!>=2}
  ":: " always ":: "
  scope2 {symbolic=(":: "+scope1),!symbolic=(scope1),!size=0}
Line 2226
  :: always !<=-1
  end always !<=-1
  end always !<=-1
  = always !<=-1
  scope2 always {!symbolic=(scope1),!size=0}
  ( always !<=-1
  ' ' always 32
Line 2227
  end always !<=-1
  == always {!<=-1,!>=2}
Line 2228
  end always !<=-1
  = always !<=0
  scope2 always {!symbolic=(scope1),!size=0}
  ( always !<=0
Line 2229
  ( always {!<=-1,!>=2}
  scope2 always {!symbolic=(scope1),!size=0}
  0 always 0
  end always !<=-1
Line 2230
  return always {!<=-1,!>=2}
  true always 1
Line 2231
  scope2 always {!symbolic=(scope1),!size=0}
  == always {!<=-1,!>=2}
  ":: " always ":: "
  scope1 always {!symbolic=(scope2),!symbolic=(":: "+scope2),!size=0}
Line 2232
  :: always !<=-1
  end always !<=-1
  end always !<=-1
  = always !<=-1
  scope1 always {!symbolic=(scope2),!symbolic=(":: "+scope2),!size=0}
  ( always !<=-1
  ' ' always 32
Line 2233
  end always !<=-1
  == always {!<=-1,!>=2}
Line 2234
  end always !<=-1
  = always !<=0
  scope1 always {!symbolic=(scope2),!symbolic=(":: "+scope2),!size=0}
  ( always !<=0
Line 2235
  ( always {!<=-1,!>=2}
  scope1 always {!symbolic=(scope2),!symbolic=(":: "+scope2),!size=0}
  0 always 0
  end always !<=-1
Line 2236
  return always {!<=-1,!>=2}
  true always 1
Line 2239
  return always {!<=-1,!>=2}
  false always 0
Line 2242
  ( always {!<=-1,!>=2}
Line 2244
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  < always {!<=-1,!>=2}
  :: always 1
  CPP11 always 1
Line 2245
  return always {!<=-1,!>=2}
  false always 0
Line 2247
  substitute always {!<=-1,!>=2}
  substitute always {!<=-1,!>=2}
  = always 0
  false always 0
Line 2249
  = {&,lifetime[Address]=(scopeInfo),!0}
  & {&,lifetime[Address]=(scopeInfo),!0}
Line 2258
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 2259
  mErrorLogger always !0
  ( always !size=0
  0 always 0
  "Tokenize (using)" always "Tokenize (using)"
Line 2261
  ( always {!<=-1,!>=2}
Line 2262
  return always {!<=-1,!>=2}
  substitute always {!<=-1,!>=2}
Line 2264
  ( always {!<=-1,!>=2}
  "enum class|struct" always "enum class|struct"
Line 2266
  ( always {!<=-1,!>=2}
  bodyStart possible {symbolic=(tok),0}
  "%name%|:|::|<" always "%name%|:|::|<"
Line 2267
  == always {!<=-1,!>=2}
  "<" always "<"
Line 2269
  = possible 0
  ? possible 0
  bodyStart always !0
  : always 0
  nullptr always 0
Line 2271
  ( always {!<=-1,!>=2}
  bodyStart possible symbolic=(tok)
  "{" always "{"
Line 2276
  ( always {!<=-1,!>=2}
  "{|}|namespace|class|struct|union" always "{|}|namespace|class|struct|union"
  || always {!<=-1,!>=2}
Line 2277
  ( always {!<=-1,!>=2}
  "using namespace %name% ;|::" always "using namespace %name% ;|::"
Line 2279
  & {lifetime[Address]=(currentScope),!0}
  . always {!<=-1,!>=2}
  debugwarnings always {!<=-1,!>=2}
Line 2281
  :: always 7
  debug always 7
  "simplifyUsingUnmatchedBodyEnd" always "simplifyUsingUnmatchedBodyEnd"
Line 2282
  "simplifyUsing: unmatched body end" always "simplifyUsing: unmatched body end"
Line 2288
  ( always {!<=-1,!>=2}
  "template < !!>" always "template < !!>"
Line 2291
  end always symbolic=(tok->next()->findClosingBracket())
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  end {symbolic=(tok->next()->findClosingBracket()),!0}
  "class|struct|union %name%" always "class|struct|union %name%"
Line 2292
  end {symbolic=(tok->next()->findClosingBracket()),!0}
  2 always 2
Line 2296
  = always !0
  declEndToken always !0
Line 2301
  ! always {!<=-1,!>=2}
  -1 always -1
  != always {!<=-1,!>=2}
  ">" always ">"
  && always {!<=-1,!>=2}
Line 2302
  ( always {!<=-1,!>=2}
  "using %name% = ::| %name%" always "using %name% = ::| %name%"
  || always {!<=-1,!>=2}
Line 2303
  ( always {!<=-1,!>=2}
  "using %name% [ [" always "using %name% [ ["
  && always {!<=-1,!>=2}
Line 2304
  ( always {!<=-1,!>=2}
  2 always 2
  "] ] = ::| %name%" always "] ] = ::| %name%"
Line 2307
  1 always 1
Line 2312
  tok always symbolic=(usingStart)
  2 always 2
  == always {!<=-1,!>=2}
  "=" always "="
Line 2313
  tok always symbolic=(usingStart)
  3 always 3
Line 2315
  tok always symbolic=(usingStart)
  2 always 2
  3 always 3
Line 2317
  ! always {!<=-1,!>=2}
Line 2323
  ( always {!<=-1,!>=2}
  "class|struct|union|enum %name%| {|:" always "class|struct|union|enum %name%| {|:"
Line 2324
  1 always 1
Line 2325
  hasName always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "%name%" always "%name%"
Line 2328
  hasName {!<=-1,!>=2,0}
Line 2332
  == always {!<=-1,!>=2}
  ":" always ":"
Line 2334
  structEnd possible 0
  && always {!<=-1,!>=2}
  structEnd always !0
  != always {!<=-1,!>=2}
  "{" always "{"
Line 2335
  structEnd always !0
Line 2336
  ! {!<=-1,!>=2,1}
  structEnd possible 0
Line 2344
  ";" always ";"
  "" always ""
Line 2347
  ! always {!<=-1,!>=2}
  hasName always {!<=-1,!>=2}
Line 2349
  2 always 2
  == always {!<=-1,!>=2}
  ";" always ";"
Line 2352
  "Unnamed" always "Unnamed"
Line 2353
  tok always symbolic=(usingStart)
Line 2354
  5 always 5
  newName possible symbolic=(name)
  "" always ""
Line 2355
  newName possible symbolic=(name)
  "" always ""
Line 2357
  tok always symbolic=(usingStart)
Line 2360
  2 always 2
Line 2362
  2 always 2
  == always {!<=-1,!>=2}
  "=" always "="
Line 2363
  3 always 3
Line 2365
  2 always 2
  3 always 3
Line 2376
  == always {!<=-1,!>=2}
  "typename" always "typename"
Line 2379
  ( always {!<=-1,!>=2}
  temp possible symbolic=(start)
  "%name% ::" always "%name% ::"
Line 2380
  2 always 2
Line 2381
  ( always {!<=-1,!>=2}
  temp possible symbolic=(start)
  "template %name%" always "template %name%"
Line 2386
  = always !0
  usingEnd always !0
Line 2392
  = {&,lifetime[Address]=(scopeInfo1),!0}
  & {&,lifetime[Address]=(scopeInfo1),!0}
Line 2394
  = always 0
  nullptr always 0
Line 2395
  inMemberFunc always {!<=-1,!>=2}
  inMemberFunc always {!<=-1,!>=2}
  = always 0
  false always 0
Line 2396
  = always 0
  nullptr always 0
Line 2397
  = always 0
  nullptr always 0
Line 2401
  . possible 3
  == {!<=-1,!>=2,0}
  :: always 4
  Other always 4
  || always {!<=-1,!>=2}
Line 2402
  . always !4
  == always {!<=-1,!>=2}
  :: always 3
  MemberFunction always 3
Line 2404
  scopeInfo1 always symbolic=(scopeInfo)
Line 2405
  ! always {!<=-1,!>=2}
Line 2406
  return always {!<=-1,!>=2}
  substitute always {!<=-1,!>=2}
Line 2409
  == always {!<=-1,!>=2}
  :: always 3
  MemberFunction always 3
Line 2411
  temp always symbolic=(currentScope->findScope(currentScope->fullName))
Line 2412
  inMemberFunc always {!<=-1,!>=2}
  = always 1
  true always 1
Line 2413
  = {symbolic=(currentScope->findScope(currentScope->fullName)),!0}
  temp {symbolic=(currentScope->findScope(currentScope->fullName)),!0}
Line 2414
  = always symbolic=(currentScope->bodyEnd->next())
  endToken always symbolic=(currentScope->bodyEnd->next())
Line 2419
  currentScope1 possible {lifetime[Address]=(scopeInfo1),symbolic=(&scopeInfo1),&}
Line 2420
  skip always {!<=-1,!>=2}
  skip always {!<=-1,!>=2}
  = always 0
  false always 0
Line 2421
  = always 0
  nullptr always 0
Line 2422
  = possible {symbolic=(list.front()),symbolic=(usingEnd->next())}
  startToken possible {symbolic=(list.front()),symbolic=(usingEnd->next())}
  ! {!<=-1,!>=2,1}
  skip {!<=-1,!>=2,0}
  && always {!<=-1,!>=2}
  tok1 possible {symbolic=(list.front()),symbolic=(usingEnd->next())}
  && always {!<=-1,!>=2}
  tok1 always !0
  != always {!<=-1,!>=2}
  = possible symbolic=(tok1)
  tok1 possible {symbolic=(after),symbolic=(tok1->next())}
  ( possible symbolic=(tok1)
Line 2424
  tok1 possible symbolic=(enumOpenBrace)
  && always {!<=-1,!>=2}
  tok1 always !0
  == always {!<=-1,!>=2}
Line 2425
  tok1 {!0,symbolic=(enumOpenBrace)}
Line 2426
  = always 0
  nullptr always 0
Line 2430
  ( always {!<=-1,!>=2}
  "{|}|namespace|class|struct|union" always "{|}|namespace|class|struct|union"
  && always {!<=-1,!>=2}
  -1 always -1
  != always {!<=-1,!>=2}
  "using" always "using"
  || always {!<=-1,!>=2}
Line 2431
  ( always {!<=-1,!>=2}
  "using namespace %name% ;|::" always "using namespace %name% ;|::"
Line 2433
  & {lifetime[Address]=(currentScope1),!0}
  currentScope1 possible lifetime[Address]=(scopeInfo1)
  . always {!<=-1,!>=2}
  debugwarnings always {!<=-1,!>=2}
Line 2435
  :: always 7
  debug always 7
  "simplifyUsingUnmatchedBodyEnd" always "simplifyUsingUnmatchedBodyEnd"
Line 2436
  "simplifyUsing: unmatched body end" always "simplifyUsing: unmatched body end"
Line 2439
  inMemberFunc always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  memberFuncEnd always !0
Line 2440
  inMemberFunc always {!<=-1,!>=2}
  = always 0
  false always 0
Line 2441
  = always 0
  nullptr always 0
Line 2442
  = always 0
  nullptr always 0
Line 2448
  ( always {!<=-1,!>=2}
  "template < !!>" always "template < !!>"
Line 2451
  = always !0
  declEndToken always !0
Line 2456
  == always {!<=-1,!>=2}
  "enum" always "enum"
Line 2457
  ( always {!<=-1,!>=2}
  "enum class|struct" always "enum class|struct"
Line 2460
  ( always {!<=-1,!>=2}
  defStart possible symbolic=(tok1)
  "%name%|::|:" always "%name%|::|:"
Line 2462
  ( always {!<=-1,!>=2}
  defStart possible symbolic=(tok1)
  "{" always "{"
Line 2468
  ( always {!<=-1,!>=2}
Line 2469
  ! {!<=-1,!>=2,0}
  scope1 possible size=0
  ( {!<=-1,!>=2,1}
Line 2470
  scope1 always !size=0
  " :: " always " :: "
Line 2473
  temp always symbolic=(currentScope1->findScope(scope1))
Line 2476
  inMemberFunc always {!<=-1,!>=2}
  = always 1
  true always 1
Line 2477
  = {symbolic=(currentScope1->findScope(scope1)),!0}
  temp {symbolic=(currentScope1->findScope(scope1)),!0}
Line 2478
  = always !0
  end always !0
Line 2482
  inMemberFunc always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 2483
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  & {lifetime[Address]=(tok1),!0}
  memberFuncScope always !0
Line 2485
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  & {lifetime[Address]=(tok1),!0}
  nullptr always 0
Line 2491
  ( always {!<=-1,!>=2}
  -2 always -2
  "%name% ::" always "%name% ::"
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  -2 always -2
  ( always {!<=-1,!>=2}
Line 2492
  -2 always -2
  " :: " always " :: "
Line 2493
  == always {!<=-1,!>=2}
  -2 always -2
Line 2498
  idx always !<=-1
  = always !<=-1
  ( always !<=-1
  " " always " "
Line 2500
  idx always !<=-1
  == always {!<=-1,!>=2}
Line 2503
  -2 always -2
  == always {!<=-1,!>=2}
  idx always !<=-1
  + always !<=0
  1 always 1
Line 2506
  idx always !<=-1
  - always !<=-1
  3 always 3
Line 2513
  -1 always -1
  == always {!<=-1,!>=2}
  "::" always "::"
Line 2514
  ( possible lifetime[Iterator]=(removed)
  0 always 0
  ":: " always ":: "
Line 2518
  = always 0
  nullptr always 0
Line 2522
  type always symbolic=(start)
  == always {!<=-1,!>=2}
  "::" always "::"
Line 2523
  type always symbolic=(start)
Line 2524
  ( always {!<=-1,!>=2}
  "%type% ::" always "%type% ::"
Line 2525
  2 always 2
Line 2526
  ( always {!<=-1,!>=2}
  "%type%" always "%type%"
Line 2528
  ( always {!<=-1,!>=2}
  type always symbolic=(start)
  "%type% ::" always "%type% ::"
Line 2530
  type possible symbolic=(start)
  2 always 2
Line 2531
  ( always {!<=-1,!>=2}
  "%type% ::" always "%type% ::"
Line 2532
  ( always {!<=-1,!>=2}
  "%type%" always "%type%"
Line 2534
  ( always {!<=-1,!>=2}
  type always symbolic=(start)
  "%type%" always "%type%"
Line 2535
  ( always {!<=-1,!>=2}
  type possible symbolic=(start)
  "const|class|struct|union|enum %type%" always "const|class|struct|union|enum %type%"
  || always {!<=-1,!>=2}
Line 2536
  type possible symbolic=(start)
  && always {!<=-1,!>=2}
  type possible symbolic=(start)
  ( always !0
  ( always {!<=-1,!>=2}
Line 2539
  type possible symbolic=(start)
Line 2541
  ( always {!<=-1,!>=2}
  "%type%" always "%type%"
  && always {!<=-1,!>=2}
Line 2542
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "unsigned|signed" always "unsigned|signed"
Line 2546
  atEnd always {!<=-1,!>=2}
  atEnd always {!<=-1,!>=2}
  = always 0
  false always 0
Line 2547
  ! {!<=-1,!>=2,1}
  atEnd {!<=-1,!>=2,0}
Line 2548
  && always {!<=-1,!>=2}
  type always !0
  == always {!<=-1,!>=2}
  "::" always "::"
Line 2549
  type always !0
Line 2552
  ( always {!<=-1,!>=2}
  "%type%" always "%type%"
  && always {!<=-1,!>=2}
Line 2553
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  ( always !0
  "[|,|(" always "[|,|("
Line 2554
  = always !0
  ( always !0
Line 2555
  ( always {!<=-1,!>=2}
  "const (" always "const ("
Line 2557
  atEnd always {!<=-1,!>=2}
  = always 1
  true always 1
Line 2559
  atEnd always {!<=-1,!>=2}
  = always 1
  true always 1
Line 2562
  type always symbolic=(start)
Line 2565
  ! always {!<=-1,!>=2}
Line 2569
  type always !0
  == always {!<=-1,!>=2}
  "<" always "<"
Line 2570
  type always !0
Line 2572
  type possible 0
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  type always !0
  ":: %type%" always ":: %type%"
Line 2573
  type always !0
  2 always 2
Line 2575
  ! {!<=-1,!>=2,1}
  type possible 0
Line 2579
  ( always {!<=-1,!>=2}
  "const|volatile" always "const|volatile"
Line 2587
  ( always {!<=-1,!>=2}
  type possible 0
  "*|&|&&|const" always "*|&|&&|const"
Line 2593
  && always {!<=-1,!>=2}
  type always !0
  == always {!<=-1,!>=2}
  "[" always "["
Line 2595
  ! always {!<=-1,!>=2}
Line 2598
  atEnd always {!<=-1,!>=2}
  atEnd always {!<=-1,!>=2}
  = always 0
  false always 0
Line 2599
  ! {!<=-1,!>=2,1}
  atEnd {!<=-1,!>=2,0}
Line 2600
  type possible symbolic=(arrayStart)
  ( possible 0
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  ( always !0
  ";|," always ";|,"
Line 2601
  = always !0
  ( always !0
Line 2604
  ! {!<=-1,!>=2,1}
  ( possible 0
Line 2606
  ( always !0
  == always {!<=-1,!>=2}
  ";" always ";"
Line 2607
  atEnd always {!<=-1,!>=2}
  = always 1
  true always 1
Line 2608
  == always {!<=-1,!>=2}
  "]" always "]"
Line 2609
  atEnd always {!<=-1,!>=2}
  = always 1
  true always 1
Line 2611
  = always !0
  ( always !0
Line 2615
  && always {!<=-1,!>=2}
  type always !0
  == always {!<=-1,!>=2}
  "[" always "["
Line 2619
  ! always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  tok1 always !0
Line 2622
  = always !0
  tok1 always !0
  ( always !0
Line 2624
  type possible symbolic=(usingEnd)
  && always {!<=-1,!>=2}
  type always !0
  == always {!<=-1,!>=2}
Line 2627
  ( always {!<=-1,!>=2}
  tok1 always !0
  ( {symbolic=(after),!0}
  "%name%" always "%name%"
Line 2628
  tok1 always !0
  ( {symbolic=(after),!0}
  arrayStart always !0
  usingEnd {!0,symbolic=(type)}
Line 2629
  tok1 always !0
  arrayStart always !0
Line 2630
  tok1 always !0
Line 2631
  substitute always {!<=-1,!>=2}
  = always 1
  true always 1
Line 2636
  :: always !<=-1
  idx always !<=-1
  idx always !<=-1
  = always !<=-1
  removed1 always symbolic=(removed)
  ( always !<=-1
  " ::" always " ::"
Line 2637
  idx always !<=-1
  != always {!<=-1,!>=2}
Line 2638
  removed1 always symbolic=(removed)
  idx always !<=-1
Line 2639
  ( always {!<=-1,!>=2}
  removed1 possible symbolic=(removed)
  & {lifetime[Address]=(scopeInfo1),!0}
Line 2641
  tempScope possible symbolic=(currentScope)
Line 2642
  ( possible lifetime[Iterator]=(tempScope->recordTypes)
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(tempScope->recordTypes),end=0}
Line 2643
  :: always !<=-1
  spaceIdx always !<=-1
  spaceIdx always !<=-1
  = always 0
  0 always 0
Line 2644
  :: always !<=-1
  startIdx always !<=-1
  startIdx always !<=-1
  = always 0
  0 always 0
Line 2645
  spaceIdx always !<=-1
  = always !<=-1
  ( always !<=-1
  " " always " "
  startIdx {symbolic=(spaceIdx+1),!<=-1,0}
  != always {!<=-1,!>=2}
Line 2646
  tok1 always !0
  startIdx always !<=-1
  spaceIdx always !<=-1
  - always !<=-1
  startIdx always !<=-1
Line 2647
  startIdx always !<=-1
  = always !<=0
  spaceIdx always !<=-1
  + always !<=0
  1 always 1
Line 2649
  tok1 always !0
  startIdx {!<=-1,0}
Line 2650
  tok1 always !0
  "::" always "::"
Line 2653
  idx always !<=-1
  = always !<=-1
  ( always !<=-1
  " ::" always " ::"
Line 2654
  idx always !<=-1
  == always {!<=-1,!>=2}
Line 2657
  idx always !<=-1
Line 2663
  tok1 always !0
  usingEnd {!0,symbolic=(type)}
Line 2664
  tok1 always !0
Line 2665
  substitute always {!<=-1,!>=2}
  = always 1
  true always 1
Line 2668
  skip always {!<=-1,!>=2}
  = always 1
  true always 1
Line 2669
  . always {!<=-1,!>=2}
  debugwarnings always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 2671
  && always {!<=-1,!>=2}
  tok3 always !0
  != always {!<=-1,!>=2}
Line 2672
  ! {!<=-1,!>=2,0}
  str possible size=0
  ( {!<=-1,!>=2,1}
Line 2673
  ' ' always 32
Line 2676
  str possible size=0
  " ;" always " ;"
Line 2677
  1 always 1
Line 2678
  mErrorLogger always !0
  callstack always size=1
  & {lifetime[Address]=(list),!0}
  :: always 7
  debug always 7
  "simplifyUsing" always "simplifyUsing"
Line 2679
  "Failed to parse \'" always "Failed to parse \'"
  + possible size=19
  str {size=2,!<=size=1}
  + possible size=52
  "\'. The checking continues anyway." always "\'. The checking continues anyway."
  :: always 0
  normal always 0
Line 2682
  = {symbolic=(tok1->next()),!0}
  after {symbolic=(tok1->next()),!0}
Line 2685
  ! {!<=-1,!>=2,0}
  skip {!<=-1,!>=2,1}
Line 2690
  = {lifetime[Iterator]=(usingList),size=0,start=0}
  usingList possible size=0
  ( {lifetime[Iterator]=(usingList),size=0,start=0}
  it possible {lifetime[Iterator]=(usingList),size=0,start=0}
  != always {!<=-1,!>=2}
  usingList possible size=0
  ( {lifetime[Iterator]=(usingList),size=0,end=0}
  it possible lifetime[Iterator]=(usingList)
Line 2691
  it possible lifetime[Iterator]=(usingList)
Line 2692
  it possible lifetime[Iterator]=(usingList)
Line 2693
  usingStart always symbolic=(it->startTok)
Line 2694
  usingEnd always symbolic=(it->endTok)
Line 2695
  usingStart always symbolic=(it->startTok)
  ( always !0
  usingEnd always symbolic=(it->endTok)
  ( always !0
Line 2697
  usingStart always symbolic=(it->startTok)
  ( always !0
  usingEnd always symbolic=(it->endTok)
Line 2698
  usingEnd always symbolic=(it->endTok)
Line 2701
  usingEnd always symbolic=(it->endTok)
Line 2702
  usingStart always symbolic=(it->startTok)
  usingEnd always symbolic=(it->endTok)
  ( always !0
Line 2703
  usingStart always symbolic=(it->startTok)
Line 2706
  usingStart always symbolic=(it->startTok)
  usingEnd always symbolic=(it->endTok)
Line 2707
  usingStart always symbolic=(it->startTok)
Line 2712
  return always {!<=-1,!>=2}
  substitute always {!<=-1,!>=2}
Line 2715
  ( always {!<=-1,!>=2}
Line 2721
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 2724
  && always {!<=-1,!>=2}
Line 2728
  ( always {!<=-1,!>=2}
  ( possible lifetime[Object]=(tokenList)
Line 2731
  ( always {!<=-1,!>=2}
Line 2738
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  ( {lifetime[Object]=(list.getFiles().front()),lifetime[Object]=(list),!0}
Line 2739
  return always {!<=-1,!>=2}
  false always 0
Line 2742
  "Tokenizer::simplifyTokens1::createAst" always "Tokenizer::simplifyTokens1::createAst"
  mTimerResults always !0
Line 2750
  mTimerResults possible 0
Line 2751
  "Tokenizer::simplifyTokens1::createSymbolDatabase" always "Tokenizer::simplifyTokens1::createSymbolDatabase"
  mTimerResults always !0
Line 2758
  "Tokenizer::simplifyTokens1::setValueType" always "Tokenizer::simplifyTokens1::setValueType"
  mTimerResults always !0
Line 2759
  true always 1
Line 2761
  true always 1
Line 2764
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 2765
  this always !0
Line 2768
  "DISABLE_VALUEFLOW" always "DISABLE_VALUEFLOW"
Line 2769
  doValueFlow always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  disableValueflowEnv always !0
  "1" always "1"
  != always {!<=-1,!>=2}
  0 always 0
Line 2771
  doValueFlow {symbolic=(!disableValueflowEnv||(std::strcmp(disableValueflowEnv,"1")!=0)),!<=-1,!>=2,0}
Line 2773
  "Tokenizer::simplifyTokens1::ValueFlow" always "Tokenizer::simplifyTokens1::ValueFlow"
  mTimerResults always !0
Line 2774
  & {lifetime[Address]=(list),!0}
Line 2776
  & {lifetime[Address]=(list),!0}
Line 2781
  ( always {!<=-1,!>=2}
  :: always 5
  portability always 5
Line 2783
  == always {!<=-1,!>=2}
  :: always 7
  eChar always 7
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 2793
  doValueFlow {symbolic=(!disableValueflowEnv||(std::strcmp(disableValueflowEnv,"1")!=0)),!<=-1,!>=2}
Line 2797
  1 always 1
Line 2799
  return always {!<=-1,!>=2}
  true always 1
Line 2802
  ( always {!<=-1,!>=2}
Line 2806
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 2807
  return always {!<=-1,!>=2}
  false always 0
Line 2809
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 2822
  ( always {!<=-1,!>=2}
  "enum %name% {" always "enum %name% {"
Line 2823
  2 always 2
Line 2824
  "typedef" always "typedef"
Line 2825
  tok2 always symbolic=(Token::findsimplematch(tok,"typedef",tok->link()))
Line 2826
  tok2 {symbolic=(Token::findsimplematch(tok,"typedef",tok->link())),!0}
Line 2835
  mTypeSize always size=0
  "char" always "char"
  = always 1
  1 always 1
Line 2836
  "_Bool" always "_Bool"
Line 2837
  "bool" always "bool"
Line 2838
  "short" always "short"
Line 2839
  "int" always "int"
Line 2840
  "long" always "long"
Line 2841
  "float" always "float"
Line 2842
  "double" always "double"
Line 2843
  "wchar_t" always "wchar_t"
Line 2844
  "size_t" always "size_t"
Line 2845
  "*" always "*"
Line 2850
  cpp always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 2853
  && always {!<=-1,!>=2}
  tok always !0
Line 2854
  ( possible {size=1,size=2}
  0 always 0
Line 2856
  ( possible {size=1,size=2}
  ( {!<=-1,1,2}
  == {!<=-1,!>=2,1,0}
  1 always 1
  && always {!<=-1,!>=2}
  ( always !<=-1
  == always {!<=-1,!>=2}
  1 always 1
Line 2857
  ( always size=1
  0 always 0
Line 2860
  c2 always symbolic=(tok->next()->str()[0])
  == always {!<=-1,!>=2}
  '=' always 61
  && always {!<=-1,!>=2}
  "+-*/%|^=!<>" always "+-*/%|^=!<>"
  c1 always symbolic=(tok->str()[0])
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "%type% *" always "%type% *"
Line 2862
  cpp {symbolic=(isCPP()),!<=-1,!>=2}
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  ">" always ">"
  || always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "> *" always "> *"
Line 2864
  == always {!<=-1,!>=2}
  ">" always ">"
Line 2865
  opening always symbolic=(tok->str()==">"?tok->findOpeningBracket():tok->previous()->findOpeningBracket())
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  opening {symbolic=(tok->str()==">"?tok->findOpeningBracket():tok->previous()->findOpeningBracket()),!0}
  "%name%" always "%name%"
Line 2868
  c2 always 61
Line 2872
  == always {!<=-1,!>=2}
  "=" always "="
Line 2873
  ( possible size=2
  == always {!<=-1,!>=2}
  ">>" always ">>"
Line 2874
  ">>=" always ">>="
Line 2876
  == always {!<=-1,!>=2}
  "<<" always "<<"
Line 2877
  "<<=" always "<<="
Line 2880
  cpp {symbolic=(isCPP()),!<=-1,!>=2}
  && always {!<=-1,!>=2}
  c1 always symbolic=(tok->str()[0])
  == always {!<=-1,!>=2}
  'p' always 112
  || always {!<=-1,!>=2}
  c1 {symbolic=(tok->str()[0]),!112}
  == always {!<=-1,!>=2}
  '_' always 95
  && always {!<=-1,!>=2}
Line 2881
  ( always {!<=-1,!>=2}
  "private|protected|public|__published : !!:" always "private|protected|public|__published : !!:"
Line 2882
  simplify always {!<=-1,!>=2}
  simplify always {!<=-1,!>=2}
  = always 0
  false always 0
Line 2883
  = always 0
  0 always 0
Line 2885
  ( possible size=1
  == always {!<=-1,!>=2}
  ")" always ")"
Line 2887
  == always {!<=-1,!>=2}
  "(" always "("
Line 2888
  == always {!<=-1,!>=2}
  0U always 0
Line 2890
  -- always !-1
  par always !0
Line 2892
  != always {!<=-1,!>=2}
  0U always 0
  || always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  "(" always "("
Line 2894
  ( always {!<=-1,!>=2}
  "[;{}]" always "[;{}]"
Line 2895
  simplify always {!<=-1,!>=2}
  = always 1
  true always 1
Line 2898
  ( {!<=-1,!>=2,0}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 2900
  ( {!<=-1,!>=2,0}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  ':' always 58
Line 2901
  simplify always {!<=-1,!>=2}
  = always 1
  true always 1
Line 2904
  simplify {!<=-1,!>=2,0,1}
Line 2905
  ":" always ":"
Line 2908
  == always {!<=-1,!>=2}
  "->" always "->"
Line 2910
  -4 always -4
Line 2911
  ( always {!<=-1,!>=2}
  "( & %name% )" always "( & %name% )"
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  ">" always ">"
Line 2915
  "." always "."
Line 2917
  "." always "."
Line 2918
  "->" always "->"
Line 2928
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 2933
  ( always {!<=-1,!>=2}
  "%str%" always "%str%"
  || always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "_T|_TEXT|TEXT ( %str% )" always "_T|_TEXT|TEXT ( %str% )"
Line 2934
  ( always {!<=-1,!>=2}
Line 2935
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 2937
  2 always 2
Line 2950
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "?|:|,|(|[|{|return|case|sizeof|%op% +|-" always "?|:|,|(|[|{|return|case|sizeof|%op% +|-"
  || always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 16
  eIncDecOp always 16
Line 2953
  != always {!<=-1,!>=2}
  ">" always ">"
  && always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always !0
  == always {!<=-1,!>=2}
  "+" always "+"
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  2 always 2
  "%name% (|;" always "%name% (|;"
  || always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "%op%" always "%op%"
Line 2956
  ( always {!<=-1,!>=2}
  "- %num%" always "- %num%"
Line 2958
  "-" always "-"
Line 2965
  ( always {!<=-1,!>=2}
Line 2970
  ( always {!<=-1,!>=2}
  "extern \"C\"" always "extern \"C\""
Line 2972
  2 always 2
  == always {!<=-1,!>=2}
  "{" always "{"
Line 2973
  tok2 always symbolic=(tok->next())
Line 2974
  && always {!<=-1,!>=2}
  tok2 always !0
  != always {!<=-1,!>=2}
  2 always 2
Line 2975
  tok2 always !0
  true always 1
Line 2976
  2 always 2
Line 2977
  2 always 2
Line 2979
  tok2 possible symbolic=(tok->next())
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  tok2 always !0
  ";" always ";"
Line 2980
  tok2 always !0
  true always 1
Line 2991
  ( always {!<=-1,!>=2}
  "[;{}:] ( {" always "[;{}:] ( {"
  && always {!<=-1,!>=2}
Line 2992
  ( always {!<=-1,!>=2}
  2 always 2
  "} ) ;" always "} ) ;"
Line 2993
  == always {!<=-1,!>=2}
  ":" always ":"
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  -2 always -2
  "[;{}] %type% :" always "[;{}] %type% :"
Line 2995
  2 always 2
  -3 always -3
Line 2996
  ( always {!<=-1,!>=2}
  "[;{}] %num%|%str% ;" always "[;{}] %num%|%str% ;"
Line 2997
  2 always 2
Line 2998
  2 always 2
  3 always 3
Line 2999
  2 always 2
Line 3001
  ( always {!<=-1,!>=2}
  "( { %bool%|%char%|%num%|%str%|%name% ; } )" always "( { %bool%|%char%|%num%|%str%|%name% ; } )"
Line 3004
  3 always 3
Line 3012
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "__CPPCHECK_EMBEDDED_SQL_EXEC__ SQL" always "__CPPCHECK_EMBEDDED_SQL_EXEC__ SQL"
Line 3016
  == always {!<=-1,!>=2}
  nullptr always 0
Line 3017
  nullptr always 0
Line 3019
  end always !0
Line 3024
  "asm" always "asm"
Line 3026
  ! always {!<=-1,!>=2}
Line 3027
  ";" always ";"
Line 3028
  ")" always ")"
Line 3029
  "\"" always "\""
  "\"" always "\""
Line 3030
  "(" always "("
Line 3032
  3 always 3
Line 3040
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "%num% [ %name% ]" always "%num% [ %name% ]"
Line 3042
  2 always 2
Line 3053
  ( always {!<=-1,!>=2}
  "%name% ( void )" always "%name% ( void )"
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "sizeof|decltype|typeof|return" always "sizeof|decltype|typeof|return"
Line 3055
  true always 1
Line 3064
  ( always {!<=-1,!>=2}
  "= {" always "= {"
Line 3065
  1 always 1
Line 3066
  ( always {!<=-1,!>=2}
  "{ {" always "{ {"
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "} }" always "} }"
Line 3078
  = possible 0
  ( possible 0
Line 3080
  ( possible size=1
  == always {!<=-1,!>=2}
  "+" always "+"
Line 3081
  ( always !0
  0 always 0
  == always {!<=-1,!>=2}
  '-' always 45
Line 3082
  = always !0
  ( always !0
Line 3083
  tok always !0
  ( always !<=-1
  == always {!<=-1,!>=2}
  1 always 1
Line 3084
  tok always !0
Line 3085
  "-" always "-"
Line 3087
  tok always !0
  ( always {!<=-1,!>=2}
Line 3088
  tok always !0
  tok always !0
  1 always 1
Line 3089
  tok always !0
Line 3090
  "-" always "-"
Line 3094
  == always {!<=-1,!>=2}
  "-" always "-"
Line 3095
  ( always !0
  0 always 0
  == always {!<=-1,!>=2}
  '-' always 45
Line 3096
  = always !0
  ( always !0
Line 3097
  tok always !0
  ( always !<=-1
  == always {!<=-1,!>=2}
  1 always 1
Line 3098
  tok always !0
Line 3099
  "+" always "+"
Line 3101
  tok always !0
  ( always {!<=-1,!>=2}
Line 3102
  tok always !0
  tok always !0
  1 always 1
Line 3103
  tok always !0
Line 3104
  "+" always "+"
Line 3119
  tok possible symbolic=(end->next()?end->next():end)
Line 3120
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "%var% [ ] =" always "%var% [ ] ="
Line 3122
  addlength {!<=-1,!>=2,0}
  addlength always {!<=-1,!>=2}
  = always 0
  false always 0
Line 3123
  ( always {!<=-1,!>=2}
  "%var% [ ] = { %str% } ;" always "%var% [ ] = { %str% } ;"
Line 3124
  3 always 3
Line 3127
  addlength always {!<=-1,!>=2}
  = always 1
  true always 1
Line 3130
  addlength {!<=-1,!>=2,0,1}
  || always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "%var% [ ] = %str% ;" always "%var% [ ] = %str% ;"
Line 3132
  3 always 3
Line 3134
  5 always 5
Line 3137
  ( always {!<=-1,!>=2}
  "%var% [ ] = {" always "%var% [ ] = {"
Line 3138
  sz always !<=-1
  sz always !<=-1
  = always 1
  1 always 1
Line 3140
  3 always 3
Line 3141
  4 always 4
  && always {!<=-1,!>=2}
  tok2 always !0
  != always {!<=-1,!>=2}
Line 3142
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "{|(|[|<" always "{|(|[|<"
Line 3143
  == always {!<=-1,!>=2}
  "[" always "["
  && always {!<=-1,!>=2}
  ( always !0
  1 always 1
  == always {!<=-1,!>=2}
  "=" always "="
Line 3144
  ( always {!<=-1,!>=2}
  "[ %num% ]" always "[ %num% ]"
Line 3145
  sz always !<=-1
  = always !<=-1
  sz always !<=-1
  ( always !<=-1
  1 always 1
  + always !<=0
  1U always 1
Line 3147
  sz always !<=-1
  = always 0
  0 always 0
Line 3151
  = always !0
  ( always !0
Line 3152
  == always {!<=-1,!>=2}
  "," always ","
Line 3153
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "[},]" always "[},]"
Line 3154
  ++ always !<=0
  sz always !<=-1
Line 3162
  sz {!<=-1,1,0}
  != {!<=-1,!>=2,1,0}
  0 always 0
Line 3163
  sz {1,!<=0}
Line 3165
  ( always !0
  : always 1
Line 3172
  = always 1
  1 always 1
Line 3173
  nullptr always 0
  != always {!<=-1,!>=2}
Line 3174
  tok always !0
  ( possible size=1
  == always {!<=-1,!>=2}
  "?" always "?"
Line 3176
  tok always !0
  == always {!<=-1,!>=2}
  ":" always ":"
Line 3177
  -- possible 0
  colonLevel possible 1
Line 3178
  == always {!<=-1,!>=2}
  0 always 0
Line 3179
  tok always !0
Line 3183
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "[(<]" always "[(<]"
Line 3184
  = always !0
  ( always !0
Line 3185
  ( always {!<=-1,!>=2}
  "[{};)]" always "[{};)]"
Line 3188
  > always {!<=-1,!>=2}
  0 always 0
Line 3189
  nullptr always 0
Line 3198
  == always {!<=-1,!>=2}
  "case" always "case"
Line 3199
  nullptr always 0
  != always {!<=-1,!>=2}
Line 3200
  ( always {!<=-1,!>=2}
  tok always !0
  "(|[" always "(|["
Line 3201
  tok always !0
Line 3202
  tok always !0
  == always {!<=-1,!>=2}
  "?" always "?"
Line 3203
  tok always !0
Line 3204
  ! always {!<=-1,!>=2}
Line 3205
  tok always !0
Line 3206
  = always !0
  tok1 always !0
Line 3208
  ( always {!<=-1,!>=2}
  tok possible symbolic=(tok1)
  "[:{};]" always "[:{};]"
Line 3211
  nullptr always 0
Line 3216
  != always {!<=-1,!>=2}
  ")" always ")"
Line 3217
  nullptr always 0
Line 3219
  ":{" always ":{"
  true always 1
Line 3221
  ( always {!<=-1,!>=2}
  ": %name% [({]" always ": %name% [({]"
Line 3222
  ( always {!<=-1,!>=2}
  "[:,] %name% [({]" always "[:,] %name% [({]"
Line 3223
  2 always 2
Line 3226
  && always {!<=-1,!>=2}
  tok always !0
  == always {!<=-1,!>=2}
  "{" always "{"
  tok always !0
  nullptr always 0
Line 3234
  cpp always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 3235
  executablescope always {!<=-1,!>=2}
  executablescope always {!<=-1,!>=2}
  = always 0
  false always 0
Line 3236
  = always 0
  0 always 0
Line 3241
  = always !0
  start always !0
Line 3242
  executablescope always {!<=-1,!>=2}
  = always 1
  true always 1
Line 3245
  ! {!<=-1,!>=2,0}
  executablescope {!<=-1,!>=2,1}
Line 3248
  tok possible symbolic=(start)
  ( possible size=1
  == always {!<=-1,!>=2}
  "{" always "{"
Line 3249
  == always {!<=-1,!>=2}
  "=" always "="
Line 3253
  == always {!<=-1,!>=2}
  "}" always "}"
Line 3254
  -- possible 0
  indentLevel possible 1
Line 3255
  == always {!<=-1,!>=2}
  0 always 0
Line 3256
  executablescope always {!<=-1,!>=2}
  = always 0
  false always 0
Line 3259
  ( always {!<=-1,!>=2}
  "(|[" always "(|["
Line 3262
  ( always {!<=-1,!>=2}
  "[;{}:] case" always "[;{}:] case"
Line 3264
  ! always {!<=-1,!>=2}
Line 3266
  tok always !0
  != always {!<=-1,!>=2}
  ":" always ":"
  || always {!<=-1,!>=2}
  tok always !0
  -1 always -1
  == always {!<=-1,!>=2}
  "case" always "case"
  || always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  tok always !0
Line 3267
  tok always !0
Line 3268
  tok always !0
  ( always !0
  ( possible size=4
  != {!<=-1,!>=2,1}
  ";" always ";"
  && always {!<=-1,!>=2}
  tok always !0
  ( always !0
  != always {!<=-1,!>=2}
  "case" always "case"
Line 3269
  tok always !0
  ";" always ";"
Line 3271
  tok always !0
Line 3272
  ( always {!<=-1,!>=2}
  "[;{}] %name% : !!;" always "[;{}] %name% : !!;"
Line 3273
  ! always {!<=-1,!>=2}
  cpp {symbolic=(isCPP()),!<=-1,!>=2}
  || always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "class|struct|enum" always "class|struct|enum"
Line 3274
  2 always 2
Line 3275
  ";" always ";"
Line 3285
  ( always {!<=-1,!>=2}
  "case %num%|%char% ... %num%|%char% :" always "case %num%|%char% ... %num%|%char% :"
Line 3286
  1 always 1
Line 3287
  3 always 3
Line 3288
  50 always 50
Line 3289
  < always {!<=-1,!>=2}
Line 3290
  2 always 2
Line 3291
  ":" always ":"
Line 3292
  "case" always "case"
Line 3293
  end {>=symbolic=(start+1),!<=symbolic=(start)}
  1 always 1
  > always {!<=-1,!>=2}
  start {<=symbolic=(end-1),!>=symbolic=(end)}
Line 3294
  ":" always ":"
Line 3295
  i {>=symbolic=(start+1),!<=symbolic=(start)}
Line 3296
  "case" always "case"
Line 3306
  nullptr always 0
Line 3309
  = always !0
  ( always !0
  "" always ""
  nullptr always 0
Line 3310
  primaryScope {symbolic=(std::make_shared<ScopeInfo2>("",nullptr)),!0}
Line 3313
  tok possible symbolic=(list.front())
  == {!<=-1,!>=2,1}
  ( possible symbolic=(tok)
  || always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  tok always !symbolic=(list.front())
Line 3314
  tok possible symbolic=(list.front())
  != {!<=-1,!>=2,0}
  ( possible symbolic=(tok)
Line 3315
  tok always !symbolic=(list.front())
  tok always !symbolic=(list.front())
Line 3317
  ( always {!<=-1,!>=2}
  tok possible symbolic=(list.front())
  "using namespace %name% ::|<|;" always "using namespace %name% ::|<|;"
Line 3319
  2 always 2
Line 3320
  && always {!<=-1,!>=2}
  namespaceNameToken always !0
  != always {!<=-1,!>=2}
  ";" always ";"
Line 3323
  " " always " "
Line 3325
  usingNamespaceName possible size=0
  ( {!<=-1,0}
  > {!<=-1,!>=2,0}
  0 always 0
Line 3326
  usingNamespaceName {>=size=1,!<=size=0}
  0 always 0
  usingNamespaceName {>=size=1,!<=size=0}
  ( {>=1,!<=0}
  - {!<=-1,>=0}
  1 always 1
Line 3327
  usingNamespaceName possible size=0
Line 3328
  ( always {!<=-1,!>=2}
  "namespace|class|struct|union %name% {|::|:|<" always "namespace|class|struct|union %name% {|::|:|<"
Line 3329
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  nameTok always !0
  "{|:" always "{|:"
Line 3330
  ( always {!<=-1,!>=2}
  ";|<" always ";|<"
Line 3331
  = always ""
  "" always ""
Line 3335
  " " always " "
Line 3337
  nextScopeNameAddition possible {"",size=0}
  ( {!<=-1,0}
  > {!<=-1,!>=2,0}
  0 always 0
Line 3338
  nextScopeNameAddition {>=size=1,!<=size=0}
  0 always 0
  nextScopeNameAddition {>=size=1,!<=size=0}
  ( {>=1,!<=0}
  - {!<=-1,>=0}
  1 always 1
Line 3341
  ( always {!<=-1,!>=2}
  "{" always "{"
Line 3344
  ( always {!<=-1,!>=2}
  tok1 possible symbolic=(tok)
  ( possible 0
  "const|volatile|final|override|&|&&|noexcept" always "const|volatile|final|override|&|&&|noexcept"
Line 3346
  tok1 possible symbolic=(tok)
  && always {!<=-1,!>=2}
  -1 always -1
  == always {!<=-1,!>=2}
  ")" always ")"
Line 3347
  member always {!<=-1,!>=2}
  member always {!<=-1,!>=2}
  = always 1
  true always 1
Line 3348
  -1 always -1
Line 3349
  ( always {!<=-1,!>=2}
  "throw|noexcept" always "throw|noexcept"
Line 3351
  ( always {!<=-1,!>=2}
  "const|volatile|final|override|&|&&|noexcept" always "const|volatile|final|override|&|&&|noexcept"
Line 3353
  -1 always -1
  != always {!<=-1,!>=2}
  ")" always ")"
Line 3354
  member always {!<=-1,!>=2}
  = always 0
  false always 0
Line 3355
  ( always {!<=-1,!>=2}
  -2 always -2
  ":|, %name%" always ":|, %name%"
Line 3356
  -2 always -2
Line 3357
  -1 always -1
  != always {!<=-1,!>=2}
  ")" always ")"
Line 3358
  member always {!<=-1,!>=2}
  = always 0
  false always 0
Line 3360
  member {!<=-1,!>=2,0}
Line 3361
  -1 always -1
  == always {!<=-1,!>=2}
  ">" always ">"
Line 3363
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  tok1 always !0
  -3 always -3
  "%name% :: %name%" always "%name% :: %name%"
Line 3364
  tok1 always !0
  -2 always -2
Line 3365
  -1 always -1
Line 3366
  ( always {!<=-1,!>=2}
  -2 always -2
  ":: %name%" always ":: %name%"
Line 3367
  -3 always -3
  " :: " always " :: "
Line 3368
  -2 always -2
Line 3371
  ! {!<=-1,!>=2,0}
  nextScopeNameAddition possible size=0
  ( {!<=-1,!>=2,1}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 3372
  nextScopeNameAddition always !size=0
  " :: " always " :: "
Line 3373
  scope possible size=0
Line 3379
  = always !0
  ( always !0
Line 3381
  ! {!<=-1,!>=2,0}
  newScopeInfo {symbolic=(std::make_shared<ScopeInfo2>(tok->scopeInfo()->name,tok->link(),tok->scopeInfo()->usingNamespaces)),!0}
  . possible size=0
  ( {!<=-1,!>=2,1}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 3382
  newScopeInfo {symbolic=(std::make_shared<ScopeInfo2>(tok->scopeInfo()->name,tok->link(),tok->scopeInfo()->usingNamespaces)),!0}
  . always !size=0
  " :: " always " :: "
Line 3383
  newScopeInfo {symbolic=(std::make_shared<ScopeInfo2>(tok->scopeInfo()->name,tok->link(),tok->scopeInfo()->usingNamespaces)),!0}
  nextScopeNameAddition possible size=0
Line 3384
  = always ""
  "" always ""
Line 3387
  ( always !0
Line 3388
  newScopeInfo always !0
Line 3396
  ( always {!<=-1,!>=2}
Line 3403
  0 always 0
Line 3405
  mCodeWithTemplates always {!<=-1,!>=2}
Line 3410
  ( always {!<=-1,!>=2}
  , always {!<=-1,!>=2}
  executableScope always {!<=-1,!>=2}
  , always {!<=-1,!>=2}
  cpp always {!<=-1,!>=2}
  , always {!<=-1,!>=2}
  c always {!<=-1,!>=2}
Line 3412
  tok possible lifetime[Address]=(tok2)@202
Line 3413
  ! always {!<=-1,!>=2}
  tok2 always symbolic=(*tok)
  ( always {!<=-1,!>=2}
Line 3414
  return always {!<=-1,!>=2}
  false always 0
Line 3416
  = always 0
  0 always 0
Line 3417
  = always 0
  0 always 0
Line 3418
  hasstruct always {!<=-1,!>=2}
  hasstruct always {!<=-1,!>=2}
  = always 0
  false always 0
Line 3419
  bracket always {!<=-1,!>=2}
  bracket always {!<=-1,!>=2}
  = always 0
  false always 0
Line 3420
  ref always {!<=-1,!>=2}
  ref always {!<=-1,!>=2}
  = always 0
  false always 0
Line 3421
  tok2 possible symbolic=(*tok)
Line 3422
  tok2 always !0
  ( always {!<=-1,!>=2}
Line 3423
  cpp {!<=-1,!>=2,0}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  tok2 always !0
  "namespace|public|private|protected" always "namespace|public|private|protected"
Line 3424
  return always {!<=-1,!>=2}
  false always 0
Line 3425
  cpp {!<=-1,!>=2,0}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  tok2 always !0
  "decltype (" always "decltype ("
Line 3426
  = always 1
  1 always 1
Line 3427
  tok2 always !0
  1 always 1
Line 3430
  ( always {!<=-1,!>=2}
  "struct|union|enum" always "struct|union|enum"
  || always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  c always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "class|typename" always "class|typename"
Line 3431
  hasstruct always {!<=-1,!>=2}
  = always 1
  true always 1
Line 3432
  = always 0
  0 always 0
Line 3433
  = always 0
  0 always 0
Line 3434
  ( always {!<=-1,!>=2}
  "const|extern" always "const|extern"
Line 3436
  ! always {!<=-1,!>=2}
  hasstruct always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( possible lifetime[Iterator]=(variableId)
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(variableId),end=0}
  && always {!<=-1,!>=2}
  != always {!<=-1,!>=2}
  "::" always "::"
Line 3439
  ! always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  tok2 always !0
  != always {!<=-1,!>=2}
  "::" always "::"
Line 3442
  != always {!<=-1,!>=2}
  "void" always "void"
  || always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "void const| *|(" always "void const| *|("
Line 3446
  ! always {!<=-1,!>=2}
  c always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always !<=-1
  tok2 always !0
  > always {!<=-1,!>=2}
  0 always 0
  || always {!<=-1,!>=2}
Line 3447
  ( always {!<=-1,!>=2}
  tok2 always !0
  "< >" always "< >"
Line 3449
  ( always {!<=-1,!>=2}
  start always symbolic=(*tok)
  "%or%|%oror%|&&|&|^|+|-|*|/" always "%or%|%oror%|&&|&|^|+|-|*|/"
Line 3450
  return always {!<=-1,!>=2}
  false always 0
Line 3451
  tok2 always !0
Line 3452
  closingBracket always symbolic=(tok2->findClosingBracket())
  == always {!<=-1,!>=2}
  nullptr always 0
Line 3453
  tok2 always !0
Line 3455
  = {symbolic=(tok2->findClosingBracket()),!0}
  closingBracket {symbolic=(tok2->findClosingBracket()),!0}
Line 3456
  tok2 {symbolic=(closingBracket),!0,symbolic=(tok2->findClosingBracket())}
  != always {!<=-1,!>=2}
  ">" always ">"
Line 3458
  = always 1
  1 always 1
Line 3459
  ( always {!<=-1,!>=2}
  tok2 {symbolic=(closingBracket),!0}
  "> %name% %or%|%oror%|&&|&|^|+|-|*|/" always "> %name% %or%|%oror%|&&|&|^|+|-|*|/"
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  tok2 {symbolic=(closingBracket),!0}
  "> const [*&]" always "> const [*&]"
Line 3460
  return always {!<=-1,!>=2}
  false always 0
Line 3461
  ( always {!<=-1,!>=2}
  "> %name% )" always "> %name% )"
Line 3462
  ( always {!<=-1,!>=2}
  2 always 2
  "if|for|while (" always "if|for|while ("
Line 3463
  return always {!<=-1,!>=2}
  false always 0
Line 3464
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  2 always 2
  "%name%|] (" always "%name%|] ("
Line 3465
  return always {!<=-1,!>=2}
  false always 0
Line 3467
  ( always {!<=-1,!>=2}
  tok2 always !0
  "&|&&" always "&|&&"
Line 3468
  ref always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  bracket always {!<=-1,!>=2}
Line 3469
  singleNameCount possible {>=1,<=0}
  >= {!<=-1,!>=2,>=1,<=0}
  1 always 1
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  tok2 always !0
  "( [*&]" always "( [*&]"
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  tok2 always !0
  "(|[" always "(|["
Line 3470
  bracket always {!<=-1,!>=2}
  = always 1
  true always 1
Line 3471
  singleNameCount possible {>=1,<=0}
  >= {!<=-1,!>=2,>=1,<=0}
  1 always 1
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  tok2 always !0
  "( * %name% [" always "( * %name% ["
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  tok2 always !0
  3 always 3
  "] ) [;,]" always "] ) [;,]"
Line 3472
  bracket always {!<=-1,!>=2}
  = always 1
  true always 1
Line 3473
  singleNameCount possible <=0
  >= {!<=-1,!>=2,<=0}
  1 always 1
  && always {!<=-1,!>=2}
  tok2 always !0
  && always {!<=-1,!>=2}
  tok2 always !0
  ( always !0
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  tok2 always !0
  "( *|&| %name% ) ;" always "( *|&| %name% ) ;"
Line 3474
  bracket always {!<=-1,!>=2}
  = always 1
  true always 1
Line 3475
  tok2 always !0
  ( possible {size=1,size=2,size=3}
  == {!<=-1,!>=2,0}
  "::" always "::"
Line 3476
  = always 0
  0 always 0
Line 3477
  tok2 always !0
  ( possible {size=2,size=3}
  != {!<=-1,!>=2,1}
  "*" always "*"
  && always {!<=-1,!>=2}
  tok2 always !0
  != always {!<=-1,!>=2}
  "::" always "::"
  && always {!<=-1,!>=2}
  tok2 always !0
  != always {!<=-1,!>=2}
  "..." always "..."
Line 3483
  tok2 possible 0
Line 3484
  isLambdaArg always {!<=-1,!>=2}
  isLambdaArg always {!<=-1,!>=2}
  = always 0
  false always 0
Line 3487
  tok3 always symbolic=((*tok)->previous())
  && always {!<=-1,!>=2}
  tok3 {symbolic=((*tok)->previous()),!0}
  == always {!<=-1,!>=2}
  "," always ","
Line 3488
  tok3 possible {symbolic=((*tok)->previous()),0}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  tok3 {symbolic=((*tok)->previous()),!0}
  ";|(|[|{" always ";|(|[|{"
Line 3489
  ( always {!<=-1,!>=2}
  tok3 always !0
  ")|]" always ")|]"
Line 3490
  tok3 always !0
Line 3494
  && always {!<=-1,!>=2}
  executableScope always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  tok3 always !0
  "%name% (" always "%name% ("
Line 3495
  tok3 always !0
Line 3496
  = always 0
  0 always 0
Line 3497
  ( always {!<=-1,!>=2}
  fdecl possible symbolic=(tok3->previous())
  "%name%|*" always "%name%|*"
Line 3501
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fdecl possible symbolic=(tok3->previous())
  "[;{}] %name%" always "[;{}] %name%"
  || always {!<=-1,!>=2}
  <= always {!<=-1,!>=2}
  1 always 1
Line 3502
  return always {!<=-1,!>=2}
  false always 0
Line 3506
  cpp always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  tok3 always !0
  "] (" always "] ("
  && always {!<=-1,!>=2}
Line 3507
  ( always {!<=-1,!>=2}
  tok3 always !0
  ") {" always ") {"
  || always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  tok3 always !0
  ") . %name%" always ") . %name%"
Line 3508
  isLambdaArg always {!<=-1,!>=2}
  = always 1
  true always 1
Line 3512
  = always !0
  tok2 always !0
Line 3516
  executableScope always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ref always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  isLambdaArg always {!<=-1,!>=2}
Line 3517
  ( always {!<=-1,!>=2}
  tok2 {symbolic=(*tok),!0}
  "(|=|{|:" always "(|=|{|:"
Line 3519
  tok2 always !0
  != always {!<=-1,!>=2}
  ")" always ")"
  || always {!<=-1,!>=2}
  tok2 always !0
  -1 always -1
  != always {!<=-1,!>=2}
  "catch" always "catch"
Line 3520
  return always {!<=-1,!>=2}
  false always 0
Line 3526
  >= always {!<=-1,!>=2}
  2 always 2
  && always {!<=-1,!>=2}
  executableScope always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  tok2 always !0
  == always {!<=-1,!>=2}
  "[" always "["
Line 3527
  tok2 always !0
Line 3528
  tok3 possible symbolic=(tok2->link()->next())
  && always {!<=-1,!>=2}
  tok3 {symbolic=(tok2->link()->next()),!0}
  == always {!<=-1,!>=2}
  "[" always "["
Line 3529
  tok3 always !0
Line 3531
  ( always {!<=-1,!>=2}
  tok3 possible {symbolic=(tok2->link()->next()),0}
  "= %num%" always "= %num%"
Line 3532
  return always {!<=-1,!>=2}
  false always 0
Line 3535
  return always {!<=-1,!>=2}
  typeCount possible {>=2,<=1}
  >= {!<=-1,!>=2,>=1,<=0}
  2 always 2
  && always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  tok2 always !0
  -2 always -2
  "!!:: %type%" always "!!:: %type%"
Line 3543
  tok1 possible {lifetime[Address]=(tok)@42,lifetime[Address]=(tok2)@69,lifetime[Address]=(tok)@106}
Line 3545
  ( always {!<=-1,!>=2}
  tok always symbolic=(*tok1)
  "%name% = { . %name% =|{" always "%name% = { . %name% =|{"
Line 3547
  struct_varid {symbolic=(tok->varId()),0}
  == {!<=-1,!>=2,1}
  0 always 0
Line 3550
  struct_varid {symbolic=(tok->varId()),!0}
Line 3552
  3 always 3
Line 3553
  != always {!<=-1,!>=2}
  "}" always "}"
Line 3554
  ( always {!<=-1,!>=2}
  "{|[|(" always "{|[|("
Line 3556
  ( always {!<=-1,!>=2}
  "[,{] . %name% =|{" always "[,{] . %name% =|{"
Line 3558
  :: possible {symbolic=(members.end()),end=0}
  it possible {symbolic=(members.end()),end=0}
  = possible {lifetime[Iterator]=(structMembers[struct_varid]),lifetime[Object]=(structMembers)}
  ( possible {lifetime[Iterator]=(structMembers[struct_varid]),lifetime[Object]=(structMembers)}
Line 3559
  == always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(structMembers[struct_varid]),lifetime[Object]=(structMembers),end=0}
Line 3563
  it always !end=0
Line 3572
  ( always {!<=-1,!>=2}
  ")| . %name% !!(" always ")| . %name% !!("
Line 3574
  1 always 1
  == always {!<=-1,!>=2}
  ")" always ")"
  && always {!<=-1,!>=2}
  1 always 1
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  1 always 1
  -1 always -1
  == always {!<=-1,!>=2}
  "]" always "]"
  && always {!<=-1,!>=2}
Line 3575
  1 always 1
  "{|;" always "{|;"
Line 3576
  3 always 3
Line 3580
  2 always 2
Line 3581
  == always {!<=-1,!>=2}
  0 always 0
Line 3584
  == always {!<=-1,!>=2}
  "." always "."
Line 3588
  ( always !<=-1
  > always {!<=-1,!>=2}
  0 always 0
Line 3591
  struct_varid always !0
Line 3592
  :: possible {symbolic=(members.end()),end=0}
  it possible {symbolic=(members.end()),end=0}
  = possible {lifetime[Iterator]=(structMembers[struct_varid]),lifetime[Object]=(structMembers)}
  ( possible {lifetime[Iterator]=(structMembers[struct_varid]),lifetime[Object]=(structMembers)}
Line 3593
  == always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(structMembers[struct_varid]),lifetime[Object]=(structMembers),end=0}
Line 3597
  it always !end=0
Line 3616
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  != always {!<=-1,!>=2}
  ":" always ":"
Line 3618
  ( always {!<=-1,!>=2}
  "class|struct|enum %type% [:{]" always "class|struct|enum %type% [:{]"
Line 3625
  = always 0
  0 always 0
Line 3626
  initList always {!<=-1,!>=2}
  initList always {!<=-1,!>=2}
  = always 0
  false always 0
Line 3627
  inEnum always {!<=-1,!>=2}
  inEnum always {!<=-1,!>=2}
  = always 0
  false always 0
Line 3628
  = always 0
  nullptr always 0
Line 3629
  != always {!<=-1,!>=2}
Line 3630
  ! always {!<=-1,!>=2}
  tok possible symbolic=(initListArgLastToken)
Line 3631
  nullptr always 0
Line 3632
  initList {!<=-1,!>=2,0}
Line 3633
  tok always !0
  == {!<=-1,!>=2,0}
  initListArgLastToken possible 0
Line 3634
  = always 0
  nullptr always 0
Line 3635
  ! always {!<=-1,!>=2}
  initListArgLastToken always !symbolic=(tok)
  && always {!<=-1,!>=2}
Line 3636
  ( always {!<=-1,!>=2}
  tok always {!symbolic=(initListArgLastToken),!0}
  "%name%|>|>> {|(" always "%name%|>|>> {|("
  && always {!<=-1,!>=2}
Line 3637
  ( always {!<=-1,!>=2}
  tok always {!symbolic=(initListArgLastToken),!0}
  "}|) ,|{" always "}|) ,|{"
Line 3638
  tok always {!symbolic=(initListArgLastToken),!0}
Line 3640
  tok always !0
  ( possible size=1
  == always {!<=-1,!>=2}
  "{" always "{"
Line 3641
  inEnum always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  tok always !0
Line 3642
  initList always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
Line 3643
  initList always {!<=-1,!>=2}
  = always 0
  false always 0
Line 3645
  tok always !0
  ( possible size=1
  == always {!<=-1,!>=2}
  "}" always "}"
Line 3647
  inEnum always {!<=-1,!>=2}
  = always 0
  false always 0
Line 3648
  initList {!<=-1,!>=2,0}
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  0 always 0
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  tok always !0
  "[,:] %name% [({]" always "[,:] %name% [({]"
Line 3649
  :: possible {symbolic=(variableMap.end()),end=0}
  it possible {symbolic=(variableMap.end()),end=0}
  = possible lifetime[Object]=(variableMap)
  ( possible lifetime[Object]=(variableMap)
  tok always !0
Line 3650
  != always {!<=-1,!>=2}
  ( {lifetime[Object]=(variableMap),end=0}
Line 3651
  tok always !0
  it always !end=0
Line 3653
  tok always !0
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  tok always !0
  <= always {!<=-1,!>=2}
Line 3654
  > always {!<=-1,!>=2}
  0 always 0
  || always {!<=-1,!>=2}
  initList always {!<=-1,!>=2}
Line 3655
  ( always {!<=-1,!>=2}
  tok always !0
  "::|." always "::|."
  && always {!<=-1,!>=2}
  tok always !0
  -2 always -2
  != always {!<=-1,!>=2}
  "this" always "this"
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  tok always !0
  -5 always -5
  "( * this ) ." always "( * this ) ."
Line 3657
  ! always {!<=-1,!>=2}
  tok always !0
Line 3658
  nullptr always 0
Line 3659
  ( always !0
  == always {!<=-1,!>=2}
  "::" always "::"
Line 3660
  == always {!<=-1,!>=2}
Line 3661
  2 always 2
Line 3666
  ! always {!<=-1,!>=2}
  inEnum always {!<=-1,!>=2}
Line 3667
  :: possible {symbolic=(variableMap.end()),end=0}
  it possible {symbolic=(variableMap.end()),end=0}
  = possible lifetime[Object]=(variableMap)
  ( possible lifetime[Object]=(variableMap)
Line 3668
  != always {!<=-1,!>=2}
  ( {lifetime[Object]=(variableMap),end=0}
Line 3669
  it always !end=0
Line 3670
  & {lifetime[Address]=(tok),!0}
  ( {lifetime[Object]=(variableMap),!0}
Line 3674
  == always {!<=-1,!>=2}
  0 always 0
  && always {!<=-1,!>=2}
  tok always !0
  == always {!<=-1,!>=2}
  ":" always ":"
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
Line 3675
  initList always {!<=-1,!>=2}
  = always 1
  true always 1
Line 3690
  && always {!<=-1,!>=2}
  tok2 always !0
  != always {!<=-1,!>=2}
Line 3691
  != always {!<=-1,!>=2}
  0 always 0
  || always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 3693
  ( always {!<=-1,!>=2}
  -2 always -2
  "!!" always "!!"
  " ::" always " ::"
  ( {lifetime[Object]=("!!"+classname+" ::"),!0}
Line 3695
  ( always {!<=-1,!>=2}
  -4 always -4
  "%name% :: %name% ::" always "%name% :: %name% ::"
Line 3697
  ( always {!<=-1,!>=2}
  -2 always -2
  "!!this ." always "!!this ."
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  -5 always -5
  "( * this ) ." always "( * this ) ."
Line 3699
  ( always {!<=-1,!>=2}
  "%name% ::" always "%name% ::"
Line 3702
  :: possible {symbolic=(varlist.end()),end=0}
  it possible {symbolic=(varlist.end()),end=0}
  = possible lifetime[Iterator]=(varlist)
  ( possible lifetime[Iterator]=(varlist)
Line 3703
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(varlist),end=0}
Line 3704
  it always !end=0
Line 3705
  & {lifetime[Address]=(tok2),!0}
Line 3716
  ( always {!<=-1,!>=2}
Line 3717
  0 always 0
Line 3730
  "NOT" always "NOT"
  "case" always "case"
  "default" always "default"
  "goto" always "goto"
  "not" always "not"
  "return" always "return"
  "sizeof" always "sizeof"
  "typedef" always "typedef"
Line 3731
  "NOT" always "NOT"
  "case" always "case"
  "default" always "default"
  "goto" always "goto"
  "not" always "not"
  "return" always "return"
  "sizeof" always "sizeof"
  "typedef" always "typedef"
Line 3732
  "delete" always "delete"
  "friend" always "friend"
  "new" always "new"
  "throw" always "throw"
  "using" always "using"
  "virtual" always "virtual"
  "explicit" always "explicit"
  "const_cast" always "const_cast"
  "dynamic_cast" always "dynamic_cast"
  "reinterpret_cast" always "reinterpret_cast"
  "static_cast" always "static_cast"
  "template" always "template"
Line 3738
  ( always {!<=-1,!>=2}
Line 3745
  scopeStack always size=0
Line 3747
  = always 0
  nullptr always 0
Line 3748
  initlist always {!<=-1,!>=2}
  initlist always {!<=-1,!>=2}
  = always 0
  false always 0
Line 3749
  inlineFunction always {!<=-1,!>=2}
  inlineFunction always {!<=-1,!>=2}
  = always 0
  false always 0
Line 3751
  tok possible symbolic=(functionDeclEndToken)
  ( always {!<=-1,!>=2}
Line 3753
  == always {!<=-1,!>=2}
Line 3755
  ( always {!<=-1,!>=2}
  nullptr always 0
  : always 0
  functionDeclEndStack always !size=0
Line 3756
  ( possible size=1
  == always {!<=-1,!>=2}
  ":" always ":"
Line 3757
  initlist always {!<=-1,!>=2}
  = always 1
  true always 1
Line 3758
  ( possible size=1
  == always {!<=-1,!>=2}
  ";" always ";"
Line 3759
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 3761
  == always {!<=-1,!>=2}
  "{" always "{"
Line 3762
  true always 1
  . always {!<=-1,!>=2}
  isStructInit always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  -1 always -1
  == always {!<=-1,!>=2}
  "=" always "="
  false always 0
  ( {lifetime[Object]=(variableMap),!0}
Line 3766
  ifToken {symbolic=(tok->previous()),0}
  && always {!<=-1,!>=2}
  ifToken {symbolic=(tok->previous()),!0}
  == always {!<=-1,!>=2}
  ")" always ")"
Line 3767
  ifToken {symbolic=(tok->previous()),!0}
Line 3769
  = always 0
  nullptr always 0
Line 3770
  ifToken possible 0
Line 3771
  ifToken always !0
Line 3772
  ifToken possible 0
  && always {!<=-1,!>=2}
  ifToken always !0
  == always {!<=-1,!>=2}
  "if" always "if"
Line 3777
  ! {!<=-1,!>=2,1}
  initlist {!<=-1,!>=2,0}
  && always {!<=-1,!>=2}
  tok always !symbolic=(functionDeclEndToken)
  == always {!<=-1,!>=2}
  "(" always "("
Line 3778
  = always 0
  nullptr always 0
Line 3779
  ! always {!<=-1,!>=2}
  . always {!<=-1,!>=2}
  isExecutable always {!<=-1,!>=2}
Line 3780
  tok always !symbolic=(functionDeclEndToken)
  "{:;" always "{:;"
Line 3782
  tok always !symbolic=(functionDeclEndToken)
Line 3783
  tokenLinkNext always symbolic=(tok->link()->next())
  && always {!<=-1,!>=2}
  tokenLinkNext {symbolic=(tok->link()->next()),!0}
  == always {!<=-1,!>=2}
  "{" always "{"
Line 3784
  = {symbolic=(tok->link()->next()),!0}
  tokenLinkNext {symbolic=(tok->link()->next()),!0}
Line 3786
  newFunctionDeclEnd possible {symbolic=(tokenLinkNext),symbolic=(functionDeclEndToken),symbolic=(tok->link()->next())}
  && always {!<=-1,!>=2}
  newFunctionDeclEnd always !0
  != always {!<=-1,!>=2}
  functionDeclEndToken always !symbolic=(tok)
Line 3787
  newFunctionDeclEnd always {!symbolic=(functionDeclEndToken),!0}
Line 3791
  ( always {!<=-1,!>=2}
  tok always !symbolic=(functionDeclEndToken)
  "{|}" always "{|}"
Line 3792
  inlineFunction always {!<=-1,!>=2}
  = always 0
  false always 0
Line 3794
  tok always !symbolic=(functionDeclEndToken)
  ( possible size=1
  == always {!<=-1,!>=2}
  "{" always "{"
  tok always !symbolic=(functionDeclEndToken)
  : always !symbolic=(functionDeclEndToken)
  tok always !symbolic=(functionDeclEndToken)
Line 3797
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  startToken always symbolic=((tok->str()=="{")?tok:tok->link())
  "union|struct|enum {" always "union|struct|enum {"
  && always {!<=-1,!>=2}
Line 3798
  ! always {!<=-1,!>=2}
  initlist always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  startToken always symbolic=((tok->str()=="{")?tok:tok->link())
  "%name%|>|>>" always "%name%|>|>>"
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  startToken always symbolic=((tok->str()=="{")?tok:tok->link())
  "} ,|{" always "} ,|{"
Line 3800
  tok always !symbolic=(functionDeclEndToken)
  == always {!<=-1,!>=2}
  "{" always "{"
Line 3801
  isExecutable always {!<=-1,!>=2}
Line 3802
  tok always !symbolic=(functionDeclEndToken)
Line 3803
  ( always {!<=-1,!>=2}
  prev possible symbolic=(tok->previous())
  "%name%|." always "%name%|."
Line 3805
  isLambda always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  prev possible symbolic=(tok->previous())
  && always {!<=-1,!>=2}
  prev always !0
  == always {!<=-1,!>=2}
  ")" always ")"
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  prev always !0
  "] (" always "] ("
Line 3806
  ! always {!<=-1,!>=2}
  isLambda always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  tok always !symbolic=(functionDeclEndToken)
  -1 always -1
  == always {!<=-1,!>=2}
  ")" always ")"
  || always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  tok always !symbolic=(functionDeclEndToken)
  -2 always -2
  ") %type%" always ") %type%"
  || always {!<=-1,!>=2}
Line 3807
  initlist always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  tok always !symbolic=(functionDeclEndToken)
  -1 always -1
  == always {!<=-1,!>=2}
  "}" always "}"
Line 3808
  isExecutable always {!<=-1,!>=2}
  = always 1
  true always 1
Line 3810
  isExecutable always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  . always {!<=-1,!>=2}
  isExecutable always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  initlist always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  tok always !symbolic=(functionDeclEndToken)
  -1 always -1
  == always {!<=-1,!>=2}
  "else" always "else"
  && always {!<=-1,!>=2}
Line 3811
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  tok always !symbolic=(functionDeclEndToken)
Line 3812
  ! always {!<=-1,!>=2}
  . always {!<=-1,!>=2}
  isStructInit always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  tok always !symbolic=(functionDeclEndToken)
  -1 always -1
  == always {!<=-1,!>=2}
  "=" always "="
Line 3815
  initlist always {!<=-1,!>=2}
  = always 0
  false always 0
Line 3816
  isExecutable {!<=-1,!>=2,1}
  . always {!<=-1,!>=2}
  isStructInit always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  tok always !symbolic=(functionDeclEndToken)
  -1 always -1
  == always {!<=-1,!>=2}
  "=" always "="
  ( always {!<=-1,!>=2}
  tok always !symbolic=(functionDeclEndToken)
  ( {lifetime[Object]=(variableMap),!0}
Line 3818
  isNamespace always {!<=-1,!>=2}
  isNamespace always {!<=-1,!>=2}
  = always 0
  false always 0
Line 3819
  tok always !symbolic=(functionDeclEndToken)
  && always {!<=-1,!>=2}
  tok1 always !0
  ( always {!<=-1,!>=2}
Line 3820
  == always {!<=-1,!>=2}
  "namespace" always "namespace"
Line 3821
  isNamespace always {!<=-1,!>=2}
  = always 1
  true always 1
Line 3826
  ! always {!<=-1,!>=2}
  initlist always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  . always {!<=-1,!>=2}
  isExecutable always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  tok always !symbolic=(functionDeclEndToken)
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  isNamespace always {!<=-1,!>=2}
Line 3827
  tok always !symbolic=(functionDeclEndToken)
  ( always !0
Line 3833
  ! always {!<=-1,!>=2}
  scopeStack possible size=1
  . always {!<=-1,!>=2}
  isStructInit always {!<=-1,!>=2}
Line 3834
  ( always {!<=-1,!>=2}
Line 3837
  startToken always symbolic=((tok->str()=="{")?tok:tok->link())
Line 3838
  ifToken {symbolic=(startToken->previous()),0}
  && always {!<=-1,!>=2}
  ifToken {symbolic=(startToken->previous()),!0}
  == always {!<=-1,!>=2}
  ")" always ")"
Line 3839
  ifToken {symbolic=(startToken->previous()),!0}
Line 3841
  = always 0
  nullptr always 0
Line 3842
  startToken always symbolic=((tok->str()=="{")?tok:tok->link())
  -1 always -1
  == always {!<=-1,!>=2}
  "else" always "else"
  || always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ifToken always !0
  == always {!<=-1,!>=2}
  "if" always "if"
  && always {!<=-1,!>=2}
  tok always !symbolic=(functionDeclEndToken)
  1 always 1
  != always {!<=-1,!>=2}
  "else" always "else"
Line 3844
  ( always {!<=-1,!>=2}
Line 3848
  scopeStack possible size=1
Line 3849
  ( always {!<=-1,!>=2}
Line 3850
  scopeStack always size=0
Line 3856
  ! always {!<=-1,!>=2}
  . always {!<=-1,!>=2}
  isStructInit always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 3857
  == always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
Line 3858
  ( always {!<=-1,!>=2}
  tok always !symbolic=(list.front())
  "[;{}]" always "[;{}]"
  || always {!<=-1,!>=2}
Line 3859
  tok always !symbolic=(list.front())
  == always {!<=-1,!>=2}
  "(" always "("
  && always {!<=-1,!>=2}
  tok always !symbolic=(list.front())
  "{" always "{"
  || always {!<=-1,!>=2}
Line 3860
  == always {!<=-1,!>=2}
  "(" always "("
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  . always {!<=-1,!>=2}
  isExecutable always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ";:" always ";:"
  || always {!<=-1,!>=2}
Line 3861
  == always {!<=-1,!>=2}
  "," always ","
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  . always {!<=-1,!>=2}
  isExecutable always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  inlineFunction always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
Line 3862
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  ':' always 58
Line 3865
  ( always {!<=-1,!>=2}
  "sizeof (" always "sizeof ("
Line 3869
  ( always {!<=-1,!>=2}
Line 3873
  ( always {!<=-1,!>=2}
Line 3876
  tok2 possible {symbolic=((tok->isName())?tok:tok->next()),0}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  tok2 {symbolic=((tok->isName())?tok:tok->next()),!0}
  ':' always 58
Line 3877
  tok2 always !0
Line 3879
  ! {!<=-1,!>=2,1}
  tok2 possible {symbolic=((tok->isName())?tok:tok->next()),0}
Line 3883
  ( possible {lifetime[Iterator]=(notstart_c),lifetime[Iterator]=(notstart_cpp)}
  tok2 always !0
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(notstart_c),lifetime[Iterator]=(notstart_cpp),end=0}
Line 3886
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  tok2 always !0
  "const new" always "const new"
Line 3889
  decl always {!<=-1,!>=2}
Line 3890
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  >= always {!<=-1,!>=2}
  :: always 3
  CPP17 always 3
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "[(;{}] const| auto &|&&| [" always "[(;{}] const| auto &|&&| ["
Line 3892
  "[" always "["
Line 3893
  ( always {!<=-1,!>=2}
  "for (" always "for ("
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  tok2 always symbolic=(Token::findsimplematch(tok,"["))
  "] :" always "] :"
  || always {!<=-1,!>=2}
Line 3894
  ( always {!<=-1,!>=2}
  tok2 always symbolic=(Token::findsimplematch(tok,"["))
  "] =" always "] ="
Line 3895
  tok2 possible symbolic=(Token::findsimplematch(tok,"["))
  && always {!<=-1,!>=2}
  tok2 {symbolic=(Token::findsimplematch(tok,"[")),!0}
  != always {!<=-1,!>=2}
  "]" always "]"
Line 3896
  ( always {!<=-1,!>=2}
  tok2 always !0
  "%name% [,]]" always "%name% [,]]"
Line 3897
  tok2 always !0
Line 3898
  tok2 always !0
Line 3905
  decl always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  & {lifetime[Address]=(tok2),!0}
  tok2 possible symbolic=(Token::findsimplematch(tok,"["))
  . always {!<=-1,!>=2}
  isExecutable always {!<=-1,!>=2}
  ( {!<=-1,!>=2,1,0}
  ( always {!<=-1,!>=2}
Line 3909
  decl {!<=-1,!>=2,0}
Line 3910
  ( {!<=-1,!>=2,0}
Line 3911
  "decltype (" always "decltype ("
Line 3912
  declTypeTok always !0
  1 always 1
  != always {!<=-1,!>=2}
  declTypeTok always !0
Line 3913
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "::|." always "::|."
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 3914
  ( possible lifetime[Object]=(variableMap)
Line 3919
  == always {!<=-1,!>=2}
  "(" always "("
  && always {!<=-1,!>=2}
  "{" always "{"
  && always {!<=-1,!>=2}
  . always {!<=-1,!>=2}
  isExecutable always {!<=-1,!>=2}
Line 3920
  inlineFunction always {!<=-1,!>=2}
  = always 1
  true always 1
Line 3923
  ( always {!<=-1,!>=2}
  prev2 always symbolic=(tok2->previous())
  "%type% [;[=,)]" always "%type% [;[=,)]"
  && always {!<=-1,!>=2}
  ( always symbolic=(prev2)
  != always {!<=-1,!>=2}
  "const" always "const"
Line 3925
  ( always {!<=-1,!>=2}
  prev2 always symbolic=(tok2->previous())
  "%type% :" always "%type% :"
  && always {!<=-1,!>=2}
  -1 always -1
  == always {!<=-1,!>=2}
  "for" always "for"
Line 3927
  ( always {!<=-1,!>=2}
  prev2 always symbolic=(tok2->previous())
  "%type% ( !!)" always "%type% ( !!)"
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  ") ;" always ") ;"
Line 3929
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 3930
  prev2 always symbolic=(tok2->previous())
  ( always {!<=-1,!>=2}
Line 3934
  ! always {!<=-1,!>=2}
  tok3 always symbolic=(tok2->next())
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  tok3 always symbolic=(tok2->next())
  != always {!<=-1,!>=2}
  "void" always "void"
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  tok3 always symbolic=(tok2->next())
  "struct|union|class %type%" always "struct|union|class %type%"
  && always {!<=-1,!>=2}
  tok3 always symbolic=(tok2->next())
  != always {!<=-1,!>=2}
  "." always "."
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "[&*]" always "[&*]"
Line 3935
  ! always {!<=-1,!>=2}
  . always {!<=-1,!>=2}
  isExecutable always {!<=-1,!>=2}
Line 3937
  decl always {!<=-1,!>=2}
  = always 0
  false always 0
Line 3938
  rhs always {!<=-1,!>=2}
  rhs always {!<=-1,!>=2}
  = always 0
  false always 0
Line 3939
  tok3 possible symbolic=(tok2->next())
Line 3940
  tok3 possible symbolic=(tok2->next())
  ( possible size=1
  == always {!<=-1,!>=2}
  "=" always "="
Line 3941
  rhs always {!<=-1,!>=2}
  = always 1
  true always 1
Line 3945
  ( possible size=1
  == always {!<=-1,!>=2}
  "," always ","
Line 3946
  rhs always {!<=-1,!>=2}
  = always 0
  false always 0
Line 3950
  rhs always {!<=-1,!>=2}
Line 3953
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
Line 3954
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
Line 3955
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
Line 3956
  == always {!<=-1,!>=2}
  "(" always "("
  || always {!<=-1,!>=2}
Line 3957
  ( possible {lifetime[Iterator]=(notstart_c),lifetime[Iterator]=(notstart_cpp)}
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(notstart_c),lifetime[Iterator]=(notstart_cpp),end=0}
Line 3958
  decl always {!<=-1,!>=2}
  = always 1
  true always 1
Line 3964
  decl always {!<=-1,!>=2}
  = always 0
  false always 0
Line 3965
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  prev2 always symbolic=(tok2->previous())
  "%type% {" always "%type% {"
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "} ;" always "} ;"
Line 3966
  != always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 3967
  ( always {!<=-1,!>=2}
  prev2 always symbolic=(tok2->previous())
  "do|try|else" always "do|try|else"
  || always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  prev2 always symbolic=(tok2->previous())
  -2 always -2
  "struct|class|:" always "struct|class|:"
Line 3970
  decl always {!<=-1,!>=2}
  = always 0
  false always 0
Line 3972
  decl {!<=-1,!>=2,0,1}
Line 3973
  prev2 always symbolic=(tok2->previous())
Line 3975
  ( always {!<=-1,!>=2}
  "for (" always "for ("
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  prev2 always symbolic=(tok2->previous())
  "%name% [=,]" always "%name% [=,]"
Line 3976
  prev2 always symbolic=(tok2->previous())
  && always {!<=-1,!>=2}
  tok3 always !0
  != always {!<=-1,!>=2}
  ";" always ";"
Line 3977
  ( always {!<=-1,!>=2}
  "[([]" always "[([]"
Line 3979
  ( always {!<=-1,!>=2}
  ", %name% [,=;]" always ", %name% [,=;]"
Line 3986
  ( always {!<=-1,!>=2}
  tok possible 0
  "%name%|::" always "%name%|::"
Line 3988
  && always {!<=-1,!>=2}
  tok always !0
  == always {!<=-1,!>=2}
  "<" always "<"
Line 3989
  tok always !0
Line 3990
  != always {!<=-1,!>=2}
  end possible symbolic=(tok->findClosingBracket())
Line 3991
  tok always !symbolic=(end)
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  tok always !symbolic=(end)
  "<" always "<"
  && always {!<=-1,!>=2}
Line 3992
  ( always {!<=-1,!>=2}
  tok always !symbolic=(end)
  -1 always -1
  ":: %name%" always ":: %name%"
Line 3993
  :: possible {symbolic=(variableMap.end()),end=0}
  it possible {symbolic=(variableMap.end()),end=0}
  = possible lifetime[Object]=(variableMap)
  ( possible lifetime[Object]=(variableMap)
  tok always !symbolic=(end)
Line 3994
  != always {!<=-1,!>=2}
  ( {lifetime[Object]=(variableMap),end=0}
Line 3995
  tok always !symbolic=(end)
  it always {!symbolic=(variableMap.end()),!end=0}
Line 3997
  tok always !symbolic=(end)
Line 4001
  = always symbolic=(prev2)
  ( always symbolic=(prev2)
Line 4006
  tok possible {symbolic=(tok2->previous()),symbolic=(prev2)}
  ( always {!<=-1,!>=2}
Line 4008
  ( always {!<=-1,!>=2}
  ( possible 0
  "struct|enum|union" always "struct|enum|union"
  || always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  -1 always -1
  == always {!<=-1,!>=2}
  "class" always "class"
Line 4011
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 4012
  && always {!<=-1,!>=2}
  ( always !0
  == always {!<=-1,!>=2}
  "::" always "::"
Line 4014
  && always {!<=-1,!>=2}
  ( always !0
  == always {!<=-1,!>=2}
  "::" always "::"
Line 4016
  ( always {!<=-1,!>=2}
  -2 always -2
  ":: template" always ":: template"
Line 4021
  . always {!<=-1,!>=2}
  isExecutable always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "%name% [,)]" always "%name% [,)]"
Line 4022
  par always {!<=-1,!>=2}
  par always {!<=-1,!>=2}
  = always 0
  false always 0
Line 4026
  ( always {!<=-1,!>=2}
  "%name%|*|&|,|(" always "%name%|*|&|,|("
Line 4027
  == always {!<=-1,!>=2}
  "(" always "("
Line 4028
  par always {!<=-1,!>=2}
Line 4030
  par always {!<=-1,!>=2}
  = always 1
  true always 1
Line 4032
  ( always {!<=-1,!>=2}
  "[(,]" always "[(,]"
Line 4033
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "[(,] %type% %name%|*|&" always "[(,] %type% %name%|*|&"
Line 4036
  > always {!<=-1,!>=2}
  0 always 0
Line 4041
  ( always {!<=-1,!>=2}
  "%name%|*|&|," always "%name%|*|&|,"
Line 4044
  isNotstartKeyword always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( possible {lifetime[Iterator]=(notstart_c),lifetime[Iterator]=(notstart_cpp)}
  ( always !0
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(notstart_c),lifetime[Iterator]=(notstart_cpp),end=0}
Line 4047
  ( always {!<=-1,!>=2}
  "[;{}] %type% %name%|*" always "[;{}] %type% %name%|*"
  && always {!<=-1,!>=2}
  par always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  ") ;" always ") ;"
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  isNotstartKeyword always {!<=-1,!>=2}
Line 4052
  ! always {!<=-1,!>=2}
  . always {!<=-1,!>=2}
  isEnum always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "{|," always "{|,"
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  ",|=|}" always ",|=|}"
Line 4053
  :: possible {symbolic=(variableMap.end()),end=0}
  it possible {symbolic=(variableMap.end()),end=0}
  = possible lifetime[Object]=(variableMap)
  ( possible lifetime[Object]=(variableMap)
Line 4054
  != always {!<=-1,!>=2}
  ( {lifetime[Object]=(variableMap),end=0}
Line 4055
  it always {!symbolic=(variableMap.end()),!end=0}
Line 4056
  & {lifetime[Address]=(tok),!0}
  ( {lifetime[Object]=(variableMap),!0}
Line 4059
  ( always {!<=-1,!>=2}
  "::|. %name%" always "::|. %name%"
Line 4062
  == always {!<=-1,!>=2}
  ":" always ":"
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  -2 always -2
  "class %type%" always "class %type%"
Line 4065
  tok possible 0
  && always {!<=-1,!>=2}
  tok always !0
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  tok always !0
  == always {!<=-1,!>=2}
  "," always ","
Line 4066
  ! always {!<=-1,!>=2}
Line 4068
  tok always !0
Line 4072
  ( {lifetime[Object]=(variableMap),!0}
Line 4088
  ret possible size=0
  ( {!<=-1,!>=2,1}
  "" always ""
  : always " :: "
  " :: " always " :: "
Line 4094
  = {lifetime[Iterator]=(scopeInfo),start=0}
  ( {lifetime[Iterator]=(scopeInfo),start=0}
Line 4097
  = {lifetime[Iterator]=(scope),start=0}
  ( {lifetime[Iterator]=(scope),start=0}
  it possible {lifetime[Iterator]=(scope),start=0}
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(scope),end=0}
Line 4098
  scopeIt possible lifetime[Iterator]=(scopeInfo)
  == always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(scopeInfo),end=0}
  || always {!<=-1,!>=2}
  scopeIt {lifetime[Iterator]=(scopeInfo),!symbolic=(scopeInfo.end()),!end=0}
  != always {!<=-1,!>=2}
  it {lifetime[Iterator]=(scope),!symbolic=(scope.end()),!end=0}
Line 4099
  nullptr always 0
Line 4100
  ++ always !symbolic=(scopeInfo.end()+1)
  scopeIt always {!symbolic=(scopeInfo.end()),!end=0}
Line 4105
  ( always {!<=-1,!>=2}
  "%name% ::" always "%name% ::"
Line 4106
  scopeIt possible lifetime[Iterator]=(scopeInfo)
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(scopeInfo),end=0}
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  scopeIt {lifetime[Iterator]=(scopeInfo),!symbolic=(scopeInfo.end()),!end=0}
Line 4107
  2 always 2
Line 4108
  scopeIt {lifetime[Iterator]=(scopeInfo),!end=0}
Line 4110
  nullptr always 0
Line 4113
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "%name% ;" always "%name% ;"
Line 4114
  nullptr always 0
Line 4115
  == always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(scopeInfo),end=0}
  || always {!<=-1,!>=2}
  != always {!<=-1,!>=2}
  scopeIt always {!symbolic=(scopeInfo.end()),!end=0}
Line 4116
  nullptr always 0
Line 4117
  ++ always !symbolic=(scopeInfo.end()+1)
  scopeIt always {!symbolic=(scopeInfo.end()),!end=0}
Line 4121
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(scopeInfo),end=0}
Line 4122
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "%name% ::|<" always "%name% ::|<"
Line 4123
  nullptr always 0
Line 4124
  != always {!<=-1,!>=2}
  scopeIt always !end=0
Line 4125
  nullptr always 0
Line 4126
  == always {!<=-1,!>=2}
  "<" always "<"
Line 4128
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "> ::" always "> ::"
Line 4129
  nullptr always 0
Line 4131
  2 always 2
Line 4135
  ( always {!<=-1,!>=2}
  "~| %name%" always "~| %name%"
  : always 0
  nullptr always 0
Line 4140
  ( always {!<=-1,!>=2}
Line 4141
  nullptr always 0
Line 4144
  nullptr always 0
  scopeInfo always !size=0
Line 4146
  ret always !0
Line 4152
  ret always !0
Line 4155
  nullptr always 0
Line 4161
  ( always {!<=-1,!>=2}
  tok always symbolic=(matchMemberName(var,scopeInfo))
  "%name% !!(" always "%name% !!("
  : always 0
  nullptr always 0
Line 4167
  ( always {!<=-1,!>=2}
  tok always symbolic=(matchMemberName(func,scopeInfo))
  "~| %name% (" always "~| %name% ("
  : always 0
  nullptr always 0
Line 4177
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 4182
  ! always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  ( always !0
  "[;{}]" always "[;{}]"
Line 4183
  ( always {!<=-1,!>=2}
  "using namespace %name% ::|;" always "using namespace %name% ::|;"
Line 4184
  2 always 2
Line 4185
  ( always {!<=-1,!>=2}
  "%name% ::" always "%name% ::"
Line 4186
  2 always 2
Line 4187
  ( always {!<=-1,!>=2}
  "%name% ;" always "%name% ;"
Line 4188
  2 always 2
Line 4191
  ( always {!<=-1,!>=2}
  "namespace %name% {" always "namespace %name% {"
Line 4192
  1 always 1
Line 4193
  2 always 2
  1 always 1
Line 4197
  == always {!<=-1,!>=2}
  "}" always "}"
Line 4198
  :: possible {symbolic=(endOfScope.end()),end=0}
  it possible {symbolic=(endOfScope.end()),end=0}
  = possible lifetime[Iterator]=(endOfScope)
  ( possible lifetime[Iterator]=(endOfScope)
Line 4199
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(endOfScope),end=0}
Line 4200
  it always {!symbolic=(endOfScope.end()),!end=0}
Line 4204
  ( always {!<=-1,!>=2}
  tok always symbolic=(tok1)
  "!!:: %name% :: ~| %name%" always "!!:: %name% :: ~| %name%"
Line 4205
  tok always symbolic=(tok1)
Line 4206
  ( always {!<=-1,!>=2}
  tok always symbolic=(tok1)
  "!!:: %name% <" always "!!:: %name% <"
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  tok always symbolic=(tok1)
  "> :: ~| %name%" always "> :: ~| %name%"
Line 4207
  tok always symbolic=(tok1)
Line 4208
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  tok always symbolic=(tok1)
  || always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  tok always symbolic=(tok1)
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  tok always symbolic=(tok1)
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  tok always symbolic=(tok1)
  == always {!<=-1,!>=2}
  :: always 3
  eKeyword always 3
  || always {!<=-1,!>=2}
  tok always symbolic=(tok1)
  ( always !3
  == always {!<=-1,!>=2}
  :: always 8
  eBoolean always 8
  || always {!<=-1,!>=2}
Line 4209
  ( always {!<=-1,!>=2}
  tok always symbolic=(tok1)
  ".|namespace|class|struct|&|&&|*|> %name%" always ".|namespace|class|struct|&|&&|*|> %name%"
  || always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  tok always symbolic=(tok1)
  "%type%| %name% ( %type%|)" always "%type%| %name% ( %type%|)"
  || always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  tok always symbolic=(tok1)
  "public:|private:|protected:" always "public:|private:|protected:"
  || always {!<=-1,!>=2}
Line 4210
  ! always {!<=-1,!>=2}
  tok always symbolic=(tok1)
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  tok always symbolic=(tok1)
  "}|; %name%" always "}|; %name%"
Line 4213
  ( always {!<=-1,!>=2}
  ":: ~| %name%" always ":: ~| %name%"
Line 4215
  == always {!<=-1,!>=2}
  "~" always "~"
Line 4217
  ( always {!<=-1,!>=2}
  "%name% <" always "%name% <"
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "> :: ~| %name%" always "> :: ~| %name%"
Line 4219
  ( always {!<=-1,!>=2}
  "%name% ::" always "%name% ::"
Line 4224
  ! always {!<=-1,!>=2}
Line 4226
  ( always {!<=-1,!>=2}
  "%name% (" always "%name% ("
Line 4238
  tok possible symbolic=(scopeInfo.back().bodyEnd)
  == always {!<=-1,!>=2}
  "}" always "}"
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  scopeInfo always !size=0
Line 4239
  scopeInfo always !size=0
Line 4241
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "namespace|class|struct %name% {|:|::|<" always "namespace|class|struct %name% {|:|::|<"
Line 4245
  ( always {!<=-1,!>=2}
  scopeName always !size=0
  " :: " always " :: "
Line 4248
  classnameTokens always size=0
Line 4249
  2 always 2
Line 4250
  ( always {!<=-1,!>=2}
  tokStart possible symbolic=(closeTok->next())
  ":: %name%" always ":: %name%"
  || always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  "<" always "<"
Line 4251
  ( possible size=1
  == always {!<=-1,!>=2}
  "<" always "<"
Line 4254
  ! always {!<=-1,!>=2}
  closeTok always symbolic=(tokStart->findClosingBracket())
Line 4256
  closeTok {symbolic=(tokStart->findClosingBracket()),!0}
Line 4259
  2 always 2
Line 4265
  classname possible size=0
  ( {!<=-1,!>=2,1}
  "" always ""
  : always " :: "
  " :: " always " :: "
Line 4268
  ( always {!<=-1,!>=2}
  ":|::|,|%name%" always ":|::|,|%name%"
Line 4269
  ( always {!<=-1,!>=2}
  "%name% <" always "%name% <"
Line 4272
  tokStart always !0
Line 4275
  ( always {!<=-1,!>=2}
  "%name% ,|{" always "%name% ,|{"
Line 4278
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 4279
  scopeName3 {<=size=8,>=size=9,!size=0}
Line 4280
  ( possible lifetime[Iterator]=(varsByClass)
  name always symbolic=(scopeName3+baseClassName)
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(varsByClass),end=0}
Line 4285
  scopeName3 always !size=0
  ( always !<=0
  <= always {!<=-1,!>=2}
  8 always 8
Line 4287
  scopeName3 {!<=size=8,>=size=9}
  ( always !<=-1
  - always !<=-1
  4 always 4
Line 4288
  pos always !<=-1
  = always !<=-1
  ( always !<=-1
  " :: " always " :: "
Line 4289
  pos always !<=-1
  == always {!<=-1,!>=2}
Line 4291
  pos always !<=-1
  + always !<=3
  4 always 4
Line 4293
  baseClassName possible {symbolic=(tokStart->str()),symbolic=(name)}
Line 4294
  ( {lifetime[Iterator]=(varsByClass[baseClassName]),lifetime[Object]=(varsByClass),start=0}
  ( {lifetime[Iterator]=(varsByClass[baseClassName]),lifetime[Object]=(varsByClass),end=0}
Line 4298
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "{" always "{"
Line 4305
  && always {!<=-1,!>=2}
  tok2 always !0
  != always {!<=-1,!>=2}
Line 4308
  == always {!<=-1,!>=2}
  "(" always "("
Line 4309
  "{" always "{"
Line 4311
  funcstart always !0
  funcstart always !0
  & {lifetime[Address]=(mVarId),!0}
Line 4312
  funcstart always !0
Line 4316
  == always {!<=-1,!>=2}
  "{" always "{"
Line 4317
  -1 always -1
  == always {!<=-1,!>=2}
  ")" always ")"
Line 4318
  & {lifetime[Address]=(mVarId),!0}
Line 4320
  ( always {!<=-1,!>=2}
  "( %name%|)" always "( %name%|)"
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "(|[" always "(|["
Line 4324
  ( always {!<=-1,!>=2}
  ") [:,] %name% (" always ") [:,] %name% ("
Line 4325
  3 always 3
Line 4330
  > always {!<=-1,!>=2}
  0 always 0
Line 4331
  = {>=1,!<=0}
  ( {>=1,!<=0}
Line 4335
  ( always {!<=-1,!>=2}
Line 4341
  ! always {!<=-1,!>=2}
  tok2 always symbolic=(matchMemberVarName(var,scopeInfo))
Line 4343
  tok2 {symbolic=(matchMemberVarName(var,scopeInfo)),!0}
  == always {!<=-1,!>=2}
  0 always 0
Line 4344
  tok2 {symbolic=(matchMemberVarName(var,scopeInfo)),!0}
  tok2 always !0
Line 4347
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  "namespace" always "namespace"
Line 4353
  ! always {!<=-1,!>=2}
  tok2 always symbolic=(matchMemberFunctionName(func,scopeInfo))
Line 4356
  tok2 {symbolic=(matchMemberFunctionName(func,scopeInfo)),!0}
  == always {!<=-1,!>=2}
  "~" always "~"
Line 4357
  tok2 {symbolic=(matchMemberFunctionName(func,scopeInfo)),!0}
  2 always 2
Line 4359
  tok2 {symbolic=(matchMemberFunctionName(func,scopeInfo)),!0}
  1 always 1
Line 4362
  "{" always "{"
Line 4364
  start always !0
  start always !0
  & {lifetime[Address]=(mVarId),!0}
Line 4367
  ( always {!<=-1,!>=2}
  ") %name% (" always ") %name% ("
Line 4368
  2 always 2
Line 4371
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  ") : ::| %name%" always ") : ::| %name%"
Line 4375
  ( always {!<=-1,!>=2}
  tok3 possible symbolic=(tok2)
  "[)}] [,:]" always "[)}] [,:]"
Line 4376
  2 always 2
Line 4377
  ( always {!<=-1,!>=2}
  ":: %name%" always ":: %name%"
Line 4379
  ( always {!<=-1,!>=2}
  "%name% :: %name%" always "%name% :: %name%"
Line 4380
  2 always 2
Line 4381
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "%name% (|{|<" always "%name% (|{|<"
Line 4385
  :: possible {symbolic=(thisClassVars.end()),end=0}
  varpos possible {symbolic=(thisClassVars.end()),end=0}
  = possible {lifetime[Iterator]=(varsByClass[scopeName2+classname]),lifetime[Object]=(varsByClass)}
  ( possible {lifetime[Iterator]=(varsByClass[scopeName2+classname]),lifetime[Object]=(varsByClass)}
Line 4386
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(varsByClass[scopeName2+classname]),lifetime[Object]=(varsByClass),end=0}
Line 4387
  varpos always {!symbolic=(thisClassVars.end()),!end=0}
Line 4390
  1 always 1
  == always {!<=-1,!>=2}
  "<" always "<"
Line 4392
  && always {!<=-1,!>=2}
  tok3 always !0
  && always {!<=-1,!>=2}
  tok3 always !0
  ( always !0
Line 4393
  = always !0
  tok3 always !0
  ( always !0
  ( always !0
Line 4395
  1 always 1
Line 4397
  ( always {!<=-1,!>=2}
  tok3 possible symbolic=(tok2)
  ")|} {" always ")|} {"
Line 4398
  & {lifetime[Address]=(mVarId),!0}
Line 4406
  [ possible symbolic=(close)
  0 always 0
  == always {!<=-1,!>=2}
  open possible {123@245,40@246,91@247}
Line 4407
  links possible lifetime[Object]=(token)
Line 4408
  type possible lifetime[Object]=(token)
Line 4409
  [ always !symbolic=(open)
  0 always 0
  == always {!<=-1,!>=2}
Line 4410
  ( always {!<=-1,!>=2}
Line 4414
  0 always 0
  != always {!<=-1,!>=2}
  open always {!symbolic=(token->str()[0]),!symbolic=(close)}
Line 4432
  nullptr always 0
Line 4435
  this always !0
  '{' always 123
  '}' always 125
Line 4437
  this always !0
  '(' always 40
  ')' always 41
Line 4439
  this always !0
  '[' always 91
  ']' always 93
Line 4442
  ! {!<=-1,!>=2,0}
  links1 possible size=0
  ( {!<=-1,!>=2,1}
Line 4444
  links1 always !size=0
Line 4447
  ! {!<=-1,!>=2,0}
  links2 possible size=0
  ( {!<=-1,!>=2,1}
Line 4449
  links2 always !size=0
Line 4452
  ! {!<=-1,!>=2,0}
  links3 possible size=0
  ( {!<=-1,!>=2,1}
Line 4454
  links3 always !size=0
Line 4460
  ( always {!<=-1,!>=2}
Line 4463
  isStruct always {!<=-1,!>=2}
  isStruct always {!<=-1,!>=2}
  = always 0
  false always 0
Line 4468
  ( always {!<=-1,!>=2}
  "%name%|> %name% [:<]" always "%name%|> %name% [:<]"
Line 4469
  isStruct always {!<=-1,!>=2}
  = always 1
  true always 1
Line 4470
  ( always {!<=-1,!>=2}
  "[;{}]" always "[;{}]"
Line 4471
  isStruct always {!<=-1,!>=2}
  = always 0
  false always 0
Line 4474
  ( always {!<=-1,!>=2}
  "{|[|(" always "{|[|("
Line 4476
  ! {!<=-1,!>=2,0}
  type possible size=0
  ( {!<=-1,!>=2,1}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "}|]|)" always "}|]|)"
Line 4477
  == always {!<=-1,!>=2}
  "<" always "<"
Line 4478
  ! {!<=-1,!>=2,0}
  templateTokens possible size=0
  ( {!<=-1,!>=2,1}
  && always {!<=-1,!>=2}
  templateTokens always !size=0
  == always {!<=-1,!>=2}
Line 4479
  templateTokens always !size=0
Line 4484
  templateTokens possible {size=2,size=0}
  ( {!<=-1,!>=2,0,1}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  isStruct always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "%oror%|&&|;" always "%oror%|&&|;"
Line 4485
  ( always {!<=-1,!>=2}
  "&& [,>]" always "&& [,>]"
Line 4489
  == always {!<=-1,!>=2}
  :: always 14
  eLogicalOp always 14
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  type always !size=0
  == always {!<=-1,!>=2}
  "<" always "<"
Line 4491
  foundComparison always {!<=-1,!>=2}
  foundComparison always {!<=-1,!>=2}
  = always 0
  false always 0
Line 4492
  ( always {!<=-1,!>=2}
  prev possible symbolic=(token->previous())
  "%name%|%num%|%str%|%cop%|)|]" always "%name%|%num%|%str%|%cop%|)|]"
  && always {!<=-1,!>=2}
  prev possible symbolic=(token->previous())
  != always {!<=-1,!>=2}
  type always !size=0
Line 4493
  prev always !symbolic=(type.top())
  ( possible size=1
  == always {!<=-1,!>=2}
  ")" always ")"
  || always {!<=-1,!>=2}
  prev always !symbolic=(type.top())
  == always {!<=-1,!>=2}
  "]" always "]"
Line 4494
  prev always !symbolic=(type.top())
Line 4495
  prev always !symbolic=(type.top())
  == always {!<=-1,!>=2}
  :: always 14
  eLogicalOp always 14
Line 4497
  prev always !symbolic=(type.top())
  ( always {!<=-1,!>=2}
Line 4498
  foundComparison always {!<=-1,!>=2}
  = always 1
  true always 1
Line 4501
  prev possible symbolic=(token->previous())
  == always {!<=-1,!>=2}
  type always !size=0
  && always {!<=-1,!>=2}
  foundComparison always {!<=-1,!>=2}
Line 4504
  foundComparison always {!<=-1,!>=2}
  = always 0
  false always 0
Line 4505
  ( always {!<=-1,!>=2}
  next possible symbolic=(token->next())
  "%name%|%num%|%str%|%cop%|(|[" always "%name%|%num%|%str%|%cop%|(|["
  && always {!<=-1,!>=2}
  next possible symbolic=(token->next())
  != always {!<=-1,!>=2}
  ">" always ">"
Line 4506
  ( possible size=1
  == always {!<=-1,!>=2}
  "(" always "("
  || always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  "[" always "["
Line 4508
  == always {!<=-1,!>=2}
  :: always 14
  eLogicalOp always 14
Line 4510
  ( always {!<=-1,!>=2}
Line 4511
  foundComparison always {!<=-1,!>=2}
  = always 1
  true always 1
Line 4514
  next possible symbolic=(token->next())
  && always {!<=-1,!>=2}
  next always !0
  == always {!<=-1,!>=2}
  ">" always ">"
  && always {!<=-1,!>=2}
  foundComparison always {!<=-1,!>=2}
Line 4518
  ! {!<=-1,!>=2,1,0}
  type possible size=0
  ( {!<=-1,!>=2,0,1}
  && always {!<=-1,!>=2}
  type always !size=0
  == always {!<=-1,!>=2}
  "<" always "<"
Line 4519
  type always !size=0
Line 4520
  ( always {!<=-1,!>=2}
  end always symbolic=(type.top()->findClosingBracket())
  "> %comp%|;|.|=|{|::" always "> %comp%|;|.|=|{|::"
Line 4523
  ( always {!<=-1,!>=2}
  end always symbolic=(type.top()->findClosingBracket())
  "> %var% ;" always "> %var% ;"
  && always {!<=-1,!>=2}
  type always !size=0
  -2 always -2
  == always {!<=-1,!>=2}
  nullptr always 0
  || always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  type always !size=0
  -2 always -2
  ";|}|{" always ";|}|{"
Line 4527
  ( possible {size=1,size=2}
  == {!<=-1,!>=2,0}
  "<" always "<"
  && always {!<=-1,!>=2}
Line 4528
  && always {!<=-1,!>=2}
  ( always !0
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
Line 4529
  ( always !0
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always !0
  || always {!<=-1,!>=2}
Line 4530
  ( always {!<=-1,!>=2}
  ">|>>" always ">|>>"
Line 4532
  == always {!<=-1,!>=2}
  "template" always "template"
Line 4534
  ( possible size=2
  == {!<=-1,!>=2,0}
  ">" always ">"
  || always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  ">>" always ">>"
Line 4535
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  type always !size=0
  != always {!<=-1,!>=2}
  "<" always "<"
Line 4537
  type always !size=0
Line 4538
  type always !size=0
Line 4539
  type always !size=-1
  ( always {!<=-1,!>=2}
  nullptr always 0
  : always 0
  type always {!size=-1,!size=0}
Line 4540
  type always !size=-1
  top1 inconclusive {symbolic=(templateTokens.top()),0}
Line 4541
  ! {!<=-1,!>=2,1}
  top2 possible {symbolic=(templateTokens.top()),0}
  || always {!<=-1,!>=2}
  top2 always !0
  != always {!<=-1,!>=2}
  "<" always "<"
Line 4542
  == always {!<=-1,!>=2}
  ">>" always ">>"
Line 4544
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "%name%|%cop%|%assign%|::|,|(|)|{|}|;|[|:|.|=|..." always "%name%|%cop%|%assign%|::|,|(|)|{|}|;|[|:|.|=|..."
  && always {!<=-1,!>=2}
Line 4545
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "&& %name% =" always "&& %name% ="
Line 4550
  1 always 1
  == always {!<=-1,!>=2}
  "[" always "["
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  -1 always -1
  "... >" always "... >"
  && always {!<=-1,!>=2}
Line 4551
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  1 always 1
  "[ ]" always "[ ]"
Line 4552
  type always !size=0
Line 4553
  prev possible {symbolic=(type.top()->previous()),0}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  prev {symbolic=(type.top()->previous()),!0}
  ":: %name%" always ":: %name%"
Line 4554
  prev always !0
  -2 always -2
Line 4555
  prev possible {symbolic=(type.top()->previous()),0}
  && always {!<=-1,!>=2}
  prev always !0
  != always {!<=-1,!>=2}
  "new" always "new"
Line 4556
  prev always !0
Line 4557
  ! {!<=-1,!>=2,1}
  prev possible 0
  || always {!<=-1,!>=2}
  prev always !0
  != always {!<=-1,!>=2}
  "new" always "new"
Line 4561
  == always {!<=-1,!>=2}
  ">>" always ">>"
  && always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 4562
  type always !size=0
Line 4563
  type always !size=-1
Line 4565
  ">" always ">"
Line 4566
  top1 {symbolic=(templateTokens.top()),!0}
  ">" always ">"
Line 4567
  top2 {symbolic=(templateTokens.top()),!0}
Line 4568
  ( always !<=-1
  == always {!<=-1,!>=2}
  2 always 2
  && always {!<=-1,!>=2}
  top1 always !0
  == always {!<=-1,!>=2}
  templateTokens always size=2
  ( possible symbolic=(top2)
  || always {!<=-1,!>=2}
  top2 always !0
  == always {!<=-1,!>=2}
  ( always !symbolic=(top1)
Line 4569
  templateTokens always size=2
Line 4570
  templateTokens always size=1
Line 4573
  type always !size=0
Line 4574
  ( always {!<=-1,!>=2}
  "> %name%" always "> %name%"
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 4575
  ( always {!<=-1,!>=2}
  -2 always -2
  "%op% %name% <" always "%op% %name% <"
  && always {!<=-1,!>=2}
Line 4576
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  != always {!<=-1,!>=2}
  templateTokens always !size=0
Line 4578
  top1 possible symbolic=(templateTokens.top())
Line 4579
  ! {!<=-1,!>=2,0}
  templateTokens possible size=0
  ( {!<=-1,!>=2,1}
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  templateTokens always !size=0
Line 4580
  templateTokens always !size=0
Line 4589
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "sizeof !!(" always "sizeof !!("
Line 4591
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "%name%|*|~|!|&" always "%name%|*|~|!|&"
Line 4593
  ( always {!<=-1,!>=2}
  endToken possible symbolic=(tok->next())
  "* *" always "* *"
Line 4595
  ( always {!<=-1,!>=2}
  endToken possible symbolic=(tok->next())
  "%name%|%num%|%str%|[|(|.|::|++|--|!|~" always "%name%|%num%|%str%|[|(|.|::|++|--|!|~"
  || always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "%type% * %op%|?|:|const|;|," always "%type% * %op%|?|:|const|;|,"
Line 4596
  ( always {!<=-1,!>=2}
  "(|[" always "(|["
Line 4597
  1 always 1
Line 4603
  "(" always "("
Line 4604
  ")" always ")"
Line 4610
  ( always {!<=-1,!>=2}
Line 4615
  tok possible symbolic=(tok2)
Line 4616
  != always {!<=-1,!>=2}
  0 always 0
  && always {!<=-1,!>=2}
  ( possible lifetime[Iterator]=(sizeOfVar)
  ( always !0
  == always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(sizeOfVar),end=0}
Line 4618
  ( always {!<=-1,!>=2}
  -3 always -3
  "[;{}(,] %type% * %name% [;,)]" always "[;{}(,] %type% * %name% [;,)]"
  || always {!<=-1,!>=2}
Line 4619
  ( always {!<=-1,!>=2}
  -4 always -4
  "[;{}(,] const %type% * %name% [;),]" always "[;{}(,] const %type% * %name% [;),]"
  || always {!<=-1,!>=2}
Line 4620
  ( always {!<=-1,!>=2}
  -2 always -2
  "[;{}(,] %type% %name% [;),]" always "[;{}(,] %type% %name% [;),]"
  || always {!<=-1,!>=2}
Line 4621
  ( always {!<=-1,!>=2}
  -3 always -3
  "[;{}(,] const %type% %name% [;),]" always "[;{}(,] const %type% %name% [;),]"
Line 4623
  == always {!<=-1,!>=2}
  0 always 0
Line 4627
  varId always symbolic=(tok->varId())
  = always !0
  size always !0
Line 4628
  varId always symbolic=(tok->varId())
Line 4631
  ( always {!<=-1,!>=2}
  "%type% %name% [ %num% ] [[;=]" always "%type% %name% [ %num% ] [[;=]"
  || always {!<=-1,!>=2}
Line 4632
  ( always {!<=-1,!>=2}
  -2 always -2
  "%type% * %name% [ %num% ] [[;=]" always "%type% * %name% [ %num% ] [[;=]"
Line 4634
  == always {!<=-1,!>=2}
  0 always 0
Line 4639
  tok2 possible symbolic=(tok->next())
  1 always 1
Line 4640
  < always {!<=-1,!>=2}
  0 always 0
Line 4642
  num {!<=-1,>=0}
Line 4643
  tok2 possible symbolic=(tok->next())
  3 always 3
Line 4644
  ( always {!<=-1,!>=2}
  tok2 possible 0
  "[ %num% ]" always "[ %num% ]"
Line 4645
  ( always {!<=-1,!>=2}
  tok2 possible 0
  "[;=]" always "[;=]"
Line 4649
  ! always {!<=-1,!>=2}
Line 4652
  = always !0
  tok2 always !0
Line 4655
  ( always {!<=-1,!>=2}
  "%type% %name% [ %num% ] [,)]" always "%type% %name% [ %num% ] [,)]"
  || always {!<=-1,!>=2}
Line 4656
  ( always {!<=-1,!>=2}
  -2 always -2
  "%type% * %name% [ %num% ] [,)]" always "%type% * %name% [ %num% ] [,)]"
Line 4658
  "*" always "*"
Line 4659
  varId always symbolic=(tok->varId())
  & {lifetime[Address]=(tempTok),!0}
Line 4660
  varId always symbolic=(tok->varId())
Line 4665
  ret always {!<=-1,!>=2}
  ret always {!<=-1,!>=2}
  = always 0
  false always 0
Line 4667
  != always {!<=-1,!>=2}
  "sizeof" always "sizeof"
Line 4670
  ( always {!<=-1,!>=2}
  "..." always "..."
Line 4676
  ( always {!<=-1,!>=2}
  "( %char% )" always "( %char% )"
Line 4681
  ( always {!<=-1,!>=2}
  : always 1
  1 always 1
Line 4683
  ret always {!<=-1,!>=2}
  = always 1
  true always 1
Line 4688
  ( always {!<=-1,!>=2}
  "( %str% )" always "( %str% )"
Line 4693
  1 always 1
Line 4695
  ret always {!<=-1,!>=2}
  = always 1
  true always 1
Line 4700
  ( always {!<=-1,!>=2}
  "( %type% * )" always "( %type% * )"
Line 4704
  ( always {!<=-1,!>=2}
  "( * )" always "( * )"
Line 4705
  2 always 2
Line 4706
  3 always 3
Line 4707
  ret always {!<=-1,!>=2}
  = always 1
  true always 1
Line 4711
  ( always {!<=-1,!>=2}
  "( %var% )" always "( %var% )"
Line 4712
  :: possible {symbolic=(sizeOfVar.end()),end=0}
  sizeOfVarPos possible {symbolic=(sizeOfVar.end()),end=0}
  = possible lifetime[Iterator]=(sizeOfVar)
  ( possible lifetime[Iterator]=(sizeOfVar)
  2 always 2
Line 4713
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(sizeOfVar),end=0}
Line 4717
  sizeOfVarPos always {!symbolic=(sizeOfVar.end()),!end=0}
Line 4718
  ret always {!<=-1,!>=2}
  = always 1
  true always 1
Line 4725
  ( always {!<=-1,!>=2}
  "( %type% )" always "( %type% )"
Line 4726
  2 always 2
Line 4727
  > always {!<=-1,!>=2}
  0 always 0
Line 4728
  size {>=1,!<=0}
Line 4729
  3 always 3
Line 4730
  ret always {!<=-1,!>=2}
  = always 1
  true always 1
Line 4734
  ( always {!<=-1,!>=2}
  "( *" always "( *"
  || always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "( %name% [" always "( %name% ["
Line 4735
  = always 0
  0 always 0
Line 4737
  2 always 2
Line 4738
  == always {!<=-1,!>=2}
  "*" always "*"
Line 4741
  derefs possible 0
  ++ possible 0
Line 4742
  && always {!<=-1,!>=2}
  nametok always !0
  == always {!<=-1,!>=2}
  "*" always "*"
Line 4744
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "%name% )" always "%name% )"
Line 4749
  tok2 possible symbolic=(nametok->next())
Line 4750
  derefs possible 0
  ++ possible 0
Line 4751
  tok2 possible 0
  && always {!<=-1,!>=2}
  tok2 always !0
  == always {!<=-1,!>=2}
  "[" always "["
Line 4753
  ! always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  tok2 always !0
  != always {!<=-1,!>=2}
  ")" always ")"
Line 4758
  size always !<=-1
  size always !<=-1
  = always 0
  0 always 0
Line 4761
  != always {!<=-1,!>=2}
  0 always 0
  && always {!<=-1,!>=2}
  varid always symbolic=(nametok->varId())
  != always {!<=-1,!>=2}
  0 always 0
  && always {!<=-1,!>=2}
  ( possible lifetime[Iterator]=(declTokOfVar)
  varid {symbolic=(nametok->varId()),!0}
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(declTokOfVar),end=0}
Line 4764
  ( always {!<=-1,!>=2}
  decltok always symbolic=(declTokOfVar[varid])
  "%type%|* %name% [" always "%type%|* %name% ["
Line 4765
  size always !<=-1
  = always !<=-1
  decltok always symbolic=(declTokOfVar[varid])
Line 4766
  ( always {!<=-1,!>=2}
  decltok always symbolic=(declTokOfVar[varid])
  -2 always -2
  "%type% * %name%" always "%type% * %name%"
Line 4767
  size always !<=-1
  = always !<=-1
  decltok always symbolic=(declTokOfVar[varid])
  -2 always -2
Line 4770
  ( always {!<=-1,!>=2}
  decltok always symbolic=(declTokOfVar[varid])
  "%name% [" always "%name% ["
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  decltok always symbolic=(declTokOfVar[varid])
  1 always 1
  "] [" always "] ["
Line 4771
  = always symbolic=(declTokOfVar[varid])
  decltok always symbolic=(declTokOfVar[varid])
Line 4772
  = always 0
  0 always 0
  i possible 0
  < always {!<=-1,!>=2}
  derefs always !0
Line 4773
  1 always 1
Line 4774
  ( always {!<=-1,!>=2}
  tok2 possible {symbolic=(decltok),symbolic=(declTokOfVar[varid])}
  "] [ %num% ]" always "] [ %num% ]"
Line 4775
  size always !<=-1
  *= always !<=-1
  ( always !<=-1
  2 always 2
Line 4776
  1 always 1
Line 4778
  ( always {!<=-1,!>=2}
  "] [" always "] ["
Line 4781
  1 always 1
  == always {!<=-1,!>=2}
  "[" always "["
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 4782
  size always !<=-1
  = always !<=-1
Line 4783
  size always !<=-1
  == always {!<=-1,!>=2}
  0 always 0
Line 4786
  ( always {!<=-1,!>=2}
  tok2 possible {symbolic=(nametok->next()),0}
  "[ %num% ]" always "[ %num% ]"
Line 4787
  size always !<=-1
  *= always !<=-1
  ( always !<=-1
  1 always 1
Line 4790
  ! always {!<=-1,!>=2}
  tok2 possible symbolic=(nametok->next())
  || always {!<=-1,!>=2}
  tok2 always !0
  != always {!<=-1,!>=2}
  ")" always ")"
Line 4794
  size always !<=-1
  > always {!<=-1,!>=2}
  0 always 0
Line 4795
  size {>=1,!<=0}
Line 4797
  ret always {!<=-1,!>=2}
  = always 1
  true always 1
Line 4801
  return always {!<=-1,!>=2}
  ret {!<=-1,!>=2,0}
Line 4804
  ( always {!<=-1,!>=2}
Line 4806
  ( always {!<=-1,!>=2}
Line 4807
  return always {!<=-1,!>=2}
  false always 0
Line 4811
  ( always {!<=-1,!>=2}
  "if|for|while|BOOST_FOREACH %name% (" always "if|for|while|BOOST_FOREACH %name% ("
Line 4812
  ( always {!<=-1,!>=2}
  "for each" always "for each"
Line 4814
  "asm" always "asm"
Line 4816
  1 always 1
  == always {!<=-1,!>=2}
  "constexpr" always "constexpr"
Line 4818
  true always 1
Line 4842
  ( always {!<=-1,!>=2}
Line 4852
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  . always {!<=-1,!>=2}
  daca always {!<=-1,!>=2}
Line 4853
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 4864
  "Tokenizer::tokenize::findGarbageCode" always "Tokenizer::tokenize::findGarbageCode"
  mTimerResults always !0
Line 4874
  ( always {!<=-1,!>=2}
  "if (" always "if ("
Line 4876
  ( always {!<=-1,!>=2}
  ") %name% (" always ") %name% ("
  && always {!<=-1,!>=2}
Line 4877
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 4878
  ( always {!<=-1,!>=2}
  2 always 2
  ") {|else" always ") {|else"
Line 4884
  ( always {!<=-1,!>=2}
Line 4885
  return always {!<=-1,!>=2}
  false always 0
Line 4915
  ( always {!<=-1,!>=2}
Line 4923
  ( always {!<=-1,!>=2}
  "> struct {" always "> struct {"
  && always {!<=-1,!>=2}
Line 4924
  ( always {!<=-1,!>=2}
  2 always 2
  "} ;" always "} ;"
Line 4929
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 4930
  return always {!<=-1,!>=2}
  false always 0
Line 4936
  ( always {!<=-1,!>=2}
  "0 [" always "0 ["
  && always {!<=-1,!>=2}
  1 always 1
Line 4937
  "*" always "*"
Line 4938
  "(" always "("
Line 4939
  1 always 1
  ")" always ")"
Line 4943
  ( always {!<=-1,!>=2}
Line 4944
  return always {!<=-1,!>=2}
  false always 0
Line 4954
  ( always {!<=-1,!>=2}
Line 4955
  = always 0
  nullptr always 0
Line 4956
  = possible symbolic=(lt)
  ( possible symbolic=(lt)
Line 4957
  ( always {!<=-1,!>=2}
  "[;{}]" always "[;{}]"
Line 4958
  = always 0
  nullptr always 0
Line 4959
  ( always {!<=-1,!>=2}
  "%type% <" always "%type% <"
Line 4961
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  ">|>> %name%|::|(" always ">|>> %name%|::|("
Line 4963
  = always !0
  lt always !0
  != always {!<=-1,!>=2}
Line 4964
  ( always {!<=-1,!>=2}
Line 4965
  ( always {!<=-1,!>=2}
Line 4973
  true always 1
Line 4982
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 4986
  ( always {!<=-1,!>=2}
Line 4987
  return always {!<=-1,!>=2}
  false always 0
Line 5014
  ( always {!<=-1,!>=2}
Line 5015
  return always {!<=-1,!>=2}
  false always 0
Line 5033
  false always 0
Line 5039
  "Tokenizer::tokenize::simplifyTypedef" always "Tokenizer::tokenize::simplifyTypedef"
  mTimerResults always !0
Line 5046
  ( always {!<=-1,!>=2}
Line 5055
  ( always {!<=-1,!>=2}
  "union|struct|class union|struct|class" always "union|struct|class union|struct|class"
Line 5062
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  :: always 6
  information always 6
Line 5064
  ( always {!<=-1,!>=2}
  "class %type% %type% [:{]" always "class %type% %type% [:{]"
Line 5078
  ( always {!<=-1,!>=2}
Line 5079
  return always {!<=-1,!>=2}
  false always 0
Line 5089
  ( possible size=1
  == always {!<=-1,!>=2}
  "(" always "("
Line 5091
  tok always symbolic=(tok1)
Line 5092
  ! always {!<=-1,!>=2}
Line 5094
  == always {!<=-1,!>=2}
  "@" always "@"
Line 5111
  ( always {!<=-1,!>=2}
Line 5112
  return always {!<=-1,!>=2}
  false always 0
Line 5117
  ( always {!<=-1,!>=2}
Line 5118
  return always {!<=-1,!>=2}
  false always 0
Line 5123
  ( always {!<=-1,!>=2}
Line 5124
  return always {!<=-1,!>=2}
  false always 0
Line 5129
  ( always {!<=-1,!>=2}
Line 5130
  return always {!<=-1,!>=2}
  false always 0
Line 5139
  ( always {!<=-1,!>=2}
Line 5141
  ( always {!<=-1,!>=2}
Line 5144
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 5147
  "Tokenizer::tokenize::simplifyTemplates" always "Tokenizer::tokenize::simplifyTemplates"
  mTimerResults always !0
Line 5154
  ( always {!<=-1,!>=2}
Line 5155
  return always {!<=-1,!>=2}
  false always 0
Line 5170
  false always 0
Line 5177
  "Tokenizer::tokenize::setVarId" always "Tokenizer::tokenize::setVarId"
  mTimerResults always !0
Line 5187
  "Tokenizer::tokenize::setVarId (2)" always "Tokenizer::tokenize::setVarId (2)"
  mTimerResults always !0
Line 5196
  ( always {!<=-1,!>=2}
  "const_cast|dynamic_cast|reinterpret_cast|static_cast <" always "const_cast|dynamic_cast|reinterpret_cast|static_cast <"
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  1 always 1
  "> (" always "> ("
Line 5197
  1 always 1
Line 5198
  true always 1
Line 5206
  ( always {!<=-1,!>=2}
Line 5207
  return always {!<=-1,!>=2}
  false always 0
Line 5237
  return always {!<=-1,!>=2}
  true always 1
Line 5240
  ( always {!<=-1,!>=2}
Line 5267
  ( always {!<=-1,!>=2}
Line 5268
  return always {!<=-1,!>=2}
  false always 0
Line 5270
  ( always {!<=-1,!>=2}
Line 5278
  ( always {!<=-1,!>=2}
Line 5280
  ( always {!<=-1,!>=2}
Line 5281
  return always {!<=-1,!>=2}
  false always 0
Line 5297
  false always 0
Line 5301
  ( always {!<=-1,!>=2}
Line 5309
  ( always {!<=-1,!>=2}
  "strlen ( %str% )" always "strlen ( %str% )"
Line 5310
  2 always 2
Line 5311
  3 always 3
Line 5315
  modified always {!<=-1,!>=2}
  modified always {!<=-1,!>=2}
  = always 1
  true always 1
Line 5316
  modified {!<=-1,!>=2,1}
Line 5317
  ( always {!<=-1,!>=2}
Line 5318
  return always {!<=-1,!>=2}
  false always 0
Line 5320
  modified always {!<=-1,!>=2}
  = always 0
  false always 0
Line 5321
  modified always {!<=-1,!>=2}
  |= always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 5322
  modified always {!<=-1,!>=2}
  |= always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 5323
  modified always {!<=-1,!>=2}
  |= always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 5324
  modified always {!<=-1,!>=2}
  |= always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 5326
  modified always {!<=-1,!>=2}
  |= always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 5327
  modified always {!<=-1,!>=2}
  |= always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 5328
  modified always {!<=-1,!>=2}
  |= always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 5329
  modified always {!<=-1,!>=2}
  |= always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 5339
  ( always {!<=-1,!>=2}
  "return (" always "return ("
Line 5341
  ( always {!<=-1,!>=2}
  tok2 always symbolic=(tok->next()->link())
  ") ;" always ") ;"
Line 5378
  true always 1
Line 5380
  & {lifetime[Address]=(list),!0}
Line 5382
  ( always {!<=-1,!>=2}
Line 5383
  return always {!<=-1,!>=2}
  false always 0
Line 5385
  2 always 2
Line 5387
  return always {!<=-1,!>=2}
  true always 1
Line 5393
  debug always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  simplification possible {2,0@167,1@192}
  != {!<=-1,!>=2,1}
  1U always 1
  && always {!<=-1,!>=2}
  . always {!<=-1,!>=2}
  debugSimplified always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
Line 5394
  simplification possible {0@167,2@185,1@192}
  != always {!<=-1,!>=2}
  2U always 2
  && always {!<=-1,!>=2}
  . always {!<=-1,!>=2}
  debugnormal always {!<=-1,!>=2}
Line 5396
  debug {symbolic=((simplification!=1U&&mSettings->debugSimplified)||(simplification!=2U&&mSettings->debugnormal)),!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 5397
  nullptr always 0
Line 5399
  . {!<=-1,!>=2,0}
  xml always {!<=-1,!>=2}
Line 5400
  "<debug>" always "<debug>"
Line 5403
  . always {!<=-1,!>=2}
  xml always {!<=-1,!>=2}
Line 5404
  mSymbolDatabase always !0
Line 5405
  . always {!<=-1,!>=2}
  verbose always {!<=-1,!>=2}
Line 5406
  mSymbolDatabase always !0
  "Symbol database" always "Symbol database"
Line 5410
  . {!<=-1,!>=2,1,0}
  verbose always {!<=-1,!>=2}
Line 5411
  . always {!<=-1,!>=2}
  verbose always {!<=-1,!>=2}
  . always {!<=-1,!>=2}
  xml always {!<=-1,!>=2}
Line 5413
  . always {!<=-1,!>=2}
  xml always {!<=-1,!>=2}
Line 5415
  . always {!<=-1,!>=2}
  xml always {!<=-1,!>=2}
Line 5416
  "</debug>" always "</debug>"
Line 5419
  && always {!<=-1,!>=2}
  simplification possible {0@167,2@185,1@192}
  == always {!<=-1,!>=2}
  2U always 2
  && always {!<=-1,!>=2}
  . always {!<=-1,!>=2}
  debugwarnings always {!<=-1,!>=2}
Line 5423
  mSymbolDatabase always !0
Line 5424
  ! always {!<=-1,!>=2}
Line 5427
  var always !0
Line 5428
  typetok possible {symbolic=(var->typeStartToken()),symbolic=(var->typeEndToken())}
  && always {!<=-1,!>=2}
  typetok {symbolic=(var->typeStartToken()),!0}
  != always {!<=-1,!>=2}
  var always !0
Line 5429
  typetok always {!symbolic=(var->typeEndToken()),!0}
Line 5431
  typetok possible {symbolic=(var->typeStartToken()),symbolic=(var->typeEndToken()),0}
  != {!<=-1,!>=2,0}
  var always !0
  ( possible symbolic=(typetok)
Line 5432
  var always !0
Line 5433
  :: always 7
  debug always 7
Line 5434
  "debug" always "debug"
Line 5435
  "Variable::typeStartToken() of variable '" always "Variable::typeStartToken() of variable '"
  var always !0
  "' is not located before Variable::typeEndToken(). The location of the typeStartToken() is '" always "' is not located before Variable::typeEndToken(). The location of the typeStartToken() is '"
  var always !0
  "' at line " always "' at line "
  var always !0
Line 5448
  "  <tokenlist>" always "  <tokenlist>"
Line 5450
  "    <token id=\"" always "    <token id=\""
  "\" file=\"" always "\" file=\""
  "\" linenr=\"" always "\" linenr=\""
  "\" column=\"" always "\" column=\""
  "\"" always "\""
Line 5451
  " str=\"" always " str=\""
  '\"' always 34
Line 5452
  " scope=\"" always " scope=\""
  '\"' always 34
Line 5453
  ( always {!<=-1,!>=2}
Line 5454
  " type=\"name\"" always " type=\"name\""
Line 5455
  ( always {!<=-1,!>=2}
Line 5456
  " isUnsigned=\"true\"" always " isUnsigned=\"true\""
Line 5457
  ( always {!<=-1,!>=2}
Line 5458
  " isSigned=\"true\"" always " isSigned=\"true\""
Line 5459
  ( always {!<=-1,!>=2}
Line 5460
  " type=\"number\"" always " type=\"number\""
Line 5461
  ( always {!<=-1,!>=2}
Line 5462
  " isInt=\"true\"" always " isInt=\"true\""
Line 5463
  ( always {!<=-1,!>=2}
Line 5464
  " isFloat=\"true\"" always " isFloat=\"true\""
Line 5465
  ( possible {7,14}
  == {!<=-1,!>=2,0}
  :: always 6
  eString always 6
Line 5466
  " type=\"string\" strlen=\"" always " type=\"string\" strlen=\""
  '\"' always 34
Line 5467
  ( {14,!6}
  == {!<=-1,!>=2,0}
  :: always 7
  eChar always 7
Line 5468
  " type=\"char\"" always " type=\"char\""
Line 5469
  ( always {!<=-1,!>=2}
Line 5470
  " type=\"boolean\"" always " type=\"boolean\""
Line 5471
  ( always {!<=-1,!>=2}
Line 5472
  " type=\"op\"" always " type=\"op\""
Line 5473
  ( always {!<=-1,!>=2}
Line 5474
  " isArithmeticalOp=\"true\"" always " isArithmeticalOp=\"true\""
Line 5475
  ( always {!<=-1,!>=2}
Line 5476
  " isAssignmentOp=\"true\"" always " isAssignmentOp=\"true\""
Line 5477
  ( always {!<=-1,!>=2}
Line 5478
  " isComparisonOp=\"true\"" always " isComparisonOp=\"true\""
Line 5479
  ( always {!6,!7}
  == always {!<=-1,!>=2}
  :: always 14
  eLogicalOp always 14
Line 5480
  " isLogicalOp=\"true\"" always " isLogicalOp=\"true\""
Line 5482
  ( always {!<=-1,!>=2}
Line 5483
  " isExpandedMacro=\"true\"" always " isExpandedMacro=\"true\""
Line 5484
  ( always {!<=-1,!>=2}
Line 5485
  " isRemovedVoidParameter=\"true\"" always " isRemovedVoidParameter=\"true\""
Line 5486
  ( always {!<=-1,!>=2}
Line 5487
  " isSplittedVarDeclComma=\"true\"" always " isSplittedVarDeclComma=\"true\""
Line 5488
  ( always {!<=-1,!>=2}
Line 5489
  " isSplittedVarDeclEq=\"true\"" always " isSplittedVarDeclEq=\"true\""
Line 5490
  ( always {!<=-1,!>=2}
Line 5491
  " isImplicitInt=\"true\"" always " isImplicitInt=\"true\""
Line 5492
  ( always {!<=-1,!>=2}
Line 5493
  " isComplex=\"true\"" always " isComplex=\"true\""
Line 5495
  " link=\"" always " link=\""
  ( always !0
  '\"' always 34
Line 5496
  > always {!<=-1,!>=2}
  0 always 0
Line 5497
  " varId=\"" always " varId=\""
  ( {>=1,!<=0}
  '\"' always 34
Line 5499
  " variable=\"" always " variable=\""
  ( always !0
  '\"' always 34
Line 5501
  " function=\"" always " function=\""
  ( always !0
  '\"' always 34
Line 5502
  ! {!<=-1,!>=2,0}
  ( possible size=0
  ( {!<=-1,!>=2,1}
Line 5503
  " values=\"" always " values=\""
  & always !0
  ( always !size=0
  '\"' always 34
Line 5505
  " type-scope=\"" always " type-scope=\""
  ( always !0
  '\"' always 34
Line 5507
  " astParent=\"" always " astParent=\""
  ( always !0
  '\"' always 34
Line 5509
  " astOperand1=\"" always " astOperand1=\""
  ( always !0
  '\"' always 34
Line 5511
  " astOperand2=\"" always " astOperand2=\""
  ( always !0
  '\"' always 34
Line 5512
  ! {!<=-1,!>=2,0}
  ( possible size=0
  ( {!<=-1,!>=2,1}
Line 5513
  " originalName=\"" always " originalName=\""
  ( always !size=0
  '\"' always 34
Line 5515
  ( always !0
Line 5516
  ! {!<=-1,!>=2,0}
  vt {symbolic=(tok->valueType()->dump()),size=0}
  ( {!<=-1,!>=2,1}
Line 5517
  ' ' always 32
  vt {symbolic=(tok->valueType()->dump()),!size=0}
Line 5519
  ! always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "%name% (" always "%name% ("
Line 5520
  ( always {!<=-1,!>=2}
Line 5521
  " noreturn=\"true\"" always " noreturn=\"true\""
Line 5524
  "/>" always "/>"
Line 5526
  "  </tokenlist>" always "  </tokenlist>"
Line 5530
  true always 1
Line 5532
  ! {!<=-1,!>=2,0}
  mTypedefInfo possible size=0
  ( {!<=-1,!>=2,1}
Line 5533
  "  <typedef-info>" always "  <typedef-info>"
Line 5534
  mTypedefInfo always !size=0
Line 5535
  "    <info" always "    <info"
Line 5536
  " name=\"" always " name=\""
  "\"" always "\""
Line 5537
  " file=\"" always " file=\""
  "\"" always "\""
Line 5538
  " line=\"" always " line=\""
  "\"" always "\""
Line 5539
  " column=\"" always " column=\""
  "\"" always "\""
Line 5540
  " used=\"" always " used=\""
  . always {!<=-1,!>=2}
  used always {!<=-1,!>=2}
  1 always 1
  : always 0
  0 always 0
  "\"" always "\""
Line 5541
  "/>" always "/>"
Line 5543
  "  </typedef-info>" always "  </typedef-info>"
Line 5549
  . {!<=-1,!>=2,0}
  checkHeaders always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  . always {!<=-1,!>=2}
  checkUnusedTemplates always {!<=-1,!>=2}
Line 5553
  checkHeaders always {!<=-1,!>=2}
  = {!<=-1,!>=2,0}
  . {!<=-1,!>=2,0}
  checkHeaders always {!<=-1,!>=2}
Line 5554
  removeUnusedIncludedFunctions always {!<=-1,!>=2}
  = {!<=-1,!>=2,1}
  ! {!<=-1,!>=2,1}
  . {symbolic=(checkHeaders),!<=-1,!>=2,0}
  checkHeaders always {!<=-1,!>=2}
Line 5555
  removeUnusedIncludedClasses always {!<=-1,!>=2}
  = {symbolic=(removeUnusedIncludedFunctions),!<=-1,!>=2,1}
  ! {symbolic=(removeUnusedIncludedFunctions),!<=-1,!>=2,1}
  . {symbolic=(checkHeaders),!<=-1,!>=2,0}
  checkHeaders always {!<=-1,!>=2}
Line 5556
  removeUnusedIncludedTemplates always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  ! {!<=-1,!>=2,1}
  . {!<=-1,!>=2,0}
  checkUnusedTemplates always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  ! {symbolic=(removeUnusedIncludedFunctions),symbolic=(removeUnusedIncludedClasses),!<=-1,!>=2}
  . {symbolic=(checkHeaders),!<=-1,!>=2}
  checkHeaders always {!<=-1,!>=2}
Line 5557
  removeUnusedTemplates always {!<=-1,!>=2}
  = {!<=-1,!>=2,1}
  ! {!<=-1,!>=2,1}
  . {!<=-1,!>=2,0}
  checkUnusedTemplates always {!<=-1,!>=2}
Line 5573
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "template <" always "template <"
Line 5575
  ( always {!<=-1,!>=2}
  closingBracket always symbolic=(tok->next()->findClosingBracket())
  "> class|struct %name% {" always "> class|struct %name% {"
Line 5576
  closingBracket always symbolic=(tok->next()->findClosingBracket())
  3 always 3
Line 5579
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 5582
  ! always {!<=-1,!>=2}
  checkHeaders {symbolic=(mSettings->checkHeaders),!<=-1,!>=2}
  && always {!<=-1,!>=2}
  != always {!<=-1,!>=2}
  0 always 0
Line 5585
  ( always {!<=-1,!>=2}
  "%name% (" always "%name% ("
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  1 always 1
  ") {" always ") {"
Line 5590
  ( always {!<=-1,!>=2}
  "%name% %name%|::|*|&|<" always "%name% %name%|::|*|&|<"
Line 5595
  "static" always "static"
  "const" always "const"
  "unsigned" always "unsigned"
  "signed" always "signed"
  "void" always "void"
  "bool" always "bool"
  "char" always "char"
  "short" always "short"
  "int" always "int"
  "long" always "long"
  "float" always "float"
  "*" always "*"
Line 5598
  isIncluded always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  != always {!<=-1,!>=2}
  0 always 0
Line 5601
  isIncluded {symbolic=(tok->fileIndex()!=0),!<=-1,!>=2,0}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  . always {!<=-1,!>=2}
  checkHeaders always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  "{" always "{"
Line 5604
  prev possible symbolic=(tok->previous())
  && always {!<=-1,!>=2}
  prev {symbolic=(tok->previous()),!0}
  ( always {!<=-1,!>=2}
Line 5605
  prev always !0
Line 5606
  ( always {!<=-1,!>=2}
  prev possible {symbolic=(tok->previous()),0}
  ")" always ")"
Line 5609
  ";" always ";"
Line 5610
  nullptr always 0
Line 5614
  ! always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  ( always !0
  "[;{}]" always "[;{}]"
Line 5616
  isIncluded {!<=-1,!>=2,0}
  && always {!<=-1,!>=2}
  removeUnusedIncludedFunctions always {!<=-1,!>=2}
Line 5617
  true always 1
Line 5619
  start possible symbolic=(tok)
  && always {!<=-1,!>=2}
  functionStart always {{,size=12}
  ( possible lifetime[Iterator]=(functionStart)
  start {symbolic=(tok),!0}
  != always {!<=-1,!>=2}
  functionStart always {{,size=12}
  ( {lifetime[Iterator]=(functionStart),end=0}
Line 5620
  start always !0
Line 5621
  ( always {!<=-1,!>=2}
  start possible {symbolic=(tok),0}
  "%name% (" always "%name% ("
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  1 always 1
  ") const| ;" always ") const| ;"
  && always {!<=-1,!>=2}
  ( possible lifetime[Iterator]=(keep)
  == always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(keep),end=0}
Line 5622
  1 always 1
  2 always 2
Line 5629
  isIncluded {!<=-1,!>=2,0,1}
  && always {!<=-1,!>=2}
  removeUnusedIncludedClasses always {!<=-1,!>=2}
Line 5630
  ( always {!<=-1,!>=2}
  "class|struct %name% [:{]" always "class|struct %name% [:{]"
  && always {!<=-1,!>=2}
  ( possible lifetime[Iterator]=(keep)
  1 always 1
  == always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(keep),end=0}
Line 5632
  2 always 2
Line 5633
  == always {!<=-1,!>=2}
  ":" always ":"
Line 5635
  ( always {!<=-1,!>=2}
  "%name%|," always "%name%|,"
Line 5638
  && always {!<=-1,!>=2}
  endToken always !0
  == always {!<=-1,!>=2}
  "{" always "{"
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  endToken always !0
  "} ;" always "} ;"
Line 5639
  endToken always !0
Line 5645
  removeUnusedTemplates always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  isIncluded always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  removeUnusedIncludedTemplates always {!<=-1,!>=2}
Line 5646
  ( always {!<=-1,!>=2}
  "template < %name%" always "template < %name%"
Line 5648
  ( always {!<=-1,!>=2}
  closingBracket always symbolic=(tok->next()->findClosingBracket())
  "> class|struct %name% [;:{]" always "> class|struct %name% [;:{]"
  && always {!<=-1,!>=2}
  ( possible lifetime[Iterator]=(keep)
  closingBracket always symbolic=(tok->next()->findClosingBracket())
  2 always 2
  == always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(keep),end=0}
Line 5649
  closingBracket always symbolic=(tok->next()->findClosingBracket())
  3 always 3
Line 5650
  == always {!<=-1,!>=2}
  ":" always ":"
Line 5652
  ( always {!<=-1,!>=2}
  "%name%|," always "%name%|,"
Line 5655
  && always {!<=-1,!>=2}
  endToken always !0
  == always {!<=-1,!>=2}
  "{" always "{"
Line 5656
  endToken always !0
Line 5657
  && always {!<=-1,!>=2}
  endToken always !0
  == always {!<=-1,!>=2}
  ";" always ";"
Line 5658
  endToken always !0
Line 5661
  ( always {!<=-1,!>=2}
  closingBracket always symbolic=(tok->next()->findClosingBracket())
  "> %type% %name% (" always "> %type% %name% ("
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  closingBracket always symbolic=(tok->next()->findClosingBracket())
  3 always 3
  ") {" always ") {"
  && always {!<=-1,!>=2}
  ( possible lifetime[Iterator]=(keep)
  closingBracket always symbolic=(tok->next()->findClosingBracket())
  2 always 2
  == always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(keep),end=0}
Line 5662
  closingBracket always symbolic=(tok->next()->findClosingBracket())
  3 always 3
  1 always 1
Line 5674
  ( always {!<=-1,!>=2}
Line 5676
  ( always {!<=-1,!>=2}
  "%name%|>|) .|:: template %name%" always "%name%|>|) .|:: template %name%"
Line 5678
  2 always 2
Line 5679
  ( always {!<=-1,!>=2}
  "%name%|::" always "%name%|::"
Line 5680
  true always 1
Line 5683
  ( always {!<=-1,!>=2}
  "operator %op%|(" always "operator %op%|("
Line 5684
  true always 1
Line 5685
  == always {!<=-1,!>=2}
  "(" always "("
  && always {!<=-1,!>=2}
Line 5686
  ( always !0
  true always 1
Line 5696
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  prev always !0
  "[;{}]" always "[;{}]"
Line 5697
  " " always " "
Line 5698
  "!!!" always "!!!"
  "!!!" always "!!!"
Line 5699
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  next always !0
  "[;{}]" always "[;{}]"
Line 5700
  " " always " "
Line 5704
  check always {!<=-1,!>=2}
Line 5709
  ( always {!<=-1,!>=2}
  "[;{}] %type% %type% [;,=]" always "[;{}] %type% %type% [;,=]"
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 5710
  2 always 2
Line 5713
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  "<" always "<"
  && always {!<=-1,!>=2}
  ( always !<=-1
  && always {!<=-1,!>=2}
  ( possible lifetime[Iterator]=(vars)
  == always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(vars),end=0}
Line 5715
  check always {!<=-1,!>=2}
Line 5716
  ( always {!<=-1,!>=2}
  endTok always symbolic=(tok->findClosingBracket())
  ">>|>>=" always ">>|>>="
Line 5717
  :: always 7
  debug always 7
  "dacaWrongSplitTemplateRightAngleBrackets" always "dacaWrongSplitTemplateRightAngleBrackets"
  "bad closing bracket for !!!<!!!: " always "bad closing bracket for !!!<!!!: "
  false always 0
Line 5720
  endTok {symbolic=(tok->findClosingBracket()),0}
  && always {!<=-1,!>=2}
  endTok {symbolic=(tok->findClosingBracket()),!0}
  == always {!<=-1,!>=2}
  ">>" always ">>"
Line 5721
  endTok {symbolic=(tok->findClosingBracket()),!0}
  ">" always ">"
Line 5722
  endTok {symbolic=(tok->findClosingBracket()),!0}
  ">" always ">"
Line 5723
  endTok {symbolic=(tok->findClosingBracket()),0}
  && always {!<=-1,!>=2}
  endTok {symbolic=(tok->findClosingBracket()),!0}
  == always {!<=-1,!>=2}
  ">>=" always ">>="
Line 5724
  endTok {symbolic=(tok->findClosingBracket()),!0}
  ">" always ">"
Line 5725
  endTok {symbolic=(tok->findClosingBracket()),!0}
  "=" always "="
Line 5726
  endTok {symbolic=(tok->findClosingBracket()),!0}
  ">" always ">"
Line 5728
  ( always {!<=-1,!>=2}
  "class|struct|union|=|:|public|protected|private %name% <" always "class|struct|union|=|:|public|protected|private %name% <"
  && always {!<=-1,!>=2}
  ( possible lifetime[Iterator]=(vars)
  == always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(vars),end=0}
Line 5729
  2 always 2
Line 5730
  check always {!<=-1,!>=2}
Line 5731
  ( always {!<=-1,!>=2}
  ">>" always ">>"
Line 5732
  :: always 7
  debug always 7
  "dacaWrongSplitTemplateRightAngleBrackets" always "dacaWrongSplitTemplateRightAngleBrackets"
  "bad closing bracket for !!!<!!!: " always "bad closing bracket for !!!<!!!: "
  false always 0
Line 5735
  ( always {!<=-1,!>=2}
  ">> ;|{|%type%" always ">> ;|{|%type%"
Line 5736
  ">" always ">"
Line 5737
  ">" always ">"
Line 5746
  == always {!<=-1,!>=2}
  "(" always "("
Line 5748
  ( always {!<=-1,!>=2}
  ") %type% {" always ") %type% {"
  && always {!<=-1,!>=2}
Line 5749
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "const|namespace|class|struct|union|noexcept|override|final|volatile|mutable" always "const|namespace|class|struct|union|noexcept|override|final|volatile|mutable"
Line 5753
  ( always {!<=-1,!>=2}
  "%type%" always "%type%"
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 5754
  ! always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  ( always !0
  "[;{}]" always "[;{}]"
  || always {!<=-1,!>=2}
  ( always !0
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  ( always !0
  ':' always 58
Line 5756
  tok2 {symbolic=(tok->next()),0}
  && always {!<=-1,!>=2}
  tok2 {symbolic=(tok->next()),!0}
  == always {!<=-1,!>=2}
  "(" always "("
Line 5757
  tok2 {symbolic=(tok->next()),!0}
Line 5760
  ( always {!<=-1,!>=2}
  tok2 possible symbolic=(tok->next())
  "%type% (" always "%type% ("
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 5761
  1 always 1
Line 5763
  ( always {!<=-1,!>=2}
  "%name% (" always "%name% ("
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "%name% *|&|::|<| %name%" always "%name% *|&|::|<| %name%"
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "namespace|class|struct|union|private:|protected:|public:" always "namespace|class|struct|union|private:|protected:|public:"
Line 5766
  ( always {!<=-1,!>=2}
  "%type% (" always "%type% ("
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "%type% (" always "%type% ("
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "noexcept|throw" always "noexcept|throw"
  && always {!<=-1,!>=2}
  ":;{" always ":;{"
Line 5770
  ( always {!<=-1,!>=2}
  "namespace|class|struct|union" always "namespace|class|struct|union"
Line 5773
  tok3 possible {symbolic=(tok2),0}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  tok3 {symbolic=(tok2),!0}
  "[;{}()]" always "[;{}()]"
Line 5774
  tok3 always !0
Line 5775
  tok3 possible {symbolic=(tok2),0}
  && always {!<=-1,!>=2}
  tok3 always !0
  == always {!<=-1,!>=2}
  "{" always "{"
Line 5793
  ( always {!<=-1,!>=2}
  "%type% :: %type%" always "%type% :: %type%"
Line 5795
  ( always {!<=-1,!>=2}
  tok3 possible symbolic=(tok2)
  "%type% :: %type% ::" always "%type% :: %type% ::"
Line 5796
  2 always 2
Line 5797
  ( always {!<=-1,!>=2}
  tok3 possible symbolic=(tok2)
  "%type% :: %type% (" always "%type% :: %type% ("
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  2 always 2
Line 5806
  == always {!<=-1,!>=2}
  "{" always "{"
Line 5808
  prev possible {symbolic=(tok->previous()),0}
  && always {!<=-1,!>=2}
  prev {symbolic=(tok->previous()),!0}
  ( always {!<=-1,!>=2}
Line 5809
  prev always !0
Line 5810
  prev possible {symbolic=(tok->previous()),0}
  && always {!<=-1,!>=2}
  prev always !0
  == always {!<=-1,!>=2}
  ")" always ")"
Line 5820
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 0
  C89 always 0
Line 5822
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 0
  CPP03 always 0
Line 5825
  ( always {!<=-1,!>=2}
  "_Pragma (" always "_Pragma ("
Line 5826
  1 always 1
Line 5837
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "class|struct %name% %name% {|:" always "class|struct %name% %name% {|:"
Line 5840
  nextIsUppercase always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 5841
  afterNextIsUppercase always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  2 always 2
  ( always {!<=-1,!>=2}
Line 5842
  nextIsUppercase {!<=-1,!>=2,0}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  afterNextIsUppercase always {!<=-1,!>=2}
Line 5844
  ! {!<=-1,!>=2,1}
  nextIsUppercase {!<=-1,!>=2,0}
  && always {!<=-1,!>=2}
  afterNextIsUppercase always {!<=-1,!>=2}
Line 5854
  ( always {!<=-1,!>=2}
  "[;{}] %name% (" always "[;{}] %name% ("
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 5857
  = always 0
  0 always 0
Line 5858
  tok2 possible symbolic=(tok)
Line 5859
  tok2 {symbolic=(tok),!0}
  ( possible size=1
  == always {!<=-1,!>=2}
  "(" always "("
Line 5861
  tok2 always !0
  == always {!<=-1,!>=2}
  ")" always ")"
Line 5862
  <= always {!<=-1,!>=2}
  0 always 0
Line 5865
  tok2 always !0
Line 5867
  = possible 0
  tok2 possible {symbolic=(tok),0}
  ? possible 0
  tok2 always !0
  : always 0
  nullptr always 0
Line 5870
  = possible 0
  tok2 possible 0
Line 5871
  tok3 possible {symbolic=(tok2),0}
  && always {!<=-1,!>=2}
  tok3 {symbolic=(tok2),!0}
  ( always {!<=-1,!>=2}
Line 5872
  tok3 always !0
Line 5873
  tok3 possible {symbolic=(tok2),0}
  && always {!<=-1,!>=2}
  tok3 always !0
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  tok3 always !0
  "const|static|struct|union|class" always "const|static|struct|union|class"
Line 5882
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 5885
  != always {!<=-1,!>=2}
  ")" always ")"
Line 5887
  ( always !0
  : always 0
  nullptr always 0
Line 5888
  ! always {!<=-1,!>=2}
  macro always symbolic=(tok->link()?tok->link()->previous():nullptr)
  || always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  macro {symbolic=(tok->link()?tok->link()->previous():nullptr),!0}
  ( always {!<=-1,!>=2}
Line 5890
  ( always {!<=-1,!>=2}
  ") try" always ") try"
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  macro {symbolic=(tok->link()?tok->link()->previous():nullptr),!0}
  "if|for|while" always "if|for|while"
Line 5891
  ";" always ";"
Line 5892
  ( always {!<=-1,!>=2}
  ") using" always ") using"
Line 5893
  ";" always ";"
Line 5900
  tok possible symbolic=(start->previous())
Line 5901
  == always {!<=-1,!>=2}
  "{" always "{"
Line 5906
  start always !0
Line 5909
  tok always symbolic=(start->previous())
Line 5910
  tok always symbolic=(start->previous())
  && always {!<=-1,!>=2}
  tok2 always !0
  != always {!<=-1,!>=2}
  end always symbolic=(tok->next()->link())
Line 5912
  ( always {!<=-1,!>=2}
  "class|struct %type% {|:" always "class|struct %type% {|:"
Line 5914
  2 always 2
Line 5915
  tok2 possible 0
  && always {!<=-1,!>=2}
  tok2 always !0
  != always {!<=-1,!>=2}
  "{" always "{"
Line 5916
  tok2 always !0
Line 5918
  tok2 possible 0
Line 5919
  tok2 always !0
Line 5922
  ( always {!<=-1,!>=2}
  "[;{}] %type% * %name% ;" always "[;{}] %type% * %name% ;"
  && always {!<=-1,!>=2}
  != always {!<=-1,!>=2}
  "return" always "return"
Line 5923
  3 always 3
Line 5925
  ( always {!<=-1,!>=2}
  "[;{}] %type% %name% ;" always "[;{}] %type% %name% ;"
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 5926
  2 always 2
Line 5928
  && always {!<=-1,!>=2}
Line 5929
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "[;{}] %name% = %char%|%num%|%name% ;" always "[;{}] %name% = %char%|%num%|%name% ;"
Line 5930
  ( always !0
Line 5933
  0 always 0
Line 5934
  ! {!<=-1,!>=2,0}
  localvars possible size=0
  ( {!<=-1,!>=2,1}
Line 5935
  tok always symbolic=(start->previous())
  && always {!<=-1,!>=2}
  tok2 always !0
  != always {!<=-1,!>=2}
  end always symbolic=(tok->next()->link())
Line 5936
  ( always {!<=-1,!>=2}
  "[;{}] %type% %name% ;" always "[;{}] %type% %name% ;"
  && always {!<=-1,!>=2}
  localvars always !size=0
  ( {lifetime[Iterator]=(localvars),!size=0}
  2 always 2
  != always {!<=-1,!>=2}
  localvars always !size=0
  ( {lifetime[Iterator]=(localvars),!size=0,end=0}
Line 5937
  3 always 3
Line 5938
  ( always {!<=-1,!>=2}
  "[;{}] %type% * %name% ;" always "[;{}] %type% * %name% ;"
  && always {!<=-1,!>=2}
Line 5939
  localvars always !size=0
  ( {lifetime[Iterator]=(localvars),!size=0}
  3 always 3
  != always {!<=-1,!>=2}
  localvars always !size=0
  ( {lifetime[Iterator]=(localvars),!size=0,end=0}
  || always {!<=-1,!>=2}
Line 5940
  ( always {!<=-1,!>=2}
  "[;{}] %name% = %any% ;" always "[;{}] %name% = %any% ;"
  && always {!<=-1,!>=2}
Line 5941
  localvars always !size=0
  ( {lifetime[Iterator]=(localvars),!size=0}
  != always {!<=-1,!>=2}
  localvars always !size=0
  ( {lifetime[Iterator]=(localvars),!size=0,end=0}
Line 5942
  4 always 4
Line 5954
  ( always {!<=-1,!>=2}
  "(|[" always "(|["
  || always {!<=-1,!>=2}
Line 5955
  == always {!<=-1,!>=2}
  "{" always "{"
  && always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always !0
  == always {!<=-1,!>=2}
  "=" always "="
Line 5957
  ( always {!<=-1,!>=2}
  "[;{}] %name% = realloc (" always "[;{}] %name% = realloc ("
Line 5958
  3 always 3
Line 5959
  ( always {!<=-1,!>=2}
  "( 0 ," always "( 0 ,"
Line 5961
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  ") ;" always ") ;"
  || always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  3 always 3
Line 5965
  2 always 2
Line 5968
  "malloc" always "malloc"
Line 5971
  -2 always -2
Line 5973
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  ", 0 ) ;" always ", 0 ) ;"
  || always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  2 always 2
Line 5978
  2 always 2
Line 5980
  "free" always "free"
Line 5983
  "0" always "0"
Line 5988
  ";" always ";"
Line 5998
  ( always {!<=-1,!>=2}
Line 6001
  goback always {!<=-1,!>=2}
  goback always {!<=-1,!>=2}
  = always 0
  false always 0
Line 6002
  = possible 0
  ? possible 0
  : always 0
  nullptr always 0
Line 6003
  goback always {!<=-1,!>=2}
Line 6005
  goback always {!<=-1,!>=2}
  = always 0
  false always 0
Line 6007
  ( always {!<=-1,!>=2}
  "(|[|{" always "(|[|{"
Line 6011
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "namespace %name%| {" always "namespace %name%| {"
Line 6013
  isAnonymousNS always {!<=-1,!>=2}
  isAnonymousNS always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  1 always 1
  == always {!<=-1,!>=2}
  "{" always "{"
Line 6014
  3 always 3
  - always {!>=4,!<=1}
  isAnonymousNS always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  "}" always "}"
Line 6015
  3 always 3
  - always {!>=4,!<=1}
  isAnonymousNS always {!<=-1,!>=2}
Line 6016
  ! always {!<=-1,!>=2}
Line 6019
  goback always {!<=-1,!>=2}
  = always 1
  true always 1
Line 6021
  = always !0
  ( always !0
Line 6022
  tok always !0
Line 6023
  tok always !0
  == always {!<=-1,!>=2}
  "{" always "{"
Line 6025
  tok always !0
  -2 always -2
  tok always !0
  -2 always -2
  tok always !0
Line 6026
  goback always {!<=-1,!>=2}
  = always 1
  true always 1
Line 6030
  2 always 2
  - always {!>=3,!<=0}
  isAnonymousNS always {!<=-1,!>=2}
Line 6037
  begin possible symbolic=(end)
Line 6039
  ( always {!<=-1,!>=2}
  "(|[" always "(|["
  || always {!<=-1,!>=2}
Line 6040
  == always {!<=-1,!>=2}
  "{" always "{"
  && always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  -1 always -1
  == always {!<=-1,!>=2}
  "=" always "="
Line 6044
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  ") {" always ") {"
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  ") %name% {" always ") %name% {"
Line 6047
  1 always 1
  == always {!<=-1,!>=2}
  "{" always "{"
  0 always 0
  : always 1
  1 always 1
Line 6048
  = always 0
  0 always 0
Line 6049
  stilldead always {!<=-1,!>=2}
  stilldead always {!<=-1,!>=2}
  = always 0
  false always 0
Line 6051
  && always {!<=-1,!>=2}
  tok always !0
  != always {!<=-1,!>=2}
  tok possible symbolic=(tok2)
Line 6052
  ( always {!<=-1,!>=2}
  "(|[" always "(|["
Line 6057
  ( possible size=1
  == always {!<=-1,!>=2}
  "{" always "{"
Line 6058
  && always {!<=-1,!>=2}
  ( always !0
  == always {!<=-1,!>=2}
  "=" always "="
Line 6063
  == always {!<=-1,!>=2}
  "}" always "}"
Line 6064
  indentLevel possible 2
  == {!<=-1,!>=2,0}
  0 always 0
Line 6066
  -- {1,!-1}
  indentLevel {2,!0}
Line 6067
  stilldead always {!<=-1,!>=2}
Line 6068
  nullptr always 0
Line 6069
  indentLevel always !-1
  == always {!<=-1,!>=2}
  1 always 1
  || always {!<=-1,!>=2}
  != always {!<=-1,!>=2}
  "}" always "}"
  || always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  ";|{|}|do {" always ";|{|}|do {"
Line 6070
  stilldead always {!<=-1,!>=2}
  = always 0
  false always 0
Line 6075
  == always {!<=-1,!>=2}
  0 always 0
Line 6078
  ( always {!<=-1,!>=2}
  "continue|break ;" always "continue|break ;"
Line 6080
  nullptr always 0
Line 6082
  ( always {!<=-1,!>=2}
  "return|goto" always "return|goto"
  || always {!<=-1,!>=2}
Line 6083
  ( always {!<=-1,!>=2}
  "[;{}] %name% (" always "[;{}] %name% ("
  && always {!<=-1,!>=2}
Line 6084
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
Line 6085
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  "throw" always "throw"
Line 6086
  == always {!<=-1,!>=2}
  "}" always "}"
Line 6091
  ( always {!<=-1,!>=2}
  "(|[" always "(|["
Line 6093
  == always {!<=-1,!>=2}
  ";" always ";"
Line 6095
  tok always symbolic=(tok2)
  nullptr always 0
Line 6097
  ( always {!<=-1,!>=2}
  "[{}]" always "[{}]"
Line 6102
  indentLevel always !0
  > always {!<=-1,!>=2}
  1 always 1
  && always {!<=-1,!>=2}
  tok possible symbolic=(tok2)
  == always {!<=-1,!>=2}
  "}" always "}"
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  tok possible symbolic=(tok2)
  ";|{|}|do {" always ";|{|}|do {"
Line 6103
  stilldead always {!<=-1,!>=2}
  = always 1
  true always 1
Line 6111
  ( always {!<=-1,!>=2}
Line 6114
  ret always {!<=-1,!>=2}
  ret always {!<=-1,!>=2}
  = always 0
  false always 0
Line 6117
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "if ( %bool% ) {" always "if ( %bool% ) {"
Line 6121
  4 always 4
Line 6123
  boolValue always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  2 always 2
  == always {!<=-1,!>=2}
  "true" always "true"
Line 6126
  ( always {!<=-1,!>=2}
  "else {" always "else {"
Line 6128
  ! always {!<=-1,!>=2}
  boolValue always {!<=-1,!>=2}
Line 6132
  3 always 3
Line 6148
  3 always 3
Line 6152
  ret always {!<=-1,!>=2}
  = always 1
  true always 1
Line 6157
  ! always {!<=-1,!>=2}
  boolValue always {!<=-1,!>=2}
Line 6159
  3 always 3
Line 6166
  3 always 3
Line 6170
  ret always {!<=-1,!>=2}
  = always 1
  true always 1
Line 6174
  return always {!<=-1,!>=2}
  ret {!<=-1,!>=2,0}
Line 6180
  ( always {!<=-1,!>=2}
  "[;{}] for ( %name% = %num% ; %name% < %num% ; ++| %name% ++| ) {" always "[;{}] for ( %name% = %num% ; %name% < %num% ; ++| %name% ++| ) {"
  || always {!<=-1,!>=2}
Line 6181
  ( always {!<=-1,!>=2}
  "[;{}] for ( %type% %name% = %num% ; %name% < %num% ; ++| %name% ++| ) {" always "[;{}] for ( %type% %name% = %num% ; %name% < %num% ; ++| %name% ++| ) {"
Line 6183
  3 always 3
Line 6184
  type always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 6185
  type {symbolic=(varTok->next()->isName()),!<=-1,!>=2}
Line 6187
  :: possible symbolic=(tok2->str())
  varname possible symbolic=(tok2->str())
Line 6189
  varname possible symbolic=(tok2->str())
  != always {!<=-1,!>=2}
  4 always 4
Line 6191
  2 always 2
Line 6192
  == always {!<=-1,!>=2}
  "++" always "++"
Line 6194
  -1 always -1
  != always {!<=-1,!>=2}
  "++" always "++"
Line 6196
  varname possible symbolic=(tok2->str())
  != always {!<=-1,!>=2}
Line 6200
  2 always 2
Line 6201
  num2 possible symbolic=(num1+1)
  6 always 6
Line 6202
  1 always 1
  != always {!<=-1,!>=2}
Line 6206
  read always {!<=-1,!>=2}
  read always {!<=-1,!>=2}
  = always 0
  false always 0
Line 6207
  write always {!<=-1,!>=2}
  write always {!<=-1,!>=2}
  = always 0
  false always 0
Line 6208
  2 always 2
Line 6209
  2 always 2
  != always {!<=-1,!>=2}
Line 6210
  == always {!<=-1,!>=2}
  varname always symbolic=(vartok2->str())
Line 6211
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 6212
  && always {!<=-1,!>=2}
Line 6213
  ( always !0
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  ( always !0
  == always {!<=-1,!>=2}
  ";" always ";"
Line 6214
  read always {!<=-1,!>=2}
  = always 1
  true always 1
Line 6216
  read always {!<=-1,!>=2}
  = always 1
  write always {!<=-1,!>=2}
  = always 1
  true always 1
Line 6223
  ! {!<=-1,!>=2,1}
  write {!<=-1,!>=2,0}
Line 6224
  2 always 2
Line 6226
  2 always 2
Line 6230
  type {!<=-1,!>=2,0}
Line 6231
  "{" always "{"
Line 6234
  6 always 6
Line 6235
  read always {!<=-1,!>=2}
Line 6237
  4 always 4
Line 6240
  4 always 4
Line 6244
  7 always 7
Line 6246
  ! {!<=-1,!>=2,0,1}
  type {!<=-1,!>=2,1,0}
Line 6250
  tok2 always symbolic=(tok->next()->link())
  ";" always ";"
Line 6251
  tok2 always symbolic=(tok->next()->link())
  num2 always symbolic=(num1+1)
Line 6252
  tok2 always symbolic=(tok->next()->link())
  "=" always "="
Line 6253
  tok2 always symbolic=(tok->next()->link())
  varname always symbolic=(vartok2->str())
Line 6254
  tok2 always symbolic=(tok->next()->link())
Line 6265
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  "(" always "("
Line 6266
  = always !0
  ( always !0
Line 6270
  ( always {!<=-1,!>=2}
  "; ;" always "; ;"
Line 6272
  ( always {!<=-1,!>=2}
  "; { ; }" always "; { ; }"
Line 6273
  3 always 3
Line 6282
  ( always {!<=-1,!>=2}
Line 6286
  ! always {!<=-1,!>=2}
Line 6287
  return always {!<=-1,!>=2}
  false always 0
Line 6289
  return always {!<=-1,!>=2}
  true always 1
Line 6295
  ( always {!<=-1,!>=2}
  tok always symbolic=(tokEnd)
  "for|switch|BOOST_FOREACH" always "for|switch|BOOST_FOREACH"
Line 6296
  = inconclusive lifetime[Object]=(tok)
  ( inconclusive lifetime[Object]=(tok)
  tok always symbolic=(tokEnd)
  true always 1
Line 6297
  tok always symbolic=(tokEnd)
  ( possible size=2
  == {!<=-1,!>=2,0}
  "while" always "while"
Line 6298
  tok always symbolic=(tokEnd)
Line 6299
  ( always {!<=-1,!>=2}
  tok always symbolic=(tokEnd)
  ( always symbolic=(tokPossibleDo)
  "{" always "{"
Line 6300
  = always 0
  nullptr always 0
Line 6301
  ( always {!<=-1,!>=2}
  tokPossibleDo always symbolic=(tok->previous())
  "}" always "}"
Line 6302
  tokPossibleDo always symbolic=(tok->previous())
Line 6303
  ! {!<=-1,!>=2,1}
  tokPossibleDo possible 0
  || always {!<=-1,!>=2}
  tokPossibleDo always !0
  -1 always -1
  != always {!<=-1,!>=2}
  "do" always "do"
Line 6304
  = inconclusive lifetime[Object]=(tok)
  ( inconclusive lifetime[Object]=(tok)
  tok always symbolic=(tokEnd)
  true always 1
Line 6305
  tok always symbolic=(tokEnd)
  ( possible size=2
  == always {!<=-1,!>=2}
  "do" always "do"
Line 6306
  = inconclusive lifetime[Object]=(tok)
  ( inconclusive lifetime[Object]=(tok)
  tok always symbolic=(tokEnd)
  false always 0
Line 6307
  tokEnd {lifetime[Object]=(tok),0}
  != always {!<=-1,!>=2}
Line 6311
  tokEnd {lifetime[Object]=(tok),!symbolic=(tok)}
Line 6312
  tokEnd {lifetime[Object]=(tok),!symbolic=(tok),!0}
Line 6313
  ! always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  tokEnd always !0
  != always {!<=-1,!>=2}
  "while" always "while"
Line 6317
  tok always symbolic=(tokEnd)
  == always {!<=-1,!>=2}
  "if" always "if"
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  tok always symbolic=(tokEnd)
  -2 always -2
  "operator \"\"" always "operator \"\""
Line 6318
  = inconclusive lifetime[Object]=(tok)
  ( inconclusive lifetime[Object]=(tok)
  tok always symbolic=(tokEnd)
  true always 1
Line 6319
  ! always {!<=-1,!>=2}
  tokEnd inconclusive lifetime[Object]=(tok)
Line 6320
  nullptr always 0
Line 6321
  tokEnd {lifetime[Object]=(tok),!0}
  1 always 1
  == always {!<=-1,!>=2}
  "else" always "else"
Line 6322
  tokEnd {lifetime[Object]=(tok),!0}
  2 always 2
Line 6323
  ! always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  tokEndNextNext always !0
  == always {!<=-1,!>=2}
  "}" always "}"
Line 6324
  tokEndNextNext possible 0
Line 6325
  tokEndNextNext always !0
  == always {!<=-1,!>=2}
  "if" always "if"
Line 6327
  tokEndNextNext always !0
Line 6329
  tokEnd always !0
  false always 0
Line 6333
  tokEnd inconclusive {lifetime[Object]=(tok),lifetime[Object]=(tok),lifetime[Object]=(tok)}
Line 6336
  , always {!<=-1,!>=2}
  commandWithCondition always {!<=-1,!>=2}
Line 6338
  tok possible symbolic=(tokEnd)@209
Line 6339
  ! always {!<=-1,!>=2}
  tokCondition always symbolic=(tok->next())
Line 6342
  = {symbolic=(tok->next()),!0}
  tokCondition {symbolic=(tok->next()),!0}
Line 6343
  commandWithCondition {!<=-1,!>=2,1@209,0@218}
Line 6344
  tokCondition {symbolic=(tok->next()),symbolic=(tokAfterCondition),!0}
  == always {!<=-1,!>=2}
  "(" always "("
Line 6345
  tokCondition {symbolic=(tok->next()),symbolic=(tokAfterCondition),!0}
Line 6349
  ! always {!<=-1,!>=2}
  tokAfterCondition possible symbolic=(tokCondition->link())
  || always {!<=-1,!>=2}
  tokAfterCondition always !0
  1 always 1
  == always {!<=-1,!>=2}
  "]" always "]"
Line 6352
  tokAfterCondition always !0
Line 6353
  ! always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  tokAfterCondition always !0
  ")|}|," always ")|}|,"
Line 6359
  = possible symbolic=(tokCondition)
  tokAfterCondition possible symbolic=(tokCondition)
Line 6360
  true always 1
Line 6361
  ( always {!<=-1,!>=2}
  tokStatement possible {symbolic=(tokAfterCondition),symbolic=(tokCondition)}
  "%name% :" always "%name% :"
Line 6362
  2 always 2
Line 6363
  == always {!<=-1,!>=2}
  "case" always "case"
Line 6365
  ! always {!<=-1,!>=2}
Line 6367
  tokStatement always !0
  != always {!<=-1,!>=2}
  ":" always ":"
Line 6368
  tokStatement always !0
Line 6369
  tokStatement always !0
Line 6372
  ! always {!<=-1,!>=2}
Line 6375
  = always 0
  nullptr always 0
Line 6376
  tokStatement possible symbolic=(tokAfterCondition)
  == always {!<=-1,!>=2}
  "{" always "{"
Line 6378
  != always {!<=-1,!>=2}
Line 6380
  tokStatement always !symbolic=(tokAfterCondition)
  tokStatement always !symbolic=(tokAfterCondition)
  tokAfterCondition always !symbolic=(tokStatement)
Line 6382
  tokStatement possible symbolic=(tokAfterCondition)
Line 6383
  ( always {!<=-1,!>=2}
  "try {" always "try {"
  && always {!<=-1,!>=2}
Line 6384
  ( always {!<=-1,!>=2}
  1 always 1
  "} catch (" always "} catch ("
Line 6385
  "{" always "{"
Line 6387
  1 always 1
  2 always 2
  1 always 1
Line 6388
  ! always {!<=-1,!>=2}
Line 6391
  tokEnd always !0
  "}" always "}"
Line 6392
  tokEnd always !0
Line 6394
  tokOpenBrace always symbolic=(tokAfterCondition->previous())
  tokCloseBrace always symbolic=(tokEnd->next())
Line 6395
  = always symbolic=(tokEnd->next())
  tokCloseBrace always symbolic=(tokEnd->next())
Line 6398
  ! always {!<=-1,!>=2}
Line 6400
  tokEnd always !0
  != always {!<=-1,!>=2}
  "}" always "}"
Line 6403
  tokEnd possible 0
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  tokEnd always !0
  ";|)|}" always ";|)|}"
Line 6404
  tokEnd always !0
  == always {!<=-1,!>=2}
  :: always 18
  eBracket always 18
  || always {!<=-1,!>=2}
  tokEnd always !0
  == always {!<=-1,!>=2}
  "(" always "("
Line 6405
  tokEnd always !0
Line 6406
  ! always {!<=-1,!>=2}
Line 6413
  ! always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  tokEnd always !0
  != always {!<=-1,!>=2}
  ";" always ";"
Line 6419
  "{" always "{"
Line 6422
  "}" always "}"
Line 6425
  tokOpenBrace always symbolic=(tokAfterCondition->previous())
  tokCloseBrace always symbolic=(tokEnd->next())
Line 6426
  = always symbolic=(tokEnd->next())
  tokCloseBrace always symbolic=(tokEnd->next())
Line 6429
  tokBracesEnd possible {symbolic=(tokStatement->link()),symbolic=(tokCloseBrace),symbolic=(tokCloseBrace),symbolic=(tokEnd->next()),symbolic=(tokEnd->next())}
Line 6436
  tok possible symbolic=(tok1)
Line 6437
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "[;{}] (| *| (| %name%" always "[;{}] (| *| (| %name%"
Line 6439
  == always {!<=-1,!>=2}
  "return" always "return"
Line 6444
  tok always symbolic=(tok1)
  == always {!<=-1,!>=2}
  "*" always "*"
Line 6445
  tok always symbolic=(tok1)
Line 6447
  tok possible symbolic=(tok1)
  && always {!<=-1,!>=2}
  ( always !0
  == always {!<=-1,!>=2}
  "(" always "("
Line 6448
  ( always !0
Line 6451
  2 always 2
Line 6452
  ( always {!<=-1,!>=2}
  tok possible 0
  ". %name%" always ". %name%"
  || always {!<=-1,!>=2}
Line 6453
  ( always {!<=-1,!>=2}
  "[|(" always "[|("
Line 6454
  == always {!<=-1,!>=2}
  "." always "."
Line 6455
  2 always 2
Line 6461
  = possible 0
  ? possible 0
  tok always !0
  : always 0
  nullptr always 0
Line 6465
  ! always {!<=-1,!>=2}
Line 6469
  tok always !0
Line 6471
  tok always !0
  ( {!<=-1,!>=2,0}
  && always {!<=-1,!>=2}
  str always {symbolic=(tok->str()),symbolic=(str)}
  ( always !<=-1
  == always {!<=-1,!>=2}
  2 always 2
Line 6472
  str always {symbolic=(tok->str()),symbolic=(str),size=2}
  0 always 0
  1 always 1
Line 6473
  tok always !0
  ( {!<=-1,!>=2,0}
  && always {!<=-1,!>=2}
  str always {symbolic=(tok->str()),symbolic=(str)}
  ( always !<=-1
  == always {!<=-1,!>=2}
  3 always 3
Line 6474
  str always {symbolic=(tok->str()),symbolic=(str),size=3}
  0 always 0
  2 always 2
Line 6481
  ( always {!<=-1,!>=2}
  "+=|-= 0 ;" always "+=|-= 0 ;"
  || always {!<=-1,!>=2}
Line 6482
  ( always {!<=-1,!>=2}
  "|= 0 ;" always "|= 0 ;"
  || always {!<=-1,!>=2}
Line 6483
  ( always {!<=-1,!>=2}
  "*=|/= 1 ;" always "*=|/= 1 ;"
Line 6485
  tok always symbolic=(tok1)
  != always {!<=-1,!>=2}
  ";" always ";"
Line 6486
  tok always symbolic=(tok1)
Line 6489
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  2 always 2
  "[;)]" always "[;)]"
Line 6491
  someOperator always {!<=-1,!>=2}
  someOperator always {!<=-1,!>=2}
  = always 0
  false always 0
Line 6493
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "{|[|(" always "{|[|("
Line 6494
  = always !0
  ( always !0
Line 6496
  ( always {!<=-1,!>=2}
  "[;)]" always "[;)]"
Line 6497
  someOperator always {!<=-1,!>=2}
Line 6498
  "(" always "("
Line 6499
  ")" always ")"
Line 6505
  someOperator always {!<=-1,!>=2}
  |= always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  "?" always "?"
Line 6510
  "=" always "="
Line 6514
  && always {!<=-1,!>=2}
  tok2 always !0
  != always {!<=-1,!>=2}
Line 6517
  == always {!<=-1,!>=2}
  :: always 16
  eIncDecOp always 16
Line 6519
  ( always {!<=-1,!>=2}
Line 6532
  ( always {!<=-1,!>=2}
  "]|)|}" always "]|)|}"
Line 6534
  ( always {!<=-1,!>=2}
  "(|[|{" always "(|[|{"
Line 6543
  ( always {!<=-1,!>=2}
Line 6545
  ret always {!<=-1,!>=2}
  ret always {!<=-1,!>=2}
  = always 0
  false always 0
Line 6548
  ( always {!<=-1,!>=2}
  "! %bool%|%num%" always "! %bool%|%num%"
Line 6550
  ( always {!<=-1,!>=2}
  "0|false" always "0|false"
Line 6551
  "true" always "true"
Line 6553
  "false" always "false"
Line 6555
  ret always {!<=-1,!>=2}
  = always 1
  true always 1
Line 6558
  ( always {!<=-1,!>=2}
  "&& true &&" always "&& true &&"
Line 6559
  2 always 2
Line 6560
  ret always {!<=-1,!>=2}
  = always 1
  true always 1
Line 6563
  ( always {!<=-1,!>=2}
  "|| false ||" always "|| false ||"
Line 6564
  2 always 2
Line 6565
  ret always {!<=-1,!>=2}
  = always 1
  true always 1
Line 6568
  ( always {!<=-1,!>=2}
  "(|&& true && true &&|)" always "(|&& true && true &&|)"
Line 6569
  2 always 2
Line 6570
  ret always {!<=-1,!>=2}
  = always 1
  true always 1
Line 6573
  ( always {!<=-1,!>=2}
  "%oror%|( false %oror% false %oror%|)" always "%oror%|( false %oror% false %oror%|)"
Line 6574
  2 always 2
Line 6575
  ret always {!<=-1,!>=2}
  = always 1
  true always 1
Line 6578
  ( always {!<=-1,!>=2}
  "( true ||" always "( true ||"
  || always {!<=-1,!>=2}
Line 6579
  ( always {!<=-1,!>=2}
  "( false &&" always "( false &&"
Line 6581
  ret always {!<=-1,!>=2}
  = always 1
  true always 1
Line 6584
  ( always {!<=-1,!>=2}
  "|| true )" always "|| true )"
  || always {!<=-1,!>=2}
Line 6585
  ( always {!<=-1,!>=2}
  "&& false )" always "&& false )"
Line 6588
  ret always {!<=-1,!>=2}
  = always 1
  true always 1
Line 6591
  ( always {!<=-1,!>=2}
  "&& false &&" always "&& false &&"
  || always {!<=-1,!>=2}
Line 6592
  ( always {!<=-1,!>=2}
  "|| true ||" always "|| true ||"
Line 6595
  tok2 possible symbolic=(tok)
  && always {!<=-1,!>=2}
  tok2 {symbolic=(tok),!0}
Line 6596
  tok2 always !0
  ( always !0
  == always {!<=-1,!>=2}
  ")" always ")"
Line 6597
  tok2 always !0
  ( always !0
Line 6599
  = always !0
  tok2 always !0
  ( always !0
Line 6600
  tok2 always !0
  == always {!<=-1,!>=2}
  "(" always "("
Line 6604
  ! {!<=-1,!>=2,1}
  tok2 possible {symbolic=(tok),0}
Line 6609
  tok2 always !0
Line 6611
  tok2 always !0
Line 6612
  ret always {!<=-1,!>=2}
  = always 1
  true always 1
Line 6616
  ( always {!<=-1,!>=2}
  "if|while ( %num% )|%oror%|&&" always "if|while ( %num% )|%oror%|&&"
Line 6617
  2 always 2
  2 always 2
  != always {!<=-1,!>=2}
  "0" always "0"
  "true" always "true"
  : always "false"
  "false" always "false"
Line 6618
  ret always {!<=-1,!>=2}
  = always 1
  true always 1
Line 6620
  ( always {!<=-1,!>=2}
  "&&|%oror% %num% )|%oror%|&&" always "&&|%oror% %num% )|%oror%|&&"
Line 6621
  != always {!<=-1,!>=2}
  "0" always "0"
  "true" always "true"
  : always "false"
  "false" always "false"
Line 6622
  ret always {!<=-1,!>=2}
  = always 1
  true always 1
Line 6626
  ( always {!<=-1,!>=2}
  "&&|%oror%|(" always "&&|%oror%|("
  && always {!<=-1,!>=2}
Line 6627
  ( always {!<=-1,!>=2}
  "%num% %any% %num%" always "%num% %any% %num%"
  || always {!<=-1,!>=2}
Line 6628
  ( always {!<=-1,!>=2}
  "%bool% %any% %bool%" always "%bool% %any% %bool%"
  && always {!<=-1,!>=2}
Line 6629
  ( always {!<=-1,!>=2}
  4 always 4
  "&&|%oror%|)|?" always "&&|%oror%|)|?"
Line 6630
  2 always 2
Line 6631
  result always {!<=-1,!>=2}
  result always {!<=-1,!>=2}
  = always 0
  false always 0
Line 6632
  ( always {!<=-1,!>=2}
Line 6635
  cmp possible {size=2,size=1}
  == {!<=-1,!>=2,0}
  "==" always "=="
  || always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  "!=" always "!="
Line 6637
  3 always 3
Line 6639
  eq always {!<=-1,!>=2}
  eq always {!<=-1,!>=2}
  = always 0
  false always 0
Line 6640
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 6641
  eq always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
Line 6643
  eq always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
Line 6646
  ! always {!<=-1,!>=2}
  eq {symbolic=(op1==op2),!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 6647
  cmp always NonMovedVariable
Line 6650
  cmp possible {NonMovedVariable,size=0}
  == {!<=-1,!>=2,0}
  "==" always "=="
Line 6651
  result always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  eq always {!<=-1,!>=2}
Line 6653
  result always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  eq always {!<=-1,!>=2}
Line 6656
  3 always 3
Line 6657
  cmp possible {size=1,size=2}
  == {!<=-1,!>=2,0}
  ">=" always ">="
Line 6658
  result always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  op1 always symbolic=(MathLib::toDoubleNumber(tok->next()->str()))
  >= always {!<=-1,!>=2}
Line 6659
  cmp possible {size=2,size=1}
  == {!<=-1,!>=2,0}
  ">" always ">"
Line 6660
  result always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  op1 always symbolic=(MathLib::toDoubleNumber(tok->next()->str()))
  > always {!<=-1,!>=2}
Line 6661
  cmp possible size=1
  == {!<=-1,!>=2,0}
  "<=" always "<="
Line 6662
  result always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  op1 always symbolic=(MathLib::toDoubleNumber(tok->next()->str()))
  <= always {!<=-1,!>=2}
Line 6663
  == always {!<=-1,!>=2}
  "<" always "<"
Line 6664
  result always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  op1 always symbolic=(MathLib::toDoubleNumber(tok->next()->str()))
  < always {!<=-1,!>=2}
Line 6666
  cmp always NonMovedVariable
Line 6670
  op1 always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  "true" always "true"
Line 6671
  op2 always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  3 always 3
  == always {!<=-1,!>=2}
  "true" always "true"
Line 6673
  cmp possible {size=2,size=1}
  == {!<=-1,!>=2,0}
  "==" always "=="
Line 6674
  result always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  op1 always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  op2 always {!<=-1,!>=2}
Line 6675
  cmp possible {size=2,size=1}
  == {!<=-1,!>=2,0}
  "!=" always "!="
Line 6676
  result always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  op1 always {!<=-1,!>=2}
  != always {!<=-1,!>=2}
  op2 always {!<=-1,!>=2}
Line 6677
  cmp possible {size=1,size=2}
  == {!<=-1,!>=2,0}
  ">=" always ">="
Line 6678
  result always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  op1 always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  op2 always {!<=-1,!>=2}
Line 6679
  cmp possible {size=2,size=1}
  == {!<=-1,!>=2,0}
  ">" always ">"
Line 6680
  result always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  op1 always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  op2 always {!<=-1,!>=2}
Line 6681
  cmp possible size=1
  == {!<=-1,!>=2,0}
  "<=" always "<="
Line 6682
  result always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  op1 always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  op2 always {!<=-1,!>=2}
Line 6683
  == always {!<=-1,!>=2}
  "<" always "<"
Line 6684
  result always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  op1 always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  op2 always {!<=-1,!>=2}
Line 6686
  cmp always NonMovedVariable
Line 6689
  ! {!<=-1,!>=2,0,1}
  cmp possible {NonMovedVariable,size=0,size=2}
  ( {!<=-1,!>=2,1,0}
Line 6691
  2 always 2
Line 6693
  result always {!<=-1,!>=2}
  ? possible {"true","false"}
  "true" always "true"
  : always "false"
  "false" always "false"
Line 6694
  ret always {!<=-1,!>=2}
  = always 1
  true always 1
Line 6699
  return always {!<=-1,!>=2}
  ret {!<=-1,!>=2,0}
Line 6702
  ( always {!<=-1,!>=2}
Line 6704
  ret always {!<=-1,!>=2}
  ret always {!<=-1,!>=2}
  = always 0
  false always 0
Line 6705
  = always 0
  nullptr always 0
Line 6707
  == always {!<=-1,!>=2}
  "<" always "<"
  && always {!<=-1,!>=2}
  ( always !<=-1
Line 6709
  == always {!<=-1,!>=2}
  templateParameterEnd possible symbolic=(tok->findClosingBracket())
Line 6710
  = always 0
  nullptr always 0
Line 6711
  != always {!<=-1,!>=2}
  "?" always "?"
Line 6714
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  -2 always -2
  "<|=|,|(|[|{|}|;|case|return %bool%|%num%" always "<|=|,|(|[|{|}|;|case|return %bool%|%num%"
  && always {!<=-1,!>=2}
Line 6715
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  -4 always -4
  "<|=|,|(|[|{|}|;|case|return ( %bool%|%num% )" always "<|=|,|(|[|{|}|;|case|return ( %bool%|%num% )"
Line 6718
  == always {!<=-1,!>=2}
  ")" always ")"
  2 always 2
  : always 1
  1 always 1
Line 6720
  -2 always -2
  offset always symbolic=((tok->previous()->str()==")")?2:1)
  == always {!<=-1,!>=2}
  "<" always "<"
Line 6721
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always !<=-1
  -2 always -2
  offset always symbolic=((tok->previous()->str()==")")?2:1)
Line 6727
  ! always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  colon always !0
  != always {!<=-1,!>=2}
  ":" always ":"
  || always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  colon always !0
Line 6731
  colon always !0
  == always {!<=-1,!>=2}
Line 6735
  -2 always -2
Line 6736
  == always {!<=-1,!>=2}
  2 always 2
Line 6738
  -2 always -2
Line 6744
  ( always {!<=-1,!>=2}
  "false|0" always "false|0"
Line 6746
  colon always !0
Line 6749
  ret always {!<=-1,!>=2}
  = always 1
  true always 1
Line 6755
  2 always 2
Line 6757
  = always 0
  0 always 0
Line 6758
  = always !0
  colon always !0
Line 6759
  ( always {!<=-1,!>=2}
  "(|[|{" always "(|[|{"
Line 6761
  ( possible size=1
  == always {!<=-1,!>=2}
  "<" always "<"
  && always {!<=-1,!>=2}
  1 always 1
  == always {!<=-1,!>=2}
  ">" always ">"
  || always {!<=-1,!>=2}
  ( always !<=-1
Line 6763
  ( possible size=1
  == always {!<=-1,!>=2}
  "?" always "?"
Line 6765
  ( always {!<=-1,!>=2}
  ")|}|]|;|,|:|>" always ")|}|]|;|,|:|>"
Line 6766
  ( possible size=1
  == always {!<=-1,!>=2}
  ":" always ":"
  && always {!<=-1,!>=2}
Line 6767
  -- always !-1
  ternaryOplevel always !0
Line 6768
  == always {!<=-1,!>=2}
  ">" always ">"
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
Line 6771
  colon always !0
  -2 always -2
Line 6772
  ret always {!<=-1,!>=2}
  = always 1
  true always 1
Line 6779
  return always {!<=-1,!>=2}
  ret {!<=-1,!>=2,0}
Line 6784
  tok possible symbolic=(end)
Line 6785
  ( always {!<=-1,!>=2}
  "%type%" always "%type%"
Line 6787
  tok2 possible symbolic=(tok->next())
  && always {!<=-1,!>=2}
  tok2 {symbolic=(tok->next()),!0}
  == always {!<=-1,!>=2}
  "*" always "*"
Line 6788
  tok2 always !0
Line 6789
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  tok2 possible {symbolic=(tok->next()),0}
  "%name% [ ] ;|[" always "%name% [ ] ;|["
Line 6794
  = always 0
  0 always 0
Line 6796
  end possible symbolic=(tok2->next())
  2 always 2
Line 6797
  ++ possible 1
  count possible 0
Line 6798
  ( always {!<=-1,!>=2}
  "[ ] [;=[]" always "[ ] [;=[]"
Line 6799
  ( always {!<=-1,!>=2}
  "[;=]" always "[;=]"
Line 6801
  2 always 2
Line 6802
  "*" always "*"
Line 6806
  tok always symbolic=(tok2->previous())
  3 always 3
Line 6818
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 6819
  ( always {!<=-1,!>=2}
  "* (" always "* ("
  && always {!<=-1,!>=2}
Line 6820
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  2 always 2
  ") %name%|&" always ") %name%|&"
Line 6821
  2 always 2
Line 6826
  == always {!<=-1,!>=2}
  "(" always "("
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  ") [" always ") ["
Line 6831
  ( always {!<=-1,!>=2}
  "( %type% ) %num%" always "( %type% ) %num%"
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 6834
  ! always {!<=-1,!>=2}
  2 always 2
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  > always {!<=-1,!>=2}
  0 always 0
Line 6835
  bits {>=1,!<=0}
  -- {>=1,!<=0}
Line 6836
  < always {!<=-1,!>=2}
  31 always 31
  && always {!<=-1,!>=2}
  >= always {!<=-1,!>=2}
  0 always 0
  && always {!<=-1,!>=2}
  value {>=0,!<=-1}
  < always {!<=-1,!>=2}
  1LL always 1
  << possible <=1073741824
  bits {<=30,!>=31}
Line 6837
  1 always 1
  true always 1
Line 6843
  ( always {!<=-1,!>=2}
  "( %type% *| *| *|&| ) *|&| %name%" always "( %type% *| *| *|&| ) *|&| %name%"
  && always {!<=-1,!>=2}
  != always {!<=-1,!>=2}
  ")" always ")"
  || always {!<=-1,!>=2}
  2 always 2
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
Line 6844
  ( always {!<=-1,!>=2}
  "( const| %type% * *| *|&| ) *|&| %name%" always "( const| %type% * *| *|&| ) *|&| %name%"
  || always {!<=-1,!>=2}
Line 6845
  ( always {!<=-1,!>=2}
  "( const| %type% %type% *| *| *|&| ) *|&| %name%" always "( const| %type% %type% *| *| *|&| ) *|&| %name%"
  || always {!<=-1,!>=2}
Line 6846
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "( %type% * *| *|&| ) (" always "( %type% * *| *|&| ) ("
  || always {!<=-1,!>=2}
Line 6847
  ( always {!<=-1,!>=2}
  "( const| %type% %type% * *| *|&| ) (" always "( const| %type% %type% * *| *|&| ) ("
Line 6848
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  != always {!<=-1,!>=2}
  "return" always "return"
Line 6851
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  -1 always -1
  == always {!<=-1,!>=2}
  "operator" always "operator"
Line 6859
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  tok2 always symbolic=(tok->next())
  "%name% [|." always "%name% [|."
Line 6860
  tok2 always symbolic=(tok->next())
  true always 1
Line 6863
  tok2 always symbolic=(tok->next())
  true always 1
Line 6867
  ( always {!<=-1,!>=2}
  "* &" always "* &"
Line 6872
  == always {!<=-1,!>=2}
  ")" always ")"
  && always {!<=-1,!>=2}
Line 6875
  = always !0
  ( always !0
Line 6880
  ( always {!<=-1,!>=2}
  "( %type% %type%| * *| ) 0" always "( %type% %type%| * *| ) 0"
Line 6881
  1 always 1
  true always 1
Line 6883
  == always {!<=-1,!>=2}
  ")" always ")"
  && always {!<=-1,!>=2}
Line 6886
  = always !0
  ( always !0
Line 6890
  ( always {!<=-1,!>=2}
  "dynamic_cast|reinterpret_cast|const_cast|static_cast <" always "dynamic_cast|reinterpret_cast|const_cast|static_cast <"
Line 6891
  2 always 2
Line 6892
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "> (" always "> ("
Line 6895
  2 always 2
  true always 1
Line 6905
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "{|[|(" always "{|[|("
Line 6906
  = always !0
  ( always !0
Line 6910
  ( always {!<=-1,!>=2}
  "%name% ( %name% [,)]" always "%name% ( %name% [,)]"
  && always {!<=-1,!>=2}
Line 6911
  ! always {!<=-1,!>=2}
  -1 always -1
  == always {!<=-1,!>=2}
  ":" always ":"
  || always {!<=-1,!>=2}
  -1 always -1
  == always {!<=-1,!>=2}
  "," always ","
  || always {!<=-1,!>=2}
  -1 always -1
  == always {!<=-1,!>=2}
  "::" always "::"
Line 6916
  bailOut always {!<=-1,!>=2}
  bailOut always {!<=-1,!>=2}
  = always 0
  false always 0
Line 6917
  = always 0
  nullptr always 0
Line 6925
  nullptr always 0
  != always {!<=-1,!>=2}
  tok1 possible symbolic=(tok)
  2 always 2
Line 6926
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  tok1 always !0
  "%name% [,)]" always "%name% [,)]"
Line 6927
  bailOut always {!<=-1,!>=2}
  = always 1
  true always 1
Line 6932
  ( possible lifetime[Iterator]=(argumentNames)
  tok1 always !0
  ( possible symbolic=(funcName)
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(argumentNames),end=0}
Line 6933
  = always !0
  tok1 always !0
Line 6934
  tok1 always !0
  != always {!<=-1,!>=2}
Line 6935
  tok1 always !0
  ( always !symbolic=(funcName)
  = always !0
  tok1 always !0
Line 6937
  tok1 always !0
  == always {!<=-1,!>=2}
  ")" always ")"
Line 6938
  tok1 always !0
  == always {!<=-1,!>=2}
  "," always ","
Line 6939
  tok1 always !0
  -2 always -2
Line 6940
  2 always 2
Line 6942
  tok1 always !0
Line 6944
  bailOut always {!<=-1,!>=2}
  = always 1
  true always 1
Line 6948
  tok1 always !0
  -2 always -2
Line 6949
  2 always 2
Line 6953
  tok1 possible {symbolic=(tokparam),symbolic=(argumentNames[tok1->str()])}
  == always {!<=-1,!>=2}
  ")" always ")"
Line 6954
  2 always 2
Line 6956
  ! always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  tok1 always !0
  ( always {!<=-1,!>=2}
Line 6957
  bailOut always {!<=-1,!>=2}
  = always 1
  true always 1
Line 6965
  bailOut {!<=-1,!>=2,0,1}
Line 6973
  = always symbolic=(tok->link()->next())
  tok1 always symbolic=(tok->link()->next())
  tok2 possible symbolic=(tok->link()->next())
Line 6974
  ( always {!<=-1,!>=2}
  tok2 possible symbolic=(tok->link()->next())
  "; {" always "; {"
Line 6976
  == always {!<=-1,!>=2}
  "{" always "{"
Line 6977
  bailOut always {!<=-1,!>=2}
  = always 1
  true always 1
Line 6982
  bailOut {!<=-1,!>=2,1}
Line 6990
  tok1 possible symbolic=(tok->link()->next())
  && always {!<=-1,!>=2}
  tok1 always !0
  != always {!<=-1,!>=2}
  "{" always "{"
Line 6991
  ( always {!<=-1,!>=2}
  tok1 always !0
  "(|)" always "(|)"
Line 6992
  bailOut always {!<=-1,!>=2}
  = always 1
  true always 1
Line 6995
  tok1 always !0
  == always {!<=-1,!>=2}
  ";" always ";"
Line 6997
  tokparam always !0
Line 7000
  tok2 possible symbolic=(tok1->previous())
  == always {!<=-1,!>=2}
  "]" always "]"
Line 7004
  ! always {!<=-1,!>=2}
  tok2 possible symbolic=(tok1->previous())
  ( always {!<=-1,!>=2}
Line 7005
  bailOut always {!<=-1,!>=2}
  = always 1
  true always 1
Line 7009
  ( possible lifetime[Iterator]=(argumentNames2)
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(argumentNames2),end=0}
Line 7015
  ( possible lifetime[Iterator]=(argumentNames)
  tok2 possible symbolic=(argumentNames2[tok2->str()])
  == always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(argumentNames),end=0}
Line 7017
  bailOut always {!<=-1,!>=2}
  = always 1
  true always 1
Line 7021
  tok1 always !0
Line 7024
  bailOut {!<=-1,!>=2,1}
  || always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
Line 7031
  ( always !<=-1
  != always {!<=-1,!>=2}
  ( always !<=-1
Line 7033
  tok1 always !0
Line 7035
  ( possible lifetime[Iterator]=(argumentNames2)
  == always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(argumentNames2),end=0}
Line 7037
  ";" always ";"
Line 7041
  "int" always "int"
Line 7046
  tok possible symbolic=(declEnd->next())
  != always {!<=-1,!>=2}
  ")" always ")"
Line 7049
  = always symbolic=(argumentNames2[tok->next()->str()])
  declStart always symbolic=(argumentNames2[tok->next()->str()])
Line 7050
  declStart possible {symbolic=(argumentNames2[tok->next()->str()]),symbolic=(declEnd)}
  != always {!<=-1,!>=2}
  ";" always ";"
  && always {!<=-1,!>=2}
  declStart possible {symbolic=(argumentNames2[tok->next()->str()]),symbolic=(declEnd)}
  != always {!<=-1,!>=2}
  ")" always ")"
Line 7052
  declEnd possible {symbolic=(declStart),symbolic=(argumentNames2[tok->next()->str()])}
  != always {!<=-1,!>=2}
  ";" always ";"
  && always {!<=-1,!>=2}
  declEnd possible symbolic=(argumentNames2[tok->next()->str()])
  != always {!<=-1,!>=2}
  "{" always "{"
Line 7056
  declEnd possible symbolic=(argumentNames2[tok->next()->str()])
Line 7059
  declEnd possible symbolic=(argumentNames2[tok->next()->str()])
Line 7062
  declEnd possible symbolic=(argumentNames2[tok->next()->str()])
Line 7065
  tok always symbolic=(declEnd->next())
  == always {!<=-1,!>=2}
  "," always ","
Line 7066
  tok always symbolic=(declEnd->next())
  tok always symbolic=(declEnd->next())
Line 7069
  tok possible symbolic=(declEnd->next())
Line 7076
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 7080
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "& %name% [ 0 ] !![" always "& %name% [ 0 ] !!["
Line 7083
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "[,(=]" always "[,(=]"
Line 7087
  5 always 5
Line 7090
  ! always {!<=-1,!>=2}
Line 7092
  tok always !0
Line 7101
  ( always {!<=-1,!>=2}
  ") (" always ") ("
Line 7107
  ( always {!<=-1,!>=2}
  "( %type% %type%| *| *| ( * ) (" always "( %type% %type%| *| *| ( * ) ("
  || always {!<=-1,!>=2}
Line 7108
  ( always {!<=-1,!>=2}
  "static_cast < %type% %type%| *| *| ( * ) (" always "static_cast < %type% %type%| *| *| ( * ) ("
Line 7111
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  tok1 always symbolic=(tok)
  == always {!<=-1,!>=2}
  "static_cast" always "static_cast"
Line 7112
  tok1 always symbolic=(tok)
Line 7114
  tok1 possible symbolic=(tok)
Line 7116
  ( always {!<=-1,!>=2}
  "%type%" always "%type%"
Line 7119
  == always {!<=-1,!>=2}
  "*" always "*"
Line 7123
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  4 always 4
  ") )|>" always ") )|>"
Line 7129
  2 always 2
Line 7134
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  ( always !0
  "{|}|;|,|(|public:|protected:|private:" always "{|}|;|,|(|public:|protected:|private:"
Line 7137
  ( always {!<=-1,!>=2}
  "delete|else|return|throw|typedef" always "delete|else|return|throw|typedef"
Line 7140
  ( always {!<=-1,!>=2}
  "%type%|:: %type%|::" always "%type%|:: %type%|::"
Line 7143
  && always {!<=-1,!>=2}
  tok always !0
  ( always {!<=-1,!>=2}
  tok always !0
  : always 0
  nullptr always 0
Line 7144
  ( always {!<=-1,!>=2}
  tok2 possible {symbolic=((tok&&tok->isName())?tok->next():nullptr),0}
  "*|&" always "*|&"
Line 7146
  ! always {!<=-1,!>=2}
  tok2 possible symbolic=((tok&&tok->isName())?tok->next():nullptr)
  || always {!<=-1,!>=2}
  tok2 always !0
  != always {!<=-1,!>=2}
  "(" always "("
Line 7148
  ( always {!<=-1,!>=2}
  "(|:: %type%" always "(|:: %type%"
Line 7149
  2 always 2
Line 7150
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "(|:: * *| %name%" always "(|:: * *| %name%"
Line 7152
  2 always 2
Line 7153
  == always {!<=-1,!>=2}
  "*" always "*"
Line 7155
  ( always {!<=-1,!>=2}
  "%type%|:: %type%|::" always "%type%|:: %type%|::"
Line 7158
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "%name% ) (" always "%name% ) ("
  && always {!<=-1,!>=2}
Line 7159
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "%name% [ ] ) (" always "%name% [ ] ) ("
  && always {!<=-1,!>=2}
Line 7160
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "%name% (" always "%name% ("
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  1 always 1
  ") ) (" always ") ) ("
Line 7163
  tok possible 0
  && always {!<=-1,!>=2}
  tok always !0
  != always {!<=-1,!>=2}
  "(" always "("
Line 7164
  tok always !0
Line 7167
  ! {!<=-1,!>=2,1}
  tok possible 0
  || always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  tok always !0
  || always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  tok always !0
  ( always !0
Line 7168
  nullptr always 0
Line 7170
  tok always !0
  ( always !0
  ( always !0
Line 7171
  ( always {!<=-1,!>=2}
  endTok always symbolic=(tok->link()->next()->link())
  ") throw (" always ") throw ("
Line 7172
  endTok always symbolic=(tok->link()->next()->link())
  2 always 2
Line 7173
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  endTok possible symbolic=(tok->link()->next()->link())
  ") const|volatile| const|volatile| ;|,|)|=|[|{" always ") const|volatile| const|volatile| ;|,|)|=|[|{"
Line 7176
  ( always {!<=-1,!>=2}
  "const|volatile" always "const|volatile"
Line 7180
  tok always !0
  ( always !0
Line 7181
  ( always {!<=-1,!>=2}
  tok always !0
  ( always !0
  ") )" always ") )"
Line 7184
  tok always !0
  ( always !0
Line 7185
  tok always !0
Line 7189
  tok always !0
  ( always !0
  "(" always "("
Line 7190
  = always !0
  tok always !0
  ( always !0
  ( always !0
Line 7191
  par1 {symbolic=(tok->link()->next()),!0}
  ")" always ")"
Line 7192
  par1 {symbolic=(tok->link()->next()),!0}
  par1 {symbolic=(tok->link()->next()),!0}
Line 7193
  par1 {symbolic=(tok->link()->next()),!0}
  par1 {symbolic=(tok->link()->next()),!0}
Line 7194
  ( always {!<=-1,!>=2}
  tok always !0
  "( %type% ::" always "( %type% ::"
Line 7195
  tok always !0
  2 always 2
Line 7201
  ( always {!<=-1,!>=2}
Line 7205
  tok possible {symbolic=(any),symbolic=(functions[tok->str()])}
Line 7206
  == always {!<=-1,!>=2}
  "{" always "{"
Line 7209
  ( always {!<=-1,!>=2}
  "%name% ( ) { return %bool%|%char%|%num%|%str% ; }" always "%name% ( ) { return %bool%|%char%|%num%|%str% ; }"
  && always {!<=-1,!>=2}
  -1 always -1
  != always {!<=-1,!>=2}
  "::" always "::"
Line 7210
  5 always 5
Line 7212
  = always symbolic=(functions[tok->str()])
  any always symbolic=(functions[tok->str()])
Line 7216
  functions possible size=0
  ( {!<=-1,!>=2,1}
Line 7217
  return always {!<=-1,!>=2}
  false always 0
Line 7219
  ret always {!<=-1,!>=2}
  ret always {!<=-1,!>=2}
  = always 0
  false always 0
Line 7221
  ( always {!<=-1,!>=2}
  "(|[|=|return|%op% %name% ( ) ;|]|)|%cop%" always "(|[|=|return|%op% %name% ( ) ;|]|)|%cop%"
Line 7223
  = {lifetime[Iterator]=(functions),!size=0}
  functions always !size=0
  ( {lifetime[Iterator]=(functions),!size=0}
Line 7224
  it {lifetime[Iterator]=(functions),symbolic=(functions.find(tok->str())),!size=0}
  != always {!<=-1,!>=2}
  functions always !size=0
  ( {lifetime[Iterator]=(functions),!size=0,end=0}
Line 7225
  it {lifetime[Iterator]=(functions),!symbolic=(functions.cend()),!end=0,!size=0}
Line 7226
  2 always 2
Line 7227
  ret always {!<=-1,!>=2}
  = always 1
  true always 1
Line 7232
  return always {!<=-1,!>=2}
  ret {!<=-1,!>=2,0}
Line 7235
  only_k_r_fpar always {!<=-1,!>=2}
Line 7237
  nullptr always 0
  only_k_r_fpar {!<=-1,!>=2,0@142,1}
Line 7240
  , always {!<=-1,!>=2}
  only_k_r_fpar always {!<=-1,!>=2}
Line 7242
  isCPP11 always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  >= always {!<=-1,!>=2}
  :: always 1
  CPP11 always 1
Line 7246
  finishedwithkr always {!<=-1,!>=2}
  finishedwithkr always {!<=-1,!>=2}
  = always 1
  true always 1
Line 7247
  scopeDecl always {!<=-1,!>=2}
  scopeDecl always {!<=-1,!>=2}
  = always 0
  false always 0
Line 7248
  != always {!<=-1,!>=2}
  tokEnd possible 0@87
Line 7249
  ( always {!<=-1,!>=2}
  "{|;" always "{|;"
Line 7250
  scopeDecl always {!<=-1,!>=2}
  = always 0
  false always 0
Line 7251
  ( always {!<=-1,!>=2}
Line 7252
  ( always {!<=-1,!>=2}
  "class|struct|namespace|union" always "class|struct|namespace|union"
Line 7253
  scopeDecl always {!<=-1,!>=2}
  = always 1
  true always 1
Line 7254
  ( always {!<=-1,!>=2}
  "decltype|noexcept (" always "decltype|noexcept ("
Line 7257
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  tok always !0
  ") {" always ") {"
Line 7258
  tok always !0
Line 7259
  ( always {!<=-1,!>=2}
  "= {" always "= {"
  || always {!<=-1,!>=2}
Line 7260
  ! always {!<=-1,!>=2}
  scopeDecl always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "%name%|> {" always "%name%|> {"
  && always {!<=-1,!>=2}
Line 7261
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "else|try|do|const|constexpr|override|volatile|noexcept" always "else|try|do|const|constexpr|override|volatile|noexcept"
Line 7262
  ! always {!<=-1,!>=2}
Line 7265
  ( always {!<=-1,!>=2}
  -2 always -2
  ") . %name%" always ") . %name%"
Line 7267
  -2 always -2
Line 7268
  ( always {!<=-1,!>=2}
  "]" always "]"
Line 7272
  lambdaEnd always !0
  lambdaEnd always !0
  only_k_r_fpar always {!<=-1,!>=2}
Line 7274
  != always {!<=-1,!>=2}
Line 7276
  ! always {!<=-1,!>=2}
Line 7278
  lambdaEnd always !0
  lambdaEnd always !0
  only_k_r_fpar always {!<=-1,!>=2}
Line 7284
  ( always {!<=-1,!>=2}
  "= {" always "= {"
Line 7287
  ! always {!<=-1,!>=2}
Line 7290
  only_k_r_fpar {!<=-1,!>=2,1@87}
  && always {!<=-1,!>=2}
  finishedwithkr always {!<=-1,!>=2}
Line 7291
  ( always {!<=-1,!>=2}
  tok always !0
  "(|[|{" always "(|[|{"
Line 7292
  tok always !0
Line 7293
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  ") !!{" always ") !!{"
Line 7294
  = always !0
  ( always !0
Line 7299
  tok always !0
  == always {!<=-1,!>=2}
  "(" always "("
Line 7300
  ( always {!<=-1,!>=2}
Line 7301
  = always !0
  tok always !0
  && always {!<=-1,!>=2}
  tok2 always !0
  != always {!<=-1,!>=2}
  tok always !0
Line 7302
  ( always {!<=-1,!>=2}
  "[(,] [" always "[(,] ["
Line 7306
  lambdaBody possible {symbolic=(tok2),symbolic=(tok2->link()),0}
  && always {!<=-1,!>=2}
  lambdaBody {symbolic=(tok2),!0}
  != always {!<=-1,!>=2}
  tok2 possible symbolic=(lambdaBody)
  && always {!<=-1,!>=2}
  lambdaBody {symbolic=(tok2),!symbolic=(tok2->link()),!0}
  != always {!<=-1,!>=2}
  "{" always "{"
Line 7307
  lambdaBody always {!symbolic=(tok2->link()),!0}
Line 7308
  lambdaBody possible {symbolic=(tok2),symbolic=(tok2->link()),0}
  && always {!<=-1,!>=2}
  lambdaBody always !0
  != always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  lambdaBody always {!symbolic=(tok2->link()),!0}
Line 7309
  lambdaBody always {!symbolic=(tok2->link()),!0}
  lambdaBody always {!symbolic=(tok2->link()),!0}
  only_k_r_fpar always {!<=-1,!>=2}
Line 7313
  tok always !0
Line 7316
  ! always {!<=-1,!>=2}
Line 7317
  nullptr always 0
Line 7318
  tok always !0
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  tok always !0
  ( always !0
  "{|}|;|)|public:|protected:|private:" always "{|}|;|)|public:|protected:|private:"
Line 7320
  ( always {!<=-1,!>=2}
  tok always !0
  "template <" always "template <"
Line 7324
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  type0 always symbolic=(tok)
  "::|extern| %type%" always "::|extern| %type%"
Line 7326
  ( always {!<=-1,!>=2}
  type0 always symbolic=(tok)
  "else|return|public:|protected:|private:" always "else|return|public:|protected:|private:"
Line 7328
  isCPP11 always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  "using" always "using"
Line 7330
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  "namespace" always "namespace"
Line 7333
  isconst always {!<=-1,!>=2}
  isconst always {!<=-1,!>=2}
  = always 0
  false always 0
Line 7334
  isstatic always {!<=-1,!>=2}
  isstatic always {!<=-1,!>=2}
  = always 0
  false always 0
Line 7336
  = always 1
  1 always 1
Line 7338
  ( always {!<=-1,!>=2}
  tok2 always symbolic=(type0)
  "::|extern" always "::|extern"
Line 7339
  tok2 always symbolic=(type0)
Line 7340
  typelen always 1
  ++ always 1
Line 7344
  tok2 possible symbolic=(type0)
Line 7345
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  tok2 always !0
  "const|static|constexpr" always "const|static|constexpr"
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  tok2 always !0
  "%type% const|static" always "%type% const|static"
Line 7346
  tok2 always !0
Line 7350
  ( always {!<=-1,!>=2}
  "const|constexpr" always "const|constexpr"
Line 7351
  isconst always {!<=-1,!>=2}
  = always 1
  true always 1
Line 7353
  ( always {!<=-1,!>=2}
  "static|constexpr" always "static|constexpr"
Line 7354
  isstatic always {!<=-1,!>=2}
  = always 1
  true always 1
Line 7356
  ( always {!<=-1,!>=2}
  "%type% :: %type%" always "%type% :: %type%"
Line 7364
  1 always 1
  == always {!<=-1,!>=2}
  "*" always "*"
Line 7367
  ( always {!<=-1,!>=2}
  "& %name% ," always "& %name% ,"
Line 7375
  ( always {!<=-1,!>=2}
  "%type% *|&| %name% , %type% *|&| %name%" always "%type% *|&| %name% , %type% *|&| %name%"
Line 7378
  ( always {!<=-1,!>=2}
  "struct|union|class %type%" always "struct|union|class %type%"
Line 7384
  ( always {!<=-1,!>=2}
  ":: %type%" always ":: %type%"
Line 7390
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "%type% <" always "%type% <"
  || always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "%type% ::" always "%type% ::"
Line 7391
  == always {!<=-1,!>=2}
  "<" always "<"
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always !<=-1
Line 7392
  = always 0
  nullptr always 0
Line 7395
  2 always 2
Line 7396
  2 always 2
Line 7397
  && always {!<=-1,!>=2}
  tok2 always !0
  == always {!<=-1,!>=2}
  "::" always "::"
Line 7399
  = always 0
  0 always 0
Line 7400
  = always 0
  0 always 0
Line 7402
  = possible 0
  tok2 possible 0
  tok3 possible 0
Line 7405
  ! {!<=-1,!>=2,1}
  parens possible 0
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  "<" always "<"
Line 7407
  ! {!<=-1,!>=2,1}
  parens possible 0
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  ">" always ">"
Line 7408
  == always {!<=-1,!>=2}
  0 always 0
Line 7412
  -- always !-1
  indentlevel always !0
Line 7413
  ! {!<=-1,!>=2,1}
  parens possible 0
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  ">>" always ">>"
Line 7414
  <= always {!<=-1,!>=2}
  1 always 1
Line 7418
  indentlevel {!<=1,>=2}
  2 always 2
Line 7419
  ( possible size=1
  == always {!<=-1,!>=2}
  "(" always "("
Line 7421
  ( possible size=1
  == always {!<=-1,!>=2}
  ")" always ")"
Line 7422
  ! always {!<=-1,!>=2}
Line 7423
  = always 0
  nullptr always 0
Line 7426
  -- always !-1
  parens always !0
Line 7427
  == always {!<=-1,!>=2}
  ";" always ";"
Line 7432
  ( always {!<=-1,!>=2}
  tok2 possible {symbolic=(tok3->next()),0}
  ":: %type%" always ":: %type%"
Line 7438
  ( always {!<=-1,!>=2}
  tok2 possible symbolic=(tok3->next())
  "const" always "const"
Line 7439
  isconst always {!<=-1,!>=2}
  = always 1
  true always 1
Line 7443
  ( always {!<=-1,!>=2}
  tok2 possible 0
  "%type%" always "%type%"
  || always {!<=-1,!>=2}
Line 7444
  && always {!<=-1,!>=2}
  tok2 always !0
  && always {!<=-1,!>=2}
  tok2 always !0
  ( always !0
  == always {!<=-1,!>=2}
  ">" always ">"
Line 7446
  ! always {!<=-1,!>=2}
  tok2 always symbolic=(varName)
  || always {!<=-1,!>=2}
  tok2 always symbolic=(varName)
  ( always !0
  != always {!<=-1,!>=2}
  ">" always ">"
Line 7447
  varName always symbolic=(tok2)
Line 7451
  isPointerOrRef always {!<=-1,!>=2}
  isPointerOrRef always {!<=-1,!>=2}
  = always 0
  false always 0
Line 7452
  ( always {!<=-1,!>=2}
  varName possible symbolic=(tok2)
  "*" always "*"
  || always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "& %name% ," always "& %name% ,"
Line 7453
  isPointerOrRef always {!<=-1,!>=2}
  = always 1
  true always 1
Line 7457
  ( always {!<=-1,!>=2}
  "%type% %type%" always "%type% %type%"
Line 7458
  ( possible size=8
  != {!<=-1,!>=2,1}
  "const" always "const"
  && always {!<=-1,!>=2}
  != always {!<=-1,!>=2}
  "volatile" always "volatile"
Line 7464
  ( always {!<=-1,!>=2}
  "( *" always "( *"
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "%name% ) ( ) =" always "%name% ) ( ) ="
Line 7465
  2 always 2
Line 7467
  ";" always ";"
Line 7469
  true always 1
Line 7474
  ( always {!<=-1,!>=2}
  "%name% ,|=" always "%name% ,|="
Line 7475
  != always {!<=-1,!>=2}
  "operator" always "operator"
Line 7478
  tok2 always symbolic=(varName->next())
  == always {!<=-1,!>=2}
  "=" always "="
  && always {!<=-1,!>=2}
  isstatic always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  isconst always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  isPointerOrRef always {!<=-1,!>=2}
Line 7480
  tok2 possible {symbolic=(varName->next()),0}
  && always {!<=-1,!>=2}
  tok2 {symbolic=(varName->next()),!0}
  != always {!<=-1,!>=2}
  "," always ","
  && always {!<=-1,!>=2}
  tok2 {symbolic=(varName->next()),!0}
  != always {!<=-1,!>=2}
  ";" always ";"
Line 7481
  ( always {!<=-1,!>=2}
  tok2 always !0
  "{|(|[" always "{|(|["
Line 7482
  tok2 always !0
Line 7484
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  tok2 always symbolic=(tok3)
  == always {!<=-1,!>=2}
  "<" always "<"
  && always {!<=-1,!>=2}
  ( always !<=-1
  tok2 always symbolic=(tok3)
  > always {!<=-1,!>=2}
  0 always 0
Line 7485
  tok2 always symbolic=(tok3)
Line 7487
  ! always {!<=-1,!>=2}
  tok2 possible symbolic=(tok3)
Line 7489
  tok2 always !0
Line 7491
  tok2 possible symbolic=(varName->next())
  && always {!<=-1,!>=2}
  tok2 always !0
  == always {!<=-1,!>=2}
  ";" always ";"
Line 7492
  = always 0
  nullptr always 0
Line 7495
  = always 0
  nullptr always 0
Line 7499
  ( always {!<=-1,!>=2}
  "%name% [" always "%name% ["
Line 7502
  ( always {!<=-1,!>=2}
  tok2 possible symbolic=(varName->next())
  "] ,|=|[" always "] ,|=|["
Line 7504
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  tok2 possible symbolic=(varName->next())
  "=|," always "=|,"
Line 7505
  = always 0
  nullptr always 0
Line 7506
  tok2 possible 0
  && always {!<=-1,!>=2}
  tok2 always !0
  == always {!<=-1,!>=2}
  "=" always "="
Line 7507
  tok2 possible 0
  && always {!<=-1,!>=2}
  tok2 always !0
  ( possible size=1
  != always {!<=-1,!>=2}
  "," always ","
  && always {!<=-1,!>=2}
  tok2 always !0
  != always {!<=-1,!>=2}
  ";" always ";"
Line 7508
  ( always {!<=-1,!>=2}
  tok2 always !0
  "{|(|[" always "{|(|["
Line 7509
  tok2 always !0
Line 7512
  && always {!<=-1,!>=2}
  tok2 always !0
  == always {!<=-1,!>=2}
  ";" always ";"
Line 7513
  = always 0
  nullptr always 0
Line 7518
  ( always {!<=-1,!>=2}
  "%name% {" always "%name% {"
Line 7520
  tok2 always symbolic=(varName->next())
Line 7522
  tok2 always !0
Line 7523
  && always {!<=-1,!>=2}
  tok2 always !0
  != always {!<=-1,!>=2}
  "," always ","
Line 7524
  = always 0
  nullptr always 0
Line 7530
  ( always {!<=-1,!>=2}
  "%name% (" always "%name% ("
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  1 always 1
  ") ," always ") ,"
Line 7531
  1 always 1
Line 7535
  = always 0
  nullptr always 0
Line 7537
  = always 0
  nullptr always 0
Line 7540
  ! {!<=-1,!>=2,1}
  tok2 possible {symbolic=(varName->next()),0}
Line 7541
  only_k_r_fpar always {!<=-1,!>=2}
Line 7542
  finishedwithkr always {!<=-1,!>=2}
  = always 0
  false always 0
Line 7546
  tok2 always !0
  == always {!<=-1,!>=2}
  "," always ","
Line 7547
  tok2 always !0
  ";" always ";"
Line 7548
  tok2 always !0
  true always 1
Line 7550
  tok2 always !0
Line 7554
  = always !0
  tok2 always !0
Line 7556
  tok2 possible symbolic=(eq)
Line 7557
  ( always {!<=-1,!>=2}
  tok2 {symbolic=(eq),!0}
  "{|(|[" always "{|(|["
Line 7558
  tok2 always !0
Line 7560
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  tok2 always !0
  == always {!<=-1,!>=2}
  "<" always "<"
  && always {!<=-1,!>=2}
  tok2 always !0
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  tok2 always !0
Line 7561
  tok2 always !0
Line 7563
  ";," always ";,"
  tok2 always !0
  ( possible size=1
  0 always 0
Line 7566
  ( always {!<=-1,!>=2}
  varTok possible 0
  "%name%|*|& %name%|*|&" always "%name%|*|& %name%|*|&"
Line 7568
  ! always {!<=-1,!>=2}
Line 7569
  tok2 always !0
Line 7570
  eq always !0
  varTok always !0
  2 always 2
Line 7571
  eq always !0
  ";" always ";"
Line 7572
  eq always !0
  true always 1
Line 7575
  tok2 always !0
  == always {!<=-1,!>=2}
  "," always ","
Line 7576
  tok2 always !0
  ";" always ";"
Line 7577
  tok2 always !0
  true always 1
Line 7578
  tok2 always !0
Line 7583
  tok2 always !0
Line 7586
  finishedwithkr always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  only_k_r_fpar always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  tok2 always !0
  1 always 1
  == always {!<=-1,!>=2}
  "{" always "{"
Line 7594
  3 always 3
  "extern" always "extern"
  "static" always "static"
  "const" always "const"
Line 7599
  continue2 always {!<=-1,!>=2}
  continue2 always {!<=-1,!>=2}
  = always 0
  false always 0
Line 7600
  = always 0
  0 always 0
  i possible 0
  < {!<=-1,!>=2,1}
  ( always !<=-1
  qualifiers always {
  / always 3
  ( always !<=-1
  qualifiers always {
Line 7603
  ! always {!<=-1,!>=2}
  tok possible {symbolic=(list.front()),symbolic=(leftTok->next()),symbolic=(leftTok)}
  || always {!<=-1,!>=2}
  ( always !0
  != always {!<=-1,!>=2}
  qualifiers always {
  i always {!>=3,!<=-1}
Line 7608
  behindOther always {!<=-1,!>=2}
  behindOther always {!<=-1,!>=2}
  = always 0
  false always 0
Line 7609
  leftTok possible symbolic=(tok)
Line 7610
  = always 0
  0 always 0
  j possible {0,1}
  <= always {!<=-1,!>=2}
  i always !<=-1
  j possible 0
  ++ possible 0
Line 7611
  == always {!<=-1,!>=2}
  qualifiers always {
  j {<=symbolic=(i),!>=symbolic=(i+1),0}
Line 7612
  behindOther always {!<=-1,!>=2}
  = always 1
  true always 1
Line 7616
  behindOther {!<=-1,!>=2,1}
Line 7618
  ( {!<=-1,!>=2,0}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  ">" always ">"
Line 7620
  opening always symbolic=(leftTok->findOpeningBracket())
Line 7621
  = {symbolic=(leftTok->findOpeningBracket()),!0}
  opening {symbolic=(leftTok->findOpeningBracket()),!0}
Line 7625
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "%type%|struct|::" always "%type%|struct|::"
  || always {!<=-1,!>=2}
Line 7626
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "private:|protected:|public:|operator|template" always "private:|protected:|public:|operator|template"
Line 7632
  leftTok possible {symbolic=(tok),0}
  == {!<=-1,!>=2,1}
  tok possible symbolic=(leftTok)
Line 7635
  leftTok {!symbolic=(tok),0}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  behindOther always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  leftTok always {!symbolic=(tok),!0}
  ";|{|}|(|,|private:|protected:|public:" always ";|{|}|(|,|private:|protected:|public:"
Line 7636
  continue2 always {!<=-1,!>=2}
  = always 1
  true always 1
Line 7641
  tok always !symbolic=(leftTok)
Line 7642
  ! {!<=-1,!>=2,1}
  leftTok {!symbolic=(tok),0}
Line 7643
  qualifiers always {
  false always 0
Line 7646
  leftTok always {!symbolic=(tok),!0}
Line 7647
  leftTok always {!symbolic=(tok),!0}
  ( always !0
  qualifiers always {
  true always 1
Line 7648
  = always !0
  leftTok always {!symbolic=(tok),!0}
  ( always !0
Line 7650
  leftTok always {!symbolic=(tok),!0}
  qualifiers always {
Line 7651
  = always {!symbolic=(tok),!0}
  leftTok always {!symbolic=(tok),!0}
Line 7654
  continue2 {!<=-1,!>=2,1}
Line 7662
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "if|while (" always "if|while ("
Line 7665
  3 always 3
Line 7666
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "!| (| %name% =" always "!| (| %name% ="
  && always {!<=-1,!>=2}
Line 7667
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "!| (| %name% . %name% =" always "!| (| %name% . %name% ="
  && always {!<=-1,!>=2}
Line 7668
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "0 == (| %name% =" always "0 == (| %name% ="
  && always {!<=-1,!>=2}
Line 7669
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "0 == (| %name% . %name% =" always "0 == (| %name% . %name% ="
Line 7673
  iswhile always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  "while" always "while"
Line 7676
  isDoWhile always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  iswhile always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "}" always "}"
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "do" always "do"
Line 7683
  isNot {!<=-1,!>=2,0}
  ( always {!<=-1,!>=2}
  2 always 2
  "!|0" always "!|0"
Line 7684
  isNot always {!<=-1,!>=2}
Line 7685
  2 always 2
  == always {!<=-1,!>=2}
  "0" always "0"
  2 always 2
  : always 1
  1 always 1
Line 7690
  == always {!<=-1,!>=2}
  "(" always "("
Line 7698
  ( possible size=1
  == always {!<=-1,!>=2}
  "(" always "("
Line 7700
  == always {!<=-1,!>=2}
  ")" always ")"
Line 7706
  2 always 2
  == always {!<=-1,!>=2}
  "." always "."
Line 7707
  3 always 3
Line 7708
  3 always 3
Line 7709
  "." always "."
Line 7714
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 7715
  "(" always "("
Line 7716
  braces always !size=0
Line 7717
  braces always !size=0
Line 7720
  isNot always {!<=-1,!>=2}
Line 7721
  "!" always "!"
Line 7722
  iswhile {!<=-1,!>=2,0}
  ? possible {"while","if"}
  "while" always "while"
  : always "if"
  "if" always "if"
Line 7723
  isDoWhile {!<=-1,!>=2,0}
Line 7724
  "}" always "}"
Line 7728
  ";" always ";"
Line 7731
  isDoWhile {!<=-1,!>=2,0,1}
Line 7735
  iswhile always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  isDoWhile always {!<=-1,!>=2}
Line 7736
  = always 0
  0 always 0
Line 7739
  tok3 possible symbolic=(tok2)
Line 7740
  tok3 possible symbolic=(tok2)
  ( possible size=1
  == always {!<=-1,!>=2}
  "{" always "{"
Line 7742
  == always {!<=-1,!>=2}
  "}" always "}"
Line 7743
  <= always {!<=-1,!>=2}
  1 always 1
Line 7745
  -- {!<=0,>=1}
  indentlevel {!<=1,>=2}
Line 7749
  tok3 possible symbolic=(tok2)
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  1 always 1
Line 7750
  tok3 always !0
Line 7753
  && always {!<=-1,!>=2}
  tok2 always !0
  != always {!<=-1,!>=2}
Line 7757
  newTok always symbolic=(tok3->next())
Line 7758
  newTok always symbolic=(tok3->next())
Line 7759
  newTok always symbolic=(tok3->next())
Line 7763
  ( always {!<=-1,!>=2}
  newTok always symbolic=(tok3->next())
  "}|)|]|>" always "}|)|]|>"
Line 7764
  newTok always symbolic=(tok3->next())
Line 7766
  newTok always symbolic=(tok3->next())
Line 7779
  ( always {!<=-1,!>=2}
  "%name% = %name% = %num%|%name% ;" always "%name% = %name% = %num%|%name% ;"
Line 7782
  tok2 possible {symbolic=(tok->previous()),0}
  && always {!<=-1,!>=2}
Line 7783
  tok2 {symbolic=(tok->previous()),!0}
  == always {!<=-1,!>=2}
  "=" always "="
  && always {!<=-1,!>=2}
Line 7784
  ( always {!<=-1,!>=2}
  tok2 {symbolic=(tok->previous()),!0}
  "%name%" always "%name%"
Line 7785
  tok2 always !0
  -2 always -2
Line 7788
  ! {!<=-1,!>=2,1}
  tok2 possible {symbolic=(tok->previous()),0}
  || always {!<=-1,!>=2}
  tok2 always !0
  != always {!<=-1,!>=2}
  ";" always ";"
Line 7792
  2 always 2
Line 7793
  2 always 2
Line 7795
  tok2 always !0
Line 7797
  != always {!<=-1,!>=2}
Line 7798
  tok2 always !symbolic=(stopAt)
  ";" always ";"
Line 7799
  tok2 always !symbolic=(stopAt)
Line 7800
  tok2 always !symbolic=(stopAt)
  4 always 4
Line 7808
  "and" always "and"
  "&&" always "&&"
Line 7809
  "and_eq" always "and_eq"
  "&=" always "&="
Line 7810
  "bitand" always "bitand"
  "&" always "&"
Line 7811
  "bitor" always "bitor"
  "|" always "|"
Line 7812
  "not_eq" always "not_eq"
  "!=" always "!="
Line 7813
  "or" always "or"
  "||" always "||"
Line 7814
  "or_eq" always "or_eq"
  "|=" always "|="
Line 7815
  "xor" always "xor"
  "^" always "^"
Line 7816
  "xor_eq" always "xor_eq"
  "^=" always "^="
Line 7831
  ( always {!<=-1,!>=2}
Line 7834
  = always 0
  0 always 0
Line 7837
  replaceAll always {!<=-1,!>=2}
  replaceAll always {!<=-1,!>=2}
  = always 0
  false always 0
Line 7840
  == always {!<=-1,!>=2}
  ")" always ")"
Line 7841
  "{" always "{"
Line 7843
  = always !0
  ( always !0
  end always !0
Line 7848
  ( possible size=1
  == always {!<=-1,!>=2}
  "{" always "{"
Line 7849
  > always {!<=-1,!>=2}
  0 always 0
Line 7850
  ++ {>=2,!<=1}
  executableScopeLevel {>=1,!<=0}
Line 7854
  == always {!<=-1,!>=2}
  "}" always "}"
Line 7855
  > always {!<=-1,!>=2}
  0 always 0
Line 7856
  -- {>=0,!<=-1}
  executableScopeLevel {>=1,!<=0}
Line 7860
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 7863
  :: possible {symbolic=(cAlternativeTokens.end()),end=0}
  cOpIt possible {symbolic=(cAlternativeTokens.end()),end=0}
  = possible lifetime[Iterator]=(cAlternativeTokens)
  ( possible lifetime[Iterator]=(cAlternativeTokens)
Line 7864
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(cAlternativeTokens),end=0}
Line 7868
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "%type%|* %name% [;,=]" always "%type%|* %name% [;,=]"
Line 7869
  return always {!<=-1,!>=2}
  false always 0
Line 7871
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "%name%|%num%|%char%|)|]|> %name% %name%|%num%|%char%|%op%|(" always "%name%|%num%|%char%|)|]|> %name% %name%|%num%|%char%|%op%|("
Line 7873
  ( always {!<=-1,!>=2}
  "%assign%|%or%|%oror%|&&|*|/|%|^" always "%assign%|%or%|%oror%|&&|*|/|%|^"
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "%num%|%char%|) %name% *" always "%num%|%char%|) %name% *"
Line 7875
  == always {!<=-1,!>=2}
  0 always 0
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "%name% (" always "%name% ("
Line 7877
  ( always {!<=-1,!>=2}
  start possible {symbolic=(tok),0}
  "%name%|*" always "%name%|*"
Line 7879
  ! always {!<=-1,!>=2}
  start possible symbolic=(tok)
  || always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  start always !0
  "[;}]" always "[;}]"
Line 7882
  replaceAll always {!<=-1,!>=2}
  = always 1
  true always 1
Line 7883
  ( always {!<=-1,!>=2}
  "not|compl" always "not|compl"
Line 7886
  ( always {!<=-1,!>=2}
  "%assign%" always "%assign%"
  || always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "%num%" always "%num%"
Line 7887
  replaceAll always {!<=-1,!>=2}
  = always 1
  true always 1
Line 7892
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "%name%|(" always "%name%|("
  || always {!<=-1,!>=2}
Line 7893
  ( always {!<=-1,!>=2}
  "[;{}]" always "[;{}]"
  || always {!<=-1,!>=2}
Line 7894
  == always {!<=-1,!>=2}
  0U always 0
  && always {!<=-1,!>=2}
  -1 always -1
  == always {!<=-1,!>=2}
  "(" always "("
Line 7897
  replaceAll always {!<=-1,!>=2}
  = always 1
  true always 1
Line 7901
  ! {!<=-1,!>=2,1}
  replaceAll {!<=-1,!>=2,0}
Line 7902
  return always {!<=-1,!>=2}
  false always 0
Line 7905
  :: possible {symbolic=(cAlternativeTokens.end()),end=0}
  cOpIt possible {symbolic=(cAlternativeTokens.end()),end=0}
  = possible lifetime[Iterator]=(cAlternativeTokens)
  ( possible lifetime[Iterator]=(cAlternativeTokens)
Line 7906
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(cAlternativeTokens),end=0}
Line 7907
  cOpIt always !end=0
Line 7908
  == always {!<=-1,!>=2}
  "not" always "not"
Line 7909
  "!" always "!"
Line 7911
  "~" always "~"
Line 7914
  return always {!<=-1,!>=2}
  ! {!<=-1,!>=2,0}
  alt possible size=0
  ( {!<=-1,!>=2,1}
Line 7921
  ( always {!<=-1,!>=2}
Line 7925
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  ( always !0
  "[;{}]" always "[;{}]"
Line 7928
  ( possible size=3
  == {!<=-1,!>=2,0}
  "return" always "return"
Line 7931
  ( always {!<=-1,!>=2}
  "class|struct|union| %type% *| %name% ( &| %any% ) ;" always "class|struct|union| %type% *| %name% ( &| %any% ) ;"
Line 7933
  ( always {!<=-1,!>=2}
  "%type% *| %name% ( %type% (" always "%type% *| %name% ( %type% ("
Line 7934
  2 always 2
Line 7935
  ! always {!<=-1,!>=2}
Line 7937
  ! always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  ( always !0
  1 always 1
  == always {!<=-1,!>=2}
  ";" always ";"
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  2 always 2
  ") (" always ") ("
Line 7939
  ( always {!<=-1,!>=2}
  "class|struct|union| %type% *| %name% ( &| %any% ) ," always "class|struct|union| %type% *| %name% ( &| %any% ) ,"
  && always {!<=-1,!>=2}
  != always {!<=-1,!>=2}
  "new" always "new"
Line 7940
  5 always 5
Line 7941
  != always {!<=-1,!>=2}
  "," always ","
Line 7943
  ";" always ";"
Line 7945
  = always !<=-1
  ( always {!<=-1,!>=2}
  "class|struct|union" always "class|struct|union"
  ? always !<=-1
  2U always 2
  : always 1
  1U always 1
Line 7955
  ( always {!<=-1,!>=2}
  "class|struct|union" always "class|struct|union"
Line 7956
  2 always 2
  != always {!<=-1,!>=2}
  "*" always "*"
Line 7960
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  != always {!<=-1,!>=2}
  "auto" always "auto"
  && always {!<=-1,!>=2}
  != always {!<=-1,!>=2}
  "*" always "*"
Line 7965
  == always {!<=-1,!>=2}
  "*" always "*"
Line 7969
  == always {!<=-1,!>=2}
  "sizeof" always "sizeof"
Line 7973
  2 always 2
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  2 always 2
  == always {!<=-1,!>=2}
  "void" always "void"
Line 7975
  ! always {!<=-1,!>=2}
  2 always 2
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  2 always 2
  "%type% (" always "%type% ("
  && always {!<=-1,!>=2}
  2 always 2
  != always {!<=-1,!>=2}
  "&" always "&"
  && always {!<=-1,!>=2}
  2 always 2
  == always {!<=-1,!>=2}
  0 always 0
Line 7979
  ";" always ";"
Line 7981
  2 always 2
Line 7982
  2 always 2
Line 7983
  "=" always "="
Line 7986
  2 always 2
Line 7998
  ( always {!<=-1,!>=2}
Line 8001
  ret always {!<=-1,!>=2}
  ret always {!<=-1,!>=2}
  = always 0
  false always 0
Line 8010
  ( always {!<=-1,!>=2}
  "%type%|* & %name% = %name% ;" always "%type%|* & %name% = %name% ;"
Line 8012
  ( always {!<=-1,!>=2}
  start possible symbolic=(tok->previous())
  "%type%|*|&" always "%type%|*|&"
Line 8014
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  start possible symbolic=(tok->previous())
  "[;{}]" always "[;{}]"
Line 8016
  2 always 2
Line 8017
  2 always 2
Line 8018
  = always 0
  0 always 0
Line 8019
  6 always 6
Line 8020
  ( possible size=1
  == always {!<=-1,!>=2}
  "{" always "{"
Line 8022
  == always {!<=-1,!>=2}
  "}" always "}"
Line 8023
  <= always {!<=-1,!>=2}
  0 always 0
Line 8025
  -- {!<=-1,>=0}
  level {!<=0,>=1}
Line 8026
  == always {!<=-1,!>=2}
Line 8031
  6 always 6
Line 8035
  tok possible symbolic=(start)
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "static| const| static| %type% const| %name% = %any% ;" always "static| const| static| %type% const| %name% = %any% ;"
  || always {!<=-1,!>=2}
Line 8036
  ( always {!<=-1,!>=2}
  "static| const| static| %type% const| %name% ( %any% ) ;" always "static| const| static| %type% const| %name% ( %any% ) ;"
Line 8037
  isconst always {!<=-1,!>=2}
  isconst always {!<=-1,!>=2}
  = always 0
  false always 0
Line 8038
  ( possible size=5
  != {!<=-1,!>=2,1}
  "=" always "="
  && always {!<=-1,!>=2}
  != always {!<=-1,!>=2}
  "(" always "("
Line 8039
  == always {!<=-1,!>=2}
  "const" always "const"
Line 8040
  isconst always {!<=-1,!>=2}
  = always 1
  true always 1
Line 8044
  ! {!<=-1,!>=2,1,0}
  isconst {!<=-1,!>=2,0,1}
Line 8047
  = possible symbolic=(list.front())
  tok possible symbolic=(list.front())
Line 8050
  tok {symbolic=(tok1),symbolic=(list.front())}
  != {!<=-1,!>=2,0}
  ( possible symbolic=(tok1)
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  tok {symbolic=(tok1),!symbolic=(list.front())}
  ";|{|}|private:|protected:|public:" always ";|{|}|private:|protected:|public:"
Line 8053
  ( always {!<=-1,!>=2}
  tok possible {symbolic=(tok1),symbolic=(list.front())}
  "const|static" always "const|static"
Line 8056
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 8059
  && always {!<=-1,!>=2}
  ( always !0
  == always {!<=-1,!>=2}
  "const" always "const"
  2 always 2
  : possible 0
  ( possible 0
Line 8060
  2 always 2
Line 8061
  ( always {!<=-1,!>=2}
  "%bool%|%char%|%num%|%str% )| ;" always "%bool%|%char%|%num%|%str% )| ;"
Line 8068
  ( possible lifetime[Iterator]=(constantValues)
  ( always !0
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(constantValues),end=0}
  && always {!<=-1,!>=2}
  != always {!<=-1,!>=2}
  "=" always "="
Line 8074
  = {lifetime[Iterator]=(constantVars),size=0,start=0}
  constantVars possible size=0
  ( {lifetime[Iterator]=(constantVars),size=0,start=0}
  constantVar possible {lifetime[Iterator]=(constantVars),size=0,start=0}
  != always {!<=-1,!>=2}
  constantVars possible size=0
  ( {lifetime[Iterator]=(constantVars),size=0,end=0}
Line 8075
  referenceFound always {!<=-1,!>=2}
  referenceFound always {!<=-1,!>=2}
  = always 0
  false always 0
Line 8076
  constantVar possible lifetime[Iterator]=(constantVars)
Line 8077
  : always symbolic=(constantValueUsages[constantVar->first])
  usageList always symbolic=(constantValueUsages[constantVar->first])
Line 8079
  ( always {!<=-1,!>=2}
  -2 always -2
  "(|[|,|{|return|%op% & %varid%" always "(|[|,|{|return|%op% & %varid%"
  constantVar possible lifetime[Iterator]=(constantVars)
Line 8080
  referenceFound always {!<=-1,!>=2}
  = always 1
  true always 1
Line 8085
  ! {!<=-1,!>=2,0}
  referenceFound {!<=-1,!>=2,1}
Line 8093
  startTok always symbolic=(constantVar->second)
  != always {!<=-1,!>=2}
  ";" always ";"
Line 8094
  startTok always symbolic=(constantVar->second)
Line 8095
  startTok always symbolic=(constantVar->second)
Line 8098
  startTok always symbolic=(constantVar->second)
Line 8099
  startTok always symbolic=(constantVar->second)
  ( always !0
Line 8100
  startTok always symbolic=(constantVar->second)
Line 8101
  startTok always symbolic=(constantVar->second)
  ( always !0
Line 8103
  startTok always symbolic=(constantVar->second)
Line 8105
  = always 0
  nullptr always 0
Line 8107
  = always 0
  nullptr always 0
Line 8108
  ret always {!<=-1,!>=2}
  = always 1
  true always 1
Line 8119
  tok possible {symbolic=(start),symbolic=(tok2->previous())}
Line 8122
  ! always {!<=-1,!>=2}
Line 8125
  start always !0
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  tok2 always !0
  "[;{}]" always "[;{}]"
Line 8126
  != always {!<=-1,!>=2}
  0 always 0
Line 8127
  ( always !0
Line 8130
  = always !0
  start always !0
Line 8132
  = always 0
  0 always 0
Line 8133
  = {symbolic=(start),!0}
  tok {symbolic=(start),!0}
Line 8134
  tok2 possible {symbolic=(tok),symbolic=(start)}
Line 8135
  ( always {!<=-1,!>=2}
  tok2 possible {symbolic=(tok),symbolic=(start)}
  "[;{}] %type% %name%|*" always "[;{}] %type% %name%|*"
Line 8136
  isfloat always {!<=-1,!>=2}
  isfloat always {!<=-1,!>=2}
  = always 0
  false always 0
Line 8137
  ispointer always {!<=-1,!>=2}
  ispointer always {!<=-1,!>=2}
  = always 0
  false always 0
Line 8139
  ( always {!<=-1,!>=2}
  vartok possible symbolic=(tok2->next())
  "%name%|* %name%|*" always "%name%|* %name%|*"
Line 8140
  ( always {!<=-1,!>=2}
  "float|double" always "float|double"
Line 8141
  isfloat always {!<=-1,!>=2}
  = always 1
  true always 1
Line 8142
  == always {!<=-1,!>=2}
  "*" always "*"
Line 8143
  ispointer always {!<=-1,!>=2}
  = always 1
  true always 1
Line 8146
  ( always {!<=-1,!>=2}
  vartok possible symbolic=(tok2->next())
  "%var% ;|[" always "%var% ;|["
Line 8148
  isfloat always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ispointer always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "%var% ;" always "%var% ;"
Line 8150
  ( always {!<=-1,!>=2}
  "%var% [" always "%var% ["
Line 8154
  ( possible size=1
  == always {!<=-1,!>=2}
  "{" always "{"
Line 8157
  == always {!<=-1,!>=2}
  "}" always "}"
Line 8158
  -- possible {<=0,>=1}
  indentlevel possible {<=1,>=2}
Line 8159
  <= always {!<=-1,!>=2}
  0 always 0
Line 8163
  ( always {!<=-1,!>=2}
  "for (" always "for ("
Line 8166
  != always {!<=-1,!>=2}
  "*" always "*"
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  -2 always -2
  "* --|++" always "* --|++"
  && always {!<=-1,!>=2}
Line 8167
  ( always {!<=-1,!>=2}
  "%name% = %bool%|%char%|%num%|%str%|%name% ;" always "%name% = %bool%|%char%|%num%|%str%|%name% ;"
  || always {!<=-1,!>=2}
Line 8168
  ( always {!<=-1,!>=2}
  "%name% [ %num%| ] = %str% ;" always "%name% [ %num%| ] = %str% ;"
  || always {!<=-1,!>=2}
Line 8169
  ( always {!<=-1,!>=2}
  "%name% = & %name% ;" always "%name% = & %name% ;"
  || always {!<=-1,!>=2}
Line 8170
  ( always {!<=-1,!>=2}
  "%name% = & %name% [ 0 ] ;" always "%name% = & %name% [ 0 ] ;"
  && always {!<=-1,!>=2}
  ( possible lifetime[Iterator]=(arrays)
  3 always 3
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(arrays),end=0}
Line 8172
  varid {symbolic=(tok2->varId()),0}
  == {!<=-1,!>=2,1}
  0 always 0
Line 8175
  ( always {!<=-1,!>=2}
  "[;{}]" always "[;{}]"
  && always {!<=-1,!>=2}
  ( possible lifetime[Iterator]=(localvars)
  varid {symbolic=(tok2->varId()),!0}
  == always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(localvars),end=0}
Line 8180
  isstatic always {!<=-1,!>=2}
  isstatic always {!<=-1,!>=2}
  = always 0
  false always 0
Line 8182
  decl possible symbolic=(tok2->previous())
  && always {!<=-1,!>=2}
  decl {symbolic=(tok2->previous()),!0}
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  decl {symbolic=(tok2->previous()),!0}
  == always {!<=-1,!>=2}
  "*" always "*"
Line 8183
  decl always !0
  == always {!<=-1,!>=2}
  "static" always "static"
Line 8184
  isstatic always {!<=-1,!>=2}
  = always 1
  true always 1
Line 8187
  decl always !0
Line 8189
  isstatic {!<=-1,!>=2,0,1}
Line 8194
  ( always {!<=-1,!>=2}
  -2 always -2
  "(|:: %type%" always "(|:: %type%"
Line 8197
  tok3 possible symbolic=(tok2->previous())
  -2 always -2
Line 8198
  ( always {!<=-1,!>=2}
  ":: %type%" always ":: %type%"
Line 8199
  ( always {!<=-1,!>=2}
  -2 always -2
  "for ( %type%" always "for ( %type%"
Line 8204
  ( always {!<=-1,!>=2}
  "%varid% = &| %varid%" always "%varid% = &| %varid%"
Line 8207
  ( always {!<=-1,!>=2}
  -3 always -3
  "[;{}] %name% ." always "[;{}] %name% ."
Line 8208
  -2 always -2
  " ." always " ."
Line 8211
  2 always 2
Line 8214
  = always 0
  0 always 0
Line 8216
  = always 0
  nullptr always 0
Line 8217
  valueIsPointer always {!<=-1,!>=2}
  valueIsPointer always {!<=-1,!>=2}
  = always 0
  false always 0
Line 8220
  ( always {!<=-1,!>=2}
Line 8221
  return always {!<=-1,!>=2}
  false always 0
Line 8223
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  & {lifetime[Address]=(tok2),!0}
  & {lifetime[Address]=(tok3),!0}
  tok3 always 0
  value always size=0
  valueVarId always 0
  valueIsPointer always 0
  ( possible lifetime[Iterator]=(floatvars)
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(floatvars),end=0}
Line 8226
  > always {!<=-1,!>=2}
  0 always 0
  && always {!<=-1,!>=2}
  ( possible lifetime[Iterator]=(arrays)
  valueVarId {>=1,!<=0}
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(arrays),end=0}
Line 8229
  ret always {!<=-1,!>=2}
  |= always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  & {lifetime[Address]=(tok2),!0}
  valueIsPointer always {!<=-1,!>=2}
Line 8232
  ( always {!<=-1,!>=2}
  "strcpy|sprintf ( %name% , %str% ) ;" always "strcpy|sprintf ( %name% , %str% ) ;"
Line 8233
  varid possible 0
  2 always 2
Line 8234
  == always {!<=-1,!>=2}
  0 always 0
Line 8237
  4 always 4
Line 8239
  == always {!<=-1,!>=2}
  "sprintf" always "sprintf"
Line 8240
  :: always !<=-1
  n always !<=-1
  n always !<=-1
  = always 0
  0 always 0
Line 8241
  n always !<=-1
  = always !<=-1
  ( always !<=-1
  "%%" always "%%"
  n {!<=-1,0}
  != always {!<=-1,!>=2}
Line 8243
  n always !<=-1
  1 always 1
Line 8244
  ++ always !<=0
  n always !<=-1
Line 8247
  0 always 0
Line 8248
  valueIsPointer always {!<=-1,!>=2}
  false always 0
Line 8249
  6 always 6
Line 8250
  ret always {!<=-1,!>=2}
  |= always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  & {lifetime[Address]=(tok2),!0}
  varid always !0
  valueVarId always 0
  valueIsPointer always 0
Line 8253
  ( always {!<=-1,!>=2}
Line 8254
  return always {!<=-1,!>=2}
  false always 0
Line 8258
  tok2 possible {symbolic=(tok),symbolic=(start)}
Line 8259
  tok2 always !0
Line 8262
  return always {!<=-1,!>=2}
  ret always {!<=-1,!>=2}
Line 8265
  ( always {!<=-1,!>=2}
  valueIsPointer always {!<=-1,!>=2}
  , always {!<=-1,!>=2}
  floatvar always {!<=-1,!>=2}
Line 8267
  _tok2 possible lifetime[Address]=(tok2)@36
Line 8268
  = always 0
  nullptr always 0
Line 8270
  ( always {!<=-1,!>=2}
  tok2 always symbolic=(*_tok2)
  -2 always -2
  "for (" always "for ("
Line 8272
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "%varid% = %num% ; %varid% <|<= %num% ; ++| %varid% ++| ) {" always "%varid% = %num% ; %varid% <|<= %num% ; ++| %varid% ++| ) {"
Line 8273
  return always {!<=-1,!>=2}
  false always 0
Line 8276
  hasbreak always {!<=-1,!>=2}
  hasbreak always {!<=-1,!>=2}
  = always 0
  false always 0
Line 8277
  -1 always -1
  1 always 1
Line 8278
  != always {!<=-1,!>=2}
Line 8279
  == always {!<=-1,!>=2}
  "break" always "break"
Line 8280
  hasbreak always {!<=-1,!>=2}
  = always 1
  true always 1
Line 8284
  hasbreak {!<=-1,!>=2,0,1}
Line 8285
  return always {!<=-1,!>=2}
  false always 0
Line 8288
  5 always 5
Line 8289
  == always {!<=-1,!>=2}
  "<" always "<"
Line 8293
  1 always 1
Line 8298
  2 always 2
Line 8299
  2 always 2
Line 8300
  1 always 1
  == always {!<=-1,!>=2}
  "[" always "["
Line 8301
  2 always 2
Line 8302
  = always 0
  0 always 0
Line 8303
  == always {!<=-1,!>=2}
  "&" always "&"
Line 8304
  3 always 3
Line 8305
  3 always 3
Line 8310
  4 always 4
  == always {!<=-1,!>=2}
  ";" always ";"
Line 8311
  valueIsPointer always {!<=-1,!>=2}
  = always 1
  true always 1
Line 8315
  ( always {!<=-1,!>=2}
  2 always 2
  && always {!<=-1,!>=2}
  floatvar always {!<=-1,!>=2}
Line 8316
  ".0" always ".0"
Line 8320
  2 always 2
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  floatvar always {!<=-1,!>=2}
Line 8321
  = possible {"1.0","0.0"}
  == always {!<=-1,!>=2}
  "true" always "true"
  ? possible {"1.0","0.0"}
  "1.0" always "1.0"
  : always "0.0"
  "0.0" always "0.0"
Line 8324
  ( always {!<=-1,!>=2}
  "= &" always "= &"
Line 8325
  3 always 3
Line 8330
  = possible {symbolic=(tok2->previous()->link()->next()->link()->next()),symbolic=(tok2->next())}
  tok3 possible {symbolic=(tok2->previous()->link()->next()->link()->next()),symbolic=(tok2->next())}
Line 8331
  return always {!<=-1,!>=2}
  true always 1
Line 8334
  ( always {!<=-1,!>=2}
  , always {!<=-1,!>=2}
  valueIsPointer always {!<=-1,!>=2}
Line 8336
  pointeralias {!<=-1,!>=2,0}
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "& %name% [" always "& %name% ["
Line 8337
  varIsGlobal always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  0 always 0
Line 8338
  printDebug always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  . always {!<=-1,!>=2}
  debugwarnings always {!<=-1,!>=2}
Line 8340
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 8341
  mErrorLogger always !0
  ( always !size=0
  0 always 0
  "Tokenize (simplifyKnownVariables)" always "Tokenize (simplifyKnownVariables)"
Line 8343
  ( always 0
Line 8344
  return always {!<=-1,!>=2}
  false always 0
Line 8346
  ret always {!<=-1,!>=2}
  ret always {!<=-1,!>=2}
  = always 0
  false always 0
Line 8348
  = always 0
  nullptr always 0
Line 8350
  ret3 always {!<=-1,!>=2}
  ret3 always {!<=-1,!>=2}
  = always 0
  false always 0
Line 8352
  ( possible size=1
  == always {!<=-1,!>=2}
  "{" always "{"
Line 8354
  == always {!<=-1,!>=2}
  "}" always "}"
Line 8356
  < always {!<=-1,!>=2}
Line 8357
  ( always {!<=-1,!>=2}
  tok2 possible lifetime[Address]=(tok2)@38
  -7 always -7
  "%type% * %name% ; %name% = & %name% ;" always "%type% * %name% ; %name% = & %name% ;"
  && always {!<=-1,!>=2}
Line 8358
  tok2 possible lifetime[Address]=(tok2)@38
  -5 always -5
  == always {!<=-1,!>=2}
  tok2 possible lifetime[Address]=(tok2)@38
  -3 always -3
Line 8359
  tok2 possible lifetime[Address]=(tok2)@38
  tok2 possible lifetime[Address]=(tok2)@38
  -4 always -4
Line 8360
  tok2 possible lifetime[Address]=(tok2)@38
  tok2 possible lifetime[Address]=(tok2)@38
  6 always 6
Line 8368
  valueIsPointer {!<=-1,!>=2,0}
  && always {!<=-1,!>=2}
  > always {!<=-1,!>=2}
  0 always 0
  && always {!<=-1,!>=2}
Line 8369
  && always {!<=-1,!>=2}
  ( always !0
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  ( always !0
  == always {!<=-1,!>=2}
  "*" always "*"
  && always {!<=-1,!>=2}
Line 8370
  == always {!<=-1,!>=2}
  "&" always "&"
  && always {!<=-1,!>=2}
Line 8371
  && always {!<=-1,!>=2}
Line 8372
  ( always !0
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 8373
  == always {!<=-1,!>=2}
  ( always !0
  && always {!<=-1,!>=2}
Line 8374
  > always {!<=-1,!>=2}
Line 8376
  decl always {!<=-1,!>=2}
  decl always {!<=-1,!>=2}
  = always 1
  true always 1
Line 8377
  = always !0
  ( always !0
Line 8378
  ( always {!<=-1,!>=2}
  "[;{}]" always "[;{}]"
Line 8381
  ( always {!<=-1,!>=2}
Line 8382
  > always {!<=-1,!>=2}
  0 always 0
Line 8383
  decl always {!<=-1,!>=2}
  = always 0
  false always 0
Line 8388
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "[&*]" always "[&*]"
Line 8389
  decl always {!<=-1,!>=2}
  = always 0
  false always 0
Line 8393
  decl {!<=-1,!>=2,1,0}
Line 8398
  ( always {!<=-1,!>=2}
  "; %type% : ;" always "; %type% : ;"
Line 8402
  ( always {!<=-1,!>=2}
  "break|continue" always "break|continue"
Line 8404
  indentlevel3 possible symbolic=(indentlevel)
  > always {!<=-1,!>=2}
  1 always 1
  || always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  ";" always ";"
  "; }" always "; }"
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  "return" always "return"
Line 8405
  ret3 always {!<=-1,!>=2}
  = always 1
  true always 1
Line 8406
  ret3 {!<=-1,!>=2,1}
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  ";" always ";"
Line 8409
  pointeralias {!<=-1,!>=2,0}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "!!= " always "!!= "
  ( {lifetime[Object]=("!!= "+value),!0}
Line 8413
  pointeralias {!<=-1,!>=2,0}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "do|for|while" always "do|for|while"
Line 8418
  varIsGlobal always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  ")" always ")"
  && always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 8419
  ( always {!<=-1,!>=2}
  ( always !0
  -2 always -2
  "[;{}] %name% (" always "[;{}] %name% ("
  && always {!<=-1,!>=2}
Line 8420
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  ( always !0
  "if|for|while|switch|BOOST_FOREACH" always "if|for|while|switch|BOOST_FOREACH"
Line 8424
  ( always {!<=-1,!>=2}
  "for|while|do" always "for|while|do"
Line 8426
  ( always {!<=-1,!>=2}
  endpar always symbolic=(tok3->next()->link())
  ") {" always ") {"
Line 8427
  endpar always symbolic=(tok3->next()->link())
Line 8428
  bailout always {!<=-1,!>=2}
  bailout always {!<=-1,!>=2}
  = always 0
  false always 0
Line 8429
  && always {!<=-1,!>=2}
  tok4 always !0
  != always {!<=-1,!>=2}
Line 8430
  ( always {!<=-1,!>=2}
  "++|-- %varid%" always "++|-- %varid%"
  || always {!<=-1,!>=2}
Line 8431
  ( always {!<=-1,!>=2}
  "%varid% ++|--|=" always "%varid% ++|--|="
Line 8432
  bailout always {!<=-1,!>=2}
  = always 1
  true always 1
Line 8436
  bailout {!<=-1,!>=2,0,1}
Line 8440
  bailOutFromLoop possible symbolic=(tok3)
Line 8444
  tok3 possible symbolic=(bailOutFromLoop)
  == always {!<=-1,!>=2}
Line 8448
  == always {!<=-1,!>=2}
  bailOutFromLoop always !0
Line 8450
  = always 0
  nullptr always 0
Line 8455
  == always {!<=-1,!>=2}
  "{" always "{"
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  ")" always ")"
Line 8457
  && always {!<=-1,!>=2}
Line 8458
  ( always !0
  -1 always -1
  != always {!<=-1,!>=2}
  "if" always "if"
Line 8464
  ( always {!<=-1,!>=2}
  "%name% = realloc ( %name% ," always "%name% = realloc ( %name% ,"
  && always {!<=-1,!>=2}
Line 8465
  == always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 8466
  4 always 4
  == always {!<=-1,!>=2}
Line 8467
  4 always 4
Line 8468
  ret always {!<=-1,!>=2}
  = always 1
  true always 1
Line 8472
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "( %name% )" always "( %name% )"
  && always {!<=-1,!>=2}
Line 8473
  ( always {!<=-1,!>=2}
  "&&|(|%oror% %varid% &&|%oror%|)|;" always "&&|(|%oror% %varid% &&|%oror%|)|;"
Line 8476
  ret always {!<=-1,!>=2}
  = always 1
  true always 1
Line 8480
  == always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "[(,] %name% [,)]" always "[(,] %name% [,)]"
Line 8482
  ( always {!<=-1,!>=2}
Line 8485
  ret always {!<=-1,!>=2}
  = always 1
  true always 1
Line 8490
  == always {!<=-1,!>=2}
Line 8493
  printDebug always {!<=-1,!>=2}
Line 8496
  pointeralias always {!<=-1,!>=2}
Line 8500
  ( always {!<=-1,!>=2}
  ". %name% (" always ". %name% ("
Line 8504
  1 always 1
  == always {!<=-1,!>=2}
  "=" always "="
Line 8508
  ( always {!<=-1,!>=2}
  -2 always -2
  "return|= & %name% ;" always "return|= & %name% ;"
Line 8512
  ( always {!<=-1,!>=2}
  -2 always -2
  "%name% ( %name% ,|)" always "%name% ( %name% ,|)"
  || always {!<=-1,!>=2}
Line 8513
  ( always {!<=-1,!>=2}
  ", %name% ,|)" always ", %name% ,|)"
Line 8517
  ( always {!<=-1,!>=2}
  -3 always -3
  ") { ++|--" always ") { ++|--"
  || always {!<=-1,!>=2}
Line 8518
  ( always {!<=-1,!>=2}
  -2 always -2
  ") { %name% ++|--" always ") { %name% ++|--"
Line 8521
  :: always 7
  debug always 7
  "debug" always "debug"
Line 8522
  "simplifyKnownVariables: bailing out (variable=" always "simplifyKnownVariables: bailing out (variable="
  ", value=" always ", value="
  ")" always ")"
Line 8529
  ( always {!<=-1,!>=2}
  "if ( " always "if ( "
  + possible size=5
  structname possible size=0
  + possible size=21
  " %varid% %cop%|)" always " %varid% %cop%|)"
  ( {lifetime[Object]=("if ( "+structname+" %varid% %cop%|)"),!0}
  varid always !symbolic=(tok3->varId())
  || always {!<=-1,!>=2}
Line 8530
  ( always {!<=-1,!>=2}
  "( " always "( "
  " %varid% %comp%" always " %varid% %comp%"
  ( {lifetime[Object]=("( "+structname+" %varid% %comp%"),!0}
  varid always !symbolic=(tok3->varId())
  || always {!<=-1,!>=2}
Line 8531
  ( always {!<=-1,!>=2}
  "%comp%|!|= " always "%comp%|!|= "
  " %varid% %cop%|)|;" always " %varid% %cop%|)|;"
  ( {lifetime[Object]=("%comp%|!|= "+structname+" %varid% %cop%|)|;"),!0}
  varid always !symbolic=(tok3->varId())
  || always {!<=-1,!>=2}
Line 8532
  ( always {!<=-1,!>=2}
  "strlen|free ( %varid% )" always "strlen|free ( %varid% )"
  varid always !symbolic=(tok3->varId())
Line 8533
  0 always 0
  == always {!<=-1,!>=2}
  '\"' always 34
  && always {!<=-1,!>=2}
  != always {!<=-1,!>=2}
  "strlen" always "strlen"
Line 8538
  ! {!<=-1,!>=2,0}
  structname possible size=0
  ( {!<=-1,!>=2,1}
Line 8539
  2 always 2
Line 8541
  ( always {!<=-1,!>=2}
  "& %name% ;" always "& %name% ;"
Line 8542
  "&" always "&"
Line 8548
  ret always {!<=-1,!>=2}
  = always 1
  true always 1
Line 8552
  ( always {!<=-1,!>=2}
  "& %name% ;" always "& %name% ;"
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "( * " always "( * "
  " %varid% %cop%" always " %varid% %cop%"
  ( {lifetime[Object]=("( * "+structname+" %varid% %cop%"),!0}
Line 8554
  ! {!<=-1,!>=2,0}
  structname possible size=0
  ( {!<=-1,!>=2,1}
Line 8555
  2 always 2
Line 8559
  ret always {!<=-1,!>=2}
  = always 1
  true always 1
Line 8563
  ( {!<=-1,!>=2,0}
  && always {!<=-1,!>=2}
  pointeralias always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  "delete" always "delete"
  && always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 8564
  ( always {!<=-1,!>=2}
  ( always !0
  "%varid% ;" always "%varid% ;"
  || always {!<=-1,!>=2}
Line 8565
  ( always {!<=-1,!>=2}
  ( always !0
  "[ ] %varid%" always "[ ] %varid%"
Line 8566
  ( always !0
  == always {!<=-1,!>=2}
  "[" always "["
  3 always 3
Line 8569
  ret always {!<=-1,!>=2}
  = always 1
  true always 1
Line 8573
  ( always {!<=-1,!>=2}
  "%name% ( " always "%name% ( "
  " %varid% ," always " %varid% ,"
  ( {lifetime[Object]=("%name% ( "+structname+" %varid% ,"),!0}
Line 8574
  9 always 9
Line 8576
  "strcmp" always "strcmp"
  "strdup" always "strdup"
Line 8578
  "memcmp" always "memcmp"
  "memcpy" always "memcpy"
  "memmove" always "memmove"
  "memset" always "memset"
  "strcpy" always "strcpy"
  "strncmp" always "strncmp"
  "strncpy" always "strncpy"
Line 8580
  = always 0
  0 always 0
  i possible {>=0,<=1,>=2}
  < {!<=-1,!>=2,1}
  ( always !<=-1
  functionName always {
  / always 9
  ( always 8
  functionName {{,lifetime[Object]=(functionName)}
  ++ possible 1
  i possible 0
Line 8581
  == always {!<=-1,!>=2}
  0U always 0
  && always {!<=-1,!>=2}
  i {0,!>=9,!<=-1}
  >= {!<=-1,!>=2,0}
  2 always 2
Line 8583
  == always {!<=-1,!>=2}
  functionName {{,lifetime[Object]=(functionName)}
  i {0,<=1,!<=-1}
Line 8584
  2 always 2
Line 8585
  ! {!<=-1,!>=2,0}
  structname possible size=0
  ( {!<=-1,!>=2,1}
Line 8597
  ( always {!<=-1,!>=2}
  "%name% ( %any% , " always "%name% ( %any% , "
  " %varid% ,|)" always " %varid% ,|)"
  ( {lifetime[Object]=("%name% ( %any% , "+structname+" %varid% ,|)"),!0}
Line 8598
  7 always 7
Line 8600
  "strcmp" always "strcmp"
  "strcpy" always "strcpy"
  "strncmp" always "strncmp"
  "strncpy" always "strncpy"
Line 8602
  "memcmp" always "memcmp"
  "memcpy" always "memcpy"
  "memmove" always "memmove"
Line 8604
  = always 0
  0 always 0
  i possible {0,1,>=4,<=3}
  < {!<=-1,!>=2,1}
  ( always !<=-1
  functionName always {
  / always 7
  ( always 8
  functionName {{,lifetime[Object]=(functionName)}
  ++ possible 1
  i possible 0
Line 8605
  == always {!<=-1,!>=2}
  0U always 0
  && always {!<=-1,!>=2}
  i {0,!>=7,!<=-1}
  >= {!<=-1,!>=2,0}
  4 always 4
Line 8607
  == always {!<=-1,!>=2}
  functionName {{,lifetime[Object]=(functionName)}
  i {0,<=3,!<=-1}
Line 8608
  4 always 4
Line 8609
  ! {!<=-1,!>=2,0}
  structname possible size=0
  ( {!<=-1,!>=2,1}
Line 8621
  0 always 0
  != always {!<=-1,!>=2}
  '\"' always 34
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "[(,] " always "[(,] "
  " %varid% [|%cop%" always " %varid% [|%cop%"
  ( {lifetime[Object]=("[(,] "+structname+" %varid% [|%cop%"),!0}
Line 8622
  ! {!<=-1,!>=2,0}
  structname possible size=0
  ( {!<=-1,!>=2,1}
Line 8623
  2 always 2
Line 8628
  ret always {!<=-1,!>=2}
  = always 1
  true always 1
Line 8632
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  ">> " always ">> "
  " %varid%" always " %varid%"
  ( {lifetime[Object]=(">> "+structname+" %varid%"),!0}
Line 8635
  prev possible symbolic=(tok3->previous())
  && always {!<=-1,!>=2}
  prev {symbolic=(tok3->previous()),!0}
  != always {!<=-1,!>=2}
  "return" always "return"
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  prev {symbolic=(tok3->previous()),!0}
  "%name%|::|*" always "%name%|::|*"
Line 8636
  prev always !0
Line 8637
  ( always {!<=-1,!>=2}
  prev possible {symbolic=(tok3->previous()),0}
  ";|{|}|>>" always ";|{|}|>>"
Line 8642
  > always {!<=-1,!>=2}
  0 always 0
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "& " always "& "
  " %varid%" always " %varid%"
  ( {lifetime[Object]=("& "+structname+" %varid%"),!0}
  || always {!<=-1,!>=2}
Line 8643
  ( always {!<=-1,!>=2}
  "[=+-*/%^|[] " always "[=+-*/%^|[] "
  " %varid% [=?+-*/%^|;])]" always " %varid% [=?+-*/%^|;])]"
  ( {lifetime[Object]=("[=+-*/%^|[] "+structname+" %varid% [=?+-*/%^|;])]"),!0}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "= " always "= "
  " %name% =" always " %name% ="
  ( {lifetime[Object]=("= "+structname+" %name% ="),!0}
  || always {!<=-1,!>=2}
Line 8644
  ( always {!<=-1,!>=2}
  "[(=+-*/%^|[] " always "[(=+-*/%^|[] "
  " %varid% <<|>>" always " %varid% <<|>>"
  ( {lifetime[Object]=("[(=+-*/%^|[] "+structname+" %varid% <<|>>"),!0}
  || always {!<=-1,!>=2}
Line 8645
  ( always {!<=-1,!>=2}
  "<<|>> " always "<<|>> "
  " %varid% %cop%|;|]|)" always " %varid% %cop%|;|]|)"
  ( {lifetime[Object]=("<<|>> "+structname+" %varid% %cop%|;|]|)"),!0}
  || always {!<=-1,!>=2}
Line 8646
  ( always {!<=-1,!>=2}
  "[=+-*/%^|[] ( " always "[=+-*/%^|[] ( "
  " %varid% !!=" always " %varid% !!="
  ( {lifetime[Object]=("[=+-*/%^|[] ( "+structname+" %varid% !!="),!0}
Line 8647
  0 always 0
  == always {!<=-1,!>=2}
  '\"' always 34
Line 8649
  ! {!<=-1,!>=2,0}
  structname possible size=0
  ( {!<=-1,!>=2,1}
Line 8650
  2 always 2
Line 8651
  ret always {!<=-1,!>=2}
  = always 1
  true always 1
Line 8654
  != always {!<=-1,!>=2}
Line 8655
  ret always {!<=-1,!>=2}
  = always 1
  true always 1
Line 8658
  == always {!<=-1,!>=2}
  "*" always "*"
  && always {!<=-1,!>=2}
  valueIsPointer always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "& %name% ;" always "& %name% ;"
Line 8661
  ret always {!<=-1,!>=2}
  = always 1
  true always 1
Line 8662
  ( always {!<=-1,!>=2}
  "& %name% ;" always "& %name% ;"
Line 8663
  "&" always "&"
  true always 1
Line 8666
  ( always {!<=-1,!>=2}
  "= {" always "= {"
Line 8667
  1 always 1
Line 8668
  != always {!<=-1,!>=2}
Line 8669
  ( always {!<=-1,!>=2}
  "{|, %varid% ,|}" always "{|, %varid% ,|}"
Line 8672
  ret always {!<=-1,!>=2}
  = always 1
  true always 1
Line 8678
  ( always {!<=-1,!>=2}
  "for (" always "for ("
Line 8679
  2 always 2
Line 8680
  ( always {!<=-1,!>=2}
  "(|)" always "(|)"
Line 8684
  ( always {!<=-1,!>=2}
  "; %name% <|<=|!= %name% ; ++| %name% ++| )" always "; %name% <|<=|!= %name% ; ++| %name% ++| )"
Line 8685
  5 always 5
Line 8686
  == always {!<=-1,!>=2}
  "++" always "++"
Line 8688
  == always {!<=-1,!>=2}
  varid possible symbolic=(tok4->next()->varId())
Line 8691
  == always {!<=-1,!>=2}
  varid always !symbolic=(inctok->varId())
Line 8694
  ret always {!<=-1,!>=2}
  = always 1
  true always 1
Line 8696
  3 always 3
  == always {!<=-1,!>=2}
  varid always !symbolic=(inctok->varId())
Line 8697
  3 always 3
Line 8698
  3 always 3
Line 8699
  ret always {!<=-1,!>=2}
  = always 1
  true always 1
Line 8705
  indentlevel possible symbolic=(indentlevel3)
  == {!<=-1,!>=2,1}
  indentlevel3 possible symbolic=(indentlevel)
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "%varid% ++|--" always "%varid% ++|--"
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 8706
  2 always 2
Line 8707
  ( always {!<=-1,!>=2}
  "[{};] %any% %any% ;" always "[{};] %any% %any% ;"
Line 8708
  3 always 3
Line 8716
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  -2 always -2
  "for (" always "for ("
Line 8717
  2 always 2
Line 8718
  2 always 2
Line 8720
  ret always {!<=-1,!>=2}
  = always 1
  true always 1
Line 8723
  indentlevel possible symbolic=(indentlevel3)
  == {!<=-1,!>=2,1}
  indentlevel3 possible symbolic=(indentlevel)
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "++|-- %varid%" always "++|-- %varid%"
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 8724
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  3 always 3
  "[.[]" always "[.[]"
Line 8726
  2 always 2
Line 8727
  2 always 2
Line 8728
  ( always {!<=-1,!>=2}
  "[;{}] %any% %any% ;" always "[;{}] %any% %any% ;"
Line 8729
  3 always 3
Line 8736
  ret always {!<=-1,!>=2}
  = always 1
  true always 1
Line 8740
  ( always {!<=-1,!>=2}
  "return %varid% %any%" always "return %varid% %any%"
  && always {!<=-1,!>=2}
Line 8741
  != always {!<=-1,!>=2}
  "&" always "&"
  && always {!<=-1,!>=2}
Line 8742
  2 always 2
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  2 always 2
  == always {!<=-1,!>=2}
  ";" always ";"
  && always {!<=-1,!>=2}
Line 8743
  0 always 0
  != always {!<=-1,!>=2}
  '\"' always 34
Line 8748
  pointeralias always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "return * %varid% ;" always "return * %varid% ;"
  && always {!<=-1,!>=2}
  0 always 0
  != always {!<=-1,!>=2}
  '\"' always 34
Line 8754
  return always {!<=-1,!>=2}
  ret {!<=-1,!>=2,0}
Line 8761
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "else if" always "else if"
Line 8765
  ( always {!<=-1,!>=2}
  "(|{|[" always "(|{|["
Line 8768
  ( always {!<=-1,!>=2}
  "}|;" always "}|;"
Line 8769
  && always {!<=-1,!>=2}
  ( always !0
  != always {!<=-1,!>=2}
  "else" always "else"
Line 8770
  "{" always "{"
Line 8771
  "}" always "}"
Line 8783
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  < always {!<=-1,!>=2}
  :: always 3
  CPP17 always 3
Line 8786
  forInit always {!<=-1,!>=2}
  = {!<=-1,!>=2,>=0}
  . {!<=2,>=3}
  >= {!<=-1,!>=2,>=0}
  :: always 4
  CPP20 always 4
Line 8789
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "if|switch|for (" always "if|switch|for ("
Line 8792
  2 always 2
Line 8793
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "[;)]" always "[;)]"
Line 8794
  ( always {!<=-1,!>=2}
  "(|{|[" always "(|{|["
  && always {!<=-1,!>=2}
Line 8795
  = always !0
  ( always !0
Line 8798
  != always {!<=-1,!>=2}
  ";" always ";"
Line 8801
  == always {!<=-1,!>=2}
  "for" always "for"
Line 8802
  ! always {!<=-1,!>=2}
  forInit always {!<=-1,!>=2}
Line 8807
  rangeFor always {!<=-1,!>=2}
  rangeFor always {!<=-1,!>=2}
  = always 0
  false always 0
Line 8808
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  tok2 possible symbolic=(semicolon->next())
  "[;)]" always "[;)]"
Line 8809
  ( possible size=1
  == always {!<=-1,!>=2}
  "(" always "("
Line 8811
  ! always {!<=-1,!>=2}
  rangeFor always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  "?" always "?"
Line 8813
  == always {!<=-1,!>=2}
  ":" always ":"
Line 8814
  rangeFor always {!<=-1,!>=2}
  = always 1
  true always 1
Line 8817
  ! always {!<=-1,!>=2}
  rangeFor always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  != always {!<=-1,!>=2}
  ")" always ")"
Line 8821
  1 always 1
Line 8822
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  ") {" always ") {"
Line 8825
  1 always 1
Line 8826
  ( always {!<=-1,!>=2}
  "} else {" always "} else {"
Line 8827
  2 always 2
Line 8831
  "(" always "("
Line 8834
  "{" always "{"
Line 8835
  "}" always "}"
Line 8837
  true always 1
Line 8842
  ( always {!<=-1,!>=2}
Line 8844
  ret always {!<=-1,!>=2}
  ret always {!<=-1,!>=2}
  = always 0
  false always 0
Line 8846
  != always {!<=-1,!>=2}
  "(" always "("
Line 8849
  ( {!<=-1,!>=2,0}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "} (" always "} ("
Line 8851
  ( always {!<=-1,!>=2}
  plp always symbolic=(tok->previous()->link()->previous())
  "%name%|>|] {" always "%name%|>|] {"
  || always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  plp always symbolic=(tok->previous()->link()->previous())
  ")" always ")"
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  plp always symbolic=(tok->previous()->link()->previous())
  "]" always "]"
Line 8855
  ( always {!<=-1,!>=2}
  "( {" always "( {"
Line 8858
  ( always {!<=-1,!>=2}
  ") %num%" always ") %num%"
Line 8864
  ( always {!<=-1,!>=2}
  ( possible 0
  "%op% (" always "%op% ("
  || always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  ") %op%" always ") %op%"
Line 8865
  innerComma always {!<=-1,!>=2}
  innerComma always {!<=-1,!>=2}
  = always 0
  false always 0
Line 8866
  != always {!<=-1,!>=2}
Line 8867
  == always {!<=-1,!>=2}
  ")" always ")"
Line 8869
  == always {!<=-1,!>=2}
  "," always ","
Line 8870
  innerComma always {!<=-1,!>=2}
  = always 1
  true always 1
Line 8874
  innerComma {!<=-1,!>=2,0,1}
Line 8879
  -2 always -2
  != always {!<=-1,!>=2}
  "operator" always "operator"
  && always {!<=-1,!>=2}
Line 8880
  && always {!<=-1,!>=2}
  ( always !0
  == always {!<=-1,!>=2}
  "=" always "="
  && always {!<=-1,!>=2}
Line 8881
  && always {!<=-1,!>=2}
  ( always !0
  != always {!<=-1,!>=2}
  "{" always "{"
  && always {!<=-1,!>=2}
Line 8882
  ( always {!<=-1,!>=2}
  ") ;" always ") ;"
Line 8888
  ( always {!<=-1,!>=2}
  "( (" always "( ("
  && always {!<=-1,!>=2}
Line 8889
  && always {!<=-1,!>=2}
  ( always !0
  == always {!<=-1,!>=2}
Line 8893
  -2 always -2
Line 8894
  ret always {!<=-1,!>=2}
  = always 1
  true always 1
Line 8897
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  -2 always -2
  "[;{}=(] new (" always "[;{}=(] new ("
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  ") [;,{}[]" always ") [;,{}[]"
Line 8901
  ret always {!<=-1,!>=2}
  = always 1
  true always 1
Line 8904
  ( always {!<=-1,!>=2}
  "! ( %name% )" always "! ( %name% )"
Line 8908
  ret always {!<=-1,!>=2}
  = always 1
  true always 1
Line 8911
  ( always {!<=-1,!>=2}
  "[(,;{}] ( %name% ) ." always "[(,;{}] ( %name% ) ."
Line 8915
  ret always {!<=-1,!>=2}
  = always 1
  true always 1
Line 8918
  ( always {!<=-1,!>=2}
  "[(,;{}] ( %name% (" always "[(,;{}] ( %name% ("
  && always {!<=-1,!>=2}
Line 8919
  == always {!<=-1,!>=2}
  2 always 2
Line 8924
  ret always {!<=-1,!>=2}
  = always 1
  true always 1
Line 8927
  ( always {!<=-1,!>=2}
  "[,;{}] ( delete [| ]| %name% ) ;" always "[,;{}] ( delete [| ]| %name% ) ;"
Line 8932
  ret always {!<=-1,!>=2}
  = always 1
  true always 1
Line 8935
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  -2 always -2
  "operator delete" always "operator delete"
  && always {!<=-1,!>=2}
Line 8936
  ( always {!<=-1,!>=2}
  "delete|; (" always "delete|; ("
  && always {!<=-1,!>=2}
Line 8937
  != always {!<=-1,!>=2}
  "delete" always "delete"
  || always {!<=-1,!>=2}
  > always {!<=-1,!>=2}
  0 always 0
  && always {!<=-1,!>=2}
Line 8938
  ( always {!<=-1,!>=2}
  ") ;|," always ") ;|,"
Line 8941
  ret always {!<=-1,!>=2}
  = always 1
  true always 1
Line 8944
  ( always {!<=-1,!>=2}
  "[(!*;{}] ( %name% )" always "[(!*;{}] ( %name% )"
  && always {!<=-1,!>=2}
Line 8945
  != always {!<=-1,!>=2}
  0 always 0
  || always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  3 always 3
  "[+-/=]" always "[+-/=]"
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 8949
  ret always {!<=-1,!>=2}
  = always 1
  true always 1
Line 8952
  ( always {!<=-1,!>=2}
  "[;{}[(,!*] ( %name% ." always "[;{}[(,!*] ( %name% ."
Line 8953
  2 always 2
Line 8954
  ( always {!<=-1,!>=2}
  tok2 possible symbolic=(tok->link())
  ". %name%" always ". %name%"
Line 8955
  2 always 2
Line 8957
  != always {!<=-1,!>=2}
Line 8963
  ret always {!<=-1,!>=2}
  = always 1
  true always 1
Line 8966
  ( always {!<=-1,!>=2}
  "? (" always "? ("
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  ") :" always ") :"
Line 8968
  tok2 possible {symbolic=(tok->next()),0}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  tok2 {symbolic=(tok->next()),!0}
  "%bool%|%num%|%name%" always "%bool%|%num%|%name%"
  || always {!<=-1,!>=2}
  tok2 {symbolic=(tok->next()),!0}
  ( always {!<=-1,!>=2}
Line 8969
  tok2 always !0
Line 8970
  tok2 possible {symbolic=(tok->next()),0}
  && always {!<=-1,!>=2}
  tok2 always !0
  == always {!<=-1,!>=2}
  ")" always ")"
Line 8973
  ret always {!<=-1,!>=2}
  = always 1
  true always 1
Line 8978
  ( always {!<=-1,!>=2}
  "[{([,] ( !!{" always "[{([,] ( !!{"
  && always {!<=-1,!>=2}
Line 8979
  ( always {!<=-1,!>=2}
  ") [;,])]" always ") [;,])]"
  && always {!<=-1,!>=2}
Line 8980
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  -2 always -2
  "operator ," always "operator ,"
  && always {!<=-1,!>=2}
Line 8981
  ! always {!<=-1,!>=2}
  "," always ","
Line 8985
  ret always {!<=-1,!>=2}
  = always 1
  true always 1
Line 8988
  ( always {!<=-1,!>=2}
  ", (" always ", ("
  && always {!<=-1,!>=2}
Line 8989
  ( always {!<=-1,!>=2}
  ") =" always ") ="
Line 8992
  ret always {!<=-1,!>=2}
  = always 1
  true always 1
Line 8996
  ( always {!<=-1,!>=2}
  "( %bool%|%num% ) %cop%|;|,|)" always "( %bool%|%num% ) %cop%|;|,|)"
  && always {!<=-1,!>=2}
Line 8997
  -2 always -2
  != always {!<=-1,!>=2}
  "operator" always "operator"
  && always {!<=-1,!>=2}
Line 8998
  && always {!<=-1,!>=2}
Line 8999
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  ( always !0
  "%name%|)|]" always "%name%|)|]"
  && always {!<=-1,!>=2}
Line 9000
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  ( always !0
  ">|>>" always ">|>>"
Line 9003
  ret always {!<=-1,!>=2}
  = always 1
  true always 1
Line 9006
  ( always {!<=-1,!>=2}
  "*|& ( %name% )" always "*|& ( %name% )"
Line 9008
  -2 always -2
Line 9009
  ( always {!<=-1,!>=2}
  tok2 possible 0
  "%type%|static|const|extern" always "%type%|static|const|extern"
  && always {!<=-1,!>=2}
  != always {!<=-1,!>=2}
  "operator" always "operator"
Line 9012
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  tok2 always !0
  "[;,{]" always "[;,{]"
Line 9020
  return always {!<=-1,!>=2}
  ret {!<=-1,!>=2,0}
Line 9026
  "__has_nothrow_assign" always "__has_nothrow_assign"
  "has_nothrow_assign" always "has_nothrow_assign"
Line 9027
  "__has_nothrow_constructor" always "__has_nothrow_constructor"
  "has_nothrow_constructor" always "has_nothrow_constructor"
Line 9028
  "__has_nothrow_copy" always "__has_nothrow_copy"
  "has_nothrow_copy" always "has_nothrow_copy"
Line 9029
  "__has_trivial_assign" always "__has_trivial_assign"
  "has_trivial_assign" always "has_trivial_assign"
Line 9030
  "__has_trivial_constructor" always "__has_trivial_constructor"
  "has_trivial_constructor" always "has_trivial_constructor"
Line 9031
  "__has_trivial_copy" always "__has_trivial_copy"
  "has_trivial_copy" always "has_trivial_copy"
Line 9032
  "__has_trivial_destructor" always "__has_trivial_destructor"
  "has_trivial_destructor" always "has_trivial_destructor"
Line 9033
  "__has_virtual_destructor" always "__has_virtual_destructor"
  "has_virtual_destructor" always "has_virtual_destructor"
Line 9034
  "__is_abstract" always "__is_abstract"
  "is_abstract" always "is_abstract"
Line 9035
  "__is_aggregate" always "__is_aggregate"
  "is_aggregate" always "is_aggregate"
Line 9036
  "__is_assignable" always "__is_assignable"
  "is_assignable" always "is_assignable"
Line 9037
  "__is_base_of" always "__is_base_of"
  "is_base_of" always "is_base_of"
Line 9038
  "__is_class" always "__is_class"
  "is_class" always "is_class"
Line 9039
  "__is_constructible" always "__is_constructible"
  "is_constructible" always "is_constructible"
Line 9040
  "__is_convertible_to" always "__is_convertible_to"
  "is_convertible_to" always "is_convertible_to"
Line 9041
  "__is_destructible" always "__is_destructible"
  "is_destructible" always "is_destructible"
Line 9042
  "__is_empty" always "__is_empty"
  "is_empty" always "is_empty"
Line 9043
  "__is_enum" always "__is_enum"
  "is_enum" always "is_enum"
Line 9044
  "__is_final" always "__is_final"
  "is_final" always "is_final"
Line 9045
  "__is_nothrow_assignable" always "__is_nothrow_assignable"
  "is_nothrow_assignable" always "is_nothrow_assignable"
Line 9046
  "__is_nothrow_constructible" always "__is_nothrow_constructible"
  "is_nothrow_constructible" always "is_nothrow_constructible"
Line 9047
  "__is_nothrow_destructible" always "__is_nothrow_destructible"
  "is_nothrow_destructible" always "is_nothrow_destructible"
Line 9048
  "__is_pod" always "__is_pod"
  "is_pod" always "is_pod"
Line 9049
  "__is_polymorphic" always "__is_polymorphic"
  "is_polymorphic" always "is_polymorphic"
Line 9050
  "__is_trivially_assignable" always "__is_trivially_assignable"
  "is_trivially_assignable" always "is_trivially_assignable"
Line 9051
  "__is_trivially_constructible" always "__is_trivially_constructible"
  "is_trivially_constructible" always "is_trivially_constructible"
Line 9052
  "__is_union" always "__is_union"
  "is_union" always "is_union"
Line 9055
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "%name% (" always "%name% ("
Line 9057
  = possible lifetime[Iterator]=(intrinsics)
  intrinsics always {
  ( possible lifetime[Iterator]=(intrinsics)
Line 9058
  p {lifetime[Iterator]=(intrinsics),symbolic=(intrinsics.find(tok->str()))}
  == always {!<=-1,!>=2}
  intrinsics always {
  ( {lifetime[Iterator]=(intrinsics),end=0}
Line 9062
  p {lifetime[Iterator]=(intrinsics),!end=0}
Line 9063
  "::" always "::"
Line 9064
  "std" always "std"
Line 9065
  "<" always "<"
Line 9066
  ">" always ">"
Line 9067
  "}" always "}"
Line 9068
  "{" always "{"
Line 9069
  1 always 1
  2 always 2
Line 9077
  ( always {!<=-1,!>=2}
  "%str% [ %num% ]" always "%str% [ %num% ]"
Line 9078
  2 always 2
Line 9080
  >= always {!<=-1,!>=2}
  0 always 0
  && always {!<=-1,!>=2}
  index {>=0,!<=-1}
  <= always {!<=-1,!>=2}
Line 9081
  "'" always "'"
  index {>=0,!<=-1}
  "'" always "'"
Line 9082
  3 always 3
Line 9090
  ( always {!<=-1,!>=2}
Line 9093
  tok possible {symbolic=(end),symbolic=(tok->link())}
Line 9097
  = always !0
  start always !0
Line 9099
  tok {symbolic=(start),!0}
Line 9100
  = {symbolic=(start),!0}
  tok {symbolic=(start),!0}
  tok2 possible symbolic=(start)
  && always {!<=-1,!>=2}
  tok2 {symbolic=(start),!0}
  != always {!<=-1,!>=2}
  end always symbolic=(tok->link())
Line 9102
  ( always {!<=-1,!>=2}
  "[;{}] %type% & %name% (|= %name% )| ;" always "[;{}] %type% & %name% (|= %name% )| ;"
Line 9103
  3 always 3
Line 9104
  ! always {!<=-1,!>=2}
Line 9108
  7 always 7
  && always {!<=-1,!>=2}
  tok3 always !0
  != always {!<=-1,!>=2}
  end always symbolic=(tok->link())
Line 9109
  == always {!<=-1,!>=2}
  refId always !0
Line 9110
  5 always 5
Line 9111
  5 always 5
Line 9115
  6 always 6
  6 always 6
  == always {!<=-1,!>=2}
  ")" always ")"
  1 always 1
  : always 0
  0 always 0
Line 9118
  = always symbolic=(tok->link())
  end always symbolic=(tok->link())
Line 9123
  ( always {!<=-1,!>=2}
Line 9125
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  nullptr always 0
  nullptr always 0
  false always 0
Line 9133
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 9134
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "]|)|++|--" always "]|)|++|--"
Line 9135
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "* ( %name% +|- %num%|%name% )" always "* ( %name% +|- %num%|%name% )"
Line 9138
  2 always 2
Line 9141
  2 always 2
Line 9143
  isNegativeIndex always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  tok always symbolic=(openBraceTok)
  == always {!<=-1,!>=2}
  "-" always "-"
Line 9144
  tok always symbolic=(openBraceTok)
  "[" always "["
Line 9147
  isNegativeIndex always {!<=-1,!>=2}
Line 9148
  tok always symbolic=(openBraceTok)
  ( always {!<=-1,!>=2}
Line 9149
  tok always symbolic=(openBraceTok)
  "-" always "-"
Line 9150
  tok always symbolic=(openBraceTok)
Line 9152
  tok always symbolic=(openBraceTok)
  "-" always "-"
  tok always symbolic=(openBraceTok)
Line 9155
  tok possible symbolic=(openBraceTok)
  2 always 2
Line 9156
  "]" always "]"
Line 9166
  ( always {!<=-1,!>=2}
Line 9168
  && always {!<=-1,!>=2}
  tok always !0
  == always {!<=-1,!>=2}
  "*" always "*"
  || always {!<=-1,!>=2}
  tok always !0
  ( always {!<=-1,!>=2}
Line 9169
  tok always !0
  > always {!<=-1,!>=2}
  0 always 0
Line 9170
  tok always !0
  ( {>=1,!<=0}
Line 9173
  tok always !0
Line 9175
  ! {!<=-1,!>=2,1}
  tok possible 0
Line 9181
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "%num%|%name%|]|)" always "%num%|%name%|]|)"
  && always {!<=-1,!>=2}
Line 9182
  ( always {!<=-1,!>=2}
  "& %name% [ %num%|%name% ] !![" always "& %name% [ %num%|%name% ] !!["
Line 9186
  ( possible lifetime[Iterator]=(pod)
  ( always !0
  == always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(pod),end=0}
Line 9187
  5 always 5
Line 9188
  ! always {!<=-1,!>=2}
Line 9189
  tok always 0
Line 9195
  "(" always "("
Line 9200
  "+" always "+"
Line 9202
  3 always 3
Line 9204
  ")" always ")"
Line 9205
  -4 always -4
Line 9213
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "[;{}] strcat ( strcat (" always "[;{}] strcat ( strcat ("
Line 9218
  3 always 3
Line 9219
  ( always {!<=-1,!>=2}
  "strcat ( strcat" always "strcat ( strcat"
Line 9220
  2 always 2
Line 9222
  3 always 3
  != always {!<=-1,!>=2}
  "," always ","
Line 9236
  2 always 2
Line 9237
  2 always 2
Line 9240
  ";" always ";"
Line 9245
  "strcat" always "strcat"
Line 9246
  "strcpy" always "strcpy"
Line 9247
  "strncat" always "strncat"
Line 9248
  "strncpy" always "strncpy"
Line 9249
  "free" always "free"
Line 9250
  "malloc" always "malloc"
Line 9251
  "strdup" always "strdup"
Line 9256
  ( always {!<=-1,!>=2}
Line 9260
  != always {!<=-1,!>=2}
  "std" always "std"
Line 9263
  ( always {!<=-1,!>=2}
  "[(,{};] std :: %name% (" always "[(,{};] std :: %name% ("
  && always {!<=-1,!>=2}
Line 9264
  ( possible lifetime[Iterator]=(stdFunctionsPresentInC)
  2 always 2
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(stdFunctionsPresentInC),end=0}
Line 9277
  ( always {!<=-1,!>=2}
Line 9280
  ret always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  & {lifetime[Address]=(unknownFunc),!0}
  unknownFunc always size=0
Line 9281
  ! {!<=-1,!>=2,0}
  unknownFunc possible size=0
  ( {!<=-1,!>=2,1}
  && always {!<=-1,!>=2}
  ( possible lifetime[Iterator]=(mSettings->summaryReturn)
  unknownFunc always !size=0
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(mSettings->summaryReturn),end=0}
Line 9282
  return always {!<=-1,!>=2}
  false always 0
Line 9285
  * always {!<=-1,!>=2}
  unknown always !0
  = always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 9286
  ! {symbolic=(*unknown),!<=-1,!>=2,0}
  unknownFunc possible size=0
  ( {!<=-1,!>=2,1}
  && always {!<=-1,!>=2}
  . always {!<=-1,!>=2}
  checkLibrary always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  :: always 6
  information always 6
Line 9288
  globalFunction always {!<=-1,!>=2}
  globalFunction always {!<=-1,!>=2}
  = always 1
  true always 1
Line 9289
  ( always {!<=-1,!>=2}
  -2 always -2
  ") ; }" always ") ; }"
Line 9290
  -2 always -2
Line 9291
  && always {!<=-1,!>=2}
Line 9292
  ftok always !0
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 9293
  ftok always !0
  && always {!<=-1,!>=2}
Line 9294
  ( always !0
  && always {!<=-1,!>=2}
Line 9295
  ( always !0
  . always !0
  != always {!<=-1,!>=2}
  :: always 0
  eGlobal always 0
Line 9296
  globalFunction always {!<=-1,!>=2}
  = always 0
  false always 0
Line 9302
  globalFunction {!<=-1,!>=2,1,0}
Line 9304
  :: always 6
  information always 6
Line 9305
  "checkLibraryNoReturn" always "checkLibraryNoReturn"
Line 9306
  "--check-library: Function " always "--check-library: Function "
  unknownFunc always !size=0
  "() should have <noreturn> configuration" always "() should have <noreturn> configuration"
Line 9309
  return always {!<=-1,!>=2}
  ret always {!<=-1,!>=2}
Line 9314
  ( always {!<=-1,!>=2}
Line 9320
  = always 1
  1 always 1
Line 9322
  ( possible size=1
  == always {!<=-1,!>=2}
  "(" always "("
Line 9324
  ( possible size=1
  == always {!<=-1,!>=2}
  ")" always ")"
Line 9326
  == always {!<=-1,!>=2}
  "," always ","
Line 9328
  ( always {!<=-1,!>=2}
  "[;{}]" always "[;{}]"
Line 9333
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  ftok always !0
  -2 always -2
  "[;{}=] %name% (" always "[;{}=] %name% ("
Line 9334
  functionName possible size=6
  ftok always !0
Line 9336
  == always {!<=-1,!>=2}
  "return" always "return"
Line 9337
  return always {!<=-1,!>=2}
  true always 1
Line 9341
  == always {!<=-1,!>=2}
  "{" always "{"
Line 9343
  ( always {!<=-1,!>=2}
  "%type% (" always "%type% ("
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
Line 9345
  2 always 2
Line 9346
  = always 1
  1 always 1
Line 9347
  && always {!<=-1,!>=2}
  par possible 1
  < always {!<=-1,!>=2}
Line 9348
  tok always !0
  ( possible size=1
  == always {!<=-1,!>=2}
  ")" always ")"
Line 9350
  tok always !0
  == always {!<=-1,!>=2}
  "," always ","
Line 9351
  ++ always !>=symbolic=(parameter+1)
  par always !>=symbolic=(parameter)
Line 9352
  tok always !0
Line 9354
  ! {!<=-1,!>=2,1}
  tok possible 0
Line 9355
  return always {!<=-1,!>=2}
  false always 0
Line 9358
  == always {!<=-1,!>=2}
Line 9359
  knowntype always {!<=-1,!>=2}
  knowntype always {!<=-1,!>=2}
  = always 0
  false always 0
Line 9360
  tok possible 0
  && always {!<=-1,!>=2}
  tok always !0
  ( always {!<=-1,!>=2}
Line 9361
  knowntype always {!<=-1,!>=2}
  |= always {!<=-1,!>=2}
  tok always !0
  ( always {!<=-1,!>=2}
Line 9362
  knowntype always {!<=-1,!>=2}
  |= always {!<=-1,!>=2}
  tok always !0
  == always {!<=-1,!>=2}
  "struct" always "struct"
Line 9363
  tok always !0
Line 9365
  ! {!<=-1,!>=2,1}
  tok possible 0
  || always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  knowntype always {!<=-1,!>=2}
Line 9366
  return always {!<=-1,!>=2}
  false always 0
Line 9367
  tok always !0
  ( possible size=1
  != always {!<=-1,!>=2}
  "," always ","
  && always {!<=-1,!>=2}
  tok always !0
  != always {!<=-1,!>=2}
  ")" always ")"
Line 9368
  return always {!<=-1,!>=2}
  false always 0
Line 9369
  return always {!<=-1,!>=2}
  true always 1
Line 9374
  return always {!<=-1,!>=2}
  false always 0
Line 9381
  ! {!<=-1,!>=2,1@237}
  begin possible {symbolic=(tok->previous())@237,symbolic=(end->link())@237,0@237,symbolic=(tok2)@72}
Line 9383
  isgoto always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  begin {!0,symbolic=(tok2)@72}
  -2 always -2
  "goto %name% ;" always "goto %name% ;"
Line 9384
  = always 1
  1 always 1
Line 9385
  = always 0
  0 always 0
Line 9386
  = always 0
  0 always 0
Line 9387
  = always 0
  0 always 0
Line 9388
  = always 0
  0 always 0
Line 9389
  = always 0
  0 always 0
Line 9391
  checklabel always {!<=-1,!>=2}
  checklabel always {!<=-1,!>=2}
  = always 0
  false always 0
Line 9392
  = {!0,symbolic=(tok2)@72}
  begin {!0,symbolic=(tok2)@72}
Line 9393
  = always 0
  nullptr always 0
Line 9394
  tok possible {symbolic=(begin),symbolic=(const_cast<Token*>(tok2)),symbolic=(tokcheck->next()),symbolic=(tok2)@72}
  && always {!<=-1,!>=2}
  tok possible symbolic=(begin)
  ( always !0
  != always {!<=-1,!>=2}
Line 9395
  ( always {!symbolic=(end),!0}
  ( possible size=1
  == always {!<=-1,!>=2}
  "(" always "("
Line 9399
  ( always {!symbolic=(end),!0}
  == always {!<=-1,!>=2}
  ")" always ")"
Line 9400
  ! always {!<=-1,!>=2}
Line 9402
  -- always !-1
  roundbraces always !0
Line 9412
  ( always {!<=-1,!>=2}
  "[{};] switch (" always "[{};] switch ("
Line 9413
  ! always {!<=-1,!>=2}
  checklabel always {!<=-1,!>=2}
Line 9414
  ! always {!<=-1,!>=2}
Line 9416
  2 always 2
Line 9418
  2 always 2
Line 9420
  == always {!<=-1,!>=2}
  "{" always "{"
Line 9422
  1 always 1
Line 9423
  indentcase always symbolic=(indentlevel+1)
Line 9426
  2 always 2
Line 9427
  ( always {!<=-1,!>=2}
  ") {" always ") {"
Line 9429
  1 always 1
Line 9430
  indentcase always symbolic=(indentlevel+1)
Line 9433
  ( possible {size=1,size=7}
  == {!<=-1,!>=2,0}
  "{" always "{"
Line 9435
  ! always {!<=-1,!>=2}
  checklabel always {!<=-1,!>=2}
Line 9436
  checklabel always {!<=-1,!>=2}
  = always 1
  true always 1
Line 9439
  = always 0
  0 always 0
Line 9441
  tok possible symbolic=(tokcheck)
Line 9442
  ( possible size=7
  == {!<=-1,!>=2,0}
  "}" always "}"
Line 9443
  -- possible {symbolic=(indentcase),0}
  indentlevel possible {>=symbolic=(indentcase+1),1}
Line 9444
  ! always {!<=-1,!>=2}
  indentlevel possible >=symbolic=(indentcase)
Line 9447
  ! always {!<=-1,!>=2}
  checklabel always {!<=-1,!>=2}
Line 9450
  indentswitch possible 0
  && always {!<=-1,!>=2}
  indentlevel always !0
  == always {!<=-1,!>=2}
Line 9451
  -- {!-1,symbolic=(indentcase-1)}
  indentlevel {!0,symbolic=(indentcase)}
Line 9452
  < always {!<=-1,!>=2}
Line 9454
  end2 always symbolic=(tok->next())
Line 9455
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  tok always symbolic=(end2->link()->previous())
  ") {" always ") {"
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  tok always symbolic=(end2->link()->previous())
  -2 always -2
  "[{};] switch (" always "[{};] switch ("
Line 9456
  tok always symbolic=(end2->link()->previous())
  -2 always -2
Line 9457
  tok possible symbolic=(end2->link()->previous())
Line 9458
  checklabel always {!<=-1,!>=2}
  = always 0
  false always 0
Line 9459
  = always 0
  nullptr always 0
Line 9460
  = always 0
  0 always 0
Line 9465
  indentswitch possible {1,0}
  && always {!<=-1,!>=2}
  <= always {!<=-1,!>=2}
Line 9466
  -- {0,!-1}
  indentswitch {1,!0}
Line 9468
  ! always {!<=-1,!>=2}
  indentswitch always !-1
Line 9469
  = always 0
  0 always 0
Line 9471
  indentswitch always {!-1,!0}
  - always {!-2,!-1}
  1 always 1
Line 9473
  ( always {!<=-1,!>=2}
  "[{};:] case" always "[{};:] case"
Line 9474
  ": ;" always ": ;"
Line 9475
  ! always {!<=-1,!>=2}
  tok2 always symbolic=(Token::findsimplematch(tok->next(),": ;",end))
Line 9479
  indentlevel possible symbolic=(indentcase)
  == always {!<=-1,!>=2}
  1 always 1
Line 9481
  indentlevel always !1
  == always {!<=-1,!>=2}
Line 9482
  ++ {!2,symbolic=(indentcase+1)}
  indentlevel {!1,symbolic=(indentcase)}
Line 9483
  tok2 always !0
Line 9484
  ! always {!<=-1,!>=2}
  checklabel always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
Line 9489
  ( always {!<=-1,!>=2}
  "[{};] default : ;" always "[{};] default : ;"
Line 9490
  indentlevel possible symbolic=(indentcase)
  == always {!<=-1,!>=2}
  1 always 1
Line 9492
  indentlevel always !1
  == always {!<=-1,!>=2}
Line 9493
  ++ {!2,symbolic=(indentcase+1)}
  indentlevel {!1,symbolic=(indentcase)}
Line 9494
  ! always {!<=-1,!>=2}
  checklabel always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
Line 9495
  3 always 3
Line 9497
  3 always 3
Line 9499
  ( always {!<=-1,!>=2}
  "[{};] %name% : ;" always "[{};] %name% : ;"
  && always {!<=-1,!>=2}
  != always {!<=-1,!>=2}
  "default" always "default"
Line 9500
  checklabel always {!<=-1,!>=2}
Line 9503
  checklabel always {!<=-1,!>=2}
  = always 0
  false always 0
Line 9510
  3 always 3
Line 9512
  && always {!<=-1,!>=2}
  ( always !0
  != always {!<=-1,!>=2}
Line 9513
  ( always {!<=-1,!>=2}
  ( always {!symbolic=(end),!0}
  "{|[|(" always "{|[|("
Line 9514
  ( always {!symbolic=(end),!0}
Line 9515
  ( always {!<=-1,!>=2}
  "[{};:] case" always "[{};:] case"
Line 9516
  ( always {!symbolic=(end),!0}
  ": ;" always ": ;"
  end always !symbolic=(tok2->next())
Line 9517
  ! always {!<=-1,!>=2}
  tok3 always symbolic=(Token::findsimplematch(tok2->next(),": ;",end))
Line 9518
  = always {!symbolic=(end),!0}
  ( always {!symbolic=(end),!0}
Line 9521
  tok3 always !0
Line 9522
  ( always {!<=-1,!>=2}
  "[{};] default : ;" always "[{};] default : ;"
Line 9523
  3 always 3
Line 9524
  ( always {!symbolic=(end),!0}
  == always {!<=-1,!>=2}
  "}" always "}"
Line 9525
  -- possible {<=symbolic=(indentcase),>=symbolic=(indentcase+1)}
  indentlevel2 possible {<=symbolic=(indentcase+1),>=symbolic=(indentcase+2)}
Line 9526
  <= always {!<=-1,!>=2}
Line 9528
  = always {!symbolic=(end),!0}
  ( always {!symbolic=(end),!0}
Line 9530
  = always {!symbolic=(end),!0}
  ( always {!symbolic=(end),!0}
Line 9536
  isgoto always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "[{};] do|while|for|BOOST_FOREACH" always "[{};] do|while|for|BOOST_FOREACH"
Line 9539
  2 always 2
Line 9540
  && always {!<=-1,!>=2}
  start always !0
  == always {!<=-1,!>=2}
  "(" always "("
Line 9541
  start always !0
Line 9542
  && always {!<=-1,!>=2}
  start always !0
  == always {!<=-1,!>=2}
  "{" always "{"
Line 9543
  "[{};] " always "[{};] "
  begin always !0
  " : ;" always " : ;"
Line 9544
  simplify always {!<=-1,!>=2}
  simplify always {!<=-1,!>=2}
  = always 1
  true always 1
Line 9545
  start always !0
  != always {!<=-1,!>=2}
  start always !0
Line 9546
  ( always {!<=-1,!>=2}
  labelpattern always symbolic=("[{};] "+begin->previous()->str()+" : ;")
  ( {lifetime[Object]=(labelpattern),!0}
Line 9547
  simplify always {!<=-1,!>=2}
  = always 0
  false always 0
Line 9552
  ! {!<=-1,!>=2,0,1}
  simplify {!<=-1,!>=2,1,0}
Line 9558
  1 always 1
  == always {!<=-1,!>=2}
  "while" always "while"
Line 9559
  == always {!<=-1,!>=2}
  "}" always "}"
  && always {!<=-1,!>=2}
  -1 always -1
  == always {!<=-1,!>=2}
  "do" always "do"
Line 9571
  0 always 0
Line 9572
  ( inconclusive lifetime[SubObject]=(tok)
  tok possible {0@85,symbolic=(Token::findsimplematch(tok,"typedef",tok->link()))@175,symbolic=(start)@22,symbolic=(typeDef)@171,symbolic=(tokOffset->next())@24,symbolic=(argStart)@59,symbolic=(tok->next())@208}
  code possible "operator"@46
  ( always {!<=-1,!>=2}
  "syntax error" always "syntax error"
  : always "syntax error"
  "syntax error: " always "syntax error: "
  code {"operator"@46,!size=0}
  :: always 1
  SYNTAX always 1
Line 9577
  0 always 0
Line 9578
  ( inconclusive lifetime[SubObject]=(tok)
Line 9579
  "Unmatched '" always "Unmatched '"
  "'. Configuration: '" always "'. Configuration: '"
  "'." always "'."
Line 9580
  :: always 1
  SYNTAX always 1
Line 9585
  0 always 0
Line 9586
  ( inconclusive lifetime[SubObject]=(tok)
  "Code '" always "Code '"
  what possible {"C++ cast <..."@60,"template<..."@68}
  "' is invalid C code. Use --std or --language to configure the language." always "' is invalid C code. Use --std or --language to configure the language."
  :: always 1
  SYNTAX always 1
Line 9591
  0 always 0
Line 9592
  ( inconclusive lifetime[SubObject]=(tok1)
  "There is an unknown macro here somewhere. Configuration is required. If " always "There is an unknown macro here somewhere. Configuration is required. If "
  " is a macro then please configure it." always " is a macro then please configure it."
  :: always 2
  UNKNOWN_MACRO always 2
Line 9598
  :: always 6
  information always 6
Line 9599
  "class_X_Y" always "class_X_Y"
Line 9600
  "The code '" always "The code '"
Line 9601
  " " always " "
Line 9602
  1 always 1
  " " always " "
Line 9603
  2 always 2
  " " always " "
Line 9604
  3 always 3
  "' is not handled. You can use -I or --include to add handling of this code." always "' is not handled. You can use -I or --include to add handling of this code."
Line 9610
  :: always 6
  information always 6
Line 9611
  "macroWithSemicolon" always "macroWithSemicolon"
Line 9612
  "Ensure that '" always "Ensure that '"
  "' is defined either using -I, --include or -D." always "' is defined either using -I, --include or -D."
Line 9617
  0 always 0
Line 9618
  ( inconclusive lifetime[SubObject]=(tok)
  tok possible symbolic=(lastTok)@42
  "Analysis failed. If the code is valid then please report this failure." always "Analysis failed. If the code is valid then please report this failure."
  :: always 3
  INTERNAL always 3
Line 9623
  = possible ""
  ? possible ""
  " " always " "
  tok always !0
  : always ""
  "" always ""
Line 9624
  = always 0
  0 always 0
  i possible 0
  < always {!<=-1,!>=2}
  s possible {symbolic=(tok?(" "+tok->str()):""),NonMovedVariable}
  ( always !<=-1
Line 9625
  ( always !<=-1
  i {<=symbolic=(s.size()-1),!>=symbolic=(s.size())}
  >= always {!<=-1,!>=2}
  0x80 always 128
Line 9626
  s always NonMovedVariable
Line 9630
  :: always 5
  portability always 5
Line 9631
  "nonStandardCharLiteral" always "nonStandardCharLiteral"
Line 9632
  "Non-standard character literal" always "Non-standard character literal"
  + possible size=30
  s possible {symbolic=(tok?(" "+tok->str()):""),size=0}
  + possible size=32
  ". " always ". "
Line 9643
  ( always {!<=-1,!>=2}
Line 9645
  ( always {!<=-1,!>=2}
Line 9646
  == always {!<=-1,!>=2}
Line 9647
  return always {!<=-1,!>=2}
  true always 1
Line 9648
  ( always {!<=-1,!>=2}
Line 9649
  == always {!<=-1,!>=2}
Line 9650
  return always {!<=-1,!>=2}
  true always 1
Line 9652
  return always {!<=-1,!>=2}
  false always 0
Line 9660
  ( always {!<=-1,!>=2}
Line 9662
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  0L always 0
  "0.0" always "0.0"
Line 9670
  ( always {!<=-1,!>=2}
Line 9672
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 9673
  return always {!<=-1,!>=2}
  false always 0
Line 9674
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  1L always 1
  "1.0" always "1.0"
Line 9682
  ( always {!<=-1,!>=2}
Line 9684
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 9685
  return always {!<=-1,!>=2}
  false always 0
Line 9686
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  2L always 2
  "2.0" always "2.0"
Line 9714
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  1 always 1
  == always {!<=-1,!>=2}
  "(" always "("
Line 9715
  simplifcationMade {!<=-1,!>=2,0}
  simplifcationMade always {!<=-1,!>=2}
  = always 0
  false always 0
Line 9716
  ( always {!<=-1,!>=2}
  "atol ( %str% )" always "atol ( %str% )"
Line 9717
  ( always {!<=-1,!>=2}
  -2 always -2
  "std ::" always "std ::"
Line 9718
  -2 always -2
Line 9719
  2 always 2
Line 9721
  2 always 2
Line 9722
  isNotAnInteger always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  strNumber possible size=0
Line 9723
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  isNotAnInteger {symbolic=(!MathLib::isInt(strNumber)),!<=-1,!>=2}
Line 9730
  3 always 3
Line 9731
  simplifcationMade always {!<=-1,!>=2}
  = always 1
  true always 1
Line 9732
  ( always {!<=-1,!>=2}
  "sqrt|sqrtf|sqrtl|cbrt|cbrtf|cbrtl ( %num% )" always "sqrt|sqrtf|sqrtl|cbrt|cbrtf|cbrtl ( %num% )"
Line 9736
  2 always 2
Line 9738
  ( always {!<=-1,!>=2}
Line 9739
  3 always 3
Line 9740
  "0" always "0"
Line 9741
  simplifcationMade always {!<=-1,!>=2}
  = always 1
  true always 1
Line 9742
  ( always {!<=-1,!>=2}
Line 9743
  3 always 3
Line 9744
  "1" always "1"
Line 9745
  simplifcationMade always {!<=-1,!>=2}
  = always 1
  true always 1
Line 9747
  ( always {!<=-1,!>=2}
  "exp|expf|expl|exp2|exp2f|exp2l|cos|cosf|cosl|cosh|coshf|coshl|erfc|erfcf|erfcl ( %num% )" always "exp|expf|expl|exp2|exp2f|exp2l|cos|cosf|cosl|cosh|coshf|coshl|erfc|erfcf|erfcl ( %num% )"
Line 9752
  2 always 2
Line 9754
  ( always {!<=-1,!>=2}
Line 9755
  3 always 3
Line 9756
  "1" always "1"
Line 9757
  simplifcationMade always {!<=-1,!>=2}
  = always 1
  true always 1
Line 9759
  ( always {!<=-1,!>=2}
  "log1p|log1pf|log1pl|sin|sinf|sinl|sinh|sinhf|sinhl|erf|erff|erfl|asin|asinf|asinl|asinh|asinhf|asinhl|tan|tanf|tanl|tanh|tanhf|tanhl|atan|atanf|atanl|atanh|atanhf|atanhl|expm1|expm1f|expm1l ( %num% )" always "log1p|log1pf|log1pl|sin|sinf|sinl|sinh|sinhf|sinhl|erf|erff|erfl|asin|asinf|asinl|asinh|asinhf|asinhl|tan|tanf|tanl|tanh|tanhf|tanhl|atan|atanf|atanl|atanh|atanhf|atanhl|expm1|expm1f|expm1l ( %num% )"
Line 9767
  2 always 2
Line 9769
  ( always {!<=-1,!>=2}
Line 9770
  3 always 3
Line 9771
  "0" always "0"
Line 9772
  simplifcationMade always {!<=-1,!>=2}
  = always 1
  true always 1
Line 9774
  ( always {!<=-1,!>=2}
  "log2|log2f|log2l|log|logf|logl|log10|log10f|log10l|logb|logbf|logbl|acosh|acoshf|acoshl|acos|acosf|acosl|ilogb|ilogbf|ilogbl ( %num% )" always "log2|log2f|log2l|log|logf|logl|log10|log10f|log10l|logb|logbf|logbl|acosh|acoshf|acoshl|acos|acosf|acosl|ilogb|ilogbf|ilogbl ( %num% )"
Line 9780
  2 always 2
Line 9782
  ( always {!<=-1,!>=2}
Line 9783
  3 always 3
Line 9784
  "0" always "0"
Line 9785
  simplifcationMade always {!<=-1,!>=2}
  = always 1
  true always 1
Line 9787
  ( always {!<=-1,!>=2}
  "fmin|fminl|fminf ( %num% , %num% )" always "fmin|fminl|fminf ( %num% , %num% )"
Line 9791
  2 always 2
Line 9792
  4 always 4
Line 9793
  isLessEqual always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 9795
  isLessEqual {symbolic=(MathLib::isLessEqual(strLeftNumber,strRightNumber)),!<=-1,!>=2}
Line 9797
  5 always 5
Line 9798
  simplifcationMade always {!<=-1,!>=2}
  = always 1
  true always 1
Line 9801
  5 always 5
Line 9802
  simplifcationMade always {!<=-1,!>=2}
  = always 1
  true always 1
Line 9804
  ( always {!<=-1,!>=2}
  "fmax|fmaxl|fmaxf ( %num% , %num% )" always "fmax|fmaxl|fmaxf ( %num% , %num% )"
Line 9808
  2 always 2
Line 9809
  4 always 4
Line 9810
  isLessEqual always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 9812
  isLessEqual {symbolic=(MathLib::isLessEqual(strLeftNumber,strRightNumber)),!<=-1,!>=2}
Line 9814
  5 always 5
Line 9815
  simplifcationMade always {!<=-1,!>=2}
  = always 1
  true always 1
Line 9818
  5 always 5
Line 9819
  simplifcationMade always {!<=-1,!>=2}
  = always 1
  true always 1
Line 9821
  ( always {!<=-1,!>=2}
  "pow|powf|powl (" always "pow|powf|powl ("
Line 9822
  ( always {!<=-1,!>=2}
  2 always 2
  "%num% , %num% )" always "%num% , %num% )"
Line 9826
  2 always 2
Line 9827
  4 always 4
Line 9828
  isLeftNumberZero always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 9829
  isLeftNumberOne always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 9830
  isRightNumberZero always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 9831
  isLeftNumberZero {symbolic=(isZeroNumber(leftNumber)),!<=-1,!>=2,0}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  isRightNumberZero {symbolic=(isZeroNumber(rightNumber)),!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 9832
  5 always 5
Line 9833
  "0" always "0"
Line 9834
  simplifcationMade always {!<=-1,!>=2}
  = always 1
  true always 1
Line 9835
  isLeftNumberZero {symbolic=(isZeroNumber(leftNumber)),!<=-1,!>=2,0}
  && always {!<=-1,!>=2}
  isRightNumberZero {symbolic=(isZeroNumber(rightNumber)),!<=-1,!>=2}
Line 9836
  5 always 5
Line 9837
  "1" always "1"
Line 9838
  simplifcationMade always {!<=-1,!>=2}
  = always 1
  true always 1
Line 9839
  isLeftNumberOne {symbolic=(isOneNumber(leftNumber)),!<=-1,!>=2}
Line 9840
  5 always 5
Line 9841
  "1" always "1"
Line 9842
  simplifcationMade always {!<=-1,!>=2}
  = always 1
  true always 1
Line 9845
  ( always {!<=-1,!>=2}
  2 always 2
  "%any% , %num% )" always "%any% , %num% )"
Line 9847
  2 always 2
Line 9848
  4 always 4
Line 9849
  ( always {!<=-1,!>=2}
Line 9851
  5 always 5
Line 9852
  simplifcationMade always {!<=-1,!>=2}
  = always 1
  true always 1
Line 9853
  ( always {!<=-1,!>=2}
Line 9854
  5 always 5
Line 9855
  "1" always "1"
Line 9856
  simplifcationMade always {!<=-1,!>=2}
  = always 1
  true always 1
Line 9861
  simplifcationMade {!<=-1,!>=2,1}
Line 9862
  && always {!<=-1,!>=2}
  != always {!<=-1,!>=2}
  ";" always ";"
Line 9863
  = always !0
  ( always !0
Line 9872
  inReturn always {!<=-1,!>=2}
  inReturn always {!<=-1,!>=2}
  = always 0
  false always 0
Line 9874
  tok possible symbolic=(endAt)
Line 9877
  ( always {!<=-1,!>=2}
  "enum class|struct| %name%| :|{" always "enum class|struct| %name%| :|{"
Line 9878
  & {lifetime[Address]=(tok),!0}
Line 9880
  ! always {!<=-1,!>=2}
Line 9881
  nullptr always 0
Line 9883
  ( always {!<=-1,!>=2}
  tok always !0
  "(|[" always "(|["
  || always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  tok always !0
  "%name%|= {" always "%name%|= {"
Line 9884
  tok always !0
Line 9888
  ( always {!<=-1,!>=2}
  tok always !0
  "= (" always "= ("
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  tok always !0
  1 always 1
  ") {" always ") {"
Line 9889
  tok always !0
  1 always 1
  1 always 1
Line 9894
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  "<" always "<"
Line 9895
  = always !0
  ( always !0
Line 9897
  ( possible size=1
  == {!<=-1,!>=2,0}
  "return" always "return"
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "[;{}]" always "[;{}]"
Line 9898
  inReturn always {!<=-1,!>=2}
  = always 1
  true always 1
Line 9900
  inReturn {!<=-1,!>=2,1}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "[;{}?:]" always "[;{}?:]"
Line 9901
  inReturn always {!<=-1,!>=2}
  = always 0
  false always 0
Line 9903
  ! always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  != always {!<=-1,!>=2}
  "," always ","
Line 9908
  ( {!<=-1,!>=2,0}
  && always {!<=-1,!>=2}
  1 always 1
  == always {!<=-1,!>=2}
  "delete" always "delete"
Line 9910
  ";" always ";"
Line 9913
  ( {!<=-1,!>=2,0}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  -2 always -2
  "delete %name% , %name% ;" always "delete %name% , %name% ;"
  && always {!<=-1,!>=2}
Line 9914
  != always {!<=-1,!>=2}
  0 always 0
Line 9916
  ";" always ";"
Line 9917
  ! always {!<=-1,!>=2}
  inReturn always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  -2 always -2
Line 9918
  replace always {!<=-1,!>=2}
  replace always {!<=-1,!>=2}
  = always 0
  false always 0
Line 9920
  == always {!<=-1,!>=2}
  "=" always "="
Line 9922
  replace always {!<=-1,!>=2}
  = always 1
  true always 1
Line 9923
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "delete %name%" always "delete %name%"
  || always {!<=-1,!>=2}
Line 9924
  ( always {!<=-1,!>=2}
  "delete [ ] %name%" always "delete [ ] %name%"
Line 9926
  replace always {!<=-1,!>=2}
  = always 1
  true always 1
Line 9927
  ( always {!<=-1,!>=2}
  "[?:;,{}()]" always "[?:;,{}()]"
Line 9928
  replace always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "[;{}]" always "[;{}]"
Line 9929
  ";" always ";"
Line 9936
  inReturn {!<=-1,!>=2,0}
Line 9937
  = always 0
  nullptr always 0
Line 9938
  = always 0
  nullptr always 0
Line 9942
  == always {!<=-1,!>=2}
  "return" always "return"
Line 9947
  ! {!<=-1,!>=2,1}
  startFrom possible {symbolic=(tok2->previous()),0}
Line 9950
  = always 0
  0 always 0
Line 9951
  startFrom {symbolic=(tok2->previous()),!0}
Line 9952
  ( possible size=1
  == always {!<=-1,!>=2}
  ";" always ";"
Line 9956
  ( always {!<=-1,!>=2}
  "(|[" always "(|["
  || always {!<=-1,!>=2}
Line 9957
  == always {!<=-1,!>=2}
  "{" always "{"
  && always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always !0
  == always {!<=-1,!>=2}
  "=" always "="
Line 9960
  == always {!<=-1,!>=2}
  "," always ","
Line 9965
  ! always {!<=-1,!>=2}
  endAt possible symbolic=(tok2)
Line 9976
  startFrom always !0
Line 9977
  startFrom always !0
  != always {!<=-1,!>=2}
  endAt always !0
Line 9978
  ( always {!<=-1,!>=2}
  "(|[" always "(|["
  || always {!<=-1,!>=2}
Line 9979
  == always {!<=-1,!>=2}
  "{" always "{"
  && always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always !0
  == always {!<=-1,!>=2}
  "=" always "="
Line 9982
  == always {!<=-1,!>=2}
  "," always ","
Line 9983
  ";" always ";"
Line 9984
  -- possible 0
  commaCounter possible 1
Line 9985
  == always {!<=-1,!>=2}
  0 always 0
Line 9986
  "return" always "return"
Line 9990
  = always !0
  endAt always !0
Line 9998
  ! always {!<=-1,!>=2}
  . always {!<=-1,!>=2}
  checkConfiguration always {!<=-1,!>=2}
Line 10001
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "%name% (" always "%name% ("
Line 10003
  ( always {!<=-1,!>=2}
Line 10005
  2 always 2
  && always {!<=-1,!>=2}
  tok2 always !0
  != always {!<=-1,!>=2}
  ")" always ")"
Line 10006
  == always {!<=-1,!>=2}
  ";" always ";"
Line 10010
  ( always {!<=-1,!>=2}
  "(|{" always "(|{"
Line 10018
  ( always {!<=-1,!>=2}
Line 10022
  ( always {!<=-1,!>=2}
  "const_cast|dynamic_cast|reinterpret_cast|static_cast <" always "const_cast|dynamic_cast|reinterpret_cast|static_cast <"
Line 10023
  "C++ cast <..." always "C++ cast <..."
Line 10025
  ( always {!<=-1,!>=2}
  "%name% < %name% > (" always "%name% < %name% > ("
Line 10026
  5 always 5
Line 10027
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  tok2 always !0
  "[()]" always "[()]"
Line 10028
  tok2 always !0
Line 10029
  ( always {!<=-1,!>=2}
  tok2 possible 0
  ") {" always ") {"
Line 10030
  '<' always 60
  2 always 2
  ">() {}" always ">() {}"
Line 10032
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  ( always !0
  "[;{}]" always "[;{}]"
Line 10034
  ( always {!<=-1,!>=2}
  "using namespace %name% ;" always "using namespace %name% ;"
Line 10035
  "using namespace " always "using namespace "
  2 always 2
Line 10036
  ( always {!<=-1,!>=2}
  "template < class|typename %name% [,>]" always "template < class|typename %name% [,>]"
Line 10037
  "template<..." always "template<..."
Line 10038
  ( always {!<=-1,!>=2}
  "%name% :: %name%" always "%name% :: %name%"
Line 10039
  1 always 1
  2 always 2
Line 10040
  ( always {!<=-1,!>=2}
  "class|namespace %name% [:{]" always "class|namespace %name% [:{]"
Line 10041
  1 always 1
  2 always 2
Line 10048
  = always 0
  nullptr always 0
Line 10049
  tok inconclusive symbolic=(lastTok)
Line 10051
  ( always {!<=-1,!>=2}
  tok always symbolic=(lastTok)
  "[{([]" always "[{([]"
  || always {!<=-1,!>=2}
  tok always symbolic=(lastTok)
  == always {!<=-1,!>=2}
  "<" always "<"
  && always {!<=-1,!>=2}
  tok always symbolic=(lastTok)
Line 10052
  tok always symbolic=(lastTok)
  == always {!<=-1,!>=2}
  nullptr always 0
Line 10053
  tok always symbolic=(lastTok)
Line 10055
  tok always symbolic=(lastTok)
Line 10058
  ( always {!<=-1,!>=2}
  tok always symbolic=(lastTok)
  "[})]]" always "[})]]"
  || always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  tok always symbolic=(lastTok)
  ">|>>" always ">|>>"
  && always {!<=-1,!>=2}
  tok always symbolic=(lastTok)
Line 10059
  tok always symbolic=(lastTok)
  ( possible symbolic=(linkTokens.top())
  == always {!<=-1,!>=2}
  nullptr always 0
Line 10060
  tok always symbolic=(lastTok)
Line 10062
  ( always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  true always 1
Line 10063
  tok always symbolic=(lastTok)
Line 10065
  ( always !0
  != always {!<=-1,!>=2}
Line 10068
  != always {!<=-1,!>=2}
  ( always {symbolic=(tok->link()),symbolic=(linkTokens.top())}
Line 10069
  tok always !symbolic=(tok->link()->link())
Line 10074
  tok always symbolic=(lastTok)
  != always {!<=-1,!>=2}
  nullptr always 0
Line 10075
  tok always symbolic=(lastTok)
Line 10078
  ! {!<=-1,!>=2,0}
  linkTokens possible size=0
  ( {!<=-1,!>=2,1}
Line 10079
  linkTokens always !size=0
Line 10082
  != always {!<=-1,!>=2}
Line 10083
  lastTok always !symbolic=(list.back())
Line 10086
  , always 0
  = always 0
  0 always 0
Line 10089
  != always {!<=-1,!>=2}
  end possible 0@155
  && always {!<=-1,!>=2}
  tok always !symbolic=(end)
  != always {!<=-1,!>=2}
  ";" always ";"
Line 10090
  ( possible size=1
  == always {!<=-1,!>=2}
  "?" always "?"
Line 10092
  ! {!<=-1,!>=2,0}
  ternaryOp possible size=0
  ( {!<=-1,!>=2,1}
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  ":" always ":"
Line 10093
  ternaryOp always !size=0
Line 10094
  < always {!<=-1,!>=2}
  100 always 100
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "(|[" always "(|["
Line 10095
  depth {<=99,!>=100}
  + {<=100,!>=101}
  1 always 1
Line 10097
  inner always !0
Line 10101
  ( always {!<=-1,!>=2}
  nullptr always 0
  : always 0
  ternaryOp always !size=0
Line 10104
  ( always {!<=-1,!>=2}
Line 10106
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "[ [" always "[ ["
  && always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always !0
  == always {!<=-1,!>=2}
  1 always 1
Line 10109
  ( always {!<=-1,!>=2}
Line 10111
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "alignas (" always "alignas ("
  && always {!<=-1,!>=2}
Line 10116
  ( always {!<=-1,!>=2}
Line 10118
  ( always {!<=-1,!>=2}
Line 10124
  ( always {!<=-1,!>=2}
Line 10126
  tok possible symbolic=(endTok->next())@9
  ( always {!<=-1,!>=2}
Line 10127
  return always {!<=-1,!>=2}
  true always 1
Line 10128
  ( always !<=-1
  tok possible symbolic=(endTok->next())@9
  > always {!<=-1,!>=2}
  0 always 0
Line 10129
  return always {!<=-1,!>=2}
  true always 1
Line 10130
  0 always 0
  2 always 2
  "__" always "__"
  == always {!<=-1,!>=2}
  0 always 0
Line 10131
  return always {!<=-1,!>=2}
  true always 1
Line 10132
  return always {!<=-1,!>=2}
  false always 0
Line 10139
  ( always {!<=-1,!>=2}
  "%name% %num%" always "%name% %num%"
Line 10141
  ( always {!<=-1,!>=2}
Line 10144
  ( always {!<=-1,!>=2}
  "%op%|(" always "%op%|("
Line 10151
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "%name% (" always "%name% ("
Line 10153
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 10155
  1 always 1
Line 10156
  2 always 2
  != always {!<=-1,!>=2}
Line 10157
  ( always {!<=-1,!>=2}
  "[[({]" always "[[({]"
Line 10159
  == always {!<=-1,!>=2}
  ";" always ";"
Line 10166
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "%name% (" always "%name% ("
Line 10168
  1 always 1
Line 10169
  2 always 2
  != always {!<=-1,!>=2}
Line 10170
  ( always {!<=-1,!>=2}
  "[[({]" always "[[({]"
Line 10172
  ( always {!<=-1,!>=2}
  "[,(] . %name% =|{" always "[,(] . %name% =|{"
Line 10181
  ( possible size=1
  == always {!<=-1,!>=2}
  "{" always "{"
Line 10183
  prev possible {symbolic=(tok->previous()),0}
  && always {!<=-1,!>=2}
  prev {symbolic=(tok->previous()),!0}
  ( always {!<=-1,!>=2}
Line 10184
  prev always !0
Line 10185
  prev possible {symbolic=(tok->previous()),0}
  && always {!<=-1,!>=2}
  prev always !0
  == always {!<=-1,!>=2}
  ")" always ")"
Line 10188
  possible always NonMovedVariable
Line 10189
  == always {!<=-1,!>=2}
  "}" always "}"
Line 10190
  possible always NonMovedVariable
Line 10192
  ( always {!<=-1,!>=2}
  "%name% (" always "%name% ("
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  1 always 1
  ") (" always ") ("
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  1 always 1
  1 always 1
  ") {" always ") {"
Line 10194
  ( always {!<=-1,!>=2}
Line 10197
  1 always 1
  1 always 1
  2 always 2
Line 10199
  && always {!<=-1,!>=2}
  tok2 always !0
  != always {!<=-1,!>=2}
  bodyEnd always symbolic=(tok->link())
Line 10200
  ( always {!<=-1,!>=2}
  "if|switch|for|while|return" always "if|switch|for|while|return"
Line 10203
  ( always {!<=-1,!>=2}
  "%name% (" always "%name% ("
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  1 always 1
  ") %name% (" always ") %name% ("
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  1 always 1
  2 always 2
  ") [;{]" always ") [;{]"
Line 10204
  ! always {!<=-1,!>=2}
  1 always 1
  && always {!<=-1,!>=2}
  1 always 1
  ( always {!<=-1,!>=2}
Line 10205
  ( always !<=-1
  == always {!<=-1,!>=2}
  0 always 0
Line 10215
  ( always {!<=-1,!>=2}
  "%str% %name% (" always "%str% %name% ("
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  2 always 2
  ") %str%" always ") %str%"
Line 10216
  ( always {!<=-1,!>=2}
Line 10220
  ( always {!<=-1,!>=2}
  "[(,] %name% (" always "[(,] %name% ("
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  2 always 2
  ") %name% %name%|,|)" always ") %name% %name%|,|)"
Line 10221
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  2 always 2
  ( always {!<=-1,!>=2}
Line 10223
  ( always !<=-1
  2 always 2
  > always {!<=-1,!>=2}
  0 always 0
Line 10225
  0 always 0
  2 always 2
  "__" always "__"
  == always {!<=-1,!>=2}
  0 always 0
Line 10233
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "%name% (" always "%name% ("
Line 10235
  ( always {!<=-1,!>=2}
Line 10238
  1 always 1
Line 10239
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  ") %name% (|." always ") %name% (|."
Line 10243
  ( always {!<=-1,!>=2}
  tok2 always symbolic=(endTok->next())
Line 10246
  tok2 always symbolic=(endTok->next())
  == always {!<=-1,!>=2}
  "(" always "("
Line 10247
  ( always {!<=-1,!>=2}
  "%name%|::|>" always "%name%|::|>"
Line 10257
  isCPP11 always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  >= always {!<=-1,!>=2}
  :: always 1
  CPP11 always 1
Line 10259
  "break" always "break"
Line 10260
  "continue" always "continue"
Line 10261
  "for" always "for"
Line 10262
  "goto" always "goto"
Line 10263
  "if" always "if"
Line 10264
  "return" always "return"
Line 10265
  "switch" always "switch"
Line 10266
  "throw" always "throw"
Line 10267
  "typedef" always "typedef"
Line 10268
  "while" always "while"
Line 10272
  ( always {!<=-1,!>=2}
  "= {" always "= {"
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  1 always 1
  "} (" always "} ("
Line 10273
  1 always 1
Line 10276
  == always {!<=-1,!>=2}
  "[" always "["
Line 10277
  != always {!<=-1,!>=2}
Line 10278
  ( always {!<=-1,!>=2}
  "(|[|{" always "(|[|{"
Line 10280
  ( always {!<=-1,!>=2}
  ";|goto|return|typedef" always ";|goto|return|typedef"
Line 10286
  ( always {!<=-1,!>=2}
  "%assign% [" always "%assign% ["
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  1 always 1
  "] ;" always "] ;"
Line 10287
  "[...];" always "[...];"
Line 10290
  ( {!<=-1,!>=2,0}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "throw|return )" always "throw|return )"
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  1 always 1
  "%name% (" always "%name% ("
Line 10291
  1 always 1
Line 10294
  ( always {!<=-1,!>=2}
  "%name% throw|return" always "%name% throw|return"
  && always {!<=-1,!>=2}
  0 always 0
Line 10298
  ( always {!<=-1,!>=2}
  "!!) %num%|%str%|%char% %assign%|++|--" always "!!) %num%|%str%|%char% %assign%|++|--"
Line 10299
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  < always {!<=-1,!>=2}
  :: always 4
  CPP20 always 4
  || always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "%name% : %num% =" always "%name% : %num% ="
Line 10300
  " " always " "
  2 always 2
Line 10303
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "if|while|for|switch" always "if|while|for|switch"
Line 10304
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  ( always !0
  "%name%|:|;|{|}|)" always "%name%|:|;|{|}|)"
Line 10305
  ( always {!<=-1,!>=2}
  ( always !0
  "[,(]" always "[,(]"
Line 10306
  = always !0
  ( always !0
Line 10307
  prev possible {symbolic=(tok->previous()),0}
  && always {!<=-1,!>=2}
  prev {symbolic=(tok->previous()),!0}
  != always {!<=-1,!>=2}
  "(" always "("
Line 10308
  prev always !0
  == always {!<=-1,!>=2}
  ")" always ")"
Line 10309
  prev always !0
Line 10312
  prev possible symbolic=(tok->previous())
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  prev always !0
  "%name% (" always "%name% ("
Line 10313
  prev always !0
Line 10315
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  -2 always -2
  "operator \"\" if" always "operator \"\" if"
Line 10318
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "( !!)" always "( !!)"
Line 10320
  != always {!<=-1,!>=2}
  "for" always "for"
Line 10321
  ( always {!<=-1,!>=2}
  1 always 1
  . possible {>=3,<=2}
  >= {!<=-1,!>=2,>=1,<=0}
  :: always 3
  CPP17 always 3
Line 10327
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always !<=-1
  != always {!<=-1,!>=2}
  0 always 0
Line 10328
  ( always {!<=-1,!>=2}
  "%name% %name%" always "%name% %name%"
  && always {!<=-1,!>=2}
  ( always !<=-1
  == always {!<=-1,!>=2}
  1 always 1
Line 10331
  prev possible {symbolic=(tok),symbolic=(tok->previous())}
  && always {!<=-1,!>=2}
  prev {symbolic=(tok),!0}
  ( always {!<=-1,!>=2}
Line 10332
  prev always !0
Line 10333
  ( always {!<=-1,!>=2}
  prev possible {symbolic=(tok),symbolic=(tok->previous()),0}
  "%op%|%num%|%str%|%char%" always "%op%|%num%|%str%|%char%"
Line 10334
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  -2 always -2
  "operator \"\" if" always "operator \"\" if"
  && always {!<=-1,!>=2}
Line 10335
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  -2 always -2
  "extern \"C\"" always "extern \"C\""
Line 10336
  == always {!<=-1,!>=2}
  prev possible symbolic=(tok->previous())
  " " always " "
  prev always !symbolic=(tok->previous())
  " .. " always " .. "
Line 10343
  ( always {!<=-1,!>=2}
  "struct|class|enum %name%| {" always "struct|class|enum %name%| {"
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  ( always !0
  "[;{}]" always "[;{}]"
Line 10344
  ( always {!<=-1,!>=2}
  2 always 2
  : always 1
  1 always 1
Line 10345
  ( always {!<=-1,!>=2}
  "} %op%" always "} %op%"
Line 10347
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "*|&|&&" always "*|&|&&"
Line 10348
  "Unexpected token '" always "Unexpected token '"
  "'" always "'"
Line 10349
  ( always {!<=-1,!>=2}
  "*|&|&&" always "*|&|&&"
Line 10351
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "%name%" always "%name%"
Line 10352
  "Unexpected token '" always "Unexpected token '"
  "'" always "'"
Line 10358
  "break" always "break"
Line 10359
  "continue" always "continue"
Line 10360
  "for" always "for"
Line 10361
  "goto" always "goto"
Line 10362
  "if" always "if"
Line 10363
  "return" always "return"
Line 10364
  "switch" always "switch"
Line 10365
  "while" always "while"
Line 10366
  "try" always "try"
Line 10367
  "catch" always "catch"
Line 10369
  == always {!<=-1,!>=2}
  "{" always "{"
Line 10371
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always !<=-1
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  -2 always -2
  "operator %str%" always "operator %str%"
Line 10372
  "keyword '" always "keyword '"
  "' is not allowed in global scope" always "' is not allowed in global scope"
Line 10377
  ( always {!<=-1,!>=2}
  "switch (" always "switch ("
Line 10378
  ( always {!<=-1,!>=2}
  1 always 1
  ") {" always ") {"
Line 10379
  1 always 1
  1 always 1
Line 10383
  tok always symbolic=(switchToken)
  1 always 1
Line 10384
  ! always {!<=-1,!>=2}
Line 10388
  == always {!<=-1,!>=2}
  "{" always "{"
Line 10391
  ( always {!<=-1,!>=2}
  ";|}" always ";|}"
Line 10393
  == always {!<=-1,!>=2}
  "}" always "}"
  && always {!<=-1,!>=2}
  -1 always -1
  == always {!<=-1,!>=2}
  ":" always ":"
Line 10398
  ! always {!<=-1,!>=2}
Line 10400
  ( possible size=4
  == {!<=-1,!>=2,0}
  "(" always "("
Line 10402
  == always {!<=-1,!>=2}
  "case" always "case"
Line 10408
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "for (" always "for ("
Line 10411
  = always 0
  0 always 0
Line 10413
  tok always symbolic=(startTok)
Line 10415
  != always {!<=-1,!>=2}
Line 10416
  ( possible size=1
  == always {!<=-1,!>=2}
  ";" always ";"
Line 10418
  == always {!<=-1,!>=2}
  ")" always ")"
Line 10423
  semicolons possible 1
  > {!<=-1,!>=2,0}
  2 always 2
Line 10425
  semicolons {!>=3,<=2}
  == {!<=-1,!>=2,<=0}
  1 always 1
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  >= always {!<=-1,!>=2}
  :: always 4
  CPP20 always 4
Line 10430
  = always 0
  nullptr always 0
Line 10432
  ! always {!<=-1,!>=2}
  templateEndToken possible symbolic=(tok)
Line 10433
  == always {!<=-1,!>=2}
  "<" always "<"
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 10436
  templateEndToken always !0
  == always {!<=-1,!>=2}
Line 10437
  = always 0
  nullptr always 0
Line 10438
  ( always {!<=-1,!>=2}
  "> %cop%" always "> %cop%"
Line 10442
  isCPP11 always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 10447
  match1 always {!<=-1,!>=2}
  match1 always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "%or%|%oror%|==|!=|+|-|/|!|>=|<=|~|^|++|--|::|sizeof" always "%or%|%oror%|==|!=|+|-|/|!|>=|<=|~|^|++|--|::|sizeof"
Line 10448
  match2 always {!<=-1,!>=2}
  match2 always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "{|if|else|while|do|for|return|switch|break" always "{|if|else|while|do|for|return|switch|break"
Line 10449
  ( always {!<=-1,!>=2}
Line 10450
  match1 always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  match1 always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "::|throw|decltype|typeof" always "::|throw|decltype|typeof"
Line 10451
  match2 always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  match2 always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "try|catch|namespace" always "try|catch|namespace"
Line 10453
  match1 always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  match2 always {!<=-1,!>=2}
Line 10456
  ( always {!<=-1,!>=2}
  "%or%|%oror%|~|^|!|%comp%|+|-|/|%" always "%or%|%oror%|~|^|!|%comp%|+|-|/|%"
Line 10458
  ( always {!<=-1,!>=2}
  ")|]|}" always ")|]|}"
Line 10460
  ( always {!<=-1,!>=2}
  "( )" always "( )"
Line 10461
  "()" always "()"
Line 10462
  ! {!<=-1,!>=2,0}
  code possible {symbolic=(tok->str()+"()"),size=0}
  ( {!<=-1,!>=2,1}
Line 10463
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  != always {!<=-1,!>=2}
  ">" always ">"
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "operator" always "operator"
Line 10464
  code always !size=0
Line 10467
  ( always {!<=-1,!>=2}
  "%num%|%bool%|%char%|%str% %num%|%bool%|%char%|%str%" always "%num%|%bool%|%char%|%str% %num%|%bool%|%char%|%str%"
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "%str% %str%" always "%str% %str%"
Line 10469
  ( always {!<=-1,!>=2}
  "%assign% typename|class %assign%" always "%assign% typename|class %assign%"
Line 10471
  ( always {!<=-1,!>=2}
  "%cop%|=|,|[ %or%|%oror%|/|%" always "%cop%|=|,|[ %or%|%oror%|/|%"
Line 10473
  ( always {!<=-1,!>=2}
  ";|(|[ %comp%" always ";|(|[ %comp%"
Line 10475
  ( always {!<=-1,!>=2}
  "%cop%|= ]" always "%cop%|= ]"
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "[|,|%num% &|=|> ]" always "[|,|%num% &|=|> ]"
Line 10477
  ( always {!<=-1,!>=2}
  "[+-] [;,)]}]" always "[+-] [;,)]}]"
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "operator [+-] ;" always "operator [+-] ;"
Line 10479
  ( always {!<=-1,!>=2}
  "," always ","
  && always {!<=-1,!>=2}
Line 10480
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  -2 always -2
  "[ = , &|%name%" always "[ = , &|%name%"
Line 10481
  ( always {!<=-1,!>=2}
  "(|[|{|<|%assign%|%or%|%oror%|==|!=|+|-|/|!|>=|<=|~|^|::|sizeof" always "(|[|{|<|%assign%|%or%|%oror%|==|!=|+|-|/|!|>=|<=|~|^|::|sizeof"
Line 10483
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "throw|decltype|typeof" always "throw|decltype|typeof"
Line 10485
  ( always {!<=-1,!>=2}
  ")|]|>|%assign%|%or%|%oror%|==|!=|/|>=|<=|&&" always ")|]|>|%assign%|%or%|%oror%|==|!=|/|>=|<=|&&"
Line 10488
  ( always {!<=-1,!>=2}
  "." always "."
  && always {!<=-1,!>=2}
Line 10489
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "." always "."
  && always {!<=-1,!>=2}
Line 10490
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "." always "."
  && always {!<=-1,!>=2}
Line 10491
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "{|, . %name% =|.|[|{" always "{|, . %name% =|.|[|{"
  && always {!<=-1,!>=2}
Line 10492
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  ", . %name%" always ", . %name%"
Line 10493
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "%name%|)|]|>|}" always "%name%|)|]|>|}"
Line 10494
  -1 always -1
  " " always " "
  " " always " "
  1 always 1
Line 10495
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "%name%|*|~" always "%name%|*|~"
Line 10496
  -1 always -1
  " " always " "
  " " always " "
  1 always 1
Line 10498
  ( always {!<=-1,!>=2}
  "[!|+-/%^~] )|]" always "[!|+-/%^~] )|]"
Line 10500
  ( always {!<=-1,!>=2}
  "==|!=|<=|>= %comp%" always "==|!=|<=|>= %comp%"
  && always {!<=-1,!>=2}
  -1 always -1
  != always {!<=-1,!>=2}
  "operator" always "operator"
Line 10501
  " " always " "
  1 always 1
Line 10505
  nullptr always 0
Line 10506
  ternaryOp always !0
Line 10509
  ( always {!<=-1,!>=2}
  "%cop%" always "%cop%"
Line 10513
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "%name%|;|}|)" always "%name%|;|}|)"
Line 10515
  == always {!<=-1,!>=2}
  ")" always ")"
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "%name%|> (" always "%name%|> ("
Line 10517
  && always {!<=-1,!>=2}
  end always !0
  ( always {!<=-1,!>=2}
Line 10518
  ( always {!<=-1,!>=2}
  "void|char|short|int|long|float|double|const|volatile|static|inline|struct|class|enum|union|template|sizeof|case|break|continue|typedef" always "void|char|short|int|long|float|double|const|volatile|static|inline|struct|class|enum|union|template|sizeof|case|break|continue|typedef"
Line 10521
  ( possible size=1
  == always {!<=-1,!>=2}
  ")" always ")"
  || always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  "}" always "}"
  && always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always !0
  ( always {!<=-1,!>=2}
Line 10525
  ( always {!<=-1,!>=2}
Line 10527
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "template <" always "template <"
Line 10529
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  ( always !0
  ":|;|{|}|)|>|\"C++\"" always ":|;|{|}|)|>|\"C++\""
Line 10530
  ( always !0
  ( always {!<=-1,!>=2}
Line 10531
  ( always !0
Line 10536
  tok always symbolic=(tok1)
Line 10537
  ! always {!<=-1,!>=2}
Line 10539
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  tok always !0
  ">|>> ::|...| %name%" always ">|>> ::|...| %name%"
  && always {!<=-1,!>=2}
Line 10540
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  tok always !0
  ">|>> [ [ %name%" always ">|>> [ [ %name%"
  && always {!<=-1,!>=2}
Line 10541
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  tok always !0
  "> >|*" always "> >|*"
Line 10542
  tok always !0
  tok always !0
  ( always !0
  : always 1
Line 10548
  ( always {!<=-1,!>=2}
  "[;{}] [ %name% %name% ] ;" always "[;{}] [ %name% %name% ] ;"
Line 10554
  ( always {!<=-1,!>=2}
  , always {!<=-1,!>=2}
  allowSemicolon always {!<=-1,!>=2}
Line 10556
  != always {!<=-1,!>=2}
Line 10557
  ( always {!<=-1,!>=2}
Line 10558
  return always {!<=-1,!>=2}
  true always 1
Line 10559
  ! always {!<=-1,!>=2}
  allowSemicolon always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  ";" always ";"
Line 10560
  return always {!<=-1,!>=2}
  true always 1
Line 10561
  == always {!<=-1,!>=2}
  "{" always "{"
Line 10564
  return always {!<=-1,!>=2}
  false always 0
Line 10571
  i always !<=-1
  = always 0
  0 always 0
  i {!<=-1,0}
  + {!<=0,1}
  1U always 1
  < always {!<=-1,!>=2}
  str possible symbolic=(source)
  ( always !<=-1
  ++ always !<=0
  i always !<=-1
Line 10572
  i always !<=-1
  != always {!<=-1,!>=2}
  '\\' always 92
Line 10575
  = always 97
  'a' always 97
Line 10576
  sz possible >=0
  = always 0
  0 always 0
Line 10577
  i always !<=-1
  + always !<=0
  1 always 1
  == always {!<=-1,!>=2}
  'x' always 120
Line 10578
  = always 2
  2 always 2
Line 10579
  sz possible 2
  < {!<=-1,!>=2,1}
  4 always 4
  && always {!<=-1,!>=2}
  ( always !<=-1
  i always !<=-1
  + always !<=-1
  sz {2,<=3,!>=4}
Line 10580
  sz {<=3,!>=4}
  ++ {<=3,!>=4}
Line 10581
  sz possible >=4
  > {!<=-1,!>=2,>=1}
  2 always 2
Line 10582
  i always !<=-1
  + always !<=1
  2 always 2
  sz {>=3,!<=2}
  - {>=1,!<=0}
  2 always 2
Line 10585
  ( always {!<=-1,!>=2}
  [ always !120
  i always !<=-1
  + always !<=0
  1 always 1
Line 10586
  = always 2
  2 always 2
Line 10587
  sz possible 2
  < {!<=-1,!>=2,1}
  4 always 4
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  i always !<=-1
  + always !<=-1
  sz {2,<=3,!>=4}
Line 10588
  sz {<=3,!>=4}
  ++ {<=3,!>=4}
Line 10589
  i always !<=-1
  + always !<=0
  1 always 1
  sz possible >=4
  - {>=3,!<=2}
  1 always 1
Line 10591
  0 always 0
  i always !<=-1
  i always !<=-1
  + always !<=-1
  sz possible >=4
Line 10595
  sz possible {>=3,<=2}
  <= {!<=-1,!>=2,>=0,<=1}
  2 always 2
Line 10596
  i always !<=-1
  ++ always !<=-1
Line 10597
  i always !<=-1
  + always !<=-1
  sz {>=3,!<=2}
  < always {!<=-1,!>=2}
  ( always !<=-1
Line 10598
  i always !<=-1
  sz always !<=2
  1U always 1
Line 10600
  i always !<=-1
  ( always !<=-1
  - always !<=-1
  i always !<=-1
  - always !<=-1
  1U always 1
  "a" always "a"
Line 10603
  str possible symbolic=(source)
Line 10608
  tok possible symbolic=(old_prev->next())
Line 10610
  while0 {!<=-1,!>=2,0}
  ( always {!<=-1,!>=2}
  "[{};] while ( 0|false )" always "[{};] while ( 0|false )"
Line 10613
  for0 {!<=-1,!>=2,0}
  ( always {!<=-1,!>=2}
  "[{};] for ( %name% = %num% ; %name% < %num% ;" always "[{};] for ( %name% = %num% ; %name% < %num% ;"
  && always {!<=-1,!>=2}
Line 10614
  2 always 2
  == always {!<=-1,!>=2}
  6 always 6
  && always {!<=-1,!>=2}
  4 always 4
  == always {!<=-1,!>=2}
  8 always 8
  || always {!<=-1,!>=2}
Line 10615
  ( always {!<=-1,!>=2}
  "[{};] for ( %type% %name% = %num% ; %name% < %num% ;" always "[{};] for ( %type% %name% = %num% ; %name% < %num% ;"
  && always {!<=-1,!>=2}
Line 10616
  3 always 3
  == always {!<=-1,!>=2}
  7 always 7
  && always {!<=-1,!>=2}
  5 always 5
  == always {!<=-1,!>=2}
  9 always 9
Line 10618
  ! {!<=-1,!>=2,1}
  while0 {!<=-1,!>=2,0}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  for0 always {!<=-1,!>=2}
Line 10621
  while0 always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  "}" always "}"
Line 10624
  tok2 always symbolic=(tok->previous()->link())
Line 10625
  && always {!<=-1,!>=2}
  tok2 always !0
  == always {!<=-1,!>=2}
  "do" always "do"
Line 10626
  flowmatch always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  tok2 always !0
  "continue|break" always "continue|break"
  != always {!<=-1,!>=2}
  nullptr always 0
Line 10628
  tok2 always !0
Line 10629
  ! {!<=-1,!>=2,1}
  flowmatch {!<=-1,!>=2,0}
Line 10630
  tok2 always !0
Line 10634
  4 always 4
Line 10635
  && always {!<=-1,!>=2}
  ( always !0
  == always {!<=-1,!>=2}
  ";" always ";"
Line 10637
  ! always {!<=-1,!>=2}
  flowmatch always {!<=-1,!>=2}
Line 10645
  ( always {!<=-1,!>=2}
  ") {" always ") {"
Line 10647
  end always symbolic=(tok->next()->link())
Line 10648
  ( always {!<=-1,!>=2}
  "for ( %name% =" always "for ( %name% ="
Line 10650
  old_prev possible {symbolic=(tok->previous()),symbolic=(end->link()),0}
Line 10651
  old_prev possible {symbolic=(tok->previous()),symbolic=(end->link())}
  && always {!<=-1,!>=2}
  old_prev always !0
Line 10652
  = always !0
  old_prev always !0
  ( always !0
Line 10661
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 10665
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "try {" always "try {"
Line 10667
  ! always {!<=-1,!>=2}
  "try" always "try"
Line 10671
  1 always 1
Line 10673
  ( always {!<=-1,!>=2}
  endToken possible symbolic=(tryEndToken)
  "} catch (" always "} catch ("
Line 10674
  2 always 2
Line 10675
  ! always {!<=-1,!>=2}
Line 10677
  endToken always !0
  != always {!<=-1,!>=2}
  "{" always "{"
Line 10678
  = always 0
  nullptr always 0
Line 10681
  endToken always !0
Line 10683
  ! {!<=-1,!>=2,1}
  endToken possible {symbolic=(tryEndToken),0}
  || always {!<=-1,!>=2}
  endToken always !0
  == always {!<=-1,!>=2}
Line 10686
  "{" always "{"
Line 10687
  endToken always {!symbolic=(tryEndToken),!0}
  "}" always "}"
Line 10688
  endToken always {!symbolic=(tryEndToken),!0}
Line 10694
  tok possible symbolic=(endpar)
Line 10695
  != always {!<=-1,!>=2}
  "errno" always "errno"
Line 10698
  = always 0
  nullptr always 0
Line 10699
  ( always {!<=-1,!>=2}
  "&& errno == EINTR ) { ;| }" always "&& errno == EINTR ) { ;| }"
Line 10700
  3 always 3
Line 10701
  ( always {!<=-1,!>=2}
  -2 always -2
  "&& ( errno == EINTR ) ) { ;| }" always "&& ( errno == EINTR ) ) { ;| }"
Line 10702
  4 always 4
Line 10706
  ( always {!<=-1,!>=2}
  "while (" always "while ("
Line 10708
  tok1 always symbolic=(tok->previous())
  == always {!<=-1,!>=2}
  "(" always "("
Line 10709
  tok1 always symbolic=(tok->previous())
Line 10712
  tok1 possible symbolic=(tok->previous())
Line 10724
  = always 0
  0 always 0
Line 10725
  tok possible symbolic=(end)
Line 10726
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "while ( %name% ( %name% ) ) {" always "while ( %name% ( %name% ) ) {"
Line 10729
  2 always 2
Line 10730
  4 always 4
Line 10734
  "cppcheck:r" always "cppcheck:r"
Line 10735
  "int" always "int"
Line 10737
  2 always 2
Line 10738
  "while" always "while"
Line 10739
  ";" always ";"
Line 10740
  ")" always ")"
Line 10743
  "(" always "("
Line 10745
  "=" always "="
Line 10748
  4 always 4
  6 always 6
Line 10751
  "=" always "="
Line 10752
  3 always 3
Line 10753
  ";" always ";"
Line 10761
  cpp always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 10764
  = always 0
  0 always 0
Line 10768
  skip always size=0
  false always 0
Line 10772
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 10775
  ( always {!<=-1,!>=2}
  "struct|union {" always "struct|union {"
Line 10776
  ( always {!<=-1,!>=2}
  "} const| *|&| const| %type% ,|;|[|(|{|=" always "} const| *|&| const| %type% ,|;|[|(|{|="
Line 10777
  "Anonymous" always "Anonymous"
Line 10781
  cpp {symbolic=(isCPP()),!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "class|struct :" always "class|struct :"
Line 10782
  "{" always "{"
Line 10783
  tok1 always symbolic=(Token::findsimplematch(tok,"{"))
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  tok1 {symbolic=(Token::findsimplematch(tok,"{")),!0}
  "} const| *|&| const| %type% ,|;|[|(|{" always "} const| *|&| const| %type% ,|;|[|(|{"
Line 10784
  "Anonymous" always "Anonymous"
Line 10788
  ( always {!<=-1,!>=2}
  "enum {" always "enum {"
  && always {!<=-1,!>=2}
Line 10789
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  -3 always -3
  "using %name% =" always "using %name% ="
  && always {!<=-1,!>=2}
Line 10790
  ( always {!<=-1,!>=2}
  "} (| %type%| )| ,|;|[|(|{" always "} (| %type%| )| ,|;|[|(|{"
  || always {!<=-1,!>=2}
Line 10791
  ( always {!<=-1,!>=2}
  "enum : %type% {" always "enum : %type% {"
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  3 always 3
  "} (| %type%| )| ,|;|[|(|{" always "} (| %type%| )| ,|;|[|(|{"
Line 10792
  1 always 1
  == always {!<=-1,!>=2}
  ":" always ":"
  3 always 3
  1 always 1
Line 10793
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  start always !0
  "( %type% )" always "( %type% )"
Line 10794
  start always !0
Line 10795
  start always !0
Line 10797
  "Anonymous" always "Anonymous"
Line 10801
  tok possible {symbolic=(restart),symbolic=(restart),symbolic=(next)}
Line 10804
  ( possible size=1
  == always {!<=-1,!>=2}
  "{" always "{"
Line 10805
  ( always {!<=-1,!>=2}
  "const|)" always "const|)"
Line 10808
  == always {!<=-1,!>=2}
  "}" always "}"
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 10809
  skip always !size=0
Line 10812
  ( always {!<=-1,!>=2}
  "class|struct|union|enum %type% :|{" always "class|struct|union|enum %type% :|{"
Line 10814
  ( always {!<=-1,!>=2}
  start possible symbolic=(tok)
  "%type%" always "%type%"
Line 10816
  tok possible symbolic=(start)
Line 10817
  tok possible symbolic=(start)
  2 always 2
Line 10819
  next possible 0
  && always {!<=-1,!>=2}
  next always !0
  != always {!<=-1,!>=2}
  "{" always "{"
Line 10820
  next always !0
Line 10821
  ! {!<=-1,!>=2,1}
  next possible 0
Line 10823
  false always 0
Line 10824
  next always !0
Line 10825
  ! always {!<=-1,!>=2}
  tok always symbolic=(next->link())
Line 10827
  = always !0
  next always !0
Line 10830
  ( always {!<=-1,!>=2}
  tok {symbolic=(next->link()),!0}
  "const|static|volatile| *|&| const| (| %type% )| ,|;|[|=|(|{" always "const|static|volatile| *|&| const| (| %type% )| ,|;|[|=|(|{"
Line 10831
  tok {symbolic=(next->link()),!0}
  ";" always ";"
Line 10832
  tok {symbolic=(next->link()),!0}
Line 10833
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "struct|class|union|enum" always "struct|class|union|enum"
Line 10838
  ! always {!<=-1,!>=2}
Line 10840
  tok always !0
Line 10841
  != always {!<=-1,!>=2}
  "class" always "class"
Line 10842
  tok always !0
Line 10843
  tok always !0
Line 10846
  2 always 2
Line 10848
  ( always {!<=-1,!>=2}
  "( %type% )" always "( %type% )"
Line 10854
  && always {!<=-1,!>=2}
  tok always !0
  == always {!<=-1,!>=2}
  "(" always "("
  || always {!<=-1,!>=2}
  tok always !0
  == always {!<=-1,!>=2}
  "{" always "{"
Line 10855
  tok always !0
  "=" always "="
Line 10856
  tok always !0
Line 10858
  == always {!<=-1,!>=2}
  "enum" always "enum"
Line 10859
  == always {!<=-1,!>=2}
  "{" always "{"
Line 10860
  "(" always "("
Line 10861
  1 always 1
  ")" always ")"
Line 10867
  = {symbolic=(next),!0}
  restart {symbolic=(next),!0}
Line 10871
  ( always {!<=-1,!>=2}
  "struct|union {" always "struct|union {"
Line 10872
  inFunction always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 10873
  false always 0
Line 10876
  tok always symbolic=(tok1)
Line 10877
  tok always symbolic=(tok1)
  ( always symbolic=(restart)
Line 10880
  && always {!<=-1,!>=2}
  tok always !0
  && always {!<=-1,!>=2}
  tok always !0
  ( always !0
  == always {!<=-1,!>=2}
  ";" always ";"
Line 10881
  inFunction {!<=-1,!>=2,0}
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  "union" always "union"
Line 10883
  2 always 2
Line 10885
  ( always {!<=-1,!>=2}
  tok2 always !0
  "%type% %name% ;" always "%type% %name% ;"
Line 10886
  tok2 always !0
  3 always 3
Line 10890
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "} ;" always "} ;"
Line 10892
  = always 0
  nullptr always 0
Line 10893
  2 always 2
Line 10894
  ( always {!<=-1,!>=2}
  "%type% %name% ;" always "%type% %name% ;"
Line 10895
  ! always {!<=-1,!>=2}
Line 10897
  3 always 3
Line 10899
  "&" always "&"
Line 10900
  2 always 2
Line 10901
  vartok always !0
Line 10902
  vartok always !0
Line 10903
  "=" always "="
Line 10904
  4 always 4
Line 10910
  ! always {!<=-1,!>=2}
  ! {!<=-1,!>=2,0,1}
  inFunction {!<=-1,!>=2,1,0}
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  "union" always "union"
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  -3 always -3
  "using %name% =" always "using %name% ="
Line 10911
  skip always !size=0
Line 10913
  == always {!<=-1,!>=2}
  tok always !0
Line 10918
  tok1 possible symbolic=(tok)
Line 10919
  tok possible symbolic=(tok1)
Line 10920
  tok possible symbolic=(tok1)
Line 10925
  ! always {!<=-1,!>=2}
  restart possible symbolic=(tok1->previous())
Line 10928
  ! always {!<=-1,!>=2}
  restart always !0
Line 10931
  = always !0
  restart always !0
Line 10938
  windows always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 10941
  ( always {!<=-1,!>=2}
  "__cdecl|__stdcall|__fastcall|__thiscall|__clrcall|__syscall|__pascal|__fortran|__far|__near" always "__cdecl|__stdcall|__fastcall|__thiscall|__clrcall|__syscall|__pascal|__fortran|__far|__near"
  || always {!<=-1,!>=2}
  windows {symbolic=(mSettings->isWindowsPlatform()),!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "WINAPI|APIENTRY|CALLBACK" always "WINAPI|APIENTRY|CALLBACK"
Line 10950
  ( always {!<=-1,!>=2}
  "__declspec|_declspec (" always "__declspec|_declspec ("
  && always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always !0
Line 10951
  ( always {!<=-1,!>=2}
  2 always 2
  "noreturn|nothrow" always "noreturn|nothrow"
Line 10953
  tok1 possible {symbolic=(tok->next()->link()->next()),0}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  tok1 {symbolic=(tok->next()->link()->next()),!0}
  "%name%" always "%name%"
Line 10954
  tok1 always !0
Line 10956
  tok1 possible {symbolic=(tok->next()->link()->next()),0}
Line 10957
  2 always 2
  == always {!<=-1,!>=2}
  "noreturn" always "noreturn"
Line 10958
  tok1 always !0
  true always 1
Line 10960
  tok1 always !0
  true always 1
Line 10962
  2 always 2
  == always {!<=-1,!>=2}
  "property" always "property"
Line 10963
  "__property" always "__property"
Line 10974
  ( always {!<=-1,!>=2}
  "%type% (" always "%type% ("
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 10975
  ( always {!<=-1,!>=2}
  true always 1
Line 10976
  true always 1
Line 10977
  ( always {!<=-1,!>=2}
  false always 0
Line 10978
  true always 1
Line 10980
  ( always {!<=-1,!>=2}
  "__attribute__|__attribute (" always "__attribute__|__attribute ("
Line 10982
  ( always {!<=-1,!>=2}
  after possible {symbolic=(tok),0}
  "__attribute__|__attribute (" always "__attribute__|__attribute ("
Line 10983
  1 always 1
Line 10984
  ! always {!<=-1,!>=2}
  after possible symbolic=(tok)
Line 10987
  = always 0
  nullptr always 0
Line 10988
  ( always {!<=-1,!>=2}
  after always !0
  "%name%|*|&|(" always "%name%|*|&|("
Line 10989
  = always !0
  after always !0
Line 10990
  ( always {!<=-1,!>=2}
  ftok possible symbolic=(after)
  "%name%|::|<|*|& !!(" always "%name%|::|<|*|& !!("
Line 10991
  == always {!<=-1,!>=2}
  "<" always "<"
Line 10993
  ! always {!<=-1,!>=2}
Line 10998
  ( always {!<=-1,!>=2}
  ftok possible symbolic=(after)
  "( *" always "( *"
Line 10999
  2 always 2
Line 11000
  ( always {!<=-1,!>=2}
  "%name% (|)" always "%name% (|)"
Line 11002
  ( always {!<=-1,!>=2}
  after always !0
  "[;{=:]" always "[;{=:]"
Line 11004
  ( always {!<=-1,!>=2}
  prev possible {symbolic=(tok->previous()),0}
  "%name%" always "%name%"
Line 11006
  ( always {!<=-1,!>=2}
  prev possible {symbolic=(tok->previous()),0}
  ")" always ")"
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "%name% (" always "%name% ("
Line 11008
  ( always {!<=-1,!>=2}
  prev possible 0
  ")" always ")"
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  -2 always -2
  "operator %op% (" always "operator %op% ("
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 11009
  -2 always -2
Line 11010
  ! always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  prev always !0
  "[;{}*]" always "[;{}*]"
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "%name%" always "%name%"
Line 11014
  2 always 2
  != always {!<=-1,!>=2}
  ")" always ")"
Line 11015
  ( always {!<=-1,!>=2}
  "%name% (" always "%name% ("
Line 11016
  1 always 1
Line 11018
  ( always {!<=-1,!>=2}
  "[(,] constructor|__constructor__ [,()]" always "[(,] constructor|__constructor__ [,()]"
Line 11019
  ! always {!<=-1,!>=2}
Line 11021
  functok always !0
  true always 1
Line 11024
  ( always {!<=-1,!>=2}
  "[(,] destructor|__destructor__ [,()]" always "[(,] destructor|__destructor__ [,()]"
Line 11025
  ! always {!<=-1,!>=2}
Line 11027
  functok always !0
  true always 1
Line 11030
  ( always {!<=-1,!>=2}
  "[(,] unused|__unused__|used|__used__ [,)]" always "[(,] unused|__unused__|used|__used__ [,)]"
Line 11031
  = always 0
  nullptr always 0
Line 11034
  ( always {!<=-1,!>=2}
  after always !0
  ";|=" always ";|="
Line 11035
  ( always {!<=-1,!>=2}
  "%type%" always "%type%"
Line 11040
  ( always {!<=-1,!>=2}
  after always !0
  "%type%" always "%type%"
Line 11041
  = always !0
  after always !0
Line 11043
  vartok possible {symbolic=(tok->previous()),symbolic=(after)}
Line 11045
  ( always !<=-1
  "unused" always "unused"
  != always {!<=-1,!>=2}
Line 11046
  vartok always !0
  true always 1
Line 11048
  vartok always !0
  true always 1
Line 11052
  ( always {!<=-1,!>=2}
  "[(,] pure|__pure__|const|__const__|noreturn|__noreturn__|nothrow|__nothrow__|warn_unused_result [,)]" always "[(,] pure|__pure__|const|__const__|noreturn|__noreturn__|nothrow|__nothrow__|warn_unused_result [,)]"
Line 11053
  ! always {!<=-1,!>=2}
Line 11057
  ( always !<=-1
  "pure" always "pure"
  != always {!<=-1,!>=2}
Line 11058
  functok always !0
  true always 1
Line 11059
  ( always !<=-1
  "const" always "const"
  != always {!<=-1,!>=2}
Line 11060
  functok always !0
  true always 1
Line 11061
  ( always !<=-1
  "noreturn" always "noreturn"
  != always {!<=-1,!>=2}
Line 11062
  functok always !0
  true always 1
Line 11063
  ( always !<=-1
  "nothrow" always "nothrow"
  != always {!<=-1,!>=2}
Line 11064
  functok always !0
  true always 1
Line 11065
  ( always !<=-1
  "warn_unused_result" always "warn_unused_result"
  != always {!<=-1,!>=2}
Line 11066
  functok always !0
  true always 1
Line 11069
  ( always {!<=-1,!>=2}
  "[(,] packed [,)]" always "[(,] packed [,)]"
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "}" always "}"
Line 11070
  true always 1
Line 11073
  1 always 1
Line 11082
  != always {!<=-1,!>=2}
  "(" always "("
Line 11084
  ! always {!<=-1,!>=2}
Line 11086
  ( always !0
Line 11087
  attr always symbolic=(tok->previous()->str())
  0 always 0
  11 always 11
  "__cppcheck_" always "__cppcheck_"
  != always {!<=-1,!>=2}
  0 always 0
Line 11089
  attr always symbolic=(tok->previous()->str())
  attr always symbolic=(tok->previous()->str())
  ( always !<=-1
  - always !<=-1
  2 always 2
  2 always 2
  "__" always "__"
  != always {!<=-1,!>=2}
  0 always 0
Line 11093
  ( always {!<=-1,!>=2}
  vartok possible symbolic=(tok->link())
  "%name%|*|&|::" always "%name%|*|&|::"
Line 11095
  ( always {!<=-1,!>=2}
  "%name% (" always "%name% ("
  && always {!<=-1,!>=2}
  0 always 0
  11 always 11
  "__cppcheck_" always "__cppcheck_"
  == always {!<=-1,!>=2}
  0 always 0
Line 11096
  1 always 1
Line 11099
  vartok possible symbolic=(tok->link())
  ( always {!<=-1,!>=2}
Line 11100
  ( always {!<=-1,!>=2}
  "__cppcheck_low__ ( %num% )" always "__cppcheck_low__ ( %num% )"
Line 11101
  :: always 0
  LOW always 0
Line 11102
  ( always {!<=-1,!>=2}
  "__cppcheck_high__ ( %num% )" always "__cppcheck_high__ ( %num% )"
Line 11103
  :: always 1
  HIGH always 1
Line 11107
  -2 always -2
Line 11108
  -2 always -2
Line 11109
  2 always 2
Line 11112
  1 always 1
Line 11113
  ";" always ";"
Line 11120
  < always {!<=-1,!>=2}
  :: always 1
  CPP11 always 1
  || always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 11123
  tok possible symbolic=(list.front())
Line 11124
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 11127
  ( always {!<=-1,!>=2}
Line 11128
  2 always 2
  "noreturn" always "noreturn"
Line 11130
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 11133
  ( always {!<=-1,!>=2}
  head possible 0
  "%name%|::|*|&|<|>|," always "%name%|::|*|&|<|>|,"
Line 11135
  && always {!<=-1,!>=2}
  head always !0
  == always {!<=-1,!>=2}
  "(" always "("
  && always {!<=-1,!>=2}
  head always !0
  "{|;" always "{|;"
Line 11136
  head always !0
  true always 1
Line 11138
  2 always 2
  "nodiscard" always "nodiscard"
Line 11140
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 11143
  ( always {!<=-1,!>=2}
  head possible 0
  "%name%|::|*|&|<|>|," always "%name%|::|*|&|<|>|,"
Line 11145
  && always {!<=-1,!>=2}
  head always !0
  == always {!<=-1,!>=2}
  "(" always "("
  && always {!<=-1,!>=2}
  head always !0
  "{|;" always "{|;"
Line 11146
  head always !0
  true always 1
Line 11148
  2 always 2
  "maybe_unused" always "maybe_unused"
Line 11150
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 11152
  true always 1
Line 11153
  ( always {!<=-1,!>=2}
  ") [ [ expects|ensures|assert default|audit|axiom| : %name% <|<=|>|>= %num% ] ]" always ") [ [ expects|ensures|assert default|audit|axiom| : %name% <|<=|>|>= %num% ] ]"
Line 11154
  4 always 4
Line 11155
  == always {!<=-1,!>=2}
  ":" always ":"
Line 11157
  -2 always -2
Line 11158
  && always {!<=-1,!>=2}
  argtok always !0
  != always {!<=-1,!>=2}
  "(" always "("
Line 11159
  argtok always !0
  ( possible size=1
  == always {!<=-1,!>=2}
Line 11161
  argtok always !0
  ( always !symbolic=(vartok->str())
  == always {!<=-1,!>=2}
  ")" always ")"
Line 11162
  argtok always !0
Line 11165
  argtok possible 0
  && always {!<=-1,!>=2}
  argtok always !0
  == always {!<=-1,!>=2}
Line 11166
  ( possible {size=1,size=2}
  == {!<=-1,!>=2,0}
  ">=" always ">="
Line 11167
  argtok always !0
  :: always 0
  LOW always 0
  2 always 2
Line 11168
  ( possible {size=2,size=1}
  == {!<=-1,!>=2,0}
  ">" always ">"
Line 11169
  argtok always !0
  :: always 0
  LOW always 0
  2 always 2
  1 always 1
Line 11170
  ( possible size=1
  == {!<=-1,!>=2,0}
  "<=" always "<="
Line 11171
  argtok always !0
  :: always 1
  HIGH always 1
  2 always 2
Line 11172
  == always {!<=-1,!>=2}
  "<" always "<"
Line 11173
  argtok always !0
  :: always 1
  HIGH always 1
  2 always 2
  1 always 1
Line 11177
  ( always {!<=-1,!>=2}
  "alignas (" always "alignas ("
Line 11184
  = always !0
  ( always !0
Line 11185
  tok always !0
Line 11195
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  < always {!<=-1,!>=2}
  :: always 1
  CPP11 always 1
Line 11199
  ( always {!<=-1,!>=2}
  "[;{}] alignas (" always "[;{}] alignas ("
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  2 always 2
  ") %name%" always ") %name%"
Line 11200
  2 always 2
Line 11206
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  >= always {!<=-1,!>=2}
  :: always 4
  CPP20 always 4
Line 11207
  && always {!<=-1,!>=2}
  tok always !0
Line 11208
  ( always {!<=-1,!>=2}
  "<= >" always "<= >"
Line 11209
  "<=>" always "<=>"
Line 11217
  "inline" always "inline"
Line 11218
  "_inline" always "_inline"
Line 11219
  "__inline" always "__inline"
Line 11220
  "__forceinline" always "__forceinline"
Line 11221
  "register" always "register"
Line 11222
  "__restrict" always "__restrict"
Line 11223
  "__restrict__" always "__restrict__"
Line 11224
  "__thread" always "__thread"
Line 11238
  c99 always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  ( {!<=-1,!>=2,0}
  && always {!<=-1,!>=2}
  >= always {!<=-1,!>=2}
  :: always 1
  C99 always 1
Line 11239
  cpp11 always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  >= always {!<=-1,!>=2}
  :: always 1
  CPP11 always 1
Line 11242
  ( possible lifetime[Iterator]=(keywords)
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(keywords),end=0}
Line 11244
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "." always "."
Line 11245
  ( always !<=-1
  "inline" always "inline"
  != always {!<=-1,!>=2}
Line 11247
  temp possible symbolic=(tok->next())
  != always {!<=-1,!>=2}
  nullptr always 0
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  temp {symbolic=(tok->next()),!0}
  "%name%" always "%name%"
Line 11248
  temp always !0
  true always 1
Line 11249
  temp always !0
Line 11256
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 0
  CPP03 always 0
Line 11257
  == always {!<=-1,!>=2}
  "auto" always "auto"
Line 11263
  ( always {!<=-1,!>=2}
  "[ static %num%" always "[ static %num%"
Line 11266
  c99 {symbolic=(isC()&&mSettings->standards.c>=Standards::C99),!<=-1,!>=2}
Line 11267
  == always {!<=-1,!>=2}
  "restrict" always "restrict"
Line 11270
  >= always {!<=-1,!>=2}
  :: always 2
  C11 always 2
Line 11271
  == always {!<=-1,!>=2}
  "_Atomic" always "_Atomic"
Line 11276
  cpp11 {symbolic=(isCPP()&&mSettings->standards.cpp>=Standards::CPP11),!<=-1,!>=2}
Line 11279
  ( always {!<=-1,!>=2}
  "struct|class|union %type% final [:{]" always "struct|class|union %type% final [:{]"
Line 11285
  ( always {!<=-1,!>=2}
  ") noexcept :|{|;|const|override|final" always ") noexcept :|{|;|const|override|final"
Line 11289
  tokNoExcept always symbolic=(tok->next())
  ")" always ")"
Line 11290
  tokNoExcept always symbolic=(tok->next())
Line 11291
  tokNoExcept always symbolic=(tok->next())
  "true" always "true"
Line 11292
  tokNoExcept always symbolic=(tok->next())
  "(" always "("
Line 11293
  tokNoExcept always symbolic=(tok->next())
Line 11294
  3 always 3
Line 11300
  == always {!<=-1,!>=2}
  "thread_local" always "thread_local"
Line 11302
  "static" always "static"
Line 11311
  == always {!<=-1,!>=2}
  "(" always "("
Line 11315
  ( always {!<=-1,!>=2}
  "[;{}] %name% ( %name% =" always "[;{}] %name% ( %name% ="
  && always {!<=-1,!>=2}
Line 11316
  ( always {!<=-1,!>=2}
  2 always 2
  ") ;" always ") ;"
  && always {!<=-1,!>=2}
Line 11317
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "assert|while" always "assert|while"
Line 11319
  3 always 3
Line 11322
  2 always 2
Line 11323
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "(|[|{" always "(|[|{"
Line 11324
  = always !0
  ( always !0
Line 11325
  == always {!<=-1,!>=2}
  ";" always ";"
Line 11327
  ( always {!<=-1,!>=2}
  ")|," always ")|,"
Line 11333
  "(" always "("
Line 11334
  2 always 2
Line 11337
  ";" always ";"
Line 11350
  ( always {!<=-1,!>=2}
  "[;{}] %name% = ( {" always "[;{}] %name% = ( {"
Line 11354
  = always 0
  0 always 0
Line 11356
  nullptr always 0
  != always {!<=-1,!>=2}
  tok2 possible symbolic=(tok)
Line 11357
  ( always {!<=-1,!>=2}
  tok2 always !0
  "(|{" always "(|{"
Line 11359
  ( always {!<=-1,!>=2}
  tok2 always !0
  ")|}" always ")|}"
Line 11360
  <= always {!<=-1,!>=2}
  2 always 2
Line 11362
  -- {!<=1,>=2}
  indentlevel {!<=2,>=3}
Line 11363
  == always {!<=-1,!>=2}
  2 always 2
  && always {!<=-1,!>=2}
  tok2 always !0
  == always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  tok2 always !0
  "%type%|*" always "%type%|*"
Line 11367
  == always {!<=-1,!>=2}
  2 always 2
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "} )" always "} )"
Line 11368
  -3 always -3
Line 11369
  ( always {!<=-1,!>=2}
  "[;{}] %num%|%name% ;" always "[;{}] %num%|%name% ;"
Line 11370
  "=" always "="
Line 11373
  3 always 3
Line 11374
  5 always 5
Line 11386
  ( always {!<=-1,!>=2}
  "__asm|_asm|asm {" always "__asm|_asm|asm {"
  && always {!<=-1,!>=2}
Line 11388
  2 always 2
Line 11392
  ( always {!<=-1,!>=2}
  "asm|__asm|__asm__ volatile|__volatile|__volatile__| (" always "asm|__asm|__asm__ volatile|__volatile|__volatile__| ("
Line 11395
  partok always symbolic=(tok->next())
  != always {!<=-1,!>=2}
  "(" always "("
Line 11396
  partok always symbolic=(tok->next())
Line 11397
  partok possible symbolic=(tok->next())
  partok possible symbolic=(tok->next())
Line 11401
  ( always {!<=-1,!>=2}
  "_asm|__asm" always "_asm|__asm"
Line 11403
  = always 0
  nullptr always 0
Line 11404
  = always 0
  0 always 0
Line 11405
  ( always {!<=-1,!>=2}
  endasm possible symbolic=(tok->next())
  "%num%|%name%|,|:|;" always "%num%|%name%|,|:|;"
  || always {!<=-1,!>=2}
  endasm possible symbolic=(tok->next())
  && always {!<=-1,!>=2}
  endasm {symbolic=(tok->next()),!0}
  == always {!<=-1,!>=2}
  comment possible 0
Line 11406
  ( always {!<=-1,!>=2}
  "_asm|__asm|__endasm" always "_asm|__asm|__endasm"
Line 11408
  == always {!<=-1,!>=2}
  ";" always ";"
Line 11410
  ! always {!<=-1,!>=2}
Line 11413
  endasm possible symbolic=(firstSemiColon)
Line 11415
  ( always {!<=-1,!>=2}
  endasm possible {symbolic=(tok->next()),0}
  "__endasm" always "__endasm"
Line 11418
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  ";" always ";"
Line 11419
  ";" always ";"
Line 11421
  firstSemiColon always !0
Line 11423
  ! always {!<=-1,!>=2}
Line 11424
  endasm always 0
Line 11425
  endasm inconclusive 0
Line 11426
  ";" always ";"
Line 11434
  ( always {!<=-1,!>=2}
  ") %name% %name% (" always ") %name% %name% ("
Line 11440
  "asm" always "asm"
Line 11441
  1 always 1
  != always {!<=-1,!>=2}
  ";" always ";"
  && always {!<=-1,!>=2}
  1 always 1
  != always {!<=-1,!>=2}
  "{" always "{"
Line 11442
  ";" always ";"
Line 11443
  ")" always ")"
Line 11444
  "\"" always "\""
  "\"" always "\""
Line 11445
  "(" always "("
Line 11448
  2 always 2
Line 11451
  2 always 2
Line 11452
  && always {!<=-1,!>=2}
  ( always !0
  == always {!<=-1,!>=2}
  ";" always ";"
  && always {!<=-1,!>=2}
Line 11453
  ( always !0
  != always {!<=-1,!>=2}
Line 11454
  = always !symbolic=(tok->linenr())
  ( always !0
  ( always !symbolic=(tok->linenr())
Line 11455
  -3 always -3
Line 11456
  = always 0
  0 always 0
  i possible {0,1}
  < {!<=-1,!>=2,1}
  4 always 4
  ++ possible 1
  i possible 0
Line 11471
  != always {!<=-1,!>=2}
  "^" always "^"
Line 11474
  ( always {!<=-1,!>=2}
  "^ {" always "^ {"
  || always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  1 always 1
  ") {" always ") {"
  && always {!<=-1,!>=2}
  -1 always -1
  != always {!<=-1,!>=2}
  "operator" always "operator"
Line 11476
  start possible {symbolic=(tok),0}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  start {symbolic=(tok),!0}
  "[,(;{}=]" always "[,(;{}=]"
Line 11477
  start always !0
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  start always !0
  ")|]|>" always ")|]|>"
Line 11478
  = always !0
  start always !0
  ( always !0
Line 11482
  tok possible symbolic=(start)
Line 11483
  ( always {!<=-1,!>=2}
  last always symbolic=(tok->next()->link())
  ") {" always ") {"
Line 11484
  last always symbolic=(tok->next()->link())
  1 always 1
Line 11485
  last possible symbolic=(tok->next()->link())
Line 11486
  last possible {symbolic=(start->next()),0}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  last always !0
  "%cop%|,|;|{|}|)" always "%cop%|,|;|{|}|)"
Line 11487
  ( always {!<=-1,!>=2}
  last always !0
  "(|[" always "(|["
Line 11488
  last always !0
Line 11492
  && always {!<=-1,!>=2}
Line 11494
  start always !0
  != always {!<=-1,!>=2}
  last always !0
Line 11495
  start always !0
  ( always !symbolic=(last)
Line 11496
  start always !0
Line 11498
  last {!0,symbolic=(start->next())}
  == always {!<=-1,!>=2}
  "}" always "}"
Line 11499
  start always !0
  ";" always ";"
Line 11500
  start always !0
  ")" always ")"
Line 11501
  start always !0
  "\"" always "\""
  "\"" always "\""
Line 11502
  start always !0
  "(" always "("
Line 11503
  start always !0
  "asm" always "asm"
Line 11504
  start always !0
  2 always 2
  start always !0
  4 always 4
Line 11505
  start always !0
  4 always 4
  start always !0
  2 always 2
Line 11506
  start always !0
  4 always 4
Line 11517
  ( always {!<=-1,!>=2}
  "%name%|] @ %num%|%name%|(" always "%name%|] @ %num%|%name%|("
Line 11518
  2 always 2
Line 11519
  ( always {!<=-1,!>=2}
Line 11521
  == always {!<=-1,!>=2}
  "(" always "("
Line 11522
  = always 0
  0 always 0
Line 11523
  != always {!<=-1,!>=2}
  nullptr always 0
Line 11524
  end always !0
  ( possible size=1
  == always {!<=-1,!>=2}
  "(" always "("
Line 11526
  end always !0
  == always {!<=-1,!>=2}
  ")" always ")"
Line 11527
  < always {!<=-1,!>=2}
  0 always 0
Line 11531
  = possible 0
  end possible 0
  ? possible 0
  end always !0
  : always 0
  nullptr always 0
Line 11532
  ( possible lifetime[Iterator]=(var)
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(var),end=0}
Line 11537
  ( always {!<=-1,!>=2}
  end possible 0
  ": %num% ;" always ": %num% ;"
Line 11538
  2 always 2
Line 11540
  && always {!<=-1,!>=2}
  end always !0
  == always {!<=-1,!>=2}
  ";" always ";"
Line 11541
  ( always {!<=-1,!>=2}
Line 11543
  true always 1
Line 11544
  end always !0
Line 11550
  ( always {!<=-1,!>=2}
  "@ builtin|eeprom|far|inline|interrupt|near|noprd|nostack|nosvf|packed|stack|svlreg|tiny|vector" always "@ builtin|eeprom|far|inline|interrupt|near|noprd|nostack|nosvf|packed|stack|svlreg|tiny|vector"
Line 11551
  "@" always "@"
Line 11560
  goback always {!<=-1,!>=2}
  goback always {!<=-1,!>=2}
  = always 0
  false always 0
Line 11562
  goback always {!<=-1,!>=2}
Line 11563
  goback always {!<=-1,!>=2}
  = always 0
  false always 0
Line 11566
  = always 0
  nullptr always 0
Line 11568
  ( always {!<=-1,!>=2}
  "for (" always "for ("
Line 11569
  1 always 1
Line 11571
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  ";|{|}|public:|protected:|private:" always ";|{|}|public:|protected:|private:"
Line 11574
  isEnum {!<=-1,!>=2,0}
  isEnum always {!<=-1,!>=2}
  = always 0
  false always 0
Line 11575
  == always {!<=-1,!>=2}
  "}" always "}"
Line 11577
  type possible symbolic=(tok->link()->previous())
  && always {!<=-1,!>=2}
  type {symbolic=(tok->link()->previous()),!0}
  ( always {!<=-1,!>=2}
Line 11578
  type always !0
  == always {!<=-1,!>=2}
  "enum" always "enum"
Line 11579
  isEnum always {!<=-1,!>=2}
  = always 1
  true always 1
Line 11582
  type always !0
Line 11586
  ( always {!<=-1,!>=2}
  "const| %type% %name% :" always "const| %type% %name% :"
  && always {!<=-1,!>=2}
Line 11587
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "case|public|protected|private|class|struct" always "case|public|protected|private|class|struct"
  && always {!<=-1,!>=2}
Line 11588
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  2 always 2
  "default :" always "default :"
Line 11589
  == always {!<=-1,!>=2}
  "const" always "const"
  3 always 3
  2 always 2
Line 11590
  ( always {!<=-1,!>=2}
  "%name% : %num% [;=]" always "%name% : %num% [;=]"
Line 11591
  2 always 2
Line 11592
  && always {!<=-1,!>=2}
  tok1 always !0
  2 always 2
  && always {!<=-1,!>=2}
Line 11593
  ( always {!<=-1,!>=2}
  tok1 always !0
  2 always 2
  "%bool%|%num%" always "%bool%|%num%"
  || always {!<=-1,!>=2}
Line 11594
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  tok1 always !0
  2 always 2
  "public|protected|private| %type% ::|<|,|{|;" always "public|protected|private| %type% ::|<|,|{|;"
Line 11595
  tok1 always !0
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  tok1 always !0
  ( always !0
  "[;,)]{}=]" always "[;,)]{}=]"
Line 11596
  ( always {!<=-1,!>=2}
  tok1 always !0
  ( always !0
  "[([]" always "[([]"
Line 11597
  tok1 always !0
  tok1 always !0
Line 11598
  tok1 always !0
Line 11601
  tok1 always !0
Line 11603
  isEnum always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "} %name%| : %num% ;" always "} %name%| : %num% ;"
Line 11604
  == always {!<=-1,!>=2}
  ":" always ":"
Line 11605
  2 always 2
Line 11606
  "Anonymous" always "Anonymous"
Line 11608
  2 always 2
Line 11610
  ( always {!<=-1,!>=2}
  "const| %type% : %num%|%bool% ;" always "const| %type% : %num%|%bool% ;"
  && always {!<=-1,!>=2}
Line 11611
  != always {!<=-1,!>=2}
  "default" always "default"
Line 11612
  == always {!<=-1,!>=2}
  "const" always "const"
  1 always 1
  : always 0
  0 always 0
Line 11613
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  3 always 3
  offset always symbolic=((tok->next()->str()=="const")?1:0)
  "[{};()]" always "[{};()]"
Line 11614
  4 always 4
Line 11615
  goback always {!<=-1,!>=2}
  = always 1
  true always 1
Line 11619
  last possible symbolic=(tok1->next())
  && always {!<=-1,!>=2}
  last always !0
  == always {!<=-1,!>=2}
  "," always ","
Line 11620
  = always !0
  last always !0
Line 11621
  tok1 {symbolic=(last),!0}
  ";" always ";"
Line 11624
  tok1 {symbolic=(last),!0}
  tok2 always symbolic=(tok->next())
Line 11625
  tok1 {symbolic=(last),!0}
Line 11626
  tok2 always symbolic=(tok->next())
  ( always {!<=-1,!>=2}
Line 11627
  tok2 always symbolic=(tok->next())
  ( always {!<=-1,!>=2}
Line 11628
  tok2 always symbolic=(tok->next())
  ( always {!<=-1,!>=2}
Line 11636
  "string" always "string"
  "wstring" always "wstring"
  "u16string" always "u16string"
  "u32string" always "u32string"
Line 11637
  "iostream" always "iostream"
  "ostream" always "ostream"
  "ofstream" always "ofstream"
  "ostringstream" always "ostringstream"
Line 11638
  "istream" always "istream"
  "ifstream" always "ifstream"
  "istringstream" always "istringstream"
  "fstream" always "fstream"
  "stringstream" always "stringstream"
Line 11639
  "wstringstream" always "wstringstream"
  "wistringstream" always "wistringstream"
  "wostringstream" always "wostringstream"
  "wstringbuf" always "wstringbuf"
Line 11640
  "stringbuf" always "stringbuf"
  "streambuf" always "streambuf"
  "ios" always "ios"
  "filebuf" always "filebuf"
  "ios_base" always "ios_base"
Line 11641
  "exception" always "exception"
  "bad_exception" always "bad_exception"
  "bad_alloc" always "bad_alloc"
Line 11642
  "logic_error" always "logic_error"
  "domain_error" always "domain_error"
  "invalid_argument_" always "invalid_argument_"
  "length_error" always "length_error"
Line 11643
  "out_of_range" always "out_of_range"
  "runtime_error" always "runtime_error"
  "range_error" always "range_error"
  "overflow_error" always "overflow_error"
  "underflow_error" always "underflow_error"
Line 11644
  "locale" always "locale"
Line 11645
  "cout" always "cout"
  "cerr" always "cerr"
  "clog" always "clog"
  "cin" always "cin"
Line 11646
  "wcerr" always "wcerr"
  "wcin" always "wcin"
  "wclog" always "wclog"
  "wcout" always "wcout"
Line 11647
  "endl" always "endl"
  "ends" always "ends"
  "flush" always "flush"
Line 11648
  "boolalpha" always "boolalpha"
  "noboolalpha" always "noboolalpha"
  "showbase" always "showbase"
  "noshowbase" always "noshowbase"
Line 11649
  "showpoint" always "showpoint"
  "noshowpoint" always "noshowpoint"
  "showpos" always "showpos"
  "noshowpos" always "noshowpos"
Line 11650
  "skipws" always "skipws"
  "noskipws" always "noskipws"
  "unitbuf" always "unitbuf"
  "nounitbuf" always "nounitbuf"
  "uppercase" always "uppercase"
  "nouppercase" always "nouppercase"
Line 11651
  "dec" always "dec"
  "hex" always "hex"
  "oct" always "oct"
Line 11652
  "fixed" always "fixed"
  "scientific" always "scientific"
Line 11653
  "internal" always "internal"
  "left" always "left"
  "right" always "right"
Line 11654
  "fpos" always "fpos"
  "streamoff" always "streamoff"
  "streampos" always "streampos"
  "streamsize" always "streamsize"
Line 11658
  "array" always "array"
  "basic_string" always "basic_string"
  "bitset" always "bitset"
  "deque" always "deque"
  "list" always "list"
  "map" always "map"
  "multimap" always "multimap"
Line 11659
  "priority_queue" always "priority_queue"
  "queue" always "queue"
  "set" always "set"
  "multiset" always "multiset"
  "stack" always "stack"
  "vector" always "vector"
  "pair" always "pair"
Line 11660
  "iterator" always "iterator"
  "iterator_traits" always "iterator_traits"
Line 11661
  "unordered_map" always "unordered_map"
  "unordered_multimap" always "unordered_multimap"
  "unordered_set" always "unordered_set"
  "unordered_multiset" always "unordered_multiset"
Line 11662
  "tuple" always "tuple"
  "function" always "function"
Line 11665
  "getline" always "getline"
Line 11666
  "for_each" always "for_each"
  "find" always "find"
  "find_if" always "find_if"
  "find_end" always "find_end"
  "find_first_of" always "find_first_of"
Line 11667
  "adjacent_find" always "adjacent_find"
  "count" always "count"
  "count_if" always "count_if"
  "mismatch" always "mismatch"
  "equal" always "equal"
  "search" always "search"
  "search_n" always "search_n"
Line 11668
  "copy" always "copy"
  "copy_backward" always "copy_backward"
  "swap" always "swap"
  "swap_ranges" always "swap_ranges"
  "iter_swap" always "iter_swap"
  "transform" always "transform"
  "replace" always "replace"
Line 11669
  "replace_if" always "replace_if"
  "replace_copy" always "replace_copy"
  "replace_copy_if" always "replace_copy_if"
  "fill" always "fill"
  "fill_n" always "fill_n"
  "generate" always "generate"
  "generate_n" always "generate_n"
  "remove" always "remove"
Line 11670
  "remove_if" always "remove_if"
  "remove_copy" always "remove_copy"
  "remove_copy_if" always "remove_copy_if"
Line 11671
  "unique" always "unique"
  "unique_copy" always "unique_copy"
  "reverse" always "reverse"
  "reverse_copy" always "reverse_copy"
Line 11672
  "rotate" always "rotate"
  "rotate_copy" always "rotate_copy"
  "random_shuffle" always "random_shuffle"
  "partition" always "partition"
  "stable_partition" always "stable_partition"
Line 11673
  "sort" always "sort"
  "stable_sort" always "stable_sort"
  "partial_sort" always "partial_sort"
  "partial_sort_copy" always "partial_sort_copy"
  "nth_element" always "nth_element"
Line 11674
  "lower_bound" always "lower_bound"
  "upper_bound" always "upper_bound"
  "equal_range" always "equal_range"
  "binary_search" always "binary_search"
  "merge" always "merge"
  "inplace_merge" always "inplace_merge"
  "includes" always "includes"
Line 11675
  "set_union" always "set_union"
  "set_intersection" always "set_intersection"
  "set_difference" always "set_difference"
Line 11676
  "set_symmetric_difference" always "set_symmetric_difference"
  "push_heap" always "push_heap"
  "pop_heap" always "pop_heap"
  "make_heap" always "make_heap"
  "sort_heap" always "sort_heap"
Line 11677
  "min" always "min"
  "max" always "max"
  "min_element" always "min_element"
  "max_element" always "max_element"
  "lexicographical_compare" always "lexicographical_compare"
  "next_permutation" always "next_permutation"
  "prev_permutation" always "prev_permutation"
Line 11678
  "advance" always "advance"
  "back_inserter" always "back_inserter"
  "distance" always "distance"
  "front_inserter" always "front_inserter"
  "inserter" always "inserter"
Line 11679
  "make_pair" always "make_pair"
  "make_shared" always "make_shared"
  "make_tuple" always "make_tuple"
Line 11686
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 11689
  isCPP11 always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 1
  CPP11 always 1
Line 11693
  "using namespace std ;" always "using namespace std ;"
Line 11694
  insert {!<=-1,!>=2,0}
  insert always {!<=-1,!>=2}
  = always 0
  false always 0
Line 11695
  ( always {!<=-1,!>=2}
  "enum class|struct| %name%| :|{" always "enum class|struct| %name%| :|{"
Line 11696
  & {lifetime[Address]=(tok),!0}
Line 11698
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  ".|::" always ".|::"
Line 11699
  ( always {!<=-1,!>=2}
  "%name% (" always "%name% ("
Line 11700
  "{" always "{"
Line 11702
  ";" always ";"
Line 11704
  ( always {!<=-1,!>=2}
  start possible symbolic=(tok)
  ( possible 0
  "%type%|*|&" always "%type%|*|&"
Line 11706
  start possible symbolic=(tok)
  != {!<=-1,!>=2,0}
  tok possible symbolic=(start)
  && always {!<=-1,!>=2}
  start always !symbolic=(tok)
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  start always !symbolic=(tok)
  || always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  start always !symbolic=(tok)
  ( always !0
  "[;{}]" always "[;{}]"
Line 11707
  tok always !symbolic=(start)
Line 11709
  ( possible lifetime[Iterator]=(userFunctions)
  tok possible symbolic=(start)
  == always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(userFunctions),end=0}
  && always {!<=-1,!>=2}
  ( possible lifetime[Iterator]=(stdFunctions)
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(stdFunctions),end=0}
Line 11710
  insert always {!<=-1,!>=2}
  = always 1
  true always 1
Line 11711
  ( always {!<=-1,!>=2}
  "%name% <" always "%name% <"
  && always {!<=-1,!>=2}
  ( possible lifetime[Iterator]=(stdTemplates)
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(stdTemplates),end=0}
Line 11712
  insert always {!<=-1,!>=2}
  = always 1
  true always 1
Line 11713
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "(|<" always "(|<"
  && always {!<=-1,!>=2}
  ( possible lifetime[Iterator]=(stdTypes)
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(stdTypes),end=0}
Line 11714
  insert always {!<=-1,!>=2}
  = always 1
  true always 1
Line 11717
  insert {!<=-1,!>=2,1}
Line 11718
  "std" always "std"
Line 11721
  "::" always "::"
Line 11722
  isCPP11 {symbolic=(mSettings->standards.cpp==Standards::CPP11),!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "!!:: tr1 ::" always "!!:: tr1 ::"
Line 11723
  "std" always "std"
Line 11727
  isCPP11 {symbolic=(mSettings->standards.cpp==Standards::CPP11),!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "std :: tr1 ::" always "std :: tr1 ::"
Line 11728
  3 always 3
Line 11730
  ( always {!<=-1,!>=2}
  "using namespace std ;" always "using namespace std ;"
Line 11731
  4 always 4
Line 11741
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 11745
  1 always 1
  != always {!<=-1,!>=2}
  "(" always "("
Line 11748
  ( always {!<=-1,!>=2}
  "CopyMemory|RtlCopyMemory|RtlCopyBytes" always "CopyMemory|RtlCopyMemory|RtlCopyBytes"
Line 11749
  "memcpy" always "memcpy"
Line 11750
  ( always {!<=-1,!>=2}
  "MoveMemory|RtlMoveMemory" always "MoveMemory|RtlMoveMemory"
Line 11751
  "memmove" always "memmove"
Line 11752
  ( always {!<=-1,!>=2}
  "FillMemory|RtlFillMemory|RtlFillBytes" always "FillMemory|RtlFillMemory|RtlFillBytes"
Line 11754
  "memset" always "memset"
Line 11756
  2 always 2
Line 11758
  tok1 always !0
Line 11760
  tok1 always !0
Line 11762
  tok2 {symbolic=(tok1->nextArgument()),0}
Line 11763
  tok1 always !0
  tok2 {symbolic=(tok1->nextArgument()),!0}
  -2 always -2
Line 11765
  ( always {!<=-1,!>=2}
  "ZeroMemory|RtlZeroMemory|RtlZeroBytes|RtlSecureZeroMemory" always "ZeroMemory|RtlZeroMemory|RtlZeroBytes|RtlSecureZeroMemory"
Line 11767
  "memset" always "memset"
Line 11769
  2 always 2
Line 11771
  tok1 always !0
Line 11774
  tok1 always !0
Line 11775
  "0" always "0"
Line 11777
  "," always ","
Line 11779
  ( always {!<=-1,!>=2}
  "RtlCompareMemory" always "RtlCompareMemory"
Line 11781
  "memcmp" always "memcmp"
Line 11798
  "_topen" always "_topen"
  "open" always "open"
  "_wopen" always "_wopen"
Line 11799
  "_tsopen_s" always "_tsopen_s"
  "_sopen_s" always "_sopen_s"
  "_wsopen_s" always "_wsopen_s"
Line 11800
  "_tfopen" always "_tfopen"
  "fopen" always "fopen"
  "_wfopen" always "_wfopen"
Line 11801
  "_tfopen_s" always "_tfopen_s"
  "fopen_s" always "fopen_s"
  "_wfopen_s" always "_wfopen_s"
Line 11802
  "_tfreopen" always "_tfreopen"
  "freopen" always "freopen"
  "_wfreopen" always "_wfreopen"
Line 11803
  "_tfreopen_s" always "_tfreopen_s"
  "freopen_s" always "freopen_s"
  "_wfreopen_s" always "_wfreopen_s"
Line 11804
  "_tcscat" always "_tcscat"
  "strcat" always "strcat"
  "wcscat" always "wcscat"
Line 11805
  "_tcschr" always "_tcschr"
  "strchr" always "strchr"
  "wcschr" always "wcschr"
Line 11806
  "_tcscmp" always "_tcscmp"
  "strcmp" always "strcmp"
  "wcscmp" always "wcscmp"
Line 11807
  "_tcsdup" always "_tcsdup"
  "strdup" always "strdup"
  "wcsdup" always "wcsdup"
Line 11808
  "_tcscpy" always "_tcscpy"
  "strcpy" always "strcpy"
  "wcscpy" always "wcscpy"
Line 11809
  "_tcslen" always "_tcslen"
  "strlen" always "strlen"
  "wcslen" always "wcslen"
Line 11810
  "_tcsncat" always "_tcsncat"
  "strncat" always "strncat"
  "wcsncat" always "wcsncat"
Line 11811
  "_tcsncpy" always "_tcsncpy"
  "strncpy" always "strncpy"
  "wcsncpy" always "wcsncpy"
Line 11812
  "_tcsnlen" always "_tcsnlen"
  "strnlen" always "strnlen"
  "wcsnlen" always "wcsnlen"
Line 11813
  "_tcsrchr" always "_tcsrchr"
  "strrchr" always "strrchr"
  "wcsrchr" always "wcsrchr"
Line 11814
  "_tcsstr" always "_tcsstr"
  "strstr" always "strstr"
  "wcsstr" always "wcsstr"
Line 11815
  "_tcstok" always "_tcstok"
  "strtok" always "strtok"
  "wcstok" always "wcstok"
Line 11816
  "_ftprintf" always "_ftprintf"
  "fprintf" always "fprintf"
  "fwprintf" always "fwprintf"
Line 11817
  "_tprintf" always "_tprintf"
  "printf" always "printf"
  "wprintf" always "wprintf"
Line 11818
  "_stprintf" always "_stprintf"
  "sprintf" always "sprintf"
  "swprintf" always "swprintf"
Line 11819
  "_sntprintf" always "_sntprintf"
  "_snprintf" always "_snprintf"
  "_snwprintf" always "_snwprintf"
Line 11820
  "_ftscanf" always "_ftscanf"
  "fscanf" always "fscanf"
  "fwscanf" always "fwscanf"
Line 11821
  "_tscanf" always "_tscanf"
  "scanf" always "scanf"
  "wscanf" always "wscanf"
Line 11822
  "_stscanf" always "_stscanf"
  "sscanf" always "sscanf"
  "swscanf" always "swscanf"
Line 11823
  "_ftprintf_s" always "_ftprintf_s"
  "fprintf_s" always "fprintf_s"
  "fwprintf_s" always "fwprintf_s"
Line 11824
  "_tprintf_s" always "_tprintf_s"
  "printf_s" always "printf_s"
  "wprintf_s" always "wprintf_s"
Line 11825
  "_stprintf_s" always "_stprintf_s"
  "sprintf_s" always "sprintf_s"
  "swprintf_s" always "swprintf_s"
Line 11826
  "_sntprintf_s" always "_sntprintf_s"
  "_snprintf_s" always "_snprintf_s"
  "_snwprintf_s" always "_snwprintf_s"
Line 11827
  "_ftscanf_s" always "_ftscanf_s"
  "fscanf_s" always "fscanf_s"
  "fwscanf_s" always "fwscanf_s"
Line 11828
  "_tscanf_s" always "_tscanf_s"
  "scanf_s" always "scanf_s"
  "wscanf_s" always "wscanf_s"
Line 11829
  "_stscanf_s" always "_stscanf_s"
  "sscanf_s" always "sscanf_s"
  "swscanf_s" always "swscanf_s"
Line 11836
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 11839
  ansi always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
Line 11841
  1 always 1
  != always {!<=-1,!>=2}
  "(" always "("
Line 11844
  :: possible {symbolic=(apis.end()),end=0}
  match possible {symbolic=(apis.end()),end=0}
  = possible lifetime[Iterator]=(apis)
  ( possible lifetime[Iterator]=(apis)
Line 11845
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(apis),end=0}
Line 11846
  ansi always {!<=-1,!>=2}
  match always !end=0
  match always !end=0
Line 11847
  match always !end=0
Line 11848
  ( always {!<=-1,!>=2}
  "_T|_TEXT|TEXT ( %char%|%str% )" always "_T|_TEXT|TEXT ( %char%|%str% )"
Line 11852
  ! always {!<=-1,!>=2}
  ansi always {!<=-1,!>=2}
Line 11853
  true always 1
Line 11854
  0 always 0
  != always {!<=-1,!>=2}
  'L' always 76
Line 11855
  "L" always "L"
Line 11857
  ( always {!<=-1,!>=2}
  "_T|_TEXT|TEXT ( %char%|%str% )" always "_T|_TEXT|TEXT ( %char%|%str% )"
Line 11872
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 11874
  ( always {!<=-1,!>=2}
Line 11877
  ( always {!<=-1,!>=2}
  "( __closure * %name% )" always "( __closure * %name% )"
Line 11885
  == always {!<=-1,!>=2}
  "{" always "{"
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  -2 always -2
  "namespace %type%" always "namespace %type%"
Line 11887
  ! always {!<=-1,!>=2}
Line 11889
  ( always {!<=-1,!>=2}
  "class %name% :|{" always "class %name% :|{"
Line 11890
  tok possible 0
  && always {!<=-1,!>=2}
  tok always !0
  != always {!<=-1,!>=2}
  "{" always "{"
  && always {!<=-1,!>=2}
  tok always !0
  != always {!<=-1,!>=2}
  ";" always ";"
Line 11891
  tok always !0
Line 11892
  ! {!<=-1,!>=2,1}
  tok possible 0
Line 11894
  tok always !0
  == always {!<=-1,!>=2}
  ";" always ";"
Line 11897
  tok always !0
Line 11898
  tok always !0
  != always {!<=-1,!>=2}
  end always symbolic=(tok->link()->next())
Line 11899
  == always {!<=-1,!>=2}
  "__property" always "__property"
  && always {!<=-1,!>=2}
Line 11900
  ( always {!<=-1,!>=2}
  ";|{|}|protected:|public:|__published:" always ";|{|}|protected:|public:|__published:"
Line 11901
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  ( always !0
  "{|;" always "{|;"
Line 11904
  == always {!<=-1,!>=2}
  "{" always "{"
Line 11910
  ";" always ";"
Line 11911
  "__property" always "__property"
Line 11912
  ";" always ";"
Line 11923
  ( always {!<=-1,!>=2}
Line 11927
  ( always {!<=-1,!>=2}
  "emit|Q_EMIT %name% (" always "emit|Q_EMIT %name% ("
  && always {!<=-1,!>=2}
Line 11928
  ( always {!<=-1,!>=2}
  2 always 2
  ") ;" always ") ;"
Line 11930
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "class %name% :|::|{" always "class %name% :|::|{"
Line 11933
  && always {!<=-1,!>=2}
  ( always !0
  == always {!<=-1,!>=2}
  "enum" always "enum"
Line 11934
  2 always 2
Line 11939
  = always 0
  0 always 0
Line 11941
  ( possible size=1
  == always {!<=-1,!>=2}
  "{" always "{"
Line 11942
  ++ possible 1
  indentlevel possible 0
Line 11943
  == always {!<=-1,!>=2}
  1 always 1
Line 11947
  ( possible size=1
  == always {!<=-1,!>=2}
  "}" always "}"
Line 11948
  < always {!<=-1,!>=2}
  2 always 2
Line 11951
  -- {!<=0,>=1}
  indentlevel {!<=1,>=2}
Line 11952
  == always {!<=-1,!>=2}
  ";" always ";"
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  0 always 0
Line 11955
  tok2 possible symbolic=(tok)
  1 always 1
  == always {!<=-1,!>=2}
  "Q_OBJECT" always "Q_OBJECT"
Line 11958
  ( always {!<=-1,!>=2}
  "public|protected|private slots|Q_SLOTS :" always "public|protected|private slots|Q_SLOTS :"
Line 11960
  ":" always ":"
Line 11961
  2 always 2
Line 11963
  ( always {!<=-1,!>=2}
  "signals|Q_SIGNALS :" always "signals|Q_SIGNALS :"
Line 11965
  "protected:" always "protected:"
Line 11967
  ( always {!<=-1,!>=2}
  "emit|Q_EMIT %name% (" always "emit|Q_EMIT %name% ("
  && always {!<=-1,!>=2}
Line 11968
  ( always {!<=-1,!>=2}
  3 always 3
  ") ;" always ") ;"
Line 11977
  ! always {!<=-1,!>=2}
Line 11978
  this always !0
Line 11985
  = always 0
  nullptr always 0
Line 11988
  ( always {!<=-1,!>=2}
Line 11990
  && always {!<=-1,!>=2}
  tok always !0
  == always {!<=-1,!>=2}
  ")" always ")"
Line 11991
  tok always !0
  "{|;|?|:|[" always "{|;|?|:|["
Line 11992
  return always {!<=-1,!>=2}
  true always 1
Line 11994
  tok always !0
Line 11995
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  tok always !0
  "[=;{),]" always "[=;{),]"
Line 11996
  ( always {!<=-1,!>=2}
  tok always !0
  "const|volatile|override" always "const|volatile|override"
Line 11997
  tok always !0
Line 11998
  tok always !0
  ( possible size=5
  == {!<=-1,!>=2,0}
  "noexcept" always "noexcept"
Line 11999
  tok always !0
Line 12000
  && always {!<=-1,!>=2}
  tok always !0
  == always {!<=-1,!>=2}
  "(" always "("
Line 12001
  tok always !0
Line 12003
  tok always !0
  == always {!<=-1,!>=2}
  "throw" always "throw"
  && always {!<=-1,!>=2}
  tok always !0
  && always {!<=-1,!>=2}
  tok always !0
  ( always !0
  == always {!<=-1,!>=2}
  "(" always "("
Line 12004
  tok always !0
  ( always !0
Line 12007
  tok always !0
  ( always {!<=-1,!>=2}
Line 12008
  tok always !0
Line 12009
  && always {!<=-1,!>=2}
  tok always !0
  == always {!<=-1,!>=2}
  "(" always "("
Line 12010
  tok always !0
Line 12012
  ( always {!<=-1,!>=2}
  tok always !0
  "%op% !!(" always "%op% !!("
  || always {!<=-1,!>=2}
Line 12013
  ( always {!<=-1,!>=2}
  tok always !0
  "%op% (" always "%op% ("
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  tok always !0
  "{" always "{"
Line 12016
  return always {!<=-1,!>=2}
  false always 0
Line 12019
  return always {!<=-1,!>=2}
  true always 1
Line 12022
  return always {!<=-1,!>=2}
  false always 0
Line 12027
  ( always {!<=-1,!>=2}
Line 12031
  ( always {!<=-1,!>=2}
  "using|:: operator %op%|%name% ;" always "using|:: operator %op%|%name% ;"
Line 12032
  "operator" always "operator"
  2 always 2
Line 12037
  != always {!<=-1,!>=2}
  "operator" always "operator"
Line 12040
  ( always {!<=-1,!>=2}
  "operator %op% (" always "operator %op% ("
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  2 always 2
Line 12047
  done always {!<=-1,!>=2}
  done always {!<=-1,!>=2}
  = always 0
  false always 0
Line 12048
  ! {!<=-1,!>=2,1}
  done {!<=-1,!>=2,0}
  && always {!<=-1,!>=2}
  par possible symbolic=(tok->next())
Line 12049
  done always {!<=-1,!>=2}
  = always 1
  true always 1
Line 12050
  par {symbolic=(tok->next()),!0}
  ( always {!<=-1,!>=2}
Line 12051
  par always !0
Line 12052
  par always !0
Line 12054
  ( always {!<=-1,!>=2}
  ":: %name%|%op%|." always ":: %name%|%op%|."
Line 12058
  done always {!<=-1,!>=2}
  = always 0
  false always 0
Line 12059
  ( always {!<=-1,!>=2}
  par always !0
  ".|%op%|," always ".|%op%|,"
Line 12061
  par always !0
  == always {!<=-1,!>=2}
  "," always ","
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 12063
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  par always !0
  "<|>" always "<|>"
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 12064
  par always !0
Line 12065
  par always !0
Line 12066
  done always {!<=-1,!>=2}
  = always 0
  false always 0
Line 12068
  ( always {!<=-1,!>=2}
  par always !0
  "[ ]" always "[ ]"
Line 12069
  "[]" always "[]"
Line 12070
  par always !0
  2 always 2
Line 12071
  done always {!<=-1,!>=2}
  = always 0
  false always 0
Line 12072
  ( always {!<=-1,!>=2}
  par always !0
  "( *| )" always "( *| )"
Line 12074
  ( always {!<=-1,!>=2}
  par always !0
Line 12077
  != always {!<=-1,!>=2}
  ")" always ")"
Line 12081
  ")" always ")"
Line 12083
  ( always {!<=-1,!>=2}
  "..." always "..."
Line 12084
  op {!<=size=0,NonMovedVariable}
Line 12085
  = always 0
  nullptr always 0
Line 12088
  done always {!<=-1,!>=2}
  = always 0
  false always 0
Line 12089
  ( always {!<=-1,!>=2}
  par always !0
  "\"\" %name% (|;|<" always "\"\" %name% (|;|<"
Line 12090
  "\"\"" always "\"\""
Line 12091
  par always !0
  1 always 1
Line 12092
  par always !0
  2 always 2
Line 12093
  done always {!<=-1,!>=2}
  = always 1
  true always 1
Line 12094
  par always !0
  ( possible size=1
  == {!<=-1,!>=2,0}
  "::" always "::"
Line 12095
  par always !0
  ( always size=2
Line 12096
  par always !0
Line 12097
  done always {!<=-1,!>=2}
  = always 0
  false always 0
Line 12098
  par always !0
  ( possible size=1
  == always {!<=-1,!>=2}
  ";" always ";"
  || always {!<=-1,!>=2}
  par always !0
  == always {!<=-1,!>=2}
  ")" always ")"
Line 12099
  done always {!<=-1,!>=2}
  = always 1
  true always 1
Line 12100
  par always !0
  != always {!<=-1,!>=2}
  "(" always "("
Line 12101
  par always !0
  "operator" always "operator"
Line 12105
  par possible {symbolic=(tok->next()),0}
  && {!<=-1,!>=2,0}
  ! {!<=-1,!>=2,0}
  op possible {NonMovedVariable,size=0}
  ( {!<=-1,!>=2,1}
Line 12106
  "operator" always "operator"
  op always !size=0
Line 12107
  par always !0
Line 12110
  ! {!<=-1,!>=2,1,0}
  op possible {NonMovedVariable,size=0}
  ( {!<=-1,!>=2,0,1}
Line 12111
  true always 1
Line 12115
  ( always {!<=-1,!>=2}
  "%op% %str% %name%" always "%op% %str% %name%"
Line 12116
  2 always 2
Line 12118
  str always symbolic=(tok->next())
Line 12119
  "operator\"\"" always "operator\"\""
Line 12121
  true always 1
Line 12122
  "(" always "("
Line 12123
  ")" always ")"
Line 12126
  "," always ","
Line 12130
  . always {!<=-1,!>=2}
  debugwarnings always {!<=-1,!>=2}
Line 12133
  tok possible symbolic=(list.front())
  "operator" always "operator"
  != always {!<=-1,!>=2}
  nullptr always 0
Line 12134
  tok always !0
  :: always 7
  debug always 7
  "debug" always "debug"
Line 12135
  "simplifyOperatorName: found unsimplified operator name" always "simplifyOperatorName: found unsimplified operator name"
Line 12136
  tok always !0
Line 12143
  ( always {!<=-1,!>=2}
Line 12148
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 12151
  ( always {!<=-1,!>=2}
  "this ) (" always "this ) ("
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  -2 always -2
  "( *" always "( *"
Line 12153
  "operator()" always "operator()"
Line 12154
  "." always "."
Line 12159
  ( always {!<=-1,!>=2}
  "class|struct %name% [:{]" always "class|struct %name% [:{]"
Line 12160
  = always 0
  0 always 0
Line 12162
  ( possible size=1
  == always {!<=-1,!>=2}
  "}" always "}"
Line 12164
  indent possible {0,1}
  == {!<=-1,!>=2,1,0}
  0 always 0
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  ";" always ";"
Line 12166
  == always {!<=-1,!>=2}
  "{" always "{"
Line 12167
  == always {!<=-1,!>=2}
  0 always 0
Line 12168
  ++ always 1
  indent always 0
Line 12171
  == always {!<=-1,!>=2}
  1 always 1
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "operator() (" always "operator() ("
  && always {!<=-1,!>=2}
  ";{" always ";{"
Line 12172
  1 always 1
Line 12179
  ( always {!<=-1,!>=2}
  "%type% &| %var%" always "%type% &| %var%"
  && always {!<=-1,!>=2}
  ( possible lifetime[Iterator]=(classNames)
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(classNames),end=0}
Line 12181
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 12187
  ( always {!<=-1,!>=2}
  "%var% (" always "%var% ("
  && always {!<=-1,!>=2}
  ( possible lifetime[Iterator]=(classVars)
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(classVars),end=0}
Line 12189
  ( always {!<=-1,!>=2}
  "[:,]" always "[:,]"
Line 12191
  ( always {!<=-1,!>=2}
  start possible symbolic=(tok->previous())
  "," always ","
Line 12192
  ( always {!<=-1,!>=2}
  ")" always ")"
Line 12193
  -1 always -1
Line 12196
  ( always {!<=-1,!>=2}
  "%name%" always "%name%"
Line 12197
  -2 always -2
Line 12201
  1 always 1
Line 12202
  ( always {!<=-1,!>=2}
  ")|} , %name% (|{" always ")|} , %name% (|{"
Line 12203
  3 always 3
Line 12206
  ( always {!<=-1,!>=2}
  ":" always ":"
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  ") {" always ") {"
Line 12210
  "operator()" always "operator()"
Line 12211
  "." always "."
Line 12219
  ( always {!<=-1,!>=2}
Line 12224
  ( always {!<=-1,!>=2}
  tok possible symbolic=(classInfo.back().bodyEnd)
  "class|struct|namespace %type% :|{" always "class|struct|namespace %type% :|{"
  && always {!<=-1,!>=2}
Line 12225
  ! always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  ( always !0
  != always {!<=-1,!>=2}
  "enum" always "enum"
Line 12227
  . always {!<=-1,!>=2}
  isNamespace always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  "namespace" always "namespace"
Line 12231
  tok possible 0
  && always {!<=-1,!>=2}
  tok always !0
  != always {!<=-1,!>=2}
  "{" always "{"
Line 12232
  tok always !0
Line 12233
  ! {!<=-1,!>=2,1}
  tok possible 0
Line 12235
  tok always !0
Line 12237
  ! {!<=-1,!>=2,0}
  classInfo possible size=0
  ( {!<=-1,!>=2,1}
Line 12238
  == always {!<=-1,!>=2}
  classInfo always !size=0
Line 12239
  classInfo always !size=0
Line 12240
  tok always !symbolic=(classInfo.back().bodyEnd)
  == always {!<=-1,!>=2}
  classInfo always !size=0
  && always {!<=-1,!>=2}
Line 12241
  ! always {!<=-1,!>=2}
  classInfo always !size=0
  . always {!<=-1,!>=2}
  isNamespace always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  tok always !symbolic=(classInfo.back().bodyEnd)
  != always {!<=-1,!>=2}
  ":" always ":"
  && always {!<=-1,!>=2}
Line 12242
  ( always {!<=-1,!>=2}
  tok always !symbolic=(classInfo.back().bodyEnd)
  "%type% :: ~| %type% (" always "%type% :: ~| %type% ("
  || always {!<=-1,!>=2}
Line 12243
  ( always {!<=-1,!>=2}
  tok always !symbolic=(classInfo.back().bodyEnd)
  "%type% :: operator" always "%type% :: operator"
Line 12244
  tok always !symbolic=(classInfo.back().bodyEnd)
  3 always 3
Line 12245
  tok always !symbolic=(classInfo.back().bodyEnd)
  2 always 2
  == always {!<=-1,!>=2}
  "operator" always "operator"
Line 12247
  == always {!<=-1,!>=2}
  "(" always "("
Line 12250
  && always {!<=-1,!>=2}
  tok1 always !0
  != always {!<=-1,!>=2}
  "(" always "("
Line 12251
  tok1 always !0
  == always {!<=-1,!>=2}
  ";" always ";"
Line 12253
  tok1 always !0
Line 12255
  ! {!<=-1,!>=2,1}
  tok1 possible 0
  || always {!<=-1,!>=2}
  tok1 always !0
  != always {!<=-1,!>=2}
  "(" always "("
Line 12257
  tok always !symbolic=(classInfo.back().bodyEnd)
  2 always 2
  == always {!<=-1,!>=2}
  "~" always "~"
Line 12260
  ! always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  tok1 always !0
  ") const| {|;|:" always ") const| {|;|:"
Line 12264
  isConstructorOrDestructor always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
Line 12265
  ( always {!<=-1,!>=2}
  tok always !symbolic=(classInfo.back().bodyEnd)
  "%type% :: ~| %type%" always "%type% :: ~| %type%"
  && always {!<=-1,!>=2}
  tok always !symbolic=(classInfo.back().bodyEnd)
  2 always 2
  == always {!<=-1,!>=2}
  tok always !symbolic=(classInfo.back().bodyEnd)
  || always {!<=-1,!>=2}
  tok always !symbolic=(classInfo.back().bodyEnd)
  2 always 2
  == always {!<=-1,!>=2}
  "~" always "~"
  && always {!<=-1,!>=2}
  tok always !symbolic=(classInfo.back().bodyEnd)
  3 always 3
  == always {!<=-1,!>=2}
  tok always !symbolic=(classInfo.back().bodyEnd)
Line 12266
  ! always {!<=-1,!>=2}
  isConstructorOrDestructor always {!<=-1,!>=2}
Line 12267
  isPrependedByType always {!<=-1,!>=2}
  isPrependedByType always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  tok always !symbolic=(classInfo.back().bodyEnd)
  "%type%" always "%type%"
Line 12268
  ! always {!<=-1,!>=2}
  isPrependedByType always {!<=-1,!>=2}
Line 12269
  tok always !symbolic=(classInfo.back().bodyEnd)
  -2 always -2
Line 12270
  isPrependedByType always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "%type% *|&" always "%type% *|&"
Line 12272
  ! always {!<=-1,!>=2}
  isPrependedByType always {!<=-1,!>=2}
Line 12273
  tok always !symbolic=(classInfo.back().bodyEnd)
  -3 always -3
Line 12274
  isPrependedByType always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "%type% * *|&" always "%type% * *|&"
Line 12276
  ! always {!<=-1,!>=2}
  isPrependedByType always {!<=-1,!>=2}
Line 12290
  ( always {!<=-1,!>=2}
  "return strncat (" always "return strncat ("
  && always {!<=-1,!>=2}
Line 12291
  ( always {!<=-1,!>=2}
  2 always 2
  ") ;" always ") ;"
  && always {!<=-1,!>=2}
Line 12292
  3 always 3
  != always {!<=-1,!>=2}
  ")" always ")"
  && always {!<=-1,!>=2}
  3 always 3
  != always {!<=-1,!>=2}
  "," always ","
Line 12295
  3 always 3
Line 12298
  = always 0
  0 always 0
  i possible 0
  < {!<=-1,!>=2,1}
  2 always 2
Line 12300
  ! always {!<=-1,!>=2}
Line 12301
  2 always 2
Line 12305
  ! always {!<=-1,!>=2}
Line 12308
  tok2 always !0
Line 12311
  2 always 2
Line 12322
  tok2 always symbolic=(tok->link()->next())
  ";" always ";"
Line 12325
  -2 always -2
Line 12328
  tok2 always symbolic=(tok->link()->next())
Line 12329
  tok2 always symbolic=(tok->link()->next())
  "return" always "return"
Line 12336
  ! always {!<=-1,!>=2}
Line 12341
  = always 1
  1 always 1
  i possible 1
  <= always {!<=-1,!>=2}
Line 12342
  mSymbolDatabase always !0
  i {<=symbolic=(mVarId),!>=symbolic=(mVarId+1),1}
Line 12343
  ! always {!<=-1,!>=2}
Line 12346
  var always !0
  || always {!<=-1,!>=2}
  var always !0
  ( always {!<=-1,!>=2}
Line 12353
  var always !0
  == always {!<=-1,!>=2}
  var always !0
Line 12354
  = always {symbolic=(var->typeStartToken()),symbolic=(var->typeEndToken())}
  var always !0
  ( always {symbolic=(var->typeStartToken()),symbolic=(var->typeEndToken())}
Line 12355
  nameTok always {symbolic=(var->typeStartToken()),symbolic=(var->typeEndToken())}
Line 12360
  = always !symbolic=(var->typeEndToken())
  var always !0
  ( always !symbolic=(var->typeEndToken())
Line 12361
  = always 0
  0 always 0
Line 12363
  = {symbolic=(var->typeStartToken()),!symbolic=(var->typeEndToken())}
  tok {symbolic=(var->typeStartToken()),!symbolic=(var->typeEndToken())}
Line 12365
  tok possible {symbolic=(var->typeStartToken()),symbolic=(nameTok)}
Line 12367
  == always {!<=-1,!>=2}
  0 always 0
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  tok {symbolic=(var->typeStartToken()),symbolic=(nameTok),!0}
  "*|&" always "*|&"
Line 12370
  tok always !0
  ( possible size=1
Line 12372
  ( always {!<=-1,!>=2}
  tok always !0
  "struct|union|enum" always "struct|union|enum"
Line 12373
  " " always " "
Line 12376
  tok always !0
  ( possible size=1
  == always {!<=-1,!>=2}
  "<" always "<"
Line 12378
  tok always !0
  == always {!<=-1,!>=2}
  ">" always ">"
Line 12381
  tok always !0
  == always {!<=-1,!>=2}
  ( always !symbolic=(var->typeStartToken())
Line 12384
  tok always !symbolic=(var->typeEndToken())
Line 12388
  ( possible lifetime[Iterator]=(unknowns)
  name possible symbolic=(nameTok->str())
  nameTok possible {symbolic=(var->typeStartToken()),symbolic=(tok),symbolic=(var->typeEndToken())}
Line 12391
  ! {!<=-1,!>=2,0}
  unknowns possible size=0
  ( {!<=-1,!>=2,1}
Line 12393
  = always 0
  0 always 0
Line 12395
  = {lifetime[Iterator]=(unknowns),!size=0,start=0}
  unknowns always !size=0
  ( {lifetime[Iterator]=(unknowns),!size=0,start=0}
  it {lifetime[Iterator]=(unknowns),!size=0,start=0}
  != always {!<=-1,!>=2}
  unknowns always !size=0
  ( {lifetime[Iterator]=(unknowns),!size=0,end=0}
Line 12397
  it {lifetime[Iterator]=(unknowns),!size=0}
  "std::" always "std::"
  != always {!<=-1,!>=2}
  0 always 0
Line 12398
  it {lifetime[Iterator]=(unknowns),!size=0}
  != always {!<=-1,!>=2}
Line 12399
  = always !symbolic=(last)
  it {lifetime[Iterator]=(unknowns),!size=0}
  . always !symbolic=(last)
Line 12400
  = always 1
  1 always 1
Line 12401
  it {lifetime[Iterator]=(unknowns),!size=0}
  :: always 7
  debug always 7
  "debug" always "debug"
  "Unknown type \'" always "Unknown type \'"
  "\'." always "\'."
Line 12403
  < always {!<=-1,!>=2}
  3 always 3
Line 12404
  it {lifetime[Iterator]=(unknowns),!size=0}
  :: always 7
  debug always 7
  "debug" always "debug"
  "Unknown type \'" always "Unknown type \'"
  "\'." always "\'."
Line 12424
  ( always {!<=-1,!>=2}
  "pow|powf|powl (" always "pow|powf|powl ("
Line 12425
  ( always {!<=-1,!>=2}
  2 always 2
  "sin|sinf|sinl (" always "sin|sinf|sinl ("
Line 12426
  3 always 3
Line 12427
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  ") , %num% ) + pow|powf|powl ( cos|cosf|cosl (" always ") , %num% ) + pow|powf|powl ( cos|cosf|cosl ("
Line 12429
  2 always 2
Line 12430
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 12432
  8 always 8
Line 12434
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  tok4 always symbolic=(tok3->link())
  ") , %num% )" always ") , %num% )"
Line 12436
  tok4 always symbolic=(tok3->link())
  2 always 2
Line 12437
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 12439
  3 always 3
  == always {!<=-1,!>=2}
Line 12440
  4 always 4
Line 12441
  "1" always "1"
Line 12443
  ( always {!<=-1,!>=2}
  2 always 2
  "cos|cosf|cosl (" always "cos|cosf|cosl ("
Line 12444
  3 always 3
Line 12445
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  ") , %num% ) + pow|powf|powl ( sin|sinf|sinl (" always ") , %num% ) + pow|powf|powl ( sin|sinf|sinl ("
Line 12447
  2 always 2
Line 12448
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 12450
  8 always 8
Line 12452
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  tok4 always symbolic=(tok3->link())
  ") , %num% )" always ") , %num% )"
Line 12454
  tok4 always symbolic=(tok3->link())
  2 always 2
Line 12455
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 12457
  3 always 3
  == always {!<=-1,!>=2}
Line 12458
  4 always 4
Line 12459
  "1" always "1"
Line 12461
  ( always {!<=-1,!>=2}
  2 always 2
  "sinh|sinhf|sinhl (" always "sinh|sinhf|sinhl ("
Line 12462
  3 always 3
Line 12463
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  ") , %num% ) - pow|powf|powl ( cosh|coshf|coshl (" always ") , %num% ) - pow|powf|powl ( cosh|coshf|coshl ("
Line 12465
  2 always 2
Line 12466
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 12468
  8 always 8
Line 12470
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  tok4 always symbolic=(tok3->link())
  ") , %num% )" always ") , %num% )"
Line 12472
  tok4 always symbolic=(tok3->link())
  2 always 2
Line 12473
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 12475
  3 always 3
  == always {!<=-1,!>=2}
Line 12476
  4 always 4
Line 12477
  "-1" always "-1"
Line 12479
  ( always {!<=-1,!>=2}
  2 always 2
  "cosh|coshf|coshl (" always "cosh|coshf|coshl ("
Line 12480
  3 always 3
Line 12481
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  ") , %num% ) - pow|powf|powl ( sinh|sinhf|sinhl (" always ") , %num% ) - pow|powf|powl ( sinh|sinhf|sinhl ("
Line 12483
  2 always 2
Line 12484
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 12486
  8 always 8
Line 12488
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  tok4 always symbolic=(tok3->link())
  ") , %num% )" always ") , %num% )"
Line 12490
  tok4 always symbolic=(tok3->link())
  2 always 2
Line 12491
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 12493
  3 always 3
  == always {!<=-1,!>=2}
Line 12494
  4 always 4
Line 12495
  "-1" always "-1"
Line 12502
  ( always {!<=-1,!>=2}
Line 12505
  modified always {!<=-1,!>=2}
  modified always {!<=-1,!>=2}
  = always 0
  false always 0
Line 12507
  ( always {!<=-1,!>=2}
  "strlen ( %str% )" always "strlen ( %str% )"
Line 12508
  2 always 2
Line 12509
  3 always 3
Line 12510
  modified always {!<=-1,!>=2}
  = always 1
  true always 1
Line 12513
  return always {!<=-1,!>=2}
  modified {!<=-1,!>=2,0}
Line 12522
  == always {!<=-1,!>=2}
  "?" always "?"
Line 12523
  parenthesesNeeded always {!<=-1,!>=2}
  parenthesesNeeded always {!<=-1,!>=2}
  = always 0
  false always 0
Line 12524
  = always 0
  0 always 0
Line 12526
  tok2 possible symbolic=(tok->next())
Line 12527
  tok2 possible symbolic=(tok->next())
  ( possible 0
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "[|(|<" always "[|(|<"
Line 12528
  = always !0
  ( always !0
Line 12529
  ( possible size=1
  == always {!<=-1,!>=2}
  ":" always ":"
Line 12530
  == always {!<=-1,!>=2}
  0 always 0
Line 12532
  depth always !0
  -- always !0
Line 12533
  ( possible size=1
  == always {!<=-1,!>=2}
  ";" always ";"
  || always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  != always {!<=-1,!>=2}
  "{" always "{"
  && always {!<=-1,!>=2}
  != always {!<=-1,!>=2}
  "}" always "}"
Line 12535
  ( possible size=1
  == always {!<=-1,!>=2}
  "," always ","
Line 12536
  parenthesesNeeded always {!<=-1,!>=2}
  = always 1
  true always 1
Line 12537
  ( possible size=1
  == always {!<=-1,!>=2}
  "<" always "<"
Line 12538
  parenthesesNeeded always {!<=-1,!>=2}
  = always 1
  true always 1
Line 12539
  == always {!<=-1,!>=2}
  "?" always "?"
Line 12541
  parenthesesNeeded always {!<=-1,!>=2}
  = always 1
  true always 1
Line 12544
  parenthesesNeeded {!<=-1,!>=2,0}
  && always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  tok2 always !0
  == always {!<=-1,!>=2}
  ":" always ":"
Line 12545
  "(" always "("
Line 12546
  tok2 always !0
  ")" always ")"
  true always 1
Line 12547
  tok2 always !0
Line 12553
  , always {!<=-1,!>=2}
  inconclusive always {!<=-1,!>=2}
Line 12555
  1 always 1
  tok possible symbolic=(tok)@203
Line 12556
  callstack always size=1
  severity possible {7@59,5@166,6@168}
  id possible {"debug"@59,"nonStandardCharLiteral"@166,"macroWithSemicolon"@168,"class_X_Y"@169,"checkLibraryNoReturn"@15,"debug"@64,"dacaWrongSplitTemplateRightAngleBrackets"@223,"dacaWrongSplitTemplateRightAngleBrackets"@231,"debug"@112,"simplifyUsingUnmatchedBodyEnd"@207}
  msg possible {"simplifyOperatorName: found unsimplified operator name"@59,"simplifyUsing: unmatched body end"@207,"simplifyUsing: unmatched body end"@244}
  inconclusive {!<=-1,!>=2,0@223}
Line 12559
  , always {!<=-1,!>=2}
  inconclusive always {!<=-1,!>=2}
Line 12561
  & {lifetime[Address]=(list),!0}
  inconclusive always {!<=-1,!>=2}
  ? possible 0
  : always 0
  :: always 0
  normal always 0
Line 12563
  mErrorLogger always !0
Line 12570
  ! always {!<=-1,!>=2}
Line 12573
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 12577
  mSettings always !0
Line 12578
  podType always symbolic=(mSettings->library.podtype(tok->str()))
Line 12580
  prev possible {symbolic=(tok->previous()),0}
  && always {!<=-1,!>=2}
  prev {symbolic=(tok->previous()),!0}
  ( always {!<=-1,!>=2}
Line 12581
  prev always !0
Line 12582
  prev possible {symbolic=(tok->previous()),0}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  prev always !0
  ";|{|}|,|(" always ";|{|}|,|("
Line 12584
  true always 1
Line 12591
  = always 0
  nullptr always 0
Line 12592
  2 always 2
  != always {!<=-1,!>=2}
  nullptr always 0
  tok possible symbolic=(tokLastEnd)
Line 12593
  == always {!<=-1,!>=2}
  nullptr always 0
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  ";" always ";"
Line 12595
  == always {!<=-1,!>=2}
  "__CPPCHECK_EMBEDDED_SQL_EXEC__" always "__CPPCHECK_EMBEDDED_SQL_EXEC__"
Line 12596
  ( always {!<=-1,!>=2}
  -2 always -2
  "END - __CPPCHECK_EMBEDDED_SQL_EXEC__ ;" always "END - __CPPCHECK_EMBEDDED_SQL_EXEC__ ;"
Line 12599
  ( always {!<=-1,!>=2}
  "{|}|==|&&|!|^|<<|>>|++|+=|-=|/=|*=|>>=|<<=|~" always "{|}|==|&&|!|^|<<|>>|++|+=|-=|/=|*=|>>=|<<=|~"
Line 12603
  tokLastEnd possible 0
Line 12608
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 12611
  tok possible symbolic=(tok2)
Line 12612
  ( always {!<=-1,!>=2}
  "namespace %name% ::" always "namespace %name% ::"
  && always {!<=-1,!>=2}
  -1 always -1
  != always {!<=-1,!>=2}
  "using" always "using"
Line 12613
  2 always 2
Line 12616
  ( always {!<=-1,!>=2}
  tok2 possible 0
  ":: %name%" always ":: %name%"
Line 12617
  2 always 2
Line 12619
  ! always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  tok2 always !0
  != always {!<=-1,!>=2}
  "{" always "{"
Line 12623
  2 always 2
Line 12625
  == always {!<=-1,!>=2}
  "::" always "::"
Line 12627
  "{" always "{"
Line 12628
  "namespace" always "namespace"
Line 12629
  3 always 3
Line 12634
  ! {!<=-1,!>=2,0}
  links possible size=0
  ( {!<=-1,!>=2,1}
  && always {!<=-1,!>=2}
  tok2 always symbolic=(tok)
  == always {!<=-1,!>=2}
  "{" always "{"
Line 12635
  tok2 always symbolic=(tok)
Line 12636
  ! {!<=-1,!>=2,1}
  ( {!<=-1,!>=2,0}
Line 12637
  "}" always "}"
Line 12639
  links always !size=0
Line 12640
  links always !size=0
Line 12649
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  < always {!<=-1,!>=2}
  :: always 4
  CPP20 always 4
Line 12652
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "co_return|co_yield|co_await" always "co_return|co_yield|co_await"
Line 12655
  end possible symbolic=(tok->next())
  && always {!<=-1,!>=2}
  end {symbolic=(tok->next()),!0}
  != always {!<=-1,!>=2}
  ";" always ";"
Line 12656
  ( always {!<=-1,!>=2}
  end always !0
  "[({[]" always "[({[]"
Line 12657
  end always !0
Line 12658
  ( always {!<=-1,!>=2}
  end always !0
  "[)]}]" always "[)]}]"
Line 12662
  ( always {!<=-1,!>=2}
  end possible symbolic=(tok->next())
  ";" always ";"
Line 12663
  "(" always "("
Line 12664
  ")" always ")"
Line 12670
  ( always {!<=-1,!>=2}
Line 12672
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  other always !0
Line 12673
  == always {!<=-1,!>=2}
Line 12674
  return always {!<=-1,!>=2}
  true always 1
Line 12675
  first always !symbolic=(last)
Line 12676
  other always !0
Line 12679
  return always {!<=-1,!>=2}
  false always 0
Line 12682
  ( always {!<=-1,!>=2}
Line 12684
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  end always !0
Line 12685
  == always {!<=-1,!>=2}
Line 12686
  return always {!<=-1,!>=2}
  true always 1
Line 12687
  last always !symbolic=(first)
Line 12688
  end always !0
Line 12691
  return always {!<=-1,!>=2}
  false always 0
Line 12696
  ";" always ";"
Line 12709
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 12712
  = always 0
  0 always 0
Line 12714
  tok possible {symbolic=(tokNext->previous()),symbolic=(tokLast),symbolic=(tokNameEnd->next())}
Line 12715
  ( possible size=1
  == always {!<=-1,!>=2}
  "{" always "{"
Line 12717
  == always {!<=-1,!>=2}
  "}" always "}"
Line 12719
  ( always {!<=-1,!>=2}
  "namespace %name% =" always "namespace %name% ="
Line 12721
  3 always 3
Line 12724
  tokNameEnd possible {symbolic=(tokNameStart),0}
  && always {!<=-1,!>=2}
  tokNameEnd {symbolic=(tokNameStart),!0}
  && always {!<=-1,!>=2}
  tokNameEnd {symbolic=(tokNameStart),!0}
  ( always !0
  != always {!<=-1,!>=2}
  ";" always ";"
Line 12725
  = always !0
  tokNameEnd always !0
  ( always !0
Line 12727
  ! {!<=-1,!>=2,1}
  tokNameEnd possible {symbolic=(tokNameStart),0}
Line 12731
  tokNameEnd always !0
Line 12732
  tokLast always symbolic=(tokNameEnd->next())
Line 12733
  = {symbolic=(tokLast->next()),0}
  tokNext {symbolic=(tokLast->next()),0}
Line 12735
  tok2 possible {symbolic=(tokNext),symbolic=(tokLast->next()),0}
  && {!<=-1,!>=2,0}
  endScope possible symbolic=(scope)
  >= {!<=-1,!>=2,1}
  scope possible symbolic=(endScope)
Line 12736
  ( always {!<=-1,!>=2}
  tok2 always !0
  "{" always "{"
Line 12737
  endScope always !<=symbolic=(scope-1)
  ++ always !<=symbolic=(scope-1)
Line 12738
  ( always {!<=-1,!>=2}
  tok2 always !0
  "}" always "}"
Line 12739
  endScope always !<=symbolic=(scope-1)
  -- always !<=symbolic=(scope-1)
Line 12740
  tok2 always !0
  == always {!<=-1,!>=2}
Line 12741
  ( always {!<=-1,!>=2}
  tok2 always !0
  "namespace %name% =" always "namespace %name% ="
Line 12743
  ( always {!<=-1,!>=2}
  tokNameEnd always !0
  tok2 always !0
  2 always 2
Line 12745
  tok2 always !0
Line 12750
  endScope always !<=symbolic=(scope-1)
  == always {!<=-1,!>=2}
  scope always !>=symbolic=(endScope+1)
Line 12752
  tok2 always !0
Line 12758
  tok2 always !0
Line 12764
  tok2 always !0
  1 always 1
  == always {!<=-1,!>=2}
  "::" always "::"
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  tokNameEnd always !0
  tok2 always !0
Line 12765
  tok2 always !0
Line 12767
  tok3 possible symbolic=(tokNameStart)
  != always {!<=-1,!>=2}
  tokNameEnd always !0
Line 12768
  tok3 always !symbolic=(tokNameEnd)
  ( possible symbolic=(tokNameEnd)
Line 12770
  tok3 always !symbolic=(tokNameEnd)
Line 12777
  ( possible 0
  && always {!<=-1,!>=2}
  tokNext always symbolic=(tokLast->next())
Line 12778
  ( always !0
  tokNext {symbolic=(tokLast->next()),!0}
Line 12779
  tokNext {symbolic=(tokLast->next()),!0}
Line 12780
  ( possible 0
Line 12781
  ( always !0
  tokLast always symbolic=(tokNameEnd->next())
Line 12782
  = always symbolic=(tokNameEnd->next())
  tokLast always symbolic=(tokNameEnd->next())
Line 12783
  tokNext always symbolic=(tokLast->next())
Line 12784
  tokNext {symbolic=(tokLast->next()),!0}
Line 12787
  tokLast always symbolic=(tokNameEnd->next())
Line 12795
  0 always 0
Line 12799
  ( always size=0
Line 12802
  ( always {!<=-1,!>=2}
Line 12804
  ( always {!<=-1,!>=2}
Line 12805
  return always {!<=-1,!>=2}
  false always 0
Line 12807
  mScopeInfo always !size=0
Line 12808
  != always {!<=-1,!>=2}
  0 always 0
Line 12809
  = always !0
  . always !0
Line 12813
  mScopeInfo always !size=0
Line 12814
  return always {!<=-1,!>=2}
  true always 1
Line 12819
  ( always {!<=-1,!>=2}
Line 12823
  = possible lifetime[Iterator]=(mVariableId)
  ( possible lifetime[Iterator]=(mVariableId)
Line 12824
  it {lifetime[Iterator]=(mVariableId),symbolic=(mVariableId.find(varname))}
  == always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(mVariableId),end=0}
Line 12825
  mScopeInfo always !size=0
  0 always 0
Line 12829
  mScopeInfo always !size=0
  it {lifetime[Iterator]=(mVariableId),symbolic=(mVariableId.find(varname)),!end=0}
Line 12833
  ( always {!<=-1,!>=2}
Line 12835
  return always {!<=-1,!>=2}
  ( possible lifetime[Iterator]=(mVariableId)
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(mVariableId),end=0}
Line 12838
  ( always {!<=-1,!>=2}
Line 12840
  ! always {!<=-1,!>=2}
Line 12841
  return always {!<=-1,!>=2}
  false always 0
Line 12842
  mPreprocessor always !0
Line 12843
  0 always 0
  3 always 3
  "#if" always "#if"
  == always {!<=-1,!>=2}
  0 always 0
  && always {!<=-1,!>=2}
Line 12844
  . always !<=-1
  linenr always !<=-1
  >= always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 12845
  . {!<=-1,>=symbolic=(start->linenr()),!<=symbolic=(start->linenr()-1)}
  linenr always !<=-1
  <= always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 12846
  < always {!<=-1,!>=2}
  ( always !<=-1
  && always {!<=-1,!>=2}
Line 12847
  == always {!<=-1,!>=2}
  ( {<=symbolic=(list.getFiles().size()-1),!>=symbolic=(list.getFiles().size())}
Line 12848
  return always {!<=-1,!>=2}
  true always 1
Line 12850
  return always {!<=-1,!>=2}
  false always 0
Line 50
  mFlags always !<=-1
  mFlags always !<=-1
  = always 0
  0 always 0
Line 52
  ( always !<=-1
Line 53
  return always !<=-1
  mFlags always !<=-1
Line 56
  mFlags always !<=-1
  = always 0
  0 always 0
Line 59
  mFlags always !<=-1
  = always 4294967295
  0xFFFFFFFF always 4294967295
Line 61
  enabled always {!<=-1,!>=2}
Line 62
  enabled always {!<=-1,!>=2}
Line 67
  ( always {!<=-1,!>=2}
Line 68
  return always {!<=-1,!>=2}
  mFlags always !<=-1
  & always !<=-1
  1U always 1
  << always !<=0
  ( {!<=-1,6@8,5@185}
  flag possible {6@8,5@185}
  != always {!<=-1,!>=2}
  0 always 0
Line 71
  mFlags always !<=-1
  |= always !<=-1
  1U always 1
  << always !<=0
  ( always !<=-1
Line 74
  mFlags always !<=-1
  &= always !<=-1
  ~ always !<=4294967295
  1U always 1
  << always !<=0
  ( always !<=-1
Line 76
  , always {!<=-1,!>=2}
  enabled always {!<=-1,!>=2}
Line 77
  enabled always {!<=-1,!>=2}
Line 50
  mFlags always !<=-1
  mFlags always !<=-1
  = always 0
  0 always 0
Line 52
  ( always !<=-1
Line 53
  return always !<=-1
  mFlags always !<=-1
Line 56
  mFlags always !<=-1
  = always 0
  0 always 0
Line 59
  mFlags always !<=-1
  = always 4294967295
  0xFFFFFFFF always 4294967295
Line 61
  enabled always {!<=-1,!>=2}
Line 62
  enabled always {!<=-1,!>=2}
Line 67
  ( always {!<=-1,!>=2}
Line 68
  return always {!<=-1,!>=2}
  mFlags always !<=-1
  & always !<=-1
  1U always 1
  << always !<=0
  ( always !<=-1
  != always {!<=-1,!>=2}
  0 always 0
Line 71
  mFlags always !<=-1
  |= always !<=-1
  1U always 1
  << always !<=0
  ( always !<=-1
Line 74
  mFlags always !<=-1
  &= always !<=-1
  ~ always !<=4294967295
  1U always 1
  << always !<=0
  ( always !<=-1
Line 76
  , always {!<=-1,!>=2}
  enabled always {!<=-1,!>=2}
Line 77
  enabled always {!<=-1,!>=2}
Line 50
  mFlags always !<=-1
  mFlags always !<=-1
  = always 0
  0 always 0
Line 52
  ( always !<=-1
Line 53
  return always !<=-1
  mFlags always !<=-1
Line 56
  mFlags always !<=-1
  = always 0
  0 always 0
Line 59
  mFlags always !<=-1
  = always 4294967295
  0xFFFFFFFF always 4294967295
Line 61
  enabled always {!<=-1,!>=2}
Line 62
  enabled always {!<=-1,!>=2}
Line 67
  ( always {!<=-1,!>=2}
Line 68
  return always {!<=-1,!>=2}
  mFlags always !<=-1
  & always !<=-1
  1U always 1
  << always !<=0
  ( always !<=-1
  != always {!<=-1,!>=2}
  0 always 0
Line 71
  mFlags always !<=-1
  |= always !<=-1
  1U always 1
  << always !<=0
  ( always !<=-1
Line 74
  mFlags always !<=-1
  &= always !<=-1
  ~ always !<=4294967295
  1U always 1
  << always !<=0
  ( always !<=-1
Line 76
  , always {!<=-1,!>=2}
  enabled always {!<=-1,!>=2}
Line 77
  enabled always {!<=-1,!>=2}
