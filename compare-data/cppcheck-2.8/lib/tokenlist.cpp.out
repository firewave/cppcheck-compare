

##file cppcheck-2.8/lib/config.h

1:
|
78:
79: static const std :: string emptyString@var1 ;

##file cppcheck-2.8/lib/mathlib.h

1:
|
33:
34: class MathLib {
35: friend class TestMathLib ;
36:
37: public:
38:
39: class value {
40: private:
41: long long mIntValue@var2 ;
42: double mDoubleValue@var3 ;
43: enum class Type { INT , LONG , LONGLONG , FLOAT } ; enum Type mType@var4 ;
44: bool mIsUnsigned@var5 ;
45:
46: void promote ( const value & v@var6 ) ;
47:
48: public:
49: explicit value ( const std :: string & s@var7 ) ;
50: std :: string str ( ) const ;
51: bool isInt ( ) const {
52: return mType@var4 !=@expr1073744315 Type ::@expr1073744316 FLOAT ;
53: }
54: bool isFloat ( ) const {
55: return mType@var4 ==@expr1073744317 Type ::@expr1073744318 FLOAT ;
56: }
57:
58: double getDoubleValue ( ) const {
59: return isFloat (@expr1073744319 ) ?@expr1073744320 mDoubleValue@var3 :@expr1073744321 (@expr1073744322 double ) mIntValue@var2 ;
60: }
61:
62: static value calc ( char op@var8 , const value & v1@var9 , const value & v2@var10 ) ;
63: int compare ( const value & v@var11 ) const ;
64: value add ( int v@var12 ) const ;
65: value shiftLeft ( const value & v@var13 ) const ;
66: value shiftRight ( const value & v@var14 ) const ;
67: } ;
68:
69:
70:
71: static const int bigint_bits@var15 ;
72:
73: static long long toLongNumber ( const std :: string & str@var16 ) ;
74: static unsigned long long toULongNumber ( const std :: string & str@var17 ) ;
75:
76: template < class T > static std :: string toString ( T value@var18 ) {
77: std ::@expr1073744323 ostringstream result@var19 ;
78: result@var19 <<@expr1073744324 value@var18 ;
79: return result@var19 .@expr1073744325 str (@expr1073744326 ) ;
80: }
81: static double toDoubleNumber ( const std :: string & str@var20 ) ;
82:
83: static bool isInt ( const std :: string & str@var21 ) ;
84: static bool isFloat ( const std :: string & str@var22 ) ;
85: static bool isDecimalFloat ( const std :: string & str@var23 ) ;
86: static bool isNegative ( const std :: string & str@var24 ) ;
87: static bool isPositive ( const std :: string & str@var25 ) ;
88: static bool isDec ( const std :: string & str@var26 ) ;
89: static bool isFloatHex ( const std :: string & str@var27 ) ;
90: static bool isIntHex ( const std :: string & str@var28 ) ;
91: static bool isOct ( const std :: string & str@var29 ) ;
92: static bool isBin ( const std :: string & str@var30 ) ;
93:
94: static std :: string getSuffix ( const std :: string & value@var31 ) ;
95:
|
101:
102: static bool isValidIntegerSuffix ( const std :: string & str@var32 , bool supportMicrosoftExtensions@var33 = true ) ;
103:
104: static std :: string add ( const std :: string & first@var34 , const std :: string & second@var35 ) ;
105: static std :: string subtract ( const std :: string & first@var36 , const std :: string & second@var37 ) ;
106: static std :: string multiply ( const std :: string & first@var38 , const std :: string & second@var39 ) ;
107: static std :: string divide ( const std :: string & first@var40 , const std :: string & second@var41 ) ;
108: static std :: string mod ( const std :: string & first@var42 , const std :: string & second@var43 ) ;
109: static std :: string incdec ( const std :: string & var@var44 , const std :: string & op@var45 ) ;
110: static std :: string calculate ( const std :: string & first@var46 , const std :: string & second@var47 , char action@var48 ) ;
111:
112: static std :: string sin ( const std :: string & tok@var49 ) ;
113: static std :: string cos ( const std :: string & tok@var50 ) ;
114: static std :: string tan ( const std :: string & tok@var51 ) ;
115: static std :: string abs ( const std :: string & tok@var52 ) ;
116: static bool isEqual ( const std :: string & first@var53 , const std :: string & second@var54 ) ;
117: static bool isNotEqual ( const std :: string & first@var55 , const std :: string & second@var56 ) ;
118: static bool isGreater ( const std :: string & first@var57 , const std :: string & second@var58 ) ;
119: static bool isGreaterEqual ( const std :: string & first@var59 , const std :: string & second@var60 ) ;
120: static bool isLess ( const std :: string & first@var61 , const std :: string & second@var62 ) ;
121: static bool isLessEqual ( const std :: string & first@var63 , const std :: string & second@var64 ) ;
122: static bool isNullValue ( const std :: string & str@var65 ) ;
123:
|
127:
128: static bool isOctalDigit ( char c@var66 ) ;
129:
130: static unsigned int encodeMultiChar ( const std :: string & str@var67 ) ;
131:
|
136:
137: static bool isDigitSeparator ( const std :: string & iCode@var68 , std :: string :: size_type iPos@var69 ) ;
138: } ;
139:
140: MathLib :: value operator+ ( const MathLib :: value & v1@var70 , const MathLib :: value & v2@var71 ) ;
141: MathLib :: value operator- ( const MathLib :: value & v1@var72 , const MathLib :: value & v2@var73 ) ;
142: MathLib :: value operator* ( const MathLib :: value & v1@var74 , const MathLib :: value & v2@var75 ) ;
143: MathLib :: value operator/ ( const MathLib :: value & v1@var76 , const MathLib :: value & v2@var77 ) ;
144: MathLib :: value operator% ( const MathLib :: value & v1@var78 , const MathLib :: value & v2@var79 ) ;
145: MathLib :: value operator& ( const MathLib :: value & v1@var80 , const MathLib :: value & v2@var81 ) ;
146: MathLib :: value operator| ( const MathLib :: value & v1@var82 , const MathLib :: value & v2@var83 ) ;
147: MathLib :: value operator^ ( const MathLib :: value & v1@var84 , const MathLib :: value & v2@var85 ) ;
148: MathLib :: value operator<< ( const MathLib :: value & v1@var86 , const MathLib :: value & v2@var87 ) ;
149: MathLib :: value operator>> ( const MathLib :: value & v1@var88 , const MathLib :: value & v2@var89 ) ;
150:
151: template < > std :: string MathLib :: toString < double > ( double value@var90 ) ;

##file cppcheck-2.8/lib/valueflow.h

1:
|
36:
37: class ErrorLogger ;
38: struct InferModel ;
39: class Settings ;
40: class SymbolDatabase ;
41: class Token ;
42: class TokenList ;
43: class ValueType ;
44: class Variable ;
45: class Scope ;
46:
47: template < class T >
48: class ValuePtr ;
49:
50: namespace ValueFlow {
51: struct increment {
52: template < class T >
53: void operator() ( T & x@var91 ) const {
54: x@var91 ++@expr1073744327 ;
55: }
56: } ;
57: struct decrement {
58: template < class T >
59: void operator() ( T & x@var92 ) const {
60: x@var92 --@expr1073744328 ;
61: }
62: } ;
63:
64: struct less {
65: template < class T , class U >
66: bool operator() ( const T & x@var93 , const U & y@var94 ) const {
67: return x@var93 <@expr1073744329 y@var94 ;
68: }
69: } ;
70:
71: struct adjacent {
72: template < class T , class U >
73: bool operator() ( const T & x@var95 , const U & y@var96 ) const {
74: return std ::@expr1073744330 abs (@expr1073744331 x@var95 -@expr1073744332 y@var96 ) ==@expr1073744333 1 ;
75: }
76: } ;
77:
78: struct equalVisitor {
79: template < class T , class U >
80: void operator() ( bool & result@var97 , T x@var98 , U y@var99 ) const {
81: result@var97 =@expr1073744334 !@expr1073744335 (@expr1073744336 x@var98 >@expr1073744337 y@var99 ||@expr1073744338 x@var98 <@expr1073744339 y@var99 ) ;
82: }
83: } ;
84: class Value {
85: public:
86:
87:
88: enum class Bound { Upper , Lower , Point } ;
89:
90: explicit Value ( long long val@var100 = 0 , Bound b@var101 = Bound :: Point )
91: : valueType@var141 ( ValueType :: INT ) ,
92: bound@var142 ( b@var101 ) ,
93: intvalue@var143 ( val@var100 ) ,
94: tokvalue@var144 ( nullptr ) ,
95: floatValue@var145 ( 0.0 ) ,
96: moveKind@var146 ( MoveKind :: NonMovedVariable ) ,
97: varvalue@var147 ( val@var100 ) ,
98: condition@var148 ( nullptr ) ,
99: varId@var150 ( 0U ) ,
100: safe@var151 ( false ) ,
101: conditional@var152 ( false ) ,
102: macro@var153 ( false ) ,
103: defaultArg@var154 ( false ) ,
104: indirect@var155 ( 0 ) ,
105: path@var156 ( 0 ) ,
106: wideintvalue@var157 ( val@var100 ) ,
107: subexpressions@var158 ( ) ,
108: capturetok@var159 ( nullptr ) ,
109: lifetimeKind@var160 ( LifetimeKind :: Object ) ,
110: lifetimeScope@var161 ( LifetimeScope :: Local ) ,
111: valueKind@var166 ( ValueKind :: Possible )
112: { }
113: Value ( const Token * c@var102 , long long val@var103 , Bound b@var104 = Bound :: Point ) ;
114:
115: static Value unknown ( ) ;
116:
117: bool equalValue ( const ValueFlow :: Value & rhs@var105 ) const {
118: if (@expr1073744340 valueType@var141 !=@expr1073744341 rhs@var105 .@expr1073744342 valueType@var106 ) {
119: return false ; }
120: switch (@expr1073744343 valueType@var141 ) {
121: case ValueType ::@expr1073744344 INT :@expr2521
122: case ValueType ::@expr1073744346 CONTAINER_SIZE :@expr2521
123: case ValueType ::@expr1073744348 BUFFER_SIZE :@expr2521
124: case ValueType ::@expr1073744350 ITERATOR_START :@expr2521
125: case ValueType ::@expr1073744352 ITERATOR_END :@expr2521 ;
126: if (@expr2530 intvalue@var143 !=@expr2531 rhs@var105 .@expr2532 intvalue@var107 ) {
127: return false ; }
128: break ;
129: case ValueType ::@expr1073744357 TOK :@expr2521 ;
130: if (@expr2535 tokvalue@var144 !=@expr2536 rhs@var105 .@expr2537 tokvalue@var108 ) {
131: return false ; }
132: break ;
133: case ValueType ::@expr1073744362 FLOAT :@expr2521 ;
134:
135: if (@expr1073744364 floatValue@var145 >@expr1073744365 rhs@var105 .@expr2542 floatValue@var109 ||@expr1073744367 floatValue@var145 <@expr1073744368 rhs@var105 .@expr2542 floatValue@var109 ) {
136: return false ; }
137: break ;
138: case ValueType ::@expr1073744370 MOVED :@expr2521 ;
139: if (@expr1073744372 moveKind@var146 !=@expr1073744373 rhs@var105 .@expr1073744374 moveKind@var110 ) {
140: return false ; }
141: break ;
142: case ValueType ::@expr1073744375 UNINIT :@expr2521 ;
143: break ;
144: case ValueType ::@expr1073744377 LIFETIME :@expr2521 ;
145: if (@expr2535 tokvalue@var144 !=@expr2536 rhs@var105 .@expr2537 tokvalue@var108 ) {
146: return false ; }
147: break ;
148: case ValueType ::@expr1073744382 SYMBOLIC :@expr2521 ;
149: if (@expr1073744384 !@expr1073744385 sameToken (@expr1073744386 tokvalue@var144 , rhs@var105 .@expr2537 tokvalue@var108 ) ) {
150: return false ; }
151: if (@expr2530 intvalue@var143 !=@expr2531 rhs@var105 .@expr2532 intvalue@var107 ) {
152: return false ; }
153: break ;
154: }
155: return true ;
156: }
157:
158: template < class T , class F >
159: static void visitValue ( T & self@var111 , F f@var112 ) {
160: switch (@expr1073744391 self@var111 .@expr1073744392 valueType@var113 ) {
161: case ValueType ::@expr1073744393 INT :@expr2570
162: case ValueType ::@expr1073744395 SYMBOLIC :@expr2570
163: case ValueType ::@expr1073744397 BUFFER_SIZE :@expr2570
164: case ValueType ::@expr1073744399 CONTAINER_SIZE :@expr2570
165: case ValueType ::@expr1073744401 ITERATOR_START :@expr2570
166: case ValueType ::@expr1073744403 ITERATOR_END :@expr2570 ; {
167: f@var112 (@expr1073744405 self@var111 .@expr1073744406 intvalue@var114 ) ;
168: break ;
169: }
170: case ValueType ::@expr1073744407 FLOAT :@expr2570 ; {
171: f@var112 (@expr1073744409 self@var111 .@expr1073744410 floatValue@var115 ) ;
172: break ;
173: }
174: case ValueType ::@expr1073744411 UNINIT :@expr2570
175: case ValueType ::@expr1073744413 TOK :@expr2570
176: case ValueType ::@expr1073744415 LIFETIME :@expr2570
177: case ValueType ::@expr1073744417 MOVED :@expr2570 ;
178: break ;
179: }
180: }
181:
182: struct compareVisitor {
183: struct innerVisitor {
184: template < class Compare , class T , class U >
185: void operator() ( bool & result@var116 , Compare compare@var117 , T x@var118 , U y@var119 ) const {
186: result@var116 =@expr1073744419 compare@var117 (@expr1073744420 x@var118 , y@var119 ) ;
187: }
188: } ;
189: template < class Compare , class T >
190: void operator() ( bool & result@var120 , const Value & rhs@var121 , Compare compare@var122 , T x@var123 ) const {
191: visitValue (@expr1073744422 rhs@var121 ,
192: std ::@expr1073744423 bind (@expr1073744424 innerVisitor {@expr1073744425 } , std ::@expr1073744426 ref (@expr1073744427 result@var120 ) , std ::@expr1073744428 move (@expr1073744429 compare@var122 ) , x@var123 , std ::@expr1073744430 placeholders ::@expr1073744431 _1@expr1073744421 ) ) ;
193: }
194: } ;
195:
196: template < class Compare >
197: bool compareValue ( const Value & rhs@var124 , Compare compare@var125 ) const {
198: assert (@expr1073744433 (@expr1073744434 !@expr1073744435 this@expr2612 .@expr1073744437 isSymbolicValue (@expr1073744438 ) &&@expr1073744439 !@expr1073744440 rhs@var124 .@expr1073744441 isSymbolicValue (@expr1073744442 ) ) ||@expr1073744443
199: (@expr1073744444 this@expr2612 .@expr1073744445 valueType@var141 ==@expr1073744446 rhs@var124 .@expr1073744447 valueType@var126 &&@expr1073744448 sameToken (@expr1073744449 this@expr2612 .@expr1073744450 tokvalue@var144 , rhs@var124 .@expr1073744451 tokvalue@var127 ) ) ) ;
200: bool result@var128 ; result@var128 =@expr1073744452 false ;
201: visitValue (@expr1073744453
202: *@expr1073744454 this@expr2612 ,
203: std ::@expr1073744455 bind (@expr1073744456 compareVisitor {@expr1073744457 } , std ::@expr2634 ref (@expr1073744459 result@var128 ) , std ::@expr2634 ref (@expr1073744461 rhs@var124 ) , std ::@expr1073744462 move (@expr1073744463 compare@var125 ) , std ::@expr1073744464 placeholders ::@expr1073744465 _1@expr1073744432 ) ) ;
204: return result@var128 ;
205: }
206:
207: bool operator== ( const Value & rhs@var129 ) const {
208: if (@expr1073744466 !@expr1073744467 equalValue (@expr1073744468 rhs@var129 ) ) {
209: return false ; }
210:
211: return varvalue@var147 ==@expr1073744469 rhs@var129 .@expr1073744470 varvalue@var130 &&@expr1073744471
212: condition@var148 ==@expr1073744472 rhs@var129 .@expr1073744473 condition@var131 &&@expr1073744474
213: varId@var150 ==@expr1073744475 rhs@var129 .@expr1073744476 varId@var132 &&@expr1073744477
214: conditional@var152 ==@expr1073744478 rhs@var129 .@expr1073744479 conditional@var133 &&@expr1073744480
215: defaultArg@var154 ==@expr1073744481 rhs@var129 .@expr1073744482 defaultArg@var134 &&@expr1073744483
216: indirect@var155 ==@expr1073744484 rhs@var129 .@expr1073744485 indirect@var135 &&@expr1073744486
217: valueKind@var166 ==@expr1073744487 rhs@var129 .@expr1073744488 valueKind@var136 ;
218: }
219:
220: bool operator!= ( const Value & rhs@var137 ) const {
221: return !@expr1073744489 (@expr1073744490 *@expr1073744491 this@expr1073744492 ==@expr1073744493 rhs@var137 ) ;
222: }
223:
224: template < class T , $class $= $typename $std $:: $enable_if $< std :: is_arithmetic < T > $:: $value $> $:: $type >
225: bool equalTo ( const T & x@var138 ) const {
226: bool result@var139 ; result@var139 =@expr1073744495 false ;
227: visitValue (@expr1073744496 *@expr1073744497 this@expr1073744498 , std ::@expr1073744499 bind (@expr1073744500 equalVisitor {@expr1073744501 } , std ::@expr1073744502 ref (@expr1073744503 result@var139 ) , x@var138 , std ::@expr1073744504 placeholders ::@expr1073744505 _1@expr1073744494 ) ) ;
228: return result@var139 ;
229: }
230:
231: void decreaseRange ( ) {
232: if (@expr1073744506 bound@var142 ==@expr1073744507 Bound ::@expr1073744508 Lower ) {
233: visitValue (@expr1073744509 *@expr2686 this@expr2687 , increment {@expr1073744512 } ) ; }
234: else { if (@expr1073744513 bound@var142 ==@expr1073744514 Bound ::@expr1073744515 Upper ) {
235: visitValue (@expr1073744516 *@expr2686 this@expr2687 , decrement {@expr1073744518 } ) ; } }
236: }
237:
238: void invertBound ( ) {
239: if (@expr1073744519 bound@var142 ==@expr1073744520 Bound ::@expr2697 Lower ) {
240: bound@var142 =@expr1073744522 Bound ::@expr2699 Upper ; }
241: else { if (@expr1073744524 bound@var142 ==@expr1073744525 Bound ::@expr2699 Upper ) {
242: bound@var142 =@expr1073744527 Bound ::@expr2697 Lower ; } }
243: }
244:
245: void invertRange ( ) {
246: invertBound (@expr1073744529 ) ;
247: decreaseRange (@expr1073744530 ) ;
248: }
249:
250: void assumeCondition ( const Token * tok@var140 ) ;
251:
252: std :: string infoString ( ) const ;
253:
254: enum class ValueType {
255: INT ,
256: TOK ,
257: FLOAT ,
258: MOVED ,
259: UNINIT ,
260: CONTAINER_SIZE ,
261: LIFETIME ,
262: BUFFER_SIZE ,
263: ITERATOR_START ,
264: ITERATOR_END ,
265: SYMBOLIC
266: } ; enum ValueType valueType@var141 ;
267: bool isIntValue ( ) const {
268: return valueType@var141 ==@expr1073744531 ValueType ::@expr1073744532 INT ;
269: }
270: bool isTokValue ( ) const {
271: return valueType@var141 ==@expr1073744533 ValueType ::@expr1073744534 TOK ;
272: }
273: bool isFloatValue ( ) const {
274: return valueType@var141 ==@expr1073744535 ValueType ::@expr1073744536 FLOAT ;
275: }
276: bool isMovedValue ( ) const {
277: return valueType@var141 ==@expr1073744537 ValueType ::@expr1073744538 MOVED ;
278: }
279: bool isUninitValue ( ) const {
280: return valueType@var141 ==@expr1073744539 ValueType ::@expr1073744540 UNINIT ;
281: }
282: bool isContainerSizeValue ( ) const {
283: return valueType@var141 ==@expr1073744541 ValueType ::@expr1073744542 CONTAINER_SIZE ;
284: }
285: bool isLifetimeValue ( ) const {
286: return valueType@var141 ==@expr1073744543 ValueType ::@expr1073744544 LIFETIME ;
287: }
288: bool isBufferSizeValue ( ) const {
289: return valueType@var141 ==@expr1073744545 ValueType ::@expr1073744546 BUFFER_SIZE ;
290: }
291: bool isIteratorValue ( ) const {
292: return valueType@var141 ==@expr1073744547 ValueType ::@expr1073744548 ITERATOR_START ||@expr1073744549 valueType@var141 ==@expr1073744550 ValueType ::@expr1073744551 ITERATOR_END ;
293: }
294: bool isIteratorStartValue ( ) const {
295: return valueType@var141 ==@expr1073744552 ValueType ::@expr1073744553 ITERATOR_START ;
296: }
297: bool isIteratorEndValue ( ) const {
298: return valueType@var141 ==@expr1073744554 ValueType ::@expr1073744555 ITERATOR_END ;
299: }
300: bool isSymbolicValue ( ) const {
301: return valueType@var141 ==@expr1073744556 ValueType ::@expr1073744557 SYMBOLIC ;
302: }
303:
304: bool isLocalLifetimeValue ( ) const {
305: return valueType@var141 ==@expr1073744559 ValueType ::@expr1073744560 LIFETIME &&@expr1073744561 lifetimeScope@var161 ==@expr1073744562 LifetimeScope ::@expr1073744563 Local@expr1073744558 ;
306: }
307:
308: bool isArgumentLifetimeValue ( ) const {
309: return valueType@var141 ==@expr1073744564 ValueType ::@expr1073744565 LIFETIME &&@expr1073744566 lifetimeScope@var161 ==@expr1073744567 LifetimeScope ::@expr1073744568 Argument ;
310: }
311:
312: bool isSubFunctionLifetimeValue ( ) const {
313: return valueType@var141 ==@expr1073744569 ValueType ::@expr1073744570 LIFETIME &&@expr1073744571 lifetimeScope@var161 ==@expr1073744572 LifetimeScope ::@expr1073744573 SubFunction ;
314: }
315:
316: bool isNonValue ( ) const {
317: return isMovedValue (@expr1073744574 ) ||@expr1073744575 isUninitValue (@expr1073744576 ) ||@expr1073744577 isLifetimeValue (@expr1073744578 ) ;
318: }
319:
320:
321: Bound bound@var142 ;
322:
323:
324: long long intvalue@var143 ;
325:
326:
327: const Token * tokvalue@var144 ;
328:
329:
330: double floatValue@var145 ;
331:
332:
333: enum class MoveKind { NonMovedVariable , MovedVariable , ForwardedVariable } ; enum MoveKind moveKind@var146 ;
334:
335:
336: long long varvalue@var147 ;
337:
338:
339: const Token * condition@var148 ;
340:
341: std :: list < std :: pair < const Token * , std :: string > > errorPath@var149 ;
342:
343:
344: int varId@var150 ;
345:
346:
347: bool safe@var151 ;
348:
349:
350: bool conditional@var152 ;
351:
352:
353: bool macro@var153 ;
354:
355:
356: bool defaultArg@var154 ;
357:
358: int indirect@var155 ;
359:
360:
361: long long path@var156 ;
362:
363:
364: long long wideintvalue@var157 ;
365:
366: std :: vector < std :: string > subexpressions@var158 ;
367:
368:
369: const Token * capturetok@var159 ;
370:
371: enum class LifetimeKind {
372:
373: Object ,
374:
375: SubObject ,
376:
377: Lambda ,
378:
379: Iterator ,
380:
381: Address
382: } ; enum LifetimeKind lifetimeKind@var160 ;
383:
384: enum class LifetimeScope { Local , Argument , SubFunction , ThisPointer , ThisValue } ; enum LifetimeScope lifetimeScope@var161 ;
385:
386: static const char * toString ( MoveKind moveKind@var162 ) ;
387: static const char * toString ( LifetimeKind lifetimeKind@var163 ) ;
388: static const char * toString ( LifetimeScope lifetimeScope@var164 ) ;
389: static const char * toString ( Bound bound@var165 ) ;
390:
391:
392: enum class ValueKind {
393:
394: Possible ,
395:
396: Known ,
397:
398: Inconclusive ,
399:
400: Impossible
401: } ; enum ValueKind valueKind@var166 ;
402:
403: void setKnown ( ) {
404: valueKind@var166 =@expr1073744579 ValueKind ::@expr1073744580 Known ;
405: }
406:
407: bool isKnown ( ) const {
408: return valueKind@var166 ==@expr1073744581 ValueKind ::@expr1073744582 Known ;
409: }
410:
411: void setPossible ( ) {
412: valueKind@var166 =@expr1073744584 ValueKind ::@expr1073744585 Possible@expr1073744583 ;
413: }
414:
415: bool isPossible ( ) const {
416: return valueKind@var166 ==@expr1073744587 ValueKind ::@expr1073744588 Possible@expr1073744586 ;
417: }
418:
419: bool isImpossible ( ) const {
420: return valueKind@var166 ==@expr1073744589 ValueKind ::@expr1073744590 Impossible ;
421: }
422:
423: void setImpossible ( ) {
424: valueKind@var166 =@expr1073744591 ValueKind ::@expr1073744592 Impossible ;
425: }
426:
427: void setInconclusive ( bool inconclusive@var167 = true ) {
428: if (@expr1073744593 inconclusive@var167 ) {
429: valueKind@var166 =@expr1073744594 ValueKind ::@expr1073744595 Inconclusive ; }
430: }
431:
432: bool isInconclusive ( ) const {
433: return valueKind@var166 ==@expr1073744596 ValueKind ::@expr1073744597 Inconclusive ;
434: }
435:
436: void changeKnownToPossible ( ) {
437: if (@expr1073744599 isKnown (@expr1073744600 ) ) {
438: valueKind@var166 =@expr1073744601 ValueKind ::@expr1073744602 Possible@expr1073744598 ; }
439: }
440:
441: bool errorSeverity ( ) const {
442: return !@expr1073744603 condition@var148 &&@expr1073744604 !@expr1073744605 defaultArg@var154 ;
443: }
444:
445: static bool sameToken ( const Token * tok1@var168 , const Token * tok2@var169 ) ;
446: } ;
447:
448:
449: const ValueFlow :: Value * valueFlowConstantFoldAST ( Token * expr@var170 , const Settings * settings@var171 ) ;
450:
451:
452: void setValues ( TokenList * tokenlist@var172 , SymbolDatabase * symboldatabase@var173 , ErrorLogger * errorLogger@var174 , const Settings * settings@var175 ) ;
453:
454: std :: string eitherTheConditionIsRedundant ( const Token * condition@var176 ) ;
455:
456: unsigned long getSizeOf ( const ValueType & vt@var177 , const Settings * settings@var178 ) ;
457:
458: const ValueFlow :: Value * findValue ( const std :: list < ValueFlow :: Value > & values@var179 ,
459: const Settings * settings@var180 ,
460: std :: function < bool ( const ValueFlow :: Value & ) > pred@var181 ) ;
461:
462: std :: vector < ValueFlow :: Value > isOutOfBounds ( const Value & size@var182 , const Token * indexTok@var183 , bool possible@var184 = true ) ;
463: }
464:
465: ValueFlow :: Value asImpossible ( ValueFlow :: Value v@var185 ) ;
466:
467: bool isContainerSizeChanged ( const Token * tok@var186 , const Settings * settings@var187 = nullptr , int depth@var188 = 20 ) ;
468:
469: struct LifetimeToken {
470: const Token * token@var189 ;
471: bool addressOf@var190 ;
472: ValueFlow :: Value :: ErrorPath errorPath@var191 ;
473: bool inconclusive@var192 ;
474:
475: LifetimeToken ( ) : token@var189 ( nullptr ) , addressOf@var190 ( false ) , errorPath@var191 ( ) , inconclusive@var192 ( false ) { }
476:
477: LifetimeToken ( const Token * token@var193 , ValueFlow :: Value :: ErrorPath errorPath@var194 )
478: : token@var189 ( token@var193 ) , addressOf@var190 ( false ) , errorPath@var191 ( std :: move ( errorPath@var194 ) ) , inconclusive@var192 ( false )
479: { }
480:
481: LifetimeToken ( const Token * token@var195 , bool addressOf@var196 , ValueFlow :: Value :: ErrorPath errorPath@var197 )
482: : token@var189 ( token@var195 ) , addressOf@var190 ( addressOf@var196 ) , errorPath@var191 ( std :: move ( errorPath@var197 ) ) , inconclusive@var192 ( false )
483: { }
484:
485: static std :: vector < LifetimeToken > setAddressOf ( std :: vector < LifetimeToken > v@var198 , bool b@var199 ) {
486: for (@expr1073744606 LifetimeToken &@expr1073744607 x@var200 :@expr1073744608 v@var198 ) {
487: x@var200 .@expr1073744609 addressOf@var201 =@expr1073744610 b@var199 ; }
488: return v@var198 ;
489: }
490:
491: static std :: vector < LifetimeToken > setInconclusive ( std :: vector < LifetimeToken > v@var202 , bool b@var203 ) {
492: for (@expr1073744611 LifetimeToken &@expr1073744612 x@var204 :@expr1073744613 v@var202 ) {
493: x@var204 .@expr1073744614 inconclusive@var205 =@expr1073744615 b@var203 ; }
494: return v@var202 ;
495: }
496: } ;
497:
498: const Token * parseCompareInt ( const Token * tok@var206 , ValueFlow :: Value & true_value@var207 , ValueFlow :: Value & false_value@var208 , const std :: function < std :: vector < long long > ( const Token * ) > & evaluate@var209 ) ;
499: const Token * parseCompareInt ( const Token * tok@var210 , ValueFlow :: Value & true_value@var211 , ValueFlow :: Value & false_value@var212 ) ;
500:
501: ValueFlow :: Value inferCondition ( std :: string op@var213 , long long val@var214 , const Token * varTok@var215 ) ;
502: ValueFlow :: Value inferCondition ( const std :: string & op@var216 , const Token * varTok@var217 , long long val@var218 ) ;
503:
504: ValuePtr < InferModel > makeIntegralInferModel ( ) ;
505:
506: const Token * solveExprValue ( const Token * expr@var219 ,
507: const std :: function < std :: vector < long long > ( const Token * ) > & eval@var220 ,
508: ValueFlow :: Value & value@var221 ) ;
509:
510: std :: vector < LifetimeToken > getLifetimeTokens ( const Token * tok@var222 ,
511: bool escape@var223 = false ,
512: ValueFlow :: Value :: ErrorPath errorPath@var224 = ValueFlow :: Value :: ErrorPath { } ) ;
513:
514: bool hasLifetimeToken ( const Token * tok@var225 , const Token * lifetime@var226 ) ;
515:
516: const Variable * getLifetimeVariable ( const Token * tok@var227 , ValueFlow :: Value :: ErrorPath & errorPath@var228 , bool * addressOf@var229 = nullptr ) ;
517:
518: const Variable * getLifetimeVariable ( const Token * tok@var230 ) ;
519:
520: bool isLifetimeBorrowed ( const Token * tok@var231 , const Settings * settings@var232 ) ;
521:
522: std :: string lifetimeType ( const Token * tok@var233 , const ValueFlow :: Value * val@var234 ) ;
523:
524: std :: string lifetimeMessage ( const Token * tok@var235 , const ValueFlow :: Value * val@var236 , ValueFlow :: Value :: ErrorPath & errorPath@var237 ) ;
525:
526: ValueFlow :: Value getLifetimeObjValue ( const Token * tok@var238 , bool inconclusive@var239 = false ) ;
527:
528: std :: vector < ValueFlow :: Value > getLifetimeObjValues ( const Token * tok@var240 ,
529: bool inconclusive@var241 = false ,
530: long long path@var242 = 0 ) ;
531:
532: const Token * getEndOfExprScope ( const Token * tok@var243 , const Scope * defaultScope@var244 = nullptr , bool smallest@var245 = true ) ;

##file cppcheck-2.8/lib/templatesimplifier.h

1:
|
34:
35: class ErrorLogger ;
36: class Settings ;
37: class Token ;
38: class Tokenizer ;
39: class TokenList ;
40:
|
44:
45: class TemplateSimplifier {
46: friend class TestSimplifyTemplate ;
47:
48: public:
49: explicit TemplateSimplifier ( Tokenizer * tokenizer@var246 ) ;
50: ~ TemplateSimplifier ( ) ;
51:
52:
53:
54: void checkComplicatedSyntaxErrorsInTemplates ( ) ;
55:
|
61:
62: static unsigned int templateParameters ( const Token * tok@var247 ) ;
63:
|
66:
67: class TokenAndName {
68: Token * mToken@var248 ;
69: std :: string mScope@var249 ;
70: std :: string mName@var250 ;
71: std :: string mFullName@var251 ;
72: const Token * mNameToken@var252 ;
73: const Token * mParamEnd@var253 ;
74: unsigned int mFlags@var254 ;
75:
76: enum Anonymous0 {
77: fIsClass = ( 1 << 0 ) ,
78: fIsFunction = ( 1 << 1 ) ,
79: fIsVariable = ( 1 << 2 ) ,
80: fIsAlias = ( 1 << 3 ) ,
81: fIsSpecialization = ( 1 << 4 ) ,
82: fIsPartialSpecialization = ( 1 << 5 ) ,
83: fIsForwardDeclaration = ( 1 << 6 ) ,
84: fIsVariadic = ( 1 << 7 ) ,
85: fIsFriend = ( 1 << 8 ) ,
86: fFamilyMask = ( fIsClass | fIsFunction | fIsVariable )
87: } ;
88:
89: void isClass ( bool state@var255 ) {
90: setFlag (@expr1073744616 fIsClass , state@var255 ) ;
91: }
92: void isFunction ( bool state@var256 ) {
93: setFlag (@expr1073744617 fIsFunction , state@var256 ) ;
94: }
95: void isVariable ( bool state@var257 ) {
96: setFlag (@expr1073744618 fIsVariable , state@var257 ) ;
97: }
98: void isAlias ( bool state@var258 ) {
99: setFlag (@expr1073744619 fIsAlias , state@var258 ) ;
100: }
101: void isSpecialization ( bool state@var259 ) {
102: setFlag (@expr1073744620 fIsSpecialization , state@var259 ) ;
103: }
104: void isPartialSpecialization ( bool state@var260 ) {
105: setFlag (@expr1073744621 fIsPartialSpecialization , state@var260 ) ;
106: }
107: void isForwardDeclaration ( bool state@var261 ) {
108: setFlag (@expr1073744622 fIsForwardDeclaration , state@var261 ) ;
109: }
110: void isVariadic ( bool state@var262 ) {
111: setFlag (@expr1073744623 fIsVariadic , state@var262 ) ;
112: }
113: void isFriend ( bool state@var263 ) {
114: setFlag (@expr1073744624 fIsFriend , state@var263 ) ;
115: }
116:
|
121:
122: bool getFlag ( unsigned int flag@var264 ) const {
123: return (@expr2801 (@expr2801 mFlags@var254 &@expr1073744627 flag@var264 ) !=@expr1073744628 0 ) ;
124: }
125:
|
130:
131: void setFlag ( unsigned int flag@var265 , bool state@var266 ) {
132: mFlags@var254 =@expr1073744629 state@var266 ?@expr1073744630 mFlags@var254 |@expr1073744631 flag@var265 :@expr1073744632 mFlags@var254 &@expr1073744633 ~@expr1073744634 flag@var265 ;
133: }
134:
135: public:
136:
|
140:
141: TokenAndName ( Token * token@var267 , const std :: string & scope@var268 ) ;
142:
|
148:
149: TokenAndName ( Token * token@var269 , const std :: string & scope@var270 , const Token * nameToken@var271 , const Token * paramEnd@var272 ) ;
150: TokenAndName ( const TokenAndName & other@var273 ) ;
151: ~ TokenAndName ( ) ;
152:
153: bool operator== ( const TokenAndName & rhs@var274 ) const {
154: return mToken@var248 ==@expr1073744635 rhs@var274 .@expr1073744636 mToken@var275 &&@expr1073744637 mScope@var249 ==@expr1073744638 rhs@var274 .@expr1073744639 mScope@var276 &&@expr1073744640 mName@var250 ==@expr1073744641 rhs@var274 .@expr1073744642 mName@var277 &&@expr1073744643 mFullName@var251 ==@expr1073744644 rhs@var274 .@expr1073744645 mFullName@var278 &&@expr1073744646
155: mNameToken@var252 ==@expr1073744647 rhs@var274 .@expr1073744648 mNameToken@var279 &&@expr1073744649 mParamEnd@var253 ==@expr1073744650 rhs@var274 .@expr1073744651 mParamEnd@var280 &&@expr1073744652 mFlags@var254 ==@expr1073744653 rhs@var274 .@expr1073744654 mFlags@var281 ;
156: }
157:
158: Token * token ( ) const {
159: return mToken@var248 ;
160: }
161: void token ( Token * token@var282 ) {
162: mToken@var248 =@expr1073744655 token@var282 ;
163: }
164: const std :: string & scope ( ) const {
165: return mScope@var249 ;
166: }
167: const std :: string & name ( ) const {
168: return mName@var250 ;
169: }
170: const std :: string & fullName ( ) const {
171: return mFullName@var251 ;
172: }
173: const Token * nameToken ( ) const {
174: return mNameToken@var252 ;
175: }
176: const Token * paramEnd ( ) const {
177: return mParamEnd@var253 ;
178: }
179: void paramEnd ( const Token * end@var283 ) {
180: mParamEnd@var253 =@expr1073744656 end@var283 ;
181: }
182:
183: bool isClass ( ) const {
184: return getFlag (@expr1073744657 fIsClass ) ;
185: }
186: bool isFunction ( ) const {
187: return getFlag (@expr1073744658 fIsFunction ) ;
188: }
189: bool isVariable ( ) const {
190: return getFlag (@expr1073744659 fIsVariable ) ;
191: }
192: bool isAlias ( ) const {
193: return getFlag (@expr1073744660 fIsAlias ) ;
194: }
195: bool isSpecialization ( ) const {
196: return getFlag (@expr1073744661 fIsSpecialization ) ;
197: }
198: bool isPartialSpecialization ( ) const {
199: return getFlag (@expr1073744662 fIsPartialSpecialization ) ;
200: }
201: bool isForwardDeclaration ( ) const {
202: return getFlag (@expr1073744663 fIsForwardDeclaration ) ;
203: }
204: bool isVariadic ( ) const {
205: return getFlag (@expr1073744664 fIsVariadic ) ;
206: }
207: bool isFriend ( ) const {
208: return getFlag (@expr1073744665 fIsFriend ) ;
209: }
210:
|
216:
217: const Token * aliasStartToken ( ) const ;
218:
|
224:
225: const Token * aliasEndToken ( ) const ;
226:
|
233:
234: bool isAliasToken ( const Token * tok@var284 ) const ;
235:
|
241:
242: bool isSameFamily ( const TemplateSimplifier :: TokenAndName & decl@var285 ) const {
243:
244:
245: return (@expr2842 (@expr2842 mFlags@var254 &@expr1073744668 fFamilyMask ) &@expr1073744669 (@expr2842 decl@var285 .@expr1073744671 mFlags@var286 &@expr1073744672 fFamilyMask ) ) !=@expr1073744673 0 ;
246: }
247: } ;
248:
|
253:
254: static Token * findTemplateDeclarationEnd ( Token * tok@var287 ) ;
255: static const Token * findTemplateDeclarationEnd ( const Token * tok@var288 ) ;
256:
|
264:
265: static bool instantiateMatch ( const Token * instance@var289 , const unsigned long numberOfArguments@var290 , bool variadic@var291 , const char patternAfter@var292 [ ] ) ;
266:
|
272:
273: int getTemplateNamePosition ( const Token * tok@var293 ) ;
274:
|
280:
281: static bool getTemplateNamePositionTemplateClass ( const Token * tok@var294 , int & namepos@var295 ) ;
282:
|
288:
289: static bool getTemplateNamePositionTemplateFunction ( const Token * tok@var296 , int & namepos@var297 ) ;
290:
|
296:
297: static bool getTemplateNamePositionTemplateVariable ( const Token * tok@var298 , int & namepos@var299 ) ;
298:
|
303:
304: void simplifyTemplates (
305: const std :: time_t maxtime@var300 ,
306: bool & codeWithTemplates@var301 ) ;
307:
|
313:
314: static bool simplifyNumericCalculations ( Token * tok@var302 , bool isTemplate@var303 = true ) ;
315:
|
321:
322: bool simplifyCalculations ( Token * frontToken@var304 = nullptr , Token * backToken@var305 = nullptr , bool isTemplate@var306 = true ) ;
323:
|
327:
328: void simplifyTemplateArgs ( Token * start@var307 , Token * end@var308 ) ;
329:
330: private:
331:
|
334:
335: bool getTemplateDeclarations ( ) ;
336:
|
340:
341: void addInstantiation ( Token * token@var309 , const std :: string & scope@var310 ) ;
342:
|
345:
346: void getTemplateInstantiations ( ) ;
347:
|
351:
352: void fixForwardDeclaredDefaultArgumentValues ( ) ;
353:
|
356:
357: void useDefaultArgumentValues ( ) ;
358:
|
362:
363: void useDefaultArgumentValues ( TokenAndName & declaration@var311 ) ;
364:
|
368:
369: void getSpecializations ( ) ;
370:
|
374:
375: void getPartialSpecializations ( ) ;
376:
|
379:
380: void simplifyTemplateAliases ( ) ;
381:
|
390:
391: bool simplifyTemplateInstantiations (
392: const TokenAndName & templateDeclaration@var312 ,
393: const std :: list < const Token * > & specializations@var313 ,
394: const std :: time_t maxtime@var314 ,
395: std :: set < std :: string > & expandedtemplates@var315 ) ;
396:
|
401:
402: void addNamespace ( const TokenAndName & templateDeclaration@var316 , const Token * tok@var317 ) ;
403:
|
409:
410: static bool alreadyHasNamespace ( const TokenAndName & templateDeclaration@var318 , const Token * tok@var319 ) ;
411:
|
419:
420: void expandTemplate (
421: const TokenAndName & templateDeclaration@var320 ,
422: const TokenAndName & templateInstantiation@var321 ,
423: const std :: vector < const Token * > & typeParametersInDeclaration@var322 ,
424: const std :: string & newName@var323 ,
425: bool copy@var324 ) ;
426:
|
432:
433: void replaceTemplateUsage ( const TokenAndName & instantiation@var325 ,
434: const std :: list < std :: string > & typeStringsUsedInTemplateInstantiation@var326 ,
435: const std :: string & newName@var327 ) ;
436:
|
443:
444: static void getTemplateParametersInDeclaration (
445: const Token * tok@var328 ,
446: std :: vector < const Token * > & typeParametersInDeclaration@var329 ) ;
447:
|
450:
451: static bool removeTemplate ( Token * tok@var330 ) ;
452:
453:
454: static void syntaxError ( const Token * tok@var331 ) ;
455:
456: static bool matchSpecialization (
457: const Token * templateDeclarationNameToken@var332 ,
458: const Token * templateInstantiationNameToken@var333 ,
459: const std :: list < const Token * > & specializations@var334 ) ;
460:
|
465:
466: static void eraseTokens ( Token * begin@var335 , const Token * end@var336 ) ;
467:
|
472:
473: static void deleteToken ( Token * tok@var337 ) ;
474:
|
480:
481: std :: string getNewName (
482: Token * tok2@var338 ,
483: std :: list < std :: string > & typeStringsUsedInTemplateInstantiation@var339 ) ;
484:
485: void printOut (
486: const TokenAndName & tokenAndName@var340 ,
487: const std :: string & indent@var341 = "    " ) const ;
488: void printOut ( const std :: string & text@var342 = "" ) const ;
489:
490: Tokenizer * mTokenizer@var343 ;
491: TokenList & mTokenList@var344 ;
492: const Settings * mSettings@var345 ;
493: ErrorLogger * mErrorLogger@var346 ;
494: bool mChanged@var347 ;
495:
496: std :: list < TokenAndName > mTemplateDeclarations@var348 ;
497: std :: list < TokenAndName > mTemplateForwardDeclarations@var349 ;
498: std :: map < Token * , Token * > mTemplateForwardDeclarationsMap@var350 ;
499: std :: map < Token * , Token * > mTemplateSpecializationMap@var351 ;
500: std :: map < Token * , Token * > mTemplatePartialSpecializationMap@var352 ;
501: std :: list < TokenAndName > mTemplateInstantiations@var353 ;
502: std :: list < TokenAndName > mInstantiatedTemplates@var354 ;
503: std :: list < TokenAndName > mMemberFunctionsToDelete@var355 ;
504: std :: vector < TokenAndName > mExplicitInstantiationsToDelete@var356 ;
505: std :: vector < TokenAndName > mTypesUsedInTemplateInstantiation@var357 ;
506: std :: unordered_map < const Token * , int > mTemplateNamePos@var358 ;
507: } ;

##file cppcheck-2.8/lib/utils.h

1:
|
31:
32: struct SelectMapKeys {
33: template < class Pair >
34: Pair :: first_type operator() ( const Pair & p@var359 ) const {
35: return p@var359 .@expr1073744674 first@var360 ;
36: }
37: } ;
38:
39: struct SelectMapValues {
40: template < class Pair >
41: Pair :: second_type operator() ( const Pair & p@var361 ) const {
42: return p@var361 .@expr1073744675 second@var362 ;
43: }
44: } ;
45:
46: template < class Range , class T >
47: bool contains ( const Range & r@var363 , const T & x@var364 )
48: {
49: return std ::@expr1073744676 find (@expr1073744677 r@var363 .@expr1073744678 begin (@expr1073744679 ) , r@var363 .@expr2856 end (@expr2857 ) , x@var364 ) !=@expr1073744682 r@var363 .@expr2856 end (@expr2857 ) ;
50: }
51:
52: template < class T >
53: bool contains ( const std :: initializer_list < T > & r@var365 , const T & x@var366 )
54: {
55: return std ::@expr1073744685 find (@expr1073744686 r@var365 .@expr1073744687 begin (@expr1073744688 ) , r@var365 .@expr2865 end (@expr2866 ) , x@var366 ) !=@expr1073744691 r@var365 .@expr2865 end (@expr2866 ) ;
56: }
57:
58: template < class T , class U >
59: bool contains ( const std :: initializer_list < T > & r@var367 , const U & x@var368 )
60: {
61: return std ::@expr1073744694 find (@expr1073744695 r@var367 .@expr1073744696 begin (@expr1073744697 ) , r@var367 .@expr2874 end (@expr2875 ) , x@var368 ) !=@expr1073744700 r@var367 .@expr2874 end (@expr2875 ) ;
62: }
63:
64:
65: struct EnumClassHash {
66: template < typename T >
67: unsigned long operator() ( T t@var369 ) const
68: {
69: return static_cast < unsigned long > (@expr1073744703 t@var369 ) ;
70: }
71: } ;
72:
73: bool endsWith ( const std :: string & str@var370 , char c@var371 )
74: {
75: return !@expr1073744704 str@var370 .@expr1073744705 empty (@expr1073744706 ) &&@expr1073744707 str@var370 .@expr1073744708 back (@expr1073744709 ) ==@expr1073744710 c@var371 ;
76: }
77:
78: bool endsWith ( const std :: string & str@var372 , const char end@var373 [ ] , unsigned long endlen@var374 )
79: {
80: return (@expr2887 str@var372 .@expr2888 size (@expr2889 ) >=@expr1073744714 endlen@var374 ) &&@expr1073744715 (@expr2887 str@var372 .@expr1073744717 compare (@expr1073744718 str@var372 .@expr2888 size (@expr2889 ) -@expr1073744721 endlen@var374 , endlen@var374 , end@var373 ) ==@expr1073744722 0 ) ;
81: }
82:
83: template < unsigned long N >
84: bool endsWith ( const std :: string & str@var375 , const char ( & end@var376 ) [ N ] )
85: {
86: return endsWith (@expr1073744724 str@var375 , end@var376 , N@expr1073744723 -@expr1073744725 1 ) ;
87: }
88:
89: static bool isPrefixStringCharLiteral ( const std :: string & str@var377 , char q@var378 , const std :: string & p@var379 )
90: {
91: if (@expr1073744726 !@expr1073744727 endsWith (@expr1073744728 str@var377 , q@var378 ) ) {
92: return false ; }
93: if (@expr1073744729 (@expr1073744730 str@var377 .@expr1073744731 length (@expr1073744732 ) +@expr1073744733 1 ) >@expr1073744734 p@var379 .@expr1073744735 length (@expr1073744736 ) &&@expr1073744737 (@expr1073744738 str@var377 .@expr1073744739 compare (@expr1073744740 0 , p@var379 .@expr1073744741 size (@expr1073744742 ) +@expr1073744743 1 , p@var379 +@expr1073744744 q@var378 ) ==@expr1073744745 0 ) ) {
94: return true ; }
95: return false ;
96: }
97:
98: static bool isStringCharLiteral ( const std :: string & str@var380 , char q@var381 )
99: {
100: static const std ::@expr2922 vector < std ::@expr2922 string > suffixes@var382 {@expr1073744748 "" , "u8" , "u" , "U" , "L" } ;
101: for (@expr1073744749 const std ::@expr2922 string &@expr1073744751 p@var383 :@expr1073744752 suffixes@var382 ) {
102: if (@expr1073744753 isPrefixStringCharLiteral (@expr1073744754 str@var380 , q@var381 , p@var383 ) ) {
103: return true ; }
104: }
105: return false ;
106: }
107:
108: static bool isStringLiteral ( const std :: string & str@var384 )
109: {
110: return isStringCharLiteral (@expr1073744755 str@var384 , '"' ) ;
111: }
112:
113: static bool isCharLiteral ( const std :: string & str@var385 )
114: {
115: return isStringCharLiteral (@expr1073744756 str@var385 , '\'' ) ;
116: }
117:
118: static std :: string getStringCharLiteral ( const std :: string & str@var386 , char q@var387 )
119: {
120: const unsigned long quotePos@var388 =@expr1073744757 str@var386 .@expr1073744758 find (@expr1073744759 q@var387 ) ;
121: return str@var386 .@expr1073744760 substr (@expr1073744761 quotePos@var388 +@expr1073744762 1U , str@var386 .@expr1073744763 size (@expr1073744764 ) -@expr1073744765 quotePos@var388 -@expr1073744766 2U ) ;
122: }
123:
124: static std :: string getStringLiteral ( const std :: string & str@var389 )
125: {
126: if (@expr1073744767 isStringLiteral (@expr1073744768 str@var389 ) ) {
127: return getStringCharLiteral (@expr1073744769 str@var389 , '"' ) ; }
128: return "" ;
129: }
130:
131: static std :: string getCharLiteral ( const std :: string & str@var390 )
132: {
133: if (@expr1073744770 isCharLiteral (@expr1073744771 str@var390 ) ) {
134: return getStringCharLiteral (@expr1073744772 str@var390 , '\'' ) ; }
135: return "" ;
136: }
137:
138: static const char * getOrdinalText ( int i@var391 )
139: {
140: if (@expr1073744773 i@var391 ==@expr1073744774 1 ) {
141: return "st" ; }
142: if (@expr1073744775 i@var391 ==@expr1073744776 2 ) {
143: return "nd" ; }
144: if (@expr1073744777 i@var391 ==@expr1073744778 3 ) {
145: return "rd" ; }
146: return "th" ;
147: }
148:
149: int caseInsensitiveStringCompare ( const std :: string & lhs@var392 , const std :: string & rhs@var393 ) ;
150:
151: bool isValidGlobPattern ( const std :: string & pattern@var394 ) ;
152:
153: bool matchglob ( const std :: string & pattern@var395 , const std :: string & name@var396 ) ;
154:
155: bool matchglobs ( const std :: vector < std :: string > & patterns@var397 , const std :: string & name@var398 ) ;
156:
157: void strTolower ( std :: string & str@var399 ) ;

##file cppcheck-2.8/lib/token.h

1:
|
40:
41: class Enumerator ;
42: class Function ;
43: class Scope ;
44: class Settings ;
45: class Type ;
46: class ValueType ;
47: class Variable ;
48: class TokenList ;
49: class ConstTokenRange ;
50: class Token ;
51:
|
54:
55: struct TokensFrontBack {
56: Token * front@var400 ;
57: Token * back@var401 ;
58: const TokenList * list@var402 ;
59: } ;
60:
61: struct ScopeInfo2 {
62: ScopeInfo2 ( const std :: string & name_@var403 , const Token * bodyEnd_@var404 , const std :: set < std :: string > & usingNamespaces_@var405 = std :: set < std :: string > ( ) ) : name@var406 ( name_@var403 ) , bodyEnd@var407 ( bodyEnd_@var404 ) , usingNamespaces@var408 ( usingNamespaces_@var405 ) { }
63: std :: string name@var406 ;
64: const Token * const bodyEnd@var407 ;
65: std :: set < std :: string > usingNamespaces@var408 ;
66: } ;
67:
68: struct TokenImpl {
69: int mVarId@var409 ;
70: int mFileIndex@var410 ;
71: int mLineNumber@var411 ;
72: int mColumn@var412 ;
73: int mExprId@var413 ;
74:
75:
76: Token * mAstOperand1@var414 ;
77: Token * mAstOperand2@var415 ;
78: Token * mAstParent@var416 ;
79:
80:
81: const Scope * mScope@var417 ;
82: union {
83: const Function * mFunction@var418 ;
84: const Variable * mVariable@var419 ;
85: const :: Type * mType@var420 ;
86: const Enumerator * mEnumerator@var421 ;
87: } ;
88:
|
92:
93: int mProgressValue@var422 ;
94:
|
97:
98: int mIndex@var423 ;
99:
100:
101: std :: string * mOriginalName@var424 ;
102:
103:
104: ValueType * mValueType@var425 ;
105:
106:
107: std :: list < ValueFlow :: Value > * mValues@var426 ;
108: static const std :: list < ValueFlow :: Value > mEmptyValueList@var427 ;
109:
110:
111: std :: set < TemplateSimplifier :: TokenAndName * > * mTemplateSimplifierPointers@var428 ;
112:
113:
114: std :: shared_ptr < ScopeInfo2 > mScopeInfo@var429 ;
115:
116:
117: struct CppcheckAttributes {
118: enum Type { LOW , HIGH } ; enum Type type@var430 ;
119: long long value@var431 ;
120: struct CppcheckAttributes * next@var432 ;
121: } ;
122: struct CppcheckAttributes * mCppcheckAttributes@var433 ;
123:
124:
125: enum class Cpp11init { UNKNOWN , CPP11INIT , NOINIT } ; enum Cpp11init mCpp11init@var434 ;
126:
127:
128: unsigned char mBits@var435 ;
129:
130: void setCppcheckAttribute ( CppcheckAttributes :: Type type@var436 , long long value@var437 ) ;
131: bool getCppcheckAttribute ( CppcheckAttributes :: Type type@var438 , long long * value@var439 ) const ;
132:
133: TokenImpl ( )
134: : mVarId@var409 ( 0 )
135: , mFileIndex@var410 ( 0 )
136: , mLineNumber@var411 ( 0 )
137: , mColumn@var412 ( 0 )
138: , mExprId@var413 ( 0 )
139: , mAstOperand1@var414 ( nullptr )
140: , mAstOperand2@var415 ( nullptr )
141: , mAstParent@var416 ( nullptr )
142: , mScope@var417 ( nullptr )
143: , mFunction@var418 ( nullptr )
144: , mProgressValue@var422 ( 0 )
145: , mIndex@var423 ( 0 )
146: , mOriginalName@var424 ( nullptr )
147: , mValueType@var425 ( nullptr )
148: , mValues@var426 ( nullptr )
149: , mTemplateSimplifierPointers@var428 ( nullptr )
150: , mScopeInfo@var429 ( nullptr )
151: , mCppcheckAttributes@var433 ( nullptr )
152: , mCpp11init@var434 ( Cpp11init :: UNKNOWN )
153: , mBits@var435 ( 0 )
154: { }
155:
156: ~ TokenImpl ( ) ;
157: } ;
158:
|
171:
172: class Token {
173: private:
174: TokensFrontBack * mTokensFrontBack@var440 ;
175:
176:
177: Token ( const Token & ) ;
178: Token operator= ( const Token & ) ;
179:
180: public:
181: enum Type {
182: eVariable , eType , eFunction , eKeyword , eName ,
183: eNumber , eString , eChar , eBoolean , eLiteral , eEnumerator ,
184: eArithmeticalOp , eComparisonOp , eAssignmentOp , eLogicalOp , eBitOp , eIncDecOp , eExtendedOp ,
185: eBracket ,
186: eLambda ,
187: eEllipsis ,
188: eOther ,
189: eNone
190: } ;
191:
192: explicit Token ( TokensFrontBack * tokensFrontBack@var441 = nullptr ) ;
193: ~ Token ( ) ;
194:
195: ConstTokenRange until ( const Token * t@var442 ) const ;
196:
197: template < typename T >
198: void str ( T && s@var443 ) {
199: mStr@var655 =@expr1073744779 s@var443 ;
200: mImpl@var661 .@expr1073744780 mVarId@var692 =@expr1073744781 0 ;
201:
202: update_property_info (@expr1073744782 ) ;
203: }
204:
|
208:
209: void concatStr ( const std :: string & b@var444 ) ;
210:
211: const std :: string & str ( ) const {
212: return mStr@var655 ;
213: }
214:
|
217:
218: void deleteNext ( int count@var445 = 1 ) ;
219:
|
222:
223: void deletePrevious ( int count@var446 = 1 ) ;
224:
|
227:
228: void swapWithNext ( ) ;
229:
|
234:
235: const Token * tokAt ( int index@var447 ) const ;
236: Token * tokAt ( int index@var448 ) {
237: return const_cast < Token *@expr2959 > (@expr1073744784 const_cast < const Token *@expr2959 > (@expr1073744786 this@expr1073744787 ) .@expr1073744788 tokAt (@expr1073744789 index@var448 ) ) ;
238: }
239:
|
243:
244: const Token * linkAt ( int index@var449 ) const ;
245: Token * linkAt ( int index@var450 ) {
246: return const_cast < Token *@expr2966 > (@expr1073744791 const_cast < const Token *@expr2966 > (@expr1073744793 this@expr1073744794 ) .@expr1073744795 linkAt (@expr1073744796 index@var450 ) ) ;
247: }
248:
|
252:
253: const std :: string & strAt ( int index@var451 ) const ;
254:
|
273:
274: template < unsigned long count >
275: static bool simpleMatch ( const Token * tok@var452 , const char ( & pattern@var453 ) [ count ] ) {
276: return simpleMatch (@expr1073744798 tok@var452 , pattern@var453 , count@expr1073744797 -@expr1073744799 1 ) ;
277: }
278:
279: static bool simpleMatch ( const Token * tok@var454 , const char pattern@var455 [ ] , unsigned long pattern_len@var456 ) ;
280:
|
323:
324: static bool Match ( const Token * tok@var457 , const char pattern@var458 [ ] , int varid@var459 = 0 ) ;
325:
|
332:
333: static int getStrLength ( const Token * tok@var460 ) ;
334:
|
341:
342: static int getStrArraySize ( const Token * tok@var461 ) ;
343:
|
351:
352: static int getStrSize ( const Token * tok@var462 , const Settings * const settings@var463 ) ;
353:
|
361:
362: static std :: string getCharAt ( const Token * tok@var464 , long long index@var465 ) ;
363:
364: const ValueType * valueType ( ) const {
365: return mImpl@var661 .@expr1073744800 mValueType@var693 ;
366: }
367: void setValueType ( ValueType * vt@var466 ) ;
368:
369: const ValueType * argumentType ( ) const {
370: const Token * top@var467 ; top@var467 =@expr1073744801 this@expr1073744802 ;
371: while (@expr1073744803 top@var467 &&@expr1073744804 !@expr1073744805 Token ::@expr1073744806 Match (@expr1073744807 top@var467 .@expr2984 astParent (@expr2985 ) , ",|(" ) ) {
372: top@var467 =@expr1073744810 top@var467 .@expr2984 astParent (@expr2985 ) ; }
373: return top@var467 ?@expr1073744813 top@var467 .@expr1073744814 mImpl@var468 .@expr1073744815 mValueType@var469 :@expr1073744816 nullptr ;
374: }
375:
376: Token :: Type tokType ( ) const {
377: return mTokType@var659 ;
378: }
379: void tokType ( Token :: Type t@var470 ) {
380: mTokType@var659 =@expr1073744817 t@var470 ;
381:
382: const bool memoizedIsName@var471 =@expr1073744818 mTokType@var659 ==@expr1073744819 eName ||@expr1073744820 mTokType@var659 ==@expr1073744821 eType ||@expr1073744822 mTokType@var659 ==@expr1073744823 eVariable ||@expr1073744824
383: mTokType@var659 ==@expr1073744825 eFunction ||@expr1073744826 mTokType@var659 ==@expr1073744827 eKeyword ||@expr1073744828 mTokType@var659 ==@expr3005 eBoolean ||@expr1073744830
384: mTokType@var659 ==@expr3007 eEnumerator ;
385: setFlag (@expr1073744832 fIsName , memoizedIsName@var471 ) ;
386:
387: const bool memoizedIsLiteral@var472 =@expr1073744833 mTokType@var659 ==@expr1073744834 eNumber ||@expr1073744835 mTokType@var659 ==@expr1073744836 eString ||@expr1073744837 mTokType@var659 ==@expr1073744838 eChar ||@expr1073744839
388: mTokType@var659 ==@expr3005 eBoolean ||@expr1073744841 mTokType@var659 ==@expr1073744842 eLiteral ||@expr1073744843 mTokType@var659 ==@expr3007 eEnumerator ;
389: setFlag (@expr1073744845 fIsLiteral , memoizedIsLiteral@var472 ) ;
390: }
391: bool isKeyword ( ) const {
392: return mTokType@var659 ==@expr1073744846 eKeyword ;
393: }
394: bool isName ( ) const {
395: return getFlag (@expr1073744847 fIsName ) ;
396: }
397: bool isNameOnly ( ) const {
398: return mFlags@var660 ==@expr1073744848 fIsName &&@expr1073744849 mTokType@var659 ==@expr1073744850 eName ;
399: }
400: bool isUpperCaseName ( ) const ;
401: bool isLiteral ( ) const {
402: return getFlag (@expr1073744851 fIsLiteral ) ;
403: }
404: bool isNumber ( ) const {
405: return mTokType@var659 ==@expr1073744852 eNumber ;
406: }
407: bool isEnumerator ( ) const {
408: return mTokType@var659 ==@expr1073744853 eEnumerator ;
409: }
410: bool isOp ( ) const {
411: return (@expr1073744854 isConstOp (@expr1073744855 ) ||@expr1073744856
412: isAssignmentOp (@expr1073744857 ) ||@expr1073744858
413: mTokType@var659 ==@expr1073744859 eIncDecOp ) ;
414: }
415: bool isConstOp ( ) const {
416: return (@expr1073744860 isArithmeticalOp (@expr1073744861 ) ||@expr1073744862
417: mTokType@var659 ==@expr1073744863 eLogicalOp ||@expr1073744864
418: mTokType@var659 ==@expr1073744865 eComparisonOp ||@expr1073744866
419: mTokType@var659 ==@expr1073744867 eBitOp ) ;
420: }
421: bool isExtendedOp ( ) const {
422: return isConstOp (@expr1073744868 ) ||@expr1073744869
423: mTokType@var659 ==@expr1073744870 eExtendedOp ;
424: }
425: bool isArithmeticalOp ( ) const {
426: return mTokType@var659 ==@expr1073744871 eArithmeticalOp ;
427: }
428: bool isComparisonOp ( ) const {
429: return mTokType@var659 ==@expr1073744872 eComparisonOp ;
430: }
431: bool isAssignmentOp ( ) const {
432: return mTokType@var659 ==@expr1073744873 eAssignmentOp ;
433: }
434: bool isBoolean ( ) const {
435: return mTokType@var659 ==@expr1073744874 eBoolean ;
436: }
437: bool isIncDecOp ( ) const {
438: return mTokType@var659 ==@expr1073744875 eIncDecOp ;
439: }
440: bool isBinaryOp ( ) const {
441: return astOperand1 (@expr1073744876 ) !=@expr1073744877 nullptr &&@expr1073744878 astOperand2 (@expr1073744879 ) !=@expr1073744880 nullptr ;
442: }
443: bool isUnaryOp ( const std :: string & s@var473 ) const {
444: return s@var473 ==@expr1073744881 mStr@var655 &&@expr1073744882 astOperand1 (@expr1073744883 ) !=@expr1073744884 nullptr &&@expr1073744885 astOperand2 (@expr1073744886 ) ==@expr1073744887 nullptr ;
445: }
446: bool isUnaryPreOp ( ) const ;
447:
448: unsigned int flags ( ) const {
449: return mFlags@var660 ;
450: }
451: void flags ( const unsigned int flags_@var474 ) {
452: mFlags@var660 =@expr1073744888 flags_@var474 ;
453: }
454: bool isUnsigned ( ) const {
455: return getFlag (@expr1073744889 fIsUnsigned ) ;
456: }
457: void isUnsigned ( const bool sign@var475 ) {
458: setFlag (@expr1073744890 fIsUnsigned , sign@var475 ) ;
459: }
460: bool isSigned ( ) const {
461: return getFlag (@expr1073744891 fIsSigned ) ;
462: }
463: void isSigned ( const bool sign@var476 ) {
464: setFlag (@expr1073744892 fIsSigned , sign@var476 ) ;
465: }
466: bool isPointerCompare ( ) const {
467: return getFlag (@expr1073744893 fIsPointerCompare ) ;
468: }
469: void isPointerCompare ( const bool b@var477 ) {
470: setFlag (@expr1073744894 fIsPointerCompare , b@var477 ) ;
471: }
472: bool isLong ( ) const {
473: return getFlag (@expr1073744895 fIsLong ) ;
474: }
475: void isLong ( bool size@var478 ) {
476: setFlag (@expr1073744896 fIsLong , size@var478 ) ;
477: }
478: bool isStandardType ( ) const {
479: return getFlag (@expr1073744897 fIsStandardType ) ;
480: }
481: void isStandardType ( const bool b@var479 ) {
482: setFlag (@expr1073744898 fIsStandardType , b@var479 ) ;
483: }
484: bool isExpandedMacro ( ) const {
485: return getFlag (@expr1073744899 fIsExpandedMacro ) ;
486: }
487: void isExpandedMacro ( const bool m@var480 ) {
488: setFlag (@expr1073744900 fIsExpandedMacro , m@var480 ) ;
489: }
490: bool isCast ( ) const {
491: return getFlag (@expr1073744901 fIsCast ) ;
492: }
493: void isCast ( bool c@var481 ) {
494: setFlag (@expr1073744902 fIsCast , c@var481 ) ;
495: }
496: bool isAttributeConstructor ( ) const {
497: return getFlag (@expr1073744903 fIsAttributeConstructor ) ;
498: }
499: void isAttributeConstructor ( const bool ac@var482 ) {
500: setFlag (@expr1073744904 fIsAttributeConstructor , ac@var482 ) ;
501: }
502: bool isAttributeDestructor ( ) const {
503: return getFlag (@expr1073744905 fIsAttributeDestructor ) ;
504: }
505: void isAttributeDestructor ( const bool value@var483 ) {
506: setFlag (@expr1073744906 fIsAttributeDestructor , value@var483 ) ;
507: }
508: bool isAttributeUnused ( ) const {
509: return getFlag (@expr1073744907 fIsAttributeUnused ) ;
510: }
511: void isAttributeUnused ( bool unused@var484 ) {
512: setFlag (@expr1073744908 fIsAttributeUnused , unused@var484 ) ;
513: }
514: bool isAttributeUsed ( ) const {
515: return getFlag (@expr1073744909 fIsAttributeUsed ) ;
516: }
517: void isAttributeUsed ( const bool unused@var485 ) {
518: setFlag (@expr1073744910 fIsAttributeUsed , unused@var485 ) ;
519: }
520: bool isAttributePure ( ) const {
521: return getFlag (@expr1073744911 fIsAttributePure ) ;
522: }
523: void isAttributePure ( const bool value@var486 ) {
524: setFlag (@expr1073744912 fIsAttributePure , value@var486 ) ;
525: }
526: bool isAttributeConst ( ) const {
527: return getFlag (@expr1073744913 fIsAttributeConst ) ;
528: }
529: void isAttributeConst ( bool value@var487 ) {
530: setFlag (@expr1073744914 fIsAttributeConst , value@var487 ) ;
531: }
532: bool isAttributeNoreturn ( ) const {
533: return getFlag (@expr1073744915 fIsAttributeNoreturn ) ;
534: }
535: void isAttributeNoreturn ( const bool value@var488 ) {
536: setFlag (@expr1073744916 fIsAttributeNoreturn , value@var488 ) ;
537: }
538: bool isAttributeNothrow ( ) const {
539: return getFlag (@expr1073744917 fIsAttributeNothrow ) ;
540: }
541: void isAttributeNothrow ( const bool value@var489 ) {
542: setFlag (@expr1073744918 fIsAttributeNothrow , value@var489 ) ;
543: }
544: bool isAttributePacked ( ) const {
545: return getFlag (@expr1073744919 fIsAttributePacked ) ;
546: }
547: void isAttributePacked ( const bool value@var490 ) {
548: setFlag (@expr1073744920 fIsAttributePacked , value@var490 ) ;
549: }
550: bool isAttributeNodiscard ( ) const {
551: return getFlag (@expr1073744921 fIsAttributeNodiscard ) ;
552: }
553: void isAttributeNodiscard ( const bool value@var491 ) {
554: setFlag (@expr1073744922 fIsAttributeNodiscard , value@var491 ) ;
555: }
556: bool isAttributeMaybeUnused ( ) const {
557: return getFlag (@expr1073744923 fIsAttributeMaybeUnused ) ;
558: }
559: void isAttributeMaybeUnused ( const bool value@var492 ) {
560: setFlag (@expr1073744924 fIsAttributeMaybeUnused , value@var492 ) ;
561: }
562: void setCppcheckAttribute ( TokenImpl :: CppcheckAttributes :: Type type@var493 , long long value@var494 ) {
563: mImpl@var661 .@expr1073744925 setCppcheckAttribute (@expr1073744926 type@var493 , value@var494 ) ;
564: }
565: bool getCppcheckAttribute ( TokenImpl :: CppcheckAttributes :: Type type@var495 , long long * value@var496 ) const {
566: return mImpl@var661 .@expr1073744927 getCppcheckAttribute (@expr1073744928 type@var495 , value@var496 ) ;
567: }
568: bool hasCppcheckAttributes ( ) const {
569: return nullptr !=@expr1073744929 mImpl@var661 .@expr1073744930 mCppcheckAttributes@var694 ;
570: }
571: bool isControlFlowKeyword ( ) const {
572: return getFlag (@expr1073744931 fIsControlFlowKeyword ) ;
573: }
574: bool isOperatorKeyword ( ) const {
575: return getFlag (@expr1073744932 fIsOperatorKeyword ) ;
576: }
577: void isOperatorKeyword ( const bool value@var497 ) {
578: setFlag (@expr1073744933 fIsOperatorKeyword , value@var497 ) ;
579: }
580: bool isComplex ( ) const {
581: return getFlag (@expr1073744934 fIsComplex ) ;
582: }
583: void isComplex ( const bool value@var498 ) {
584: setFlag (@expr1073744935 fIsComplex , value@var498 ) ;
585: }
586: bool isEnumType ( ) const {
587: return getFlag (@expr1073744936 fIsEnumType ) ;
588: }
589: void isEnumType ( const bool value@var499 ) {
590: setFlag (@expr1073744937 fIsEnumType , value@var499 ) ;
591: }
592: bool isAtAddress ( ) const {
593: return getFlag (@expr1073744938 fAtAddress ) ;
594: }
595: void isAtAddress ( bool b@var500 ) {
596: setFlag (@expr1073744939 fAtAddress , b@var500 ) ;
597: }
598: bool isIncompleteVar ( ) const {
599: return getFlag (@expr1073744940 fIncompleteVar ) ;
600: }
601: void isIncompleteVar ( bool b@var501 ) {
602: setFlag (@expr1073744941 fIncompleteVar , b@var501 ) ;
603: }
604:
605: bool isIncompleteConstant ( ) const {
606: return getFlag (@expr1073744942 fIsIncompleteConstant ) ;
607: }
608: void isIncompleteConstant ( bool b@var502 ) {
609: setFlag (@expr1073744943 fIsIncompleteConstant , b@var502 ) ;
610: }
611:
612: bool isConstexpr ( ) const {
613: return getFlag (@expr1073744944 fConstexpr ) ;
614: }
615: void isConstexpr ( bool b@var503 ) {
616: setFlag (@expr1073744945 fConstexpr , b@var503 ) ;
617: }
618:
619: bool isExternC ( ) const {
620: return getFlag (@expr1073744946 fExternC ) ;
621: }
622: void isExternC ( bool b@var504 ) {
623: setFlag (@expr1073744947 fExternC , b@var504 ) ;
624: }
625:
626: bool isSplittedVarDeclComma ( ) const {
627: return getFlag (@expr1073744948 fIsSplitVarDeclComma ) ;
628: }
629: void isSplittedVarDeclComma ( bool b@var505 ) {
630: setFlag (@expr1073744949 fIsSplitVarDeclComma , b@var505 ) ;
631: }
632:
633: bool isSplittedVarDeclEq ( ) const {
634: return getFlag (@expr1073744950 fIsSplitVarDeclEq ) ;
635: }
636: void isSplittedVarDeclEq ( bool b@var506 ) {
637: setFlag (@expr1073744951 fIsSplitVarDeclEq , b@var506 ) ;
638: }
639:
640: bool isImplicitInt ( ) const {
641: return getFlag (@expr1073744952 fIsImplicitInt ) ;
642: }
643: void isImplicitInt ( bool b@var507 ) {
644: setFlag (@expr1073744953 fIsImplicitInt , b@var507 ) ;
645: }
646:
647: bool isInline ( ) const {
648: return getFlag (@expr1073744954 fIsInline ) ;
649: }
650: void isInline ( bool b@var508 ) {
651: setFlag (@expr1073744955 fIsInline , b@var508 ) ;
652: }
653:
654: bool isRemovedVoidParameter ( ) const {
655: return getFlag (@expr1073744956 fIsRemovedVoidParameter ) ;
656: }
657: void setRemovedVoidParameter ( bool b@var509 ) {
658: setFlag (@expr1073744957 fIsRemovedVoidParameter , b@var509 ) ;
659: }
660:
661: bool isTemplate ( ) const {
662: return getFlag (@expr1073744958 fIsTemplate ) ;
663: }
664: void isTemplate ( bool b@var510 ) {
665: setFlag (@expr1073744959 fIsTemplate , b@var510 ) ;
666: }
667:
668: bool isSimplifiedScope ( ) const {
669: return getFlag (@expr1073744960 fIsSimplifedScope ) ;
670: }
671: void isSimplifiedScope ( bool b@var511 ) {
672: setFlag (@expr1073744961 fIsSimplifedScope , b@var511 ) ;
673: }
674:
675: bool isBitfield ( ) const {
676: return mImpl@var661 .@expr1073744962 mBits@var695 >@expr1073744963 0 ;
677: }
678: unsigned char bits ( ) const {
679: return mImpl@var661 .@expr1073744964 mBits@var695 ;
680: }
681: std :: set < TemplateSimplifier :: TokenAndName * > * templateSimplifierPointers ( ) const {
682: return mImpl@var661 .@expr1073744965 mTemplateSimplifierPointers@var696 ;
683: }
684: void templateSimplifierPointer ( TemplateSimplifier :: TokenAndName * tokenAndName@var512 ) {
685: if (@expr1073744966 !@expr1073744967 mImpl@var661 .@expr3144 mTemplateSimplifierPointers@var696 ) {
686: mImpl@var661 .@expr3144 mTemplateSimplifierPointers@var696 =@expr1073744970 new std ::@expr1073744971 set < TemplateSimplifier ::@expr1073744972 TokenAndName *@expr1073744973 > ; }
687: mImpl@var661 .@expr3144 mTemplateSimplifierPointers@var696 .@expr1073744975 insert (@expr1073744976 tokenAndName@var512 ) ;
688: }
689: void setBits ( const unsigned char b@var513 ) {
690: mImpl@var661 .@expr1073744977 mBits@var695 =@expr1073744978 b@var513 ;
691: }
692:
693: bool isUtf8 ( ) const {
694: return (@expr3155 (@expr3155 (@expr3155 mTokType@var659 ==@expr1073744982 eString ) &&@expr1073744983 isPrefixStringCharLiteral (@expr1073744984 mStr@var655 , '"' , "u8" ) ) ||@expr1073744985
695: (@expr3155 (@expr3155 mTokType@var659 ==@expr1073744988 eChar ) &&@expr1073744989 isPrefixStringCharLiteral (@expr1073744990 mStr@var655 , '\'' , "u8" ) ) ) ;
696: }
697:
698: bool isUtf16 ( ) const {
699: return (@expr3167 (@expr3167 (@expr3167 mTokType@var659 ==@expr1073744994 eString ) &&@expr1073744995 isPrefixStringCharLiteral (@expr1073744996 mStr@var655 , '"' , "u" ) ) ||@expr1073744997
700: (@expr3167 (@expr3167 mTokType@var659 ==@expr1073745000 eChar ) &&@expr1073745001 isPrefixStringCharLiteral (@expr1073745002 mStr@var655 , '\'' , "u" ) ) ) ;
701: }
702:
703: bool isUtf32 ( ) const {
704: return (@expr3179 (@expr3179 (@expr3179 mTokType@var659 ==@expr1073745006 eString ) &&@expr1073745007 isPrefixStringCharLiteral (@expr1073745008 mStr@var655 , '"' , "U" ) ) ||@expr1073745009
705: (@expr3179 (@expr3179 mTokType@var659 ==@expr1073745012 eChar ) &&@expr1073745013 isPrefixStringCharLiteral (@expr1073745014 mStr@var655 , '\'' , "U" ) ) ) ;
706: }
707:
708: bool isCChar ( ) const {
709: return (@expr3191 (@expr3191 (@expr3191 mTokType@var659 ==@expr1073745018 eString ) &&@expr1073745019 isPrefixStringCharLiteral (@expr1073745020 mStr@var655 , '"' , "" ) ) ||@expr1073745021
710: (@expr3191 (@expr3191 mTokType@var659 ==@expr1073745024 eChar ) &&@expr1073745025 isPrefixStringCharLiteral (@expr1073745026 mStr@var655 , '\'' , "" ) &&@expr1073745027 mStr@var655 .@expr1073745028 length (@expr1073745029 ) ==@expr1073745030 3 ) ) ;
711: }
712:
713: bool isCMultiChar ( ) const {
714: return (@expr3207 (@expr3207 (@expr3207 mTokType@var659 ==@expr1073745034 eChar ) &&@expr1073745035 isPrefixStringCharLiteral (@expr1073745036 mStr@var655 , '\'' , "" ) ) &&@expr1073745037
715: (@expr3207 mStr@var655 .@expr1073745039 length (@expr1073745040 ) >@expr1073745041 3 ) ) ;
716: }
717:
|
733:
734: bool isTemplateArg ( ) const {
735: return getFlag (@expr1073745042 fIsTemplateArg ) ;
736: }
737: void isTemplateArg ( const bool value@var514 ) {
738: setFlag (@expr1073745043 fIsTemplateArg , value@var514 ) ;
739: }
740:
741: template < unsigned long count >
742: static const Token * findsimplematch ( const Token * const startTok@var515 , const char ( & pattern@var516 ) [ count ] ) {
743: return findsimplematch (@expr1073745045 startTok@var515 , pattern@var516 , count@expr1073745044 -@expr1073745046 1 ) ;
744: }
745: static const Token * findsimplematch ( const Token * const startTok@var517 , const char pattern@var518 [ ] , unsigned long pattern_len@var519 ) ;
746:
747: template < unsigned long count >
748: static const Token * findsimplematch ( const Token * const startTok@var520 , const char ( & pattern@var521 ) [ count ] , const Token * const end@var522 ) {
749: return findsimplematch (@expr1073745048 startTok@var520 , pattern@var521 , count@expr1073745047 -@expr1073745049 1 , end@var522 ) ;
750: }
751: static const Token * findsimplematch ( const Token * const startTok@var523 , const char pattern@var524 [ ] , unsigned long pattern_len@var525 , const Token * const end@var526 ) ;
752:
753: static const Token * findmatch ( const Token * const startTok@var527 , const char pattern@var528 [ ] , const int varId@var529 = 0 ) ;
754: static const Token * findmatch ( const Token * const startTok@var530 , const char pattern@var531 [ ] , const Token * const end@var532 , const int varId@var533 = 0 ) ;
755:
756: template < unsigned long count >
757: static Token * findsimplematch ( Token * const startTok@var534 , const char ( & pattern@var535 ) [ count ] ) {
758: return findsimplematch (@expr1073745051 startTok@var534 , pattern@var535 , count@expr1073745050 -@expr1073745052 1 ) ;
759: }
760: static Token * findsimplematch ( Token * const startTok@var536 , const char pattern@var537 [ ] , unsigned long pattern_len@var538 ) {
761: return const_cast < Token *@expr3229 > (@expr1073745054 findsimplematch (@expr1073745055 const_cast < const Token *@expr3229 > (@expr1073745057 startTok@var536 ) , pattern@var537 , pattern_len@var538 ) ) ;
762: }
763: template < unsigned long count >
764: static Token * findsimplematch ( Token * const startTok@var539 , const char ( & pattern@var540 ) [ count ] , const Token * const end@var541 ) {
765: return findsimplematch (@expr1073745059 startTok@var539 , pattern@var540 , count@expr1073745058 -@expr1073745060 1 , end@var541 ) ;
766: }
767: static Token * findsimplematch ( Token * const startTok@var542 , const char pattern@var543 [ ] , unsigned long pattern_len@var544 , const Token * const end@var545 ) {
768: return const_cast < Token *@expr3237 > (@expr1073745062 findsimplematch (@expr1073745063 const_cast < const Token *@expr3237 > (@expr1073745065 startTok@var542 ) , pattern@var543 , pattern_len@var544 , end@var545 ) ) ;
769: }
770:
771: static Token * findmatch ( Token * const startTok@var546 , const char pattern@var547 [ ] , const int varId@var548 = 0 ) {
772: return const_cast < Token *@expr3242 > (@expr1073745067 findmatch (@expr1073745068 const_cast < const Token *@expr3242 > (@expr1073745070 startTok@var546 ) , pattern@var547 , varId@var548 ) ) ;
773: }
774: static Token * findmatch ( Token * const startTok@var549 , const char pattern@var550 [ ] , const Token * const end@var551 , const int varId@var552 = 0 ) {
775: return const_cast < Token *@expr3247 > (@expr1073745072 findmatch (@expr1073745073 const_cast < const Token *@expr3247 > (@expr1073745075 startTok@var549 ) , pattern@var550 , end@var551 , varId@var552 ) ) ;
776: }
777:
|
791:
792: static int multiCompare ( const Token * tok@var553 , const char * haystack@var554 , int varid@var555 ) ;
793:
794: int fileIndex ( ) const {
795: return mImpl@var661 .@expr1073745076 mFileIndex@var697 ;
796: }
797: void fileIndex ( int indexOfFile@var556 ) {
798: mImpl@var661 .@expr1073745077 mFileIndex@var697 =@expr1073745078 indexOfFile@var556 ;
799: }
800:
801: int linenr ( ) const {
802: return mImpl@var661 .@expr1073745079 mLineNumber@var698 ;
803: }
804: void linenr ( int lineNumber@var557 ) {
805: mImpl@var661 .@expr1073745080 mLineNumber@var698 =@expr1073745081 lineNumber@var557 ;
806: }
807:
808: int column ( ) const {
809: return mImpl@var661 .@expr1073745082 mColumn@var699 ;
810: }
811: void column ( int c@var558 ) {
812: mImpl@var661 .@expr1073745083 mColumn@var699 =@expr1073745084 c@var558 ;
813: }
814:
815: Token * next ( ) const {
816: return mNext@var656 ;
817: }
818:
|
826:
827: static void eraseTokens ( Token * begin@var559 , const Token * end@var560 ) ;
828:
|
836:
837: Token * insertToken ( const std :: string & tokenStr@var561 , const std :: string & originalNameStr@var562 = emptyString@var1 , bool prepend@var563 = false ) ;
838:
839: Token * insertTokenBefore ( const std :: string & tokenStr@var564 , const std :: string & originalNameStr@var565 = emptyString@var1 )
840: {
841: return insertToken (@expr1073745085 tokenStr@var564 , originalNameStr@var565 , true ) ;
842: }
843:
844: Token * previous ( ) const {
845: return mPrevious@var657 ;
846: }
847:
848:
849: int varId ( ) const {
850: return mImpl@var661 .@expr1073745086 mVarId@var692 ;
851: }
852: void varId ( int id@var566 ) {
853: mImpl@var661 .@expr1073745087 mVarId@var692 =@expr1073745088 id@var566 ;
854: if (@expr1073745089 id@var566 !=@expr1073745090 0 ) {
855: tokType (@expr1073745091 eVariable ) ;
856: isStandardType (@expr1073745092 false ) ;
857: } else {
858: update_property_info (@expr1073745093 ) ;
859: }
860: }
861:
862: int exprId ( ) const {
863: if (@expr1073745094 mImpl@var661 .@expr3271 mExprId@var700 ) {
864: return mImpl@var661 .@expr3271 mExprId@var700 ; }
865: return mImpl@var661 .@expr1073745097 mVarId@var692 ;
866: }
867: void exprId ( int id@var567 ) {
868: mImpl@var661 .@expr1073745098 mExprId@var700 =@expr1073745099 id@var567 ;
869: }
870:
|
876:
877: void printOut ( const char * title@var568 = nullptr ) const ;
878:
|
886:
887: void printOut ( const char * title@var569 , const std :: vector < std :: string > & fileNames@var570 ) const ;
888:
|
891:
892: void printLines ( int lines@var571 = 5 ) const ;
893:
|
900:
901: static void replace ( Token * replaceThis@var572 , Token * start@var573 , Token * end@var574 ) ;
902:
903: struct stringifyOptions {
904: bool varid@var575 ; varid@var575 = false ;
905: bool exprid@var576 ; exprid@var576 = false ;
906: bool idtype@var577 ; idtype@var577 = false ;
907: bool attributes@var578 ; attributes@var578 = false ;
908: bool macro@var579 ; macro@var579 = false ;
909: bool linenumbers@var580 ; linenumbers@var580 = false ;
910: bool linebreaks@var581 ; linebreaks@var581 = false ;
911: bool files@var582 ; files@var582 = false ;
912: static stringifyOptions forDebug ( ) {
913: stringifyOptions options@var583 ;
914: options@var583 .@expr1073745100 attributes@var584 =@expr1073745101 true ;
915: options@var583 .@expr1073745102 macro@var585 =@expr1073745103 true ;
916: options@var583 .@expr1073745104 linenumbers@var586 =@expr1073745105 true ;
917: options@var583 .@expr1073745106 linebreaks@var587 =@expr1073745107 true ;
918: options@var583 .@expr1073745108 files@var588 =@expr1073745109 true ;
919: return options@var583 ;
920: }
921: static stringifyOptions forDebugVarId ( ) {
922: stringifyOptions options@var589 ; options@var589 =@expr1073745110 forDebug (@expr1073745111 ) ;
923: options@var589 .@expr1073745112 varid@var590 =@expr1073745113 true ;
924: return options@var589 ;
925: }
926: static stringifyOptions forDebugExprId ( ) {
927: stringifyOptions options@var591 ; options@var591 =@expr1073745114 forDebug (@expr1073745115 ) ;
928: options@var591 .@expr1073745116 exprid@var592 =@expr1073745117 true ;
929: return options@var591 ;
930: }
931: static stringifyOptions forPrintOut ( ) {
932: stringifyOptions options@var593 ; options@var593 =@expr1073745118 forDebug (@expr1073745119 ) ;
933: options@var593 .@expr1073745120 exprid@var594 =@expr1073745121 true ;
934: options@var593 .@expr1073745122 varid@var595 =@expr1073745123 true ;
935: options@var593 .@expr1073745124 idtype@var596 =@expr1073745125 true ;
936: return options@var593 ;
937: }
938: } ;
939:
940: std :: string stringify ( const stringifyOptions & options@var597 ) const ;
941:
|
947:
948: std :: string stringify ( bool varid@var598 , bool attributes@var599 , bool macro@var600 ) const ;
949:
950: std :: string stringifyList ( const stringifyOptions & options@var601 , const std :: vector < std :: string > * fileNames@var602 = nullptr , const Token * end@var603 = nullptr ) const ;
951: std :: string stringifyList ( const Token * end@var604 , bool attributes@var605 = true ) const ;
952: std :: string stringifyList ( bool varid@var606 = false ) const ;
953:
|
964:
965: std :: string stringifyList ( bool varid@var607 , bool attributes@var608 , bool linenumbers@var609 , bool linebreaks@var610 , bool files@var611 , const std :: vector < std :: string > * fileNames@var612 = nullptr , const Token * end@var613 = nullptr ) const ;
966:
|
974:
975: void deleteThis ( ) ;
976:
|
981:
982: void link ( Token * linkToToken@var614 ) {
983: mLink@var658 =@expr1073745126 linkToToken@var614 ;
984: if (@expr1073745127 mStr@var655 ==@expr1073745128 "<" ||@expr1073745129 mStr@var655 ==@expr1073745130 ">" ) {
985: update_property_info (@expr1073745131 ) ; }
986: }
987:
|
996:
997: Token * link ( ) const {
998: return mLink@var658 ;
999: }
1000:
|
1004:
1005: void scope ( const Scope * s@var615 ) {
1006: mImpl@var661 .@expr1073745132 mScope@var701 =@expr1073745133 s@var615 ;
1007: }
1008:
|
1011:
1012: const Scope * scope ( ) const {
1013: return mImpl@var661 .@expr1073745134 mScope@var701 ;
1014: }
1015:
|
1019:
1020: void function ( const Function * f@var616 ) ;
1021:
|
1024:
1025: const Function * function ( ) const {
1026: return mTokType@var659 ==@expr1073745135 eFunction ||@expr1073745136 mTokType@var659 ==@expr1073745137 eLambda ?@expr1073745138 mImpl@var661 .@expr1073745139 mFunction@var702 :@expr1073745140 nullptr ;
1027: }
1028:
|
1032:
1033: void variable ( const Variable * v@var617 ) {
1034: mImpl@var661 .@expr1073745141 mVariable@var703 =@expr1073745142 v@var617 ;
1035: if (@expr1073745143 v@var617 ||@expr1073745144 mImpl@var661 .@expr1073745145 mVarId@var692 ) {
1036: tokType (@expr1073745146 eVariable ) ; }
1037: else { if (@expr1073745147 mTokType@var659 ==@expr1073745148 eVariable ) {
1038: tokType (@expr1073745149 eName ) ; } }
1039: }
1040:
|
1043:
1044: const Variable * variable ( ) const {
1045: return mTokType@var659 ==@expr1073745150 eVariable ?@expr1073745151 mImpl@var661 .@expr1073745152 mVariable@var703 :@expr1073745153 nullptr ;
1046: }
1047:
|
1051:
1052: void type ( const :: Type * t@var618 ) ;
1053:
|
1056:
1057: const :: Type * type ( ) const {
1058: return mTokType@var659 ==@expr1073745154 eType ?@expr1073745155 mImpl@var661 .@expr1073745156 mType@var704 :@expr1073745157 nullptr ;
1059: }
1060:
1061: static const :: Type * typeOf ( const Token * tok@var619 , const Token * * typeTok@var620 = nullptr ) ;
1062:
1063: static std :: pair < const Token * , const Token * > typeDecl ( const Token * tok@var621 ) ;
1064:
1065: static std :: string typeStr ( const Token * tok@var622 ) ;
1066:
|
1069:
1070: const Enumerator * enumerator ( ) const {
1071: return mTokType@var659 ==@expr1073745158 eEnumerator ?@expr1073745159 mImpl@var661 .@expr1073745160 mEnumerator@var705 :@expr1073745161 nullptr ;
1072: }
1073:
|
1077:
1078: void enumerator ( const Enumerator * e@var623 ) {
1079: mImpl@var661 .@expr1073745162 mEnumerator@var705 =@expr1073745163 e@var623 ;
1080: if (@expr1073745164 e@var623 ) {
1081: tokType (@expr1073745165 eEnumerator ) ; }
1082: else { if (@expr1073745166 mTokType@var659 ==@expr1073745167 eEnumerator ) {
1083: tokType (@expr1073745168 eName ) ; } }
1084: }
1085:
|
1088:
1089: static void createMutualLinks ( Token * begin@var624 , Token * end@var625 ) ;
1090:
|
1096:
1097: std :: string strValue ( ) const ;
1098:
|
1105:
1106: static void move ( Token * srcStart@var626 , Token * srcEnd@var627 , Token * newLocation@var628 ) ;
1107:
1108:
1109: int progressValue ( ) const {
1110: return mImpl@var661 .@expr1073745169 mProgressValue@var706 ;
1111: }
1112:
1113:
1114: static void assignProgressValues ( Token * tok@var629 ) ;
1115:
|
1120:
1121: Token * nextArgument ( ) const ;
1122:
|
1127:
1128: Token * nextArgumentBeforeCreateLinks2 ( ) const ;
1129:
|
1134:
1135: Token * nextTemplateArgument ( ) const ;
1136:
|
1141:
1142: const Token * findClosingBracket ( ) const ;
1143: Token * findClosingBracket ( ) ;
1144:
1145: const Token * findOpeningBracket ( ) const ;
1146: Token * findOpeningBracket ( ) ;
1147:
|
1150:
1151: const std :: string & originalName ( ) const {
1152: return mImpl@var661 .@expr3346 mOriginalName@var707 ?@expr1073745171 *@expr1073745172 mImpl@var661 .@expr3346 mOriginalName@var707 :@expr1073745174 emptyString@var1 ;
1153: }
1154:
1155: const std :: list < ValueFlow :: Value > & values ( ) const {
1156: return mImpl@var661 .@expr3351 mValues@var680 ?@expr1073745176 *@expr1073745177 mImpl@var661 .@expr3351 mValues@var680 :@expr1073745179 TokenImpl ::@expr1073745180 mEmptyValueList@var427 ;
1157: }
1158:
|
1161:
1162: template < typename T >
1163: void originalName ( T && name@var630 ) {
1164: if (@expr1073745181 !@expr1073745182 mImpl@var661 .@expr3359 mOriginalName@var707 ) {
1165: mImpl@var661 .@expr3359 mOriginalName@var707 =@expr1073745185 new std ::@expr1073745186 string (@expr1073745187 name@var630 ) ; }
1166: else {
1167: *@expr1073745188 mImpl@var661 .@expr3359 mOriginalName@var707 =@expr1073745190 name@var630 ; }
1168: }
1169:
1170: bool hasKnownIntValue ( ) const ;
1171: bool hasKnownValue ( ) const ;
1172: bool hasKnownValue ( ValueFlow :: Value :: ValueType t@var631 ) const ;
1173: bool hasKnownSymbolicValue ( const Token * tok@var632 ) const ;
1174:
1175: const ValueFlow :: Value * getKnownValue ( ValueFlow :: Value :: ValueType t@var633 ) const ;
1176: long long getKnownIntValue ( ) const {
1177: return mImpl@var661 .@expr1073745192 mValues@var680 .@expr1073745193 front (@expr1073745194 ) .@expr1073745195 intvalue@expr1073745191 ;
1178: }
1179:
1180: const ValueFlow :: Value * getValue ( const long long val@var634 ) const ;
1181:
1182: const ValueFlow :: Value * getMaxValue ( bool condition@var635 , long long path@var636 = 0 ) const ;
1183:
1184: const ValueFlow :: Value * getMovedValue ( ) const ;
1185:
1186: const ValueFlow :: Value * getValueLE ( const long long val@var637 , const Settings * settings@var638 ) const ;
1187: const ValueFlow :: Value * getValueGE ( const long long val@var639 , const Settings * settings@var640 ) const ;
1188:
1189: const ValueFlow :: Value * getInvalidValue ( const Token * ftok@var641 , int argnr@var642 , const Settings * settings@var643 ) const ;
1190:
1191: const ValueFlow :: Value * getContainerSizeValue ( const long long val@var644 ) const ;
1192:
1193: const Token * getValueTokenMaxStrLength ( ) const ;
1194: const Token * getValueTokenMinStrSize ( const Settings * settings@var645 ) const ;
1195:
1196:
1197: bool addValue ( const ValueFlow :: Value & value@var646 ) ;
1198:
1199: void removeValues ( std :: function < bool ( const ValueFlow :: Value & ) > pred@var647 ) {
1200: if (@expr1073745196 mImpl@var661 .@expr3373 mValues@var680 ) {
1201: mImpl@var661 .@expr3373 mValues@var680 .@expr1073745199 remove_if (@expr1073745200 pred@var647 ) ; }
1202: }
1203:
1204: int index ( ) const {
1205: return mImpl@var661 .@expr1073745201 mIndex@var708 ;
1206: }
1207:
1208: void assignIndexes ( ) ;
1209:
1210: private:
1211:
1212: void next ( Token * nextToken@var648 ) {
1213: mNext@var656 =@expr1073745202 nextToken@var648 ;
1214: }
1215: void previous ( Token * previousToken@var649 ) {
1216: mPrevious@var657 =@expr1073745203 previousToken@var649 ;
1217: }
1218:
1219:
1220: void takeData ( Token * fromToken@var650 ) ;
1221:
|
1226:
1227: static bool firstWordEquals ( const char * str@var651 , const char * word@var652 ) ;
1228:
|
1233:
1234: static const char * chrInFirstWord ( const char * str@var653 , char c@var654 ) ;
1235:
1236: std :: string mStr@var655 ;
1237:
1238: Token * mNext@var656 ;
1239: Token * mPrevious@var657 ;
1240: Token * mLink@var658 ;
1241:
1242: enum Anonymous1 : uint64_t {
1243: fIsUnsigned = ( 1 << 0 ) ,
1244: fIsSigned = ( 1 << 1 ) ,
1245: fIsPointerCompare = ( 1 << 2 ) ,
1246: fIsLong = ( 1 << 3 ) ,
1247: fIsStandardType = ( 1 << 4 ) ,
1248: fIsExpandedMacro = ( 1 << 5 ) ,
1249: fIsCast = ( 1 << 6 ) ,
1250: fIsAttributeConstructor = ( 1 << 7 ) ,
1251: fIsAttributeDestructor = ( 1 << 8 ) ,
1252: fIsAttributeUnused = ( 1 << 9 ) ,
1253: fIsAttributePure = ( 1 << 10 ) ,
1254: fIsAttributeConst = ( 1 << 11 ) ,
1255: fIsAttributeNoreturn = ( 1 << 12 ) ,
1256: fIsAttributeNothrow = ( 1 << 13 ) ,
1257: fIsAttributeUsed = ( 1 << 14 ) ,
1258: fIsAttributePacked = ( 1 << 15 ) ,
1259: fIsAttributeMaybeUnused = ( 1 << 16 ) ,
1260: fIsControlFlowKeyword = ( 1 << 17 ) ,
1261: fIsOperatorKeyword = ( 1 << 18 ) ,
1262: fIsComplex = ( 1 << 19 ) ,
1263: fIsEnumType = ( 1 << 20 ) ,
1264: fIsName = ( 1 << 21 ) ,
1265: fIsLiteral = ( 1 << 22 ) ,
1266: fIsTemplateArg = ( 1 << 23 ) ,
1267: fIsAttributeNodiscard = ( 1 << 24 ) ,
1268: fAtAddress = ( 1 << 25 ) ,
1269: fIncompleteVar = ( 1 << 26 ) ,
1270: fConstexpr = ( 1 << 27 ) ,
1271: fExternC = ( 1 << 28 ) ,
1272: fIsSplitVarDeclComma = ( 1 << 29 ) ,
1273: fIsSplitVarDeclEq = ( 1 << 30 ) ,
1274: fIsImplicitInt = ( 1U << 31 ) ,
1275: fIsInline = ( 1ULL << 32 ) ,
1276: fIsTemplate = ( 1ULL << 33 ) ,
1277: fIsSimplifedScope = ( 1ULL << 34 ) ,
1278: fIsRemovedVoidParameter = ( 1ULL << 35 ) ,
1279: fIsIncompleteConstant = ( 1ULL << 36 ) ,
1280: } ;
1281:
1282: Token :: Type mTokType@var659 ;
1283:
1284: uint64_t mFlags@var660 ;
1285:
1286: TokenImpl * mImpl@var661 ;
1287:
|
1292:
1293: bool getFlag ( uint64_t flag_@var662 ) const {
1294: return (@expr3380 (@expr3380 mFlags@var660 &@expr1073745206 flag_@var662 ) !=@expr1073745207 0 ) ;
1295: }
1296:
|
1301:
1302: void setFlag ( uint64_t flag_@var663 , bool state_@var664 ) {
1303: mFlags@var660 =@expr1073745208 state_@var664 ?@expr1073745209 mFlags@var660 |@expr1073745210 flag_@var663 :@expr1073745211 mFlags@var660 &@expr1073745212 ~@expr1073745213 flag_@var663 ;
1304: }
1305:
1306:
1307:
1308: void update_property_info ( ) ;
1309:
1310:
1311: void update_property_isStandardType ( ) ;
1312:
1313:
1314: void update_property_char_string_literal ( ) ;
1315:
1316:
1317: void astStringVerboseRecursive ( std :: string & ret@var665 , const int indent1@var666 = 0 , const int indent2@var667 = 0 ) const ;
1318:
1319: public:
1320: void astOperand1 ( Token * tok@var668 ) ;
1321: void astOperand2 ( Token * tok@var669 ) ;
1322: void astParent ( Token * tok@var670 ) ;
1323:
1324: Token * astOperand1 ( ) {
1325: return mImpl@var661 .@expr1073745214 mAstOperand1@var671 ;
1326: }
1327: const Token * astOperand1 ( ) const {
1328: return mImpl@var661 .@expr1073745215 mAstOperand1@var671 ;
1329: }
1330: Token * astOperand2 ( ) {
1331: return mImpl@var661 .@expr1073745216 mAstOperand2@var672 ;
1332: }
1333: const Token * astOperand2 ( ) const {
1334: return mImpl@var661 .@expr1073745217 mAstOperand2@var672 ;
1335: }
1336: Token * astParent ( ) {
1337: return mImpl@var661 .@expr1073745218 mAstParent@var673 ;
1338: }
1339: const Token * astParent ( ) const {
1340: return mImpl@var661 .@expr1073745219 mAstParent@var673 ;
1341: }
1342: Token * astSibling ( ) {
1343: if (@expr1073745220 !@expr1073745221 astParent (@expr3398 ) ) {
1344: return nullptr ; }
1345: if (@expr1073745223 this@expr3400 ==@expr1073745225 astParent (@expr3398 ) .@expr3403 astOperand1 (@expr3404 ) ) {
1346: return astParent (@expr3398 ) .@expr3406 astOperand2 (@expr3407 ) ; }
1347: else { if (@expr1073745232 this@expr3400 ==@expr1073745233 astParent (@expr3398 ) .@expr3406 astOperand2 (@expr3407 ) ) {
1348: return astParent (@expr3398 ) .@expr3403 astOperand1 (@expr3404 ) ; } }
1349: return nullptr ;
1350:
1351: }
1352: const Token * astSibling ( ) const {
1353: if (@expr1073745240 !@expr1073745241 astParent (@expr3418 ) ) {
1354: return nullptr ; }
1355: if (@expr1073745243 this@expr3420 ==@expr1073745245 astParent (@expr3418 ) .@expr3423 astOperand1 (@expr3424 ) ) {
1356: return astParent (@expr3418 ) .@expr3426 astOperand2 (@expr3427 ) ; }
1357: else { if (@expr1073745252 this@expr3420 ==@expr1073745253 astParent (@expr3418 ) .@expr3426 astOperand2 (@expr3427 ) ) {
1358: return astParent (@expr3418 ) .@expr3423 astOperand1 (@expr3424 ) ; } }
1359: return nullptr ;
1360:
1361: }
1362: Token * astTop ( ) {
1363: Token * ret@var674 ; ret@var674 =@expr1073745260 this@expr1073745261 ;
1364: while (@expr1073745262 ret@var674 .@expr3439 mImpl@var675 .@expr3440 mAstParent@var676 ) {
1365: ret@var674 =@expr1073745265 ret@var674 .@expr3439 mImpl@var675 .@expr3440 mAstParent@var676 ; }
1366: return ret@var674 ;
1367: }
1368:
1369: const Token * astTop ( ) const {
1370: const Token * ret@var677 ; ret@var677 =@expr1073745268 this@expr1073745269 ;
1371: while (@expr1073745270 ret@var677 .@expr3447 mImpl@var678 .@expr3448 mAstParent@var679 ) {
1372: ret@var677 =@expr1073745273 ret@var677 .@expr3447 mImpl@var678 .@expr3448 mAstParent@var679 ; }
1373: return ret@var677 ;
1374: }
1375:
1376: std :: pair < const Token * , const Token * > findExpressionStartEndTokens ( ) const ;
1377:
|
1384:
1385: bool isCalculation ( ) const ;
1386:
1387: void clearAst ( ) {
1388: mImpl@var661 .@expr1073745276 mAstOperand1@var671 =@expr1073745277 mImpl@var661 .@expr1073745278 mAstOperand2@var672 =@expr1073745279 mImpl@var661 .@expr1073745280 mAstParent@var673 =@expr1073745281 nullptr ;
1389: }
1390:
1391: void clearValueFlow ( ) {
1392: delete mImpl@var661 .@expr3458 mValues@var680 ;
1393: mImpl@var661 .@expr3458 mValues@var680 =@expr1073745284 nullptr ;
1394: }
1395:
1396: std :: string astString ( const char * sep@var681 = "" ) const {
1397: std ::@expr1073745285 string ret@var682 ;
1398: if (@expr1073745286 mImpl@var661 .@expr3463 mAstOperand1@var671 ) {
1399: ret@var682 =@expr1073745288 mImpl@var661 .@expr3463 mAstOperand1@var671 .@expr1073745290 astString (@expr1073745291 sep@var681 ) ; }
1400: if (@expr1073745292 mImpl@var661 .@expr3469 mAstOperand2@var672 ) {
1401: ret@var682 +=@expr1073745294 mImpl@var661 .@expr3469 mAstOperand2@var672 .@expr1073745296 astString (@expr1073745297 sep@var681 ) ; }
1402: return ret@var682 +@expr1073745298 sep@var681 +@expr1073745299 mStr@var655 ;
1403: }
1404:
1405: std :: string astStringVerbose ( ) const ;
1406:
1407: std :: string astStringZ3 ( ) const ;
1408:
1409: std :: string expressionString ( ) const ;
1410:
1411: void printAst ( bool verbose@var683 , bool xml@var684 , const std :: vector < std :: string > & fileNames@var685 , std :: ostream & out@var686 ) const ;
1412:
1413: void printValueFlow ( bool xml@var687 , std :: ostream & out@var688 ) const ;
1414:
1415: void scopeInfo ( std :: shared_ptr < ScopeInfo2 > newScopeInfo@var689 ) ;
1416: std :: shared_ptr < ScopeInfo2 > scopeInfo ( ) const ;
1417:
1418: void setCpp11init ( bool cpp11init@var690 ) const {
1419: mImpl@var661 .@expr1073745300 mCpp11init@var691 =@expr1073745301 cpp11init@var690 ?@expr1073745302 TokenImpl ::@expr3479 Cpp11init ::@expr1073745304 CPP11INIT :@expr1073745305 TokenImpl ::@expr3479 Cpp11init ::@expr1073745307 NOINIT ;
1420: }
1421: TokenImpl :: Cpp11init isCpp11init ( ) const {
1422: return mImpl@var661 .@expr1073745308 mCpp11init@var691 ;
1423: }
1424: } ;
1425:
1426: Token * findTypeEnd ( Token * tok@var709 ) ;
1427: const Token * findTypeEnd ( const Token * tok@var710 ) ;
1428: Token * findLambdaEndScope ( Token * tok@var711 ) ;
1429: const Token * findLambdaEndScope ( const Token * tok@var712 ) ;

##file cppcheck-2.8/lib/tokenlist.h

1:
|
31:
32: class Settings ;
33:
34: namespace simplecpp {
35: class TokenList ;
36: }
37:
|
40:
41: class TokenList {
42: public:
43: explicit TokenList ( const Settings * settings@var713 ) ;
44: ~ TokenList ( ) ;
45:
46: void setSettings ( const Settings * settings@var714 ) {
47: mSettings@var749 =@expr1073745309 settings@var714 ;
48: }
49:
50: const Settings * getSettings ( ) const {
51: return mSettings@var749 ;
52: }
53:
54:
55: const std :: string & getSourceFilePath ( ) const ;
56:
57:
58: bool isC ( ) const {
59: return mIsC@var751 ;
60: }
61:
62:
63: bool isCPP ( ) const {
64: return mIsCpp@var752 ;
65: }
66:
|
70:
71: static void deleteTokens ( Token * tok@var715 ) ;
72:
73: void addtoken ( const std :: string & str@var716 , const int lineno@var717 , const int column@var718 , const int fileno@var719 , bool split@var720 = false ) ;
74: void addtoken ( const std :: string & str@var721 , const Token * locationTok@var722 ) ;
75:
76: void addtoken ( const Token * tok@var723 , const int lineno@var724 , const int column@var725 , const int fileno@var726 ) ;
77: void addtoken ( const Token * tok@var727 , const Token * locationTok@var728 ) ;
78: void addtoken ( const Token * tok@var729 ) ;
79:
80: static void insertTokens ( Token * dest@var730 , const Token * src@var731 , int n@var732 ) ;
81:
|
89:
90: static Token * copyTokens ( Token * dest@var733 , const Token * first@var734 , const Token * last@var735 , bool one_line@var736 = true ) ;
91:
|
100:
101: bool createTokens ( std :: istream & code@var737 , const std :: string & file0@var738 = emptyString@var1 ) ;
102:
103: void createTokens ( simplecpp :: TokenList && tokenList@var739 ) ;
104:
105:
106: void deallocateTokens ( ) ;
107:
108:
109: int appendFileIfNew ( const std :: string & fileName@var740 ) ;
110:
111:
112: const Token * front ( ) const {
113: return mTokensFrontBack@var746 .@expr1073745310 front@var753 ;
114: }
115: Token * front ( ) {
116: return mTokensFrontBack@var746 .@expr1073745311 front@var753 ;
117: }
118:
119:
120: const Token * back ( ) const {
121: return mTokensFrontBack@var746 .@expr1073745312 back@var754 ;
122: }
123: Token * back ( ) {
124: return mTokensFrontBack@var746 .@expr1073745313 back@var754 ;
125: }
126:
|
131:
132: const std :: vector < std :: string > & getFiles ( ) const {
133: return mFiles@var747 ;
134: }
135:
136: std :: string getOrigFile ( const Token * tok@var741 ) const ;
137:
|
142:
143: const std :: string & file ( const Token * tok@var742 ) const ;
144:
|
149:
150: std :: string fileLine ( const Token * tok@var743 ) const ;
151:
|
155:
156: unsigned long long calculateChecksum ( ) const ;
157:
|
160:
161: void createAst ( ) const ;
162:
|
166:
167: void validateAst ( ) const ;
168:
|
174:
175: bool validateToken ( const Token * tok@var744 ) const ;
176:
|
181:
182: void simplifyPlatformTypes ( ) ;
183:
|
187:
188: void simplifyStdType ( ) ;
189:
190: void clangSetOrigFiles ( ) ;
191:
192: bool isKeyword ( const std :: string & str@var745 ) const ;
193:
194: private:
195:
196:
197: TokenList ( const TokenList & ) ;
198:
199:
200: TokenList & operator= ( const TokenList & ) ;
201:
202: void determineCppC ( ) ;
203:
204:
205: TokensFrontBack mTokensFrontBack@var746 ;
206:
207:
208: std :: vector < std :: string > mFiles@var747 ;
209:
210:
211: std :: vector < std :: string > mOrigFiles@var748 ;
212:
213:
214: const Settings * mSettings@var749 ;
215:
216: std :: unordered_set < std :: string > mKeywords@var750 ;
217:
218:
219: bool mIsC@var751 ;
220: bool mIsCpp@var752 ;
221: } ;

##file cppcheck-2.8/lib/errortypes.h

1:
|
31:
32: class Token ;
33:
34:
35: struct InternalError {
36: enum Type { AST , SYNTAX , UNKNOWN_MACRO , INTERNAL , LIMIT , INSTANTIATION } ;
37: InternalError ( const Token * tok@var755 , const std :: string & errorMsg@var756 , Type type@var757 = INTERNAL ) ;
38: const Token * token@var758 ;
39: std :: string errorMessage@var759 ;
40: Type type@var760 ;
41: std :: string id@var761 ;
42: } ;
43:
44: class Certainty {
45: public:
46: enum CertaintyLevel {
47: normal , inconclusive , safe , experimental
48: } ;
49: } ;
50:
51: class Checks {
52: public:
53: enum CheckList {
54: unusedFunction , missingInclude , internalCheck
55: } ;
56: } ;
57:
58:
59: class Severity {
60: public:
61:
62:
63:
64: enum SeverityType {
65:
66:
67:
68: none ,
69:
|
73:
74: error ,
75:
|
79:
80: warning ,
81:
|
86:
87: style ,
88:
|
92:
93: performance ,
94:
|
100:
101: portability ,
102:
|
107:
108: information ,
109:
|
112:
113: debug
114: } ;
115:
116: static std :: string toString ( SeverityType severity@var762 ) ;
117: static SeverityType fromString ( const std :: string & severity@var763 ) ;
118: } ;
119:
120: struct CWE {
121: explicit CWE ( unsigned short cweId@var764 ) : id@var765 ( cweId@var764 ) { }
122: unsigned short id@var765 ;
123: } ;

##file cppcheck-2.8/lib/standards.h

1:
|
35:
36: struct Standards {
37:
38: enum cstd_t { C89 , C99 , C11 , CLatest = C11 } ; enum cstd_t c@var766 ;
39:
40:
41: enum cppstd_t { CPP03 , CPP11 , CPP14 , CPP17 , CPP20 , CPP23 , CPPLatest = CPP23 } ; enum cppstd_t cpp@var767 ;
42:
43:
44: std :: string stdValue@var768 ;
45:
46:
47: Standards ( ) : c@var766 ( CLatest ) , cpp@var767 ( CPPLatest ) { }
48:
49: bool setC ( const std :: string & str@var769 ) {
50: stdValue@var768 =@expr1073745314 str@var769 ;
51: if (@expr1073745315 str@var769 ==@expr1073745316 "c89" ||@expr1073745317 str@var769 ==@expr1073745318 "C89" ) {
52: c@var766 =@expr1073745319 C89 ;
53: return true ;
54: }
55: if (@expr1073745320 str@var769 ==@expr1073745321 "c99" ||@expr1073745322 str@var769 ==@expr1073745323 "C99" ) {
56: c@var766 =@expr1073745324 C99 ;
57: return true ;
58: }
59: if (@expr1073745325 str@var769 ==@expr1073745326 "c11" ||@expr1073745327 str@var769 ==@expr1073745328 "C11" ) {
60: c@var766 =@expr1073745329 C11 ;
61: return true ;
62: }
63: return false ;
64: }
65: const std :: string getC ( ) const {
66: switch (@expr1073745330 c@var766 ) {
67: case C89 :@expr3507 ;
68: return "c89" ;
69: case C99 :@expr3507 ;
70: return "c99" ;
71: case C11 :@expr3507 ;
72: return "c11" ;
73: }
74: return "" ;
75: }
76: static cstd_t getC ( const std :: string & std@var770 ) {
77: if (@expr1073745334 std@var770 ==@expr1073745335 "c89" ) {
78: return Standards ::@expr1073745336 C89 ;
79: }
80: if (@expr1073745337 std@var770 ==@expr1073745338 "c99" ) {
81: return Standards ::@expr1073745339 C99 ;
82: }
83: if (@expr1073745340 std@var770 ==@expr1073745341 "c11" ) {
84: return Standards ::@expr1073745342 C11 ;
85: }
86: return Standards ::@expr1073745343 CLatest ;
87: }
88: bool setCPP ( std :: string str@var771 ) {
89: stdValue@var768 =@expr1073745344 str@var771 ;
90: strTolower (@expr1073745345 str@var771 ) ;
91: cpp@var767 =@expr1073745346 getCPP (@expr1073745347 str@var771 ) ;
92: return !@expr1073745348 stdValue@var768 .@expr1073745349 empty (@expr1073745350 ) &&@expr1073745351 str@var771 ==@expr1073745352 getCPP (@expr1073745353 ) ;
93: }
94: std :: string getCPP ( ) const {
95: return getCPP (@expr1073745354 cpp@var767 ) ;
96: }
97: static std :: string getCPP ( cppstd_t std@var772 ) {
98: switch (@expr1073745355 std@var772 ) {
99: case CPP03 :@expr3532 ;
100: return "c++03" ;
101: case CPP11 :@expr3532 ;
102: return "c++11" ;
103: case CPP14 :@expr3532 ;
104: return "c++14" ;
105: case CPP17 :@expr3532 ;
106: return "c++17" ;
107: case CPP20 :@expr3532 ;
108: return "c++20" ;
109: case CPP23 :@expr3532 ;
110: return "c++23" ;
111: }
112: return "" ;
113: }
114: static cppstd_t getCPP ( const std :: string & std@var773 ) {
115: if (@expr1073745362 std@var773 ==@expr1073745363 "c++03" ) {
116: return Standards ::@expr1073745364 CPP03 ;
117: }
118: if (@expr1073745365 std@var773 ==@expr1073745366 "c++11" ) {
119: return Standards ::@expr1073745367 CPP11 ;
120: }
121: if (@expr1073745368 std@var773 ==@expr1073745369 "c++14" ) {
122: return Standards ::@expr1073745370 CPP14 ;
123: }
124: if (@expr1073745371 std@var773 ==@expr1073745372 "c++17" ) {
125: return Standards ::@expr1073745373 CPP17 ;
126: }
127: if (@expr1073745374 std@var773 ==@expr1073745375 "c++20" ) {
128: return Standards ::@expr1073745376 CPP20 ;
129: }
130: if (@expr1073745377 std@var773 ==@expr1073745378 "c++23" ) {
131: return Standards ::@expr1073745379 CPP23 ;
132: }
133: return Standards ::@expr1073745380 CPPLatest ;
134: }
135: } ;

##file cppcheck-2.8/lib/library.h

1:
|
37:
38: class Token ;
39: class Settings ;
40:
41: namespace tinyxml2 {
42: class XMLDocument ;
43: class XMLElement ;
44: }
45:
|
51:
52: class Library {
53: friend class TestSymbolDatabase ;
54:
55: public:
56: Library ( ) ;
57:
58: enum class ErrorCode { OK , FILE_NOT_FOUND , BAD_XML , UNKNOWN_ELEMENT , MISSING_ATTRIBUTE , BAD_ATTRIBUTE_VALUE , UNSUPPORTED_FORMAT , DUPLICATE_PLATFORM_TYPE , PLATFORM_TYPE_REDEFINED } ;
59:
60: class Error {
61: public:
62: Error ( ) : errorcode@var777 ( ErrorCode :: OK ) { }
63: explicit Error ( ErrorCode e@var774 ) : errorcode@var777 ( e@var774 ) { }
64: template < typename T >
65: Error ( ErrorCode e@var775 , T && r@var776 ) : errorcode@var777 ( e@var775 ) , reason@var778 ( r@var776 ) { }
66: ErrorCode errorcode@var777 ;
67: std :: string reason@var778 ;
68: } ;
69:
70: Error load ( const char exename@var779 [ ] , const char path@var780 [ ] ) ;
71: Error load ( const tinyxml2 :: XMLDocument & doc@var781 ) ;
72:
73:
74: bool loadxmldata ( const char xmldata@var782 [ ] , unsigned long len@var783 ) ;
75:
76: struct AllocFunc {
77: int groupId@var784 ;
78: int arg@var785 ;
79: enum class BufferSize { none , malloc , calloc , strdup } ;
80: BufferSize bufferSize@var786 ;
81: int bufferSizeArg1@var787 ;
82: int bufferSizeArg2@var788 ;
83: int reallocArg@var789 ;
84: bool initData@var790 ;
85: } ;
86:
87:
88: const AllocFunc * getAllocFuncInfo ( const Token * tok@var791 ) const ;
89:
90:
91: const AllocFunc * getDeallocFuncInfo ( const Token * tok@var792 ) const ;
92:
93:
94: const AllocFunc * getReallocFuncInfo ( const Token * tok@var793 ) const ;
95:
96:
97: int getAllocId ( const Token * tok@var794 , int arg@var795 ) const ;
98:
99:
100: int getDeallocId ( const Token * tok@var796 , int arg@var797 ) const ;
101:
102:
103: int getReallocId ( const Token * tok@var798 , int arg@var799 ) const ;
104:
105:
106: const AllocFunc * getAllocFuncInfo ( const char name@var800 [ ] ) const {
107: return getAllocDealloc (@expr1073745381 mAlloc@var1066 , name@var800 ) ;
108: }
109:
110:
111: const AllocFunc * getDeallocFuncInfo ( const char name@var801 [ ] ) const {
112: return getAllocDealloc (@expr1073745382 mDealloc@var1067 , name@var801 ) ;
113: }
114:
115:
116: int allocId ( const char name@var802 [ ] ) const {
117: const AllocFunc * af@var803 ; af@var803 =@expr1073745383 getAllocDealloc (@expr1073745384 mAlloc@var1066 , name@var802 ) ;
118: return af@var803 ?@expr1073745385 af@var803 .@expr1073745386 groupId@var804 :@expr1073745387 0 ;
119: }
120:
121:
122: int deallocId ( const char name@var805 [ ] ) const {
123: const AllocFunc * af@var806 ; af@var806 =@expr1073745388 getAllocDealloc (@expr1073745389 mDealloc@var1067 , name@var805 ) ;
124: return af@var806 ?@expr1073745390 af@var806 .@expr1073745391 groupId@var807 :@expr1073745392 0 ;
125: }
126:
127:
128: void setalloc ( const std :: string & functionname@var808 , int id@var809 , int arg@var810 ) {
129: mAlloc@var1066 [@expr3569 functionname@var808 ] .@expr1073745394 groupId@var2506 =@expr1073745395 id@var809 ;
130: mAlloc@var1066 [@expr3569 functionname@var808 ] .@expr1073745397 arg@var2507 =@expr1073745398 arg@var810 ;
131: }
132:
133: void setdealloc ( const std :: string & functionname@var811 , int id@var812 , int arg@var813 ) {
134: mDealloc@var1067 [@expr3575 functionname@var811 ] .@expr1073745400 groupId@var2508 =@expr1073745401 id@var812 ;
135: mDealloc@var1067 [@expr3575 functionname@var811 ] .@expr1073745403 arg@var2509 =@expr1073745404 arg@var813 ;
136: }
137:
138: void setrealloc ( const std :: string & functionname@var814 , int id@var815 , int arg@var816 , int reallocArg@var817 = 1 ) {
139: mRealloc@var1068 [@expr3581 functionname@var814 ] .@expr1073745406 groupId@var2510 =@expr1073745407 id@var815 ;
140: mRealloc@var1068 [@expr3581 functionname@var814 ] .@expr1073745409 arg@var2511 =@expr1073745410 arg@var816 ;
141: mRealloc@var1068 [@expr3581 functionname@var814 ] .@expr1073745412 reallocArg@var2512 =@expr1073745413 reallocArg@var817 ;
142: }
143:
144:
145: void setnoreturn ( const std :: string & funcname@var818 , bool noreturn@var819 ) {
146: mNoReturn@var1069 [@expr1073745414 funcname@var818 ] =@expr1073745415 noreturn@var819 ?@expr1073745416 FalseTrueMaybe ::@expr1073745417 True :@expr1073745418 FalseTrueMaybe ::@expr1073745419 False ;
147: }
148:
149: static bool isCompliantValidationExpression ( const char * p@var820 ) ;
150:
151:
152: static bool ismemory ( const int id@var821 ) {
153: return (@expr3596 (@expr3596 id@var821 >@expr1073745422 0 ) &&@expr1073745423 (@expr3596 (@expr3596 id@var821 &@expr1073745426 1 ) ==@expr1073745427 0 ) ) ;
154: }
155: static bool ismemory ( const AllocFunc * const func@var822 ) {
156: return (@expr3604 (@expr3604 func@var822 .@expr3606 groupId@var823 >@expr1073745431 0 ) &&@expr1073745432 (@expr3604 (@expr3604 func@var822 .@expr3606 groupId@var823 &@expr1073745436 1 ) ==@expr1073745437 0 ) ) ;
157: }
158:
159:
160: static bool isresource ( const int id@var824 ) {
161: return (@expr3614 (@expr3614 id@var824 >@expr1073745440 0 ) &&@expr1073745441 (@expr3614 (@expr3614 id@var824 &@expr1073745444 1 ) ==@expr1073745445 1 ) ) ;
162: }
163: static bool isresource ( const AllocFunc * const func@var825 ) {
164: return (@expr3622 (@expr3622 func@var825 .@expr3624 groupId@var826 >@expr1073745449 0 ) &&@expr1073745450 (@expr3622 (@expr3622 func@var825 .@expr3624 groupId@var826 &@expr1073745454 1 ) ==@expr1073745455 1 ) ) ;
165: }
166:
167: bool formatstr_function ( const Token * ftok@var827 ) const ;
168: int formatstr_argno ( const Token * ftok@var828 ) const ;
169: bool formatstr_scan ( const Token * ftok@var829 ) const ;
170: bool formatstr_secure ( const Token * ftok@var830 ) const ;
171:
172: struct NonOverlappingData {
173: int ptr1Arg@var831 ;
174: int ptr2Arg@var832 ;
175: int sizeArg@var833 ;
176: int strlenArg@var834 ;
177: } ;
178: const NonOverlappingData * getNonOverlappingData ( const Token * ftok@var835 ) const ;
179:
180: struct WarnInfo {
181: std :: string message@var836 ;
182: Standards standards@var837 ;
183: Severity :: SeverityType severity@var838 ;
184: } ;
185: std :: map < std :: string , WarnInfo > functionwarn@var839 ;
186:
187: const WarnInfo * getWarnInfo ( const Token * ftok@var840 ) const ;
188:
189:
190: bool isNotLibraryFunction ( const Token * ftok@var841 ) const ;
191: bool matchArguments ( const Token * ftok@var842 , const std :: string & functionName@var843 ) const ;
192:
193: enum class UseRetValType { NONE , DEFAULT , ERROR_CODE } ;
194: UseRetValType getUseRetValType ( const Token * ftok@var844 ) const ;
195:
196: const std :: string & returnValue ( const Token * ftok@var845 ) const ;
197: const std :: string & returnValueType ( const Token * ftok@var846 ) const ;
198: int returnValueContainer ( const Token * ftok@var847 ) const ;
199: std :: vector < long long > unknownReturnValues ( const Token * ftok@var848 ) const ;
200:
201: bool isnoreturn ( const Token * ftok@var849 ) const ;
202: bool isnotnoreturn ( const Token * ftok@var850 ) const ;
203:
204: bool isScopeNoReturn ( const Token * end@var851 , std :: string * unknownFunc@var852 ) const ;
205:
206: class Container {
207: public:
208: Container ( )
209: : type_templateArgNo@var862 ( -1 ) ,
210: size_templateArgNo@var864 ( -1 ) ,
211: arrayLike_indexOp@var865 ( false ) ,
212: stdStringLike@var866 ( false ) ,
213: stdAssociativeLike@var867 ( false ) ,
214: opLessAllowed@var868 ( true ) ,
215: hasInitializerListConstructor@var869 ( false ) ,
216: unstableErase@var870 ( false ) ,
217: unstableInsert@var871 ( false ) ,
218: view@var872 ( false )
219: { }
220:
221: enum class Action {
222: RESIZE ,
223: CLEAR ,
224: PUSH ,
225: POP ,
226: FIND ,
227: INSERT ,
228: ERASE ,
229: CHANGE_CONTENT ,
230: CHANGE ,
231: CHANGE_INTERNAL ,
232: NO_ACTION
233: } ;
234: enum class Yield {
235: AT_INDEX ,
236: ITEM ,
237: BUFFER ,
238: BUFFER_NT ,
239: START_ITERATOR ,
240: END_ITERATOR ,
241: ITERATOR ,
242: SIZE ,
243: EMPTY ,
244: NO_YIELD
245: } ;
246: struct Function {
247: Action action@var853 ;
248: Yield yield@var854 ;
249: } ;
250: struct RangeItemRecordTypeItem {
251: std :: string name@var855 ;
252: int templateParameter@var856 ;
253: } ;
254: std :: string startPattern@var857 ; std :: string startPattern2@var858 ; std :: string endPattern@var859 ; std :: string itEndPattern@var860 ;
255: std :: map < std :: string , Function > functions@var861 ;
256: int type_templateArgNo@var862 ;
257: std :: vector < RangeItemRecordTypeItem > rangeItemRecordType@var863 ;
258: int size_templateArgNo@var864 ;
259: bool arrayLike_indexOp@var865 ;
260: bool stdStringLike@var866 ;
261: bool stdAssociativeLike@var867 ;
262: bool opLessAllowed@var868 ;
263: bool hasInitializerListConstructor@var869 ;
264: bool unstableErase@var870 ;
265: bool unstableInsert@var871 ;
266: bool view@var872 ;
267:
268: Action getAction ( const std :: string & function@var873 ) const {
269: const std ::@expr1073745456 map < std ::@expr1073745457 string , Function > ::@expr1073745458 const_iterator i@var874 =@expr1073745459 functions@var861 .@expr1073745460 find (@expr1073745461 function@var873 ) ;
270: if (@expr1073745462 i@var874 !=@expr1073745463 functions@var861 .@expr1073745464 end (@expr1073745465 ) ) {
271: return i@var874 .@expr1073745466 second@var875 .@expr1073745467 action@var876 ; }
272: return Action ::@expr1073745468 NO_ACTION ;
273: }
274:
275: Yield getYield ( const std :: string & function@var877 ) const {
276: const std ::@expr1073745469 map < std ::@expr1073745470 string , Function > ::@expr1073745471 const_iterator i@var878 =@expr1073745472 functions@var861 .@expr1073745473 find (@expr1073745474 function@var877 ) ;
277: if (@expr1073745475 i@var878 !=@expr1073745476 functions@var861 .@expr1073745477 end (@expr1073745478 ) ) {
278: return i@var878 .@expr1073745479 second@var879 .@expr1073745480 yield@var880 ; }
279: return Yield ::@expr1073745481 NO_YIELD ;
280: }
281:
282: static Yield yieldFrom ( const std :: string & yieldName@var881 ) ;
283: static Action actionFrom ( const std :: string & actionName@var882 ) ;
284: } ;
285: std :: map < std :: string , Container > containers@var883 ;
286: const Container * detectContainer ( const Token * typeStart@var884 , bool iterator@var885 = false ) const ;
287: const Container * detectContainerOrIterator ( const Token * typeStart@var886 , bool * isIterator@var887 = nullptr ) const ;
288:
289: class ArgumentChecks {
290: public:
291: ArgumentChecks ( ) :
292: notbool@var888 ( false ) ,
293: notnull@var889 ( false ) ,
294: notuninit@var890 ( -1 ) ,
295: formatstr@var891 ( false ) ,
296: strz@var892 ( false ) ,
297: optional@var893 ( false ) ,
298: variadic@var894 ( false ) ,
299: iteratorInfo@var900 ( ) ,
300: direction@var908 ( Direction :: DIR_UNKNOWN ) { }
301:
302: bool notbool@var888 ;
303: bool notnull@var889 ;
304: int notuninit@var890 ;
305: bool formatstr@var891 ;
306: bool strz@var892 ;
307: bool optional@var893 ;
308: bool variadic@var894 ;
309: std :: string valid@var895 ;
310:
311: class IteratorInfo {
312: public:
313: IteratorInfo ( ) : container@var896 ( 0 ) , it@var897 ( false ) , first@var898 ( false ) , last@var899 ( false ) { }
314:
315: int container@var896 ;
316: bool it@var897 ;
317: bool first@var898 ;
318: bool last@var899 ;
319: } ;
320: IteratorInfo iteratorInfo@var900 ;
321:
322: class MinSize {
323: public:
324: enum class Type { NONE , STRLEN , ARGVALUE , SIZEOF , MUL , VALUE } ;
325: MinSize ( Type t@var901 , int a@var902 ) : type@var903 ( t@var901 ) , arg@var904 ( a@var902 ) , arg2@var905 ( 0 ) , value@var906 ( 0 ) { }
326: Type type@var903 ;
327: int arg@var904 ;
328: int arg2@var905 ;
329: long long value@var906 ;
330: } ;
331: std :: vector < MinSize > minsizes@var907 ;
332:
333: enum class Direction {
334: DIR_IN ,
335: DIR_OUT ,
336: DIR_INOUT ,
337: DIR_UNKNOWN
338: } ;
339: Direction direction@var908 ;
340: } ;
341:
342: struct Function {
343: std :: map < int , ArgumentChecks > argumentChecks@var909 ;
344: bool use@var910 ;
345: bool leakignore@var911 ;
346: bool isconst@var912 ;
347: bool ispure@var913 ;
348: UseRetValType useretval@var914 ;
349: bool ignore@var915 ;
350: bool formatstr@var916 ;
351: bool formatstr_scan@var917 ;
352: bool formatstr_secure@var918 ;
353: Container :: Action containerAction@var919 ;
354: Container :: Yield containerYield@var920 ;
355: Function ( )
356: : use@var910 ( false ) ,
357: leakignore@var911 ( false ) ,
358: isconst@var912 ( false ) ,
359: ispure@var913 ( false ) ,
360: useretval@var914 ( UseRetValType :: NONE ) ,
361: ignore@var915 ( false ) ,
362: formatstr@var916 ( false ) ,
363: formatstr_scan@var917 ( false ) ,
364: formatstr_secure@var918 ( false ) ,
365: containerAction@var919 ( Container :: Action :: NO_ACTION ) ,
366: containerYield@var920 ( Container :: Yield :: NO_YIELD )
367: { }
368: } ;
369:
370: const Function * getFunction ( const Token * ftok@var921 ) const ;
371: std :: unordered_map < std :: string , Function > functions@var922 ;
372: bool isUse ( const std :: string & functionName@var923 ) const ;
373: bool isLeakIgnore ( const std :: string & functionName@var924 ) const ;
374: bool isFunctionConst ( const std :: string & functionName@var925 , bool pure@var926 ) const ;
375: bool isFunctionConst ( const Token * ftok@var927 ) const ;
376:
377: bool isboolargbad ( const Token * ftok@var928 , int argnr@var929 ) const {
378: const ArgumentChecks * arg@var930 ; arg@var930 =@expr1073745482 getarg (@expr1073745483 ftok@var928 , argnr@var929 ) ;
379: return arg@var930 &&@expr1073745484 arg@var930 .@expr1073745485 notbool@var931 ;
380: }
381:
382: bool isnullargbad ( const Token * ftok@var932 , int argnr@var933 ) const ;
383: bool isuninitargbad ( const Token * ftok@var934 , int argnr@var935 , int indirect@var936 = 0 , bool * hasIndirect@var937 = nullptr ) const ;
384:
385: bool isargformatstr ( const Token * ftok@var938 , int argnr@var939 ) const {
386: const ArgumentChecks * arg@var940 ; arg@var940 =@expr1073745486 getarg (@expr1073745487 ftok@var938 , argnr@var939 ) ;
387: return arg@var940 &&@expr1073745488 arg@var940 .@expr1073745489 formatstr@var941 ;
388: }
389:
390: bool isargstrz ( const Token * ftok@var942 , int argnr@var943 ) const {
391: const ArgumentChecks * arg@var944 ; arg@var944 =@expr1073745490 getarg (@expr1073745491 ftok@var942 , argnr@var943 ) ;
392: return arg@var944 &&@expr1073745492 arg@var944 .@expr1073745493 strz@var945 ;
393: }
394:
395: bool isIntArgValid ( const Token * ftok@var946 , int argnr@var947 , const long long argvalue@var948 ) const ;
396: bool isFloatArgValid ( const Token * ftok@var949 , int argnr@var950 , double argvalue@var951 ) const ;
397:
398: const std :: string & validarg ( const Token * ftok@var952 , int argnr@var953 ) const {
399: const ArgumentChecks * arg@var954 ; arg@var954 =@expr1073745494 getarg (@expr1073745495 ftok@var952 , argnr@var953 ) ;
400: return arg@var954 ?@expr1073745496 arg@var954 .@expr1073745497 valid@var955 :@expr1073745498 emptyString@var1 ;
401: }
402:
403: struct InvalidArgValue {
404: enum class Type { le , lt , eq , ge , gt , range } ; enum Type type@var956 ;
405: std :: string op1@var957 ;
406: std :: string op2@var958 ;
407: bool isInt ( ) const {
408: return MathLib ::@expr1073745499 isInt (@expr1073745500 op1@var957 ) ;
409: }
410: } ;
411:
412: const ArgumentChecks :: IteratorInfo * getArgIteratorInfo ( const Token * ftok@var959 , int argnr@var960 ) const {
413: const ArgumentChecks * arg@var961 ; arg@var961 =@expr1073745501 getarg (@expr1073745502 ftok@var959 , argnr@var960 ) ;
414: return arg@var961 &&@expr1073745503 arg@var961 .@expr3680 iteratorInfo@var962 .@expr1073745505 it@var963 ?@expr1073745506 &@expr1073745507 arg@var961 .@expr3680 iteratorInfo@var962 :@expr1073745509 nullptr ;
415: }
416:
417: bool hasminsize ( const Token * ftok@var964 ) const ;
418:
419: const std :: vector < ArgumentChecks :: MinSize > * argminsizes ( const Token * ftok@var965 , int argnr@var966 ) const {
420: const ArgumentChecks * arg@var967 ; arg@var967 =@expr1073745510 getarg (@expr1073745511 ftok@var965 , argnr@var966 ) ;
421: return arg@var967 ?@expr1073745512 &@expr1073745513 arg@var967 .@expr1073745514 minsizes@var968 :@expr1073745515 nullptr ;
422: }
423:
424: ArgumentChecks :: Direction getArgDirection ( const Token * ftok@var969 , int argnr@var970 ) const ;
425:
426: bool markupFile ( const std :: string & path@var971 ) const ;
427:
428: bool processMarkupAfterCode ( const std :: string & path@var972 ) const ;
429:
430: const std :: set < std :: string > & markupExtensions ( ) const {
431: return mMarkupExtensions@var1076 ;
432: }
433:
434: bool reportErrors ( const std :: string & path@var973 ) const ;
435:
436: bool ignorefunction ( const std :: string & functionName@var974 ) const ;
437:
438: bool isexecutableblock ( const std :: string & file@var975 , const std :: string & token@var976 ) const ;
439:
440: int blockstartoffset ( const std :: string & file@var977 ) const ;
441:
442: const std :: string & blockstart ( const std :: string & file@var978 ) const ;
443: const std :: string & blockend ( const std :: string & file@var979 ) const ;
444:
445: bool iskeyword ( const std :: string & file@var980 , const std :: string & keyword@var981 ) const ;
446:
447: bool isexporter ( const std :: string & prefix@var982 ) const {
448: return mExporters@var1079 .@expr1073745516 find (@expr1073745517 prefix@var982 ) !=@expr1073745518 mExporters@var1079 .@expr1073745519 end (@expr1073745520 ) ;
449: }
450:
451: bool isexportedprefix ( const std :: string & prefix@var983 , const std :: string & token@var984 ) const {
452: const std ::@expr1073745521 map < std ::@expr1073745522 string , ExportedFunctions > ::@expr1073745523 const_iterator it@var985 =@expr1073745524 mExporters@var1079 .@expr1073745525 find (@expr1073745526 prefix@var983 ) ;
453: return (@expr1073745527 it@var985 !=@expr1073745528 mExporters@var1079 .@expr1073745529 end (@expr1073745530 ) &&@expr1073745531 it@var985 .@expr1073745532 second@var986 .@expr1073745533 isPrefix (@expr1073745534 token@var984 ) ) ;
454: }
455:
456: bool isexportedsuffix ( const std :: string & prefix@var987 , const std :: string & token@var988 ) const {
457: const std ::@expr1073745535 map < std ::@expr1073745536 string , ExportedFunctions > ::@expr1073745537 const_iterator it@var989 =@expr1073745538 mExporters@var1079 .@expr1073745539 find (@expr1073745540 prefix@var987 ) ;
458: return (@expr1073745541 it@var989 !=@expr1073745542 mExporters@var1079 .@expr1073745543 end (@expr1073745544 ) &&@expr1073745545 it@var989 .@expr1073745546 second@var990 .@expr1073745547 isSuffix (@expr1073745548 token@var988 ) ) ;
459: }
460:
461: bool isimporter ( const std :: string & file@var991 , const std :: string & importer@var992 ) const ;
462:
463: const Token * getContainerFromYield ( const Token * tok@var993 , Container :: Yield yield@var994 ) const ;
464: const Token * getContainerFromAction ( const Token * tok@var995 , Container :: Action action@var996 ) const ;
465:
466: bool isreflection ( const std :: string & token@var997 ) const {
467: return mReflection@var1081 .@expr1073745549 find (@expr1073745550 token@var997 ) !=@expr1073745551 mReflection@var1081 .@expr1073745552 end (@expr1073745553 ) ;
468: }
469:
470: int reflectionArgument ( const std :: string & token@var998 ) const {
471: const std ::@expr1073745554 map < std ::@expr1073745555 string , int > ::@expr1073745556 const_iterator it@var999 =@expr1073745557 mReflection@var1081 .@expr1073745558 find (@expr1073745559 token@var998 ) ;
472: if (@expr1073745560 it@var999 !=@expr1073745561 mReflection@var1081 .@expr1073745562 end (@expr1073745563 ) ) {
473: return it@var999 .@expr1073745564 second@var1000 ; }
474: return -1 ;
475: }
476:
477: std :: vector < std :: string > defines@var1001 ;
478:
479: struct SmartPointer {
480: std :: string name@var1002 ; name@var1002 = "" ;
481: bool unique@var1003 ; unique@var1003 = false ;
482: } ;
483:
484: std :: map < std :: string , SmartPointer > smartPointers@var1004 ;
485: bool isSmartPointer ( const Token * tok@var1005 ) const ;
486: const SmartPointer * detectSmartPointer ( const Token * tok@var1006 ) const ;
487:
488: struct PodType {
489: unsigned int size@var1007 ;
490: char sign@var1008 ;
491: enum class Type { NO , BOOL , CHAR , SHORT , INT , LONG , LONGLONG } ; enum Type stdtype@var1009 ;
492: } ;
493: const struct PodType * podtype ( const std :: string & name@var1010 ) const {
494: const std ::@expr1073745565 unordered_map < std ::@expr1073745566 string , PodType > ::@expr1073745567 const_iterator it@var1011 =@expr1073745568 mPodTypes@var1082 .@expr1073745569 find (@expr1073745570 name@var1010 ) ;
495: return (@expr3747 it@var1011 !=@expr1073745572 mPodTypes@var1082 .@expr1073745573 end (@expr1073745574 ) ) ?@expr1073745575 &@expr1073745576 (@expr3747 it@var1011 .@expr1073745578 second@var1012 ) :@expr1073745579 nullptr ;
496: }
497:
498: struct PlatformType {
499: PlatformType ( )
500: : mSigned@var1023 ( false )
501: , mUnsigned@var1024 ( false )
502: , mLong@var1025 ( false )
503: , mPointer@var1026 ( false )
504: , mPtrPtr@var1027 ( false )
505: , mConstPtr@var1028 ( false ) { }
506: bool operator== ( const PlatformType & type@var1013 ) const {
507: return (@expr1073745580 mSigned@var1023 ==@expr1073745581 type@var1013 .@expr1073745582 mSigned@var1014 &&@expr1073745583
508: mUnsigned@var1024 ==@expr1073745584 type@var1013 .@expr1073745585 mUnsigned@var1015 &&@expr1073745586
509: mLong@var1025 ==@expr1073745587 type@var1013 .@expr1073745588 mLong@var1016 &&@expr1073745589
510: mPointer@var1026 ==@expr1073745590 type@var1013 .@expr1073745591 mPointer@var1017 &&@expr1073745592
511: mPtrPtr@var1027 ==@expr1073745593 type@var1013 .@expr1073745594 mPtrPtr@var1018 &&@expr1073745595
512: mConstPtr@var1028 ==@expr1073745596 type@var1013 .@expr1073745597 mConstPtr@var1019 &&@expr1073745598
513: mType@var1022 ==@expr1073745599 type@var1013 .@expr1073745600 mType@var1020 ) ;
514: }
515: bool operator!= ( const PlatformType & type@var1021 ) const {
516: return !@expr1073745601 (@expr1073745602 *@expr1073745603 this@expr1073745604 ==@expr1073745605 type@var1021 ) ;
517: }
518: std :: string mType@var1022 ;
519: bool mSigned@var1023 ;
520: bool mUnsigned@var1024 ;
521: bool mLong@var1025 ;
522: bool mPointer@var1026 ;
523: bool mPtrPtr@var1027 ;
524: bool mConstPtr@var1028 ;
525: } ;
526:
527: struct Platform {
528: const PlatformType * platform_type ( const std :: string & name@var1029 ) const {
529: const std ::@expr1073745606 map < std ::@expr1073745607 string , PlatformType > ::@expr1073745608 const_iterator it@var1030 =@expr1073745609 mPlatformTypes@var1032 .@expr1073745610 find (@expr1073745611 name@var1029 ) ;
530: return (@expr3788 it@var1030 !=@expr1073745613 mPlatformTypes@var1032 .@expr1073745614 end (@expr1073745615 ) ) ?@expr1073745616 &@expr1073745617 (@expr3788 it@var1030 .@expr1073745619 second@var1031 ) :@expr1073745620 nullptr ;
531: }
532: std :: map < std :: string , PlatformType > mPlatformTypes@var1032 ;
533: } ;
534:
535: const PlatformType * platform_type ( const std :: string & name@var1033 , const std :: string & platform@var1034 ) const {
536: const std ::@expr1073745621 map < std ::@expr3798 string , Platform > ::@expr1073745623 const_iterator it@var1035 =@expr1073745624 mPlatforms@var1084 .@expr1073745625 find (@expr1073745626 platform@var1034 ) ;
537: if (@expr1073745627 it@var1035 !=@expr1073745628 mPlatforms@var1084 .@expr1073745629 end (@expr1073745630 ) ) {
538: const PlatformType * const type@var1036 ; type@var1036 =@expr1073745631 it@var1035 .@expr1073745632 second@var1037 .@expr1073745633 platform_type (@expr1073745634 name@var1033 ) ;
539: if (@expr1073745635 type@var1036 ) {
540: return type@var1036 ; }
541: }
542:
543: const std ::@expr1073745636 map < std ::@expr3798 string , PlatformType > ::@expr1073745638 const_iterator it2@var1038 =@expr1073745639 mPlatformTypes@var1083 .@expr1073745640 find (@expr1073745641 name@var1033 ) ;
544: return (@expr3818 it2@var1038 !=@expr1073745643 mPlatformTypes@var1083 .@expr1073745644 end (@expr1073745645 ) ) ?@expr1073745646 &@expr1073745647 (@expr3818 it2@var1038 .@expr1073745649 second@var1039 ) :@expr1073745650 nullptr ;
545: }
546:
|
549:
550: std :: string getFunctionName ( const Token * ftok@var1040 ) const ;
551:
552: static bool isContainerYield ( const Token * const cond@var1041 , Library :: Container :: Yield y@var1042 , const std :: string & fallback@var1043 = "" ) ;
553:
554:
555: enum class TypeCheck { def , check , suppress } ;
556: TypeCheck getTypeCheck ( const std :: string & check@var1044 , const std :: string & typeName@var1045 ) const ;
557:
558: private:
559:
560: Error loadFunction ( const tinyxml2 :: XMLElement * const node@var1046 , const std :: string & name@var1047 , std :: set < std :: string > & unknown_elements@var1048 ) ;
561:
562: class ExportedFunctions {
563: public:
564: void addPrefix ( const std :: string & prefix@var1049 ) {
565: mPrefixes@var1053 .@expr1073745651 insert (@expr1073745652 prefix@var1049 ) ;
566: }
567: void addSuffix ( const std :: string & suffix@var1050 ) {
568: mSuffixes@var1054 .@expr1073745653 insert (@expr1073745654 suffix@var1050 ) ;
569: }
570: bool isPrefix ( const std :: string & prefix@var1051 ) const {
571: return (@expr1073745655 mPrefixes@var1053 .@expr1073745656 find (@expr1073745657 prefix@var1051 ) !=@expr1073745658 mPrefixes@var1053 .@expr1073745659 end (@expr1073745660 ) ) ;
572: }
573: bool isSuffix ( const std :: string & suffix@var1052 ) const {
574: return (@expr1073745661 mSuffixes@var1054 .@expr1073745662 find (@expr1073745663 suffix@var1052 ) !=@expr1073745664 mSuffixes@var1054 .@expr1073745665 end (@expr1073745666 ) ) ;
575: }
576:
577: private:
578: std :: set < std :: string > mPrefixes@var1053 ;
579: std :: set < std :: string > mSuffixes@var1054 ;
580: } ;
581: class CodeBlock {
582: public:
583: CodeBlock ( ) : mOffset@var1062 ( 0 ) { }
584:
585: void setStart ( const char * s@var1055 ) {
586: mStart@var1060 =@expr1073745667 s@var1055 ;
587: }
588: void setEnd ( const char * e@var1056 ) {
589: mEnd@var1061 =@expr1073745668 e@var1056 ;
590: }
591: void setOffset ( const int o@var1057 ) {
592: mOffset@var1062 =@expr1073745669 o@var1057 ;
593: }
594: void addBlock ( const char * blockName@var1058 ) {
595: mBlocks@var1063 .@expr1073745670 insert (@expr1073745671 blockName@var1058 ) ;
596: }
597: const std :: string & start ( ) const {
598: return mStart@var1060 ;
599: }
600: const std :: string & end ( ) const {
601: return mEnd@var1061 ;
602: }
603: int offset ( ) const {
604: return mOffset@var1062 ;
605: }
606: bool isBlock ( const std :: string & blockName@var1059 ) const {
607: return mBlocks@var1063 .@expr1073745672 find (@expr1073745673 blockName@var1059 ) !=@expr1073745674 mBlocks@var1063 .@expr1073745675 end (@expr1073745676 ) ;
608: }
609:
610: private:
611: std :: string mStart@var1060 ;
612: std :: string mEnd@var1061 ;
613: int mOffset@var1062 ;
614: std :: set < std :: string > mBlocks@var1063 ;
615: } ;
616: enum class FalseTrueMaybe { False , True , Maybe } ;
617: int mAllocId@var1064 ;
618: std :: set < std :: string > mFiles@var1065 ;
619: std :: map < std :: string , AllocFunc > mAlloc@var1066 ;
620: std :: map < std :: string , AllocFunc > mDealloc@var1067 ;
621: std :: map < std :: string , AllocFunc > mRealloc@var1068 ;
622: std :: unordered_map < std :: string , FalseTrueMaybe > mNoReturn@var1069 ;
623: std :: map < std :: string , std :: string > mReturnValue@var1070 ;
624: std :: map < std :: string , std :: string > mReturnValueType@var1071 ;
625: std :: map < std :: string , int > mReturnValueContainer@var1072 ;
626: std :: map < std :: string , std :: vector < long long > > mUnknownReturnValues@var1073 ;
627: std :: map < std :: string , bool > mReportErrors@var1074 ;
628: std :: map < std :: string , bool > mProcessAfterCode@var1075 ;
629: std :: set < std :: string > mMarkupExtensions@var1076 ;
630: std :: map < std :: string , std :: set < std :: string > > mKeywords@var1077 ;
631: std :: map < std :: string , CodeBlock > mExecutableBlocks@var1078 ;
632: std :: map < std :: string , ExportedFunctions > mExporters@var1079 ;
633: std :: map < std :: string , std :: set < std :: string > > mImporters@var1080 ;
634: std :: map < std :: string , int > mReflection@var1081 ;
635: std :: unordered_map < std :: string , PodType > mPodTypes@var1082 ;
636: std :: map < std :: string , PlatformType > mPlatformTypes@var1083 ;
637: std :: map < std :: string , Platform > mPlatforms@var1084 ;
638: std :: map < std :: pair < std :: string , std :: string > , TypeCheck > mTypeChecks@var1085 ;
639: std :: unordered_map < std :: string , NonOverlappingData > mNonOverlappingData@var1086 ;
640:
641: const ArgumentChecks * getarg ( const Token * ftok@var1087 , int argnr@var1088 ) const ;
642:
643: std :: string getFunctionName ( const Token * ftok@var1089 , bool * error@var1090 ) const ;
644:
645: static const AllocFunc * getAllocDealloc ( const std :: map < std :: string , AllocFunc > & data@var1091 , const std :: string & name@var1092 ) {
646: const std ::@expr1073745677 map < std ::@expr1073745678 string , AllocFunc > ::@expr1073745679 const_iterator it@var1093 =@expr1073745680 data@var1091 .@expr1073745681 find (@expr1073745682 name@var1092 ) ;
647: return (@expr1073745683 it@var1093 ==@expr1073745684 data@var1091 .@expr1073745685 end (@expr1073745686 ) ) ?@expr1073745687 nullptr :@expr1073745688 &@expr1073745689 it@var1093 .@expr1073745690 second@var1094 ;
648: }
649: } ;
650:
651: const Library :: Container * getLibraryContainer ( const Token * tok@var1095 ) ;
652:
653: std :: shared_ptr < Token > createTokenFromExpression ( const std :: string & returnValue@var1096 ,
654: const Settings * settings@var1097 ,
655: std :: unordered_map < int , const Token * > * lookupVarId@var1098 = nullptr ) ;

##file cppcheck-2.8/lib/symboldatabase.h

1:
|
39:
40: namespace cppcheck {
41: class Platform ;
42: }
43:
44: class ErrorLogger ;
45: class Function ;
46: class Scope ;
47: class Settings ;
48: class SymbolDatabase ;
49: class Tokenizer ;
50: class ValueType ;
51:
|
54:
55: enum class AccessControl { Public , Protected , Private , Global , Namespace , Argument , Local , Throw } ;
56:
|
59:
60: struct Dimension {
61: Dimension ( ) : tok@var1099 ( nullptr ) , num@var1100 ( 0 ) , known@var1101 ( true ) { }
62:
63: const Token * tok@var1099 ;
64: long long num@var1100 ;
65: bool known@var1101 ;
66: } ;
67:
68:
69: class Type {
70: public:
71: const Token * classDef@var1102 ;
72: const Scope * classScope@var1103 ;
73: const Scope * enclosingScope@var1104 ;
74: enum class NeedInitialization {
75: Unknown , True , False
76: } ; enum NeedInitialization needInitialization@var1105 ;
77:
78: class BaseInfo {
79: public:
80: BaseInfo ( ) :
81: type@var1107 ( nullptr ) , nameTok@var1108 ( nullptr ) , access@var1109 ( AccessControl :: Public ) , isVirtual@var1110 ( false ) { }
82:
83: std :: string name@var1106 ;
84: const Type * type@var1107 ;
85: const Token * nameTok@var1108 ;
86: AccessControl access@var1109 ;
87: bool isVirtual@var1110 ;
88:
89: bool operator< ( const BaseInfo & rhs@var1111 ) const {
90: return this@expr1073745691 .@expr1073745692 type@var1107 <@expr1073745693 rhs@var1111 .@expr1073745694 type@var1112 ;
91: }
92: } ;
93:
94: struct FriendInfo {
95: FriendInfo ( ) :
96: nameStart@var1113 ( nullptr ) , nameEnd@var1114 ( nullptr ) , type@var1115 ( nullptr ) { }
97:
98: const Token * nameStart@var1113 ;
99: const Token * nameEnd@var1114 ;
100: const Type * type@var1115 ;
101: } ;
102:
103: std :: vector < BaseInfo > derivedFrom@var1116 ;
104: std :: vector < FriendInfo > friendList@var1117 ;
105:
106: const Token * typeStart@var1118 ;
107: const Token * typeEnd@var1119 ;
108: long long sizeOf@var1120 ;
109:
110: Type ( const Token * classDef_@var1121 = nullptr , const Scope * classScope_@var1122 = nullptr , const Scope * enclosingScope_@var1123 = nullptr ) :
111: classDef@var1102 ( classDef_@var1121 ) ,
112: classScope@var1103 ( classScope_@var1122 ) ,
113: enclosingScope@var1104 ( enclosingScope_@var1123 ) ,
114: needInitialization@var1105 ( NeedInitialization :: Unknown ) ,
115: typeStart@var1118 ( nullptr ) ,
116: typeEnd@var1119 ( nullptr ) ,
117: sizeOf@var1120 ( 0 ) {
118: if (@expr1073745695 classDef_@var1121 &&@expr1073745696 classDef_@var1121 .@expr3873 str (@expr3874 ) ==@expr1073745699 "enum" ) {
119: needInitialization@var1105 =@expr1073745700 NeedInitialization ::@expr1073745701 True ; }
120: else { if (@expr1073745702 classDef_@var1121 &&@expr1073745703 classDef_@var1121 .@expr3873 str (@expr3874 ) ==@expr1073745706 "using" ) {
121: typeStart@var1118 =@expr1073745707 classDef@var1102 .@expr1073745708 tokAt (@expr1073745709 3 ) ;
122: typeEnd@var1119 =@expr1073745710 typeStart@var1118 ;
123: while (@expr1073745711 typeEnd@var1119 .@expr3888 next (@expr3889 ) &&@expr1073745714 typeEnd@var1119 .@expr3888 next (@expr3889 ) .@expr1073745717 str (@expr1073745718 ) !=@expr1073745719 ";" ) {
124: typeEnd@var1119 =@expr1073745720 typeEnd@var1119 .@expr3888 next (@expr3889 ) ; }
125: } }
126: }
127:
128: const std :: string & name ( ) const ;
129:
130: const std :: string & type ( ) const {
131: return classDef@var1102 ?@expr1073745723 classDef@var1102 .@expr1073745724 str (@expr1073745725 ) :@expr1073745726 emptyString@var1 ;
132: }
133:
134: bool isClassType ( ) const ;
135: bool isEnumType ( ) const ;
136: bool isStructType ( ) const ;
137: bool isUnionType ( ) const ;
138:
139: bool isTypeAlias ( ) const {
140: return classDef@var1102 &&@expr1073745727 classDef@var1102 .@expr1073745728 str (@expr1073745729 ) ==@expr1073745730 "using" ;
141: }
142:
143: const Token * initBaseInfo ( const Token * tok@var1124 , const Token * tok1@var1125 ) ;
144:
145: const Function * getFunction ( const std :: string & funcName@var1126 ) const ;
146:
|
151:
152: bool hasCircularDependencies ( std :: set < BaseInfo > * ancestors@var1127 = nullptr ) const ;
153:
|
158:
159: bool findDependency ( const Type * ancestor@var1128 ) const ;
160:
161: bool isDerivedFrom ( const std :: string & ancestor@var1129 ) const ;
162: } ;
163:
164: class Enumerator {
165: public:
166: explicit Enumerator ( const Scope * scope_@var1130 ) : scope@var1131 ( scope_@var1130 ) , name@var1132 ( nullptr ) , value@var1133 ( 0 ) , start@var1134 ( nullptr ) , end@var1135 ( nullptr ) , value_known@var1136 ( false ) { }
167: const Scope * scope@var1131 ;
168: const Token * name@var1132 ;
169: long long value@var1133 ;
170: const Token * start@var1134 ;
171: const Token * end@var1135 ;
172: bool value_known@var1136 ;
173: } ;
174:
175:
176: class Variable {
177:
178: enum Anonymous2 {
179: fIsMutable = ( 1 << 0 ) ,
180: fIsStatic = ( 1 << 1 ) ,
181: fIsConst = ( 1 << 2 ) ,
182: fIsExtern = ( 1 << 3 ) ,
183: fIsClass = ( 1 << 4 ) ,
184: fIsArray = ( 1 << 5 ) ,
185: fIsPointer = ( 1 << 6 ) ,
186: fIsReference = ( 1 << 7 ) ,
187: fIsRValueRef = ( 1 << 8 ) ,
188: fHasDefault = ( 1 << 9 ) ,
189: fIsStlType = ( 1 << 10 ) ,
190: fIsStlString = ( 1 << 11 ) ,
191: fIsFloatType = ( 1 << 12 ) ,
192: fIsVolatile = ( 1 << 13 ) ,
193: fIsSmartPointer = ( 1 << 14 ) ,
194: fIsMaybeUnused = ( 1 << 15 ) ,
195: fIsInit = ( 1 << 16 ) ,
196: } ;
197:
|
202:
203: bool getFlag ( unsigned int flag_@var1137 ) const {
204: return (@expr3907 (@expr3907 mFlags@var1173 &@expr1073745733 flag_@var1137 ) !=@expr1073745734 0 ) ;
205: }
206:
|
211:
212: void setFlag ( unsigned int flag_@var1138 , bool state_@var1139 ) {
213: mFlags@var1173 =@expr1073745735 state_@var1139 ?@expr1073745736 mFlags@var1173 |@expr1073745737 flag_@var1138 :@expr1073745738 mFlags@var1173 &@expr1073745739 ~@expr1073745740 flag_@var1138 ;
214: }
215:
|
221:
222: bool arrayDimensions ( const Settings * settings@var1140 , bool * isContainer@var1141 ) ;
223:
224: public:
225: Variable ( const Token * name_@var1142 , const Token * start_@var1143 , const Token * end_@var1144 ,
226: int index_@var1145 , AccessControl access_@var1146 , const Type * type_@var1147 ,
227: const Scope * scope_@var1148 , const Settings * settings@var1149 )
228: : mNameToken@var1168 ( name_@var1142 ) ,
229: mTypeStartToken@var1169 ( start_@var1143 ) ,
230: mTypeEndToken@var1170 ( end_@var1144 ) ,
231: mIndex@var1171 ( index_@var1145 ) ,
232: mAccess@var1172 ( access_@var1146 ) ,
233: mFlags@var1173 ( 0 ) ,
234: mType@var1174 ( type_@var1147 ) ,
235: mScope@var1175 ( scope_@var1148 ) ,
236: mValueType@var1176 ( nullptr ) {
237: evaluate (@expr1073745741 settings@var1149 ) ;
238: }
239:
240: Variable ( const Token * name_@var1150 , const std :: string & clangType@var1151 , const Token * typeStart@var1152 ,
241: const Token * typeEnd@var1153 , int index_@var1154 , AccessControl access_@var1155 ,
242: const Type * type_@var1156 , const Scope * scope_@var1157 ) ;
243:
244: Variable ( const Variable & var@var1158 , const Scope * scope@var1159 ) ;
245:
246: Variable ( const Variable & var@var1160 ) ;
247:
248: ~ Variable ( ) ;
249:
250: Variable & operator= ( const Variable & var@var1161 ) ;
251:
|
255:
256: const Token * nameToken ( ) const {
257: return mNameToken@var1168 ;
258: }
259:
|
267:
268: const Token * typeStartToken ( ) const {
269: return mTypeStartToken@var1169 ;
270: }
271:
|
279:
280: const Token * typeEndToken ( ) const {
281: return mTypeEndToken@var1170 ;
282: }
283:
|
290:
291: const Token * declEndToken ( ) const ;
292:
|
296:
297: const std :: string & name ( ) const {
298:
299: if (@expr1073745742 mNameToken@var1168 ) {
300: return mNameToken@var1168 .@expr1073745743 str (@expr1073745744 ) ; }
301:
302: return emptyString@var1 ;
303: }
304:
|
308:
309: int declarationId ( ) const {
310:
311: if (@expr1073745745 mNameToken@var1168 ) {
312: return mNameToken@var1168 .@expr1073745746 varId (@expr1073745747 ) ; }
313:
314: return 0 ;
315: }
316:
|
320:
321: int index ( ) const {
322: return mIndex@var1171 ;
323: }
324:
|
328:
329: bool isPublic ( ) const {
330: return mAccess@var1172 ==@expr1073745748 AccessControl ::@expr1073745749 Public ;
331: }
332:
|
336:
337: bool isProtected ( ) const {
338: return mAccess@var1172 ==@expr1073745750 AccessControl ::@expr1073745751 Protected ;
339: }
340:
|
344:
345: bool isPrivate ( ) const {
346: return mAccess@var1172 ==@expr1073745752 AccessControl ::@expr1073745753 Private ;
347: }
348:
|
352:
353: bool isGlobal ( ) const {
354: return mAccess@var1172 ==@expr1073745754 AccessControl ::@expr1073745755 Global ;
355: }
356:
|
360:
361: bool isNamespace ( ) const {
362: return mAccess@var1172 ==@expr1073745756 AccessControl ::@expr1073745757 Namespace ;
363: }
364:
|
368:
369: bool isArgument ( ) const {
370: return mAccess@var1172 ==@expr1073745758 AccessControl ::@expr1073745759 Argument ;
371: }
372:
|
376:
377: bool isLocal ( ) const {
378: return (@expr1073745761 mAccess@var1172 ==@expr1073745762 AccessControl ::@expr1073745763 Local@expr1073745760 ) &&@expr1073745764 !@expr1073745765 isExtern (@expr1073745766 ) ;
379: }
380:
|
384:
385: bool isMutable ( ) const {
386: return getFlag (@expr1073745767 fIsMutable ) ;
387: }
388:
|
392:
393: bool isVolatile ( ) const {
394: return getFlag (@expr1073745768 fIsVolatile ) ;
395: }
396:
|
400:
401: bool isStatic ( ) const {
402: return getFlag (@expr1073745769 fIsStatic ) ;
403: }
404:
|
408:
409: bool isExtern ( ) const {
410: return getFlag (@expr1073745770 fIsExtern ) ;
411: }
412:
|
416:
417: bool isConst ( ) const {
418: return getFlag (@expr1073745771 fIsConst ) ;
419: }
420:
|
424:
425: bool isThrow ( ) const {
426: return mAccess@var1172 ==@expr1073745772 AccessControl ::@expr1073745773 Throw ;
427: }
428:
|
432:
433: bool isClass ( ) const {
434: return getFlag (@expr1073745774 fIsClass ) ;
435: }
436:
|
440:
441: bool isArray ( ) const {
442: return getFlag (@expr1073745775 fIsArray ) &&@expr1073745776 !@expr1073745777 getFlag (@expr1073745778 fIsPointer ) ;
443: }
444:
|
448:
449: bool isPointer ( ) const {
450: return getFlag (@expr1073745779 fIsPointer ) ;
451: }
452:
|
456:
457: bool isPointerToArray ( ) const {
458: return isPointer (@expr1073745780 ) &&@expr1073745781 getFlag (@expr1073745782 fIsArray ) ;
459: }
460:
|
464:
465: bool isPointerArray ( ) const ;
466:
|
470:
471: bool isArrayOrPointer ( ) const {
472: return getFlag (@expr1073745783 fIsArray ) ||@expr1073745784 getFlag (@expr1073745785 fIsPointer ) ;
473: }
474:
|
478:
479: bool isReference ( ) const {
480: return getFlag (@expr1073745786 fIsReference ) ;
481: }
482:
|
486:
487: bool isRValueReference ( ) const {
488: return getFlag (@expr1073745787 fIsRValueRef ) ;
489: }
490:
|
494:
495: bool isUnsigned ( ) const ;
496:
|
500:
501: bool hasDefault ( ) const {
502: return getFlag (@expr1073745788 fHasDefault ) ;
503: }
504:
|
508:
509: bool isInit ( ) const {
510: return getFlag (@expr1073745789 fIsInit ) ;
511: }
512:
|
516:
517: const Type * type ( ) const {
518: return mType@var1174 ;
519: }
520:
|
524:
525: const Scope * typeScope ( ) const {
526: return mType@var1174 ?@expr1073745790 mType@var1174 .@expr1073745791 classScope@var1179 :@expr1073745792 nullptr ;
527: }
528:
|
532:
533: const Scope * scope ( ) const {
534: return mScope@var1175 ;
535: }
536:
|
540:
541: const std :: vector < Dimension > & dimensions ( ) const {
542: return mDimensions@var1177 ;
543: }
544:
|
548:
549: long long dimension ( int index_@var1162 ) const {
550: return mDimensions@var1177 [@expr1073745793 index_@var1162 ] .@expr1073745794 num@var2513 ;
551: }
552:
|
556:
557: bool dimensionKnown ( int index_@var1163 ) const {
558: return mDimensions@var1177 [@expr1073745795 index_@var1163 ] .@expr1073745796 known@var2514 ;
559: }
560:
|
568:
569: bool isStlType ( ) const {
570: return getFlag (@expr1073745797 fIsStlType ) ;
571: }
572:
|
580:
581: bool isStlStringType ( ) const {
582: return getFlag (@expr1073745798 fIsStlString ) ;
583: }
584:
585: bool isSmartPointer ( ) const {
586: return getFlag (@expr1073745799 fIsSmartPointer ) ;
587: }
588:
589: const Type * smartPointerType ( ) const ;
590:
|
600:
601: bool isStlType ( const std :: string & stlType@var1164 ) const {
602: return isStlType (@expr1073745800 ) &&@expr1073745801 stlType@var1164 ==@expr1073745802 mTypeStartToken@var1169 .@expr1073745803 strAt (@expr1073745804 2 ) ;
603: }
604:
|
614:
615: bool isStlType ( const std :: set < std :: string > & stlTypes@var1165 ) const {
616: return isStlType (@expr1073745805 ) &&@expr1073745806 stlTypes@var1165 .@expr1073745807 find (@expr1073745808 mTypeStartToken@var1169 .@expr1073745809 strAt (@expr1073745810 2 ) ) !=@expr1073745811 stlTypes@var1165 .@expr1073745812 end (@expr1073745813 ) ;
617: }
618:
|
622:
623: bool isFloatingType ( ) const {
624: return getFlag (@expr1073745814 fIsFloatType ) ;
625: }
626:
|
630:
631: bool isEnumType ( ) const {
632: return type (@expr3991 ) &&@expr1073745816 type (@expr3991 ) .@expr1073745818 isEnumType (@expr1073745819 ) ;
633: }
634:
635: bool isMaybeUnused ( ) const {
636: return getFlag (@expr1073745820 fIsMaybeUnused ) ;
637: }
638:
639: const ValueType * valueType ( ) const {
640: return mValueType@var1176 ;
641: }
642:
643: void setValueType ( const ValueType & valueType@var1166 ) ;
644:
645: AccessControl accessControl ( ) const {
646: return mAccess@var1172 ;
647: }
648:
649: std :: string getTypeName ( ) const ;
650:
651: private:
652:
653: friend class SymbolDatabase ;
654:
|
658:
659: void type ( const Type * t@var1167 ) {
660: mType@var1174 =@expr1073745821 t@var1167 ;
661: }
662:
663:
664: const Token * mNameToken@var1168 ;
665:
666:
667: const Token * mTypeStartToken@var1169 ;
668:
669:
670: const Token * mTypeEndToken@var1170 ;
671:
672:
673: int mIndex@var1171 ;
674:
675:
676: AccessControl mAccess@var1172 ;
677:
678:
679: unsigned int mFlags@var1173 ;
680:
681:
682: const Type * mType@var1174 ;
683:
684:
685: const Scope * mScope@var1175 ;
686:
687: ValueType * mValueType@var1176 ;
688:
689:
690: std :: vector < Dimension > mDimensions@var1177 ;
691:
692:
693: void evaluate ( const Settings * settings@var1178 ) ;
694: } ;
695:
696: class Function {
697:
698: friend class SymbolDatabase ;
699:
700:
701: enum Anonymous3 {
702: fHasBody = ( 1 << 0 ) ,
703: fIsInline = ( 1 << 1 ) ,
704: fIsConst = ( 1 << 2 ) ,
705: fHasVirtualSpecifier = ( 1 << 3 ) ,
706: fIsPure = ( 1 << 4 ) ,
707: fIsStatic = ( 1 << 5 ) ,
708: fIsStaticLocal = ( 1 << 6 ) ,
709: fIsExtern = ( 1 << 7 ) ,
710: fIsFriend = ( 1 << 8 ) ,
711: fIsExplicit = ( 1 << 9 ) ,
712: fIsDefault = ( 1 << 10 ) ,
713: fIsDelete = ( 1 << 11 ) ,
714: fHasOverrideSpecifier = ( 1 << 12 ) ,
715: fHasFinalSpecifier = ( 1 << 13 ) ,
716: fIsNoExcept = ( 1 << 14 ) ,
717: fIsThrow = ( 1 << 15 ) ,
718: fIsOperator = ( 1 << 16 ) ,
719: fHasLvalRefQual = ( 1 << 17 ) ,
720: fHasRvalRefQual = ( 1 << 18 ) ,
721: fIsVariadic = ( 1 << 19 ) ,
722: fIsVolatile = ( 1 << 20 ) ,
723: fHasTrailingReturnType = ( 1 << 21 ) ,
724: fIsEscapeFunction = ( 1 << 22 ) ,
725: fIsInlineKeyword = ( 1 << 23 ) ,
726: fIsConstexpr = ( 1 << 24 ) ,
727: } ;
728:
|
733:
734: bool getFlag ( unsigned int flag@var1180 ) const {
735: return (@expr3998 (@expr3998 mFlags@var1229 &@expr1073745824 flag@var1180 ) !=@expr1073745825 0 ) ;
736: }
737:
|
742:
743: void setFlag ( unsigned int flag@var1181 , bool state@var1182 ) {
744: mFlags@var1229 =@expr1073745826 state@var1182 ?@expr1073745827 mFlags@var1229 |@expr1073745828 flag@var1181 :@expr1073745829 mFlags@var1229 &@expr1073745830 ~@expr1073745831 flag@var1181 ;
745: }
746:
747: public:
748: enum Type { eConstructor , eCopyConstructor , eMoveConstructor , eOperatorEqual , eDestructor , eFunction , eLambda } ;
749:
750: Function ( const Tokenizer * mTokenizer@var1183 , const Token * tok@var1184 , const Scope * scope@var1185 , const Token * tokDef@var1186 , const Token * tokArgDef@var1187 ) ;
751: Function ( const Token * tokenDef@var1188 , const std :: string & clangType@var1189 ) ;
752:
753: const std :: string & name ( ) const {
754: return tokenDef@var1199 .@expr1073745832 str (@expr1073745833 ) ;
755: }
756:
757: std :: string fullName ( ) const ;
758:
759: int argCount ( ) const {
760: return argumentList@var1207 .@expr1073745834 size (@expr1073745835 ) ;
761: }
762: int minArgCount ( ) const {
763: return argumentList@var1207 .@expr1073745836 size (@expr1073745837 ) -@expr1073745838 initArgCount@var1208 ;
764: }
765: const Variable * getArgumentVar ( int num@var1190 ) const ;
766: int initializedArgCount ( ) const {
767: return initArgCount@var1208 ;
768: }
769: void addArguments ( const SymbolDatabase * symbolDatabase@var1191 , const Scope * scope@var1192 ) ;
770:
771:
772: bool isImplicitlyVirtual ( bool defaultVal@var1193 = false ) const ;
773:
774: std :: vector < const Function * > getOverloadedFunctions ( ) const ;
775:
776:
777: const Function * getOverriddenFunction ( bool * foundAllBaseClasses@var1194 = nullptr ) const ;
778:
779: bool isLambda ( ) const {
780: return type@var1209 ==@expr1073745839 eLambda ;
781: }
782:
783: bool isConstructor ( ) const {
784: return type@var1209 ==@expr1073745840 eConstructor ||@expr1073745841
785: type@var1209 ==@expr1073745842 eCopyConstructor ||@expr1073745843
786: type@var1209 ==@expr1073745844 eMoveConstructor ;
787: }
788:
789: bool isDestructor ( ) const {
790: return type@var1209 ==@expr1073745845 eDestructor ;
791: }
792: bool isAttributeConstructor ( ) const {
793: return tokenDef@var1199 .@expr1073745846 isAttributeConstructor (@expr1073745847 ) ;
794: }
795: bool isAttributeDestructor ( ) const {
796: return tokenDef@var1199 .@expr1073745848 isAttributeDestructor (@expr1073745849 ) ;
797: }
798: bool isAttributePure ( ) const {
799: return tokenDef@var1199 .@expr1073745850 isAttributePure (@expr1073745851 ) ;
800: }
801: bool isAttributeConst ( ) const {
802: return tokenDef@var1199 .@expr1073745852 isAttributeConst (@expr1073745853 ) ;
803: }
804: bool isAttributeNoreturn ( ) const {
805: return tokenDef@var1199 .@expr1073745854 isAttributeNoreturn (@expr1073745855 ) ;
806: }
807: bool isAttributeNothrow ( ) const {
808: return tokenDef@var1199 .@expr1073745856 isAttributeNothrow (@expr1073745857 ) ;
809: }
810: bool isAttributeNodiscard ( ) const {
811: return tokenDef@var1199 .@expr1073745858 isAttributeNodiscard (@expr1073745859 ) ;
812: }
813:
814: bool hasBody ( ) const {
815: return getFlag (@expr1073745860 fHasBody ) ;
816: }
817: bool isInline ( ) const {
818: return getFlag (@expr1073745861 fIsInline ) ;
819: }
820: bool isConst ( ) const {
821: return getFlag (@expr1073745862 fIsConst ) ;
822: }
823: bool hasVirtualSpecifier ( ) const {
824: return getFlag (@expr1073745863 fHasVirtualSpecifier ) ;
825: }
826: bool isPure ( ) const {
827: return getFlag (@expr1073745864 fIsPure ) ;
828: }
829: bool isStatic ( ) const {
830: return getFlag (@expr1073745865 fIsStatic ) ;
831: }
832: bool isStaticLocal ( ) const {
833: return getFlag (@expr1073745866 fIsStaticLocal ) ;
834: }
835: bool isExtern ( ) const {
836: return getFlag (@expr1073745867 fIsExtern ) ;
837: }
838: bool isFriend ( ) const {
839: return getFlag (@expr1073745868 fIsFriend ) ;
840: }
841: bool isExplicit ( ) const {
842: return getFlag (@expr1073745869 fIsExplicit ) ;
843: }
844: bool isDefault ( ) const {
845: return getFlag (@expr1073745870 fIsDefault ) ;
846: }
847: bool isDelete ( ) const {
848: return getFlag (@expr1073745871 fIsDelete ) ;
849: }
850: bool isNoExcept ( ) const {
851: return getFlag (@expr1073745872 fIsNoExcept ) ;
852: }
853: bool isThrow ( ) const {
854: return getFlag (@expr1073745873 fIsThrow ) ;
855: }
856: bool hasOverrideSpecifier ( ) const {
857: return getFlag (@expr1073745874 fHasOverrideSpecifier ) ;
858: }
859: bool hasFinalSpecifier ( ) const {
860: return getFlag (@expr1073745875 fHasFinalSpecifier ) ;
861: }
862: bool isOperator ( ) const {
863: return getFlag (@expr1073745876 fIsOperator ) ;
864: }
865: bool hasLvalRefQualifier ( ) const {
866: return getFlag (@expr1073745877 fHasLvalRefQual ) ;
867: }
868: bool hasRvalRefQualifier ( ) const {
869: return getFlag (@expr1073745878 fHasRvalRefQual ) ;
870: }
871: bool isVariadic ( ) const {
872: return getFlag (@expr1073745879 fIsVariadic ) ;
873: }
874: bool isVolatile ( ) const {
875: return getFlag (@expr1073745880 fIsVolatile ) ;
876: }
877: bool hasTrailingReturnType ( ) const {
878: return getFlag (@expr1073745881 fHasTrailingReturnType ) ;
879: }
880: void hasBody ( bool state@var1195 ) {
881: setFlag (@expr1073745882 fHasBody , state@var1195 ) ;
882: }
883: bool isInlineKeyword ( ) const {
884: return getFlag (@expr1073745883 fIsInlineKeyword ) ;
885: }
886:
887: bool isEscapeFunction ( ) const {
888: return getFlag (@expr1073745884 fIsEscapeFunction ) ;
889: }
890: void isEscapeFunction ( bool state@var1196 ) {
891: setFlag (@expr1073745885 fIsEscapeFunction , state@var1196 ) ;
892: }
893:
894: bool isConstexpr ( ) const {
895: return getFlag (@expr1073745886 fIsConstexpr ) ;
896: }
897: void isConstexpr ( bool state@var1197 ) {
898: setFlag (@expr1073745887 fIsConstexpr , state@var1197 ) ;
899: }
900: bool isSafe ( const Settings * settings@var1198 ) const ;
901:
902: const Token * tokenDef@var1199 ;
903: const Token * argDef@var1200 ;
904: const Token * token@var1201 ;
905: const Token * arg@var1202 ;
906: const Token * retDef@var1203 ;
907: const :: Type * retType@var1204 ;
908: const Scope * functionScope@var1205 ;
909: const Scope * nestedIn@var1206 ;
910: std :: list < Variable > argumentList@var1207 ;
911: int initArgCount@var1208 ;
912: Type type@var1209 ;
913: AccessControl access@var1210 ;
914: const Token * noexceptArg@var1211 ;
915: const Token * throwArg@var1212 ;
916: const Token * templateDef@var1213 ;
917: const Token * functionPointerUsage@var1214 ;
918:
919: bool argsMatch ( const Scope * scope@var1215 , const Token * first@var1216 , const Token * second@var1217 , const std :: string & path@var1218 , int path_length@var1219 ) const ;
920:
921: static bool returnsConst ( const Function * function@var1220 , bool unknown@var1221 = false ) ;
922:
923: static bool returnsReference ( const Function * function@var1222 , bool unknown@var1223 = false ) ;
924:
925: static bool returnsVoid ( const Function * function@var1224 , bool unknown@var1225 = false ) ;
926:
927: static std :: vector < const Token * > findReturns ( const Function * f@var1226 ) ;
928:
929: const Token * returnDefEnd ( ) const {
930: if (@expr1073745888 this@expr1073745889 .@expr1073745890 hasTrailingReturnType (@expr1073745891 ) ) {
931: return Token ::@expr1073745892 findmatch (@expr1073745893 retDef@var1203 , "{|;" ) ;
932: } else {
933: return tokenDef@var1199 ;
934: }
935: }
936:
|
940:
941: const Token * constructorMemberInitialization ( ) const ;
942:
943: private:
944:
945: const Function * getOverriddenFunctionRecursive ( const :: Type * baseType@var1227 , bool * foundAllBaseClasses@var1228 ) const ;
946:
947: unsigned int mFlags@var1229 ;
948:
949: void isInline ( bool state@var1230 ) {
950: setFlag (@expr1073745894 fIsInline , state@var1230 ) ;
951: }
952: void isConst ( bool state@var1231 ) {
953: setFlag (@expr1073745895 fIsConst , state@var1231 ) ;
954: }
955: void hasVirtualSpecifier ( bool state@var1232 ) {
956: setFlag (@expr1073745896 fHasVirtualSpecifier , state@var1232 ) ;
957: }
958: void isPure ( bool state@var1233 ) {
959: setFlag (@expr1073745897 fIsPure , state@var1233 ) ;
960: }
961: void isStatic ( bool state@var1234 ) {
962: setFlag (@expr1073745898 fIsStatic , state@var1234 ) ;
963: }
964: void isStaticLocal ( bool state@var1235 ) {
965: setFlag (@expr1073745899 fIsStaticLocal , state@var1235 ) ;
966: }
967: void isExtern ( bool state@var1236 ) {
968: setFlag (@expr1073745900 fIsExtern , state@var1236 ) ;
969: }
970: void isFriend ( bool state@var1237 ) {
971: setFlag (@expr1073745901 fIsFriend , state@var1237 ) ;
972: }
973: void isExplicit ( bool state@var1238 ) {
974: setFlag (@expr1073745902 fIsExplicit , state@var1238 ) ;
975: }
976: void isDefault ( bool state@var1239 ) {
977: setFlag (@expr1073745903 fIsDefault , state@var1239 ) ;
978: }
979: void isDelete ( bool state@var1240 ) {
980: setFlag (@expr1073745904 fIsDelete , state@var1240 ) ;
981: }
982: void isNoExcept ( bool state@var1241 ) {
983: setFlag (@expr1073745905 fIsNoExcept , state@var1241 ) ;
984: }
985: void isThrow ( bool state@var1242 ) {
986: setFlag (@expr1073745906 fIsThrow , state@var1242 ) ;
987: }
988: void isOperator ( bool state@var1243 ) {
989: setFlag (@expr1073745907 fIsOperator , state@var1243 ) ;
990: }
991: void hasLvalRefQualifier ( bool state@var1244 ) {
992: setFlag (@expr1073745908 fHasLvalRefQual , state@var1244 ) ;
993: }
994: void hasRvalRefQualifier ( bool state@var1245 ) {
995: setFlag (@expr1073745909 fHasRvalRefQual , state@var1245 ) ;
996: }
997: void isVariadic ( bool state@var1246 ) {
998: setFlag (@expr1073745910 fIsVariadic , state@var1246 ) ;
999: }
1000: void isVolatile ( bool state@var1247 ) {
1001: setFlag (@expr1073745911 fIsVolatile , state@var1247 ) ;
1002: }
1003: void hasTrailingReturnType ( bool state@var1248 ) {
1004: return setFlag (@expr1073745912 fHasTrailingReturnType , state@var1248 ) ;
1005: }
1006: void isInlineKeyword ( bool state@var1249 ) {
1007: setFlag (@expr1073745913 fIsInlineKeyword , state@var1249 ) ;
1008: }
1009: const Token * setFlags ( const Token * tok1@var1250 , const Scope * scope@var1251 ) ;
1010: } ;
1011:
1012: class Scope {
1013:
1014: friend class TestSymbolDatabase ;
1015:
1016: public:
1017: struct UsingInfo {
1018: const Token * start@var1252 ;
1019: const Scope * scope@var1253 ;
1020: } ;
1021:
1022: enum ScopeType { eGlobal , eClass , eStruct , eUnion , eNamespace , eFunction , eIf , eElse , eFor , eWhile , eDo , eSwitch , eUnconditional , eTry , eCatch , eLambda , eEnum } ;
1023:
1024: Scope ( const SymbolDatabase * check_@var1254 , const Token * classDef_@var1255 , const Scope * nestedIn_@var1256 ) ;
1025: Scope ( const SymbolDatabase * check_@var1257 , const Token * classDef_@var1258 , const Scope * nestedIn_@var1259 , ScopeType type_@var1260 , const Token * start_@var1261 ) ;
1026:
1027: const SymbolDatabase * check@var1262 ;
1028: std :: string className@var1263 ;
1029: const Token * classDef@var1264 ;
1030: const Token * bodyStart@var1265 ;
1031: const Token * bodyEnd@var1266 ;
1032: std :: list < Function > functionList@var1267 ;
1033: std :: multimap < std :: string , const Function * > functionMap@var1268 ;
1034: std :: list < Variable > varlist@var1269 ;
1035: const Scope * nestedIn@var1270 ;
1036: std :: list < Scope * > nestedList@var1271 ;
1037: int numConstructors@var1272 ;
1038: int numCopyOrMoveConstructors@var1273 ;
1039: std :: list < UsingInfo > usingList@var1274 ;
1040: ScopeType type@var1275 ;
1041: Type * definedType@var1276 ;
1042: std :: map < std :: string , Type * > definedTypesMap@var1277 ;
1043: std :: vector < const Token * > bodyStartList@var1278 ;
1044:
1045:
1046: const Scope * functionOf@var1279 ;
1047: Function * function@var1280 ;
1048:
1049:
1050: const Token * enumType@var1281 ;
1051: bool enumClass@var1282 ;
1052:
1053: std :: vector < Enumerator > enumeratorList@var1283 ;
1054:
1055: void setBodyStartEnd ( const Token * start@var1284 ) {
1056: bodyStart@var1265 =@expr1073745914 start@var1284 ;
1057: bodyEnd@var1266 =@expr1073745915 start@var1284 ?@expr1073745916 start@var1284 .@expr1073745917 link (@expr1073745918 ) :@expr1073745919 nullptr ;
1058: if (@expr1073745920 start@var1284 ) {
1059: bodyStartList@var1278 .@expr1073745921 push_back (@expr1073745922 start@var1284 ) ; }
1060: }
1061:
1062: bool isAnonymous ( ) const {
1063:
1064: return className@var1263 .@expr1073745923 size (@expr1073745924 ) >@expr1073745925 9 &&@expr1073745926 className@var1263 .@expr1073745927 compare (@expr1073745928 0 , 9 , "Anonymous" ) ==@expr1073745929 0 &&@expr1073745930 std ::@expr1073745931 isdigit (@expr1073745932 className@var1263 [@expr1073745933 9 ] ) ;
1065: }
1066:
1067: const Enumerator * findEnumerator ( const std :: string & name@var1285 ) const {
1068: for (@expr1073745934 const Enumerator &@expr1073745935 i@var1286 :@expr1073745936 enumeratorList@var1283 ) {
1069: if (@expr1073745937 i@var1286 .@expr1073745938 name@var1287 .@expr1073745939 str (@expr1073745940 ) ==@expr1073745941 name@var1285 ) {
1070: return &@expr1073745942 i@var1286 ; }
1071: }
1072: return nullptr ;
1073: }
1074:
1075: bool isNestedIn ( const Scope * outer@var1288 ) const {
1076: if (@expr1073745943 !@expr1073745944 outer@var1288 ) {
1077: return false ; }
1078: if (@expr1073745945 outer@var1288 ==@expr1073745946 this@expr1073745947 ) {
1079: return true ; }
1080: const Scope * parent@var1289 ; parent@var1289 =@expr1073745948 nestedIn@var1270 ;
1081: while (@expr1073745949 outer@var1288 !=@expr1073745950 parent@var1289 &&@expr1073745951 parent@var1289 ) {
1082: parent@var1289 =@expr1073745952 parent@var1289 .@expr1073745953 nestedIn@var1290 ; }
1083: if (@expr1073745954 parent@var1289 &&@expr1073745955 parent@var1289 ==@expr1073745956 outer@var1288 ) {
1084: return true ; }
1085: return false ;
1086: }
1087:
1088: static Function * nestedInFunction ( const Scope * scope@var1291 ) {
1089: while (@expr1073745957 scope@var1291 ) {
1090: if (@expr1073745958 scope@var1291 .@expr1073745959 type@var1292 ==@expr1073745960 Scope ::@expr1073745961 eFunction ) {
1091: break ; }
1092: scope@var1291 =@expr1073745962 scope@var1291 .@expr1073745963 nestedIn@var1293 ;
1093: }
1094: if (@expr1073745964 !@expr1073745965 scope@var1291 ) {
1095: return nullptr ; }
1096: return scope@var1291 .@expr1073745966 function@var1294 ;
1097: }
1098:
1099: bool isClassOrStruct ( ) const {
1100: return (@expr1073745967 type@var1275 ==@expr1073745968 eClass ||@expr1073745969 type@var1275 ==@expr1073745970 eStruct ) ;
1101: }
1102:
1103: bool isClassOrStructOrUnion ( ) const {
1104: return (@expr1073745971 type@var1275 ==@expr1073745972 eClass ||@expr1073745973 type@var1275 ==@expr1073745974 eStruct ||@expr1073745975 type@var1275 ==@expr1073745976 eUnion ) ;
1105: }
1106:
1107: bool isExecutable ( ) const {
1108: return type@var1275 !=@expr1073745977 eClass &&@expr1073745978 type@var1275 !=@expr1073745979 eStruct &&@expr1073745980 type@var1275 !=@expr1073745981 eUnion &&@expr1073745982 type@var1275 !=@expr1073745983 eGlobal &&@expr1073745984 type@var1275 !=@expr1073745985 eNamespace &&@expr1073745986 type@var1275 !=@expr1073745987 eEnum ;
1109: }
1110:
1111: bool isLoopScope ( ) const {
1112: return type@var1275 ==@expr1073745988 Scope ::@expr4165 ScopeType ::@expr1073745990 eFor ||@expr1073745991 type@var1275 ==@expr1073745992 Scope ::@expr4165 ScopeType ::@expr1073745994 eWhile ||@expr1073745995 type@var1275 ==@expr1073745996 Scope ::@expr4165 ScopeType ::@expr1073745998 eDo ;
1113: }
1114:
1115: bool isLocal ( ) const {
1116: return (@expr1073745999 type@var1275 ==@expr1073746000 eIf ||@expr1073746001 type@var1275 ==@expr1073746002 eElse ||@expr1073746003
1117: type@var1275 ==@expr1073746004 eFor ||@expr1073746005 type@var1275 ==@expr1073746006 eWhile ||@expr1073746007 type@var1275 ==@expr1073746008 eDo ||@expr1073746009
1118: type@var1275 ==@expr1073746010 eSwitch ||@expr1073746011 type@var1275 ==@expr1073746012 eUnconditional ||@expr1073746013
1119: type@var1275 ==@expr1073746014 eTry ||@expr1073746015 type@var1275 ==@expr1073746016 eCatch ) ;
1120: }
1121:
1122:
1123: bool hasInlineOrLambdaFunction ( ) const ;
1124:
|
1130:
1131: const Function * findFunction ( const Token * tok@var1295 , bool requireConst@var1296 = false ) const ;
1132:
1133: const Scope * findRecordInNestedList ( const std :: string & name@var1297 , bool isC@var1298 = false ) const ;
1134: Scope * findRecordInNestedList ( const std :: string & name@var1299 ) {
1135: return const_cast < Scope *@expr4193 > (@expr1073746018 const_cast < const Scope *@expr4193 > (@expr1073746020 this@expr1073746021 ) .@expr1073746022 findRecordInNestedList (@expr1073746023 name@var1299 ) ) ;
1136: }
1137:
1138: const Type * findType ( const std :: string & name@var1300 ) const ;
1139: Type * findType ( const std :: string & name@var1301 ) {
1140: return const_cast < Type *@expr4200 > (@expr1073746025 const_cast < const Scope *@expr4200 > (@expr1073746027 this@expr1073746028 ) .@expr1073746029 findType (@expr1073746030 name@var1301 ) ) ;
1141: }
1142:
|
1146:
1147: Scope * findInNestedListRecursive ( const std :: string & name@var1302 ) ;
1148:
1149: void addVariable ( const Token * token_@var1303 , const Token * start_@var1304 ,
1150: const Token * end_@var1305 , AccessControl access_@var1306 , const Type * type_@var1307 ,
1151: const Scope * scope_@var1308 , const Settings * settings@var1309 ) ;
1152:
1153:
1154: void getVariableList ( const Settings * settings@var1310 ) ;
1155:
1156: const Function * getDestructor ( ) const ;
1157:
1158: void addFunction ( const Function & func@var1311 ) {
1159: functionList@var1267 .@expr1073746031 push_back (@expr1073746032 func@var1311 ) ;
1160:
1161: const Function * back@var1312 ; back@var1312 =@expr1073746033 &@expr1073746034 functionList@var1267 .@expr1073746035 back (@expr1073746036 ) ;
1162:
1163: functionMap@var1268 .@expr1073746037 insert (@expr1073746038 make_pair (@expr1073746039 back@var1312 .@expr1073746040 tokenDef@var1313 .@expr1073746041 str (@expr1073746042 ) , back@var1312 ) ) ;
1164: }
1165:
1166: bool hasDefaultConstructor ( ) const ;
1167:
1168: AccessControl defaultAccess ( ) const ;
1169:
|
1176:
1177: const Token * checkVariable ( const Token * tok@var1314 , AccessControl varaccess@var1315 , const Settings * settings@var1316 ) ;
1178:
|
1183:
1184: const Variable * getVariable ( const std :: string & varname@var1317 ) const ;
1185:
1186: const Token * addEnum ( const Token * tok@var1318 , bool isCpp@var1319 ) ;
1187:
1188: const Scope * findRecordInBase ( const std :: string & name@var1320 ) const ;
1189:
1190: std :: vector < const Scope * > findAssociatedScopes ( ) const ;
1191:
1192: private:
1193:
|
1199:
1200: bool isVariableDeclaration ( const Token * const tok@var1321 , const Token * & vartok@var1322 , const Token * & typetok@var1323 ) const ;
1201:
1202: void findFunctionInBase ( const std :: string & name@var1324 , int args@var1325 , std :: vector < const Function * > & matches@var1326 ) const ;
1203:
1204:
1205: void getVariableList ( const Settings * settings@var1327 , const Token * start@var1328 , const Token * end@var1329 ) ;
1206: } ;
1207:
1208: enum class Reference {
1209: None ,
1210: LValue ,
1211: RValue
1212: } ;
1213:
1214:
1215: class ValueType {
1216:
1217: enum Sign { UNKNOWN_SIGN , SIGNED , UNSIGNED } ; public: enum Sign sign@var1330 ;
1218: enum Type {
1219: UNKNOWN_TYPE ,
1220: POD ,
1221: NONSTD ,
1222: RECORD ,
1223: SMART_POINTER ,
1224: CONTAINER ,
1225: ITERATOR ,
1226: VOID ,
1227: BOOL ,
1228: CHAR ,
1229: SHORT ,
1230: WCHAR_T ,
1231: INT ,
1232: LONG ,
1233: LONGLONG ,
1234: UNKNOWN_INT ,
1235: FLOAT ,
1236: DOUBLE ,
1237: LONGDOUBLE
1238: } ; enum Type type@var1331 ;
1239: int bits@var1332 ;
1240: int pointer@var1333 ;
1241: int constness@var1334 ;
1242: Reference reference@var1335 ; reference@var1335 = Reference :: None ;
1243:
1244: const Scope * typeScope@var1336 ;
1245: const :: Type * smartPointerType@var1337 ;
1246: const Token * smartPointerTypeToken@var1338 ;
1247: const Library :: SmartPointer * smartPointer@var1339 ;
1248: const Library :: Container * container@var1340 ;
1249:
1250: const Token * containerTypeToken@var1341 ;
1251:
1252: std :: string originalTypeName@var1342 ;
1253:
1254:
1255: ValueType ( )
1256: : sign@var1330 ( UNKNOWN_SIGN ) ,
1257: type@var1331 ( UNKNOWN_TYPE ) ,
1258: bits@var1332 ( 0 ) ,
1259: pointer@var1333 ( 0U ) ,
1260: constness@var1334 ( 0U ) ,
1261: typeScope@var1336 ( nullptr ) ,
1262: smartPointerType@var1337 ( nullptr ) ,
1263: smartPointerTypeToken@var1338 ( nullptr ) ,
1264: smartPointer@var1339 ( nullptr ) ,
1265: container@var1340 ( nullptr ) ,
1266: containerTypeToken@var1341 ( nullptr )
1267: { }
1268: ValueType ( enum Sign s@var1343 , enum Type t@var1344 , int p@var1345 )
1269: : sign@var1330 ( s@var1343 ) ,
1270: type@var1331 ( t@var1344 ) ,
1271: bits@var1332 ( 0 ) ,
1272: pointer@var1333 ( p@var1345 ) ,
1273: constness@var1334 ( 0U ) ,
1274: typeScope@var1336 ( nullptr ) ,
1275: smartPointerType@var1337 ( nullptr ) ,
1276: smartPointerTypeToken@var1338 ( nullptr ) ,
1277: smartPointer@var1339 ( nullptr ) ,
1278: container@var1340 ( nullptr ) ,
1279: containerTypeToken@var1341 ( nullptr )
1280: { }
1281: ValueType ( enum Sign s@var1346 , enum Type t@var1347 , int p@var1348 , int c@var1349 )
1282: : sign@var1330 ( s@var1346 ) ,
1283: type@var1331 ( t@var1347 ) ,
1284: bits@var1332 ( 0 ) ,
1285: pointer@var1333 ( p@var1348 ) ,
1286: constness@var1334 ( c@var1349 ) ,
1287: typeScope@var1336 ( nullptr ) ,
1288: smartPointerType@var1337 ( nullptr ) ,
1289: smartPointerTypeToken@var1338 ( nullptr ) ,
1290: smartPointer@var1339 ( nullptr ) ,
1291: container@var1340 ( nullptr ) ,
1292: containerTypeToken@var1341 ( nullptr )
1293: { }
1294: ValueType ( enum Sign s@var1350 , enum Type t@var1351 , int p@var1352 , int c@var1353 , const std :: string & otn@var1354 )
1295: : sign@var1330 ( s@var1350 ) ,
1296: type@var1331 ( t@var1351 ) ,
1297: bits@var1332 ( 0 ) ,
1298: pointer@var1333 ( p@var1352 ) ,
1299: constness@var1334 ( c@var1353 ) ,
1300: typeScope@var1336 ( nullptr ) ,
1301: smartPointerType@var1337 ( nullptr ) ,
1302: smartPointerTypeToken@var1338 ( nullptr ) ,
1303: smartPointer@var1339 ( nullptr ) ,
1304: container@var1340 ( nullptr ) ,
1305: containerTypeToken@var1341 ( nullptr ) ,
1306: originalTypeName@var1342 ( otn@var1354 )
1307: { }
1308:
1309: static ValueType parseDecl ( const Token * type@var1355 , const Settings * settings@var1356 ) ;
1310:
1311: static Type typeFromString ( const std :: string & typestr@var1357 , bool longType@var1358 ) ;
1312:
1313: enum class MatchResult { UNKNOWN , SAME , FALLBACK1 , FALLBACK2 , NOMATCH } ;
1314: static MatchResult matchParameter ( const ValueType * call@var1359 , const ValueType * func@var1360 ) ;
1315: static MatchResult matchParameter ( const ValueType * call@var1361 , const Variable * callVar@var1362 , const Variable * funcVar@var1363 ) ;
1316:
1317: bool isPrimitive ( ) const {
1318: return (@expr1073746043 type@var1331 >=@expr1073746044 ValueType ::@expr1073746045 Type ::@expr1073746046 BOOL ) ;
1319: }
1320:
1321: bool isIntegral ( ) const {
1322: return (@expr1073746047 type@var1331 >=@expr1073746048 ValueType ::@expr4225 Type ::@expr1073746050 BOOL &&@expr1073746051 type@var1331 <=@expr1073746052 ValueType ::@expr4225 Type ::@expr1073746054 UNKNOWN_INT ) ;
1323: }
1324:
1325: bool isFloat ( ) const {
1326: return (@expr1073746055 type@var1331 >=@expr1073746056 ValueType ::@expr4233 Type ::@expr1073746058 FLOAT &&@expr1073746059 type@var1331 <=@expr1073746060 ValueType ::@expr4233 Type ::@expr1073746062 LONGDOUBLE ) ;
1327: }
1328:
1329: bool fromLibraryType ( const std :: string & typestr@var1364 , const Settings * settings@var1365 ) ;
1330:
1331: bool isEnum ( ) const {
1332: return typeScope@var1336 &&@expr1073746063 typeScope@var1336 .@expr1073746064 type@var1366 ==@expr1073746065 Scope ::@expr1073746066 eEnum ;
1333: }
1334:
1335: long long typeSize ( const cppcheck :: Platform & platform@var1367 , bool p@var1368 = false ) const ;
1336:
1337:
1338: bool isTypeEqual ( const ValueType * that@var1369 ) const ;
1339:
1340: std :: string str ( ) const ;
1341: std :: string dump ( ) const ;
1342: } ;
1343:
1344:
1345: class SymbolDatabase {
1346: friend class TestSymbolDatabase ;
1347: public:
1348: SymbolDatabase ( const Tokenizer * tokenizer@var1370 , const Settings * settings@var1371 , ErrorLogger * errorLogger@var1372 ) ;
1349: ~ SymbolDatabase ( ) ;
1350:
1351:
1352: std :: list < Scope > scopeList@var1373 ;
1353:
1354:
1355: std :: vector < const Scope * > functionScopes@var1374 ;
1356:
1357:
1358: std :: vector < const Scope * > classAndStructScopes@var1375 ;
1359:
1360:
1361: std :: list < Type > typeList@var1376 ;
1362:
|
1368:
1369: const Type * findVariableType ( const Scope * start@var1377 , const Token * typeTok@var1378 ) const ;
1370:
|
1375:
1376: const Function * findFunction ( const Token * tok@var1379 ) const ;
1377:
1378:
1379: const Scope * findScopeByName ( const std :: string & name@var1380 ) const ;
1380:
1381: const Type * findType ( const Token * startTok@var1381 , const Scope * startScope@var1382 , bool lookOutside@var1383 = false ) const ;
1382: Type * findType ( const Token * startTok@var1384 , Scope * startScope@var1385 , bool lookOutside@var1386 = false ) const {
1383: return const_cast < Type *@expr4243 > (@expr1073746068 this@expr1073746069 .@expr1073746070 findType (@expr1073746071 startTok@var1384 , const_cast < const Scope *@expr4243 > (@expr1073746073 startScope@var1385 ) , lookOutside@var1386 ) ) ;
1384: }
1385:
1386: const Scope * findScope ( const Token * tok@var1387 , const Scope * startScope@var1388 ) const ;
1387: Scope * findScope ( const Token * tok@var1389 , Scope * startScope@var1390 ) const {
1388: return const_cast < Scope *@expr4250 > (@expr1073746075 this@expr1073746076 .@expr1073746077 findScope (@expr1073746078 tok@var1389 , const_cast < const Scope *@expr4250 > (@expr1073746080 startScope@var1390 ) ) ) ;
1389: }
1390:
1391: bool isVarId ( int varid@var1391 ) const {
1392: return varid@var1391 <@expr1073746081 mVariableList@var1448 .@expr1073746082 size (@expr1073746083 ) ;
1393: }
1394:
1395: const Variable * getVariableFromVarId ( int varId@var1392 ) const {
1396: return mVariableList@var1448 .@expr1073746084 at (@expr1073746085 varId@var1392 ) ;
1397: }
1398:
1399: const std :: vector < const Variable * > & variableList ( ) const {
1400: return mVariableList@var1448 ;
1401: }
1402:
|
1405:
1406: void debugMessage ( const Token * tok@var1393 , const std :: string & type@var1394 , const std :: string & msg@var1395 ) const ;
1407:
1408: void printOut ( const char * title@var1396 = nullptr ) const ;
1409: void printVariable ( const Variable * var@var1397 , const char * indent@var1398 ) const ;
1410: void printXml ( std :: ostream & out@var1399 ) const ;
1411:
1412: bool isCPP ( ) const ;
1413:
|
1416:
1417: void validate ( ) const ;
1418:
1419: void validateExecutableScopes ( ) const ;
1420:
1421:
1422:
1423: void validateVariables ( ) const ;
1424:
1425:
1426: void setValueTypeInTokenList ( bool reportDebugWarnings@var1400 , Token * tokens@var1401 = nullptr ) ;
1427:
|
1432:
1433: int sizeOfType ( const Token * type@var1402 ) const ;
1434:
1435:
1436: void setArrayDimensionsUsingValueFlow ( ) ;
1437:
1438: void clangSetVariables ( const std :: vector < const Variable * > & variableList@var1403 ) ;
1439: void createSymbolDatabaseExprIds ( ) ;
1440:
1441: private:
1442: friend class Scope ;
1443: friend class Function ;
1444:
1445:
1446: void createSymbolDatabaseFindAllScopes ( ) ;
1447: void createSymbolDatabaseClassInfo ( ) ;
1448: void createSymbolDatabaseVariableInfo ( ) ;
1449: void createSymbolDatabaseCopyAndMoveConstructors ( ) ;
1450: void createSymbolDatabaseFunctionScopes ( ) ;
1451: void createSymbolDatabaseClassAndStructScopes ( ) ;
1452: void createSymbolDatabaseFunctionReturnTypes ( ) ;
1453: void createSymbolDatabaseNeedInitialization ( ) ;
1454: void createSymbolDatabaseVariableSymbolTable ( ) ;
1455: void createSymbolDatabaseSetScopePointers ( ) ;
1456: void createSymbolDatabaseSetFunctionPointers ( bool firstPass@var1404 ) ;
1457: void createSymbolDatabaseSetVariablePointers ( ) ;
1458:
1459: void createSymbolDatabaseSetTypePointers ( ) ;
1460: void createSymbolDatabaseSetSmartPointerType ( ) ;
1461: void createSymbolDatabaseEnums ( ) ;
1462: void createSymbolDatabaseEscapeFunctions ( ) ;
1463:
1464: void createSymbolDatabaseIncompleteVars ( ) ;
1465:
1466: void addClassFunction ( Scope * * scope@var1405 , const Token * * tok@var1406 , const Token * argStart@var1407 ) ;
1467: Function * addGlobalFunctionDecl ( Scope * & scope@var1408 , const Token * tok@var1409 , const Token * argStart@var1410 , const Token * funcStart@var1411 ) ;
1468: Function * addGlobalFunction ( Scope * & scope@var1412 , const Token * & tok@var1413 , const Token * argStart@var1414 , const Token * funcStart@var1415 ) ;
1469: void addNewFunction ( Scope * * scope@var1416 , const Token * * tok@var1417 ) ;
1470: bool isFunction ( const Token * tok@var1418 , const Scope * outerScope@var1419 , const Token * * funcStart@var1420 , const Token * * argStart@var1421 , const Token * * declEnd@var1422 ) const ;
1471: const Type * findTypeInNested ( const Token * startTok@var1423 , const Scope * startScope@var1424 ) const ;
1472: const Scope * findNamespace ( const Token * tok@var1425 , const Scope * scope@var1426 ) const ;
1473: Function * findFunctionInScope ( const Token * func@var1427 , const Scope * ns@var1428 , const std :: string & path@var1429 , int path_length@var1430 ) ;
1474: const Type * findVariableTypeInBase ( const Scope * scope@var1431 , const Token * typeTok@var1432 ) const ;
1475:
|
1478:
1479: void fixVarId ( std :: map < unsigned int , std :: map < unsigned int , unsigned int > > & varIds@var1433 , const Token * vartok@var1434 , Token * membertok@var1435 , const Variable * membervar@var1436 ) ;
1480:
1481:
1482: bool isReservedName ( const std :: string & iName@var1437 ) const ;
1483:
1484: const Enumerator * findEnumerator ( const Token * tok@var1438 ) const ;
1485:
1486: void setValueType ( Token * tok@var1439 , const ValueType & valuetype@var1440 ) ;
1487: void setValueType ( Token * tok@var1441 , const Variable & var@var1442 ) ;
1488: void setValueType ( Token * tok@var1443 , const Enumerator & enumerator@var1444 ) ;
1489:
1490: const Tokenizer * mTokenizer@var1445 ;
1491: const Settings * mSettings@var1446 ;
1492: ErrorLogger * mErrorLogger@var1447 ;
1493:
1494:
1495: std :: vector < const Variable * > mVariableList@var1448 ;
1496:
1497:
1498: std :: list < Type > mBlankTypes@var1449 ;
1499:
1500: bool mIsCpp@var1450 ;
1501: ValueType :: Sign mDefaultSignedness@var1451 ;
1502:
1503:
1504: mutable std :: set < std :: string > mTokensThatAreNotEnumeratorValues@var1452 ;
1505: } ;

##file cppcheck-2.8/lib/astutils.h

1:
|
34:
35: class Library ;
36: class Settings ;
37: class Token ;
38:
39: enum class ChildrenToVisit {
40: none ,
41: op1 ,
42: op2 ,
43: op1_and_op2 ,
44: done
45: } ;
46:
|
49:
50: template < class T , class TFunc , $class $= $typename $std $:: $enable_if $< std :: is_convertible < T * , const Token * > $:: $value $> $:: $type >
51: void visitAstNodes ( T * ast@var1453 , const TFunc & visitor@var1454 )
52: {
53: if (@expr1073746086 !@expr1073746087 ast@var1453 ) {
54: return ; }
55:
56: std ::@expr1073746088 stack < T *@expr4265 , std ::@expr1073746090 vector < T *@expr4265 > > tokens@var1455 ;
57: T * tok@var1456 ; tok@var1456 =@expr1073746092 ast@var1453 ;
58: do {
59: ChildrenToVisit c@var1457 ; c@var1457 =@expr1073746093 visitor@var1454 (@expr1073746094 tok@var1456 ) ;
60:
61: if (@expr1073746095 c@var1457 ==@expr1073746096 ChildrenToVisit ::@expr1073746097 done ) {
62: break ; }
63: if (@expr1073746098 c@var1457 ==@expr1073746099 ChildrenToVisit ::@expr1073746100 op2 ||@expr1073746101 c@var1457 ==@expr4278 ChildrenToVisit ::@expr4279 op1_and_op2 ) {
64: T * t2@var1458 ; t2@var1458 =@expr1073746104 tok@var1456 .@expr1073746105 astOperand2 (@expr1073746106 ) ;
65: if (@expr1073746107 t2@var1458 ) {
66: tokens@var1455 .@expr4284 push (@expr1073746109 t2@var1458 ) ; }
67: }
68: if (@expr1073746110 c@var1457 ==@expr1073746111 ChildrenToVisit ::@expr1073746112 op1 ||@expr1073746113 c@var1457 ==@expr4278 ChildrenToVisit ::@expr4279 op1_and_op2 ) {
69: T * t1@var1459 ; t1@var1459 =@expr1073746116 tok@var1456 .@expr1073746117 astOperand1 (@expr1073746118 ) ;
70: if (@expr1073746119 t1@var1459 ) {
71: tokens@var1455 .@expr4284 push (@expr1073746121 t1@var1459 ) ; }
72: }
73:
74: if (@expr1073746122 tokens@var1455 .@expr1073746123 empty (@expr1073746124 ) ) {
75: break ; }
76:
77: tok@var1456 =@expr1073746125 tokens@var1455 .@expr1073746126 top (@expr1073746127 ) ;
78: tokens@var1455 .@expr1073746128 pop (@expr1073746129 ) ;
79: } while (@expr1073746130 true ) ;
80: }
81:
82: const Token * findAstNode ( const Token * ast@var1460 , const std :: function < bool ( const Token * ) > & pred@var1461 ) ;
83: const Token * findExpression ( const int exprid@var1462 ,
84: const Token * start@var1463 ,
85: const Token * end@var1464 ,
86: const std :: function < bool ( const Token * ) > & pred@var1465 ) ;
87: const Token * findExpression ( const Token * start@var1466 , const int exprid@var1467 ) ;
88:
89: std :: vector < const Token * > astFlatten ( const Token * tok@var1468 , const char * op@var1469 ) ;
90: std :: vector < Token * > astFlatten ( Token * tok@var1470 , const char * op@var1471 ) ;
91:
92: int astCount ( const Token * tok@var1472 , const char * op@var1473 , int depth@var1474 = 100 ) ;
93:
94: bool astHasToken ( const Token * root@var1475 , const Token * tok@var1476 ) ;
95:
96: bool astHasVar ( const Token * tok@var1477 , int varid@var1478 ) ;
97:
98: bool astIsPrimitive ( const Token * tok@var1479 ) ;
99:
100: bool astIsSignedChar ( const Token * tok@var1480 ) ;
101:
102: bool astIsUnknownSignChar ( const Token * tok@var1481 ) ;
103:
104: bool astIsGenericChar ( const Token * tok@var1482 ) ;
105:
106: bool astIsIntegral ( const Token * tok@var1483 , bool unknown@var1484 ) ;
107: bool astIsUnsigned ( const Token * tok@var1485 ) ;
108:
109: bool astIsFloat ( const Token * tok@var1486 , bool unknown@var1487 ) ;
110:
111: bool astIsBool ( const Token * tok@var1488 ) ;
112:
113: bool astIsPointer ( const Token * tok@var1489 ) ;
114:
115: bool astIsSmartPointer ( const Token * tok@var1490 ) ;
116: bool astIsUniqueSmartPointer ( const Token * tok@var1491 ) ;
117:
118: bool astIsIterator ( const Token * tok@var1492 ) ;
119:
120: bool astIsContainer ( const Token * tok@var1493 ) ;
121:
122: bool astIsContainerView ( const Token * tok@var1494 ) ;
123: bool astIsContainerOwned ( const Token * tok@var1495 ) ;
124:
|
133:
134: std :: string astCanonicalType ( const Token * expr@var1496 ) ;
135:
136:
137: const Token * astIsVariableComparison ( const Token * tok@var1497 , const std :: string & comp@var1498 , const std :: string & rhs@var1499 , const Token * * vartok@var1500 = nullptr ) ;
138:
139: bool isVariableDecl ( const Token * tok@var1501 ) ;
140:
141: bool isTemporary ( bool cpp@var1502 , const Token * tok@var1503 , const Library * library@var1504 , bool unknown@var1505 = false ) ;
142:
143: const Token * previousBeforeAstLeftmostLeaf ( const Token * tok@var1506 ) ;
144: Token * previousBeforeAstLeftmostLeaf ( Token * tok@var1507 ) ;
145:
146: const Token * nextAfterAstRightmostLeaf ( const Token * tok@var1508 ) ;
147: Token * nextAfterAstRightmostLeaf ( Token * tok@var1509 ) ;
148:
149: Token * astParentSkipParens ( Token * tok@var1510 ) ;
150: const Token * astParentSkipParens ( const Token * tok@var1511 ) ;
151:
152: const Token * getParentMember ( const Token * tok@var1512 ) ;
153:
154: const Token * getParentLifetime ( const Token * tok@var1513 ) ;
155: const Token * getParentLifetime ( bool cpp@var1514 , const Token * tok@var1515 , const Library * library@var1516 ) ;
156:
157: bool astIsLHS ( const Token * tok@var1517 ) ;
158: bool astIsRHS ( const Token * tok@var1518 ) ;
159:
160: Token * getCondTok ( Token * tok@var1519 ) ;
161: const Token * getCondTok ( const Token * tok@var1520 ) ;
162:
163: Token * getInitTok ( Token * tok@var1521 ) ;
164: const Token * getInitTok ( const Token * tok@var1522 ) ;
165:
166: Token * getStepTok ( Token * tok@var1523 ) ;
167: const Token * getStepTok ( const Token * tok@var1524 ) ;
168:
169: Token * getCondTokFromEnd ( Token * endBlock@var1525 ) ;
170: const Token * getCondTokFromEnd ( const Token * endBlock@var1526 ) ;
171:
172:
173:
174: const Token * findNextTokenFromBreak ( const Token * breakToken@var1527 ) ;
175:
|
178:
179: bool extractForLoopValues ( const Token * forToken@var1528 ,
180: int * const varid@var1529 ,
181: bool * const knownInitValue@var1530 ,
182: long long * const initValue@var1531 ,
183: bool * const partialCond@var1532 ,
184: long long * const stepValue@var1533 ,
185: long long * const lastValue@var1534 ) ;
186:
187: bool precedes ( const Token * tok1@var1535 , const Token * tok2@var1536 ) ;
188: bool succeeds ( const Token * tok1@var1537 , const Token * tok2@var1538 ) ;
189:
190: bool exprDependsOnThis ( const Token * expr@var1539 , bool onVar@var1540 = true , int depth@var1541 = 0 ) ;
191:
192: struct ReferenceToken {
193: const Token * token@var1542 ;
194: std :: list < std :: pair < const Token * , std :: string > > errors@var1543 ;
195: } ;
196:
197: std :: vector < ReferenceToken > followAllReferences ( const Token * tok@var1544 ,
198: bool temporary@var1545 = true ,
199: bool inconclusive@var1546 = true ,
200: std :: list < std :: pair < const Token * , std :: string > > errors@var1547 = std :: list < std :: pair < const Token * , std :: string > > { } ,
201: int depth@var1548 = 20 ) ;
202: const Token * followReferences ( const Token * tok@var1549 , std :: list < std :: pair < const Token * , std :: string > > * errors@var1550 = nullptr ) ;
203:
204: bool isSameExpression ( bool cpp@var1551 , bool macro@var1552 , const Token * tok1@var1553 , const Token * tok2@var1554 , const Library & library@var1555 , bool pure@var1556 , bool followVar@var1557 , std :: list < std :: pair < const Token * , std :: string > > * errors@var1558 = nullptr ) ;
205:
206: bool isEqualKnownValue ( const Token * const tok1@var1559 , const Token * const tok2@var1560 ) ;
207:
|
210:
211: bool isUsedAsBool ( const Token * const tok@var1561 ) ;
212:
|
221:
222: bool isOppositeCond ( bool isNot@var1562 , bool cpp@var1563 , const Token * const cond1@var1564 , const Token * const cond2@var1565 , const Library & library@var1566 , bool pure@var1567 , bool followVar@var1568 , std :: list < std :: pair < const Token * , std :: string > > * errors@var1569 = nullptr ) ;
223:
224: bool isOppositeExpression ( bool cpp@var1570 , const Token * const tok1@var1571 , const Token * const tok2@var1572 , const Library & library@var1573 , bool pure@var1574 , bool followVar@var1575 , std :: list < std :: pair < const Token * , std :: string > > * errors@var1576 = nullptr ) ;
225:
226: bool isConstFunctionCall ( const Token * ftok@var1577 , const Library & library@var1578 ) ;
227:
228: bool isConstExpression ( const Token * tok@var1579 , const Library & library@var1580 , bool pure@var1581 , bool cpp@var1582 ) ;
229:
230: bool isWithoutSideEffects ( bool cpp@var1583 , const Token * tok@var1584 , bool checkArrayAccess@var1585 = false , bool checkReference@var1586 = true ) ;
231:
232: bool isUniqueExpression ( const Token * tok@var1587 ) ;
233:
234: bool isEscapeFunction ( const Token * ftok@var1588 , const Library * library@var1589 ) ;
235:
236:
237: bool isReturnScope ( const Token * const endToken@var1590 ,
238: const Library * library@var1591 = nullptr ,
239: const Token * * unknownFunc@var1592 = nullptr ,
240: bool functionScope@var1593 = false ) ;
241:
242:
243: bool isWithinScope ( const Token * tok@var1594 ,
244: const Variable * var@var1595 ,
245: Scope :: ScopeType type@var1596 ) ;
246:
247:
248: const Token * getTokenArgumentFunction ( const Token * tok@var1597 , int & argn@var1598 ) ;
249: Token * getTokenArgumentFunction ( Token * tok@var1599 , int & argn@var1600 ) ;
250:
251: std :: vector < const Variable * > getArgumentVars ( const Token * tok@var1601 , int argnr@var1602 ) ;
252:
|
261:
262: bool isVariableChangedByFunctionCall ( const Token * tok@var1603 , int indirect@var1604 , int varid@var1605 , const Settings * settings@var1606 , bool * inconclusive@var1607 ) ;
263:
|
271:
272: bool isVariableChangedByFunctionCall ( const Token * tok@var1608 , int indirect@var1609 , const Settings * settings@var1610 , bool * inconclusive@var1611 ) ;
273:
274:
275: bool isVariableChanged ( const Token * start@var1612 , const Token * end@var1613 , const int exprid@var1614 , bool globalvar@var1615 , const Settings * settings@var1616 , bool cpp@var1617 , int depth@var1618 = 20 ) ;
276: bool isVariableChanged ( const Token * start@var1619 , const Token * end@var1620 , int indirect@var1621 , const int exprid@var1622 , bool globalvar@var1623 , const Settings * settings@var1624 , bool cpp@var1625 , int depth@var1626 = 20 ) ;
277:
278: bool isVariableChanged ( const Token * tok@var1627 , int indirect@var1628 , const Settings * settings@var1629 , bool cpp@var1630 , int depth@var1631 = 20 ) ;
279:
280: bool isVariableChanged ( const Variable * var@var1632 , const Settings * settings@var1633 , bool cpp@var1634 , int depth@var1635 = 20 ) ;
281:
282: bool isVariablesChanged ( const Token * start@var1636 ,
283: const Token * end@var1637 ,
284: int indirect@var1638 ,
285: std :: vector < const Variable * > vars@var1639 ,
286: const Settings * settings@var1640 ,
287: bool cpp@var1641 ) ;
288:
289: bool isThisChanged ( const Token * tok@var1642 , int indirect@var1643 , const Settings * settings@var1644 , bool cpp@var1645 ) ;
290: bool isThisChanged ( const Token * start@var1646 , const Token * end@var1647 , int indirect@var1648 , const Settings * settings@var1649 , bool cpp@var1650 ) ;
291:
292: const Token * findVariableChanged ( const Token * start@var1651 , const Token * end@var1652 , int indirect@var1653 , const int exprid@var1654 , bool globalvar@var1655 , const Settings * settings@var1656 , bool cpp@var1657 , int depth@var1658 = 20 ) ;
293: Token * findVariableChanged ( Token * start@var1659 , const Token * end@var1660 , int indirect@var1661 , const int exprid@var1662 , bool globalvar@var1663 , const Settings * settings@var1664 , bool cpp@var1665 , int depth@var1666 = 20 ) ;
294:
295: bool isExpressionChanged ( const Token * expr@var1667 ,
296: const Token * start@var1668 ,
297: const Token * end@var1669 ,
298: const Settings * settings@var1670 ,
299: bool cpp@var1671 ,
300: int depth@var1672 = 20 ) ;
301:
302: bool isExpressionChangedAt ( const Token * expr@var1673 ,
303: const Token * tok@var1674 ,
304: int indirect@var1675 ,
305: bool globalvar@var1676 ,
306: const Settings * settings@var1677 ,
307: bool cpp@var1678 ,
308: int depth@var1679 = 20 ) ;
309:
310:
311: bool isAliasOf ( const Token * tok@var1680 , int varid@var1681 , bool * inconclusive@var1682 = nullptr ) ;
312:
313: bool isAliased ( const Variable * var@var1683 ) ;
314:
315: const Token * getArgumentStart ( const Token * ftok@var1684 ) ;
316:
|
320:
321: int numberOfArguments ( const Token * ftok@var1685 ) ;
322:
323:
324: int numberOfArgumentsWithoutAst ( const Token * start@var1686 ) ;
325:
|
328:
329: std :: vector < const Token * > getArguments ( const Token * ftok@var1687 ) ;
330:
331: int getArgumentPos ( const Variable * var@var1688 , const Function * f@var1689 ) ;
332:
|
335:
336: bool isIteratorPair ( std :: vector < const Token * > args@var1690 ) ;
337:
338: const Token * findLambdaStartToken ( const Token * last@var1691 ) ;
339:
|
344:
345: const Token * findLambdaEndToken ( const Token * first@var1692 ) ;
346: Token * findLambdaEndToken ( Token * first@var1693 ) ;
347:
348: bool isLikelyStream ( bool cpp@var1694 , const Token * stream@var1695 ) ;
349:
|
354:
355: bool isLikelyStreamRead ( bool cpp@var1696 , const Token * op@var1697 ) ;
356:
357: bool isCPPCast ( const Token * tok@var1698 ) ;
358:
359: bool isConstVarExpression ( const Token * tok@var1699 , const char * skipMatch@var1700 = nullptr ) ;
360:
361: const Variable * getLHSVariable ( const Token * tok@var1701 ) ;
362:
363: const Token * getLHSVariableToken ( const Token * tok@var1702 ) ;
364:
365: std :: vector < const Variable * > getLHSVariables ( const Token * tok@var1703 ) ;
366:
367:
368: const Token * findAllocFuncCallToken ( const Token * expr@var1704 , const Library & library@var1705 ) ;
369:
370: bool isScopeBracket ( const Token * tok@var1706 ) ;
371:
372: bool isNullOperand ( const Token * expr@var1707 ) ;
373:
374: bool isGlobalData ( const Token * expr@var1708 , bool cpp@var1709 ) ;
375:
|
380:
381: class FwdAnalysis {
382: public:
383: FwdAnalysis ( bool cpp@var1710 , const Library & library@var1711 ) : mCpp@var1744 ( cpp@var1710 ) , mLibrary@var1745 ( library@var1711 ) , mWhat@var1746 ( What :: Reassign ) , mValueFlowKnown@var1748 ( true ) { }
384:
385: bool hasOperand ( const Token * tok@var1712 , const Token * lhs@var1713 ) const ;
386:
|
393:
394: const Token * reassign ( const Token * expr@var1714 , const Token * startToken@var1715 , const Token * endToken@var1716 ) ;
395:
|
402:
403: bool unusedValue ( const Token * expr@var1717 , const Token * startToken@var1718 , const Token * endToken@var1719 ) ;
404:
405: struct KnownAndToken {
406: bool known@var1720 ;
407: const Token * token@var1721 ;
408: } ;
409:
410:
411: bool possiblyAliased ( const Token * expr@var1722 , const Token * startToken@var1723 ) const ;
412:
413: std :: set < int > getExprVarIds ( const Token * expr@var1724 , bool * localOut@var1725 = nullptr , bool * unknownVarIdOut@var1726 = nullptr ) const ;
414: private:
415: static bool isEscapedAlias ( const Token * expr@var1727 ) ;
416:
417:
418: struct Result {
419: enum class Type { NONE , READ , WRITE , BREAK , RETURN , BAILOUT } ; enum Type type@var1728 ;
420: explicit Result ( Type type@var1729 ) : type@var1728 ( type@var1729 ) , token@var1732 ( nullptr ) { }
421: Result ( Type type@var1730 , const Token * token@var1731 ) : type@var1728 ( type@var1730 ) , token@var1732 ( token@var1731 ) { }
422: const Token * token@var1732 ;
423: } ;
424:
425: struct Result check ( const Token * expr@var1733 , const Token * startToken@var1734 , const Token * endToken@var1735 ) ;
426: struct Result checkRecursive ( const Token * expr@var1736 , const Token * startToken@var1737 , const Token * endToken@var1738 , const std :: set < int > & exprVarIds@var1739 , bool local@var1740 , bool inInnerClass@var1741 , int depth@var1742 = 0 ) ;
427:
428:
429: bool isGlobalData ( const Token * expr@var1743 ) const ;
430:
431: const bool mCpp@var1744 ;
432: const Library & mLibrary@var1745 ;
433: enum class What { Reassign , UnusedValue , ValueFlow } ; enum What mWhat@var1746 ;
434: std :: vector < KnownAndToken > mValueFlow@var1747 ;
435: bool mValueFlowKnown@var1748 ;
436: } ;
437:
438: bool isSizeOfEtc ( const Token * tok@var1749 ) ;

##file cppcheck-2.8/lib/suppressions.h

1:
|
34:
35: class Tokenizer ;
36:
37:
38: class Suppressions {
39: public:
40:
41: struct ErrorMessage {
42: unsigned long hash@var1750 ;
43: std :: string errorId@var1751 ;
44: void setFileName ( const std :: string & s@var1752 ) ;
45: const std :: string & getFileName ( ) const {
46: return mFileName@var1756 ;
47: }
48: int lineNumber@var1753 ;
49: Certainty :: CertaintyLevel certainty@var1754 ;
50: std :: string symbolNames@var1755 ;
51: private:
52: std :: string mFileName@var1756 ;
53: } ;
54:
55: struct Suppression {
56: Suppression ( ) : lineNumber@var1790 ( NO_LINE ) , hash@var1792 ( 0 ) , thisAndNextLine@var1793 ( false ) , matched@var1794 ( false ) , checked@var1795 ( false ) { }
57: Suppression ( const Suppression & other@var1757 ) {
58: *@expr1073746131 this@expr1073746132 =@expr1073746133 other@var1757 ;
59: }
60: Suppression ( const std :: string & id@var1758 , const std :: string & file@var1759 , int line@var1760 = NO_LINE ) : errorId@var1788 ( id@var1758 ) , fileName@var1789 ( file@var1759 ) , lineNumber@var1790 ( line@var1760 ) , hash@var1792 ( 0 ) , thisAndNextLine@var1793 ( false ) , matched@var1794 ( false ) , checked@var1795 ( false ) { }
61:
62: Suppression & operator= ( const Suppression & other@var1761 ) {
63: errorId@var1788 =@expr1073746134 other@var1761 .@expr1073746135 errorId@var1762 ;
64: fileName@var1789 =@expr1073746136 other@var1761 .@expr1073746137 fileName@var1763 ;
65: lineNumber@var1790 =@expr1073746138 other@var1761 .@expr1073746139 lineNumber@var1764 ;
66: symbolName@var1791 =@expr1073746140 other@var1761 .@expr1073746141 symbolName@var1765 ;
67: hash@var1792 =@expr1073746142 other@var1761 .@expr1073746143 hash@var1766 ;
68: thisAndNextLine@var1793 =@expr1073746144 other@var1761 .@expr1073746145 thisAndNextLine@var1767 ;
69: matched@var1794 =@expr1073746146 other@var1761 .@expr1073746147 matched@var1768 ;
70: checked@var1795 =@expr1073746148 other@var1761 .@expr1073746149 checked@var1769 ;
71: return *@expr1073746150 this@expr1073746151 ;
72: }
73:
74: bool operator< ( const Suppression & other@var1770 ) const {
75: if (@expr1073746152 errorId@var1788 !=@expr1073746153 other@var1770 .@expr4330 errorId@var1771 ) {
76: return errorId@var1788 <@expr1073746155 other@var1770 .@expr4330 errorId@var1771 ; }
77: if (@expr1073746157 lineNumber@var1790 <@expr1073746158 other@var1770 .@expr1073746159 lineNumber@var1772 ) {
78: return true ; }
79: if (@expr1073746160 fileName@var1789 !=@expr1073746161 other@var1770 .@expr4338 fileName@var1773 ) {
80: return fileName@var1789 <@expr1073746163 other@var1770 .@expr4338 fileName@var1773 ; }
81: if (@expr1073746165 symbolName@var1791 !=@expr1073746166 other@var1770 .@expr4343 symbolName@var1774 ) {
82: return symbolName@var1791 <@expr1073746168 other@var1770 .@expr4343 symbolName@var1774 ; }
83: if (@expr1073746170 hash@var1792 !=@expr1073746171 other@var1770 .@expr4348 hash@var1775 ) {
84: return hash@var1792 <@expr1073746173 other@var1770 .@expr4348 hash@var1775 ; }
85: if (@expr1073746175 thisAndNextLine@var1793 !=@expr1073746176 other@var1770 .@expr1073746177 thisAndNextLine@var1776 ) {
86: return thisAndNextLine@var1793 ; }
87: return false ;
88: }
89:
|
95:
96: bool parseComment ( std :: string comment@var1777 , std :: string * errorMessage@var1778 ) ;
97:
98: bool isSuppressed ( const ErrorMessage & errmsg@var1779 ) const ;
99:
100: bool isMatch ( const ErrorMessage & errmsg@var1780 ) ;
101:
102: std :: string getText ( ) const ;
103:
104: bool isLocal ( ) const {
105: return !@expr1073746179 fileName@var1789 .@expr1073746180 empty (@expr1073746181 ) &&@expr1073746182 fileName@var1789 .@expr1073746183 find_first_of (@expr1073746184 "?*" ) ==@expr1073746185 std ::@expr1073746186 string ::@expr1073746187 npos@expr1073746178 ;
106: }
107:
108: bool isSameParameters ( const Suppression & other@var1781 ) const {
109: return errorId@var1788 ==@expr1073746188 other@var1781 .@expr1073746189 errorId@var1782 &&@expr1073746190
110: fileName@var1789 ==@expr1073746191 other@var1781 .@expr1073746192 fileName@var1783 &&@expr1073746193
111: lineNumber@var1790 ==@expr1073746194 other@var1781 .@expr1073746195 lineNumber@var1784 &&@expr1073746196
112: symbolName@var1791 ==@expr1073746197 other@var1781 .@expr1073746198 symbolName@var1785 &&@expr1073746199
113: hash@var1792 ==@expr1073746200 other@var1781 .@expr1073746201 hash@var1786 &&@expr1073746202
114: thisAndNextLine@var1793 ==@expr1073746203 other@var1781 .@expr1073746204 thisAndNextLine@var1787 ;
115: }
116:
117: std :: string errorId@var1788 ;
118: std :: string fileName@var1789 ;
119: int lineNumber@var1790 ;
120: std :: string symbolName@var1791 ;
121: unsigned long hash@var1792 ;
122: bool thisAndNextLine@var1793 ;
123: bool matched@var1794 ;
124: bool checked@var1795 ;
125:
126: enum Anonymous4 { NO_LINE = -1 } ;
127: } ;
128:
|
133:
134: std :: string parseFile ( std :: istream & istr@var1796 ) ;
135:
|
140:
141: std :: string parseXmlFile ( const char * filename@var1797 ) ;
142:
|
148:
149: static std :: vector < Suppression > parseMultiSuppressComment ( const std :: string & comment@var1798 , std :: string * errorMessage@var1799 ) ;
150:
|
155:
156: std :: string addSuppressionLine ( const std :: string & line@var1800 ) ;
157:
|
163:
164: std :: string addSuppression ( const Suppression & suppression@var1801 ) ;
165:
|
170:
171: std :: string addSuppressions ( const std :: list < Suppression > & suppressions@var1802 ) ;
172:
|
177:
178: bool isSuppressed ( const ErrorMessage & errmsg@var1803 ) ;
179:
|
184:
185: bool isSuppressedLocal ( const ErrorMessage & errmsg@var1804 ) ;
186:
|
190:
191: void dump ( std :: ostream & out@var1805 ) const ;
192:
|
196:
197: std :: list < Suppression > getUnmatchedLocalSuppressions ( const std :: string & file@var1806 , const bool unusedFunctionChecking@var1807 ) const ;
198:
|
202:
203: std :: list < Suppression > getUnmatchedGlobalSuppressions ( const bool unusedFunctionChecking@var1808 ) const ;
204:
|
208:
209: const std :: list < Suppression > & getSuppressions ( ) const ;
210:
|
213:
214: void markUnmatchedInlineSuppressionsAsChecked ( const Tokenizer & tokenizer@var1809 ) ;
215:
216: private:
217:
218: std :: list < Suppression > mSuppressions@var1810 ;
219: } ;

##file cppcheck-2.8/lib/color.h

1:
|
26:
27: enum class Color {
28: Reset = 0 ,
29: Bold = 1 ,
30: Dim = 2 ,
31: FgRed = 31 ,
32: FgGreen = 32 ,
33: FgBlue = 34 ,
34: FgMagenta = 35 ,
35: FgDefault = 39 ,
36: BgRed = 41 ,
37: BgGreen = 42 ,
38: BgBlue = 44 ,
39: BgDefault = 49
40: } ;
41: std :: ostream & operator<< ( std :: ostream & os@var1811 , const Color & c@var1812 ) ;
42:
43: std :: string toString ( const Color & c@var1813 ) ;

##file cppcheck-2.8/lib/errorlogger.h

1:
|
39:
40: static const struct CWE CWE_USE_OF_UNINITIALIZED_VARIABLE@var1814 ( 457U ) ;
41: static const struct CWE CWE_NULL_POINTER_DEREFERENCE@var1815 ( 476U ) ;
42: static const struct CWE CWE_USE_OF_POTENTIALLY_DANGEROUS_FUNCTION@var1816 ( 676U ) ;
43: static const struct CWE CWE_INCORRECT_CALCULATION@var1817 ( 682U ) ;
44: static const struct CWE CWE_EXPIRED_POINTER_DEREFERENCE@var1818 ( 825U ) ;
45:
46:
47: class Token ;
48: class TokenList ;
49:
50: namespace tinyxml2 {
51: class XMLElement ;
52: }
53:
|
59:
60: class ErrorMessage {
61: public:
62:
|
66:
67: class FileLocation {
68: public:
69: FileLocation ( )
70: : fileIndex@var1834 ( 0 ) , line@var1835 ( 0 ) , column@var1836 ( 0 ) { }
71:
72: FileLocation ( const std :: string & file@var1819 , int line@var1820 , unsigned int column@var1821 )
73: : fileIndex@var1834 ( 0 ) , line@var1835 ( line@var1820 ) , column@var1836 ( column@var1821 ) , mOrigFileName@var1838 ( file@var1819 ) , mFileName@var1839 ( file@var1819 ) { }
74:
75: FileLocation ( const std :: string & file@var1822 , const std :: string & info@var1823 , int line@var1824 , unsigned int column@var1825 )
76: : fileIndex@var1834 ( 0 ) , line@var1835 ( line@var1824 ) , column@var1836 ( column@var1825 ) , mOrigFileName@var1838 ( file@var1822 ) , mFileName@var1839 ( file@var1822 ) , mInfo@var1840 ( info@var1823 ) { }
77:
78: FileLocation ( const Token * tok@var1826 , const TokenList * tokenList@var1827 ) ;
79: FileLocation ( const Token * tok@var1828 , const std :: string & info@var1829 , const TokenList * tokenList@var1830 ) ;
80:
|
85:
86: std :: string getfile ( bool convert@var1831 = true ) const ;
87:
|
92:
93: std :: string getOrigFile ( bool convert@var1832 = true ) const ;
94:
|
98:
99: void setfile ( const std :: string & file@var1833 ) ;
100:
|
103:
104: std :: string stringify ( ) const ;
105:
106: unsigned int fileIndex@var1834 ;
107: int line@var1835 ;
108: unsigned int column@var1836 ;
109:
110: std :: string getinfo ( ) const {
111: return mInfo@var1840 ;
112: }
113: void setinfo ( const std :: string & i@var1837 ) {
114: mInfo@var1840 =@expr1073746205 i@var1837 ;
115: }
116:
117: private:
118: std :: string mOrigFileName@var1838 ;
119: std :: string mFileName@var1839 ;
120: std :: string mInfo@var1840 ;
121: } ;
122:
123: ErrorMessage ( const std :: list < FileLocation > & callStack@var1841 ,
124: const std :: string & file1@var1842 ,
125: Severity :: SeverityType severity@var1843 ,
126: const std :: string & msg@var1844 ,
127: const std :: string & id@var1845 , Certainty :: CertaintyLevel certainty@var1846 ) ;
128: ErrorMessage ( const std :: list < FileLocation > & callStack@var1847 ,
129: const std :: string & file1@var1848 ,
130: Severity :: SeverityType severity@var1849 ,
131: const std :: string & msg@var1850 ,
132: const std :: string & id@var1851 ,
133: const CWE & cwe@var1852 ,
134: Certainty :: CertaintyLevel certainty@var1853 ) ;
135: ErrorMessage ( const std :: list < const Token * > & callstack@var1854 ,
136: const TokenList * list@var1855 ,
137: Severity :: SeverityType severity@var1856 ,
138: const std :: string & id@var1857 ,
139: const std :: string & msg@var1858 ,
140: Certainty :: CertaintyLevel certainty@var1859 ) ;
141: ErrorMessage ( const std :: list < const Token * > & callstack@var1860 ,
142: const TokenList * list@var1861 ,
143: Severity :: SeverityType severity@var1862 ,
144: const std :: string & id@var1863 ,
145: const std :: string & msg@var1864 ,
146: const CWE & cwe@var1865 ,
147: Certainty :: CertaintyLevel certainty@var1866 ) ;
148: ErrorMessage ( const std :: list < std :: pair < const Token * , std :: string > > & errorPath@var1867 ,
149: const TokenList * tokenList@var1868 ,
150: Severity :: SeverityType severity@var1869 ,
151: const char id@var1870 [ ] ,
152: const std :: string & msg@var1871 ,
153: const CWE & cwe@var1872 ,
154: Certainty :: CertaintyLevel certainty@var1873 ) ;
155: ErrorMessage ( ) ;
156: explicit ErrorMessage ( const tinyxml2 :: XMLElement * const errmsg@var1874 ) ;
157:
|
160:
161: std :: string toXML ( ) const ;
162:
163: static std :: string getXMLHeader ( ) ;
164: static std :: string getXMLFooter ( ) ;
165:
|
174:
175: std :: string toString ( bool verbose@var1875 ,
176: const std :: string & templateFormat@var1876 = emptyString@var1 ,
177: const std :: string & templateLocation@var1877 = emptyString@var1 ) const ;
178:
179: std :: string serialize ( ) const ;
180: bool deserialize ( const std :: string & data@var1878 ) ;
181:
182: std :: list < FileLocation > callStack@var1879 ;
183: std :: string id@var1880 ;
184:
185:
186: std :: string file0@var1881 ;
187:
188: std :: string function@var1882 ;
189:
190: bool incomplete@var1883 ;
191:
192: Severity :: SeverityType severity@var1884 ;
193: CWE cwe@var1885 ;
194: Certainty :: CertaintyLevel certainty@var1886 ;
195:
196:
197: unsigned long hash@var1887 ;
198:
199:
200: void setmsg ( const std :: string & msg@var1888 ) ;
201:
202:
203: const std :: string & shortMessage ( ) const {
204: return mShortMessage@var1890 ;
205: }
206:
207:
208: const std :: string & verboseMessage ( ) const {
209: return mVerboseMessage@var1891 ;
210: }
211:
212:
213: const std :: string & symbolNames ( ) const {
214: return mSymbolNames@var1892 ;
215: }
216:
217: Suppressions :: ErrorMessage toSuppressionsErrorMessage ( ) const ;
218:
219: private:
220: static std :: string fixInvalidChars ( const std :: string & raw@var1889 ) ;
221:
222:
223: std :: string mShortMessage@var1890 ;
224:
225:
226: std :: string mVerboseMessage@var1891 ;
227:
228:
229: std :: string mSymbolNames@var1892 ;
230: } ;
231:
|
235:
236: class ErrorLogger {
237: protected:
238: std :: ofstream plistFile@var1893 ;
239: public:
240: ErrorLogger ( ) { }
241: virtual ~ ErrorLogger ( ) {
242: if (@expr1073746206 plistFile@var1893 .@expr1073746207 is_open (@expr1073746208 ) ) {
243: plistFile@var1893 <<@expr1073746209 ErrorLogger ::@expr1073746210 plistFooter (@expr1073746211 ) ;
244: plistFile@var1893 .@expr1073746212 close (@expr1073746213 ) ;
245: }
246: }
247:
|
253:
254: virtual void reportOut ( const std :: string & outmsg@var1894 , Color c@var1895 = Color :: Reset ) = 0 ;
255:
|
261:
262: virtual void reportErr ( const ErrorMessage & msg@var1896 ) = 0 ;
263:
|
269:
270: virtual void reportProgress ( const std :: string & filename@var1897 , const char stage@var1898 [ ] , const unsigned long value@var1899 ) {
271: (@expr1073746214 void ) filename@var1897 ;
272: (@expr1073746215 void ) stage@var1898 ;
273: (@expr1073746216 void ) value@var1899 ;
274: }
275:
|
279:
280: virtual void reportInfo ( const ErrorMessage & msg@var1900 ) {
281: reportErr (@expr1073746217 msg@var1900 ) ;
282: }
283:
|
288:
289: bool reportUnmatchedSuppressions ( const std :: list < Suppressions :: Suppression > & unmatched@var1901 ) ;
290:
291: static std :: string callStackToString ( const std :: list < ErrorMessage :: FileLocation > & callStack@var1902 ) ;
292:
|
297:
298: static std :: string toxml ( const std :: string & str@var1903 ) ;
299:
300: static std :: string plistHeader ( const std :: string & version@var1904 , const std :: vector < std :: string > & files@var1905 ) ;
301: static std :: string plistData ( const ErrorMessage & msg@var1906 ) ;
302: static const char * plistFooter ( ) {
303: return " </array>\r\n</dict>\r\n</plist>"
304:
305: ;
306: }
307: } ;
308:
309:
310: std :: string replaceStr ( std :: string s@var1907 , const std :: string & from@var1908 , const std :: string & to@var1909 ) ;

##file cppcheck-2.8/lib/path.h

1:
|
39:
40: class Path {
41: public:
42:
|
46:
47: static std :: string toNativeSeparators ( std :: string path@var1910 ) ;
48:
|
53:
54: static std :: string fromNativeSeparators ( std :: string path@var1911 ) ;
55:
|
60:
61: static std :: string simplifyPath ( std :: string originalPath@var1912 ) ;
62:
|
67:
68: static std :: string getPathFromFilename ( const std :: string & filename@var1913 ) ;
69:
|
76:
77: static bool sameFileName ( const std :: string & fname1@var1914 , const std :: string & fname2@var1915 ) ;
78:
|
83:
84: static std :: string removeQuotationMarks ( std :: string path@var1916 ) ;
85:
|
90:
91: static std :: string getFilenameExtension ( const std :: string & path@var1917 ) ;
92:
|
97:
98: static std :: string getFilenameExtensionInLowerCase ( const std :: string & path@var1918 ) ;
99:
|
103:
104: static std :: string getCurrentPath ( ) ;
105:
|
110:
111: static bool isAbsolute ( const std :: string & path@var1919 ) ;
112:
|
118:
119: static std :: string getRelativePath ( const std :: string & absolutePath@var1920 , const std :: vector < std :: string > & basePaths@var1921 ) ;
120:
|
125:
126: static std :: string getAbsoluteFilePath ( const std :: string & filePath@var1922 ) ;
127:
|
133:
134: static bool acceptFile ( const std :: string & filename@var1923 ) {
135: const std ::@expr1073746218 set < std ::@expr1073746219 string > extra@var1924 ;
136: return acceptFile (@expr1073746220 filename@var1923 , extra@var1924 ) ;
137: }
138:
|
145:
146: static bool acceptFile ( const std :: string & path@var1925 , const std :: set < std :: string > & extra@var1926 ) ;
147:
|
152:
153: static bool isC ( const std :: string & path@var1927 ) ;
154:
|
159:
160: static bool isCPP ( const std :: string & path@var1928 ) ;
161:
|
166:
167: static bool isHeader ( const std :: string & path@var1929 ) ;
168:
|
173:
174: static std :: string stripDirectoryPart ( const std :: string & file@var1930 ) ;
175:
|
180:
181: static bool fileExists ( const std :: string & file@var1931 ) ;
182: } ;

##file cppcheck-2.8/lib/platform.h

1:
|
31:
32: namespace tinyxml2 {
33: class XMLDocument ;
34: }
35:
36: namespace cppcheck {
37:
|
40:
41: class Platform {
42: private:
43: static long long min_value ( int bit@var1932 ) {
44: if (@expr1073746221 bit@var1932 >=@expr1073746222 64 ) {
45: return LLONG_MIN ; }
46: return -@expr1073746223 (@expr1073746224 1LL <<@expr1073746225 (@expr1073746226 bit@var1932 -@expr1073746227 1 ) ) ;
47: }
48:
49: static long long max_value ( int bit@var1933 ) {
50: if (@expr1073746228 bit@var1933 >=@expr1073746229 64 ) {
51: return (@expr4406 ~@expr1073746231 0ULL ) >>@expr1073746232 1 ; }
52: return (@expr4406 1LL <<@expr1073746234 (@expr4406 bit@var1933 -@expr1073746236 1 ) ) -@expr1073746237 1LL ;
53: }
54: public:
55: Platform ( ) ;
56: virtual ~ Platform ( ) { }
57:
58: bool isIntValue ( long long value@var1934 ) const {
59: return value@var1934 >=@expr1073746238 min_value (@expr1073746239 int_bit@var1944 ) &&@expr1073746240 value@var1934 <=@expr1073746241 max_value (@expr1073746242 int_bit@var1944 ) ;
60: }
61:
62: bool isIntValue ( unsigned long long value@var1935 ) const {
63: unsigned long long intMax@var1936 ; intMax@var1936 =@expr1073746243 max_value (@expr1073746244 int_bit@var1944 ) ;
64: return value@var1935 <=@expr1073746245 intMax@var1936 ;
65: }
66:
67: bool isLongValue ( long long value@var1937 ) const {
68: return value@var1937 >=@expr1073746246 min_value (@expr1073746247 long_bit@var1945 ) &&@expr1073746248 value@var1937 <=@expr1073746249 max_value (@expr1073746250 long_bit@var1945 ) ;
69: }
70:
71: bool isLongValue ( unsigned long long value@var1938 ) const {
72: unsigned long long longMax@var1939 ; longMax@var1939 =@expr1073746251 max_value (@expr1073746252 long_bit@var1945 ) ;
73: return value@var1938 <=@expr1073746253 longMax@var1939 ;
74: }
75:
76: bool isLongLongValue ( unsigned long long value@var1940 ) const {
77: unsigned long long longLongMax@var1941 ; longLongMax@var1941 =@expr1073746254 max_value (@expr1073746255 long_long_bit@var1946 ) ;
78: return value@var1940 <=@expr1073746256 longLongMax@var1941 ;
79: }
80:
81: int char_bit@var1942 ;
82: int short_bit@var1943 ;
83: int int_bit@var1944 ;
84: int long_bit@var1945 ;
85: int long_long_bit@var1946 ;
86:
87:
88: int sizeof_bool@var1947 ;
89: int sizeof_short@var1948 ;
90: int sizeof_int@var1949 ;
91: int sizeof_long@var1950 ;
92: int sizeof_long_long@var1951 ;
93: int sizeof_float@var1952 ;
94: int sizeof_double@var1953 ;
95: int sizeof_long_double@var1954 ;
96: int sizeof_wchar_t@var1955 ;
97: int sizeof_size_t@var1956 ;
98: int sizeof_pointer@var1957 ;
99:
100: char defaultSign@var1958 ;
101:
102: enum PlatformType {
103: Unspecified ,
104: Native ,
105: Win32A ,
106: Win32W ,
107: Win64 ,
108: Unix32 ,
109: Unix64 ,
110: PlatformFile
111: } ;
112:
113:
114: PlatformType platformType@var1959 ;
115:
116:
117: bool platform ( PlatformType type@var1960 ) ;
118:
|
124:
125: bool loadPlatformFile ( const char exename@var1961 [ ] , const std :: string & filename@var1962 ) ;
126:
127:
128: bool loadFromXmlDocument ( const tinyxml2 :: XMLDocument * doc@var1963 ) ;
129:
|
133:
134: bool isWindowsPlatform ( ) const {
135: return platformType@var1959 ==@expr1073746257 Win32A ||@expr1073746258
136: platformType@var1959 ==@expr1073746259 Win32W ||@expr1073746260
137: platformType@var1959 ==@expr1073746261 Win64 ;
138: }
139:
140: const char * platformString ( ) const {
141: return platformString (@expr1073746262 platformType@var1959 ) ;
142: }
143:
144: static const char * platformString ( PlatformType pt@var1964 ) {
145: switch (@expr1073746263 pt@var1964 ) {
146: case Unspecified :@expr4440 ;
147: return "Unspecified" ;
148: case Native :@expr4440 ;
149: return "Native" ;
150: case Win32A :@expr4440 ;
151: return "win32A" ;
152: case Win32W :@expr4440 ;
153: return "win32W" ;
154: case Win64 :@expr4440 ;
155: return "win64" ;
156: case Unix32 :@expr4440 ;
157: return "unix32" ;
158: case Unix64 :@expr4440 ;
159: return "unix64" ;
160: case PlatformFile :@expr4440 ;
161: return "platformFile" ;
162: default :@expr4440 ;
163: return "unknown" ;
164: }
165: }
166:
167: long long unsignedCharMax ( ) const {
168: return max_value (@expr1073746273 char_bit@var1942 +@expr1073746274 1 ) ;
169: }
170:
171: long long signedCharMax ( ) const {
172: return max_value (@expr1073746275 char_bit@var1942 ) ;
173: }
174:
175: long long signedCharMin ( ) const {
176: return min_value (@expr1073746276 char_bit@var1942 ) ;
177: }
178: } ;
179:
180: }

##file cppcheck-2.8/lib/importproject.h

1:
|
37:
38: namespace cppcheck {
39: struct stricmp {
40: bool operator() ( const std :: string & lhs@var1965 , const std :: string & rhs@var1966 ) const {
41: return caseInsensitiveStringCompare (@expr1073746277 lhs@var1965 , rhs@var1966 ) <@expr1073746278 0 ;
42: }
43: } ;
44: }
45:
46: class Settings ;
47:
|
50:
51: class ImportProject {
52: public:
53: enum class Type {
54: UNKNOWN ,
55: MISSING ,
56: FAILURE ,
57: COMPILE_DB ,
58: VS_SLN ,
59: VS_VCXPROJ ,
60: BORLAND ,
61: CPPCHECK_GUI
62: } ;
63:
64:
65: struct FileSettings {
66: FileSettings ( ) : platformType@var1974 ( cppcheck :: Platform :: Unspecified ) , msc@var1975 ( false ) , useMfc@var1976 ( false ) { }
67: std :: string cfg@var1967 ;
68: std :: string filename@var1968 ;
69: std :: string defines@var1969 ;
70: std :: string cppcheckDefines ( ) const {
71: return defines@var1969 +@expr1073746279 (@expr1073746280 msc@var1975 ?@expr1073746281 ";_MSC_VER=1900" :@expr1073746282 "" ) +@expr1073746283 (@expr1073746284 useMfc@var1976 ?@expr1073746285 ";__AFXWIN_H__=1" :@expr1073746286 "" ) ;
72: }
73: std :: set < std :: string > undefs@var1970 ;
74: std :: list < std :: string > includePaths@var1971 ;
75: std :: list < std :: string > systemIncludePaths@var1972 ;
76: std :: string standard@var1973 ;
77: cppcheck :: Platform :: PlatformType platformType@var1974 ;
78: bool msc@var1975 ;
79: bool useMfc@var1976 ;
80:
81: void parseCommand ( std :: string command@var1977 ) ;
82: void setDefines ( std :: string defs@var1978 ) ;
83: void setIncludePaths ( const std :: string & basepath@var1979 , const std :: list < std :: string > & in@var1980 , std :: map < std :: string , std :: string , cppcheck :: stricmp > & variables@var1981 ) ;
84: } ;
85: std :: list < FileSettings > fileSettings@var1982 ;
86: Type projectType@var1983 ;
87:
88: ImportProject ( ) ;
89:
90: void selectOneVsConfig ( cppcheck :: Platform :: PlatformType platform@var1984 ) ;
91:
92: std :: list < std :: string > getVSConfigs ( ) ;
93:
94:
95: struct Anonymous5 {
96: std :: string analyzeAllVsConfigs@var1985 ;
97: std :: vector < std :: string > pathNames@var1986 ;
98: std :: list < std :: string > libraries@var1987 ;
99: std :: list < std :: string > excludedPaths@var1988 ;
100: std :: list < std :: string > checkVsConfigs@var1989 ;
101: std :: string projectFile@var1990 ;
102: std :: string platform@var1991 ;
103: } ; struct Anonymous5 guiProject@var1992 ;
104:
105: void ignorePaths ( const std :: vector < std :: string > & ipaths@var1993 ) ;
106: void ignoreOtherConfigs ( const std :: string & cfg@var1994 ) ;
107:
108: Type import ( const std :: string & filename@var1995 , Settings * settings@var1996 = nullptr ) ;
109: protected:
110: bool importCompileCommands ( std :: istream & istr@var1997 ) ;
111: bool importCppcheckGuiProject ( std :: istream & istr@var1998 , Settings * settings@var1999 ) ;
112: virtual bool sourceFileExists ( const std :: string & file@var2000 ) ;
113: private:
114: bool importSln ( std :: istream & istr@var2001 , const std :: string & path@var2002 , const std :: vector < std :: string > & fileFilters@var2003 ) ;
115: bool importVcxproj ( const std :: string & filename@var2004 , std :: map < std :: string , std :: string , cppcheck :: stricmp > & variables@var2005 , const std :: string & additionalIncludeDirectories@var2006 , const std :: vector < std :: string > & fileFilters@var2007 ) ;
116: bool importBcb6Prj ( const std :: string & projectFilename@var2008 ) ;
117:
118: static void printError ( const std :: string & message@var2009 ) ;
119:
120: void setRelativePaths ( const std :: string & filename@var2010 ) ;
121:
122: std :: string mPath@var2011 ;
123: std :: set < std :: string > mAllVSConfigs@var2012 ;
124: } ;
125:
126:
127: namespace CppcheckXml {
128: const char ProjectElementName@var2013 [ 8 ] = "project" ;
129: const char ProjectVersionAttrib@var2014 [ 8 ] = "version" ;
130: const char ProjectFileVersion@var2015 [ 2 ] = "1" ;
131: const char BuildDirElementName@var2016 [ 9 ] = "builddir" ;
132: const char ImportProjectElementName@var2017 [ 14 ] = "importproject" ;
133: const char AnalyzeAllVsConfigsElementName@var2018 [ 23 ] = "analyze-all-vs-configs" ;
134: const char Parser@var2019 [ 7 ] = "parser" ;
135: const char BugHunting@var2020 [ 12 ] = "bug-hunting" ;
136: const char IncludeDirElementName@var2021 [ 11 ] = "includedir" ;
137: const char DirElementName@var2022 [ 4 ] = "dir" ;
138: const char DirNameAttrib@var2023 [ 5 ] = "name" ;
139: const char DefinesElementName@var2024 [ 8 ] = "defines" ;
140: const char DefineName@var2025 [ 7 ] = "define" ;
141: const char DefineNameAttrib@var2026 [ 5 ] = "name" ;
142: const char UndefinesElementName@var2027 [ 10 ] = "undefines" ;
143: const char UndefineName@var2028 [ 9 ] = "undefine" ;
144: const char PathsElementName@var2029 [ 6 ] = "paths" ;
145: const char PathName@var2030 [ 4 ] = "dir" ;
146: const char PathNameAttrib@var2031 [ 5 ] = "name" ;
147: const char RootPathName@var2032 [ 5 ] = "root" ;
148: const char RootPathNameAttrib@var2033 [ 5 ] = "name" ;
149: const char IgnoreElementName@var2034 [ 7 ] = "ignore" ;
150: const char IgnorePathName@var2035 [ 5 ] = "path" ;
151: const char IgnorePathNameAttrib@var2036 [ 5 ] = "name" ;
152: const char ExcludeElementName@var2037 [ 8 ] = "exclude" ;
153: const char ExcludePathName@var2038 [ 5 ] = "path" ;
154: const char ExcludePathNameAttrib@var2039 [ 5 ] = "name" ;
155: const char FunctionContracts@var2040 [ 19 ] = "function-contracts" ;
156: const char VariableContractsElementName@var2041 [ 19 ] = "variable-contracts" ;
157: const char LibrariesElementName@var2042 [ 10 ] = "libraries" ;
158: const char LibraryElementName@var2043 [ 8 ] = "library" ;
159: const char PlatformElementName@var2044 [ 9 ] = "platform" ;
160: const char SuppressionsElementName@var2045 [ 13 ] = "suppressions" ;
161: const char SuppressionElementName@var2046 [ 12 ] = "suppression" ;
162: const char AddonElementName@var2047 [ 6 ] = "addon" ;
163: const char AddonsElementName@var2048 [ 7 ] = "addons" ;
164: const char ToolElementName@var2049 [ 5 ] = "tool" ;
165: const char ToolsElementName@var2050 [ 6 ] = "tools" ;
166: const char TagsElementName@var2051 [ 5 ] = "tags" ;
167: const char TagElementName@var2052 [ 4 ] = "tag" ;
168: const char TagWarningsElementName@var2053 [ 13 ] = "tag-warnings" ;
169: const char TagAttributeName@var2054 [ 4 ] = "tag" ;
170: const char WarningElementName@var2055 [ 8 ] = "warning" ;
171: const char HashAttributeName@var2056 [ 5 ] = "hash" ;
172: const char CheckHeadersElementName@var2057 [ 14 ] = "check-headers" ;
173: const char CheckUnusedTemplatesElementName@var2058 [ 23 ] = "check-unused-templates" ;
174: const char MaxCtuDepthElementName@var2059 [ 14 ] = "max-ctu-depth" ;
175: const char MaxTemplateRecursionElementName@var2060 [ 23 ] = "max-template-recursion" ;
176: const char CheckUnknownFunctionReturn@var2061 [ 37 ] = "check-unknown-function-return-values" ;
177: const char ClangTidy@var2062 [ 11 ] = "clang-tidy" ;
178: const char Name@var2063 [ 5 ] = "name" ;
179: const char VSConfigurationElementName@var2064 [ 18 ] = "vs-configurations" ;
180: const char VSConfigurationName@var2065 [ 7 ] = "config" ;
181: }

##file cppcheck-2.8/lib/timer.h

1:
|
28:
29: enum class SHOWTIME_MODES {
30: SHOWTIME_NONE = 0 ,
31: SHOWTIME_FILE ,
32: SHOWTIME_SUMMARY ,
33: SHOWTIME_TOP5
34: } ;
35:
36: class TimerResultsIntf {
37: public:
38: virtual ~ TimerResultsIntf ( ) { }
39:
40: virtual void addResults ( const std :: string & str@var2066 , std :: clock_t clocks@var2067 ) = 0 ;
41: } ;
42:
43: struct TimerResultsData {
44: std :: clock_t mClocks@var2068 ;
45: long mNumberOfResults@var2069 ;
46:
47: TimerResultsData ( )
48: : mClocks@var2068 ( 0 )
49: , mNumberOfResults@var2069 ( 0 ) { }
50:
51: double seconds ( ) const {
52: const double ret@var2070 =@expr1073746288 (@expr1073746289 double ) (@expr1073746290 (@expr1073746291 unsigned long ) mClocks@var2068 ) /@expr1073746292 (@expr1073746293 double ) CLOCKS_PER_SEC@expr1073746287 ;
53: return ret@var2070 ;
54: }
55: } ;
56:
57: class TimerResults : public TimerResultsIntf {
58: public:
59: TimerResults ( ) { }
60:
61: void showResults ( SHOWTIME_MODES mode@var2071 ) const ;
62: void addResults ( const std :: string & str@var2072 , std :: clock_t clocks@var2073 ) override ;
63:
64: private:
65: std :: map < std :: string , TimerResultsData > mResults@var2074 ;
66: } ;
67:
68: class Timer {
69: public:
70: Timer ( const std :: string & str@var2075 , SHOWTIME_MODES showtimeMode@var2076 , TimerResultsIntf * timerResults@var2077 = nullptr ) ;
71: ~ Timer ( ) ;
72: void stop ( ) ;
73:
74: private:
75: Timer ( const Timer & other@var2078 ) ;
76: Timer & operator= ( const Timer & ) ;
77:
78: const std :: string mStr@var2079 ;
79: TimerResultsIntf * mTimerResults@var2080 ;
80: std :: clock_t mStart@var2081 ;
81: const SHOWTIME_MODES mShowTimeMode@var2082 ;
82: bool mStopped@var2083 ;
83: } ;

##file cppcheck-2.8/lib/settings.h

1:
|
40:
41: namespace ValueFlow {
42: class Value ;
43: }
44:
|
47:
48: class SimpleEnableGroup<Severity::SeverityType> ; class SimpleEnableGroup<Certainty::CertaintyLevel> ; class SimpleEnableGroup<Checks::CheckList> ;
49:
|
89:
90: class Settings : public cppcheck :: Platform {
91: private:
92:
93:
94: static std :: atomic < bool > mTerminated@var2084 ;
95:
96: public:
97: Settings ( ) ;
98:
99: void loadCppcheckCfg ( ) ;
100:
101:
102: std :: list < std :: string > addons@var2085 ;
103:
104:
105: std :: string addonPython@var2086 ;
106:
107:
108: std :: vector < std :: string > basePaths@var2087 ;
109:
110:
111: std :: string buildDir@var2088 ;
112:
113:
114: bool checkAllConfigurations@var2089 ;
115:
116:
117: bool checkConfiguration@var2090 ;
118:
|
121:
122: bool checkHeaders@var2091 ;
123:
124:
125: bool checkLibrary@var2092 ;
126:
127:
128: std :: set < std :: string > checkUnknownFunctionReturn@var2093 ;
129:
130:
131: bool checkUnusedTemplates@var2094 ;
132:
133:
134: bool clang@var2095 ;
135:
136:
137: std :: string clangExecutable@var2096 ;
138:
139:
140: bool clangTidy@var2097 ;
141:
142:
143: std :: set < std :: string > configExcludePaths@var2098 ;
144:
145:
146: std :: string cppcheckCfgProductName@var2099 ;
147:
148:
149: std :: string cppcheckCfgAbout@var2100 ;
150:
151:
152: bool daca@var2101 ;
153:
154:
155: bool debugnormal@var2102 ;
156:
157:
158: bool debugSimplified@var2103 ;
159:
160:
161: bool debugtemplate@var2104 ;
162:
163:
164: bool debugwarnings@var2105 ;
165:
166:
167: bool dump@var2106 ;
168: std :: string dumpFile@var2107 ;
169:
170: enum Language {
171: None , C , CPP
172: } ;
173:
174:
175: Language enforcedLang@var2108 ;
176:
177:
178: bool exceptionHandling@var2109 ;
179:
180:
181: std :: string exename@var2110 ;
182:
183:
184:
185: int exitCode@var2111 ;
186:
187:
188: std :: vector < std :: string > fileFilters@var2112 ;
189:
190:
191: bool force@var2113 ;
192:
193:
194:
195: std :: list < std :: string > includePaths@var2114 ;
196:
197:
198: bool inlineSuppressions@var2115 ;
199:
200:
201:
202: unsigned int jobs@var2116 ;
203:
|
206:
207: bool jointSuppressionReport@var2117 ;
208:
209:
210: std :: list < std :: string > libraries@var2118 ;
211:
212:
213: Library library@var2119 ;
214:
215:
216:
217: int loadAverage@var2120 ;
218:
|
221:
222: int maxConfigs@var2121 ;
223:
224:
225: int maxCtuDepth@var2122 ;
226:
227:
228: int maxTemplateRecursion@var2123 ;
229:
230:
231: Suppressions nofail@var2124 ;
232:
233:
234: Suppressions nomsg@var2125 ;
235:
236:
237: std :: string outputFile@var2126 ;
238:
239:
240: std :: string plistOutput@var2127 ;
241:
242:
243: bool preprocessOnly@var2128 ;
244:
245: ImportProject project@var2129 ;
246:
247:
248: bool quiet@var2130 ;
249:
250:
251: bool relativePaths@var2131 ;
252:
253:
254: bool reportProgress@var2132 ;
255:
256:
257: class Rule {
258: public:
259: Rule ( )
260: : tokenlist@var2133 ( "simple" )
261: , id@var2135 ( "rule" )
262: , severity@var2137 ( Severity :: style ) {
263: }
264:
265: std :: string tokenlist@var2133 ;
266: std :: string pattern@var2134 ;
267: std :: string id@var2135 ;
268: std :: string summary@var2136 ;
269: Severity :: SeverityType severity@var2137 ;
270: } ;
271:
|
274:
275: std :: list < Rule > rules@var2138 ;
276:
277:
278: class SafeChecks {
279: public:
280: SafeChecks ( ) : classes@var2144 ( false ) , externalFunctions@var2145 ( false ) , internalFunctions@var2146 ( false ) , externalVariables@var2147 ( false ) { }
281:
282: static const char XmlRootName@var2139 [ ] ;
283: static const char XmlClasses@var2140 [ ] ;
284: static const char XmlExternalFunctions@var2141 [ ] ;
285: static const char XmlInternalFunctions@var2142 [ ] ;
286: static const char XmlExternalVariables@var2143 [ ] ;
287:
288: void clear ( ) {
289: classes@var2144 =@expr1073746294 externalFunctions@var2145 =@expr1073746295 internalFunctions@var2146 =@expr1073746296 externalVariables@var2147 =@expr1073746297 false ;
290: }
291:
|
297:
298: bool classes@var2144 ;
299:
|
304:
305: bool externalFunctions@var2145 ;
306:
|
310:
311: bool internalFunctions@var2146 ;
312:
|
316:
317: bool externalVariables@var2147 ;
318: } ;
319:
320: SafeChecks safeChecks@var2148 ;
321:
322: SimpleEnableGroup<Severity::SeverityType> severity@var2149 ;
323: SimpleEnableGroup<Certainty::CertaintyLevel> certainty@var2150 ;
324: SimpleEnableGroup<Checks::CheckList> checks@var2151 ;
325:
326:
327: SHOWTIME_MODES showtime@var2152 ;
328:
329:
330: Standards standards@var2153 ;
331:
332:
333:
334: std :: string templateFormat@var2154 ;
335:
336:
337:
338: std :: string templateLocation@var2155 ;
339:
340:
341: std :: string userDefines@var2156 ;
342:
343:
344: std :: set < std :: string > userUndefs@var2157 ;
345:
346:
347: std :: list < std :: string > userIncludes@var2158 ;
348:
349:
350: bool verbose@var2159 ;
351:
352:
353: bool xml@var2160 ;
354:
355:
356: int xml_version@var2161 ;
357:
|
361:
362: bool configurationExcluded ( const std :: string & file@var2162 ) const {
363: for (@expr1073746298 const std ::@expr1073746299 string &@expr1073746300 configExcludePath@var2163 :@expr1073746301 configExcludePaths@var2098 ) {
364: if (@expr1073746302 file@var2162 .@expr1073746303 length (@expr1073746304 ) >=@expr1073746305 configExcludePath@var2163 .@expr4482 length (@expr4483 ) &&@expr1073746308 file@var2162 .@expr1073746309 compare (@expr1073746310 0 , configExcludePath@var2163 .@expr4482 length (@expr4483 ) , configExcludePath@var2163 ) ==@expr1073746313 0 ) {
365: return true ;
366: }
367: }
368: return false ;
369: }
370:
|
376:
377: std :: string addEnabled ( const std :: string & str@var2164 ) ;
378:
|
382:
383: bool isEnabled ( const ValueFlow :: Value * value@var2165 , bool inconclusiveCheck@var2166 = false ) const ;
384:
385:
386: bool posix ( ) const {
387: return std ::@expr1073746314 find (@expr1073746315 libraries@var2118 .@expr1073746316 begin (@expr1073746317 ) , libraries@var2118 .@expr4494 end (@expr4495 ) , "posix" ) !=@expr1073746320 libraries@var2118 .@expr4494 end (@expr4495 ) ;
388: }
389:
390:
391: static void terminate ( bool t@var2167 = true ) {
392: Settings ::@expr1073746323 mTerminated@var2084 =@expr1073746324 t@var2167 ;
393: }
394:
395:
396: static bool terminated ( ) {
397: return Settings ::@expr1073746325 mTerminated@var2084 ;
398: }
399:
400: std :: set < std :: string > summaryReturn@var2168 ;
401:
402: void loadSummaries ( ) ;
403: } ;

##file cppcheck-2.8/lib/tokenlist.cpp

1:
|
44:
45: static const int AST_MAX_DEPTH@var2169 = 100 ;
46:
47:
48: TokenList :: TokenList ( const Settings * settings@var2170 ) :
49: mTokensFrontBack@var746 ( ) ,
50: mSettings@var749 ( settings@var2170 ) ,
51: mIsC@var751 ( false ) ,
52: mIsCpp@var752 ( false )
53: {
54: mTokensFrontBack@var746 .@expr1073746326 list@var2491 =@expr1073746327 this@expr1073746328 ;
55: mKeywords@var750 .@expr4505 insert (@expr1073746330 "auto" ) ;
56: mKeywords@var750 .@expr4505 insert (@expr1073746332 "break" ) ;
57: mKeywords@var750 .@expr4505 insert (@expr1073746334 "case" ) ;
58:
59: mKeywords@var750 .@expr4505 insert (@expr1073746336 "const" ) ;
60: mKeywords@var750 .@expr4505 insert (@expr1073746338 "continue" ) ;
61: mKeywords@var750 .@expr4505 insert (@expr1073746340 "default" ) ;
62: mKeywords@var750 .@expr4505 insert (@expr1073746342 "do" ) ;
63:
64: mKeywords@var750 .@expr4505 insert (@expr1073746344 "else" ) ;
65: mKeywords@var750 .@expr4505 insert (@expr1073746346 "enum" ) ;
66: mKeywords@var750 .@expr4505 insert (@expr1073746348 "extern" ) ;
67:
68: mKeywords@var750 .@expr4505 insert (@expr1073746350 "for" ) ;
69: mKeywords@var750 .@expr4505 insert (@expr1073746352 "goto" ) ;
70: mKeywords@var750 .@expr4505 insert (@expr1073746354 "if" ) ;
71: mKeywords@var750 .@expr4505 insert (@expr1073746356 "inline" ) ;
72:
73:
74: mKeywords@var750 .@expr4505 insert (@expr1073746358 "register" ) ;
75: mKeywords@var750 .@expr4505 insert (@expr1073746360 "restrict" ) ;
76: mKeywords@var750 .@expr4505 insert (@expr1073746362 "return" ) ;
77:
78: mKeywords@var750 .@expr4505 insert (@expr1073746364 "signed" ) ;
79: mKeywords@var750 .@expr4505 insert (@expr1073746366 "sizeof" ) ;
80: mKeywords@var750 .@expr4505 insert (@expr1073746368 "static" ) ;
81: mKeywords@var750 .@expr4505 insert (@expr1073746370 "struct" ) ;
82: mKeywords@var750 .@expr4505 insert (@expr1073746372 "switch" ) ;
83: mKeywords@var750 .@expr4505 insert (@expr1073746374 "typedef" ) ;
84: mKeywords@var750 .@expr4505 insert (@expr1073746376 "union" ) ;
85: mKeywords@var750 .@expr4505 insert (@expr1073746378 "unsigned" ) ;
86: mKeywords@var750 .@expr4505 insert (@expr1073746380 "void" ) ;
87: mKeywords@var750 .@expr4505 insert (@expr1073746382 "volatile" ) ;
88: mKeywords@var750 .@expr4505 insert (@expr1073746384 "while" ) ;
89: }
90:
91: TokenList :: ~ TokenList ( )
92: {
93: deallocateTokens (@expr1073746385 ) ;
94: }
95:
96:
97:
98: const std :: string & TokenList :: getSourceFilePath ( ) const
99: {
100: if (@expr1073746386 getFiles (@expr4563 ) .@expr1073746388 empty (@expr1073746389 ) ) {
101: return emptyString@var1 ;
102: }
103: return getFiles (@expr4563 ) [@expr1073746391 0 ] ;
104: }
105:
|
108:
109: void TokenList :: deallocateTokens ( )
110: {
111: deleteTokens (@expr1073746392 mTokensFrontBack@var746 .@expr4569 front@var2492 ) ;
112: mTokensFrontBack@var746 .@expr4569 front@var2492 =@expr1073746395 nullptr ;
113: mTokensFrontBack@var746 .@expr1073746396 back@var2493 =@expr1073746397 nullptr ;
114: mFiles@var747 .@expr1073746398 clear (@expr1073746399 ) ;
115: }
116:
117: void TokenList :: determineCppC ( )
118: {
119: if (@expr1073746400 !@expr4577 mSettings@var749 ) {
120: mIsC@var751 =@expr1073746402 Path ::@expr4579 isC (@expr4580 getSourceFilePath (@expr4581 ) ) ;
121: mIsCpp@var752 =@expr1073746406 Path ::@expr4583 isCPP (@expr4584 getSourceFilePath (@expr4581 ) ) ;
122: } else {
123: mIsC@var751 =@expr1073746410 mSettings@var749 .@expr4587 enforcedLang@var2494 ==@expr1073746412 Settings ::@expr1073746413 C ||@expr1073746414 (@expr1073746415 mSettings@var749 .@expr4587 enforcedLang@var2494 ==@expr4593 Settings ::@expr4594 None &&@expr1073746419 Path ::@expr4579 isC (@expr4580 getSourceFilePath (@expr4581 ) ) ) ;
124: mIsCpp@var752 =@expr1073746423 mSettings@var749 .@expr4587 enforcedLang@var2494 ==@expr1073746425 Settings ::@expr1073746426 CPP ||@expr1073746427 (@expr1073746428 mSettings@var749 .@expr4587 enforcedLang@var2494 ==@expr4593 Settings ::@expr4594 None &&@expr1073746432 Path ::@expr4583 isCPP (@expr4584 getSourceFilePath (@expr4581 ) ) ) ;
125: }
126:
127: if (@expr1073746436 mIsCpp@var752 ) {
128:
129: mKeywords@var750 .@expr4613 insert (@expr1073746438 "catch" ) ;
130: mKeywords@var750 .@expr4613 insert (@expr1073746440 "class" ) ;
131: mKeywords@var750 .@expr4613 insert (@expr1073746442 "constexpr" ) ;
132: mKeywords@var750 .@expr4613 insert (@expr1073746444 "const_cast" ) ;
133: mKeywords@var750 .@expr4613 insert (@expr1073746446 "decltype" ) ;
134: mKeywords@var750 .@expr4613 insert (@expr1073746448 "delete" ) ;
135: mKeywords@var750 .@expr4613 insert (@expr1073746450 "dynamic_cast" ) ;
136: mKeywords@var750 .@expr4613 insert (@expr1073746452 "explicit" ) ;
137: mKeywords@var750 .@expr4613 insert (@expr1073746454 "export" ) ;
138:
139: mKeywords@var750 .@expr4613 insert (@expr1073746456 "friend" ) ;
140: mKeywords@var750 .@expr4613 insert (@expr1073746458 "mutable" ) ;
141: mKeywords@var750 .@expr4613 insert (@expr1073746460 "namespace" ) ;
142: mKeywords@var750 .@expr4613 insert (@expr1073746462 "new" ) ;
143: mKeywords@var750 .@expr4613 insert (@expr1073746464 "noexcept" ) ;
144: mKeywords@var750 .@expr4613 insert (@expr1073746466 "operator" ) ;
145: mKeywords@var750 .@expr4613 insert (@expr1073746468 "private" ) ;
146: mKeywords@var750 .@expr4613 insert (@expr1073746470 "protected" ) ;
147: mKeywords@var750 .@expr4613 insert (@expr1073746472 "public" ) ;
148: mKeywords@var750 .@expr4613 insert (@expr1073746474 "reinterpret_cast" ) ;
149: mKeywords@var750 .@expr4613 insert (@expr1073746476 "static_assert" ) ;
150: mKeywords@var750 .@expr4613 insert (@expr1073746478 "static_cast" ) ;
151: mKeywords@var750 .@expr4613 insert (@expr1073746480 "template" ) ;
152: mKeywords@var750 .@expr4613 insert (@expr1073746482 "this" ) ;
153: mKeywords@var750 .@expr4613 insert (@expr1073746484 "thread_local" ) ;
154: mKeywords@var750 .@expr4613 insert (@expr1073746486 "throw" ) ;
155:
156: mKeywords@var750 .@expr4613 insert (@expr1073746488 "try" ) ;
157: mKeywords@var750 .@expr4613 insert (@expr1073746490 "typeid" ) ;
158: mKeywords@var750 .@expr4613 insert (@expr1073746492 "typename" ) ;
159: mKeywords@var750 .@expr4613 insert (@expr1073746494 "typeof" ) ;
160: mKeywords@var750 .@expr4613 insert (@expr1073746496 "using" ) ;
161: mKeywords@var750 .@expr4613 insert (@expr1073746498 "virtual" ) ;
162:
163: if (@expr1073746499 !@expr4577 mSettings@var749 ||@expr1073746501 mSettings@var749 .@expr1073746502 standards@var2495 .@expr1073746503 cpp@var2496 >=@expr1073746504 Standards ::@expr1073746505 CPP20 ) {
164: mKeywords@var750 .@expr4613 insert (@expr1073746507 "alignas" ) ;
165: mKeywords@var750 .@expr4613 insert (@expr1073746509 "alignof" ) ;
166: mKeywords@var750 .@expr4613 insert (@expr1073746511 "axiom" ) ;
167: mKeywords@var750 .@expr4613 insert (@expr1073746513 "co_await" ) ;
168: mKeywords@var750 .@expr4613 insert (@expr1073746515 "co_return" ) ;
169: mKeywords@var750 .@expr4613 insert (@expr1073746517 "co_yield" ) ;
170: mKeywords@var750 .@expr4613 insert (@expr1073746519 "concept" ) ;
171: mKeywords@var750 .@expr4613 insert (@expr1073746521 "synchronized" ) ;
172: mKeywords@var750 .@expr4613 insert (@expr1073746523 "consteval" ) ;
173: mKeywords@var750 .@expr4613 insert (@expr1073746525 "reflexpr" ) ;
174: mKeywords@var750 .@expr4613 insert (@expr1073746527 "requires" ) ;
175: }
176: }
177: }
178:
179: int TokenList :: appendFileIfNew ( const std :: string & fileName@var2171 )
180: {
181:
182: for (@expr1073746528 int i@var2172 =@expr1073746529 0 ; i@var2172 <@expr1073746530 mFiles@var747 .@expr4707 size (@expr4708 ) ; ++@expr1073746533 i@var2172 ) {
183: if (@expr1073746534 Path ::@expr1073746535 sameFileName (@expr1073746536 mFiles@var747 [@expr1073746537 i@var2172 ] , fileName@var2171 ) ) {
184: return i@var2172 ; } }
185:
186:
187: mFiles@var747 .@expr1073746538 push_back (@expr1073746539 fileName@var2171 ) ;
188:
189:
190: if (@expr1073746540 mFiles@var747 .@expr4707 size (@expr4708 ) ==@expr1073746543 1 ) {
191: determineCppC (@expr1073746544 ) ;
192: }
193: return mFiles@var747 .@expr4707 size (@expr4708 ) -@expr1073746547 1 ;
194: }
195:
196: void TokenList :: clangSetOrigFiles ( )
197: {
198: mOrigFiles@var748 =@expr1073746548 mFiles@var747 ;
199: }
200:
201: void TokenList :: deleteTokens ( Token * tok@var2173 )
202: {
203: while (@expr1073746549 tok@var2173 ) {
204: Token * next@var2174 ; next@var2174 =@expr1073746550 tok@var2173 .@expr1073746551 next (@expr1073746552 ) ;
205: delete tok@var2173 ;
206: tok@var2173 =@expr1073746553 next@var2174 ;
207: }
208: }
209:
|
213:
214: void TokenList :: addtoken ( const std :: string & str@var2175 , const int lineno@var2176 , const int column@var2177 , const int fileno@var2178 , bool split@var2179 )
215: {
216: if (@expr1073746555 str@var2175 .@expr1073746556 empty (@expr1073746557 ) ) {
217: return ; }
218:
219:
220: if (@expr1073746558 split@var2179 ) {
221: unsigned long begin@var2180 ; begin@var2180 =@expr1073746559 0 ;
222: unsigned long end@var2181 ; end@var2181 =@expr1073746560 0 ;
223: while (@expr1073746561 (@expr1073746562 end@var2181 =@expr1073746563 str@var2175 .@expr1073746564 find (@expr1073746565 "##" , begin@var2180 ) ) !=@expr1073746566 std ::@expr1073746567 string ::@expr1073746568 npos@expr1073746554 ) {
224: addtoken (@expr1073746569 str@var2175 .@expr4746 substr (@expr1073746571 begin@var2180 , end@var2181 -@expr1073746572 begin@var2180 ) , lineno@var2176 , fileno@var2178 , false ) ;
225: addtoken (@expr1073746573 "##" , lineno@var2176 , column@var2177 , fileno@var2178 , false ) ;
226: begin@var2180 =@expr1073746574 end@var2181 +@expr1073746575 2 ;
227: }
228: if (@expr1073746576 begin@var2180 !=@expr1073746577 0 ) {
229: addtoken (@expr1073746578 str@var2175 .@expr4746 substr (@expr1073746580 begin@var2180 ) , lineno@var2176 , column@var2177 , fileno@var2178 , false ) ;
230: return ;
231: }
232: }
233:
234: if (@expr1073746581 mTokensFrontBack@var746 .@expr4758 back@var2493 ) {
235: mTokensFrontBack@var746 .@expr4758 back@var2493 .@expr1073746584 insertToken (@expr1073746585 str@var2175 ) ;
236: } else {
237: mTokensFrontBack@var746 .@expr4762 front@var2492 =@expr1073746587 new Token (@expr1073746588 &@expr1073746589 mTokensFrontBack@var746 ) ;
238: mTokensFrontBack@var746 .@expr4758 back@var2493 =@expr1073746591 mTokensFrontBack@var746 .@expr4762 front@var2492 ;
239: mTokensFrontBack@var746 .@expr4758 back@var2493 .@expr1073746594 str (@expr1073746595 str@var2175 ) ;
240: }
241:
242: mTokensFrontBack@var746 .@expr4758 back@var2493 .@expr1073746597 linenr (@expr1073746598 lineno@var2176 ) ;
243: mTokensFrontBack@var746 .@expr4758 back@var2493 .@expr1073746600 column (@expr1073746601 column@var2177 ) ;
244: mTokensFrontBack@var746 .@expr4758 back@var2493 .@expr1073746603 fileIndex (@expr1073746604 fileno@var2178 ) ;
245: }
246:
247: void TokenList :: addtoken ( const std :: string & str@var2182 , const Token * locationTok@var2183 )
248: {
249: if (@expr1073746605 str@var2182 .@expr1073746606 empty (@expr1073746607 ) ) {
250: return ; }
251:
252: if (@expr1073746608 mTokensFrontBack@var746 .@expr4785 back@var2493 ) {
253: mTokensFrontBack@var746 .@expr4785 back@var2493 .@expr1073746611 insertToken (@expr1073746612 str@var2182 ) ;
254: } else {
255: mTokensFrontBack@var746 .@expr4789 front@var2492 =@expr1073746614 new Token (@expr1073746615 &@expr1073746616 mTokensFrontBack@var746 ) ;
256: mTokensFrontBack@var746 .@expr4785 back@var2493 =@expr1073746618 mTokensFrontBack@var746 .@expr4789 front@var2492 ;
257: mTokensFrontBack@var746 .@expr4785 back@var2493 .@expr1073746621 str (@expr1073746622 str@var2182 ) ;
258: }
259:
260: mTokensFrontBack@var746 .@expr4785 back@var2493 .@expr1073746624 linenr (@expr1073746625 locationTok@var2183 .@expr1073746626 linenr (@expr1073746627 ) ) ;
261: mTokensFrontBack@var746 .@expr4785 back@var2493 .@expr1073746629 column (@expr1073746630 locationTok@var2183 .@expr1073746631 column (@expr1073746632 ) ) ;
262: mTokensFrontBack@var746 .@expr4785 back@var2493 .@expr1073746634 fileIndex (@expr1073746635 locationTok@var2183 .@expr1073746636 fileIndex (@expr1073746637 ) ) ;
263: }
264:
265: void TokenList :: addtoken ( const Token * tok@var2184 , const int lineno@var2185 , const int column@var2186 , const int fileno@var2187 )
266: {
267: if (@expr1073746638 tok@var2184 ==@expr1073746639 nullptr ) {
268: return ; }
269:
270: if (@expr1073746640 mTokensFrontBack@var746 .@expr4817 back@var2493 ) {
271: mTokensFrontBack@var746 .@expr4817 back@var2493 .@expr1073746643 insertToken (@expr1073746644 tok@var2184 .@expr4821 str (@expr4822 ) , tok@var2184 .@expr4823 originalName (@expr4824 ) ) ;
272: } else {
273: mTokensFrontBack@var746 .@expr4825 front@var2492 =@expr1073746650 new Token (@expr1073746651 &@expr1073746652 mTokensFrontBack@var746 ) ;
274: mTokensFrontBack@var746 .@expr4817 back@var2493 =@expr1073746654 mTokensFrontBack@var746 .@expr4825 front@var2492 ;
275: mTokensFrontBack@var746 .@expr4817 back@var2493 .@expr1073746657 str (@expr1073746658 tok@var2184 .@expr4821 str (@expr4822 ) ) ;
276: if (@expr1073746661 !@expr1073746662 tok@var2184 .@expr4823 originalName (@expr4824 ) .@expr1073746665 empty (@expr1073746666 ) ) {
277: mTokensFrontBack@var746 .@expr4817 back@var2493 .@expr1073746668 originalName (@expr1073746669 tok@var2184 .@expr4823 originalName (@expr4824 ) ) ; }
278: }
279:
280: mTokensFrontBack@var746 .@expr4817 back@var2493 .@expr1073746673 linenr (@expr1073746674 lineno@var2185 ) ;
281: mTokensFrontBack@var746 .@expr4817 back@var2493 .@expr1073746676 column (@expr1073746677 column@var2186 ) ;
282: mTokensFrontBack@var746 .@expr4817 back@var2493 .@expr1073746679 fileIndex (@expr1073746680 fileno@var2187 ) ;
283: mTokensFrontBack@var746 .@expr4817 back@var2493 .@expr1073746682 flags (@expr1073746683 tok@var2184 .@expr1073746684 flags (@expr1073746685 ) ) ;
284: }
285:
286: void TokenList :: addtoken ( const Token * tok@var2188 , const Token * locationTok@var2189 )
287: {
288: if (@expr1073746686 tok@var2188 ==@expr1073746687 nullptr ||@expr1073746688 locationTok@var2189 ==@expr1073746689 nullptr ) {
289: return ; }
290:
291: if (@expr1073746690 mTokensFrontBack@var746 .@expr4867 back@var2493 ) {
292: mTokensFrontBack@var746 .@expr4867 back@var2493 .@expr1073746693 insertToken (@expr1073746694 tok@var2188 .@expr4871 str (@expr4872 ) , tok@var2188 .@expr4873 originalName (@expr4874 ) ) ;
293: } else {
294: mTokensFrontBack@var746 .@expr4875 front@var2492 =@expr1073746700 new Token (@expr1073746701 &@expr1073746702 mTokensFrontBack@var746 ) ;
295: mTokensFrontBack@var746 .@expr4867 back@var2493 =@expr1073746704 mTokensFrontBack@var746 .@expr4875 front@var2492 ;
296: mTokensFrontBack@var746 .@expr4867 back@var2493 .@expr1073746707 str (@expr1073746708 tok@var2188 .@expr4871 str (@expr4872 ) ) ;
297: if (@expr1073746711 !@expr1073746712 tok@var2188 .@expr4873 originalName (@expr4874 ) .@expr1073746715 empty (@expr1073746716 ) ) {
298: mTokensFrontBack@var746 .@expr4867 back@var2493 .@expr1073746718 originalName (@expr1073746719 tok@var2188 .@expr4873 originalName (@expr4874 ) ) ; }
299: }
300:
301: mTokensFrontBack@var746 .@expr4867 back@var2493 .@expr1073746723 flags (@expr1073746724 tok@var2188 .@expr1073746725 flags (@expr1073746726 ) ) ;
302: mTokensFrontBack@var746 .@expr4867 back@var2493 .@expr1073746728 linenr (@expr1073746729 locationTok@var2189 .@expr1073746730 linenr (@expr1073746731 ) ) ;
303: mTokensFrontBack@var746 .@expr4867 back@var2493 .@expr1073746733 column (@expr1073746734 locationTok@var2189 .@expr1073746735 column (@expr1073746736 ) ) ;
304: mTokensFrontBack@var746 .@expr4867 back@var2493 .@expr1073746738 fileIndex (@expr1073746739 locationTok@var2189 .@expr1073746740 fileIndex (@expr1073746741 ) ) ;
305: }
306:
307: void TokenList :: addtoken ( const Token * tok@var2190 )
308: {
309: if (@expr1073746742 tok@var2190 ==@expr1073746743 nullptr ) {
310: return ; }
311:
312: if (@expr1073746744 mTokensFrontBack@var746 .@expr4921 back@var2493 ) {
313: mTokensFrontBack@var746 .@expr4921 back@var2493 .@expr1073746747 insertToken (@expr1073746748 tok@var2190 .@expr4925 str (@expr4926 ) , tok@var2190 .@expr4927 originalName (@expr4928 ) ) ;
314: } else {
315: mTokensFrontBack@var746 .@expr4929 front@var2492 =@expr1073746754 new Token (@expr1073746755 &@expr1073746756 mTokensFrontBack@var746 ) ;
316: mTokensFrontBack@var746 .@expr4921 back@var2493 =@expr1073746758 mTokensFrontBack@var746 .@expr4929 front@var2492 ;
317: mTokensFrontBack@var746 .@expr4921 back@var2493 .@expr1073746761 str (@expr1073746762 tok@var2190 .@expr4925 str (@expr4926 ) ) ;
318: if (@expr1073746765 !@expr1073746766 tok@var2190 .@expr4927 originalName (@expr4928 ) .@expr1073746769 empty (@expr1073746770 ) ) {
319: mTokensFrontBack@var746 .@expr4921 back@var2493 .@expr1073746772 originalName (@expr1073746773 tok@var2190 .@expr4927 originalName (@expr4928 ) ) ; }
320: }
321:
322: mTokensFrontBack@var746 .@expr4921 back@var2493 .@expr1073746777 flags (@expr1073746778 tok@var2190 .@expr1073746779 flags (@expr1073746780 ) ) ;
323: mTokensFrontBack@var746 .@expr4921 back@var2493 .@expr1073746782 linenr (@expr1073746783 tok@var2190 .@expr1073746784 linenr (@expr1073746785 ) ) ;
324: mTokensFrontBack@var746 .@expr4921 back@var2493 .@expr1073746787 column (@expr1073746788 tok@var2190 .@expr1073746789 column (@expr1073746790 ) ) ;
325: mTokensFrontBack@var746 .@expr4921 back@var2493 .@expr1073746792 fileIndex (@expr1073746793 tok@var2190 .@expr1073746794 fileIndex (@expr1073746795 ) ) ;
326: }
327:
|
332:
333: Token * TokenList :: copyTokens ( Token * dest@var2191 , const Token * first@var2192 , const Token * last@var2193 , bool one_line@var2194 )
334: {
335: std ::@expr1073746796 stack < Token *@expr4973 > links@var2195 ;
336: Token * tok2@var2196 ; tok2@var2196 =@expr1073746798 dest@var2191 ;
337: int linenr@var2197 ; linenr@var2197 =@expr1073746799 dest@var2191 .@expr1073746800 linenr (@expr1073746801 ) ;
338: const int commonFileIndex@var2198 =@expr1073746802 dest@var2191 .@expr1073746803 fileIndex (@expr1073746804 ) ;
339: for (@expr1073746805 const Token *@expr4973 tok@var2199 =@expr1073746807 first@var2192 ; tok@var2199 !=@expr1073746808 last@var2193 .@expr1073746809 next (@expr1073746810 ) ; tok@var2199 =@expr1073746811 tok@var2199 .@expr4988 next (@expr4989 ) ) {
340: tok2@var2196 .@expr1073746814 insertToken (@expr1073746815 tok@var2199 .@expr1073746816 str (@expr1073746817 ) ) ;
341: tok2@var2196 =@expr1073746818 tok2@var2196 .@expr1073746819 next (@expr1073746820 ) ;
342: tok2@var2196 .@expr1073746821 fileIndex (@expr1073746822 commonFileIndex@var2198 ) ;
343: tok2@var2196 .@expr1073746823 linenr (@expr1073746824 linenr@var2197 ) ;
344: tok2@var2196 .@expr1073746825 tokType (@expr1073746826 tok@var2199 .@expr1073746827 tokType (@expr1073746828 ) ) ;
345: tok2@var2196 .@expr1073746829 flags (@expr1073746830 tok@var2199 .@expr1073746831 flags (@expr1073746832 ) ) ;
346: tok2@var2196 .@expr1073746833 varId (@expr1073746834 tok@var2199 .@expr1073746835 varId (@expr1073746836 ) ) ;
347:
348:
349: if (@expr1073746837 Token ::@expr5014 Match (@expr1073746839 tok2@var2196 , "(|[|{" ) ) {
350: links@var2195 .@expr1073746840 push (@expr1073746841 tok2@var2196 ) ; }
351: else { if (@expr1073746842 Token ::@expr5014 Match (@expr1073746844 tok2@var2196 , ")|]|}" ) ) {
352: if (@expr1073746845 links@var2195 .@expr1073746846 empty (@expr1073746847 ) ) {
353: return tok2@var2196 ; }
354:
355: Token * link@var2200 ; link@var2200 =@expr1073746848 links@var2195 .@expr1073746849 top (@expr1073746850 ) ;
356:
357: tok2@var2196 .@expr1073746851 link (@expr1073746852 link@var2200 ) ;
358: link@var2200 .@expr1073746853 link (@expr1073746854 tok2@var2196 ) ;
359:
360: links@var2195 .@expr1073746855 pop (@expr1073746856 ) ;
361: } }
362: if (@expr1073746857 !@expr1073746858 one_line@var2194 &&@expr1073746859 tok@var2199 .@expr4988 next (@expr4989 ) ) {
363: linenr@var2197 +=@expr1073746862 tok@var2199 .@expr4988 next (@expr4989 ) .@expr1073746865 linenr (@expr1073746866 ) -@expr1073746867 tok@var2199 .@expr1073746868 linenr (@expr1073746869 ) ; }
364: }
365: return tok2@var2196 ;
366: }
367:
|
371:
372: void TokenList :: insertTokens ( Token * dest@var2201 , const Token * src@var2202 , int n@var2203 )
373: {
374: std ::@expr1073746870 stack < Token *@expr1073746871 > link@var2204 ;
375:
376: while (@expr1073746872 n@var2203 >@expr1073746873 0 ) {
377: dest@var2201 .@expr1073746874 insertToken (@expr1073746875 src@var2202 .@expr1073746876 str (@expr1073746877 ) , src@var2202 .@expr1073746878 originalName (@expr1073746879 ) ) ;
378: dest@var2201 =@expr1073746880 dest@var2201 .@expr1073746881 next (@expr1073746882 ) ;
379:
380:
381: if (@expr1073746883 Token ::@expr5060 Match (@expr1073746885 dest@var2201 , "(|[|{" ) ) {
382: link@var2204 .@expr1073746886 push (@expr1073746887 dest@var2201 ) ; }
383: else { if (@expr1073746888 !@expr1073746889 link@var2204 .@expr1073746890 empty (@expr1073746891 ) &&@expr1073746892 Token ::@expr5060 Match (@expr1073746894 dest@var2201 , ")|]|}" ) ) {
384: Token ::@expr1073746895 createMutualLinks (@expr1073746896 dest@var2201 , link@var2204 .@expr1073746897 top (@expr1073746898 ) ) ;
385: link@var2204 .@expr1073746899 pop (@expr1073746900 ) ;
386: } }
387:
388: dest@var2201 .@expr1073746901 fileIndex (@expr1073746902 src@var2202 .@expr1073746903 fileIndex (@expr1073746904 ) ) ;
389: dest@var2201 .@expr1073746905 linenr (@expr1073746906 src@var2202 .@expr1073746907 linenr (@expr1073746908 ) ) ;
390: dest@var2201 .@expr1073746909 column (@expr1073746910 src@var2202 .@expr1073746911 column (@expr1073746912 ) ) ;
391: dest@var2201 .@expr1073746913 varId (@expr1073746914 src@var2202 .@expr1073746915 varId (@expr1073746916 ) ) ;
392: dest@var2201 .@expr1073746917 tokType (@expr1073746918 src@var2202 .@expr1073746919 tokType (@expr1073746920 ) ) ;
393: dest@var2201 .@expr1073746921 flags (@expr1073746922 src@var2202 .@expr1073746923 flags (@expr1073746924 ) ) ;
394: src@var2202 =@expr1073746925 src@var2202 .@expr1073746926 next (@expr1073746927 ) ;
395: --@expr1073746928 n@var2203 ;
396: }
397: }
398:
|
402:
403: bool TokenList :: createTokens ( std :: istream & code@var2205 , const std :: string & file0@var2206 )
404: {
405: appendFileIfNew (@expr1073746929 file0@var2206 ) ;
406:
407: simplecpp ::@expr1073746930 OutputList outputList@var2207 ;
408: simplecpp ::@expr1073746931 TokenList tokens@var2208 (@expr1073746932 code@var2205 , mFiles@var747 , file0@var2206 , &@expr1073746933 outputList@var2207 ) ;
409:
410: createTokens (@expr1073746934 std ::@expr1073746935 move (@expr1073746936 tokens@var2208 ) ) ;
411:
412: return outputList@var2207 .@expr1073746937 empty (@expr1073746938 ) ;
413: }
414:
415:
416:
417: void TokenList :: createTokens ( simplecpp :: TokenList && tokenList@var2209 )
418: {
419: if (@expr1073746940 tokenList@var2209 .@expr5117 cfront (@expr5118 ) ) {
420: mOrigFiles@var748 =@expr1073746943 mFiles@var747 =@expr1073746944 tokenList@var2209 .@expr5117 cfront (@expr5118 ) .@expr1073746947 location .@expr1073746948 files@expr1073746939 ; }
421: else {
422: mFiles@var747 .@expr1073746949 clear (@expr1073746950 ) ; }
423:
424: determineCppC (@expr1073746951 ) ;
425:
426: for (@expr1073746952 const simplecpp ::@expr5129 Token *@expr1073746954 tok@var2210 =@expr1073746955 tokenList@var2209 .@expr5117 cfront (@expr5118 ) ; tok@var2210 ; ) {
427:
428: std ::@expr1073746958 string str@var2211 ; str@var2211 =@expr1073746959 tok@var2210 .@expr1073746960 str (@expr1073746961 ) ;
429:
430:
431: if (@expr1073746962 str@var2211 .@expr1073746963 size (@expr1073746964 ) >@expr1073746965 1 &&@expr1073746966 str@var2211 [@expr1073746967 0 ] ==@expr1073746968 '.' &&@expr1073746969 std ::@expr1073746970 isdigit (@expr1073746971 str@var2211 [@expr1073746972 1 ] ) ) {
432: str@var2211 =@expr1073746973 '0' +@expr1073746974 str@var2211 ; }
433:
434: if (@expr1073746975 mTokensFrontBack@var746 .@expr5152 back@var2493 ) {
435: mTokensFrontBack@var746 .@expr5152 back@var2493 .@expr1073746978 insertToken (@expr1073746979 str@var2211 ) ;
436: } else {
437: mTokensFrontBack@var746 .@expr5156 front@var2492 =@expr1073746981 new Token (@expr1073746982 &@expr1073746983 mTokensFrontBack@var746 ) ;
438: mTokensFrontBack@var746 .@expr5152 back@var2493 =@expr1073746985 mTokensFrontBack@var746 .@expr5156 front@var2492 ;
439: mTokensFrontBack@var746 .@expr5152 back@var2493 .@expr1073746988 str (@expr1073746989 str@var2211 ) ;
440: }
441:
442: mTokensFrontBack@var746 .@expr5152 back@var2493 .@expr1073746991 fileIndex (@expr1073746992 tok@var2210 .@expr5169 location@var2212 .@expr1073746994 fileIndex@var2213 ) ;
443: mTokensFrontBack@var746 .@expr5152 back@var2493 .@expr1073746996 linenr (@expr1073746997 tok@var2210 .@expr5169 location@var2212 .@expr1073746999 line@var2214 ) ;
444: mTokensFrontBack@var746 .@expr5152 back@var2493 .@expr1073747001 column (@expr1073747002 tok@var2210 .@expr5169 location@var2212 .@expr1073747004 col@var2215 ) ;
445: mTokensFrontBack@var746 .@expr5152 back@var2493 .@expr1073747006 isExpandedMacro (@expr1073747007 !@expr1073747008 tok@var2210 .@expr1073747009 macro@var2216 .@expr1073747010 empty (@expr1073747011 ) ) ;
446:
447: tok@var2210 =@expr1073747012 tok@var2210 .@expr1073747013 next@var2217 ;
448: if (@expr1073747014 tok@var2210 ) {
449: tokenList@var2209 .@expr1073747015 deleteToken (@expr1073747016 tok@var2210 .@expr1073747017 previous@var2218 ) ; }
450: }
451:
452: if (@expr1073747018 mSettings@var749 &&@expr1073747019 mSettings@var749 .@expr1073747020 relativePaths@var2497 ) {
453: for (@expr1073747021 std ::@expr5129 string &@expr1073747023 mFile@var2219 :@expr1073747024 mFiles@var747 ) {
454: mFile@var2219 =@expr1073747025 Path ::@expr1073747026 getRelativePath (@expr1073747027 mFile@var2219 , mSettings@var749 .@expr1073747028 basePaths@var2498 ) ; }
455: }
456:
457: Token ::@expr1073747029 assignProgressValues (@expr1073747030 mTokensFrontBack@var746 .@expr5156 front@var2492 ) ;
458: }
459:
460:
461:
462: unsigned long long TokenList :: calculateChecksum ( ) const
463: {
464: unsigned long long checksum@var2220 ; checksum@var2220 =@expr1073747032 0 ;
465: for (@expr1073747033 const Token *@expr1073747034 tok@var2221 =@expr1073747035 front (@expr1073747036 ) ; tok@var2221 ; tok@var2221 =@expr1073747037 tok@var2221 .@expr1073747038 next (@expr1073747039 ) ) {
466: const unsigned int subchecksum1@var2222 =@expr1073747040 tok@var2221 .@expr1073747041 flags (@expr1073747042 ) +@expr1073747043 tok@var2221 .@expr1073747044 varId (@expr1073747045 ) +@expr1073747046 tok@var2221 .@expr1073747047 tokType (@expr1073747048 ) ;
467: unsigned int subchecksum2@var2223 ; subchecksum2@var2223 =@expr1073747049 0 ;
468: for (@expr1073747050 char i@var2224 :@expr1073747051 tok@var2221 .@expr1073747052 str (@expr1073747053 ) ) {
469: subchecksum2@var2223 +=@expr1073747054 (@expr1073747055 unsigned int ) i@var2224 ; }
470: if (@expr1073747056 !@expr1073747057 tok@var2221 .@expr5234 originalName (@expr5235 ) .@expr1073747060 empty (@expr1073747061 ) ) {
471: for (@expr1073747062 char i@var2225 :@expr1073747063 tok@var2221 .@expr5234 originalName (@expr5235 ) ) {
472: subchecksum2@var2223 +=@expr1073747066 (@expr1073747067 unsigned int ) i@var2225 ; }
473: }
474:
475: checksum@var2220 ^=@expr1073747068 (@expr1073747069 (@expr1073747070 static_cast < unsigned long long > (@expr1073747071 subchecksum1@var2222 ) <<@expr1073747072 32 ) |@expr1073747073 subchecksum2@var2223 ) ;
476:
477: const bool bit1@var2226 =@expr1073747074 (@expr1073747075 checksum@var2220 &@expr1073747076 1 ) !=@expr1073747077 0 ;
478: checksum@var2220 >>=@expr1073747078 1 ;
479: if (@expr1073747079 bit1@var2226 ) {
480: checksum@var2220 |=@expr1073747080 (@expr1073747081 1ULL <<@expr1073747082 63 ) ; }
481: }
482: return checksum@var2220 ;
483: }
484:
|
487:
488: struct AST_state {
489: std :: stack < Token * > op@var2227 ;
490: int depth@var2228 ;
491: int inArrayAssignment@var2229 ;
492: bool cpp@var2230 ;
493: int assign@var2231 ;
494: bool inCase@var2232 ;
495: bool stopAtColon@var2233 ;
496: const Token * functionCallEndPar@var2234 ;
497: explicit AST_state ( bool cpp@var2235 ) : depth@var2228 ( 0 ) , inArrayAssignment@var2229 ( 0 ) , cpp@var2230 ( cpp@var2235 ) , assign@var2231 ( 0 ) , inCase@var2232 ( false ) , stopAtColon@var2233 ( false ) , functionCallEndPar@var2234 ( nullptr ) { }
498: } ;
499:
500: static Token * skipDecl ( Token * tok@var2236 , std :: vector < Token * > * inner@var2237 = nullptr )
501: {
502: if (@expr1073747083 !@expr1073747084 Token ::@expr5261 Match (@expr1073747086 tok@var2236 .@expr1073747087 previous (@expr1073747088 ) , "( %name%" ) ) {
503: return tok@var2236 ; }
504: Token * vartok@var2238 ; vartok@var2238 =@expr1073747089 tok@var2236 ;
505: while (@expr1073747090 Token ::@expr5261 Match (@expr1073747092 vartok@var2238 , "%name%|*|&|::|<" ) ) {
506: if (@expr1073747093 vartok@var2238 .@expr1073747094 str (@expr1073747095 ) ==@expr1073747096 "<" ) {
507: if (@expr1073747097 vartok@var2238 .@expr5274 link (@expr5275 ) ) {
508: vartok@var2238 =@expr1073747100 vartok@var2238 .@expr5274 link (@expr5275 ) ; }
509: else {
510: return tok@var2236 ; }
511: } else { if (@expr1073747103 Token ::@expr5261 Match (@expr1073747105 vartok@var2238 , "%var% [:=(]" ) ) {
512: return vartok@var2238 ;
513: } else { if (@expr1073747106 Token ::@expr5261 Match (@expr1073747108 vartok@var2238 , "decltype|typeof (" ) &&@expr1073747109 !@expr1073747110 Token ::@expr5261 Match (@expr1073747112 tok@var2236 .@expr1073747113 linkAt (@expr1073747114 1 ) , ") [,)]" ) ) {
514: if (@expr1073747115 inner@var2237 ) {
515: inner@var2237 .@expr1073747116 push_back (@expr1073747117 vartok@var2238 .@expr1073747118 tokAt (@expr1073747119 2 ) ) ; }
516: return vartok@var2238 .@expr1073747120 linkAt (@expr1073747121 1 ) .@expr1073747122 next (@expr1073747123 ) ;
517: } } }
518: vartok@var2238 =@expr1073747124 vartok@var2238 .@expr1073747125 next (@expr1073747126 ) ;
519: }
520: return tok@var2236 ;
521: }
522:
523: static bool iscast ( const Token * tok@var2239 , bool cpp@var2240 )
524: {
525: if (@expr1073747127 !@expr1073747128 Token ::@expr5305 Match (@expr1073747130 tok@var2239 , "( ::| %name%" ) ) {
526: return false ; }
527:
528: if (@expr1073747131 Token ::@expr5308 simpleMatch (@expr1073747133 tok@var2239 .@expr5310 link (@expr5311 ) , ") ( )" ) ) {
529: return false ; }
530:
531: if (@expr1073747136 tok@var2239 .@expr5313 previous (@expr5314 ) &&@expr1073747139 tok@var2239 .@expr5313 previous (@expr5314 ) .@expr1073747142 isName (@expr1073747143 ) &&@expr1073747144 tok@var2239 .@expr5313 previous (@expr5314 ) .@expr1073747147 str (@expr1073747148 ) !=@expr1073747149 "return" &&@expr1073747150
532: (@expr1073747151 !@expr1073747152 cpp@var2240 ||@expr1073747153 !@expr1073747154 Token ::@expr5305 Match (@expr1073747156 tok@var2239 .@expr5313 previous (@expr5314 ) , "delete|throw" ) ) ) {
533: return false ; }
534:
535: if (@expr1073747159 Token ::@expr5308 simpleMatch (@expr1073747161 tok@var2239 .@expr5313 previous (@expr5314 ) , ">" ) &&@expr1073747164 tok@var2239 .@expr5313 previous (@expr5314 ) .@expr1073747167 link (@expr1073747168 ) ) {
536: return false ; }
537:
538: if (@expr1073747169 Token ::@expr5305 Match (@expr1073747171 tok@var2239 , "( (| typeof (" ) &&@expr1073747172 Token ::@expr5305 Match (@expr1073747174 tok@var2239 .@expr5310 link (@expr5311 ) , ") %num%" ) ) {
539: return true ; }
540:
541: if (@expr1073747177 Token ::@expr5305 Match (@expr1073747179 tok@var2239 .@expr5310 link (@expr5311 ) , ") }|)|]|;" ) ) {
542: return false ; }
543:
544: if (@expr1073747182 Token ::@expr5305 Match (@expr1073747184 tok@var2239 .@expr5310 link (@expr5311 ) , ") %cop%" ) &&@expr1073747187 !@expr1073747188 Token ::@expr5305 Match (@expr1073747190 tok@var2239 .@expr5310 link (@expr5311 ) , ") [&*+-~!]" ) ) {
545: return false ; }
546:
547: if (@expr1073747193 Token ::@expr5305 Match (@expr1073747195 tok@var2239 .@expr5313 previous (@expr5314 ) , "= ( %name% ) {" ) &&@expr1073747198 tok@var2239 .@expr5375 next (@expr5376 ) .@expr1073747201 varId (@expr1073747202 ) ==@expr1073747203 0 ) {
548: return true ; }
549:
550: bool type@var2241 ; type@var2241 =@expr1073747204 false ;
551: for (@expr1073747205 const Token *@expr1073747206 tok2@var2242 =@expr1073747207 tok@var2239 .@expr5375 next (@expr5376 ) ; tok2@var2242 ; tok2@var2242 =@expr1073747210 tok2@var2242 .@expr5387 next (@expr5388 ) ) {
552: if (@expr1073747213 tok2@var2242 .@expr1073747214 varId (@expr1073747215 ) !=@expr1073747216 0 ) {
553: return false ; }
554:
555: while (@expr1073747217 tok2@var2242 .@expr5394 link (@expr5395 ) &&@expr1073747220 Token ::@expr5305 Match (@expr1073747222 tok2@var2242 , "(|[|<" ) ) {
556: tok2@var2242 =@expr1073747223 tok2@var2242 .@expr5394 link (@expr5395 ) .@expr1073747226 next (@expr1073747227 ) ; }
557:
558: if (@expr1073747228 tok2@var2242 .@expr1073747229 str (@expr1073747230 ) ==@expr1073747231 ")" ) {
559: if (@expr1073747232 Token ::@expr5308 simpleMatch (@expr1073747234 tok2@var2242 , ") (" ) &&@expr1073747235 Token ::@expr5308 simpleMatch (@expr1073747237 tok2@var2242 .@expr5414 linkAt (@expr5415 1 ) , ") ." ) ) {
560: return true ; }
561: if (@expr1073747240 Token ::@expr5308 simpleMatch (@expr1073747242 tok2@var2242 , ") {" ) &&@expr1073747243 !@expr1073747244 type@var2241 ) {
562: const Token * tok3@var2243 ; tok3@var2243 =@expr1073747245 tok2@var2242 .@expr5414 linkAt (@expr5415 1 ) ;
563: while (@expr1073747248 tok3@var2243 !=@expr5425 tok2@var2242 &&@expr1073747250 Token ::@expr5305 Match (@expr1073747252 tok3@var2243 , "[{}]" ) ) {
564: tok3@var2243 =@expr1073747253 tok3@var2243 .@expr1073747254 previous (@expr1073747255 ) ; }
565: return tok3@var2243 !=@expr5425 tok2@var2242 &&@expr1073747257 tok3@var2243 .@expr1073747258 str (@expr1073747259 ) !=@expr1073747260 ";" ;
566: }
567: return type@var2241 ||@expr1073747261 tok2@var2242 .@expr1073747262 strAt (@expr1073747263 -1 ) ==@expr1073747264 "*" ||@expr1073747265 Token ::@expr5308 simpleMatch (@expr1073747267 tok2@var2242 , ") ~" ) ||@expr1073747268
568: (@expr1073747269 Token ::@expr5305 Match (@expr1073747271 tok2@var2242 , ") %any%" ) &&@expr1073747272
569: (@expr1073747273 !@expr1073747274 tok2@var2242 .@expr5387 next (@expr5388 ) .@expr1073747277 isOp (@expr1073747278 ) ||@expr1073747279 Token ::@expr5305 Match (@expr1073747281 tok2@var2242 .@expr5387 next (@expr5388 ) , "!|~|++|--" ) ) &&@expr1073747284
570: !@expr1073747285 Token ::@expr5305 Match (@expr1073747287 tok2@var2242 .@expr5387 next (@expr5388 ) , "[[]);,?:.]" ) ) ;
571: }
572:
573: if (@expr1073747290 Token ::@expr5305 Match (@expr1073747292 tok2@var2242 , "&|&& )" ) ) {
574: return true ; }
575:
576: if (@expr1073747293 !@expr1073747294 Token ::@expr5305 Match (@expr1073747296 tok2@var2242 , "%name%|*|::" ) ) {
577: return false ; }
578:
579: if (@expr1073747297 tok2@var2242 .@expr1073747298 isStandardType (@expr1073747299 ) &&@expr1073747300 (@expr1073747301 tok2@var2242 .@expr5387 next (@expr5388 ) .@expr1073747304 str (@expr1073747305 ) !=@expr1073747306 "(" ||@expr1073747307 Token ::@expr5305 Match (@expr1073747309 tok2@var2242 .@expr5387 next (@expr5388 ) , "( * *| )" ) ) ) {
580: type@var2241 =@expr1073747312 true ; }
581: }
582:
583: return false ;
584: }
585:
586:
587: static Token * findCppTypeInitPar ( Token * tok@var2244 )
588: {
589: if (@expr1073747313 !@expr5490 tok@var2244 ||@expr1073747315 !@expr1073747316 Token ::@expr5493 Match (@expr1073747318 tok@var2244 .@expr1073747319 previous (@expr1073747320 ) , "[,()] %name%" ) ) {
590: return nullptr ; }
591: bool istype@var2245 ; istype@var2245 =@expr1073747321 false ;
592: while (@expr1073747322 Token ::@expr5493 Match (@expr1073747324 tok@var2244 , "%name%|::|<" ) ) {
593: if (@expr1073747325 tok@var2244 .@expr5502 str (@expr5503 ) ==@expr1073747328 "<" ) {
594: tok@var2244 =@expr1073747329 tok@var2244 .@expr1073747330 link (@expr1073747331 ) ;
595: if (@expr1073747332 !@expr5490 tok@var2244 ) {
596: return nullptr ; }
597: }
598: istype@var2245 |=@expr1073747334 tok@var2244 .@expr1073747335 isStandardType (@expr1073747336 ) ;
599: tok@var2244 =@expr1073747337 tok@var2244 .@expr5514 next (@expr5515 ) ;
600: }
601: if (@expr1073747340 !@expr1073747341 istype@var2245 ) {
602: return nullptr ; }
603: if (@expr1073747342 !@expr1073747343 Token ::@expr5493 Match (@expr5521 tok@var2244 , "[*&]" ) ) {
604: return nullptr ; }
605: while (@expr1073747346 Token ::@expr5493 Match (@expr5521 tok@var2244 , "[*&]" ) ) {
606: tok@var2244 =@expr1073747349 tok@var2244 .@expr5514 next (@expr5515 ) ; }
607: return (@expr1073747352 tok@var2244 &&@expr1073747353 tok@var2244 .@expr5502 str (@expr5503 ) ==@expr1073747356 "(" ) ?@expr1073747357 tok@var2244 :@expr1073747358 nullptr ;
608: }
609:
610:
611: static bool iscpp11init_impl ( const Token * const tok@var2246 ) ;
612: static bool iscpp11init ( const Token * const tok@var2247 )
613: {
614: if (@expr1073747360 tok@var2247 .@expr5537 isCpp11init (@expr5538 ) ==@expr1073747363 TokenImpl ::@expr5540 Cpp11init ::@expr1073747365 UNKNOWN@expr1073747359 ) {
615: tok@var2247 .@expr1073747366 setCpp11init (@expr1073747367 iscpp11init_impl (@expr1073747368 tok@var2247 ) ) ; }
616: return tok@var2247 .@expr5537 isCpp11init (@expr5538 ) ==@expr1073747371 TokenImpl ::@expr5540 Cpp11init ::@expr1073747373 CPP11INIT ;
617: }
618:
619: static bool iscpp11init_impl ( const Token * const tok@var2248 )
620: {
621: if (@expr1073747375 Token ::@expr5552 simpleMatch (@expr1073747377 tok@var2248 , "{" ) &&@expr1073747378 Token ::@expr5552 simpleMatch (@expr1073747380 tok@var2248 .@expr1073747381 link (@expr1073747382 ) .@expr1073747383 previous (@expr1073747384 ) , "; }" ) ) {
622: return false ; }
623: const Token * nameToken@var2249 ; nameToken@var2249 =@expr1073747385 tok@var2248 ;
624: while (@expr1073747386 nameToken@var2249 &&@expr1073747387 nameToken@var2249 .@expr5564 str (@expr5565 ) ==@expr1073747390 "{" ) {
625: if (@expr1073747391 nameToken@var2249 .@expr5568 isCpp11init (@expr5569 ) !=@expr1073747394 TokenImpl ::@expr5571 Cpp11init ::@expr1073747396 UNKNOWN@expr1073747374 ) {
626: return nameToken@var2249 .@expr5568 isCpp11init (@expr5569 ) ==@expr1073747399 TokenImpl ::@expr5571 Cpp11init ::@expr1073747401 CPP11INIT ; }
627: nameToken@var2249 =@expr1073747402 nameToken@var2249 .@expr5579 previous (@expr5580 ) ;
628: if (@expr1073747405 nameToken@var2249 &&@expr1073747406 nameToken@var2249 .@expr5564 str (@expr5565 ) ==@expr1073747409 "," &&@expr1073747410 Token ::@expr5552 simpleMatch (@expr1073747412 nameToken@var2249 .@expr5579 previous (@expr5580 ) , "} ," ) ) {
629: nameToken@var2249 =@expr1073747415 nameToken@var2249 .@expr5592 linkAt (@expr1073747417 -1 ) ; }
630: }
631: if (@expr1073747418 !@expr1073747419 nameToken@var2249 ) {
632: return false ; }
633: if (@expr1073747420 nameToken@var2249 .@expr5564 str (@expr5565 ) ==@expr1073747423 ")" &&@expr1073747424 Token ::@expr5552 simpleMatch (@expr1073747426 nameToken@var2249 .@expr5603 link (@expr5604 ) .@expr5605 previous (@expr5606 ) , "decltype (" ) ) {
634: return true ; }
635: if (@expr1073747431 Token ::@expr5552 simpleMatch (@expr1073747433 nameToken@var2249 , ", {" ) ) {
636: return true ; }
637: if (@expr1073747434 nameToken@var2249 .@expr5564 str (@expr5565 ) ==@expr1073747437 ">" &&@expr1073747438 nameToken@var2249 .@expr5603 link (@expr5604 ) ) {
638: nameToken@var2249 =@expr1073747441 nameToken@var2249 .@expr5603 link (@expr5604 ) .@expr5605 previous (@expr5606 ) ; }
639: if (@expr1073747446 nameToken@var2249 .@expr5564 str (@expr5565 ) ==@expr1073747449 "]" ) {
640: const Token * newTok@var2250 ; newTok@var2250 =@expr1073747450 nameToken@var2249 .@expr5603 link (@expr5604 ) .@expr5605 previous (@expr5606 ) ;
641: while (@expr1073747455 Token ::@expr5632 Match (@expr1073747457 newTok@var2250 , "%type%" ) &&@expr1073747458 !@expr1073747459 newTok@var2250 .@expr1073747460 isKeyword (@expr1073747461 ) ) {
642: newTok@var2250 =@expr1073747462 newTok@var2250 .@expr1073747463 previous (@expr1073747464 ) ; }
643: if (@expr1073747465 Token ::@expr5552 simpleMatch (@expr1073747467 newTok@var2250 , "new" ) ) {
644: return true ; }
645: }
646:
647: const Token * endtok@var2251 ; endtok@var2251 =@expr1073747468 nullptr ;
648: if (@expr1073747469 Token ::@expr5632 Match (@expr1073747471 nameToken@var2249 , "%name%|return|: {" ) &&@expr1073747472
649: (@expr1073747473 !@expr1073747474 Token ::@expr5552 simpleMatch (@expr1073747476 nameToken@var2249 .@expr5653 tokAt (@expr5654 2 ) , "[" ) ||@expr1073747479 findLambdaEndScope (@expr1073747480 nameToken@var2249 .@expr5653 tokAt (@expr5654 2 ) ) ) ) {
650: endtok@var2251 =@expr1073747483 nameToken@var2249 .@expr5592 linkAt (@expr5661 1 ) ; }
651: else { if (@expr1073747486 Token ::@expr5632 Match (@expr1073747488 nameToken@var2249 , "%name% <" ) &&@expr1073747489 Token ::@expr5552 simpleMatch (@expr1073747491 nameToken@var2249 .@expr5592 linkAt (@expr5661 1 ) , "> {" ) ) {
652: endtok@var2251 =@expr1073747494 nameToken@var2249 .@expr5592 linkAt (@expr5661 1 ) .@expr1073747497 linkAt (@expr1073747498 1 ) ; }
653: else { if (@expr1073747499 Token ::@expr5632 Match (@expr1073747501 nameToken@var2249 .@expr5579 previous (@expr5580 ) , "%name%|> ( {" ) ) {
654: endtok@var2251 =@expr1073747504 nameToken@var2249 .@expr5592 linkAt (@expr5661 1 ) ; }
655: else {
656: return false ; } } }
657: if (@expr1073747507 Token ::@expr5632 Match (@expr1073747509 nameToken@var2249 , "else|try|do|const|constexpr|override|volatile|&|&&" ) ) {
658: return false ; }
659: if (@expr1073747510 Token ::@expr5552 simpleMatch (@expr1073747512 nameToken@var2249 .@expr5579 previous (@expr5580 ) , "namespace" ) ) {
660: return false ; }
661: if (@expr1073747515 Token ::@expr5632 Match (@expr1073747517 nameToken@var2249 , "%any% {" ) &&@expr1073747518 !@expr1073747519 Token ::@expr5632 Match (@expr1073747521 nameToken@var2249 , "return|:" ) ) {
662:
663: for (@expr1073747522 const Token *@expr1073747523 tok2@var2252 =@expr1073747524 nameToken@var2249 .@expr1073747525 next (@expr1073747526 ) ; tok2@var2252 !=@expr1073747527 endtok@var2251 ; tok2@var2252 =@expr1073747528 tok2@var2252 .@expr1073747529 next (@expr1073747530 ) ) {
664: if (@expr1073747531 tok2@var2252 .@expr1073747532 str (@expr1073747533 ) ==@expr1073747534 ";" ) {
665: return false ; }
666: const Token * lambdaEnd@var2253 ; lambdaEnd@var2253 =@expr1073747535 findLambdaEndScope (@expr1073747536 tok2@var2252 ) ;
667: if (@expr1073747537 lambdaEnd@var2253 ) {
668: tok2@var2252 =@expr1073747538 lambdaEnd@var2253 ; }
669: }
670: }
671:
672: if (@expr1073747539 !@expr1073747540 Token ::@expr5552 simpleMatch (@expr1073747542 endtok@var2251 , "} ;" ) ) {
673: return true ; }
674: const Token * prev@var2254 ; prev@var2254 =@expr1073747543 nameToken@var2249 ;
675: while (@expr1073747544 Token ::@expr5632 Match (@expr1073747546 prev@var2254 , "%name%|::|:|<|>" ) ) {
676: if (@expr1073747547 Token ::@expr5632 Match (@expr1073747549 prev@var2254 , "class|struct" ) ) {
677: return false ; }
678:
679: prev@var2254 =@expr1073747550 prev@var2254 .@expr1073747551 previous (@expr1073747552 ) ;
680: }
681: return true ;
682: }
683:
684: static bool isQualifier ( const Token * tok@var2255 )
685: {
686: while (@expr1073747553 Token ::@expr5730 Match (@expr1073747555 tok@var2255 , "&|&&|*" ) ) {
687: tok@var2255 =@expr1073747556 tok@var2255 .@expr1073747557 next (@expr1073747558 ) ; }
688: if (@expr1073747559 !@expr1073747560 Token ::@expr5730 Match (@expr1073747562 tok@var2255 , "{|;" ) ) {
689: return false ; }
690: return true ;
691: }
692:
693: static void compileUnaryOp ( Token * & tok@var2256 , AST_state & state@var2257 , void ( * f@var2258 ) ( Token * & , AST_state & ) )
694: {
695: Token * unaryop@var2259 ; unaryop@var2259 =@expr1073747563 tok@var2256 ;
696: if (@expr1073747564 f@var2258 ) {
697: tok@var2256 =@expr1073747565 tok@var2256 .@expr1073747566 next (@expr1073747567 ) ;
698: state@var2257 .@expr5744 depth@var2260 ++@expr1073747569 ;
699: if (@expr1073747570 state@var2257 .@expr5744 depth@var2260 >@expr1073747572 AST_MAX_DEPTH@var2169 ) {
700: throw InternalError (@expr1073747573 tok@var2256 , "maximum AST depth exceeded" , InternalError ::@expr1073747574 AST ) ; }
701: if (@expr1073747575 tok@var2256 ) {
702: f@var2258 (@expr1073747576 tok@var2256 , state@var2257 ) ; }
703: state@var2257 .@expr5744 depth@var2260 --@expr1073747578 ;
704: }
705:
706: if (@expr1073747579 !@expr1073747580 state@var2257 .@expr5757 op@var2261 .@expr1073747582 empty (@expr1073747583 ) ) {
707: unaryop@var2259 .@expr1073747584 astOperand1 (@expr1073747585 state@var2257 .@expr5757 op@var2261 .@expr1073747587 top (@expr1073747588 ) ) ;
708: state@var2257 .@expr5757 op@var2261 .@expr1073747590 pop (@expr1073747591 ) ;
709: }
710: state@var2257 .@expr5757 op@var2261 .@expr1073747593 push (@expr1073747594 unaryop@var2259 ) ;
711: }
712:
713: static void compileBinOp ( Token * & tok@var2262 , AST_state & state@var2263 , void ( * f@var2264 ) ( Token * & , AST_state & ) )
714: {
715: Token * binop@var2265 ; binop@var2265 =@expr1073747595 tok@var2262 ;
716: if (@expr1073747596 f@var2264 ) {
717: tok@var2262 =@expr1073747597 tok@var2262 .@expr5774 next (@expr5775 ) ;
718: if (@expr1073747600 Token ::@expr1073747601 Match (@expr1073747602 binop@var2265 , "::|. ~" ) ) {
719: tok@var2262 =@expr1073747603 tok@var2262 .@expr5774 next (@expr5775 ) ; }
720: state@var2263 .@expr5782 depth@var2266 ++@expr1073747607 ;
721: if (@expr1073747608 tok@var2262 &&@expr1073747609 state@var2263 .@expr5782 depth@var2266 <=@expr1073747611 AST_MAX_DEPTH@var2169 ) {
722: f@var2264 (@expr1073747612 tok@var2262 , state@var2263 ) ; }
723: state@var2263 .@expr5782 depth@var2266 --@expr1073747614 ;
724: }
725:
|
728:
729: if (@expr5791 !@expr5792 state@var2263 .@expr5793 op@var2267 .@expr5794 empty (@expr5795 ) ) {
730: binop@var2265 .@expr1073747620 astOperand2 (@expr1073747621 state@var2263 .@expr5793 op@var2267 .@expr5799 top (@expr5800 ) ) ;
731: state@var2263 .@expr5793 op@var2267 .@expr5802 pop (@expr5803 ) ;
732: }
733: if (@expr5791 !@expr5792 state@var2263 .@expr5793 op@var2267 .@expr5794 empty (@expr5795 ) ) {
734: binop@var2265 .@expr1073747633 astOperand1 (@expr1073747634 state@var2263 .@expr5793 op@var2267 .@expr5799 top (@expr5800 ) ) ;
735: state@var2263 .@expr5793 op@var2267 .@expr5802 pop (@expr5803 ) ;
736: }
737: state@var2263 .@expr5793 op@var2267 .@expr1073747642 push (@expr1073747643 binop@var2265 ) ;
738: }
739:
740: static void compileExpression ( Token * & tok@var2268 , AST_state & state@var2269 ) ;
741:
742: static void compileTerm ( Token * & tok@var2270 , AST_state & state@var2271 )
743: {
744: if (@expr1073747644 !@expr1073747645 tok@var2270 ) {
745: return ; }
746: if (@expr1073747646 Token ::@expr5823 Match (@expr1073747648 tok@var2270 , "L %str%|%char%" ) ) {
747: tok@var2270 =@expr1073747649 tok@var2270 .@expr5826 next (@expr5827 ) ; }
748: if (@expr1073747652 state@var2271 .@expr5829 inArrayAssignment@var2272 &&@expr1073747654 Token ::@expr5823 Match (@expr1073747656 tok@var2270 .@expr5833 previous (@expr5834 ) , "[{,] . %name%" ) ) {
749: state@var2271 .@expr5835 op@var2273 .@expr5836 push (@expr5837 tok@var2270 ) ;
750: tok@var2270 .@expr5838 astOperand1 (@expr5839 tok@var2270 .@expr5826 next (@expr5827 ) ) ;
751: tok@var2270 =@expr1073747666 tok@var2270 .@expr5843 tokAt (@expr5844 2 ) ;
752: }
753: if (@expr1073747669 state@var2271 .@expr5829 inArrayAssignment@var2272 &&@expr1073747671 Token ::@expr5823 Match (@expr1073747673 tok@var2270 .@expr5833 previous (@expr5834 ) , "[{,] [ %num%|%name% ]" ) ) {
754: state@var2271 .@expr5835 op@var2273 .@expr5836 push (@expr5837 tok@var2270 ) ;
755: tok@var2270 .@expr5838 astOperand1 (@expr5839 tok@var2270 .@expr5826 next (@expr5827 ) ) ;
756: tok@var2270 =@expr1073747683 tok@var2270 .@expr5843 tokAt (@expr1073747685 3 ) ;
757: }
758: if (@expr1073747686 tok@var2270 .@expr1073747687 isLiteral (@expr1073747688 ) ) {
759: state@var2271 .@expr5835 op@var2273 .@expr5836 push (@expr5837 tok@var2270 ) ;
760: do {
761: tok@var2270 =@expr1073747692 tok@var2270 .@expr5826 next (@expr5827 ) ;
762: } while (@expr5871 Token ::@expr5823 Match (@expr5873 tok@var2270 , "%name%|%str%" ) ) ;
763: } else { if (@expr1073747698 tok@var2270 .@expr1073747699 isName (@expr1073747700 ) ) {
764: if (@expr1073747701 Token ::@expr5823 Match (@expr1073747703 tok@var2270 , "return|case" ) ||@expr1073747704 (@expr1073747705 state@var2271 .@expr5882 cpp@var2274 &&@expr1073747707 tok@var2270 .@expr5884 str (@expr5885 ) ==@expr1073747710 "throw" ) ) {
765: if (@expr1073747711 tok@var2270 .@expr5884 str (@expr5885 ) ==@expr1073747714 "case" ) {
766: state@var2271 .@expr5891 inCase@var2275 =@expr1073747716 true ; }
767: const bool tokIsReturn@var2276 =@expr1073747717 tok@var2270 .@expr5884 str (@expr5885 ) ==@expr1073747720 "return" ;
768: const bool stopAtColon@var2277 =@expr1073747721 state@var2271 .@expr5898 stopAtColon@var2278 ;
769: state@var2271 .@expr5898 stopAtColon@var2278 =@expr1073747724 true ;
770: compileUnaryOp (@expr5901 tok@var2270 , state@var2271 , compileExpression ) ;
771: state@var2271 .@expr5898 stopAtColon@var2278 =@expr1073747727 stopAtColon@var2277 ;
772: if (@expr1073747728 tokIsReturn@var2276 ) {
773: state@var2271 .@expr5835 op@var2273 .@expr5906 pop (@expr5907 ) ; }
774: if (@expr1073747732 state@var2271 .@expr5891 inCase@var2275 &&@expr1073747734 Token ::@expr5911 simpleMatch (@expr1073747736 tok@var2270 , ": ;" ) ) {
775: state@var2271 .@expr5891 inCase@var2275 =@expr1073747738 false ;
776: tok@var2270 =@expr1073747739 tok@var2270 .@expr5826 next (@expr5827 ) ;
777: }
778: } else { if (@expr1073747742 Token ::@expr5823 Match (@expr1073747744 tok@var2270 , "sizeof !!(" ) ) {
779: compileUnaryOp (@expr5901 tok@var2270 , state@var2271 , compileExpression ) ;
780: state@var2271 .@expr5835 op@var2273 .@expr5906 pop (@expr5907 ) ;
781: } else { if (@expr1073747749 state@var2271 .@expr5882 cpp@var2274 &&@expr1073747751 findCppTypeInitPar (@expr5928 tok@var2270 ) ) {
782: tok@var2270 =@expr1073747753 findCppTypeInitPar (@expr5928 tok@var2270 ) ;
783: state@var2271 .@expr5835 op@var2273 .@expr5836 push (@expr5837 tok@var2270 ) ;
784: tok@var2270 =@expr1073747758 tok@var2270 .@expr5843 tokAt (@expr5844 2 ) ;
785: } else { if (@expr5937 state@var2271 .@expr5882 cpp@var2274 &&@expr5939 iscpp11init (@expr5940 tok@var2270 ) ) {
786: state@var2271 .@expr5835 op@var2273 .@expr5836 push (@expr5837 tok@var2270 ) ;
787: tok@var2270 =@expr1073747768 tok@var2270 .@expr5826 next (@expr5827 ) ;
788: if (@expr1073747771 tok@var2270 .@expr5884 str (@expr5885 ) ==@expr1073747774 "<" ) {
789: tok@var2270 =@expr1073747775 tok@var2270 .@expr5952 link (@expr5953 ) .@expr5954 next (@expr5955 ) ; }
790:
791: if (@expr5956 Token ::@expr5823 Match (@expr5958 tok@var2270 , "{ . %name% =|{" ) ) {
792: const int inArrayAssignment@var2279 =@expr1073747783 state@var2271 .@expr5829 inArrayAssignment@var2272 ;
793: state@var2271 .@expr5829 inArrayAssignment@var2272 =@expr1073747786 1 ;
794: compileBinOp (@expr5963 tok@var2270 , state@var2271 , compileExpression ) ;
795: state@var2271 .@expr5829 inArrayAssignment@var2272 =@expr1073747789 inArrayAssignment@var2279 ;
796: } else { if (@expr5966 Token ::@expr5911 simpleMatch (@expr5968 tok@var2270 , "{ }" ) ) {
797: tok@var2270 .@expr5838 astOperand1 (@expr1073747794 state@var2271 .@expr5835 op@var2273 .@expr1073747796 top (@expr1073747797 ) ) ;
798: state@var2271 .@expr5835 op@var2273 .@expr5906 pop (@expr5907 ) ;
799: state@var2271 .@expr5835 op@var2273 .@expr5836 push (@expr5837 tok@var2270 ) ;
800: tok@var2270 =@expr1073747804 tok@var2270 .@expr5843 tokAt (@expr5844 2 ) ;
801: } }
802: } else { if (@expr1073747807 !@expr1073747808 state@var2271 .@expr5882 cpp@var2274 ||@expr1073747810 !@expr1073747811 Token ::@expr5823 Match (@expr1073747813 tok@var2270 , "new|delete %name%|*|&|::|(|[" ) ) {
803: std ::@expr1073747814 vector < Token *@expr5991 > inner@var2280 ;
804: tok@var2270 =@expr1073747816 skipDecl (@expr1073747817 tok@var2270 , &@expr1073747818 inner@var2280 ) ;
805: for (@expr1073747819 Token *@expr5991 tok3@var2281 :@expr1073747821 inner@var2280 ) {
806: AST_state state1@var2282 (@expr1073747822 state@var2271 .@expr5882 cpp@var2274 ) ;
807: compileExpression (@expr1073747824 tok3@var2281 , state1@var2282 ) ;
808: }
809: bool repeat@var2283 ; repeat@var2283 =@expr1073747825 true ;
810: while (@expr1073747826 repeat@var2283 ) {
811: repeat@var2283 =@expr1073747827 false ;
812: if (@expr1073747828 Token ::@expr5823 Match (@expr1073747830 tok@var2270 .@expr5826 next (@expr5827 ) , "%name%" ) ) {
813: tok@var2270 =@expr1073747833 tok@var2270 .@expr5826 next (@expr5827 ) ;
814: repeat@var2283 =@expr1073747836 true ;
815: }
816: if (@expr1073747837 Token ::@expr5911 simpleMatch (@expr1073747839 tok@var2270 .@expr5826 next (@expr5827 ) , "<" ) &&@expr1073747842 Token ::@expr5823 Match (@expr1073747844 tok@var2270 .@expr6021 linkAt (@expr6022 1 ) , "> %name%" ) ) {
817: tok@var2270 =@expr1073747847 tok@var2270 .@expr5826 next (@expr5827 ) .@expr1073747850 link (@expr1073747851 ) .@expr1073747852 next (@expr1073747853 ) ;
818: repeat@var2283 =@expr1073747854 true ;
819: }
820: }
821: state@var2271 .@expr5835 op@var2273 .@expr5836 push (@expr5837 tok@var2270 ) ;
822: if (@expr1073747858 Token ::@expr5823 Match (@expr1073747860 tok@var2270 , "%name% <" ) &&@expr1073747861 tok@var2270 .@expr6021 linkAt (@expr6022 1 ) ) {
823: tok@var2270 =@expr1073747864 tok@var2270 .@expr6021 linkAt (@expr6022 1 ) ; }
824: else { if (@expr1073747867 Token ::@expr5823 Match (@expr1073747869 tok@var2270 , "%name% ..." ) ||@expr1073747870 (@expr1073747871 state@var2271 .@expr5835 op@var2273 .@expr1073747873 size (@expr1073747874 ) ==@expr1073747875 1 &&@expr1073747876 state@var2271 .@expr1073747877 depth@var2284 ==@expr1073747878 0 &&@expr1073747879 Token ::@expr5823 Match (@expr1073747881 tok@var2270 .@expr5843 tokAt (@expr1073747883 -3 ) , "!!& ) ( %name% ) =" ) ) ) {
825: tok@var2270 =@expr1073747884 tok@var2270 .@expr5826 next (@expr5827 ) ; } }
826: tok@var2270 =@expr1073747887 tok@var2270 .@expr5826 next (@expr5827 ) ;
827: if (@expr1073747890 Token ::@expr5823 Match (@expr1073747892 tok@var2270 , "%str%" ) ) {
828: while (@expr5871 Token ::@expr5823 Match (@expr5873 tok@var2270 , "%name%|%str%" ) ) {
829: tok@var2270 =@expr1073747896 tok@var2270 .@expr5826 next (@expr5827 ) ; }
830: }
831: if (@expr1073747899 Token ::@expr5823 Match (@expr1073747901 tok@var2270 , "%name% %assign%" ) ) {
832: tok@var2270 =@expr1073747902 tok@var2270 .@expr5826 next (@expr5827 ) ; }
833: } } } } }
834: } else { if (@expr1073747905 tok@var2270 .@expr5884 str (@expr5885 ) ==@expr1073747908 "{" ) {
835: const Token * prev@var2285 ; prev@var2285 =@expr1073747909 tok@var2270 .@expr5833 previous (@expr5834 ) ;
836: if (@expr1073747912 Token ::@expr5911 simpleMatch (@expr1073747914 prev@var2285 , ") {" ) &&@expr1073747915 iscast (@expr1073747916 prev@var2285 .@expr6093 link (@expr6094 ) , state@var2271 .@expr5882 cpp@var2274 ) ) {
837: prev@var2285 =@expr1073747920 prev@var2285 .@expr6093 link (@expr6094 ) .@expr1073747923 previous (@expr1073747924 ) ; }
838: if (@expr1073747925 Token ::@expr5911 simpleMatch (@expr1073747927 tok@var2270 .@expr5952 link (@expr5953 ) , "} [" ) ) {
839: tok@var2270 =@expr1073747930 tok@var2270 .@expr5826 next (@expr5827 ) ;
840: } else { if (@expr5937 state@var2271 .@expr5882 cpp@var2274 &&@expr5939 iscpp11init (@expr5940 tok@var2270 ) ) {
841: if (@expr1073747937 state@var2271 .@expr5835 op@var2273 .@expr1073747939 empty (@expr1073747940 ) ||@expr1073747941 Token ::@expr5823 Match (@expr1073747943 tok@var2270 .@expr5833 previous (@expr5834 ) , "[{,]" ) ||@expr1073747946 Token ::@expr5823 Match (@expr1073747948 tok@var2270 .@expr5843 tokAt (@expr6126 -2 ) , "%name% (" ) ) {
842: if (@expr1073747951 Token ::@expr5823 Match (@expr1073747953 tok@var2270 , "{ !!}" ) ) {
843: Token * const end@var2286 ; end@var2286 =@expr1073747954 tok@var2270 .@expr5952 link (@expr5953 ) ;
844: if (@expr5956 Token ::@expr5823 Match (@expr5958 tok@var2270 , "{ . %name% =|{" ) ) {
845: const int inArrayAssignment@var2287 =@expr1073747960 state@var2271 .@expr5829 inArrayAssignment@var2272 ;
846: state@var2271 .@expr5829 inArrayAssignment@var2272 =@expr1073747963 1 ;
847: compileBinOp (@expr5963 tok@var2270 , state@var2271 , compileExpression ) ;
848: state@var2271 .@expr5829 inArrayAssignment@var2272 =@expr1073747966 inArrayAssignment@var2287 ;
849: } else {
850: compileUnaryOp (@expr5901 tok@var2270 , state@var2271 , compileExpression ) ;
851: }
852: if (@expr1073747968 precedes (@expr1073747969 tok@var2270 , end@var2286 ) ) {
853: tok@var2270 =@expr1073747970 end@var2286 ; }
854: } else {
855: state@var2271 .@expr5835 op@var2273 .@expr5836 push (@expr5837 tok@var2270 ) ;
856: tok@var2270 =@expr1073747974 tok@var2270 .@expr5843 tokAt (@expr5844 2 ) ;
857: }
858: } else {
859: compileBinOp (@expr5963 tok@var2270 , state@var2271 , compileExpression ) ; }
860: if (@expr1073747978 Token ::@expr5823 Match (@expr1073747980 tok@var2270 , "} ,|:|)" ) ) {
861: tok@var2270 =@expr1073747981 tok@var2270 .@expr5826 next (@expr5827 ) ; }
862: } else { if (@expr1073747984 state@var2271 .@expr5882 cpp@var2274 &&@expr1073747986 Token ::@expr5823 Match (@expr1073747988 tok@var2270 .@expr5843 tokAt (@expr6126 -2 ) , "%name% ( {" ) &&@expr1073747991 !@expr1073747992 Token ::@expr1073747993 findsimplematch (@expr1073747994 tok@var2270 , ";" , tok@var2270 .@expr5952 link (@expr5953 ) ) ) {
863: if (@expr5966 Token ::@expr5911 simpleMatch (@expr5968 tok@var2270 , "{ }" ) ) {
864: tok@var2270 =@expr1073748000 tok@var2270 .@expr5843 tokAt (@expr5844 2 ) ; }
865: else {
866: Token * tok1@var2288 ; tok1@var2288 =@expr1073748003 tok@var2270 ;
867: state@var2271 .@expr5829 inArrayAssignment@var2272 ++@expr1073748005 ;
868: compileUnaryOp (@expr5901 tok@var2270 , state@var2271 , compileExpression ) ;
869: state@var2271 .@expr5829 inArrayAssignment@var2272 --@expr1073748008 ;
870: tok@var2270 =@expr1073748009 tok1@var2288 .@expr1073748010 link (@expr1073748011 ) .@expr1073748012 next (@expr1073748013 ) ;
871: }
872: } else { if (@expr1073748014 !@expr1073748015 state@var2271 .@expr5829 inArrayAssignment@var2272 &&@expr1073748017 !@expr1073748018 Token ::@expr5911 simpleMatch (@expr1073748020 prev@var2285 , "=" ) ) {
873: state@var2271 .@expr5835 op@var2273 .@expr5836 push (@expr5837 tok@var2270 ) ;
874: tok@var2270 =@expr1073748024 tok@var2270 .@expr5952 link (@expr5953 ) .@expr5954 next (@expr5955 ) ;
875: } else {
876: if (@expr1073748029 tok@var2270 .@expr5952 link (@expr5953 ) !=@expr1073748032 tok@var2270 .@expr5826 next (@expr5827 ) ) {
877: state@var2271 .@expr5829 inArrayAssignment@var2272 ++@expr1073748036 ;
878: compileUnaryOp (@expr5901 tok@var2270 , state@var2271 , compileExpression ) ;
879: if (@expr1073748038 Token ::@expr5823 Match (@expr1073748040 tok@var2270 , "} [,};]" ) &&@expr1073748041 state@var2271 .@expr5829 inArrayAssignment@var2272 >@expr1073748043 0 ) {
880: tok@var2270 =@expr1073748044 tok@var2270 .@expr5826 next (@expr5827 ) ;
881: state@var2271 .@expr5829 inArrayAssignment@var2272 --@expr1073748048 ;
882: }
883: } else {
884: state@var2271 .@expr5835 op@var2273 .@expr5836 push (@expr5837 tok@var2270 ) ;
885: tok@var2270 =@expr1073748052 tok@var2270 .@expr5843 tokAt (@expr5844 2 ) ;
886: }
887: } } } }
888: } } }
889: }
890:
891: static void compileScope ( Token * & tok@var2289 , AST_state & state@var2290 )
892: {
893: compileTerm (@expr1073748055 tok@var2289 , state@var2290 ) ;
894: while (@expr1073748056 tok@var2289 ) {
895: if (@expr1073748057 tok@var2289 .@expr1073748058 str (@expr1073748059 ) ==@expr1073748060 "::" ) {
896: const Token * lastOp@var2291 ; lastOp@var2291 =@expr1073748061 state@var2290 .@expr6238 op@var2292 .@expr1073748063 empty (@expr1073748064 ) ?@expr1073748065 nullptr :@expr1073748066 state@var2290 .@expr6238 op@var2292 .@expr1073748068 top (@expr1073748069 ) ;
897: if (@expr1073748070 Token ::@expr6247 Match (@expr1073748072 lastOp@var2291 , ":: %name%" ) ) {
898: lastOp@var2291 =@expr1073748073 lastOp@var2291 .@expr6250 next (@expr6251 ) ; }
899: if (@expr1073748076 Token ::@expr6247 Match (@expr1073748078 lastOp@var2291 , "%name%" ) &&@expr1073748079
900: (@expr1073748080 lastOp@var2291 .@expr6250 next (@expr6251 ) ==@expr1073748083 tok@var2289 ||@expr1073748084 (@expr1073748085 Token ::@expr6247 Match (@expr1073748087 lastOp@var2291 , "%name% <" ) &&@expr1073748088 lastOp@var2291 .@expr6265 linkAt (@expr6266 1 ) &&@expr1073748091 tok@var2289 ==@expr1073748092 lastOp@var2291 .@expr6265 linkAt (@expr6266 1 ) .@expr1073748095 next (@expr1073748096 ) ) ) ) {
901: compileBinOp (@expr1073748097 tok@var2289 , state@var2290 , compileTerm ) ; }
902: else {
903: compileUnaryOp (@expr1073748098 tok@var2289 , state@var2290 , compileTerm ) ; }
904: } else { break ; }
905: }
906: }
907:
908: static bool isPrefixUnary ( const Token * tok@var2293 , bool cpp@var2294 )
909: {
910: if (@expr1073748099 !@expr1073748100 tok@var2293 .@expr6277 previous (@expr6278 )
911: ||@expr1073748103 (@expr1073748104 (@expr1073748105 Token ::@expr1073748106 Match (@expr1073748107 tok@var2293 .@expr6277 previous (@expr6278 ) , "(|[|{|%op%|;|}|?|:|,|.|return|::" ) ||@expr1073748110 (@expr1073748111 cpp@var2294 &&@expr1073748112 tok@var2293 .@expr6289 strAt (@expr6290 -1 ) ==@expr1073748115 "throw" ) )
912: &&@expr1073748116 (@expr1073748117 tok@var2293 .@expr6277 previous (@expr6278 ) .@expr6296 tokType (@expr6297 ) !=@expr1073748122 Token ::@expr6299 eIncDecOp ||@expr1073748124 tok@var2293 .@expr1073748125 tokType (@expr1073748126 ) ==@expr1073748127 Token ::@expr6299 eIncDecOp ) ) ) {
913: return true ; }
914:
915: if (@expr1073748129 tok@var2293 .@expr1073748130 str (@expr1073748131 ) ==@expr1073748132 "*" &&@expr1073748133 tok@var2293 .@expr6277 previous (@expr6278 ) .@expr6296 tokType (@expr6297 ) ==@expr1073748138 Token ::@expr6299 eIncDecOp &&@expr1073748140 isPrefixUnary (@expr1073748141 tok@var2293 .@expr6277 previous (@expr6278 ) , cpp@var2294 ) ) {
916: return true ; }
917:
918: return tok@var2293 .@expr6289 strAt (@expr6290 -1 ) ==@expr1073748146 ")" &&@expr1073748147 iscast (@expr1073748148 tok@var2293 .@expr1073748149 linkAt (@expr1073748150 -1 ) , cpp@var2294 ) ;
919: }
920:
921: static void compilePrecedence2 ( Token * & tok@var2295 , AST_state & state@var2296 )
922: {
923: const bool isStartOfCpp11Init@var2297 =@expr1073748151 state@var2296 .@expr6328 cpp@var2298 &&@expr1073748153 tok@var2295 &&@expr1073748154 tok@var2295 .@expr6331 str (@expr6332 ) ==@expr6333 "{" &&@expr1073748158 iscpp11init (@expr6335 tok@var2295 ) ;
924: if (@expr1073748160 !@expr1073748161 (@expr1073748162 isStartOfCpp11Init@var2297 &&@expr1073748163 Token ::@expr6340 Match (@expr1073748165 tok@var2295 .@expr6342 tokAt (@expr1073748167 -2 ) , "new %type% {" ) ) ) {
925: compileScope (@expr1073748168 tok@var2295 , state@var2296 ) ; }
926: while (@expr1073748169 tok@var2295 ) {
927: if (@expr1073748170 tok@var2295 .@expr1073748171 tokType (@expr1073748172 ) ==@expr1073748173 Token ::@expr1073748174 eIncDecOp &&@expr1073748175 !@expr1073748176 isPrefixUnary (@expr6353 tok@var2295 , state@var2296 .@expr6328 cpp@var2298 ) ) {
928: compileUnaryOp (@expr1073748179 tok@var2295 , state@var2296 , compileScope ) ;
929: } else { if (@expr1073748180 tok@var2295 .@expr6331 str (@expr6332 ) ==@expr1073748183 "..." ) {
930: state@var2296 .@expr6360 op@var2299 .@expr6361 push (@expr6362 tok@var2295 ) ;
931: tok@var2295 =@expr1073748187 tok@var2295 .@expr6364 next (@expr6365 ) ;
932: break ;
933: } else { if (@expr1073748190 tok@var2295 .@expr6331 str (@expr6332 ) ==@expr1073748193 "." &&@expr1073748194 tok@var2295 .@expr6371 strAt (@expr6372 1 ) !=@expr1073748197 "*" ) {
934: if (@expr1073748198 tok@var2295 .@expr6371 strAt (@expr6372 1 ) ==@expr1073748201 "." ) {
935: state@var2296 .@expr6360 op@var2299 .@expr6361 push (@expr6362 tok@var2295 ) ;
936: tok@var2295 =@expr1073748205 tok@var2295 .@expr6342 tokAt (@expr1073748207 3 ) ;
937: break ;
938: }
939: compileBinOp (@expr1073748208 tok@var2295 , state@var2296 , compileScope ) ;
940: } else { if (@expr1073748209 tok@var2295 .@expr6331 str (@expr6332 ) ==@expr1073748212 "[" ) {
941: if (@expr1073748213 state@var2296 .@expr6328 cpp@var2298 &&@expr1073748215 isPrefixUnary (@expr6353 tok@var2295 , state@var2296 .@expr6328 cpp@var2298 ) &&@expr1073748218 Token ::@expr6340 Match (@expr1073748220 tok@var2295 .@expr6397 link (@expr6398 ) , "] (|{" ) ) {
942:
|
946:
947: Token * const squareBracket@var2300 ; squareBracket@var2300 =@expr1073748223 tok@var2295 ;
948:
949: if (@expr6400 tok@var2295 .@expr6371 strAt (@expr6372 1 ) !=@expr6403 "]" ) {
950: Token * tok2@var2301 ; tok2@var2301 =@expr1073748228 tok@var2295 .@expr6364 next (@expr6365 ) ;
951: AST_state state2@var2302 (@expr1073748231 state@var2296 .@expr6328 cpp@var2298 ) ;
952: compileExpression (@expr1073748233 tok2@var2301 , state2@var2302 ) ;
953: if (@expr1073748234 !@expr1073748235 state2@var2302 .@expr6412 op@var2303 .@expr1073748237 empty (@expr1073748238 ) ) {
954: squareBracket@var2300 .@expr1073748239 astOperand2 (@expr1073748240 state2@var2302 .@expr6412 op@var2303 .@expr1073748242 top (@expr1073748243 ) ) ;
955: }
956: }
957:
958: if (@expr1073748244 Token ::@expr6421 simpleMatch (@expr1073748246 squareBracket@var2300 .@expr6423 link (@expr6424 ) , "] (" ) ) {
959: Token * const roundBracket@var2304 ; roundBracket@var2304 =@expr1073748249 squareBracket@var2300 .@expr6423 link (@expr6424 ) .@expr6428 next (@expr6429 ) ;
960: Token * curlyBracket@var2305 ; curlyBracket@var2305 =@expr1073748254 roundBracket@var2304 .@expr1073748255 link (@expr1073748256 ) .@expr1073748257 next (@expr1073748258 ) ;
961: while (@expr1073748259 Token ::@expr6340 Match (@expr1073748261 curlyBracket@var2305 , "mutable|const|constexpr" ) ) {
962: curlyBracket@var2305 =@expr1073748262 curlyBracket@var2305 .@expr6439 next (@expr6440 ) ; }
963: if (@expr1073748265 Token ::@expr6421 simpleMatch (@expr1073748267 curlyBracket@var2305 , "noexcept (" ) ) {
964: curlyBracket@var2305 =@expr1073748268 curlyBracket@var2305 .@expr1073748269 linkAt (@expr1073748270 1 ) .@expr1073748271 next (@expr1073748272 ) ; }
965: if (@expr1073748273 curlyBracket@var2305 &&@expr1073748274 curlyBracket@var2305 .@expr1073748275 originalName (@expr1073748276 ) ==@expr1073748277 "->" ) {
966: curlyBracket@var2305 =@expr1073748278 findTypeEnd (@expr1073748279 curlyBracket@var2305 .@expr6439 next (@expr6440 ) ) ; }
967: if (@expr1073748282 curlyBracket@var2305 &&@expr1073748283 curlyBracket@var2305 .@expr1073748284 str (@expr1073748285 ) ==@expr1073748286 "{" ) {
968: squareBracket@var2300 .@expr6463 astOperand1 (@expr1073748288 roundBracket@var2304 ) ;
969: roundBracket@var2304 .@expr1073748289 astOperand1 (@expr1073748290 curlyBracket@var2305 ) ;
970: state@var2296 .@expr6360 op@var2299 .@expr6361 push (@expr6469 squareBracket@var2300 ) ;
971: tok@var2295 =@expr1073748294 curlyBracket@var2305 .@expr1073748295 link (@expr1073748296 ) .@expr1073748297 next (@expr1073748298 ) ;
972: continue ;
973: }
974: } else {
975: Token * const curlyBracket@var2306 ; curlyBracket@var2306 =@expr1073748299 squareBracket@var2300 .@expr6423 link (@expr6424 ) .@expr6428 next (@expr6429 ) ;
976: squareBracket@var2300 .@expr6463 astOperand1 (@expr1073748305 curlyBracket@var2306 ) ;
977: state@var2296 .@expr6360 op@var2299 .@expr6361 push (@expr6469 squareBracket@var2300 ) ;
978: tok@var2295 =@expr1073748309 curlyBracket@var2306 .@expr1073748310 link (@expr1073748311 ) .@expr1073748312 next (@expr1073748313 ) ;
979: continue ;
980: }
981: }
982:
983: const Token * const tok2@var2307 ; tok2@var2307 =@expr1073748314 tok@var2295 ;
984: if (@expr6400 tok@var2295 .@expr6371 strAt (@expr6372 1 ) !=@expr6403 "]" ) {
985: compileBinOp (@expr6495 tok@var2295 , state@var2296 , compileExpression ) ; }
986: else {
987: compileUnaryOp (@expr6496 tok@var2295 , state@var2296 , compileExpression ) ; }
988: tok@var2295 =@expr1073748321 tok2@var2307 .@expr1073748322 link (@expr1073748323 ) .@expr1073748324 next (@expr1073748325 ) ;
989: } else { if (@expr1073748326 tok@var2295 .@expr6331 str (@expr6332 ) ==@expr1073748329 "(" &&@expr1073748330 (@expr1073748331 !@expr1073748332 iscast (@expr6509 tok@var2295 , state@var2296 .@expr6328 cpp@var2298 ) ||@expr1073748335 Token ::@expr6340 Match (@expr1073748337 tok@var2295 .@expr6514 previous (@expr6515 ) , "if|while|for|switch|catch" ) ) ) {
990: Token * tok2@var2308 ; tok2@var2308 =@expr1073748340 tok@var2295 ;
991: tok@var2295 =@expr1073748341 tok@var2295 .@expr6364 next (@expr6365 ) ;
992: const bool opPrevTopSquare@var2309 =@expr1073748344 !@expr1073748345 state@var2296 .@expr6360 op@var2299 .@expr1073748347 empty (@expr1073748348 ) &&@expr1073748349 state@var2296 .@expr6360 op@var2299 .@expr6527 top (@expr6528 ) &&@expr1073748353 state@var2296 .@expr6360 op@var2299 .@expr6527 top (@expr6528 ) .@expr1073748357 str (@expr1073748358 ) ==@expr1073748359 "[" ;
993: const unsigned long oldOpSize@var2310 =@expr1073748360 state@var2296 .@expr6360 op@var2299 .@expr6538 size (@expr6539 ) ;
994: compileExpression (@expr1073748364 tok@var2295 , state@var2296 ) ;
995: tok@var2295 =@expr1073748365 tok2@var2308 ;
996: if (@expr1073748366 (@expr1073748367 oldOpSize@var2310 >@expr1073748368 0 &&@expr1073748369 Token ::@expr6421 simpleMatch (@expr1073748371 tok@var2295 .@expr6514 previous (@expr6515 ) , "} (" ) )
997: ||@expr1073748374 (@expr1073748375 tok@var2295 .@expr6514 previous (@expr6515 ) &&@expr1073748378 tok@var2295 .@expr6514 previous (@expr6515 ) .@expr1073748381 isName (@expr1073748382 ) &&@expr1073748383 !@expr1073748384 Token ::@expr6340 Match (@expr1073748386 tok@var2295 .@expr6514 previous (@expr6515 ) , "return|case" ) &&@expr1073748389 (@expr1073748390 !@expr6567 state@var2296 .@expr6328 cpp@var2298 ||@expr1073748393 !@expr1073748394 Token ::@expr6340 Match (@expr1073748396 tok@var2295 .@expr6514 previous (@expr6515 ) , "throw|delete" ) ) )
998: ||@expr1073748399 (@expr1073748400 tok@var2295 .@expr6371 strAt (@expr6578 -1 ) ==@expr1073748403 "]" &&@expr1073748404 (@expr1073748405 !@expr6567 state@var2296 .@expr6328 cpp@var2298 ||@expr1073748408 !@expr1073748409 Token ::@expr6340 Match (@expr1073748411 tok@var2295 .@expr6588 linkAt (@expr6589 -1 ) .@expr1073748414 previous (@expr1073748415 ) , "new|delete" ) ) )
999: ||@expr1073748416 (@expr1073748417 tok@var2295 .@expr6371 strAt (@expr6578 -1 ) ==@expr1073748420 ">" &&@expr1073748421 tok@var2295 .@expr6588 linkAt (@expr6589 -1 ) )
1000: ||@expr1073748424 (@expr1073748425 tok@var2295 .@expr6371 strAt (@expr6578 -1 ) ==@expr1073748428 ")" &&@expr1073748429 !@expr1073748430 iscast (@expr1073748431 tok@var2295 .@expr6588 linkAt (@expr6589 -1 ) , state@var2296 .@expr6328 cpp@var2298 ) )
1001: ||@expr1073748435 (@expr1073748436 tok@var2295 .@expr6371 strAt (@expr6578 -1 ) ==@expr1073748439 "}" &&@expr1073748440 opPrevTopSquare@var2309 ) ) {
1002: const bool operandInside@var2311 =@expr1073748441 oldOpSize@var2310 <@expr1073748442 state@var2296 .@expr6360 op@var2299 .@expr6538 size (@expr6539 ) ;
1003: if (@expr1073748446 operandInside@var2311 ) {
1004: compileBinOp (@expr1073748447 tok@var2295 , state@var2296 , nullptr ) ; }
1005: else {
1006: compileUnaryOp (@expr1073748448 tok@var2295 , state@var2296 , nullptr ) ; }
1007: }
1008: tok@var2295 =@expr1073748449 tok@var2295 .@expr6397 link (@expr6398 ) .@expr6628 next (@expr6629 ) ;
1009: } else { if (@expr1073748454 iscast (@expr6509 tok@var2295 , state@var2296 .@expr6328 cpp@var2298 ) &&@expr1073748457 Token ::@expr6421 simpleMatch (@expr1073748459 tok@var2295 .@expr6397 link (@expr6398 ) , ") {" ) &&@expr1073748462 Token ::@expr6421 simpleMatch (@expr1073748464 tok@var2295 .@expr6397 link (@expr6398 ) .@expr1073748467 linkAt (@expr1073748468 1 ) , "} [" ) ) {
1010: Token * cast@var2312 ; cast@var2312 =@expr1073748469 tok@var2295 ;
1011: tok@var2295 =@expr1073748470 tok@var2295 .@expr6397 link (@expr6398 ) .@expr6628 next (@expr6629 ) ;
1012: Token * tok1@var2313 ; tok1@var2313 =@expr1073748475 tok@var2295 ;
1013: compileUnaryOp (@expr6496 tok@var2295 , state@var2296 , compileExpression ) ;
1014: cast@var2312 .@expr1073748477 astOperand1 (@expr1073748478 tok1@var2313 ) ;
1015: tok@var2295 =@expr1073748479 tok1@var2313 .@expr1073748480 link (@expr1073748481 ) .@expr1073748482 next (@expr1073748483 ) ;
1016: } else { if (@expr1073748484 state@var2296 .@expr6328 cpp@var2298 &&@expr1073748486 tok@var2295 .@expr6331 str (@expr6332 ) ==@expr6333 "{" &&@expr1073748490 iscpp11init (@expr6335 tok@var2295 ) ) {
1017: if (@expr1073748492 Token ::@expr6421 simpleMatch (@expr1073748494 tok@var2295 , "{ }" ) ) {
1018: compileUnaryOp (@expr6496 tok@var2295 , state@var2296 , compileExpression ) ; }
1019: else {
1020: compileBinOp (@expr6495 tok@var2295 , state@var2296 , compileExpression ) ; }
1021: while (@expr1073748497 Token ::@expr6421 simpleMatch (@expr1073748499 tok@var2295 , "}" ) ) {
1022: tok@var2295 =@expr1073748500 tok@var2295 .@expr6364 next (@expr6365 ) ; }
1023: } else { break ; } } } } } } }
1024: }
1025: }
1026:
1027: static void compilePrecedence3 ( Token * & tok@var2314 , AST_state & state@var2315 )
1028: {
1029: compilePrecedence2 (@expr6679 tok@var2314 , state@var2315 ) ;
1030: while (@expr1073748504 tok@var2314 ) {
1031: if (@expr1073748505 (@expr1073748506 Token ::@expr6683 Match (@expr1073748508 tok@var2314 , "[+-!~*&]" ) ||@expr1073748509 tok@var2314 .@expr1073748510 tokType (@expr1073748511 ) ==@expr1073748512 Token ::@expr1073748513 eIncDecOp ) &&@expr1073748514
1032: isPrefixUnary (@expr1073748515 tok@var2314 , state@var2315 .@expr6692 cpp@var2316 ) ) {
1033: if (@expr1073748517 Token ::@expr6683 Match (@expr1073748519 tok@var2314 , "* [*,)]" ) ) {
1034: Token * tok2@var2317 ; tok2@var2317 =@expr1073748520 tok@var2314 .@expr6697 next (@expr6698 ) ;
1035: while (@expr1073748523 tok2@var2317 .@expr6700 next (@expr6701 ) &&@expr1073748526 tok2@var2317 .@expr1073748527 str (@expr1073748528 ) ==@expr1073748529 "*" ) {
1036: tok2@var2317 =@expr1073748530 tok2@var2317 .@expr6700 next (@expr6701 ) ; }
1037: if (@expr1073748533 Token ::@expr6683 Match (@expr1073748535 tok2@var2317 , "[>),]" ) ) {
1038: tok@var2314 =@expr1073748536 tok2@var2317 ;
1039: continue ;
1040: }
1041: }
1042: compileUnaryOp (@expr1073748537 tok@var2314 , state@var2315 , compilePrecedence3 ) ;
1043: } else { if (@expr1073748538 tok@var2314 .@expr6715 str (@expr6716 ) ==@expr6717 "(" &&@expr1073748542 iscast (@expr1073748543 tok@var2314 , state@var2315 .@expr6692 cpp@var2316 ) ) {
1044: Token * castTok@var2318 ; castTok@var2318 =@expr1073748545 tok@var2314 ;
1045: castTok@var2318 .@expr1073748546 isCast (@expr1073748547 true ) ;
1046: tok@var2314 =@expr1073748548 tok@var2314 .@expr6725 link (@expr6726 ) .@expr6727 next (@expr6728 ) ;
1047: const int inArrayAssignment@var2319 =@expr1073748553 state@var2315 .@expr6730 inArrayAssignment@var2320 ;
1048: if (@expr1073748555 tok@var2314 &&@expr1073748556 tok@var2314 .@expr6715 str (@expr6716 ) ==@expr6735 "{" ) {
1049: state@var2315 .@expr6730 inArrayAssignment@var2320 =@expr1073748561 1 ; }
1050: compilePrecedence3 (@expr6738 tok@var2314 , state@var2315 ) ;
1051: state@var2315 .@expr6730 inArrayAssignment@var2320 =@expr1073748564 inArrayAssignment@var2319 ;
1052: compileUnaryOp (@expr1073748565 castTok@var2318 , state@var2315 , nullptr ) ;
1053: } else { if (@expr1073748566 state@var2315 .@expr6692 cpp@var2316 &&@expr1073748568 Token ::@expr6683 Match (@expr1073748570 tok@var2314 , "new %name%|::|(" ) ) {
1054: Token * newtok@var2321 ; newtok@var2321 =@expr1073748571 tok@var2314 ;
1055: tok@var2314 =@expr1073748572 tok@var2314 .@expr6697 next (@expr6698 ) ;
1056: bool innertype@var2322 ; innertype@var2322 =@expr1073748575 false ;
1057: if (@expr1073748576 tok@var2314 .@expr6715 str (@expr6716 ) ==@expr6717 "(" ) {
1058: if (@expr1073748580 Token ::@expr6683 Match (@expr6758 tok@var2314 , "( &| %name%" ) &&@expr1073748583 Token ::@expr6683 Match (@expr1073748585 tok@var2314 .@expr6725 link (@expr6726 ) , ") ( %type%" ) &&@expr1073748588 Token ::@expr6765 simpleMatch (@expr1073748590 tok@var2314 .@expr6725 link (@expr6726 ) .@expr1073748593 linkAt (@expr1073748594 1 ) , ") (" ) ) {
1059: tok@var2314 =@expr1073748595 tok@var2314 .@expr6725 link (@expr6726 ) .@expr6727 next (@expr6728 ) ; }
1060: if (@expr1073748600 Token ::@expr6683 Match (@expr1073748602 tok@var2314 .@expr6725 link (@expr6726 ) , ") ::| %type%" ) ) {
1061: if (@expr1073748605 Token ::@expr6683 Match (@expr1073748607 tok@var2314 , "( !!)" ) ) {
1062: Token * innerTok@var2323 ; innerTok@var2323 =@expr1073748608 tok@var2314 .@expr6697 next (@expr6698 ) ;
1063: AST_state innerState@var2324 (@expr1073748611 true ) ;
1064: compileExpression (@expr1073748612 innerTok@var2323 , innerState@var2324 ) ;
1065: }
1066: tok@var2314 =@expr1073748613 tok@var2314 .@expr6725 link (@expr6726 ) .@expr6727 next (@expr6728 ) ;
1067: } else { if (@expr1073748618 Token ::@expr6683 Match (@expr1073748620 tok@var2314 , "( %type%" ) &&@expr1073748621 Token ::@expr6683 Match (@expr1073748623 tok@var2314 .@expr6725 link (@expr6726 ) , ") [();,[]" ) ) {
1068: tok@var2314 =@expr1073748626 tok@var2314 .@expr6697 next (@expr6698 ) ;
1069: innertype@var2322 =@expr1073748629 true ;
1070: } else { if (@expr1073748630 Token ::@expr6683 Match (@expr6758 tok@var2314 , "( &| %name%" ) &&@expr1073748633 Token ::@expr6765 simpleMatch (@expr1073748635 tok@var2314 .@expr6725 link (@expr6726 ) , ") (" ) ) {
1071: tok@var2314 =@expr1073748638 tok@var2314 .@expr6697 next (@expr6698 ) ;
1072: innertype@var2322 =@expr1073748641 true ;
1073: } else {
1074:
1075: continue ;
1076: } } }
1077: }
1078:
1079: Token * leftToken@var2325 ; leftToken@var2325 =@expr1073748642 tok@var2314 ;
1080: while (@expr1073748643 Token ::@expr6683 Match (@expr1073748645 tok@var2314 .@expr6697 next (@expr6698 ) , ":: %name%" ) ) {
1081: Token * scopeToken@var2326 ; scopeToken@var2326 =@expr1073748648 tok@var2314 .@expr6697 next (@expr6698 ) ;
1082: scopeToken@var2326 .@expr1073748651 astOperand1 (@expr1073748652 leftToken@var2325 ) ;
1083: scopeToken@var2326 .@expr1073748653 astOperand2 (@expr1073748654 scopeToken@var2326 .@expr6831 next (@expr6832 ) ) ;
1084: leftToken@var2325 =@expr1073748657 scopeToken@var2326 ;
1085: tok@var2314 =@expr1073748658 scopeToken@var2326 .@expr6831 next (@expr6832 ) ;
1086: }
1087:
1088: state@var2315 .@expr6837 op@var2327 .@expr6838 push (@expr1073748663 tok@var2314 ) ;
1089: while (@expr1073748664 Token ::@expr6683 Match (@expr1073748666 tok@var2314 , "%name%|*|&|<|::" ) ) {
1090: if (@expr1073748667 tok@var2314 .@expr6725 link (@expr6726 ) ) {
1091: tok@var2314 =@expr1073748670 tok@var2314 .@expr6725 link (@expr6726 ) ; }
1092: tok@var2314 =@expr1073748673 tok@var2314 .@expr6697 next (@expr6698 ) ;
1093: }
1094: if (@expr1073748676 Token ::@expr6683 Match (@expr1073748678 tok@var2314 , "( const| %type% ) (" ) ) {
1095: state@var2315 .@expr6837 op@var2327 .@expr6838 push (@expr1073748681 tok@var2314 .@expr6697 next (@expr6698 ) ) ;
1096: tok@var2314 =@expr1073748684 tok@var2314 .@expr6725 link (@expr6726 ) .@expr6727 next (@expr6728 ) ;
1097: compileBinOp (@expr1073748689 tok@var2314 , state@var2315 , compilePrecedence2 ) ;
1098: } else { if (@expr1073748690 tok@var2314 &&@expr1073748691 (@expr1073748692 tok@var2314 .@expr6715 str (@expr6716 ) ==@expr6871 "[" ||@expr1073748696 tok@var2314 .@expr6715 str (@expr6716 ) ==@expr6717 "(" ||@expr1073748700 tok@var2314 .@expr6715 str (@expr6716 ) ==@expr6735 "{" ) ) {
1099: compilePrecedence2 (@expr6679 tok@var2314 , state@var2315 ) ; }
1100: else { if (@expr1073748705 innertype@var2322 &&@expr1073748706 Token ::@expr6765 simpleMatch (@expr1073748708 tok@var2314 , ") [" ) ) {
1101: tok@var2314 =@expr1073748709 tok@var2314 .@expr6697 next (@expr6698 ) ;
1102: compilePrecedence2 (@expr6679 tok@var2314 , state@var2315 ) ;
1103: } } }
1104: compileUnaryOp (@expr1073748713 newtok@var2321 , state@var2315 , nullptr ) ;
1105: if (@expr1073748714 innertype@var2322 &&@expr1073748715 Token ::@expr6765 simpleMatch (@expr1073748717 tok@var2314 , ") ," ) ) {
1106: tok@var2314 =@expr1073748718 tok@var2314 .@expr6697 next (@expr6698 ) ; }
1107: } else { if (@expr1073748721 state@var2315 .@expr6692 cpp@var2316 &&@expr1073748723 Token ::@expr6683 Match (@expr1073748725 tok@var2314 , "delete %name%|*|&|::|(|[" ) ) {
1108: Token * tok2@var2328 ; tok2@var2328 =@expr1073748726 tok@var2314 ;
1109: tok@var2314 =@expr1073748727 tok@var2314 .@expr6697 next (@expr6698 ) ;
1110: if (@expr1073748730 tok@var2314 &&@expr1073748731 tok@var2314 .@expr6715 str (@expr6716 ) ==@expr6871 "[" ) {
1111: tok@var2314 =@expr1073748735 tok@var2314 .@expr6725 link (@expr6726 ) .@expr6727 next (@expr6728 ) ; }
1112: compilePrecedence3 (@expr6738 tok@var2314 , state@var2315 ) ;
1113: compileUnaryOp (@expr1073748741 tok2@var2328 , state@var2315 , nullptr ) ;
1114: }
1115:
1116: else { break ; } } } }
1117: }
1118: }
1119:
1120: static void compilePointerToElem ( Token * & tok@var2329 , AST_state & state@var2330 )
1121: {
1122: compilePrecedence3 (@expr1073748742 tok@var2329 , state@var2330 ) ;
1123: while (@expr1073748743 tok@var2329 ) {
1124: if (@expr1073748744 Token ::@expr1073748745 simpleMatch (@expr1073748746 tok@var2329 , ". *" ) ) {
1125: compileBinOp (@expr1073748747 tok@var2329 , state@var2330 , compilePrecedence3 ) ;
1126: } else { break ; }
1127: }
1128: }
1129:
1130: static void compileMulDiv ( Token * & tok@var2331 , AST_state & state@var2332 )
1131: {
1132: compilePointerToElem (@expr1073748748 tok@var2331 , state@var2332 ) ;
1133: while (@expr1073748749 tok@var2331 ) {
1134: if (@expr1073748750 Token ::@expr6927 Match (@expr1073748752 tok@var2331 , "[/%]" ) ||@expr1073748753 (@expr1073748754 tok@var2331 .@expr1073748755 str (@expr1073748756 ) ==@expr1073748757 "*" &&@expr1073748758 !@expr1073748759 tok@var2331 .@expr1073748760 astOperand1 (@expr1073748761 ) &&@expr1073748762 !@expr1073748763 isQualifier (@expr1073748764 tok@var2331 ) ) ) {
1135: if (@expr1073748765 Token ::@expr6927 Match (@expr1073748767 tok@var2331 , "* [*,)]" ) ) {
1136: Token * tok2@var2333 ; tok2@var2333 =@expr1073748768 tok@var2331 .@expr1073748769 next (@expr1073748770 ) ;
1137: while (@expr1073748771 tok2@var2333 .@expr6948 next (@expr6949 ) &&@expr1073748774 tok2@var2333 .@expr1073748775 str (@expr1073748776 ) ==@expr1073748777 "*" ) {
1138: tok2@var2333 =@expr1073748778 tok2@var2333 .@expr6948 next (@expr6949 ) ; }
1139: if (@expr1073748781 Token ::@expr6927 Match (@expr1073748783 tok2@var2333 , "[>),]" ) ) {
1140: tok@var2331 =@expr1073748784 tok2@var2333 ;
1141: break ;
1142: }
1143: }
1144: compileBinOp (@expr1073748785 tok@var2331 , state@var2332 , compilePointerToElem ) ;
1145: } else { break ; }
1146: }
1147: }
1148:
1149: static void compileAddSub ( Token * & tok@var2334 , AST_state & state@var2335 )
1150: {
1151: compileMulDiv (@expr1073748786 tok@var2334 , state@var2335 ) ;
1152: while (@expr1073748787 tok@var2334 ) {
1153: if (@expr1073748788 Token ::@expr1073748789 Match (@expr1073748790 tok@var2334 , "+|-" ) &&@expr1073748791 !@expr1073748792 tok@var2334 .@expr1073748793 astOperand1 (@expr1073748794 ) ) {
1154: compileBinOp (@expr1073748795 tok@var2334 , state@var2335 , compileMulDiv ) ;
1155: } else { break ; }
1156: }
1157: }
1158:
1159: static void compileShift ( Token * & tok@var2336 , AST_state & state@var2337 )
1160: {
1161: compileAddSub (@expr1073748796 tok@var2336 , state@var2337 ) ;
1162: while (@expr1073748797 tok@var2336 ) {
1163: if (@expr1073748798 Token ::@expr1073748799 Match (@expr1073748800 tok@var2336 , "<<|>>" ) ) {
1164: compileBinOp (@expr1073748801 tok@var2336 , state@var2337 , compileAddSub ) ;
1165: } else { break ; }
1166: }
1167: }
1168:
1169: static void compileThreewayComp ( Token * & tok@var2338 , AST_state & state@var2339 )
1170: {
1171: compileShift (@expr1073748802 tok@var2338 , state@var2339 ) ;
1172: while (@expr1073748803 tok@var2338 ) {
1173: if (@expr1073748804 tok@var2338 .@expr1073748805 str (@expr1073748806 ) ==@expr1073748807 "<=>" ) {
1174: compileBinOp (@expr1073748808 tok@var2338 , state@var2339 , compileShift ) ;
1175: } else { break ; }
1176: }
1177: }
1178:
1179: static void compileRelComp ( Token * & tok@var2340 , AST_state & state@var2341 )
1180: {
1181: compileThreewayComp (@expr1073748809 tok@var2340 , state@var2341 ) ;
1182: while (@expr1073748810 tok@var2340 ) {
1183: if (@expr1073748811 Token ::@expr1073748812 Match (@expr1073748813 tok@var2340 , "<|<=|>=|>" ) &&@expr1073748814 !@expr1073748815 tok@var2340 .@expr1073748816 link (@expr1073748817 ) ) {
1184: compileBinOp (@expr1073748818 tok@var2340 , state@var2341 , compileThreewayComp ) ;
1185: } else { break ; }
1186: }
1187: }
1188:
1189: static void compileEqComp ( Token * & tok@var2342 , AST_state & state@var2343 )
1190: {
1191: compileRelComp (@expr1073748819 tok@var2342 , state@var2343 ) ;
1192: while (@expr1073748820 tok@var2342 ) {
1193: if (@expr1073748821 Token ::@expr1073748822 Match (@expr1073748823 tok@var2342 , "==|!=" ) ) {
1194: compileBinOp (@expr1073748824 tok@var2342 , state@var2343 , compileRelComp ) ;
1195: } else { break ; }
1196: }
1197: }
1198:
1199: static void compileAnd ( Token * & tok@var2344 , AST_state & state@var2345 )
1200: {
1201: compileEqComp (@expr1073748825 tok@var2344 , state@var2345 ) ;
1202: while (@expr1073748826 tok@var2344 ) {
1203: if (@expr1073748827 tok@var2344 .@expr1073748828 str (@expr1073748829 ) ==@expr1073748830 "&" &&@expr1073748831 !@expr1073748832 tok@var2344 .@expr1073748833 astOperand1 (@expr1073748834 ) &&@expr1073748835 !@expr1073748836 isQualifier (@expr1073748837 tok@var2344 ) ) {
1204: Token * tok2@var2346 ; tok2@var2346 =@expr1073748838 tok@var2344 .@expr1073748839 next (@expr1073748840 ) ;
1205: if (@expr1073748841 !@expr1073748842 tok2@var2346 ) {
1206: break ; }
1207: if (@expr1073748843 tok2@var2346 .@expr1073748844 str (@expr1073748845 ) ==@expr1073748846 "&" ) {
1208: tok2@var2346 =@expr1073748847 tok2@var2346 .@expr1073748848 next (@expr1073748849 ) ; }
1209: if (@expr1073748850 state@var2345 .@expr1073748851 cpp@var2347 &&@expr1073748852 Token ::@expr1073748853 Match (@expr1073748854 tok2@var2346 , ",|)" ) ) {
1210: tok@var2344 =@expr1073748855 tok2@var2346 ;
1211: break ;
1212: }
1213: compileBinOp (@expr1073748856 tok@var2344 , state@var2345 , compileEqComp ) ;
1214: } else { break ; }
1215: }
1216: }
1217:
1218: static void compileXor ( Token * & tok@var2348 , AST_state & state@var2349 )
1219: {
1220: compileAnd (@expr1073748857 tok@var2348 , state@var2349 ) ;
1221: while (@expr1073748858 tok@var2348 ) {
1222: if (@expr1073748859 tok@var2348 .@expr1073748860 str (@expr1073748861 ) ==@expr1073748862 "^" ) {
1223: compileBinOp (@expr1073748863 tok@var2348 , state@var2349 , compileAnd ) ;
1224: } else { break ; }
1225: }
1226: }
1227:
1228: static void compileOr ( Token * & tok@var2350 , AST_state & state@var2351 )
1229: {
1230: compileXor (@expr1073748864 tok@var2350 , state@var2351 ) ;
1231: while (@expr1073748865 tok@var2350 ) {
1232: if (@expr1073748866 tok@var2350 .@expr1073748867 str (@expr1073748868 ) ==@expr1073748869 "|" ) {
1233: compileBinOp (@expr1073748870 tok@var2350 , state@var2351 , compileXor ) ;
1234: } else { break ; }
1235: }
1236: }
1237:
1238: static void compileLogicAnd ( Token * & tok@var2352 , AST_state & state@var2353 )
1239: {
1240: compileOr (@expr1073748871 tok@var2352 , state@var2353 ) ;
1241: while (@expr1073748872 tok@var2352 ) {
1242: if (@expr1073748873 tok@var2352 .@expr1073748874 str (@expr1073748875 ) ==@expr1073748876 "&&" &&@expr1073748877 !@expr1073748878 isQualifier (@expr1073748879 tok@var2352 ) ) {
1243: if (@expr1073748880 !@expr1073748881 tok@var2352 .@expr1073748882 astOperand1 (@expr1073748883 ) ) {
1244: Token * tok2@var2354 ; tok2@var2354 =@expr1073748884 tok@var2352 .@expr1073748885 next (@expr1073748886 ) ;
1245: if (@expr1073748887 !@expr1073748888 tok2@var2354 ) {
1246: break ; }
1247: if (@expr1073748889 state@var2353 .@expr1073748890 cpp@var2355 &&@expr1073748891 Token ::@expr1073748892 Match (@expr1073748893 tok2@var2354 , ",|)" ) ) {
1248: tok@var2352 =@expr1073748894 tok2@var2354 ;
1249: break ;
1250: }
1251: }
1252: compileBinOp (@expr1073748895 tok@var2352 , state@var2353 , compileOr ) ;
1253: } else { break ; }
1254: }
1255: }
1256:
1257: static void compileLogicOr ( Token * & tok@var2356 , AST_state & state@var2357 )
1258: {
1259: compileLogicAnd (@expr1073748896 tok@var2356 , state@var2357 ) ;
1260: while (@expr1073748897 tok@var2356 ) {
1261: if (@expr1073748898 tok@var2356 .@expr1073748899 str (@expr1073748900 ) ==@expr1073748901 "||" ) {
1262: compileBinOp (@expr1073748902 tok@var2356 , state@var2357 , compileLogicAnd ) ;
1263: } else { break ; }
1264: }
1265: }
1266:
1267: static void compileAssignTernary ( Token * & tok@var2358 , AST_state & state@var2359 )
1268: {
1269: compileLogicOr (@expr1073748903 tok@var2358 , state@var2359 ) ;
1270: while (@expr1073748904 tok@var2358 ) {
1271: if (@expr1073748905 tok@var2358 .@expr1073748906 isAssignmentOp (@expr1073748907 ) ) {
1272: state@var2359 .@expr7084 assign@var2360 ++@expr1073748909 ;
1273: const Token * tok1@var2361 ; tok1@var2361 =@expr1073748910 tok@var2358 .@expr7087 next (@expr7088 ) ;
1274: compileBinOp (@expr7089 tok@var2358 , state@var2359 , compileAssignTernary ) ;
1275: if (@expr1073748914 Token ::@expr1073748915 simpleMatch (@expr1073748916 tok1@var2361 , "{" ) &&@expr1073748917 tok@var2358 ==@expr1073748918 tok1@var2361 .@expr1073748919 link (@expr1073748920 ) &&@expr1073748921 tok@var2358 .@expr7087 next (@expr7088 ) ) {
1276: tok@var2358 =@expr1073748924 tok@var2358 .@expr7087 next (@expr7088 ) ; }
1277: if (@expr7103 state@var2359 .@expr7084 assign@var2360 >@expr7105 0 ) {
1278: state@var2359 .@expr7084 assign@var2360 --@expr1073748931 ; }
1279: } else { if (@expr1073748932 tok@var2358 .@expr7109 str (@expr7110 ) ==@expr1073748935 "?" ) {
1280:
1281:
1282:
1283: const bool stopAtColon@var2362 =@expr1073748936 state@var2359 .@expr7113 stopAtColon@var2363 ;
1284: state@var2359 .@expr7113 stopAtColon@var2363 =@expr1073748939 false ;
1285: if (@expr1073748940 tok@var2358 .@expr1073748941 strAt (@expr1073748942 1 ) ==@expr1073748943 ":" ) {
1286: state@var2359 .@expr1073748944 op@var2364 .@expr1073748945 push (@expr1073748946 nullptr ) ;
1287: }
1288: const int assign@var2365 =@expr1073748947 state@var2359 .@expr7084 assign@var2360 ;
1289: state@var2359 .@expr7084 assign@var2360 =@expr1073748950 0 ;
1290: compileBinOp (@expr7089 tok@var2358 , state@var2359 , compileAssignTernary ) ;
1291: state@var2359 .@expr7084 assign@var2360 =@expr1073748953 assign@var2365 ;
1292: state@var2359 .@expr7113 stopAtColon@var2363 =@expr1073748955 stopAtColon@var2362 ;
1293: } else { if (@expr1073748956 tok@var2358 .@expr7109 str (@expr7110 ) ==@expr1073748959 ":" ) {
1294: if (@expr1073748960 state@var2359 .@expr1073748961 depth@var2366 ==@expr1073748962 1U &&@expr1073748963 state@var2359 .@expr7140 inCase@var2367 ) {
1295: state@var2359 .@expr7140 inCase@var2367 =@expr1073748966 false ;
1296: tok@var2358 =@expr1073748967 tok@var2358 .@expr7087 next (@expr7088 ) ;
1297: break ;
1298: }
1299: if (@expr1073748970 state@var2359 .@expr7113 stopAtColon@var2363 ) {
1300: break ; }
1301: if (@expr7103 state@var2359 .@expr7084 assign@var2360 >@expr7105 0 ) {
1302: break ; }
1303: compileBinOp (@expr7089 tok@var2358 , state@var2359 , compileAssignTernary ) ;
1304: } else { break ; } } }
1305: }
1306: }
1307:
1308: static void compileComma ( Token * & tok@var2368 , AST_state & state@var2369 )
1309: {
1310: compileAssignTernary (@expr1073748976 tok@var2368 , state@var2369 ) ;
1311: while (@expr1073748977 tok@var2368 ) {
1312: if (@expr1073748978 tok@var2368 .@expr7155 str (@expr7156 ) ==@expr1073748981 "," ) {
1313: if (@expr1073748982 Token ::@expr1073748983 simpleMatch (@expr1073748984 tok@var2368 , ", }" ) ) {
1314: tok@var2368 =@expr1073748985 tok@var2368 .@expr1073748986 next (@expr1073748987 ) ; }
1315: else {
1316: compileBinOp (@expr7164 tok@var2368 , state@var2369 , compileAssignTernary ) ; }
1317: } else { if (@expr1073748989 tok@var2368 .@expr7155 str (@expr7156 ) ==@expr1073748992 ";" &&@expr1073748993 state@var2369 .@expr7170 functionCallEndPar@var2370 &&@expr1073748995 tok@var2368 .@expr1073748996 index (@expr1073748997 ) <@expr1073748998 state@var2369 .@expr7170 functionCallEndPar@var2370 .@expr1073749000 index (@expr1073749001 ) ) {
1318: compileBinOp (@expr7164 tok@var2368 , state@var2369 , compileAssignTernary ) ;
1319: } else { break ; } }
1320: }
1321: }
1322:
1323: static void compileExpression ( Token * & tok@var2371 , AST_state & state@var2372 )
1324: {
1325: if (@expr1073749003 state@var2372 .@expr1073749004 depth@var2373 >@expr1073749005 AST_MAX_DEPTH@var2169 ) {
1326: throw InternalError (@expr1073749006 tok@var2371 , "maximum AST depth exceeded" , InternalError ::@expr1073749007 AST ) ; }
1327: if (@expr1073749008 tok@var2371 ) {
1328: compileComma (@expr1073749009 tok@var2371 , state@var2372 ) ; }
1329: }
1330:
1331: static bool isLambdaCaptureList ( const Token * tok@var2374 )
1332: {
1333:
|
1337:
1338: if (@expr1073749010 tok@var2374 .@expr1073749011 str (@expr1073749012 ) !=@expr1073749013 "[" ) {
1339: return false ; }
1340: if (@expr1073749014 !@expr1073749015 Token ::@expr1073749016 Match (@expr1073749017 tok@var2374 .@expr7194 link (@expr7195 ) , "] (|{" ) ) {
1341: return false ; }
1342: if (@expr1073749020 Token ::@expr1073749021 simpleMatch (@expr1073749022 tok@var2374 .@expr7199 astOperand1 (@expr7200 ) , "{" ) &&@expr1073749025 tok@var2374 .@expr7199 astOperand1 (@expr7200 ) ==@expr1073749028 tok@var2374 .@expr7194 link (@expr7195 ) .@expr1073749031 next (@expr1073749032 ) ) {
1343: return true ; }
1344: if (@expr1073749033 !@expr1073749034 tok@var2374 .@expr7199 astOperand1 (@expr7200 ) ||@expr1073749037 tok@var2374 .@expr7199 astOperand1 (@expr7200 ) .@expr1073749040 str (@expr1073749041 ) !=@expr1073749042 "(" ) {
1345: return false ; }
1346: const Token * params@var2375 ; params@var2375 =@expr1073749043 tok@var2374 .@expr7199 astOperand1 (@expr7200 ) ;
1347: if (@expr1073749046 !@expr1073749047 params@var2375 .@expr7224 astOperand1 (@expr7225 ) ||@expr1073749050 params@var2375 .@expr7224 astOperand1 (@expr7225 ) .@expr1073749053 str (@expr1073749054 ) !=@expr1073749055 "{" ) {
1348: return false ; }
1349: return true ;
1350: }
1351:
1352: static Token * createAstAtToken ( Token * tok@var2376 , bool cpp@var2377 ) ;
1353:
1354:
1355: static void createAstAtTokenInner ( Token * const tok1@var2378 , const Token * endToken@var2379 , bool cpp@var2380 )
1356: {
1357: for (@expr1073749056 Token *@expr7233 tok@var2381 =@expr1073749058 tok1@var2378 ; precedes (@expr1073749059 tok@var2381 , endToken@var2379 ) ; tok@var2381 =@expr1073749060 tok@var2381 ?@expr7237 tok@var2381 .@expr7238 next (@expr7239 ) :@expr7240 nullptr ) {
1358: if (@expr1073749065 tok@var2381 .@expr7242 str (@expr7243 ) ==@expr1073749068 "{" &&@expr1073749069 !@expr1073749070 iscpp11init (@expr1073749071 tok@var2381 ) ) {
1359: const Token * const endToken2@var2382 ; endToken2@var2382 =@expr1073749072 tok@var2381 .@expr7249 link (@expr7250 ) ;
1360: bool hasAst@var2383 ; hasAst@var2383 =@expr1073749075 false ;
1361: for (@expr1073749076 const Token *@expr7233 inner@var2384 =@expr1073749078 tok@var2381 .@expr7238 next (@expr7239 ) ; inner@var2384 !=@expr1073749081 endToken2@var2382 ; inner@var2384 =@expr1073749082 inner@var2384 .@expr1073749083 next (@expr1073749084 ) ) {
1362: if (@expr1073749085 inner@var2384 .@expr1073749086 astOperand1 (@expr1073749087 ) ) {
1363: hasAst@var2383 =@expr1073749088 true ;
1364: break ;
1365: }
1366: if (@expr1073749089 tok@var2381 .@expr1073749090 isConstOp (@expr1073749091 ) ) {
1367: break ; }
1368: if (@expr1073749092 inner@var2384 .@expr1073749093 str (@expr1073749094 ) ==@expr1073749095 "{" ) {
1369: inner@var2384 =@expr1073749096 inner@var2384 .@expr1073749097 link (@expr1073749098 ) ; }
1370: }
1371: if (@expr1073749099 !@expr1073749100 hasAst@var2383 ) {
1372: for (@expr1073749101 ; tok@var2381 &&@expr7278 tok@var2381 !=@expr7279 endToken@var2379 &&@expr1073749104 tok@var2381 !=@expr1073749105 endToken2@var2382 ; tok@var2381 =@expr1073749106 tok@var2381 ?@expr7237 tok@var2381 .@expr7238 next (@expr7239 ) :@expr7240 nullptr ) {
1373: tok@var2381 =@expr1073749111 createAstAtToken (@expr7288 tok@var2381 , cpp@var2380 ) ; }
1374: }
1375: } else { if (@expr1073749113 cpp@var2380 &&@expr1073749114 tok@var2381 .@expr7242 str (@expr7243 ) ==@expr1073749117 "[" ) {
1376: if (@expr1073749118 isLambdaCaptureList (@expr1073749119 tok@var2381 ) ) {
1377: tok@var2381 =@expr1073749120 tok@var2381 .@expr7297 astOperand1 (@expr7298 ) ;
1378: if (@expr1073749123 tok@var2381 .@expr7242 str (@expr7243 ) ==@expr1073749126 "(" ) {
1379: tok@var2381 =@expr1073749127 tok@var2381 .@expr7297 astOperand1 (@expr7298 ) ; }
1380: const Token * const endToken2@var2385 ; endToken2@var2385 =@expr1073749130 tok@var2381 .@expr7249 link (@expr7250 ) ;
1381: tok@var2381 =@expr1073749133 tok@var2381 .@expr7238 next (@expr7239 ) ;
1382: for (@expr1073749136 ; tok@var2381 &&@expr7278 tok@var2381 !=@expr7279 endToken@var2379 &&@expr1073749139 tok@var2381 !=@expr1073749140 endToken2@var2385 ; tok@var2381 =@expr1073749141 tok@var2381 ?@expr7237 tok@var2381 .@expr7238 next (@expr7239 ) :@expr7240 nullptr ) {
1383: tok@var2381 =@expr1073749146 createAstAtToken (@expr7288 tok@var2381 , cpp@var2380 ) ; }
1384: }
1385: }
1386: else { if (@expr1073749148 Token ::@expr1073749149 simpleMatch (@expr1073749150 tok@var2381 , "( * ) [" ) ) {
1387: bool hasAst@var2386 ; hasAst@var2386 =@expr1073749151 false ;
1388: for (@expr1073749152 const Token *@expr7233 tok2@var2387 =@expr1073749154 tok@var2381 .@expr1073749155 linkAt (@expr1073749156 3 ) ; tok2@var2387 !=@expr1073749157 tok@var2381 ; tok2@var2387 =@expr1073749158 tok2@var2387 .@expr1073749159 previous (@expr1073749160 ) ) {
1389: if (@expr1073749161 tok2@var2387 .@expr1073749162 astParent (@expr1073749163 ) ||@expr1073749164 tok2@var2387 .@expr1073749165 astOperand1 (@expr1073749166 ) ||@expr1073749167 tok2@var2387 .@expr1073749168 astOperand2 (@expr1073749169 ) ) {
1390: hasAst@var2386 =@expr1073749170 true ;
1391: break ;
1392: }
1393: }
1394: if (@expr1073749171 !@expr1073749172 hasAst@var2386 ) {
1395: Token * const startTok@var2388 ; startTok@var2388 =@expr1073749173 tok@var2381 =@expr1073749174 tok@var2381 .@expr1073749175 tokAt (@expr1073749176 4 ) ;
1396: const Token * const endtok@var2389 ; endtok@var2389 =@expr1073749177 startTok@var2388 .@expr1073749178 linkAt (@expr1073749179 -1 ) ;
1397: AST_state state@var2390 (@expr1073749180 cpp@var2380 ) ;
1398: compileExpression (@expr1073749181 tok@var2381 , state@var2390 ) ;
1399: createAstAtTokenInner (@expr1073749182 startTok@var2388 , endtok@var2389 , cpp@var2380 ) ;
1400: }
1401: } } }
1402: }
1403: }
1404:
1405: static Token * findAstTop ( Token * tok1@var2391 , Token * tok2@var2392 )
1406: {
1407: for (@expr1073749183 Token *@expr7360 tok@var2393 =@expr1073749185 tok1@var2391 ; tok@var2393 &&@expr1073749186 (@expr1073749187 tok@var2393 !=@expr1073749188 tok2@var2392 ) ; tok@var2393 =@expr1073749189 tok@var2393 .@expr1073749190 next (@expr1073749191 ) ) {
1408: if (@expr1073749192 tok@var2393 .@expr7369 astParent (@expr7370 ) ||@expr1073749195 tok@var2393 .@expr1073749196 astOperand1 (@expr1073749197 ) ||@expr1073749198 tok@var2393 .@expr1073749199 astOperand2 (@expr1073749200 ) ) {
1409: while (@expr1073749201 tok@var2393 .@expr7369 astParent (@expr7370 ) &&@expr1073749204 tok@var2393 .@expr7369 astParent (@expr7370 ) .@expr7383 index (@expr7384 ) >=@expr1073749209 tok1@var2391 .@expr1073749210 index (@expr1073749211 ) &&@expr1073749212 tok@var2393 .@expr7369 astParent (@expr7370 ) .@expr7383 index (@expr7384 ) <=@expr1073749217 tok2@var2392 .@expr1073749218 index (@expr1073749219 ) ) {
1410: tok@var2393 =@expr1073749220 tok@var2393 .@expr7369 astParent (@expr7370 ) ; }
1411: return tok@var2393 ;
1412: }
1413: if (@expr1073749223 Token ::@expr7400 simpleMatch (@expr1073749225 tok@var2393 , "( {" ) ) {
1414: tok@var2393 =@expr1073749226 tok@var2393 .@expr1073749227 link (@expr1073749228 ) ; }
1415: }
1416: for (@expr1073749229 Token *@expr7360 tok@var2394 =@expr1073749231 tok1@var2391 ; tok@var2394 &&@expr1073749232 (@expr1073749233 tok@var2394 !=@expr1073749234 tok2@var2392 ) ; tok@var2394 =@expr1073749235 tok@var2394 .@expr1073749236 next (@expr1073749237 ) ) {
1417: if (@expr1073749238 tok@var2394 .@expr1073749239 isName (@expr1073749240 ) ||@expr1073749241 tok@var2394 .@expr1073749242 isNumber (@expr1073749243 ) ) {
1418: return tok@var2394 ; }
1419: if (@expr1073749244 Token ::@expr7400 simpleMatch (@expr1073749246 tok@var2394 , "( {" ) ) {
1420: tok@var2394 =@expr1073749247 tok@var2394 .@expr1073749248 link (@expr1073749249 ) ; }
1421: }
1422: return nullptr ;
1423: }
1424:
1425: static Token * createAstAtToken ( Token * tok@var2395 , bool cpp@var2396 )
1426: {
1427: if (@expr1073749250 Token ::@expr7427 simpleMatch (@expr1073749252 tok@var2395 , "for (" ) ) {
1428: if (@expr1073749253 cpp@var2396 &&@expr1073749254 Token ::@expr7431 Match (@expr1073749256 tok@var2395 , "for ( const| auto &|&&| [" ) ) {
1429: Token * decl@var2397 ; decl@var2397 =@expr1073749257 Token ::@expr1073749258 findsimplematch (@expr1073749259 tok@var2395 , "[" ) ;
1430: if (@expr1073749260 Token ::@expr7427 simpleMatch (@expr1073749262 decl@var2397 .@expr1073749263 link (@expr1073749264 ) , "] :" ) ) {
1431: AST_state state1@var2398 (@expr1073749265 cpp@var2396 ) ;
1432: while (@expr1073749266 decl@var2397 .@expr7443 str (@expr7444 ) !=@expr1073749269 "]" ) {
1433: if (@expr1073749270 Token ::@expr7431 Match (@expr1073749272 decl@var2397 , "%name% ,|]" ) ) {
1434: state1@var2398 .@expr7449 op@var2399 .@expr7450 push (@expr7451 decl@var2397 ) ;
1435: } else { if (@expr1073749276 decl@var2397 .@expr7443 str (@expr7444 ) ==@expr1073749279 "," ) {
1436: if (@expr7456 !@expr7457 state1@var2398 .@expr7449 op@var2399 .@expr7459 empty (@expr7460 ) ) {
1437: decl@var2397 .@expr1073749285 astOperand1 (@expr1073749286 state1@var2398 .@expr7449 op@var2399 .@expr7464 top (@expr7465 ) ) ;
1438: state1@var2398 .@expr7449 op@var2399 .@expr7467 pop (@expr7468 ) ;
1439: }
1440: if (@expr7456 !@expr7457 state1@var2398 .@expr7449 op@var2399 .@expr7459 empty (@expr7460 ) ) {
1441: state1@var2398 .@expr7449 op@var2399 .@expr7464 top (@expr7465 ) .@expr7477 astOperand2 (@expr1073749302 decl@var2397 ) ;
1442: state1@var2398 .@expr7449 op@var2399 .@expr7467 pop (@expr7468 ) ;
1443: }
1444: state1@var2398 .@expr7449 op@var2399 .@expr7450 push (@expr7451 decl@var2397 ) ;
1445: } }
1446: decl@var2397 =@expr1073749309 decl@var2397 .@expr7486 next (@expr7487 ) ;
1447: }
1448: if (@expr1073749312 state1@var2398 .@expr7449 op@var2399 .@expr1073749314 size (@expr1073749315 ) >@expr1073749316 1 ) {
1449: Token * lastName@var2400 ; lastName@var2400 =@expr1073749317 state1@var2398 .@expr7449 op@var2399 .@expr7464 top (@expr7465 ) ;
1450: state1@var2398 .@expr7449 op@var2399 .@expr7467 pop (@expr7468 ) ;
1451: state1@var2398 .@expr7449 op@var2399 .@expr7464 top (@expr7465 ) .@expr7477 astOperand2 (@expr1073749328 lastName@var2400 ) ;
1452: }
1453: decl@var2397 =@expr1073749329 decl@var2397 .@expr7486 next (@expr7487 ) ;
1454:
1455: Token * colon@var2401 ; colon@var2401 =@expr1073749332 decl@var2397 ;
1456: compileExpression (@expr1073749333 decl@var2397 , state1@var2398 ) ;
1457:
1458: tok@var2395 .@expr7510 next (@expr7511 ) .@expr7512 astOperand1 (@expr7513 tok@var2395 ) ;
1459: tok@var2395 .@expr7510 next (@expr7511 ) .@expr7516 astOperand2 (@expr1073749341 colon@var2401 ) ;
1460:
1461: return decl@var2397 ;
1462: }
1463: }
1464:
1465: std ::@expr1073749342 vector < Token *@expr7519 > inner@var2402 ;
1466: Token * tok2@var2403 ; tok2@var2403 =@expr1073749344 skipDecl (@expr1073749345 tok@var2395 .@expr7522 tokAt (@expr7523 2 ) , &@expr1073749348 inner@var2402 ) ;
1467: for (@expr1073749349 Token *@expr7519 tok3@var2404 :@expr1073749351 inner@var2402 ) {
1468: AST_state state1@var2405 (@expr1073749352 cpp@var2396 ) ;
1469: compileExpression (@expr1073749353 tok3@var2404 , state1@var2405 ) ;
1470: }
1471: Token * init1@var2406 ; init1@var2406 =@expr1073749354 nullptr ;
1472: Token * const endPar@var2407 ; endPar@var2407 =@expr1073749355 tok@var2395 .@expr7510 next (@expr7511 ) .@expr1073749358 link (@expr1073749359 ) ;
1473: if (@expr1073749360 tok2@var2403 ==@expr1073749361 tok@var2395 .@expr7522 tokAt (@expr7523 2 ) &&@expr1073749364 Token ::@expr7431 Match (@expr1073749366 tok2@var2403 , "%op%|(" ) ) {
1474: init1@var2406 =@expr1073749367 tok2@var2403 ;
1475: AST_state state1@var2408 (@expr1073749368 cpp@var2396 ) ;
1476: compileExpression (@expr1073749369 tok2@var2403 , state1@var2408 ) ;
1477: if (@expr1073749370 Token ::@expr7431 Match (@expr1073749372 init1@var2406 , "( !!{" ) ) {
1478: for (@expr1073749373 Token *@expr7519 tok3@var2409 =@expr1073749375 init1@var2406 ; tok3@var2409 !=@expr1073749376 tok3@var2409 .@expr1073749377 link (@expr1073749378 ) ; tok3@var2409 =@expr1073749379 tok3@var2409 .@expr1073749380 next (@expr1073749381 ) ) {
1479: if (@expr1073749382 tok3@var2409 .@expr7559 astParent (@expr7560 ) ) {
1480: while (@expr1073749385 tok3@var2409 .@expr7559 astParent (@expr7560 ) ) {
1481: tok3@var2409 =@expr1073749388 tok3@var2409 .@expr7559 astParent (@expr7560 ) ; }
1482: init1@var2406 =@expr1073749391 tok3@var2409 ;
1483: break ;
1484: }
1485: if (@expr1073749392 !@expr1073749393 Token ::@expr7431 Match (@expr1073749395 tok3@var2409 , "%op%|(|[" ) ) {
1486: init1@var2406 =@expr1073749396 tok3@var2409 ; }
1487: }
1488: }
1489: } else {
1490: while (@expr1073749397 tok2@var2403 &&@expr1073749398 tok2@var2403 !=@expr1073749399 endPar@var2407 &&@expr1073749400 tok2@var2403 .@expr7577 str (@expr7578 ) !=@expr7579 ";" ) {
1491: if (@expr1073749404 tok2@var2403 .@expr7577 str (@expr7578 ) ==@expr1073749407 "<" &&@expr1073749408 tok2@var2403 .@expr7585 link (@expr7586 ) ) {
1492: tok2@var2403 =@expr1073749411 tok2@var2403 .@expr7585 link (@expr7586 ) ;
1493: } else { if (@expr1073749414 Token ::@expr7431 Match (@expr1073749416 tok2@var2403 , "%name% )| %op%|(|[|.|:|::" ) ||@expr1073749417 Token ::@expr7431 Match (@expr1073749419 tok2@var2403 .@expr1073749420 previous (@expr1073749421 ) , "[(;{}] %cop%|(" ) ) {
1494: init1@var2406 =@expr1073749422 tok2@var2403 ;
1495: AST_state state1@var2410 (@expr1073749423 cpp@var2396 ) ;
1496: compileExpression (@expr1073749424 tok2@var2403 , state1@var2410 ) ;
1497: if (@expr1073749425 Token ::@expr7431 Match (@expr1073749427 tok2@var2403 , ";|)" ) ) {
1498: break ; }
1499: init1@var2406 =@expr1073749428 nullptr ;
1500: } }
1501: if (@expr1073749429 !@expr7606 tok2@var2403 ) {
1502: return nullptr ; }
1503: tok2@var2403 =@expr1073749431 tok2@var2403 .@expr7608 next (@expr7609 ) ;
1504: }
1505: }
1506: if (@expr1073749434 !@expr7606 tok2@var2403 ||@expr1073749436 tok2@var2403 .@expr7577 str (@expr7578 ) !=@expr7579 ";" ) {
1507: if (@expr1073749440 tok2@var2403 ==@expr1073749441 endPar@var2407 &&@expr1073749442 init1@var2406 ) {
1508: tok@var2395 .@expr7510 next (@expr7511 ) .@expr7516 astOperand2 (@expr1073749446 init1@var2406 ) ;
1509: tok@var2395 .@expr7510 next (@expr7511 ) .@expr7512 astOperand1 (@expr7513 tok@var2395 ) ;
1510: }
1511: return tok2@var2403 ;
1512: }
1513:
1514: Token * const init@var2411 ; init@var2411 =@expr1073749451 init1@var2406 ?@expr1073749452 init1@var2406 :@expr1073749453 tok2@var2403 ;
1515:
1516: Token * const semicolon1@var2412 ; semicolon1@var2412 =@expr1073749454 tok2@var2403 ;
1517: tok2@var2403 =@expr1073749455 tok2@var2403 .@expr7608 next (@expr7609 ) ;
1518: AST_state state2@var2413 (@expr1073749458 cpp@var2396 ) ;
1519: compileExpression (@expr1073749459 tok2@var2403 , state2@var2413 ) ;
1520:
1521: Token * const semicolon2@var2414 ; semicolon2@var2414 =@expr1073749460 tok2@var2403 ;
1522: if (@expr1073749461 !@expr1073749462 semicolon2@var2414 ) {
1523: return nullptr ; }
1524:
1525: if (@expr1073749463 semicolon2@var2414 .@expr1073749464 str (@expr1073749465 ) ==@expr1073749466 ";" ) {
1526: tok2@var2403 =@expr1073749467 tok2@var2403 .@expr7608 next (@expr7609 ) ;
1527: AST_state state3@var2415 (@expr1073749470 cpp@var2396 ) ;
1528: if (@expr1073749471 Token ::@expr7427 simpleMatch (@expr1073749473 tok2@var2403 , "( {" ) ) {
1529: state3@var2415 .@expr7650 op@var2416 .@expr1073749475 push (@expr1073749476 tok2@var2403 .@expr7608 next (@expr7609 ) ) ;
1530: tok2@var2403 =@expr1073749479 tok2@var2403 .@expr7585 link (@expr7586 ) .@expr1073749482 next (@expr1073749483 ) ;
1531: }
1532: compileExpression (@expr1073749484 tok2@var2403 , state3@var2415 ) ;
1533:
1534: tok2@var2403 =@expr1073749485 findAstTop (@expr1073749486 semicolon1@var2412 .@expr1073749487 next (@expr1073749488 ) , semicolon2@var2414 ) ;
1535: if (@expr7665 tok2@var2403 ) {
1536: semicolon2@var2414 .@expr1073749490 astOperand1 (@expr1073749491 tok2@var2403 ) ; }
1537: tok2@var2403 =@expr1073749492 findAstTop (@expr1073749493 semicolon2@var2414 .@expr1073749494 next (@expr1073749495 ) , endPar@var2407 ) ;
1538: if (@expr7665 tok2@var2403 ) {
1539: semicolon2@var2414 .@expr7673 astOperand2 (@expr1073749498 tok2@var2403 ) ; }
1540: else { if (@expr1073749499 !@expr1073749500 state3@var2415 .@expr7650 op@var2416 .@expr1073749502 empty (@expr1073749503 ) ) {
1541: semicolon2@var2414 .@expr7673 astOperand2 (@expr1073749505 state3@var2415 .@expr7650 op@var2416 .@expr1073749507 top (@expr1073749508 ) ) ; } }
1542: semicolon1@var2412 .@expr7685 astOperand2 (@expr1073749510 semicolon2@var2414 ) ;
1543: } else {
1544: if (@expr1073749511 !@expr1073749512 cpp@var2396 ||@expr1073749513 !@expr1073749514 Token ::@expr7427 simpleMatch (@expr1073749516 state2@var2413 .@expr7693 op@var2417 .@expr7694 top (@expr7695 ) , ":" ) ) {
1545: throw InternalError (@expr1073749520 tok@var2395 , "syntax error" , InternalError ::@expr1073749521 SYNTAX ) ; }
1546:
1547: semicolon1@var2412 .@expr7685 astOperand2 (@expr1073749523 state2@var2413 .@expr7693 op@var2417 .@expr7694 top (@expr7695 ) ) ;
1548: }
1549:
1550: if (@expr1073749527 init@var2411 !=@expr1073749528 semicolon1@var2412 ) {
1551: semicolon1@var2412 .@expr1073749529 astOperand1 (@expr1073749530 init@var2411 .@expr1073749531 astTop (@expr1073749532 ) ) ; }
1552: tok@var2395 .@expr7510 next (@expr7511 ) .@expr7512 astOperand1 (@expr7513 tok@var2395 ) ;
1553: tok@var2395 .@expr7510 next (@expr7511 ) .@expr7516 astOperand2 (@expr1073749540 semicolon1@var2412 ) ;
1554:
1555: createAstAtTokenInner (@expr1073749541 endPar@var2407 .@expr1073749542 link (@expr1073749543 ) , endPar@var2407 , cpp@var2396 ) ;
1556:
1557: return endPar@var2407 ;
1558: }
1559:
1560: if (@expr1073749544 Token ::@expr7427 simpleMatch (@expr1073749546 tok@var2395 , "( {" ) ) {
1561: return tok@var2395 ; }
1562:
1563: if (@expr1073749547 Token ::@expr7431 Match (@expr1073749549 tok@var2395 , "%type% <" ) &&@expr1073749550 tok@var2395 .@expr7727 linkAt (@expr7728 1 ) &&@expr1073749553 !@expr1073749554 Token ::@expr7431 Match (@expr1073749556 tok@var2395 .@expr7727 linkAt (@expr7728 1 ) , "> [({]" ) ) {
1564: return tok@var2395 .@expr7727 linkAt (@expr7728 1 ) ; }
1565:
1566: if (@expr1073749561 cpp@var2396 &&@expr1073749562 !@expr1073749563 tok@var2395 .@expr1073749564 isKeyword (@expr1073749565 ) &&@expr1073749566 Token ::@expr7431 Match (@expr1073749568 tok@var2395 , "%type% ::|<|%name%" ) ) {
1567: Token * tok2@var2418 ; tok2@var2418 =@expr1073749569 tok@var2395 ;
1568: while (@expr1073749570 true ) {
1569: if (@expr1073749571 Token ::@expr7431 Match (@expr1073749573 tok2@var2418 , "%name%|> :: %name%" ) ) {
1570: tok2@var2418 =@expr1073749574 tok2@var2418 .@expr7751 tokAt (@expr7752 2 ) ; }
1571: else { if (@expr1073749577 Token ::@expr7431 Match (@expr1073749579 tok2@var2418 , "%name% <" ) &&@expr1073749580 tok2@var2418 .@expr7757 linkAt (@expr7758 1 ) ) {
1572: tok2@var2418 =@expr1073749583 tok2@var2418 .@expr7757 linkAt (@expr7758 1 ) ; }
1573: else {
1574: break ; } }
1575: }
1576: if (@expr1073749586 Token ::@expr7431 Match (@expr1073749588 tok2@var2418 , "%name%|> %name% {" ) &&@expr1073749589 tok2@var2418 .@expr7766 next (@expr7767 ) .@expr1073749592 varId (@expr1073749593 ) &&@expr1073749594 iscpp11init (@expr1073749595 tok2@var2418 .@expr7751 tokAt (@expr7752 2 ) ) ) {
1577: Token * const tok1@var2419 ; tok1@var2419 =@expr1073749598 tok@var2395 =@expr1073749599 tok2@var2418 .@expr7766 next (@expr7767 ) ;
1578: AST_state state@var2420 (@expr1073749602 cpp@var2396 ) ;
1579: compileExpression (@expr1073749603 tok@var2395 , state@var2420 ) ;
1580: createAstAtTokenInner (@expr1073749604 tok1@var2419 .@expr1073749605 next (@expr1073749606 ) , tok1@var2419 .@expr1073749607 linkAt (@expr1073749608 1 ) , cpp@var2396 ) ;
1581: return tok@var2395 ;
1582: }
1583: }
1584:
1585: if (@expr1073749609 Token ::@expr7431 Match (@expr1073749611 tok@var2395 , "%type% %name%|*|&|::" ) &&@expr1073749612 !@expr1073749613 Token ::@expr7431 Match (@expr1073749615 tok@var2395 , "return|new" ) ) {
1586: int typecount@var2421 ; typecount@var2421 =@expr1073749616 0 ;
1587: Token * typetok@var2422 ; typetok@var2422 =@expr1073749617 tok@var2395 ;
1588: while (@expr1073749618 Token ::@expr7431 Match (@expr1073749620 typetok@var2422 , "%type%|::|*|&" ) ) {
1589: if (@expr1073749621 typetok@var2422 .@expr1073749622 isName (@expr1073749623 ) &&@expr1073749624 !@expr1073749625 Token ::@expr7427 simpleMatch (@expr1073749627 typetok@var2422 .@expr7804 previous (@expr7805 ) , "::" ) ) {
1590: typecount@var2421 ++@expr1073749630 ; }
1591: typetok@var2422 =@expr1073749631 typetok@var2422 .@expr1073749632 next (@expr1073749633 ) ;
1592: }
1593: if (@expr1073749634 Token ::@expr7431 Match (@expr1073749636 typetok@var2422 , "%var% =" ) &&@expr1073749637 typetok@var2422 .@expr1073749638 varId (@expr1073749639 ) ) {
1594: tok@var2395 =@expr1073749640 typetok@var2422 ; }
1595:
1596:
1597: if (@expr1073749641 typetok@var2422 &&@expr1073749642
1598: typecount@var2421 >=@expr1073749643 2 &&@expr1073749644
1599: !@expr1073749645 Token ::@expr7431 Match (@expr1073749647 tok@var2395 , "return|throw" ) &&@expr1073749648
1600: Token ::@expr7431 Match (@expr1073749650 typetok@var2422 .@expr7804 previous (@expr7805 ) , "%name% ( !!*" ) &&@expr1073749653
1601: typetok@var2422 .@expr7804 previous (@expr7805 ) .@expr1073749656 varId (@expr1073749657 ) ==@expr1073749658 0 &&@expr1073749659
1602: !@expr1073749660 typetok@var2422 .@expr7804 previous (@expr7805 ) .@expr1073749663 isKeyword (@expr1073749664 ) &&@expr1073749665
1603: Token ::@expr7431 Match (@expr1073749667 typetok@var2422 .@expr1073749668 link (@expr1073749669 ) , ") const|;|{" ) ) {
1604: return typetok@var2422 ; }
1605: }
1606:
1607: if (@expr1073749670 Token ::@expr7431 Match (@expr1073749672 tok@var2395 , "return|case" ) ||@expr1073749673
1608: (@expr1073749674 cpp@var2396 &&@expr1073749675 tok@var2395 .@expr7852 str (@expr7853 ) ==@expr1073749678 "throw" ) ||@expr1073749679
1609: !@expr1073749680 tok@var2395 .@expr7857 previous (@expr7858 ) ||@expr1073749683
1610: Token ::@expr7431 Match (@expr1073749685 tok@var2395 , "%name% %op%|(|[|.|::|<|?|;" ) ||@expr1073749686
1611: (@expr1073749687 cpp@var2396 &&@expr1073749688 Token ::@expr7431 Match (@expr1073749690 tok@var2395 , "%name% {" ) &&@expr1073749691 iscpp11init (@expr1073749692 tok@var2395 .@expr7510 next (@expr7511 ) ) ) ||@expr1073749695
1612: Token ::@expr7431 Match (@expr1073749697 tok@var2395 .@expr7857 previous (@expr7858 ) , "[;{}] %cop%|++|--|( !!{" ) ||@expr1073749700
1613: Token ::@expr7431 Match (@expr1073749702 tok@var2395 .@expr7857 previous (@expr7858 ) , "[;{}] %num%|%str%|%char%" ) ) {
1614: if (@expr1073749705 cpp@var2396 &&@expr1073749706 (@expr1073749707 Token ::@expr7431 Match (@expr1073749709 tok@var2395 .@expr7522 tokAt (@expr1073749711 -2 ) , "[;{}] new|delete %name%" ) ||@expr1073749712 Token ::@expr7431 Match (@expr1073749714 tok@var2395 .@expr7522 tokAt (@expr1073749716 -3 ) , "[;{}] :: new|delete %name%" ) ) ) {
1615: tok@var2395 =@expr1073749717 tok@var2395 .@expr7857 previous (@expr7858 ) ; }
1616:
1617: Token * const tok1@var2423 ; tok1@var2423 =@expr1073749720 tok@var2395 ;
1618: AST_state state@var2424 (@expr1073749721 cpp@var2396 ) ;
1619: if (@expr1073749722 Token ::@expr7431 Match (@expr1073749724 tok@var2395 , "%name% (" ) ) {
1620: state@var2424 .@expr1073749725 functionCallEndPar@var2425 =@expr1073749726 tok@var2395 .@expr7727 linkAt (@expr7728 1 ) ; }
1621: compileExpression (@expr1073749729 tok@var2395 , state@var2424 ) ;
1622: const Token * const endToken@var2426 ; endToken@var2426 =@expr1073749730 tok@var2395 ;
1623: if (@expr1073749731 endToken@var2426 ==@expr1073749732 tok1@var2423 ||@expr1073749733 !@expr1073749734 endToken@var2426 ) {
1624: return tok1@var2423 ; }
1625:
1626: createAstAtTokenInner (@expr1073749735 tok1@var2423 .@expr1073749736 next (@expr1073749737 ) , endToken@var2426 , cpp@var2396 ) ;
1627:
1628: return endToken@var2426 .@expr1073749738 previous (@expr1073749739 ) ;
1629: }
1630:
1631: if (@expr1073749740 cpp@var2396 &&@expr1073749741 tok@var2395 .@expr7852 str (@expr7853 ) ==@expr1073749744 "{" &&@expr1073749745 iscpp11init (@expr1073749746 tok@var2395 ) ) {
1632: Token * const tok1@var2427 ; tok1@var2427 =@expr1073749747 tok@var2395 ;
1633: AST_state state@var2428 (@expr1073749748 cpp@var2396 ) ;
1634: compileExpression (@expr1073749749 tok@var2395 , state@var2428 ) ;
1635: const Token * const endToken@var2429 ; endToken@var2429 =@expr1073749750 tok@var2395 ;
1636: if (@expr1073749751 endToken@var2429 ==@expr1073749752 tok1@var2427 ||@expr1073749753 !@expr1073749754 endToken@var2429 ) {
1637: return tok1@var2427 ; }
1638:
1639: createAstAtTokenInner (@expr1073749755 tok1@var2427 .@expr1073749756 next (@expr1073749757 ) , endToken@var2429 , cpp@var2396 ) ;
1640: return endToken@var2429 .@expr1073749758 previous (@expr1073749759 ) ;
1641: }
1642:
1643: return tok@var2395 ;
1644: }
1645:
1646: void TokenList :: createAst ( ) const
1647: {
1648: for (@expr1073749760 Token *@expr1073749761 tok@var2430 =@expr1073749762 mTokensFrontBack@var746 .@expr1073749763 front@var2492 ; tok@var2430 ; tok@var2430 =@expr1073749764 tok@var2430 ?@expr1073749765 tok@var2430 .@expr1073749766 next (@expr1073749767 ) :@expr1073749768 nullptr ) {
1649: tok@var2430 =@expr1073749769 createAstAtToken (@expr1073749770 tok@var2430 , isCPP (@expr1073749771 ) ) ;
1650: }
1651: }
1652:
1653: struct OnException {
1654: std :: function < void ( ) > f@var2431 ;
1655:
1656: ~ OnException ( ) {
1657:
1658: if (@expr1073749772 std ::@expr1073749773 uncaught_exception (@expr1073749774 ) ) {
1659: f@var2431 (@expr1073749775 ) ; }
1660:
1661: }
1662: } ;
1663:
1664: void TokenList :: validateAst ( ) const
1665: {
1666: OnException oe@var2432 {@expr1073749776 [@expr1073749777 &@expr7954 ] {
1667: if (@expr1073749779 mSettings@var749 .@expr1073749780 debugnormal@var2499 ) {
1668: mTokensFrontBack@var746 .@expr7957 front@var2492 .@expr1073749782 printOut (@expr1073749783 ) ; }
1669: } } ;
1670:
1671: std ::@expr1073749784 set < const Token *@expr7961 > safeAstTokens@var2433 ;
1672: for (@expr1073749786 const Token *@expr7961 tok@var2434 =@expr1073749788 mTokensFrontBack@var746 .@expr7957 front@var2492 ; tok@var2434 ; tok@var2434 =@expr1073749790 tok@var2434 .@expr7967 next (@expr7968 ) ) {
1673:
1674: if (@expr1073749793 (@expr1073749794 tok@var2434 .@expr1073749795 isAssignmentOp (@expr1073749796 ) ||@expr1073749797 tok@var2434 .@expr1073749798 isComparisonOp (@expr1073749799 ) ||@expr1073749800 Token ::@expr7977 Match (@expr1073749802 tok@var2434 , "[|^/%]" ) ) &&@expr1073749803 tok@var2434 .@expr7980 astOperand1 (@expr7981 ) &&@expr1073749806 !@expr7983 tok@var2434 .@expr7984 astOperand2 (@expr7985 ) ) {
1675: throw InternalError (@expr1073749810 tok@var2434 , "Syntax Error: AST broken, binary operator has only one operand." , InternalError ::@expr7987 AST ) ; }
1676:
1677:
1678: if (@expr1073749812 tok@var2434 .@expr7989 str (@expr7990 ) ==@expr1073749815 "?" ) {
1679: if (@expr7992 !@expr7993 tok@var2434 .@expr7980 astOperand1 (@expr7981 ) ||@expr7996 !@expr7983 tok@var2434 .@expr7984 astOperand2 (@expr7985 ) ) {
1680: throw InternalError (@expr1073749824 tok@var2434 , "AST broken, ternary operator missing operand(s)" , InternalError ::@expr7987 AST ) ; }
1681: else { if (@expr1073749826 tok@var2434 .@expr7984 astOperand2 (@expr7985 ) .@expr1073749829 str (@expr1073749830 ) !=@expr1073749831 ":" ) {
1682: throw InternalError (@expr1073749832 tok@var2434 , "Syntax Error: AST broken, ternary operator lacks ':'." , InternalError ::@expr7987 AST ) ; } }
1683: }
1684:
1685:
1686: const Token * parent@var2435 ; parent@var2435 =@expr1073749834 tok@var2434 .@expr8011 astParent (@expr8012 ) ;
1687: if (@expr1073749837 parent@var2435 ) {
1688: std ::@expr1073749838 set < const Token *@expr7961 > astTokens@var2436 ;
1689: astTokens@var2436 .@expr8016 insert (@expr1073749841 tok@var2434 ) ;
1690: do {
1691: if (@expr1073749842 safeAstTokens@var2433 .@expr1073749843 find (@expr1073749844 parent@var2435 ) !=@expr1073749845 safeAstTokens@var2433 .@expr1073749846 end (@expr1073749847 ) ) {
1692: break ; }
1693: if (@expr1073749848 astTokens@var2436 .@expr1073749849 find (@expr1073749850 parent@var2435 ) !=@expr1073749851 astTokens@var2436 .@expr8028 end (@expr8029 ) ) {
1694: throw InternalError (@expr1073749854 tok@var2434 , "AST broken: endless recursion from '" +@expr1073749855 tok@var2434 .@expr7989 str (@expr7990 ) +@expr1073749858 "'" , InternalError ::@expr7987 AST ) ; }
1695: astTokens@var2436 .@expr8016 insert (@expr1073749861 parent@var2435 ) ;
1696: } while (@expr1073749862 (@expr1073749863 parent@var2435 =@expr1073749864 parent@var2435 .@expr1073749865 astParent (@expr1073749866 ) ) !=@expr1073749867 nullptr ) ;
1697: safeAstTokens@var2433 .@expr8044 insert (@expr1073749869 astTokens@var2436 .@expr1073749870 begin (@expr1073749871 ) , astTokens@var2436 .@expr8028 end (@expr8029 ) ) ;
1698: } else { if (@expr1073749874 tok@var2434 .@expr7989 str (@expr7990 ) ==@expr1073749877 ";" ) {
1699: safeAstTokens@var2433 .@expr1073749878 clear (@expr1073749879 ) ;
1700: } else {
1701: safeAstTokens@var2433 .@expr8044 insert (@expr1073749881 tok@var2434 ) ;
1702: } }
1703:
1704:
1705: if (@expr1073749882 tok@var2434 .@expr7989 str (@expr7990 ) ==@expr1073749885 "<" &&@expr1073749886 tok@var2434 .@expr8063 link (@expr8064 ) ) {
1706: tok@var2434 =@expr1073749889 tok@var2434 .@expr8063 link (@expr8064 ) ;
1707: continue ;
1708: }
1709:
1710:
1711: if (@expr1073749892 Token ::@expr7977 Match (@expr1073749894 tok@var2434 , "%or%|%oror%|%assign%|%comp%" ) ) {
1712:
1713: if (@expr1073749895 Token ::@expr7977 Match (@expr1073749897 tok@var2434 , "= ,|]" ) ) {
1714: continue ; }
1715:
1716: if (@expr1073749898 Token ::@expr8075 simpleMatch (@expr1073749900 tok@var2434 .@expr8077 previous (@expr8078 ) , ") = 0" ) ) {
1717: continue ; }
1718:
1719: if (@expr1073749903 Token ::@expr8075 simpleMatch (@expr1073749905 tok@var2434 .@expr8077 previous (@expr8078 ) , "operator" ) ) {
1720: continue ; }
1721:
1722: if (@expr1073749908 !@expr7993 tok@var2434 .@expr7980 astOperand1 (@expr7981 ) &&@expr1073749912 !@expr7983 tok@var2434 .@expr7984 astOperand2 (@expr7985 ) &&@expr1073749916 !@expr8093 tok@var2434 .@expr8011 astParent (@expr8012 ) ) {
1723: continue ; }
1724:
1725: if (@expr1073749920 Token ::@expr7977 Match (@expr1073749922 tok@var2434 , "= {|^|[" ) ) {
1726: continue ; }
1727:
1728: if (@expr1073749923 Token ::@expr7977 Match (@expr1073749925 tok@var2434 .@expr8077 previous (@expr8078 ) , "%name% = %name%" ) ) {
1729: continue ; }
1730: if (@expr7992 !@expr7993 tok@var2434 .@expr7980 astOperand1 (@expr7981 ) ||@expr7996 !@expr7983 tok@var2434 .@expr7984 astOperand2 (@expr7985 ) ) {
1731: throw InternalError (@expr1073749936 tok@var2434 , "Syntax Error: AST broken, binary operator '" +@expr1073749937 tok@var2434 .@expr7989 str (@expr7990 ) +@expr1073749940 "' doesn't have two operands." , InternalError ::@expr7987 AST ) ; }
1732: }
1733:
1734:
1735: if (@expr1073749942 Token ::@expr7977 Match (@expr1073749944 tok@var2434 .@expr8077 previous (@expr8078 ) , "if|while|for|switch|assert|ASSERT (" ) ) {
1736: if (@expr7992 !@expr7993 tok@var2434 .@expr7980 astOperand1 (@expr7981 ) ||@expr7996 !@expr7983 tok@var2434 .@expr7984 astOperand2 (@expr7985 ) ) {
1737: throw InternalError (@expr1073749955 tok@var2434 ,
1738: "Syntax Error: AST broken, '" +@expr1073749956 tok@var2434 .@expr8077 previous (@expr8078 ) .@expr1073749959 str (@expr1073749960 ) +@expr1073749961
1739: "' doesn't have two operands." ,
1740: InternalError ::@expr7987 AST ) ; }
1741: }
1742:
1743:
1744: if (@expr1073749963 Token ::@expr7977 Match (@expr1073749965 tok@var2434 , "%var% ." ) ) {
1745: if (@expr1073749966 !@expr8093 tok@var2434 .@expr8011 astParent (@expr8012 ) ) {
1746: throw InternalError (@expr1073749970
1747: tok@var2434 , "Syntax Error: AST broken, '" +@expr1073749971 tok@var2434 .@expr7989 str (@expr7990 ) +@expr1073749974 "' doesn't have a parent." , InternalError ::@expr7987 AST ) ;
1748: }
1749: if (@expr1073749976 !@expr1073749977 tok@var2434 .@expr7967 next (@expr7968 ) .@expr1073749980 astOperand1 (@expr1073749981 ) ||@expr1073749982 !@expr1073749983 tok@var2434 .@expr7967 next (@expr7968 ) .@expr1073749986 astOperand2 (@expr1073749987 ) ) {
1750: const std ::@expr1073749988 string &@expr7954 op@var2437 =@expr1073749990
1751: tok@var2434 .@expr7967 next (@expr7968 ) .@expr8169 originalName (@expr8170 ) .@expr1073749995 empty (@expr1073749996 ) ?@expr1073749997 tok@var2434 .@expr7967 next (@expr7968 ) .@expr1073750000 str (@expr1073750001 ) :@expr1073750002 tok@var2434 .@expr7967 next (@expr7968 ) .@expr8169 originalName (@expr8170 ) ;
1752: throw InternalError (@expr1073750007
1753: tok@var2434 , "Syntax Error: AST broken, '" +@expr1073750008 op@var2437 +@expr1073750009 "' doesn't have two operands." , InternalError ::@expr7987 AST ) ;
1754: }
1755: }
1756: }
1757: }
1758:
1759: std :: string TokenList :: getOrigFile ( const Token * tok@var2438 ) const
1760: {
1761: return mOrigFiles@var748 .@expr1073750011 at (@expr1073750012 tok@var2438 .@expr1073750013 fileIndex (@expr1073750014 ) ) ;
1762: }
1763:
1764: const std :: string & TokenList :: file ( const Token * tok@var2439 ) const
1765: {
1766: return mFiles@var747 .@expr1073750015 at (@expr1073750016 tok@var2439 .@expr1073750017 fileIndex (@expr1073750018 ) ) ;
1767: }
1768:
1769: std :: string TokenList :: fileLine ( const Token * tok@var2440 ) const
1770: {
1771: return ErrorMessage ::@expr1073750019 FileLocation (@expr1073750020 tok@var2440 , this@expr1073750021 ) .@expr1073750022 stringify (@expr1073750023 ) ;
1772: }
1773:
1774: bool TokenList :: validateToken ( const Token * tok@var2441 ) const
1775: {
1776: if (@expr1073750024 !@expr1073750025 tok@var2441 ) {
1777: return true ; }
1778: for (@expr1073750026 const Token *@expr1073750027 t@var2442 =@expr1073750028 mTokensFrontBack@var746 .@expr1073750029 front@var2492 ; t@var2442 ; t@var2442 =@expr1073750030 t@var2442 .@expr1073750031 next (@expr1073750032 ) ) {
1779: if (@expr1073750033 tok@var2441 ==@expr1073750034 t@var2442 ) {
1780: return true ; }
1781: }
1782: return false ;
1783: }
1784:
1785: void TokenList :: simplifyPlatformTypes ( )
1786: {
1787: const bool isCPP11@var2443 =@expr1073750035 mSettings@var749 .@expr1073750036 standards@var2495 .@expr1073750037 cpp@var2496 >=@expr1073750038 Standards ::@expr1073750039 CPP11 ;
1788:
1789: enum Anonymous6 { isLongLong , isLong , isInt } ; enum Anonymous6 type@var2444 ;
1790:
1791:
1792:
1793: if (@expr1073750040 mSettings@var749 .@expr8217 sizeof_size_t@var2500 ==@expr1073750042 mSettings@var749 .@expr1073750043 sizeof_long@var2501 ) {
1794: type@var2444 =@expr1073750044 isLong ; }
1795: else { if (@expr1073750045 mSettings@var749 .@expr8217 sizeof_size_t@var2500 ==@expr1073750047 mSettings@var749 .@expr1073750048 sizeof_long_long@var2502 ) {
1796: type@var2444 =@expr1073750049 isLongLong ; }
1797: else { if (@expr1073750050 mSettings@var749 .@expr8217 sizeof_size_t@var2500 ==@expr1073750052 mSettings@var749 .@expr1073750053 sizeof_int@var2503 ) {
1798: type@var2444 =@expr1073750054 isInt ; }
1799: else {
1800: return ; } } }
1801:
1802: for (@expr1073750055 Token *@expr8232 tok@var2445 =@expr1073750057 front (@expr8234 ) ; tok@var2445 ; tok@var2445 =@expr1073750059 tok@var2445 .@expr8236 next (@expr8237 ) ) {
1803:
1804: if (@expr1073750062 !@expr1073750063 Token ::@expr8240 Match (@expr1073750065 tok@var2445 , "std| ::| %type%" ) ) {
1805: continue ; }
1806: bool isUnsigned@var2446 ;
1807: if (@expr1073750066 Token ::@expr8240 Match (@expr1073750068 tok@var2445 , "std| ::| size_t|uintptr_t|uintmax_t" ) ) {
1808: if (@expr8245 isCPP11@var2443 &&@expr8246 tok@var2445 .@expr8247 strAt (@expr8248 -1 ) ==@expr8249 "using" &&@expr8250 tok@var2445 .@expr8247 strAt (@expr8252 1 ) ==@expr8253 "=" ) {
1809: continue ; }
1810: isUnsigned@var2446 =@expr1073750078 true ;
1811: } else { if (@expr1073750079 Token ::@expr8240 Match (@expr1073750081 tok@var2445 , "std| ::| ssize_t|ptrdiff_t|intptr_t|intmax_t" ) ) {
1812: if (@expr8245 isCPP11@var2443 &&@expr8246 tok@var2445 .@expr8247 strAt (@expr8248 -1 ) ==@expr8249 "using" &&@expr8250 tok@var2445 .@expr8247 strAt (@expr8252 1 ) ==@expr8253 "=" ) {
1813: continue ; }
1814: isUnsigned@var2446 =@expr1073750091 false ;
1815: } else {
1816: continue ; } }
1817:
1818: bool inStd@var2447 ; inStd@var2447 =@expr1073750092 false ;
1819: if (@expr1073750093 tok@var2445 .@expr8270 str (@expr8271 ) ==@expr1073750096 "::" ) {
1820: tok@var2445 .@expr8273 deleteThis (@expr8274 ) ;
1821: } else { if (@expr1073750099 tok@var2445 .@expr8270 str (@expr8271 ) ==@expr1073750102 "std" ) {
1822: if (@expr1073750103 tok@var2445 .@expr8236 next (@expr8237 ) .@expr1073750106 str (@expr1073750107 ) !=@expr1073750108 "::" ) {
1823: continue ; }
1824: inStd@var2447 =@expr1073750109 true ;
1825: tok@var2445 .@expr1073750110 deleteNext (@expr1073750111 ) ;
1826: tok@var2445 .@expr8273 deleteThis (@expr8274 ) ;
1827: } }
1828:
1829: if (@expr1073750114 inStd@var2447 ) {
1830: tok@var2445 .@expr8291 originalName (@expr1073750116 "std::" +@expr1073750117 tok@var2445 .@expr8270 str (@expr8271 ) ) ; }
1831: else {
1832: tok@var2445 .@expr8291 originalName (@expr1073750121 tok@var2445 .@expr8270 str (@expr8271 ) ) ; }
1833: if (@expr1073750124 isUnsigned@var2446 ) {
1834: tok@var2445 .@expr1073750125 isUnsigned (@expr1073750126 true ) ; }
1835:
1836: switch (@expr1073750127 type@var2444 ) {
1837: case isLongLong :@expr8304 ;
1838: tok@var2445 .@expr1073750129 isLong (@expr1073750130 true ) ;
1839: tok@var2445 .@expr8270 str (@expr8308 "long" ) ;
1840: break ;
1841: case isLong :@expr8304 ;
1842: tok@var2445 .@expr8270 str (@expr8308 "long" ) ;
1843: break ;
1844: case isInt :@expr8304 ;
1845: tok@var2445 .@expr8270 str (@expr1073750138 "int" ) ;
1846: break ;
1847: }
1848: }
1849:
1850: const std ::@expr1073750139 string platform_type@var2448 (@expr1073750140 mSettings@var749 .@expr1073750141 platformString (@expr1073750142 ) ) ;
1851:
1852: for (@expr1073750143 Token *@expr8232 tok@var2449 =@expr1073750145 front (@expr8234 ) ; tok@var2449 ; tok@var2449 =@expr1073750147 tok@var2449 .@expr1073750148 next (@expr1073750149 ) ) {
1853: if (@expr1073750150 tok@var2449 .@expr8327 tokType (@expr8328 ) !=@expr1073750153 Token ::@expr1073750154 eType &&@expr1073750155 tok@var2449 .@expr8327 tokType (@expr8328 ) !=@expr1073750158 Token ::@expr8335 eName ) {
1854: continue ; }
1855:
1856: const Library ::@expr1073750160 PlatformType * const platformtype@var2450 ; platformtype@var2450 =@expr1073750161 mSettings@var749 .@expr1073750162 library@var2504 .@expr1073750163 platform_type (@expr1073750164 tok@var2449 .@expr8341 str (@expr8342 ) , platform_type@var2448 ) ;
1857:
1858: if (@expr1073750167 platformtype@var2450 ) {
1859:
1860: if (@expr1073750168 tok@var2449 .@expr1073750169 strAt (@expr1073750170 -1 ) ==@expr1073750171 "::" ) {
1861: const Token * tok1@var2451 ; tok1@var2451 =@expr1073750172 tok@var2449 .@expr1073750173 tokAt (@expr1073750174 -2 ) ;
1862:
1863: if (@expr1073750175 tok1@var2451 &&@expr1073750176 tok1@var2451 .@expr1073750177 tokType (@expr1073750178 ) ==@expr1073750179 Token ::@expr8335 eName ) {
1864: continue ; }
1865: tok@var2449 =@expr1073750181 tok@var2449 .@expr1073750182 previous (@expr1073750183 ) ;
1866: tok@var2449 .@expr1073750184 deleteThis (@expr1073750185 ) ;
1867: }
1868: Token * typeToken@var2452 ;
1869: if (@expr1073750186 platformtype@var2450 .@expr1073750187 mConstPtr@var2453 ) {
1870: tok@var2449 .@expr8341 str (@expr1073750189 "const" ) ;
1871: tok@var2449 .@expr8366 insertToken (@expr8367 "*" ) ;
1872: tok@var2449 .@expr8366 insertToken (@expr1073750193 platformtype@var2450 .@expr8370 mType@var2454 ) ;
1873: typeToken@var2452 =@expr1073750195 tok@var2449 ;
1874: } else { if (@expr1073750196 platformtype@var2450 .@expr1073750197 mPointer@var2455 ) {
1875: tok@var2449 .@expr8341 str (@expr8375 platformtype@var2450 .@expr8370 mType@var2454 ) ;
1876: typeToken@var2452 =@expr1073750201 tok@var2449 ;
1877: tok@var2449 .@expr8366 insertToken (@expr8367 "*" ) ;
1878: } else { if (@expr1073750204 platformtype@var2450 .@expr1073750205 mPtrPtr@var2456 ) {
1879: tok@var2449 .@expr8341 str (@expr8375 platformtype@var2450 .@expr8370 mType@var2454 ) ;
1880: typeToken@var2452 =@expr1073750209 tok@var2449 ;
1881: tok@var2449 .@expr8366 insertToken (@expr8367 "*" ) ;
1882: tok@var2449 .@expr8366 insertToken (@expr8367 "*" ) ;
1883: } else {
1884: tok@var2449 .@expr1073750214 originalName (@expr1073750215 tok@var2449 .@expr8341 str (@expr8342 ) ) ;
1885: tok@var2449 .@expr8341 str (@expr8375 platformtype@var2450 .@expr8370 mType@var2454 ) ;
1886: typeToken@var2452 =@expr1073750221 tok@var2449 ;
1887: } } }
1888: if (@expr1073750222 platformtype@var2450 .@expr1073750223 mSigned@var2457 ) {
1889: typeToken@var2452 .@expr1073750224 isSigned (@expr1073750225 true ) ; }
1890: if (@expr1073750226 platformtype@var2450 .@expr1073750227 mUnsigned@var2458 ) {
1891: typeToken@var2452 .@expr1073750228 isUnsigned (@expr1073750229 true ) ; }
1892: if (@expr1073750230 platformtype@var2450 .@expr1073750231 mLong@var2459 ) {
1893: typeToken@var2452 .@expr1073750232 isLong (@expr1073750233 true ) ; }
1894: }
1895: }
1896: }
1897:
1898: void TokenList :: simplifyStdType ( )
1899: {
1900: for (@expr1073750234 Token *@expr1073750235 tok@var2460 =@expr1073750236 front (@expr1073750237 ) ; tok@var2460 ; tok@var2460 =@expr1073750238 tok@var2460 .@expr8415 next (@expr8416 ) ) {
1901:
1902: if (@expr1073750241 Token ::@expr8418 Match (@expr1073750243 tok@var2460 , "const|extern *|&|%name%" ) &&@expr1073750244 (@expr1073750245 !@expr1073750246 tok@var2460 .@expr8423 previous (@expr8424 ) ||@expr1073750249 Token ::@expr8418 Match (@expr1073750251 tok@var2460 .@expr8423 previous (@expr8424 ) , "[;{}]" ) ) ) {
1903: if (@expr1073750254 Token ::@expr8418 Match (@expr1073750256 tok@var2460 .@expr8415 next (@expr8416 ) , "%name% !!;" ) ) {
1904: continue ; }
1905:
1906: tok@var2460 .@expr1073750259 insertToken (@expr1073750260 "int" ) ;
1907: tok@var2460 .@expr8415 next (@expr8416 ) .@expr1073750263 isImplicitInt (@expr1073750264 true ) ;
1908: continue ;
1909: }
1910:
1911: if (@expr1073750265 Token ::@expr8418 Match (@expr1073750267 tok@var2460 , "char|short|int|long|unsigned|signed|double|float" ) ||@expr1073750268 (@expr1073750269 mSettings@var749 .@expr8446 standards@var2495 .@expr8447 c@var2505 >=@expr8448 Standards ::@expr8449 C99 &&@expr1073750274 Token ::@expr8418 Match (@expr1073750276 tok@var2460 , "complex|_Complex" ) ) ) {
1912: bool isFloat@var2461 ; isFloat@var2461 =@expr1073750277 false ;
1913: bool isSigned@var2462 ; isSigned@var2462 =@expr1073750278 false ;
1914: bool isUnsigned@var2463 ; isUnsigned@var2463 =@expr1073750279 false ;
1915: bool isComplex@var2464 ; isComplex@var2464 =@expr1073750280 false ;
1916: int countLong@var2465 ; countLong@var2465 =@expr1073750281 0 ;
1917: Token * typeSpec@var2466 ; typeSpec@var2466 =@expr1073750282 nullptr ;
1918:
1919: Token * tok2@var2467 ; tok2@var2467 =@expr1073750283 tok@var2460 ;
1920: for (@expr1073750284 ; tok2@var2467 .@expr8461 next (@expr8462 ) ; tok2@var2467 =@expr1073750287 tok2@var2467 .@expr8461 next (@expr8462 ) ) {
1921: if (@expr1073750290 tok2@var2467 .@expr8467 str (@expr8468 ) ==@expr1073750293 "long" ) {
1922: countLong@var2465 ++@expr1073750294 ;
1923: if (@expr1073750295 !@expr8472 isFloat@var2461 ) {
1924: typeSpec@var2466 =@expr1073750297 tok2@var2467 ; }
1925: } else { if (@expr1073750298 tok2@var2467 .@expr8467 str (@expr8468 ) ==@expr1073750301 "short" ) {
1926: typeSpec@var2466 =@expr1073750302 tok2@var2467 ;
1927: } else { if (@expr1073750303 tok2@var2467 .@expr8467 str (@expr8468 ) ==@expr1073750306 "unsigned" ) {
1928: isUnsigned@var2463 =@expr1073750307 true ; }
1929: else { if (@expr1073750308 tok2@var2467 .@expr8467 str (@expr8468 ) ==@expr1073750311 "signed" ) {
1930: isSigned@var2462 =@expr1073750312 true ; }
1931: else { if (@expr1073750313 Token ::@expr8418 Match (@expr1073750315 tok2@var2467 , "float|double" ) ) {
1932: isFloat@var2461 =@expr1073750316 true ;
1933: typeSpec@var2466 =@expr1073750317 tok2@var2467 ;
1934: } else { if (@expr1073750318 mSettings@var749 .@expr8446 standards@var2495 .@expr8447 c@var2505 >=@expr8448 Standards ::@expr8449 C99 &&@expr1073750323 Token ::@expr8418 Match (@expr8501 tok2@var2467 , "complex|_Complex" ) ) {
1935: isComplex@var2464 =@expr1073750326 !@expr8472 isFloat@var2461 ||@expr1073750328 tok2@var2467 .@expr8467 str (@expr8468 ) ==@expr1073750331 "_Complex" ||@expr1073750332 Token ::@expr8418 Match (@expr1073750334 tok2@var2467 .@expr8461 next (@expr8462 ) , "*|&|%name%" ) ; }
1936: else { if (@expr1073750337 Token ::@expr8418 Match (@expr1073750339 tok2@var2467 , "char|int" ) ) {
1937: if (@expr8516 !@expr8517 typeSpec@var2466 ) {
1938: typeSpec@var2466 =@expr1073750342 tok2@var2467 ; }
1939: } else {
1940: break ; } } } } } } }
1941: }
1942:
1943: if (@expr8516 !@expr8517 typeSpec@var2466 ) {
1944: if (@expr1073750345 !@expr1073750346 isComplex@var2464 ) {
1945: tok@var2460 .@expr1073750347 str (@expr1073750348 "int" ) ;
1946: tok@var2460 .@expr1073750349 isSigned (@expr1073750350 isSigned@var2462 ) ;
1947: tok@var2460 .@expr1073750351 isUnsigned (@expr1073750352 isUnsigned@var2463 ) ;
1948: tok@var2460 .@expr1073750353 isImplicitInt (@expr1073750354 true ) ;
1949: }
1950: } else {
1951: typeSpec@var2466 .@expr8531 isLong (@expr1073750356 typeSpec@var2466 .@expr8531 isLong (@expr1073750358 ) ||@expr1073750359 (@expr1073750360 isFloat@var2461 &&@expr1073750361 countLong@var2465 ==@expr1073750362 1 ) ||@expr1073750363 countLong@var2465 >@expr1073750364 1 ) ;
1952: typeSpec@var2466 .@expr8541 isComplex (@expr1073750366 typeSpec@var2466 .@expr8541 isComplex (@expr1073750368 ) ||@expr1073750369 (@expr1073750370 isFloat@var2461 &&@expr1073750371 isComplex@var2464 ) ) ;
1953: typeSpec@var2466 .@expr8548 isSigned (@expr1073750373 typeSpec@var2466 .@expr8548 isSigned (@expr1073750375 ) ||@expr1073750376 isSigned@var2462 ) ;
1954: typeSpec@var2466 .@expr8553 isUnsigned (@expr1073750378 typeSpec@var2466 .@expr8553 isUnsigned (@expr1073750380 ) ||@expr1073750381 isUnsigned@var2463 ) ;
1955:
1956:
1957: const Token * tok3@var2468 ; tok3@var2468 =@expr1073750382 tok@var2460 .@expr8423 previous (@expr8424 ) ;
1958: tok2@var2467 =@expr1073750385 tok2@var2467 .@expr8562 previous (@expr8563 ) ;
1959: while (@expr1073750388 tok3@var2468 !=@expr1073750389 tok2@var2467 ) {
1960: if (@expr1073750390 tok2@var2467 !=@expr1073750391 typeSpec@var2466 &&@expr1073750392
1961: (@expr1073750393 isComplex@var2464 ||@expr1073750394 !@expr1073750395 Token ::@expr8418 Match (@expr8501 tok2@var2467 , "complex|_Complex" ) ) ) {
1962: tok2@var2467 .@expr1073750398 deleteThis (@expr1073750399 ) ; }
1963: tok2@var2467 =@expr1073750400 tok2@var2467 .@expr8562 previous (@expr8563 ) ;
1964: }
1965: }
1966: }
1967: }
1968: }
1969:
1970: bool TokenList :: isKeyword ( const std :: string & str@var2469 ) const
1971: {
1972: return mKeywords@var750 .@expr1073750403 find (@expr1073750404 str@var2469 ) !=@expr1073750405 mKeywords@var750 .@expr1073750406 end (@expr1073750407 ) ;
1973: }

##file cppcheck-2.8/lib/settings.h

1:
|
48:
49: class SimpleEnableGroup<Severity::SeverityType> {
50: uint32_t mFlags@var2470 ; mFlags@var2470 = 0 ;
51: public:
52: uint32_t intValue ( ) const {
53: return mFlags@var2470 ;
54: }
55: void clear ( ) {
56: mFlags@var2470 =@expr1073750408 0 ;
57: }
58: void fill ( ) {
59: mFlags@var2470 =@expr1073750409 0xFFFFFFFF ;
60: }
61: void setEnabledAll ( bool enabled@var2471 ) {
62: if (@expr1073750410 enabled@var2471 ) {
63: fill (@expr1073750411 ) ; }
64: else {
65: clear (@expr1073750412 ) ; }
66: }
67: bool isEnabled ( Severity :: SeverityType flag@var2472 ) const {
68: return (@expr8589 mFlags@var2470 &@expr1073750414 (@expr8589 1U <<@expr1073750416 (@expr1073750417 uint32_t ) flag@var2472 ) ) !=@expr1073750418 0 ;
69: }
70: void enable ( Severity :: SeverityType flag@var2473 ) {
71: mFlags@var2470 |=@expr1073750419 (@expr1073750420 1U <<@expr1073750421 (@expr1073750422 uint32_t ) flag@var2473 ) ;
72: }
73: void disable ( Severity :: SeverityType flag@var2474 ) {
74: mFlags@var2470 &=@expr1073750423 ~@expr1073750424 (@expr1073750425 1U <<@expr1073750426 (@expr1073750427 uint32_t ) flag@var2474 ) ;
75: }
76: void setEnabled ( Severity :: SeverityType flag@var2475 , bool enabled@var2476 ) {
77: if (@expr1073750428 enabled@var2476 ) {
78: enable (@expr1073750429 flag@var2475 ) ; }
79: else {
80: disable (@expr1073750430 flag@var2475 ) ; }
81: }
82: } ;
49: class SimpleEnableGroup<Certainty::CertaintyLevel> {
50: uint32_t mFlags@var2477 ; mFlags@var2477 = 0 ;
51: public:
52: uint32_t intValue ( ) const {
53: return mFlags@var2477 ;
54: }
55: void clear ( ) {
56: mFlags@var2477 =@expr1073750431 0 ;
57: }
58: void fill ( ) {
59: mFlags@var2477 =@expr1073750432 0xFFFFFFFF ;
60: }
61: void setEnabledAll ( bool enabled@var2478 ) {
62: if (@expr1073750433 enabled@var2478 ) {
63: fill (@expr1073750434 ) ; }
64: else {
65: clear (@expr1073750435 ) ; }
66: }
67: bool isEnabled ( Certainty :: CertaintyLevel flag@var2479 ) const {
68: return (@expr8612 mFlags@var2477 &@expr1073750437 (@expr8612 1U <<@expr1073750439 (@expr1073750440 uint32_t ) flag@var2479 ) ) !=@expr1073750441 0 ;
69: }
70: void enable ( Certainty :: CertaintyLevel flag@var2480 ) {
71: mFlags@var2477 |=@expr1073750442 (@expr1073750443 1U <<@expr1073750444 (@expr1073750445 uint32_t ) flag@var2480 ) ;
72: }
73: void disable ( Certainty :: CertaintyLevel flag@var2481 ) {
74: mFlags@var2477 &=@expr1073750446 ~@expr1073750447 (@expr1073750448 1U <<@expr1073750449 (@expr1073750450 uint32_t ) flag@var2481 ) ;
75: }
76: void setEnabled ( Certainty :: CertaintyLevel flag@var2482 , bool enabled@var2483 ) {
77: if (@expr1073750451 enabled@var2483 ) {
78: enable (@expr1073750452 flag@var2482 ) ; }
79: else {
80: disable (@expr1073750453 flag@var2482 ) ; }
81: }
82: } ;
49: class SimpleEnableGroup<Checks::CheckList> {
50: uint32_t mFlags@var2484 ; mFlags@var2484 = 0 ;
51: public:
52: uint32_t intValue ( ) const {
53: return mFlags@var2484 ;
54: }
55: void clear ( ) {
56: mFlags@var2484 =@expr1073750454 0 ;
57: }
58: void fill ( ) {
59: mFlags@var2484 =@expr1073750455 0xFFFFFFFF ;
60: }
61: void setEnabledAll ( bool enabled@var2485 ) {
62: if (@expr1073750456 enabled@var2485 ) {
63: fill (@expr1073750457 ) ; }
64: else {
65: clear (@expr1073750458 ) ; }
66: }
67: bool isEnabled ( Checks :: CheckList flag@var2486 ) const {
68: return (@expr8635 mFlags@var2484 &@expr1073750460 (@expr8635 1U <<@expr1073750462 (@expr1073750463 uint32_t ) flag@var2486 ) ) !=@expr1073750464 0 ;
69: }
70: void enable ( Checks :: CheckList flag@var2487 ) {
71: mFlags@var2484 |=@expr1073750465 (@expr1073750466 1U <<@expr1073750467 (@expr1073750468 uint32_t ) flag@var2487 ) ;
72: }
73: void disable ( Checks :: CheckList flag@var2488 ) {
74: mFlags@var2484 &=@expr1073750469 ~@expr1073750470 (@expr1073750471 1U <<@expr1073750472 (@expr1073750473 uint32_t ) flag@var2488 ) ;
75: }
76: void setEnabled ( Checks :: CheckList flag@var2489 , bool enabled@var2490 ) {
77: if (@expr1073750474 enabled@var2490 ) {
78: enable (@expr1073750475 flag@var2489 ) ; }
79: else {
80: disable (@expr1073750476 flag@var2489 ) ; }
81: }
82: } ;



##Value flow
Line 43
  INT always 0
  LONG always 1
  LONGLONG always 2
  FLOAT always 3
Line 44
  mIsUnsigned always {!<=-1,!>=2}
Line 51
  ( always {!<=-1,!>=2}
Line 52
  return always {!<=-1,!>=2}
  != always {!<=-1,!>=2}
  :: always 3
  FLOAT always 3
Line 54
  ( always {!<=-1,!>=2}
Line 55
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 3
  FLOAT always 3
Line 59
  ( always {!<=-1,!>=2}
Line 74
  ( always !<=-1
Line 83
  ( always {!<=-1,!>=2}
Line 84
  ( always {!<=-1,!>=2}
Line 85
  ( always {!<=-1,!>=2}
Line 86
  ( always {!<=-1,!>=2}
Line 87
  ( always {!<=-1,!>=2}
Line 88
  ( always {!<=-1,!>=2}
Line 89
  ( always {!<=-1,!>=2}
Line 90
  ( always {!<=-1,!>=2}
Line 91
  ( always {!<=-1,!>=2}
Line 92
  ( always {!<=-1,!>=2}
Line 102
  ( always {!<=-1,!>=2}
  , always 1
  supportMicrosoftExtensions always {!<=-1,!>=2}
  = always 1
  true always 1
Line 115
  ( always !<=-1
Line 116
  ( always {!<=-1,!>=2}
Line 117
  ( always {!<=-1,!>=2}
Line 118
  ( always {!<=-1,!>=2}
Line 119
  ( always {!<=-1,!>=2}
Line 120
  ( always {!<=-1,!>=2}
Line 121
  ( always {!<=-1,!>=2}
Line 122
  ( always {!<=-1,!>=2}
Line 128
  ( always {!<=-1,!>=2}
Line 130
  ( always !<=-1
Line 137
  ( always {!<=-1,!>=2}
  , always !<=-1
  :: always !<=-1
  iPos always !<=-1
Line 66
  ( always {!<=-1,!>=2}
Line 67
  return always {!<=-1,!>=2}
  < always {!<=-1,!>=2}
Line 73
  ( always {!<=-1,!>=2}
Line 74
  return always {!<=-1,!>=2}
  ( always !<=-1
  == always {!<=-1,!>=2}
  1 always 1
Line 80
  result always {!<=-1,!>=2}
Line 81
  result always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  > always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  x {!>=symbolic=(y+1),<=symbolic=(y)}
  < always {!<=-1,!>=2}
  y {!<=symbolic=(x-1),>=symbolic=(x)}
Line 88
  Upper always 0
  Lower always 1
  Point always 2
Line 90
  = always 0
  0 always 0
Line 91
  :: always 12
  INT always 12
Line 94
  nullptr always 0
Line 95
  0.0 always 0
Line 98
  nullptr always 0
Line 99
  0U always 0
Line 100
  safe always {!<=-1,!>=2}
  false always 0
Line 101
  conditional always {!<=-1,!>=2}
  false always 0
Line 102
  macro always {!<=-1,!>=2}
  false always 0
Line 103
  defaultArg always {!<=-1,!>=2}
  false always 0
Line 104
  0 always 0
Line 105
  0 always 0
Line 108
  nullptr always 0
Line 117
  ( always {!<=-1,!>=2}
Line 118
  != always {!<=-1,!>=2}
Line 119
  return always {!<=-1,!>=2}
  false always 0
Line 120
  valueType always symbolic=(rhs.valueType)
Line 121
  :: always 0
  INT always 0
Line 122
  :: always 5
  CONTAINER_SIZE always 5
Line 123
  :: always 7
  BUFFER_SIZE always 7
Line 124
  :: always 8
  ITERATOR_START always 8
Line 125
  :: always 9
  ITERATOR_END always 9
Line 126
  != always {!<=-1,!>=2}
Line 127
  return always {!<=-1,!>=2}
  false always 0
Line 129
  :: always 1
  TOK always 1
Line 130
  != always {!<=-1,!>=2}
Line 131
  return always {!<=-1,!>=2}
  false always 0
Line 133
  :: always 2
  FLOAT always 2
Line 135
  > always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  floatValue possible <=symbolic=(rhs.floatValue)
  < always {!<=-1,!>=2}
  . possible >=symbolic=(floatValue)
Line 136
  return always {!<=-1,!>=2}
  false always 0
Line 138
  :: always 3
  MOVED always 3
Line 139
  != always {!<=-1,!>=2}
Line 140
  return always {!<=-1,!>=2}
  false always 0
Line 142
  :: always 4
  UNINIT always 4
Line 144
  :: always 6
  LIFETIME always 6
Line 145
  != always {!<=-1,!>=2}
Line 146
  return always {!<=-1,!>=2}
  false always 0
Line 148
  :: always 10
  SYMBOLIC always 10
Line 149
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 150
  return always {!<=-1,!>=2}
  false always 0
Line 151
  != always {!<=-1,!>=2}
Line 152
  return always {!<=-1,!>=2}
  false always 0
Line 155
  return always {!<=-1,!>=2}
  true always 1
Line 161
  :: always 0
  INT always 0
Line 162
  :: always 10
  SYMBOLIC always 10
Line 163
  :: always 7
  BUFFER_SIZE always 7
Line 164
  :: always 5
  CONTAINER_SIZE always 5
Line 165
  :: always 8
  ITERATOR_START always 8
Line 166
  :: always 9
  ITERATOR_END always 9
Line 170
  :: always 2
  FLOAT always 2
Line 174
  :: always 4
  UNINIT always 4
Line 175
  :: always 1
  TOK always 1
Line 176
  :: always 6
  LIFETIME always 6
Line 177
  :: always 3
  MOVED always 3
Line 185
  result always {!<=-1,!>=2}
Line 186
  result always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
Line 190
  result always {!<=-1,!>=2}
Line 192
  ( possible {lifetime[Object]=(x),lifetime[Object]=(result),lifetime[Object]=(compare)}
  ( possible lifetime[Object]=(result)
  result always {!<=-1,!>=2}
  ( possible lifetime[Object]=(compare)
Line 197
  ( always {!<=-1,!>=2}
Line 198
  ! always {!<=-1,!>=2}
  this always !0
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
Line 199
  this always !0
  == always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  this always !0
Line 200
  result always {!<=-1,!>=2}
  result always {!<=-1,!>=2}
  = always 0
  false always 0
Line 202
  this always !0
Line 203
  ( possible {lifetime[Object]=(result),lifetime[Object]=(rhs),lifetime[Object]=(compare)}
  ( possible lifetime[Object]=(result)
  result always 0
  ( possible lifetime[Object]=(rhs)
  ( possible lifetime[Object]=(compare)
Line 204
  return always {!<=-1,!>=2}
  result {!<=-1,!>=2,0}
Line 207
  ( always {!<=-1,!>=2}
Line 208
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 209
  return always {!<=-1,!>=2}
  false always 0
Line 211
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 212
  == always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 213
  == always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 214
  conditional always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  . always {!<=-1,!>=2}
  conditional always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 215
  defaultArg always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  . always {!<=-1,!>=2}
  defaultArg always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 216
  == always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 217
  == always {!<=-1,!>=2}
Line 220
  ( always {!<=-1,!>=2}
Line 221
  return always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  this always !0
  == always {!<=-1,!>=2}
Line 225
  ( always {!<=-1,!>=2}
Line 226
  result always {!<=-1,!>=2}
  result always {!<=-1,!>=2}
  = always 0
  false always 0
Line 227
  this always !0
  ( possible {lifetime[Object]=(x),lifetime[Object]=(result)}
  ( possible lifetime[Object]=(result)
  result always 0
Line 228
  return always {!<=-1,!>=2}
  result {!<=-1,!>=2,0}
Line 232
  bound possible 0
  == {!<=-1,!>=2,0}
  :: always 1
  Lower always 1
Line 233
  this always !0
Line 234
  bound always !1
  == always {!<=-1,!>=2}
  :: always 0
  Upper always 0
Line 235
  this always !0
Line 239
  bound possible 0
  == {!<=-1,!>=2,0}
  :: always 1
  Lower always 1
Line 240
  = always 0
  :: always 0
  Upper always 0
Line 241
  bound always !1
  == always {!<=-1,!>=2}
  :: always 0
  Upper always 0
Line 242
  = always 1
  :: always 1
  Lower always 1
Line 255
  INT always 0
Line 256
  TOK always 1
Line 257
  FLOAT always 2
Line 258
  MOVED always 3
Line 259
  UNINIT always 4
Line 260
  CONTAINER_SIZE always 5
Line 261
  LIFETIME always 6
Line 262
  BUFFER_SIZE always 7
Line 263
  ITERATOR_START always 8
Line 264
  ITERATOR_END always 9
Line 265
  SYMBOLIC always 10
Line 267
  ( always {!<=-1,!>=2}
Line 268
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 0
  INT always 0
Line 270
  ( always {!<=-1,!>=2}
Line 271
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 1
  TOK always 1
Line 273
  ( always {!<=-1,!>=2}
Line 274
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 2
  FLOAT always 2
Line 276
  ( always {!<=-1,!>=2}
Line 277
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 3
  MOVED always 3
Line 279
  ( always {!<=-1,!>=2}
Line 280
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 4
  UNINIT always 4
Line 282
  ( always {!<=-1,!>=2}
Line 283
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 5
  CONTAINER_SIZE always 5
Line 285
  ( always {!<=-1,!>=2}
Line 286
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 6
  LIFETIME always 6
Line 288
  ( always {!<=-1,!>=2}
Line 289
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 7
  BUFFER_SIZE always 7
Line 291
  ( always {!<=-1,!>=2}
Line 292
  return always {!<=-1,!>=2}
  valueType possible 9
  == {!<=-1,!>=2,0}
  :: always 8
  ITERATOR_START always 8
  || always {!<=-1,!>=2}
  valueType always !8
  == always {!<=-1,!>=2}
  :: always 9
  ITERATOR_END always 9
Line 294
  ( always {!<=-1,!>=2}
Line 295
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 8
  ITERATOR_START always 8
Line 297
  ( always {!<=-1,!>=2}
Line 298
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 9
  ITERATOR_END always 9
Line 300
  ( always {!<=-1,!>=2}
Line 301
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 10
  SYMBOLIC always 10
Line 304
  ( always {!<=-1,!>=2}
Line 305
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 6
  LIFETIME always 6
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
Line 308
  ( always {!<=-1,!>=2}
Line 309
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 6
  LIFETIME always 6
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 1
  Argument always 1
Line 312
  ( always {!<=-1,!>=2}
Line 313
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 6
  LIFETIME always 6
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 2
  SubFunction always 2
Line 316
  ( always {!<=-1,!>=2}
Line 317
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 333
  NonMovedVariable always 0
  MovedVariable always 1
  ForwardedVariable always 2
Line 347
  safe always {!<=-1,!>=2}
Line 350
  conditional always {!<=-1,!>=2}
Line 353
  macro always {!<=-1,!>=2}
Line 356
  defaultArg always {!<=-1,!>=2}
Line 373
  Object always 0
Line 375
  SubObject always 1
Line 377
  Lambda always 2
Line 379
  Iterator always 3
Line 381
  Address always 4
Line 384
  Local always 0
  Argument always 1
  SubFunction always 2
  ThisPointer always 3
  ThisValue always 4
Line 394
  Possible always 0
Line 396
  Known always 1
Line 398
  Inconclusive always 2
Line 400
  Impossible always 3
Line 404
  = always 1
  :: always 1
  Known always 1
Line 407
  ( always {!<=-1,!>=2}
Line 408
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 1
  Known always 1
Line 415
  ( always {!<=-1,!>=2}
Line 416
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
Line 419
  ( always {!<=-1,!>=2}
Line 420
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 3
  Impossible always 3
Line 424
  = always 3
  :: always 3
  Impossible always 3
Line 427
  inconclusive always {!<=-1,!>=2}
  = always 1
  true always 1
Line 428
  inconclusive always {!<=-1,!>=2}
Line 429
  = always 2
  :: always 2
  Inconclusive always 2
Line 432
  ( always {!<=-1,!>=2}
Line 433
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 2
  Inconclusive always 2
Line 437
  ( always {!<=-1,!>=2}
Line 441
  ( always {!<=-1,!>=2}
Line 442
  return always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  defaultArg always {!<=-1,!>=2}
Line 445
  ( always {!<=-1,!>=2}
Line 456
  ( always !<=-1
Line 460
  ( always {!<=-1,!>=2}
Line 462
  possible always {!<=-1,!>=2}
  = always 1
  true always 1
Line 467
  ( always {!<=-1,!>=2}
  , always 0
  = always 0
  nullptr always 0
  , always 20
  = always 20
  20 always 20
Line 471
  addressOf always {!<=-1,!>=2}
Line 473
  inconclusive always {!<=-1,!>=2}
Line 475
  nullptr always 0
  addressOf always {!<=-1,!>=2}
  false always 0
  inconclusive always {!<=-1,!>=2}
  false always 0
Line 478
  addressOf always {!<=-1,!>=2}
  false always 0
  ( possible lifetime[Object]=(errorPath)
  inconclusive always {!<=-1,!>=2}
  false always 0
Line 481
  addressOf always {!<=-1,!>=2}
Line 482
  addressOf always {!<=-1,!>=2}
  addressOf always {!<=-1,!>=2}
  ( possible lifetime[Object]=(errorPath)
  inconclusive always {!<=-1,!>=2}
  false always 0
Line 485
  b always {!<=-1,!>=2}
Line 487
  . always {!<=-1,!>=2}
  addressOf always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  b always {!<=-1,!>=2}
Line 491
  b always {!<=-1,!>=2}
Line 493
  . always {!<=-1,!>=2}
  inconclusive always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  b always {!<=-1,!>=2}
Line 511
  escape always {!<=-1,!>=2}
  = always 0
  false always 0
Line 514
  ( always {!<=-1,!>=2}
Line 516
  , always 0
  = always 0
  nullptr always 0
Line 520
  ( always {!<=-1,!>=2}
Line 526
  , always 0
  inconclusive always {!<=-1,!>=2}
  = always 0
  false always 0
Line 529
  inconclusive always {!<=-1,!>=2}
  = always 0
  false always 0
Line 530
  = always 0
  0 always 0
Line 532
  , always 0
  = always 0
  nullptr always 0
  , always 1
  smallest always {!<=-1,!>=2}
  = always 1
  true always 1
Line 62
  ( always !<=-1
Line 74
  mFlags always !<=-1
Line 77
  fIsClass always 1
  = always 1
  1 always 1
  << always 1
  0 always 0
  , always 2
Line 78
  fIsFunction always 2
  = always 2
  1 always 1
  << always 2
  1 always 1
  , always 4
Line 79
  fIsVariable always 4
  = always 4
  1 always 1
  << always 4
  2 always 2
  , always 8
Line 80
  fIsAlias always 8
  = always 8
  1 always 1
  << always 8
  3 always 3
  , always 16
Line 81
  fIsSpecialization always 16
  = always 16
  1 always 1
  << always 16
  4 always 4
  , always 32
Line 82
  fIsPartialSpecialization always 32
  = always 32
  1 always 1
  << always 32
  5 always 5
  , always 64
Line 83
  fIsForwardDeclaration always 64
  = always 64
  1 always 1
  << always 64
  6 always 6
  , always 128
Line 84
  fIsVariadic always 128
  = always 128
  1 always 1
  << always 128
  7 always 7
  , always 256
Line 85
  fIsFriend always 256
  = always 256
  1 always 1
  << always 256
  8 always 8
  , always 7
Line 86
  fFamilyMask always 7
  = always 7
  fIsClass always 1
  | always 3
  fIsFunction always 2
  | always 7
  fIsVariable always 4
Line 89
  state always {!<=-1,!>=2}
Line 90
  fIsClass always 1
  state always {!<=-1,!>=2}
Line 92
  state always {!<=-1,!>=2}
Line 93
  fIsFunction always 2
  state always {!<=-1,!>=2}
Line 95
  state always {!<=-1,!>=2}
Line 96
  fIsVariable always 4
  state always {!<=-1,!>=2}
Line 98
  state always {!<=-1,!>=2}
Line 99
  fIsAlias always 8
  state always {!<=-1,!>=2}
Line 101
  state always {!<=-1,!>=2}
Line 102
  fIsSpecialization always 16
  state always {!<=-1,!>=2}
Line 104
  state always {!<=-1,!>=2}
Line 105
  fIsPartialSpecialization always 32
  state always {!<=-1,!>=2}
Line 107
  state always {!<=-1,!>=2}
Line 108
  fIsForwardDeclaration always 64
  state always {!<=-1,!>=2}
Line 110
  state always {!<=-1,!>=2}
Line 111
  fIsVariadic always 128
  state always {!<=-1,!>=2}
Line 113
  state always {!<=-1,!>=2}
Line 114
  fIsFriend always 256
  state always {!<=-1,!>=2}
Line 122
  ( always {!<=-1,!>=2}
  flag always !<=-1
Line 123
  return always {!<=-1,!>=2}
  mFlags always !<=-1
  & always !<=-1
  flag {!<=-1,256@35,128@36,64@37,32@38,16@39,8@40,4@41,2@42,1@43}
  != always {!<=-1,!>=2}
  0 always 0
Line 131
  flag always !<=-1
  state always {!<=-1,!>=2}
Line 132
  mFlags always !<=-1
  = always !<=-1
  state always {!<=-1,!>=2}
  ? always !<=-1
  mFlags always !<=-1
  | always !<=-1
  flag {!<=-1,256@44,128@45,64@46,32@47,16@48,8@49,4@50,2@51,1@52}
  : always !<=-1
  mFlags always !<=-1
  & always !<=-1
  ~ {!<=0,4294967039@44,4294967167@45,4294967231@46,4294967263@47,4294967279@48,4294967287@49,4294967291@50,4294967293@51,4294967294@52}
  flag {!<=-1,256@44,128@45,64@46,32@47,16@48,8@49,4@50,2@51,1@52}
Line 153
  ( always {!<=-1,!>=2}
Line 154
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 155
  == always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  mFlags always !<=-1
  == always {!<=-1,!>=2}
  . always !<=-1
  mFlags always !<=-1
Line 183
  ( always {!<=-1,!>=2}
Line 184
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsClass always 1
Line 186
  ( always {!<=-1,!>=2}
Line 187
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsFunction always 2
Line 189
  ( always {!<=-1,!>=2}
Line 190
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsVariable always 4
Line 192
  ( always {!<=-1,!>=2}
Line 193
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsAlias always 8
Line 195
  ( always {!<=-1,!>=2}
Line 196
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsSpecialization always 16
Line 198
  ( always {!<=-1,!>=2}
Line 199
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsPartialSpecialization always 32
Line 201
  ( always {!<=-1,!>=2}
Line 202
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsForwardDeclaration always 64
Line 204
  ( always {!<=-1,!>=2}
Line 205
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsVariadic always 128
Line 207
  ( always {!<=-1,!>=2}
Line 208
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsFriend always 256
Line 234
  ( always {!<=-1,!>=2}
Line 242
  ( always {!<=-1,!>=2}
Line 245
  return always {!<=-1,!>=2}
  mFlags always !<=-1
  & always !<=-1
  fFamilyMask always 7
  & always !<=-1
  . always !<=-1
  mFlags always !<=-1
  & always !<=-1
  fFamilyMask always 7
  != always {!<=-1,!>=2}
  0 always 0
Line 265
  ( always {!<=-1,!>=2}
  , always !<=-1
  numberOfArguments always !<=-1
  , always {!<=-1,!>=2}
  variadic always {!<=-1,!>=2}
Line 281
  ( always {!<=-1,!>=2}
Line 289
  ( always {!<=-1,!>=2}
Line 297
  ( always {!<=-1,!>=2}
Line 306
  codeWithTemplates always {!<=-1,!>=2}
Line 314
  ( always {!<=-1,!>=2}
  , always 1
  isTemplate always {!<=-1,!>=2}
  = always 1
  true always 1
Line 322
  ( always {!<=-1,!>=2}
  = always 0
  nullptr always 0
  , always 0
  = always 0
  nullptr always 0
  , always 1
  isTemplate always {!<=-1,!>=2}
  = always 1
  true always 1
Line 335
  ( always {!<=-1,!>=2}
Line 391
  ( always {!<=-1,!>=2}
Line 410
  ( always {!<=-1,!>=2}
Line 424
  , always {!<=-1,!>=2}
Line 425
  copy always {!<=-1,!>=2}
Line 451
  ( always {!<=-1,!>=2}
Line 456
  ( always {!<=-1,!>=2}
Line 486
  , always "    "
Line 487
  = always "    "
  "    " always "    "
Line 488
  = always ""
  "" always ""
Line 494
  mChanged always {!<=-1,!>=2}
Line 47
  ( always {!<=-1,!>=2}
Line 49
  return always {!<=-1,!>=2}
  != always {!<=-1,!>=2}
Line 53
  ( always {!<=-1,!>=2}
Line 55
  return always {!<=-1,!>=2}
  != always {!<=-1,!>=2}
Line 59
  ( always {!<=-1,!>=2}
Line 61
  return always {!<=-1,!>=2}
  != always {!<=-1,!>=2}
Line 67
  ( always !<=-1
Line 69
  return always !<=-1
  ( always !<=-1
Line 73
  ( always {!<=-1,!>=2}
Line 75
  return always {!<=-1,!>=2}
  ! {!<=-1,!>=2,0}
  str possible size=0
  ( {!<=-1,!>=2,1}
  && always {!<=-1,!>=2}
  str always !size=0
  == always {!<=-1,!>=2}
  c possible {39@49185,34@49441}
Line 78
  ( always {!<=-1,!>=2}
  , always !<=-1
  endlen always !<=-1
Line 80
  return always {!<=-1,!>=2}
  ( always !<=-1
  >= always {!<=-1,!>=2}
  endlen always !<=-1
  && always {!<=-1,!>=2}
  ( {!<=-1,>=symbolic=(endlen),!<=symbolic=(endlen-1)}
  - always !<=-1
  endlen {!<=-1,<=symbolic=(str.size()),!>=symbolic=(str.size()+1)}
  endlen {!<=-1,<=symbolic=(str.size()),!>=symbolic=(str.size()+1)}
  == always {!<=-1,!>=2}
  0 always 0
Line 84
  ( always {!<=-1,!>=2}
  ( always !0
  & always !0
Line 86
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  1 always 1
Line 89
  ( always {!<=-1,!>=2}
Line 91
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  q possible {39@192,34@193}
Line 92
  return always {!<=-1,!>=2}
  false always 0
Line 93
  ( always !<=-1
  + always !<=0
  1 always 1
  > always {!<=-1,!>=2}
  p possible {""@192,""@193,""@194,"U"@195,"U"@196,"u"@197,"u"@198,"u8"@199,"u8"@200}
  ( always !<=-1
  && always {!<=-1,!>=2}
  0 always 0
  ( always !<=-1
  + always !<=0
  1 always 1
  == always {!<=-1,!>=2}
  0 always 0
Line 94
  return always {!<=-1,!>=2}
  true always 1
Line 95
  return always {!<=-1,!>=2}
  false always 0
Line 98
  ( always {!<=-1,!>=2}
Line 100
  "" always ""
  "u8" always "u8"
  "u" always "u"
  "U" always "U"
  "L" always "L"
Line 102
  ( always {!<=-1,!>=2}
  q possible {39@30,34@31}
Line 103
  return always {!<=-1,!>=2}
  true always 1
Line 105
  return always {!<=-1,!>=2}
  false always 0
Line 108
  ( always {!<=-1,!>=2}
Line 110
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  '"' always 34
Line 113
  ( always {!<=-1,!>=2}
Line 115
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  '\'' always 39
Line 120
  quotePos always !<=-1
  = always !<=-1
  ( always !<=-1
  q possible {39@27,34@29}
Line 121
  quotePos {symbolic=(str.find(q)),!<=-1}
  + always !<=0
  1U always 1
  ( always !<=-1
  - always !<=-1
  quotePos {symbolic=(str.find(q)),!<=-1}
  - always !<=-1
  2U always 2
Line 126
  ( always {!<=-1,!>=2}
Line 127
  '"' always 34
Line 128
  "" always ""
Line 133
  ( always {!<=-1,!>=2}
Line 134
  '\'' always 39
Line 135
  "" always ""
Line 140
  i possible {2,3}
  == {!<=-1,!>=2,0}
  1 always 1
Line 141
  "st" always "st"
Line 142
  i {3,!1}
  == {!<=-1,!>=2,0}
  2 always 2
Line 143
  "nd" always "nd"
Line 144
  i always {!1,!2}
  == always {!<=-1,!>=2}
  3 always 3
Line 145
  "rd" always "rd"
Line 146
  "th" always "th"
Line 151
  ( always {!<=-1,!>=2}
Line 153
  ( always {!<=-1,!>=2}
Line 155
  ( always {!<=-1,!>=2}
Line 118
  LOW always 0
  HIGH always 1
Line 125
  UNKNOWN always 0
  CPP11INIT always 1
  NOINIT always 2
Line 128
  mBits always !<=-1
Line 131
  ( always {!<=-1,!>=2}
Line 134
  0 always 0
Line 135
  0 always 0
Line 136
  0 always 0
Line 137
  0 always 0
Line 138
  0 always 0
Line 139
  nullptr always 0
Line 140
  nullptr always 0
Line 141
  nullptr always 0
Line 142
  nullptr always 0
Line 143
  nullptr always 0
Line 144
  0 always 0
Line 145
  0 always 0
Line 146
  nullptr always 0
Line 147
  nullptr always 0
Line 148
  nullptr always 0
Line 149
  nullptr always 0
Line 150
  nullptr always 0
Line 151
  nullptr always 0
Line 153
  mBits always !<=-1
  0 always 0
Line 182
  eVariable always 0
  eType always 1
  eFunction always 2
  eKeyword always 3
  eName always 4
Line 183
  eNumber always 5
  eString always 6
  eChar always 7
  eBoolean always 8
  eLiteral always 9
  eEnumerator always 10
Line 184
  eArithmeticalOp always 11
  eComparisonOp always 12
  eAssignmentOp always 13
  eLogicalOp always 14
  eBitOp always 15
  eIncDecOp always 16
  eExtendedOp always 17
Line 185
  eBracket always 18
Line 186
  eLambda always 19
Line 187
  eEllipsis always 20
Line 188
  eOther always 21
Line 189
  eNone always 22
Line 192
  = always 0
  nullptr always 0
Line 198
  && always {!<=-1,!>=2}
Line 200
  = always 0
  0 always 0
Line 218
  = always 1
  1 always 1
Line 223
  = always 1
  1 always 1
Line 237
  ( always !0
  this always !0
  index possible {-2@61,2@135,-3@210,4@13,3@173}
Line 246
  ( always !0
  this always !0
  index possible {1@176,3@8,-1@14}
Line 275
  ( always {!<=-1,!>=2}
  ( always !0
  & {lifetime[Address]=(pattern),!0}
Line 276
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  tok possible {symbolic=(tok->link()->next())@19,0@19,symbolic=(roundBracket->link()->next())@187,symbolic=(tok->previous())@52,symbolic=(nameToken->link()->previous())@114}
  pattern possible {") = 0"@92,"operator"@94,"for ("@123,"] :"@125,"( {"@160,":"@169,"( {"@175,"::"@193,"( {"@235,"( {"@240}
  1 always 1
Line 279
  ( always {!<=-1,!>=2}
  , always !<=-1
  pattern_len always !<=-1
Line 324
  ( always {!<=-1,!>=2}
  , always 0
  = always 0
  0 always 0
Line 370
  = always !0
  this always !0
Line 371
  top possible {symbolic=(this),0}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  top {symbolic=(this),!0}
  ",|(" always ",|("
Line 372
  top always !0
Line 373
  top possible {symbolic=(this),0}
  ? possible 0
  top always !0
  : always 0
  nullptr always 0
Line 380
  = possible {10@181,4@182,0@183}
  t possible {10@181,4@182,0@183}
Line 382
  memoizedIsName always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  mTokType possible {10@181,4@182,0@183}
  == always {!<=-1,!>=2}
  eName always 4
  || always {!<=-1,!>=2}
  mTokType {!4,10@181,0@183}
  == always {!<=-1,!>=2}
  eType always 1
  || always {!<=-1,!>=2}
  mTokType {!4,!1,10@181,0@183}
  == always {!<=-1,!>=2}
  eVariable always 0
  || always {!<=-1,!>=2}
Line 383
  mTokType {!1,!0,10@181}
  == always {!<=-1,!>=2}
  eFunction always 2
  || always {!<=-1,!>=2}
  mTokType {!0,!2,10@181}
  == always {!<=-1,!>=2}
  eKeyword always 3
  || always {!<=-1,!>=2}
  mTokType {!2,!3,10@181}
  == always {!<=-1,!>=2}
  eBoolean always 8
  || always {!<=-1,!>=2}
Line 384
  mTokType {!3,!8,10@181}
  == always {!<=-1,!>=2}
  eEnumerator always 10
Line 385
  fIsName always 2097152
  memoizedIsName {symbolic=(mTokType==eName||mTokType==eType||mTokType==eVariable||mTokType==eFunction||mTokType==eKeyword||mTokType==eBoolean||mTokType==eEnumerator),!<=-1,!>=2,1@181}
Line 387
  memoizedIsLiteral always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  eNumber always 5
  || always {!<=-1,!>=2}
  mTokType always !5
  == always {!<=-1,!>=2}
  eString always 6
  || always {!<=-1,!>=2}
  mTokType always {!5,!6}
  == always {!<=-1,!>=2}
  eChar always 7
  || always {!<=-1,!>=2}
Line 388
  mTokType always {!6,!7}
  == always {!<=-1,!>=2}
  eBoolean always 8
  || always {!<=-1,!>=2}
  mTokType always {!7,!8}
  == always {!<=-1,!>=2}
  eLiteral always 9
  || always {!<=-1,!>=2}
  mTokType always {!8,!9}
  == always {!<=-1,!>=2}
  eEnumerator always 10
Line 389
  fIsLiteral always 4194304
  memoizedIsLiteral {symbolic=(mTokType==eNumber||mTokType==eString||mTokType==eChar||mTokType==eBoolean||mTokType==eLiteral||mTokType==eEnumerator),!<=-1,!>=2}
Line 391
  ( always {!<=-1,!>=2}
Line 392
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  eKeyword always 3
Line 394
  ( always {!<=-1,!>=2}
Line 395
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsName always 2097152
Line 397
  ( always {!<=-1,!>=2}
Line 398
  return always {!<=-1,!>=2}
  mFlags always !<=-1
  == always {!<=-1,!>=2}
  fIsName always 2097152
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  eName always 4
Line 400
  ( always {!<=-1,!>=2}
Line 401
  ( always {!<=-1,!>=2}
Line 402
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsLiteral always 4194304
Line 404
  ( always {!<=-1,!>=2}
Line 405
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  eNumber always 5
Line 407
  ( always {!<=-1,!>=2}
Line 408
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  eEnumerator always 10
Line 410
  ( always {!<=-1,!>=2}
Line 411
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
Line 412
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
Line 413
  == always {!<=-1,!>=2}
  eIncDecOp always 16
Line 415
  ( always {!<=-1,!>=2}
Line 416
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
Line 417
  == always {!<=-1,!>=2}
  eLogicalOp always 14
  || always {!<=-1,!>=2}
Line 418
  mTokType always !14
  == always {!<=-1,!>=2}
  eComparisonOp always 12
  || always {!<=-1,!>=2}
Line 419
  mTokType always {!14,!12}
  == always {!<=-1,!>=2}
  eBitOp always 15
Line 421
  ( always {!<=-1,!>=2}
Line 422
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
Line 423
  == always {!<=-1,!>=2}
  eExtendedOp always 17
Line 425
  ( always {!<=-1,!>=2}
Line 426
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  eArithmeticalOp always 11
Line 428
  ( always {!<=-1,!>=2}
Line 429
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  eComparisonOp always 12
Line 431
  ( always {!<=-1,!>=2}
Line 432
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  eAssignmentOp always 13
Line 434
  ( always {!<=-1,!>=2}
Line 435
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  eBoolean always 8
Line 437
  ( always {!<=-1,!>=2}
Line 438
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  eIncDecOp always 16
Line 440
  ( always {!<=-1,!>=2}
Line 441
  return always {!<=-1,!>=2}
  != always {!<=-1,!>=2}
  nullptr always 0
  && always {!<=-1,!>=2}
  != always {!<=-1,!>=2}
  nullptr always 0
Line 443
  ( always {!<=-1,!>=2}
Line 444
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  != always {!<=-1,!>=2}
  nullptr always 0
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  nullptr always 0
Line 446
  ( always {!<=-1,!>=2}
Line 448
  ( always !<=-1
Line 449
  return always !<=-1
  mFlags always !<=-1
Line 451
  flags_ always !<=-1
Line 452
  mFlags always !<=-1
  = always !<=-1
  flags_ always !<=-1
Line 454
  ( always {!<=-1,!>=2}
Line 455
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsUnsigned always 1
Line 457
  sign always {!<=-1,!>=2}
Line 458
  fIsUnsigned always 1
  sign {!<=-1,!>=2,0@29,1@37}
Line 460
  ( always {!<=-1,!>=2}
Line 461
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsSigned always 2
Line 463
  sign always {!<=-1,!>=2}
Line 464
  fIsSigned always 2
  sign {!<=-1,!>=2,0@28,1@35}
Line 466
  ( always {!<=-1,!>=2}
Line 467
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsPointerCompare always 4
Line 469
  b always {!<=-1,!>=2}
Line 470
  fIsPointerCompare always 4
  b always {!<=-1,!>=2}
Line 472
  ( always {!<=-1,!>=2}
Line 473
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsLong always 8
Line 475
  size always {!<=-1,!>=2}
Line 476
  fIsLong always 8
  size {!<=-1,!>=2,0@31,1@31}
Line 478
  ( always {!<=-1,!>=2}
Line 479
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsStandardType always 16
Line 481
  b always {!<=-1,!>=2}
Line 482
  fIsStandardType always 16
  b {!<=-1,!>=2,0@189}
Line 484
  ( always {!<=-1,!>=2}
Line 485
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsExpandedMacro always 32
Line 487
  m always {!<=-1,!>=2}
Line 488
  fIsExpandedMacro always 32
  m {!<=-1,!>=2,0@198,1@198}
Line 490
  ( always {!<=-1,!>=2}
Line 491
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsCast always 64
Line 493
  c always {!<=-1,!>=2}
Line 494
  fIsCast always 64
  c {!<=-1,!>=2,1@112}
Line 496
  ( always {!<=-1,!>=2}
Line 497
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsAttributeConstructor always 128
Line 499
  ac always {!<=-1,!>=2}
Line 500
  fIsAttributeConstructor always 128
  ac always {!<=-1,!>=2}
Line 502
  ( always {!<=-1,!>=2}
Line 503
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsAttributeDestructor always 256
Line 505
  value always {!<=-1,!>=2}
Line 506
  fIsAttributeDestructor always 256
  value always {!<=-1,!>=2}
Line 508
  ( always {!<=-1,!>=2}
Line 509
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsAttributeUnused always 512
Line 511
  unused always {!<=-1,!>=2}
Line 512
  fIsAttributeUnused always 512
  unused always {!<=-1,!>=2}
Line 514
  ( always {!<=-1,!>=2}
Line 515
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsAttributeUsed always 16384
Line 517
  unused always {!<=-1,!>=2}
Line 518
  fIsAttributeUsed always 16384
  unused always {!<=-1,!>=2}
Line 520
  ( always {!<=-1,!>=2}
Line 521
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsAttributePure always 1024
Line 523
  value always {!<=-1,!>=2}
Line 524
  fIsAttributePure always 1024
  value always {!<=-1,!>=2}
Line 526
  ( always {!<=-1,!>=2}
Line 527
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsAttributeConst always 2048
Line 529
  value always {!<=-1,!>=2}
Line 530
  fIsAttributeConst always 2048
  value always {!<=-1,!>=2}
Line 532
  ( always {!<=-1,!>=2}
Line 533
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsAttributeNoreturn always 4096
Line 535
  value always {!<=-1,!>=2}
Line 536
  fIsAttributeNoreturn always 4096
  value always {!<=-1,!>=2}
Line 538
  ( always {!<=-1,!>=2}
Line 539
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsAttributeNothrow always 8192
Line 541
  value always {!<=-1,!>=2}
Line 542
  fIsAttributeNothrow always 8192
  value always {!<=-1,!>=2}
Line 544
  ( always {!<=-1,!>=2}
Line 545
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsAttributePacked always 32768
Line 547
  value always {!<=-1,!>=2}
Line 548
  fIsAttributePacked always 32768
  value always {!<=-1,!>=2}
Line 550
  ( always {!<=-1,!>=2}
Line 551
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsAttributeNodiscard always 16777216
Line 553
  value always {!<=-1,!>=2}
Line 554
  fIsAttributeNodiscard always 16777216
  value always {!<=-1,!>=2}
Line 556
  ( always {!<=-1,!>=2}
Line 557
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsAttributeMaybeUnused always 65536
Line 559
  value always {!<=-1,!>=2}
Line 560
  fIsAttributeMaybeUnused always 65536
  value always {!<=-1,!>=2}
Line 565
  ( always {!<=-1,!>=2}
Line 566
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 568
  ( always {!<=-1,!>=2}
Line 569
  return always {!<=-1,!>=2}
  nullptr always 0
  != always {!<=-1,!>=2}
Line 571
  ( always {!<=-1,!>=2}
Line 572
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsControlFlowKeyword always 131072
Line 574
  ( always {!<=-1,!>=2}
Line 575
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsOperatorKeyword always 262144
Line 577
  value always {!<=-1,!>=2}
Line 578
  fIsOperatorKeyword always 262144
  value always {!<=-1,!>=2}
Line 580
  ( always {!<=-1,!>=2}
Line 581
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsComplex always 524288
Line 583
  value always {!<=-1,!>=2}
Line 584
  fIsComplex always 524288
  value {!<=-1,!>=2,0@33,1@33}
Line 586
  ( always {!<=-1,!>=2}
Line 587
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsEnumType always 1048576
Line 589
  value always {!<=-1,!>=2}
Line 590
  fIsEnumType always 1048576
  value always {!<=-1,!>=2}
Line 592
  ( always {!<=-1,!>=2}
Line 593
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fAtAddress always 33554432
Line 595
  b always {!<=-1,!>=2}
Line 596
  fAtAddress always 33554432
  b always {!<=-1,!>=2}
Line 598
  ( always {!<=-1,!>=2}
Line 599
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIncompleteVar always 67108864
Line 601
  b always {!<=-1,!>=2}
Line 602
  fIncompleteVar always 67108864
  b always {!<=-1,!>=2}
Line 605
  ( always {!<=-1,!>=2}
Line 606
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsIncompleteConstant always 68719476736
Line 608
  b always {!<=-1,!>=2}
Line 609
  fIsIncompleteConstant always 68719476736
  b always {!<=-1,!>=2}
Line 612
  ( always {!<=-1,!>=2}
Line 613
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fConstexpr always 134217728
Line 615
  b always {!<=-1,!>=2}
Line 616
  fConstexpr always 134217728
  b always {!<=-1,!>=2}
Line 619
  ( always {!<=-1,!>=2}
Line 620
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fExternC always 268435456
Line 622
  b always {!<=-1,!>=2}
Line 623
  fExternC always 268435456
  b always {!<=-1,!>=2}
Line 626
  ( always {!<=-1,!>=2}
Line 627
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsSplitVarDeclComma always 536870912
Line 629
  b always {!<=-1,!>=2}
Line 630
  fIsSplitVarDeclComma always 536870912
  b always {!<=-1,!>=2}
Line 633
  ( always {!<=-1,!>=2}
Line 634
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsSplitVarDeclEq always 1073741824
Line 636
  b always {!<=-1,!>=2}
Line 637
  fIsSplitVarDeclEq always 1073741824
  b always {!<=-1,!>=2}
Line 640
  ( always {!<=-1,!>=2}
Line 641
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsImplicitInt always 2147483648
Line 643
  b always {!<=-1,!>=2}
Line 644
  fIsImplicitInt always 2147483648
  b {!<=-1,!>=2,1@19}
Line 647
  ( always {!<=-1,!>=2}
Line 648
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsInline always 4294967296
Line 650
  b always {!<=-1,!>=2}
Line 651
  fIsInline always 4294967296
  b always {!<=-1,!>=2}
Line 654
  ( always {!<=-1,!>=2}
Line 655
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsRemovedVoidParameter always 34359738368
Line 657
  b always {!<=-1,!>=2}
Line 658
  fIsRemovedVoidParameter always 34359738368
  b always {!<=-1,!>=2}
Line 661
  ( always {!<=-1,!>=2}
Line 662
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsTemplate always 8589934592
Line 664
  b always {!<=-1,!>=2}
Line 665
  fIsTemplate always 8589934592
  b always {!<=-1,!>=2}
Line 668
  ( always {!<=-1,!>=2}
Line 669
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsSimplifedScope always 17179869184
Line 671
  b always {!<=-1,!>=2}
Line 672
  fIsSimplifedScope always 17179869184
  b always {!<=-1,!>=2}
Line 675
  ( always {!<=-1,!>=2}
Line 676
  return always {!<=-1,!>=2}
  . always !<=-1
  mBits always !<=-1
  > always {!<=-1,!>=2}
  0 always 0
Line 678
  ( always !<=-1
Line 679
  return always !<=-1
  . always !<=-1
  mBits always !<=-1
Line 685
  ! always {!<=-1,!>=2}
Line 687
  . possible lifetime[Object]=(tokenAndName)
Line 689
  b always !<=-1
Line 690
  . always !<=-1
  mBits always !<=-1
  = always !<=-1
  b always !<=-1
Line 693
  ( always {!<=-1,!>=2}
Line 694
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  eString always 6
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  '"' always 34
  "u8" always "u8"
  || always {!<=-1,!>=2}
Line 695
  == always {!<=-1,!>=2}
  eChar always 7
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  '\'' always 39
  "u8" always "u8"
Line 698
  ( always {!<=-1,!>=2}
Line 699
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  eString always 6
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  '"' always 34
  "u" always "u"
  || always {!<=-1,!>=2}
Line 700
  == always {!<=-1,!>=2}
  eChar always 7
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  '\'' always 39
  "u" always "u"
Line 703
  ( always {!<=-1,!>=2}
Line 704
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  eString always 6
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  '"' always 34
  "U" always "U"
  || always {!<=-1,!>=2}
Line 705
  == always {!<=-1,!>=2}
  eChar always 7
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  '\'' always 39
  "U" always "U"
Line 708
  ( always {!<=-1,!>=2}
Line 709
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  eString always 6
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  '"' always 34
  "" always ""
  || always {!<=-1,!>=2}
Line 710
  == always {!<=-1,!>=2}
  eChar always 7
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  '\'' always 39
  "" always ""
  && always {!<=-1,!>=2}
  ( always !<=-1
  == always {!<=-1,!>=2}
  3 always 3
Line 713
  ( always {!<=-1,!>=2}
Line 714
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  eChar always 7
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  '\'' always 39
  "" always ""
  && always {!<=-1,!>=2}
Line 715
  ( always !<=-1
  > always {!<=-1,!>=2}
  3 always 3
Line 734
  ( always {!<=-1,!>=2}
Line 735
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsTemplateArg always 8388608
Line 737
  value always {!<=-1,!>=2}
Line 738
  fIsTemplateArg always 8388608
  value always {!<=-1,!>=2}
Line 742
  ( always !0
  & {lifetime[Address]=(pattern),!0}
Line 743
  pattern possible "["@124
  1 always 1
Line 745
  , always !<=-1
  pattern_len always !<=-1
Line 748
  ( always !0
  & {lifetime[Address]=(pattern),!0}
Line 749
  pattern possible ";"@70
  1 always 1
Line 751
  , always !<=-1
  pattern_len always !<=-1
Line 753
  , always 0
  = always 0
  0 always 0
Line 754
  , always 0
  = always 0
  0 always 0
Line 757
  ( always !0
  & {lifetime[Address]=(pattern),!0}
Line 758
  1 always 1
Line 760
  , always !<=-1
  pattern_len always !<=-1
Line 761
  pattern_len always !<=-1
Line 764
  ( always !0
  & {lifetime[Address]=(pattern),!0}
Line 765
  1 always 1
Line 767
  , always !<=-1
  pattern_len always !<=-1
Line 768
  pattern_len always !<=-1
Line 771
  , always 0
  = always 0
  0 always 0
Line 772
  varId possible 0
Line 774
  , always 0
  = always 0
  0 always 0
Line 775
  varId possible 0
Line 837
  , always 0
  prepend always {!<=-1,!>=2}
  = always 0
  false always 0
Line 841
  true always 1
Line 853
  = possible 0
  id possible 0
Line 854
  != always {!<=-1,!>=2}
  0 always 0
Line 855
  eVariable always 0
Line 856
  false always 0
Line 864
  . always !0
Line 877
  = always 0
  nullptr always 0
Line 892
  = always 5
  5 always 5
Line 904
  varid always {!<=-1,!>=2}
  varid always {!<=-1,!>=2}
  = always 0
  false always 0
Line 905
  exprid always {!<=-1,!>=2}
  exprid always {!<=-1,!>=2}
  = always 0
  false always 0
Line 906
  idtype always {!<=-1,!>=2}
  idtype always {!<=-1,!>=2}
  = always 0
  false always 0
Line 907
  attributes always {!<=-1,!>=2}
  attributes always {!<=-1,!>=2}
  = always 0
  false always 0
Line 908
  macro always {!<=-1,!>=2}
  macro always {!<=-1,!>=2}
  = always 0
  false always 0
Line 909
  linenumbers always {!<=-1,!>=2}
  linenumbers always {!<=-1,!>=2}
  = always 0
  false always 0
Line 910
  linebreaks always {!<=-1,!>=2}
  linebreaks always {!<=-1,!>=2}
  = always 0
  false always 0
Line 911
  files always {!<=-1,!>=2}
  files always {!<=-1,!>=2}
  = always 0
  false always 0
Line 914
  . always {!<=-1,!>=2}
  attributes always {!<=-1,!>=2}
  = always 1
  true always 1
Line 915
  . always {!<=-1,!>=2}
  macro always {!<=-1,!>=2}
  = always 1
  true always 1
Line 916
  . always {!<=-1,!>=2}
  linenumbers always {!<=-1,!>=2}
  = always 1
  true always 1
Line 917
  . always {!<=-1,!>=2}
  linebreaks always {!<=-1,!>=2}
  = always 1
  true always 1
Line 918
  . always {!<=-1,!>=2}
  files always {!<=-1,!>=2}
  = always 1
  true always 1
Line 923
  . always {!<=-1,!>=2}
  varid always {!<=-1,!>=2}
  = always 1
  true always 1
Line 928
  . always {!<=-1,!>=2}
  exprid always {!<=-1,!>=2}
  = always 1
  true always 1
Line 933
  . always {!<=-1,!>=2}
  exprid always {!<=-1,!>=2}
  = always 1
  true always 1
Line 934
  . always {!<=-1,!>=2}
  varid always {!<=-1,!>=2}
  = always 1
  true always 1
Line 935
  . always {!<=-1,!>=2}
  idtype always {!<=-1,!>=2}
  = always 1
  true always 1
Line 948
  varid always {!<=-1,!>=2}
  attributes always {!<=-1,!>=2}
  macro always {!<=-1,!>=2}
Line 950
  , always 0
  = always 0
  nullptr always 0
  , always 0
  = always 0
  nullptr always 0
Line 951
  , always 1
  attributes always {!<=-1,!>=2}
  = always 1
  true always 1
Line 952
  varid always {!<=-1,!>=2}
  = always 0
  false always 0
Line 965
  varid always {!<=-1,!>=2}
  attributes always {!<=-1,!>=2}
  linenumbers always {!<=-1,!>=2}
  linebreaks always {!<=-1,!>=2}
  files always {!<=-1,!>=2}
  = always 0
  nullptr always 0
  , always 0
  = always 0
  nullptr always 0
Line 983
  = possible symbolic=(links.top())@230
  linkToToken possible symbolic=(links.top())@230
Line 984
  mStr possible size=1
  == always {!<=-1,!>=2}
  "<" always "<"
  || always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  ">" always ">"
Line 1026
  mTokType possible 19
  == {!<=-1,!>=2,0}
  eFunction always 2
  || always {!<=-1,!>=2}
  mTokType always !2
  == always {!<=-1,!>=2}
  eLambda always 19
  : always 0
  nullptr always 0
Line 1034
  = possible 0
  v possible 0
Line 1035
  || always {!<=-1,!>=2}
Line 1036
  eVariable always 0
Line 1037
  == always {!<=-1,!>=2}
  eVariable always 0
Line 1038
  eName always 4
Line 1045
  == always {!<=-1,!>=2}
  eVariable always 0
  ? possible 0
  : always 0
  nullptr always 0
Line 1058
  == always {!<=-1,!>=2}
  eType always 1
  ? possible 0
  : always 0
  nullptr always 0
Line 1061
  , always 0
  = always 0
  nullptr always 0
Line 1071
  == always {!<=-1,!>=2}
  eEnumerator always 10
  ? possible 0
  : always 0
  nullptr always 0
Line 1079
  = possible 0
  e possible 0
Line 1081
  eEnumerator always 10
Line 1082
  == always {!<=-1,!>=2}
  eEnumerator always 10
Line 1083
  eName always 4
Line 1152
  . always !0
Line 1156
  . always !0
Line 1163
  && always {!<=-1,!>=2}
Line 1164
  ! always {!<=-1,!>=2}
Line 1170
  ( always {!<=-1,!>=2}
Line 1171
  ( always {!<=-1,!>=2}
Line 1172
  ( always {!<=-1,!>=2}
Line 1173
  ( always {!<=-1,!>=2}
Line 1182
  condition always {!<=-1,!>=2}
  = always 0
  0 always 0
Line 1197
  ( always {!<=-1,!>=2}
Line 1199
  ( always {!<=-1,!>=2}
Line 1227
  ( always {!<=-1,!>=2}
Line 1243
  fIsUnsigned always 1
  = always 1
  1 always 1
  << always 1
  0 always 0
  , always 2
Line 1244
  fIsSigned always 2
  = always 2
  1 always 1
  << always 2
  1 always 1
  , always 4
Line 1245
  fIsPointerCompare always 4
  = always 4
  1 always 1
  << always 4
  2 always 2
  , always 8
Line 1246
  fIsLong always 8
  = always 8
  1 always 1
  << always 8
  3 always 3
  , always 16
Line 1247
  fIsStandardType always 16
  = always 16
  1 always 1
  << always 16
  4 always 4
  , always 32
Line 1248
  fIsExpandedMacro always 32
  = always 32
  1 always 1
  << always 32
  5 always 5
  , always 64
Line 1249
  fIsCast always 64
  = always 64
  1 always 1
  << always 64
  6 always 6
  , always 128
Line 1250
  fIsAttributeConstructor always 128
  = always 128
  1 always 1
  << always 128
  7 always 7
  , always 256
Line 1251
  fIsAttributeDestructor always 256
  = always 256
  1 always 1
  << always 256
  8 always 8
  , always 512
Line 1252
  fIsAttributeUnused always 512
  = always 512
  1 always 1
  << always 512
  9 always 9
  , always 1024
Line 1253
  fIsAttributePure always 1024
  = always 1024
  1 always 1
  << always 1024
  10 always 10
  , always 2048
Line 1254
  fIsAttributeConst always 2048
  = always 2048
  1 always 1
  << always 2048
  11 always 11
  , always 4096
Line 1255
  fIsAttributeNoreturn always 4096
  = always 4096
  1 always 1
  << always 4096
  12 always 12
  , always 8192
Line 1256
  fIsAttributeNothrow always 8192
  = always 8192
  1 always 1
  << always 8192
  13 always 13
  , always 16384
Line 1257
  fIsAttributeUsed always 16384
  = always 16384
  1 always 1
  << always 16384
  14 always 14
  , always 32768
Line 1258
  fIsAttributePacked always 32768
  = always 32768
  1 always 1
  << always 32768
  15 always 15
  , always 65536
Line 1259
  fIsAttributeMaybeUnused always 65536
  = always 65536
  1 always 1
  << always 65536
  16 always 16
  , always 131072
Line 1260
  fIsControlFlowKeyword always 131072
  = always 131072
  1 always 1
  << always 131072
  17 always 17
  , always 262144
Line 1261
  fIsOperatorKeyword always 262144
  = always 262144
  1 always 1
  << always 262144
  18 always 18
  , always 524288
Line 1262
  fIsComplex always 524288
  = always 524288
  1 always 1
  << always 524288
  19 always 19
  , always 1048576
Line 1263
  fIsEnumType always 1048576
  = always 1048576
  1 always 1
  << always 1048576
  20 always 20
  , always 2097152
Line 1264
  fIsName always 2097152
  = always 2097152
  1 always 1
  << always 2097152
  21 always 21
  , always 4194304
Line 1265
  fIsLiteral always 4194304
  = always 4194304
  1 always 1
  << always 4194304
  22 always 22
  , always 8388608
Line 1266
  fIsTemplateArg always 8388608
  = always 8388608
  1 always 1
  << always 8388608
  23 always 23
  , always 16777216
Line 1267
  fIsAttributeNodiscard always 16777216
  = always 16777216
  1 always 1
  << always 16777216
  24 always 24
  , always 33554432
Line 1268
  fAtAddress always 33554432
  = always 33554432
  1 always 1
  << always 33554432
  25 always 25
  , always 67108864
Line 1269
  fIncompleteVar always 67108864
  = always 67108864
  1 always 1
  << always 67108864
  26 always 26
  , always 134217728
Line 1270
  fConstexpr always 134217728
  = always 134217728
  1 always 1
  << always 134217728
  27 always 27
  , always 268435456
Line 1271
  fExternC always 268435456
  = always 268435456
  1 always 1
  << always 268435456
  28 always 28
  , always 536870912
Line 1272
  fIsSplitVarDeclComma always 536870912
  = always 536870912
  1 always 1
  << always 536870912
  29 always 29
  , always 1073741824
Line 1273
  fIsSplitVarDeclEq always 1073741824
  = always 1073741824
  1 always 1
  << always 1073741824
  30 always 30
  , always 2147483648
Line 1274
  fIsImplicitInt always 2147483648
  = always 2147483648
  1U always 1
  << always 2147483648
  31 always 31
  , always 4294967296
Line 1275
  fIsInline always 4294967296
  = always 4294967296
  1ULL always 1
  << always 4294967296
  32 always 32
  , always 8589934592
Line 1276
  fIsTemplate always 8589934592
  = always 8589934592
  1ULL always 1
  << always 8589934592
  33 always 33
  , always 17179869184
Line 1277
  fIsSimplifedScope always 17179869184
  = always 17179869184
  1ULL always 1
  << always 17179869184
  34 always 34
  , always 34359738368
Line 1278
  fIsRemovedVoidParameter always 34359738368
  = always 34359738368
  1ULL always 1
  << always 34359738368
  35 always 35
  , always 68719476736
Line 1279
  fIsIncompleteConstant always 68719476736
  = always 68719476736
  1ULL always 1
  << always 68719476736
  36 always 36
Line 1284
  mFlags always !<=-1
Line 1293
  ( always {!<=-1,!>=2}
  flag_ always !<=-1
Line 1294
  return always {!<=-1,!>=2}
  mFlags always !<=-1
  & always !<=-1
  flag_ {!<=-1,8388608@191,17179869184@202,8589934592@204,34359738368@206,4294967296@208,2147483648@210,1073741824@212,536870912@214,268435456@216}
  != always {!<=-1,!>=2}
  0 always 0
Line 1302
  flag_ always !<=-1
  state_ always {!<=-1,!>=2}
Line 1303
  mFlags always !<=-1
  = always !<=-1
  state_ {!<=-1,!>=2,symbolic=(mTokType==eName||mTokType==eType||mTokType==eVariable||mTokType==eFunction||mTokType==eKeyword||mTokType==eBoolean||mTokType==eEnumerator)@22,symbolic=(mTokType==eNumber||mTokType==eString||mTokType==eChar||mTokType==eBoolean||mTokType==eLiteral||mTokType==eEnumerator)@23}
  ? always !<=-1
  mFlags always !<=-1
  | always !<=-1
  flag_ {!<=-1,8388608@190,17179869184@201,8589934592@203,34359738368@205,4294967296@207,1073741824@211,536870912@213,268435456@215,134217728@217}
  : always !<=-1
  mFlags always !<=-1
  & always !<=-1
  ~ always !<=0
  flag_ {!<=-1,8388608@190,17179869184@201,8589934592@203,34359738368@205,4294967296@207,1073741824@211,536870912@213,268435456@215,134217728@217}
Line 1317
  , always 0
  = always 0
  0 always 0
  , always 0
  = always 0
  0 always 0
Line 1343
  ! always {!<=-1,!>=2}
Line 1344
  nullptr always 0
Line 1345
  this {!0,symbolic=(astParent()->astOperand2())}
  == always {!<=-1,!>=2}
  ( always !0
Line 1346
  ( always !0
Line 1347
  this always {!0,!symbolic=(astParent()->astOperand1())}
  == always {!<=-1,!>=2}
  ( always !0
Line 1348
  ( always !0
Line 1349
  nullptr always 0
Line 1353
  ! always {!<=-1,!>=2}
Line 1354
  nullptr always 0
Line 1355
  this {!0,symbolic=(astParent()->astOperand2())}
  == always {!<=-1,!>=2}
  ( always !0
Line 1356
  ( always !0
Line 1357
  this always {!0,!symbolic=(astParent()->astOperand1())}
  == always {!<=-1,!>=2}
  ( always !0
Line 1358
  ( always !0
Line 1359
  nullptr always 0
Line 1363
  = always !0
  this always !0
Line 1364
  ret possible symbolic=(this)
Line 1365
  = always !0
  . always !0
Line 1366
  ret possible symbolic=(this)
Line 1370
  = always !0
  this always !0
Line 1371
  ret possible symbolic=(this)
Line 1372
  = always !0
  . always !0
Line 1373
  ret possible symbolic=(this)
Line 1385
  ( always {!<=-1,!>=2}
Line 1388
  = always 0
  = always 0
  = always 0
  nullptr always 0
Line 1393
  = always 0
  nullptr always 0
Line 1396
  = always ""
  "" always ""
Line 1402
  sep possible ""
Line 1411
  verbose always {!<=-1,!>=2}
  xml always {!<=-1,!>=2}
Line 1413
  xml always {!<=-1,!>=2}
Line 1418
  cpp11init always {!<=-1,!>=2}
Line 1419
  = possible {1,2}
  cpp11init always {!<=-1,!>=2}
  ? possible {1,2}
  :: always 1
  CPP11INIT always 1
  : always 2
  :: always 2
  NOINIT always 2
Line 58
  ( always {!<=-1,!>=2}
Line 59
  return always {!<=-1,!>=2}
  mIsC always {!<=-1,!>=2}
Line 63
  ( always {!<=-1,!>=2}
Line 64
  return always {!<=-1,!>=2}
  mIsCpp always {!<=-1,!>=2}
Line 73
  , always 0
  = always 0
  false always 0
Line 90
  , always 1
  = always 1
  true always 1
Line 101
  ( always {!<=-1,!>=2}
Line 103
  && always {!<=-1,!>=2}
Line 156
  ( always !<=-1
Line 175
  ( always {!<=-1,!>=2}
Line 192
  ( always {!<=-1,!>=2}
Line 219
  mIsC always {!<=-1,!>=2}
Line 220
  mIsCpp always {!<=-1,!>=2}
Line 36
  AST always 0
  SYNTAX always 1
  UNKNOWN_MACRO always 2
  INTERNAL always 3
  LIMIT always 4
  INSTANTIATION always 5
Line 37
  = always 3
  INTERNAL always 3
Line 47
  normal always 0
  inconclusive always 1
  safe always 2
  experimental always 3
Line 54
  unusedFunction always 0
  missingInclude always 1
  internalCheck always 2
Line 68
  none always 0
Line 74
  error always 1
Line 80
  warning always 2
Line 87
  style always 3
Line 93
  performance always 4
Line 101
  portability always 5
Line 108
  information always 6
Line 113
  debug always 7
Line 121
  ( possible lifetime[SubObject]=(cweId)
  cweId always !<=-1
  id always !<=-1
  cweId always !<=-1
Line 122
  id always !<=-1
Line 38
  C89 always 0
  C99 always 1
  C11 always 2
  CLatest always 2
  = always 2
  C11 always 2
Line 41
  CPP03 always 0
  CPP11 always 1
  CPP14 always 2
  CPP17 always 3
  CPP20 always 4
  CPP23 always 5
  CPPLatest always 5
  = always 5
  CPP23 always 5
Line 47
  CLatest always 2
  CPPLatest always 5
Line 49
  ( always {!<=-1,!>=2}
Line 50
  = possible size=3
  str possible size=3
Line 51
  str possible size=3
  == always {!<=-1,!>=2}
  "c89" always "c89"
  || always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  "C89" always "C89"
Line 52
  = always 0
  C89 always 0
Line 53
  return always {!<=-1,!>=2}
  true always 1
Line 55
  str possible size=3
  == always {!<=-1,!>=2}
  "c99" always "c99"
  || always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  "C99" always "C99"
Line 56
  = always 1
  C99 always 1
Line 57
  return always {!<=-1,!>=2}
  true always 1
Line 59
  str possible size=3
  == always {!<=-1,!>=2}
  "c11" always "c11"
  || always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  "C11" always "C11"
Line 60
  = always 2
  C11 always 2
Line 61
  return always {!<=-1,!>=2}
  true always 1
Line 63
  return always {!<=-1,!>=2}
  false always 0
Line 67
  C89 always 0
Line 68
  "c89" always "c89"
Line 69
  C99 always 1
Line 70
  "c99" always "c99"
Line 71
  C11 always 2
Line 72
  "c11" always "c11"
Line 74
  "" always ""
Line 77
  std possible size=3
  == always {!<=-1,!>=2}
  "c89" always "c89"
Line 78
  :: always 0
  C89 always 0
Line 80
  std possible size=3
  == always {!<=-1,!>=2}
  "c99" always "c99"
Line 81
  :: always 1
  C99 always 1
Line 83
  == always {!<=-1,!>=2}
  "c11" always "c11"
Line 84
  :: always 2
  C11 always 2
Line 86
  :: always 2
  CLatest always 2
Line 88
  ( always {!<=-1,!>=2}
Line 92
  return always {!<=-1,!>=2}
  ! {!<=-1,!>=2,0}
  stdValue possible size=0
  ( {!<=-1,!>=2,1}
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
Line 99
  CPP03 always 0
Line 100
  "c++03" always "c++03"
Line 101
  CPP11 always 1
Line 102
  "c++11" always "c++11"
Line 103
  CPP14 always 2
Line 104
  "c++14" always "c++14"
Line 105
  CPP17 always 3
Line 106
  "c++17" always "c++17"
Line 107
  CPP20 always 4
Line 108
  "c++20" always "c++20"
Line 109
  CPP23 always 5
Line 110
  "c++23" always "c++23"
Line 112
  "" always ""
Line 115
  std possible size=5
  == always {!<=-1,!>=2}
  "c++03" always "c++03"
Line 116
  :: always 0
  CPP03 always 0
Line 118
  std possible size=5
  == always {!<=-1,!>=2}
  "c++11" always "c++11"
Line 119
  :: always 1
  CPP11 always 1
Line 121
  std possible size=5
  == always {!<=-1,!>=2}
  "c++14" always "c++14"
Line 122
  :: always 2
  CPP14 always 2
Line 124
  std possible size=5
  == always {!<=-1,!>=2}
  "c++17" always "c++17"
Line 125
  :: always 3
  CPP17 always 3
Line 127
  std possible size=5
  == always {!<=-1,!>=2}
  "c++20" always "c++20"
Line 128
  :: always 4
  CPP20 always 4
Line 130
  == always {!<=-1,!>=2}
  "c++23" always "c++23"
Line 131
  :: always 5
  CPP23 always 5
Line 133
  :: always 5
  CPPLatest always 5
Line 58
  OK always 0
  FILE_NOT_FOUND always 1
  BAD_XML always 2
  UNKNOWN_ELEMENT always 3
  MISSING_ATTRIBUTE always 4
  BAD_ATTRIBUTE_VALUE always 5
  UNSUPPORTED_FORMAT always 6
  DUPLICATE_PLATFORM_TYPE always 7
  PLATFORM_TYPE_REDEFINED always 8
Line 62
  :: always 0
  OK always 0
Line 63
  ( possible lifetime[SubObject]=(e)
Line 65
  ( possible lifetime[SubObject]=(e)
  && always {!<=-1,!>=2}
Line 74
  ( always {!<=-1,!>=2}
  , always !<=-1
  len always !<=-1
Line 79
  none always 0
  malloc always 1
  calloc always 2
  strdup always 3
Line 84
  initData always {!<=-1,!>=2}
Line 118
  ? possible 0
  af always !0
  : always 0
  0 always 0
Line 124
  ? possible 0
  af always !0
  : always 0
  0 always 0
Line 138
  , always 1
  = always 1
  1 always 1
Line 141
  = possible 1
  reallocArg possible 1
Line 145
  , always {!<=-1,!>=2}
  noreturn always {!<=-1,!>=2}
Line 146
  = possible {1,0}
  noreturn always {!<=-1,!>=2}
  ? possible {1,0}
  :: always 1
  True always 1
  : always 0
  :: always 0
  False always 0
Line 149
  ( always {!<=-1,!>=2}
Line 152
  ( always {!<=-1,!>=2}
Line 153
  return always {!<=-1,!>=2}
  > always {!<=-1,!>=2}
  0 always 0
  && always {!<=-1,!>=2}
  id {>=1,!<=0}
  & possible {0,1}
  1 always 1
  == {1,0,!<=-1,!>=2}
  0 always 0
Line 155
  ( always {!<=-1,!>=2}
Line 156
  return always {!<=-1,!>=2}
  > always {!<=-1,!>=2}
  0 always 0
  && always {!<=-1,!>=2}
  . {>=1,!<=0}
  & possible {0,1}
  1 always 1
  == {1,0,!<=-1,!>=2}
  0 always 0
Line 160
  ( always {!<=-1,!>=2}
Line 161
  return always {!<=-1,!>=2}
  > always {!<=-1,!>=2}
  0 always 0
  && always {!<=-1,!>=2}
  id {>=1,!<=0}
  & possible {0,1}
  1 always 1
  == {0,1,!<=-1,!>=2}
  1 always 1
Line 163
  ( always {!<=-1,!>=2}
Line 164
  return always {!<=-1,!>=2}
  > always {!<=-1,!>=2}
  0 always 0
  && always {!<=-1,!>=2}
  . {>=1,!<=0}
  & possible {0,1}
  1 always 1
  == {0,1,!<=-1,!>=2}
  1 always 1
Line 167
  ( always {!<=-1,!>=2}
Line 169
  ( always {!<=-1,!>=2}
Line 170
  ( always {!<=-1,!>=2}
Line 190
  ( always {!<=-1,!>=2}
Line 191
  ( always {!<=-1,!>=2}
Line 193
  NONE always 0
  DEFAULT always 1
  ERROR_CODE always 2
Line 201
  ( always {!<=-1,!>=2}
Line 202
  ( always {!<=-1,!>=2}
Line 204
  ( always {!<=-1,!>=2}
Line 209
  -1 always -1
Line 210
  -1 always -1
Line 211
  arrayLike_indexOp always {!<=-1,!>=2}
  false always 0
Line 212
  stdStringLike always {!<=-1,!>=2}
  false always 0
Line 213
  stdAssociativeLike always {!<=-1,!>=2}
  false always 0
Line 214
  opLessAllowed always {!<=-1,!>=2}
  true always 1
Line 215
  hasInitializerListConstructor always {!<=-1,!>=2}
  false always 0
Line 216
  unstableErase always {!<=-1,!>=2}
  false always 0
Line 217
  unstableInsert always {!<=-1,!>=2}
  false always 0
Line 218
  view always {!<=-1,!>=2}
  false always 0
Line 222
  RESIZE always 0
Line 223
  CLEAR always 1
Line 224
  PUSH always 2
Line 225
  POP always 3
Line 226
  FIND always 4
Line 227
  INSERT always 5
Line 228
  ERASE always 6
Line 229
  CHANGE_CONTENT always 7
Line 230
  CHANGE always 8
Line 231
  CHANGE_INTERNAL always 9
Line 232
  NO_ACTION always 10
Line 235
  AT_INDEX always 0
Line 236
  ITEM always 1
Line 237
  BUFFER always 2
Line 238
  BUFFER_NT always 3
Line 239
  START_ITERATOR always 4
Line 240
  END_ITERATOR always 5
Line 241
  ITERATOR always 6
Line 242
  SIZE always 7
Line 243
  EMPTY always 8
Line 244
  NO_YIELD always 9
Line 259
  arrayLike_indexOp always {!<=-1,!>=2}
Line 260
  stdStringLike always {!<=-1,!>=2}
Line 261
  stdAssociativeLike always {!<=-1,!>=2}
Line 262
  opLessAllowed always {!<=-1,!>=2}
Line 263
  hasInitializerListConstructor always {!<=-1,!>=2}
Line 264
  unstableErase always {!<=-1,!>=2}
Line 265
  unstableInsert always {!<=-1,!>=2}
Line 266
  view always {!<=-1,!>=2}
Line 269
  :: possible {symbolic=(functions.end()),end=0}
  i possible {symbolic=(functions.end()),end=0}
  = possible lifetime[Iterator]=(functions)
  ( possible lifetime[Iterator]=(functions)
Line 270
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(functions),end=0}
Line 271
  i always {!symbolic=(functions.end()),!end=0}
Line 272
  :: always 10
  NO_ACTION always 10
Line 276
  :: possible {symbolic=(functions.end()),end=0}
  i possible {symbolic=(functions.end()),end=0}
  = possible lifetime[Iterator]=(functions)
  ( possible lifetime[Iterator]=(functions)
Line 277
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(functions),end=0}
Line 278
  i always {!symbolic=(functions.end()),!end=0}
Line 279
  :: always 9
  NO_YIELD always 9
Line 286
  , always 0
  iterator always {!<=-1,!>=2}
  = always 0
  false always 0
Line 287
  , always 0
  = always 0
  nullptr always 0
Line 292
  notbool always {!<=-1,!>=2}
  false always 0
Line 293
  notnull always {!<=-1,!>=2}
  false always 0
Line 294
  -1 always -1
Line 295
  formatstr always {!<=-1,!>=2}
  false always 0
Line 296
  strz always {!<=-1,!>=2}
  false always 0
Line 297
  optional always {!<=-1,!>=2}
  false always 0
Line 298
  variadic always {!<=-1,!>=2}
  false always 0
Line 302
  notbool always {!<=-1,!>=2}
Line 303
  notnull always {!<=-1,!>=2}
Line 305
  formatstr always {!<=-1,!>=2}
Line 306
  strz always {!<=-1,!>=2}
Line 307
  optional always {!<=-1,!>=2}
Line 308
  variadic always {!<=-1,!>=2}
Line 313
  0 always 0
  it always {!<=-1,!>=2}
  false always 0
  first always {!<=-1,!>=2}
  false always 0
  last always {!<=-1,!>=2}
  false always 0
Line 316
  it always {!<=-1,!>=2}
Line 317
  first always {!<=-1,!>=2}
Line 318
  last always {!<=-1,!>=2}
Line 324
  NONE always 0
  STRLEN always 1
  ARGVALUE always 2
  SIZEOF always 3
  MUL always 4
  VALUE always 5
Line 325
  ( possible lifetime[SubObject]=(t)
  0 always 0
  0 always 0
Line 334
  DIR_IN always 0
Line 335
  DIR_OUT always 1
Line 336
  DIR_INOUT always 2
Line 337
  DIR_UNKNOWN always 3
Line 344
  use always {!<=-1,!>=2}
Line 345
  leakignore always {!<=-1,!>=2}
Line 346
  isconst always {!<=-1,!>=2}
Line 347
  ispure always {!<=-1,!>=2}
Line 349
  ignore always {!<=-1,!>=2}
Line 350
  formatstr always {!<=-1,!>=2}
Line 351
  formatstr_scan always {!<=-1,!>=2}
Line 352
  formatstr_secure always {!<=-1,!>=2}
Line 356
  use always {!<=-1,!>=2}
  false always 0
Line 357
  leakignore always {!<=-1,!>=2}
  false always 0
Line 358
  isconst always {!<=-1,!>=2}
  false always 0
Line 359
  ispure always {!<=-1,!>=2}
  false always 0
Line 360
  :: always 0
  NONE always 0
Line 361
  ignore always {!<=-1,!>=2}
  false always 0
Line 362
  formatstr always {!<=-1,!>=2}
  false always 0
Line 363
  formatstr_scan always {!<=-1,!>=2}
  false always 0
Line 364
  formatstr_secure always {!<=-1,!>=2}
  false always 0
Line 365
  :: always 10
  NO_ACTION always 10
Line 366
  :: always 9
  NO_YIELD always 9
Line 372
  ( always {!<=-1,!>=2}
Line 373
  ( always {!<=-1,!>=2}
Line 374
  ( always {!<=-1,!>=2}
  , always {!<=-1,!>=2}
  pure always {!<=-1,!>=2}
Line 375
  ( always {!<=-1,!>=2}
Line 377
  ( always {!<=-1,!>=2}
Line 379
  return always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  arg always !0
  . always {!<=-1,!>=2}
  notbool always {!<=-1,!>=2}
Line 382
  ( always {!<=-1,!>=2}
Line 383
  ( always {!<=-1,!>=2}
  , always 0
  = always 0
  0 always 0
  , always 0
  = always 0
  nullptr always 0
Line 385
  ( always {!<=-1,!>=2}
Line 387
  return always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  arg always !0
  . always {!<=-1,!>=2}
  formatstr always {!<=-1,!>=2}
Line 390
  ( always {!<=-1,!>=2}
Line 392
  return always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  arg always !0
  . always {!<=-1,!>=2}
  strz always {!<=-1,!>=2}
Line 395
  ( always {!<=-1,!>=2}
Line 396
  ( always {!<=-1,!>=2}
Line 400
  arg always !0
Line 404
  le always 0
  lt always 1
  eq always 2
  ge always 3
  gt always 4
  range always 5
Line 407
  ( always {!<=-1,!>=2}
Line 408
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 414
  && always {!<=-1,!>=2}
  arg always !0
  . always {!<=-1,!>=2}
  it always {!<=-1,!>=2}
  & {lifetime[Address]=(arg->iteratorInfo),!0}
  arg always !0
  nullptr always 0
Line 417
  ( always {!<=-1,!>=2}
Line 421
  ? possible 0
  & {lifetime[Address]=(arg->minsizes),!0}
  arg always !0
  nullptr always 0
Line 426
  ( always {!<=-1,!>=2}
Line 428
  ( always {!<=-1,!>=2}
Line 434
  ( always {!<=-1,!>=2}
Line 436
  ( always {!<=-1,!>=2}
Line 438
  ( always {!<=-1,!>=2}
Line 445
  ( always {!<=-1,!>=2}
Line 447
  ( always {!<=-1,!>=2}
Line 448
  return always {!<=-1,!>=2}
  ( possible lifetime[Iterator]=(mExporters)
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(mExporters),end=0}
Line 451
  ( always {!<=-1,!>=2}
Line 452
  = possible lifetime[Iterator]=(mExporters)
  ( possible lifetime[Iterator]=(mExporters)
Line 453
  return always {!<=-1,!>=2}
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(mExporters),end=0}
  && always {!<=-1,!>=2}
  it always {!symbolic=(mExporters.end()),!end=0}
Line 456
  ( always {!<=-1,!>=2}
Line 457
  = possible lifetime[Iterator]=(mExporters)
  ( possible lifetime[Iterator]=(mExporters)
Line 458
  return always {!<=-1,!>=2}
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(mExporters),end=0}
  && always {!<=-1,!>=2}
  it always {!symbolic=(mExporters.end()),!end=0}
Line 461
  ( always {!<=-1,!>=2}
Line 466
  ( always {!<=-1,!>=2}
Line 467
  return always {!<=-1,!>=2}
  ( possible lifetime[Iterator]=(mReflection)
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(mReflection),end=0}
Line 471
  :: possible {symbolic=(mReflection.end()),end=0}
  it possible {symbolic=(mReflection.end()),end=0}
  = possible lifetime[Iterator]=(mReflection)
  ( possible lifetime[Iterator]=(mReflection)
Line 472
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(mReflection),end=0}
Line 473
  it always {!symbolic=(mReflection.end()),!end=0}
Line 474
  -1 always -1
Line 480
  = always ""
  "" always ""
Line 481
  unique always {!<=-1,!>=2}
  unique always {!<=-1,!>=2}
  = always 0
  false always 0
Line 485
  ( always {!<=-1,!>=2}
Line 489
  size always !<=-1
Line 491
  NO always 0
  BOOL always 1
  CHAR always 2
  SHORT always 3
  INT always 4
  LONG always 5
  LONGLONG always 6
Line 494
  = possible lifetime[Iterator]=(mPodTypes)
  ( possible lifetime[Iterator]=(mPodTypes)
Line 495
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(mPodTypes),end=0}
  & {lifetime[Address]=(it->second),!0}
  it always {!symbolic=(mPodTypes.end()),!end=0}
  nullptr always 0
Line 500
  mSigned always {!<=-1,!>=2}
  false always 0
Line 501
  mUnsigned always {!<=-1,!>=2}
  false always 0
Line 502
  mLong always {!<=-1,!>=2}
  false always 0
Line 503
  mPointer always {!<=-1,!>=2}
  false always 0
Line 504
  mPtrPtr always {!<=-1,!>=2}
  false always 0
Line 505
  mConstPtr always {!<=-1,!>=2}
  false always 0
Line 506
  ( always {!<=-1,!>=2}
Line 507
  return always {!<=-1,!>=2}
  mSigned always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  . always {!<=-1,!>=2}
  mSigned always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 508
  mUnsigned always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  . always {!<=-1,!>=2}
  mUnsigned always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 509
  mLong always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  . always {!<=-1,!>=2}
  mLong always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 510
  mPointer always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  . always {!<=-1,!>=2}
  mPointer always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 511
  mPtrPtr always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  . always {!<=-1,!>=2}
  mPtrPtr always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 512
  mConstPtr always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  . always {!<=-1,!>=2}
  mConstPtr always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 513
  == always {!<=-1,!>=2}
Line 515
  ( always {!<=-1,!>=2}
Line 516
  return always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  this always !0
  == always {!<=-1,!>=2}
Line 519
  mSigned always {!<=-1,!>=2}
Line 520
  mUnsigned always {!<=-1,!>=2}
Line 521
  mLong always {!<=-1,!>=2}
Line 522
  mPointer always {!<=-1,!>=2}
Line 523
  mPtrPtr always {!<=-1,!>=2}
Line 524
  mConstPtr always {!<=-1,!>=2}
Line 529
  = possible lifetime[Iterator]=(mPlatformTypes)
  ( possible lifetime[Iterator]=(mPlatformTypes)
Line 530
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(mPlatformTypes),end=0}
  & {lifetime[Address]=(it->second),!0}
  it always {!symbolic=(mPlatformTypes.end()),!end=0}
  nullptr always 0
Line 536
  :: possible {symbolic=(mPlatforms.end()),end=0}
  it possible {symbolic=(mPlatforms.end()),end=0}
  = possible lifetime[Iterator]=(mPlatforms)
  ( possible lifetime[Iterator]=(mPlatforms)
Line 537
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(mPlatforms),end=0}
Line 538
  it always {!symbolic=(mPlatforms.end()),!end=0}
Line 540
  type always !0
Line 543
  = possible lifetime[Iterator]=(mPlatformTypes)
  ( possible lifetime[Iterator]=(mPlatformTypes)
Line 544
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(mPlatformTypes),end=0}
  & {lifetime[Address]=(it2->second),!0}
  it2 always {!symbolic=(mPlatformTypes.end()),!end=0}
  nullptr always 0
Line 552
  ( always {!<=-1,!>=2}
  , always ""
  = always ""
  "" always ""
Line 555
  def always 0
  check always 1
  suppress always 2
Line 570
  ( always {!<=-1,!>=2}
Line 571
  return always {!<=-1,!>=2}
  ( possible lifetime[Iterator]=(mPrefixes)
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(mPrefixes),end=0}
Line 573
  ( always {!<=-1,!>=2}
Line 574
  return always {!<=-1,!>=2}
  ( possible lifetime[Iterator]=(mSuffixes)
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(mSuffixes),end=0}
Line 583
  0 always 0
Line 606
  ( always {!<=-1,!>=2}
Line 607
  return always {!<=-1,!>=2}
  ( possible lifetime[Iterator]=(mBlocks)
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(mBlocks),end=0}
Line 616
  False always 0
  True always 1
  Maybe always 2
Line 646
  = possible lifetime[Iterator]=(data)
  ( possible lifetime[Iterator]=(data)
Line 647
  == always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(data),end=0}
  nullptr always 0
  & {lifetime[Address]=(it->second),!0}
  it always {!symbolic=(data.end()),!end=0}
Line 655
  = always 0
  nullptr always 0
Line 55
  Public always 0
  Protected always 1
  Private always 2
  Global always 3
  Namespace always 4
  Argument always 5
  Local always 6
  Throw always 7
Line 61
  nullptr always 0
  0 always 0
  known always {!<=-1,!>=2}
  true always 1
Line 65
  known always {!<=-1,!>=2}
Line 75
  Unknown always 0
  True always 1
  False always 2
Line 81
  nullptr always 0
  nullptr always 0
  :: always 0
  Public always 0
  isVirtual always {!<=-1,!>=2}
  false always 0
Line 87
  isVirtual always {!<=-1,!>=2}
Line 89
  ( always {!<=-1,!>=2}
Line 90
  return always {!<=-1,!>=2}
  this always !0
  < always {!<=-1,!>=2}
Line 96
  nullptr always 0
  nullptr always 0
  nullptr always 0
Line 110
  = always 0
  nullptr always 0
  = always 0
  nullptr always 0
  = always 0
  nullptr always 0
Line 111
  classDef_ inconclusive 0
Line 115
  nullptr always 0
Line 116
  nullptr always 0
Line 117
  0 always 0
Line 118
  classDef_ possible 0
  && always {!<=-1,!>=2}
  classDef_ always !0
  == always {!<=-1,!>=2}
  "enum" always "enum"
Line 119
  = always 1
  :: always 1
  True always 1
Line 120
  classDef_ possible 0
  && always {!<=-1,!>=2}
  classDef_ always !0
  == always {!<=-1,!>=2}
  "using" always "using"
Line 121
  3 always 3
Line 123
  && always {!<=-1,!>=2}
  ( always !0
  != always {!<=-1,!>=2}
  ";" always ";"
Line 124
  = always !0
  ( always !0
Line 131
  classDef always !0
Line 134
  ( always {!<=-1,!>=2}
Line 135
  ( always {!<=-1,!>=2}
Line 136
  ( always {!<=-1,!>=2}
Line 137
  ( always {!<=-1,!>=2}
Line 139
  ( always {!<=-1,!>=2}
Line 140
  return always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  classDef always !0
  == always {!<=-1,!>=2}
  "using" always "using"
Line 152
  ( always {!<=-1,!>=2}
  = always 0
  nullptr always 0
Line 159
  ( always {!<=-1,!>=2}
Line 161
  ( always {!<=-1,!>=2}
Line 166
  nullptr always 0
  0 always 0
  nullptr always 0
  nullptr always 0
  value_known always {!<=-1,!>=2}
  false always 0
Line 172
  value_known always {!<=-1,!>=2}
Line 179
  fIsMutable always 1
  = always 1
  1 always 1
  << always 1
  0 always 0
  , always 2
Line 180
  fIsStatic always 2
  = always 2
  1 always 1
  << always 2
  1 always 1
  , always 4
Line 181
  fIsConst always 4
  = always 4
  1 always 1
  << always 4
  2 always 2
  , always 8
Line 182
  fIsExtern always 8
  = always 8
  1 always 1
  << always 8
  3 always 3
  , always 16
Line 183
  fIsClass always 16
  = always 16
  1 always 1
  << always 16
  4 always 4
  , always 32
Line 184
  fIsArray always 32
  = always 32
  1 always 1
  << always 32
  5 always 5
  , always 64
Line 185
  fIsPointer always 64
  = always 64
  1 always 1
  << always 64
  6 always 6
  , always 128
Line 186
  fIsReference always 128
  = always 128
  1 always 1
  << always 128
  7 always 7
  , always 256
Line 187
  fIsRValueRef always 256
  = always 256
  1 always 1
  << always 256
  8 always 8
  , always 512
Line 188
  fHasDefault always 512
  = always 512
  1 always 1
  << always 512
  9 always 9
  , always 1024
Line 189
  fIsStlType always 1024
  = always 1024
  1 always 1
  << always 1024
  10 always 10
  , always 2048
Line 190
  fIsStlString always 2048
  = always 2048
  1 always 1
  << always 2048
  11 always 11
  , always 4096
Line 191
  fIsFloatType always 4096
  = always 4096
  1 always 1
  << always 4096
  12 always 12
  , always 8192
Line 192
  fIsVolatile always 8192
  = always 8192
  1 always 1
  << always 8192
  13 always 13
  , always 16384
Line 193
  fIsSmartPointer always 16384
  = always 16384
  1 always 1
  << always 16384
  14 always 14
  , always 32768
Line 194
  fIsMaybeUnused always 32768
  = always 32768
  1 always 1
  << always 32768
  15 always 15
  , always 65536
Line 195
  fIsInit always 65536
  = always 65536
  1 always 1
  << always 65536
  16 always 16
Line 203
  ( always {!<=-1,!>=2}
  flag_ always !<=-1
Line 204
  return always {!<=-1,!>=2}
  mFlags always !<=-1
  & always !<=-1
  flag_ {!<=-1,32768@118,4096@121,16384@124,2048@125,1024@126,65536@127,512@128,256@129,128@130}
  != always {!<=-1,!>=2}
  0 always 0
Line 212
  flag_ always !<=-1
  state_ always {!<=-1,!>=2}
Line 213
  mFlags always !<=-1
  = always !<=-1
  state_ always {!<=-1,!>=2}
  ? always !<=-1
  mFlags always !<=-1
  | always !<=-1
  flag_ always !<=-1
  : always !<=-1
  mFlags always !<=-1
  & always !<=-1
  ~ always !<=0
  flag_ always !<=-1
Line 222
  ( always {!<=-1,!>=2}
Line 233
  mFlags always !<=-1
  0 always 0
  , possible lifetime[SubObject]=(type_)
Line 234
  ( possible lifetime[SubObject]=(type_)
Line 236
  nullptr always 0
Line 300
  mNameToken always !0
Line 312
  mNameToken always !0
Line 314
  0 always 0
Line 329
  ( always {!<=-1,!>=2}
Line 330
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 0
  Public always 0
Line 337
  ( always {!<=-1,!>=2}
Line 338
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 1
  Protected always 1
Line 345
  ( always {!<=-1,!>=2}
Line 346
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 2
  Private always 2
Line 353
  ( always {!<=-1,!>=2}
Line 354
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 3
  Global always 3
Line 361
  ( always {!<=-1,!>=2}
Line 362
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 4
  Namespace always 4
Line 369
  ( always {!<=-1,!>=2}
Line 370
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 5
  Argument always 5
Line 377
  ( always {!<=-1,!>=2}
Line 378
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 385
  ( always {!<=-1,!>=2}
Line 386
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsMutable always 1
Line 393
  ( always {!<=-1,!>=2}
Line 394
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsVolatile always 8192
Line 401
  ( always {!<=-1,!>=2}
Line 402
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsStatic always 2
Line 409
  ( always {!<=-1,!>=2}
Line 410
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsExtern always 8
Line 417
  ( always {!<=-1,!>=2}
Line 418
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsConst always 4
Line 425
  ( always {!<=-1,!>=2}
Line 426
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 7
  Throw always 7
Line 433
  ( always {!<=-1,!>=2}
Line 434
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsClass always 16
Line 441
  ( always {!<=-1,!>=2}
Line 442
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsArray always 32
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsPointer always 64
Line 449
  ( always {!<=-1,!>=2}
Line 450
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsPointer always 64
Line 457
  ( always {!<=-1,!>=2}
Line 458
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsArray always 32
Line 465
  ( always {!<=-1,!>=2}
Line 471
  ( always {!<=-1,!>=2}
Line 472
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsArray always 32
  || always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsPointer always 64
Line 479
  ( always {!<=-1,!>=2}
Line 480
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsReference always 128
Line 487
  ( always {!<=-1,!>=2}
Line 488
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsRValueRef always 256
Line 495
  ( always {!<=-1,!>=2}
Line 501
  ( always {!<=-1,!>=2}
Line 502
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fHasDefault always 512
Line 509
  ( always {!<=-1,!>=2}
Line 510
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsInit always 65536
Line 526
  ? possible 0
  mType always !0
  : always 0
  nullptr always 0
Line 557
  ( always {!<=-1,!>=2}
Line 558
  return always {!<=-1,!>=2}
  . always {!<=-1,!>=2}
  known always {!<=-1,!>=2}
Line 569
  ( always {!<=-1,!>=2}
Line 570
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsStlType always 1024
Line 581
  ( always {!<=-1,!>=2}
Line 582
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsStlString always 2048
Line 585
  ( always {!<=-1,!>=2}
Line 586
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsSmartPointer always 16384
Line 601
  ( always {!<=-1,!>=2}
Line 602
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  2 always 2
Line 615
  ( always {!<=-1,!>=2}
Line 616
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( possible lifetime[Iterator]=(stlTypes)
  2 always 2
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(stlTypes),end=0}
Line 623
  ( always {!<=-1,!>=2}
Line 624
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsFloatType always 4096
Line 631
  ( always {!<=-1,!>=2}
Line 632
  return always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always !0
  ( always {!<=-1,!>=2}
Line 635
  ( always {!<=-1,!>=2}
Line 636
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsMaybeUnused always 32768
Line 679
  mFlags always !<=-1
Line 702
  fHasBody always 1
  = always 1
  1 always 1
  << always 1
  0 always 0
  , always 2
Line 703
  fIsInline always 2
  = always 2
  1 always 1
  << always 2
  1 always 1
  , always 4
Line 704
  fIsConst always 4
  = always 4
  1 always 1
  << always 4
  2 always 2
  , always 8
Line 705
  fHasVirtualSpecifier always 8
  = always 8
  1 always 1
  << always 8
  3 always 3
  , always 16
Line 706
  fIsPure always 16
  = always 16
  1 always 1
  << always 16
  4 always 4
  , always 32
Line 707
  fIsStatic always 32
  = always 32
  1 always 1
  << always 32
  5 always 5
  , always 64
Line 708
  fIsStaticLocal always 64
  = always 64
  1 always 1
  << always 64
  6 always 6
  , always 128
Line 709
  fIsExtern always 128
  = always 128
  1 always 1
  << always 128
  7 always 7
  , always 256
Line 710
  fIsFriend always 256
  = always 256
  1 always 1
  << always 256
  8 always 8
  , always 512
Line 711
  fIsExplicit always 512
  = always 512
  1 always 1
  << always 512
  9 always 9
  , always 1024
Line 712
  fIsDefault always 1024
  = always 1024
  1 always 1
  << always 1024
  10 always 10
  , always 2048
Line 713
  fIsDelete always 2048
  = always 2048
  1 always 1
  << always 2048
  11 always 11
  , always 4096
Line 714
  fHasOverrideSpecifier always 4096
  = always 4096
  1 always 1
  << always 4096
  12 always 12
  , always 8192
Line 715
  fHasFinalSpecifier always 8192
  = always 8192
  1 always 1
  << always 8192
  13 always 13
  , always 16384
Line 716
  fIsNoExcept always 16384
  = always 16384
  1 always 1
  << always 16384
  14 always 14
  , always 32768
Line 717
  fIsThrow always 32768
  = always 32768
  1 always 1
  << always 32768
  15 always 15
  , always 65536
Line 718
  fIsOperator always 65536
  = always 65536
  1 always 1
  << always 65536
  16 always 16
  , always 131072
Line 719
  fHasLvalRefQual always 131072
  = always 131072
  1 always 1
  << always 131072
  17 always 17
  , always 262144
Line 720
  fHasRvalRefQual always 262144
  = always 262144
  1 always 1
  << always 262144
  18 always 18
  , always 524288
Line 721
  fIsVariadic always 524288
  = always 524288
  1 always 1
  << always 524288
  19 always 19
  , always 1048576
Line 722
  fIsVolatile always 1048576
  = always 1048576
  1 always 1
  << always 1048576
  20 always 20
  , always 2097152
Line 723
  fHasTrailingReturnType always 2097152
  = always 2097152
  1 always 1
  << always 2097152
  21 always 21
  , always 4194304
Line 724
  fIsEscapeFunction always 4194304
  = always 4194304
  1 always 1
  << always 4194304
  22 always 22
  , always 8388608
Line 725
  fIsInlineKeyword always 8388608
  = always 8388608
  1 always 1
  << always 8388608
  23 always 23
  , always 16777216
Line 726
  fIsConstexpr always 16777216
  = always 16777216
  1 always 1
  << always 16777216
  24 always 24
Line 734
  ( always {!<=-1,!>=2}
  flag always !<=-1
Line 735
  return always {!<=-1,!>=2}
  mFlags always !<=-1
  & always !<=-1
  flag {!<=-1,16777216@83,4194304@85,8388608@86,2097152@88,1048576@89,524288@90,262144@91,131072@92,65536@93}
  != always {!<=-1,!>=2}
  0 always 0
Line 743
  flag always !<=-1
  state always {!<=-1,!>=2}
Line 744
  mFlags always !<=-1
  = always !<=-1
  state always {!<=-1,!>=2}
  ? always !<=-1
  mFlags always !<=-1
  | always !<=-1
  flag {!<=-1,8388608@61,2097152@62,1048576@63,524288@64,262144@65,131072@66,65536@67,32768@68,16384@69}
  : always !<=-1
  mFlags always !<=-1
  & always !<=-1
  ~ {!<=0,4286578687@61,4292870143@62,4293918719@63,4294443007@64,4294705151@65,4294836223@66,4294901759@67,4294934527@68,4294950911@69}
  flag {!<=-1,8388608@61,2097152@62,1048576@63,524288@64,262144@65,131072@66,65536@67,32768@68,16384@69}
Line 748
  eConstructor always 0
  eCopyConstructor always 1
  eMoveConstructor always 2
  eOperatorEqual always 3
  eDestructor always 4
  eFunction always 5
  eLambda always 6
Line 760
  ( always !<=-1
Line 763
  ( always !<=-1
  - always !<=-1
Line 772
  ( always {!<=-1,!>=2}
  defaultVal always {!<=-1,!>=2}
  = always 0
  false always 0
Line 777
  = always 0
  nullptr always 0
Line 779
  ( always {!<=-1,!>=2}
Line 780
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  eLambda always 6
Line 783
  ( always {!<=-1,!>=2}
Line 784
  return always {!<=-1,!>=2}
  type possible {1,2}
  == {!<=-1,!>=2,0}
  eConstructor always 0
  || always {!<=-1,!>=2}
Line 785
  type {2,!0}
  == {!<=-1,!>=2,0}
  eCopyConstructor always 1
  || always {!<=-1,!>=2}
Line 786
  type always {!0,!1}
  == always {!<=-1,!>=2}
  eMoveConstructor always 2
Line 789
  ( always {!<=-1,!>=2}
Line 790
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  eDestructor always 4
Line 792
  ( always {!<=-1,!>=2}
Line 793
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 795
  ( always {!<=-1,!>=2}
Line 796
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 798
  ( always {!<=-1,!>=2}
Line 799
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 801
  ( always {!<=-1,!>=2}
Line 802
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 804
  ( always {!<=-1,!>=2}
Line 805
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 807
  ( always {!<=-1,!>=2}
Line 808
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 810
  ( always {!<=-1,!>=2}
Line 811
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 814
  ( always {!<=-1,!>=2}
Line 815
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fHasBody always 1
Line 817
  ( always {!<=-1,!>=2}
Line 818
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsInline always 2
Line 820
  ( always {!<=-1,!>=2}
Line 821
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsConst always 4
Line 823
  ( always {!<=-1,!>=2}
Line 824
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fHasVirtualSpecifier always 8
Line 826
  ( always {!<=-1,!>=2}
Line 827
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsPure always 16
Line 829
  ( always {!<=-1,!>=2}
Line 830
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsStatic always 32
Line 832
  ( always {!<=-1,!>=2}
Line 833
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsStaticLocal always 64
Line 835
  ( always {!<=-1,!>=2}
Line 836
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsExtern always 128
Line 838
  ( always {!<=-1,!>=2}
Line 839
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsFriend always 256
Line 841
  ( always {!<=-1,!>=2}
Line 842
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsExplicit always 512
Line 844
  ( always {!<=-1,!>=2}
Line 845
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsDefault always 1024
Line 847
  ( always {!<=-1,!>=2}
Line 848
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsDelete always 2048
Line 850
  ( always {!<=-1,!>=2}
Line 851
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsNoExcept always 16384
Line 853
  ( always {!<=-1,!>=2}
Line 854
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsThrow always 32768
Line 856
  ( always {!<=-1,!>=2}
Line 857
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fHasOverrideSpecifier always 4096
Line 859
  ( always {!<=-1,!>=2}
Line 860
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fHasFinalSpecifier always 8192
Line 862
  ( always {!<=-1,!>=2}
Line 863
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsOperator always 65536
Line 865
  ( always {!<=-1,!>=2}
Line 866
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fHasLvalRefQual always 131072
Line 868
  ( always {!<=-1,!>=2}
Line 869
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fHasRvalRefQual always 262144
Line 871
  ( always {!<=-1,!>=2}
Line 872
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsVariadic always 524288
Line 874
  ( always {!<=-1,!>=2}
Line 875
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsVolatile always 1048576
Line 877
  ( always {!<=-1,!>=2}
Line 878
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fHasTrailingReturnType always 2097152
Line 880
  state always {!<=-1,!>=2}
Line 881
  fHasBody always 1
  state always {!<=-1,!>=2}
Line 883
  ( always {!<=-1,!>=2}
Line 884
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsInlineKeyword always 8388608
Line 887
  ( always {!<=-1,!>=2}
Line 888
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsEscapeFunction always 4194304
Line 890
  state always {!<=-1,!>=2}
Line 891
  fIsEscapeFunction always 4194304
  state always {!<=-1,!>=2}
Line 894
  ( always {!<=-1,!>=2}
Line 895
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsConstexpr always 16777216
Line 897
  state always {!<=-1,!>=2}
Line 898
  fIsConstexpr always 16777216
  state always {!<=-1,!>=2}
Line 900
  ( always {!<=-1,!>=2}
Line 919
  ( always {!<=-1,!>=2}
Line 921
  ( always {!<=-1,!>=2}
  , always 0
  unknown always {!<=-1,!>=2}
  = always 0
  false always 0
Line 923
  ( always {!<=-1,!>=2}
  , always 0
  unknown always {!<=-1,!>=2}
  = always 0
  false always 0
Line 925
  ( always {!<=-1,!>=2}
  , always 0
  unknown always {!<=-1,!>=2}
  = always 0
  false always 0
Line 930
  this always !0
  ( always {!<=-1,!>=2}
Line 931
  "{|;" always "{|;"
Line 947
  mFlags always !<=-1
Line 949
  state always {!<=-1,!>=2}
Line 950
  fIsInline always 2
  state always {!<=-1,!>=2}
Line 952
  state always {!<=-1,!>=2}
Line 953
  fIsConst always 4
  state always {!<=-1,!>=2}
Line 955
  state always {!<=-1,!>=2}
Line 956
  fHasVirtualSpecifier always 8
  state always {!<=-1,!>=2}
Line 958
  state always {!<=-1,!>=2}
Line 959
  fIsPure always 16
  state always {!<=-1,!>=2}
Line 961
  state always {!<=-1,!>=2}
Line 962
  fIsStatic always 32
  state always {!<=-1,!>=2}
Line 964
  state always {!<=-1,!>=2}
Line 965
  fIsStaticLocal always 64
  state always {!<=-1,!>=2}
Line 967
  state always {!<=-1,!>=2}
Line 968
  fIsExtern always 128
  state always {!<=-1,!>=2}
Line 970
  state always {!<=-1,!>=2}
Line 971
  fIsFriend always 256
  state always {!<=-1,!>=2}
Line 973
  state always {!<=-1,!>=2}
Line 974
  fIsExplicit always 512
  state always {!<=-1,!>=2}
Line 976
  state always {!<=-1,!>=2}
Line 977
  fIsDefault always 1024
  state always {!<=-1,!>=2}
Line 979
  state always {!<=-1,!>=2}
Line 980
  fIsDelete always 2048
  state always {!<=-1,!>=2}
Line 982
  state always {!<=-1,!>=2}
Line 983
  fIsNoExcept always 16384
  state always {!<=-1,!>=2}
Line 985
  state always {!<=-1,!>=2}
Line 986
  fIsThrow always 32768
  state always {!<=-1,!>=2}
Line 988
  state always {!<=-1,!>=2}
Line 989
  fIsOperator always 65536
  state always {!<=-1,!>=2}
Line 991
  state always {!<=-1,!>=2}
Line 992
  fHasLvalRefQual always 131072
  state always {!<=-1,!>=2}
Line 994
  state always {!<=-1,!>=2}
Line 995
  fHasRvalRefQual always 262144
  state always {!<=-1,!>=2}
Line 997
  state always {!<=-1,!>=2}
Line 998
  fIsVariadic always 524288
  state always {!<=-1,!>=2}
Line 1000
  state always {!<=-1,!>=2}
Line 1001
  fIsVolatile always 1048576
  state always {!<=-1,!>=2}
Line 1003
  state always {!<=-1,!>=2}
Line 1004
  fHasTrailingReturnType always 2097152
  state always {!<=-1,!>=2}
Line 1006
  state always {!<=-1,!>=2}
Line 1007
  fIsInlineKeyword always 8388608
  state always {!<=-1,!>=2}
Line 1022
  eGlobal always 0
  eClass always 1
  eStruct always 2
  eUnion always 3
  eNamespace always 4
  eFunction always 5
  eIf always 6
  eElse always 7
  eFor always 8
  eWhile always 9
  eDo always 10
  eSwitch always 11
  eUnconditional always 12
  eTry always 13
  eCatch always 14
  eLambda always 15
  eEnum always 16
Line 1051
  enumClass always {!<=-1,!>=2}
Line 1056
  = possible 0
  start possible 0
Line 1057
  = possible 0
  start possible 0
  ? possible 0
  start always !0
  : always 0
  nullptr always 0
Line 1059
  bodyStartList possible lifetime[Object]=(start)
  start always !0
Line 1062
  ( always {!<=-1,!>=2}
Line 1064
  return always {!<=-1,!>=2}
  ( always !<=-1
  > always {!<=-1,!>=2}
  9 always 9
  && always {!<=-1,!>=2}
  className {>=size=10,!<=size=9}
  0 always 0
  9 always 9
  "Anonymous" always "Anonymous"
  == always {!<=-1,!>=2}
  0 always 0
  && always {!<=-1,!>=2}
  9 always 9
Line 1069
  == always {!<=-1,!>=2}
Line 1070
  & {lifetime[Address]=(enumeratorList),!0}
Line 1072
  nullptr always 0
Line 1075
  ( always {!<=-1,!>=2}
Line 1076
  ! always {!<=-1,!>=2}
  outer possible symbolic=(this)
Line 1077
  return always {!<=-1,!>=2}
  false always 0
Line 1078
  outer always !0
  == always {!<=-1,!>=2}
  this always !0
Line 1079
  return always {!<=-1,!>=2}
  true always 1
Line 1081
  outer {symbolic=(parent),!symbolic=(this),!0}
  != {!<=-1,!>=2,0,1}
  parent possible {symbolic=(nestedIn),symbolic=(outer),0}
  && {!<=-1,!>=2,0}
  parent {symbolic=(nestedIn),!symbolic=(outer),0}
Line 1082
  parent {symbolic=(nestedIn),!symbolic=(outer),!0}
Line 1083
  parent possible {symbolic=(nestedIn),symbolic=(outer),0}
  && always {!<=-1,!>=2}
  parent always !0
  == always {!<=-1,!>=2}
  outer always {!symbolic=(this),!0}
Line 1084
  return always {!<=-1,!>=2}
  true always 1
Line 1085
  return always {!<=-1,!>=2}
  false always 0
Line 1090
  scope always !0
  == always {!<=-1,!>=2}
  :: always 5
  eFunction always 5
Line 1092
  scope always !0
Line 1094
  ! {!<=-1,!>=2,1}
  scope possible 0
Line 1095
  nullptr always 0
Line 1096
  scope always !0
Line 1099
  ( always {!<=-1,!>=2}
Line 1100
  return always {!<=-1,!>=2}
  type possible 2
  == {!<=-1,!>=2,0}
  eClass always 1
  || always {!<=-1,!>=2}
  type always !1
  == always {!<=-1,!>=2}
  eStruct always 2
Line 1103
  ( always {!<=-1,!>=2}
Line 1104
  return always {!<=-1,!>=2}
  type possible {2,3}
  == {!<=-1,!>=2,0}
  eClass always 1
  || always {!<=-1,!>=2}
  type {3,!1}
  == {!<=-1,!>=2,0}
  eStruct always 2
  || always {!<=-1,!>=2}
  type always {!1,!2}
  == always {!<=-1,!>=2}
  eUnion always 3
Line 1107
  ( always {!<=-1,!>=2}
Line 1108
  return always {!<=-1,!>=2}
  type possible {2,3,0,4,16}
  != {!<=-1,!>=2,1}
  eClass always 1
  && always {!<=-1,!>=2}
  type {3,0,4,16,!1}
  != {!<=-1,!>=2,1}
  eStruct always 2
  && always {!<=-1,!>=2}
  type {0,4,16,!1,!2}
  != {!<=-1,!>=2,1}
  eUnion always 3
  && always {!<=-1,!>=2}
  type {4,16,!2,!3}
  != {!<=-1,!>=2,1}
  eGlobal always 0
  && always {!<=-1,!>=2}
  type {16,!3,!0}
  != {!<=-1,!>=2,1}
  eNamespace always 4
  && always {!<=-1,!>=2}
  type always {!0,!4}
  != always {!<=-1,!>=2}
  eEnum always 16
Line 1111
  ( always {!<=-1,!>=2}
Line 1112
  return always {!<=-1,!>=2}
  type possible {9,10}
  == {!<=-1,!>=2,0}
  :: always 8
  eFor always 8
  || always {!<=-1,!>=2}
  type {10,!8}
  == {!<=-1,!>=2,0}
  :: always 9
  eWhile always 9
  || always {!<=-1,!>=2}
  type always {!8,!9}
  == always {!<=-1,!>=2}
  :: always 10
  eDo always 10
Line 1115
  ( always {!<=-1,!>=2}
Line 1116
  return always {!<=-1,!>=2}
  type possible {7,8,9,10,11,12,13,14}
  == {!<=-1,!>=2,0}
  eIf always 6
  || always {!<=-1,!>=2}
  type {8,9,10,11,12,13,14,!6}
  == {!<=-1,!>=2,0}
  eElse always 7
  || always {!<=-1,!>=2}
Line 1117
  type {9,10,11,12,13,14,!6,!7}
  == {!<=-1,!>=2,0}
  eFor always 8
  || always {!<=-1,!>=2}
  type {10,11,12,13,14,!7,!8}
  == {!<=-1,!>=2,0}
  eWhile always 9
  || always {!<=-1,!>=2}
  type {11,12,13,14,!8,!9}
  == {!<=-1,!>=2,0}
  eDo always 10
  || always {!<=-1,!>=2}
Line 1118
  type {12,13,14,!9,!10}
  == {!<=-1,!>=2,0}
  eSwitch always 11
  || always {!<=-1,!>=2}
  type {13,14,!10,!11}
  == {!<=-1,!>=2,0}
  eUnconditional always 12
  || always {!<=-1,!>=2}
Line 1119
  type {14,!11,!12}
  == {!<=-1,!>=2,0}
  eTry always 13
  || always {!<=-1,!>=2}
  type always {!12,!13}
  == always {!<=-1,!>=2}
  eCatch always 14
Line 1123
  ( always {!<=-1,!>=2}
Line 1131
  , always 0
  requireConst always {!<=-1,!>=2}
  = always 0
  false always 0
Line 1133
  , always 0
  isC always {!<=-1,!>=2}
  = always 0
  false always 0
Line 1135
  ( always !0
  this always !0
Line 1140
  ( always !0
  this always !0
Line 1159
  functionList possible lifetime[Object]=(func)
Line 1161
  = {lifetime[Object]=(functionList),!0}
  & {lifetime[Object]=(functionList),!0}
  functionList {lifetime[Object]=(func),!size=0}
Line 1163
  ( possible lifetime[Iterator]=(functionMap)
  back {lifetime[Object]=(functionList),symbolic=(&functionList.back()),!0}
  back {lifetime[Object]=(functionList),symbolic=(&functionList.back()),!0}
Line 1166
  ( always {!<=-1,!>=2}
Line 1186
  , always {!<=-1,!>=2}
  isCpp always {!<=-1,!>=2}
Line 1200
  ( always {!<=-1,!>=2}
  & {lifetime[Address]=(vartok),!0}
  & {lifetime[Address]=(typetok),!0}
Line 1209
  None always 0
Line 1210
  LValue always 1
Line 1211
  RValue always 2
Line 1217
  UNKNOWN_SIGN always 0
  SIGNED always 1
  UNSIGNED always 2
Line 1219
  UNKNOWN_TYPE always 0
Line 1220
  POD always 1
Line 1221
  NONSTD always 2
Line 1222
  RECORD always 3
Line 1223
  SMART_POINTER always 4
Line 1224
  CONTAINER always 5
Line 1225
  ITERATOR always 6
Line 1226
  VOID always 7
Line 1227
  BOOL always 8
Line 1228
  CHAR always 9
Line 1229
  SHORT always 10
Line 1230
  WCHAR_T always 11
Line 1231
  INT always 12
Line 1232
  LONG always 13
Line 1233
  LONGLONG always 14
Line 1234
  UNKNOWN_INT always 15
Line 1235
  FLOAT always 16
Line 1236
  DOUBLE always 17
Line 1237
  LONGDOUBLE always 18
Line 1242
  = always 0
  :: always 0
  None always 0
Line 1256
  UNKNOWN_SIGN always 0
Line 1257
  UNKNOWN_TYPE always 0
Line 1258
  0 always 0
Line 1259
  0U always 0
Line 1260
  0U always 0
Line 1261
  nullptr always 0
Line 1262
  nullptr always 0
Line 1263
  nullptr always 0
Line 1264
  nullptr always 0
Line 1265
  nullptr always 0
Line 1266
  nullptr always 0
Line 1268
  ( possible lifetime[SubObject]=(s)
Line 1271
  0 always 0
Line 1273
  0U always 0
Line 1274
  nullptr always 0
Line 1275
  nullptr always 0
Line 1276
  nullptr always 0
Line 1277
  nullptr always 0
Line 1278
  nullptr always 0
Line 1279
  nullptr always 0
Line 1281
  ( possible lifetime[SubObject]=(s)
Line 1284
  0 always 0
Line 1287
  nullptr always 0
Line 1288
  nullptr always 0
Line 1289
  nullptr always 0
Line 1290
  nullptr always 0
Line 1291
  nullptr always 0
Line 1292
  nullptr always 0
Line 1294
  ( possible lifetime[SubObject]=(s)
Line 1297
  0 always 0
Line 1300
  nullptr always 0
Line 1301
  nullptr always 0
Line 1302
  nullptr always 0
Line 1303
  nullptr always 0
Line 1304
  nullptr always 0
Line 1305
  nullptr always 0
Line 1311
  , always {!<=-1,!>=2}
  longType always {!<=-1,!>=2}
Line 1313
  UNKNOWN always 0
  SAME always 1
  FALLBACK1 always 2
  FALLBACK2 always 3
  NOMATCH always 4
Line 1317
  ( always {!<=-1,!>=2}
Line 1318
  return always {!<=-1,!>=2}
  >= always {!<=-1,!>=2}
  :: always 8
  BOOL always 8
Line 1321
  ( always {!<=-1,!>=2}
Line 1322
  return always {!<=-1,!>=2}
  type possible {<=15,>=16}
  >= {!<=-1,!>=2,<=1}
  :: always 8
  BOOL always 8
  && always {!<=-1,!>=2}
  type {>=8,!<=7}
  <= {!<=-1,!>=2,>=1}
  :: always 15
  UNKNOWN_INT always 15
Line 1325
  ( always {!<=-1,!>=2}
Line 1326
  return always {!<=-1,!>=2}
  type possible {<=18,>=19}
  >= {!<=-1,!>=2,<=1}
  :: always 16
  FLOAT always 16
  && always {!<=-1,!>=2}
  type {>=16,!<=15}
  <= {!<=-1,!>=2,>=1}
  :: always 18
  LONGDOUBLE always 18
Line 1329
  ( always {!<=-1,!>=2}
Line 1331
  ( always {!<=-1,!>=2}
Line 1332
  return always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  typeScope always !0
  == always {!<=-1,!>=2}
  :: always 16
  eEnum always 16
Line 1335
  , always 0
  p always {!<=-1,!>=2}
  = always 0
  false always 0
Line 1338
  ( always {!<=-1,!>=2}
Line 1381
  , always 0
  lookOutside always {!<=-1,!>=2}
  = always 0
  false always 0
Line 1382
  , always 0
  lookOutside always {!<=-1,!>=2}
  = always 0
  false always 0
Line 1383
  this always !0
  lookOutside always {!<=-1,!>=2}
Line 1388
  this always !0
Line 1391
  ( always {!<=-1,!>=2}
Line 1392
  return always {!<=-1,!>=2}
  < always {!<=-1,!>=2}
  ( always !<=-1
Line 1408
  = always 0
  nullptr always 0
Line 1412
  ( always {!<=-1,!>=2}
Line 1426
  reportDebugWarnings always {!<=-1,!>=2}
  = always 0
  nullptr always 0
Line 1456
  firstPass always {!<=-1,!>=2}
Line 1467
  & {lifetime[Address]=(scope),!0}
Line 1468
  & {lifetime[Address]=(scope),!0}
  & {lifetime[Address]=(tok),!0}
Line 1470
  ( always {!<=-1,!>=2}
Line 1482
  ( always {!<=-1,!>=2}
Line 1500
  mIsCpp always {!<=-1,!>=2}
Line 40
  none always 0
Line 41
  op1 always 1
Line 42
  op2 always 2
Line 43
  op1_and_op2 always 3
Line 44
  done always 4
Line 53
  ! always {!<=-1,!>=2}
Line 57
  = always !0
  ast always !0
Line 59
  tok inconclusive symbolic=(ast)
Line 61
  c possible {2,3,1}
  == {!<=-1,!>=2,0}
  :: always 4
  done always 4
Line 63
  c {3,1,!4}
  == {!<=-1,!>=2,0}
  :: always 2
  op2 always 2
  || {!<=-1,!>=2,1}
  c {1,3,!4,!2}
  == {!<=-1,!>=2,0,1}
  :: always 3
  op1_and_op2 always 3
Line 66
  t2 always !0
Line 68
  c {3,!4,2}
  == {!<=-1,!>=2,0}
  :: always 1
  op1 always 1
  || {!<=-1,!>=2,1}
  c {!4,2,3,!1}
  == {!<=-1,!>=2,0,1}
  :: always 3
  op1_and_op2 always 3
Line 71
  t1 always !0
Line 74
  ( always {!<=-1,!>=2}
Line 77
  tokens always !size=0
Line 78
  tokens always !size=0
Line 79
  true always 1
Line 82
  ( always {!<=-1,!>=2}
Line 86
  ( always {!<=-1,!>=2}
Line 92
  , always 100
  = always 100
  100 always 100
Line 94
  ( always {!<=-1,!>=2}
Line 96
  ( always {!<=-1,!>=2}
Line 98
  ( always {!<=-1,!>=2}
Line 100
  ( always {!<=-1,!>=2}
Line 102
  ( always {!<=-1,!>=2}
Line 104
  ( always {!<=-1,!>=2}
Line 106
  ( always {!<=-1,!>=2}
  , always {!<=-1,!>=2}
  unknown always {!<=-1,!>=2}
Line 107
  ( always {!<=-1,!>=2}
Line 109
  ( always {!<=-1,!>=2}
  , always {!<=-1,!>=2}
  unknown always {!<=-1,!>=2}
Line 111
  ( always {!<=-1,!>=2}
Line 113
  ( always {!<=-1,!>=2}
Line 115
  ( always {!<=-1,!>=2}
Line 116
  ( always {!<=-1,!>=2}
Line 118
  ( always {!<=-1,!>=2}
Line 120
  ( always {!<=-1,!>=2}
Line 122
  ( always {!<=-1,!>=2}
Line 123
  ( always {!<=-1,!>=2}
Line 137
  , always 0
  = always 0
  nullptr always 0
Line 139
  ( always {!<=-1,!>=2}
Line 141
  ( always {!<=-1,!>=2}
  cpp always {!<=-1,!>=2}
  , always 0
  unknown always {!<=-1,!>=2}
  = always 0
  false always 0
Line 155
  cpp always {!<=-1,!>=2}
Line 157
  ( always {!<=-1,!>=2}
Line 158
  ( always {!<=-1,!>=2}
Line 179
  ( always {!<=-1,!>=2}
Line 187
  ( always {!<=-1,!>=2}
Line 188
  ( always {!<=-1,!>=2}
Line 190
  ( always {!<=-1,!>=2}
  , always 1
  onVar always {!<=-1,!>=2}
  = always 1
  true always 1
  , always 0
  = always 0
  0 always 0
Line 198
  temporary always {!<=-1,!>=2}
  = always 1
  true always 1
Line 199
  inconclusive always {!<=-1,!>=2}
  = always 1
  true always 1
Line 201
  = always 20
  20 always 20
Line 202
  , always 0
  = always 0
  nullptr always 0
Line 204
  ( always {!<=-1,!>=2}
  cpp always {!<=-1,!>=2}
  macro always {!<=-1,!>=2}
  , always {!<=-1,!>=2}
  pure always {!<=-1,!>=2}
  , always {!<=-1,!>=2}
  followVar always {!<=-1,!>=2}
  , always 0
  = always 0
  nullptr always 0
Line 206
  ( always {!<=-1,!>=2}
Line 211
  ( always {!<=-1,!>=2}
Line 222
  ( always {!<=-1,!>=2}
  isNot always {!<=-1,!>=2}
  cpp always {!<=-1,!>=2}
  , always {!<=-1,!>=2}
  pure always {!<=-1,!>=2}
  , always {!<=-1,!>=2}
  followVar always {!<=-1,!>=2}
  , always 0
  = always 0
  nullptr always 0
Line 224
  ( always {!<=-1,!>=2}
  cpp always {!<=-1,!>=2}
  , always {!<=-1,!>=2}
  pure always {!<=-1,!>=2}
  , always {!<=-1,!>=2}
  followVar always {!<=-1,!>=2}
  , always 0
  = always 0
  nullptr always 0
Line 226
  ( always {!<=-1,!>=2}
Line 228
  ( always {!<=-1,!>=2}
  , always {!<=-1,!>=2}
  pure always {!<=-1,!>=2}
  , always {!<=-1,!>=2}
  cpp always {!<=-1,!>=2}
Line 230
  ( always {!<=-1,!>=2}
  cpp always {!<=-1,!>=2}
  , always 0
  checkArrayAccess always {!<=-1,!>=2}
  = always 0
  false always 0
  , always 1
  checkReference always {!<=-1,!>=2}
  = always 1
  true always 1
Line 232
  ( always {!<=-1,!>=2}
Line 234
  ( always {!<=-1,!>=2}
Line 237
  ( always {!<=-1,!>=2}
  , always 0
Line 238
  = always 0
  nullptr always 0
  , always 0
Line 239
  = always 0
  nullptr always 0
  , always 0
Line 240
  functionScope always {!<=-1,!>=2}
  = always 0
  false always 0
Line 243
  ( always {!<=-1,!>=2}
Line 262
  ( always {!<=-1,!>=2}
Line 272
  ( always {!<=-1,!>=2}
Line 275
  ( always {!<=-1,!>=2}
  , always {!<=-1,!>=2}
  globalvar always {!<=-1,!>=2}
  , always {!<=-1,!>=2}
  cpp always {!<=-1,!>=2}
  , always 20
  = always 20
  20 always 20
Line 276
  ( always {!<=-1,!>=2}
  , always {!<=-1,!>=2}
  globalvar always {!<=-1,!>=2}
  , always {!<=-1,!>=2}
  cpp always {!<=-1,!>=2}
  , always 20
  = always 20
  20 always 20
Line 278
  ( always {!<=-1,!>=2}
  , always {!<=-1,!>=2}
  cpp always {!<=-1,!>=2}
  , always 20
  = always 20
  20 always 20
Line 280
  ( always {!<=-1,!>=2}
  , always {!<=-1,!>=2}
  cpp always {!<=-1,!>=2}
  , always 20
  = always 20
  20 always 20
Line 282
  ( always {!<=-1,!>=2}
Line 286
  , always {!<=-1,!>=2}
Line 287
  cpp always {!<=-1,!>=2}
Line 289
  ( always {!<=-1,!>=2}
  , always {!<=-1,!>=2}
  cpp always {!<=-1,!>=2}
Line 290
  ( always {!<=-1,!>=2}
  , always {!<=-1,!>=2}
  cpp always {!<=-1,!>=2}
Line 292
  , always {!<=-1,!>=2}
  globalvar always {!<=-1,!>=2}
  , always {!<=-1,!>=2}
  cpp always {!<=-1,!>=2}
  , always 20
  = always 20
  20 always 20
Line 293
  , always {!<=-1,!>=2}
  globalvar always {!<=-1,!>=2}
  , always {!<=-1,!>=2}
  cpp always {!<=-1,!>=2}
  , always 20
  = always 20
  20 always 20
Line 295
  ( always {!<=-1,!>=2}
Line 298
  , always {!<=-1,!>=2}
Line 299
  cpp always {!<=-1,!>=2}
  , always 20
Line 300
  = always 20
  20 always 20
Line 302
  ( always {!<=-1,!>=2}
Line 304
  , always {!<=-1,!>=2}
Line 305
  globalvar always {!<=-1,!>=2}
Line 306
  , always {!<=-1,!>=2}
Line 307
  cpp always {!<=-1,!>=2}
  , always 20
Line 308
  = always 20
  20 always 20
Line 311
  ( always {!<=-1,!>=2}
  , always 0
  = always 0
  nullptr always 0
Line 313
  ( always {!<=-1,!>=2}
Line 336
  ( always {!<=-1,!>=2}
Line 348
  ( always {!<=-1,!>=2}
  cpp always {!<=-1,!>=2}
Line 355
  ( always {!<=-1,!>=2}
  cpp always {!<=-1,!>=2}
Line 357
  ( always {!<=-1,!>=2}
Line 359
  ( always {!<=-1,!>=2}
  , always 0
  = always 0
  nullptr always 0
Line 370
  ( always {!<=-1,!>=2}
Line 372
  ( always {!<=-1,!>=2}
Line 374
  ( always {!<=-1,!>=2}
  , always {!<=-1,!>=2}
  cpp always {!<=-1,!>=2}
Line 383
  ( possible lifetime[SubObject]=(cpp)
  cpp always {!<=-1,!>=2}
  mCpp always {!<=-1,!>=2}
  cpp always {!<=-1,!>=2}
  mValueFlowKnown always {!<=-1,!>=2}
  true always 1
Line 385
  ( always {!<=-1,!>=2}
Line 403
  ( always {!<=-1,!>=2}
Line 406
  known always {!<=-1,!>=2}
Line 411
  ( always {!<=-1,!>=2}
Line 413
  = always 0
  nullptr always 0
  = always 0
  nullptr always 0
Line 415
  ( always {!<=-1,!>=2}
Line 419
  NONE always 0
  READ always 1
  WRITE always 2
  BREAK always 3
  RETURN always 4
  BAILOUT always 5
Line 420
  ( possible lifetime[SubObject]=(type)
  nullptr always 0
Line 421
  ( possible lifetime[SubObject]=(type)
Line 426
  , always {!<=-1,!>=2}
  local always {!<=-1,!>=2}
  , always {!<=-1,!>=2}
  inInnerClass always {!<=-1,!>=2}
  , always 0
  = always 0
  0 always 0
Line 429
  ( always {!<=-1,!>=2}
Line 431
  mCpp always {!<=-1,!>=2}
Line 433
  Reassign always 0
  UnusedValue always 1
  ValueFlow always 2
Line 435
  mValueFlowKnown always {!<=-1,!>=2}
Line 438
  ( always {!<=-1,!>=2}
Line 42
  hash always !<=-1
Line 56
  NO_LINE always -1
  hash always !<=-1
  0 always 0
  thisAndNextLine always {!<=-1,!>=2}
  false always 0
  matched always {!<=-1,!>=2}
  false always 0
  checked always {!<=-1,!>=2}
  false always 0
Line 58
  this always !0
Line 60
  = always -1
  NO_LINE always -1
  hash always !<=-1
  0 always 0
  thisAndNextLine always {!<=-1,!>=2}
  false always 0
  matched always {!<=-1,!>=2}
  false always 0
  checked always {!<=-1,!>=2}
  false always 0
Line 67
  hash always !<=-1
  = always !<=-1
  . always !<=-1
  hash always !<=-1
Line 68
  thisAndNextLine always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  . always {!<=-1,!>=2}
  thisAndNextLine always {!<=-1,!>=2}
Line 69
  matched always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  . always {!<=-1,!>=2}
  matched always {!<=-1,!>=2}
Line 70
  checked always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  . always {!<=-1,!>=2}
  checked always {!<=-1,!>=2}
Line 71
  this always !0
Line 74
  ( always {!<=-1,!>=2}
Line 75
  != always {!<=-1,!>=2}
Line 76
  return always {!<=-1,!>=2}
  errorId always !symbolic=(other.errorId)
  < always {!<=-1,!>=2}
  . always !symbolic=(errorId)
Line 77
  < always {!<=-1,!>=2}
Line 78
  return always {!<=-1,!>=2}
  true always 1
Line 79
  != always {!<=-1,!>=2}
Line 80
  return always {!<=-1,!>=2}
  fileName always !symbolic=(other.fileName)
  < always {!<=-1,!>=2}
  . always !symbolic=(fileName)
Line 81
  != always {!<=-1,!>=2}
Line 82
  return always {!<=-1,!>=2}
  symbolName always !symbolic=(other.symbolName)
  < always {!<=-1,!>=2}
  . always !symbolic=(symbolName)
Line 83
  hash always !<=-1
  != always {!<=-1,!>=2}
  . always !<=-1
  hash always !<=-1
Line 84
  return always {!<=-1,!>=2}
  hash always {!<=-1,!symbolic=(other.hash)}
  < always {!<=-1,!>=2}
  . always {!<=-1,!symbolic=(hash)}
  hash always !<=-1
Line 85
  thisAndNextLine always {!<=-1,!>=2}
  != always {!<=-1,!>=2}
  . always {!<=-1,!>=2}
  thisAndNextLine always {!<=-1,!>=2}
Line 86
  return always {!<=-1,!>=2}
  thisAndNextLine always {!<=-1,!>=2,!symbolic=(other.thisAndNextLine)}
Line 87
  return always {!<=-1,!>=2}
  false always 0
Line 96
  ( always {!<=-1,!>=2}
Line 98
  ( always {!<=-1,!>=2}
Line 100
  ( always {!<=-1,!>=2}
Line 104
  ( always {!<=-1,!>=2}
Line 105
  return always {!<=-1,!>=2}
  ! {!<=-1,!>=2,0}
  fileName possible size=0
  ( {!<=-1,!>=2,1}
  && always {!<=-1,!>=2}
  fileName always !size=0
  ( always !<=-1
  "?*" always "?*"
  == always {!<=-1,!>=2}
Line 108
  ( always {!<=-1,!>=2}
Line 109
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 110
  == always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 111
  == always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 112
  == always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 113
  hash always !<=-1
  == always {!<=-1,!>=2}
  . always !<=-1
  hash always !<=-1
  && always {!<=-1,!>=2}
Line 114
  thisAndNextLine always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  . always {!<=-1,!>=2}
  thisAndNextLine always {!<=-1,!>=2}
Line 121
  hash always !<=-1
Line 122
  thisAndNextLine always {!<=-1,!>=2}
Line 123
  matched always {!<=-1,!>=2}
Line 124
  checked always {!<=-1,!>=2}
Line 126
  NO_LINE always -1
  = always -1
  -1 always -1
Line 178
  ( always {!<=-1,!>=2}
Line 185
  ( always {!<=-1,!>=2}
Line 197
  unusedFunctionChecking always {!<=-1,!>=2}
Line 203
  unusedFunctionChecking always {!<=-1,!>=2}
Line 28
  Reset always 0
  = always 0
  0 always 0
  , always 1
Line 29
  Bold always 1
  = always 1
  1 always 1
  , always 2
Line 30
  Dim always 2
  = always 2
  2 always 2
  , always 31
Line 31
  FgRed always 31
  = always 31
  31 always 31
  , always 32
Line 32
  FgGreen always 32
  = always 32
  32 always 32
  , always 34
Line 33
  FgBlue always 34
  = always 34
  34 always 34
  , always 35
Line 34
  FgMagenta always 35
  = always 35
  35 always 35
  , always 39
Line 35
  FgDefault always 39
  = always 39
  39 always 39
  , always 41
Line 36
  BgRed always 41
  = always 41
  41 always 41
  , always 42
Line 37
  BgGreen always 42
  = always 42
  42 always 42
  , always 44
Line 38
  BgBlue always 44
  = always 44
  44 always 44
  , always 49
Line 39
  BgDefault always 49
  = always 49
  49 always 49
Line 40
  457U always 457
Line 41
  476U always 476
Line 42
  676U always 676
Line 43
  682U always 682
Line 44
  825U always 825
Line 70
  fileIndex always !<=-1
  0 always 0
  0 always 0
  column always !<=-1
  0 always 0
Line 72
  column always !<=-1
Line 73
  fileIndex always !<=-1
  0 always 0
  column always !<=-1
  column always !<=-1
Line 75
  column always !<=-1
Line 76
  fileIndex always !<=-1
  0 always 0
  column always !<=-1
  column always !<=-1
Line 86
  convert always {!<=-1,!>=2}
  = always 1
  true always 1
Line 93
  convert always {!<=-1,!>=2}
  = always 1
  true always 1
Line 106
  fileIndex always !<=-1
Line 108
  column always !<=-1
Line 175
  verbose always {!<=-1,!>=2}
Line 180
  ( always {!<=-1,!>=2}
Line 190
  incomplete always {!<=-1,!>=2}
Line 197
  hash always !<=-1
Line 243
  ( always " </array>\r\n</dict>\r\n</plist>"
Line 254
  = always 0
  :: always 0
  Reset always 0
  = always 0
  0 always 0
Line 262
  = always 0
  0 always 0
Line 270
  , always !<=-1
  value always !<=-1
Line 273
  ( always !<=-1
  value always !<=-1
Line 289
  ( always {!<=-1,!>=2}
Line 303
  " </array>\r\n</dict>\r\n</plist>" always " </array>\r\n</dict>\r\n</plist>"
Line 77
  ( always {!<=-1,!>=2}
Line 111
  ( always {!<=-1,!>=2}
Line 134
  ( always {!<=-1,!>=2}
Line 136
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  extra always size=0
Line 146
  ( always {!<=-1,!>=2}
Line 153
  ( always {!<=-1,!>=2}
Line 160
  ( always {!<=-1,!>=2}
Line 167
  ( always {!<=-1,!>=2}
Line 181
  ( always {!<=-1,!>=2}
Line 44
  >= always {!<=-1,!>=2}
  64 always 64
Line 46
  - possible >=-4611686018427387904
  1LL always 1
  << possible <=4611686018427387904
  bit {!>=64,<=63}
  - {!>=63,<=62}
  1 always 1
Line 50
  >= always {!<=-1,!>=2}
  64 always 64
Line 51
  ~ always !<=-1
  0ULL always 0
  >> always !<=-1
  1 always 1
Line 52
  1LL always 1
  << possible <=4611686018427387904
  bit {!>=64,<=63}
  - {!>=63,<=62}
  1 always 1
  - {<=4611686018427387903,!>=4611686018427387904}
  1LL always 1
Line 58
  ( always {!<=-1,!>=2}
Line 59
  return always {!<=-1,!>=2}
  >= always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  <= always {!<=-1,!>=2}
Line 62
  ( always {!<=-1,!>=2}
  value always !<=-1
Line 63
  intMax always !<=-1
  intMax always !<=-1
  = always !<=-1
Line 64
  return always {!<=-1,!>=2}
  value always !<=-1
  <= always {!<=-1,!>=2}
  intMax always !<=-1
Line 67
  ( always {!<=-1,!>=2}
Line 68
  return always {!<=-1,!>=2}
  >= always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  <= always {!<=-1,!>=2}
Line 71
  ( always {!<=-1,!>=2}
  value always !<=-1
Line 72
  longMax always !<=-1
  longMax always !<=-1
  = always !<=-1
Line 73
  return always {!<=-1,!>=2}
  value always !<=-1
  <= always {!<=-1,!>=2}
  longMax always !<=-1
Line 76
  ( always {!<=-1,!>=2}
  value always !<=-1
Line 77
  longLongMax always !<=-1
  longLongMax always !<=-1
  = always !<=-1
Line 78
  return always {!<=-1,!>=2}
  value always !<=-1
  <= always {!<=-1,!>=2}
  longLongMax always !<=-1
Line 103
  Unspecified always 0
Line 104
  Native always 1
Line 105
  Win32A always 2
Line 106
  Win32W always 3
Line 107
  Win64 always 4
Line 108
  Unix32 always 5
Line 109
  Unix64 always 6
Line 110
  PlatformFile always 7
Line 117
  ( always {!<=-1,!>=2}
Line 125
  ( always {!<=-1,!>=2}
Line 128
  ( always {!<=-1,!>=2}
Line 134
  ( always {!<=-1,!>=2}
Line 135
  return always {!<=-1,!>=2}
  platformType possible {3,4}
  == {!<=-1,!>=2,0}
  Win32A always 2
  || always {!<=-1,!>=2}
Line 136
  platformType {4,!2}
  == {!<=-1,!>=2,0}
  Win32W always 3
  || always {!<=-1,!>=2}
Line 137
  platformType always {!2,!3}
  == always {!<=-1,!>=2}
  Win64 always 4
Line 146
  Unspecified always 0
Line 147
  "Unspecified" always "Unspecified"
Line 148
  Native always 1
Line 149
  "Native" always "Native"
Line 150
  Win32A always 2
Line 151
  "win32A" always "win32A"
Line 152
  Win32W always 3
Line 153
  "win32W" always "win32W"
Line 154
  Win64 always 4
Line 155
  "win64" always "win64"
Line 156
  Unix32 always 5
Line 157
  "unix32" always "unix32"
Line 158
  Unix64 always 6
Line 159
  "unix64" always "unix64"
Line 160
  PlatformFile always 7
Line 161
  "platformFile" always "platformFile"
Line 163
  "unknown" always "unknown"
Line 168
  1 always 1
Line 40
  ( always {!<=-1,!>=2}
Line 41
  return always {!<=-1,!>=2}
  < always {!<=-1,!>=2}
  0 always 0
Line 54
  UNKNOWN always 0
Line 55
  MISSING always 1
Line 56
  FAILURE always 2
Line 57
  COMPILE_DB always 3
Line 58
  VS_SLN always 4
Line 59
  VS_VCXPROJ always 5
Line 60
  BORLAND always 6
Line 61
  CPPCHECK_GUI always 7
Line 66
  :: always 0
  Unspecified always 0
  msc always {!<=-1,!>=2}
  false always 0
  useMfc always {!<=-1,!>=2}
  false always 0
Line 71
  msc always {!<=-1,!>=2}
  ? possible {";_MSC_VER=1900",""}
  ";_MSC_VER=1900" always ";_MSC_VER=1900"
  : always ""
  "" always ""
  useMfc always {!<=-1,!>=2}
  ? possible {";__AFXWIN_H__=1",""}
  ";__AFXWIN_H__=1" always ";__AFXWIN_H__=1"
  : always ""
  "" always ""
Line 78
  msc always {!<=-1,!>=2}
Line 79
  useMfc always {!<=-1,!>=2}
Line 108
  , always 0
  = always 0
  nullptr always 0
Line 110
  ( always {!<=-1,!>=2}
Line 111
  ( always {!<=-1,!>=2}
Line 112
  ( always {!<=-1,!>=2}
Line 114
  ( always {!<=-1,!>=2}
Line 115
  ( always {!<=-1,!>=2}
Line 116
  ( always {!<=-1,!>=2}
Line 128
  8 always 8
  = always "project"
  "project" always "project"
Line 129
  8 always 8
  = always "version"
  "version" always "version"
Line 130
  2 always 2
  = always "1"
  "1" always "1"
Line 131
  9 always 9
  = always "builddir"
  "builddir" always "builddir"
Line 132
  14 always 14
  = always "importproject"
  "importproject" always "importproject"
Line 133
  23 always 23
  = always "analyze-all-vs-configs"
  "analyze-all-vs-configs" always "analyze-all-vs-configs"
Line 134
  7 always 7
  = always "parser"
  "parser" always "parser"
Line 135
  12 always 12
  = always "bug-hunting"
  "bug-hunting" always "bug-hunting"
Line 136
  11 always 11
  = always "includedir"
  "includedir" always "includedir"
Line 137
  4 always 4
  = always "dir"
  "dir" always "dir"
Line 138
  5 always 5
  = always "name"
  "name" always "name"
Line 139
  8 always 8
  = always "defines"
  "defines" always "defines"
Line 140
  7 always 7
  = always "define"
  "define" always "define"
Line 141
  5 always 5
  = always "name"
  "name" always "name"
Line 142
  10 always 10
  = always "undefines"
  "undefines" always "undefines"
Line 143
  9 always 9
  = always "undefine"
  "undefine" always "undefine"
Line 144
  6 always 6
  = always "paths"
  "paths" always "paths"
Line 145
  4 always 4
  = always "dir"
  "dir" always "dir"
Line 146
  5 always 5
  = always "name"
  "name" always "name"
Line 147
  5 always 5
  = always "root"
  "root" always "root"
Line 148
  5 always 5
  = always "name"
  "name" always "name"
Line 149
  7 always 7
  = always "ignore"
  "ignore" always "ignore"
Line 150
  5 always 5
  = always "path"
  "path" always "path"
Line 151
  5 always 5
  = always "name"
  "name" always "name"
Line 152
  8 always 8
  = always "exclude"
  "exclude" always "exclude"
Line 153
  5 always 5
  = always "path"
  "path" always "path"
Line 154
  5 always 5
  = always "name"
  "name" always "name"
Line 155
  19 always 19
  = always "function-contracts"
  "function-contracts" always "function-contracts"
Line 156
  19 always 19
  = always "variable-contracts"
  "variable-contracts" always "variable-contracts"
Line 157
  10 always 10
  = always "libraries"
  "libraries" always "libraries"
Line 158
  8 always 8
  = always "library"
  "library" always "library"
Line 159
  9 always 9
  = always "platform"
  "platform" always "platform"
Line 160
  13 always 13
  = always "suppressions"
  "suppressions" always "suppressions"
Line 161
  12 always 12
  = always "suppression"
  "suppression" always "suppression"
Line 162
  6 always 6
  = always "addon"
  "addon" always "addon"
Line 163
  7 always 7
  = always "addons"
  "addons" always "addons"
Line 164
  5 always 5
  = always "tool"
  "tool" always "tool"
Line 165
  6 always 6
  = always "tools"
  "tools" always "tools"
Line 166
  5 always 5
  = always "tags"
  "tags" always "tags"
Line 167
  4 always 4
  = always "tag"
  "tag" always "tag"
Line 168
  13 always 13
  = always "tag-warnings"
  "tag-warnings" always "tag-warnings"
Line 169
  4 always 4
  = always "tag"
  "tag" always "tag"
Line 170
  8 always 8
  = always "warning"
  "warning" always "warning"
Line 171
  5 always 5
  = always "hash"
  "hash" always "hash"
Line 172
  14 always 14
  = always "check-headers"
  "check-headers" always "check-headers"
Line 173
  23 always 23
  = always "check-unused-templates"
  "check-unused-templates" always "check-unused-templates"
Line 174
  14 always 14
  = always "max-ctu-depth"
  "max-ctu-depth" always "max-ctu-depth"
Line 175
  23 always 23
  = always "max-template-recursion"
  "max-template-recursion" always "max-template-recursion"
Line 176
  37 always 37
  = always "check-unknown-function-return-values"
  "check-unknown-function-return-values" always "check-unknown-function-return-values"
Line 177
  11 always 11
  = always "clang-tidy"
  "clang-tidy" always "clang-tidy"
Line 178
  5 always 5
  = always "name"
  "name" always "name"
Line 179
  18 always 18
  = always "vs-configurations"
  "vs-configurations" always "vs-configurations"
Line 180
  7 always 7
  = always "config"
  "config" always "config"
Line 30
  SHOWTIME_NONE always 0
  = always 0
  0 always 0
  , always 1
Line 31
  SHOWTIME_FILE always 1
  , always 2
Line 32
  SHOWTIME_SUMMARY always 2
  , always 3
Line 33
  SHOWTIME_TOP5 always 3
Line 40
  = always 0
  0 always 0
Line 48
  0 always 0
Line 49
  0 always 0
Line 52
  ( always !<=-1
  ( always !<=-1
Line 70
  , always 0
  = always 0
  nullptr always 0
Line 82
  mStopped always {!<=-1,!>=2}
Line 114
  checkAllConfigurations always {!<=-1,!>=2}
Line 117
  checkConfiguration always {!<=-1,!>=2}
Line 122
  checkHeaders always {!<=-1,!>=2}
Line 125
  checkLibrary always {!<=-1,!>=2}
Line 131
  checkUnusedTemplates always {!<=-1,!>=2}
Line 134
  clang always {!<=-1,!>=2}
Line 140
  clangTidy always {!<=-1,!>=2}
Line 152
  daca always {!<=-1,!>=2}
Line 155
  debugnormal always {!<=-1,!>=2}
Line 158
  debugSimplified always {!<=-1,!>=2}
Line 161
  debugtemplate always {!<=-1,!>=2}
Line 164
  debugwarnings always {!<=-1,!>=2}
Line 167
  dump always {!<=-1,!>=2}
Line 171
  None always 0
  C always 1
  CPP always 2
Line 178
  exceptionHandling always {!<=-1,!>=2}
Line 191
  force always {!<=-1,!>=2}
Line 198
  inlineSuppressions always {!<=-1,!>=2}
Line 202
  jobs always !<=-1
Line 207
  jointSuppressionReport always {!<=-1,!>=2}
Line 243
  preprocessOnly always {!<=-1,!>=2}
Line 248
  quiet always {!<=-1,!>=2}
Line 251
  relativePaths always {!<=-1,!>=2}
Line 254
  reportProgress always {!<=-1,!>=2}
Line 260
  "simple" always "simple"
Line 261
  "rule" always "rule"
Line 262
  :: always 3
  style always 3
Line 280
  classes always {!<=-1,!>=2}
  false always 0
  externalFunctions always {!<=-1,!>=2}
  false always 0
  internalFunctions always {!<=-1,!>=2}
  false always 0
  externalVariables always {!<=-1,!>=2}
  false always 0
Line 289
  classes always {!<=-1,!>=2}
  = always 0
  externalFunctions always {!<=-1,!>=2}
  = always 0
  internalFunctions always {!<=-1,!>=2}
  = always 0
  externalVariables always {!<=-1,!>=2}
  = always 0
  false always 0
Line 298
  classes always {!<=-1,!>=2}
Line 305
  externalFunctions always {!<=-1,!>=2}
Line 311
  internalFunctions always {!<=-1,!>=2}
Line 317
  externalVariables always {!<=-1,!>=2}
Line 350
  verbose always {!<=-1,!>=2}
Line 353
  xml always {!<=-1,!>=2}
Line 362
  ( always {!<=-1,!>=2}
Line 364
  ( always !<=-1
  >= always {!<=-1,!>=2}
  ( always !<=-1
  && always {!<=-1,!>=2}
  0 always 0
  ( {!<=-1,<=symbolic=(file.length()),!>=symbolic=(file.length()+1)}
  == always {!<=-1,!>=2}
  0 always 0
Line 365
  return always {!<=-1,!>=2}
  true always 1
Line 368
  return always {!<=-1,!>=2}
  false always 0
Line 383
  ( always {!<=-1,!>=2}
  , always 0
  inconclusiveCheck always {!<=-1,!>=2}
  = always 0
  false always 0
Line 386
  ( always {!<=-1,!>=2}
Line 387
  return always {!<=-1,!>=2}
  ( possible lifetime[Iterator]=(libraries)
  ( {lifetime[Iterator]=(libraries),start=0}
  ( {lifetime[Iterator]=(libraries),end=0}
  "posix" always "posix"
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(libraries),end=0}
Line 391
  t always {!<=-1,!>=2}
  = always 1
  true always 1
Line 392
  = always {!<=-1,!>=2}
  t always {!<=-1,!>=2}
Line 396
  ( always {!<=-1,!>=2}
Line 397
  return always {!<=-1,!>=2}
Line 45
  AST_MAX_DEPTH always 100
  = always 100
  100 always 100
Line 51
  mIsC always {!<=-1,!>=2}
  false always 0
Line 52
  mIsCpp always {!<=-1,!>=2}
  false always 0
Line 54
  = always !0
  this always !0
Line 55
  "auto" always "auto"
Line 56
  mKeywords always !size=0
  "break" always "break"
Line 57
  mKeywords always {!size=1,!size=0}
  "case" always "case"
Line 59
  mKeywords always {!size=2,!size=1,!size=0}
  "const" always "const"
Line 60
  mKeywords always {!size=3,!size=2,!size=1,!size=0}
  "continue" always "continue"
Line 61
  mKeywords always {!size=4,!size=3,!size=2,!size=1,!size=0}
  "default" always "default"
Line 62
  mKeywords always {!size=5,!size=4,!size=3,!size=2,!size=1,!size=0}
  "do" always "do"
Line 64
  mKeywords always {!size=6,!size=5,!size=4,!size=3,!size=2,!size=1,!size=0}
  "else" always "else"
Line 65
  mKeywords always {!size=7,!size=6,!size=5,!size=4,!size=3,!size=2,!size=1,!size=0}
  "enum" always "enum"
Line 66
  mKeywords always {!size=8,!size=7,!size=6,!size=5,!size=4,!size=3,!size=2,!size=1,!size=0}
  "extern" always "extern"
Line 68
  mKeywords always {!size=9,!size=8,!size=7,!size=6,!size=5,!size=4,!size=3,!size=2,!size=1,!size=0}
  "for" always "for"
Line 69
  mKeywords always {!size=10,!size=9,!size=8,!size=7,!size=6,!size=5,!size=4,!size=3,!size=2,!size=1}
  "goto" always "goto"
Line 70
  mKeywords always {!size=11,!size=10,!size=9,!size=8,!size=7,!size=6,!size=5,!size=4,!size=3,!size=2}
  "if" always "if"
Line 71
  mKeywords always {!size=12,!size=11,!size=10,!size=9,!size=8,!size=7,!size=6,!size=5,!size=4,!size=3}
  "inline" always "inline"
Line 74
  mKeywords always {!size=13,!size=12,!size=11,!size=10,!size=9,!size=8,!size=7,!size=6,!size=5,!size=4}
  "register" always "register"
Line 75
  mKeywords always {!size=14,!size=13,!size=12,!size=11,!size=10,!size=9,!size=8,!size=7,!size=6,!size=5}
  "restrict" always "restrict"
Line 76
  mKeywords always {!size=15,!size=14,!size=13,!size=12,!size=11,!size=10,!size=9,!size=8,!size=7,!size=6}
  "return" always "return"
Line 78
  mKeywords always {!size=16,!size=15,!size=14,!size=13,!size=12,!size=11,!size=10,!size=9,!size=8,!size=7}
  "signed" always "signed"
Line 79
  mKeywords always {!size=17,!size=16,!size=15,!size=14,!size=13,!size=12,!size=11,!size=10,!size=9,!size=8}
  "sizeof" always "sizeof"
Line 80
  mKeywords always {!size=18,!size=17,!size=16,!size=15,!size=14,!size=13,!size=12,!size=11,!size=10,!size=9}
  "static" always "static"
Line 81
  mKeywords always {!size=19,!size=18,!size=17,!size=16,!size=15,!size=14,!size=13,!size=12,!size=11,!size=10}
  "struct" always "struct"
Line 82
  mKeywords always {!size=20,!size=19,!size=18,!size=17,!size=16,!size=15,!size=14,!size=13,!size=12,!size=11}
  "switch" always "switch"
Line 83
  mKeywords always {!size=21,!size=20,!size=19,!size=18,!size=17,!size=16,!size=15,!size=14,!size=13,!size=12}
  "typedef" always "typedef"
Line 84
  mKeywords always {!size=22,!size=21,!size=20,!size=19,!size=18,!size=17,!size=16,!size=15,!size=14,!size=13}
  "union" always "union"
Line 85
  mKeywords always {!size=23,!size=22,!size=21,!size=20,!size=19,!size=18,!size=17,!size=16,!size=15,!size=14}
  "unsigned" always "unsigned"
Line 86
  mKeywords always {!size=24,!size=23,!size=22,!size=21,!size=20,!size=19,!size=18,!size=17,!size=16,!size=15}
  "void" always "void"
Line 87
  mKeywords always {!size=25,!size=24,!size=23,!size=22,!size=21,!size=20,!size=19,!size=18,!size=17,!size=16}
  "volatile" always "volatile"
Line 88
  mKeywords always {!size=26,!size=25,!size=24,!size=23,!size=22,!size=21,!size=20,!size=19,!size=18,!size=17}
  "while" always "while"
Line 100
  ( always {!<=-1,!>=2}
Line 103
  ( always !size=0
  0 always 0
Line 112
  = always 0
  nullptr always 0
Line 113
  = always 0
  nullptr always 0
Line 119
  ! always {!<=-1,!>=2}
Line 120
  mIsC always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 121
  mIsCpp always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 123
  mIsC always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  mSettings always !0
  == always {!<=-1,!>=2}
  :: always 1
  C always 1
  || always {!<=-1,!>=2}
  mSettings always !0
  . always !1
  == always {!<=-1,!>=2}
  :: always 0
  None always 0
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 124
  mIsCpp always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  mSettings always !0
  == always {!<=-1,!>=2}
  :: always 2
  CPP always 2
  || always {!<=-1,!>=2}
  mSettings always !0
  . always !2
  == always {!<=-1,!>=2}
  :: always 0
  None always 0
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 127
  mIsCpp always {!<=-1,!>=2}
Line 129
  "catch" always "catch"
Line 130
  mKeywords always !size=0
  "class" always "class"
Line 131
  mKeywords always {!size=1,!size=0}
  "constexpr" always "constexpr"
Line 132
  mKeywords always {!size=2,!size=1,!size=0}
  "const_cast" always "const_cast"
Line 133
  mKeywords always {!size=3,!size=2,!size=1,!size=0}
  "decltype" always "decltype"
Line 134
  mKeywords always {!size=4,!size=3,!size=2,!size=1,!size=0}
  "delete" always "delete"
Line 135
  mKeywords always {!size=5,!size=4,!size=3,!size=2,!size=1,!size=0}
  "dynamic_cast" always "dynamic_cast"
Line 136
  mKeywords always {!size=6,!size=5,!size=4,!size=3,!size=2,!size=1,!size=0}
  "explicit" always "explicit"
Line 137
  mKeywords always {!size=7,!size=6,!size=5,!size=4,!size=3,!size=2,!size=1,!size=0}
  "export" always "export"
Line 139
  mKeywords always {!size=8,!size=7,!size=6,!size=5,!size=4,!size=3,!size=2,!size=1,!size=0}
  "friend" always "friend"
Line 140
  mKeywords always {!size=9,!size=8,!size=7,!size=6,!size=5,!size=4,!size=3,!size=2,!size=1,!size=0}
  "mutable" always "mutable"
Line 141
  mKeywords always {!size=10,!size=9,!size=8,!size=7,!size=6,!size=5,!size=4,!size=3,!size=2,!size=1}
  "namespace" always "namespace"
Line 142
  mKeywords always {!size=11,!size=10,!size=9,!size=8,!size=7,!size=6,!size=5,!size=4,!size=3,!size=2}
  "new" always "new"
Line 143
  mKeywords always {!size=12,!size=11,!size=10,!size=9,!size=8,!size=7,!size=6,!size=5,!size=4,!size=3}
  "noexcept" always "noexcept"
Line 144
  mKeywords always {!size=13,!size=12,!size=11,!size=10,!size=9,!size=8,!size=7,!size=6,!size=5,!size=4}
  "operator" always "operator"
Line 145
  mKeywords always {!size=14,!size=13,!size=12,!size=11,!size=10,!size=9,!size=8,!size=7,!size=6,!size=5}
  "private" always "private"
Line 146
  mKeywords always {!size=15,!size=14,!size=13,!size=12,!size=11,!size=10,!size=9,!size=8,!size=7,!size=6}
  "protected" always "protected"
Line 147
  mKeywords always {!size=16,!size=15,!size=14,!size=13,!size=12,!size=11,!size=10,!size=9,!size=8,!size=7}
  "public" always "public"
Line 148
  mKeywords always {!size=17,!size=16,!size=15,!size=14,!size=13,!size=12,!size=11,!size=10,!size=9,!size=8}
  "reinterpret_cast" always "reinterpret_cast"
Line 149
  mKeywords always {!size=18,!size=17,!size=16,!size=15,!size=14,!size=13,!size=12,!size=11,!size=10,!size=9}
  "static_assert" always "static_assert"
Line 150
  mKeywords always {!size=19,!size=18,!size=17,!size=16,!size=15,!size=14,!size=13,!size=12,!size=11,!size=10}
  "static_cast" always "static_cast"
Line 151
  mKeywords always {!size=20,!size=19,!size=18,!size=17,!size=16,!size=15,!size=14,!size=13,!size=12,!size=11}
  "template" always "template"
Line 152
  mKeywords always {!size=21,!size=20,!size=19,!size=18,!size=17,!size=16,!size=15,!size=14,!size=13,!size=12}
  "this" always "this"
Line 153
  mKeywords always {!size=22,!size=21,!size=20,!size=19,!size=18,!size=17,!size=16,!size=15,!size=14,!size=13}
  "thread_local" always "thread_local"
Line 154
  mKeywords always {!size=23,!size=22,!size=21,!size=20,!size=19,!size=18,!size=17,!size=16,!size=15,!size=14}
  "throw" always "throw"
Line 156
  mKeywords always {!size=24,!size=23,!size=22,!size=21,!size=20,!size=19,!size=18,!size=17,!size=16,!size=15}
  "try" always "try"
Line 157
  mKeywords always {!size=25,!size=24,!size=23,!size=22,!size=21,!size=20,!size=19,!size=18,!size=17,!size=16}
  "typeid" always "typeid"
Line 158
  mKeywords always {!size=26,!size=25,!size=24,!size=23,!size=22,!size=21,!size=20,!size=19,!size=18,!size=17}
  "typename" always "typename"
Line 159
  mKeywords always {!size=27,!size=26,!size=25,!size=24,!size=23,!size=22,!size=21,!size=20,!size=19,!size=18}
  "typeof" always "typeof"
Line 160
  mKeywords always {!size=28,!size=27,!size=26,!size=25,!size=24,!size=23,!size=22,!size=21,!size=20,!size=19}
  "using" always "using"
Line 161
  mKeywords always {!size=29,!size=28,!size=27,!size=26,!size=25,!size=24,!size=23,!size=22,!size=21,!size=20}
  "virtual" always "virtual"
Line 163
  ! always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  mSettings always !0
  >= always {!<=-1,!>=2}
  :: always 4
  CPP20 always 4
Line 164
  mKeywords always {!size=30,!size=29,!size=28,!size=27,!size=26,!size=25,!size=24,!size=23,!size=22,!size=21}
  "alignas" always "alignas"
Line 165
  mKeywords always {!size=31,!size=30,!size=29,!size=28,!size=27,!size=26,!size=25,!size=24,!size=23,!size=22}
  "alignof" always "alignof"
Line 166
  mKeywords always {!size=32,!size=31,!size=30,!size=29,!size=28,!size=27,!size=26,!size=25,!size=24,!size=23}
  "axiom" always "axiom"
Line 167
  mKeywords always {!size=33,!size=32,!size=31,!size=30,!size=29,!size=28,!size=27,!size=26,!size=25,!size=24}
  "co_await" always "co_await"
Line 168
  mKeywords always {!size=34,!size=33,!size=32,!size=31,!size=30,!size=29,!size=28,!size=27,!size=26,!size=25}
  "co_return" always "co_return"
Line 169
  mKeywords always {!size=35,!size=34,!size=33,!size=32,!size=31,!size=30,!size=29,!size=28,!size=27,!size=26}
  "co_yield" always "co_yield"
Line 170
  mKeywords always {!size=36,!size=35,!size=34,!size=33,!size=32,!size=31,!size=30,!size=29,!size=28,!size=27}
  "concept" always "concept"
Line 171
  mKeywords always {!size=37,!size=36,!size=35,!size=34,!size=33,!size=32,!size=31,!size=30,!size=29,!size=28}
  "synchronized" always "synchronized"
Line 172
  mKeywords always {!size=38,!size=37,!size=36,!size=35,!size=34,!size=33,!size=32,!size=31,!size=30,!size=29}
  "consteval" always "consteval"
Line 173
  mKeywords always {!size=39,!size=38,!size=37,!size=36,!size=35,!size=34,!size=33,!size=32,!size=31,!size=30}
  "reflexpr" always "reflexpr"
Line 174
  mKeywords always {!size=40,!size=39,!size=38,!size=37,!size=36,!size=35,!size=34,!size=33,!size=32,!size=31}
  "requires" always "requires"
Line 182
  = always 0
  0 always 0
  i possible 0
  < {!<=-1,!>=2,0}
  mFiles possible size=0
  ( {!<=-1,0}
Line 183
  ( always {!<=-1,!>=2}
  i {<=symbolic=(mFiles.size()-1),!>=symbolic=(mFiles.size())}
Line 184
  i always !>=symbolic=(mFiles.size())
Line 187
  mFiles possible size=0
Line 190
  mFiles always !size=0
  ( always !<=0
  == always {!<=-1,!>=2}
  1 always 1
Line 193
  ( always !<=-1
  - always !<=-1
  1 always 1
Line 203
  tok possible {symbolic=(next),symbolic=(tok->next())}
Line 204
  next possible symbolic=(tok)
  tok {symbolic=(next),symbolic=(tok->next()),!0}
Line 205
  tok {symbolic=(tok->next()),!0}
Line 206
  = always symbolic=(tok->next())
  next always symbolic=(tok->next())
Line 214
  , always {!<=-1,!>=2}
  split always {!<=-1,!>=2}
Line 216
  str possible "##"@30
  ( always {!<=-1,!>=2}
Line 220
  split {!<=-1,!>=2,0@30}
Line 221
  begin always !<=-1
  begin always !<=-1
  = always 0
  0 always 0
Line 222
  end always !<=-1
  end always !<=-1
  = always 0
  0 always 0
Line 223
  end always !<=-1
  = always !<=-1
  ( always !<=-1
  "##" always "##"
  begin {symbolic=(end+2),!<=-1,0}
  != always {!<=-1,!>=2}
Line 224
  begin always !<=-1
  end always !<=-1
  - always !<=-1
  begin always !<=-1
  false always 0
Line 225
  "##" always "##"
  false always 0
Line 226
  begin always !<=-1
  = always !<=1
  end always !<=-1
  + always !<=1
  2 always 2
Line 228
  begin {!<=-1,0}
  != {!<=-1,!>=2,0}
  0 always 0
Line 229
  begin always !<=0
  false always 0
Line 237
  ( inconclusive lifetime[SubObject]=(mTokensFrontBack)
  & {lifetime[Address]=(mTokensFrontBack),!0}
Line 249
  ( always {!<=-1,!>=2}
Line 255
  ( inconclusive lifetime[SubObject]=(mTokensFrontBack)
  & {lifetime[Address]=(mTokensFrontBack),!0}
Line 267
  == always {!<=-1,!>=2}
  nullptr always 0
Line 271
  tok always !0
  tok always !0
Line 273
  ( inconclusive lifetime[SubObject]=(mTokensFrontBack)
  & {lifetime[Address]=(mTokensFrontBack),!0}
Line 275
  tok always !0
Line 276
  ! {!<=-1,!>=2,0}
  tok always !0
  ( possible size=0
  ( {!<=-1,!>=2,1}
Line 277
  tok always !0
  ( always !size=0
Line 283
  tok always !0
  ( always !<=-1
Line 288
  == always {!<=-1,!>=2}
  nullptr always 0
  || always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  nullptr always 0
Line 292
  tok always !0
  tok always !0
Line 294
  ( inconclusive lifetime[SubObject]=(mTokensFrontBack)
  & {lifetime[Address]=(mTokensFrontBack),!0}
Line 296
  tok always !0
Line 297
  ! {!<=-1,!>=2,0}
  tok always !0
  ( possible size=0
  ( {!<=-1,!>=2,1}
Line 298
  tok always !0
  ( always !size=0
Line 301
  tok always !0
  ( always !<=-1
Line 302
  locationTok always !0
Line 303
  locationTok always !0
Line 304
  locationTok always !0
Line 309
  == always {!<=-1,!>=2}
  nullptr always 0
Line 313
  tok always !0
  tok always !0
Line 315
  ( inconclusive lifetime[SubObject]=(mTokensFrontBack)
  & {lifetime[Address]=(mTokensFrontBack),!0}
Line 317
  tok always !0
Line 318
  ! {!<=-1,!>=2,0}
  tok always !0
  ( possible size=0
  ( {!<=-1,!>=2,1}
Line 319
  tok always !0
  ( always !size=0
Line 322
  tok always !0
  ( always !<=-1
Line 323
  tok always !0
Line 324
  tok always !0
Line 325
  tok always !0
Line 333
  , always {!<=-1,!>=2}
  one_line always {!<=-1,!>=2}
Line 337
  dest always symbolic=(tok2)
Line 338
  dest always symbolic=(tok2)
Line 339
  != always {!<=-1,!>=2}
  = possible 0
  ( possible 0
Line 345
  ( always !<=-1
Line 349
  ( always {!<=-1,!>=2}
  "(|[|{" always "(|[|{"
Line 351
  ( always {!<=-1,!>=2}
  ")|]|}" always ")|]|}"
Line 352
  ( always {!<=-1,!>=2}
Line 355
  links always !size=0
Line 357
  link always symbolic=(links.top())
Line 358
  link always symbolic=(links.top())
Line 360
  links always !size=0
Line 362
  ! always {!<=-1,!>=2}
  one_line always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 363
  ( always !0
Line 365
  tok2 possible symbolic=(dest)
Line 376
  > always {!<=-1,!>=2}
  0 always 0
Line 381
  ( always {!<=-1,!>=2}
  "(|[|{" always "(|[|{"
Line 382
  link possible lifetime[Object]=(dest)
Line 383
  ! {!<=-1,!>=2,0}
  link possible {lifetime[Object]=(dest),size=0}
  ( {!<=-1,!>=2,1}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  ")|]|}" always ")|]|}"
Line 384
  link {lifetime[Object]=(dest),!size=0}
Line 385
  link {lifetime[Object]=(dest),!size=0}
Line 393
  ( always !<=-1
Line 395
  -- always !<=-1
  n always !<=0
Line 403
  ( always {!<=-1,!>=2}
Line 408
  & {lifetime[Address]=(outputList),!0}
Line 412
  return always {!<=-1,!>=2}
Line 417
  && always {!<=-1,!>=2}
Line 431
  ( always !<=-1
  > always {!<=-1,!>=2}
  1 always 1
  && always {!<=-1,!>=2}
  str {>=size=2,!<=size=1}
  0 always 0
  == always {!<=-1,!>=2}
  '.' always 46
  && always {!<=-1,!>=2}
  str {>=size=2,!<=size=1}
  1 always 1
Line 432
  '0' always 48
  str {>=size=2,!<=size=1}
Line 437
  ( inconclusive lifetime[SubObject]=(mTokensFrontBack)
  & {lifetime[Address]=(mTokensFrontBack),!0}
Line 445
  ! always {!<=-1,!>=2}
Line 449
  tok always !0
Line 452
  && always {!<=-1,!>=2}
  mSettings always !0
  . always {!<=-1,!>=2}
  relativePaths always {!<=-1,!>=2}
Line 454
  mSettings always !0
Line 462
  ( always !<=-1
Line 464
  checksum always !<=-1
  checksum always !<=-1
  = always 0
  0 always 0
Line 466
  subchecksum1 always !<=-1
  = always !<=-1
  ( always !<=-1
  + always !<=-1
  + always !<=-1
Line 467
  subchecksum2 always !<=-1
  subchecksum2 always !<=-1
  = always 0
  0 always 0
Line 469
  subchecksum2 always !<=-1
  += always !<=-1
  ( always !<=-1
Line 470
  ! {!<=-1,!>=2,0}
  ( possible size=0
  ( {!<=-1,!>=2,1}
Line 471
  ( always !size=0
Line 472
  subchecksum2 always !<=-1
  += always !<=-1
  ( always !<=-1
Line 475
  checksum always !<=-1
  ^= always !<=-1
  ( {symbolic=(tok->flags()+tok->varId()+tok->tokType()),!<=-1}
  subchecksum1 {symbolic=(tok->flags()+tok->varId()+tok->tokType()),!<=-1}
  << always !<=-1
  32 always 32
  | always !<=-1
  subchecksum2 always !<=-1
Line 477
  bit1 always {!<=-1,!>=2}
  = {0,1,!<=-1,!>=2}
  checksum always !<=-1
  & {0,1,!<=-1}
  1 always 1
  != {0,1,!<=-1,!>=2}
  0 always 0
Line 478
  checksum always !<=-1
  >>= always !<=-1
  1 always 1
Line 479
  bit1 {!<=-1,!>=2,0,1}
Line 480
  checksum always !<=-1
  |= always !<=-1
  1ULL always 1
  << always !<=-1
  63 always 63
Line 482
  return always !<=-1
  checksum {!<=-1,0}
Line 492
  cpp always {!<=-1,!>=2}
Line 494
  inCase always {!<=-1,!>=2}
Line 495
  stopAtColon always {!<=-1,!>=2}
Line 497
  cpp always {!<=-1,!>=2}
  0 always 0
  0 always 0
  cpp always {!<=-1,!>=2}
  cpp always {!<=-1,!>=2}
  0 always 0
  inCase always {!<=-1,!>=2}
  false always 0
  stopAtColon always {!<=-1,!>=2}
  false always 0
  nullptr always 0
Line 500
  , always 0
  = always 0
  nullptr always 0
Line 502
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "( %name%" always "( %name%"
Line 505
  ( always {!<=-1,!>=2}
  vartok possible symbolic=(tok)
  "%name%|*|&|::|<" always "%name%|*|&|::|<"
Line 506
  == always {!<=-1,!>=2}
  "<" always "<"
Line 508
  = always !0
  ( always !0
Line 511
  ( always {!<=-1,!>=2}
  "%var% [:=(]" always "%var% [:=(]"
Line 513
  ( always {!<=-1,!>=2}
  "decltype|typeof (" always "decltype|typeof ("
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  1 always 1
  ") [,)]" always ") [,)]"
Line 515
  inner always !0
  2 always 2
Line 516
  1 always 1
Line 520
  tok possible symbolic=(vartok)
Line 523
  ( always {!<=-1,!>=2}
  , always {!<=-1,!>=2}
  cpp always {!<=-1,!>=2}
Line 525
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "( ::| %name%" always "( ::| %name%"
Line 526
  return always {!<=-1,!>=2}
  false always 0
Line 528
  ( always {!<=-1,!>=2}
  ") ( )" always ") ( )"
Line 529
  return always {!<=-1,!>=2}
  false always 0
Line 531
  && always {!<=-1,!>=2}
  ( always !0
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always !0
  != always {!<=-1,!>=2}
  "return" always "return"
  && always {!<=-1,!>=2}
Line 532
  ! always {!<=-1,!>=2}
  cpp always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "delete|throw" always "delete|throw"
Line 533
  return always {!<=-1,!>=2}
  false always 0
Line 535
  ( always {!<=-1,!>=2}
  ( possible 0
  ">" always ">"
  && always {!<=-1,!>=2}
Line 536
  return always {!<=-1,!>=2}
  false always 0
Line 538
  ( always {!<=-1,!>=2}
  "( (| typeof (" always "( (| typeof ("
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  ") %num%" always ") %num%"
Line 539
  return always {!<=-1,!>=2}
  true always 1
Line 541
  ( always {!<=-1,!>=2}
  ") }|)|]|;" always ") }|)|]|;"
Line 542
  return always {!<=-1,!>=2}
  false always 0
Line 544
  ( always {!<=-1,!>=2}
  ") %cop%" always ") %cop%"
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  ") [&*+-~!]" always ") [&*+-~!]"
Line 545
  return always {!<=-1,!>=2}
  false always 0
Line 547
  ( always {!<=-1,!>=2}
  "= ( %name% ) {" always "= ( %name% ) {"
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  0 always 0
Line 548
  return always {!<=-1,!>=2}
  true always 1
Line 550
  type always {!<=-1,!>=2}
  type always {!<=-1,!>=2}
  = always 0
  false always 0
Line 552
  != always {!<=-1,!>=2}
  0 always 0
Line 553
  return always {!<=-1,!>=2}
  false always 0
Line 555
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "(|[|<" always "(|[|<"
Line 556
  ( always !0
Line 558
  == always {!<=-1,!>=2}
  ")" always ")"
Line 559
  ( always {!<=-1,!>=2}
  ") (" always ") ("
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  1 always 1
  ") ." always ") ."
Line 560
  return always {!<=-1,!>=2}
  true always 1
Line 561
  ( always {!<=-1,!>=2}
  ") {" always ") {"
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  type always {!<=-1,!>=2}
Line 562
  1 always 1
Line 563
  tok3 possible symbolic=(tok2)
  != {!<=-1,!>=2,0}
  tok2 possible symbolic=(tok3)
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  tok3 always !symbolic=(tok2)
  "[{}]" always "[{}]"
Line 564
  tok3 always !symbolic=(tok2)
Line 565
  return always {!<=-1,!>=2}
  tok3 possible symbolic=(tok2)
  != {!<=-1,!>=2,0}
  tok2 possible symbolic=(tok3)
  && always {!<=-1,!>=2}
  tok3 always !symbolic=(tok2)
  != always {!<=-1,!>=2}
  ";" always ";"
Line 567
  return always {!<=-1,!>=2}
  type always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  -1 always -1
  == always {!<=-1,!>=2}
  "*" always "*"
  || always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  ") ~" always ") ~"
  || always {!<=-1,!>=2}
Line 568
  ( always {!<=-1,!>=2}
  ") %any%" always ") %any%"
  && always {!<=-1,!>=2}
Line 569
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "!|~|++|--" always "!|~|++|--"
  && always {!<=-1,!>=2}
Line 570
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "[[]);,?:.]" always "[[]);,?:.]"
Line 573
  ( always {!<=-1,!>=2}
  "&|&& )" always "&|&& )"
Line 574
  return always {!<=-1,!>=2}
  true always 1
Line 576
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "%name%|*|::" always "%name%|*|::"
Line 577
  return always {!<=-1,!>=2}
  false always 0
Line 579
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  != always {!<=-1,!>=2}
  "(" always "("
  || always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "( * *| )" always "( * *| )"
Line 580
  type always {!<=-1,!>=2}
  = always 1
  true always 1
Line 583
  return always {!<=-1,!>=2}
  false always 0
Line 589
  ! always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  tok always !0
  "[,()] %name%" always "[,()] %name%"
Line 590
  nullptr always 0
Line 591
  istype always {!<=-1,!>=2}
  istype always {!<=-1,!>=2}
  = always 0
  false always 0
Line 592
  ( always {!<=-1,!>=2}
  "%name%|::|<" always "%name%|::|<"
Line 593
  == always {!<=-1,!>=2}
  "<" always "<"
Line 595
  ! always {!<=-1,!>=2}
Line 596
  nullptr always 0
Line 598
  istype always {!<=-1,!>=2}
  |= always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 601
  ! {!<=-1,!>=2,1}
  istype {!<=-1,!>=2,0}
Line 602
  nullptr always 0
Line 603
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "[*&]" always "[*&]"
Line 604
  nullptr always 0
Line 605
  ( always {!<=-1,!>=2}
  "[*&]" always "[*&]"
Line 607
  && always {!<=-1,!>=2}
  tok always !0
  == always {!<=-1,!>=2}
  "(" always "("
  tok always !0
  nullptr always 0
Line 611
  ( always {!<=-1,!>=2}
Line 612
  ( always {!<=-1,!>=2}
Line 614
  == always {!<=-1,!>=2}
Line 615
  ( always {!<=-1,!>=2}
Line 616
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 1
  CPP11INIT always 1
Line 619
  ( always {!<=-1,!>=2}
Line 621
  ( always {!<=-1,!>=2}
  "{" always "{"
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "; }" always "; }"
Line 622
  return always {!<=-1,!>=2}
  false always 0
Line 624
  nameToken possible {symbolic=(tok),0}
  && always {!<=-1,!>=2}
  nameToken {symbolic=(tok),!0}
  == always {!<=-1,!>=2}
  "{" always "{"
Line 625
  nameToken always !0
  != always {!<=-1,!>=2}
Line 626
  return always {!<=-1,!>=2}
  nameToken always !0
  == always {!<=-1,!>=2}
  :: always 1
  CPP11INIT always 1
Line 627
  nameToken always !0
Line 628
  && always {!<=-1,!>=2}
  nameToken always !0
  == always {!<=-1,!>=2}
  "," always ","
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  nameToken always !0
  "} ," always "} ,"
Line 629
  nameToken always !0
  -1 always -1
Line 631
  ! {!<=-1,!>=2,1}
  nameToken possible {symbolic=(tok),0}
Line 632
  return always {!<=-1,!>=2}
  false always 0
Line 633
  nameToken always !0
  ( possible size=1
  == always {!<=-1,!>=2}
  ")" always ")"
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  nameToken always !0
  "decltype (" always "decltype ("
Line 634
  return always {!<=-1,!>=2}
  true always 1
Line 635
  ( always {!<=-1,!>=2}
  nameToken always !0
  ", {" always ", {"
Line 636
  return always {!<=-1,!>=2}
  true always 1
Line 637
  == always {!<=-1,!>=2}
  ">" always ">"
  && always {!<=-1,!>=2}
Line 638
  ( always !0
Line 639
  == always {!<=-1,!>=2}
  "]" always "]"
Line 641
  ( always {!<=-1,!>=2}
  newTok possible symbolic=(nameToken->link()->previous())
  "%type%" always "%type%"
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  newTok possible symbolic=(nameToken->link()->previous())
  ( always {!<=-1,!>=2}
Line 643
  ( always {!<=-1,!>=2}
  newTok possible symbolic=(nameToken->link()->previous())
  "new" always "new"
Line 644
  return always {!<=-1,!>=2}
  true always 1
Line 647
  = always 0
  nullptr always 0
Line 648
  ( always {!<=-1,!>=2}
  "%name%|return|: {" always "%name%|return|: {"
  && always {!<=-1,!>=2}
Line 649
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  2 always 2
  "[" always "["
  || always {!<=-1,!>=2}
  2 always 2
Line 650
  1 always 1
Line 651
  ( always {!<=-1,!>=2}
  "%name% <" always "%name% <"
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  1 always 1
  "> {" always "> {"
Line 652
  1 always 1
  1 always 1
Line 653
  ( always {!<=-1,!>=2}
  "%name%|> ( {" always "%name%|> ( {"
Line 654
  1 always 1
Line 656
  return always {!<=-1,!>=2}
  false always 0
Line 657
  ( always {!<=-1,!>=2}
  "else|try|do|const|constexpr|override|volatile|&|&&" always "else|try|do|const|constexpr|override|volatile|&|&&"
Line 658
  return always {!<=-1,!>=2}
  false always 0
Line 659
  ( always {!<=-1,!>=2}
  "namespace" always "namespace"
Line 660
  return always {!<=-1,!>=2}
  false always 0
Line 661
  ( always {!<=-1,!>=2}
  "%any% {" always "%any% {"
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "return|:" always "return|:"
Line 663
  != always {!<=-1,!>=2}
  tok2 possible symbolic=(lambdaEnd)
Line 664
  == always {!<=-1,!>=2}
  ";" always ";"
Line 665
  return always {!<=-1,!>=2}
  false always 0
Line 668
  = always !0
  lambdaEnd always !0
Line 672
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "} ;" always "} ;"
Line 673
  return always {!<=-1,!>=2}
  true always 1
Line 675
  ( always {!<=-1,!>=2}
  prev possible symbolic=(nameToken)
  "%name%|::|:|<|>" always "%name%|::|:|<|>"
Line 676
  ( always {!<=-1,!>=2}
  "class|struct" always "class|struct"
Line 677
  return always {!<=-1,!>=2}
  false always 0
Line 681
  return always {!<=-1,!>=2}
  true always 1
Line 684
  ( always {!<=-1,!>=2}
Line 686
  ( always {!<=-1,!>=2}
  "&|&&|*" always "&|&&|*"
Line 688
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "{|;" always "{|;"
Line 689
  return always {!<=-1,!>=2}
  false always 0
Line 690
  return always {!<=-1,!>=2}
  true always 1
Line 693
  & always !0
  & always !0
Line 696
  f possible 0@117
Line 697
  tok always symbolic=(unaryop)
Line 699
  > always {!<=-1,!>=2}
  AST_MAX_DEPTH always 100
Line 700
  ( inconclusive lifetime[SubObject]=(tok)
  "maximum AST depth exceeded" always "maximum AST depth exceeded"
  :: always 0
  AST always 0
Line 702
  f always !0
Line 706
  ! {!<=-1,!>=2,0}
  . possible size=0
  ( {!<=-1,!>=2,1}
Line 713
  & always !0
  & always !0
Line 716
  f possible 0@221
Line 717
  tok always symbolic=(binop)
Line 718
  ( always {!<=-1,!>=2}
  "::|. ~" always "::|. ~"
Line 721
  && always {!<=-1,!>=2}
  <= always {!<=-1,!>=2}
  AST_MAX_DEPTH always 100
Line 722
  f always !0
Line 729
  ! {!<=-1,!>=2,0}
  . possible size=0
  ( {!<=-1,!>=2,1}
Line 733
  ! {!<=-1,!>=2,0}
  . possible size=0
  ( {!<=-1,!>=2,1}
Line 740
  & always !0
Line 742
  & always !0
Line 744
  ! always {!<=-1,!>=2}
Line 746
  ( always {!<=-1,!>=2}
  tok always !0
  "L %str%|%char%" always "L %str%|%char%"
Line 748
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "[{,] . %name%" always "[{,] . %name%"
Line 749
  . possible lifetime[Object]=(tok)
Line 751
  2 always 2
Line 753
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "[{,] [ %num%|%name% ]" always "[{,] [ %num%|%name% ]"
Line 754
  . possible lifetime[Object]=(tok)
Line 756
  3 always 3
Line 758
  ( always {!<=-1,!>=2}
Line 759
  . possible lifetime[Object]=(tok)
Line 762
  ( always {!<=-1,!>=2}
  "%name%|%str%" always "%name%|%str%"
Line 763
  ( always {!<=-1,!>=2}
Line 764
  ( always {!<=-1,!>=2}
  "return|case" always "return|case"
  || always {!<=-1,!>=2}
  . always {!<=-1,!>=2}
  cpp always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  "throw" always "throw"
Line 765
  == always {!<=-1,!>=2}
  "case" always "case"
Line 766
  . always {!<=-1,!>=2}
  inCase always {!<=-1,!>=2}
  = always 1
  true always 1
Line 767
  tokIsReturn always {!<=-1,!>=2}
  = {!<=-1,!>=2,0}
  ( possible size=4
  == {!<=-1,!>=2,0}
  "return" always "return"
Line 768
  stopAtColon always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  . always {!<=-1,!>=2}
  stopAtColon always {!<=-1,!>=2}
Line 769
  . always {!<=-1,!>=2}
  stopAtColon always {!<=-1,!>=2}
  = always 1
  true always 1
Line 771
  . always {!<=-1,!>=2}
  stopAtColon always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  stopAtColon always {!<=-1,!>=2}
Line 772
  tokIsReturn {!<=-1,!>=2,0}
Line 774
  . always {!<=-1,!>=2}
  inCase always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  ": ;" always ": ;"
Line 775
  . always {!<=-1,!>=2}
  inCase always {!<=-1,!>=2}
  = always 0
  false always 0
Line 778
  ( always {!<=-1,!>=2}
  "sizeof !!(" always "sizeof !!("
Line 781
  . {!<=-1,!>=2,0}
  cpp always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 783
  . possible lifetime[Object]=(tok)
Line 784
  2 always 2
Line 785
  . {!<=-1,!>=2,0}
  cpp always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 786
  . possible lifetime[Object]=(tok)
Line 788
  == always {!<=-1,!>=2}
  "<" always "<"
Line 791
  ( always {!<=-1,!>=2}
  "{ . %name% =|{" always "{ . %name% =|{"
Line 793
  = always 1
  1 always 1
Line 796
  ( always {!<=-1,!>=2}
  "{ }" always "{ }"
Line 799
  . possible lifetime[Object]=(tok)
Line 800
  2 always 2
Line 802
  ! {!<=-1,!>=2,1}
  . {!<=-1,!>=2,0}
  cpp always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "new|delete %name%|*|&|::|(|[" always "new|delete %name%|*|&|::|(|["
Line 804
  & {lifetime[Address]=(inner),!0}
  inner always size=0
Line 806
  . always {!<=-1,!>=2}
  cpp always {!<=-1,!>=2}
Line 809
  repeat always {!<=-1,!>=2}
  repeat always {!<=-1,!>=2}
  = always 1
  true always 1
Line 810
  repeat {!<=-1,!>=2,1}
Line 811
  repeat always {!<=-1,!>=2}
  = always 0
  false always 0
Line 812
  ( always {!<=-1,!>=2}
  "%name%" always "%name%"
Line 814
  repeat always {!<=-1,!>=2}
  = always 1
  true always 1
Line 816
  ( always {!<=-1,!>=2}
  "<" always "<"
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  1 always 1
  "> %name%" always "> %name%"
Line 818
  repeat always {!<=-1,!>=2}
  = always 1
  true always 1
Line 821
  . possible lifetime[Object]=(tok)
Line 822
  ( always {!<=-1,!>=2}
  "%name% <" always "%name% <"
  && always {!<=-1,!>=2}
  1 always 1
Line 823
  1 always 1
Line 824
  ( always {!<=-1,!>=2}
  "%name% ..." always "%name% ..."
  || always {!<=-1,!>=2}
  ( always !<=-1
  == always {!<=-1,!>=2}
  1 always 1
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  0 always 0
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  -3 always -3
  "!!& ) ( %name% ) =" always "!!& ) ( %name% ) ="
Line 827
  ( always {!<=-1,!>=2}
  "%str%" always "%str%"
Line 828
  ( always {!<=-1,!>=2}
  "%name%|%str%" always "%name%|%str%"
Line 831
  ( always {!<=-1,!>=2}
  "%name% %assign%" always "%name% %assign%"
Line 834
  == always {!<=-1,!>=2}
  "{" always "{"
Line 836
  ( always {!<=-1,!>=2}
  prev always symbolic=(tok->previous())
  ") {" always ") {"
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  . always {!<=-1,!>=2}
  cpp always {!<=-1,!>=2}
Line 838
  ( always {!<=-1,!>=2}
  "} [" always "} ["
Line 840
  . {!<=-1,!>=2,0}
  cpp always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 841
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "[{,]" always "[{,]"
  || always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  -2 always -2
  "%name% (" always "%name% ("
Line 842
  ( always {!<=-1,!>=2}
  "{ !!}" always "{ !!}"
Line 844
  ( always {!<=-1,!>=2}
  "{ . %name% =|{" always "{ . %name% =|{"
Line 846
  = always 1
  1 always 1
Line 852
  ( always {!<=-1,!>=2}
Line 855
  . possible lifetime[Object]=(tok)
Line 856
  2 always 2
Line 860
  ( always {!<=-1,!>=2}
  tok possible symbolic=(end)
  "} ,|:|)" always "} ,|:|)"
Line 862
  . {!<=-1,!>=2,0}
  cpp always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  -2 always -2
  "%name% ( {" always "%name% ( {"
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ";" always ";"
Line 863
  ( always {!<=-1,!>=2}
  "{ }" always "{ }"
Line 864
  2 always 2
Line 872
  ! always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "=" always "="
Line 873
  . possible lifetime[Object]=(tok)
Line 876
  != always {!<=-1,!>=2}
Line 879
  ( always {!<=-1,!>=2}
  "} [,};]" always "} [,};]"
  && always {!<=-1,!>=2}
  > always {!<=-1,!>=2}
  0 always 0
Line 884
  . possible lifetime[Object]=(tok)
Line 885
  2 always 2
Line 891
  & always !0
Line 895
  tok always !0
  == always {!<=-1,!>=2}
  "::" always "::"
Line 896
  ( always {!<=-1,!>=2}
  nullptr always 0
  : always 0
Line 897
  ( always {!<=-1,!>=2}
  lastOp always symbolic=(state.op.empty()?nullptr:state.op.top())
  ":: %name%" always ":: %name%"
Line 899
  ( always {!<=-1,!>=2}
  "%name%" always "%name%"
  && always {!<=-1,!>=2}
Line 900
  == always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "%name% <" always "%name% <"
  && always {!<=-1,!>=2}
  1 always 1
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  1 always 1
Line 908
  ( always {!<=-1,!>=2}
  , always {!<=-1,!>=2}
  cpp always {!<=-1,!>=2}
Line 910
  ! always {!<=-1,!>=2}
Line 911
  || always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  ( always !0
  "(|[|{|%op%|;|}|?|:|,|.|return|::" always "(|[|{|%op%|;|}|?|:|,|.|return|::"
  || always {!<=-1,!>=2}
  cpp always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  -1 always -1
  == always {!<=-1,!>=2}
  "throw" always "throw"
Line 912
  && always {!<=-1,!>=2}
  ( always !0
  != always {!<=-1,!>=2}
  :: always 16
  eIncDecOp always 16
  || always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 16
  eIncDecOp always 16
Line 913
  return always {!<=-1,!>=2}
  true always 1
Line 915
  == always {!<=-1,!>=2}
  "*" always "*"
  && always {!<=-1,!>=2}
  ( always !0
  == always {!<=-1,!>=2}
  :: always 16
  eIncDecOp always 16
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  ( always !0
  cpp always {!<=-1,!>=2}
Line 916
  return always {!<=-1,!>=2}
  true always 1
Line 918
  return always {!<=-1,!>=2}
  -1 always -1
  == always {!<=-1,!>=2}
  ")" always ")"
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  -1 always -1
  cpp always {!<=-1,!>=2}
Line 921
  & always !0
Line 923
  isStartOfCpp11Init always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  . always {!<=-1,!>=2}
  cpp always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  tok always !0
  == always {!<=-1,!>=2}
  "{" always "{"
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  tok always !0
Line 924
  ! always {!<=-1,!>=2}
  isStartOfCpp11Init {symbolic=(state.cpp&&tok&&tok->str()=="{"&&iscpp11init(tok)),!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  -2 always -2
  "new %type% {" always "new %type% {"
Line 926
  tok possible {symbolic=(tok2->link()->next()),symbolic=(tok1->link()->next())}
Line 927
  tok always !0
  == always {!<=-1,!>=2}
  :: always 16
  eIncDecOp always 16
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  tok always !0
  . always {!<=-1,!>=2}
  cpp always {!<=-1,!>=2}
Line 929
  ( possible size=1
  == {!<=-1,!>=2,0}
  "..." always "..."
Line 930
  . possible lifetime[Object]=(tok)
Line 933
  ( possible size=1
  == always {!<=-1,!>=2}
  "." always "."
  && always {!<=-1,!>=2}
  1 always 1
  != always {!<=-1,!>=2}
  "*" always "*"
Line 934
  1 always 1
  == always {!<=-1,!>=2}
  "." always "."
Line 935
  . possible lifetime[Object]=(tok)
Line 936
  3 always 3
Line 940
  ( possible size=1
  == always {!<=-1,!>=2}
  "[" always "["
Line 941
  . always {!<=-1,!>=2}
  cpp always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  . always 1
  cpp always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "] (|{" always "] (|{"
Line 949
  tok always symbolic=(squareBracket)
  1 always 1
  != always {!<=-1,!>=2}
  "]" always "]"
Line 951
  . always {!<=-1,!>=2}
  cpp always {!<=-1,!>=2}
Line 953
  ! {!<=-1,!>=2,0}
  . possible size=0
  ( {!<=-1,!>=2,1}
Line 958
  ( always {!<=-1,!>=2}
  "] (" always "] ("
Line 960
  roundBracket always symbolic=(squareBracket->link()->next())
Line 961
  ( always {!<=-1,!>=2}
  curlyBracket possible symbolic=(roundBracket->link()->next())
  "mutable|const|constexpr" always "mutable|const|constexpr"
Line 963
  ( always {!<=-1,!>=2}
  curlyBracket possible symbolic=(roundBracket->link()->next())
  "noexcept (" always "noexcept ("
Line 964
  1 always 1
Line 965
  && always {!<=-1,!>=2}
  curlyBracket always !0
  == always {!<=-1,!>=2}
  "->" always "->"
Line 966
  curlyBracket always !0
Line 967
  && always {!<=-1,!>=2}
  curlyBracket always !0
  == always {!<=-1,!>=2}
  "{" always "{"
Line 969
  curlyBracket always !0
Line 971
  curlyBracket always !0
Line 984
  tok always symbolic=(tok2)
  1 always 1
  != always {!<=-1,!>=2}
  "]" always "]"
Line 989
  == always {!<=-1,!>=2}
  "(" always "("
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  . always {!<=-1,!>=2}
  cpp always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "if|while|for|switch|catch" always "if|while|for|switch|catch"
Line 991
  tok always symbolic=(tok2)
Line 992
  opPrevTopSquare always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always !0
  == always {!<=-1,!>=2}
  "[" always "["
Line 993
  oldOpSize always !<=-1
  = always !<=-1
  ( always !<=-1
Line 996
  oldOpSize always !<=-1
  > always {!<=-1,!>=2}
  0 always 0
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  tok always symbolic=(tok2)
  "} (" always "} ("
Line 997
  || always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always !0
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  ( always !0
  "return|case" always "return|case"
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  . always {!<=-1,!>=2}
  cpp always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "throw|delete" always "throw|delete"
Line 998
  || always {!<=-1,!>=2}
  -1 always -1
  == always {!<=-1,!>=2}
  "]" always "]"
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  . always {!<=-1,!>=2}
  cpp always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  -1 always -1
  "new|delete" always "new|delete"
Line 999
  || always {!<=-1,!>=2}
  -1 always -1
  == always {!<=-1,!>=2}
  ">" always ">"
  && always {!<=-1,!>=2}
  -1 always -1
Line 1000
  || always {!<=-1,!>=2}
  -1 always -1
  == always {!<=-1,!>=2}
  ")" always ")"
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  -1 always -1
  . always {!<=-1,!>=2}
  cpp always {!<=-1,!>=2}
Line 1001
  || always {!<=-1,!>=2}
  -1 always -1
  == always {!<=-1,!>=2}
  "}" always "}"
  && always {!<=-1,!>=2}
  opPrevTopSquare always {!<=-1,!>=2}
Line 1002
  operandInside always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  oldOpSize always !<=-1
  < always {!<=-1,!>=2}
  ( always !<=-1
Line 1003
  operandInside {symbolic=(oldOpSize<state.op.size()),!<=-1,!>=2}
Line 1004
  nullptr always 0
Line 1006
  nullptr always 0
Line 1009
  ( always {!<=-1,!>=2}
  . {!<=-1,!>=2,0}
  cpp always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  ") {" always ") {"
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  1 always 1
  "} [" always "} ["
Line 1011
  tok always symbolic=(cast)
Line 1016
  . always {!<=-1,!>=2}
  cpp always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  "{" always "{"
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 1017
  ( always {!<=-1,!>=2}
  "{ }" always "{ }"
Line 1021
  ( always {!<=-1,!>=2}
  "}" always "}"
Line 1027
  & always !0
Line 1031
  ( always {!<=-1,!>=2}
  tok always !0
  "[+-!~*&]" always "[+-!~*&]"
  || always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 16
  eIncDecOp always 16
  && always {!<=-1,!>=2}
Line 1032
  ( always {!<=-1,!>=2}
  . always {!<=-1,!>=2}
  cpp always {!<=-1,!>=2}
Line 1033
  ( always {!<=-1,!>=2}
  "* [*,)]" always "* [*,)]"
Line 1035
  tok2 possible symbolic=(tok->next())
  && always {!<=-1,!>=2}
  tok2 possible symbolic=(tok->next())
  == always {!<=-1,!>=2}
  "*" always "*"
Line 1036
  = always !0
  ( always !0
Line 1037
  ( always {!<=-1,!>=2}
  tok2 possible symbolic=(tok->next())
  "[>),]" always "[>),]"
Line 1043
  == always {!<=-1,!>=2}
  "(" always "("
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  . always {!<=-1,!>=2}
  cpp always {!<=-1,!>=2}
Line 1045
  castTok always symbolic=(tok)
  true always 1
Line 1048
  && always {!<=-1,!>=2}
  tok always !0
  == always {!<=-1,!>=2}
  "{" always "{"
Line 1049
  = always 1
  1 always 1
Line 1052
  nullptr always 0
Line 1053
  . {!<=-1,!>=2,0}
  cpp always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "new %name%|::|(" always "new %name%|::|("
Line 1055
  tok always symbolic=(newtok)
Line 1056
  innertype {!<=-1,!>=2,0}
  innertype always {!<=-1,!>=2}
  = always 0
  false always 0
Line 1057
  == always {!<=-1,!>=2}
  "(" always "("
Line 1058
  ( always {!<=-1,!>=2}
  "( &| %name%" always "( &| %name%"
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  ") ( %type%" always ") ( %type%"
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  1 always 1
  ") (" always ") ("
Line 1060
  ( always {!<=-1,!>=2}
  ") ::| %type%" always ") ::| %type%"
Line 1061
  ( always {!<=-1,!>=2}
  "( !!)" always "( !!)"
Line 1063
  true always 1
Line 1067
  ( always {!<=-1,!>=2}
  "( %type%" always "( %type%"
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  ") [();,[]" always ") [();,[]"
Line 1069
  innertype always {!<=-1,!>=2}
  = always 1
  true always 1
Line 1070
  ( always {!<=-1,!>=2}
  "( &| %name%" always "( &| %name%"
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  ") (" always ") ("
Line 1072
  innertype always {!<=-1,!>=2}
  = always 1
  true always 1
Line 1080
  ( always {!<=-1,!>=2}
  tok possible {symbolic=(leftToken),symbolic=(scopeToken->next())}
  ":: %name%" always ":: %name%"
Line 1082
  scopeToken always symbolic=(tok->next())
Line 1085
  scopeToken always symbolic=(leftToken)
Line 1088
  . possible lifetime[Object]=(tok)
Line 1089
  ( always {!<=-1,!>=2}
  "%name%|*|&|<|::" always "%name%|*|&|<|::"
Line 1091
  = always !0
  ( always !0
Line 1094
  ( always {!<=-1,!>=2}
  tok possible 0
  "( const| %type% ) (" always "( const| %type% ) ("
Line 1098
  && always {!<=-1,!>=2}
  tok always !0
  == always {!<=-1,!>=2}
  "[" always "["
  || always {!<=-1,!>=2}
  tok always !0
  == always {!<=-1,!>=2}
  "(" always "("
  || always {!<=-1,!>=2}
  tok always !0
  == always {!<=-1,!>=2}
  "{" always "{"
Line 1100
  innertype always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  ") [" always ") ["
Line 1104
  nullptr always 0
Line 1105
  innertype {!<=-1,!>=2,1,0}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  ") ," always ") ,"
Line 1107
  . always {!<=-1,!>=2}
  cpp always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "delete %name%|*|&|::|(|[" always "delete %name%|*|&|::|(|["
Line 1109
  tok always symbolic=(tok2)
Line 1110
  && always {!<=-1,!>=2}
  tok always !0
  == always {!<=-1,!>=2}
  "[" always "["
Line 1111
  tok always !0
Line 1113
  nullptr always 0
Line 1120
  & always !0
Line 1124
  ( always {!<=-1,!>=2}
  tok always !0
  ". *" always ". *"
Line 1130
  & always !0
Line 1134
  ( always {!<=-1,!>=2}
  tok always !0
  "[/%]" always "[/%]"
  || always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  "*" always "*"
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 1135
  ( always {!<=-1,!>=2}
  "* [*,)]" always "* [*,)]"
Line 1137
  tok2 possible symbolic=(tok->next())
  && always {!<=-1,!>=2}
  tok2 possible symbolic=(tok->next())
  == always {!<=-1,!>=2}
  "*" always "*"
Line 1138
  = always !0
  ( always !0
Line 1139
  ( always {!<=-1,!>=2}
  tok2 possible symbolic=(tok->next())
  "[>),]" always "[>),]"
Line 1149
  & always !0
Line 1153
  ( always {!<=-1,!>=2}
  tok always !0
  "+|-" always "+|-"
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
Line 1159
  & always !0
Line 1163
  ( always {!<=-1,!>=2}
  tok always !0
  "<<|>>" always "<<|>>"
Line 1169
  & always !0
Line 1173
  tok always !0
  == always {!<=-1,!>=2}
  "<=>" always "<=>"
Line 1179
  & always !0
Line 1183
  ( always {!<=-1,!>=2}
  tok always !0
  "<|<=|>=|>" always "<|<=|>=|>"
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
Line 1189
  & always !0
Line 1193
  ( always {!<=-1,!>=2}
  tok always !0
  "==|!=" always "==|!="
Line 1199
  & always !0
Line 1203
  tok always !0
  == always {!<=-1,!>=2}
  "&" always "&"
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  tok always !0
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  tok always !0
Line 1205
  ! always {!<=-1,!>=2}
  tok2 always symbolic=(tok->next())
Line 1207
  tok2 {symbolic=(tok->next()),!0}
  == always {!<=-1,!>=2}
  "&" always "&"
Line 1208
  tok2 {symbolic=(tok->next()),!0}
Line 1209
  . always {!<=-1,!>=2}
  cpp always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  ",|)" always ",|)"
Line 1218
  & always !0
Line 1222
  tok always !0
  == always {!<=-1,!>=2}
  "^" always "^"
Line 1228
  & always !0
Line 1232
  tok always !0
  == always {!<=-1,!>=2}
  "|" always "|"
Line 1238
  & always !0
Line 1242
  tok always !0
  == always {!<=-1,!>=2}
  "&&" always "&&"
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  tok always !0
Line 1243
  ! always {!<=-1,!>=2}
Line 1245
  ! always {!<=-1,!>=2}
  tok2 always symbolic=(tok->next())
Line 1247
  . always {!<=-1,!>=2}
  cpp always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  tok2 {symbolic=(tok->next()),!0}
  ",|)" always ",|)"
Line 1248
  = always !0
  tok2 always !0
Line 1257
  & always !0
Line 1261
  tok always !0
  == always {!<=-1,!>=2}
  "||" always "||"
Line 1267
  & always !0
Line 1271
  tok always !0
  ( always {!<=-1,!>=2}
Line 1273
  tok always !0
Line 1275
  ( always {!<=-1,!>=2}
  "{" always "{"
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  tok always symbolic=(tok1->link())
Line 1276
  = always !0
  tok always symbolic=(tok1->link())
  ( always !0
Line 1277
  > always {!<=-1,!>=2}
  0 always 0
Line 1279
  tok always !0
  ( possible size=1
  == always {!<=-1,!>=2}
  "?" always "?"
Line 1283
  stopAtColon always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  . always {!<=-1,!>=2}
  stopAtColon always {!<=-1,!>=2}
Line 1284
  . always {!<=-1,!>=2}
  stopAtColon always {!<=-1,!>=2}
  = always 0
  false always 0
Line 1285
  tok always !0
  1 always 1
  == always {!<=-1,!>=2}
  ":" always ":"
Line 1286
  nullptr always 0
Line 1289
  = always 0
  0 always 0
Line 1292
  . always {!<=-1,!>=2}
  stopAtColon always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  stopAtColon always {!<=-1,!>=2}
Line 1293
  tok always !0
  == always {!<=-1,!>=2}
  ":" always ":"
Line 1294
  == always {!<=-1,!>=2}
  1U always 1
  && always {!<=-1,!>=2}
  . always {!<=-1,!>=2}
  inCase always {!<=-1,!>=2}
Line 1295
  . always {!<=-1,!>=2}
  inCase always {!<=-1,!>=2}
  = always 0
  false always 0
Line 1296
  tok always !0
Line 1299
  . always {!<=-1,!>=2}
  stopAtColon always {!<=-1,!>=2}
Line 1301
  > always {!<=-1,!>=2}
  0 always 0
Line 1308
  & always !0
Line 1312
  tok always !0
  ( possible size=1
  == always {!<=-1,!>=2}
  "," always ","
Line 1313
  ( always {!<=-1,!>=2}
  tok always !0
  ", }" always ", }"
Line 1317
  tok always !0
  == always {!<=-1,!>=2}
  ";" always ";"
  && always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  tok always !0
  < always {!<=-1,!>=2}
Line 1323
  & always !0
Line 1325
  > always {!<=-1,!>=2}
  AST_MAX_DEPTH always 100
Line 1326
  ( inconclusive lifetime[SubObject]=(tok)
  "maximum AST depth exceeded" always "maximum AST depth exceeded"
  :: always 0
  AST always 0
Line 1327
  tok possible {symbolic=(colon)@131,symbolic=(init1)@140,symbolic=(tok1)@213,symbolic=(tok1)@219}
Line 1331
  ( always {!<=-1,!>=2}
Line 1338
  != always {!<=-1,!>=2}
  "[" always "["
Line 1339
  return always {!<=-1,!>=2}
  false always 0
Line 1340
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "] (|{" always "] (|{"
Line 1341
  return always {!<=-1,!>=2}
  false always 0
Line 1342
  ( always {!<=-1,!>=2}
  ( possible {symbolic=(tok->link()->next()),0}
  "{" always "{"
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
Line 1343
  return always {!<=-1,!>=2}
  true always 1
Line 1344
  ! always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  ( always !0
  != always {!<=-1,!>=2}
  "(" always "("
Line 1345
  return always {!<=-1,!>=2}
  false always 0
Line 1346
  = always !0
  ( always !0
Line 1347
  ! always {!<=-1,!>=2}
  params {symbolic=(tok->astOperand1()),!0}
  || always {!<=-1,!>=2}
  params {symbolic=(tok->astOperand1()),!0}
  ( always !0
  != always {!<=-1,!>=2}
  "{" always "{"
Line 1348
  return always {!<=-1,!>=2}
  false always 0
Line 1349
  return always {!<=-1,!>=2}
  true always 1
Line 1355
  , always {!<=-1,!>=2}
  cpp always {!<=-1,!>=2}
Line 1357
  ( always {!<=-1,!>=2}
  endToken possible symbolic=(tok)@214
  = possible 0
  ? possible 0
  : always 0
  nullptr always 0
Line 1358
  ( possible size=1
  == always {!<=-1,!>=2}
  "{" always "{"
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 1360
  hasAst always {!<=-1,!>=2}
  hasAst always {!<=-1,!>=2}
  = always 0
  false always 0
Line 1361
  != always {!<=-1,!>=2}
  endToken2 always symbolic=(tok->link())
Line 1363
  hasAst always {!<=-1,!>=2}
  = always 1
  true always 1
Line 1366
  ( always {!<=-1,!>=2}
Line 1368
  == always {!<=-1,!>=2}
  "{" always "{"
Line 1371
  ! {!<=-1,!>=2,1,0}
  hasAst {!<=-1,!>=2,0,1}
Line 1372
  && always {!<=-1,!>=2}
  tok always !0
  != always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  tok always {!symbolic=(endToken),!0}
  != always {!<=-1,!>=2}
  = possible 0
  ? possible 0
  : always 0
  nullptr always 0
Line 1373
  cpp always {!<=-1,!>=2}
Line 1375
  cpp always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  "[" always "["
Line 1376
  ( always {!<=-1,!>=2}
Line 1378
  == always {!<=-1,!>=2}
  "(" always "("
Line 1382
  && always {!<=-1,!>=2}
  tok always !0
  != always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  tok always {!symbolic=(endToken),!0}
  != always {!<=-1,!>=2}
  = possible 0
  ? possible 0
  : always 0
  nullptr always 0
Line 1383
  cpp always 1
Line 1386
  ( always {!<=-1,!>=2}
  "( * ) [" always "( * ) ["
Line 1387
  hasAst always {!<=-1,!>=2}
  hasAst always {!<=-1,!>=2}
  = always 0
  false always 0
Line 1388
  3 always 3
  != always {!<=-1,!>=2}
Line 1389
  || always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
Line 1390
  hasAst always {!<=-1,!>=2}
  = always 1
  true always 1
Line 1394
  ! {!<=-1,!>=2,1,0}
  hasAst {!<=-1,!>=2,0,1}
Line 1395
  4 always 4
Line 1396
  -1 always -1
Line 1397
  cpp always {!<=-1,!>=2}
Line 1399
  cpp always {!<=-1,!>=2}
Line 1407
  && always {!<=-1,!>=2}
  tok always !0
  != always {!<=-1,!>=2}
Line 1408
  || always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
Line 1409
  && always {!<=-1,!>=2}
  ( always !0
  >= always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( {>=symbolic=(tok1->index()),!<=symbolic=(tok1->index()-1)}
  <= always {!<=-1,!>=2}
Line 1413
  ( always {!<=-1,!>=2}
  "( {" always "( {"
Line 1416
  && always {!<=-1,!>=2}
  tok always !0
  != always {!<=-1,!>=2}
Line 1417
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 1419
  ( always {!<=-1,!>=2}
  "( {" always "( {"
Line 1422
  nullptr always 0
Line 1425
  , always {!<=-1,!>=2}
  cpp always {!<=-1,!>=2}
Line 1427
  ( always {!<=-1,!>=2}
  "for (" always "for ("
Line 1428
  cpp always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "for ( const| auto &|&&| [" always "for ( const| auto &|&&| ["
Line 1429
  "[" always "["
Line 1430
  ( always {!<=-1,!>=2}
  decl always symbolic=(Token::findsimplematch(tok,"["))
  "] :" always "] :"
Line 1431
  cpp always 1
Line 1432
  decl inconclusive symbolic=(Token::findsimplematch(tok,"["))
  != always {!<=-1,!>=2}
  "]" always "]"
Line 1433
  ( always {!<=-1,!>=2}
  decl inconclusive symbolic=(Token::findsimplematch(tok,"["))
  "%name% ,|]" always "%name% ,|]"
Line 1435
  == always {!<=-1,!>=2}
  "," always ","
Line 1436
  ! {!<=-1,!>=2,0}
  . possible size=0
  ( {!<=-1,!>=2,1}
Line 1440
  ! {!<=-1,!>=2,0}
  . possible size=0
  ( {!<=-1,!>=2,1}
Line 1448
  ( always !<=-1
  > always {!<=-1,!>=2}
  1 always 1
Line 1456
  decl always symbolic=(colon)
Line 1466
  2 always 2
  & {lifetime[Address]=(inner),!0}
  inner always size=0
Line 1468
  cpp {!<=-1,!>=2,1,0}
Line 1471
  = always 0
  nullptr always 0
Line 1473
  == always {!<=-1,!>=2}
  2 always 2
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "%op%|(" always "%op%|("
Line 1475
  cpp always {!<=-1,!>=2}
Line 1476
  tok2 always symbolic=(init1)
Line 1477
  ( always {!<=-1,!>=2}
  "( !!{" always "( !!{"
Line 1478
  != always {!<=-1,!>=2}
  tok3 possible symbolic=(init1)
Line 1481
  = always !0
  ( always !0
Line 1485
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "%op%|(|[" always "%op%|(|["
Line 1490
  && always {!<=-1,!>=2}
  tok2 always !0
  != always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  tok2 always {!symbolic=(endPar),!0}
  != always {!<=-1,!>=2}
  ";" always ";"
Line 1491
  tok2 always {!symbolic=(endPar),!0}
  == always {!<=-1,!>=2}
  "<" always "<"
  && always {!<=-1,!>=2}
  tok2 always {!symbolic=(endPar),!0}
Line 1492
  = always !0
  tok2 always {!symbolic=(endPar),!0}
  ( always !0
Line 1493
  ( always {!<=-1,!>=2}
  tok2 always {!symbolic=(endPar),!0}
  "%name% )| %op%|(|[|.|:|::" always "%name% )| %op%|(|[|.|:|::"
  || always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  tok2 always {!symbolic=(endPar),!0}
  "[(;{}] %cop%|(" always "[(;{}] %cop%|("
Line 1494
  = always {!symbolic=(endPar),!0}
  tok2 always {!symbolic=(endPar),!0}
Line 1495
  cpp always {!<=-1,!>=2}
Line 1496
  tok2 {symbolic=(init1),!symbolic=(endPar),!0}
Line 1497
  ( always {!<=-1,!>=2}
  ";|)" always ";|)"
Line 1499
  = always 0
  nullptr always 0
Line 1501
  ! always {!<=-1,!>=2}
Line 1502
  nullptr always 0
Line 1503
  tok2 always !0
Line 1506
  ! {!<=-1,!>=2,1}
  tok2 possible {symbolic=(endPar),0}
  || always {!<=-1,!>=2}
  tok2 always !0
  != always {!<=-1,!>=2}
  ";" always ";"
Line 1507
  tok2 possible 0
  == always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 1508
  init1 always !0
Line 1511
  tok2 possible symbolic=(endPar)
Line 1514
  = possible 1
  ? possible 1
  init1 always !0
  : always 1
  tok2 always !0
Line 1516
  = always !0
  tok2 always !0
Line 1517
  tok2 {symbolic=(semicolon1),!0}
Line 1518
  cpp {!<=-1,!>=2,0}
Line 1522
  ! always {!<=-1,!>=2}
  semicolon2 always symbolic=(tok2)
Line 1523
  nullptr always 0
Line 1525
  semicolon2 {symbolic=(tok2),!0}
  == always {!<=-1,!>=2}
  ";" always ";"
Line 1526
  tok2 {symbolic=(semicolon2),!0}
Line 1527
  cpp always {!<=-1,!>=2}
Line 1528
  ( always {!<=-1,!>=2}
  "( {" always "( {"
Line 1534
  semicolon1 always !0
  semicolon2 always !0
Line 1536
  semicolon2 always !0
  tok2 always !0
Line 1537
  semicolon2 always !0
Line 1539
  semicolon2 always !0
  tok2 always !0
Line 1540
  ! {!<=-1,!>=2,0}
  . possible size=0
  ( {!<=-1,!>=2,1}
Line 1541
  semicolon2 always !0
Line 1542
  semicolon1 always !0
  semicolon2 always !0
Line 1544
  ! always {!<=-1,!>=2}
  cpp always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  ":" always ":"
Line 1545
  ( inconclusive lifetime[SubObject]=(tok)
  "syntax error" always "syntax error"
  :: always 1
  SYNTAX always 1
Line 1550
  != always {!<=-1,!>=2}
  semicolon1 always !0
Line 1551
  semicolon1 always {!symbolic=(init),!0}
  init always !symbolic=(semicolon1)
Line 1553
  semicolon1 {symbolic=(init),!0}
Line 1555
  cpp always {!<=-1,!>=2}
Line 1560
  ( always {!<=-1,!>=2}
  "( {" always "( {"
Line 1563
  ( always {!<=-1,!>=2}
  "%type% <" always "%type% <"
  && always {!<=-1,!>=2}
  1 always 1
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  1 always 1
  "> [({]" always "> [({]"
Line 1564
  1 always 1
Line 1566
  cpp always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "%type% ::|<|%name%" always "%type% ::|<|%name%"
Line 1568
  true always 1
Line 1569
  ( always {!<=-1,!>=2}
  tok2 possible symbolic=(tok)
  "%name%|> :: %name%" always "%name%|> :: %name%"
Line 1570
  2 always 2
Line 1571
  ( always {!<=-1,!>=2}
  "%name% <" always "%name% <"
  && always {!<=-1,!>=2}
  1 always 1
Line 1572
  1 always 1
Line 1576
  ( always {!<=-1,!>=2}
  "%name%|> %name% {" always "%name%|> %name% {"
  && always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  2 always 2
Line 1578
  cpp always 1
Line 1580
  1 always 1
  cpp always 1
Line 1585
  ( always {!<=-1,!>=2}
  "%type% %name%|*|&|::" always "%type% %name%|*|&|::"
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "return|new" always "return|new"
Line 1586
  = always 0
  0 always 0
Line 1588
  ( always {!<=-1,!>=2}
  typetok possible symbolic=(tok)
  "%type%|::|*|&" always "%type%|::|*|&"
Line 1589
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "::" always "::"
Line 1593
  ( always {!<=-1,!>=2}
  typetok possible symbolic=(tok)
  "%var% =" always "%var% ="
  && always {!<=-1,!>=2}
Line 1597
  typetok possible symbolic=(tok)
  && always {!<=-1,!>=2}
Line 1598
  >= always {!<=-1,!>=2}
  2 always 2
  && always {!<=-1,!>=2}
Line 1599
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "return|throw" always "return|throw"
  && always {!<=-1,!>=2}
Line 1600
  ( always {!<=-1,!>=2}
  "%name% ( !!*" always "%name% ( !!*"
  && always {!<=-1,!>=2}
Line 1601
  == always {!<=-1,!>=2}
  0 always 0
  && always {!<=-1,!>=2}
Line 1602
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 1603
  ( always {!<=-1,!>=2}
  ") const|;|{" always ") const|;|{"
Line 1604
  typetok always !0
Line 1607
  ( always {!<=-1,!>=2}
  "return|case" always "return|case"
  || always {!<=-1,!>=2}
Line 1608
  cpp always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  "throw" always "throw"
  || always {!<=-1,!>=2}
Line 1609
  ! always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
Line 1610
  ( always {!<=-1,!>=2}
  "%name% %op%|(|[|.|::|<|?|;" always "%name% %op%|(|[|.|::|<|?|;"
  || always {!<=-1,!>=2}
Line 1611
  cpp always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "%name% {" always "%name% {"
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
Line 1612
  ( always {!<=-1,!>=2}
  "[;{}] %cop%|++|--|( !!{" always "[;{}] %cop%|++|--|( !!{"
  || always {!<=-1,!>=2}
Line 1613
  ( always {!<=-1,!>=2}
  "[;{}] %num%|%str%|%char%" always "[;{}] %num%|%str%|%char%"
Line 1614
  cpp always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  -2 always -2
  "[;{}] new|delete %name%" always "[;{}] new|delete %name%"
  || always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  -3 always -3
  "[;{}] :: new|delete %name%" always "[;{}] :: new|delete %name%"
Line 1618
  cpp {!<=-1,!>=2,1,0}
Line 1619
  ( always {!<=-1,!>=2}
  tok always symbolic=(tok1)
  "%name% (" always "%name% ("
Line 1620
  tok always symbolic=(tok1)
  1 always 1
Line 1621
  tok always symbolic=(tok1)
Line 1623
  endToken {symbolic=(tok),0}
  == always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  endToken {symbolic=(tok),!symbolic=(tok1)}
Line 1624
  tok1 possible symbolic=(endToken)
Line 1626
  tok1 always !symbolic=(endToken)
  endToken {symbolic=(tok),!symbolic=(tok1),!0}
  cpp always {!<=-1,!>=2}
Line 1628
  endToken {symbolic=(tok),!symbolic=(tok1),!0}
Line 1631
  cpp always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  "{" always "{"
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 1633
  cpp always 1
Line 1634
  tok always symbolic=(tok1)
Line 1636
  endToken {symbolic=(tok),0}
  == always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  endToken {symbolic=(tok),!symbolic=(tok1)}
Line 1637
  tok1 possible symbolic=(endToken)
Line 1639
  tok1 always !symbolic=(endToken)
  endToken {symbolic=(tok),!symbolic=(tok1),!0}
  cpp always {!>=2,!<=0}
Line 1640
  endToken {symbolic=(tok),!symbolic=(tok1),!0}
Line 1648
  = possible 0
  ? possible 0
  : always 0
  nullptr always 0
Line 1649
  ( always {!<=-1,!>=2}
Line 1654
  ( always 0
Line 1666
  { possible lifetime[SubObject]=(if(mSettings->debugnormal))
  [ possible lifetime[Lambda]=(if(mSettings->debugnormal))
Line 1667
  . always {!<=-1,!>=2}
  debugnormal always {!<=-1,!>=2}
Line 1674
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "[|^/%]" always "[|^/%]"
  && always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
Line 1675
  "Syntax Error: AST broken, binary operator has only one operand." always "Syntax Error: AST broken, binary operator has only one operand."
  :: always 0
  AST always 0
Line 1678
  ( possible size=1
  == always {!<=-1,!>=2}
  "?" always "?"
Line 1679
  ! always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
Line 1680
  "AST broken, ternary operator missing operand(s)" always "AST broken, ternary operator missing operand(s)"
  :: always 0
  AST always 0
Line 1681
  ( always !0
  != always {!<=-1,!>=2}
  ":" always ":"
Line 1682
  "Syntax Error: AST broken, ternary operator lacks ':'." always "Syntax Error: AST broken, ternary operator lacks ':'."
  :: always 0
  AST always 0
Line 1687
  parent {symbolic=(tok->astParent()),0}
Line 1689
  astTokens always size=0
Line 1691
  ( possible lifetime[Iterator]=(safeAstTokens)
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(safeAstTokens),end=0}
Line 1693
  astTokens possible size=1
  ( possible {lifetime[Iterator]=(astTokens),size=1}
  != always {!<=-1,!>=2}
  astTokens possible size=1
  ( {lifetime[Iterator]=(astTokens),size=1,end=0}
Line 1694
  "AST broken: endless recursion from '" always "AST broken: endless recursion from '"
  "'" always "'"
  :: always 0
  AST always 0
Line 1696
  != always {!<=-1,!>=2}
  nullptr always 0
Line 1697
  ( {lifetime[Iterator]=(astTokens),start=0}
  ( {lifetime[Iterator]=(astTokens),end=0}
Line 1698
  == always {!<=-1,!>=2}
  ";" always ";"
Line 1699
  safeAstTokens always NonMovedVariable
Line 1705
  == always {!<=-1,!>=2}
  "<" always "<"
  && always {!<=-1,!>=2}
Line 1706
  = always !0
  ( always !0
Line 1711
  ( always {!<=-1,!>=2}
  "%or%|%oror%|%assign%|%comp%" always "%or%|%oror%|%assign%|%comp%"
Line 1713
  ( always {!<=-1,!>=2}
  "= ,|]" always "= ,|]"
Line 1716
  ( always {!<=-1,!>=2}
  ") = 0" always ") = 0"
Line 1719
  ( always {!<=-1,!>=2}
  "operator" always "operator"
Line 1722
  ! {!<=-1,!>=2,1}
  ( possible 0
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
Line 1725
  ( always {!<=-1,!>=2}
  "= {|^|[" always "= {|^|["
Line 1728
  ( always {!<=-1,!>=2}
  "%name% = %name%" always "%name% = %name%"
Line 1730
  ! always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
Line 1731
  "Syntax Error: AST broken, binary operator '" always "Syntax Error: AST broken, binary operator '"
  "' doesn't have two operands." always "' doesn't have two operands."
  :: always 0
  AST always 0
Line 1735
  ( always {!<=-1,!>=2}
  "if|while|for|switch|assert|ASSERT (" always "if|while|for|switch|assert|ASSERT ("
Line 1736
  ! always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
Line 1738
  "Syntax Error: AST broken, '" always "Syntax Error: AST broken, '"
Line 1739
  "' doesn't have two operands." always "' doesn't have two operands."
Line 1740
  :: always 0
  AST always 0
Line 1744
  ( always {!<=-1,!>=2}
  "%var% ." always "%var% ."
Line 1745
  ! always {!<=-1,!>=2}
Line 1747
  "Syntax Error: AST broken, '" always "Syntax Error: AST broken, '"
  "' doesn't have a parent." always "' doesn't have a parent."
  :: always 0
  AST always 0
Line 1749
  ! always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
Line 1751
  ( always {!<=-1,!>=2}
  ( always !size=0
Line 1753
  "Syntax Error: AST broken, '" always "Syntax Error: AST broken, '"
  op always symbolic=(tok->next()->originalName().empty()?tok->next()->str():tok->next()->originalName())
  "' doesn't have two operands." always "' doesn't have two operands."
  :: always 0
  AST always 0
Line 1771
  this always !0
Line 1774
  ( always {!<=-1,!>=2}
Line 1776
  ! always {!<=-1,!>=2}
  tok possible symbolic=(t)
Line 1777
  return always {!<=-1,!>=2}
  true always 1
Line 1778
  t possible symbolic=(tok)
Line 1779
  tok always !0
  == always {!<=-1,!>=2}
Line 1780
  return always {!<=-1,!>=2}
  true always 1
Line 1782
  return always {!<=-1,!>=2}
  false always 0
Line 1787
  isCPP11 always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  >= always {!<=-1,!>=2}
  :: always 1
  CPP11 always 1
Line 1789
  isLongLong always 0
  isLong always 1
  isInt always 2
Line 1793
  . possible {symbolic=(mSettings->sizeof_long_long),symbolic=(mSettings->sizeof_int)}
  == always {!<=-1,!>=2}
Line 1794
  = always 1
  isLong always 1
Line 1795
  . {symbolic=(mSettings->sizeof_int),!symbolic=(mSettings->sizeof_long)}
  == always {!<=-1,!>=2}
Line 1796
  = always 0
  isLongLong always 0
Line 1797
  . always {!symbolic=(mSettings->sizeof_long),!symbolic=(mSettings->sizeof_long_long)}
  == always {!<=-1,!>=2}
Line 1798
  = always 2
  isInt always 2
Line 1804
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "std| ::| %type%" always "std| ::| %type%"
Line 1806
  isUnsigned {!<=-1,!>=2,0}
Line 1807
  ( always {!<=-1,!>=2}
  "std| ::| size_t|uintptr_t|uintmax_t" always "std| ::| size_t|uintptr_t|uintmax_t"
Line 1808
  isCPP11 always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  -1 always -1
  == always {!<=-1,!>=2}
  "using" always "using"
  && always {!<=-1,!>=2}
  1 always 1
  == always {!<=-1,!>=2}
  "=" always "="
Line 1810
  isUnsigned always {!<=-1,!>=2}
  = always 1
  true always 1
Line 1811
  ( always {!<=-1,!>=2}
  "std| ::| ssize_t|ptrdiff_t|intptr_t|intmax_t" always "std| ::| ssize_t|ptrdiff_t|intptr_t|intmax_t"
Line 1812
  isCPP11 always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  -1 always -1
  == always {!<=-1,!>=2}
  "using" always "using"
  && always {!<=-1,!>=2}
  1 always 1
  == always {!<=-1,!>=2}
  "=" always "="
Line 1814
  isUnsigned always {!<=-1,!>=2}
  = always 0
  false always 0
Line 1818
  inStd {!<=-1,!>=2,0}
  inStd always {!<=-1,!>=2}
  = always 0
  false always 0
Line 1819
  ( possible size=3
  == {!<=-1,!>=2,0}
  "::" always "::"
Line 1821
  == always {!<=-1,!>=2}
  "std" always "std"
Line 1822
  != always {!<=-1,!>=2}
  "::" always "::"
Line 1824
  inStd always {!<=-1,!>=2}
  = always 1
  true always 1
Line 1829
  inStd {!<=-1,!>=2,0,1}
Line 1830
  "std::" always "std::"
Line 1833
  isUnsigned always {!<=-1,!>=2}
Line 1834
  true always 1
Line 1837
  isLongLong always 0
Line 1838
  true always 1
Line 1839
  "long" always "long"
Line 1841
  isLong always 1
Line 1842
  "long" always "long"
Line 1844
  isInt always 2
Line 1845
  "int" always "int"
Line 1853
  ( possible 4
  != {!<=-1,!>=2,1}
  :: always 1
  eType always 1
  && always {!<=-1,!>=2}
  ( always !1
  != always {!<=-1,!>=2}
  :: always 4
  eName always 4
Line 1858
  platformtype always symbolic=(mSettings->library.platform_type(tok->str(),platform_type))
Line 1860
  -1 always -1
  == always {!<=-1,!>=2}
  "::" always "::"
Line 1861
  -2 always -2
Line 1863
  && always {!<=-1,!>=2}
  tok1 always !0
  == always {!<=-1,!>=2}
  :: always 4
  eName always 4
Line 1869
  platformtype {symbolic=(mSettings->library.platform_type(tok->str(),platform_type)),!0}
  . always {!<=-1,!>=2}
  mConstPtr always {!<=-1,!>=2}
Line 1870
  "const" always "const"
Line 1871
  "*" always "*"
Line 1872
  platformtype always !0
Line 1874
  platformtype always !0
  . always {!<=-1,!>=2}
  mPointer always {!<=-1,!>=2}
Line 1875
  platformtype always !0
Line 1877
  tok always symbolic=(typeToken)
  "*" always "*"
Line 1878
  platformtype always !0
  . always {!<=-1,!>=2}
  mPtrPtr always {!<=-1,!>=2}
Line 1879
  platformtype always !0
Line 1881
  tok always symbolic=(typeToken)
  "*" always "*"
Line 1882
  tok always symbolic=(typeToken)
  "*" always "*"
Line 1885
  platformtype always !0
Line 1888
  platformtype always !0
  . always {!<=-1,!>=2}
  mSigned always {!<=-1,!>=2}
Line 1889
  true always 1
Line 1890
  platformtype always !0
  . always {!<=-1,!>=2}
  mUnsigned always {!<=-1,!>=2}
Line 1891
  true always 1
Line 1892
  platformtype always !0
  . always {!<=-1,!>=2}
  mLong always {!<=-1,!>=2}
Line 1893
  true always 1
Line 1902
  ( always {!<=-1,!>=2}
  "const|extern *|&|%name%" always "const|extern *|&|%name%"
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  ( always !0
  "[;{}]" always "[;{}]"
Line 1903
  ( always {!<=-1,!>=2}
  "%name% !!;" always "%name% !!;"
Line 1906
  "int" always "int"
Line 1907
  true always 1
Line 1911
  ( always {!<=-1,!>=2}
  "char|short|int|long|unsigned|signed|double|float" always "char|short|int|long|unsigned|signed|double|float"
  || always {!<=-1,!>=2}
  >= always {!<=-1,!>=2}
  :: always 1
  C99 always 1
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "complex|_Complex" always "complex|_Complex"
Line 1912
  isFloat always {!<=-1,!>=2}
  isFloat always {!<=-1,!>=2}
  = always 0
  false always 0
Line 1913
  isSigned always {!<=-1,!>=2}
  isSigned always {!<=-1,!>=2}
  = always 0
  false always 0
Line 1914
  isUnsigned always {!<=-1,!>=2}
  isUnsigned always {!<=-1,!>=2}
  = always 0
  false always 0
Line 1915
  isComplex always {!<=-1,!>=2}
  isComplex always {!<=-1,!>=2}
  = always 0
  false always 0
Line 1916
  = always 0
  0 always 0
Line 1917
  = always 0
  nullptr always 0
Line 1920
  tok2 possible symbolic=(tok)
  tok2 possible symbolic=(typeSpec)
Line 1921
  ( possible {size=5,size=8,size=6}
  == {!<=-1,!>=2,0}
  "long" always "long"
Line 1923
  ! always {!<=-1,!>=2}
  isFloat always {!<=-1,!>=2}
Line 1925
  ( possible {size=8,size=6}
  == {!<=-1,!>=2,0}
  "short" always "short"
Line 1927
  ( possible size=6
  == {!<=-1,!>=2,0}
  "unsigned" always "unsigned"
Line 1928
  isUnsigned always {!<=-1,!>=2}
  = always 1
  true always 1
Line 1929
  == always {!<=-1,!>=2}
  "signed" always "signed"
Line 1930
  isSigned always {!<=-1,!>=2}
  = always 1
  true always 1
Line 1931
  ( always {!<=-1,!>=2}
  "float|double" always "float|double"
Line 1932
  isFloat always {!<=-1,!>=2}
  = always 1
  true always 1
Line 1934
  >= always {!<=-1,!>=2}
  :: always 1
  C99 always 1
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "complex|_Complex" always "complex|_Complex"
Line 1935
  isComplex always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  isFloat always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  "_Complex" always "_Complex"
  || always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "*|&|%name%" always "*|&|%name%"
Line 1936
  ( always {!<=-1,!>=2}
  "char|int" always "char|int"
Line 1937
  ! always {!<=-1,!>=2}
Line 1943
  ! {!<=-1,!>=2,1}
  typeSpec possible 0
Line 1944
  ! {!<=-1,!>=2,1}
  isComplex {!<=-1,!>=2,0}
Line 1945
  tok possible symbolic=(tok2)
  "int" always "int"
Line 1946
  tok possible symbolic=(tok2)
  isSigned {!<=-1,!>=2,0}
Line 1947
  tok possible symbolic=(tok2)
  isUnsigned {!<=-1,!>=2,0}
Line 1948
  tok possible symbolic=(tok2)
  true always 1
Line 1951
  typeSpec always !0
  typeSpec always !0
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  isFloat always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  1 always 1
  || always {!<=-1,!>=2}
  > always {!<=-1,!>=2}
  1 always 1
Line 1952
  typeSpec always !0
  typeSpec always !0
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  isFloat always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  isComplex always {!<=-1,!>=2}
Line 1953
  typeSpec always !0
  typeSpec always !0
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  isSigned always {!<=-1,!>=2}
Line 1954
  typeSpec always !0
  typeSpec always !0
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  isUnsigned always {!<=-1,!>=2}
Line 1959
  tok3 always symbolic=(tok->previous())
  != always {!<=-1,!>=2}
Line 1960
  tok2 always !symbolic=(tok3)
  != always {!<=-1,!>=2}
  typeSpec always !0
  && always {!<=-1,!>=2}
Line 1961
  isComplex always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  tok2 always {!symbolic=(tok3),!symbolic=(typeSpec)}
  "complex|_Complex" always "complex|_Complex"
Line 1962
  tok2 always {!symbolic=(tok3),!symbolic=(typeSpec)}
Line 1963
  tok2 {!symbolic=(tok3),symbolic=(typeSpec)}
Line 1970
  ( always {!<=-1,!>=2}
Line 1972
  return always {!<=-1,!>=2}
  ( possible lifetime[Iterator]=(mKeywords)
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(mKeywords),end=0}
Line 50
  mFlags always !<=-1
  mFlags always !<=-1
  = always 0
  0 always 0
Line 52
  ( always !<=-1
Line 53
  return always !<=-1
  mFlags always !<=-1
Line 56
  mFlags always !<=-1
  = always 0
  0 always 0
Line 59
  mFlags always !<=-1
  = always 4294967295
  0xFFFFFFFF always 4294967295
Line 61
  enabled always {!<=-1,!>=2}
Line 62
  enabled always {!<=-1,!>=2}
Line 67
  ( always {!<=-1,!>=2}
Line 68
  return always {!<=-1,!>=2}
  mFlags always !<=-1
  & always !<=-1
  1U always 1
  << always !<=0
  ( always !<=-1
  != always {!<=-1,!>=2}
  0 always 0
Line 71
  mFlags always !<=-1
  |= always !<=-1
  1U always 1
  << always !<=0
  ( always !<=-1
Line 74
  mFlags always !<=-1
  &= always !<=-1
  ~ always !<=4294967295
  1U always 1
  << always !<=0
  ( always !<=-1
Line 76
  , always {!<=-1,!>=2}
  enabled always {!<=-1,!>=2}
Line 77
  enabled always {!<=-1,!>=2}
Line 50
  mFlags always !<=-1
  mFlags always !<=-1
  = always 0
  0 always 0
Line 52
  ( always !<=-1
Line 53
  return always !<=-1
  mFlags always !<=-1
Line 56
  mFlags always !<=-1
  = always 0
  0 always 0
Line 59
  mFlags always !<=-1
  = always 4294967295
  0xFFFFFFFF always 4294967295
Line 61
  enabled always {!<=-1,!>=2}
Line 62
  enabled always {!<=-1,!>=2}
Line 67
  ( always {!<=-1,!>=2}
Line 68
  return always {!<=-1,!>=2}
  mFlags always !<=-1
  & always !<=-1
  1U always 1
  << always !<=0
  ( always !<=-1
  != always {!<=-1,!>=2}
  0 always 0
Line 71
  mFlags always !<=-1
  |= always !<=-1
  1U always 1
  << always !<=0
  ( always !<=-1
Line 74
  mFlags always !<=-1
  &= always !<=-1
  ~ always !<=4294967295
  1U always 1
  << always !<=0
  ( always !<=-1
Line 76
  , always {!<=-1,!>=2}
  enabled always {!<=-1,!>=2}
Line 77
  enabled always {!<=-1,!>=2}
Line 50
  mFlags always !<=-1
  mFlags always !<=-1
  = always 0
  0 always 0
Line 52
  ( always !<=-1
Line 53
  return always !<=-1
  mFlags always !<=-1
Line 56
  mFlags always !<=-1
  = always 0
  0 always 0
Line 59
  mFlags always !<=-1
  = always 4294967295
  0xFFFFFFFF always 4294967295
Line 61
  enabled always {!<=-1,!>=2}
Line 62
  enabled always {!<=-1,!>=2}
Line 67
  ( always {!<=-1,!>=2}
Line 68
  return always {!<=-1,!>=2}
  mFlags always !<=-1
  & always !<=-1
  1U always 1
  << always !<=0
  ( always !<=-1
  != always {!<=-1,!>=2}
  0 always 0
Line 71
  mFlags always !<=-1
  |= always !<=-1
  1U always 1
  << always !<=0
  ( always !<=-1
Line 74
  mFlags always !<=-1
  &= always !<=-1
  ~ always !<=4294967295
  1U always 1
  << always !<=0
  ( always !<=-1
Line 76
  , always {!<=-1,!>=2}
  enabled always {!<=-1,!>=2}
Line 77
  enabled always {!<=-1,!>=2}
