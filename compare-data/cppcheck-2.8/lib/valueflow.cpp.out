

##file cppcheck-2.8/lib/config.h

1:
|
78:
79: static const std :: string emptyString@var1 ;

##file cppcheck-2.8/lib/mathlib.h

1:
|
33:
34: class MathLib {
35: friend class TestMathLib ;
36:
37: public:
38:
39: class value {
40: private:
41: long long mIntValue@var2 ;
42: double mDoubleValue@var3 ;
43: enum class Type { INT , LONG , LONGLONG , FLOAT } ; enum Type mType@var4 ;
44: bool mIsUnsigned@var5 ;
45:
46: void promote ( const value & v@var6 ) ;
47:
48: public:
49: explicit value ( const std :: string & s@var7 ) ;
50: std :: string str ( ) const ;
51: bool isInt ( ) const {
52: return mType@var4 !=@expr1073747129 Type ::@expr1073747130 FLOAT ;
53: }
54: bool isFloat ( ) const {
55: return mType@var4 ==@expr1073747131 Type ::@expr1073747132 FLOAT ;
56: }
57:
58: double getDoubleValue ( ) const {
59: return isFloat (@expr1073747133 ) ?@expr1073747134 mDoubleValue@var3 :@expr1073747135 (@expr1073747136 double ) mIntValue@var2 ;
60: }
61:
62: static value calc ( char op@var8 , const value & v1@var9 , const value & v2@var10 ) ;
63: int compare ( const value & v@var11 ) const ;
64: value add ( int v@var12 ) const ;
65: value shiftLeft ( const value & v@var13 ) const ;
66: value shiftRight ( const value & v@var14 ) const ;
67: } ;
68:
69:
70:
71: static const int bigint_bits@var15 ;
72:
73: static long long toLongNumber ( const std :: string & str@var16 ) ;
74: static unsigned long long toULongNumber ( const std :: string & str@var17 ) ;
75:
76: template < class T > static std :: string toString ( T value@var18 ) {
77: std ::@expr1073747137 ostringstream result@var19 ;
78: result@var19 <<@expr1073747138 value@var18 ;
79: return result@var19 .@expr1073747139 str (@expr1073747140 ) ;
80: }
81: static double toDoubleNumber ( const std :: string & str@var20 ) ;
82:
83: static bool isInt ( const std :: string & str@var21 ) ;
84: static bool isFloat ( const std :: string & str@var22 ) ;
85: static bool isDecimalFloat ( const std :: string & str@var23 ) ;
86: static bool isNegative ( const std :: string & str@var24 ) ;
87: static bool isPositive ( const std :: string & str@var25 ) ;
88: static bool isDec ( const std :: string & str@var26 ) ;
89: static bool isFloatHex ( const std :: string & str@var27 ) ;
90: static bool isIntHex ( const std :: string & str@var28 ) ;
91: static bool isOct ( const std :: string & str@var29 ) ;
92: static bool isBin ( const std :: string & str@var30 ) ;
93:
94: static std :: string getSuffix ( const std :: string & value@var31 ) ;
95:
|
101:
102: static bool isValidIntegerSuffix ( const std :: string & str@var32 , bool supportMicrosoftExtensions@var33 = true ) ;
103:
104: static std :: string add ( const std :: string & first@var34 , const std :: string & second@var35 ) ;
105: static std :: string subtract ( const std :: string & first@var36 , const std :: string & second@var37 ) ;
106: static std :: string multiply ( const std :: string & first@var38 , const std :: string & second@var39 ) ;
107: static std :: string divide ( const std :: string & first@var40 , const std :: string & second@var41 ) ;
108: static std :: string mod ( const std :: string & first@var42 , const std :: string & second@var43 ) ;
109: static std :: string incdec ( const std :: string & var@var44 , const std :: string & op@var45 ) ;
110: static std :: string calculate ( const std :: string & first@var46 , const std :: string & second@var47 , char action@var48 ) ;
111:
112: static std :: string sin ( const std :: string & tok@var49 ) ;
113: static std :: string cos ( const std :: string & tok@var50 ) ;
114: static std :: string tan ( const std :: string & tok@var51 ) ;
115: static std :: string abs ( const std :: string & tok@var52 ) ;
116: static bool isEqual ( const std :: string & first@var53 , const std :: string & second@var54 ) ;
117: static bool isNotEqual ( const std :: string & first@var55 , const std :: string & second@var56 ) ;
118: static bool isGreater ( const std :: string & first@var57 , const std :: string & second@var58 ) ;
119: static bool isGreaterEqual ( const std :: string & first@var59 , const std :: string & second@var60 ) ;
120: static bool isLess ( const std :: string & first@var61 , const std :: string & second@var62 ) ;
121: static bool isLessEqual ( const std :: string & first@var63 , const std :: string & second@var64 ) ;
122: static bool isNullValue ( const std :: string & str@var65 ) ;
123:
|
127:
128: static bool isOctalDigit ( char c@var66 ) ;
129:
130: static unsigned int encodeMultiChar ( const std :: string & str@var67 ) ;
131:
|
136:
137: static bool isDigitSeparator ( const std :: string & iCode@var68 , std :: string :: size_type iPos@var69 ) ;
138: } ;
139:
140: MathLib :: value operator+ ( const MathLib :: value & v1@var70 , const MathLib :: value & v2@var71 ) ;
141: MathLib :: value operator- ( const MathLib :: value & v1@var72 , const MathLib :: value & v2@var73 ) ;
142: MathLib :: value operator* ( const MathLib :: value & v1@var74 , const MathLib :: value & v2@var75 ) ;
143: MathLib :: value operator/ ( const MathLib :: value & v1@var76 , const MathLib :: value & v2@var77 ) ;
144: MathLib :: value operator% ( const MathLib :: value & v1@var78 , const MathLib :: value & v2@var79 ) ;
145: MathLib :: value operator& ( const MathLib :: value & v1@var80 , const MathLib :: value & v2@var81 ) ;
146: MathLib :: value operator| ( const MathLib :: value & v1@var82 , const MathLib :: value & v2@var83 ) ;
147: MathLib :: value operator^ ( const MathLib :: value & v1@var84 , const MathLib :: value & v2@var85 ) ;
148: MathLib :: value operator<< ( const MathLib :: value & v1@var86 , const MathLib :: value & v2@var87 ) ;
149: MathLib :: value operator>> ( const MathLib :: value & v1@var88 , const MathLib :: value & v2@var89 ) ;
150:
151: template < > std :: string MathLib :: toString < double > ( double value@var90 ) ;

##file cppcheck-2.8/lib/valueflow.h

1:
|
36:
37: class ErrorLogger ;
38: struct InferModel ;
39: class Settings ;
40: class SymbolDatabase ;
41: class Token ;
42: class TokenList ;
43: class ValueType ;
44: class Variable ;
45: class Scope ;
46:
47: template < class T >
48: class ValuePtr ;
49:
50: namespace ValueFlow {
51: struct increment {
52: template < class T >
53: void operator() ( T & x@var91 ) const {
54: x@var91 ++@expr1073747141 ;
55: }
56: } ;
57: struct decrement {
58: template < class T >
59: void operator() ( T & x@var92 ) const {
60: x@var92 --@expr1073747142 ;
61: }
62: } ;
63:
64: struct less {
65: template < class T , class U >
66: bool operator() ( const T & x@var93 , const U & y@var94 ) const {
67: return x@var93 <@expr1073747143 y@var94 ;
68: }
69: } ;
70:
71: struct adjacent {
72: template < class T , class U >
73: bool operator() ( const T & x@var95 , const U & y@var96 ) const {
74: return std ::@expr1073747144 abs (@expr1073747145 x@var95 -@expr1073747146 y@var96 ) ==@expr1073747147 1 ;
75: }
76: } ;
77:
78: struct equalVisitor {
79: template < class T , class U >
80: void operator() ( bool & result@var97 , T x@var98 , U y@var99 ) const {
81: result@var97 =@expr1073747148 !@expr1073747149 (@expr1073747150 x@var98 >@expr1073747151 y@var99 ||@expr1073747152 x@var98 <@expr1073747153 y@var99 ) ;
82: }
83: } ;
84: class Value {
85: public:
86:
87:
88: enum class Bound { Upper , Lower , Point } ;
89:
90: explicit Value ( long long val@var100 = 0 , Bound b@var101 = Bound :: Point )
91: : valueType@var141 ( ValueType :: INT ) ,
92: bound@var142 ( b@var101 ) ,
93: intvalue@var143 ( val@var100 ) ,
94: tokvalue@var144 ( nullptr ) ,
95: floatValue@var145 ( 0.0 ) ,
96: moveKind@var146 ( MoveKind :: NonMovedVariable ) ,
97: varvalue@var147 ( val@var100 ) ,
98: condition@var148 ( nullptr ) ,
99: varId@var150 ( 0U ) ,
100: safe@var151 ( false ) ,
101: conditional@var152 ( false ) ,
102: macro@var153 ( false ) ,
103: defaultArg@var154 ( false ) ,
104: indirect@var155 ( 0 ) ,
105: path@var156 ( 0 ) ,
106: wideintvalue@var157 ( val@var100 ) ,
107: subexpressions@var158 ( ) ,
108: capturetok@var159 ( nullptr ) ,
109: lifetimeKind@var160 ( LifetimeKind :: Object ) ,
110: lifetimeScope@var161 ( LifetimeScope :: Local ) ,
111: valueKind@var166 ( ValueKind :: Possible )
112: { }
113: Value ( const Token * c@var102 , long long val@var103 , Bound b@var104 = Bound :: Point ) ;
114:
115: static Value unknown ( ) ;
116:
117: bool equalValue ( const ValueFlow :: Value & rhs@var105 ) const {
118: if (@expr1073747154 valueType@var141 !=@expr1073747155 rhs@var105 .@expr1073747156 valueType@var106 ) {
119: return false ; }
120: switch (@expr1073747157 valueType@var141 ) {
121: case ValueType ::@expr1073747158 INT :@expr5335
122: case ValueType ::@expr1073747160 CONTAINER_SIZE :@expr5335
123: case ValueType ::@expr1073747162 BUFFER_SIZE :@expr5335
124: case ValueType ::@expr1073747164 ITERATOR_START :@expr5335
125: case ValueType ::@expr1073747166 ITERATOR_END :@expr5335 ;
126: if (@expr5344 intvalue@var143 !=@expr5345 rhs@var105 .@expr5346 intvalue@var107 ) {
127: return false ; }
128: break ;
129: case ValueType ::@expr1073747171 TOK :@expr5335 ;
130: if (@expr5349 tokvalue@var144 !=@expr5350 rhs@var105 .@expr5351 tokvalue@var108 ) {
131: return false ; }
132: break ;
133: case ValueType ::@expr1073747176 FLOAT :@expr5335 ;
134:
135: if (@expr1073747178 floatValue@var145 >@expr1073747179 rhs@var105 .@expr5356 floatValue@var109 ||@expr1073747181 floatValue@var145 <@expr1073747182 rhs@var105 .@expr5356 floatValue@var109 ) {
136: return false ; }
137: break ;
138: case ValueType ::@expr1073747184 MOVED :@expr5335 ;
139: if (@expr1073747186 moveKind@var146 !=@expr1073747187 rhs@var105 .@expr1073747188 moveKind@var110 ) {
140: return false ; }
141: break ;
142: case ValueType ::@expr1073747189 UNINIT :@expr5335 ;
143: break ;
144: case ValueType ::@expr1073747191 LIFETIME :@expr5335 ;
145: if (@expr5349 tokvalue@var144 !=@expr5350 rhs@var105 .@expr5351 tokvalue@var108 ) {
146: return false ; }
147: break ;
148: case ValueType ::@expr1073747196 SYMBOLIC :@expr5335 ;
149: if (@expr1073747198 !@expr1073747199 sameToken (@expr1073747200 tokvalue@var144 , rhs@var105 .@expr5351 tokvalue@var108 ) ) {
150: return false ; }
151: if (@expr5344 intvalue@var143 !=@expr5345 rhs@var105 .@expr5346 intvalue@var107 ) {
152: return false ; }
153: break ;
154: }
155: return true ;
156: }
157:
158: template < class T , class F >
159: static void visitValue ( T & self@var111 , F f@var112 ) {
160: switch (@expr1073747205 self@var111 .@expr1073747206 valueType@var113 ) {
161: case ValueType ::@expr1073747207 INT :@expr5384
162: case ValueType ::@expr1073747209 SYMBOLIC :@expr5384
163: case ValueType ::@expr1073747211 BUFFER_SIZE :@expr5384
164: case ValueType ::@expr1073747213 CONTAINER_SIZE :@expr5384
165: case ValueType ::@expr1073747215 ITERATOR_START :@expr5384
166: case ValueType ::@expr1073747217 ITERATOR_END :@expr5384 ; {
167: f@var112 (@expr1073747219 self@var111 .@expr1073747220 intvalue@var114 ) ;
168: break ;
169: }
170: case ValueType ::@expr1073747221 FLOAT :@expr5384 ; {
171: f@var112 (@expr1073747223 self@var111 .@expr1073747224 floatValue@var115 ) ;
172: break ;
173: }
174: case ValueType ::@expr1073747225 UNINIT :@expr5384
175: case ValueType ::@expr1073747227 TOK :@expr5384
176: case ValueType ::@expr1073747229 LIFETIME :@expr5384
177: case ValueType ::@expr1073747231 MOVED :@expr5384 ;
178: break ;
179: }
180: }
181:
182: struct compareVisitor {
183: struct innerVisitor {
184: template < class Compare , class T , class U >
185: void operator() ( bool & result@var116 , Compare compare@var117 , T x@var118 , U y@var119 ) const {
186: result@var116 =@expr1073747233 compare@var117 (@expr1073747234 x@var118 , y@var119 ) ;
187: }
188: } ;
189: template < class Compare , class T >
190: void operator() ( bool & result@var120 , const Value & rhs@var121 , Compare compare@var122 , T x@var123 ) const {
191: visitValue (@expr1073747236 rhs@var121 ,
192: std ::@expr1073747237 bind (@expr1073747238 innerVisitor {@expr1073747239 } , std ::@expr1073747240 ref (@expr1073747241 result@var120 ) , std ::@expr1073747242 move (@expr1073747243 compare@var122 ) , x@var123 , std ::@expr1073747244 placeholders ::@expr1073747245 _1@expr1073747235 ) ) ;
193: }
194: } ;
195:
196: template < class Compare >
197: bool compareValue ( const Value & rhs@var124 , Compare compare@var125 ) const {
198: assert (@expr1073747247 (@expr1073747248 !@expr1073747249 this@expr5426 .@expr1073747251 isSymbolicValue (@expr1073747252 ) &&@expr1073747253 !@expr1073747254 rhs@var124 .@expr1073747255 isSymbolicValue (@expr1073747256 ) ) ||@expr1073747257
199: (@expr1073747258 this@expr5426 .@expr1073747259 valueType@var141 ==@expr1073747260 rhs@var124 .@expr1073747261 valueType@var126 &&@expr1073747262 sameToken (@expr1073747263 this@expr5426 .@expr1073747264 tokvalue@var144 , rhs@var124 .@expr1073747265 tokvalue@var127 ) ) ) ;
200: bool result@var128 ; result@var128 =@expr1073747266 false ;
201: visitValue (@expr1073747267
202: *@expr1073747268 this@expr5426 ,
203: std ::@expr1073747269 bind (@expr1073747270 compareVisitor {@expr1073747271 } , std ::@expr5448 ref (@expr1073747273 result@var128 ) , std ::@expr5448 ref (@expr1073747275 rhs@var124 ) , std ::@expr1073747276 move (@expr1073747277 compare@var125 ) , std ::@expr1073747278 placeholders ::@expr1073747279 _1@expr1073747246 ) ) ;
204: return result@var128 ;
205: }
206:
207: bool operator== ( const Value & rhs@var129 ) const {
208: if (@expr1073747280 !@expr1073747281 equalValue (@expr1073747282 rhs@var129 ) ) {
209: return false ; }
210:
211: return varvalue@var147 ==@expr1073747283 rhs@var129 .@expr1073747284 varvalue@var130 &&@expr1073747285
212: condition@var148 ==@expr1073747286 rhs@var129 .@expr1073747287 condition@var131 &&@expr1073747288
213: varId@var150 ==@expr1073747289 rhs@var129 .@expr1073747290 varId@var132 &&@expr1073747291
214: conditional@var152 ==@expr1073747292 rhs@var129 .@expr1073747293 conditional@var133 &&@expr1073747294
215: defaultArg@var154 ==@expr1073747295 rhs@var129 .@expr1073747296 defaultArg@var134 &&@expr1073747297
216: indirect@var155 ==@expr1073747298 rhs@var129 .@expr1073747299 indirect@var135 &&@expr1073747300
217: valueKind@var166 ==@expr1073747301 rhs@var129 .@expr1073747302 valueKind@var136 ;
218: }
219:
220: bool operator!= ( const Value & rhs@var137 ) const {
221: return !@expr1073747303 (@expr1073747304 *@expr1073747305 this@expr1073747306 ==@expr1073747307 rhs@var137 ) ;
222: }
223:
224: template < class T , $class $= $typename $std $:: $enable_if $< std :: is_arithmetic < T > $:: $value $> $:: $type >
225: bool equalTo ( const T & x@var138 ) const {
226: bool result@var139 ; result@var139 =@expr1073747309 false ;
227: visitValue (@expr1073747310 *@expr1073747311 this@expr1073747312 , std ::@expr1073747313 bind (@expr1073747314 equalVisitor {@expr1073747315 } , std ::@expr1073747316 ref (@expr1073747317 result@var139 ) , x@var138 , std ::@expr1073747318 placeholders ::@expr1073747319 _1@expr1073747308 ) ) ;
228: return result@var139 ;
229: }
230:
231: void decreaseRange ( ) {
232: if (@expr1073747320 bound@var142 ==@expr1073747321 Bound ::@expr1073747322 Lower ) {
233: visitValue (@expr1073747323 *@expr5500 this@expr5501 , increment {@expr1073747326 } ) ; }
234: else { if (@expr1073747327 bound@var142 ==@expr1073747328 Bound ::@expr1073747329 Upper ) {
235: visitValue (@expr1073747330 *@expr5500 this@expr5501 , decrement {@expr1073747332 } ) ; } }
236: }
237:
238: void invertBound ( ) {
239: if (@expr1073747333 bound@var142 ==@expr1073747334 Bound ::@expr5511 Lower ) {
240: bound@var142 =@expr1073747336 Bound ::@expr5513 Upper ; }
241: else { if (@expr1073747338 bound@var142 ==@expr1073747339 Bound ::@expr5513 Upper ) {
242: bound@var142 =@expr1073747341 Bound ::@expr5511 Lower ; } }
243: }
244:
245: void invertRange ( ) {
246: invertBound (@expr1073747343 ) ;
247: decreaseRange (@expr1073747344 ) ;
248: }
249:
250: void assumeCondition ( const Token * tok@var140 ) ;
251:
252: std :: string infoString ( ) const ;
253:
254: enum class ValueType {
255: INT ,
256: TOK ,
257: FLOAT ,
258: MOVED ,
259: UNINIT ,
260: CONTAINER_SIZE ,
261: LIFETIME ,
262: BUFFER_SIZE ,
263: ITERATOR_START ,
264: ITERATOR_END ,
265: SYMBOLIC
266: } ; enum ValueType valueType@var141 ;
267: bool isIntValue ( ) const {
268: return valueType@var141 ==@expr1073747345 ValueType ::@expr1073747346 INT ;
269: }
270: bool isTokValue ( ) const {
271: return valueType@var141 ==@expr1073747347 ValueType ::@expr1073747348 TOK ;
272: }
273: bool isFloatValue ( ) const {
274: return valueType@var141 ==@expr1073747349 ValueType ::@expr1073747350 FLOAT ;
275: }
276: bool isMovedValue ( ) const {
277: return valueType@var141 ==@expr1073747351 ValueType ::@expr1073747352 MOVED ;
278: }
279: bool isUninitValue ( ) const {
280: return valueType@var141 ==@expr1073747353 ValueType ::@expr1073747354 UNINIT ;
281: }
282: bool isContainerSizeValue ( ) const {
283: return valueType@var141 ==@expr1073747355 ValueType ::@expr1073747356 CONTAINER_SIZE ;
284: }
285: bool isLifetimeValue ( ) const {
286: return valueType@var141 ==@expr1073747357 ValueType ::@expr1073747358 LIFETIME ;
287: }
288: bool isBufferSizeValue ( ) const {
289: return valueType@var141 ==@expr1073747359 ValueType ::@expr1073747360 BUFFER_SIZE ;
290: }
291: bool isIteratorValue ( ) const {
292: return valueType@var141 ==@expr1073747361 ValueType ::@expr1073747362 ITERATOR_START ||@expr1073747363 valueType@var141 ==@expr1073747364 ValueType ::@expr1073747365 ITERATOR_END ;
293: }
294: bool isIteratorStartValue ( ) const {
295: return valueType@var141 ==@expr1073747366 ValueType ::@expr1073747367 ITERATOR_START ;
296: }
297: bool isIteratorEndValue ( ) const {
298: return valueType@var141 ==@expr1073747368 ValueType ::@expr1073747369 ITERATOR_END ;
299: }
300: bool isSymbolicValue ( ) const {
301: return valueType@var141 ==@expr1073747370 ValueType ::@expr1073747371 SYMBOLIC ;
302: }
303:
304: bool isLocalLifetimeValue ( ) const {
305: return valueType@var141 ==@expr1073747373 ValueType ::@expr1073747374 LIFETIME &&@expr1073747375 lifetimeScope@var161 ==@expr1073747376 LifetimeScope ::@expr1073747377 Local@expr1073747372 ;
306: }
307:
308: bool isArgumentLifetimeValue ( ) const {
309: return valueType@var141 ==@expr1073747378 ValueType ::@expr1073747379 LIFETIME &&@expr1073747380 lifetimeScope@var161 ==@expr1073747381 LifetimeScope ::@expr1073747382 Argument ;
310: }
311:
312: bool isSubFunctionLifetimeValue ( ) const {
313: return valueType@var141 ==@expr1073747383 ValueType ::@expr1073747384 LIFETIME &&@expr1073747385 lifetimeScope@var161 ==@expr1073747386 LifetimeScope ::@expr1073747387 SubFunction ;
314: }
315:
316: bool isNonValue ( ) const {
317: return isMovedValue (@expr1073747388 ) ||@expr1073747389 isUninitValue (@expr1073747390 ) ||@expr1073747391 isLifetimeValue (@expr1073747392 ) ;
318: }
319:
320:
321: Bound bound@var142 ;
322:
323:
324: long long intvalue@var143 ;
325:
326:
327: const Token * tokvalue@var144 ;
328:
329:
330: double floatValue@var145 ;
331:
332:
333: enum class MoveKind { NonMovedVariable , MovedVariable , ForwardedVariable } ; enum MoveKind moveKind@var146 ;
334:
335:
336: long long varvalue@var147 ;
337:
338:
339: const Token * condition@var148 ;
340:
341: std :: list < std :: pair < const Token * , std :: string > > errorPath@var149 ;
342:
343:
344: int varId@var150 ;
345:
346:
347: bool safe@var151 ;
348:
349:
350: bool conditional@var152 ;
351:
352:
353: bool macro@var153 ;
354:
355:
356: bool defaultArg@var154 ;
357:
358: int indirect@var155 ;
359:
360:
361: long long path@var156 ;
362:
363:
364: long long wideintvalue@var157 ;
365:
366: std :: vector < std :: string > subexpressions@var158 ;
367:
368:
369: const Token * capturetok@var159 ;
370:
371: enum class LifetimeKind {
372:
373: Object ,
374:
375: SubObject ,
376:
377: Lambda ,
378:
379: Iterator ,
380:
381: Address
382: } ; enum LifetimeKind lifetimeKind@var160 ;
383:
384: enum class LifetimeScope { Local , Argument , SubFunction , ThisPointer , ThisValue } ; enum LifetimeScope lifetimeScope@var161 ;
385:
386: static const char * toString ( MoveKind moveKind@var162 ) ;
387: static const char * toString ( LifetimeKind lifetimeKind@var163 ) ;
388: static const char * toString ( LifetimeScope lifetimeScope@var164 ) ;
389: static const char * toString ( Bound bound@var165 ) ;
390:
391:
392: enum class ValueKind {
393:
394: Possible ,
395:
396: Known ,
397:
398: Inconclusive ,
399:
400: Impossible
401: } ; enum ValueKind valueKind@var166 ;
402:
403: void setKnown ( ) {
404: valueKind@var166 =@expr1073747393 ValueKind ::@expr1073747394 Known ;
405: }
406:
407: bool isKnown ( ) const {
408: return valueKind@var166 ==@expr1073747395 ValueKind ::@expr1073747396 Known ;
409: }
410:
411: void setPossible ( ) {
412: valueKind@var166 =@expr1073747398 ValueKind ::@expr1073747399 Possible@expr1073747397 ;
413: }
414:
415: bool isPossible ( ) const {
416: return valueKind@var166 ==@expr1073747401 ValueKind ::@expr1073747402 Possible@expr1073747400 ;
417: }
418:
419: bool isImpossible ( ) const {
420: return valueKind@var166 ==@expr1073747403 ValueKind ::@expr1073747404 Impossible ;
421: }
422:
423: void setImpossible ( ) {
424: valueKind@var166 =@expr1073747405 ValueKind ::@expr1073747406 Impossible ;
425: }
426:
427: void setInconclusive ( bool inconclusive@var167 = true ) {
428: if (@expr1073747407 inconclusive@var167 ) {
429: valueKind@var166 =@expr1073747408 ValueKind ::@expr1073747409 Inconclusive ; }
430: }
431:
432: bool isInconclusive ( ) const {
433: return valueKind@var166 ==@expr1073747410 ValueKind ::@expr1073747411 Inconclusive ;
434: }
435:
436: void changeKnownToPossible ( ) {
437: if (@expr1073747413 isKnown (@expr1073747414 ) ) {
438: valueKind@var166 =@expr1073747415 ValueKind ::@expr1073747416 Possible@expr1073747412 ; }
439: }
440:
441: bool errorSeverity ( ) const {
442: return !@expr1073747417 condition@var148 &&@expr1073747418 !@expr1073747419 defaultArg@var154 ;
443: }
444:
445: static bool sameToken ( const Token * tok1@var168 , const Token * tok2@var169 ) ;
446: } ;
447:
448:
449: const ValueFlow :: Value * valueFlowConstantFoldAST ( Token * expr@var170 , const Settings * settings@var171 ) ;
450:
451:
452: void setValues ( TokenList * tokenlist@var172 , SymbolDatabase * symboldatabase@var173 , ErrorLogger * errorLogger@var174 , const Settings * settings@var175 ) ;
453:
454: std :: string eitherTheConditionIsRedundant ( const Token * condition@var176 ) ;
455:
456: unsigned long getSizeOf ( const ValueType & vt@var177 , const Settings * settings@var178 ) ;
457:
458: const ValueFlow :: Value * findValue ( const std :: list < ValueFlow :: Value > & values@var179 ,
459: const Settings * settings@var180 ,
460: std :: function < bool ( const ValueFlow :: Value & ) > pred@var181 ) ;
461:
462: std :: vector < ValueFlow :: Value > isOutOfBounds ( const Value & size@var182 , const Token * indexTok@var183 , bool possible@var184 = true ) ;
463: }
464:
465: ValueFlow :: Value asImpossible ( ValueFlow :: Value v@var185 ) ;
466:
467: bool isContainerSizeChanged ( const Token * tok@var186 , const Settings * settings@var187 = nullptr , int depth@var188 = 20 ) ;
468:
469: struct LifetimeToken {
470: const Token * token@var189 ;
471: bool addressOf@var190 ;
472: ValueFlow :: Value :: ErrorPath errorPath@var191 ;
473: bool inconclusive@var192 ;
474:
475: LifetimeToken ( ) : token@var189 ( nullptr ) , addressOf@var190 ( false ) , errorPath@var191 ( ) , inconclusive@var192 ( false ) { }
476:
477: LifetimeToken ( const Token * token@var193 , ValueFlow :: Value :: ErrorPath errorPath@var194 )
478: : token@var189 ( token@var193 ) , addressOf@var190 ( false ) , errorPath@var191 ( std :: move ( errorPath@var194 ) ) , inconclusive@var192 ( false )
479: { }
480:
481: LifetimeToken ( const Token * token@var195 , bool addressOf@var196 , ValueFlow :: Value :: ErrorPath errorPath@var197 )
482: : token@var189 ( token@var195 ) , addressOf@var190 ( addressOf@var196 ) , errorPath@var191 ( std :: move ( errorPath@var197 ) ) , inconclusive@var192 ( false )
483: { }
484:
485: static std :: vector < LifetimeToken > setAddressOf ( std :: vector < LifetimeToken > v@var198 , bool b@var199 ) {
486: for (@expr1073747420 LifetimeToken &@expr1073747421 x@var200 :@expr1073747422 v@var198 ) {
487: x@var200 .@expr1073747423 addressOf@var201 =@expr1073747424 b@var199 ; }
488: return v@var198 ;
489: }
490:
491: static std :: vector < LifetimeToken > setInconclusive ( std :: vector < LifetimeToken > v@var202 , bool b@var203 ) {
492: for (@expr1073747425 LifetimeToken &@expr1073747426 x@var204 :@expr1073747427 v@var202 ) {
493: x@var204 .@expr1073747428 inconclusive@var205 =@expr1073747429 b@var203 ; }
494: return v@var202 ;
495: }
496: } ;
497:
498: const Token * parseCompareInt ( const Token * tok@var206 , ValueFlow :: Value & true_value@var207 , ValueFlow :: Value & false_value@var208 , const std :: function < std :: vector < long long > ( const Token * ) > & evaluate@var209 ) ;
499: const Token * parseCompareInt ( const Token * tok@var210 , ValueFlow :: Value & true_value@var211 , ValueFlow :: Value & false_value@var212 ) ;
500:
501: ValueFlow :: Value inferCondition ( std :: string op@var213 , long long val@var214 , const Token * varTok@var215 ) ;
502: ValueFlow :: Value inferCondition ( const std :: string & op@var216 , const Token * varTok@var217 , long long val@var218 ) ;
503:
504: ValuePtr<InferModel> makeIntegralInferModel ( ) ;
505:
506: const Token * solveExprValue ( const Token * expr@var219 ,
507: const std :: function < std :: vector < long long > ( const Token * ) > & eval@var220 ,
508: ValueFlow :: Value & value@var221 ) ;
509:
510: std :: vector < LifetimeToken > getLifetimeTokens ( const Token * tok@var222 ,
511: bool escape@var223 = false ,
512: ValueFlow :: Value :: ErrorPath errorPath@var224 = ValueFlow :: Value :: ErrorPath { } ) ;
513:
514: bool hasLifetimeToken ( const Token * tok@var225 , const Token * lifetime@var226 ) ;
515:
516: const Variable * getLifetimeVariable ( const Token * tok@var227 , ValueFlow :: Value :: ErrorPath & errorPath@var228 , bool * addressOf@var229 = nullptr ) ;
517:
518: const Variable * getLifetimeVariable ( const Token * tok@var230 ) ;
519:
520: bool isLifetimeBorrowed ( const Token * tok@var231 , const Settings * settings@var232 ) ;
521:
522: std :: string lifetimeType ( const Token * tok@var233 , const ValueFlow :: Value * val@var234 ) ;
523:
524: std :: string lifetimeMessage ( const Token * tok@var235 , const ValueFlow :: Value * val@var236 , ValueFlow :: Value :: ErrorPath & errorPath@var237 ) ;
525:
526: ValueFlow :: Value getLifetimeObjValue ( const Token * tok@var238 , bool inconclusive@var239 = false ) ;
527:
528: std :: vector < ValueFlow :: Value > getLifetimeObjValues ( const Token * tok@var240 ,
529: bool inconclusive@var241 = false ,
530: long long path@var242 = 0 ) ;
531:
532: const Token * getEndOfExprScope ( const Token * tok@var243 , const Scope * defaultScope@var244 = nullptr , bool smallest@var245 = true ) ;

##file cppcheck-2.8/lib/analyzer.h

1:
|
27:
28: class Token ;
29: template < class T >
30: class ValuePtr ;
31:
32: struct Analyzer {
33: struct Action {
34:
35: Action ( ) : mFlag@var262 ( 0 ) { }
36:
37: template < class T ,
38: $class $= $typename $std $:: $enable_if $< std :: is_convertible < T , unsigned int > $:: $value $> $:: $type ,
39: $class $= $typename $std $:: $enable_if $< ! std :: is_same < T , bool > $:: $value $> $:: $type >
40: Action ( T f@var246 ) : mFlag@var262 ( f@var246 )
41: { }
42:
43: enum Anonymous0 {
44: None = 0 ,
45: Read = ( 1 << 0 ) ,
46: Write = ( 1 << 1 ) ,
47: Invalid = ( 1 << 2 ) ,
48: Inconclusive = ( 1 << 3 ) ,
49: Match = ( 1 << 4 ) ,
50: Idempotent = ( 1 << 5 ) ,
51: Incremental = ( 1 << 6 ) ,
52: SymbolicMatch = ( 1 << 7 ) ,
53: Internal = ( 1 << 8 ) ,
54: } ;
55:
56: void set ( unsigned int f@var247 , bool state@var248 = true ) {
57: mFlag@var262 =@expr1073747430 state@var248 ?@expr1073747431 mFlag@var262 |@expr1073747432 f@var247 :@expr1073747433 mFlag@var262 &@expr1073747434 ~@expr1073747435 f@var247 ;
58: }
59:
60: bool get ( unsigned int f@var249 ) const {
61: return (@expr5612 (@expr5612 mFlag@var262 &@expr1073747438 f@var249 ) !=@expr1073747439 0 ) ;
62: }
63:
64: bool isRead ( ) const {
65: return get (@expr1073747440 Read ) ;
66: }
67:
68: bool isWrite ( ) const {
69: return get (@expr1073747441 Write ) ;
70: }
71:
72: bool isInvalid ( ) const {
73: return get (@expr1073747442 Invalid ) ;
74: }
75:
76: bool isInconclusive ( ) const {
77: return get (@expr1073747443 Inconclusive ) ;
78: }
79:
80: bool isNone ( ) const {
81: return mFlag@var262 ==@expr1073747444 None ;
82: }
83:
84: bool isModified ( ) const {
85: return isWrite (@expr1073747445 ) ||@expr1073747446 isInvalid (@expr1073747447 ) ;
86: }
87:
88: bool isIdempotent ( ) const {
89: return get (@expr1073747448 Idempotent ) ;
90: }
91:
92: bool isIncremental ( ) const {
93: return get (@expr1073747449 Incremental ) ;
94: }
95:
96: bool isSymbolicMatch ( ) const {
97: return get (@expr1073747450 SymbolicMatch ) ;
98: }
99:
100: bool isInternal ( ) const {
101: return get (@expr1073747451 Internal ) ;
102: }
103:
104: bool matches ( ) const {
105: return get (@expr1073747452 Match ) ;
106: }
107:
108: Action & operator|= ( Action a@var250 ) {
109: set (@expr1073747453 a@var250 .@expr1073747454 mFlag@var251 ) ;
110: return *@expr1073747455 this@expr1073747456 ;
111: }
112:
113: friend Action operator| ( Action a@var252 , Action b@var253 ) {
114: a@var252 |=@expr1073747457 b@var253 ;
115: return a@var252 ;
116: }
117:
118: friend bool operator== ( Action a@var254 , Action b@var255 ) {
119: return a@var254 .@expr1073747458 mFlag@var256 ==@expr1073747459 b@var255 .@expr1073747460 mFlag@var257 ;
120: }
121:
122: friend bool operator!= ( Action a@var258 , Action b@var259 ) {
123: return a@var258 .@expr1073747461 mFlag@var260 !=@expr1073747462 b@var259 .@expr1073747463 mFlag@var261 ;
124: }
125:
126: private:
127: unsigned int mFlag@var262 ;
128: } ;
129:
130: enum class Terminate { None , Bail , Escape , Modified , Inconclusive , Conditional } ;
131:
132: struct Result {
133: Result ( Action action@var263 = Action :: None , Terminate terminate@var264 = Terminate :: None )
134: : action@var265 ( action@var263 ) , terminate@var266 ( terminate@var264 )
135: { }
136: Action action@var265 ;
137: Terminate terminate@var266 ;
138:
139: void update ( Result rhs@var267 ) {
140: if (@expr1073747464 terminate@var266 ==@expr1073747465 Terminate ::@expr1073747466 None ) {
141: terminate@var266 =@expr1073747467 rhs@var267 .@expr1073747468 terminate@var268 ; }
142: action@var265 |=@expr1073747469 rhs@var267 .@expr1073747470 action@var269 ;
143: }
144: } ;
145:
146: enum class Direction { Forward , Reverse } ;
147:
148: struct Assume {
149: enum Flags {
150: None = 0 ,
151: Quiet = ( 1 << 0 ) ,
152: Absolute = ( 1 << 1 ) ,
153: ContainerEmpty = ( 1 << 2 ) ,
154: } ;
155: } ;
156:
157: enum class Evaluate { Integral , ContainerEmpty } ;
158:
159:
160: virtual Action analyze ( const Token * tok@var270 , Direction d@var271 ) const = 0 ;
161:
162: virtual void update ( Token * tok@var272 , Action a@var273 , Direction d@var274 ) = 0 ;
163:
164: virtual std :: vector < long long > evaluate ( Evaluate e@var275 , const Token * tok@var276 , const Token * ctx@var277 = nullptr ) const = 0 ;
165: std :: vector < long long > evaluate ( const Token * tok@var278 , const Token * ctx@var279 = nullptr ) const
166: {
167: return evaluate (@expr1073747471 Evaluate ::@expr1073747472 Integral , tok@var278 , ctx@var279 ) ;
168: }
169:
170: virtual bool lowerToPossible ( ) = 0 ;
171:
172: virtual bool lowerToInconclusive ( ) = 0 ;
173:
174: virtual bool updateScope ( const Token * endBlock@var280 , bool modified@var281 ) const = 0 ;
175:
176: virtual void forkScope ( const Token * ) { }
177:
178: virtual bool isConditional ( ) const = 0 ;
179:
180: virtual bool stopOnCondition ( const Token * condTok@var282 ) const = 0 ;
181:
182: virtual void assume ( const Token * tok@var283 , bool state@var284 , unsigned int flags@var285 = 0 ) = 0 ;
183:
184: virtual ValuePtr<Analyzer> reanalyze ( Token * tok@var286 , const std :: string & msg@var287 = "" ) const = 0 ;
185: virtual ~ Analyzer ( ) { }
186: } ;

##file cppcheck-2.8/lib/errortypes.h

1:
|
31:
32: class Token ;
33:
34:
35: struct InternalError {
36: enum Type { AST , SYNTAX , UNKNOWN_MACRO , INTERNAL , LIMIT , INSTANTIATION } ;
37: InternalError ( const Token * tok@var288 , const std :: string & errorMsg@var289 , Type type@var290 = INTERNAL ) ;
38: const Token * token@var291 ;
39: std :: string errorMessage@var292 ;
40: Type type@var293 ;
41: std :: string id@var294 ;
42: } ;
43:
44: class Certainty {
45: public:
46: enum CertaintyLevel {
47: normal , inconclusive , safe , experimental
48: } ;
49: } ;
50:
51: class Checks {
52: public:
53: enum CheckList {
54: unusedFunction , missingInclude , internalCheck
55: } ;
56: } ;
57:
58:
59: class Severity {
60: public:
61:
62:
63:
64: enum SeverityType {
65:
66:
67:
68: none ,
69:
|
73:
74: error ,
75:
|
79:
80: warning ,
81:
|
86:
87: style ,
88:
|
92:
93: performance ,
94:
|
100:
101: portability ,
102:
|
107:
108: information ,
109:
|
112:
113: debug
114: } ;
115:
116: static std :: string toString ( SeverityType severity@var295 ) ;
117: static SeverityType fromString ( const std :: string & severity@var296 ) ;
118: } ;
119:
120: struct CWE {
121: explicit CWE ( unsigned short cweId@var297 ) : id@var298 ( cweId@var297 ) { }
122: unsigned short id@var298 ;
123: } ;

##file cppcheck-2.8/lib/utils.h

1:
|
31:
32: struct SelectMapKeys {
33: template < class Pair >
34: Pair :: first_type operator() ( const Pair & p@var299 ) const {
35: return p@var299 .@expr1073747473 first@var300 ;
36: }
37: } ;
38:
39: struct SelectMapValues {
40: template < class Pair >
41: Pair :: second_type operator() ( const Pair & p@var301 ) const {
42: return p@var301 .@expr1073747474 second@var302 ;
43: }
44: } ;
45:
46: template < class Range , class T >
47: bool contains ( const Range & r@var303 , const T & x@var304 )
48: {
49: return std ::@expr1073747475 find (@expr1073747476 r@var303 .@expr1073747477 begin (@expr1073747478 ) , r@var303 .@expr5655 end (@expr5656 ) , x@var304 ) !=@expr1073747481 r@var303 .@expr5655 end (@expr5656 ) ;
50: }
51:
52: template < class T >
53: bool contains ( const std :: initializer_list < T > & r@var305 , const T & x@var306 )
54: {
55: return std ::@expr1073747484 find (@expr1073747485 r@var305 .@expr1073747486 begin (@expr1073747487 ) , r@var305 .@expr5664 end (@expr5665 ) , x@var306 ) !=@expr1073747490 r@var305 .@expr5664 end (@expr5665 ) ;
56: }
57:
58: template < class T , class U >
59: bool contains ( const std :: initializer_list < T > & r@var307 , const U & x@var308 )
60: {
61: return std ::@expr1073747493 find (@expr1073747494 r@var307 .@expr1073747495 begin (@expr1073747496 ) , r@var307 .@expr5673 end (@expr5674 ) , x@var308 ) !=@expr1073747499 r@var307 .@expr5673 end (@expr5674 ) ;
62: }
63:
64:
65: struct EnumClassHash {
66: template < typename T >
67: unsigned long operator() ( T t@var309 ) const
68: {
69: return static_cast < unsigned long > (@expr1073747502 t@var309 ) ;
70: }
71: } ;
72:
73: bool endsWith ( const std :: string & str@var310 , char c@var311 )
74: {
75: return !@expr1073747503 str@var310 .@expr1073747504 empty (@expr1073747505 ) &&@expr1073747506 str@var310 .@expr1073747507 back (@expr1073747508 ) ==@expr1073747509 c@var311 ;
76: }
77:
78: bool endsWith ( const std :: string & str@var312 , const char end@var313 [ ] , unsigned long endlen@var314 )
79: {
80: return (@expr5686 str@var312 .@expr5687 size (@expr5688 ) >=@expr1073747513 endlen@var314 ) &&@expr1073747514 (@expr5686 str@var312 .@expr1073747516 compare (@expr1073747517 str@var312 .@expr5687 size (@expr5688 ) -@expr1073747520 endlen@var314 , endlen@var314 , end@var313 ) ==@expr1073747521 0 ) ;
81: }
82:
83: template < unsigned long N >
84: bool endsWith ( const std :: string & str@var315 , const char ( & end@var316 ) [ N ] )
85: {
86: return endsWith (@expr1073747523 str@var315 , end@var316 , N@expr1073747522 -@expr1073747524 1 ) ;
87: }
88:
89: static bool isPrefixStringCharLiteral ( const std :: string & str@var317 , char q@var318 , const std :: string & p@var319 )
90: {
91: if (@expr1073747525 !@expr1073747526 endsWith (@expr1073747527 str@var317 , q@var318 ) ) {
92: return false ; }
93: if (@expr1073747528 (@expr1073747529 str@var317 .@expr1073747530 length (@expr1073747531 ) +@expr1073747532 1 ) >@expr1073747533 p@var319 .@expr1073747534 length (@expr1073747535 ) &&@expr1073747536 (@expr1073747537 str@var317 .@expr1073747538 compare (@expr1073747539 0 , p@var319 .@expr1073747540 size (@expr1073747541 ) +@expr1073747542 1 , p@var319 +@expr1073747543 q@var318 ) ==@expr1073747544 0 ) ) {
94: return true ; }
95: return false ;
96: }
97:
98: static bool isStringCharLiteral ( const std :: string & str@var320 , char q@var321 )
99: {
100: static const std ::@expr5721 vector < std ::@expr5721 string > suffixes@var322 {@expr1073747547 "" , "u8" , "u" , "U" , "L" } ;
101: for (@expr1073747548 const std ::@expr5721 string &@expr1073747550 p@var323 :@expr1073747551 suffixes@var322 ) {
102: if (@expr1073747552 isPrefixStringCharLiteral (@expr1073747553 str@var320 , q@var321 , p@var323 ) ) {
103: return true ; }
104: }
105: return false ;
106: }
107:
108: static bool isStringLiteral ( const std :: string & str@var324 )
109: {
110: return isStringCharLiteral (@expr1073747554 str@var324 , '"' ) ;
111: }
112:
113: static bool isCharLiteral ( const std :: string & str@var325 )
114: {
115: return isStringCharLiteral (@expr1073747555 str@var325 , '\'' ) ;
116: }
117:
118: static std :: string getStringCharLiteral ( const std :: string & str@var326 , char q@var327 )
119: {
120: const unsigned long quotePos@var328 =@expr1073747556 str@var326 .@expr1073747557 find (@expr1073747558 q@var327 ) ;
121: return str@var326 .@expr1073747559 substr (@expr1073747560 quotePos@var328 +@expr1073747561 1U , str@var326 .@expr1073747562 size (@expr1073747563 ) -@expr1073747564 quotePos@var328 -@expr1073747565 2U ) ;
122: }
123:
124: static std :: string getStringLiteral ( const std :: string & str@var329 )
125: {
126: if (@expr1073747566 isStringLiteral (@expr1073747567 str@var329 ) ) {
127: return getStringCharLiteral (@expr1073747568 str@var329 , '"' ) ; }
128: return "" ;
129: }
130:
131: static std :: string getCharLiteral ( const std :: string & str@var330 )
132: {
133: if (@expr1073747569 isCharLiteral (@expr1073747570 str@var330 ) ) {
134: return getStringCharLiteral (@expr1073747571 str@var330 , '\'' ) ; }
135: return "" ;
136: }
137:
138: static const char * getOrdinalText ( int i@var331 )
139: {
140: if (@expr1073747572 i@var331 ==@expr1073747573 1 ) {
141: return "st" ; }
142: if (@expr1073747574 i@var331 ==@expr1073747575 2 ) {
143: return "nd" ; }
144: if (@expr1073747576 i@var331 ==@expr1073747577 3 ) {
145: return "rd" ; }
146: return "th" ;
147: }
148:
149: int caseInsensitiveStringCompare ( const std :: string & lhs@var332 , const std :: string & rhs@var333 ) ;
150:
151: bool isValidGlobPattern ( const std :: string & pattern@var334 ) ;
152:
153: bool matchglob ( const std :: string & pattern@var335 , const std :: string & name@var336 ) ;
154:
155: bool matchglobs ( const std :: vector < std :: string > & patterns@var337 , const std :: string & name@var338 ) ;
156:
157: void strTolower ( std :: string & str@var339 ) ;

##file cppcheck-2.8/lib/standards.h

1:
|
35:
36: struct Standards {
37:
38: enum cstd_t { C89 , C99 , C11 , CLatest = C11 } ; enum cstd_t c@var340 ;
39:
40:
41: enum cppstd_t { CPP03 , CPP11 , CPP14 , CPP17 , CPP20 , CPP23 , CPPLatest = CPP23 } ; enum cppstd_t cpp@var341 ;
42:
43:
44: std :: string stdValue@var342 ;
45:
46:
47: Standards ( ) : c@var340 ( CLatest ) , cpp@var341 ( CPPLatest ) { }
48:
49: bool setC ( const std :: string & str@var343 ) {
50: stdValue@var342 =@expr1073747578 str@var343 ;
51: if (@expr1073747579 str@var343 ==@expr1073747580 "c89" ||@expr1073747581 str@var343 ==@expr1073747582 "C89" ) {
52: c@var340 =@expr1073747583 C89 ;
53: return true ;
54: }
55: if (@expr1073747584 str@var343 ==@expr1073747585 "c99" ||@expr1073747586 str@var343 ==@expr1073747587 "C99" ) {
56: c@var340 =@expr1073747588 C99 ;
57: return true ;
58: }
59: if (@expr1073747589 str@var343 ==@expr1073747590 "c11" ||@expr1073747591 str@var343 ==@expr1073747592 "C11" ) {
60: c@var340 =@expr1073747593 C11 ;
61: return true ;
62: }
63: return false ;
64: }
65: const std :: string getC ( ) const {
66: switch (@expr1073747594 c@var340 ) {
67: case C89 :@expr5771 ;
68: return "c89" ;
69: case C99 :@expr5771 ;
70: return "c99" ;
71: case C11 :@expr5771 ;
72: return "c11" ;
73: }
74: return "" ;
75: }
76: static cstd_t getC ( const std :: string & std@var344 ) {
77: if (@expr1073747598 std@var344 ==@expr1073747599 "c89" ) {
78: return Standards ::@expr1073747600 C89 ;
79: }
80: if (@expr1073747601 std@var344 ==@expr1073747602 "c99" ) {
81: return Standards ::@expr1073747603 C99 ;
82: }
83: if (@expr1073747604 std@var344 ==@expr1073747605 "c11" ) {
84: return Standards ::@expr1073747606 C11 ;
85: }
86: return Standards ::@expr1073747607 CLatest ;
87: }
88: bool setCPP ( std :: string str@var345 ) {
89: stdValue@var342 =@expr1073747608 str@var345 ;
90: strTolower (@expr1073747609 str@var345 ) ;
91: cpp@var341 =@expr1073747610 getCPP (@expr1073747611 str@var345 ) ;
92: return !@expr1073747612 stdValue@var342 .@expr1073747613 empty (@expr1073747614 ) &&@expr1073747615 str@var345 ==@expr1073747616 getCPP (@expr1073747617 ) ;
93: }
94: std :: string getCPP ( ) const {
95: return getCPP (@expr1073747618 cpp@var341 ) ;
96: }
97: static std :: string getCPP ( cppstd_t std@var346 ) {
98: switch (@expr1073747619 std@var346 ) {
99: case CPP03 :@expr5796 ;
100: return "c++03" ;
101: case CPP11 :@expr5796 ;
102: return "c++11" ;
103: case CPP14 :@expr5796 ;
104: return "c++14" ;
105: case CPP17 :@expr5796 ;
106: return "c++17" ;
107: case CPP20 :@expr5796 ;
108: return "c++20" ;
109: case CPP23 :@expr5796 ;
110: return "c++23" ;
111: }
112: return "" ;
113: }
114: static cppstd_t getCPP ( const std :: string & std@var347 ) {
115: if (@expr1073747626 std@var347 ==@expr1073747627 "c++03" ) {
116: return Standards ::@expr1073747628 CPP03 ;
117: }
118: if (@expr1073747629 std@var347 ==@expr1073747630 "c++11" ) {
119: return Standards ::@expr1073747631 CPP11 ;
120: }
121: if (@expr1073747632 std@var347 ==@expr1073747633 "c++14" ) {
122: return Standards ::@expr1073747634 CPP14 ;
123: }
124: if (@expr1073747635 std@var347 ==@expr1073747636 "c++17" ) {
125: return Standards ::@expr1073747637 CPP17 ;
126: }
127: if (@expr1073747638 std@var347 ==@expr1073747639 "c++20" ) {
128: return Standards ::@expr1073747640 CPP20 ;
129: }
130: if (@expr1073747641 std@var347 ==@expr1073747642 "c++23" ) {
131: return Standards ::@expr1073747643 CPP23 ;
132: }
133: return Standards ::@expr1073747644 CPPLatest ;
134: }
135: } ;

##file cppcheck-2.8/lib/library.h

1:
|
37:
38: class Token ;
39: class Settings ;
40:
41: namespace tinyxml2 {
42: class XMLDocument ;
43: class XMLElement ;
44: }
45:
|
51:
52: class Library {
53: friend class TestSymbolDatabase ;
54:
55: public:
56: Library ( ) ;
57:
58: enum class ErrorCode { OK , FILE_NOT_FOUND , BAD_XML , UNKNOWN_ELEMENT , MISSING_ATTRIBUTE , BAD_ATTRIBUTE_VALUE , UNSUPPORTED_FORMAT , DUPLICATE_PLATFORM_TYPE , PLATFORM_TYPE_REDEFINED } ;
59:
60: class Error {
61: public:
62: Error ( ) : errorcode@var351 ( ErrorCode :: OK ) { }
63: explicit Error ( ErrorCode e@var348 ) : errorcode@var351 ( e@var348 ) { }
64: template < typename T >
65: Error ( ErrorCode e@var349 , T && r@var350 ) : errorcode@var351 ( e@var349 ) , reason@var352 ( r@var350 ) { }
66: ErrorCode errorcode@var351 ;
67: std :: string reason@var352 ;
68: } ;
69:
70: Error load ( const char exename@var353 [ ] , const char path@var354 [ ] ) ;
71: Error load ( const tinyxml2 :: XMLDocument & doc@var355 ) ;
72:
73:
74: bool loadxmldata ( const char xmldata@var356 [ ] , unsigned long len@var357 ) ;
75:
76: struct AllocFunc {
77: int groupId@var358 ;
78: int arg@var359 ;
79: enum class BufferSize { none , malloc , calloc , strdup } ;
80: BufferSize bufferSize@var360 ;
81: int bufferSizeArg1@var361 ;
82: int bufferSizeArg2@var362 ;
83: int reallocArg@var363 ;
84: bool initData@var364 ;
85: } ;
86:
87:
88: const AllocFunc * getAllocFuncInfo ( const Token * tok@var365 ) const ;
89:
90:
91: const AllocFunc * getDeallocFuncInfo ( const Token * tok@var366 ) const ;
92:
93:
94: const AllocFunc * getReallocFuncInfo ( const Token * tok@var367 ) const ;
95:
96:
97: int getAllocId ( const Token * tok@var368 , int arg@var369 ) const ;
98:
99:
100: int getDeallocId ( const Token * tok@var370 , int arg@var371 ) const ;
101:
102:
103: int getReallocId ( const Token * tok@var372 , int arg@var373 ) const ;
104:
105:
106: const AllocFunc * getAllocFuncInfo ( const char name@var374 [ ] ) const {
107: return getAllocDealloc (@expr1073747645 mAlloc@var640 , name@var374 ) ;
108: }
109:
110:
111: const AllocFunc * getDeallocFuncInfo ( const char name@var375 [ ] ) const {
112: return getAllocDealloc (@expr1073747646 mDealloc@var641 , name@var375 ) ;
113: }
114:
115:
116: int allocId ( const char name@var376 [ ] ) const {
117: const AllocFunc * af@var377 ; af@var377 =@expr1073747647 getAllocDealloc (@expr1073747648 mAlloc@var640 , name@var376 ) ;
118: return af@var377 ?@expr1073747649 af@var377 .@expr1073747650 groupId@var378 :@expr1073747651 0 ;
119: }
120:
121:
122: int deallocId ( const char name@var379 [ ] ) const {
123: const AllocFunc * af@var380 ; af@var380 =@expr1073747652 getAllocDealloc (@expr1073747653 mDealloc@var641 , name@var379 ) ;
124: return af@var380 ?@expr1073747654 af@var380 .@expr1073747655 groupId@var381 :@expr1073747656 0 ;
125: }
126:
127:
128: void setalloc ( const std :: string & functionname@var382 , int id@var383 , int arg@var384 ) {
129: mAlloc@var640 [@expr5833 functionname@var382 ] .@expr1073747658 groupId@var5306 =@expr1073747659 id@var383 ;
130: mAlloc@var640 [@expr5833 functionname@var382 ] .@expr1073747661 arg@var5307 =@expr1073747662 arg@var384 ;
131: }
132:
133: void setdealloc ( const std :: string & functionname@var385 , int id@var386 , int arg@var387 ) {
134: mDealloc@var641 [@expr5839 functionname@var385 ] .@expr1073747664 groupId@var5308 =@expr1073747665 id@var386 ;
135: mDealloc@var641 [@expr5839 functionname@var385 ] .@expr1073747667 arg@var5309 =@expr1073747668 arg@var387 ;
136: }
137:
138: void setrealloc ( const std :: string & functionname@var388 , int id@var389 , int arg@var390 , int reallocArg@var391 = 1 ) {
139: mRealloc@var642 [@expr5845 functionname@var388 ] .@expr1073747670 groupId@var5310 =@expr1073747671 id@var389 ;
140: mRealloc@var642 [@expr5845 functionname@var388 ] .@expr1073747673 arg@var5311 =@expr1073747674 arg@var390 ;
141: mRealloc@var642 [@expr5845 functionname@var388 ] .@expr1073747676 reallocArg@var5312 =@expr1073747677 reallocArg@var391 ;
142: }
143:
144:
145: void setnoreturn ( const std :: string & funcname@var392 , bool noreturn@var393 ) {
146: mNoReturn@var643 [@expr1073747678 funcname@var392 ] =@expr1073747679 noreturn@var393 ?@expr1073747680 FalseTrueMaybe ::@expr1073747681 True :@expr1073747682 FalseTrueMaybe ::@expr1073747683 False ;
147: }
148:
149: static bool isCompliantValidationExpression ( const char * p@var394 ) ;
150:
151:
152: static bool ismemory ( const int id@var395 ) {
153: return (@expr5860 (@expr5860 id@var395 >@expr1073747686 0 ) &&@expr1073747687 (@expr5860 (@expr5860 id@var395 &@expr1073747690 1 ) ==@expr1073747691 0 ) ) ;
154: }
155: static bool ismemory ( const AllocFunc * const func@var396 ) {
156: return (@expr5868 (@expr5868 func@var396 .@expr5870 groupId@var397 >@expr1073747695 0 ) &&@expr1073747696 (@expr5868 (@expr5868 func@var396 .@expr5870 groupId@var397 &@expr1073747700 1 ) ==@expr1073747701 0 ) ) ;
157: }
158:
159:
160: static bool isresource ( const int id@var398 ) {
161: return (@expr5878 (@expr5878 id@var398 >@expr1073747704 0 ) &&@expr1073747705 (@expr5878 (@expr5878 id@var398 &@expr1073747708 1 ) ==@expr1073747709 1 ) ) ;
162: }
163: static bool isresource ( const AllocFunc * const func@var399 ) {
164: return (@expr5886 (@expr5886 func@var399 .@expr5888 groupId@var400 >@expr1073747713 0 ) &&@expr1073747714 (@expr5886 (@expr5886 func@var399 .@expr5888 groupId@var400 &@expr1073747718 1 ) ==@expr1073747719 1 ) ) ;
165: }
166:
167: bool formatstr_function ( const Token * ftok@var401 ) const ;
168: int formatstr_argno ( const Token * ftok@var402 ) const ;
169: bool formatstr_scan ( const Token * ftok@var403 ) const ;
170: bool formatstr_secure ( const Token * ftok@var404 ) const ;
171:
172: struct NonOverlappingData {
173: int ptr1Arg@var405 ;
174: int ptr2Arg@var406 ;
175: int sizeArg@var407 ;
176: int strlenArg@var408 ;
177: } ;
178: const NonOverlappingData * getNonOverlappingData ( const Token * ftok@var409 ) const ;
179:
180: struct WarnInfo {
181: std :: string message@var410 ;
182: Standards standards@var411 ;
183: Severity :: SeverityType severity@var412 ;
184: } ;
185: std :: map < std :: string , WarnInfo > functionwarn@var413 ;
186:
187: const WarnInfo * getWarnInfo ( const Token * ftok@var414 ) const ;
188:
189:
190: bool isNotLibraryFunction ( const Token * ftok@var415 ) const ;
191: bool matchArguments ( const Token * ftok@var416 , const std :: string & functionName@var417 ) const ;
192:
193: enum class UseRetValType { NONE , DEFAULT , ERROR_CODE } ;
194: UseRetValType getUseRetValType ( const Token * ftok@var418 ) const ;
195:
196: const std :: string & returnValue ( const Token * ftok@var419 ) const ;
197: const std :: string & returnValueType ( const Token * ftok@var420 ) const ;
198: int returnValueContainer ( const Token * ftok@var421 ) const ;
199: std :: vector < long long > unknownReturnValues ( const Token * ftok@var422 ) const ;
200:
201: bool isnoreturn ( const Token * ftok@var423 ) const ;
202: bool isnotnoreturn ( const Token * ftok@var424 ) const ;
203:
204: bool isScopeNoReturn ( const Token * end@var425 , std :: string * unknownFunc@var426 ) const ;
205:
206: class Container {
207: public:
208: Container ( )
209: : type_templateArgNo@var436 ( -1 ) ,
210: size_templateArgNo@var438 ( -1 ) ,
211: arrayLike_indexOp@var439 ( false ) ,
212: stdStringLike@var440 ( false ) ,
213: stdAssociativeLike@var441 ( false ) ,
214: opLessAllowed@var442 ( true ) ,
215: hasInitializerListConstructor@var443 ( false ) ,
216: unstableErase@var444 ( false ) ,
217: unstableInsert@var445 ( false ) ,
218: view@var446 ( false )
219: { }
220:
221: enum class Action {
222: RESIZE ,
223: CLEAR ,
224: PUSH ,
225: POP ,
226: FIND ,
227: INSERT ,
228: ERASE ,
229: CHANGE_CONTENT ,
230: CHANGE ,
231: CHANGE_INTERNAL ,
232: NO_ACTION
233: } ;
234: enum class Yield {
235: AT_INDEX ,
236: ITEM ,
237: BUFFER ,
238: BUFFER_NT ,
239: START_ITERATOR ,
240: END_ITERATOR ,
241: ITERATOR ,
242: SIZE ,
243: EMPTY ,
244: NO_YIELD
245: } ;
246: struct Function {
247: Action action@var427 ;
248: Yield yield@var428 ;
249: } ;
250: struct RangeItemRecordTypeItem {
251: std :: string name@var429 ;
252: int templateParameter@var430 ;
253: } ;
254: std :: string startPattern@var431 ; std :: string startPattern2@var432 ; std :: string endPattern@var433 ; std :: string itEndPattern@var434 ;
255: std :: map < std :: string , Function > functions@var435 ;
256: int type_templateArgNo@var436 ;
257: std :: vector < RangeItemRecordTypeItem > rangeItemRecordType@var437 ;
258: int size_templateArgNo@var438 ;
259: bool arrayLike_indexOp@var439 ;
260: bool stdStringLike@var440 ;
261: bool stdAssociativeLike@var441 ;
262: bool opLessAllowed@var442 ;
263: bool hasInitializerListConstructor@var443 ;
264: bool unstableErase@var444 ;
265: bool unstableInsert@var445 ;
266: bool view@var446 ;
267:
268: Action getAction ( const std :: string & function@var447 ) const {
269: const std ::@expr1073747720 map < std ::@expr1073747721 string , Function > ::@expr1073747722 const_iterator i@var448 =@expr1073747723 functions@var435 .@expr1073747724 find (@expr1073747725 function@var447 ) ;
270: if (@expr1073747726 i@var448 !=@expr1073747727 functions@var435 .@expr1073747728 end (@expr1073747729 ) ) {
271: return i@var448 .@expr1073747730 second@var449 .@expr1073747731 action@var450 ; }
272: return Action ::@expr1073747732 NO_ACTION ;
273: }
274:
275: Yield getYield ( const std :: string & function@var451 ) const {
276: const std ::@expr1073747733 map < std ::@expr1073747734 string , Function > ::@expr1073747735 const_iterator i@var452 =@expr1073747736 functions@var435 .@expr1073747737 find (@expr1073747738 function@var451 ) ;
277: if (@expr1073747739 i@var452 !=@expr1073747740 functions@var435 .@expr1073747741 end (@expr1073747742 ) ) {
278: return i@var452 .@expr1073747743 second@var453 .@expr1073747744 yield@var454 ; }
279: return Yield ::@expr1073747745 NO_YIELD ;
280: }
281:
282: static Yield yieldFrom ( const std :: string & yieldName@var455 ) ;
283: static Action actionFrom ( const std :: string & actionName@var456 ) ;
284: } ;
285: std :: map < std :: string , Container > containers@var457 ;
286: const Container * detectContainer ( const Token * typeStart@var458 , bool iterator@var459 = false ) const ;
287: const Container * detectContainerOrIterator ( const Token * typeStart@var460 , bool * isIterator@var461 = nullptr ) const ;
288:
289: class ArgumentChecks {
290: public:
291: ArgumentChecks ( ) :
292: notbool@var462 ( false ) ,
293: notnull@var463 ( false ) ,
294: notuninit@var464 ( -1 ) ,
295: formatstr@var465 ( false ) ,
296: strz@var466 ( false ) ,
297: optional@var467 ( false ) ,
298: variadic@var468 ( false ) ,
299: iteratorInfo@var474 ( ) ,
300: direction@var482 ( Direction :: DIR_UNKNOWN ) { }
301:
302: bool notbool@var462 ;
303: bool notnull@var463 ;
304: int notuninit@var464 ;
305: bool formatstr@var465 ;
306: bool strz@var466 ;
307: bool optional@var467 ;
308: bool variadic@var468 ;
309: std :: string valid@var469 ;
310:
311: class IteratorInfo {
312: public:
313: IteratorInfo ( ) : container@var470 ( 0 ) , it@var471 ( false ) , first@var472 ( false ) , last@var473 ( false ) { }
314:
315: int container@var470 ;
316: bool it@var471 ;
317: bool first@var472 ;
318: bool last@var473 ;
319: } ;
320: IteratorInfo iteratorInfo@var474 ;
321:
322: class MinSize {
323: public:
324: enum class Type { NONE , STRLEN , ARGVALUE , SIZEOF , MUL , VALUE } ;
325: MinSize ( Type t@var475 , int a@var476 ) : type@var477 ( t@var475 ) , arg@var478 ( a@var476 ) , arg2@var479 ( 0 ) , value@var480 ( 0 ) { }
326: Type type@var477 ;
327: int arg@var478 ;
328: int arg2@var479 ;
329: long long value@var480 ;
330: } ;
331: std :: vector < MinSize > minsizes@var481 ;
332:
333: enum class Direction {
334: DIR_IN ,
335: DIR_OUT ,
336: DIR_INOUT ,
337: DIR_UNKNOWN
338: } ;
339: Direction direction@var482 ;
340: } ;
341:
342: struct Function {
343: std :: map < int , ArgumentChecks > argumentChecks@var483 ;
344: bool use@var484 ;
345: bool leakignore@var485 ;
346: bool isconst@var486 ;
347: bool ispure@var487 ;
348: UseRetValType useretval@var488 ;
349: bool ignore@var489 ;
350: bool formatstr@var490 ;
351: bool formatstr_scan@var491 ;
352: bool formatstr_secure@var492 ;
353: Container :: Action containerAction@var493 ;
354: Container :: Yield containerYield@var494 ;
355: Function ( )
356: : use@var484 ( false ) ,
357: leakignore@var485 ( false ) ,
358: isconst@var486 ( false ) ,
359: ispure@var487 ( false ) ,
360: useretval@var488 ( UseRetValType :: NONE ) ,
361: ignore@var489 ( false ) ,
362: formatstr@var490 ( false ) ,
363: formatstr_scan@var491 ( false ) ,
364: formatstr_secure@var492 ( false ) ,
365: containerAction@var493 ( Container :: Action :: NO_ACTION ) ,
366: containerYield@var494 ( Container :: Yield :: NO_YIELD )
367: { }
368: } ;
369:
370: const Function * getFunction ( const Token * ftok@var495 ) const ;
371: std :: unordered_map < std :: string , Function > functions@var496 ;
372: bool isUse ( const std :: string & functionName@var497 ) const ;
373: bool isLeakIgnore ( const std :: string & functionName@var498 ) const ;
374: bool isFunctionConst ( const std :: string & functionName@var499 , bool pure@var500 ) const ;
375: bool isFunctionConst ( const Token * ftok@var501 ) const ;
376:
377: bool isboolargbad ( const Token * ftok@var502 , int argnr@var503 ) const {
378: const ArgumentChecks * arg@var504 ; arg@var504 =@expr1073747746 getarg (@expr1073747747 ftok@var502 , argnr@var503 ) ;
379: return arg@var504 &&@expr1073747748 arg@var504 .@expr1073747749 notbool@var505 ;
380: }
381:
382: bool isnullargbad ( const Token * ftok@var506 , int argnr@var507 ) const ;
383: bool isuninitargbad ( const Token * ftok@var508 , int argnr@var509 , int indirect@var510 = 0 , bool * hasIndirect@var511 = nullptr ) const ;
384:
385: bool isargformatstr ( const Token * ftok@var512 , int argnr@var513 ) const {
386: const ArgumentChecks * arg@var514 ; arg@var514 =@expr1073747750 getarg (@expr1073747751 ftok@var512 , argnr@var513 ) ;
387: return arg@var514 &&@expr1073747752 arg@var514 .@expr1073747753 formatstr@var515 ;
388: }
389:
390: bool isargstrz ( const Token * ftok@var516 , int argnr@var517 ) const {
391: const ArgumentChecks * arg@var518 ; arg@var518 =@expr1073747754 getarg (@expr1073747755 ftok@var516 , argnr@var517 ) ;
392: return arg@var518 &&@expr1073747756 arg@var518 .@expr1073747757 strz@var519 ;
393: }
394:
395: bool isIntArgValid ( const Token * ftok@var520 , int argnr@var521 , const long long argvalue@var522 ) const ;
396: bool isFloatArgValid ( const Token * ftok@var523 , int argnr@var524 , double argvalue@var525 ) const ;
397:
398: const std :: string & validarg ( const Token * ftok@var526 , int argnr@var527 ) const {
399: const ArgumentChecks * arg@var528 ; arg@var528 =@expr1073747758 getarg (@expr1073747759 ftok@var526 , argnr@var527 ) ;
400: return arg@var528 ?@expr1073747760 arg@var528 .@expr1073747761 valid@var529 :@expr1073747762 emptyString@var1 ;
401: }
402:
403: struct InvalidArgValue {
404: enum class Type { le , lt , eq , ge , gt , range } ; enum Type type@var530 ;
405: std :: string op1@var531 ;
406: std :: string op2@var532 ;
407: bool isInt ( ) const {
408: return MathLib ::@expr1073747763 isInt (@expr1073747764 op1@var531 ) ;
409: }
410: } ;
411:
412: const ArgumentChecks :: IteratorInfo * getArgIteratorInfo ( const Token * ftok@var533 , int argnr@var534 ) const {
413: const ArgumentChecks * arg@var535 ; arg@var535 =@expr1073747765 getarg (@expr1073747766 ftok@var533 , argnr@var534 ) ;
414: return arg@var535 &&@expr1073747767 arg@var535 .@expr5944 iteratorInfo@var536 .@expr1073747769 it@var537 ?@expr1073747770 &@expr1073747771 arg@var535 .@expr5944 iteratorInfo@var536 :@expr1073747773 nullptr ;
415: }
416:
417: bool hasminsize ( const Token * ftok@var538 ) const ;
418:
419: const std :: vector < ArgumentChecks :: MinSize > * argminsizes ( const Token * ftok@var539 , int argnr@var540 ) const {
420: const ArgumentChecks * arg@var541 ; arg@var541 =@expr1073747774 getarg (@expr1073747775 ftok@var539 , argnr@var540 ) ;
421: return arg@var541 ?@expr1073747776 &@expr1073747777 arg@var541 .@expr1073747778 minsizes@var542 :@expr1073747779 nullptr ;
422: }
423:
424: ArgumentChecks :: Direction getArgDirection ( const Token * ftok@var543 , int argnr@var544 ) const ;
425:
426: bool markupFile ( const std :: string & path@var545 ) const ;
427:
428: bool processMarkupAfterCode ( const std :: string & path@var546 ) const ;
429:
430: const std :: set < std :: string > & markupExtensions ( ) const {
431: return mMarkupExtensions@var650 ;
432: }
433:
434: bool reportErrors ( const std :: string & path@var547 ) const ;
435:
436: bool ignorefunction ( const std :: string & functionName@var548 ) const ;
437:
438: bool isexecutableblock ( const std :: string & file@var549 , const std :: string & token@var550 ) const ;
439:
440: int blockstartoffset ( const std :: string & file@var551 ) const ;
441:
442: const std :: string & blockstart ( const std :: string & file@var552 ) const ;
443: const std :: string & blockend ( const std :: string & file@var553 ) const ;
444:
445: bool iskeyword ( const std :: string & file@var554 , const std :: string & keyword@var555 ) const ;
446:
447: bool isexporter ( const std :: string & prefix@var556 ) const {
448: return mExporters@var653 .@expr1073747780 find (@expr1073747781 prefix@var556 ) !=@expr1073747782 mExporters@var653 .@expr1073747783 end (@expr1073747784 ) ;
449: }
450:
451: bool isexportedprefix ( const std :: string & prefix@var557 , const std :: string & token@var558 ) const {
452: const std ::@expr1073747785 map < std ::@expr1073747786 string , ExportedFunctions > ::@expr1073747787 const_iterator it@var559 =@expr1073747788 mExporters@var653 .@expr1073747789 find (@expr1073747790 prefix@var557 ) ;
453: return (@expr1073747791 it@var559 !=@expr1073747792 mExporters@var653 .@expr1073747793 end (@expr1073747794 ) &&@expr1073747795 it@var559 .@expr1073747796 second@var560 .@expr1073747797 isPrefix (@expr1073747798 token@var558 ) ) ;
454: }
455:
456: bool isexportedsuffix ( const std :: string & prefix@var561 , const std :: string & token@var562 ) const {
457: const std ::@expr1073747799 map < std ::@expr1073747800 string , ExportedFunctions > ::@expr1073747801 const_iterator it@var563 =@expr1073747802 mExporters@var653 .@expr1073747803 find (@expr1073747804 prefix@var561 ) ;
458: return (@expr1073747805 it@var563 !=@expr1073747806 mExporters@var653 .@expr1073747807 end (@expr1073747808 ) &&@expr1073747809 it@var563 .@expr1073747810 second@var564 .@expr1073747811 isSuffix (@expr1073747812 token@var562 ) ) ;
459: }
460:
461: bool isimporter ( const std :: string & file@var565 , const std :: string & importer@var566 ) const ;
462:
463: const Token * getContainerFromYield ( const Token * tok@var567 , Container :: Yield yield@var568 ) const ;
464: const Token * getContainerFromAction ( const Token * tok@var569 , Container :: Action action@var570 ) const ;
465:
466: bool isreflection ( const std :: string & token@var571 ) const {
467: return mReflection@var655 .@expr1073747813 find (@expr1073747814 token@var571 ) !=@expr1073747815 mReflection@var655 .@expr1073747816 end (@expr1073747817 ) ;
468: }
469:
470: int reflectionArgument ( const std :: string & token@var572 ) const {
471: const std ::@expr1073747818 map < std ::@expr1073747819 string , int > ::@expr1073747820 const_iterator it@var573 =@expr1073747821 mReflection@var655 .@expr1073747822 find (@expr1073747823 token@var572 ) ;
472: if (@expr1073747824 it@var573 !=@expr1073747825 mReflection@var655 .@expr1073747826 end (@expr1073747827 ) ) {
473: return it@var573 .@expr1073747828 second@var574 ; }
474: return -1 ;
475: }
476:
477: std :: vector < std :: string > defines@var575 ;
478:
479: struct SmartPointer {
480: std :: string name@var576 ; name@var576 = "" ;
481: bool unique@var577 ; unique@var577 = false ;
482: } ;
483:
484: std :: map < std :: string , SmartPointer > smartPointers@var578 ;
485: bool isSmartPointer ( const Token * tok@var579 ) const ;
486: const SmartPointer * detectSmartPointer ( const Token * tok@var580 ) const ;
487:
488: struct PodType {
489: unsigned int size@var581 ;
490: char sign@var582 ;
491: enum class Type { NO , BOOL , CHAR , SHORT , INT , LONG , LONGLONG } ; enum Type stdtype@var583 ;
492: } ;
493: const struct PodType * podtype ( const std :: string & name@var584 ) const {
494: const std ::@expr1073747829 unordered_map < std ::@expr1073747830 string , PodType > ::@expr1073747831 const_iterator it@var585 =@expr1073747832 mPodTypes@var656 .@expr1073747833 find (@expr1073747834 name@var584 ) ;
495: return (@expr6011 it@var585 !=@expr1073747836 mPodTypes@var656 .@expr1073747837 end (@expr1073747838 ) ) ?@expr1073747839 &@expr1073747840 (@expr6011 it@var585 .@expr1073747842 second@var586 ) :@expr1073747843 nullptr ;
496: }
497:
498: struct PlatformType {
499: PlatformType ( )
500: : mSigned@var597 ( false )
501: , mUnsigned@var598 ( false )
502: , mLong@var599 ( false )
503: , mPointer@var600 ( false )
504: , mPtrPtr@var601 ( false )
505: , mConstPtr@var602 ( false ) { }
506: bool operator== ( const PlatformType & type@var587 ) const {
507: return (@expr1073747844 mSigned@var597 ==@expr1073747845 type@var587 .@expr1073747846 mSigned@var588 &&@expr1073747847
508: mUnsigned@var598 ==@expr1073747848 type@var587 .@expr1073747849 mUnsigned@var589 &&@expr1073747850
509: mLong@var599 ==@expr1073747851 type@var587 .@expr1073747852 mLong@var590 &&@expr1073747853
510: mPointer@var600 ==@expr1073747854 type@var587 .@expr1073747855 mPointer@var591 &&@expr1073747856
511: mPtrPtr@var601 ==@expr1073747857 type@var587 .@expr1073747858 mPtrPtr@var592 &&@expr1073747859
512: mConstPtr@var602 ==@expr1073747860 type@var587 .@expr1073747861 mConstPtr@var593 &&@expr1073747862
513: mType@var596 ==@expr1073747863 type@var587 .@expr1073747864 mType@var594 ) ;
514: }
515: bool operator!= ( const PlatformType & type@var595 ) const {
516: return !@expr1073747865 (@expr1073747866 *@expr1073747867 this@expr1073747868 ==@expr1073747869 type@var595 ) ;
517: }
518: std :: string mType@var596 ;
519: bool mSigned@var597 ;
520: bool mUnsigned@var598 ;
521: bool mLong@var599 ;
522: bool mPointer@var600 ;
523: bool mPtrPtr@var601 ;
524: bool mConstPtr@var602 ;
525: } ;
526:
527: struct Platform {
528: const PlatformType * platform_type ( const std :: string & name@var603 ) const {
529: const std ::@expr1073747870 map < std ::@expr1073747871 string , PlatformType > ::@expr1073747872 const_iterator it@var604 =@expr1073747873 mPlatformTypes@var606 .@expr1073747874 find (@expr1073747875 name@var603 ) ;
530: return (@expr6052 it@var604 !=@expr1073747877 mPlatformTypes@var606 .@expr1073747878 end (@expr1073747879 ) ) ?@expr1073747880 &@expr1073747881 (@expr6052 it@var604 .@expr1073747883 second@var605 ) :@expr1073747884 nullptr ;
531: }
532: std :: map < std :: string , PlatformType > mPlatformTypes@var606 ;
533: } ;
534:
535: const PlatformType * platform_type ( const std :: string & name@var607 , const std :: string & platform@var608 ) const {
536: const std ::@expr1073747885 map < std ::@expr6062 string , Platform > ::@expr1073747887 const_iterator it@var609 =@expr1073747888 mPlatforms@var658 .@expr1073747889 find (@expr1073747890 platform@var608 ) ;
537: if (@expr1073747891 it@var609 !=@expr1073747892 mPlatforms@var658 .@expr1073747893 end (@expr1073747894 ) ) {
538: const PlatformType * const type@var610 ; type@var610 =@expr1073747895 it@var609 .@expr1073747896 second@var611 .@expr1073747897 platform_type (@expr1073747898 name@var607 ) ;
539: if (@expr1073747899 type@var610 ) {
540: return type@var610 ; }
541: }
542:
543: const std ::@expr1073747900 map < std ::@expr6062 string , PlatformType > ::@expr1073747902 const_iterator it2@var612 =@expr1073747903 mPlatformTypes@var657 .@expr1073747904 find (@expr1073747905 name@var607 ) ;
544: return (@expr6082 it2@var612 !=@expr1073747907 mPlatformTypes@var657 .@expr1073747908 end (@expr1073747909 ) ) ?@expr1073747910 &@expr1073747911 (@expr6082 it2@var612 .@expr1073747913 second@var613 ) :@expr1073747914 nullptr ;
545: }
546:
|
549:
550: std :: string getFunctionName ( const Token * ftok@var614 ) const ;
551:
552: static bool isContainerYield ( const Token * const cond@var615 , Library :: Container :: Yield y@var616 , const std :: string & fallback@var617 = "" ) ;
553:
554:
555: enum class TypeCheck { def , check , suppress } ;
556: TypeCheck getTypeCheck ( const std :: string & check@var618 , const std :: string & typeName@var619 ) const ;
557:
558: private:
559:
560: Error loadFunction ( const tinyxml2 :: XMLElement * const node@var620 , const std :: string & name@var621 , std :: set < std :: string > & unknown_elements@var622 ) ;
561:
562: class ExportedFunctions {
563: public:
564: void addPrefix ( const std :: string & prefix@var623 ) {
565: mPrefixes@var627 .@expr1073747915 insert (@expr1073747916 prefix@var623 ) ;
566: }
567: void addSuffix ( const std :: string & suffix@var624 ) {
568: mSuffixes@var628 .@expr1073747917 insert (@expr1073747918 suffix@var624 ) ;
569: }
570: bool isPrefix ( const std :: string & prefix@var625 ) const {
571: return (@expr1073747919 mPrefixes@var627 .@expr1073747920 find (@expr1073747921 prefix@var625 ) !=@expr1073747922 mPrefixes@var627 .@expr1073747923 end (@expr1073747924 ) ) ;
572: }
573: bool isSuffix ( const std :: string & suffix@var626 ) const {
574: return (@expr1073747925 mSuffixes@var628 .@expr1073747926 find (@expr1073747927 suffix@var626 ) !=@expr1073747928 mSuffixes@var628 .@expr1073747929 end (@expr1073747930 ) ) ;
575: }
576:
577: private:
578: std :: set < std :: string > mPrefixes@var627 ;
579: std :: set < std :: string > mSuffixes@var628 ;
580: } ;
581: class CodeBlock {
582: public:
583: CodeBlock ( ) : mOffset@var636 ( 0 ) { }
584:
585: void setStart ( const char * s@var629 ) {
586: mStart@var634 =@expr1073747931 s@var629 ;
587: }
588: void setEnd ( const char * e@var630 ) {
589: mEnd@var635 =@expr1073747932 e@var630 ;
590: }
591: void setOffset ( const int o@var631 ) {
592: mOffset@var636 =@expr1073747933 o@var631 ;
593: }
594: void addBlock ( const char * blockName@var632 ) {
595: mBlocks@var637 .@expr1073747934 insert (@expr1073747935 blockName@var632 ) ;
596: }
597: const std :: string & start ( ) const {
598: return mStart@var634 ;
599: }
600: const std :: string & end ( ) const {
601: return mEnd@var635 ;
602: }
603: int offset ( ) const {
604: return mOffset@var636 ;
605: }
606: bool isBlock ( const std :: string & blockName@var633 ) const {
607: return mBlocks@var637 .@expr1073747936 find (@expr1073747937 blockName@var633 ) !=@expr1073747938 mBlocks@var637 .@expr1073747939 end (@expr1073747940 ) ;
608: }
609:
610: private:
611: std :: string mStart@var634 ;
612: std :: string mEnd@var635 ;
613: int mOffset@var636 ;
614: std :: set < std :: string > mBlocks@var637 ;
615: } ;
616: enum class FalseTrueMaybe { False , True , Maybe } ;
617: int mAllocId@var638 ;
618: std :: set < std :: string > mFiles@var639 ;
619: std :: map < std :: string , AllocFunc > mAlloc@var640 ;
620: std :: map < std :: string , AllocFunc > mDealloc@var641 ;
621: std :: map < std :: string , AllocFunc > mRealloc@var642 ;
622: std :: unordered_map < std :: string , FalseTrueMaybe > mNoReturn@var643 ;
623: std :: map < std :: string , std :: string > mReturnValue@var644 ;
624: std :: map < std :: string , std :: string > mReturnValueType@var645 ;
625: std :: map < std :: string , int > mReturnValueContainer@var646 ;
626: std :: map < std :: string , std :: vector < long long > > mUnknownReturnValues@var647 ;
627: std :: map < std :: string , bool > mReportErrors@var648 ;
628: std :: map < std :: string , bool > mProcessAfterCode@var649 ;
629: std :: set < std :: string > mMarkupExtensions@var650 ;
630: std :: map < std :: string , std :: set < std :: string > > mKeywords@var651 ;
631: std :: map < std :: string , CodeBlock > mExecutableBlocks@var652 ;
632: std :: map < std :: string , ExportedFunctions > mExporters@var653 ;
633: std :: map < std :: string , std :: set < std :: string > > mImporters@var654 ;
634: std :: map < std :: string , int > mReflection@var655 ;
635: std :: unordered_map < std :: string , PodType > mPodTypes@var656 ;
636: std :: map < std :: string , PlatformType > mPlatformTypes@var657 ;
637: std :: map < std :: string , Platform > mPlatforms@var658 ;
638: std :: map < std :: pair < std :: string , std :: string > , TypeCheck > mTypeChecks@var659 ;
639: std :: unordered_map < std :: string , NonOverlappingData > mNonOverlappingData@var660 ;
640:
641: const ArgumentChecks * getarg ( const Token * ftok@var661 , int argnr@var662 ) const ;
642:
643: std :: string getFunctionName ( const Token * ftok@var663 , bool * error@var664 ) const ;
644:
645: static const AllocFunc * getAllocDealloc ( const std :: map < std :: string , AllocFunc > & data@var665 , const std :: string & name@var666 ) {
646: const std ::@expr1073747941 map < std ::@expr1073747942 string , AllocFunc > ::@expr1073747943 const_iterator it@var667 =@expr1073747944 data@var665 .@expr1073747945 find (@expr1073747946 name@var666 ) ;
647: return (@expr1073747947 it@var667 ==@expr1073747948 data@var665 .@expr1073747949 end (@expr1073747950 ) ) ?@expr1073747951 nullptr :@expr1073747952 &@expr1073747953 it@var667 .@expr1073747954 second@var668 ;
648: }
649: } ;
650:
651: const Library :: Container * getLibraryContainer ( const Token * tok@var669 ) ;
652:
653: std :: shared_ptr < Token > createTokenFromExpression ( const std :: string & returnValue@var670 ,
654: const Settings * settings@var671 ,
655: std :: unordered_map < int , const Token * > * lookupVarId@var672 = nullptr ) ;

##file cppcheck-2.8/lib/templatesimplifier.h

1:
|
34:
35: class ErrorLogger ;
36: class Settings ;
37: class Token ;
38: class Tokenizer ;
39: class TokenList ;
40:
|
44:
45: class TemplateSimplifier {
46: friend class TestSimplifyTemplate ;
47:
48: public:
49: explicit TemplateSimplifier ( Tokenizer * tokenizer@var673 ) ;
50: ~ TemplateSimplifier ( ) ;
51:
52:
53:
54: void checkComplicatedSyntaxErrorsInTemplates ( ) ;
55:
|
61:
62: static unsigned int templateParameters ( const Token * tok@var674 ) ;
63:
|
66:
67: class TokenAndName {
68: Token * mToken@var675 ;
69: std :: string mScope@var676 ;
70: std :: string mName@var677 ;
71: std :: string mFullName@var678 ;
72: const Token * mNameToken@var679 ;
73: const Token * mParamEnd@var680 ;
74: unsigned int mFlags@var681 ;
75:
76: enum Anonymous1 {
77: fIsClass = ( 1 << 0 ) ,
78: fIsFunction = ( 1 << 1 ) ,
79: fIsVariable = ( 1 << 2 ) ,
80: fIsAlias = ( 1 << 3 ) ,
81: fIsSpecialization = ( 1 << 4 ) ,
82: fIsPartialSpecialization = ( 1 << 5 ) ,
83: fIsForwardDeclaration = ( 1 << 6 ) ,
84: fIsVariadic = ( 1 << 7 ) ,
85: fIsFriend = ( 1 << 8 ) ,
86: fFamilyMask = ( fIsClass | fIsFunction | fIsVariable )
87: } ;
88:
89: void isClass ( bool state@var682 ) {
90: setFlag (@expr1073747955 fIsClass , state@var682 ) ;
91: }
92: void isFunction ( bool state@var683 ) {
93: setFlag (@expr1073747956 fIsFunction , state@var683 ) ;
94: }
95: void isVariable ( bool state@var684 ) {
96: setFlag (@expr1073747957 fIsVariable , state@var684 ) ;
97: }
98: void isAlias ( bool state@var685 ) {
99: setFlag (@expr1073747958 fIsAlias , state@var685 ) ;
100: }
101: void isSpecialization ( bool state@var686 ) {
102: setFlag (@expr1073747959 fIsSpecialization , state@var686 ) ;
103: }
104: void isPartialSpecialization ( bool state@var687 ) {
105: setFlag (@expr1073747960 fIsPartialSpecialization , state@var687 ) ;
106: }
107: void isForwardDeclaration ( bool state@var688 ) {
108: setFlag (@expr1073747961 fIsForwardDeclaration , state@var688 ) ;
109: }
110: void isVariadic ( bool state@var689 ) {
111: setFlag (@expr1073747962 fIsVariadic , state@var689 ) ;
112: }
113: void isFriend ( bool state@var690 ) {
114: setFlag (@expr1073747963 fIsFriend , state@var690 ) ;
115: }
116:
|
121:
122: bool getFlag ( unsigned int flag@var691 ) const {
123: return (@expr6140 (@expr6140 mFlags@var681 &@expr1073747966 flag@var691 ) !=@expr1073747967 0 ) ;
124: }
125:
|
130:
131: void setFlag ( unsigned int flag@var692 , bool state@var693 ) {
132: mFlags@var681 =@expr1073747968 state@var693 ?@expr1073747969 mFlags@var681 |@expr1073747970 flag@var692 :@expr1073747971 mFlags@var681 &@expr1073747972 ~@expr1073747973 flag@var692 ;
133: }
134:
135: public:
136:
|
140:
141: TokenAndName ( Token * token@var694 , const std :: string & scope@var695 ) ;
142:
|
148:
149: TokenAndName ( Token * token@var696 , const std :: string & scope@var697 , const Token * nameToken@var698 , const Token * paramEnd@var699 ) ;
150: TokenAndName ( const TokenAndName & other@var700 ) ;
151: ~ TokenAndName ( ) ;
152:
153: bool operator== ( const TokenAndName & rhs@var701 ) const {
154: return mToken@var675 ==@expr1073747974 rhs@var701 .@expr1073747975 mToken@var702 &&@expr1073747976 mScope@var676 ==@expr1073747977 rhs@var701 .@expr1073747978 mScope@var703 &&@expr1073747979 mName@var677 ==@expr1073747980 rhs@var701 .@expr1073747981 mName@var704 &&@expr1073747982 mFullName@var678 ==@expr1073747983 rhs@var701 .@expr1073747984 mFullName@var705 &&@expr1073747985
155: mNameToken@var679 ==@expr1073747986 rhs@var701 .@expr1073747987 mNameToken@var706 &&@expr1073747988 mParamEnd@var680 ==@expr1073747989 rhs@var701 .@expr1073747990 mParamEnd@var707 &&@expr1073747991 mFlags@var681 ==@expr1073747992 rhs@var701 .@expr1073747993 mFlags@var708 ;
156: }
157:
158: Token * token ( ) const {
159: return mToken@var675 ;
160: }
161: void token ( Token * token@var709 ) {
162: mToken@var675 =@expr1073747994 token@var709 ;
163: }
164: const std :: string & scope ( ) const {
165: return mScope@var676 ;
166: }
167: const std :: string & name ( ) const {
168: return mName@var677 ;
169: }
170: const std :: string & fullName ( ) const {
171: return mFullName@var678 ;
172: }
173: const Token * nameToken ( ) const {
174: return mNameToken@var679 ;
175: }
176: const Token * paramEnd ( ) const {
177: return mParamEnd@var680 ;
178: }
179: void paramEnd ( const Token * end@var710 ) {
180: mParamEnd@var680 =@expr1073747995 end@var710 ;
181: }
182:
183: bool isClass ( ) const {
184: return getFlag (@expr1073747996 fIsClass ) ;
185: }
186: bool isFunction ( ) const {
187: return getFlag (@expr1073747997 fIsFunction ) ;
188: }
189: bool isVariable ( ) const {
190: return getFlag (@expr1073747998 fIsVariable ) ;
191: }
192: bool isAlias ( ) const {
193: return getFlag (@expr1073747999 fIsAlias ) ;
194: }
195: bool isSpecialization ( ) const {
196: return getFlag (@expr1073748000 fIsSpecialization ) ;
197: }
198: bool isPartialSpecialization ( ) const {
199: return getFlag (@expr1073748001 fIsPartialSpecialization ) ;
200: }
201: bool isForwardDeclaration ( ) const {
202: return getFlag (@expr1073748002 fIsForwardDeclaration ) ;
203: }
204: bool isVariadic ( ) const {
205: return getFlag (@expr1073748003 fIsVariadic ) ;
206: }
207: bool isFriend ( ) const {
208: return getFlag (@expr1073748004 fIsFriend ) ;
209: }
210:
|
216:
217: const Token * aliasStartToken ( ) const ;
218:
|
224:
225: const Token * aliasEndToken ( ) const ;
226:
|
233:
234: bool isAliasToken ( const Token * tok@var711 ) const ;
235:
|
241:
242: bool isSameFamily ( const TemplateSimplifier :: TokenAndName & decl@var712 ) const {
243:
244:
245: return (@expr6181 (@expr6181 mFlags@var681 &@expr1073748007 fFamilyMask ) &@expr1073748008 (@expr6181 decl@var712 .@expr1073748010 mFlags@var713 &@expr1073748011 fFamilyMask ) ) !=@expr1073748012 0 ;
246: }
247: } ;
248:
|
253:
254: static Token * findTemplateDeclarationEnd ( Token * tok@var714 ) ;
255: static const Token * findTemplateDeclarationEnd ( const Token * tok@var715 ) ;
256:
|
264:
265: static bool instantiateMatch ( const Token * instance@var716 , const unsigned long numberOfArguments@var717 , bool variadic@var718 , const char patternAfter@var719 [ ] ) ;
266:
|
272:
273: int getTemplateNamePosition ( const Token * tok@var720 ) ;
274:
|
280:
281: static bool getTemplateNamePositionTemplateClass ( const Token * tok@var721 , int & namepos@var722 ) ;
282:
|
288:
289: static bool getTemplateNamePositionTemplateFunction ( const Token * tok@var723 , int & namepos@var724 ) ;
290:
|
296:
297: static bool getTemplateNamePositionTemplateVariable ( const Token * tok@var725 , int & namepos@var726 ) ;
298:
|
303:
304: void simplifyTemplates (
305: const std :: time_t maxtime@var727 ,
306: bool & codeWithTemplates@var728 ) ;
307:
|
313:
314: static bool simplifyNumericCalculations ( Token * tok@var729 , bool isTemplate@var730 = true ) ;
315:
|
321:
322: bool simplifyCalculations ( Token * frontToken@var731 = nullptr , Token * backToken@var732 = nullptr , bool isTemplate@var733 = true ) ;
323:
|
327:
328: void simplifyTemplateArgs ( Token * start@var734 , Token * end@var735 ) ;
329:
330: private:
331:
|
334:
335: bool getTemplateDeclarations ( ) ;
336:
|
340:
341: void addInstantiation ( Token * token@var736 , const std :: string & scope@var737 ) ;
342:
|
345:
346: void getTemplateInstantiations ( ) ;
347:
|
351:
352: void fixForwardDeclaredDefaultArgumentValues ( ) ;
353:
|
356:
357: void useDefaultArgumentValues ( ) ;
358:
|
362:
363: void useDefaultArgumentValues ( TokenAndName & declaration@var738 ) ;
364:
|
368:
369: void getSpecializations ( ) ;
370:
|
374:
375: void getPartialSpecializations ( ) ;
376:
|
379:
380: void simplifyTemplateAliases ( ) ;
381:
|
390:
391: bool simplifyTemplateInstantiations (
392: const TokenAndName & templateDeclaration@var739 ,
393: const std :: list < const Token * > & specializations@var740 ,
394: const std :: time_t maxtime@var741 ,
395: std :: set < std :: string > & expandedtemplates@var742 ) ;
396:
|
401:
402: void addNamespace ( const TokenAndName & templateDeclaration@var743 , const Token * tok@var744 ) ;
403:
|
409:
410: static bool alreadyHasNamespace ( const TokenAndName & templateDeclaration@var745 , const Token * tok@var746 ) ;
411:
|
419:
420: void expandTemplate (
421: const TokenAndName & templateDeclaration@var747 ,
422: const TokenAndName & templateInstantiation@var748 ,
423: const std :: vector < const Token * > & typeParametersInDeclaration@var749 ,
424: const std :: string & newName@var750 ,
425: bool copy@var751 ) ;
426:
|
432:
433: void replaceTemplateUsage ( const TokenAndName & instantiation@var752 ,
434: const std :: list < std :: string > & typeStringsUsedInTemplateInstantiation@var753 ,
435: const std :: string & newName@var754 ) ;
436:
|
443:
444: static void getTemplateParametersInDeclaration (
445: const Token * tok@var755 ,
446: std :: vector < const Token * > & typeParametersInDeclaration@var756 ) ;
447:
|
450:
451: static bool removeTemplate ( Token * tok@var757 ) ;
452:
453:
454: static void syntaxError ( const Token * tok@var758 ) ;
455:
456: static bool matchSpecialization (
457: const Token * templateDeclarationNameToken@var759 ,
458: const Token * templateInstantiationNameToken@var760 ,
459: const std :: list < const Token * > & specializations@var761 ) ;
460:
|
465:
466: static void eraseTokens ( Token * begin@var762 , const Token * end@var763 ) ;
467:
|
472:
473: static void deleteToken ( Token * tok@var764 ) ;
474:
|
480:
481: std :: string getNewName (
482: Token * tok2@var765 ,
483: std :: list < std :: string > & typeStringsUsedInTemplateInstantiation@var766 ) ;
484:
485: void printOut (
486: const TokenAndName & tokenAndName@var767 ,
487: const std :: string & indent@var768 = "    " ) const ;
488: void printOut ( const std :: string & text@var769 = "" ) const ;
489:
490: Tokenizer * mTokenizer@var770 ;
491: TokenList & mTokenList@var771 ;
492: const Settings * mSettings@var772 ;
493: ErrorLogger * mErrorLogger@var773 ;
494: bool mChanged@var774 ;
495:
496: std :: list < TokenAndName > mTemplateDeclarations@var775 ;
497: std :: list < TokenAndName > mTemplateForwardDeclarations@var776 ;
498: std :: map < Token * , Token * > mTemplateForwardDeclarationsMap@var777 ;
499: std :: map < Token * , Token * > mTemplateSpecializationMap@var778 ;
500: std :: map < Token * , Token * > mTemplatePartialSpecializationMap@var779 ;
501: std :: list < TokenAndName > mTemplateInstantiations@var780 ;
502: std :: list < TokenAndName > mInstantiatedTemplates@var781 ;
503: std :: list < TokenAndName > mMemberFunctionsToDelete@var782 ;
504: std :: vector < TokenAndName > mExplicitInstantiationsToDelete@var783 ;
505: std :: vector < TokenAndName > mTypesUsedInTemplateInstantiation@var784 ;
506: std :: unordered_map < const Token * , int > mTemplateNamePos@var785 ;
507: } ;

##file cppcheck-2.8/lib/token.h

1:
|
40:
41: class Enumerator ;
42: class Function ;
43: class Scope ;
44: class Settings ;
45: class Type ;
46: class ValueType ;
47: class Variable ;
48: class TokenList ;
49: class ConstTokenRange ;
50: class Token ;
51:
|
54:
55: struct TokensFrontBack {
56: Token * front@var786 ;
57: Token * back@var787 ;
58: const TokenList * list@var788 ;
59: } ;
60:
61: struct ScopeInfo2 {
62: ScopeInfo2 ( const std :: string & name_@var789 , const Token * bodyEnd_@var790 , const std :: set < std :: string > & usingNamespaces_@var791 = std :: set < std :: string > ( ) ) : name@var792 ( name_@var789 ) , bodyEnd@var793 ( bodyEnd_@var790 ) , usingNamespaces@var794 ( usingNamespaces_@var791 ) { }
63: std :: string name@var792 ;
64: const Token * const bodyEnd@var793 ;
65: std :: set < std :: string > usingNamespaces@var794 ;
66: } ;
67:
68: struct TokenImpl {
69: int mVarId@var795 ;
70: int mFileIndex@var796 ;
71: int mLineNumber@var797 ;
72: int mColumn@var798 ;
73: int mExprId@var799 ;
74:
75:
76: Token * mAstOperand1@var800 ;
77: Token * mAstOperand2@var801 ;
78: Token * mAstParent@var802 ;
79:
80:
81: const Scope * mScope@var803 ;
82: union {
83: const Function * mFunction@var804 ;
84: const Variable * mVariable@var805 ;
85: const :: Type * mType@var806 ;
86: const Enumerator * mEnumerator@var807 ;
87: } ;
88:
|
92:
93: int mProgressValue@var808 ;
94:
|
97:
98: int mIndex@var809 ;
99:
100:
101: std :: string * mOriginalName@var810 ;
102:
103:
104: ValueType * mValueType@var811 ;
105:
106:
107: std :: list < ValueFlow :: Value > * mValues@var812 ;
108: static const std :: list < ValueFlow :: Value > mEmptyValueList@var813 ;
109:
110:
111: std :: set < TemplateSimplifier :: TokenAndName * > * mTemplateSimplifierPointers@var814 ;
112:
113:
114: std :: shared_ptr < ScopeInfo2 > mScopeInfo@var815 ;
115:
116:
117: struct CppcheckAttributes {
118: enum Type { LOW , HIGH } ; enum Type type@var816 ;
119: long long value@var817 ;
120: struct CppcheckAttributes * next@var818 ;
121: } ;
122: struct CppcheckAttributes * mCppcheckAttributes@var819 ;
123:
124:
125: enum class Cpp11init { UNKNOWN , CPP11INIT , NOINIT } ; enum Cpp11init mCpp11init@var820 ;
126:
127:
128: unsigned char mBits@var821 ;
129:
130: void setCppcheckAttribute ( CppcheckAttributes :: Type type@var822 , long long value@var823 ) ;
131: bool getCppcheckAttribute ( CppcheckAttributes :: Type type@var824 , long long * value@var825 ) const ;
132:
133: TokenImpl ( )
134: : mVarId@var795 ( 0 )
135: , mFileIndex@var796 ( 0 )
136: , mLineNumber@var797 ( 0 )
137: , mColumn@var798 ( 0 )
138: , mExprId@var799 ( 0 )
139: , mAstOperand1@var800 ( nullptr )
140: , mAstOperand2@var801 ( nullptr )
141: , mAstParent@var802 ( nullptr )
142: , mScope@var803 ( nullptr )
143: , mFunction@var804 ( nullptr )
144: , mProgressValue@var808 ( 0 )
145: , mIndex@var809 ( 0 )
146: , mOriginalName@var810 ( nullptr )
147: , mValueType@var811 ( nullptr )
148: , mValues@var812 ( nullptr )
149: , mTemplateSimplifierPointers@var814 ( nullptr )
150: , mScopeInfo@var815 ( nullptr )
151: , mCppcheckAttributes@var819 ( nullptr )
152: , mCpp11init@var820 ( Cpp11init :: UNKNOWN )
153: , mBits@var821 ( 0 )
154: { }
155:
156: ~ TokenImpl ( ) ;
157: } ;
158:
|
171:
172: class Token {
173: private:
174: TokensFrontBack * mTokensFrontBack@var826 ;
175:
176:
177: Token ( const Token & ) ;
178: Token operator= ( const Token & ) ;
179:
180: public:
181: enum Type {
182: eVariable , eType , eFunction , eKeyword , eName ,
183: eNumber , eString , eChar , eBoolean , eLiteral , eEnumerator ,
184: eArithmeticalOp , eComparisonOp , eAssignmentOp , eLogicalOp , eBitOp , eIncDecOp , eExtendedOp ,
185: eBracket ,
186: eLambda ,
187: eEllipsis ,
188: eOther ,
189: eNone
190: } ;
191:
192: explicit Token ( TokensFrontBack * tokensFrontBack@var827 = nullptr ) ;
193: ~ Token ( ) ;
194:
195: ConstTokenRange until ( const Token * t@var828 ) const ;
196:
197: template < typename T >
198: void str ( T && s@var829 ) {
199: mStr@var1041 =@expr1073748013 s@var829 ;
200: mImpl@var1047 .@expr1073748014 mVarId@var1078 =@expr1073748015 0 ;
201:
202: update_property_info (@expr1073748016 ) ;
203: }
204:
|
208:
209: void concatStr ( const std :: string & b@var830 ) ;
210:
211: const std :: string & str ( ) const {
212: return mStr@var1041 ;
213: }
214:
|
217:
218: void deleteNext ( int count@var831 = 1 ) ;
219:
|
222:
223: void deletePrevious ( int count@var832 = 1 ) ;
224:
|
227:
228: void swapWithNext ( ) ;
229:
|
234:
235: const Token * tokAt ( int index@var833 ) const ;
236: Token * tokAt ( int index@var834 ) {
237: return const_cast < Token *@expr6193 > (@expr1073748018 const_cast < const Token *@expr6193 > (@expr1073748020 this@expr1073748021 ) .@expr1073748022 tokAt (@expr1073748023 index@var834 ) ) ;
238: }
239:
|
243:
244: const Token * linkAt ( int index@var835 ) const ;
245: Token * linkAt ( int index@var836 ) {
246: return const_cast < Token *@expr6200 > (@expr1073748025 const_cast < const Token *@expr6200 > (@expr1073748027 this@expr1073748028 ) .@expr1073748029 linkAt (@expr1073748030 index@var836 ) ) ;
247: }
248:
|
252:
253: const std :: string & strAt ( int index@var837 ) const ;
254:
|
273:
274: template < unsigned long count >
275: static bool simpleMatch ( const Token * tok@var838 , const char ( & pattern@var839 ) [ count ] ) {
276: return simpleMatch (@expr1073748032 tok@var838 , pattern@var839 , count@expr1073748031 -@expr1073748033 1 ) ;
277: }
278:
279: static bool simpleMatch ( const Token * tok@var840 , const char pattern@var841 [ ] , unsigned long pattern_len@var842 ) ;
280:
|
323:
324: static bool Match ( const Token * tok@var843 , const char pattern@var844 [ ] , int varid@var845 = 0 ) ;
325:
|
332:
333: static int getStrLength ( const Token * tok@var846 ) ;
334:
|
341:
342: static int getStrArraySize ( const Token * tok@var847 ) ;
343:
|
351:
352: static int getStrSize ( const Token * tok@var848 , const Settings * const settings@var849 ) ;
353:
|
361:
362: static std :: string getCharAt ( const Token * tok@var850 , long long index@var851 ) ;
363:
364: const ValueType * valueType ( ) const {
365: return mImpl@var1047 .@expr1073748034 mValueType@var1079 ;
366: }
367: void setValueType ( ValueType * vt@var852 ) ;
368:
369: const ValueType * argumentType ( ) const {
370: const Token * top@var853 ; top@var853 =@expr1073748035 this@expr1073748036 ;
371: while (@expr1073748037 top@var853 &&@expr1073748038 !@expr1073748039 Token ::@expr1073748040 Match (@expr1073748041 top@var853 .@expr6218 astParent (@expr6219 ) , ",|(" ) ) {
372: top@var853 =@expr1073748044 top@var853 .@expr6218 astParent (@expr6219 ) ; }
373: return top@var853 ?@expr1073748047 top@var853 .@expr1073748048 mImpl@var854 .@expr1073748049 mValueType@var855 :@expr1073748050 nullptr ;
374: }
375:
376: Token :: Type tokType ( ) const {
377: return mTokType@var1045 ;
378: }
379: void tokType ( Token :: Type t@var856 ) {
380: mTokType@var1045 =@expr1073748051 t@var856 ;
381:
382: const bool memoizedIsName@var857 =@expr1073748052 mTokType@var1045 ==@expr1073748053 eName ||@expr1073748054 mTokType@var1045 ==@expr1073748055 eType ||@expr1073748056 mTokType@var1045 ==@expr1073748057 eVariable ||@expr1073748058
383: mTokType@var1045 ==@expr1073748059 eFunction ||@expr1073748060 mTokType@var1045 ==@expr1073748061 eKeyword ||@expr1073748062 mTokType@var1045 ==@expr6239 eBoolean ||@expr1073748064
384: mTokType@var1045 ==@expr6241 eEnumerator ;
385: setFlag (@expr1073748066 fIsName , memoizedIsName@var857 ) ;
386:
387: const bool memoizedIsLiteral@var858 =@expr1073748067 mTokType@var1045 ==@expr1073748068 eNumber ||@expr1073748069 mTokType@var1045 ==@expr1073748070 eString ||@expr1073748071 mTokType@var1045 ==@expr1073748072 eChar ||@expr1073748073
388: mTokType@var1045 ==@expr6239 eBoolean ||@expr1073748075 mTokType@var1045 ==@expr1073748076 eLiteral ||@expr1073748077 mTokType@var1045 ==@expr6241 eEnumerator ;
389: setFlag (@expr1073748079 fIsLiteral , memoizedIsLiteral@var858 ) ;
390: }
391: bool isKeyword ( ) const {
392: return mTokType@var1045 ==@expr1073748080 eKeyword ;
393: }
394: bool isName ( ) const {
395: return getFlag (@expr1073748081 fIsName ) ;
396: }
397: bool isNameOnly ( ) const {
398: return mFlags@var1046 ==@expr1073748082 fIsName &&@expr1073748083 mTokType@var1045 ==@expr1073748084 eName ;
399: }
400: bool isUpperCaseName ( ) const ;
401: bool isLiteral ( ) const {
402: return getFlag (@expr1073748085 fIsLiteral ) ;
403: }
404: bool isNumber ( ) const {
405: return mTokType@var1045 ==@expr1073748086 eNumber ;
406: }
407: bool isEnumerator ( ) const {
408: return mTokType@var1045 ==@expr1073748087 eEnumerator ;
409: }
410: bool isOp ( ) const {
411: return (@expr1073748088 isConstOp (@expr1073748089 ) ||@expr1073748090
412: isAssignmentOp (@expr1073748091 ) ||@expr1073748092
413: mTokType@var1045 ==@expr1073748093 eIncDecOp ) ;
414: }
415: bool isConstOp ( ) const {
416: return (@expr1073748094 isArithmeticalOp (@expr1073748095 ) ||@expr1073748096
417: mTokType@var1045 ==@expr1073748097 eLogicalOp ||@expr1073748098
418: mTokType@var1045 ==@expr1073748099 eComparisonOp ||@expr1073748100
419: mTokType@var1045 ==@expr1073748101 eBitOp ) ;
420: }
421: bool isExtendedOp ( ) const {
422: return isConstOp (@expr1073748102 ) ||@expr1073748103
423: mTokType@var1045 ==@expr1073748104 eExtendedOp ;
424: }
425: bool isArithmeticalOp ( ) const {
426: return mTokType@var1045 ==@expr1073748105 eArithmeticalOp ;
427: }
428: bool isComparisonOp ( ) const {
429: return mTokType@var1045 ==@expr1073748106 eComparisonOp ;
430: }
431: bool isAssignmentOp ( ) const {
432: return mTokType@var1045 ==@expr1073748107 eAssignmentOp ;
433: }
434: bool isBoolean ( ) const {
435: return mTokType@var1045 ==@expr1073748108 eBoolean ;
436: }
437: bool isIncDecOp ( ) const {
438: return mTokType@var1045 ==@expr1073748109 eIncDecOp ;
439: }
440: bool isBinaryOp ( ) const {
441: return astOperand1 (@expr1073748110 ) !=@expr1073748111 nullptr &&@expr1073748112 astOperand2 (@expr1073748113 ) !=@expr1073748114 nullptr ;
442: }
443: bool isUnaryOp ( const std :: string & s@var859 ) const {
444: return s@var859 ==@expr1073748115 mStr@var1041 &&@expr1073748116 astOperand1 (@expr1073748117 ) !=@expr1073748118 nullptr &&@expr1073748119 astOperand2 (@expr1073748120 ) ==@expr1073748121 nullptr ;
445: }
446: bool isUnaryPreOp ( ) const ;
447:
448: unsigned int flags ( ) const {
449: return mFlags@var1046 ;
450: }
451: void flags ( const unsigned int flags_@var860 ) {
452: mFlags@var1046 =@expr1073748122 flags_@var860 ;
453: }
454: bool isUnsigned ( ) const {
455: return getFlag (@expr1073748123 fIsUnsigned ) ;
456: }
457: void isUnsigned ( const bool sign@var861 ) {
458: setFlag (@expr1073748124 fIsUnsigned , sign@var861 ) ;
459: }
460: bool isSigned ( ) const {
461: return getFlag (@expr1073748125 fIsSigned ) ;
462: }
463: void isSigned ( const bool sign@var862 ) {
464: setFlag (@expr1073748126 fIsSigned , sign@var862 ) ;
465: }
466: bool isPointerCompare ( ) const {
467: return getFlag (@expr1073748127 fIsPointerCompare ) ;
468: }
469: void isPointerCompare ( const bool b@var863 ) {
470: setFlag (@expr1073748128 fIsPointerCompare , b@var863 ) ;
471: }
472: bool isLong ( ) const {
473: return getFlag (@expr1073748129 fIsLong ) ;
474: }
475: void isLong ( bool size@var864 ) {
476: setFlag (@expr1073748130 fIsLong , size@var864 ) ;
477: }
478: bool isStandardType ( ) const {
479: return getFlag (@expr1073748131 fIsStandardType ) ;
480: }
481: void isStandardType ( const bool b@var865 ) {
482: setFlag (@expr1073748132 fIsStandardType , b@var865 ) ;
483: }
484: bool isExpandedMacro ( ) const {
485: return getFlag (@expr1073748133 fIsExpandedMacro ) ;
486: }
487: void isExpandedMacro ( const bool m@var866 ) {
488: setFlag (@expr1073748134 fIsExpandedMacro , m@var866 ) ;
489: }
490: bool isCast ( ) const {
491: return getFlag (@expr1073748135 fIsCast ) ;
492: }
493: void isCast ( bool c@var867 ) {
494: setFlag (@expr1073748136 fIsCast , c@var867 ) ;
495: }
496: bool isAttributeConstructor ( ) const {
497: return getFlag (@expr1073748137 fIsAttributeConstructor ) ;
498: }
499: void isAttributeConstructor ( const bool ac@var868 ) {
500: setFlag (@expr1073748138 fIsAttributeConstructor , ac@var868 ) ;
501: }
502: bool isAttributeDestructor ( ) const {
503: return getFlag (@expr1073748139 fIsAttributeDestructor ) ;
504: }
505: void isAttributeDestructor ( const bool value@var869 ) {
506: setFlag (@expr1073748140 fIsAttributeDestructor , value@var869 ) ;
507: }
508: bool isAttributeUnused ( ) const {
509: return getFlag (@expr1073748141 fIsAttributeUnused ) ;
510: }
511: void isAttributeUnused ( bool unused@var870 ) {
512: setFlag (@expr1073748142 fIsAttributeUnused , unused@var870 ) ;
513: }
514: bool isAttributeUsed ( ) const {
515: return getFlag (@expr1073748143 fIsAttributeUsed ) ;
516: }
517: void isAttributeUsed ( const bool unused@var871 ) {
518: setFlag (@expr1073748144 fIsAttributeUsed , unused@var871 ) ;
519: }
520: bool isAttributePure ( ) const {
521: return getFlag (@expr1073748145 fIsAttributePure ) ;
522: }
523: void isAttributePure ( const bool value@var872 ) {
524: setFlag (@expr1073748146 fIsAttributePure , value@var872 ) ;
525: }
526: bool isAttributeConst ( ) const {
527: return getFlag (@expr1073748147 fIsAttributeConst ) ;
528: }
529: void isAttributeConst ( bool value@var873 ) {
530: setFlag (@expr1073748148 fIsAttributeConst , value@var873 ) ;
531: }
532: bool isAttributeNoreturn ( ) const {
533: return getFlag (@expr1073748149 fIsAttributeNoreturn ) ;
534: }
535: void isAttributeNoreturn ( const bool value@var874 ) {
536: setFlag (@expr1073748150 fIsAttributeNoreturn , value@var874 ) ;
537: }
538: bool isAttributeNothrow ( ) const {
539: return getFlag (@expr1073748151 fIsAttributeNothrow ) ;
540: }
541: void isAttributeNothrow ( const bool value@var875 ) {
542: setFlag (@expr1073748152 fIsAttributeNothrow , value@var875 ) ;
543: }
544: bool isAttributePacked ( ) const {
545: return getFlag (@expr1073748153 fIsAttributePacked ) ;
546: }
547: void isAttributePacked ( const bool value@var876 ) {
548: setFlag (@expr1073748154 fIsAttributePacked , value@var876 ) ;
549: }
550: bool isAttributeNodiscard ( ) const {
551: return getFlag (@expr1073748155 fIsAttributeNodiscard ) ;
552: }
553: void isAttributeNodiscard ( const bool value@var877 ) {
554: setFlag (@expr1073748156 fIsAttributeNodiscard , value@var877 ) ;
555: }
556: bool isAttributeMaybeUnused ( ) const {
557: return getFlag (@expr1073748157 fIsAttributeMaybeUnused ) ;
558: }
559: void isAttributeMaybeUnused ( const bool value@var878 ) {
560: setFlag (@expr1073748158 fIsAttributeMaybeUnused , value@var878 ) ;
561: }
562: void setCppcheckAttribute ( TokenImpl :: CppcheckAttributes :: Type type@var879 , long long value@var880 ) {
563: mImpl@var1047 .@expr1073748159 setCppcheckAttribute (@expr1073748160 type@var879 , value@var880 ) ;
564: }
565: bool getCppcheckAttribute ( TokenImpl :: CppcheckAttributes :: Type type@var881 , long long * value@var882 ) const {
566: return mImpl@var1047 .@expr1073748161 getCppcheckAttribute (@expr1073748162 type@var881 , value@var882 ) ;
567: }
568: bool hasCppcheckAttributes ( ) const {
569: return nullptr !=@expr1073748163 mImpl@var1047 .@expr1073748164 mCppcheckAttributes@var1080 ;
570: }
571: bool isControlFlowKeyword ( ) const {
572: return getFlag (@expr1073748165 fIsControlFlowKeyword ) ;
573: }
574: bool isOperatorKeyword ( ) const {
575: return getFlag (@expr1073748166 fIsOperatorKeyword ) ;
576: }
577: void isOperatorKeyword ( const bool value@var883 ) {
578: setFlag (@expr1073748167 fIsOperatorKeyword , value@var883 ) ;
579: }
580: bool isComplex ( ) const {
581: return getFlag (@expr1073748168 fIsComplex ) ;
582: }
583: void isComplex ( const bool value@var884 ) {
584: setFlag (@expr1073748169 fIsComplex , value@var884 ) ;
585: }
586: bool isEnumType ( ) const {
587: return getFlag (@expr1073748170 fIsEnumType ) ;
588: }
589: void isEnumType ( const bool value@var885 ) {
590: setFlag (@expr1073748171 fIsEnumType , value@var885 ) ;
591: }
592: bool isAtAddress ( ) const {
593: return getFlag (@expr1073748172 fAtAddress ) ;
594: }
595: void isAtAddress ( bool b@var886 ) {
596: setFlag (@expr1073748173 fAtAddress , b@var886 ) ;
597: }
598: bool isIncompleteVar ( ) const {
599: return getFlag (@expr1073748174 fIncompleteVar ) ;
600: }
601: void isIncompleteVar ( bool b@var887 ) {
602: setFlag (@expr1073748175 fIncompleteVar , b@var887 ) ;
603: }
604:
605: bool isIncompleteConstant ( ) const {
606: return getFlag (@expr1073748176 fIsIncompleteConstant ) ;
607: }
608: void isIncompleteConstant ( bool b@var888 ) {
609: setFlag (@expr1073748177 fIsIncompleteConstant , b@var888 ) ;
610: }
611:
612: bool isConstexpr ( ) const {
613: return getFlag (@expr1073748178 fConstexpr ) ;
614: }
615: void isConstexpr ( bool b@var889 ) {
616: setFlag (@expr1073748179 fConstexpr , b@var889 ) ;
617: }
618:
619: bool isExternC ( ) const {
620: return getFlag (@expr1073748180 fExternC ) ;
621: }
622: void isExternC ( bool b@var890 ) {
623: setFlag (@expr1073748181 fExternC , b@var890 ) ;
624: }
625:
626: bool isSplittedVarDeclComma ( ) const {
627: return getFlag (@expr1073748182 fIsSplitVarDeclComma ) ;
628: }
629: void isSplittedVarDeclComma ( bool b@var891 ) {
630: setFlag (@expr1073748183 fIsSplitVarDeclComma , b@var891 ) ;
631: }
632:
633: bool isSplittedVarDeclEq ( ) const {
634: return getFlag (@expr1073748184 fIsSplitVarDeclEq ) ;
635: }
636: void isSplittedVarDeclEq ( bool b@var892 ) {
637: setFlag (@expr1073748185 fIsSplitVarDeclEq , b@var892 ) ;
638: }
639:
640: bool isImplicitInt ( ) const {
641: return getFlag (@expr1073748186 fIsImplicitInt ) ;
642: }
643: void isImplicitInt ( bool b@var893 ) {
644: setFlag (@expr1073748187 fIsImplicitInt , b@var893 ) ;
645: }
646:
647: bool isInline ( ) const {
648: return getFlag (@expr1073748188 fIsInline ) ;
649: }
650: void isInline ( bool b@var894 ) {
651: setFlag (@expr1073748189 fIsInline , b@var894 ) ;
652: }
653:
654: bool isRemovedVoidParameter ( ) const {
655: return getFlag (@expr1073748190 fIsRemovedVoidParameter ) ;
656: }
657: void setRemovedVoidParameter ( bool b@var895 ) {
658: setFlag (@expr1073748191 fIsRemovedVoidParameter , b@var895 ) ;
659: }
660:
661: bool isTemplate ( ) const {
662: return getFlag (@expr1073748192 fIsTemplate ) ;
663: }
664: void isTemplate ( bool b@var896 ) {
665: setFlag (@expr1073748193 fIsTemplate , b@var896 ) ;
666: }
667:
668: bool isSimplifiedScope ( ) const {
669: return getFlag (@expr1073748194 fIsSimplifedScope ) ;
670: }
671: void isSimplifiedScope ( bool b@var897 ) {
672: setFlag (@expr1073748195 fIsSimplifedScope , b@var897 ) ;
673: }
674:
675: bool isBitfield ( ) const {
676: return mImpl@var1047 .@expr1073748196 mBits@var1081 >@expr1073748197 0 ;
677: }
678: unsigned char bits ( ) const {
679: return mImpl@var1047 .@expr1073748198 mBits@var1081 ;
680: }
681: std :: set < TemplateSimplifier :: TokenAndName * > * templateSimplifierPointers ( ) const {
682: return mImpl@var1047 .@expr1073748199 mTemplateSimplifierPointers@var1082 ;
683: }
684: void templateSimplifierPointer ( TemplateSimplifier :: TokenAndName * tokenAndName@var898 ) {
685: if (@expr1073748200 !@expr1073748201 mImpl@var1047 .@expr6378 mTemplateSimplifierPointers@var1082 ) {
686: mImpl@var1047 .@expr6378 mTemplateSimplifierPointers@var1082 =@expr1073748204 new std ::@expr1073748205 set < TemplateSimplifier ::@expr1073748206 TokenAndName *@expr1073748207 > ; }
687: mImpl@var1047 .@expr6378 mTemplateSimplifierPointers@var1082 .@expr1073748209 insert (@expr1073748210 tokenAndName@var898 ) ;
688: }
689: void setBits ( const unsigned char b@var899 ) {
690: mImpl@var1047 .@expr1073748211 mBits@var1081 =@expr1073748212 b@var899 ;
691: }
692:
693: bool isUtf8 ( ) const {
694: return (@expr6389 (@expr6389 (@expr6389 mTokType@var1045 ==@expr1073748216 eString ) &&@expr1073748217 isPrefixStringCharLiteral (@expr1073748218 mStr@var1041 , '"' , "u8" ) ) ||@expr1073748219
695: (@expr6389 (@expr6389 mTokType@var1045 ==@expr1073748222 eChar ) &&@expr1073748223 isPrefixStringCharLiteral (@expr1073748224 mStr@var1041 , '\'' , "u8" ) ) ) ;
696: }
697:
698: bool isUtf16 ( ) const {
699: return (@expr6401 (@expr6401 (@expr6401 mTokType@var1045 ==@expr1073748228 eString ) &&@expr1073748229 isPrefixStringCharLiteral (@expr1073748230 mStr@var1041 , '"' , "u" ) ) ||@expr1073748231
700: (@expr6401 (@expr6401 mTokType@var1045 ==@expr1073748234 eChar ) &&@expr1073748235 isPrefixStringCharLiteral (@expr1073748236 mStr@var1041 , '\'' , "u" ) ) ) ;
701: }
702:
703: bool isUtf32 ( ) const {
704: return (@expr6413 (@expr6413 (@expr6413 mTokType@var1045 ==@expr1073748240 eString ) &&@expr1073748241 isPrefixStringCharLiteral (@expr1073748242 mStr@var1041 , '"' , "U" ) ) ||@expr1073748243
705: (@expr6413 (@expr6413 mTokType@var1045 ==@expr1073748246 eChar ) &&@expr1073748247 isPrefixStringCharLiteral (@expr1073748248 mStr@var1041 , '\'' , "U" ) ) ) ;
706: }
707:
708: bool isCChar ( ) const {
709: return (@expr6425 (@expr6425 (@expr6425 mTokType@var1045 ==@expr1073748252 eString ) &&@expr1073748253 isPrefixStringCharLiteral (@expr1073748254 mStr@var1041 , '"' , "" ) ) ||@expr1073748255
710: (@expr6425 (@expr6425 mTokType@var1045 ==@expr1073748258 eChar ) &&@expr1073748259 isPrefixStringCharLiteral (@expr1073748260 mStr@var1041 , '\'' , "" ) &&@expr1073748261 mStr@var1041 .@expr1073748262 length (@expr1073748263 ) ==@expr1073748264 3 ) ) ;
711: }
712:
713: bool isCMultiChar ( ) const {
714: return (@expr6441 (@expr6441 (@expr6441 mTokType@var1045 ==@expr1073748268 eChar ) &&@expr1073748269 isPrefixStringCharLiteral (@expr1073748270 mStr@var1041 , '\'' , "" ) ) &&@expr1073748271
715: (@expr6441 mStr@var1041 .@expr1073748273 length (@expr1073748274 ) >@expr1073748275 3 ) ) ;
716: }
717:
|
733:
734: bool isTemplateArg ( ) const {
735: return getFlag (@expr1073748276 fIsTemplateArg ) ;
736: }
737: void isTemplateArg ( const bool value@var900 ) {
738: setFlag (@expr1073748277 fIsTemplateArg , value@var900 ) ;
739: }
740:
741: template < unsigned long count >
742: static const Token * findsimplematch ( const Token * const startTok@var901 , const char ( & pattern@var902 ) [ count ] ) {
743: return findsimplematch (@expr1073748279 startTok@var901 , pattern@var902 , count@expr1073748278 -@expr1073748280 1 ) ;
744: }
745: static const Token * findsimplematch ( const Token * const startTok@var903 , const char pattern@var904 [ ] , unsigned long pattern_len@var905 ) ;
746:
747: template < unsigned long count >
748: static const Token * findsimplematch ( const Token * const startTok@var906 , const char ( & pattern@var907 ) [ count ] , const Token * const end@var908 ) {
749: return findsimplematch (@expr1073748282 startTok@var906 , pattern@var907 , count@expr1073748281 -@expr1073748283 1 , end@var908 ) ;
750: }
751: static const Token * findsimplematch ( const Token * const startTok@var909 , const char pattern@var910 [ ] , unsigned long pattern_len@var911 , const Token * const end@var912 ) ;
752:
753: static const Token * findmatch ( const Token * const startTok@var913 , const char pattern@var914 [ ] , const int varId@var915 = 0 ) ;
754: static const Token * findmatch ( const Token * const startTok@var916 , const char pattern@var917 [ ] , const Token * const end@var918 , const int varId@var919 = 0 ) ;
755:
756: template < unsigned long count >
757: static Token * findsimplematch ( Token * const startTok@var920 , const char ( & pattern@var921 ) [ count ] ) {
758: return findsimplematch (@expr1073748285 startTok@var920 , pattern@var921 , count@expr1073748284 -@expr1073748286 1 ) ;
759: }
760: static Token * findsimplematch ( Token * const startTok@var922 , const char pattern@var923 [ ] , unsigned long pattern_len@var924 ) {
761: return const_cast < Token *@expr6463 > (@expr1073748288 findsimplematch (@expr1073748289 const_cast < const Token *@expr6463 > (@expr1073748291 startTok@var922 ) , pattern@var923 , pattern_len@var924 ) ) ;
762: }
763: template < unsigned long count >
764: static Token * findsimplematch ( Token * const startTok@var925 , const char ( & pattern@var926 ) [ count ] , const Token * const end@var927 ) {
765: return findsimplematch (@expr1073748293 startTok@var925 , pattern@var926 , count@expr1073748292 -@expr1073748294 1 , end@var927 ) ;
766: }
767: static Token * findsimplematch ( Token * const startTok@var928 , const char pattern@var929 [ ] , unsigned long pattern_len@var930 , const Token * const end@var931 ) {
768: return const_cast < Token *@expr6471 > (@expr1073748296 findsimplematch (@expr1073748297 const_cast < const Token *@expr6471 > (@expr1073748299 startTok@var928 ) , pattern@var929 , pattern_len@var930 , end@var931 ) ) ;
769: }
770:
771: static Token * findmatch ( Token * const startTok@var932 , const char pattern@var933 [ ] , const int varId@var934 = 0 ) {
772: return const_cast < Token *@expr6476 > (@expr1073748301 findmatch (@expr1073748302 const_cast < const Token *@expr6476 > (@expr1073748304 startTok@var932 ) , pattern@var933 , varId@var934 ) ) ;
773: }
774: static Token * findmatch ( Token * const startTok@var935 , const char pattern@var936 [ ] , const Token * const end@var937 , const int varId@var938 = 0 ) {
775: return const_cast < Token *@expr6481 > (@expr1073748306 findmatch (@expr1073748307 const_cast < const Token *@expr6481 > (@expr1073748309 startTok@var935 ) , pattern@var936 , end@var937 , varId@var938 ) ) ;
776: }
777:
|
791:
792: static int multiCompare ( const Token * tok@var939 , const char * haystack@var940 , int varid@var941 ) ;
793:
794: int fileIndex ( ) const {
795: return mImpl@var1047 .@expr1073748310 mFileIndex@var1083 ;
796: }
797: void fileIndex ( int indexOfFile@var942 ) {
798: mImpl@var1047 .@expr1073748311 mFileIndex@var1083 =@expr1073748312 indexOfFile@var942 ;
799: }
800:
801: int linenr ( ) const {
802: return mImpl@var1047 .@expr1073748313 mLineNumber@var1084 ;
803: }
804: void linenr ( int lineNumber@var943 ) {
805: mImpl@var1047 .@expr1073748314 mLineNumber@var1084 =@expr1073748315 lineNumber@var943 ;
806: }
807:
808: int column ( ) const {
809: return mImpl@var1047 .@expr1073748316 mColumn@var1085 ;
810: }
811: void column ( int c@var944 ) {
812: mImpl@var1047 .@expr1073748317 mColumn@var1085 =@expr1073748318 c@var944 ;
813: }
814:
815: Token * next ( ) const {
816: return mNext@var1042 ;
817: }
818:
|
826:
827: static void eraseTokens ( Token * begin@var945 , const Token * end@var946 ) ;
828:
|
836:
837: Token * insertToken ( const std :: string & tokenStr@var947 , const std :: string & originalNameStr@var948 = emptyString@var1 , bool prepend@var949 = false ) ;
838:
839: Token * insertTokenBefore ( const std :: string & tokenStr@var950 , const std :: string & originalNameStr@var951 = emptyString@var1 )
840: {
841: return insertToken (@expr1073748319 tokenStr@var950 , originalNameStr@var951 , true ) ;
842: }
843:
844: Token * previous ( ) const {
845: return mPrevious@var1043 ;
846: }
847:
848:
849: int varId ( ) const {
850: return mImpl@var1047 .@expr1073748320 mVarId@var1078 ;
851: }
852: void varId ( int id@var952 ) {
853: mImpl@var1047 .@expr1073748321 mVarId@var1078 =@expr1073748322 id@var952 ;
854: if (@expr1073748323 id@var952 !=@expr1073748324 0 ) {
855: tokType (@expr1073748325 eVariable ) ;
856: isStandardType (@expr1073748326 false ) ;
857: } else {
858: update_property_info (@expr1073748327 ) ;
859: }
860: }
861:
862: int exprId ( ) const {
863: if (@expr1073748328 mImpl@var1047 .@expr6505 mExprId@var1086 ) {
864: return mImpl@var1047 .@expr6505 mExprId@var1086 ; }
865: return mImpl@var1047 .@expr1073748331 mVarId@var1078 ;
866: }
867: void exprId ( int id@var953 ) {
868: mImpl@var1047 .@expr1073748332 mExprId@var1086 =@expr1073748333 id@var953 ;
869: }
870:
|
876:
877: void printOut ( const char * title@var954 = nullptr ) const ;
878:
|
886:
887: void printOut ( const char * title@var955 , const std :: vector < std :: string > & fileNames@var956 ) const ;
888:
|
891:
892: void printLines ( int lines@var957 = 5 ) const ;
893:
|
900:
901: static void replace ( Token * replaceThis@var958 , Token * start@var959 , Token * end@var960 ) ;
902:
903: struct stringifyOptions {
904: bool varid@var961 ; varid@var961 = false ;
905: bool exprid@var962 ; exprid@var962 = false ;
906: bool idtype@var963 ; idtype@var963 = false ;
907: bool attributes@var964 ; attributes@var964 = false ;
908: bool macro@var965 ; macro@var965 = false ;
909: bool linenumbers@var966 ; linenumbers@var966 = false ;
910: bool linebreaks@var967 ; linebreaks@var967 = false ;
911: bool files@var968 ; files@var968 = false ;
912: static stringifyOptions forDebug ( ) {
913: stringifyOptions options@var969 ;
914: options@var969 .@expr1073748334 attributes@var970 =@expr1073748335 true ;
915: options@var969 .@expr1073748336 macro@var971 =@expr1073748337 true ;
916: options@var969 .@expr1073748338 linenumbers@var972 =@expr1073748339 true ;
917: options@var969 .@expr1073748340 linebreaks@var973 =@expr1073748341 true ;
918: options@var969 .@expr1073748342 files@var974 =@expr1073748343 true ;
919: return options@var969 ;
920: }
921: static stringifyOptions forDebugVarId ( ) {
922: stringifyOptions options@var975 ; options@var975 =@expr1073748344 forDebug (@expr1073748345 ) ;
923: options@var975 .@expr1073748346 varid@var976 =@expr1073748347 true ;
924: return options@var975 ;
925: }
926: static stringifyOptions forDebugExprId ( ) {
927: stringifyOptions options@var977 ; options@var977 =@expr1073748348 forDebug (@expr1073748349 ) ;
928: options@var977 .@expr1073748350 exprid@var978 =@expr1073748351 true ;
929: return options@var977 ;
930: }
931: static stringifyOptions forPrintOut ( ) {
932: stringifyOptions options@var979 ; options@var979 =@expr1073748352 forDebug (@expr1073748353 ) ;
933: options@var979 .@expr1073748354 exprid@var980 =@expr1073748355 true ;
934: options@var979 .@expr1073748356 varid@var981 =@expr1073748357 true ;
935: options@var979 .@expr1073748358 idtype@var982 =@expr1073748359 true ;
936: return options@var979 ;
937: }
938: } ;
939:
940: std :: string stringify ( const stringifyOptions & options@var983 ) const ;
941:
|
947:
948: std :: string stringify ( bool varid@var984 , bool attributes@var985 , bool macro@var986 ) const ;
949:
950: std :: string stringifyList ( const stringifyOptions & options@var987 , const std :: vector < std :: string > * fileNames@var988 = nullptr , const Token * end@var989 = nullptr ) const ;
951: std :: string stringifyList ( const Token * end@var990 , bool attributes@var991 = true ) const ;
952: std :: string stringifyList ( bool varid@var992 = false ) const ;
953:
|
964:
965: std :: string stringifyList ( bool varid@var993 , bool attributes@var994 , bool linenumbers@var995 , bool linebreaks@var996 , bool files@var997 , const std :: vector < std :: string > * fileNames@var998 = nullptr , const Token * end@var999 = nullptr ) const ;
966:
|
974:
975: void deleteThis ( ) ;
976:
|
981:
982: void link ( Token * linkToToken@var1000 ) {
983: mLink@var1044 =@expr1073748360 linkToToken@var1000 ;
984: if (@expr1073748361 mStr@var1041 ==@expr1073748362 "<" ||@expr1073748363 mStr@var1041 ==@expr1073748364 ">" ) {
985: update_property_info (@expr1073748365 ) ; }
986: }
987:
|
996:
997: Token * link ( ) const {
998: return mLink@var1044 ;
999: }
1000:
|
1004:
1005: void scope ( const Scope * s@var1001 ) {
1006: mImpl@var1047 .@expr1073748366 mScope@var1087 =@expr1073748367 s@var1001 ;
1007: }
1008:
|
1011:
1012: const Scope * scope ( ) const {
1013: return mImpl@var1047 .@expr1073748368 mScope@var1087 ;
1014: }
1015:
|
1019:
1020: void function ( const Function * f@var1002 ) ;
1021:
|
1024:
1025: const Function * function ( ) const {
1026: return mTokType@var1045 ==@expr1073748369 eFunction ||@expr1073748370 mTokType@var1045 ==@expr1073748371 eLambda ?@expr1073748372 mImpl@var1047 .@expr1073748373 mFunction@var1088 :@expr1073748374 nullptr ;
1027: }
1028:
|
1032:
1033: void variable ( const Variable * v@var1003 ) {
1034: mImpl@var1047 .@expr1073748375 mVariable@var1089 =@expr1073748376 v@var1003 ;
1035: if (@expr1073748377 v@var1003 ||@expr1073748378 mImpl@var1047 .@expr1073748379 mVarId@var1078 ) {
1036: tokType (@expr1073748380 eVariable ) ; }
1037: else { if (@expr1073748381 mTokType@var1045 ==@expr1073748382 eVariable ) {
1038: tokType (@expr1073748383 eName ) ; } }
1039: }
1040:
|
1043:
1044: const Variable * variable ( ) const {
1045: return mTokType@var1045 ==@expr1073748384 eVariable ?@expr1073748385 mImpl@var1047 .@expr1073748386 mVariable@var1089 :@expr1073748387 nullptr ;
1046: }
1047:
|
1051:
1052: void type ( const :: Type * t@var1004 ) ;
1053:
|
1056:
1057: const :: Type * type ( ) const {
1058: return mTokType@var1045 ==@expr1073748388 eType ?@expr1073748389 mImpl@var1047 .@expr1073748390 mType@var1090 :@expr1073748391 nullptr ;
1059: }
1060:
1061: static const :: Type * typeOf ( const Token * tok@var1005 , const Token * * typeTok@var1006 = nullptr ) ;
1062:
1063: static std :: pair < const Token * , const Token * > typeDecl ( const Token * tok@var1007 ) ;
1064:
1065: static std :: string typeStr ( const Token * tok@var1008 ) ;
1066:
|
1069:
1070: const Enumerator * enumerator ( ) const {
1071: return mTokType@var1045 ==@expr1073748392 eEnumerator ?@expr1073748393 mImpl@var1047 .@expr1073748394 mEnumerator@var1091 :@expr1073748395 nullptr ;
1072: }
1073:
|
1077:
1078: void enumerator ( const Enumerator * e@var1009 ) {
1079: mImpl@var1047 .@expr1073748396 mEnumerator@var1091 =@expr1073748397 e@var1009 ;
1080: if (@expr1073748398 e@var1009 ) {
1081: tokType (@expr1073748399 eEnumerator ) ; }
1082: else { if (@expr1073748400 mTokType@var1045 ==@expr1073748401 eEnumerator ) {
1083: tokType (@expr1073748402 eName ) ; } }
1084: }
1085:
|
1088:
1089: static void createMutualLinks ( Token * begin@var1010 , Token * end@var1011 ) ;
1090:
|
1096:
1097: std :: string strValue ( ) const ;
1098:
|
1105:
1106: static void move ( Token * srcStart@var1012 , Token * srcEnd@var1013 , Token * newLocation@var1014 ) ;
1107:
1108:
1109: int progressValue ( ) const {
1110: return mImpl@var1047 .@expr1073748403 mProgressValue@var1092 ;
1111: }
1112:
1113:
1114: static void assignProgressValues ( Token * tok@var1015 ) ;
1115:
|
1120:
1121: Token * nextArgument ( ) const ;
1122:
|
1127:
1128: Token * nextArgumentBeforeCreateLinks2 ( ) const ;
1129:
|
1134:
1135: Token * nextTemplateArgument ( ) const ;
1136:
|
1141:
1142: const Token * findClosingBracket ( ) const ;
1143: Token * findClosingBracket ( ) ;
1144:
1145: const Token * findOpeningBracket ( ) const ;
1146: Token * findOpeningBracket ( ) ;
1147:
|
1150:
1151: const std :: string & originalName ( ) const {
1152: return mImpl@var1047 .@expr6580 mOriginalName@var1093 ?@expr1073748405 *@expr1073748406 mImpl@var1047 .@expr6580 mOriginalName@var1093 :@expr1073748408 emptyString@var1 ;
1153: }
1154:
1155: const std :: list < ValueFlow :: Value > & values ( ) const {
1156: return mImpl@var1047 .@expr6585 mValues@var1066 ?@expr1073748410 *@expr1073748411 mImpl@var1047 .@expr6585 mValues@var1066 :@expr1073748413 TokenImpl ::@expr1073748414 mEmptyValueList@var813 ;
1157: }
1158:
|
1161:
1162: template < typename T >
1163: void originalName ( T && name@var1016 ) {
1164: if (@expr1073748415 !@expr1073748416 mImpl@var1047 .@expr6593 mOriginalName@var1093 ) {
1165: mImpl@var1047 .@expr6593 mOriginalName@var1093 =@expr1073748419 new std ::@expr1073748420 string (@expr1073748421 name@var1016 ) ; }
1166: else {
1167: *@expr1073748422 mImpl@var1047 .@expr6593 mOriginalName@var1093 =@expr1073748424 name@var1016 ; }
1168: }
1169:
1170: bool hasKnownIntValue ( ) const ;
1171: bool hasKnownValue ( ) const ;
1172: bool hasKnownValue ( ValueFlow :: Value :: ValueType t@var1017 ) const ;
1173: bool hasKnownSymbolicValue ( const Token * tok@var1018 ) const ;
1174:
1175: const ValueFlow :: Value * getKnownValue ( ValueFlow :: Value :: ValueType t@var1019 ) const ;
1176: long long getKnownIntValue ( ) const {
1177: return mImpl@var1047 .@expr1073748426 mValues@var1066 .@expr1073748427 front (@expr1073748428 ) .@expr1073748429 intvalue@expr1073748425 ;
1178: }
1179:
1180: const ValueFlow :: Value * getValue ( const long long val@var1020 ) const ;
1181:
1182: const ValueFlow :: Value * getMaxValue ( bool condition@var1021 , long long path@var1022 = 0 ) const ;
1183:
1184: const ValueFlow :: Value * getMovedValue ( ) const ;
1185:
1186: const ValueFlow :: Value * getValueLE ( const long long val@var1023 , const Settings * settings@var1024 ) const ;
1187: const ValueFlow :: Value * getValueGE ( const long long val@var1025 , const Settings * settings@var1026 ) const ;
1188:
1189: const ValueFlow :: Value * getInvalidValue ( const Token * ftok@var1027 , int argnr@var1028 , const Settings * settings@var1029 ) const ;
1190:
1191: const ValueFlow :: Value * getContainerSizeValue ( const long long val@var1030 ) const ;
1192:
1193: const Token * getValueTokenMaxStrLength ( ) const ;
1194: const Token * getValueTokenMinStrSize ( const Settings * settings@var1031 ) const ;
1195:
1196:
1197: bool addValue ( const ValueFlow :: Value & value@var1032 ) ;
1198:
1199: void removeValues ( std :: function < bool ( const ValueFlow :: Value & ) > pred@var1033 ) {
1200: if (@expr1073748430 mImpl@var1047 .@expr6607 mValues@var1066 ) {
1201: mImpl@var1047 .@expr6607 mValues@var1066 .@expr1073748433 remove_if (@expr1073748434 pred@var1033 ) ; }
1202: }
1203:
1204: int index ( ) const {
1205: return mImpl@var1047 .@expr1073748435 mIndex@var1094 ;
1206: }
1207:
1208: void assignIndexes ( ) ;
1209:
1210: private:
1211:
1212: void next ( Token * nextToken@var1034 ) {
1213: mNext@var1042 =@expr1073748436 nextToken@var1034 ;
1214: }
1215: void previous ( Token * previousToken@var1035 ) {
1216: mPrevious@var1043 =@expr1073748437 previousToken@var1035 ;
1217: }
1218:
1219:
1220: void takeData ( Token * fromToken@var1036 ) ;
1221:
|
1226:
1227: static bool firstWordEquals ( const char * str@var1037 , const char * word@var1038 ) ;
1228:
|
1233:
1234: static const char * chrInFirstWord ( const char * str@var1039 , char c@var1040 ) ;
1235:
1236: std :: string mStr@var1041 ;
1237:
1238: Token * mNext@var1042 ;
1239: Token * mPrevious@var1043 ;
1240: Token * mLink@var1044 ;
1241:
1242: enum Anonymous2 : uint64_t {
1243: fIsUnsigned = ( 1 << 0 ) ,
1244: fIsSigned = ( 1 << 1 ) ,
1245: fIsPointerCompare = ( 1 << 2 ) ,
1246: fIsLong = ( 1 << 3 ) ,
1247: fIsStandardType = ( 1 << 4 ) ,
1248: fIsExpandedMacro = ( 1 << 5 ) ,
1249: fIsCast = ( 1 << 6 ) ,
1250: fIsAttributeConstructor = ( 1 << 7 ) ,
1251: fIsAttributeDestructor = ( 1 << 8 ) ,
1252: fIsAttributeUnused = ( 1 << 9 ) ,
1253: fIsAttributePure = ( 1 << 10 ) ,
1254: fIsAttributeConst = ( 1 << 11 ) ,
1255: fIsAttributeNoreturn = ( 1 << 12 ) ,
1256: fIsAttributeNothrow = ( 1 << 13 ) ,
1257: fIsAttributeUsed = ( 1 << 14 ) ,
1258: fIsAttributePacked = ( 1 << 15 ) ,
1259: fIsAttributeMaybeUnused = ( 1 << 16 ) ,
1260: fIsControlFlowKeyword = ( 1 << 17 ) ,
1261: fIsOperatorKeyword = ( 1 << 18 ) ,
1262: fIsComplex = ( 1 << 19 ) ,
1263: fIsEnumType = ( 1 << 20 ) ,
1264: fIsName = ( 1 << 21 ) ,
1265: fIsLiteral = ( 1 << 22 ) ,
1266: fIsTemplateArg = ( 1 << 23 ) ,
1267: fIsAttributeNodiscard = ( 1 << 24 ) ,
1268: fAtAddress = ( 1 << 25 ) ,
1269: fIncompleteVar = ( 1 << 26 ) ,
1270: fConstexpr = ( 1 << 27 ) ,
1271: fExternC = ( 1 << 28 ) ,
1272: fIsSplitVarDeclComma = ( 1 << 29 ) ,
1273: fIsSplitVarDeclEq = ( 1 << 30 ) ,
1274: fIsImplicitInt = ( 1U << 31 ) ,
1275: fIsInline = ( 1ULL << 32 ) ,
1276: fIsTemplate = ( 1ULL << 33 ) ,
1277: fIsSimplifedScope = ( 1ULL << 34 ) ,
1278: fIsRemovedVoidParameter = ( 1ULL << 35 ) ,
1279: fIsIncompleteConstant = ( 1ULL << 36 ) ,
1280: } ;
1281:
1282: Token :: Type mTokType@var1045 ;
1283:
1284: uint64_t mFlags@var1046 ;
1285:
1286: TokenImpl * mImpl@var1047 ;
1287:
|
1292:
1293: bool getFlag ( uint64_t flag_@var1048 ) const {
1294: return (@expr6614 (@expr6614 mFlags@var1046 &@expr1073748440 flag_@var1048 ) !=@expr1073748441 0 ) ;
1295: }
1296:
|
1301:
1302: void setFlag ( uint64_t flag_@var1049 , bool state_@var1050 ) {
1303: mFlags@var1046 =@expr1073748442 state_@var1050 ?@expr1073748443 mFlags@var1046 |@expr1073748444 flag_@var1049 :@expr1073748445 mFlags@var1046 &@expr1073748446 ~@expr1073748447 flag_@var1049 ;
1304: }
1305:
1306:
1307:
1308: void update_property_info ( ) ;
1309:
1310:
1311: void update_property_isStandardType ( ) ;
1312:
1313:
1314: void update_property_char_string_literal ( ) ;
1315:
1316:
1317: void astStringVerboseRecursive ( std :: string & ret@var1051 , const int indent1@var1052 = 0 , const int indent2@var1053 = 0 ) const ;
1318:
1319: public:
1320: void astOperand1 ( Token * tok@var1054 ) ;
1321: void astOperand2 ( Token * tok@var1055 ) ;
1322: void astParent ( Token * tok@var1056 ) ;
1323:
1324: Token * astOperand1 ( ) {
1325: return mImpl@var1047 .@expr1073748448 mAstOperand1@var1057 ;
1326: }
1327: const Token * astOperand1 ( ) const {
1328: return mImpl@var1047 .@expr1073748449 mAstOperand1@var1057 ;
1329: }
1330: Token * astOperand2 ( ) {
1331: return mImpl@var1047 .@expr1073748450 mAstOperand2@var1058 ;
1332: }
1333: const Token * astOperand2 ( ) const {
1334: return mImpl@var1047 .@expr1073748451 mAstOperand2@var1058 ;
1335: }
1336: Token * astParent ( ) {
1337: return mImpl@var1047 .@expr1073748452 mAstParent@var1059 ;
1338: }
1339: const Token * astParent ( ) const {
1340: return mImpl@var1047 .@expr1073748453 mAstParent@var1059 ;
1341: }
1342: Token * astSibling ( ) {
1343: if (@expr1073748454 !@expr1073748455 astParent (@expr6632 ) ) {
1344: return nullptr ; }
1345: if (@expr1073748457 this@expr6634 ==@expr1073748459 astParent (@expr6632 ) .@expr6637 astOperand1 (@expr6638 ) ) {
1346: return astParent (@expr6632 ) .@expr6640 astOperand2 (@expr6641 ) ; }
1347: else { if (@expr1073748466 this@expr6634 ==@expr1073748467 astParent (@expr6632 ) .@expr6640 astOperand2 (@expr6641 ) ) {
1348: return astParent (@expr6632 ) .@expr6637 astOperand1 (@expr6638 ) ; } }
1349: return nullptr ;
1350:
1351: }
1352: const Token * astSibling ( ) const {
1353: if (@expr1073748474 !@expr1073748475 astParent (@expr6652 ) ) {
1354: return nullptr ; }
1355: if (@expr1073748477 this@expr6654 ==@expr1073748479 astParent (@expr6652 ) .@expr6657 astOperand1 (@expr6658 ) ) {
1356: return astParent (@expr6652 ) .@expr6660 astOperand2 (@expr6661 ) ; }
1357: else { if (@expr1073748486 this@expr6654 ==@expr1073748487 astParent (@expr6652 ) .@expr6660 astOperand2 (@expr6661 ) ) {
1358: return astParent (@expr6652 ) .@expr6657 astOperand1 (@expr6658 ) ; } }
1359: return nullptr ;
1360:
1361: }
1362: Token * astTop ( ) {
1363: Token * ret@var1060 ; ret@var1060 =@expr1073748494 this@expr1073748495 ;
1364: while (@expr1073748496 ret@var1060 .@expr6673 mImpl@var1061 .@expr6674 mAstParent@var1062 ) {
1365: ret@var1060 =@expr1073748499 ret@var1060 .@expr6673 mImpl@var1061 .@expr6674 mAstParent@var1062 ; }
1366: return ret@var1060 ;
1367: }
1368:
1369: const Token * astTop ( ) const {
1370: const Token * ret@var1063 ; ret@var1063 =@expr1073748502 this@expr1073748503 ;
1371: while (@expr1073748504 ret@var1063 .@expr6681 mImpl@var1064 .@expr6682 mAstParent@var1065 ) {
1372: ret@var1063 =@expr1073748507 ret@var1063 .@expr6681 mImpl@var1064 .@expr6682 mAstParent@var1065 ; }
1373: return ret@var1063 ;
1374: }
1375:
1376: std :: pair < const Token * , const Token * > findExpressionStartEndTokens ( ) const ;
1377:
|
1384:
1385: bool isCalculation ( ) const ;
1386:
1387: void clearAst ( ) {
1388: mImpl@var1047 .@expr1073748510 mAstOperand1@var1057 =@expr1073748511 mImpl@var1047 .@expr1073748512 mAstOperand2@var1058 =@expr1073748513 mImpl@var1047 .@expr1073748514 mAstParent@var1059 =@expr1073748515 nullptr ;
1389: }
1390:
1391: void clearValueFlow ( ) {
1392: delete mImpl@var1047 .@expr6692 mValues@var1066 ;
1393: mImpl@var1047 .@expr6692 mValues@var1066 =@expr1073748518 nullptr ;
1394: }
1395:
1396: std :: string astString ( const char * sep@var1067 = "" ) const {
1397: std ::@expr1073748519 string ret@var1068 ;
1398: if (@expr1073748520 mImpl@var1047 .@expr6697 mAstOperand1@var1057 ) {
1399: ret@var1068 =@expr1073748522 mImpl@var1047 .@expr6697 mAstOperand1@var1057 .@expr1073748524 astString (@expr1073748525 sep@var1067 ) ; }
1400: if (@expr1073748526 mImpl@var1047 .@expr6703 mAstOperand2@var1058 ) {
1401: ret@var1068 +=@expr1073748528 mImpl@var1047 .@expr6703 mAstOperand2@var1058 .@expr1073748530 astString (@expr1073748531 sep@var1067 ) ; }
1402: return ret@var1068 +@expr1073748532 sep@var1067 +@expr1073748533 mStr@var1041 ;
1403: }
1404:
1405: std :: string astStringVerbose ( ) const ;
1406:
1407: std :: string astStringZ3 ( ) const ;
1408:
1409: std :: string expressionString ( ) const ;
1410:
1411: void printAst ( bool verbose@var1069 , bool xml@var1070 , const std :: vector < std :: string > & fileNames@var1071 , std :: ostream & out@var1072 ) const ;
1412:
1413: void printValueFlow ( bool xml@var1073 , std :: ostream & out@var1074 ) const ;
1414:
1415: void scopeInfo ( std :: shared_ptr < ScopeInfo2 > newScopeInfo@var1075 ) ;
1416: std :: shared_ptr < ScopeInfo2 > scopeInfo ( ) const ;
1417:
1418: void setCpp11init ( bool cpp11init@var1076 ) const {
1419: mImpl@var1047 .@expr1073748534 mCpp11init@var1077 =@expr1073748535 cpp11init@var1076 ?@expr1073748536 TokenImpl ::@expr6713 Cpp11init ::@expr1073748538 CPP11INIT :@expr1073748539 TokenImpl ::@expr6713 Cpp11init ::@expr1073748541 NOINIT ;
1420: }
1421: TokenImpl :: Cpp11init isCpp11init ( ) const {
1422: return mImpl@var1047 .@expr1073748542 mCpp11init@var1077 ;
1423: }
1424: } ;
1425:
1426: Token * findTypeEnd ( Token * tok@var1095 ) ;
1427: const Token * findTypeEnd ( const Token * tok@var1096 ) ;
1428: Token * findLambdaEndScope ( Token * tok@var1097 ) ;
1429: const Token * findLambdaEndScope ( const Token * tok@var1098 ) ;

##file cppcheck-2.8/lib/symboldatabase.h

1:
|
39:
40: namespace cppcheck {
41: class Platform ;
42: }
43:
44: class ErrorLogger ;
45: class Function ;
46: class Scope ;
47: class Settings ;
48: class SymbolDatabase ;
49: class Tokenizer ;
50: class ValueType ;
51:
|
54:
55: enum class AccessControl { Public , Protected , Private , Global , Namespace , Argument , Local , Throw } ;
56:
|
59:
60: struct Dimension {
61: Dimension ( ) : tok@var1099 ( nullptr ) , num@var1100 ( 0 ) , known@var1101 ( true ) { }
62:
63: const Token * tok@var1099 ;
64: long long num@var1100 ;
65: bool known@var1101 ;
66: } ;
67:
68:
69: class Type {
70: public:
71: const Token * classDef@var1102 ;
72: const Scope * classScope@var1103 ;
73: const Scope * enclosingScope@var1104 ;
74: enum class NeedInitialization {
75: Unknown , True , False
76: } ; enum NeedInitialization needInitialization@var1105 ;
77:
78: class BaseInfo {
79: public:
80: BaseInfo ( ) :
81: type@var1107 ( nullptr ) , nameTok@var1108 ( nullptr ) , access@var1109 ( AccessControl :: Public ) , isVirtual@var1110 ( false ) { }
82:
83: std :: string name@var1106 ;
84: const Type * type@var1107 ;
85: const Token * nameTok@var1108 ;
86: AccessControl access@var1109 ;
87: bool isVirtual@var1110 ;
88:
89: bool operator< ( const BaseInfo & rhs@var1111 ) const {
90: return this@expr1073748543 .@expr1073748544 type@var1107 <@expr1073748545 rhs@var1111 .@expr1073748546 type@var1112 ;
91: }
92: } ;
93:
94: struct FriendInfo {
95: FriendInfo ( ) :
96: nameStart@var1113 ( nullptr ) , nameEnd@var1114 ( nullptr ) , type@var1115 ( nullptr ) { }
97:
98: const Token * nameStart@var1113 ;
99: const Token * nameEnd@var1114 ;
100: const Type * type@var1115 ;
101: } ;
102:
103: std :: vector < BaseInfo > derivedFrom@var1116 ;
104: std :: vector < FriendInfo > friendList@var1117 ;
105:
106: const Token * typeStart@var1118 ;
107: const Token * typeEnd@var1119 ;
108: long long sizeOf@var1120 ;
109:
110: Type ( const Token * classDef_@var1121 = nullptr , const Scope * classScope_@var1122 = nullptr , const Scope * enclosingScope_@var1123 = nullptr ) :
111: classDef@var1102 ( classDef_@var1121 ) ,
112: classScope@var1103 ( classScope_@var1122 ) ,
113: enclosingScope@var1104 ( enclosingScope_@var1123 ) ,
114: needInitialization@var1105 ( NeedInitialization :: Unknown ) ,
115: typeStart@var1118 ( nullptr ) ,
116: typeEnd@var1119 ( nullptr ) ,
117: sizeOf@var1120 ( 0 ) {
118: if (@expr1073748547 classDef_@var1121 &&@expr1073748548 classDef_@var1121 .@expr6725 str (@expr6726 ) ==@expr1073748551 "enum" ) {
119: needInitialization@var1105 =@expr1073748552 NeedInitialization ::@expr1073748553 True ; }
120: else { if (@expr1073748554 classDef_@var1121 &&@expr1073748555 classDef_@var1121 .@expr6725 str (@expr6726 ) ==@expr1073748558 "using" ) {
121: typeStart@var1118 =@expr1073748559 classDef@var1102 .@expr1073748560 tokAt (@expr1073748561 3 ) ;
122: typeEnd@var1119 =@expr1073748562 typeStart@var1118 ;
123: while (@expr1073748563 typeEnd@var1119 .@expr6740 next (@expr6741 ) &&@expr1073748566 typeEnd@var1119 .@expr6740 next (@expr6741 ) .@expr1073748569 str (@expr1073748570 ) !=@expr1073748571 ";" ) {
124: typeEnd@var1119 =@expr1073748572 typeEnd@var1119 .@expr6740 next (@expr6741 ) ; }
125: } }
126: }
127:
128: const std :: string & name ( ) const ;
129:
130: const std :: string & type ( ) const {
131: return classDef@var1102 ?@expr1073748575 classDef@var1102 .@expr1073748576 str (@expr1073748577 ) :@expr1073748578 emptyString@var1 ;
132: }
133:
134: bool isClassType ( ) const ;
135: bool isEnumType ( ) const ;
136: bool isStructType ( ) const ;
137: bool isUnionType ( ) const ;
138:
139: bool isTypeAlias ( ) const {
140: return classDef@var1102 &&@expr1073748579 classDef@var1102 .@expr1073748580 str (@expr1073748581 ) ==@expr1073748582 "using" ;
141: }
142:
143: const Token * initBaseInfo ( const Token * tok@var1124 , const Token * tok1@var1125 ) ;
144:
145: const Function * getFunction ( const std :: string & funcName@var1126 ) const ;
146:
|
151:
152: bool hasCircularDependencies ( std :: set < BaseInfo > * ancestors@var1127 = nullptr ) const ;
153:
|
158:
159: bool findDependency ( const Type * ancestor@var1128 ) const ;
160:
161: bool isDerivedFrom ( const std :: string & ancestor@var1129 ) const ;
162: } ;
163:
164: class Enumerator {
165: public:
166: explicit Enumerator ( const Scope * scope_@var1130 ) : scope@var1131 ( scope_@var1130 ) , name@var1132 ( nullptr ) , value@var1133 ( 0 ) , start@var1134 ( nullptr ) , end@var1135 ( nullptr ) , value_known@var1136 ( false ) { }
167: const Scope * scope@var1131 ;
168: const Token * name@var1132 ;
169: long long value@var1133 ;
170: const Token * start@var1134 ;
171: const Token * end@var1135 ;
172: bool value_known@var1136 ;
173: } ;
174:
175:
176: class Variable {
177:
178: enum Anonymous3 {
179: fIsMutable = ( 1 << 0 ) ,
180: fIsStatic = ( 1 << 1 ) ,
181: fIsConst = ( 1 << 2 ) ,
182: fIsExtern = ( 1 << 3 ) ,
183: fIsClass = ( 1 << 4 ) ,
184: fIsArray = ( 1 << 5 ) ,
185: fIsPointer = ( 1 << 6 ) ,
186: fIsReference = ( 1 << 7 ) ,
187: fIsRValueRef = ( 1 << 8 ) ,
188: fHasDefault = ( 1 << 9 ) ,
189: fIsStlType = ( 1 << 10 ) ,
190: fIsStlString = ( 1 << 11 ) ,
191: fIsFloatType = ( 1 << 12 ) ,
192: fIsVolatile = ( 1 << 13 ) ,
193: fIsSmartPointer = ( 1 << 14 ) ,
194: fIsMaybeUnused = ( 1 << 15 ) ,
195: fIsInit = ( 1 << 16 ) ,
196: } ;
197:
|
202:
203: bool getFlag ( unsigned int flag_@var1137 ) const {
204: return (@expr6759 (@expr6759 mFlags@var1173 &@expr1073748585 flag_@var1137 ) !=@expr1073748586 0 ) ;
205: }
206:
|
211:
212: void setFlag ( unsigned int flag_@var1138 , bool state_@var1139 ) {
213: mFlags@var1173 =@expr1073748587 state_@var1139 ?@expr1073748588 mFlags@var1173 |@expr1073748589 flag_@var1138 :@expr1073748590 mFlags@var1173 &@expr1073748591 ~@expr1073748592 flag_@var1138 ;
214: }
215:
|
221:
222: bool arrayDimensions ( const Settings * settings@var1140 , bool * isContainer@var1141 ) ;
223:
224: public:
225: Variable ( const Token * name_@var1142 , const Token * start_@var1143 , const Token * end_@var1144 ,
226: int index_@var1145 , AccessControl access_@var1146 , const Type * type_@var1147 ,
227: const Scope * scope_@var1148 , const Settings * settings@var1149 )
228: : mNameToken@var1168 ( name_@var1142 ) ,
229: mTypeStartToken@var1169 ( start_@var1143 ) ,
230: mTypeEndToken@var1170 ( end_@var1144 ) ,
231: mIndex@var1171 ( index_@var1145 ) ,
232: mAccess@var1172 ( access_@var1146 ) ,
233: mFlags@var1173 ( 0 ) ,
234: mType@var1174 ( type_@var1147 ) ,
235: mScope@var1175 ( scope_@var1148 ) ,
236: mValueType@var1176 ( nullptr ) {
237: evaluate (@expr1073748593 settings@var1149 ) ;
238: }
239:
240: Variable ( const Token * name_@var1150 , const std :: string & clangType@var1151 , const Token * typeStart@var1152 ,
241: const Token * typeEnd@var1153 , int index_@var1154 , AccessControl access_@var1155 ,
242: const Type * type_@var1156 , const Scope * scope_@var1157 ) ;
243:
244: Variable ( const Variable & var@var1158 , const Scope * scope@var1159 ) ;
245:
246: Variable ( const Variable & var@var1160 ) ;
247:
248: ~ Variable ( ) ;
249:
250: Variable & operator= ( const Variable & var@var1161 ) ;
251:
|
255:
256: const Token * nameToken ( ) const {
257: return mNameToken@var1168 ;
258: }
259:
|
267:
268: const Token * typeStartToken ( ) const {
269: return mTypeStartToken@var1169 ;
270: }
271:
|
279:
280: const Token * typeEndToken ( ) const {
281: return mTypeEndToken@var1170 ;
282: }
283:
|
290:
291: const Token * declEndToken ( ) const ;
292:
|
296:
297: const std :: string & name ( ) const {
298:
299: if (@expr1073748594 mNameToken@var1168 ) {
300: return mNameToken@var1168 .@expr1073748595 str (@expr1073748596 ) ; }
301:
302: return emptyString@var1 ;
303: }
304:
|
308:
309: int declarationId ( ) const {
310:
311: if (@expr1073748597 mNameToken@var1168 ) {
312: return mNameToken@var1168 .@expr1073748598 varId (@expr1073748599 ) ; }
313:
314: return 0 ;
315: }
316:
|
320:
321: int index ( ) const {
322: return mIndex@var1171 ;
323: }
324:
|
328:
329: bool isPublic ( ) const {
330: return mAccess@var1172 ==@expr1073748600 AccessControl ::@expr1073748601 Public ;
331: }
332:
|
336:
337: bool isProtected ( ) const {
338: return mAccess@var1172 ==@expr1073748602 AccessControl ::@expr1073748603 Protected ;
339: }
340:
|
344:
345: bool isPrivate ( ) const {
346: return mAccess@var1172 ==@expr1073748604 AccessControl ::@expr1073748605 Private ;
347: }
348:
|
352:
353: bool isGlobal ( ) const {
354: return mAccess@var1172 ==@expr1073748606 AccessControl ::@expr1073748607 Global ;
355: }
356:
|
360:
361: bool isNamespace ( ) const {
362: return mAccess@var1172 ==@expr1073748608 AccessControl ::@expr1073748609 Namespace ;
363: }
364:
|
368:
369: bool isArgument ( ) const {
370: return mAccess@var1172 ==@expr1073748610 AccessControl ::@expr1073748611 Argument ;
371: }
372:
|
376:
377: bool isLocal ( ) const {
378: return (@expr1073748613 mAccess@var1172 ==@expr1073748614 AccessControl ::@expr1073748615 Local@expr1073748612 ) &&@expr1073748616 !@expr1073748617 isExtern (@expr1073748618 ) ;
379: }
380:
|
384:
385: bool isMutable ( ) const {
386: return getFlag (@expr1073748619 fIsMutable ) ;
387: }
388:
|
392:
393: bool isVolatile ( ) const {
394: return getFlag (@expr1073748620 fIsVolatile ) ;
395: }
396:
|
400:
401: bool isStatic ( ) const {
402: return getFlag (@expr1073748621 fIsStatic ) ;
403: }
404:
|
408:
409: bool isExtern ( ) const {
410: return getFlag (@expr1073748622 fIsExtern ) ;
411: }
412:
|
416:
417: bool isConst ( ) const {
418: return getFlag (@expr1073748623 fIsConst ) ;
419: }
420:
|
424:
425: bool isThrow ( ) const {
426: return mAccess@var1172 ==@expr1073748624 AccessControl ::@expr1073748625 Throw ;
427: }
428:
|
432:
433: bool isClass ( ) const {
434: return getFlag (@expr1073748626 fIsClass ) ;
435: }
436:
|
440:
441: bool isArray ( ) const {
442: return getFlag (@expr1073748627 fIsArray ) &&@expr1073748628 !@expr1073748629 getFlag (@expr1073748630 fIsPointer ) ;
443: }
444:
|
448:
449: bool isPointer ( ) const {
450: return getFlag (@expr1073748631 fIsPointer ) ;
451: }
452:
|
456:
457: bool isPointerToArray ( ) const {
458: return isPointer (@expr1073748632 ) &&@expr1073748633 getFlag (@expr1073748634 fIsArray ) ;
459: }
460:
|
464:
465: bool isPointerArray ( ) const ;
466:
|
470:
471: bool isArrayOrPointer ( ) const {
472: return getFlag (@expr1073748635 fIsArray ) ||@expr1073748636 getFlag (@expr1073748637 fIsPointer ) ;
473: }
474:
|
478:
479: bool isReference ( ) const {
480: return getFlag (@expr1073748638 fIsReference ) ;
481: }
482:
|
486:
487: bool isRValueReference ( ) const {
488: return getFlag (@expr1073748639 fIsRValueRef ) ;
489: }
490:
|
494:
495: bool isUnsigned ( ) const ;
496:
|
500:
501: bool hasDefault ( ) const {
502: return getFlag (@expr1073748640 fHasDefault ) ;
503: }
504:
|
508:
509: bool isInit ( ) const {
510: return getFlag (@expr1073748641 fIsInit ) ;
511: }
512:
|
516:
517: const Type * type ( ) const {
518: return mType@var1174 ;
519: }
520:
|
524:
525: const Scope * typeScope ( ) const {
526: return mType@var1174 ?@expr1073748642 mType@var1174 .@expr1073748643 classScope@var1179 :@expr1073748644 nullptr ;
527: }
528:
|
532:
533: const Scope * scope ( ) const {
534: return mScope@var1175 ;
535: }
536:
|
540:
541: const std :: vector < Dimension > & dimensions ( ) const {
542: return mDimensions@var1177 ;
543: }
544:
|
548:
549: long long dimension ( int index_@var1162 ) const {
550: return mDimensions@var1177 [@expr1073748645 index_@var1162 ] .@expr1073748646 num@var5313 ;
551: }
552:
|
556:
557: bool dimensionKnown ( int index_@var1163 ) const {
558: return mDimensions@var1177 [@expr1073748647 index_@var1163 ] .@expr1073748648 known@var5314 ;
559: }
560:
|
568:
569: bool isStlType ( ) const {
570: return getFlag (@expr1073748649 fIsStlType ) ;
571: }
572:
|
580:
581: bool isStlStringType ( ) const {
582: return getFlag (@expr1073748650 fIsStlString ) ;
583: }
584:
585: bool isSmartPointer ( ) const {
586: return getFlag (@expr1073748651 fIsSmartPointer ) ;
587: }
588:
589: const Type * smartPointerType ( ) const ;
590:
|
600:
601: bool isStlType ( const std :: string & stlType@var1164 ) const {
602: return isStlType (@expr1073748652 ) &&@expr1073748653 stlType@var1164 ==@expr1073748654 mTypeStartToken@var1169 .@expr1073748655 strAt (@expr1073748656 2 ) ;
603: }
604:
|
614:
615: bool isStlType ( const std :: set < std :: string > & stlTypes@var1165 ) const {
616: return isStlType (@expr1073748657 ) &&@expr1073748658 stlTypes@var1165 .@expr1073748659 find (@expr1073748660 mTypeStartToken@var1169 .@expr1073748661 strAt (@expr1073748662 2 ) ) !=@expr1073748663 stlTypes@var1165 .@expr1073748664 end (@expr1073748665 ) ;
617: }
618:
|
622:
623: bool isFloatingType ( ) const {
624: return getFlag (@expr1073748666 fIsFloatType ) ;
625: }
626:
|
630:
631: bool isEnumType ( ) const {
632: return type (@expr6843 ) &&@expr1073748668 type (@expr6843 ) .@expr1073748670 isEnumType (@expr1073748671 ) ;
633: }
634:
635: bool isMaybeUnused ( ) const {
636: return getFlag (@expr1073748672 fIsMaybeUnused ) ;
637: }
638:
639: const ValueType * valueType ( ) const {
640: return mValueType@var1176 ;
641: }
642:
643: void setValueType ( const ValueType & valueType@var1166 ) ;
644:
645: AccessControl accessControl ( ) const {
646: return mAccess@var1172 ;
647: }
648:
649: std :: string getTypeName ( ) const ;
650:
651: private:
652:
653: friend class SymbolDatabase ;
654:
|
658:
659: void type ( const Type * t@var1167 ) {
660: mType@var1174 =@expr1073748673 t@var1167 ;
661: }
662:
663:
664: const Token * mNameToken@var1168 ;
665:
666:
667: const Token * mTypeStartToken@var1169 ;
668:
669:
670: const Token * mTypeEndToken@var1170 ;
671:
672:
673: int mIndex@var1171 ;
674:
675:
676: AccessControl mAccess@var1172 ;
677:
678:
679: unsigned int mFlags@var1173 ;
680:
681:
682: const Type * mType@var1174 ;
683:
684:
685: const Scope * mScope@var1175 ;
686:
687: ValueType * mValueType@var1176 ;
688:
689:
690: std :: vector < Dimension > mDimensions@var1177 ;
691:
692:
693: void evaluate ( const Settings * settings@var1178 ) ;
694: } ;
695:
696: class Function {
697:
698: friend class SymbolDatabase ;
699:
700:
701: enum Anonymous4 {
702: fHasBody = ( 1 << 0 ) ,
703: fIsInline = ( 1 << 1 ) ,
704: fIsConst = ( 1 << 2 ) ,
705: fHasVirtualSpecifier = ( 1 << 3 ) ,
706: fIsPure = ( 1 << 4 ) ,
707: fIsStatic = ( 1 << 5 ) ,
708: fIsStaticLocal = ( 1 << 6 ) ,
709: fIsExtern = ( 1 << 7 ) ,
710: fIsFriend = ( 1 << 8 ) ,
711: fIsExplicit = ( 1 << 9 ) ,
712: fIsDefault = ( 1 << 10 ) ,
713: fIsDelete = ( 1 << 11 ) ,
714: fHasOverrideSpecifier = ( 1 << 12 ) ,
715: fHasFinalSpecifier = ( 1 << 13 ) ,
716: fIsNoExcept = ( 1 << 14 ) ,
717: fIsThrow = ( 1 << 15 ) ,
718: fIsOperator = ( 1 << 16 ) ,
719: fHasLvalRefQual = ( 1 << 17 ) ,
720: fHasRvalRefQual = ( 1 << 18 ) ,
721: fIsVariadic = ( 1 << 19 ) ,
722: fIsVolatile = ( 1 << 20 ) ,
723: fHasTrailingReturnType = ( 1 << 21 ) ,
724: fIsEscapeFunction = ( 1 << 22 ) ,
725: fIsInlineKeyword = ( 1 << 23 ) ,
726: fIsConstexpr = ( 1 << 24 ) ,
727: } ;
728:
|
733:
734: bool getFlag ( unsigned int flag@var1180 ) const {
735: return (@expr6850 (@expr6850 mFlags@var1229 &@expr1073748676 flag@var1180 ) !=@expr1073748677 0 ) ;
736: }
737:
|
742:
743: void setFlag ( unsigned int flag@var1181 , bool state@var1182 ) {
744: mFlags@var1229 =@expr1073748678 state@var1182 ?@expr1073748679 mFlags@var1229 |@expr1073748680 flag@var1181 :@expr1073748681 mFlags@var1229 &@expr1073748682 ~@expr1073748683 flag@var1181 ;
745: }
746:
747: public:
748: enum Type { eConstructor , eCopyConstructor , eMoveConstructor , eOperatorEqual , eDestructor , eFunction , eLambda } ;
749:
750: Function ( const Tokenizer * mTokenizer@var1183 , const Token * tok@var1184 , const Scope * scope@var1185 , const Token * tokDef@var1186 , const Token * tokArgDef@var1187 ) ;
751: Function ( const Token * tokenDef@var1188 , const std :: string & clangType@var1189 ) ;
752:
753: const std :: string & name ( ) const {
754: return tokenDef@var1199 .@expr1073748684 str (@expr1073748685 ) ;
755: }
756:
757: std :: string fullName ( ) const ;
758:
759: int argCount ( ) const {
760: return argumentList@var1207 .@expr1073748686 size (@expr1073748687 ) ;
761: }
762: int minArgCount ( ) const {
763: return argumentList@var1207 .@expr1073748688 size (@expr1073748689 ) -@expr1073748690 initArgCount@var1208 ;
764: }
765: const Variable * getArgumentVar ( int num@var1190 ) const ;
766: int initializedArgCount ( ) const {
767: return initArgCount@var1208 ;
768: }
769: void addArguments ( const SymbolDatabase * symbolDatabase@var1191 , const Scope * scope@var1192 ) ;
770:
771:
772: bool isImplicitlyVirtual ( bool defaultVal@var1193 = false ) const ;
773:
774: std :: vector < const Function * > getOverloadedFunctions ( ) const ;
775:
776:
777: const Function * getOverriddenFunction ( bool * foundAllBaseClasses@var1194 = nullptr ) const ;
778:
779: bool isLambda ( ) const {
780: return type@var1209 ==@expr1073748691 eLambda ;
781: }
782:
783: bool isConstructor ( ) const {
784: return type@var1209 ==@expr1073748692 eConstructor ||@expr1073748693
785: type@var1209 ==@expr1073748694 eCopyConstructor ||@expr1073748695
786: type@var1209 ==@expr1073748696 eMoveConstructor ;
787: }
788:
789: bool isDestructor ( ) const {
790: return type@var1209 ==@expr1073748697 eDestructor ;
791: }
792: bool isAttributeConstructor ( ) const {
793: return tokenDef@var1199 .@expr1073748698 isAttributeConstructor (@expr1073748699 ) ;
794: }
795: bool isAttributeDestructor ( ) const {
796: return tokenDef@var1199 .@expr1073748700 isAttributeDestructor (@expr1073748701 ) ;
797: }
798: bool isAttributePure ( ) const {
799: return tokenDef@var1199 .@expr1073748702 isAttributePure (@expr1073748703 ) ;
800: }
801: bool isAttributeConst ( ) const {
802: return tokenDef@var1199 .@expr1073748704 isAttributeConst (@expr1073748705 ) ;
803: }
804: bool isAttributeNoreturn ( ) const {
805: return tokenDef@var1199 .@expr1073748706 isAttributeNoreturn (@expr1073748707 ) ;
806: }
807: bool isAttributeNothrow ( ) const {
808: return tokenDef@var1199 .@expr1073748708 isAttributeNothrow (@expr1073748709 ) ;
809: }
810: bool isAttributeNodiscard ( ) const {
811: return tokenDef@var1199 .@expr1073748710 isAttributeNodiscard (@expr1073748711 ) ;
812: }
813:
814: bool hasBody ( ) const {
815: return getFlag (@expr1073748712 fHasBody ) ;
816: }
817: bool isInline ( ) const {
818: return getFlag (@expr1073748713 fIsInline ) ;
819: }
820: bool isConst ( ) const {
821: return getFlag (@expr1073748714 fIsConst ) ;
822: }
823: bool hasVirtualSpecifier ( ) const {
824: return getFlag (@expr1073748715 fHasVirtualSpecifier ) ;
825: }
826: bool isPure ( ) const {
827: return getFlag (@expr1073748716 fIsPure ) ;
828: }
829: bool isStatic ( ) const {
830: return getFlag (@expr1073748717 fIsStatic ) ;
831: }
832: bool isStaticLocal ( ) const {
833: return getFlag (@expr1073748718 fIsStaticLocal ) ;
834: }
835: bool isExtern ( ) const {
836: return getFlag (@expr1073748719 fIsExtern ) ;
837: }
838: bool isFriend ( ) const {
839: return getFlag (@expr1073748720 fIsFriend ) ;
840: }
841: bool isExplicit ( ) const {
842: return getFlag (@expr1073748721 fIsExplicit ) ;
843: }
844: bool isDefault ( ) const {
845: return getFlag (@expr1073748722 fIsDefault ) ;
846: }
847: bool isDelete ( ) const {
848: return getFlag (@expr1073748723 fIsDelete ) ;
849: }
850: bool isNoExcept ( ) const {
851: return getFlag (@expr1073748724 fIsNoExcept ) ;
852: }
853: bool isThrow ( ) const {
854: return getFlag (@expr1073748725 fIsThrow ) ;
855: }
856: bool hasOverrideSpecifier ( ) const {
857: return getFlag (@expr1073748726 fHasOverrideSpecifier ) ;
858: }
859: bool hasFinalSpecifier ( ) const {
860: return getFlag (@expr1073748727 fHasFinalSpecifier ) ;
861: }
862: bool isOperator ( ) const {
863: return getFlag (@expr1073748728 fIsOperator ) ;
864: }
865: bool hasLvalRefQualifier ( ) const {
866: return getFlag (@expr1073748729 fHasLvalRefQual ) ;
867: }
868: bool hasRvalRefQualifier ( ) const {
869: return getFlag (@expr1073748730 fHasRvalRefQual ) ;
870: }
871: bool isVariadic ( ) const {
872: return getFlag (@expr1073748731 fIsVariadic ) ;
873: }
874: bool isVolatile ( ) const {
875: return getFlag (@expr1073748732 fIsVolatile ) ;
876: }
877: bool hasTrailingReturnType ( ) const {
878: return getFlag (@expr1073748733 fHasTrailingReturnType ) ;
879: }
880: void hasBody ( bool state@var1195 ) {
881: setFlag (@expr1073748734 fHasBody , state@var1195 ) ;
882: }
883: bool isInlineKeyword ( ) const {
884: return getFlag (@expr1073748735 fIsInlineKeyword ) ;
885: }
886:
887: bool isEscapeFunction ( ) const {
888: return getFlag (@expr1073748736 fIsEscapeFunction ) ;
889: }
890: void isEscapeFunction ( bool state@var1196 ) {
891: setFlag (@expr1073748737 fIsEscapeFunction , state@var1196 ) ;
892: }
893:
894: bool isConstexpr ( ) const {
895: return getFlag (@expr1073748738 fIsConstexpr ) ;
896: }
897: void isConstexpr ( bool state@var1197 ) {
898: setFlag (@expr1073748739 fIsConstexpr , state@var1197 ) ;
899: }
900: bool isSafe ( const Settings * settings@var1198 ) const ;
901:
902: const Token * tokenDef@var1199 ;
903: const Token * argDef@var1200 ;
904: const Token * token@var1201 ;
905: const Token * arg@var1202 ;
906: const Token * retDef@var1203 ;
907: const :: Type * retType@var1204 ;
908: const Scope * functionScope@var1205 ;
909: const Scope * nestedIn@var1206 ;
910: std :: list < Variable > argumentList@var1207 ;
911: int initArgCount@var1208 ;
912: Type type@var1209 ;
913: AccessControl access@var1210 ;
914: const Token * noexceptArg@var1211 ;
915: const Token * throwArg@var1212 ;
916: const Token * templateDef@var1213 ;
917: const Token * functionPointerUsage@var1214 ;
918:
919: bool argsMatch ( const Scope * scope@var1215 , const Token * first@var1216 , const Token * second@var1217 , const std :: string & path@var1218 , int path_length@var1219 ) const ;
920:
921: static bool returnsConst ( const Function * function@var1220 , bool unknown@var1221 = false ) ;
922:
923: static bool returnsReference ( const Function * function@var1222 , bool unknown@var1223 = false ) ;
924:
925: static bool returnsVoid ( const Function * function@var1224 , bool unknown@var1225 = false ) ;
926:
927: static std :: vector < const Token * > findReturns ( const Function * f@var1226 ) ;
928:
929: const Token * returnDefEnd ( ) const {
930: if (@expr1073748740 this@expr1073748741 .@expr1073748742 hasTrailingReturnType (@expr1073748743 ) ) {
931: return Token ::@expr1073748744 findmatch (@expr1073748745 retDef@var1203 , "{|;" ) ;
932: } else {
933: return tokenDef@var1199 ;
934: }
935: }
936:
|
940:
941: const Token * constructorMemberInitialization ( ) const ;
942:
943: private:
944:
945: const Function * getOverriddenFunctionRecursive ( const :: Type * baseType@var1227 , bool * foundAllBaseClasses@var1228 ) const ;
946:
947: unsigned int mFlags@var1229 ;
948:
949: void isInline ( bool state@var1230 ) {
950: setFlag (@expr1073748746 fIsInline , state@var1230 ) ;
951: }
952: void isConst ( bool state@var1231 ) {
953: setFlag (@expr1073748747 fIsConst , state@var1231 ) ;
954: }
955: void hasVirtualSpecifier ( bool state@var1232 ) {
956: setFlag (@expr1073748748 fHasVirtualSpecifier , state@var1232 ) ;
957: }
958: void isPure ( bool state@var1233 ) {
959: setFlag (@expr1073748749 fIsPure , state@var1233 ) ;
960: }
961: void isStatic ( bool state@var1234 ) {
962: setFlag (@expr1073748750 fIsStatic , state@var1234 ) ;
963: }
964: void isStaticLocal ( bool state@var1235 ) {
965: setFlag (@expr1073748751 fIsStaticLocal , state@var1235 ) ;
966: }
967: void isExtern ( bool state@var1236 ) {
968: setFlag (@expr1073748752 fIsExtern , state@var1236 ) ;
969: }
970: void isFriend ( bool state@var1237 ) {
971: setFlag (@expr1073748753 fIsFriend , state@var1237 ) ;
972: }
973: void isExplicit ( bool state@var1238 ) {
974: setFlag (@expr1073748754 fIsExplicit , state@var1238 ) ;
975: }
976: void isDefault ( bool state@var1239 ) {
977: setFlag (@expr1073748755 fIsDefault , state@var1239 ) ;
978: }
979: void isDelete ( bool state@var1240 ) {
980: setFlag (@expr1073748756 fIsDelete , state@var1240 ) ;
981: }
982: void isNoExcept ( bool state@var1241 ) {
983: setFlag (@expr1073748757 fIsNoExcept , state@var1241 ) ;
984: }
985: void isThrow ( bool state@var1242 ) {
986: setFlag (@expr1073748758 fIsThrow , state@var1242 ) ;
987: }
988: void isOperator ( bool state@var1243 ) {
989: setFlag (@expr1073748759 fIsOperator , state@var1243 ) ;
990: }
991: void hasLvalRefQualifier ( bool state@var1244 ) {
992: setFlag (@expr1073748760 fHasLvalRefQual , state@var1244 ) ;
993: }
994: void hasRvalRefQualifier ( bool state@var1245 ) {
995: setFlag (@expr1073748761 fHasRvalRefQual , state@var1245 ) ;
996: }
997: void isVariadic ( bool state@var1246 ) {
998: setFlag (@expr1073748762 fIsVariadic , state@var1246 ) ;
999: }
1000: void isVolatile ( bool state@var1247 ) {
1001: setFlag (@expr1073748763 fIsVolatile , state@var1247 ) ;
1002: }
1003: void hasTrailingReturnType ( bool state@var1248 ) {
1004: return setFlag (@expr1073748764 fHasTrailingReturnType , state@var1248 ) ;
1005: }
1006: void isInlineKeyword ( bool state@var1249 ) {
1007: setFlag (@expr1073748765 fIsInlineKeyword , state@var1249 ) ;
1008: }
1009: const Token * setFlags ( const Token * tok1@var1250 , const Scope * scope@var1251 ) ;
1010: } ;
1011:
1012: class Scope {
1013:
1014: friend class TestSymbolDatabase ;
1015:
1016: public:
1017: struct UsingInfo {
1018: const Token * start@var1252 ;
1019: const Scope * scope@var1253 ;
1020: } ;
1021:
1022: enum ScopeType { eGlobal , eClass , eStruct , eUnion , eNamespace , eFunction , eIf , eElse , eFor , eWhile , eDo , eSwitch , eUnconditional , eTry , eCatch , eLambda , eEnum } ;
1023:
1024: Scope ( const SymbolDatabase * check_@var1254 , const Token * classDef_@var1255 , const Scope * nestedIn_@var1256 ) ;
1025: Scope ( const SymbolDatabase * check_@var1257 , const Token * classDef_@var1258 , const Scope * nestedIn_@var1259 , ScopeType type_@var1260 , const Token * start_@var1261 ) ;
1026:
1027: const SymbolDatabase * check@var1262 ;
1028: std :: string className@var1263 ;
1029: const Token * classDef@var1264 ;
1030: const Token * bodyStart@var1265 ;
1031: const Token * bodyEnd@var1266 ;
1032: std :: list < Function > functionList@var1267 ;
1033: std :: multimap < std :: string , const Function * > functionMap@var1268 ;
1034: std :: list < Variable > varlist@var1269 ;
1035: const Scope * nestedIn@var1270 ;
1036: std :: list < Scope * > nestedList@var1271 ;
1037: int numConstructors@var1272 ;
1038: int numCopyOrMoveConstructors@var1273 ;
1039: std :: list < UsingInfo > usingList@var1274 ;
1040: ScopeType type@var1275 ;
1041: Type * definedType@var1276 ;
1042: std :: map < std :: string , Type * > definedTypesMap@var1277 ;
1043: std :: vector < const Token * > bodyStartList@var1278 ;
1044:
1045:
1046: const Scope * functionOf@var1279 ;
1047: Function * function@var1280 ;
1048:
1049:
1050: const Token * enumType@var1281 ;
1051: bool enumClass@var1282 ;
1052:
1053: std :: vector < Enumerator > enumeratorList@var1283 ;
1054:
1055: void setBodyStartEnd ( const Token * start@var1284 ) {
1056: bodyStart@var1265 =@expr1073748766 start@var1284 ;
1057: bodyEnd@var1266 =@expr1073748767 start@var1284 ?@expr1073748768 start@var1284 .@expr1073748769 link (@expr1073748770 ) :@expr1073748771 nullptr ;
1058: if (@expr1073748772 start@var1284 ) {
1059: bodyStartList@var1278 .@expr1073748773 push_back (@expr1073748774 start@var1284 ) ; }
1060: }
1061:
1062: bool isAnonymous ( ) const {
1063:
1064: return className@var1263 .@expr1073748775 size (@expr1073748776 ) >@expr1073748777 9 &&@expr1073748778 className@var1263 .@expr1073748779 compare (@expr1073748780 0 , 9 , "Anonymous" ) ==@expr1073748781 0 &&@expr1073748782 std ::@expr1073748783 isdigit (@expr1073748784 className@var1263 [@expr1073748785 9 ] ) ;
1065: }
1066:
1067: const Enumerator * findEnumerator ( const std :: string & name@var1285 ) const {
1068: for (@expr1073748786 const Enumerator &@expr1073748787 i@var1286 :@expr1073748788 enumeratorList@var1283 ) {
1069: if (@expr1073748789 i@var1286 .@expr1073748790 name@var1287 .@expr1073748791 str (@expr1073748792 ) ==@expr1073748793 name@var1285 ) {
1070: return &@expr1073748794 i@var1286 ; }
1071: }
1072: return nullptr ;
1073: }
1074:
1075: bool isNestedIn ( const Scope * outer@var1288 ) const {
1076: if (@expr1073748795 !@expr1073748796 outer@var1288 ) {
1077: return false ; }
1078: if (@expr1073748797 outer@var1288 ==@expr1073748798 this@expr1073748799 ) {
1079: return true ; }
1080: const Scope * parent@var1289 ; parent@var1289 =@expr1073748800 nestedIn@var1270 ;
1081: while (@expr1073748801 outer@var1288 !=@expr1073748802 parent@var1289 &&@expr1073748803 parent@var1289 ) {
1082: parent@var1289 =@expr1073748804 parent@var1289 .@expr1073748805 nestedIn@var1290 ; }
1083: if (@expr1073748806 parent@var1289 &&@expr1073748807 parent@var1289 ==@expr1073748808 outer@var1288 ) {
1084: return true ; }
1085: return false ;
1086: }
1087:
1088: static Function * nestedInFunction ( const Scope * scope@var1291 ) {
1089: while (@expr1073748809 scope@var1291 ) {
1090: if (@expr1073748810 scope@var1291 .@expr1073748811 type@var1292 ==@expr1073748812 Scope ::@expr1073748813 eFunction ) {
1091: break ; }
1092: scope@var1291 =@expr1073748814 scope@var1291 .@expr1073748815 nestedIn@var1293 ;
1093: }
1094: if (@expr1073748816 !@expr1073748817 scope@var1291 ) {
1095: return nullptr ; }
1096: return scope@var1291 .@expr1073748818 function@var1294 ;
1097: }
1098:
1099: bool isClassOrStruct ( ) const {
1100: return (@expr1073748819 type@var1275 ==@expr1073748820 eClass ||@expr1073748821 type@var1275 ==@expr1073748822 eStruct ) ;
1101: }
1102:
1103: bool isClassOrStructOrUnion ( ) const {
1104: return (@expr1073748823 type@var1275 ==@expr1073748824 eClass ||@expr1073748825 type@var1275 ==@expr1073748826 eStruct ||@expr1073748827 type@var1275 ==@expr1073748828 eUnion ) ;
1105: }
1106:
1107: bool isExecutable ( ) const {
1108: return type@var1275 !=@expr1073748829 eClass &&@expr1073748830 type@var1275 !=@expr1073748831 eStruct &&@expr1073748832 type@var1275 !=@expr1073748833 eUnion &&@expr1073748834 type@var1275 !=@expr1073748835 eGlobal &&@expr1073748836 type@var1275 !=@expr1073748837 eNamespace &&@expr1073748838 type@var1275 !=@expr1073748839 eEnum ;
1109: }
1110:
1111: bool isLoopScope ( ) const {
1112: return type@var1275 ==@expr1073748840 Scope ::@expr7017 ScopeType ::@expr1073748842 eFor ||@expr1073748843 type@var1275 ==@expr1073748844 Scope ::@expr7017 ScopeType ::@expr1073748846 eWhile ||@expr1073748847 type@var1275 ==@expr1073748848 Scope ::@expr7017 ScopeType ::@expr1073748850 eDo ;
1113: }
1114:
1115: bool isLocal ( ) const {
1116: return (@expr1073748851 type@var1275 ==@expr1073748852 eIf ||@expr1073748853 type@var1275 ==@expr1073748854 eElse ||@expr1073748855
1117: type@var1275 ==@expr1073748856 eFor ||@expr1073748857 type@var1275 ==@expr1073748858 eWhile ||@expr1073748859 type@var1275 ==@expr1073748860 eDo ||@expr1073748861
1118: type@var1275 ==@expr1073748862 eSwitch ||@expr1073748863 type@var1275 ==@expr1073748864 eUnconditional ||@expr1073748865
1119: type@var1275 ==@expr1073748866 eTry ||@expr1073748867 type@var1275 ==@expr1073748868 eCatch ) ;
1120: }
1121:
1122:
1123: bool hasInlineOrLambdaFunction ( ) const ;
1124:
|
1130:
1131: const Function * findFunction ( const Token * tok@var1295 , bool requireConst@var1296 = false ) const ;
1132:
1133: const Scope * findRecordInNestedList ( const std :: string & name@var1297 , bool isC@var1298 = false ) const ;
1134: Scope * findRecordInNestedList ( const std :: string & name@var1299 ) {
1135: return const_cast < Scope *@expr7045 > (@expr1073748870 const_cast < const Scope *@expr7045 > (@expr1073748872 this@expr1073748873 ) .@expr1073748874 findRecordInNestedList (@expr1073748875 name@var1299 ) ) ;
1136: }
1137:
1138: const Type * findType ( const std :: string & name@var1300 ) const ;
1139: Type * findType ( const std :: string & name@var1301 ) {
1140: return const_cast < Type *@expr7052 > (@expr1073748877 const_cast < const Scope *@expr7052 > (@expr1073748879 this@expr1073748880 ) .@expr1073748881 findType (@expr1073748882 name@var1301 ) ) ;
1141: }
1142:
|
1146:
1147: Scope * findInNestedListRecursive ( const std :: string & name@var1302 ) ;
1148:
1149: void addVariable ( const Token * token_@var1303 , const Token * start_@var1304 ,
1150: const Token * end_@var1305 , AccessControl access_@var1306 , const Type * type_@var1307 ,
1151: const Scope * scope_@var1308 , const Settings * settings@var1309 ) ;
1152:
1153:
1154: void getVariableList ( const Settings * settings@var1310 ) ;
1155:
1156: const Function * getDestructor ( ) const ;
1157:
1158: void addFunction ( const Function & func@var1311 ) {
1159: functionList@var1267 .@expr1073748883 push_back (@expr1073748884 func@var1311 ) ;
1160:
1161: const Function * back@var1312 ; back@var1312 =@expr1073748885 &@expr1073748886 functionList@var1267 .@expr1073748887 back (@expr1073748888 ) ;
1162:
1163: functionMap@var1268 .@expr1073748889 insert (@expr1073748890 make_pair (@expr1073748891 back@var1312 .@expr1073748892 tokenDef@var1313 .@expr1073748893 str (@expr1073748894 ) , back@var1312 ) ) ;
1164: }
1165:
1166: bool hasDefaultConstructor ( ) const ;
1167:
1168: AccessControl defaultAccess ( ) const ;
1169:
|
1176:
1177: const Token * checkVariable ( const Token * tok@var1314 , AccessControl varaccess@var1315 , const Settings * settings@var1316 ) ;
1178:
|
1183:
1184: const Variable * getVariable ( const std :: string & varname@var1317 ) const ;
1185:
1186: const Token * addEnum ( const Token * tok@var1318 , bool isCpp@var1319 ) ;
1187:
1188: const Scope * findRecordInBase ( const std :: string & name@var1320 ) const ;
1189:
1190: std :: vector < const Scope * > findAssociatedScopes ( ) const ;
1191:
1192: private:
1193:
|
1199:
1200: bool isVariableDeclaration ( const Token * const tok@var1321 , const Token * & vartok@var1322 , const Token * & typetok@var1323 ) const ;
1201:
1202: void findFunctionInBase ( const std :: string & name@var1324 , int args@var1325 , std :: vector < const Function * > & matches@var1326 ) const ;
1203:
1204:
1205: void getVariableList ( const Settings * settings@var1327 , const Token * start@var1328 , const Token * end@var1329 ) ;
1206: } ;
1207:
1208: enum class Reference {
1209: None ,
1210: LValue ,
1211: RValue
1212: } ;
1213:
1214:
1215: class ValueType {
1216:
1217: enum Sign { UNKNOWN_SIGN , SIGNED , UNSIGNED } ; public: enum Sign sign@var1330 ;
1218: enum Type {
1219: UNKNOWN_TYPE ,
1220: POD ,
1221: NONSTD ,
1222: RECORD ,
1223: SMART_POINTER ,
1224: CONTAINER ,
1225: ITERATOR ,
1226: VOID ,
1227: BOOL ,
1228: CHAR ,
1229: SHORT ,
1230: WCHAR_T ,
1231: INT ,
1232: LONG ,
1233: LONGLONG ,
1234: UNKNOWN_INT ,
1235: FLOAT ,
1236: DOUBLE ,
1237: LONGDOUBLE
1238: } ; enum Type type@var1331 ;
1239: int bits@var1332 ;
1240: int pointer@var1333 ;
1241: int constness@var1334 ;
1242: Reference reference@var1335 ; reference@var1335 = Reference :: None ;
1243:
1244: const Scope * typeScope@var1336 ;
1245: const :: Type * smartPointerType@var1337 ;
1246: const Token * smartPointerTypeToken@var1338 ;
1247: const Library :: SmartPointer * smartPointer@var1339 ;
1248: const Library :: Container * container@var1340 ;
1249:
1250: const Token * containerTypeToken@var1341 ;
1251:
1252: std :: string originalTypeName@var1342 ;
1253:
1254:
1255: ValueType ( )
1256: : sign@var1330 ( UNKNOWN_SIGN ) ,
1257: type@var1331 ( UNKNOWN_TYPE ) ,
1258: bits@var1332 ( 0 ) ,
1259: pointer@var1333 ( 0U ) ,
1260: constness@var1334 ( 0U ) ,
1261: typeScope@var1336 ( nullptr ) ,
1262: smartPointerType@var1337 ( nullptr ) ,
1263: smartPointerTypeToken@var1338 ( nullptr ) ,
1264: smartPointer@var1339 ( nullptr ) ,
1265: container@var1340 ( nullptr ) ,
1266: containerTypeToken@var1341 ( nullptr )
1267: { }
1268: ValueType ( enum Sign s@var1343 , enum Type t@var1344 , int p@var1345 )
1269: : sign@var1330 ( s@var1343 ) ,
1270: type@var1331 ( t@var1344 ) ,
1271: bits@var1332 ( 0 ) ,
1272: pointer@var1333 ( p@var1345 ) ,
1273: constness@var1334 ( 0U ) ,
1274: typeScope@var1336 ( nullptr ) ,
1275: smartPointerType@var1337 ( nullptr ) ,
1276: smartPointerTypeToken@var1338 ( nullptr ) ,
1277: smartPointer@var1339 ( nullptr ) ,
1278: container@var1340 ( nullptr ) ,
1279: containerTypeToken@var1341 ( nullptr )
1280: { }
1281: ValueType ( enum Sign s@var1346 , enum Type t@var1347 , int p@var1348 , int c@var1349 )
1282: : sign@var1330 ( s@var1346 ) ,
1283: type@var1331 ( t@var1347 ) ,
1284: bits@var1332 ( 0 ) ,
1285: pointer@var1333 ( p@var1348 ) ,
1286: constness@var1334 ( c@var1349 ) ,
1287: typeScope@var1336 ( nullptr ) ,
1288: smartPointerType@var1337 ( nullptr ) ,
1289: smartPointerTypeToken@var1338 ( nullptr ) ,
1290: smartPointer@var1339 ( nullptr ) ,
1291: container@var1340 ( nullptr ) ,
1292: containerTypeToken@var1341 ( nullptr )
1293: { }
1294: ValueType ( enum Sign s@var1350 , enum Type t@var1351 , int p@var1352 , int c@var1353 , const std :: string & otn@var1354 )
1295: : sign@var1330 ( s@var1350 ) ,
1296: type@var1331 ( t@var1351 ) ,
1297: bits@var1332 ( 0 ) ,
1298: pointer@var1333 ( p@var1352 ) ,
1299: constness@var1334 ( c@var1353 ) ,
1300: typeScope@var1336 ( nullptr ) ,
1301: smartPointerType@var1337 ( nullptr ) ,
1302: smartPointerTypeToken@var1338 ( nullptr ) ,
1303: smartPointer@var1339 ( nullptr ) ,
1304: container@var1340 ( nullptr ) ,
1305: containerTypeToken@var1341 ( nullptr ) ,
1306: originalTypeName@var1342 ( otn@var1354 )
1307: { }
1308:
1309: static ValueType parseDecl ( const Token * type@var1355 , const Settings * settings@var1356 ) ;
1310:
1311: static Type typeFromString ( const std :: string & typestr@var1357 , bool longType@var1358 ) ;
1312:
1313: enum class MatchResult { UNKNOWN , SAME , FALLBACK1 , FALLBACK2 , NOMATCH } ;
1314: static MatchResult matchParameter ( const ValueType * call@var1359 , const ValueType * func@var1360 ) ;
1315: static MatchResult matchParameter ( const ValueType * call@var1361 , const Variable * callVar@var1362 , const Variable * funcVar@var1363 ) ;
1316:
1317: bool isPrimitive ( ) const {
1318: return (@expr1073748895 type@var1331 >=@expr1073748896 ValueType ::@expr1073748897 Type ::@expr1073748898 BOOL ) ;
1319: }
1320:
1321: bool isIntegral ( ) const {
1322: return (@expr1073748899 type@var1331 >=@expr1073748900 ValueType ::@expr7077 Type ::@expr1073748902 BOOL &&@expr1073748903 type@var1331 <=@expr1073748904 ValueType ::@expr7077 Type ::@expr1073748906 UNKNOWN_INT ) ;
1323: }
1324:
1325: bool isFloat ( ) const {
1326: return (@expr1073748907 type@var1331 >=@expr1073748908 ValueType ::@expr7085 Type ::@expr1073748910 FLOAT &&@expr1073748911 type@var1331 <=@expr1073748912 ValueType ::@expr7085 Type ::@expr1073748914 LONGDOUBLE ) ;
1327: }
1328:
1329: bool fromLibraryType ( const std :: string & typestr@var1364 , const Settings * settings@var1365 ) ;
1330:
1331: bool isEnum ( ) const {
1332: return typeScope@var1336 &&@expr1073748915 typeScope@var1336 .@expr1073748916 type@var1366 ==@expr1073748917 Scope ::@expr1073748918 eEnum ;
1333: }
1334:
1335: long long typeSize ( const cppcheck :: Platform & platform@var1367 , bool p@var1368 = false ) const ;
1336:
1337:
1338: bool isTypeEqual ( const ValueType * that@var1369 ) const ;
1339:
1340: std :: string str ( ) const ;
1341: std :: string dump ( ) const ;
1342: } ;
1343:
1344:
1345: class SymbolDatabase {
1346: friend class TestSymbolDatabase ;
1347: public:
1348: SymbolDatabase ( const Tokenizer * tokenizer@var1370 , const Settings * settings@var1371 , ErrorLogger * errorLogger@var1372 ) ;
1349: ~ SymbolDatabase ( ) ;
1350:
1351:
1352: std :: list < Scope > scopeList@var1373 ;
1353:
1354:
1355: std :: vector < const Scope * > functionScopes@var1374 ;
1356:
1357:
1358: std :: vector < const Scope * > classAndStructScopes@var1375 ;
1359:
1360:
1361: std :: list < Type > typeList@var1376 ;
1362:
|
1368:
1369: const Type * findVariableType ( const Scope * start@var1377 , const Token * typeTok@var1378 ) const ;
1370:
|
1375:
1376: const Function * findFunction ( const Token * tok@var1379 ) const ;
1377:
1378:
1379: const Scope * findScopeByName ( const std :: string & name@var1380 ) const ;
1380:
1381: const Type * findType ( const Token * startTok@var1381 , const Scope * startScope@var1382 , bool lookOutside@var1383 = false ) const ;
1382: Type * findType ( const Token * startTok@var1384 , Scope * startScope@var1385 , bool lookOutside@var1386 = false ) const {
1383: return const_cast < Type *@expr7095 > (@expr1073748920 this@expr1073748921 .@expr1073748922 findType (@expr1073748923 startTok@var1384 , const_cast < const Scope *@expr7095 > (@expr1073748925 startScope@var1385 ) , lookOutside@var1386 ) ) ;
1384: }
1385:
1386: const Scope * findScope ( const Token * tok@var1387 , const Scope * startScope@var1388 ) const ;
1387: Scope * findScope ( const Token * tok@var1389 , Scope * startScope@var1390 ) const {
1388: return const_cast < Scope *@expr7102 > (@expr1073748927 this@expr1073748928 .@expr1073748929 findScope (@expr1073748930 tok@var1389 , const_cast < const Scope *@expr7102 > (@expr1073748932 startScope@var1390 ) ) ) ;
1389: }
1390:
1391: bool isVarId ( int varid@var1391 ) const {
1392: return varid@var1391 <@expr1073748933 mVariableList@var1448 .@expr1073748934 size (@expr1073748935 ) ;
1393: }
1394:
1395: const Variable * getVariableFromVarId ( int varId@var1392 ) const {
1396: return mVariableList@var1448 .@expr1073748936 at (@expr1073748937 varId@var1392 ) ;
1397: }
1398:
1399: const std :: vector < const Variable * > & variableList ( ) const {
1400: return mVariableList@var1448 ;
1401: }
1402:
|
1405:
1406: void debugMessage ( const Token * tok@var1393 , const std :: string & type@var1394 , const std :: string & msg@var1395 ) const ;
1407:
1408: void printOut ( const char * title@var1396 = nullptr ) const ;
1409: void printVariable ( const Variable * var@var1397 , const char * indent@var1398 ) const ;
1410: void printXml ( std :: ostream & out@var1399 ) const ;
1411:
1412: bool isCPP ( ) const ;
1413:
|
1416:
1417: void validate ( ) const ;
1418:
1419: void validateExecutableScopes ( ) const ;
1420:
1421:
1422:
1423: void validateVariables ( ) const ;
1424:
1425:
1426: void setValueTypeInTokenList ( bool reportDebugWarnings@var1400 , Token * tokens@var1401 = nullptr ) ;
1427:
|
1432:
1433: int sizeOfType ( const Token * type@var1402 ) const ;
1434:
1435:
1436: void setArrayDimensionsUsingValueFlow ( ) ;
1437:
1438: void clangSetVariables ( const std :: vector < const Variable * > & variableList@var1403 ) ;
1439: void createSymbolDatabaseExprIds ( ) ;
1440:
1441: private:
1442: friend class Scope ;
1443: friend class Function ;
1444:
1445:
1446: void createSymbolDatabaseFindAllScopes ( ) ;
1447: void createSymbolDatabaseClassInfo ( ) ;
1448: void createSymbolDatabaseVariableInfo ( ) ;
1449: void createSymbolDatabaseCopyAndMoveConstructors ( ) ;
1450: void createSymbolDatabaseFunctionScopes ( ) ;
1451: void createSymbolDatabaseClassAndStructScopes ( ) ;
1452: void createSymbolDatabaseFunctionReturnTypes ( ) ;
1453: void createSymbolDatabaseNeedInitialization ( ) ;
1454: void createSymbolDatabaseVariableSymbolTable ( ) ;
1455: void createSymbolDatabaseSetScopePointers ( ) ;
1456: void createSymbolDatabaseSetFunctionPointers ( bool firstPass@var1404 ) ;
1457: void createSymbolDatabaseSetVariablePointers ( ) ;
1458:
1459: void createSymbolDatabaseSetTypePointers ( ) ;
1460: void createSymbolDatabaseSetSmartPointerType ( ) ;
1461: void createSymbolDatabaseEnums ( ) ;
1462: void createSymbolDatabaseEscapeFunctions ( ) ;
1463:
1464: void createSymbolDatabaseIncompleteVars ( ) ;
1465:
1466: void addClassFunction ( Scope * * scope@var1405 , const Token * * tok@var1406 , const Token * argStart@var1407 ) ;
1467: Function * addGlobalFunctionDecl ( Scope * & scope@var1408 , const Token * tok@var1409 , const Token * argStart@var1410 , const Token * funcStart@var1411 ) ;
1468: Function * addGlobalFunction ( Scope * & scope@var1412 , const Token * & tok@var1413 , const Token * argStart@var1414 , const Token * funcStart@var1415 ) ;
1469: void addNewFunction ( Scope * * scope@var1416 , const Token * * tok@var1417 ) ;
1470: bool isFunction ( const Token * tok@var1418 , const Scope * outerScope@var1419 , const Token * * funcStart@var1420 , const Token * * argStart@var1421 , const Token * * declEnd@var1422 ) const ;
1471: const Type * findTypeInNested ( const Token * startTok@var1423 , const Scope * startScope@var1424 ) const ;
1472: const Scope * findNamespace ( const Token * tok@var1425 , const Scope * scope@var1426 ) const ;
1473: Function * findFunctionInScope ( const Token * func@var1427 , const Scope * ns@var1428 , const std :: string & path@var1429 , int path_length@var1430 ) ;
1474: const Type * findVariableTypeInBase ( const Scope * scope@var1431 , const Token * typeTok@var1432 ) const ;
1475:
|
1478:
1479: void fixVarId ( std :: map < unsigned int , std :: map < unsigned int , unsigned int > > & varIds@var1433 , const Token * vartok@var1434 , Token * membertok@var1435 , const Variable * membervar@var1436 ) ;
1480:
1481:
1482: bool isReservedName ( const std :: string & iName@var1437 ) const ;
1483:
1484: const Enumerator * findEnumerator ( const Token * tok@var1438 ) const ;
1485:
1486: void setValueType ( Token * tok@var1439 , const ValueType & valuetype@var1440 ) ;
1487: void setValueType ( Token * tok@var1441 , const Variable & var@var1442 ) ;
1488: void setValueType ( Token * tok@var1443 , const Enumerator & enumerator@var1444 ) ;
1489:
1490: const Tokenizer * mTokenizer@var1445 ;
1491: const Settings * mSettings@var1446 ;
1492: ErrorLogger * mErrorLogger@var1447 ;
1493:
1494:
1495: std :: vector < const Variable * > mVariableList@var1448 ;
1496:
1497:
1498: std :: list < Type > mBlankTypes@var1449 ;
1499:
1500: bool mIsCpp@var1450 ;
1501: ValueType :: Sign mDefaultSignedness@var1451 ;
1502:
1503:
1504: mutable std :: set < std :: string > mTokensThatAreNotEnumeratorValues@var1452 ;
1505: } ;

##file cppcheck-2.8/lib/astutils.h

1:
|
34:
35: class Library ;
36: class Settings ;
37: class Token ;
38:
39: enum class ChildrenToVisit {
40: none ,
41: op1 ,
42: op2 ,
43: op1_and_op2 ,
44: done
45: } ;
46:
|
49:
50: template < class T , class TFunc , $class $= $typename $std $:: $enable_if $< std :: is_convertible < T * , const Token * > $:: $value $> $:: $type >
51: void visitAstNodes ( T * ast@var1453 , const TFunc & visitor@var1454 )
52: {
53: if (@expr1073748938 !@expr1073748939 ast@var1453 ) {
54: return ; }
55:
56: std ::@expr1073748940 stack < T *@expr7117 , std ::@expr1073748942 vector < T *@expr7117 > > tokens@var1455 ;
57: T * tok@var1456 ; tok@var1456 =@expr1073748944 ast@var1453 ;
58: do {
59: ChildrenToVisit c@var1457 ; c@var1457 =@expr1073748945 visitor@var1454 (@expr1073748946 tok@var1456 ) ;
60:
61: if (@expr1073748947 c@var1457 ==@expr1073748948 ChildrenToVisit ::@expr1073748949 done ) {
62: break ; }
63: if (@expr1073748950 c@var1457 ==@expr1073748951 ChildrenToVisit ::@expr1073748952 op2 ||@expr1073748953 c@var1457 ==@expr7130 ChildrenToVisit ::@expr7131 op1_and_op2 ) {
64: T * t2@var1458 ; t2@var1458 =@expr1073748956 tok@var1456 .@expr1073748957 astOperand2 (@expr1073748958 ) ;
65: if (@expr1073748959 t2@var1458 ) {
66: tokens@var1455 .@expr7136 push (@expr1073748961 t2@var1458 ) ; }
67: }
68: if (@expr1073748962 c@var1457 ==@expr1073748963 ChildrenToVisit ::@expr1073748964 op1 ||@expr1073748965 c@var1457 ==@expr7130 ChildrenToVisit ::@expr7131 op1_and_op2 ) {
69: T * t1@var1459 ; t1@var1459 =@expr1073748968 tok@var1456 .@expr1073748969 astOperand1 (@expr1073748970 ) ;
70: if (@expr1073748971 t1@var1459 ) {
71: tokens@var1455 .@expr7136 push (@expr1073748973 t1@var1459 ) ; }
72: }
73:
74: if (@expr1073748974 tokens@var1455 .@expr1073748975 empty (@expr1073748976 ) ) {
75: break ; }
76:
77: tok@var1456 =@expr1073748977 tokens@var1455 .@expr1073748978 top (@expr1073748979 ) ;
78: tokens@var1455 .@expr1073748980 pop (@expr1073748981 ) ;
79: } while (@expr1073748982 true ) ;
80: }
81:
82: const Token * findAstNode ( const Token * ast@var1460 , const std :: function < bool ( const Token * ) > & pred@var1461 ) ;
83: const Token * findExpression ( const int exprid@var1462 ,
84: const Token * start@var1463 ,
85: const Token * end@var1464 ,
86: const std :: function < bool ( const Token * ) > & pred@var1465 ) ;
87: const Token * findExpression ( const Token * start@var1466 , const int exprid@var1467 ) ;
88:
89: std :: vector < const Token * > astFlatten ( const Token * tok@var1468 , const char * op@var1469 ) ;
90: std :: vector < Token * > astFlatten ( Token * tok@var1470 , const char * op@var1471 ) ;
91:
92: int astCount ( const Token * tok@var1472 , const char * op@var1473 , int depth@var1474 = 100 ) ;
93:
94: bool astHasToken ( const Token * root@var1475 , const Token * tok@var1476 ) ;
95:
96: bool astHasVar ( const Token * tok@var1477 , int varid@var1478 ) ;
97:
98: bool astIsPrimitive ( const Token * tok@var1479 ) ;
99:
100: bool astIsSignedChar ( const Token * tok@var1480 ) ;
101:
102: bool astIsUnknownSignChar ( const Token * tok@var1481 ) ;
103:
104: bool astIsGenericChar ( const Token * tok@var1482 ) ;
105:
106: bool astIsIntegral ( const Token * tok@var1483 , bool unknown@var1484 ) ;
107: bool astIsUnsigned ( const Token * tok@var1485 ) ;
108:
109: bool astIsFloat ( const Token * tok@var1486 , bool unknown@var1487 ) ;
110:
111: bool astIsBool ( const Token * tok@var1488 ) ;
112:
113: bool astIsPointer ( const Token * tok@var1489 ) ;
114:
115: bool astIsSmartPointer ( const Token * tok@var1490 ) ;
116: bool astIsUniqueSmartPointer ( const Token * tok@var1491 ) ;
117:
118: bool astIsIterator ( const Token * tok@var1492 ) ;
119:
120: bool astIsContainer ( const Token * tok@var1493 ) ;
121:
122: bool astIsContainerView ( const Token * tok@var1494 ) ;
123: bool astIsContainerOwned ( const Token * tok@var1495 ) ;
124:
|
133:
134: std :: string astCanonicalType ( const Token * expr@var1496 ) ;
135:
136:
137: const Token * astIsVariableComparison ( const Token * tok@var1497 , const std :: string & comp@var1498 , const std :: string & rhs@var1499 , const Token * * vartok@var1500 = nullptr ) ;
138:
139: bool isVariableDecl ( const Token * tok@var1501 ) ;
140:
141: bool isTemporary ( bool cpp@var1502 , const Token * tok@var1503 , const Library * library@var1504 , bool unknown@var1505 = false ) ;
142:
143: const Token * previousBeforeAstLeftmostLeaf ( const Token * tok@var1506 ) ;
144: Token * previousBeforeAstLeftmostLeaf ( Token * tok@var1507 ) ;
145:
146: const Token * nextAfterAstRightmostLeaf ( const Token * tok@var1508 ) ;
147: Token * nextAfterAstRightmostLeaf ( Token * tok@var1509 ) ;
148:
149: Token * astParentSkipParens ( Token * tok@var1510 ) ;
150: const Token * astParentSkipParens ( const Token * tok@var1511 ) ;
151:
152: const Token * getParentMember ( const Token * tok@var1512 ) ;
153:
154: const Token * getParentLifetime ( const Token * tok@var1513 ) ;
155: const Token * getParentLifetime ( bool cpp@var1514 , const Token * tok@var1515 , const Library * library@var1516 ) ;
156:
157: bool astIsLHS ( const Token * tok@var1517 ) ;
158: bool astIsRHS ( const Token * tok@var1518 ) ;
159:
160: Token * getCondTok ( Token * tok@var1519 ) ;
161: const Token * getCondTok ( const Token * tok@var1520 ) ;
162:
163: Token * getInitTok ( Token * tok@var1521 ) ;
164: const Token * getInitTok ( const Token * tok@var1522 ) ;
165:
166: Token * getStepTok ( Token * tok@var1523 ) ;
167: const Token * getStepTok ( const Token * tok@var1524 ) ;
168:
169: Token * getCondTokFromEnd ( Token * endBlock@var1525 ) ;
170: const Token * getCondTokFromEnd ( const Token * endBlock@var1526 ) ;
171:
172:
173:
174: const Token * findNextTokenFromBreak ( const Token * breakToken@var1527 ) ;
175:
|
178:
179: bool extractForLoopValues ( const Token * forToken@var1528 ,
180: int * const varid@var1529 ,
181: bool * const knownInitValue@var1530 ,
182: long long * const initValue@var1531 ,
183: bool * const partialCond@var1532 ,
184: long long * const stepValue@var1533 ,
185: long long * const lastValue@var1534 ) ;
186:
187: bool precedes ( const Token * tok1@var1535 , const Token * tok2@var1536 ) ;
188: bool succeeds ( const Token * tok1@var1537 , const Token * tok2@var1538 ) ;
189:
190: bool exprDependsOnThis ( const Token * expr@var1539 , bool onVar@var1540 = true , int depth@var1541 = 0 ) ;
191:
192: struct ReferenceToken {
193: const Token * token@var1542 ;
194: std :: list < std :: pair < const Token * , std :: string > > errors@var1543 ;
195: } ;
196:
197: std :: vector < ReferenceToken > followAllReferences ( const Token * tok@var1544 ,
198: bool temporary@var1545 = true ,
199: bool inconclusive@var1546 = true ,
200: std :: list < std :: pair < const Token * , std :: string > > errors@var1547 = std :: list < std :: pair < const Token * , std :: string > > { } ,
201: int depth@var1548 = 20 ) ;
202: const Token * followReferences ( const Token * tok@var1549 , std :: list < std :: pair < const Token * , std :: string > > * errors@var1550 = nullptr ) ;
203:
204: bool isSameExpression ( bool cpp@var1551 , bool macro@var1552 , const Token * tok1@var1553 , const Token * tok2@var1554 , const Library & library@var1555 , bool pure@var1556 , bool followVar@var1557 , std :: list < std :: pair < const Token * , std :: string > > * errors@var1558 = nullptr ) ;
205:
206: bool isEqualKnownValue ( const Token * const tok1@var1559 , const Token * const tok2@var1560 ) ;
207:
|
210:
211: bool isUsedAsBool ( const Token * const tok@var1561 ) ;
212:
|
221:
222: bool isOppositeCond ( bool isNot@var1562 , bool cpp@var1563 , const Token * const cond1@var1564 , const Token * const cond2@var1565 , const Library & library@var1566 , bool pure@var1567 , bool followVar@var1568 , std :: list < std :: pair < const Token * , std :: string > > * errors@var1569 = nullptr ) ;
223:
224: bool isOppositeExpression ( bool cpp@var1570 , const Token * const tok1@var1571 , const Token * const tok2@var1572 , const Library & library@var1573 , bool pure@var1574 , bool followVar@var1575 , std :: list < std :: pair < const Token * , std :: string > > * errors@var1576 = nullptr ) ;
225:
226: bool isConstFunctionCall ( const Token * ftok@var1577 , const Library & library@var1578 ) ;
227:
228: bool isConstExpression ( const Token * tok@var1579 , const Library & library@var1580 , bool pure@var1581 , bool cpp@var1582 ) ;
229:
230: bool isWithoutSideEffects ( bool cpp@var1583 , const Token * tok@var1584 , bool checkArrayAccess@var1585 = false , bool checkReference@var1586 = true ) ;
231:
232: bool isUniqueExpression ( const Token * tok@var1587 ) ;
233:
234: bool isEscapeFunction ( const Token * ftok@var1588 , const Library * library@var1589 ) ;
235:
236:
237: bool isReturnScope ( const Token * const endToken@var1590 ,
238: const Library * library@var1591 = nullptr ,
239: const Token * * unknownFunc@var1592 = nullptr ,
240: bool functionScope@var1593 = false ) ;
241:
242:
243: bool isWithinScope ( const Token * tok@var1594 ,
244: const Variable * var@var1595 ,
245: Scope :: ScopeType type@var1596 ) ;
246:
247:
248: const Token * getTokenArgumentFunction ( const Token * tok@var1597 , int & argn@var1598 ) ;
249: Token * getTokenArgumentFunction ( Token * tok@var1599 , int & argn@var1600 ) ;
250:
251: std :: vector < const Variable * > getArgumentVars ( const Token * tok@var1601 , int argnr@var1602 ) ;
252:
|
261:
262: bool isVariableChangedByFunctionCall ( const Token * tok@var1603 , int indirect@var1604 , int varid@var1605 , const Settings * settings@var1606 , bool * inconclusive@var1607 ) ;
263:
|
271:
272: bool isVariableChangedByFunctionCall ( const Token * tok@var1608 , int indirect@var1609 , const Settings * settings@var1610 , bool * inconclusive@var1611 ) ;
273:
274:
275: bool isVariableChanged ( const Token * start@var1612 , const Token * end@var1613 , const int exprid@var1614 , bool globalvar@var1615 , const Settings * settings@var1616 , bool cpp@var1617 , int depth@var1618 = 20 ) ;
276: bool isVariableChanged ( const Token * start@var1619 , const Token * end@var1620 , int indirect@var1621 , const int exprid@var1622 , bool globalvar@var1623 , const Settings * settings@var1624 , bool cpp@var1625 , int depth@var1626 = 20 ) ;
277:
278: bool isVariableChanged ( const Token * tok@var1627 , int indirect@var1628 , const Settings * settings@var1629 , bool cpp@var1630 , int depth@var1631 = 20 ) ;
279:
280: bool isVariableChanged ( const Variable * var@var1632 , const Settings * settings@var1633 , bool cpp@var1634 , int depth@var1635 = 20 ) ;
281:
282: bool isVariablesChanged ( const Token * start@var1636 ,
283: const Token * end@var1637 ,
284: int indirect@var1638 ,
285: std :: vector < const Variable * > vars@var1639 ,
286: const Settings * settings@var1640 ,
287: bool cpp@var1641 ) ;
288:
289: bool isThisChanged ( const Token * tok@var1642 , int indirect@var1643 , const Settings * settings@var1644 , bool cpp@var1645 ) ;
290: bool isThisChanged ( const Token * start@var1646 , const Token * end@var1647 , int indirect@var1648 , const Settings * settings@var1649 , bool cpp@var1650 ) ;
291:
292: const Token * findVariableChanged ( const Token * start@var1651 , const Token * end@var1652 , int indirect@var1653 , const int exprid@var1654 , bool globalvar@var1655 , const Settings * settings@var1656 , bool cpp@var1657 , int depth@var1658 = 20 ) ;
293: Token * findVariableChanged ( Token * start@var1659 , const Token * end@var1660 , int indirect@var1661 , const int exprid@var1662 , bool globalvar@var1663 , const Settings * settings@var1664 , bool cpp@var1665 , int depth@var1666 = 20 ) ;
294:
295: bool isExpressionChanged ( const Token * expr@var1667 ,
296: const Token * start@var1668 ,
297: const Token * end@var1669 ,
298: const Settings * settings@var1670 ,
299: bool cpp@var1671 ,
300: int depth@var1672 = 20 ) ;
301:
302: bool isExpressionChangedAt ( const Token * expr@var1673 ,
303: const Token * tok@var1674 ,
304: int indirect@var1675 ,
305: bool globalvar@var1676 ,
306: const Settings * settings@var1677 ,
307: bool cpp@var1678 ,
308: int depth@var1679 = 20 ) ;
309:
310:
311: bool isAliasOf ( const Token * tok@var1680 , int varid@var1681 , bool * inconclusive@var1682 = nullptr ) ;
312:
313: bool isAliased ( const Variable * var@var1683 ) ;
314:
315: const Token * getArgumentStart ( const Token * ftok@var1684 ) ;
316:
|
320:
321: int numberOfArguments ( const Token * ftok@var1685 ) ;
322:
323:
324: int numberOfArgumentsWithoutAst ( const Token * start@var1686 ) ;
325:
|
328:
329: std :: vector < const Token * > getArguments ( const Token * ftok@var1687 ) ;
330:
331: int getArgumentPos ( const Variable * var@var1688 , const Function * f@var1689 ) ;
332:
|
335:
336: bool isIteratorPair ( std :: vector < const Token * > args@var1690 ) ;
337:
338: const Token * findLambdaStartToken ( const Token * last@var1691 ) ;
339:
|
344:
345: const Token * findLambdaEndToken ( const Token * first@var1692 ) ;
346: Token * findLambdaEndToken ( Token * first@var1693 ) ;
347:
348: bool isLikelyStream ( bool cpp@var1694 , const Token * stream@var1695 ) ;
349:
|
354:
355: bool isLikelyStreamRead ( bool cpp@var1696 , const Token * op@var1697 ) ;
356:
357: bool isCPPCast ( const Token * tok@var1698 ) ;
358:
359: bool isConstVarExpression ( const Token * tok@var1699 , const char * skipMatch@var1700 = nullptr ) ;
360:
361: const Variable * getLHSVariable ( const Token * tok@var1701 ) ;
362:
363: const Token * getLHSVariableToken ( const Token * tok@var1702 ) ;
364:
365: std :: vector < const Variable * > getLHSVariables ( const Token * tok@var1703 ) ;
366:
367:
368: const Token * findAllocFuncCallToken ( const Token * expr@var1704 , const Library & library@var1705 ) ;
369:
370: bool isScopeBracket ( const Token * tok@var1706 ) ;
371:
372: bool isNullOperand ( const Token * expr@var1707 ) ;
373:
374: bool isGlobalData ( const Token * expr@var1708 , bool cpp@var1709 ) ;
375:
|
380:
381: class FwdAnalysis {
382: public:
383: FwdAnalysis ( bool cpp@var1710 , const Library & library@var1711 ) : mCpp@var1744 ( cpp@var1710 ) , mLibrary@var1745 ( library@var1711 ) , mWhat@var1746 ( What :: Reassign ) , mValueFlowKnown@var1748 ( true ) { }
384:
385: bool hasOperand ( const Token * tok@var1712 , const Token * lhs@var1713 ) const ;
386:
|
393:
394: const Token * reassign ( const Token * expr@var1714 , const Token * startToken@var1715 , const Token * endToken@var1716 ) ;
395:
|
402:
403: bool unusedValue ( const Token * expr@var1717 , const Token * startToken@var1718 , const Token * endToken@var1719 ) ;
404:
405: struct KnownAndToken {
406: bool known@var1720 ;
407: const Token * token@var1721 ;
408: } ;
409:
410:
411: bool possiblyAliased ( const Token * expr@var1722 , const Token * startToken@var1723 ) const ;
412:
413: std :: set < int > getExprVarIds ( const Token * expr@var1724 , bool * localOut@var1725 = nullptr , bool * unknownVarIdOut@var1726 = nullptr ) const ;
414: private:
415: static bool isEscapedAlias ( const Token * expr@var1727 ) ;
416:
417:
418: struct Result {
419: enum class Type { NONE , READ , WRITE , BREAK , RETURN , BAILOUT } ; enum Type type@var1728 ;
420: explicit Result ( Type type@var1729 ) : type@var1728 ( type@var1729 ) , token@var1732 ( nullptr ) { }
421: Result ( Type type@var1730 , const Token * token@var1731 ) : type@var1728 ( type@var1730 ) , token@var1732 ( token@var1731 ) { }
422: const Token * token@var1732 ;
423: } ;
424:
425: struct Result check ( const Token * expr@var1733 , const Token * startToken@var1734 , const Token * endToken@var1735 ) ;
426: struct Result checkRecursive ( const Token * expr@var1736 , const Token * startToken@var1737 , const Token * endToken@var1738 , const std :: set < int > & exprVarIds@var1739 , bool local@var1740 , bool inInnerClass@var1741 , int depth@var1742 = 0 ) ;
427:
428:
429: bool isGlobalData ( const Token * expr@var1743 ) const ;
430:
431: const bool mCpp@var1744 ;
432: const Library & mLibrary@var1745 ;
433: enum class What { Reassign , UnusedValue , ValueFlow } ; enum What mWhat@var1746 ;
434: std :: vector < KnownAndToken > mValueFlow@var1747 ;
435: bool mValueFlowKnown@var1748 ;
436: } ;
437:
438: bool isSizeOfEtc ( const Token * tok@var1749 ) ;

##file cppcheck-2.8/lib/calculate.h

1:
|
25:
26: template < class T >
27: bool isEqual ( T x@var1750 , T y@var1751 )
28: {
29: return x@var1750 ==@expr1073748983 y@var1751 ;
30: }
31:
32: bool isEqual ( double x@var1752 , double y@var1753 )
33: {
34: const double diff@var1754 =@expr1073748984 (@expr1073748985 x@var1752 >@expr1073748986 y@var1753 ) ?@expr1073748987 x@var1752 -@expr1073748988 y@var1753 :@expr1073748989 y@var1753 -@expr1073748990 x@var1752 ;
35: return !@expr1073748991 (@expr1073748992 (@expr1073748993 diff@var1754 /@expr1073748994 2 ) <@expr1073748995 diff@var1754 ) ;
36: }
37: bool isEqual ( float x@var1755 , float y@var1756 )
38: {
39: return isEqual (@expr1073748996 double {@expr1073748997 x@var1755 } , double {@expr1073748998 y@var1756 } ) ;
40: }
41:
42: template < class T >
43: bool isZero ( T x@var1757 )
44: {
45: return isEqual (@expr1073748999 x@var1757 , T (@expr1073749000 0 ) ) ;
46: }
47:
48:
49: std :: vector < long long > calculate<std::vector<longlong>,std::vector<longlong>> ( const std :: string & s@var1758 , const std :: vector < long long > & x@var1759 , const std :: vector < long long > & y@var1760 , bool * error@var1761 = nullptr ) ;
50:
|
120:
121: std :: vector < long long > calculate<std::vector<longlong>> ( const std :: string & s@var1762 , const std :: vector < long long > & x@var1763 , const std :: vector < long long > & y@var1764 , bool * error@var1765 = nullptr ) ;

##file cppcheck-2.8/lib/check.h

1:
|
29:
30: namespace tinyxml2 {
31: class XMLElement ;
32: }
33:
34: namespace CTU {
35: class FileInfo ;
36: }
37:
38: namespace ValueFlow {
39: class Value ;
40: }
41:
42: class Settings ;
43: class Token ;
44: class ErrorLogger ;
45: class ErrorMessage ;
46: class Tokenizer ;
47:
|
57:
58: class Check {
59: public:
60:
61: explicit Check ( const std :: string & aname@var1766 ) ;
62:
63:
64: Check ( const std :: string & aname@var1767 , const Tokenizer * tokenizer@var1768 , const Settings * settings@var1769 , ErrorLogger * errorLogger@var1770 )
65: : mTokenizer@var1781 ( tokenizer@var1768 ) , mSettings@var1782 ( settings@var1769 ) , mErrorLogger@var1783 ( errorLogger@var1770 ) , mName@var1816 ( aname@var1767 ) { }
66:
67: virtual ~ Check ( ) {
68: if (@expr1073749001 !@expr1073749002 mTokenizer@var1781 ) {
69: instances (@expr1073749003 ) .@expr1073749004 remove (@expr1073749005 this@expr1073749006 ) ; }
70: }
71:
72:
73: static std :: list < Check * > & instances ( ) ;
74:
75:
76: virtual void runChecks ( const Tokenizer * , const Settings * , ErrorLogger * ) = 0 ;
77:
78:
79: virtual void getErrorMessages ( ErrorLogger * errorLogger@var1771 , const Settings * settings@var1772 ) const = 0 ;
80:
81:
82: const std :: string & name ( ) const {
83: return mName@var1816 ;
84: }
85:
86:
87: virtual std :: string classInfo ( ) const = 0 ;
88:
|
93:
94: static void reportError ( const ErrorMessage & errmsg@var1773 ) ;
95:
96:
97: class FileInfo {
98: public:
99: FileInfo ( ) { }
100: virtual ~ FileInfo ( ) { }
101: virtual std :: string toString ( ) const {
102: return std ::@expr1073749007 string (@expr1073749008 ) ;
103: }
104: } ;
105:
106: virtual FileInfo * getFileInfo ( const Tokenizer * tokenizer@var1774 , const Settings * settings@var1775 ) const {
107: (@expr1073749009 void ) tokenizer@var1774 ;
108: (@expr1073749010 void ) settings@var1775 ;
109: return nullptr ;
110: }
111:
112: virtual FileInfo * loadFileInfoFromXml ( const tinyxml2 :: XMLElement * xmlElement@var1776 ) const {
113: (@expr1073749011 void ) xmlElement@var1776 ;
114: return nullptr ;
115: }
116:
117:
118: virtual bool analyseWholeProgram ( const CTU :: FileInfo * ctu@var1777 , const std :: list < FileInfo * > & fileInfo@var1778 , const Settings & , ErrorLogger & ) {
119: (@expr1073749012 void ) ctu@var1777 ;
120: (@expr1073749013 void ) fileInfo@var1778 ;
121:
122:
123: return false ;
124: }
125:
126: static std :: string getMessageId ( const ValueFlow :: Value & value@var1779 , const char id@var1780 [ ] ) ;
127:
128: protected:
129: const Tokenizer * const mTokenizer@var1781 ;
130: const Settings * const mSettings@var1782 ;
131: ErrorLogger * const mErrorLogger@var1783 ;
132:
133:
134: void reportError ( const Token * tok@var1784 , const Severity :: SeverityType severity@var1785 , const std :: string & id@var1786 , const std :: string & msg@var1787 ) {
135: reportError (@expr1073749014 tok@var1784 , severity@var1785 , id@var1786 , msg@var1787 , CWE (@expr1073749015 0U ) , Certainty ::@expr1073749016 normal ) ;
136: }
137:
138:
139: void reportError ( const Token * tok@var1788 , const Severity :: SeverityType severity@var1789 , const std :: string & id@var1790 , const std :: string & msg@var1791 , const CWE & cwe@var1792 , Certainty :: CertaintyLevel certainty@var1793 ) {
140: const std ::@expr1073749017 list < const Token *@expr1073749018 > callstack@var1794 (@expr1073749019 1 , tok@var1788 ) ;
141: reportError (@expr1073749020 callstack@var1794 , severity@var1789 , id@var1790 , msg@var1791 , cwe@var1792 , certainty@var1793 ) ;
142: }
143:
144:
145: void reportError ( const std :: list < const Token * > & callstack@var1795 , Severity :: SeverityType severity@var1796 , const std :: string & id@var1797 , const std :: string & msg@var1798 ) {
146: reportError (@expr1073749021 callstack@var1795 , severity@var1796 , id@var1797 , msg@var1798 , CWE (@expr1073749022 0U ) , Certainty ::@expr1073749023 normal ) ;
147: }
148:
149:
150: void reportError ( const std :: list < const Token * > & callstack@var1799 , Severity :: SeverityType severity@var1800 , const std :: string & id@var1801 , const std :: string & msg@var1802 , const CWE & cwe@var1803 , Certainty :: CertaintyLevel certainty@var1804 ) ;
151:
152: void reportError ( const std :: list < std :: pair < const Token * , std :: string > > & errorPath@var1805 , Severity :: SeverityType severity@var1806 , const char id@var1807 [ ] , const std :: string & msg@var1808 , const CWE & cwe@var1809 , Certainty :: CertaintyLevel certainty@var1810 ) ;
153:
154: std :: list < std :: pair < const Token * , std :: string > > getErrorPath ( const Token * errtok@var1811 , const ValueFlow :: Value * value@var1812 , const std :: string & bug@var1813 ) const ;
155:
|
159:
160: bool wrongData ( const Token * tok@var1814 , const char * str@var1815 ) ;
161:
162:
163: void operator= ( const Check & ) = delete ;
164: Check ( const Check & ) = delete ;
165: private:
166: const std :: string mName@var1816 ;
167: } ;

##file cppcheck-2.8/lib/suppressions.h

1:
|
34:
35: class Tokenizer ;
36:
37:
38: class Suppressions {
39: public:
40:
41: struct ErrorMessage {
42: unsigned long hash@var1817 ;
43: std :: string errorId@var1818 ;
44: void setFileName ( const std :: string & s@var1819 ) ;
45: const std :: string & getFileName ( ) const {
46: return mFileName@var1823 ;
47: }
48: int lineNumber@var1820 ;
49: Certainty :: CertaintyLevel certainty@var1821 ;
50: std :: string symbolNames@var1822 ;
51: private:
52: std :: string mFileName@var1823 ;
53: } ;
54:
55: struct Suppression {
56: Suppression ( ) : lineNumber@var1857 ( NO_LINE ) , hash@var1859 ( 0 ) , thisAndNextLine@var1860 ( false ) , matched@var1861 ( false ) , checked@var1862 ( false ) { }
57: Suppression ( const Suppression & other@var1824 ) {
58: *@expr1073749024 this@expr1073749025 =@expr1073749026 other@var1824 ;
59: }
60: Suppression ( const std :: string & id@var1825 , const std :: string & file@var1826 , int line@var1827 = NO_LINE ) : errorId@var1855 ( id@var1825 ) , fileName@var1856 ( file@var1826 ) , lineNumber@var1857 ( line@var1827 ) , hash@var1859 ( 0 ) , thisAndNextLine@var1860 ( false ) , matched@var1861 ( false ) , checked@var1862 ( false ) { }
61:
62: Suppression & operator= ( const Suppression & other@var1828 ) {
63: errorId@var1855 =@expr1073749027 other@var1828 .@expr1073749028 errorId@var1829 ;
64: fileName@var1856 =@expr1073749029 other@var1828 .@expr1073749030 fileName@var1830 ;
65: lineNumber@var1857 =@expr1073749031 other@var1828 .@expr1073749032 lineNumber@var1831 ;
66: symbolName@var1858 =@expr1073749033 other@var1828 .@expr1073749034 symbolName@var1832 ;
67: hash@var1859 =@expr1073749035 other@var1828 .@expr1073749036 hash@var1833 ;
68: thisAndNextLine@var1860 =@expr1073749037 other@var1828 .@expr1073749038 thisAndNextLine@var1834 ;
69: matched@var1861 =@expr1073749039 other@var1828 .@expr1073749040 matched@var1835 ;
70: checked@var1862 =@expr1073749041 other@var1828 .@expr1073749042 checked@var1836 ;
71: return *@expr1073749043 this@expr1073749044 ;
72: }
73:
74: bool operator< ( const Suppression & other@var1837 ) const {
75: if (@expr1073749045 errorId@var1855 !=@expr1073749046 other@var1837 .@expr7223 errorId@var1838 ) {
76: return errorId@var1855 <@expr1073749048 other@var1837 .@expr7223 errorId@var1838 ; }
77: if (@expr1073749050 lineNumber@var1857 <@expr1073749051 other@var1837 .@expr1073749052 lineNumber@var1839 ) {
78: return true ; }
79: if (@expr1073749053 fileName@var1856 !=@expr1073749054 other@var1837 .@expr7231 fileName@var1840 ) {
80: return fileName@var1856 <@expr1073749056 other@var1837 .@expr7231 fileName@var1840 ; }
81: if (@expr1073749058 symbolName@var1858 !=@expr1073749059 other@var1837 .@expr7236 symbolName@var1841 ) {
82: return symbolName@var1858 <@expr1073749061 other@var1837 .@expr7236 symbolName@var1841 ; }
83: if (@expr1073749063 hash@var1859 !=@expr1073749064 other@var1837 .@expr7241 hash@var1842 ) {
84: return hash@var1859 <@expr1073749066 other@var1837 .@expr7241 hash@var1842 ; }
85: if (@expr1073749068 thisAndNextLine@var1860 !=@expr1073749069 other@var1837 .@expr1073749070 thisAndNextLine@var1843 ) {
86: return thisAndNextLine@var1860 ; }
87: return false ;
88: }
89:
|
95:
96: bool parseComment ( std :: string comment@var1844 , std :: string * errorMessage@var1845 ) ;
97:
98: bool isSuppressed ( const ErrorMessage & errmsg@var1846 ) const ;
99:
100: bool isMatch ( const ErrorMessage & errmsg@var1847 ) ;
101:
102: std :: string getText ( ) const ;
103:
104: bool isLocal ( ) const {
105: return !@expr1073749072 fileName@var1856 .@expr1073749073 empty (@expr1073749074 ) &&@expr1073749075 fileName@var1856 .@expr1073749076 find_first_of (@expr1073749077 "?*" ) ==@expr1073749078 std ::@expr1073749079 string ::@expr1073749080 npos@expr1073749071 ;
106: }
107:
108: bool isSameParameters ( const Suppression & other@var1848 ) const {
109: return errorId@var1855 ==@expr1073749081 other@var1848 .@expr1073749082 errorId@var1849 &&@expr1073749083
110: fileName@var1856 ==@expr1073749084 other@var1848 .@expr1073749085 fileName@var1850 &&@expr1073749086
111: lineNumber@var1857 ==@expr1073749087 other@var1848 .@expr1073749088 lineNumber@var1851 &&@expr1073749089
112: symbolName@var1858 ==@expr1073749090 other@var1848 .@expr1073749091 symbolName@var1852 &&@expr1073749092
113: hash@var1859 ==@expr1073749093 other@var1848 .@expr1073749094 hash@var1853 &&@expr1073749095
114: thisAndNextLine@var1860 ==@expr1073749096 other@var1848 .@expr1073749097 thisAndNextLine@var1854 ;
115: }
116:
117: std :: string errorId@var1855 ;
118: std :: string fileName@var1856 ;
119: int lineNumber@var1857 ;
120: std :: string symbolName@var1858 ;
121: unsigned long hash@var1859 ;
122: bool thisAndNextLine@var1860 ;
123: bool matched@var1861 ;
124: bool checked@var1862 ;
125:
126: enum Anonymous5 { NO_LINE = -1 } ;
127: } ;
128:
|
133:
134: std :: string parseFile ( std :: istream & istr@var1863 ) ;
135:
|
140:
141: std :: string parseXmlFile ( const char * filename@var1864 ) ;
142:
|
148:
149: static std :: vector < Suppression > parseMultiSuppressComment ( const std :: string & comment@var1865 , std :: string * errorMessage@var1866 ) ;
150:
|
155:
156: std :: string addSuppressionLine ( const std :: string & line@var1867 ) ;
157:
|
163:
164: std :: string addSuppression ( const Suppression & suppression@var1868 ) ;
165:
|
170:
171: std :: string addSuppressions ( const std :: list < Suppression > & suppressions@var1869 ) ;
172:
|
177:
178: bool isSuppressed ( const ErrorMessage & errmsg@var1870 ) ;
179:
|
184:
185: bool isSuppressedLocal ( const ErrorMessage & errmsg@var1871 ) ;
186:
|
190:
191: void dump ( std :: ostream & out@var1872 ) const ;
192:
|
196:
197: std :: list < Suppression > getUnmatchedLocalSuppressions ( const std :: string & file@var1873 , const bool unusedFunctionChecking@var1874 ) const ;
198:
|
202:
203: std :: list < Suppression > getUnmatchedGlobalSuppressions ( const bool unusedFunctionChecking@var1875 ) const ;
204:
|
208:
209: const std :: list < Suppression > & getSuppressions ( ) const ;
210:
|
213:
214: void markUnmatchedInlineSuppressionsAsChecked ( const Tokenizer & tokenizer@var1876 ) ;
215:
216: private:
217:
218: std :: list < Suppression > mSuppressions@var1877 ;
219: } ;

##file cppcheck-2.8/lib/color.h

1:
|
26:
27: enum class Color {
28: Reset = 0 ,
29: Bold = 1 ,
30: Dim = 2 ,
31: FgRed = 31 ,
32: FgGreen = 32 ,
33: FgBlue = 34 ,
34: FgMagenta = 35 ,
35: FgDefault = 39 ,
36: BgRed = 41 ,
37: BgGreen = 42 ,
38: BgBlue = 44 ,
39: BgDefault = 49
40: } ;
41: std :: ostream & operator<< ( std :: ostream & os@var1878 , const Color & c@var1879 ) ;
42:
43: std :: string toString ( const Color & c@var1880 ) ;

##file cppcheck-2.8/lib/errorlogger.h

1:
|
39:
40: static const struct CWE CWE_USE_OF_UNINITIALIZED_VARIABLE@var1881 ( 457U ) ;
41: static const struct CWE CWE_NULL_POINTER_DEREFERENCE@var1882 ( 476U ) ;
42: static const struct CWE CWE_USE_OF_POTENTIALLY_DANGEROUS_FUNCTION@var1883 ( 676U ) ;
43: static const struct CWE CWE_INCORRECT_CALCULATION@var1884 ( 682U ) ;
44: static const struct CWE CWE_EXPIRED_POINTER_DEREFERENCE@var1885 ( 825U ) ;
45:
46:
47: class Token ;
48: class TokenList ;
49:
50: namespace tinyxml2 {
51: class XMLElement ;
52: }
53:
|
59:
60: class ErrorMessage {
61: public:
62:
|
66:
67: class FileLocation {
68: public:
69: FileLocation ( )
70: : fileIndex@var1901 ( 0 ) , line@var1902 ( 0 ) , column@var1903 ( 0 ) { }
71:
72: FileLocation ( const std :: string & file@var1886 , int line@var1887 , unsigned int column@var1888 )
73: : fileIndex@var1901 ( 0 ) , line@var1902 ( line@var1887 ) , column@var1903 ( column@var1888 ) , mOrigFileName@var1905 ( file@var1886 ) , mFileName@var1906 ( file@var1886 ) { }
74:
75: FileLocation ( const std :: string & file@var1889 , const std :: string & info@var1890 , int line@var1891 , unsigned int column@var1892 )
76: : fileIndex@var1901 ( 0 ) , line@var1902 ( line@var1891 ) , column@var1903 ( column@var1892 ) , mOrigFileName@var1905 ( file@var1889 ) , mFileName@var1906 ( file@var1889 ) , mInfo@var1907 ( info@var1890 ) { }
77:
78: FileLocation ( const Token * tok@var1893 , const TokenList * tokenList@var1894 ) ;
79: FileLocation ( const Token * tok@var1895 , const std :: string & info@var1896 , const TokenList * tokenList@var1897 ) ;
80:
|
85:
86: std :: string getfile ( bool convert@var1898 = true ) const ;
87:
|
92:
93: std :: string getOrigFile ( bool convert@var1899 = true ) const ;
94:
|
98:
99: void setfile ( const std :: string & file@var1900 ) ;
100:
|
103:
104: std :: string stringify ( ) const ;
105:
106: unsigned int fileIndex@var1901 ;
107: int line@var1902 ;
108: unsigned int column@var1903 ;
109:
110: std :: string getinfo ( ) const {
111: return mInfo@var1907 ;
112: }
113: void setinfo ( const std :: string & i@var1904 ) {
114: mInfo@var1907 =@expr1073749098 i@var1904 ;
115: }
116:
117: private:
118: std :: string mOrigFileName@var1905 ;
119: std :: string mFileName@var1906 ;
120: std :: string mInfo@var1907 ;
121: } ;
122:
123: ErrorMessage ( const std :: list < FileLocation > & callStack@var1908 ,
124: const std :: string & file1@var1909 ,
125: Severity :: SeverityType severity@var1910 ,
126: const std :: string & msg@var1911 ,
127: const std :: string & id@var1912 , Certainty :: CertaintyLevel certainty@var1913 ) ;
128: ErrorMessage ( const std :: list < FileLocation > & callStack@var1914 ,
129: const std :: string & file1@var1915 ,
130: Severity :: SeverityType severity@var1916 ,
131: const std :: string & msg@var1917 ,
132: const std :: string & id@var1918 ,
133: const CWE & cwe@var1919 ,
134: Certainty :: CertaintyLevel certainty@var1920 ) ;
135: ErrorMessage ( const std :: list < const Token * > & callstack@var1921 ,
136: const TokenList * list@var1922 ,
137: Severity :: SeverityType severity@var1923 ,
138: const std :: string & id@var1924 ,
139: const std :: string & msg@var1925 ,
140: Certainty :: CertaintyLevel certainty@var1926 ) ;
141: ErrorMessage ( const std :: list < const Token * > & callstack@var1927 ,
142: const TokenList * list@var1928 ,
143: Severity :: SeverityType severity@var1929 ,
144: const std :: string & id@var1930 ,
145: const std :: string & msg@var1931 ,
146: const CWE & cwe@var1932 ,
147: Certainty :: CertaintyLevel certainty@var1933 ) ;
148: ErrorMessage ( const std :: list < std :: pair < const Token * , std :: string > > & errorPath@var1934 ,
149: const TokenList * tokenList@var1935 ,
150: Severity :: SeverityType severity@var1936 ,
151: const char id@var1937 [ ] ,
152: const std :: string & msg@var1938 ,
153: const CWE & cwe@var1939 ,
154: Certainty :: CertaintyLevel certainty@var1940 ) ;
155: ErrorMessage ( ) ;
156: explicit ErrorMessage ( const tinyxml2 :: XMLElement * const errmsg@var1941 ) ;
157:
|
160:
161: std :: string toXML ( ) const ;
162:
163: static std :: string getXMLHeader ( ) ;
164: static std :: string getXMLFooter ( ) ;
165:
|
174:
175: std :: string toString ( bool verbose@var1942 ,
176: const std :: string & templateFormat@var1943 = emptyString@var1 ,
177: const std :: string & templateLocation@var1944 = emptyString@var1 ) const ;
178:
179: std :: string serialize ( ) const ;
180: bool deserialize ( const std :: string & data@var1945 ) ;
181:
182: std :: list < FileLocation > callStack@var1946 ;
183: std :: string id@var1947 ;
184:
185:
186: std :: string file0@var1948 ;
187:
188: std :: string function@var1949 ;
189:
190: bool incomplete@var1950 ;
191:
192: Severity :: SeverityType severity@var1951 ;
193: CWE cwe@var1952 ;
194: Certainty :: CertaintyLevel certainty@var1953 ;
195:
196:
197: unsigned long hash@var1954 ;
198:
199:
200: void setmsg ( const std :: string & msg@var1955 ) ;
201:
202:
203: const std :: string & shortMessage ( ) const {
204: return mShortMessage@var1957 ;
205: }
206:
207:
208: const std :: string & verboseMessage ( ) const {
209: return mVerboseMessage@var1958 ;
210: }
211:
212:
213: const std :: string & symbolNames ( ) const {
214: return mSymbolNames@var1959 ;
215: }
216:
217: Suppressions :: ErrorMessage toSuppressionsErrorMessage ( ) const ;
218:
219: private:
220: static std :: string fixInvalidChars ( const std :: string & raw@var1956 ) ;
221:
222:
223: std :: string mShortMessage@var1957 ;
224:
225:
226: std :: string mVerboseMessage@var1958 ;
227:
228:
229: std :: string mSymbolNames@var1959 ;
230: } ;
231:
|
235:
236: class ErrorLogger {
237: protected:
238: std :: ofstream plistFile@var1960 ;
239: public:
240: ErrorLogger ( ) { }
241: virtual ~ ErrorLogger ( ) {
242: if (@expr1073749099 plistFile@var1960 .@expr1073749100 is_open (@expr1073749101 ) ) {
243: plistFile@var1960 <<@expr1073749102 ErrorLogger ::@expr1073749103 plistFooter (@expr1073749104 ) ;
244: plistFile@var1960 .@expr1073749105 close (@expr1073749106 ) ;
245: }
246: }
247:
|
253:
254: virtual void reportOut ( const std :: string & outmsg@var1961 , Color c@var1962 = Color :: Reset ) = 0 ;
255:
|
261:
262: virtual void reportErr ( const ErrorMessage & msg@var1963 ) = 0 ;
263:
|
269:
270: virtual void reportProgress ( const std :: string & filename@var1964 , const char stage@var1965 [ ] , const unsigned long value@var1966 ) {
271: (@expr1073749107 void ) filename@var1964 ;
272: (@expr1073749108 void ) stage@var1965 ;
273: (@expr1073749109 void ) value@var1966 ;
274: }
275:
|
279:
280: virtual void reportInfo ( const ErrorMessage & msg@var1967 ) {
281: reportErr (@expr1073749110 msg@var1967 ) ;
282: }
283:
|
288:
289: bool reportUnmatchedSuppressions ( const std :: list < Suppressions :: Suppression > & unmatched@var1968 ) ;
290:
291: static std :: string callStackToString ( const std :: list < ErrorMessage :: FileLocation > & callStack@var1969 ) ;
292:
|
297:
298: static std :: string toxml ( const std :: string & str@var1970 ) ;
299:
300: static std :: string plistHeader ( const std :: string & version@var1971 , const std :: vector < std :: string > & files@var1972 ) ;
301: static std :: string plistData ( const ErrorMessage & msg@var1973 ) ;
302: static const char * plistFooter ( ) {
303: return " </array>\r\n</dict>\r\n</plist>"
304:
305: ;
306: }
307: } ;
308:
309:
310: std :: string replaceStr ( std :: string s@var1974 , const std :: string & from@var1975 , const std :: string & to@var1976 ) ;

##file cppcheck-2.8/lib/ctu.h

1:
|
36:
37: class Function ;
38: class Settings ;
39: class Token ;
40: class Tokenizer ;
41:
42: namespace tinyxml2 {
43: class XMLElement ;
44: }
45:
|
50:
51: namespace CTU {
52: class FileInfo : public Check :: FileInfo {
53: public:
54: enum class InvalidValueType { null , uninit , bufferOverflow } ;
55:
56: std :: string toString ( ) const override ;
57:
58: struct Location {
59: Location ( ) = default ;
60: Location ( const Tokenizer * tokenizer@var1977 , const Token * tok@var1978 ) ;
61: Location ( const std :: string & fileName@var1979 , int lineNumber@var1980 , int column@var1981 ) : fileName@var1982 ( fileName@var1979 ) , lineNumber@var1983 ( lineNumber@var1980 ) , column@var1984 ( column@var1981 ) { }
62: std :: string fileName@var1982 ;
63: int lineNumber@var1983 { } ;
64: int column@var1984 { } ;
65: } ;
66:
67: struct UnsafeUsage {
68: UnsafeUsage ( ) = default ;
69: UnsafeUsage ( const std :: string & myId@var1985 , int myArgNr@var1986 , const std :: string & myArgumentName@var1987 , const Location & location@var1988 , long long value@var1989 ) : myId@var1990 ( myId@var1985 ) , myArgNr@var1991 ( myArgNr@var1986 ) , myArgumentName@var1992 ( myArgumentName@var1987 ) , location@var1993 ( location@var1988 ) , value@var1994 ( value@var1989 ) { }
70: std :: string myId@var1990 ;
71: int myArgNr@var1991 { } ;
72: std :: string myArgumentName@var1992 ;
73: Location location@var1993 ;
74: long long value@var1994 { } ;
75: std :: string toString ( ) const ;
76: } ;
77:
78: class CallBase {
79: public:
80: CallBase ( ) = default ;
81: CallBase ( const std :: string & callId@var1995 , int callArgNr@var1996 , const std :: string & callFunctionName@var1997 , const Location & loc@var1998 )
82: : callId@var2001 ( callId@var1995 ) , callArgNr@var2002 ( callArgNr@var1996 ) , callFunctionName@var2003 ( callFunctionName@var1997 ) , location@var2004 ( loc@var1998 )
83: { }
84: CallBase ( const Tokenizer * tokenizer@var1999 , const Token * callToken@var2000 ) ;
85: virtual ~ CallBase ( ) { }
86: std :: string callId@var2001 ;
87: int callArgNr@var2002 { } ;
88: std :: string callFunctionName@var2003 ;
89: Location location@var2004 ;
90: protected:
91: std :: string toBaseXmlString ( ) const ;
92: bool loadBaseFromXml ( const tinyxml2 :: XMLElement * xmlElement@var2005 ) ;
93: } ;
94:
95: class FunctionCall : public CallBase {
96: public:
97: std :: string callArgumentExpression@var2006 ;
98: long long callArgValue@var2007 ;
99: ValueFlow :: Value :: ValueType callValueType@var2008 ;
100: std :: vector < ErrorMessage :: FileLocation > callValuePath@var2009 ;
101: bool warning@var2010 ;
102:
103: std :: string toXmlString ( ) const ;
104: bool loadFromXml ( const tinyxml2 :: XMLElement * xmlElement@var2011 ) ;
105: } ;
106:
107: class NestedCall : public CallBase {
108: public:
109: NestedCall ( ) = default ;
110:
111: NestedCall ( const std :: string & myId@var2012 , int myArgNr@var2013 , const std :: string & callId@var2014 , int callArgnr@var2015 , const std :: string & callFunctionName@var2016 , const Location & location@var2017 )
112: : CallBase ( callId@var2014 , callArgnr@var2015 , callFunctionName@var2016 , location@var2017 ) ,
113: myId@var2022 ( myId@var2012 ) ,
114: myArgNr@var2023 ( myArgNr@var2013 ) { }
115:
116: NestedCall ( const Tokenizer * tokenizer@var2018 , const Function * myFunction@var2019 , const Token * callToken@var2020 ) ;
117:
118: std :: string toXmlString ( ) const ;
119: bool loadFromXml ( const tinyxml2 :: XMLElement * xmlElement@var2021 ) ;
120:
121: std :: string myId@var2022 ;
122: int myArgNr@var2023 { } ;
123: } ;
124:
125: std :: list < FunctionCall > functionCalls@var2024 ;
126: std :: list < NestedCall > nestedCalls@var2025 ;
127:
128: void loadFromXml ( const tinyxml2 :: XMLElement * xmlElement@var2026 ) ;
129: std :: map < std :: string , std :: list < const CallBase * > > getCallsMap ( ) const ;
130:
131: static std :: list < ErrorMessage :: FileLocation > getErrorPath ( InvalidValueType invalidValue@var2027 ,
132: const UnsafeUsage & unsafeUsage@var2028 ,
133: const std :: map < std :: string , std :: list < const CallBase * > > & callsMap@var2029 ,
134: const char info@var2030 [ ] ,
135: const FunctionCall * * const functionCallPtr@var2031 ,
136: bool warning@var2032 ) ;
137: } ;
138:
139: extern int maxCtuDepth@var2033 ;
140:
141: std :: string toString ( const std :: list < FileInfo :: UnsafeUsage > & unsafeUsage@var2034 ) ;
142:
143: std :: string getFunctionId ( const Tokenizer * tokenizer@var2035 , const Function * function@var2036 ) ;
144:
145:
146: FileInfo * getFileInfo ( const Tokenizer * tokenizer@var2037 ) ;
147:
148: std :: list < FileInfo :: UnsafeUsage > getUnsafeUsage ( const Tokenizer * tokenizer@var2038 , const Settings * settings@var2039 , const Check * check@var2040 , bool ( * isUnsafeUsage@var2041 ) ( const Check * , const Token * , long long * ) ) ;
149:
150: std :: list < FileInfo :: UnsafeUsage > loadUnsafeUsageListFromXml ( const tinyxml2 :: XMLElement * xmlElement@var2042 ) ;
151: }

##file cppcheck-2.8/lib/checkuninitvar.h

1:
|
36:
37: class Scope ;
38: class Token ;
39: class Tokenizer ;
40: class Variable ;
41: class ErrorLogger ;
42: class Settings ;
43: class Library ;
44:
45: namespace tinyxml2 {
46: class XMLElement ;
47: }
48:
49:
50: struct VariableValue {
51: explicit VariableValue ( long long val@var2043 = 0 ) : value@var2044 ( val@var2043 ) , notEqual@var2045 ( false ) { }
52: long long value@var2044 ;
53: bool notEqual@var2045 ;
54: } ;
55:
|
61:
62: class CheckUninitVar : public Check {
63: public:
64:
65: CheckUninitVar ( ) : Check ( myName ( ) ) { }
66:
67:
68: CheckUninitVar ( const Tokenizer * tokenizer@var2046 , const Settings * settings@var2047 , ErrorLogger * errorLogger@var2048 )
69: : Check ( myName ( ) , tokenizer@var2046 , settings@var2047 , errorLogger@var2048 ) { }
70:
71:
72: void runChecks ( const Tokenizer * tokenizer@var2049 , const Settings * settings@var2050 , ErrorLogger * errorLogger@var2051 ) override {
73: CheckUninitVar checkUninitVar@var2052 (@expr1073749111 tokenizer@var2049 , settings@var2050 , errorLogger@var2051 ) ;
74: checkUninitVar@var2052 .@expr1073749112 valueFlowUninit (@expr1073749113 ) ;
75: checkUninitVar@var2052 .@expr1073749114 check (@expr1073749115 ) ;
76: }
77:
78: bool diag ( const Token * tok@var2053 ) ;
79:
80: void check ( ) ;
81: void checkScope ( const Scope * scope@var2054 , const std :: set < std :: string > & arrayTypeDefs@var2055 ) ;
82: void checkStruct ( const Token * tok@var2056 , const Variable & structvar@var2057 ) ;
83: enum Alloc { NO_ALLOC , NO_CTOR_CALL , CTOR_CALL , ARRAY } ;
84: bool checkScopeForVariable ( const Token * tok@var2058 , const Variable & var@var2059 , bool * const possibleInit@var2060 , bool * const noreturn@var2061 , Alloc * const alloc@var2062 , const std :: string & membervar@var2063 , std :: map < int , VariableValue > variableValue@var2064 ) ;
85: const Token * checkExpr ( const Token * tok@var2065 , const Variable & var@var2066 , const Alloc alloc@var2067 , bool known@var2068 , bool * bailout@var2069 = nullptr ) ;
86: bool checkIfForWhileHead ( const Token * startparentheses@var2070 , const Variable & var@var2071 , bool suppressErrors@var2072 , bool isuninit@var2073 , Alloc alloc@var2074 , const std :: string & membervar@var2075 ) ;
87: bool checkLoopBody ( const Token * tok@var2076 , const Variable & var@var2077 , const Alloc alloc@var2078 , const std :: string & membervar@var2079 , const bool suppressErrors@var2080 ) ;
88: const Token * checkLoopBodyRecursive ( const Token * start@var2081 , const Variable & var@var2082 , const Alloc alloc@var2083 , const std :: string & membervar@var2084 , bool & bailout@var2085 ) const ;
89: void checkRhs ( const Token * tok@var2086 , const Variable & var@var2087 , Alloc alloc@var2088 , int number_of_if@var2089 , const std :: string & membervar@var2090 ) ;
90: static const Token * isVariableUsage ( bool cpp@var2091 , const Token * vartok@var2092 , const Library & library@var2093 , bool pointer@var2094 , Alloc alloc@var2095 , int indirect@var2096 = 0 ) ;
91: const Token * isVariableUsage ( const Token * vartok@var2097 , bool pointer@var2098 , Alloc alloc@var2099 , int indirect@var2100 = 0 ) const ;
92: static int isFunctionParUsage ( const Token * vartok@var2101 , const Library & library@var2102 , bool pointer@var2103 , Alloc alloc@var2104 , int indirect@var2105 = 0 ) ;
93: int isFunctionParUsage ( const Token * vartok@var2106 , bool pointer@var2107 , Alloc alloc@var2108 , int indirect@var2109 = 0 ) const ;
94: bool isMemberVariableAssignment ( const Token * tok@var2110 , const std :: string & membervar@var2111 ) const ;
95: bool isMemberVariableUsage ( const Token * tok@var2112 , bool isPointer@var2113 , Alloc alloc@var2114 , const std :: string & membervar@var2115 ) const ;
96:
97:
98: void valueFlowUninit ( ) ;
99:
100:
101: class MyFileInfo : public Check :: FileInfo {
102: public:
103:
104: std :: list < CTU :: FileInfo :: UnsafeUsage > unsafeUsage@var2116 ;
105:
106:
107: std :: string toString ( ) const override ;
108: } ;
109:
110:
111: Check :: FileInfo * getFileInfo ( const Tokenizer * tokenizer@var2117 , const Settings * settings@var2118 ) const override ;
112:
113: Check :: FileInfo * loadFileInfoFromXml ( const tinyxml2 :: XMLElement * xmlElement@var2119 ) const override ;
114:
115:
116: bool analyseWholeProgram ( const CTU :: FileInfo * ctu@var2120 , const std :: list < Check :: FileInfo * > & fileInfo@var2121 , const Settings & settings@var2122 , ErrorLogger & errorLogger@var2123 ) override ;
117:
118: void uninitvarError ( const Token * tok@var2124 , const ValueFlow :: Value & v@var2125 ) ;
119: void uninitstringError ( const Token * tok@var2126 , const std :: string & varname@var2127 , bool strncpy_@var2128 ) ;
120: void uninitdataError ( const Token * tok@var2129 , const std :: string & varname@var2130 ) ;
121: void uninitvarError ( const Token * tok@var2131 , const std :: string & varname@var2132 , std :: list < std :: pair < const Token * , std :: string > > errorPath@var2133 ) ;
122: void uninitvarError ( const Token * tok@var2134 , const std :: string & varname@var2135 ) {
123: std ::@expr1073749116 list < std ::@expr7293 pair < const Token *@expr1073749118 , std ::@expr7293 string > > errorPath@var2136 ;
124: uninitvarError (@expr1073749120 tok@var2134 , varname@var2135 , errorPath@var2136 ) ;
125: }
126: void uninitvarError ( const Token * tok@var2137 , const std :: string & varname@var2138 , Alloc alloc@var2139 ) {
127: if (@expr1073749121 alloc@var2139 ==@expr1073749122 NO_CTOR_CALL ||@expr1073749123 alloc@var2139 ==@expr1073749124 CTOR_CALL ) {
128: uninitdataError (@expr1073749125 tok@var2137 , varname@var2138 ) ; }
129: else {
130: uninitvarError (@expr1073749126 tok@var2137 , varname@var2138 ) ; }
131: }
132: void uninitStructMemberError ( const Token * tok@var2140 , const std :: string & membername@var2141 ) ;
133:
134: private:
135: std :: set < const Token * > mUninitDiags@var2142 ;
136: Check :: FileInfo * getFileInfo ( ) const ;
137: bool isUnsafeFunction ( const Scope * scope@var2143 , int argnr@var2144 , const Token * * tok@var2145 ) const ;
138:
139: void getErrorMessages ( ErrorLogger * errorLogger@var2146 , const Settings * settings@var2147 ) const override
140: {
141: CheckUninitVar c@var2148 (@expr1073749127 nullptr , settings@var2147 , errorLogger@var2146 ) ;
142:
143: ValueFlow ::@expr1073749128 Value v@var2149 {@expr1073749129 } ;
144:
145:
146: c@var2148 .@expr1073749130 uninitvarError (@expr1073749131 nullptr , v@var2149 ) ;
147: c@var2148 .@expr1073749132 uninitstringError (@expr1073749133 nullptr , "varname" , true ) ;
148: c@var2148 .@expr1073749134 uninitdataError (@expr1073749135 nullptr , "varname" ) ;
149: c@var2148 .@expr1073749136 uninitStructMemberError (@expr1073749137 nullptr , "a.b" ) ;
150: }
151:
152: static std :: string myName ( ) {
153: return "Uninitialized variables" ;
154: }
155:
156: std :: string classInfo ( ) const override {
157: return "Uninitialized variables\n- using uninitialized local variables\n- using allocated data before it has been initialized\n"
158:
159: ;
160: }
161: } ;

##file cppcheck-2.8/lib/forwardanalyzer.h

1:
|
23:
24: class Settings ;
25: class Token ;
26: template < class T > class ValuePtr ;
27:
28: Analyzer :: Result valueFlowGenericForward ( Token * start@var2150 ,
29: const Token * end@var2151 ,
30: const ValuePtr<Analyzer> & a@var2152 ,
31: const Settings * settings@var2153 ) ;
32:
33: Analyzer :: Result valueFlowGenericForward ( Token * start@var2154 , const ValuePtr<Analyzer> & a@var2155 , const Settings * settings@var2156 ) ;

##file cppcheck-2.8/lib/infer.h

1:
|
29:
30: struct Interval ;
31: template < class T > class ValuePtr ;
32:
33: struct InferModel {
34: virtual bool match ( const ValueFlow :: Value & value@var2157 ) const = 0 ;
35: virtual ValueFlow :: Value yield ( long long value@var2158 ) const = 0 ;
36: virtual ~ InferModel ( ) { }
37: } ;
38:
39: std :: vector < ValueFlow :: Value > infer ( const ValuePtr<InferModel> & model@var2159 ,
40: const std :: string & op@var2160 ,
41: std :: list < ValueFlow :: Value > lhsValues@var2161 ,
42: std :: list < ValueFlow :: Value > rhsValues@var2162 ) ;
43:
44: std :: vector < ValueFlow :: Value > infer ( const ValuePtr<InferModel> & model@var2163 ,
45: const std :: string & op@var2164 ,
46: long long lhs@var2165 ,
47: std :: list < ValueFlow :: Value > rhsValues@var2166 ) ;
48:
49: std :: vector < ValueFlow :: Value > infer ( const ValuePtr<InferModel> & model@var2167 ,
50: const std :: string & op@var2168 ,
51: std :: list < ValueFlow :: Value > lhsValues@var2169 ,
52: long long rhs@var2170 ) ;
53:
54: std :: vector < long long > getMinValue ( const ValuePtr<InferModel> & model@var2171 , const std :: list < ValueFlow :: Value > & values@var2172 ) ;
55: std :: vector < long long > getMaxValue ( const ValuePtr<InferModel> & model@var2173 , const std :: list < ValueFlow :: Value > & values@var2174 ) ;
56:
57: std :: string toString ( const Interval & i@var2175 ) ;

##file cppcheck-2.8/lib/path.h

1:
|
39:
40: class Path {
41: public:
42:
|
46:
47: static std :: string toNativeSeparators ( std :: string path@var2176 ) ;
48:
|
53:
54: static std :: string fromNativeSeparators ( std :: string path@var2177 ) ;
55:
|
60:
61: static std :: string simplifyPath ( std :: string originalPath@var2178 ) ;
62:
|
67:
68: static std :: string getPathFromFilename ( const std :: string & filename@var2179 ) ;
69:
|
76:
77: static bool sameFileName ( const std :: string & fname1@var2180 , const std :: string & fname2@var2181 ) ;
78:
|
83:
84: static std :: string removeQuotationMarks ( std :: string path@var2182 ) ;
85:
|
90:
91: static std :: string getFilenameExtension ( const std :: string & path@var2183 ) ;
92:
|
97:
98: static std :: string getFilenameExtensionInLowerCase ( const std :: string & path@var2184 ) ;
99:
|
103:
104: static std :: string getCurrentPath ( ) ;
105:
|
110:
111: static bool isAbsolute ( const std :: string & path@var2185 ) ;
112:
|
118:
119: static std :: string getRelativePath ( const std :: string & absolutePath@var2186 , const std :: vector < std :: string > & basePaths@var2187 ) ;
120:
|
125:
126: static std :: string getAbsoluteFilePath ( const std :: string & filePath@var2188 ) ;
127:
|
133:
134: static bool acceptFile ( const std :: string & filename@var2189 ) {
135: const std ::@expr1073749138 set < std ::@expr1073749139 string > extra@var2190 ;
136: return acceptFile (@expr1073749140 filename@var2189 , extra@var2190 ) ;
137: }
138:
|
145:
146: static bool acceptFile ( const std :: string & path@var2191 , const std :: set < std :: string > & extra@var2192 ) ;
147:
|
152:
153: static bool isC ( const std :: string & path@var2193 ) ;
154:
|
159:
160: static bool isCPP ( const std :: string & path@var2194 ) ;
161:
|
166:
167: static bool isHeader ( const std :: string & path@var2195 ) ;
168:
|
173:
174: static std :: string stripDirectoryPart ( const std :: string & file@var2196 ) ;
175:
|
180:
181: static bool fileExists ( const std :: string & file@var2197 ) ;
182: } ;

##file cppcheck-2.8/lib/platform.h

1:
|
31:
32: namespace tinyxml2 {
33: class XMLDocument ;
34: }
35:
36: namespace cppcheck {
37:
|
40:
41: class Platform {
42: private:
43: static long long min_value ( int bit@var2198 ) {
44: if (@expr1073749141 bit@var2198 >=@expr1073749142 64 ) {
45: return LLONG_MIN ; }
46: return -@expr1073749143 (@expr1073749144 1LL <<@expr1073749145 (@expr1073749146 bit@var2198 -@expr1073749147 1 ) ) ;
47: }
48:
49: static long long max_value ( int bit@var2199 ) {
50: if (@expr1073749148 bit@var2199 >=@expr1073749149 64 ) {
51: return (@expr7326 ~@expr1073749151 0ULL ) >>@expr1073749152 1 ; }
52: return (@expr7326 1LL <<@expr1073749154 (@expr7326 bit@var2199 -@expr1073749156 1 ) ) -@expr1073749157 1LL ;
53: }
54: public:
55: Platform ( ) ;
56: virtual ~ Platform ( ) { }
57:
58: bool isIntValue ( long long value@var2200 ) const {
59: return value@var2200 >=@expr1073749158 min_value (@expr1073749159 int_bit@var2210 ) &&@expr1073749160 value@var2200 <=@expr1073749161 max_value (@expr1073749162 int_bit@var2210 ) ;
60: }
61:
62: bool isIntValue ( unsigned long long value@var2201 ) const {
63: unsigned long long intMax@var2202 ; intMax@var2202 =@expr1073749163 max_value (@expr1073749164 int_bit@var2210 ) ;
64: return value@var2201 <=@expr1073749165 intMax@var2202 ;
65: }
66:
67: bool isLongValue ( long long value@var2203 ) const {
68: return value@var2203 >=@expr1073749166 min_value (@expr1073749167 long_bit@var2211 ) &&@expr1073749168 value@var2203 <=@expr1073749169 max_value (@expr1073749170 long_bit@var2211 ) ;
69: }
70:
71: bool isLongValue ( unsigned long long value@var2204 ) const {
72: unsigned long long longMax@var2205 ; longMax@var2205 =@expr1073749171 max_value (@expr1073749172 long_bit@var2211 ) ;
73: return value@var2204 <=@expr1073749173 longMax@var2205 ;
74: }
75:
76: bool isLongLongValue ( unsigned long long value@var2206 ) const {
77: unsigned long long longLongMax@var2207 ; longLongMax@var2207 =@expr1073749174 max_value (@expr1073749175 long_long_bit@var2212 ) ;
78: return value@var2206 <=@expr1073749176 longLongMax@var2207 ;
79: }
80:
81: int char_bit@var2208 ;
82: int short_bit@var2209 ;
83: int int_bit@var2210 ;
84: int long_bit@var2211 ;
85: int long_long_bit@var2212 ;
86:
87:
88: int sizeof_bool@var2213 ;
89: int sizeof_short@var2214 ;
90: int sizeof_int@var2215 ;
91: int sizeof_long@var2216 ;
92: int sizeof_long_long@var2217 ;
93: int sizeof_float@var2218 ;
94: int sizeof_double@var2219 ;
95: int sizeof_long_double@var2220 ;
96: int sizeof_wchar_t@var2221 ;
97: int sizeof_size_t@var2222 ;
98: int sizeof_pointer@var2223 ;
99:
100: char defaultSign@var2224 ;
101:
102: enum PlatformType {
103: Unspecified ,
104: Native ,
105: Win32A ,
106: Win32W ,
107: Win64 ,
108: Unix32 ,
109: Unix64 ,
110: PlatformFile
111: } ;
112:
113:
114: PlatformType platformType@var2225 ;
115:
116:
117: bool platform ( PlatformType type@var2226 ) ;
118:
|
124:
125: bool loadPlatformFile ( const char exename@var2227 [ ] , const std :: string & filename@var2228 ) ;
126:
127:
128: bool loadFromXmlDocument ( const tinyxml2 :: XMLDocument * doc@var2229 ) ;
129:
|
133:
134: bool isWindowsPlatform ( ) const {
135: return platformType@var2225 ==@expr1073749177 Win32A ||@expr1073749178
136: platformType@var2225 ==@expr1073749179 Win32W ||@expr1073749180
137: platformType@var2225 ==@expr1073749181 Win64 ;
138: }
139:
140: const char * platformString ( ) const {
141: return platformString (@expr1073749182 platformType@var2225 ) ;
142: }
143:
144: static const char * platformString ( PlatformType pt@var2230 ) {
145: switch (@expr1073749183 pt@var2230 ) {
146: case Unspecified :@expr7360 ;
147: return "Unspecified" ;
148: case Native :@expr7360 ;
149: return "Native" ;
150: case Win32A :@expr7360 ;
151: return "win32A" ;
152: case Win32W :@expr7360 ;
153: return "win32W" ;
154: case Win64 :@expr7360 ;
155: return "win64" ;
156: case Unix32 :@expr7360 ;
157: return "unix32" ;
158: case Unix64 :@expr7360 ;
159: return "unix64" ;
160: case PlatformFile :@expr7360 ;
161: return "platformFile" ;
162: default :@expr7360 ;
163: return "unknown" ;
164: }
165: }
166:
167: long long unsignedCharMax ( ) const {
168: return max_value (@expr1073749193 char_bit@var2208 +@expr1073749194 1 ) ;
169: }
170:
171: long long signedCharMax ( ) const {
172: return max_value (@expr1073749195 char_bit@var2208 ) ;
173: }
174:
175: long long signedCharMin ( ) const {
176: return min_value (@expr1073749196 char_bit@var2208 ) ;
177: }
178: } ;
179:
180: }

##file cppcheck-2.8/lib/programmemory.h

1:
|
31:
32: class Token ;
33: class Settings ;
34:
35:
36: struct ExprIdToken {
37: const Token * tok@var2231 ; tok@var2231 = nullptr ;
38: int exprid@var2232 ; exprid@var2232 = 0 ;
39:
40: ExprIdToken ( ) = default ;
41:
42: ExprIdToken ( const Token * tok@var2233 ) : tok@var2231 ( tok@var2233 ) { }
43:
44:
45: ExprIdToken ( int exprid@var2234 ) : exprid@var2232 ( exprid@var2234 ) { }
46:
47: int getExpressionId ( ) const ;
48:
49: bool operator== ( const ExprIdToken & rhs@var2235 ) const {
50: return getExpressionId (@expr1073749197 ) ==@expr1073749198 rhs@var2235 .@expr1073749199 getExpressionId (@expr1073749200 ) ;
51: }
52:
53: template < class T , class U >
54: friend bool operator!= ( const T & lhs@var2236 , const U & rhs@var2237 )
55: {
56: return !@expr1073749201 (@expr1073749202 lhs@var2236 ==@expr1073749203 rhs@var2237 ) ;
57: }
58:
59: struct Hash {
60: unsigned long operator() ( ExprIdToken etok@var2238 ) const ;
61: } ;
62: } ;
63:
64: struct ProgramMemory {
65:
66:
67: ProgramMemory ( ) = default ;
68:
69: explicit ProgramMemory ( const std :: unordered_map < ExprIdToken , ValueFlow :: Value , ExprIdToken :: Hash > & values@var2239 ) : mValues@var2266 ( values@var2239 ) { }
70:
71: void setValue ( const Token * expr@var2240 , const ValueFlow :: Value & value@var2241 ) ;
72: const ValueFlow :: Value * getValue ( int exprid@var2242 , bool impossible@var2243 = false ) const ;
73:
74: bool getIntValue ( int exprid@var2244 , long long * result@var2245 ) const ;
75: void setIntValue ( const Token * expr@var2246 , long long value@var2247 , bool impossible@var2248 = false ) ;
76:
77: bool getContainerSizeValue ( int exprid@var2249 , long long * result@var2250 ) const ;
78: bool getContainerEmptyValue ( int exprid@var2251 , long long * result@var2252 ) const ;
79: void setContainerSizeValue ( const Token * expr@var2253 , long long value@var2254 , bool isEqual@var2255 = true ) ;
80:
81: void setUnknown ( const Token * expr@var2256 ) ;
82:
83: bool getTokValue ( int exprid@var2257 , const Token * * result@var2258 ) const ;
84: bool hasValue ( int exprid@var2259 ) ;
85:
86: const ValueFlow :: Value & at ( int exprid@var2260 ) const ;
87: ValueFlow :: Value & at ( int exprid@var2261 ) ;
88:
89: void erase_if ( const std :: function < bool ( const ExprIdToken & ) > & pred@var2262 ) ;
90:
91: void swap ( ProgramMemory & pm@var2263 ) ;
92:
93: void clear ( ) ;
94:
95: bool empty ( ) const ;
96:
97: void replace ( const ProgramMemory & pm@var2264 ) ;
98:
99: void insert ( const ProgramMemory & pm@var2265 ) ;
100:
101: std :: unordered_map < ExprIdToken , ValueFlow :: Value , ExprIdToken :: Hash > :: iterator begin ( ) {
102: return mValues@var2266 .@expr1073749204 begin (@expr1073749205 ) ;
103: }
104:
105: std :: unordered_map < ExprIdToken , ValueFlow :: Value , ExprIdToken :: Hash > :: iterator end ( ) {
106: return mValues@var2266 .@expr1073749206 end (@expr1073749207 ) ;
107: }
108:
109: std :: unordered_map < ExprIdToken , ValueFlow :: Value , ExprIdToken :: Hash > :: const_iterator begin ( ) const {
110: return mValues@var2266 .@expr1073749208 begin (@expr1073749209 ) ;
111: }
112:
113: std :: unordered_map < ExprIdToken , ValueFlow :: Value , ExprIdToken :: Hash > :: const_iterator end ( ) const {
114: return mValues@var2266 .@expr1073749210 end (@expr1073749211 ) ;
115: }
116:
117: private:
118: std :: unordered_map < ExprIdToken , ValueFlow :: Value , ExprIdToken :: Hash > mValues@var2266 ;
119: } ;
120:
121: void programMemoryParseCondition ( ProgramMemory & pm@var2267 , const Token * tok@var2268 , const Token * endTok@var2269 , const Settings * settings@var2270 , bool then@var2271 ) ;
122:
123: struct ProgramMemoryState {
124: ProgramMemory state@var2272 ;
125: std :: map < int , const Token * > origins@var2273 ;
126: const Settings * settings@var2274 ;
127:
128: explicit ProgramMemoryState ( const Settings * s@var2275 ) ;
129:
130: void insert ( const ProgramMemory & pm@var2276 , const Token * origin@var2277 = nullptr ) ;
131: void replace ( const ProgramMemory & pm@var2278 , const Token * origin@var2279 = nullptr ) ;
132:
133: void addState ( const Token * tok@var2280 , const std :: unordered_map < ExprIdToken , ValueFlow :: Value , ExprIdToken :: Hash > & vars@var2281 ) ;
134:
135: void assume ( const Token * tok@var2282 , bool b@var2283 , bool isEmpty@var2284 = false ) ;
136:
137: void removeModifiedVars ( const Token * tok@var2285 ) ;
138:
139: ProgramMemory get ( const Token * tok@var2286 , const Token * ctx@var2287 , const std :: unordered_map < ExprIdToken , ValueFlow :: Value , ExprIdToken :: Hash > & vars@var2288 ) const ;
140: } ;
141:
142: void execute ( const Token * expr@var2289 ,
143: ProgramMemory * const programMemory@var2290 ,
144: long long * result@var2291 ,
145: bool * error@var2292 ,
146: const Settings * settings@var2293 = nullptr ) ;
147:
|
152:
153: bool conditionIsFalse ( const Token * condition@var2294 , ProgramMemory pm@var2295 , const Settings * settings@var2296 = nullptr ) ;
154:
|
159:
160: bool conditionIsTrue ( const Token * condition@var2297 , ProgramMemory pm@var2298 , const Settings * settings@var2299 = nullptr ) ;
161:
|
164:
165: ProgramMemory getProgramMemory ( const Token * tok@var2300 , const Token * expr@var2301 , const ValueFlow :: Value & value@var2302 , const Settings * settings@var2303 ) ;
166:
167: ProgramMemory getProgramMemory ( const Token * tok@var2304 , const std :: unordered_map < ExprIdToken , ValueFlow :: Value , ExprIdToken :: Hash > & vars@var2305 ) ;
168:
169: ValueFlow :: Value evaluateLibraryFunction ( const std :: unordered_map < int , ValueFlow :: Value > & args@var2306 ,
170: const std :: string & returnValue@var2307 ,
171: const Settings * settings@var2308 ) ;

##file cppcheck-2.8/lib/reverseanalyzer.h

1:
|
21:
22: struct Analyzer ;
23: class Settings ;
24: class Token ;
25:
26:
27:
28: void valueFlowGenericReverse ( Token * start@var2309 , const ValuePtr<Analyzer> & a@var2310 , const Settings * settings@var2311 ) ;
29: void valueFlowGenericReverse ( Token * start@var2312 , const Token * end@var2313 , const ValuePtr<Analyzer> & a@var2314 , const Settings * settings@var2315 ) ;

##file cppcheck-2.8/lib/importproject.h

1:
|
37:
38: namespace cppcheck {
39: struct stricmp {
40: bool operator() ( const std :: string & lhs@var2316 , const std :: string & rhs@var2317 ) const {
41: return caseInsensitiveStringCompare (@expr1073749212 lhs@var2316 , rhs@var2317 ) <@expr1073749213 0 ;
42: }
43: } ;
44: }
45:
46: class Settings ;
47:
|
50:
51: class ImportProject {
52: public:
53: enum class Type {
54: UNKNOWN ,
55: MISSING ,
56: FAILURE ,
57: COMPILE_DB ,
58: VS_SLN ,
59: VS_VCXPROJ ,
60: BORLAND ,
61: CPPCHECK_GUI
62: } ;
63:
64:
65: struct FileSettings {
66: FileSettings ( ) : platformType@var2325 ( cppcheck :: Platform :: Unspecified ) , msc@var2326 ( false ) , useMfc@var2327 ( false ) { }
67: std :: string cfg@var2318 ;
68: std :: string filename@var2319 ;
69: std :: string defines@var2320 ;
70: std :: string cppcheckDefines ( ) const {
71: return defines@var2320 +@expr1073749214 (@expr1073749215 msc@var2326 ?@expr1073749216 ";_MSC_VER=1900" :@expr1073749217 "" ) +@expr1073749218 (@expr1073749219 useMfc@var2327 ?@expr1073749220 ";__AFXWIN_H__=1" :@expr1073749221 "" ) ;
72: }
73: std :: set < std :: string > undefs@var2321 ;
74: std :: list < std :: string > includePaths@var2322 ;
75: std :: list < std :: string > systemIncludePaths@var2323 ;
76: std :: string standard@var2324 ;
77: cppcheck :: Platform :: PlatformType platformType@var2325 ;
78: bool msc@var2326 ;
79: bool useMfc@var2327 ;
80:
81: void parseCommand ( std :: string command@var2328 ) ;
82: void setDefines ( std :: string defs@var2329 ) ;
83: void setIncludePaths ( const std :: string & basepath@var2330 , const std :: list < std :: string > & in@var2331 , std :: map < std :: string , std :: string , cppcheck :: stricmp > & variables@var2332 ) ;
84: } ;
85: std :: list < FileSettings > fileSettings@var2333 ;
86: Type projectType@var2334 ;
87:
88: ImportProject ( ) ;
89:
90: void selectOneVsConfig ( cppcheck :: Platform :: PlatformType platform@var2335 ) ;
91:
92: std :: list < std :: string > getVSConfigs ( ) ;
93:
94:
95: struct Anonymous6 {
96: std :: string analyzeAllVsConfigs@var2336 ;
97: std :: vector < std :: string > pathNames@var2337 ;
98: std :: list < std :: string > libraries@var2338 ;
99: std :: list < std :: string > excludedPaths@var2339 ;
100: std :: list < std :: string > checkVsConfigs@var2340 ;
101: std :: string projectFile@var2341 ;
102: std :: string platform@var2342 ;
103: } ; struct Anonymous6 guiProject@var2343 ;
104:
105: void ignorePaths ( const std :: vector < std :: string > & ipaths@var2344 ) ;
106: void ignoreOtherConfigs ( const std :: string & cfg@var2345 ) ;
107:
108: Type import ( const std :: string & filename@var2346 , Settings * settings@var2347 = nullptr ) ;
109: protected:
110: bool importCompileCommands ( std :: istream & istr@var2348 ) ;
111: bool importCppcheckGuiProject ( std :: istream & istr@var2349 , Settings * settings@var2350 ) ;
112: virtual bool sourceFileExists ( const std :: string & file@var2351 ) ;
113: private:
114: bool importSln ( std :: istream & istr@var2352 , const std :: string & path@var2353 , const std :: vector < std :: string > & fileFilters@var2354 ) ;
115: bool importVcxproj ( const std :: string & filename@var2355 , std :: map < std :: string , std :: string , cppcheck :: stricmp > & variables@var2356 , const std :: string & additionalIncludeDirectories@var2357 , const std :: vector < std :: string > & fileFilters@var2358 ) ;
116: bool importBcb6Prj ( const std :: string & projectFilename@var2359 ) ;
117:
118: static void printError ( const std :: string & message@var2360 ) ;
119:
120: void setRelativePaths ( const std :: string & filename@var2361 ) ;
121:
122: std :: string mPath@var2362 ;
123: std :: set < std :: string > mAllVSConfigs@var2363 ;
124: } ;
125:
126:
127: namespace CppcheckXml {
128: const char ProjectElementName@var2364 [ 8 ] = "project" ;
129: const char ProjectVersionAttrib@var2365 [ 8 ] = "version" ;
130: const char ProjectFileVersion@var2366 [ 2 ] = "1" ;
131: const char BuildDirElementName@var2367 [ 9 ] = "builddir" ;
132: const char ImportProjectElementName@var2368 [ 14 ] = "importproject" ;
133: const char AnalyzeAllVsConfigsElementName@var2369 [ 23 ] = "analyze-all-vs-configs" ;
134: const char Parser@var2370 [ 7 ] = "parser" ;
135: const char BugHunting@var2371 [ 12 ] = "bug-hunting" ;
136: const char IncludeDirElementName@var2372 [ 11 ] = "includedir" ;
137: const char DirElementName@var2373 [ 4 ] = "dir" ;
138: const char DirNameAttrib@var2374 [ 5 ] = "name" ;
139: const char DefinesElementName@var2375 [ 8 ] = "defines" ;
140: const char DefineName@var2376 [ 7 ] = "define" ;
141: const char DefineNameAttrib@var2377 [ 5 ] = "name" ;
142: const char UndefinesElementName@var2378 [ 10 ] = "undefines" ;
143: const char UndefineName@var2379 [ 9 ] = "undefine" ;
144: const char PathsElementName@var2380 [ 6 ] = "paths" ;
145: const char PathName@var2381 [ 4 ] = "dir" ;
146: const char PathNameAttrib@var2382 [ 5 ] = "name" ;
147: const char RootPathName@var2383 [ 5 ] = "root" ;
148: const char RootPathNameAttrib@var2384 [ 5 ] = "name" ;
149: const char IgnoreElementName@var2385 [ 7 ] = "ignore" ;
150: const char IgnorePathName@var2386 [ 5 ] = "path" ;
151: const char IgnorePathNameAttrib@var2387 [ 5 ] = "name" ;
152: const char ExcludeElementName@var2388 [ 8 ] = "exclude" ;
153: const char ExcludePathName@var2389 [ 5 ] = "path" ;
154: const char ExcludePathNameAttrib@var2390 [ 5 ] = "name" ;
155: const char FunctionContracts@var2391 [ 19 ] = "function-contracts" ;
156: const char VariableContractsElementName@var2392 [ 19 ] = "variable-contracts" ;
157: const char LibrariesElementName@var2393 [ 10 ] = "libraries" ;
158: const char LibraryElementName@var2394 [ 8 ] = "library" ;
159: const char PlatformElementName@var2395 [ 9 ] = "platform" ;
160: const char SuppressionsElementName@var2396 [ 13 ] = "suppressions" ;
161: const char SuppressionElementName@var2397 [ 12 ] = "suppression" ;
162: const char AddonElementName@var2398 [ 6 ] = "addon" ;
163: const char AddonsElementName@var2399 [ 7 ] = "addons" ;
164: const char ToolElementName@var2400 [ 5 ] = "tool" ;
165: const char ToolsElementName@var2401 [ 6 ] = "tools" ;
166: const char TagsElementName@var2402 [ 5 ] = "tags" ;
167: const char TagElementName@var2403 [ 4 ] = "tag" ;
168: const char TagWarningsElementName@var2404 [ 13 ] = "tag-warnings" ;
169: const char TagAttributeName@var2405 [ 4 ] = "tag" ;
170: const char WarningElementName@var2406 [ 8 ] = "warning" ;
171: const char HashAttributeName@var2407 [ 5 ] = "hash" ;
172: const char CheckHeadersElementName@var2408 [ 14 ] = "check-headers" ;
173: const char CheckUnusedTemplatesElementName@var2409 [ 23 ] = "check-unused-templates" ;
174: const char MaxCtuDepthElementName@var2410 [ 14 ] = "max-ctu-depth" ;
175: const char MaxTemplateRecursionElementName@var2411 [ 23 ] = "max-template-recursion" ;
176: const char CheckUnknownFunctionReturn@var2412 [ 37 ] = "check-unknown-function-return-values" ;
177: const char ClangTidy@var2413 [ 11 ] = "clang-tidy" ;
178: const char Name@var2414 [ 5 ] = "name" ;
179: const char VSConfigurationElementName@var2415 [ 18 ] = "vs-configurations" ;
180: const char VSConfigurationName@var2416 [ 7 ] = "config" ;
181: }

##file cppcheck-2.8/lib/timer.h

1:
|
28:
29: enum class SHOWTIME_MODES {
30: SHOWTIME_NONE = 0 ,
31: SHOWTIME_FILE ,
32: SHOWTIME_SUMMARY ,
33: SHOWTIME_TOP5
34: } ;
35:
36: class TimerResultsIntf {
37: public:
38: virtual ~ TimerResultsIntf ( ) { }
39:
40: virtual void addResults ( const std :: string & str@var2417 , std :: clock_t clocks@var2418 ) = 0 ;
41: } ;
42:
43: struct TimerResultsData {
44: std :: clock_t mClocks@var2419 ;
45: long mNumberOfResults@var2420 ;
46:
47: TimerResultsData ( )
48: : mClocks@var2419 ( 0 )
49: , mNumberOfResults@var2420 ( 0 ) { }
50:
51: double seconds ( ) const {
52: const double ret@var2421 =@expr1073749223 (@expr1073749224 double ) (@expr1073749225 (@expr1073749226 unsigned long ) mClocks@var2419 ) /@expr1073749227 (@expr1073749228 double ) CLOCKS_PER_SEC@expr1073749222 ;
53: return ret@var2421 ;
54: }
55: } ;
56:
57: class TimerResults : public TimerResultsIntf {
58: public:
59: TimerResults ( ) { }
60:
61: void showResults ( SHOWTIME_MODES mode@var2422 ) const ;
62: void addResults ( const std :: string & str@var2423 , std :: clock_t clocks@var2424 ) override ;
63:
64: private:
65: std :: map < std :: string , TimerResultsData > mResults@var2425 ;
66: } ;
67:
68: class Timer {
69: public:
70: Timer ( const std :: string & str@var2426 , SHOWTIME_MODES showtimeMode@var2427 , TimerResultsIntf * timerResults@var2428 = nullptr ) ;
71: ~ Timer ( ) ;
72: void stop ( ) ;
73:
74: private:
75: Timer ( const Timer & other@var2429 ) ;
76: Timer & operator= ( const Timer & ) ;
77:
78: const std :: string mStr@var2430 ;
79: TimerResultsIntf * mTimerResults@var2431 ;
80: std :: clock_t mStart@var2432 ;
81: const SHOWTIME_MODES mShowTimeMode@var2433 ;
82: bool mStopped@var2434 ;
83: } ;

##file cppcheck-2.8/lib/settings.h

1:
|
40:
41: namespace ValueFlow {
42: class Value ;
43: }
44:
|
47:
48: class SimpleEnableGroup<Severity::SeverityType> ; class SimpleEnableGroup<Certainty::CertaintyLevel> ; class SimpleEnableGroup<Checks::CheckList> ;
49:
|
89:
90: class Settings : public cppcheck :: Platform {
91: private:
92:
93:
94: static std :: atomic < bool > mTerminated@var2435 ;
95:
96: public:
97: Settings ( ) ;
98:
99: void loadCppcheckCfg ( ) ;
100:
101:
102: std :: list < std :: string > addons@var2436 ;
103:
104:
105: std :: string addonPython@var2437 ;
106:
107:
108: std :: vector < std :: string > basePaths@var2438 ;
109:
110:
111: std :: string buildDir@var2439 ;
112:
113:
114: bool checkAllConfigurations@var2440 ;
115:
116:
117: bool checkConfiguration@var2441 ;
118:
|
121:
122: bool checkHeaders@var2442 ;
123:
124:
125: bool checkLibrary@var2443 ;
126:
127:
128: std :: set < std :: string > checkUnknownFunctionReturn@var2444 ;
129:
130:
131: bool checkUnusedTemplates@var2445 ;
132:
133:
134: bool clang@var2446 ;
135:
136:
137: std :: string clangExecutable@var2447 ;
138:
139:
140: bool clangTidy@var2448 ;
141:
142:
143: std :: set < std :: string > configExcludePaths@var2449 ;
144:
145:
146: std :: string cppcheckCfgProductName@var2450 ;
147:
148:
149: std :: string cppcheckCfgAbout@var2451 ;
150:
151:
152: bool daca@var2452 ;
153:
154:
155: bool debugnormal@var2453 ;
156:
157:
158: bool debugSimplified@var2454 ;
159:
160:
161: bool debugtemplate@var2455 ;
162:
163:
164: bool debugwarnings@var2456 ;
165:
166:
167: bool dump@var2457 ;
168: std :: string dumpFile@var2458 ;
169:
170: enum Language {
171: None , C , CPP
172: } ;
173:
174:
175: Language enforcedLang@var2459 ;
176:
177:
178: bool exceptionHandling@var2460 ;
179:
180:
181: std :: string exename@var2461 ;
182:
183:
184:
185: int exitCode@var2462 ;
186:
187:
188: std :: vector < std :: string > fileFilters@var2463 ;
189:
190:
191: bool force@var2464 ;
192:
193:
194:
195: std :: list < std :: string > includePaths@var2465 ;
196:
197:
198: bool inlineSuppressions@var2466 ;
199:
200:
201:
202: unsigned int jobs@var2467 ;
203:
|
206:
207: bool jointSuppressionReport@var2468 ;
208:
209:
210: std :: list < std :: string > libraries@var2469 ;
211:
212:
213: Library library@var2470 ;
214:
215:
216:
217: int loadAverage@var2471 ;
218:
|
221:
222: int maxConfigs@var2472 ;
223:
224:
225: int maxCtuDepth@var2473 ;
226:
227:
228: int maxTemplateRecursion@var2474 ;
229:
230:
231: Suppressions nofail@var2475 ;
232:
233:
234: Suppressions nomsg@var2476 ;
235:
236:
237: std :: string outputFile@var2477 ;
238:
239:
240: std :: string plistOutput@var2478 ;
241:
242:
243: bool preprocessOnly@var2479 ;
244:
245: ImportProject project@var2480 ;
246:
247:
248: bool quiet@var2481 ;
249:
250:
251: bool relativePaths@var2482 ;
252:
253:
254: bool reportProgress@var2483 ;
255:
256:
257: class Rule {
258: public:
259: Rule ( )
260: : tokenlist@var2484 ( "simple" )
261: , id@var2486 ( "rule" )
262: , severity@var2488 ( Severity :: style ) {
263: }
264:
265: std :: string tokenlist@var2484 ;
266: std :: string pattern@var2485 ;
267: std :: string id@var2486 ;
268: std :: string summary@var2487 ;
269: Severity :: SeverityType severity@var2488 ;
270: } ;
271:
|
274:
275: std :: list < Rule > rules@var2489 ;
276:
277:
278: class SafeChecks {
279: public:
280: SafeChecks ( ) : classes@var2495 ( false ) , externalFunctions@var2496 ( false ) , internalFunctions@var2497 ( false ) , externalVariables@var2498 ( false ) { }
281:
282: static const char XmlRootName@var2490 [ ] ;
283: static const char XmlClasses@var2491 [ ] ;
284: static const char XmlExternalFunctions@var2492 [ ] ;
285: static const char XmlInternalFunctions@var2493 [ ] ;
286: static const char XmlExternalVariables@var2494 [ ] ;
287:
288: void clear ( ) {
289: classes@var2495 =@expr1073749229 externalFunctions@var2496 =@expr1073749230 internalFunctions@var2497 =@expr1073749231 externalVariables@var2498 =@expr1073749232 false ;
290: }
291:
|
297:
298: bool classes@var2495 ;
299:
|
304:
305: bool externalFunctions@var2496 ;
306:
|
310:
311: bool internalFunctions@var2497 ;
312:
|
316:
317: bool externalVariables@var2498 ;
318: } ;
319:
320: SafeChecks safeChecks@var2499 ;
321:
322: SimpleEnableGroup<Severity::SeverityType> severity@var2500 ;
323: SimpleEnableGroup<Certainty::CertaintyLevel> certainty@var2501 ;
324: SimpleEnableGroup<Checks::CheckList> checks@var2502 ;
325:
326:
327: SHOWTIME_MODES showtime@var2503 ;
328:
329:
330: Standards standards@var2504 ;
331:
332:
333:
334: std :: string templateFormat@var2505 ;
335:
336:
337:
338: std :: string templateLocation@var2506 ;
339:
340:
341: std :: string userDefines@var2507 ;
342:
343:
344: std :: set < std :: string > userUndefs@var2508 ;
345:
346:
347: std :: list < std :: string > userIncludes@var2509 ;
348:
349:
350: bool verbose@var2510 ;
351:
352:
353: bool xml@var2511 ;
354:
355:
356: int xml_version@var2512 ;
357:
|
361:
362: bool configurationExcluded ( const std :: string & file@var2513 ) const {
363: for (@expr1073749233 const std ::@expr1073749234 string &@expr1073749235 configExcludePath@var2514 :@expr1073749236 configExcludePaths@var2449 ) {
364: if (@expr1073749237 file@var2513 .@expr1073749238 length (@expr1073749239 ) >=@expr1073749240 configExcludePath@var2514 .@expr7417 length (@expr7418 ) &&@expr1073749243 file@var2513 .@expr1073749244 compare (@expr1073749245 0 , configExcludePath@var2514 .@expr7417 length (@expr7418 ) , configExcludePath@var2514 ) ==@expr1073749248 0 ) {
365: return true ;
366: }
367: }
368: return false ;
369: }
370:
|
376:
377: std :: string addEnabled ( const std :: string & str@var2515 ) ;
378:
|
382:
383: bool isEnabled ( const ValueFlow :: Value * value@var2516 , bool inconclusiveCheck@var2517 = false ) const ;
384:
385:
386: bool posix ( ) const {
387: return std ::@expr1073749249 find (@expr1073749250 libraries@var2469 .@expr1073749251 begin (@expr1073749252 ) , libraries@var2469 .@expr7429 end (@expr7430 ) , "posix" ) !=@expr1073749255 libraries@var2469 .@expr7429 end (@expr7430 ) ;
388: }
389:
390:
391: static void terminate ( bool t@var2518 = true ) {
392: Settings ::@expr1073749258 mTerminated@var2435 =@expr1073749259 t@var2518 ;
393: }
394:
395:
396: static bool terminated ( ) {
397: return Settings ::@expr1073749260 mTerminated@var2435 ;
398: }
399:
400: std :: set < std :: string > summaryReturn@var2519 ;
401:
402: void loadSummaries ( ) ;
403: } ;

##file cppcheck-2.8/lib/tokenlist.h

1:
|
31:
32: class Settings ;
33:
34: namespace simplecpp {
35: class TokenList ;
36: }
37:
|
40:
41: class TokenList {
42: public:
43: explicit TokenList ( const Settings * settings@var2520 ) ;
44: ~ TokenList ( ) ;
45:
46: void setSettings ( const Settings * settings@var2521 ) {
47: mSettings@var2556 =@expr1073749261 settings@var2521 ;
48: }
49:
50: const Settings * getSettings ( ) const {
51: return mSettings@var2556 ;
52: }
53:
54:
55: const std :: string & getSourceFilePath ( ) const ;
56:
57:
58: bool isC ( ) const {
59: return mIsC@var2558 ;
60: }
61:
62:
63: bool isCPP ( ) const {
64: return mIsCpp@var2559 ;
65: }
66:
|
70:
71: static void deleteTokens ( Token * tok@var2522 ) ;
72:
73: void addtoken ( const std :: string & str@var2523 , const int lineno@var2524 , const int column@var2525 , const int fileno@var2526 , bool split@var2527 = false ) ;
74: void addtoken ( const std :: string & str@var2528 , const Token * locationTok@var2529 ) ;
75:
76: void addtoken ( const Token * tok@var2530 , const int lineno@var2531 , const int column@var2532 , const int fileno@var2533 ) ;
77: void addtoken ( const Token * tok@var2534 , const Token * locationTok@var2535 ) ;
78: void addtoken ( const Token * tok@var2536 ) ;
79:
80: static void insertTokens ( Token * dest@var2537 , const Token * src@var2538 , int n@var2539 ) ;
81:
|
89:
90: static Token * copyTokens ( Token * dest@var2540 , const Token * first@var2541 , const Token * last@var2542 , bool one_line@var2543 = true ) ;
91:
|
100:
101: bool createTokens ( std :: istream & code@var2544 , const std :: string & file0@var2545 = emptyString@var1 ) ;
102:
103: void createTokens ( simplecpp :: TokenList && tokenList@var2546 ) ;
104:
105:
106: void deallocateTokens ( ) ;
107:
108:
109: int appendFileIfNew ( const std :: string & fileName@var2547 ) ;
110:
111:
112: const Token * front ( ) const {
113: return mTokensFrontBack@var2553 .@expr1073749262 front@var2560 ;
114: }
115: Token * front ( ) {
116: return mTokensFrontBack@var2553 .@expr1073749263 front@var2560 ;
117: }
118:
119:
120: const Token * back ( ) const {
121: return mTokensFrontBack@var2553 .@expr1073749264 back@var2561 ;
122: }
123: Token * back ( ) {
124: return mTokensFrontBack@var2553 .@expr1073749265 back@var2561 ;
125: }
126:
|
131:
132: const std :: vector < std :: string > & getFiles ( ) const {
133: return mFiles@var2554 ;
134: }
135:
136: std :: string getOrigFile ( const Token * tok@var2548 ) const ;
137:
|
142:
143: const std :: string & file ( const Token * tok@var2549 ) const ;
144:
|
149:
150: std :: string fileLine ( const Token * tok@var2550 ) const ;
151:
|
155:
156: unsigned long long calculateChecksum ( ) const ;
157:
|
160:
161: void createAst ( ) const ;
162:
|
166:
167: void validateAst ( ) const ;
168:
|
174:
175: bool validateToken ( const Token * tok@var2551 ) const ;
176:
|
181:
182: void simplifyPlatformTypes ( ) ;
183:
|
187:
188: void simplifyStdType ( ) ;
189:
190: void clangSetOrigFiles ( ) ;
191:
192: bool isKeyword ( const std :: string & str@var2552 ) const ;
193:
194: private:
195:
196:
197: TokenList ( const TokenList & ) ;
198:
199:
200: TokenList & operator= ( const TokenList & ) ;
201:
202: void determineCppC ( ) ;
203:
204:
205: TokensFrontBack mTokensFrontBack@var2553 ;
206:
207:
208: std :: vector < std :: string > mFiles@var2554 ;
209:
210:
211: std :: vector < std :: string > mOrigFiles@var2555 ;
212:
213:
214: const Settings * mSettings@var2556 ;
215:
216: std :: unordered_set < std :: string > mKeywords@var2557 ;
217:
218:
219: bool mIsC@var2558 ;
220: bool mIsCpp@var2559 ;
221: } ;

##file cppcheck-2.8/lib/valueptr.h

1:
|
27:
28: class ValuePtr<InferModel> ; class ValuePtr<Analyzer> ; class ValuePtr<ConditionHandler> ;

##file cppcheck-2.8/lib/valueflow.cpp

1:
|
123:
124: static void bailoutInternal ( const std :: string & type@var2562 , TokenList * tokenlist@var2563 , ErrorLogger * errorLogger@var2564 , const Token * tok@var2565 , const std :: string & what@var2566 , const std :: string & file@var2567 , int line@var2568 , std :: string function@var2569 )
125: {
126: if (@expr1073749267 function@var2569 .@expr1073749268 find (@expr1073749269 "operator" ) !=@expr1073749270 std ::@expr1073749271 string ::@expr1073749272 npos@expr1073749266 ) {
127: function@var2569 =@expr1073749273 "(valueFlow)" ; }
128: std ::@expr1073749274 list < ErrorMessage ::@expr1073749275 FileLocation > callstack@var2570 (@expr1073749276 1 , ErrorMessage ::@expr1073749277 FileLocation (@expr1073749278 tok@var2565 , tokenlist@var2563 ) ) ;
129: ErrorMessage errmsg@var2571 (@expr1073749279 callstack@var2570 , tokenlist@var2563 .@expr1073749280 getSourceFilePath (@expr1073749281 ) , Severity ::@expr1073749282 debug ,
130: Path ::@expr1073749283 stripDirectoryPart (@expr1073749284 file@var2567 ) +@expr1073749285 ":" +@expr1073749286 MathLib ::@expr1073749287 toString (@expr1073749288 line@var2568 ) +@expr1073749289 ":" +@expr1073749290 function@var2569 +@expr1073749291 " bailout: " +@expr1073749292 what@var2566 , type@var2562 , Certainty ::@expr1073749293 normal ) ;
131: errorLogger@var2564 .@expr1073749294 reportErr (@expr1073749295 errmsg@var2571 ) ;
132: }
133:
|
139:
140: static void changeKnownToPossible ( std :: list < ValueFlow :: Value > & values@var2572 , int indirect@var2573 = -1 )
141: {
142: for (@expr1073749296 ValueFlow ::@expr1073749297 Value &@expr1073749298 v@var2574 :@expr1073749299 values@var2572 ) {
143: if (@expr1073749300 indirect@var2573 >=@expr1073749301 0 &&@expr1073749302 v@var2574 .@expr1073749303 indirect@var2575 !=@expr1073749304 indirect@var2573 ) {
144: continue ; }
145: v@var2574 .@expr1073749305 changeKnownToPossible (@expr1073749306 ) ;
146: }
147: }
148:
149: static void removeImpossible ( std :: list < ValueFlow :: Value > & values@var2576 , int indirect@var2577 = -1 )
150: {
151: values@var2576 .@expr1073749307 remove_if (@expr1073749308 [@expr1073749309 &@expr7486 ] (@expr1073749311 const ValueFlow ::@expr1073749312 Value &@expr7486 v@var2578 ) {
152: if (@expr1073749314 indirect@var2577 >=@expr1073749315 0 &&@expr1073749316 v@var2578 .@expr1073749317 indirect@var2579 !=@expr1073749318 indirect@var2577 ) {
153: return false ; }
154: return v@var2578 .@expr1073749319 isImpossible (@expr1073749320 ) ;
155: } ) ;
156: }
157:
158: static void lowerToPossible ( std :: list < ValueFlow :: Value > & values@var2580 , int indirect@var2581 = -1 )
159: {
160: changeKnownToPossible (@expr1073749321 values@var2580 , indirect@var2581 ) ;
161: removeImpossible (@expr1073749322 values@var2580 , indirect@var2581 ) ;
162: }
163:
164: static void changePossibleToKnown ( std :: list < ValueFlow :: Value > & values@var2582 , int indirect@var2583 = -1 )
165: {
166: for (@expr1073749324 ValueFlow ::@expr1073749325 Value &@expr1073749326 v@var2584 :@expr1073749327 values@var2582 ) {
167: if (@expr1073749328 indirect@var2583 >=@expr1073749329 0 &&@expr1073749330 v@var2584 .@expr1073749331 indirect@var2585 !=@expr1073749332 indirect@var2583 ) {
168: continue ; }
169: if (@expr1073749333 !@expr1073749334 v@var2584 .@expr1073749335 isPossible (@expr1073749336 ) ) {
170: continue ; }
171: if (@expr1073749337 v@var2584 .@expr1073749338 bound@var2586 !=@expr1073749339 ValueFlow ::@expr1073749340 Value ::@expr1073749341 Bound ::@expr1073749342 Point@expr1073749323 ) {
172: continue ; }
173: v@var2584 .@expr1073749343 setKnown (@expr1073749344 ) ;
174: }
175: }
176:
177: static void setValueUpperBound ( ValueFlow :: Value & value@var2587 , bool upper@var2588 )
178: {
179: if (@expr1073749345 upper@var2588 ) {
180: value@var2587 .@expr7522 bound@var2589 =@expr1073749347 ValueFlow ::@expr7524 Value ::@expr7525 Bound ::@expr1073749350 Upper ; }
181: else {
182: value@var2587 .@expr7522 bound@var2589 =@expr1073749352 ValueFlow ::@expr7524 Value ::@expr7525 Bound ::@expr1073749355 Lower ; }
183: }
184:
185: static void setValueBound ( ValueFlow :: Value & value@var2590 , const Token * tok@var2591 , bool invert@var2592 )
186: {
187: if (@expr1073749356 Token ::@expr7533 Match (@expr1073749358 tok@var2591 , "<|<=" ) ) {
188: setValueUpperBound (@expr1073749359 value@var2590 , !@expr1073749360 invert@var2592 ) ;
189: } else { if (@expr1073749361 Token ::@expr7533 Match (@expr1073749363 tok@var2591 , ">|>=" ) ) {
190: setValueUpperBound (@expr1073749364 value@var2590 , invert@var2592 ) ;
191: } }
192: }
193:
194: static void setConditionalValues ( const Token * tok@var2593 ,
195: bool lhs@var2594 ,
196: long long value@var2595 ,
197: ValueFlow :: Value & true_value@var2596 ,
198: ValueFlow :: Value & false_value@var2597 )
199: {
200: if (@expr1073749365 Token ::@expr1073749366 Match (@expr1073749367 tok@var2593 , "==|!=|>=|<=" ) ) {
201: true_value@var2596 =@expr1073749368 ValueFlow ::@expr7545 Value {@expr1073749370 tok@var2593 , value@var2595 } ;
202: const char * greaterThan@var2598 ; greaterThan@var2598 =@expr1073749371 ">=" ;
203: const char * lessThan@var2599 ; lessThan@var2599 =@expr1073749372 "<=" ;
204: if (@expr7549 lhs@var2594 ) {
205: std ::@expr7550 swap (@expr1073749375 greaterThan@var2598 , lessThan@var2599 ) ; }
206: if (@expr1073749376 Token ::@expr7553 simpleMatch (@expr1073749378 tok@var2593 , greaterThan@var2598 , strlen (@expr1073749379 greaterThan@var2598 ) ) ) {
207: false_value@var2597 =@expr1073749380 ValueFlow ::@expr7545 Value {@expr1073749382 tok@var2593 , value@var2595 -@expr7559 1 } ;
208: } else { if (@expr1073749384 Token ::@expr7553 simpleMatch (@expr1073749386 tok@var2593 , lessThan@var2599 , strlen (@expr1073749387 lessThan@var2599 ) ) ) {
209: false_value@var2597 =@expr1073749388 ValueFlow ::@expr7545 Value {@expr1073749390 tok@var2593 , value@var2595 +@expr7567 1 } ;
210: } else {
211: false_value@var2597 =@expr1073749392 ValueFlow ::@expr7545 Value {@expr1073749394 tok@var2593 , value@var2595 } ;
212: } }
213: } else {
214: const char * greaterThan@var2600 ; greaterThan@var2600 =@expr1073749395 ">" ;
215: const char * lessThan@var2601 ; lessThan@var2601 =@expr1073749396 "<" ;
216: if (@expr7549 lhs@var2594 ) {
217: std ::@expr7550 swap (@expr1073749399 greaterThan@var2600 , lessThan@var2601 ) ; }
218: if (@expr1073749400 Token ::@expr7553 simpleMatch (@expr1073749402 tok@var2593 , greaterThan@var2600 , strlen (@expr1073749403 greaterThan@var2600 ) ) ) {
219: true_value@var2596 =@expr1073749404 ValueFlow ::@expr7545 Value {@expr1073749406 tok@var2593 , value@var2595 +@expr7567 1 } ;
220: false_value@var2597 =@expr1073749408 ValueFlow ::@expr7545 Value {@expr1073749410 tok@var2593 , value@var2595 } ;
221: } else { if (@expr1073749411 Token ::@expr7553 simpleMatch (@expr1073749413 tok@var2593 , lessThan@var2601 , strlen (@expr1073749414 lessThan@var2601 ) ) ) {
222: true_value@var2596 =@expr1073749415 ValueFlow ::@expr7545 Value {@expr1073749417 tok@var2593 , value@var2595 -@expr7559 1 } ;
223: false_value@var2597 =@expr1073749419 ValueFlow ::@expr7545 Value {@expr1073749421 tok@var2593 , value@var2595 } ;
224: } }
225: }
226: setValueBound (@expr1073749422 true_value@var2596 , tok@var2593 , lhs@var2594 ) ;
227: setValueBound (@expr1073749423 false_value@var2597 , tok@var2593 , !@expr1073749424 lhs@var2594 ) ;
228: }
229:
230: static bool isSaturated ( long long value@var2602 )
231: {
232: return value@var2602 ==@expr1073749425 std ::@expr7602 numeric_limits < long long > ::@expr1073749427 max (@expr1073749428 ) ||@expr1073749429 value@var2602 ==@expr1073749430 std ::@expr7602 numeric_limits < long long > ::@expr1073749432 min (@expr1073749433 ) ;
233: }
234:
235: const Token * parseCompareInt ( const Token * tok@var2603 , ValueFlow :: Value & true_value@var2604 , ValueFlow :: Value & false_value@var2605 , const std :: function < std :: vector < long long > ( const Token * ) > & evaluate@var2606 )
236: {
237: if (@expr1073749434 !@expr1073749435 tok@var2603 .@expr7612 astOperand1 (@expr7613 ) ||@expr1073749438 !@expr1073749439 tok@var2603 .@expr7616 astOperand2 (@expr7617 ) ) {
238: return nullptr ; }
239: if (@expr1073749442 tok@var2603 .@expr1073749443 isComparisonOp (@expr1073749444 ) ) {
240: std ::@expr1073749445 vector < long long > value1@var2607 ; value1@var2607 =@expr1073749446 evaluate@var2606 (@expr1073749447 tok@var2603 .@expr7612 astOperand1 (@expr7613 ) ) ;
241: std ::@expr1073749450 vector < long long > value2@var2608 ; value2@var2608 =@expr1073749451 evaluate@var2606 (@expr1073749452 tok@var2603 .@expr7616 astOperand2 (@expr7617 ) ) ;
242: if (@expr1073749455 !@expr7632 value1@var2607 .@expr7633 empty (@expr7634 ) &&@expr1073749459 !@expr7636 value2@var2608 .@expr7637 empty (@expr7638 ) ) {
243: if (@expr1073749463 tok@var2603 .@expr7612 astOperand1 (@expr7613 ) .@expr1073749466 hasKnownIntValue (@expr1073749467 ) ) {
244: value2@var2608 .@expr1073749468 clear (@expr1073749469 ) ; }
245: if (@expr1073749470 tok@var2603 .@expr7616 astOperand2 (@expr7617 ) .@expr1073749473 hasKnownIntValue (@expr1073749474 ) ) {
246: value1@var2607 .@expr1073749475 clear (@expr1073749476 ) ; }
247: }
248: if (@expr1073749477 !@expr7632 value1@var2607 .@expr7633 empty (@expr7634 ) ) {
249: if (@expr1073749481 isSaturated (@expr1073749482 value1@var2607 .@expr7659 front (@expr7660 ) ) ||@expr1073749485 astIsFloat (@expr1073749486 tok@var2603 .@expr7616 astOperand2 (@expr7617 ) , false ) ) {
250: return nullptr ; }
251: setConditionalValues (@expr1073749489 tok@var2603 , true , value1@var2607 .@expr7659 front (@expr7660 ) , true_value@var2604 , false_value@var2605 ) ;
252: return tok@var2603 .@expr7616 astOperand2 (@expr7617 ) ;
253: } else { if (@expr1073749494 !@expr7636 value2@var2608 .@expr7637 empty (@expr7638 ) ) {
254: if (@expr1073749498 isSaturated (@expr1073749499 value2@var2608 .@expr7676 front (@expr7677 ) ) ||@expr1073749502 astIsFloat (@expr1073749503 tok@var2603 .@expr7612 astOperand1 (@expr7613 ) , false ) ) {
255: return nullptr ; }
256: setConditionalValues (@expr1073749506 tok@var2603 , false , value2@var2608 .@expr7676 front (@expr7677 ) , true_value@var2604 , false_value@var2605 ) ;
257: return tok@var2603 .@expr7612 astOperand1 (@expr7613 ) ;
258: } }
259: }
260: return nullptr ;
261: }
262:
263: const Token * parseCompareInt ( const Token * tok@var2609 , ValueFlow :: Value & true_value@var2610 , ValueFlow :: Value & false_value@var2611 )
264: {
265: return parseCompareInt (@expr1073749512 tok@var2609 , true_value@var2610 , false_value@var2611 , [@expr1073749513 ] (@expr1073749514 const Token *@expr1073749515 t@var2612 ) .@expr1073749516 std ::@expr1073749517 vector < long long > {
266: if (@expr1073749518 t@var2612 .@expr1073749519 hasKnownIntValue (@expr1073749520 ) ) {
267: return {@expr1073749521 t@var2612 .@expr1073749522 values (@expr1073749523 ) .@expr1073749524 front (@expr1073749525 ) .@expr1073749526 intvalue@expr1073749511 } ; }
268: return std ::@expr1073749527 vector < long long > {@expr1073749528 } ;
269: } ) ;
270: }
271:
272: static bool isInConstructorList ( const Token * tok@var2613 )
273: {
274: if (@expr1073749529 !@expr1073749530 tok@var2613 ) {
275: return false ; }
276: if (@expr1073749531 !@expr1073749532 astIsRHS (@expr1073749533 tok@var2613 ) ) {
277: return false ; }
278: const Token * parent@var2614 ; parent@var2614 =@expr1073749534 tok@var2613 .@expr1073749535 astParent (@expr1073749536 ) ;
279: if (@expr1073749537 !@expr1073749538 Token ::@expr7715 Match (@expr1073749540 parent@var2614 , "{|(" ) ) {
280: return false ; }
281: if (@expr1073749541 !@expr1073749542 Token ::@expr7715 Match (@expr1073749544 parent@var2614 .@expr1073749545 previous (@expr1073749546 ) , "%var% {|(" ) ) {
282: return false ; }
283: if (@expr1073749547 !@expr1073749548 parent@var2614 .@expr1073749549 astOperand1 (@expr1073749550 ) ||@expr1073749551 !@expr1073749552 parent@var2614 .@expr1073749553 astOperand2 (@expr1073749554 ) ) {
284: return false ; }
285: do {
286: parent@var2614 =@expr1073749555 parent@var2614 .@expr7732 astParent (@expr7733 ) ;
287: } while (@expr1073749558 Token ::@expr7735 simpleMatch (@expr1073749560 parent@var2614 , "," ) ) ;
288: return Token ::@expr7735 simpleMatch (@expr1073749562 parent@var2614 , ":" ) &&@expr1073749563 !@expr1073749564 Token ::@expr7735 simpleMatch (@expr1073749566 parent@var2614 .@expr7732 astParent (@expr7733 ) , "?" ) ;
289: }
290:
291: static std :: vector < ValueType > getParentValueTypes ( const Token * tok@var2615 ,
292: const Settings * settings@var2616 = nullptr ,
293: const Token * * parent@var2617 = nullptr )
294: {
295: if (@expr1073749569 !@expr1073749570 tok@var2615 ) {
296: return { } ; }
297: if (@expr1073749571 !@expr1073749572 tok@var2615 .@expr7749 astParent (@expr7750 ) ) {
298: return { } ; }
299: if (@expr1073749575 isInConstructorList (@expr1073749576 tok@var2615 ) ) {
300: if (@expr1073749577 parent@var2617 ) {
301: *@expr7754 parent@var2617 =@expr1073749579 tok@var2615 .@expr7749 astParent (@expr7750 ) .@expr7758 astOperand1 (@expr7759 ) ; }
302: if (@expr1073749584 tok@var2615 .@expr7749 astParent (@expr7750 ) .@expr7758 astOperand1 (@expr7759 ) .@expr7765 valueType (@expr7766 ) ) {
303: return {@expr1073749591 *@expr1073749592 tok@var2615 .@expr7749 astParent (@expr7750 ) .@expr7758 astOperand1 (@expr7759 ) .@expr7765 valueType (@expr7766 ) } ; }
304: return { } ;
305: } else { if (@expr1073749599 Token ::@expr7776 Match (@expr1073749601 tok@var2615 .@expr7749 astParent (@expr7750 ) , "(|{|," ) ) {
306: int argn@var2618 ; argn@var2618 =@expr1073749604 -1 ;
307: const Token * ftok@var2619 ; ftok@var2619 =@expr1073749605 getTokenArgumentFunction (@expr1073749606 tok@var2615 , argn@var2618 ) ;
308: const Token * typeTok@var2620 ; typeTok@var2620 =@expr1073749607 nullptr ;
309: if (@expr1073749608 ftok@var2619 &&@expr1073749609 argn@var2618 >=@expr1073749610 0 ) {
310: if (@expr1073749611 ftok@var2619 .@expr1073749612 function (@expr1073749613 ) ) {
311: std ::@expr1073749614 vector < ValueType > result@var2621 ;
312: std ::@expr1073749615 vector < const Variable *@expr7792 > argsVars@var2622 ; argsVars@var2622 =@expr1073749617 getArgumentVars (@expr7794 ftok@var2619 , argn@var2618 ) ;
313: const Token * nameTok@var2623 ; nameTok@var2623 =@expr1073749619 nullptr ;
314: for (@expr1073749620 const Variable *@expr7792 var@var2624 :@expr1073749622 getArgumentVars (@expr7794 ftok@var2619 , argn@var2618 ) ) {
315: if (@expr1073749624 !@expr1073749625 var@var2624 ) {
316: continue ; }
317: if (@expr1073749626 !@expr1073749627 var@var2624 .@expr7804 valueType (@expr7805 ) ) {
318: continue ; }
319: nameTok@var2623 =@expr1073749630 var@var2624 .@expr1073749631 nameToken (@expr1073749632 ) ;
320: result@var2621 .@expr1073749633 push_back (@expr1073749634 *@expr1073749635 var@var2624 .@expr7804 valueType (@expr7805 ) ) ;
321: }
322: if (@expr1073749638 result@var2621 .@expr1073749639 size (@expr1073749640 ) ==@expr1073749641 1 &&@expr1073749642 nameTok@var2623 &&@expr1073749643 parent@var2617 ) {
323: *@expr7754 parent@var2617 =@expr1073749645 nameTok@var2623 ;
324: }
325: return result@var2621 ;
326: } else { if (@expr1073749646 const Type *@expr7792 t@var2625 =@expr1073749648 Token ::@expr1073749649 typeOf (@expr1073749650 ftok@var2619 , &@expr1073749651 typeTok@var2620 ) ) {
327: if (@expr1073749652 astIsPointer (@expr1073749653 typeTok@var2620 ) ) {
328: return {@expr1073749654 *@expr1073749655 typeTok@var2620 .@expr1073749656 valueType (@expr1073749657 ) } ; }
329: const Scope * scope@var2626 ; scope@var2626 =@expr1073749658 t@var2625 .@expr1073749659 classScope@var2627 ;
330:
331: if (@expr1073749660 scope@var2626 &&@expr1073749661 scope@var2626 .@expr1073749662 numConstructors@var2628 ==@expr1073749663 0 &&@expr1073749664 t@var2625 .@expr1073749665 derivedFrom@var2629 .@expr1073749666 empty (@expr1073749667 ) &&@expr1073749668
332: (@expr1073749669 t@var2625 .@expr1073749670 isClassType (@expr1073749671 ) ||@expr1073749672 t@var2625 .@expr1073749673 isStructType (@expr1073749674 ) ) &&@expr1073749675 numberOfArguments (@expr1073749676 ftok@var2619 ) <@expr1073749677 scope@var2626 .@expr7854 varlist@var2630 .@expr7855 size (@expr7856 ) ) {
333: assert (@expr1073749681 argn@var2618 <@expr1073749682 scope@var2626 .@expr7854 varlist@var2630 .@expr7855 size (@expr7856 ) ) ;
334: auto it@var2631 ; it@var2631 =@expr1073749686 std ::@expr1073749687 next (@expr1073749688 scope@var2626 .@expr7854 varlist@var2630 .@expr1073749690 begin (@expr1073749691 ) , argn@var2618 ) ;
335: if (@expr1073749692 it@var2631 .@expr7869 valueType (@expr7870 ) ) {
336: return {@expr1073749695 *@expr1073749696 it@var2631 .@expr7869 valueType (@expr7870 ) } ; }
337: }
338: } }
339: }
340: } }
341: if (@expr1073749699 settings@var2616 &&@expr1073749700 Token ::@expr7776 Match (@expr1073749702 tok@var2615 .@expr7749 astParent (@expr7750 ) .@expr7881 tokAt (@expr7882 -2 ) , ". push_back|push_front|insert|push (" ) &&@expr1073749707
342: astIsContainer (@expr1073749708 tok@var2615 .@expr7749 astParent (@expr7750 ) .@expr7881 tokAt (@expr7882 -2 ) .@expr7889 astOperand1 (@expr7890 ) ) ) {
343: const Token * contTok@var2632 ; contTok@var2632 =@expr1073749715 tok@var2615 .@expr7749 astParent (@expr7750 ) .@expr7881 tokAt (@expr7882 -2 ) .@expr7889 astOperand1 (@expr7890 ) ;
344: const ValueType * vtCont@var2633 ; vtCont@var2633 =@expr1073749722 contTok@var2632 .@expr1073749723 valueType (@expr1073749724 ) ;
345: if (@expr1073749725 !@expr1073749726 vtCont@var2633 .@expr7903 containerTypeToken@var2634 ) {
346: return { } ; }
347: ValueType vtParent@var2635 ; vtParent@var2635 =@expr1073749728 ValueType ::@expr1073749729 parseDecl (@expr1073749730 vtCont@var2633 .@expr7903 containerTypeToken@var2634 , settings@var2616 ) ;
348: return {@expr1073749732 std ::@expr1073749733 move (@expr1073749734 vtParent@var2635 ) } ;
349: }
350: if (@expr1073749735 Token ::@expr7776 Match (@expr1073749737 tok@var2615 .@expr7749 astParent (@expr7750 ) , "return|(|{|%assign%" ) &&@expr1073749740 parent@var2617 ) {
351: *@expr7754 parent@var2617 =@expr1073749742 tok@var2615 .@expr7749 astParent (@expr7750 ) ;
352: }
353: if (@expr1073749745 tok@var2615 .@expr7749 astParent (@expr7750 ) .@expr7924 valueType (@expr7925 ) ) {
354: return {@expr1073749750 *@expr1073749751 tok@var2615 .@expr7749 astParent (@expr7750 ) .@expr7924 valueType (@expr7925 ) } ; }
355: return { } ;
356: }
357:
358: static bool isEscapeScope ( const Token * tok@var2636 , TokenList * tokenlist@var2637 , bool unknown@var2638 = false )
359: {
360: if (@expr1073749756 !@expr1073749757 Token ::@expr1073749758 simpleMatch (@expr1073749759 tok@var2636 , "{" ) ) {
361: return false ; }
362:
363: const Token * termTok@var2639 ; termTok@var2639 =@expr1073749760 Token ::@expr1073749761 findmatch (@expr1073749762 tok@var2636 , "return|continue|break|throw|goto" , tok@var2636 .@expr7939 link (@expr7940 ) ) ;
364: if (@expr1073749765 termTok@var2639 &&@expr1073749766 termTok@var2639 .@expr1073749767 scope (@expr1073749768 ) ==@expr1073749769 tok@var2636 .@expr1073749770 scope (@expr1073749771 ) ) {
365: return true ; }
366: std ::@expr1073749772 string unknownFunction@var2640 ;
367: if (@expr1073749773 tokenlist@var2637 &&@expr1073749774 tokenlist@var2637 .@expr1073749775 getSettings (@expr1073749776 ) .@expr1073749777 library@var5315 .@expr1073749778 isScopeNoReturn (@expr1073749779 tok@var2636 .@expr7939 link (@expr7940 ) , &@expr1073749782 unknownFunction@var2640 ) ) {
368: return unknownFunction@var2640 .@expr1073749783 empty (@expr1073749784 ) ||@expr1073749785 unknown@var2638 ; }
369: return false ;
370: }
371:
372: static ValueFlow :: Value castValue ( ValueFlow :: Value value@var2641 , const ValueType :: Sign sign@var2642 , int bit@var2643 )
373: {
374: if (@expr1073749786 value@var2641 .@expr1073749787 isFloatValue (@expr1073749788 ) ) {
375: value@var2641 .@expr1073749789 valueType@var2644 =@expr1073749790 ValueFlow ::@expr1073749791 Value ::@expr1073749792 ValueType ::@expr1073749793 INT ;
376: if (@expr1073749794 value@var2641 .@expr7971 floatValue@var2645 >=@expr1073749796 std ::@expr7973 numeric_limits < int > ::@expr1073749798 min (@expr1073749799 ) &&@expr1073749800 value@var2641 .@expr7971 floatValue@var2645 <=@expr1073749802 std ::@expr7973 numeric_limits < int > ::@expr1073749804 max (@expr1073749805 ) ) {
377: value@var2641 .@expr7982 intvalue@var2646 =@expr1073749807 value@var2641 .@expr7971 floatValue@var2645 ;
378: } else {
379: value@var2641 .@expr7982 intvalue@var2646 =@expr1073749810 0 ;
380: }
381: }
382: if (@expr1073749811 bit@var2643 <@expr1073749812 MathLib ::@expr1073749813 bigint_bits@var15 ) {
383: const unsigned long long one@var2647 =@expr1073749814 1 ;
384: value@var2641 .@expr7982 intvalue@var2646 &=@expr1073749816 (@expr1073749817 one@var2647 <<@expr7994 bit@var2643 ) -@expr1073749819 1 ;
385: if (@expr1073749820 sign@var2642 ==@expr1073749821 ValueType ::@expr1073749822 Sign ::@expr1073749823 SIGNED &&@expr1073749824 value@var2641 .@expr7982 intvalue@var2646 &@expr1073749826 (@expr1073749827 one@var2647 <<@expr1073749828 (@expr1073749829 bit@var2643 -@expr1073749830 1 ) ) ) {
386: value@var2641 .@expr7982 intvalue@var2646 |=@expr1073749832 ~@expr1073749833 (@expr1073749834 (@expr1073749835 one@var2647 <<@expr7994 bit@var2643 ) -@expr1073749837 1ULL ) ;
387: }
388: }
389: return value@var2641 ;
390: }
391:
392: static bool isNumeric ( const ValueFlow :: Value & value@var2648 ) {
393: return value@var2648 .@expr1073749838 isIntValue (@expr1073749839 ) ||@expr1073749840 value@var2648 .@expr1073749841 isFloatValue (@expr1073749842 ) ;
394: }
395:
396: static void combineValueProperties ( const ValueFlow :: Value & value1@var2649 , const ValueFlow :: Value & value2@var2650 , ValueFlow :: Value * result@var2651 )
397: {
398: if (@expr1073749844 value1@var2649 .@expr1073749845 isKnown (@expr1073749846 ) &&@expr1073749847 value2@var2650 .@expr1073749848 isKnown (@expr1073749849 ) ) {
399: result@var2651 .@expr1073749850 setKnown (@expr1073749851 ) ; }
400: else { if (@expr1073749852 value1@var2649 .@expr1073749853 isImpossible (@expr1073749854 ) ||@expr1073749855 value2@var2650 .@expr1073749856 isImpossible (@expr1073749857 ) ) {
401: result@var2651 .@expr1073749858 setImpossible (@expr1073749859 ) ; }
402: else { if (@expr1073749860 value1@var2649 .@expr1073749861 isInconclusive (@expr1073749862 ) ||@expr1073749863 value2@var2650 .@expr1073749864 isInconclusive (@expr1073749865 ) ) {
403: result@var2651 .@expr1073749866 setInconclusive (@expr1073749867 ) ; }
404: else {
405: result@var2651 .@expr1073749868 setPossible (@expr1073749869 ) ; } } }
406: if (@expr1073749870 value1@var2649 .@expr1073749871 isSymbolicValue (@expr1073749872 ) ) {
407: result@var2651 .@expr8049 valueType@var2652 =@expr1073749874 value1@var2649 .@expr8051 valueType@var2653 ;
408: result@var2651 .@expr8052 tokvalue@var2654 =@expr1073749877 value1@var2649 .@expr1073749878 tokvalue@var2655 ;
409: }
410: if (@expr1073749879 value2@var2650 .@expr1073749880 isSymbolicValue (@expr1073749881 ) ) {
411: result@var2651 .@expr8049 valueType@var2652 =@expr1073749883 value2@var2650 .@expr8060 valueType@var2656 ;
412: result@var2651 .@expr8052 tokvalue@var2654 =@expr1073749886 value2@var2650 .@expr1073749887 tokvalue@var2657 ;
413: }
414: if (@expr1073749888 value1@var2649 .@expr1073749889 isIteratorValue (@expr1073749890 ) ) {
415: result@var2651 .@expr8049 valueType@var2652 =@expr1073749892 value1@var2649 .@expr8051 valueType@var2653 ; }
416: if (@expr1073749894 value2@var2650 .@expr1073749895 isIteratorValue (@expr1073749896 ) ) {
417: result@var2651 .@expr8049 valueType@var2652 =@expr1073749898 value2@var2650 .@expr8060 valueType@var2656 ; }
418: result@var2651 .@expr1073749900 condition@var2658 =@expr1073749901 value1@var2649 .@expr8078 condition@var2659 ?@expr1073749903 value1@var2649 .@expr8078 condition@var2659 :@expr1073749905 value2@var2650 .@expr1073749906 condition@var2660 ;
419: result@var2651 .@expr8083 varId@var2661 =@expr1073749908 (@expr1073749909 value1@var2649 .@expr8086 varId@var2662 !=@expr1073749911 0 ) ?@expr1073749912 value1@var2649 .@expr8086 varId@var2662 :@expr1073749914 value2@var2650 .@expr1073749915 varId@var2663 ;
420: result@var2651 .@expr1073749916 varvalue@var2664 =@expr1073749917 (@expr1073749918 result@var2651 .@expr8083 varId@var2661 ==@expr1073749920 value1@var2649 .@expr8086 varId@var2662 ) ?@expr1073749922 value1@var2649 .@expr1073749923 varvalue@var2665 :@expr1073749924 value2@var2650 .@expr1073749925 varvalue@var2666 ;
421: result@var2651 .@expr1073749926 errorPath@var2667 =@expr1073749927 (@expr1073749928 value1@var2649 .@expr1073749929 errorPath@var2668 .@expr1073749930 empty (@expr1073749931 ) ?@expr1073749932 value2@var2650 :@expr1073749933 value1@var2649 ) .@expr1073749934 errorPath@var2668 ;
422: result@var2651 .@expr1073749935 safe@var2669 =@expr1073749936 value1@var2649 .@expr1073749937 safe@var2670 ||@expr1073749938 value2@var2650 .@expr1073749939 safe@var2671 ;
423: if (@expr1073749940 value1@var2649 .@expr8117 bound@var2672 ==@expr1073749942 ValueFlow ::@expr8119 Value ::@expr8120 Bound ::@expr8121 Point@expr8019 ||@expr1073749946 value2@var2650 .@expr8123 bound@var2673 ==@expr1073749948 ValueFlow ::@expr8119 Value ::@expr8120 Bound ::@expr8121 Point@expr8019 ) {
424: if (@expr1073749952 value1@var2649 .@expr8117 bound@var2672 ==@expr1073749954 ValueFlow ::@expr8119 Value ::@expr8120 Bound ::@expr8133 Upper ||@expr1073749958 value2@var2650 .@expr8123 bound@var2673 ==@expr1073749960 ValueFlow ::@expr8119 Value ::@expr8120 Bound ::@expr8133 Upper ) {
425: result@var2651 .@expr8140 bound@var2674 =@expr1073749965 ValueFlow ::@expr8119 Value ::@expr8120 Bound ::@expr8133 Upper ; }
426: if (@expr1073749969 value1@var2649 .@expr8117 bound@var2672 ==@expr1073749971 ValueFlow ::@expr8119 Value ::@expr8120 Bound ::@expr8150 Lower ||@expr1073749975 value2@var2650 .@expr8123 bound@var2673 ==@expr1073749977 ValueFlow ::@expr8119 Value ::@expr8120 Bound ::@expr8150 Lower ) {
427: result@var2651 .@expr8140 bound@var2674 =@expr1073749982 ValueFlow ::@expr8119 Value ::@expr8120 Bound ::@expr8150 Lower ; }
428: }
429: if (@expr1073749986 value1@var2649 .@expr8163 path@var2675 !=@expr1073749988 value2@var2650 .@expr1073749989 path@var2676 ) {
430: result@var2651 .@expr8166 path@var2677 =@expr1073749991 -1 ; }
431: else {
432: result@var2651 .@expr8166 path@var2677 =@expr1073749993 value1@var2649 .@expr8163 path@var2675 ; }
433: }
434:
435: static const Token * getCastTypeStartToken ( const Token * parent@var2678 )
436: {
437:
438: if (@expr1073749995 !@expr1073749996 Token ::@expr8173 Match (@expr1073749998 parent@var2678 , "{|(" ) ) {
439: return nullptr ; }
440:
441: if (@expr1073749999 parent@var2678 .@expr1073750000 isBinaryOp (@expr1073750001 ) &&@expr1073750002 Token ::@expr8173 Match (@expr1073750004 parent@var2678 .@expr8181 astOperand1 (@expr8182 ) , "%type% (|{" ) &&@expr1073750007
442: parent@var2678 .@expr8181 astOperand1 (@expr8182 ) .@expr1073750010 tokType (@expr1073750011 ) ==@expr1073750012 Token ::@expr1073750013 eType &&@expr1073750014 astIsPrimitive (@expr1073750015 parent@var2678 ) ) {
443: return parent@var2678 .@expr8181 astOperand1 (@expr8182 ) ; }
444: if (@expr1073750018 parent@var2678 .@expr1073750019 str (@expr1073750020 ) !=@expr1073750021 "(" ) {
445: return nullptr ; }
446: if (@expr1073750022 !@expr1073750023 parent@var2678 .@expr8200 astOperand2 (@expr8201 ) &&@expr1073750026 Token ::@expr8173 Match (@expr1073750028 parent@var2678 , "( %name%" ) ) {
447: return parent@var2678 .@expr1073750029 next (@expr1073750030 ) ; }
448: if (@expr1073750031 parent@var2678 .@expr8200 astOperand2 (@expr8201 ) &&@expr1073750034 Token ::@expr8173 Match (@expr1073750036 parent@var2678 .@expr8181 astOperand1 (@expr8182 ) , "const_cast|dynamic_cast|reinterpret_cast|static_cast <" ) ) {
449: return parent@var2678 .@expr8181 astOperand1 (@expr8182 ) .@expr1073750041 tokAt (@expr1073750042 2 ) ; }
450: return nullptr ;
451: }
452:
453:
454: static bool isNonInvertibleOperation ( const Token * tok@var2679 )
455: {
456: return !@expr1073750043 Token ::@expr1073750044 Match (@expr1073750045 tok@var2679 , "+|-" ) ;
457: }
458:
459: static bool isComputableValue ( const Token * parent@var2680 , const ValueFlow :: Value & value@var2681 )
460: {
461: const bool noninvertible@var2682 =@expr1073750046 isNonInvertibleOperation (@expr1073750047 parent@var2680 ) ;
462: if (@expr1073750048 noninvertible@var2682 &&@expr1073750049 value@var2681 .@expr1073750050 isImpossible (@expr1073750051 ) ) {
463: return false ; }
464: if (@expr1073750052 !@expr1073750053 value@var2681 .@expr1073750054 isIntValue (@expr1073750055 ) &&@expr1073750056 !@expr1073750057 value@var2681 .@expr1073750058 isFloatValue (@expr1073750059 ) &&@expr1073750060 !@expr1073750061 value@var2681 .@expr8238 isTokValue (@expr8239 ) &&@expr1073750064 !@expr1073750065 value@var2681 .@expr8242 isIteratorValue (@expr8243 ) ) {
465: return false ; }
466: if (@expr1073750068 value@var2681 .@expr8242 isIteratorValue (@expr8243 ) &&@expr1073750071 !@expr1073750072 Token ::@expr1073750073 Match (@expr1073750074 parent@var2680 , "+|-" ) ) {
467: return false ; }
468: if (@expr1073750075 value@var2681 .@expr8238 isTokValue (@expr8239 ) &&@expr1073750078 (@expr1073750079 !@expr1073750080 parent@var2680 .@expr1073750081 isComparisonOp (@expr1073750082 ) ||@expr1073750083 value@var2681 .@expr1073750084 tokvalue@var2683 .@expr1073750085 tokType (@expr1073750086 ) !=@expr1073750087 Token ::@expr1073750088 eString ) ) {
469: return false ; }
470: return true ;
471: }
472:
473:
474: static void setTokenValueCast ( Token * parent@var2684 , const ValueType & valueType@var2685 , const ValueFlow :: Value & value@var2686 , const Settings * settings@var2687 ) ;
475:
476: static bool isCompatibleValueTypes ( ValueFlow :: Value :: ValueType x@var2688 , ValueFlow :: Value :: ValueType y@var2689 )
477: {
478: static const std ::@expr1073750089 unordered_map < ValueFlow ::@expr8266 Value ::@expr8266 ValueType ,
479: std ::@expr8266 unordered_set < ValueFlow ::@expr8266 Value ::@expr8266 ValueType , EnumClassHash > ,
480: EnumClassHash >
481: compatibleTypes@var2690 =@expr1073750095 {@expr1073750096
482: {@expr1073750097 ValueFlow ::@expr8274 Value ::@expr8275 ValueType ::@expr8276 INT ,
483: {@expr1073750101 ValueFlow ::@expr8274 Value ::@expr8275 ValueType ::@expr8280 FLOAT ,
484: ValueFlow ::@expr8274 Value ::@expr8275 ValueType ::@expr1073750107 SYMBOLIC ,
485: ValueFlow ::@expr8274 Value ::@expr8275 ValueType ::@expr8286 TOK } } ,
486: {@expr1073750111 ValueFlow ::@expr8274 Value ::@expr8275 ValueType ::@expr8280 FLOAT , {@expr1073750115 ValueFlow ::@expr8274 Value ::@expr8275 ValueType ::@expr8276 INT } } ,
487: {@expr1073750119 ValueFlow ::@expr8274 Value ::@expr8275 ValueType ::@expr8286 TOK , {@expr1073750123 ValueFlow ::@expr8274 Value ::@expr8275 ValueType ::@expr8276 INT } } ,
488: {@expr1073750127 ValueFlow ::@expr8274 Value ::@expr8275 ValueType ::@expr1073750130 ITERATOR_START , {@expr1073750131 ValueFlow ::@expr8274 Value ::@expr8275 ValueType ::@expr8276 INT } } ,
489: {@expr1073750135 ValueFlow ::@expr8274 Value ::@expr8275 ValueType ::@expr1073750138 ITERATOR_END , {@expr1073750139 ValueFlow ::@expr8274 Value ::@expr8275 ValueType ::@expr8276 INT } } ,
490: } ;
491: if (@expr1073750143 x@var2688 ==@expr1073750144 y@var2689 ) {
492: return true ; }
493: auto it@var2691 ; it@var2691 =@expr1073750145 compatibleTypes@var2690 .@expr1073750146 find (@expr1073750147 x@var2688 ) ;
494: if (@expr1073750148 it@var2691 ==@expr1073750149 compatibleTypes@var2690 .@expr1073750150 end (@expr1073750151 ) ) {
495: return false ; }
496: return it@var2691 .@expr1073750152 second@var2692 .@expr1073750153 count (@expr1073750154 y@var2689 ) >@expr1073750155 0 ;
497: }
498:
499: static bool isCompatibleValues ( const ValueFlow :: Value & value1@var2693 , const ValueFlow :: Value & value2@var2694 )
500: {
501: if (@expr1073750156 value1@var2693 .@expr1073750157 isSymbolicValue (@expr1073750158 ) &&@expr1073750159 value2@var2694 .@expr1073750160 isSymbolicValue (@expr1073750161 ) &&@expr1073750162 value1@var2693 .@expr1073750163 tokvalue@var2695 .@expr1073750164 exprId (@expr1073750165 ) !=@expr1073750166 value2@var2694 .@expr1073750167 tokvalue@var2696 .@expr1073750168 exprId (@expr1073750169 ) ) {
502: return false ; }
503: if (@expr1073750170 !@expr1073750171 isCompatibleValueTypes (@expr1073750172 value1@var2693 .@expr1073750173 valueType@var2697 , value2@var2694 .@expr1073750174 valueType@var2698 ) ) {
504: return false ; }
505: if (@expr1073750175 value1@var2693 .@expr1073750176 isKnown (@expr1073750177 ) ||@expr1073750178 value2@var2694 .@expr1073750179 isKnown (@expr1073750180 ) ) {
506: return true ; }
507: if (@expr1073750181 value1@var2693 .@expr1073750182 isImpossible (@expr1073750183 ) ||@expr1073750184 value2@var2694 .@expr1073750185 isImpossible (@expr1073750186 ) ) {
508: return false ; }
509: if (@expr1073750187 value1@var2693 .@expr8364 varId@var2699 ==@expr1073750189 0 ||@expr1073750190 value2@var2694 .@expr8367 varId@var2700 ==@expr1073750192 0 ) {
510: return true ; }
511: if (@expr1073750193 value1@var2693 .@expr8364 varId@var2699 ==@expr1073750195 value2@var2694 .@expr8367 varId@var2700 &&@expr1073750197 value1@var2693 .@expr1073750198 varvalue@var2701 ==@expr1073750199 value2@var2694 .@expr1073750200 varvalue@var2702 &&@expr1073750201 value1@var2693 .@expr1073750202 isIntValue (@expr1073750203 ) &&@expr1073750204 value2@var2694 .@expr1073750205 isIntValue (@expr1073750206 ) ) {
512: return true ; }
513: return false ;
514: }
515:
516: static ValueFlow :: Value truncateImplicitConversion ( Token * parent@var2703 , const ValueFlow :: Value & value@var2704 , const Settings * settings@var2705 )
517: {
518: if (@expr1073750207 !@expr1073750208 value@var2704 .@expr1073750209 isIntValue (@expr1073750210 ) &&@expr1073750211 !@expr1073750212 value@var2704 .@expr1073750213 isFloatValue (@expr1073750214 ) ) {
519: return value@var2704 ; }
520: if (@expr1073750215 !@expr1073750216 parent@var2703 ) {
521: return value@var2704 ; }
522: if (@expr1073750217 !@expr1073750218 parent@var2703 .@expr1073750219 isBinaryOp (@expr1073750220 ) ) {
523: return value@var2704 ; }
524: if (@expr1073750221 !@expr1073750222 parent@var2703 .@expr1073750223 isConstOp (@expr1073750224 ) ) {
525: return value@var2704 ; }
526: if (@expr1073750225 !@expr1073750226 astIsIntegral (@expr1073750227 parent@var2703 .@expr8404 astOperand1 (@expr8405 ) , false ) ) {
527: return value@var2704 ; }
528: if (@expr1073750230 !@expr1073750231 astIsIntegral (@expr1073750232 parent@var2703 .@expr8409 astOperand2 (@expr8410 ) , false ) ) {
529: return value@var2704 ; }
530: const ValueType * vt1@var2706 ; vt1@var2706 =@expr1073750235 parent@var2703 .@expr8404 astOperand1 (@expr8405 ) .@expr1073750238 valueType (@expr1073750239 ) ;
531: const ValueType * vt2@var2707 ; vt2@var2707 =@expr1073750240 parent@var2703 .@expr8409 astOperand2 (@expr8410 ) .@expr1073750243 valueType (@expr1073750244 ) ;
532:
533: if (@expr1073750245 vt1@var2706 .@expr8422 sign@var2708 ==@expr1073750247 vt2@var2707 .@expr8424 sign@var2709 ) {
534: return value@var2704 ; }
535: unsigned long n1@var2710 ; n1@var2710 =@expr1073750249 ValueFlow ::@expr8426 getSizeOf (@expr1073750251 *@expr1073750252 vt1@var2706 , settings@var2705 ) ;
536: unsigned long n2@var2711 ; n2@var2711 =@expr1073750253 ValueFlow ::@expr8426 getSizeOf (@expr1073750255 *@expr1073750256 vt2@var2707 , settings@var2705 ) ;
537: ValueType ::@expr1073750257 Sign sign@var2712 ; sign@var2712 =@expr1073750258 ValueType ::@expr1073750259 Sign ::@expr1073750260 UNSIGNED ;
538: if (@expr1073750261 n1@var2710 <@expr1073750262 n2@var2711 ) {
539: sign@var2712 =@expr1073750263 vt2@var2707 .@expr8424 sign@var2709 ; }
540: else { if (@expr1073750265 n1@var2710 >@expr1073750266 n2@var2711 ) {
541: sign@var2712 =@expr1073750267 vt1@var2706 .@expr8422 sign@var2708 ; } }
542: ValueFlow ::@expr1073750269 Value v@var2713 ; v@var2713 =@expr1073750270 castValue (@expr1073750271 value@var2704 , sign@var2712 , std ::@expr1073750272 max (@expr1073750273 n1@var2710 , n2@var2711 ) *@expr1073750274 8 ) ;
543: v@var2713 .@expr1073750275 wideintvalue@var2714 =@expr1073750276 value@var2704 .@expr1073750277 intvalue@var2715 ;
544: return v@var2713 ;
545: }
546:
547:
548: static void setTokenValue ( Token * tok@var2716 , ValueFlow :: Value value@var2717 , const Settings * settings@var2718 )
549: {
550:
551: if (@expr1073750280 !@expr8457 value@var2717 .@expr8458 isImpossible (@expr8459 ) &&@expr8460 value@var2717 .@expr8461 isIntValue (@expr8462 ) &&@expr1073750287 value@var2717 .@expr8464 intvalue@var2719 <@expr8465 0 &&@expr1073750290 astIsUnsigned (@expr8467 tok@var2716 ) &&@expr1073750292
552: ValueFlow ::@expr8469 getSizeOf (@expr8470 *@expr8471 tok@var2716 .@expr8472 valueType (@expr8473 ) , settings@var2718 ) >=@expr1073750298 sizeof (@expr1073750299 long long ) ) {
553: return ; }
554:
555: if (@expr1073750300 !@expr8457 value@var2717 .@expr8458 isImpossible (@expr8459 ) &&@expr8460 value@var2717 .@expr8461 isIntValue (@expr8462 ) ) {
556: value@var2717 =@expr1073750307 truncateImplicitConversion (@expr1073750308 tok@var2716 .@expr8485 astParent (@expr8486 ) , value@var2717 , settings@var2718 ) ; }
557:
558: if (@expr1073750311 !@expr1073750312 tok@var2716 .@expr1073750313 addValue (@expr1073750314 value@var2717 ) ) {
559: return ; }
560:
561: if (@expr1073750315 value@var2717 .@expr1073750316 path@var2720 <@expr1073750317 0 ) {
562: return ; }
563:
564: Token * parent@var2721 ; parent@var2721 =@expr1073750318 tok@var2716 .@expr8485 astParent (@expr8486 ) ;
565: if (@expr1073750321 !@expr1073750322 parent@var2721 ) {
566: return ; }
567:
568: if (@expr1073750323 Token ::@expr8500 simpleMatch (@expr1073750325 parent@var2721 , "=" ) &&@expr1073750326 astIsRHS (@expr8503 tok@var2716 ) &&@expr1073750328 !@expr1073750329 value@var2717 .@expr8506 isLifetimeValue (@expr8507 ) ) {
569: setTokenValue (@expr8508 parent@var2721 , value@var2717 , settings@var2718 ) ;
570: return ;
571: }
572:
573: if (@expr1073750333 value@var2717 .@expr1073750334 isContainerSizeValue (@expr1073750335 ) ) {
574:
575: if (@expr1073750336 Token ::@expr8513 Match (@expr1073750338 parent@var2721 , "+|==|!=" ) &&@expr1073750339 parent@var2721 .@expr8516 astOperand1 (@expr8517 ) &&@expr1073750342 parent@var2721 .@expr8519 astOperand2 (@expr8520 ) ) {
576: for (@expr1073750345 const ValueFlow ::@expr8522 Value &@expr8523 value1@var2722 :@expr1073750348 parent@var2721 .@expr8516 astOperand1 (@expr8517 ) .@expr8527 values (@expr8528 ) ) {
577: if (@expr1073750353 value1@var2722 .@expr1073750354 isImpossible (@expr1073750355 ) ) {
578: continue ; }
579: for (@expr1073750356 const ValueFlow ::@expr8522 Value &@expr8523 value2@var2723 :@expr1073750359 parent@var2721 .@expr8519 astOperand2 (@expr8520 ) .@expr8538 values (@expr8539 ) ) {
580: if (@expr1073750364 value2@var2723 .@expr1073750365 isImpossible (@expr1073750366 ) ) {
581: continue ; }
582: if (@expr1073750367 value1@var2722 .@expr1073750368 path@var2724 !=@expr1073750369 value2@var2723 .@expr1073750370 path@var2725 ) {
583: continue ; }
584: ValueFlow ::@expr1073750371 Value result@var2726 ;
585: if (@expr8548 Token ::@expr8513 Match (@expr8550 parent@var2721 , "%comp%" ) ) {
586: result@var2726 .@expr8551 valueType@var2727 =@expr1073750376 ValueFlow ::@expr8553 Value ::@expr8554 ValueType ::@expr8555 INT ; }
587: else {
588: result@var2726 .@expr8551 valueType@var2727 =@expr1073750381 ValueFlow ::@expr8553 Value ::@expr8554 ValueType ::@expr1073750384 CONTAINER_SIZE ; }
589:
590: if (@expr1073750385 value1@var2722 .@expr8562 isContainerSizeValue (@expr8563 ) &&@expr1073750388 value2@var2723 .@expr8565 isContainerSizeValue (@expr8566 ) ) {
591: result@var2726 .@expr8567 intvalue@var2728 =@expr1073750392 calculate (@expr1073750393 parent@var2721 .@expr8570 str (@expr8571 ) , value1@var2722 .@expr8572 intvalue@var2729 , value2@var2723 .@expr8573 intvalue@var2730 ) ; }
592: else { if (@expr1073750398 value1@var2722 .@expr8562 isContainerSizeValue (@expr8563 ) &&@expr1073750401 value2@var2723 .@expr1073750402 isTokValue (@expr1073750403 ) &&@expr1073750404 value2@var2723 .@expr8581 tokvalue@var2731 .@expr1073750406 tokType (@expr1073750407 ) ==@expr1073750408 Token ::@expr8585 eString ) {
593: result@var2726 .@expr8567 intvalue@var2728 =@expr1073750411 calculate (@expr1073750412 parent@var2721 .@expr8570 str (@expr8571 ) , value1@var2722 .@expr8572 intvalue@var2729 , long long (@expr1073750416 Token ::@expr8593 getStrLength (@expr1073750418 value2@var2723 .@expr8581 tokvalue@var2731 ) ) ) ; }
594: else { if (@expr1073750420 value2@var2723 .@expr8565 isContainerSizeValue (@expr8566 ) &&@expr1073750423 value1@var2722 .@expr1073750424 isTokValue (@expr1073750425 ) &&@expr1073750426 value1@var2722 .@expr8603 tokvalue@var2732 .@expr1073750428 tokType (@expr1073750429 ) ==@expr1073750430 Token ::@expr8585 eString ) {
595: result@var2726 .@expr8567 intvalue@var2728 =@expr1073750433 calculate (@expr1073750434 parent@var2721 .@expr8570 str (@expr8571 ) , long long (@expr1073750437 Token ::@expr8593 getStrLength (@expr1073750439 value1@var2722 .@expr8603 tokvalue@var2732 ) ) , value2@var2723 .@expr8573 intvalue@var2730 ) ; }
596: else {
597: continue ; } } }
598:
599: combineValueProperties (@expr1073750442 value1@var2722 , value2@var2723 , &@expr1073750443 result@var2726 ) ;
600:
601: if (@expr1073750444 Token ::@expr8500 simpleMatch (@expr1073750446 parent@var2721 , "==" ) &&@expr1073750447 result@var2726 .@expr8567 intvalue@var2728 ) {
602: continue ; }
603: if (@expr1073750449 Token ::@expr8500 simpleMatch (@expr1073750451 parent@var2721 , "!=" ) &&@expr1073750452 !@expr1073750453 result@var2726 .@expr8567 intvalue@var2728 ) {
604: continue ; }
605:
606: setTokenValue (@expr1073750455 parent@var2721 , result@var2726 , settings@var2718 ) ;
607: }
608: }
609: }
610:
611: else { if (@expr1073750456 Token ::@expr8513 Match (@expr1073750458 parent@var2721 , ". %name% (" ) &&@expr1073750459 parent@var2721 .@expr8636 astParent (@expr8637 ) ==@expr1073750462 parent@var2721 .@expr1073750463 tokAt (@expr1073750464 2 ) &&@expr1073750465
612: parent@var2721 .@expr8516 astOperand1 (@expr8517 ) &&@expr1073750468 parent@var2721 .@expr8516 astOperand1 (@expr8517 ) .@expr1073750471 valueType (@expr1073750472 ) ) {
613: const Library ::@expr8649 Container * c@var2733 ; c@var2733 =@expr1073750474 getLibraryContainer (@expr1073750475 parent@var2721 .@expr8516 astOperand1 (@expr8517 ) ) ;
614: const Library ::@expr8522 Container ::@expr8522 Yield yields@var2734 =@expr1073750480 c@var2733 ?@expr1073750481 c@var2733 .@expr1073750482 getYield (@expr1073750483 parent@var2721 .@expr1073750484 strAt (@expr1073750485 1 ) ) :@expr1073750486 Library ::@expr8649 Container ::@expr8664 Yield ::@expr1073750489 NO_YIELD ;
615: if (@expr1073750490 yields@var2734 ==@expr1073750491 Library ::@expr8649 Container ::@expr8664 Yield ::@expr8670 SIZE ) {
616: ValueFlow ::@expr1073750495 Value v@var2735 (@expr1073750496 value@var2717 ) ;
617: v@var2735 .@expr1073750497 valueType@var2736 =@expr1073750498 ValueFlow ::@expr8553 Value ::@expr8554 ValueType ::@expr8555 INT ;
618: setTokenValue (@expr1073750502 parent@var2721 .@expr8636 astParent (@expr8637 ) , v@var2735 , settings@var2718 ) ;
619: } else { if (@expr1073750505 yields@var2734 ==@expr1073750506 Library ::@expr8649 Container ::@expr8664 Yield ::@expr8685 EMPTY ) {
620: ValueFlow ::@expr1073750510 Value v@var2737 (@expr1073750511 value@var2717 ) ;
621: v@var2737 .@expr8688 intvalue@var2738 =@expr1073750513 !@expr1073750514 v@var2737 .@expr8688 intvalue@var2738 ;
622: v@var2737 .@expr1073750516 valueType@var2739 =@expr1073750517 ValueFlow ::@expr8553 Value ::@expr8554 ValueType ::@expr8555 INT ;
623: setTokenValue (@expr1073750521 parent@var2721 .@expr8636 astParent (@expr8637 ) , v@var2737 , settings@var2718 ) ;
624: } }
625: } else { if (@expr1073750524 Token ::@expr8513 Match (@expr8702 parent@var2721 .@expr8703 previous (@expr8704 ) , "%name% (" ) ) {
626: if (@expr1073750529 const Library ::@expr8522 Function *@expr8707 f@var2740 =@expr1073750532 settings@var2718 .@expr8709 library@var2741 .@expr8710 getFunction (@expr8711 parent@var2721 .@expr8703 previous (@expr8704 ) ) ) {
627: if (@expr1073750538 f@var2740 .@expr8715 containerYield@var2742 ==@expr1073750540 Library ::@expr8649 Container ::@expr8664 Yield ::@expr8670 SIZE ) {
628: ValueFlow ::@expr1073750544 Value v@var2743 (@expr1073750545 value@var2717 ) ;
629: v@var2743 .@expr1073750546 valueType@var2744 =@expr1073750547 ValueFlow ::@expr8553 Value ::@expr8554 ValueType ::@expr8555 INT ;
630: setTokenValue (@expr1073750551 parent@var2721 , v@var2743 , settings@var2718 ) ;
631: } else { if (@expr1073750552 f@var2740 .@expr8715 containerYield@var2742 ==@expr1073750554 Library ::@expr8649 Container ::@expr8664 Yield ::@expr8685 EMPTY ) {
632: ValueFlow ::@expr1073750558 Value v@var2745 (@expr1073750559 value@var2717 ) ;
633: v@var2745 .@expr8736 intvalue@var2746 =@expr1073750561 !@expr1073750562 v@var2745 .@expr8736 intvalue@var2746 ;
634: v@var2745 .@expr1073750564 valueType@var2747 =@expr1073750565 ValueFlow ::@expr8553 Value ::@expr8554 ValueType ::@expr8555 INT ;
635: setTokenValue (@expr1073750569 parent@var2721 , v@var2745 , settings@var2718 ) ;
636: } }
637: }
638: } } }
639:
640: return ;
641: }
642:
643: if (@expr1073750570 value@var2717 .@expr8506 isLifetimeValue (@expr8507 ) ) {
644: if (@expr1073750573 !@expr1073750574 isLifetimeBorrowed (@expr1073750575 parent@var2721 , settings@var2718 ) ) {
645: return ; }
646: if (@expr1073750576 value@var2717 .@expr1073750577 lifetimeKind@var2748 ==@expr1073750578 ValueFlow ::@expr8553 Value ::@expr1073750580 LifetimeKind ::@expr1073750581 Iterator &&@expr1073750582 astIsIterator (@expr1073750583 parent@var2721 ) ) {
647: setTokenValue (@expr8508 parent@var2721 , value@var2717 , settings@var2718 ) ;
648: } else { if (@expr1073750585 astIsPointer (@expr8762 tok@var2716 ) &&@expr1073750587 astIsPointer (@expr1073750588 parent@var2721 ) &&@expr1073750589 !@expr1073750590 parent@var2721 .@expr8767 isUnaryOp (@expr8768 "*" ) &&@expr1073750593
649: (@expr1073750594 parent@var2721 .@expr8771 isArithmeticalOp (@expr8772 ) ||@expr1073750597 parent@var2721 .@expr8774 isCast (@expr8775 ) ) ) {
650: setTokenValue (@expr8508 parent@var2721 , value@var2717 , settings@var2718 ) ;
651: } }
652: return ;
653: }
654:
655: if (@expr1073750601 value@var2717 .@expr1073750602 isUninitValue (@expr1073750603 ) ) {
656: if (@expr1073750604 Token ::@expr8513 Match (@expr1073750606 tok@var2716 , ". %var%" ) ) {
657: setTokenValue (@expr1073750607 tok@var2716 .@expr1073750608 next (@expr1073750609 ) , value@var2717 , settings@var2718 ) ; }
658: if (@expr1073750610 parent@var2721 .@expr8774 isCast (@expr8775 ) ) {
659: setTokenValue (@expr8508 parent@var2721 , value@var2717 , settings@var2718 ) ;
660: return ;
661: }
662: ValueFlow ::@expr1073750614 Value pvalue@var2749 ; pvalue@var2749 =@expr1073750615 value@var2717 ;
663: if (@expr1073750616 !@expr1073750617 value@var2717 .@expr8794 subexpressions@var2750 .@expr1073750619 empty (@expr1073750620 ) &&@expr1073750621 Token ::@expr8513 Match (@expr8799 parent@var2721 , ". %var%" ) ) {
664: if (@expr1073750624 contains (@expr1073750625 value@var2717 .@expr8794 subexpressions@var2750 , parent@var2721 .@expr1073750627 next (@expr1073750628 ) .@expr1073750629 str (@expr1073750630 ) ) ) {
665: pvalue@var2749 .@expr1073750631 subexpressions@var2751 .@expr1073750632 clear (@expr1073750633 ) ; }
666: else {
667: return ; }
668: }
669: if (@expr1073750634 parent@var2721 .@expr8767 isUnaryOp (@expr1073750636 "&" ) ) {
670: pvalue@var2749 .@expr8813 indirect@var2752 ++@expr1073750638 ;
671: setTokenValue (@expr8815 parent@var2721 , pvalue@var2749 , settings@var2718 ) ;
672: } else { if (@expr1073750640 Token ::@expr8513 Match (@expr8799 parent@var2721 , ". %var%" ) &&@expr1073750643 parent@var2721 .@expr8516 astOperand1 (@expr8517 ) ==@expr8822 tok@var2716 ) {
673: if (@expr1073750647 parent@var2721 .@expr1073750648 originalName (@expr1073750649 ) ==@expr1073750650 "->" &&@expr1073750651 pvalue@var2749 .@expr8813 indirect@var2752 >@expr8829 0 ) {
674: pvalue@var2749 .@expr8813 indirect@var2752 --@expr1073750655 ; }
675: setTokenValue (@expr1073750656 parent@var2721 .@expr8519 astOperand2 (@expr8520 ) , pvalue@var2749 , settings@var2718 ) ;
676: } else { if (@expr1073750659 Token ::@expr8513 Match (@expr1073750661 parent@var2721 .@expr8636 astParent (@expr8637 ) , ". %var%" ) &&@expr1073750664 parent@var2721 .@expr8636 astParent (@expr8637 ) .@expr1073750667 astOperand1 (@expr1073750668 ) ==@expr1073750669 parent@var2721 ) {
677: if (@expr1073750670 parent@var2721 .@expr8636 astParent (@expr8637 ) .@expr1073750673 originalName (@expr1073750674 ) ==@expr1073750675 "->" &&@expr1073750676 pvalue@var2749 .@expr8813 indirect@var2752 >@expr8829 0 ) {
678: pvalue@var2749 .@expr8813 indirect@var2752 --@expr1073750680 ; }
679: setTokenValue (@expr1073750681 parent@var2721 .@expr8636 astParent (@expr8637 ) .@expr1073750684 astOperand2 (@expr1073750685 ) , pvalue@var2749 , settings@var2718 ) ;
680: } else { if (@expr1073750686 parent@var2721 .@expr8767 isUnaryOp (@expr8768 "*" ) &&@expr1073750689 pvalue@var2749 .@expr8813 indirect@var2752 >@expr8829 0 ) {
681: pvalue@var2749 .@expr8813 indirect@var2752 --@expr1073750693 ;
682: setTokenValue (@expr8815 parent@var2721 , pvalue@var2749 , settings@var2718 ) ;
683: } } } }
684: return ;
685: }
686:
687:
688: if (@expr1073750695 const Token *@expr8707 castType@var2753 =@expr1073750697 getCastTypeStartToken (@expr1073750698 parent@var2721 ) ) {
689: if (@expr1073750699 (@expr1073750700 (@expr1073750701 tok@var2716 .@expr8472 valueType (@expr8473 ) ==@expr1073750704 nullptr &&@expr1073750705 value@var2717 .@expr8458 isImpossible (@expr8459 ) ) ||@expr1073750708 astIsPointer (@expr8762 tok@var2716 ) ) &&@expr1073750710
690: contains (@expr1073750711 {@expr1073750712 ValueFlow ::@expr8553 Value ::@expr8554 ValueType ::@expr8555 INT , ValueFlow ::@expr8553 Value ::@expr8554 ValueType ::@expr1073750718 SYMBOLIC } , value@var2717 .@expr1073750719 valueType@var2754 ) &&@expr1073750720
691: Token ::@expr8500 simpleMatch (@expr1073750722 parent@var2721 .@expr8516 astOperand1 (@expr8517 ) , "dynamic_cast" ) ) {
692: return ; }
693: const ValueType &@expr8523 valueType@var2755 =@expr1073750726 ValueType ::@expr1073750727 parseDecl (@expr1073750728 castType@var2753 , settings@var2718 ) ;
694: if (@expr1073750729 value@var2717 .@expr8458 isImpossible (@expr8459 ) &&@expr1073750732 value@var2717 .@expr8461 isIntValue (@expr8462 ) &&@expr1073750735 value@var2717 .@expr8464 intvalue@var2719 <@expr8465 0 &&@expr1073750738 astIsUnsigned (@expr8467 tok@var2716 ) &&@expr1073750740
695: valueType@var2755 .@expr1073750741 sign@var2756 ==@expr1073750742 ValueType ::@expr1073750743 SIGNED &&@expr1073750744 tok@var2716 .@expr8472 valueType (@expr8473 ) &&@expr1073750747
696: ValueFlow ::@expr8469 getSizeOf (@expr8470 *@expr8471 tok@var2716 .@expr8472 valueType (@expr8473 ) , settings@var2718 ) >=@expr1073750753 ValueFlow ::@expr8469 getSizeOf (@expr1073750755 valueType@var2755 , settings@var2718 ) ) {
697: return ; }
698: setTokenValueCast (@expr1073750756 parent@var2721 , valueType@var2755 , value@var2717 , settings@var2718 ) ;
699: }
700:
701: else { if (@expr1073750757 parent@var2721 .@expr8570 str (@expr8571 ) ==@expr1073750760 ":" ) {
702: setTokenValue (@expr8508 parent@var2721 , value@var2717 , settings@var2718 ) ;
703: }
704:
705: else { if (@expr1073750762 parent@var2721 .@expr8570 str (@expr8571 ) ==@expr8941 "?" &&@expr1073750766 tok@var2716 .@expr1073750767 str (@expr1073750768 ) ==@expr1073750769 ":" &&@expr1073750770 tok@var2716 ==@expr8947 parent@var2721 .@expr8519 astOperand2 (@expr8520 ) &&@expr1073750774 parent@var2721 .@expr8516 astOperand1 (@expr8517 ) ) {
706:
707: if (@expr1073750777 parent@var2721 .@expr8516 astOperand1 (@expr8517 ) .@expr1073750780 hasKnownValue (@expr1073750781 ) ) {
708: const ValueFlow ::@expr8522 Value &@expr8523 condvalue@var2757 =@expr1073750784 parent@var2721 .@expr8516 astOperand1 (@expr8517 ) .@expr8527 values (@expr8528 ) .@expr1073750789 front (@expr1073750790 ) ;
709: const bool cond@var2758 (@expr1073750791 condvalue@var2757 .@expr1073750792 isTokValue (@expr1073750793 ) ||@expr1073750794 (@expr1073750795 condvalue@var2757 .@expr1073750796 isIntValue (@expr1073750797 ) &&@expr1073750798 condvalue@var2757 .@expr1073750799 intvalue@var2759 !=@expr1073750800 0 ) ) ;
710: if (@expr1073750801 cond@var2758 &&@expr1073750802 !@expr1073750803 tok@var2716 .@expr8980 astOperand1 (@expr8981 ) ) {
711: setTokenValue (@expr1073750806 parent@var2721 , condvalue@var2757 , settings@var2718 ) ;
712: } else {
713: const Token * op@var2760 ; op@var2760 =@expr1073750807 cond@var2758 ?@expr1073750808 tok@var2716 .@expr8980 astOperand1 (@expr8981 ) :@expr1073750811 tok@var2716 .@expr1073750812 astOperand2 (@expr1073750813 ) ;
714: if (@expr1073750814 !@expr1073750815 op@var2760 ) {
715: return ; }
716: const std ::@expr8992 list < ValueFlow ::@expr8522 Value > & values@var2761 =@expr1073750818 op@var2760 .@expr1073750819 values (@expr1073750820 ) ;
717: if (@expr1073750821 std ::@expr1073750822 find (@expr1073750823 values@var2761 .@expr1073750824 begin (@expr1073750825 ) , values@var2761 .@expr9002 end (@expr9003 ) , value@var2717 ) !=@expr1073750828 values@var2761 .@expr9002 end (@expr9003 ) ) {
718: setTokenValue (@expr8508 parent@var2721 , value@var2717 , settings@var2718 ) ; }
719: }
720: } else { if (@expr1073750832 !@expr8457 value@var2717 .@expr8458 isImpossible (@expr8459 ) ) {
721:
722:
723: int varId@var2762 ; varId@var2762 =@expr1073750836 0 ;
724: bool ret@var2763 ; ret@var2763 =@expr1073750837 false ;
725: visitAstNodes (@expr1073750838 parent@var2721 .@expr8516 astOperand1 (@expr8517 ) ,
726: [@expr1073750841 &@expr8523 ] (@expr1073750843 const Token *@expr8707 t@var2764 ) {
727: if (@expr1073750845 t@var2764 .@expr9022 varId (@expr9023 ) ) {
728: if (@expr1073750848 varId@var2762 >@expr1073750849 0 ||@expr1073750850 value@var2717 .@expr1073750851 varId@var2765 !=@expr1073750852 0 ) {
729: ret@var2763 =@expr1073750853 true ; }
730: varId@var2762 =@expr1073750854 t@var2764 .@expr9022 varId (@expr9023 ) ;
731: } else { if (@expr1073750857 t@var2764 .@expr1073750858 str (@expr1073750859 ) ==@expr1073750860 "(" &&@expr1073750861 Token ::@expr8513 Match (@expr1073750863 t@var2764 .@expr1073750864 previous (@expr1073750865 ) , "%name%" ) ) {
732: ret@var2763 =@expr1073750866 true ; } }
733: return ret@var2763 ?@expr1073750867 ChildrenToVisit ::@expr1073750868 done :@expr1073750869 ChildrenToVisit ::@expr1073750870 op1_and_op2 ;
734: } ) ;
735: if (@expr1073750871 ret@var2763 ) {
736: return ; }
737:
738: ValueFlow ::@expr1073750872 Value v@var2766 (@expr1073750873 value@var2717 ) ;
739: v@var2766 .@expr1073750874 conditional@var2767 =@expr1073750875 true ;
740: v@var2766 .@expr1073750876 changeKnownToPossible (@expr1073750877 ) ;
741:
742: setTokenValue (@expr1073750878 parent@var2721 , v@var2766 , settings@var2718 ) ;
743: } }
744: }
745:
746: else { if (@expr1073750879 parent@var2721 .@expr8570 str (@expr8571 ) ==@expr8941 "?" &&@expr1073750883 value@var2717 .@expr8461 isIntValue (@expr8462 ) &&@expr1073750886 tok@var2716 ==@expr8822 parent@var2721 .@expr8516 astOperand1 (@expr8517 ) &&@expr1073750890 value@var2717 .@expr9067 isKnown (@expr9068 ) &&@expr1073750893
747: parent@var2721 .@expr8519 astOperand2 (@expr8520 ) &&@expr1073750896 parent@var2721 .@expr8519 astOperand2 (@expr8520 ) .@expr9075 astOperand1 (@expr9076 ) &&@expr1073750901 parent@var2721 .@expr8519 astOperand2 (@expr8520 ) .@expr9080 astOperand2 (@expr9081 ) ) {
748: const std ::@expr8992 list < ValueFlow ::@expr8522 Value > & values@var2768 =@expr1073750908 value@var2717 .@expr8464 intvalue@var2719 ==@expr9086 0
749: ?@expr1073750911 parent@var2721 .@expr8519 astOperand2 (@expr8520 ) .@expr9080 astOperand2 (@expr9081 ) .@expr1073750916 values (@expr1073750917 )
750: :@expr1073750918 parent@var2721 .@expr8519 astOperand2 (@expr8520 ) .@expr9075 astOperand1 (@expr9076 ) .@expr1073750923 values (@expr1073750924 ) ;
751:
752: for (@expr1073750925 const ValueFlow ::@expr8522 Value &@expr8523 v@var2769 :@expr1073750928 values@var2768 ) {
753: setTokenValue (@expr1073750929 parent@var2721 , v@var2769 , settings@var2718 ) ; }
754: }
755:
756:
757: else { if (@expr1073750930 (@expr1073750931 parent@var2721 .@expr8771 isArithmeticalOp (@expr8772 ) ||@expr1073750934 parent@var2721 .@expr1073750935 isComparisonOp (@expr1073750936 ) ||@expr1073750937 (@expr1073750938 parent@var2721 .@expr9115 tokType (@expr9116 ) ==@expr1073750941 Token ::@expr1073750942 eBitOp ) ||@expr1073750943 (@expr1073750944 parent@var2721 .@expr9115 tokType (@expr9116 ) ==@expr1073750947 Token ::@expr1073750948 eLogicalOp ) ) &&@expr1073750949
758: parent@var2721 .@expr8516 astOperand1 (@expr8517 ) &&@expr1073750952
759: parent@var2721 .@expr8519 astOperand2 (@expr8520 ) ) {
760:
761: const bool noninvertible@var2770 =@expr1073750955 isNonInvertibleOperation (@expr1073750956 parent@var2721 ) ;
762:
763:
764: if (@expr1073750957 noninvertible@var2770 &&@expr1073750958 value@var2717 .@expr8458 isImpossible (@expr8459 ) ) {
765: return ; }
766:
767:
768: if (@expr1073750961 Token ::@expr8513 Match (@expr1073750963 parent@var2721 , "[&*]" ) &&@expr1073750964 astIsIntegral (@expr1073750965 parent@var2721 , true ) &&@expr1073750966 value@var2717 .@expr9067 isKnown (@expr9068 ) &&@expr1073750969 value@var2717 .@expr8461 isIntValue (@expr8462 ) &&@expr1073750972
769: value@var2717 .@expr8464 intvalue@var2719 ==@expr9086 0 ) {
770: setTokenValue (@expr8508 parent@var2721 , value@var2717 , settings@var2718 ) ;
771: return ;
772: }
773:
774:
775: if (@expr1073750976 Token ::@expr8500 simpleMatch (@expr1073750978 parent@var2721 , "&&" ) &&@expr1073750979 value@var2717 .@expr9067 isKnown (@expr9068 ) &&@expr1073750982 value@var2717 .@expr8461 isIntValue (@expr8462 ) &&@expr1073750985 value@var2717 .@expr8464 intvalue@var2719 ==@expr9086 0 ) {
776: setTokenValue (@expr8508 parent@var2721 , value@var2717 , settings@var2718 ) ;
777: return ;
778: }
779:
780:
781: if (@expr1073750989 Token ::@expr8500 simpleMatch (@expr1073750991 parent@var2721 , "||" ) &&@expr1073750992 value@var2717 .@expr9067 isKnown (@expr9068 ) &&@expr1073750995 value@var2717 .@expr8461 isIntValue (@expr8462 ) &&@expr1073750998 value@var2717 .@expr8464 intvalue@var2719 !=@expr1073751000 0 ) {
782: setTokenValue (@expr8508 parent@var2721 , value@var2717 , settings@var2718 ) ;
783: return ;
784: }
785:
786: for (@expr1073751002 const ValueFlow ::@expr8522 Value &@expr8523 value1@var2771 :@expr1073751005 parent@var2721 .@expr8516 astOperand1 (@expr8517 ) .@expr8527 values (@expr8528 ) ) {
787: if (@expr1073751010 !@expr1073751011 isComputableValue (@expr1073751012 parent@var2721 , value1@var2771 ) ) {
788: continue ; }
789: for (@expr1073751013 const ValueFlow ::@expr8522 Value &@expr8523 value2@var2772 :@expr1073751016 parent@var2721 .@expr8519 astOperand2 (@expr8520 ) .@expr8538 values (@expr8539 ) ) {
790: if (@expr1073751021 value1@var2771 .@expr1073751022 path@var2773 !=@expr1073751023 value2@var2772 .@expr1073751024 path@var2774 ) {
791: continue ; }
792: if (@expr1073751025 !@expr1073751026 isComputableValue (@expr1073751027 parent@var2721 , value2@var2772 ) ) {
793: continue ; }
794: if (@expr1073751028 value1@var2771 .@expr1073751029 isIteratorValue (@expr1073751030 ) &&@expr1073751031 value2@var2772 .@expr1073751032 isIteratorValue (@expr1073751033 ) ) {
795: continue ; }
796: if (@expr1073751034 !@expr1073751035 isCompatibleValues (@expr1073751036 value1@var2771 , value2@var2772 ) ) {
797: continue ; }
798: ValueFlow ::@expr1073751037 Value result@var2775 (@expr1073751038 0 ) ;
799: combineValueProperties (@expr1073751039 value1@var2771 , value2@var2772 , &@expr1073751040 result@var2775 ) ;
800: if (@expr1073751041 astIsFloat (@expr1073751042 parent@var2721 , false ) ) {
801: if (@expr1073751043 !@expr1073751044 result@var2775 .@expr1073751045 isIntValue (@expr1073751046 ) &&@expr1073751047 !@expr9224 result@var2775 .@expr9225 isFloatValue (@expr9226 ) ) {
802: continue ; }
803: result@var2775 .@expr1073751051 valueType@var2776 =@expr1073751052 ValueFlow ::@expr8553 Value ::@expr8554 ValueType ::@expr1073751055 FLOAT ;
804: }
805: const double floatValue1@var2777 =@expr1073751056 value1@var2771 .@expr9233 isFloatValue (@expr9234 ) ?@expr1073751059 value1@var2771 .@expr9236 floatValue@var2778 :@expr1073751061 value1@var2771 .@expr9238 intvalue@var2779 ;
806: const double floatValue2@var2780 =@expr1073751063 value2@var2772 .@expr9240 isFloatValue (@expr9241 ) ?@expr1073751066 value2@var2772 .@expr9243 floatValue@var2781 :@expr1073751068 value2@var2772 .@expr9245 intvalue@var2782 ;
807: const long long intValue1@var2783 =@expr1073751070
808: value1@var2771 .@expr9233 isFloatValue (@expr9234 ) ?@expr1073751073 (@expr1073751074 static_cast < long long > (@expr1073751075 value1@var2771 .@expr9236 floatValue@var2778 ) ) :@expr1073751077 value1@var2771 .@expr9238 intvalue@var2779 ;
809: const long long intValue2@var2784 =@expr1073751079
810: value2@var2772 .@expr9240 isFloatValue (@expr9241 ) ?@expr1073751082 (@expr1073751083 static_cast < long long > (@expr1073751084 value2@var2772 .@expr9243 floatValue@var2781 ) ) :@expr1073751086 value2@var2772 .@expr9245 intvalue@var2782 ;
811: if (@expr1073751088 (@expr1073751089 value1@var2771 .@expr9233 isFloatValue (@expr9234 ) ||@expr1073751092 value2@var2772 .@expr9240 isFloatValue (@expr9241 ) ) &&@expr1073751095 Token ::@expr8513 Match (@expr1073751097 parent@var2721 , "&|^|%|<<|>>|==|!=|%or%" ) ) {
812: continue ; }
813: if (@expr1073751098 Token ::@expr8513 Match (@expr1073751100 parent@var2721 , "==|!=" ) ) {
814: if (@expr1073751101 (@expr1073751102 value1@var2771 .@expr9279 isIntValue (@expr9280 ) &&@expr1073751105 value2@var2772 .@expr9282 isTokValue (@expr9283 ) ) ||@expr1073751108 (@expr1073751109 value1@var2771 .@expr9286 isTokValue (@expr9287 ) &&@expr1073751112 value2@var2772 .@expr9289 isIntValue (@expr9290 ) ) ) {
815: if (@expr1073751115 parent@var2721 .@expr8570 str (@expr8571 ) ==@expr1073751118 "==" ) {
816: result@var2775 .@expr9295 intvalue@var2785 =@expr1073751120 0 ; }
817: else { if (@expr1073751121 parent@var2721 .@expr8570 str (@expr8571 ) ==@expr1073751124 "!=" ) {
818: result@var2775 .@expr9295 intvalue@var2785 =@expr1073751126 1 ; } }
819: } else { if (@expr1073751127 value1@var2771 .@expr9279 isIntValue (@expr9280 ) &&@expr1073751130 value2@var2772 .@expr9289 isIntValue (@expr9290 ) ) {
820: bool error@var2786 ; error@var2786 =@expr1073751133 false ;
821: result@var2775 .@expr9295 intvalue@var2785 =@expr1073751135 calculate (@expr1073751136 parent@var2721 .@expr8570 str (@expr8571 ) , intValue1@var2783 , intValue2@var2784 , &@expr1073751139 error@var2786 ) ;
822: if (@expr1073751140 error@var2786 ) {
823: continue ; }
824: } else {
825: continue ;
826: } }
827: setTokenValue (@expr9317 parent@var2721 , result@var2775 , settings@var2718 ) ;
828: } else { if (@expr1073751142 Token ::@expr8513 Match (@expr1073751144 parent@var2721 , "%op%" ) ) {
829: if (@expr8548 Token ::@expr8513 Match (@expr8550 parent@var2721 , "%comp%" ) ) {
830: if (@expr1073751148 !@expr9224 result@var2775 .@expr9225 isFloatValue (@expr9226 ) &&@expr1073751152 !@expr1073751153 value1@var2771 .@expr9279 isIntValue (@expr9280 ) &&@expr1073751156 !@expr1073751157 value2@var2772 .@expr9289 isIntValue (@expr9290 ) ) {
831: continue ; }
832: } else {
833: if (@expr1073751160 value1@var2771 .@expr9286 isTokValue (@expr9287 ) ||@expr1073751163 value2@var2772 .@expr9282 isTokValue (@expr9283 ) ) {
834: break ; }
835: }
836: bool error@var2787 ; error@var2787 =@expr1073751166 false ;
837: if (@expr1073751167 result@var2775 .@expr9225 isFloatValue (@expr9226 ) ) {
838: result@var2775 .@expr1073751170 floatValue@var2788 =@expr1073751171 calculate (@expr1073751172 parent@var2721 .@expr8570 str (@expr8571 ) , floatValue1@var2777 , floatValue2@var2780 , &@expr9351 error@var2787 ) ;
839: } else {
840: result@var2775 .@expr9295 intvalue@var2785 =@expr1073751177 calculate (@expr1073751178 parent@var2721 .@expr8570 str (@expr8571 ) , intValue1@var2783 , intValue2@var2784 , &@expr9351 error@var2787 ) ;
841: }
842: if (@expr1073751182 error@var2787 ) {
843: continue ; }
844:
845: if (@expr1073751183 Token ::@expr8500 simpleMatch (@expr1073751185 parent@var2721 , "-" ) &&@expr1073751186 value2@var2772 .@expr9363 bound@var2789 ==@expr1073751188 result@var2775 .@expr1073751189 bound@var2790 &&@expr1073751190
846: value2@var2772 .@expr9363 bound@var2789 !=@expr1073751192 ValueFlow ::@expr8553 Value ::@expr1073751194 Bound ::@expr1073751195 Point@expr1073750278 ) {
847: result@var2775 .@expr1073751196 invertBound (@expr1073751197 ) ; }
848: setTokenValue (@expr9317 parent@var2721 , result@var2775 , settings@var2718 ) ;
849: } }
850: }
851: }
852: }
853:
854:
855: else { if (@expr1073751199 parent@var2721 .@expr8570 str (@expr8571 ) ==@expr1073751202 "!" ) {
856: for (@expr1073751203 const ValueFlow ::@expr8522 Value &@expr8523 val@var2791 :@expr1073751206 tok@var2716 .@expr9383 values (@expr9384 ) ) {
857: if (@expr1073751209 !@expr1073751210 val@var2791 .@expr1073751211 isIntValue (@expr1073751212 ) ) {
858: continue ; }
859: if (@expr1073751213 val@var2791 .@expr1073751214 isImpossible (@expr1073751215 ) &&@expr1073751216 val@var2791 .@expr1073751217 intvalue@var2792 !=@expr1073751218 0 ) {
860: continue ; }
861: ValueFlow ::@expr1073751219 Value v@var2793 (@expr1073751220 val@var2791 ) ;
862: v@var2793 .@expr9397 intvalue@var2794 =@expr1073751222 !@expr1073751223 v@var2793 .@expr9397 intvalue@var2794 ;
863: setTokenValue (@expr1073751225 parent@var2721 , v@var2793 , settings@var2718 ) ;
864: }
865: }
866:
867:
868: else { if (@expr1073751226 parent@var2721 .@expr8570 str (@expr8571 ) ==@expr1073751229 "~" ) {
869: for (@expr1073751230 const ValueFlow ::@expr8522 Value &@expr8523 val@var2795 :@expr1073751233 tok@var2716 .@expr9383 values (@expr9384 ) ) {
870: if (@expr1073751236 !@expr1073751237 val@var2795 .@expr1073751238 isIntValue (@expr1073751239 ) ) {
871: continue ; }
872: ValueFlow ::@expr1073751240 Value v@var2796 (@expr1073751241 val@var2795 ) ;
873: v@var2796 .@expr9418 intvalue@var2797 =@expr1073751243 ~@expr1073751244 v@var2796 .@expr9418 intvalue@var2797 ;
874: int bits@var2798 ; bits@var2798 =@expr1073751246 0 ;
875: if (@expr1073751247 settings@var2718 &&@expr1073751248
876: tok@var2716 .@expr8472 valueType (@expr8473 ) &&@expr1073751251
877: tok@var2716 .@expr8472 valueType (@expr8473 ) .@expr1073751254 sign@var5316 ==@expr1073751255 ValueType ::@expr1073751256 Sign ::@expr1073751257 UNSIGNED &&@expr1073751258
878: tok@var2716 .@expr8472 valueType (@expr8473 ) .@expr1073751261 pointer@var5317 ==@expr1073751262 0 ) {
879: if (@expr1073751263 tok@var2716 .@expr8472 valueType (@expr8473 ) .@expr9442 type@var5318 ==@expr1073751267 ValueType ::@expr9444 Type ::@expr1073751269 INT ) {
880: bits@var2798 =@expr1073751270 settings@var2718 .@expr1073751271 int_bit@var2799 ; }
881: else { if (@expr1073751272 tok@var2716 .@expr8472 valueType (@expr8473 ) .@expr9442 type@var5318 ==@expr1073751276 ValueType ::@expr9444 Type ::@expr1073751278 LONG ) {
882: bits@var2798 =@expr1073751279 settings@var2718 .@expr1073751280 long_bit@var2800 ; } }
883: }
884: if (@expr1073751281 bits@var2798 >@expr1073751282 0 &&@expr1073751283 bits@var2798 <@expr1073751284 MathLib ::@expr1073751285 bigint_bits@var15 ) {
885: v@var2796 .@expr9418 intvalue@var2797 &=@expr1073751287 (@expr1073751288 (@expr1073751289 (@expr1073751290 unsigned long long ) 1 ) <<@expr1073751291 bits@var2798 ) -@expr1073751292 1 ; }
886: setTokenValue (@expr1073751293 parent@var2721 , v@var2796 , settings@var2718 ) ;
887: }
888: }
889:
890:
891: else { if (@expr1073751294 parent@var2721 .@expr8767 isUnaryOp (@expr1073751296 "-" ) ) {
892: for (@expr1073751297 const ValueFlow ::@expr8522 Value &@expr8523 val@var2801 :@expr1073751300 tok@var2716 .@expr9383 values (@expr9384 ) ) {
893: if (@expr1073751303 !@expr1073751304 val@var2801 .@expr1073751305 isIntValue (@expr1073751306 ) &&@expr1073751307 !@expr1073751308 val@var2801 .@expr1073751309 isFloatValue (@expr1073751310 ) ) {
894: continue ; }
895: ValueFlow ::@expr1073751311 Value v@var2802 (@expr1073751312 val@var2801 ) ;
896: if (@expr1073751313 v@var2802 .@expr1073751314 isIntValue (@expr1073751315 ) ) {
897: if (@expr1073751316 v@var2802 .@expr9493 intvalue@var2803 ==@expr1073751318 LLONG_MIN@expr1073750279 ) {
898:
899: continue ; }
900: v@var2802 .@expr9493 intvalue@var2803 =@expr1073751320 -@expr1073751321 v@var2802 .@expr9493 intvalue@var2803 ;
901: } else {
902: v@var2802 .@expr9499 floatValue@var2804 =@expr1073751324 -@expr1073751325 v@var2802 .@expr9499 floatValue@var2804 ; }
903: v@var2802 .@expr1073751327 invertBound (@expr1073751328 ) ;
904: setTokenValue (@expr1073751329 parent@var2721 , v@var2802 , settings@var2718 ) ;
905: }
906: }
907:
908:
909: else { if (@expr1073751330 parent@var2721 .@expr8570 str (@expr8571 ) ==@expr1073751333 "++" ) {
910: for (@expr1073751334 const ValueFlow ::@expr8522 Value &@expr8523 val@var2805 :@expr1073751337 tok@var2716 .@expr9383 values (@expr9384 ) ) {
911: if (@expr1073751340 !@expr1073751341 val@var2805 .@expr1073751342 isIntValue (@expr1073751343 ) &&@expr1073751344 !@expr1073751345 val@var2805 .@expr1073751346 isFloatValue (@expr1073751347 ) &&@expr1073751348 !@expr1073751349 val@var2805 .@expr1073751350 isSymbolicValue (@expr1073751351 ) ) {
912: continue ; }
913: ValueFlow ::@expr1073751352 Value v@var2806 (@expr1073751353 val@var2805 ) ;
914: if (@expr9530 parent@var2721 ==@expr9531 tok@var2716 .@expr9532 previous (@expr9533 ) ) {
915: if (@expr1073751358 v@var2806 .@expr1073751359 isIntValue (@expr1073751360 ) ||@expr1073751361 v@var2806 .@expr1073751362 isSymbolicValue (@expr1073751363 ) ) {
916: v@var2806 .@expr9540 intvalue@var2807 =@expr1073751365 v@var2806 .@expr9540 intvalue@var2807 +@expr1073751367 1 ; }
917: else {
918: v@var2806 .@expr9544 floatValue@var2808 =@expr1073751369 v@var2806 .@expr9544 floatValue@var2808 +@expr1073751371 1.0 ; }
919: }
920: setTokenValue (@expr1073751372 parent@var2721 , v@var2806 , settings@var2718 ) ;
921: }
922: }
923:
924:
925: else { if (@expr1073751373 parent@var2721 .@expr8570 str (@expr8571 ) ==@expr1073751376 "--" ) {
926: for (@expr1073751377 const ValueFlow ::@expr8522 Value &@expr8523 val@var2809 :@expr1073751380 tok@var2716 .@expr9383 values (@expr9384 ) ) {
927: if (@expr1073751383 !@expr1073751384 val@var2809 .@expr1073751385 isIntValue (@expr1073751386 ) &&@expr1073751387 !@expr1073751388 val@var2809 .@expr1073751389 isFloatValue (@expr1073751390 ) &&@expr1073751391 !@expr1073751392 val@var2809 .@expr1073751393 isSymbolicValue (@expr1073751394 ) ) {
928: continue ; }
929: ValueFlow ::@expr1073751395 Value v@var2810 (@expr1073751396 val@var2809 ) ;
930: if (@expr9530 parent@var2721 ==@expr9531 tok@var2716 .@expr9532 previous (@expr9533 ) ) {
931: if (@expr1073751401 v@var2810 .@expr1073751402 isIntValue (@expr1073751403 ) ||@expr1073751404 v@var2810 .@expr1073751405 isSymbolicValue (@expr1073751406 ) ) {
932: v@var2810 .@expr9583 intvalue@var2811 =@expr1073751408 v@var2810 .@expr9583 intvalue@var2811 -@expr1073751410 1 ; }
933: else {
934: v@var2810 .@expr9587 floatValue@var2812 =@expr1073751412 v@var2810 .@expr9587 floatValue@var2812 -@expr1073751414 1.0 ; }
935: }
936: setTokenValue (@expr1073751415 parent@var2721 , v@var2810 , settings@var2718 ) ;
937: }
938: }
939:
940:
941: else { if (@expr1073751416 parent@var2721 .@expr8570 str (@expr8571 ) ==@expr1073751419 "[" &&@expr1073751420 parent@var2721 .@expr1073751421 isBinaryOp (@expr1073751422 ) ) {
942: for (@expr1073751423 const ValueFlow ::@expr8522 Value &@expr8523 value1@var2813 :@expr1073751426 parent@var2721 .@expr8516 astOperand1 (@expr8517 ) .@expr8527 values (@expr8528 ) ) {
943: if (@expr1073751431 !@expr1073751432 value1@var2813 .@expr1073751433 isTokValue (@expr1073751434 ) ) {
944: continue ; }
945: for (@expr1073751435 const ValueFlow ::@expr8522 Value &@expr8523 value2@var2814 :@expr1073751438 parent@var2721 .@expr8519 astOperand2 (@expr8520 ) .@expr8538 values (@expr8539 ) ) {
946: if (@expr1073751443 !@expr1073751444 value2@var2814 .@expr1073751445 isIntValue (@expr1073751446 ) ) {
947: continue ; }
948: if (@expr1073751447 value1@var2813 .@expr9624 varId@var2815 ==@expr1073751449 0 ||@expr1073751450 value2@var2814 .@expr9627 varId@var2816 ==@expr1073751452 0 ||@expr1073751453
949: (@expr1073751454 value1@var2813 .@expr9624 varId@var2815 ==@expr1073751456 value2@var2814 .@expr9627 varId@var2816 &&@expr1073751458 value1@var2813 .@expr1073751459 varvalue@var2817 ==@expr1073751460 value2@var2814 .@expr1073751461 varvalue@var2818 ) ) {
950: ValueFlow ::@expr1073751462 Value result@var2819 (@expr1073751463 0 ) ;
951: result@var2819 .@expr1073751464 condition@var2820 =@expr1073751465 value1@var2813 .@expr9642 condition@var2821 ?@expr1073751467 value1@var2813 .@expr9642 condition@var2821 :@expr1073751469 value2@var2814 .@expr1073751470 condition@var2822 ;
952: result@var2819 .@expr1073751471 setInconclusive (@expr1073751472 value1@var2813 .@expr1073751473 isInconclusive (@expr1073751474 ) |@expr1073751475 value2@var2814 .@expr1073751476 isInconclusive (@expr1073751477 ) ) ;
953: result@var2819 .@expr9654 varId@var2823 =@expr1073751479 (@expr1073751480 value1@var2813 .@expr9624 varId@var2815 !=@expr1073751482 0 ) ?@expr1073751483 value1@var2813 .@expr9624 varId@var2815 :@expr1073751485 value2@var2814 .@expr9627 varId@var2816 ;
954: result@var2819 .@expr1073751487 varvalue@var2824 =@expr1073751488 (@expr1073751489 result@var2819 .@expr9654 varId@var2823 ==@expr1073751491 value1@var2813 .@expr9624 varId@var2815 ) ?@expr1073751493 value1@var2813 .@expr1073751494 intvalue@var2825 :@expr1073751495 value2@var2814 .@expr9672 intvalue@var2826 ;
955: if (@expr1073751497 value1@var2813 .@expr9674 valueKind@var2827 ==@expr1073751499 value2@var2814 .@expr1073751500 valueKind@var2828 ) {
956: result@var2819 .@expr1073751501 valueKind@var2829 =@expr1073751502 value1@var2813 .@expr9674 valueKind@var2827 ; }
957: if (@expr1073751504 value1@var2813 .@expr9681 tokvalue@var2830 .@expr1073751506 tokType (@expr1073751507 ) ==@expr1073751508 Token ::@expr8585 eString ) {
958: const std ::@expr8522 string s@var2831 =@expr1073751511 value1@var2813 .@expr9681 tokvalue@var2830 .@expr1073751513 strValue (@expr1073751514 ) ;
959: const long long index@var2832 =@expr1073751515 value2@var2814 .@expr9672 intvalue@var2826 ;
960: if (@expr1073751517 index@var2832 ==@expr1073751518 s@var2831 .@expr9695 size (@expr9696 ) ) {
961: result@var2819 .@expr9697 intvalue@var2833 =@expr1073751522 0 ;
962: setTokenValue (@expr9699 parent@var2721 , result@var2819 , settings@var2718 ) ;
963: } else { if (@expr1073751524 index@var2832 >=@expr1073751525 0 &&@expr1073751526 index@var2832 <@expr1073751527 s@var2831 .@expr9695 size (@expr9696 ) ) {
964: result@var2819 .@expr9697 intvalue@var2833 =@expr1073751531 s@var2831 [@expr1073751532 index@var2832 ] ;
965: setTokenValue (@expr9699 parent@var2721 , result@var2819 , settings@var2718 ) ;
966: } }
967: } else { if (@expr1073751534 value1@var2813 .@expr9681 tokvalue@var2830 .@expr1073751536 str (@expr1073751537 ) ==@expr1073751538 "{" ) {
968: long long index@var2834 ; index@var2834 =@expr1073751539 value2@var2814 .@expr9672 intvalue@var2826 ;
969: const Token * element@var2835 ; element@var2835 =@expr1073751541 value1@var2813 .@expr9681 tokvalue@var2830 .@expr1073751543 next (@expr1073751544 ) ;
970: while (@expr1073751545 index@var2834 >@expr1073751546 0 &&@expr1073751547 element@var2835 .@expr9724 str (@expr9725 ) !=@expr1073751550 "}" ) {
971: if (@expr1073751551 element@var2835 .@expr9724 str (@expr9725 ) ==@expr1073751554 "," ) {
972: --@expr1073751555 index@var2834 ; }
973: if (@expr1073751556 Token ::@expr8513 Match (@expr1073751558 element@var2835 , "[{}()[]]" ) ) {
974: break ; }
975: element@var2835 =@expr1073751559 element@var2835 .@expr1073751560 next (@expr1073751561 ) ;
976: }
977: if (@expr1073751562 Token ::@expr8513 Match (@expr1073751564 element@var2835 , "%num% [,}]" ) ) {
978: result@var2819 .@expr9697 intvalue@var2833 =@expr1073751566 MathLib ::@expr1073751567 toLongNumber (@expr1073751568 element@var2835 .@expr9724 str (@expr9725 ) ) ;
979: setTokenValue (@expr9699 parent@var2721 , result@var2819 , settings@var2718 ) ;
980: }
981: } }
982: }
983: }
984: }
985: }
986:
987: else { if (@expr1073751572 Token ::@expr8513 Match (@expr1073751574 parent@var2721 , ":: %name%" ) &&@expr1073751575 parent@var2721 .@expr8519 astOperand2 (@expr8520 ) ==@expr8947 tok@var2716 ) {
988: setTokenValue (@expr8508 parent@var2721 , value@var2717 , settings@var2718 ) ;
989: }
990:
991: else { if (@expr1073751580 value@var2717 .@expr1073751581 isTokValue (@expr1073751582 ) &&@expr1073751583 Token ::@expr8500 simpleMatch (@expr1073751585 value@var2717 .@expr9762 tokvalue@var2836 , "{" ) &&@expr1073751587 tok@var2716 .@expr9764 variable (@expr9765 ) &&@expr1073751590
992: tok@var2716 .@expr9764 variable (@expr9765 ) .@expr1073751593 isArray (@expr1073751594 ) &&@expr1073751595 Token ::@expr8513 Match (@expr8702 parent@var2721 .@expr8703 previous (@expr8704 ) , "%name% (" ) &&@expr1073751600 astIsRHS (@expr8503 tok@var2716 ) ) {
993: std ::@expr1073751602 vector < const Token *@expr8707 > args@var2837 ; args@var2837 =@expr1073751604 getArguments (@expr1073751605 value@var2717 .@expr9762 tokvalue@var2836 ) ;
994: if (@expr1073751607 const Library ::@expr8522 Function *@expr8707 f@var2838 =@expr1073751610 settings@var2718 .@expr8709 library@var2741 .@expr8710 getFunction (@expr8711 parent@var2721 .@expr8703 previous (@expr8704 ) ) ) {
995: if (@expr1073751616 f@var2838 .@expr9793 containerYield@var2839 ==@expr1073751618 Library ::@expr8649 Container ::@expr8664 Yield ::@expr8670 SIZE ) {
996: ValueFlow ::@expr1073751622 Value v@var2840 (@expr1073751623 value@var2717 ) ;
997: v@var2840 .@expr1073751624 valueType@var2841 =@expr1073751625 ValueFlow ::@expr8553 Value ::@expr8554 ValueType ::@expr8555 INT ;
998: v@var2840 .@expr1073751629 intvalue@var2842 =@expr1073751630 args@var2837 .@expr1073751631 size (@expr1073751632 ) ;
999: setTokenValue (@expr1073751633 parent@var2721 , v@var2840 , settings@var2718 ) ;
1000: } else { if (@expr1073751634 f@var2838 .@expr9793 containerYield@var2839 ==@expr1073751636 Library ::@expr8649 Container ::@expr8664 Yield ::@expr8685 EMPTY ) {
1001: ValueFlow ::@expr1073751640 Value v@var2843 (@expr1073751641 value@var2717 ) ;
1002: v@var2843 .@expr1073751642 intvalue@var2844 =@expr1073751643 args@var2837 .@expr1073751644 empty (@expr1073751645 ) ;
1003: v@var2843 .@expr1073751646 valueType@var2845 =@expr1073751647 ValueFlow ::@expr8553 Value ::@expr8554 ValueType ::@expr8555 INT ;
1004: setTokenValue (@expr1073751651 parent@var2721 , v@var2843 , settings@var2718 ) ;
1005: } }
1006: }
1007: } } } } } } } } } } } } }
1008: }
1009:
1010: static void setTokenValueCast ( Token * parent@var2846 , const ValueType & valueType@var2847 , const ValueFlow :: Value & value@var2848 , const Settings * settings@var2849 )
1011: {
1012: if (@expr1073751652 valueType@var2847 .@expr1073751653 pointer@var2850 ||@expr1073751654 value@var2848 .@expr1073751655 isImpossible (@expr1073751656 ) ) {
1013: setTokenValue (@expr9833 parent@var2846 , value@var2848 , settings@var2849 ) ; }
1014: else { if (@expr1073751658 valueType@var2847 .@expr9835 type@var2851 ==@expr1073751660 ValueType ::@expr9837 Type ::@expr1073751662 CHAR ) {
1015: setTokenValue (@expr1073751663 parent@var2846 , castValue (@expr1073751664 value@var2848 , valueType@var2847 .@expr9841 sign@var2852 , settings@var2849 .@expr1073751666 char_bit@var2853 ) , settings@var2849 ) ; }
1016: else { if (@expr1073751667 valueType@var2847 .@expr9835 type@var2851 ==@expr1073751669 ValueType ::@expr9837 Type ::@expr1073751671 SHORT ) {
1017: setTokenValue (@expr1073751672 parent@var2846 , castValue (@expr1073751673 value@var2848 , valueType@var2847 .@expr9841 sign@var2852 , settings@var2849 .@expr1073751675 short_bit@var2854 ) , settings@var2849 ) ; }
1018: else { if (@expr1073751676 valueType@var2847 .@expr9835 type@var2851 ==@expr1073751678 ValueType ::@expr9837 Type ::@expr1073751680 INT ) {
1019: setTokenValue (@expr1073751681 parent@var2846 , castValue (@expr1073751682 value@var2848 , valueType@var2847 .@expr9841 sign@var2852 , settings@var2849 .@expr1073751684 int_bit@var2855 ) , settings@var2849 ) ; }
1020: else { if (@expr1073751685 valueType@var2847 .@expr9835 type@var2851 ==@expr1073751687 ValueType ::@expr9837 Type ::@expr1073751689 LONG ) {
1021: setTokenValue (@expr1073751690 parent@var2846 , castValue (@expr1073751691 value@var2848 , valueType@var2847 .@expr9841 sign@var2852 , settings@var2849 .@expr1073751693 long_bit@var2856 ) , settings@var2849 ) ; }
1022: else { if (@expr1073751694 valueType@var2847 .@expr9835 type@var2851 ==@expr1073751696 ValueType ::@expr9837 Type ::@expr1073751698 LONGLONG ) {
1023: setTokenValue (@expr1073751699 parent@var2846 , castValue (@expr1073751700 value@var2848 , valueType@var2847 .@expr9841 sign@var2852 , settings@var2849 .@expr1073751702 long_long_bit@var2857 ) , settings@var2849 ) ; }
1024: else { if (@expr1073751703 valueType@var2847 .@expr1073751704 isFloat (@expr1073751705 ) &&@expr1073751706 isNumeric (@expr1073751707 value@var2848 ) ) {
1025: ValueFlow ::@expr1073751708 Value floatValue@var2858 ; floatValue@var2858 =@expr1073751709 value@var2848 ;
1026: floatValue@var2858 .@expr1073751710 valueType@var2859 =@expr1073751711 ValueFlow ::@expr1073751712 Value ::@expr1073751713 ValueType ::@expr1073751714 FLOAT ;
1027: if (@expr9891 value@var2848 .@expr9892 isIntValue (@expr9893 ) ) {
1028: floatValue@var2858 .@expr1073751718 floatValue@var2860 =@expr1073751719 value@var2848 .@expr9896 intvalue@var2861 ; }
1029: setTokenValue (@expr1073751721 parent@var2846 , floatValue@var2858 , settings@var2849 ) ;
1030: } else { if (@expr9891 value@var2848 .@expr9892 isIntValue (@expr9893 ) ) {
1031: const long long charMax@var2862 =@expr1073751725 settings@var2849 .@expr1073751726 signedCharMax (@expr1073751727 ) ;
1032: const long long charMin@var2863 =@expr1073751728 settings@var2849 .@expr1073751729 signedCharMin (@expr1073751730 ) ;
1033: if (@expr1073751731 charMin@var2863 <=@expr1073751732 value@var2848 .@expr9896 intvalue@var2861 &&@expr1073751734 value@var2848 .@expr9896 intvalue@var2861 <=@expr1073751736 charMax@var2862 ) {
1034:
1035: setTokenValue (@expr9833 parent@var2846 , value@var2848 , settings@var2849 ) ;
1036: }
1037: } } } } } } } }
1038: }
1039:
1040: static int getSizeOfType ( const Token * typeTok@var2864 , const Settings * settings@var2865 )
1041: {
1042: const ValueType &@expr1073751738 valueType@var2866 =@expr1073751739 ValueType ::@expr1073751740 parseDecl (@expr1073751741 typeTok@var2864 , settings@var2865 ) ;
1043: if (@expr1073751742 valueType@var2866 .@expr1073751743 pointer@var2867 >@expr1073751744 0 ) {
1044: return settings@var2865 .@expr1073751745 sizeof_pointer@var2868 ; }
1045: if (@expr1073751746 valueType@var2866 .@expr9923 type@var2869 ==@expr1073751748 ValueType ::@expr9925 Type ::@expr1073751750 BOOL ||@expr1073751751 valueType@var2866 .@expr9923 type@var2869 ==@expr1073751753 ValueType ::@expr9925 Type ::@expr1073751755 CHAR ) {
1046: return 1 ; }
1047: if (@expr1073751756 valueType@var2866 .@expr9923 type@var2869 ==@expr1073751758 ValueType ::@expr9925 Type ::@expr1073751760 SHORT ) {
1048: return settings@var2865 .@expr1073751761 sizeof_short@var2870 ; }
1049: if (@expr1073751762 valueType@var2866 .@expr9923 type@var2869 ==@expr1073751764 ValueType ::@expr9925 Type ::@expr1073751766 INT ) {
1050: return settings@var2865 .@expr1073751767 sizeof_int@var2871 ; }
1051: if (@expr1073751768 valueType@var2866 .@expr9923 type@var2869 ==@expr1073751770 ValueType ::@expr9925 Type ::@expr1073751772 LONG ) {
1052: return settings@var2865 .@expr1073751773 sizeof_long@var2872 ; }
1053: if (@expr1073751774 valueType@var2866 .@expr9923 type@var2869 ==@expr1073751776 ValueType ::@expr9925 Type ::@expr1073751778 LONGLONG ) {
1054: return settings@var2865 .@expr1073751779 sizeof_long_long@var2873 ; }
1055: if (@expr1073751780 valueType@var2866 .@expr9923 type@var2869 ==@expr1073751782 ValueType ::@expr9925 Type ::@expr1073751784 WCHAR_T ) {
1056: return settings@var2865 .@expr1073751785 sizeof_wchar_t@var2874 ; }
1057:
1058: return 0 ;
1059: }
1060:
1061: unsigned long ValueFlow :: getSizeOf ( const ValueType & vt@var2875 , const Settings * settings@var2876 )
1062: {
1063: if (@expr1073751786 vt@var2875 .@expr1073751787 pointer@var2877 ) {
1064: return settings@var2876 .@expr1073751788 sizeof_pointer@var2878 ; }
1065: if (@expr1073751789 vt@var2875 .@expr9966 type@var2879 ==@expr1073751791 ValueType ::@expr9968 Type ::@expr1073751793 CHAR ) {
1066: return 1 ; }
1067: if (@expr1073751794 vt@var2875 .@expr9966 type@var2879 ==@expr1073751796 ValueType ::@expr9968 Type ::@expr1073751798 SHORT ) {
1068: return settings@var2876 .@expr1073751799 sizeof_short@var2880 ; }
1069: if (@expr1073751800 vt@var2875 .@expr9966 type@var2879 ==@expr1073751802 ValueType ::@expr9968 Type ::@expr1073751804 WCHAR_T ) {
1070: return settings@var2876 .@expr1073751805 sizeof_wchar_t@var2881 ; }
1071: if (@expr1073751806 vt@var2875 .@expr9966 type@var2879 ==@expr1073751808 ValueType ::@expr9968 Type ::@expr1073751810 INT ) {
1072: return settings@var2876 .@expr1073751811 sizeof_int@var2882 ; }
1073: if (@expr1073751812 vt@var2875 .@expr9966 type@var2879 ==@expr1073751814 ValueType ::@expr9968 Type ::@expr1073751816 LONG ) {
1074: return settings@var2876 .@expr1073751817 sizeof_long@var2883 ; }
1075: if (@expr1073751818 vt@var2875 .@expr9966 type@var2879 ==@expr1073751820 ValueType ::@expr9968 Type ::@expr1073751822 LONGLONG ) {
1076: return settings@var2876 .@expr1073751823 sizeof_long_long@var2884 ; }
1077: if (@expr1073751824 vt@var2875 .@expr9966 type@var2879 ==@expr1073751826 ValueType ::@expr9968 Type ::@expr1073751828 FLOAT ) {
1078: return settings@var2876 .@expr1073751829 sizeof_float@var2885 ; }
1079: if (@expr1073751830 vt@var2875 .@expr9966 type@var2879 ==@expr1073751832 ValueType ::@expr9968 Type ::@expr1073751834 DOUBLE ) {
1080: return settings@var2876 .@expr1073751835 sizeof_double@var2886 ; }
1081: if (@expr1073751836 vt@var2875 .@expr9966 type@var2879 ==@expr1073751838 ValueType ::@expr9968 Type ::@expr1073751840 LONGDOUBLE ) {
1082: return settings@var2876 .@expr1073751841 sizeof_long_double@var2887 ; }
1083:
1084: return 0 ;
1085: }
1086:
1087:
1088: static Token * valueFlowSetConstantValue ( Token * tok@var2888 , const Settings * settings@var2889 , bool cpp@var2890 )
1089: {
1090: if (@expr1073751842 (@expr1073751843 tok@var2888 .@expr10020 isNumber (@expr10021 ) &&@expr1073751846 MathLib ::@expr1073751847 isInt (@expr1073751848 tok@var2888 .@expr10025 str (@expr10026 ) ) ) ||@expr1073751851 (@expr1073751852 tok@var2888 .@expr1073751853 tokType (@expr1073751854 ) ==@expr1073751855 Token ::@expr10032 eChar ) ) {
1091: try {
1092: ValueFlow ::@expr1073751857 Value value@var2891 (@expr1073751858 MathLib ::@expr1073751859 toLongNumber (@expr1073751860 tok@var2888 .@expr10025 str (@expr10026 ) ) ) ;
1093: if (@expr10039 !@expr10040 tok@var2888 .@expr10041 isTemplateArg (@expr10042 ) ) {
1094: value@var2891 .@expr1073751867 setKnown (@expr1073751868 ) ; }
1095: setTokenValue (@expr1073751869 tok@var2888 , value@var2891 , settings@var2889 ) ;
1096: } catch (@expr1073751870 const std ::@expr1073751871 exception &@expr10048 ) {
1097:
1098: }
1099: } else { if (@expr1073751873 tok@var2888 .@expr10020 isNumber (@expr10021 ) &&@expr1073751876 MathLib ::@expr1073751877 isFloat (@expr1073751878 tok@var2888 .@expr10025 str (@expr10026 ) ) ) {
1100: ValueFlow ::@expr1073751881 Value value@var2892 ;
1101: value@var2892 .@expr1073751882 valueType@var2893 =@expr1073751883 ValueFlow ::@expr1073751884 Value ::@expr1073751885 ValueType ::@expr1073751886 FLOAT ;
1102: value@var2892 .@expr1073751887 floatValue@var2894 =@expr1073751888 MathLib ::@expr1073751889 toDoubleNumber (@expr1073751890 tok@var2888 .@expr10025 str (@expr10026 ) ) ;
1103: if (@expr10039 !@expr10040 tok@var2888 .@expr10041 isTemplateArg (@expr10042 ) ) {
1104: value@var2892 .@expr1073751897 setKnown (@expr1073751898 ) ; }
1105: setTokenValue (@expr1073751899 tok@var2888 , value@var2892 , settings@var2889 ) ;
1106: } else { if (@expr1073751900 tok@var2888 .@expr10077 enumerator (@expr10078 ) &&@expr1073751903 tok@var2888 .@expr10077 enumerator (@expr10078 ) .@expr1073751906 value_known@var5319 ) {
1107: ValueFlow ::@expr1073751907 Value value@var2895 (@expr1073751908 tok@var2888 .@expr10077 enumerator (@expr10078 ) .@expr1073751911 value@var5320 ) ;
1108: if (@expr10039 !@expr10040 tok@var2888 .@expr10041 isTemplateArg (@expr10042 ) ) {
1109: value@var2895 .@expr1073751916 setKnown (@expr1073751917 ) ; }
1110: setTokenValue (@expr1073751918 tok@var2888 , value@var2895 , settings@var2889 ) ;
1111: } else { if (@expr1073751919 tok@var2888 .@expr10025 str (@expr10026 ) ==@expr1073751922 "NULL" ||@expr1073751923 (@expr1073751924 cpp@var2890 &&@expr1073751925 tok@var2888 .@expr10025 str (@expr10026 ) ==@expr1073751928 "nullptr" ) ) {
1112: ValueFlow ::@expr1073751929 Value value@var2896 (@expr1073751930 0 ) ;
1113: if (@expr10039 !@expr10040 tok@var2888 .@expr10041 isTemplateArg (@expr10042 ) ) {
1114: value@var2896 .@expr1073751935 setKnown (@expr1073751936 ) ; }
1115: setTokenValue (@expr1073751937 tok@var2888 , value@var2896 , settings@var2889 ) ;
1116: } else { if (@expr1073751938 Token ::@expr10115 simpleMatch (@expr1073751940 tok@var2888 , "sizeof (" ) ) {
1117: if (@expr1073751941 tok@var2888 .@expr10118 next (@expr10119 ) .@expr10120 astOperand2 (@expr10121 ) &&@expr1073751946 !@expr1073751947 tok@var2888 .@expr10118 next (@expr10119 ) .@expr10120 astOperand2 (@expr10121 ) .@expr1073751952 isLiteral (@expr1073751953 ) &&@expr1073751954 tok@var2888 .@expr10118 next (@expr10119 ) .@expr10120 astOperand2 (@expr10121 ) .@expr10135 valueType (@expr10136 ) &&@expr1073751961
1118: tok@var2888 .@expr10118 next (@expr10119 ) .@expr10120 astOperand2 (@expr10121 ) .@expr10135 valueType (@expr10136 ) .@expr1073751968 pointer@var5340 ==@expr1073751969 0 &&@expr1073751970
1119: !@expr1073751971 tok@var2888 .@expr10118 next (@expr10119 ) .@expr10120 astOperand2 (@expr10121 ) .@expr10135 valueType (@expr10136 ) .@expr1073751978 isEnum (@expr1073751979 ) ) {
1120: const unsigned long sz@var2897 =@expr1073751980 ValueFlow ::@expr10157 getSizeOf (@expr1073751982 *@expr1073751983 tok@var2888 .@expr10118 next (@expr10119 ) .@expr10120 astOperand2 (@expr10121 ) .@expr10135 valueType (@expr10136 ) , settings@var2889 ) ;
1121: if (@expr1073751990 sz@var2897 ) {
1122: ValueFlow ::@expr1073751991 Value value@var2898 (@expr1073751992 sz@var2897 ) ;
1123: value@var2898 .@expr1073751993 setKnown (@expr1073751994 ) ;
1124: setTokenValue (@expr1073751995 tok@var2888 .@expr10118 next (@expr10119 ) , value@var2898 , settings@var2889 ) ;
1125: return tok@var2888 .@expr10174 linkAt (@expr10175 1 ) ;
1126: }
1127: }
1128:
1129: const Token * tok2@var2899 ; tok2@var2899 =@expr1073752000 tok@var2888 .@expr10177 tokAt (@expr10178 2 ) ;
1130:
1131: while (@expr1073752003 Token ::@expr10180 Match (@expr1073752005 tok2@var2899 , "%name% ::|.|[" ) ) {
1132: if (@expr1073752006 tok2@var2899 .@expr1073752007 next (@expr1073752008 ) .@expr1073752009 str (@expr1073752010 ) ==@expr1073752011 "[" ) {
1133: tok2@var2899 =@expr1073752012 tok2@var2899 .@expr1073752013 linkAt (@expr1073752014 1 ) .@expr1073752015 next (@expr1073752016 ) ; }
1134: else {
1135: tok2@var2899 =@expr1073752017 tok2@var2899 .@expr1073752018 tokAt (@expr1073752019 2 ) ; }
1136: }
1137: if (@expr1073752020 Token ::@expr10115 simpleMatch (@expr1073752022 tok@var2888 , "sizeof ( *" ) ) {
1138: const ValueType * vt@var2900 ; vt@var2900 =@expr1073752023 tok@var2888 .@expr10177 tokAt (@expr10178 2 ) .@expr1073752026 valueType (@expr1073752027 ) ;
1139: const unsigned long sz@var2901 =@expr1073752028 vt@var2900 ?@expr1073752029 ValueFlow ::@expr10157 getSizeOf (@expr1073752031 *@expr1073752032 vt@var2900 , settings@var2889 ) :@expr1073752033 0 ;
1140: if (@expr1073752034 sz@var2901 >@expr1073752035 0 ) {
1141: ValueFlow ::@expr1073752036 Value value@var2902 (@expr1073752037 sz@var2901 ) ;
1142: if (@expr10214 !@expr10215 tok2@var2899 .@expr10216 isTemplateArg (@expr10217 ) &&@expr10218 settings@var2889 .@expr10219 platformType@var2903 !=@expr10220 cppcheck ::@expr10221 Platform ::@expr10222 Unspecified ) {
1143: value@var2902 .@expr1073752047 setKnown (@expr1073752048 ) ; }
1144: setTokenValue (@expr1073752049 tok@var2888 .@expr10118 next (@expr10119 ) , value@var2902 , settings@var2889 ) ;
1145: }
1146: } else { if (@expr1073752052 tok2@var2899 .@expr10229 enumerator (@expr10230 ) &&@expr1073752055 tok2@var2899 .@expr10229 enumerator (@expr10230 ) .@expr10234 scope@var5321 ) {
1147: long long size@var2904 ; size@var2904 =@expr1073752059 settings@var2889 .@expr10236 sizeof_int@var2905 ;
1148: const Token * type@var2906 ; type@var2906 =@expr1073752061 tok2@var2899 .@expr10229 enumerator (@expr10230 ) .@expr10234 scope@var5321 .@expr1073752065 enumType@var5322 ;
1149: if (@expr1073752066 type@var2906 ) {
1150: size@var2904 =@expr1073752067 getSizeOfType (@expr1073752068 type@var2906 , settings@var2889 ) ;
1151: if (@expr1073752069 size@var2904 ==@expr1073752070 0 ) {
1152: tok@var2888 .@expr10174 linkAt (@expr10175 1 ) ; }
1153: }
1154: ValueFlow ::@expr1073752073 Value value@var2907 (@expr1073752074 size@var2904 ) ;
1155: if (@expr10214 !@expr10215 tok2@var2899 .@expr10216 isTemplateArg (@expr10217 ) &&@expr10218 settings@var2889 .@expr10219 platformType@var2903 !=@expr10220 cppcheck ::@expr10221 Platform ::@expr10222 Unspecified ) {
1156: value@var2907 .@expr1073752084 setKnown (@expr1073752085 ) ; }
1157: setTokenValue (@expr1073752086 tok@var2888 , value@var2907 , settings@var2889 ) ;
1158: setTokenValue (@expr1073752087 tok@var2888 .@expr10118 next (@expr10119 ) , value@var2907 , settings@var2889 ) ;
1159: } else { if (@expr1073752090 tok2@var2899 .@expr10267 type (@expr10268 ) &&@expr1073752093 tok2@var2899 .@expr10267 type (@expr10268 ) .@expr1073752096 isEnumType (@expr1073752097 ) ) {
1160: long long size@var2908 ; size@var2908 =@expr1073752098 settings@var2889 .@expr10236 sizeof_int@var2905 ;
1161: if (@expr1073752100 tok2@var2899 .@expr10267 type (@expr10268 ) .@expr10279 classScope@var5323 ) {
1162: const Token * type@var2909 ; type@var2909 =@expr1073752104 tok2@var2899 .@expr10267 type (@expr10268 ) .@expr10279 classScope@var5323 .@expr1073752108 enumType@var5324 ;
1163: if (@expr1073752109 type@var2909 ) {
1164: size@var2908 =@expr1073752110 getSizeOfType (@expr1073752111 type@var2909 , settings@var2889 ) ;
1165: }
1166: }
1167: ValueFlow ::@expr1073752112 Value value@var2910 (@expr1073752113 size@var2908 ) ;
1168: if (@expr10214 !@expr10215 tok2@var2899 .@expr10216 isTemplateArg (@expr10217 ) &&@expr10218 settings@var2889 .@expr10219 platformType@var2903 !=@expr10220 cppcheck ::@expr10221 Platform ::@expr10222 Unspecified ) {
1169: value@var2910 .@expr1073752123 setKnown (@expr1073752124 ) ; }
1170: setTokenValue (@expr1073752125 tok@var2888 , value@var2910 , settings@var2889 ) ;
1171: setTokenValue (@expr1073752126 tok@var2888 .@expr10118 next (@expr10119 ) , value@var2910 , settings@var2889 ) ;
1172: } else { if (@expr1073752129 Token ::@expr10180 Match (@expr1073752131 tok@var2888 , "sizeof ( %var% ) / sizeof (" ) &&@expr1073752132 tok@var2888 .@expr10118 next (@expr10119 ) .@expr1073752135 astParent (@expr1073752136 ) ==@expr1073752137 tok@var2888 .@expr10177 tokAt (@expr10315 4 ) ) {
1173:
1174: const Token * sz1@var2911 ; sz1@var2911 =@expr1073752140 tok@var2888 .@expr10177 tokAt (@expr10178 2 ) ;
1175: const Token * sz2@var2912 ; sz2@var2912 =@expr1073752143 tok@var2888 .@expr10177 tokAt (@expr1073752145 6 ) ;
1176: const int varid1@var2913 =@expr1073752146 sz1@var2911 .@expr1073752147 varId (@expr1073752148 ) ;
1177: if (@expr1073752149 varid1@var2913 &&@expr1073752150
1178: sz1@var2911 .@expr10327 variable (@expr10328 ) &&@expr1073752153
1179: sz1@var2911 .@expr10327 variable (@expr10328 ) .@expr1073752156 isArray (@expr1073752157 ) &&@expr1073752158
1180: !@expr1073752159 sz1@var2911 .@expr10327 variable (@expr10328 ) .@expr1073752162 dimensions (@expr1073752163 ) .@expr1073752164 empty (@expr1073752165 ) &&@expr1073752166
1181: sz1@var2911 .@expr10327 variable (@expr10328 ) .@expr1073752169 dimensionKnown (@expr1073752170 0 ) &&@expr1073752171
1182: Token ::@expr10180 Match (@expr1073752173 sz2@var2912 .@expr10350 astOperand2 (@expr10351 ) , "*|[" ) &&@expr1073752176 Token ::@expr10180 Match (@expr1073752178 sz2@var2912 .@expr10350 astOperand2 (@expr10351 ) .@expr1073752181 astOperand1 (@expr1073752182 ) , "%varid%" , varid1@var2913 ) ) {
1183: ValueFlow ::@expr1073752183 Value value@var2914 (@expr1073752184 sz1@var2911 .@expr10327 variable (@expr10328 ) .@expr1073752187 dimension (@expr1073752188 0 ) ) ;
1184: if (@expr10214 !@expr10215 tok2@var2899 .@expr10216 isTemplateArg (@expr10217 ) &&@expr10218 settings@var2889 .@expr10219 platformType@var2903 !=@expr10220 cppcheck ::@expr10221 Platform ::@expr10222 Unspecified ) {
1185: value@var2914 .@expr1073752198 setKnown (@expr1073752199 ) ; }
1186: setTokenValue (@expr1073752200 tok@var2888 .@expr10177 tokAt (@expr10315 4 ) , value@var2914 , settings@var2889 ) ;
1187: }
1188: } else { if (@expr1073752203 Token ::@expr10180 Match (@expr1073752205 tok2@var2899 , "%var% )" ) ) {
1189: const Variable * var@var2915 ; var@var2915 =@expr1073752206 tok2@var2899 .@expr1073752207 variable (@expr1073752208 ) ;
1190:
1191: if (@expr1073752209 var@var2915 &&@expr1073752210 var@var2915 .@expr10387 typeStartToken (@expr10388 ) ==@expr1073752213 var@var2915 .@expr1073752214 typeEndToken (@expr1073752215 ) ) {
1192:
1193: unsigned long size@var2916 ; size@var2916 =@expr1073752216 0 ;
1194: if (@expr1073752217 var@var2915 .@expr1073752218 isEnumType (@expr1073752219 ) ) {
1195: size@var2916 =@expr1073752220 settings@var2889 .@expr10236 sizeof_int@var2905 ;
1196: if (@expr1073752222 var@var2915 .@expr10399 type (@expr10400 ) .@expr10401 classScope@var5323 &&@expr1073752226 var@var2915 .@expr10399 type (@expr10400 ) .@expr10401 classScope@var5323 .@expr10406 enumType@var5324 ) {
1197: size@var2916 =@expr1073752231 getSizeOfType (@expr1073752232 var@var2915 .@expr10399 type (@expr10400 ) .@expr10401 classScope@var5323 .@expr10406 enumType@var5324 , settings@var2889 ) ; }
1198: } else { if (@expr1073752237 var@var2915 .@expr10414 valueType (@expr10415 ) ) {
1199: size@var2916 =@expr1073752240 ValueFlow ::@expr10157 getSizeOf (@expr1073752242 *@expr1073752243 var@var2915 .@expr10414 valueType (@expr10415 ) , settings@var2889 ) ;
1200: } else { if (@expr1073752246 !@expr1073752247 var@var2915 .@expr10399 type (@expr10400 ) ) {
1201: size@var2916 =@expr1073752250 getSizeOfType (@expr1073752251 var@var2915 .@expr10387 typeStartToken (@expr10388 ) , settings@var2889 ) ;
1202: } } }
1203:
1204: unsigned long count@var2917 ; count@var2917 =@expr1073752254 1 ;
1205: for (@expr1073752255 unsigned long i@var2918 =@expr1073752256 0 ; i@var2918 <@expr1073752257 var@var2915 .@expr1073752258 dimensions (@expr1073752259 ) .@expr1073752260 size (@expr1073752261 ) ; ++@expr1073752262 i@var2918 ) {
1206: if (@expr1073752263 var@var2915 .@expr1073752264 dimensionKnown (@expr1073752265 i@var2918 ) ) {
1207: count@var2917 *=@expr1073752266 var@var2915 .@expr1073752267 dimension (@expr1073752268 i@var2918 ) ; }
1208: else {
1209: count@var2917 =@expr1073752269 0 ; }
1210: }
1211: if (@expr1073752270 size@var2916 &&@expr1073752271 count@var2917 >@expr1073752272 0 ) {
1212: ValueFlow ::@expr1073752273 Value value@var2919 (@expr1073752274 count@var2917 *@expr1073752275 size@var2916 ) ;
1213: if (@expr1073752276 settings@var2889 .@expr10219 platformType@var2903 !=@expr10220 cppcheck ::@expr10221 Platform ::@expr10222 Unspecified ) {
1214: value@var2919 .@expr1073752281 setKnown (@expr1073752282 ) ; }
1215: setTokenValue (@expr1073752283 tok@var2888 , value@var2919 , settings@var2889 ) ;
1216: setTokenValue (@expr1073752284 tok@var2888 .@expr10118 next (@expr10119 ) , value@var2919 , settings@var2889 ) ;
1217: }
1218: }
1219: } else { if (@expr1073752287 tok2@var2899 .@expr10464 tokType (@expr10465 ) ==@expr1073752290 Token ::@expr1073752291 eString ) {
1220: unsigned long sz@var2920 ; sz@var2920 =@expr1073752292 Token ::@expr1073752293 getStrSize (@expr1073752294 tok2@var2899 , settings@var2889 ) ;
1221: if (@expr1073752295 sz@var2920 >@expr1073752296 0 ) {
1222: ValueFlow ::@expr1073752297 Value value@var2921 (@expr1073752298 sz@var2920 ) ;
1223: value@var2921 .@expr1073752299 setKnown (@expr1073752300 ) ;
1224: setTokenValue (@expr1073752301 const_cast < Token *@expr1073752302 > (@expr1073752303 tok@var2888 .@expr10118 next (@expr10119 ) ) , value@var2921 , settings@var2889 ) ;
1225: }
1226: } else { if (@expr1073752306 tok2@var2899 .@expr10464 tokType (@expr10465 ) ==@expr1073752309 Token ::@expr10032 eChar ) {
1227: int sz@var2922 ; sz@var2922 =@expr1073752311 0 ;
1228: if (@expr1073752312 cpp@var2890 &&@expr1073752313 settings@var2889 .@expr1073752314 standards@var2923 .@expr1073752315 cpp@var2924 >=@expr1073752316 Standards ::@expr1073752317 CPP20 &&@expr1073752318 tok2@var2899 .@expr1073752319 isUtf8 (@expr1073752320 ) ) {
1229: sz@var2922 =@expr1073752321 1 ; }
1230: else { if (@expr1073752322 tok2@var2899 .@expr1073752323 isUtf16 (@expr1073752324 ) ) {
1231: sz@var2922 =@expr1073752325 2 ; }
1232: else { if (@expr1073752326 tok2@var2899 .@expr1073752327 isUtf32 (@expr1073752328 ) ) {
1233: sz@var2922 =@expr1073752329 4 ; }
1234: else { if (@expr1073752330 tok2@var2899 .@expr1073752331 isLong (@expr1073752332 ) ) {
1235: sz@var2922 =@expr1073752333 settings@var2889 .@expr1073752334 sizeof_wchar_t@var2925 ; }
1236: else { if (@expr1073752335 (@expr1073752336 tok2@var2899 .@expr1073752337 isCChar (@expr1073752338 ) &&@expr1073752339 !@expr1073752340 cpp@var2890 ) ||@expr1073752341 (@expr1073752342 tok2@var2899 .@expr1073752343 isCMultiChar (@expr1073752344 ) ) ) {
1237: sz@var2922 =@expr1073752345 settings@var2889 .@expr10236 sizeof_int@var2905 ; }
1238: else {
1239: sz@var2922 =@expr1073752347 1 ; } } } } }
1240:
1241: if (@expr1073752348 sz@var2922 >@expr1073752349 0 ) {
1242: ValueFlow ::@expr1073752350 Value value@var2926 (@expr1073752351 sz@var2922 ) ;
1243: value@var2926 .@expr1073752352 setKnown (@expr1073752353 ) ;
1244: setTokenValue (@expr1073752354 tok@var2888 .@expr10118 next (@expr10119 ) , value@var2926 , settings@var2889 ) ;
1245: }
1246: } else { if (@expr1073752357 !@expr1073752358 tok2@var2899 .@expr10267 type (@expr10268 ) ) {
1247: const ValueType &@expr10048 vt@var2927 =@expr1073752362 ValueType ::@expr1073752363 parseDecl (@expr1073752364 tok2@var2899 , settings@var2889 ) ;
1248: const unsigned long sz@var2928 =@expr1073752365 ValueFlow ::@expr10157 getSizeOf (@expr1073752367 vt@var2927 , settings@var2889 ) ;
1249: if (@expr1073752368 sz@var2928 >@expr1073752369 0 ) {
1250: ValueFlow ::@expr1073752370 Value value@var2929 (@expr1073752371 sz@var2928 ) ;
1251: if (@expr10214 !@expr10215 tok2@var2899 .@expr10216 isTemplateArg (@expr10217 ) &&@expr10218 settings@var2889 .@expr10219 platformType@var2903 !=@expr10220 cppcheck ::@expr10221 Platform ::@expr10222 Unspecified ) {
1252: value@var2929 .@expr1073752381 setKnown (@expr1073752382 ) ; }
1253: setTokenValue (@expr1073752383 tok@var2888 .@expr10118 next (@expr10119 ) , value@var2929 , settings@var2889 ) ;
1254: }
1255: } } } } } } } }
1256:
1257: tok@var2888 =@expr1073752386 tok@var2888 .@expr10174 linkAt (@expr10175 1 ) ;
1258: } } } } }
1259: return tok@var2888 .@expr10118 next (@expr10119 ) ;
1260: }
1261:
1262:
1263: static void valueFlowNumber ( TokenList * tokenlist@var2930 )
1264: {
1265: for (@expr1073752391 Token *@expr10568 tok@var2931 =@expr1073752393 tokenlist@var2930 .@expr10570 front (@expr10571 ) ; tok@var2931 ; ) {
1266: tok@var2931 =@expr1073752396 valueFlowSetConstantValue (@expr1073752397 tok@var2931 , tokenlist@var2930 .@expr10574 getSettings (@expr10575 ) , tokenlist@var2930 .@expr10576 isCPP (@expr10577 ) ) ;
1267: }
1268:
1269: if (@expr1073752402 tokenlist@var2930 .@expr10576 isCPP (@expr10577 ) ) {
1270: for (@expr1073752405 Token *@expr10568 tok@var2932 =@expr1073752407 tokenlist@var2930 .@expr10570 front (@expr10571 ) ; tok@var2932 ; tok@var2932 =@expr1073752410 tok@var2932 .@expr10587 next (@expr10588 ) ) {
1271: if (@expr1073752413 tok@var2932 .@expr1073752414 isName (@expr1073752415 ) &&@expr1073752416 !@expr1073752417 tok@var2932 .@expr1073752418 varId (@expr1073752419 ) &&@expr1073752420 Token ::@expr10597 Match (@expr1073752422 tok@var2932 , "false|true" ) ) {
1272: ValueFlow ::@expr1073752423 Value value@var2933 (@expr1073752424 tok@var2932 .@expr1073752425 str (@expr1073752426 ) ==@expr1073752427 "true" ) ;
1273: if (@expr10604 !@expr10605 tok@var2932 .@expr10606 isTemplateArg (@expr10607 ) ) {
1274: value@var2933 .@expr1073752432 setKnown (@expr1073752433 ) ; }
1275: setTokenValue (@expr1073752434 tok@var2932 , value@var2933 , tokenlist@var2930 .@expr10574 getSettings (@expr10575 ) ) ;
1276: } else { if (@expr1073752437 Token ::@expr10597 Match (@expr1073752439 tok@var2932 , "[(,] NULL [,)]" ) ) {
1277:
1278:
1279: ValueFlow ::@expr1073752440 Value value@var2934 (@expr1073752441 0 ) ;
1280: if (@expr10604 !@expr10605 tok@var2932 .@expr10606 isTemplateArg (@expr10607 ) ) {
1281: value@var2934 .@expr1073752446 setKnown (@expr1073752447 ) ; }
1282: setTokenValue (@expr1073752448 tok@var2932 .@expr10587 next (@expr10588 ) , value@var2934 , tokenlist@var2930 .@expr10574 getSettings (@expr10575 ) ) ;
1283: } }
1284: }
1285: }
1286: }
1287:
1288: static void valueFlowString ( TokenList * tokenlist@var2935 )
1289: {
1290: for (@expr1073752453 Token *@expr1073752454 tok@var2936 =@expr1073752455 tokenlist@var2935 .@expr1073752456 front (@expr1073752457 ) ; tok@var2936 ; tok@var2936 =@expr1073752458 tok@var2936 .@expr1073752459 next (@expr1073752460 ) ) {
1291: if (@expr1073752461 tok@var2936 .@expr1073752462 tokType (@expr1073752463 ) ==@expr1073752464 Token ::@expr1073752465 eString ) {
1292: ValueFlow ::@expr1073752466 Value strvalue@var2937 ;
1293: strvalue@var2937 .@expr1073752467 valueType@var2938 =@expr1073752468 ValueFlow ::@expr1073752469 Value ::@expr1073752470 ValueType ::@expr1073752471 TOK ;
1294: strvalue@var2937 .@expr1073752472 tokvalue@var2939 =@expr1073752473 tok@var2936 ;
1295: strvalue@var2937 .@expr1073752474 setKnown (@expr1073752475 ) ;
1296: setTokenValue (@expr1073752476 tok@var2936 , strvalue@var2937 , tokenlist@var2935 .@expr1073752477 getSettings (@expr1073752478 ) ) ;
1297: }
1298: }
1299: }
1300:
1301: static void valueFlowArray ( TokenList * tokenlist@var2940 )
1302: {
1303: std ::@expr1073752479 map < int , const Token *@expr10656 > constantArrays@var2941 ;
1304:
1305: for (@expr1073752481 Token *@expr10656 tok@var2942 =@expr1073752483 tokenlist@var2940 .@expr1073752484 front (@expr1073752485 ) ; tok@var2942 ; tok@var2942 =@expr1073752486 tok@var2942 .@expr10663 next (@expr10664 ) ) {
1306: if (@expr1073752489 tok@var2942 .@expr10666 varId (@expr10667 ) >@expr1073752492 0 ) {
1307:
1308: const std ::@expr1073752493 map < int , const Token *@expr10656 > ::@expr1073752495 const_iterator it@var2943 =@expr1073752496 constantArrays@var2941 .@expr1073752497 find (@expr1073752498 tok@var2942 .@expr10666 varId (@expr10667 ) ) ;
1309: if (@expr1073752501 it@var2943 !=@expr1073752502 constantArrays@var2941 .@expr1073752503 end (@expr1073752504 ) ) {
1310: ValueFlow ::@expr1073752505 Value value@var2944 ;
1311: value@var2944 .@expr1073752506 valueType@var2945 =@expr1073752507 ValueFlow ::@expr10684 Value ::@expr10685 ValueType ::@expr10686 TOK ;
1312: value@var2944 .@expr1073752511 tokvalue@var2946 =@expr1073752512 it@var2943 .@expr1073752513 second@var2947 ;
1313: value@var2944 .@expr1073752514 setKnown (@expr1073752515 ) ;
1314: setTokenValue (@expr1073752516 tok@var2942 , value@var2944 , tokenlist@var2940 .@expr10693 getSettings (@expr10694 ) ) ;
1315: }
1316:
1317:
1318: else { if (@expr1073752519 tok@var2942 .@expr10696 variable (@expr10697 ) &&@expr10698 tok@var2942 .@expr10696 variable (@expr10697 ) .@expr10701 isArray (@expr10702 ) &&@expr1073752527 tok@var2942 .@expr10696 variable (@expr10697 ) .@expr1073752530 isConst (@expr1073752531 ) &&@expr1073752532
1319: tok@var2942 .@expr10696 variable (@expr10697 ) .@expr1073752535 nameToken (@expr1073752536 ) ==@expr1073752537 tok@var2942 &&@expr1073752538 Token ::@expr10715 Match (@expr1073752540 tok@var2942 , "%var% [ %num%| ] = {" ) ) {
1320: const Token * rhstok@var2948 ; rhstok@var2948 =@expr1073752541 tok@var2942 .@expr10663 next (@expr10664 ) .@expr1073752544 link (@expr1073752545 ) .@expr1073752546 tokAt (@expr1073752547 2 ) ;
1321: constantArrays@var2941 [@expr1073752548 tok@var2942 .@expr10666 varId (@expr10667 ) ] =@expr1073752551 rhstok@var2948 ;
1322: tok@var2942 =@expr1073752552 rhstok@var2948 .@expr1073752553 link (@expr1073752554 ) ;
1323: }
1324:
1325:
1326: else { if (@expr1073752555 tok@var2942 .@expr10696 variable (@expr10697 ) &&@expr10698 tok@var2942 .@expr10696 variable (@expr10697 ) .@expr10701 isArray (@expr10702 ) &&@expr1073752563 Token ::@expr1073752564 simpleMatch (@expr1073752565 tok@var2942 .@expr10742 astParent (@expr10743 ) , "=" ) &&@expr1073752568
1327: astIsRHS (@expr1073752569 tok@var2942 ) &&@expr1073752570 tok@var2942 .@expr10742 astParent (@expr10743 ) .@expr10749 astOperand1 (@expr10750 ) &&@expr1073752575
1328: tok@var2942 .@expr10742 astParent (@expr10743 ) .@expr10749 astOperand1 (@expr10750 ) .@expr10756 variable (@expr10757 ) &&@expr1073752582
1329: tok@var2942 .@expr10742 astParent (@expr10743 ) .@expr10749 astOperand1 (@expr10750 ) .@expr10756 variable (@expr10757 ) .@expr1073752589 isPointer (@expr1073752590 ) ) {
1330: ValueFlow ::@expr1073752591 Value value@var2949 ;
1331: value@var2949 .@expr1073752592 valueType@var2950 =@expr1073752593 ValueFlow ::@expr10684 Value ::@expr10685 ValueType ::@expr10686 TOK ;
1332: value@var2949 .@expr1073752597 tokvalue@var2951 =@expr1073752598 tok@var2942 ;
1333: value@var2949 .@expr1073752599 setKnown (@expr1073752600 ) ;
1334: setTokenValue (@expr1073752601 tok@var2942 , value@var2949 , tokenlist@var2940 .@expr10693 getSettings (@expr10694 ) ) ;
1335: } } }
1336: continue ;
1337: }
1338:
1339: if (@expr1073752604 Token ::@expr10715 Match (@expr1073752606 tok@var2942 , "const %type% %var% [ %num%| ] = {" ) ) {
1340: const Token * vartok@var2952 ; vartok@var2952 =@expr1073752607 tok@var2942 .@expr10784 tokAt (@expr10785 2 ) ;
1341: const Token * rhstok@var2953 ; rhstok@var2953 =@expr1073752610 vartok@var2952 .@expr1073752611 next (@expr1073752612 ) .@expr1073752613 link (@expr1073752614 ) .@expr1073752615 tokAt (@expr1073752616 2 ) ;
1342: constantArrays@var2941 [@expr1073752617 vartok@var2952 .@expr1073752618 varId (@expr1073752619 ) ] =@expr1073752620 rhstok@var2953 ;
1343: tok@var2942 =@expr1073752621 rhstok@var2953 .@expr1073752622 link (@expr1073752623 ) ;
1344: continue ;
1345: }
1346:
1347: else { if (@expr1073752624 Token ::@expr10715 Match (@expr1073752626 tok@var2942 , "const char %var% [ %num%| ] = %str% ;" ) ) {
1348: const Token * vartok@var2954 ; vartok@var2954 =@expr1073752627 tok@var2942 .@expr10784 tokAt (@expr10785 2 ) ;
1349: const Token * strtok@var2955 ; strtok@var2955 =@expr1073752630 vartok@var2954 .@expr1073752631 next (@expr1073752632 ) .@expr1073752633 link (@expr1073752634 ) .@expr1073752635 tokAt (@expr1073752636 2 ) ;
1350: constantArrays@var2941 [@expr1073752637 vartok@var2954 .@expr1073752638 varId (@expr1073752639 ) ] =@expr1073752640 strtok@var2955 ;
1351: tok@var2942 =@expr1073752641 strtok@var2955 .@expr1073752642 next (@expr1073752643 ) ;
1352: continue ;
1353: } }
1354: }
1355: }
1356:
1357: static bool isNonZero ( const Token * tok@var2956 )
1358: {
1359: return tok@var2956 &&@expr1073752645 (@expr1073752646 !@expr1073752647 tok@var2956 .@expr1073752648 hasKnownIntValue (@expr1073752649 ) ||@expr1073752650 tok@var2956 .@expr1073752651 values (@expr1073752652 ) .@expr1073752653 front (@expr1073752654 ) .@expr1073752655 intvalue@expr1073752644 !=@expr1073752656 0 ) ;
1360: }
1361:
1362: static const Token * getOtherOperand ( const Token * tok@var2957 )
1363: {
1364: if (@expr1073752657 !@expr1073752658 tok@var2957 ) {
1365: return nullptr ; }
1366: if (@expr1073752659 !@expr1073752660 tok@var2957 .@expr10837 astParent (@expr10838 ) ) {
1367: return nullptr ; }
1368: if (@expr1073752663 tok@var2957 .@expr10837 astParent (@expr10838 ) .@expr10842 astOperand1 (@expr10843 ) !=@expr1073752668 tok@var2957 ) {
1369: return tok@var2957 .@expr10837 astParent (@expr10838 ) .@expr10842 astOperand1 (@expr10843 ) ; }
1370: if (@expr1073752673 tok@var2957 .@expr10837 astParent (@expr10838 ) .@expr10852 astOperand2 (@expr10853 ) !=@expr1073752678 tok@var2957 ) {
1371: return tok@var2957 .@expr10837 astParent (@expr10838 ) .@expr10852 astOperand2 (@expr10853 ) ; }
1372: return nullptr ;
1373: }
1374:
1375: static void valueFlowArrayBool ( TokenList * tokenlist@var2958 )
1376: {
1377: for (@expr1073752683 Token *@expr1073752684 tok@var2959 =@expr1073752685 tokenlist@var2958 .@expr1073752686 front (@expr1073752687 ) ; tok@var2959 ; tok@var2959 =@expr1073752688 tok@var2959 .@expr1073752689 next (@expr1073752690 ) ) {
1378: if (@expr1073752691 tok@var2959 .@expr1073752692 hasKnownIntValue (@expr1073752693 ) ) {
1379: continue ; }
1380: const Variable * var@var2960 ; var@var2960 =@expr1073752694 nullptr ;
1381: bool known@var2961 ; known@var2961 =@expr1073752695 false ;
1382: std ::@expr1073752696 list < ValueFlow ::@expr10873 Value > ::@expr1073752698 const_iterator val@var2962 ; val@var2962 =@expr1073752699
1383: std ::@expr1073752700 find_if (@expr1073752701 tok@var2959 .@expr10878 values (@expr10879 ) .@expr1073752704 begin (@expr1073752705 ) , tok@var2959 .@expr10878 values (@expr10879 ) .@expr10884 end (@expr10885 ) , std ::@expr1073752710 mem_fn (@expr1073752711 &@expr1073752712 ValueFlow ::@expr1073752713 Value ::@expr1073752714 isTokValue ) ) ;
1384: if (@expr1073752715 val@var2962 ==@expr1073752716 tok@var2959 .@expr10878 values (@expr10879 ) .@expr10884 end (@expr10885 ) ) {
1385: var@var2960 =@expr1073752721 tok@var2959 .@expr1073752722 variable (@expr1073752723 ) ;
1386: known@var2961 =@expr1073752724 true ;
1387: } else {
1388: var@var2960 =@expr1073752725 val@var2962 .@expr1073752726 tokvalue@var2963 .@expr1073752727 variable (@expr1073752728 ) ;
1389: known@var2961 =@expr1073752729 val@var2962 .@expr1073752730 isKnown (@expr1073752731 ) ;
1390: }
1391: if (@expr1073752732 !@expr1073752733 var@var2960 ) {
1392: continue ; }
1393: if (@expr1073752734 !@expr1073752735 var@var2960 .@expr1073752736 isArray (@expr1073752737 ) ||@expr1073752738 var@var2960 .@expr1073752739 isArgument (@expr1073752740 ) ||@expr1073752741 var@var2960 .@expr1073752742 isStlType (@expr1073752743 ) ) {
1394: continue ; }
1395: if (@expr1073752744 isNonZero (@expr1073752745 getOtherOperand (@expr1073752746 tok@var2959 ) ) &&@expr1073752747 Token ::@expr10924 Match (@expr1073752749 tok@var2959 .@expr10926 astParent (@expr10927 ) , "%comp%" ) ) {
1396: continue ; }
1397:
1398: if (@expr1073752752 (@expr1073752753 astIsBool (@expr1073752754 tok@var2959 .@expr10926 astParent (@expr10927 ) ) &&@expr1073752757 !@expr1073752758 Token ::@expr10924 Match (@expr1073752760 tok@var2959 .@expr10926 astParent (@expr10927 ) , "(|%name%" ) ) ||@expr1073752763
1399: (@expr1073752764 tok@var2959 .@expr10926 astParent (@expr10927 ) &&@expr1073752767 Token ::@expr10924 Match (@expr1073752769 tok@var2959 .@expr10926 astParent (@expr10927 ) .@expr1073752772 previous (@expr1073752773 ) , "if|while|for (" ) ) ) {
1400: ValueFlow ::@expr10873 Value value@var2964 {@expr1073752775 1 } ;
1401: if (@expr1073752776 known@var2961 ) {
1402: value@var2964 .@expr1073752777 setKnown (@expr1073752778 ) ; }
1403: setTokenValue (@expr1073752779 tok@var2959 , value@var2964 , tokenlist@var2958 .@expr1073752780 getSettings (@expr1073752781 ) ) ;
1404: }
1405: }
1406: }
1407:
1408: static void valueFlowPointerAlias ( TokenList * tokenlist@var2965 )
1409: {
1410: for (@expr1073752782 Token *@expr1073752783 tok@var2966 =@expr1073752784 tokenlist@var2965 .@expr1073752785 front (@expr1073752786 ) ; tok@var2966 ; tok@var2966 =@expr1073752787 tok@var2966 .@expr1073752788 next (@expr1073752789 ) ) {
1411:
1412: if (@expr1073752790 !@expr1073752791 tok@var2966 .@expr1073752792 isUnaryOp (@expr1073752793 "&" ) ) {
1413: continue ; }
1414:
1415:
1416: if (@expr1073752794 !@expr1073752795 Token ::@expr1073752796 simpleMatch (@expr1073752797 tok@var2966 .@expr1073752798 astParent (@expr1073752799 ) , "=" ) ) {
1417: continue ; }
1418:
1419:
1420: const Token * vartok@var2967 ; vartok@var2967 =@expr1073752800 tok@var2966 .@expr1073752801 astOperand1 (@expr1073752802 ) ;
1421: while (@expr1073752803 vartok@var2967 ) {
1422: if (@expr1073752804 vartok@var2967 .@expr10981 str (@expr10982 ) ==@expr1073752807 "[" ) {
1423: vartok@var2967 =@expr1073752808 vartok@var2967 .@expr1073752809 astOperand1 (@expr1073752810 ) ; }
1424: else { if (@expr1073752811 vartok@var2967 .@expr10981 str (@expr10982 ) ==@expr1073752814 "." ||@expr1073752815 vartok@var2967 .@expr10981 str (@expr10982 ) ==@expr1073752818 "::" ) {
1425: vartok@var2967 =@expr1073752819 vartok@var2967 .@expr1073752820 astOperand2 (@expr1073752821 ) ; }
1426: else {
1427: break ; } }
1428: }
1429: if (@expr1073752822 !@expr1073752823 (@expr1073752824 vartok@var2967 &&@expr1073752825 vartok@var2967 .@expr11002 variable (@expr11003 ) &&@expr1073752828 !@expr1073752829 vartok@var2967 .@expr11002 variable (@expr11003 ) .@expr1073752832 isPointer (@expr1073752833 ) ) ) {
1430: continue ; }
1431:
1432: ValueFlow ::@expr1073752834 Value value@var2968 ;
1433: value@var2968 .@expr1073752835 valueType@var2969 =@expr1073752836 ValueFlow ::@expr1073752837 Value ::@expr1073752838 ValueType ::@expr1073752839 TOK ;
1434: value@var2968 .@expr1073752840 tokvalue@var2970 =@expr1073752841 tok@var2966 ;
1435: setTokenValue (@expr1073752842 tok@var2966 , value@var2968 , tokenlist@var2965 .@expr1073752843 getSettings (@expr1073752844 ) ) ;
1436: }
1437: }
1438:
1439: static void valueFlowBitAnd ( TokenList * tokenlist@var2971 )
1440: {
1441: for (@expr1073752845 Token *@expr1073752846 tok@var2972 =@expr1073752847 tokenlist@var2971 .@expr1073752848 front (@expr1073752849 ) ; tok@var2972 ; tok@var2972 =@expr1073752850 tok@var2972 .@expr1073752851 next (@expr1073752852 ) ) {
1442: if (@expr1073752853 tok@var2972 .@expr1073752854 str (@expr1073752855 ) !=@expr1073752856 "&" ) {
1443: continue ; }
1444:
1445: if (@expr1073752857 tok@var2972 .@expr1073752858 hasKnownValue (@expr1073752859 ) ) {
1446: continue ; }
1447:
1448: if (@expr1073752860 !@expr1073752861 tok@var2972 .@expr11038 astOperand1 (@expr11039 ) ||@expr1073752864 !@expr1073752865 tok@var2972 .@expr11042 astOperand2 (@expr11043 ) ) {
1449: continue ; }
1450:
1451: long long number@var2973 ;
1452: if (@expr1073752868 MathLib ::@expr11045 isInt (@expr1073752870 tok@var2972 .@expr11038 astOperand1 (@expr11039 ) .@expr11049 str (@expr11050 ) ) ) {
1453: number@var2973 =@expr1073752875 MathLib ::@expr11052 toLongNumber (@expr1073752877 tok@var2972 .@expr11038 astOperand1 (@expr11039 ) .@expr11049 str (@expr11050 ) ) ; }
1454: else { if (@expr1073752882 MathLib ::@expr11045 isInt (@expr1073752884 tok@var2972 .@expr11042 astOperand2 (@expr11043 ) .@expr11063 str (@expr11064 ) ) ) {
1455: number@var2973 =@expr1073752889 MathLib ::@expr11052 toLongNumber (@expr1073752891 tok@var2972 .@expr11042 astOperand2 (@expr11043 ) .@expr11063 str (@expr11064 ) ) ; }
1456: else {
1457: continue ; } }
1458:
1459: int bit@var2974 ; bit@var2974 =@expr1073752896 0 ;
1460: while (@expr1073752897 bit@var2974 <=@expr1073752898 (@expr1073752899 MathLib ::@expr1073752900 bigint_bits@var15 -@expr1073752901 2 ) &&@expr1073752902 (@expr1073752903 (@expr1073752904 (@expr1073752905 (@expr11082 long long ) 1 ) <<@expr11083 bit@var2974 ) <@expr1073752908 number@var2973 ) ) {
1461: ++@expr1073752909 bit@var2974 ; }
1462:
1463: if (@expr1073752910 (@expr1073752911 (@expr1073752912 (@expr11082 long long ) 1 ) <<@expr11083 bit@var2974 ) ==@expr1073752915 number@var2973 ) {
1464: setTokenValue (@expr1073752916 tok@var2972 , ValueFlow ::@expr11093 Value (@expr1073752918 0 ) , tokenlist@var2971 .@expr11095 getSettings (@expr11096 ) ) ;
1465: setTokenValue (@expr1073752921 tok@var2972 , ValueFlow ::@expr11093 Value (@expr1073752923 number@var2973 ) , tokenlist@var2971 .@expr11095 getSettings (@expr11096 ) ) ;
1466: }
1467: }
1468: }
1469:
1470: static void valueFlowSameExpressions ( TokenList * tokenlist@var2975 )
1471: {
1472: for (@expr1073752926 Token *@expr1073752927 tok@var2976 =@expr1073752928 tokenlist@var2975 .@expr1073752929 front (@expr1073752930 ) ; tok@var2976 ; tok@var2976 =@expr1073752931 tok@var2976 .@expr1073752932 next (@expr1073752933 ) ) {
1473: if (@expr1073752934 tok@var2976 .@expr1073752935 hasKnownIntValue (@expr1073752936 ) ) {
1474: continue ; }
1475:
1476: if (@expr1073752937 !@expr1073752938 tok@var2976 .@expr11115 astOperand1 (@expr11116 ) ||@expr1073752941 !@expr1073752942 tok@var2976 .@expr11119 astOperand2 (@expr11120 ) ) {
1477: continue ; }
1478:
1479: if (@expr1073752945 tok@var2976 .@expr11115 astOperand1 (@expr11116 ) .@expr1073752948 isLiteral (@expr1073752949 ) ||@expr1073752950 tok@var2976 .@expr11119 astOperand2 (@expr11120 ) .@expr1073752953 isLiteral (@expr1073752954 ) ) {
1480: continue ; }
1481:
1482: if (@expr1073752955 !@expr1073752956 astIsIntegral (@expr1073752957 tok@var2976 .@expr11115 astOperand1 (@expr11116 ) , false ) &&@expr1073752960 !@expr1073752961 astIsIntegral (@expr1073752962 tok@var2976 .@expr11119 astOperand2 (@expr11120 ) , false ) ) {
1483: continue ; }
1484:
1485: ValueFlow ::@expr1073752965 Value val@var2977 ;
1486:
1487: if (@expr1073752966 Token ::@expr11143 Match (@expr1073752968 tok@var2976 , "==|>=|<=|/" ) ) {
1488: val@var2977 =@expr1073752969 ValueFlow ::@expr11146 Value (@expr1073752971 1 ) ;
1489: val@var2977 .@expr11148 setKnown (@expr11149 ) ;
1490: }
1491:
1492: if (@expr1073752974 Token ::@expr11143 Match (@expr1073752976 tok@var2976 , "!=|>|<|%|-" ) ) {
1493: val@var2977 =@expr1073752977 ValueFlow ::@expr11146 Value (@expr1073752979 0 ) ;
1494: val@var2977 .@expr11148 setKnown (@expr11149 ) ;
1495: }
1496:
1497: if (@expr1073752982 !@expr1073752983 val@var2977 .@expr1073752984 isKnown (@expr1073752985 ) ) {
1498: continue ; }
1499:
1500: if (@expr1073752986 isSameExpression (@expr1073752987 tokenlist@var2975 .@expr1073752988 isCPP (@expr1073752989 ) , false , tok@var2976 .@expr11115 astOperand1 (@expr11116 ) , tok@var2976 .@expr11119 astOperand2 (@expr11120 ) , tokenlist@var2975 .@expr11170 getSettings (@expr11171 ) .@expr1073752996 library@var5315 , true , true , &@expr1073752997 val@var2977 .@expr1073752998 errorPath@var2978 ) ) {
1501: setTokenValue (@expr1073752999 tok@var2976 , val@var2977 , tokenlist@var2975 .@expr11170 getSettings (@expr11171 ) ) ;
1502: }
1503: }
1504: }
1505:
1506: static bool getExpressionRange ( const Token * expr@var2979 , long long * minvalue@var2980 , long long * maxvalue@var2981 )
1507: {
1508: if (@expr1073753003 expr@var2979 .@expr1073753004 hasKnownIntValue (@expr1073753005 ) ) {
1509: if (@expr11182 minvalue@var2980 ) {
1510: *@expr11183 minvalue@var2980 =@expr1073753008 expr@var2979 .@expr11185 values (@expr11186 ) .@expr11187 front (@expr11188 ) .@expr11189 intvalue@expr11178 ; }
1511: if (@expr11190 maxvalue@var2981 ) {
1512: *@expr11191 maxvalue@var2981 =@expr1073753016 expr@var2979 .@expr11185 values (@expr11186 ) .@expr11187 front (@expr11188 ) .@expr11189 intvalue@expr11178 ; }
1513: return true ;
1514: }
1515:
1516: if (@expr1073753022 expr@var2979 .@expr11199 str (@expr11200 ) ==@expr1073753025 "&" &&@expr1073753026 expr@var2979 .@expr11203 astOperand1 (@expr11204 ) &&@expr1073753029 expr@var2979 .@expr11206 astOperand2 (@expr11207 ) ) {
1517: long long vals@var2982 [@expr1073753032 4 ] ;
1518: bool lhsHasKnownRange@var2983 ; lhsHasKnownRange@var2983 =@expr1073753033 getExpressionRange (@expr1073753034 expr@var2979 .@expr11203 astOperand1 (@expr11204 ) , &@expr1073753037 vals@var2982 [@expr11214 0 ] , &@expr1073753039 vals@var2982 [@expr11216 1 ] ) ;
1519: bool rhsHasKnownRange@var2984 ; rhsHasKnownRange@var2984 =@expr1073753041 getExpressionRange (@expr1073753042 expr@var2979 .@expr11206 astOperand2 (@expr11207 ) , &@expr1073753045 vals@var2982 [@expr11222 2 ] , &@expr1073753047 vals@var2982 [@expr11224 3 ] ) ;
1520: if (@expr1073753049 !@expr11226 lhsHasKnownRange@var2983 &&@expr1073753051 !@expr11228 rhsHasKnownRange@var2984 ) {
1521: return false ; }
1522: if (@expr1073753053 !@expr11226 lhsHasKnownRange@var2983 ||@expr1073753055 !@expr11228 rhsHasKnownRange@var2984 ) {
1523: if (@expr11182 minvalue@var2980 ) {
1524: *@expr11183 minvalue@var2980 =@expr1073753059 lhsHasKnownRange@var2983 ?@expr1073753060 vals@var2982 [@expr11214 0 ] :@expr1073753062 vals@var2982 [@expr11222 2 ] ; }
1525: if (@expr11190 maxvalue@var2981 ) {
1526: *@expr11191 maxvalue@var2981 =@expr1073753066 lhsHasKnownRange@var2983 ?@expr1073753067 vals@var2982 [@expr11216 1 ] :@expr1073753069 vals@var2982 [@expr11224 3 ] ; }
1527: } else {
1528: if (@expr11182 minvalue@var2980 ) {
1529: *@expr11183 minvalue@var2980 =@expr1073753073 vals@var2982 [@expr11214 0 ] &@expr1073753075 vals@var2982 [@expr11222 2 ] ; }
1530: if (@expr11190 maxvalue@var2981 ) {
1531: *@expr11191 maxvalue@var2981 =@expr1073753079 vals@var2982 [@expr11216 1 ] &@expr1073753081 vals@var2982 [@expr11224 3 ] ; }
1532: }
1533: return true ;
1534: }
1535:
1536: if (@expr1073753083 expr@var2979 .@expr11199 str (@expr11200 ) ==@expr1073753086 "%" &&@expr1073753087 expr@var2979 .@expr11203 astOperand1 (@expr11204 ) &&@expr1073753090 expr@var2979 .@expr11206 astOperand2 (@expr11207 ) ) {
1537: long long vals@var2985 [@expr1073753093 4 ] ;
1538: if (@expr1073753094 !@expr1073753095 getExpressionRange (@expr1073753096 expr@var2979 .@expr11206 astOperand2 (@expr11207 ) , &@expr1073753099 vals@var2985 [@expr11276 2 ] , &@expr1073753101 vals@var2985 [@expr11278 3 ] ) ) {
1539: return false ; }
1540: if (@expr1073753103 vals@var2985 [@expr11276 2 ] <=@expr1073753105 0 ) {
1541: return false ; }
1542: bool lhsHasKnownRange@var2986 ; lhsHasKnownRange@var2986 =@expr1073753106 getExpressionRange (@expr1073753107 expr@var2979 .@expr11203 astOperand1 (@expr11204 ) , &@expr1073753110 vals@var2985 [@expr11287 0 ] , &@expr1073753112 vals@var2985 [@expr1073753113 1 ] ) ;
1543: if (@expr1073753114 lhsHasKnownRange@var2986 &&@expr1073753115 vals@var2985 [@expr11287 0 ] <@expr1073753117 0 ) {
1544: return false ; }
1545:
1546: if (@expr1073753118 !@expr1073753119 lhsHasKnownRange@var2986 &&@expr1073753120 (@expr1073753121 !@expr1073753122 expr@var2979 .@expr11203 astOperand1 (@expr11204 ) .@expr11301 valueType (@expr11302 ) ||@expr1073753127 expr@var2979 .@expr11203 astOperand1 (@expr11204 ) .@expr11301 valueType (@expr11302 ) .@expr1073753132 sign@var5341 !=@expr1073753133 ValueType ::@expr1073753134 Sign ::@expr1073753135 UNSIGNED ) ) {
1547: return false ; }
1548: if (@expr11182 minvalue@var2980 ) {
1549: *@expr11183 minvalue@var2980 =@expr1073753138 0 ; }
1550: if (@expr11190 maxvalue@var2981 ) {
1551: *@expr11191 maxvalue@var2981 =@expr1073753141 vals@var2985 [@expr11278 3 ] -@expr1073753143 1 ; }
1552: return true ;
1553: }
1554:
1555: return false ;
1556: }
1557:
1558: static void valueFlowRightShift ( TokenList * tokenList@var2987 , const Settings * settings@var2988 )
1559: {
1560: for (@expr1073753145 Token *@expr1073753146 tok@var2989 =@expr1073753147 tokenList@var2987 .@expr1073753148 front (@expr1073753149 ) ; tok@var2989 ; tok@var2989 =@expr1073753150 tok@var2989 .@expr1073753151 next (@expr1073753152 ) ) {
1561: if (@expr1073753153 tok@var2989 .@expr1073753154 str (@expr1073753155 ) !=@expr1073753156 ">>" ) {
1562: continue ; }
1563:
1564: if (@expr1073753157 tok@var2989 .@expr1073753158 hasKnownValue (@expr1073753159 ) ) {
1565: continue ; }
1566:
1567: if (@expr1073753160 !@expr1073753161 tok@var2989 .@expr11338 astOperand1 (@expr11339 ) ||@expr1073753164 !@expr1073753165 tok@var2989 .@expr11342 astOperand2 (@expr11343 ) ) {
1568: continue ; }
1569:
1570: if (@expr1073753168 !@expr1073753169 tok@var2989 .@expr11342 astOperand2 (@expr11343 ) .@expr1073753172 hasKnownValue (@expr1073753173 ) ) {
1571: continue ; }
1572:
1573: const long long rhsvalue@var2990 =@expr1073753174 tok@var2989 .@expr11342 astOperand2 (@expr11343 ) .@expr1073753177 values (@expr1073753178 ) .@expr1073753179 front (@expr1073753180 ) .@expr1073753181 intvalue@expr1073753144 ;
1574: if (@expr1073753182 rhsvalue@var2990 <@expr1073753183 0 ) {
1575: continue ; }
1576:
1577: if (@expr1073753184 !@expr1073753185 tok@var2989 .@expr11338 astOperand1 (@expr11339 ) .@expr11364 valueType (@expr11365 ) ||@expr1073753190 !@expr1073753191 tok@var2989 .@expr11338 astOperand1 (@expr11339 ) .@expr11364 valueType (@expr11365 ) .@expr1073753196 isIntegral (@expr1073753197 ) ) {
1578: continue ; }
1579:
1580: if (@expr1073753198 !@expr1073753199 tok@var2989 .@expr11342 astOperand2 (@expr11343 ) .@expr11378 valueType (@expr11379 ) ||@expr1073753204 !@expr1073753205 tok@var2989 .@expr11342 astOperand2 (@expr11343 ) .@expr11378 valueType (@expr11379 ) .@expr1073753210 isIntegral (@expr1073753211 ) ) {
1581: continue ; }
1582:
1583: long long lhsmax@var2991 ; lhsmax@var2991 =@expr1073753212 0 ;
1584: if (@expr1073753213 !@expr1073753214 getExpressionRange (@expr1073753215 tok@var2989 .@expr11338 astOperand1 (@expr11339 ) , nullptr , &@expr1073753218 lhsmax@var2991 ) ) {
1585: continue ; }
1586: if (@expr1073753219 lhsmax@var2991 <@expr1073753220 0 ) {
1587: continue ; }
1588: int lhsbits@var2992 ;
1589: if (@expr1073753221 (@expr1073753222 tok@var2989 .@expr11338 astOperand1 (@expr11339 ) .@expr11364 valueType (@expr11365 ) .@expr11403 type@var5342 ==@expr1073753228 ValueType ::@expr11405 Type ::@expr1073753230 CHAR ) ||@expr1073753231
1590: (@expr1073753232 tok@var2989 .@expr11338 astOperand1 (@expr11339 ) .@expr11364 valueType (@expr11365 ) .@expr11403 type@var5342 ==@expr1073753238 ValueType ::@expr11405 Type ::@expr1073753240 SHORT ) ||@expr1073753241
1591: (@expr1073753242 tok@var2989 .@expr11338 astOperand1 (@expr11339 ) .@expr11364 valueType (@expr11365 ) .@expr11403 type@var5342 ==@expr1073753248 ValueType ::@expr11405 Type ::@expr1073753250 WCHAR_T ) ||@expr1073753251
1592: (@expr1073753252 tok@var2989 .@expr11338 astOperand1 (@expr11339 ) .@expr11364 valueType (@expr11365 ) .@expr11403 type@var5342 ==@expr1073753258 ValueType ::@expr11405 Type ::@expr1073753260 BOOL ) ||@expr1073753261
1593: (@expr1073753262 tok@var2989 .@expr11338 astOperand1 (@expr11339 ) .@expr11364 valueType (@expr11365 ) .@expr11403 type@var5342 ==@expr1073753268 ValueType ::@expr11405 Type ::@expr1073753270 INT ) ) {
1594: lhsbits@var2992 =@expr1073753271 settings@var2988 .@expr1073753272 int_bit@var2993 ; }
1595: else { if (@expr1073753273 tok@var2989 .@expr11338 astOperand1 (@expr11339 ) .@expr11364 valueType (@expr11365 ) .@expr11403 type@var5342 ==@expr1073753279 ValueType ::@expr11405 Type ::@expr1073753281 LONG ) {
1596: lhsbits@var2992 =@expr1073753282 settings@var2988 .@expr1073753283 long_bit@var2994 ; }
1597: else { if (@expr1073753284 tok@var2989 .@expr11338 astOperand1 (@expr11339 ) .@expr11364 valueType (@expr11365 ) .@expr11403 type@var5342 ==@expr1073753290 ValueType ::@expr11405 Type ::@expr1073753292 LONGLONG ) {
1598: lhsbits@var2992 =@expr1073753293 settings@var2988 .@expr1073753294 long_long_bit@var2995 ; }
1599: else {
1600: continue ; } } }
1601: if (@expr1073753295 rhsvalue@var2990 >=@expr1073753296 lhsbits@var2992 ||@expr1073753297 rhsvalue@var2990 >=@expr1073753298 MathLib ::@expr1073753299 bigint_bits@var15 ||@expr1073753300 (@expr1073753301 1ULL <<@expr1073753302 rhsvalue@var2990 ) <=@expr1073753303 lhsmax@var2991 ) {
1602: continue ; }
1603:
1604: ValueFlow ::@expr1073753304 Value val@var2996 (@expr1073753305 0 ) ;
1605: val@var2996 .@expr1073753306 setKnown (@expr1073753307 ) ;
1606: setTokenValue (@expr1073753308 tok@var2989 , val@var2996 , tokenList@var2987 .@expr1073753309 getSettings (@expr1073753310 ) ) ;
1607: }
1608: }
1609:
1610: static std :: vector < long long > minUnsignedValue ( const Token * tok@var2997 , int depth@var2998 = 8 )
1611: {
1612: std ::@expr1073753312 vector < long long > result@var2999 ; result@var2999 =@expr1073753313 { } ;
1613: if (@expr1073753314 !@expr1073753315 tok@var2997 ) {
1614: return result@var2999 ; }
1615: if (@expr1073753316 depth@var2998 <@expr1073753317 0 ) {
1616: return result@var2999 ; }
1617: if (@expr1073753318 tok@var2997 .@expr1073753319 hasKnownIntValue (@expr1073753320 ) ) {
1618: result@var2999 =@expr1073753321 {@expr1073753322 tok@var2997 .@expr1073753323 values (@expr1073753324 ) .@expr1073753325 front (@expr1073753326 ) .@expr1073753327 intvalue@expr1073753311 } ;
1619: } else { if (@expr1073753328 !@expr1073753329 Token ::@expr1073753330 Match (@expr1073753331 tok@var2997 , "-|%|&|^" ) &&@expr1073753332 tok@var2997 .@expr1073753333 isConstOp (@expr1073753334 ) &&@expr1073753335 tok@var2997 .@expr11512 astOperand1 (@expr11513 ) &&@expr1073753338 tok@var2997 .@expr11515 astOperand2 (@expr11516 ) ) {
1620: std ::@expr1073753341 vector < long long > op1@var3000 ; op1@var3000 =@expr1073753342 minUnsignedValue (@expr1073753343 tok@var2997 .@expr11512 astOperand1 (@expr11513 ) , depth@var2998 -@expr11522 1 ) ;
1621: std ::@expr1073753347 vector < long long > op2@var3001 ; op2@var3001 =@expr1073753348 minUnsignedValue (@expr1073753349 tok@var2997 .@expr11515 astOperand2 (@expr11516 ) , depth@var2998 -@expr11522 1 ) ;
1622: if (@expr1073753353 !@expr1073753354 op1@var3000 .@expr1073753355 empty (@expr1073753356 ) &&@expr1073753357 !@expr1073753358 op2@var3001 .@expr1073753359 empty (@expr1073753360 ) ) {
1623: result@var2999 =@expr1073753361 calculate<std::vector<longlong>> (@expr1073753362 tok@var2997 .@expr1073753363 str (@expr1073753364 ) , op1@var3000 .@expr1073753365 front (@expr1073753366 ) , op2@var3001 .@expr1073753367 front (@expr1073753368 ) ) ;
1624: }
1625: } }
1626: if (@expr1073753369 result@var2999 .@expr1073753370 empty (@expr1073753371 ) &&@expr1073753372 astIsUnsigned (@expr1073753373 tok@var2997 ) ) {
1627: result@var2999 =@expr1073753374 {@expr1073753375 0 } ; }
1628: return result@var2999 ;
1629: }
1630:
1631: static bool isConvertedToIntegral ( const Token * tok@var3002 , const Settings * settings@var3003 )
1632: {
1633: if (@expr1073753376 !@expr1073753377 tok@var3002 ) {
1634: return false ; }
1635: std ::@expr1073753378 vector < ValueType > parentTypes@var3004 ; parentTypes@var3004 =@expr1073753379 getParentValueTypes (@expr1073753380 tok@var3002 , settings@var3003 ) ;
1636: if (@expr1073753381 parentTypes@var3004 .@expr1073753382 empty (@expr1073753383 ) ) {
1637: return false ; }
1638: const ValueType &@expr1073753384 vt@var3005 =@expr1073753385 parentTypes@var3004 .@expr1073753386 front (@expr1073753387 ) ;
1639: return vt@var3005 .@expr1073753388 type@var3006 !=@expr1073753389 ValueType ::@expr1073753390 UNKNOWN_INT &&@expr1073753391 vt@var3005 .@expr1073753392 isIntegral (@expr1073753393 ) ;
1640: }
1641:
1642: static void valueFlowImpossibleValues ( TokenList * tokenList@var3007 , const Settings * settings@var3008 )
1643: {
1644: for (@expr1073753394 Token *@expr1073753395 tok@var3009 =@expr1073753396 tokenList@var3007 .@expr1073753397 front (@expr1073753398 ) ; tok@var3009 ; tok@var3009 =@expr1073753399 tok@var3009 .@expr11576 next (@expr11577 ) ) {
1645: if (@expr1073753402 tok@var3009 .@expr1073753403 hasKnownIntValue (@expr1073753404 ) ) {
1646: continue ; }
1647: if (@expr1073753405 Token ::@expr11582 Match (@expr1073753407 tok@var3009 , "true|false" ) ) {
1648: continue ; }
1649: if (@expr1073753408 astIsBool (@expr1073753409 tok@var3009 ) ||@expr1073753410 Token ::@expr11582 Match (@expr1073753412 tok@var3009 , "%comp%" ) ) {
1650: ValueFlow ::@expr11589 Value lower@var3010 {@expr1073753414 -1 } ;
1651: lower@var3010 .@expr1073753415 bound@var3011 =@expr1073753416 ValueFlow ::@expr11593 Value ::@expr11594 Bound ::@expr11595 Upper ;
1652: lower@var3010 .@expr1073753420 setImpossible (@expr1073753421 ) ;
1653: setTokenValue (@expr1073753422 tok@var3009 , lower@var3010 , settings@var3008 ) ;
1654:
1655: ValueFlow ::@expr11589 Value upper@var3012 {@expr1073753424 2 } ;
1656: upper@var3012 .@expr1073753425 bound@var3013 =@expr1073753426 ValueFlow ::@expr11593 Value ::@expr11594 Bound ::@expr11605 Lower ;
1657: upper@var3012 .@expr1073753430 setImpossible (@expr1073753431 ) ;
1658: setTokenValue (@expr1073753432 tok@var3009 , upper@var3012 , settings@var3008 ) ;
1659: } else { if (@expr1073753433 astIsUnsigned (@expr1073753434 tok@var3009 ) &&@expr1073753435 !@expr1073753436 astIsPointer (@expr1073753437 tok@var3009 ) ) {
1660: std ::@expr1073753438 vector < long long > minvalue@var3014 ; minvalue@var3014 =@expr1073753439 minUnsignedValue (@expr1073753440 tok@var3009 ) ;
1661: if (@expr1073753441 minvalue@var3014 .@expr1073753442 empty (@expr1073753443 ) ) {
1662: continue ; }
1663: ValueFlow ::@expr11589 Value value@var3015 {@expr1073753445 std ::@expr1073753446 max < long long > (@expr1073753447 0 , minvalue@var3014 .@expr1073753448 front (@expr1073753449 ) ) -@expr1073753450 1 } ;
1664: value@var3015 .@expr1073753451 bound@var3016 =@expr1073753452 ValueFlow ::@expr11593 Value ::@expr11594 Bound ::@expr11595 Upper ;
1665: value@var3015 .@expr1073753456 setImpossible (@expr1073753457 ) ;
1666: setTokenValue (@expr1073753458 tok@var3009 , value@var3015 , settings@var3008 ) ;
1667: } }
1668: if (@expr1073753459 Token ::@expr11636 simpleMatch (@expr1073753461 tok@var3009 , "%" ) &&@expr1073753462 tok@var3009 .@expr11639 astOperand2 (@expr11640 ) &&@expr1073753465 tok@var3009 .@expr11639 astOperand2 (@expr11640 ) .@expr1073753468 hasKnownIntValue (@expr1073753469 ) ) {
1669: ValueFlow ::@expr11589 Value value@var3017 {@expr1073753471 tok@var3009 .@expr11639 astOperand2 (@expr11640 ) .@expr1073753474 values (@expr1073753475 ) .@expr1073753476 front (@expr1073753477 ) } ;
1670: value@var3017 .@expr1073753478 bound@var3018 =@expr1073753479 ValueFlow ::@expr11593 Value ::@expr11594 Bound ::@expr11605 Lower ;
1671: value@var3017 .@expr1073753483 setImpossible (@expr1073753484 ) ;
1672: setTokenValue (@expr1073753485 tok@var3009 , value@var3017 , settings@var3008 ) ;
1673: } else { if (@expr1073753486 Token ::@expr11582 Match (@expr1073753488 tok@var3009 , "abs|labs|llabs|fabs|fabsf|fabsl (" ) ) {
1674: ValueFlow ::@expr11589 Value value@var3019 {@expr1073753490 -1 } ;
1675: value@var3019 .@expr1073753491 bound@var3020 =@expr1073753492 ValueFlow ::@expr11593 Value ::@expr11594 Bound ::@expr11595 Upper ;
1676: value@var3019 .@expr1073753496 setImpossible (@expr1073753497 ) ;
1677: setTokenValue (@expr1073753498 tok@var3009 .@expr11576 next (@expr11577 ) , value@var3019 , settings@var3008 ) ;
1678: } else { if (@expr1073753501 Token ::@expr11582 Match (@expr1073753503 tok@var3009 , ". data|c_str (" ) &&@expr1073753504 astIsContainerOwned (@expr1073753505 tok@var3009 .@expr11682 astOperand1 (@expr11683 ) ) ) {
1679: const Library ::@expr1073753508 Container * container@var3021 ; container@var3021 =@expr1073753509 getLibraryContainer (@expr1073753510 tok@var3009 .@expr11682 astOperand1 (@expr11683 ) ) ;
1680: if (@expr1073753513 !@expr1073753514 container@var3021 ) {
1681: continue ; }
1682: if (@expr1073753515 !@expr1073753516 container@var3021 .@expr1073753517 stdStringLike@var3022 ) {
1683: continue ; }
1684: if (@expr1073753518 container@var3021 .@expr1073753519 view@var3023 ) {
1685: continue ; }
1686: ValueFlow ::@expr11589 Value value@var3024 {@expr1073753521 0 } ;
1687: value@var3024 .@expr1073753522 setImpossible (@expr1073753523 ) ;
1688: setTokenValue (@expr1073753524 tok@var3009 .@expr1073753525 tokAt (@expr1073753526 2 ) , value@var3024 , settings@var3008 ) ;
1689: } else { if (@expr1073753527 Token ::@expr11582 Match (@expr1073753529 tok@var3009 , "make_shared|make_unique <" ) &&@expr1073753530 Token ::@expr11636 simpleMatch (@expr1073753532 tok@var3009 .@expr11709 linkAt (@expr11710 1 ) , "> (" ) ) {
1690: ValueFlow ::@expr11589 Value value@var3025 {@expr1073753536 0 } ;
1691: value@var3025 .@expr1073753537 setImpossible (@expr1073753538 ) ;
1692: setTokenValue (@expr1073753539 tok@var3009 .@expr11709 linkAt (@expr11710 1 ) .@expr1073753542 next (@expr1073753543 ) , value@var3025 , settings@var3008 ) ;
1693: } else { if (@expr1073753544 tokenList@var3007 .@expr1073753545 isCPP (@expr1073753546 ) &&@expr1073753547 Token ::@expr11636 simpleMatch (@expr1073753549 tok@var3009 , "this" ) ) {
1694: ValueFlow ::@expr11589 Value value@var3026 {@expr1073753551 0 } ;
1695: value@var3026 .@expr1073753552 setImpossible (@expr1073753553 ) ;
1696: setTokenValue (@expr1073753554 tok@var3009 , value@var3026 , settings@var3008 ) ;
1697: } else { if (@expr1073753555 tok@var3009 .@expr1073753556 isIncompleteVar (@expr1073753557 ) &&@expr1073753558 tok@var3009 .@expr11735 astParent (@expr11736 ) &&@expr1073753561 tok@var3009 .@expr11735 astParent (@expr11736 ) .@expr1073753564 isUnaryOp (@expr1073753565 "-" ) &&@expr1073753566
1698: isConvertedToIntegral (@expr1073753567 tok@var3009 .@expr11735 astParent (@expr11736 ) , settings@var3008 ) ) {
1699: ValueFlow ::@expr11589 Value value@var3027 {@expr1073753571 0 } ;
1700: value@var3027 .@expr1073753572 setImpossible (@expr1073753573 ) ;
1701: setTokenValue (@expr1073753574 tok@var3009 , value@var3027 , settings@var3008 ) ;
1702: } } } } } }
1703: }
1704: }
1705:
1706: static void valueFlowEnumValue ( SymbolDatabase * symboldatabase@var3028 , const Settings * settings@var3029 )
1707: {
1708:
1709: for (@expr1073753576 Scope &@expr11753 scope@var3030 :@expr1073753578 symboldatabase@var3028 .@expr1073753579 scopeList@var3031 ) {
1710: if (@expr1073753580 scope@var3030 .@expr1073753581 type@var3032 !=@expr1073753582 Scope ::@expr1073753583 eEnum ) {
1711: continue ; }
1712: long long value@var3033 ; value@var3033 =@expr1073753584 0 ;
1713: bool prev_enum_is_known@var3034 ; prev_enum_is_known@var3034 =@expr1073753585 true ;
1714:
1715: for (@expr1073753586 Enumerator &@expr11753 enumerator@var3035 :@expr1073753588 scope@var3030 .@expr1073753589 enumeratorList@var3036 ) {
1716: if (@expr1073753590 enumerator@var3035 .@expr11767 start@var3037 ) {
1717: Token * rhs@var3038 ; rhs@var3038 =@expr1073753592 enumerator@var3035 .@expr11767 start@var3037 .@expr1073753594 previous (@expr1073753595 ) .@expr1073753596 astOperand2 (@expr1073753597 ) ;
1718: ValueFlow ::@expr1073753598 valueFlowConstantFoldAST (@expr1073753599 rhs@var3038 , settings@var3029 ) ;
1719: if (@expr1073753600 rhs@var3038 &&@expr1073753601 rhs@var3038 .@expr1073753602 hasKnownIntValue (@expr1073753603 ) ) {
1720: enumerator@var3035 .@expr11780 value@var3039 =@expr1073753605 rhs@var3038 .@expr1073753606 values (@expr1073753607 ) .@expr1073753608 front (@expr1073753609 ) .@expr1073753610 intvalue@expr1073753575 ;
1721: enumerator@var3035 .@expr11787 value_known@var3040 =@expr1073753612 true ;
1722: value@var3033 =@expr1073753613 enumerator@var3035 .@expr11780 value@var3039 +@expr1073753615 1 ;
1723: prev_enum_is_known@var3034 =@expr1073753616 true ;
1724: } else {
1725: prev_enum_is_known@var3034 =@expr1073753617 false ; }
1726: } else { if (@expr1073753618 prev_enum_is_known@var3034 ) {
1727: enumerator@var3035 .@expr11780 value@var3039 =@expr1073753620 value@var3033 ++@expr1073753621 ;
1728: enumerator@var3035 .@expr11787 value_known@var3040 =@expr1073753623 true ;
1729: } }
1730: }
1731: }
1732: }
1733:
1734: static void valueFlowGlobalConstVar ( TokenList * tokenList@var3041 , const Settings * settings@var3042 )
1735: {
1736:
1737: std ::@expr1073753624 map < const Variable *@expr11801 , ValueFlow ::@expr11802 Value > vars@var3043 ;
1738: for (@expr1073753627 const Token *@expr11801 tok@var3044 =@expr1073753629 tokenList@var3041 .@expr11806 front (@expr11807 ) ; tok@var3044 ; tok@var3044 =@expr1073753632 tok@var3044 .@expr11809 next (@expr11810 ) ) {
1739: if (@expr1073753635 !@expr1073753636 tok@var3044 .@expr11813 variable (@expr11814 ) ) {
1740: continue ; }
1741:
1742: if (@expr1073753639 tok@var3044 ==@expr1073753640 tok@var3044 .@expr11813 variable (@expr11814 ) .@expr1073753643 nameToken (@expr1073753644 ) &&@expr1073753645
1743: !@expr1073753646 tok@var3044 .@expr11813 variable (@expr11814 ) .@expr1073753649 isVolatile (@expr1073753650 ) &&@expr1073753651
1744: !@expr1073753652 tok@var3044 .@expr11813 variable (@expr11814 ) .@expr1073753655 isArgument (@expr1073753656 ) &&@expr1073753657
1745: tok@var3044 .@expr11813 variable (@expr11814 ) .@expr1073753660 isConst (@expr1073753661 ) &&@expr1073753662
1746: tok@var3044 .@expr11839 valueType (@expr11840 ) &&@expr1073753665
1747: tok@var3044 .@expr11839 valueType (@expr11840 ) .@expr1073753668 isIntegral (@expr1073753669 ) &&@expr1073753670
1748: tok@var3044 .@expr11839 valueType (@expr11840 ) .@expr1073753673 pointer@var5317 ==@expr1073753674 0 &&@expr1073753675
1749: tok@var3044 .@expr11839 valueType (@expr11840 ) .@expr1073753678 constness@var5325 ==@expr1073753679 1 &&@expr1073753680
1750: Token ::@expr1073753681 Match (@expr1073753682 tok@var3044 , "%name% =" ) &&@expr1073753683
1751: tok@var3044 .@expr11809 next (@expr11810 ) .@expr11862 astOperand2 (@expr11863 ) &&@expr1073753688
1752: tok@var3044 .@expr11809 next (@expr11810 ) .@expr11862 astOperand2 (@expr11863 ) .@expr1073753693 hasKnownIntValue (@expr1073753694 ) ) {
1753: vars@var3043 [@expr1073753695 tok@var3044 .@expr11813 variable (@expr11814 ) ] =@expr1073753698 tok@var3044 .@expr11809 next (@expr11810 ) .@expr11862 astOperand2 (@expr11863 ) .@expr1073753703 values (@expr1073753704 ) .@expr1073753705 front (@expr1073753706 ) ;
1754: }
1755: }
1756:
1757:
1758: for (@expr1073753707 Token *@expr11801 tok@var3045 =@expr1073753709 tokenList@var3041 .@expr11806 front (@expr11807 ) ; tok@var3045 ; tok@var3045 =@expr1073753712 tok@var3045 .@expr1073753713 next (@expr1073753714 ) ) {
1759: if (@expr1073753715 !@expr1073753716 tok@var3045 .@expr11893 variable (@expr11894 ) ) {
1760: continue ; }
1761: std ::@expr1073753719 map < const Variable *@expr11801 , ValueFlow ::@expr11802 Value > ::@expr1073753722 const_iterator var@var3046 ; var@var3046 =@expr1073753723 vars@var3043 .@expr1073753724 find (@expr1073753725 tok@var3045 .@expr11893 variable (@expr11894 ) ) ;
1762: if (@expr1073753728 var@var3046 ==@expr1073753729 vars@var3043 .@expr1073753730 end (@expr1073753731 ) ) {
1763: continue ; }
1764: setTokenValue (@expr1073753732 tok@var3045 , var@var3046 .@expr1073753733 second@var3047 , settings@var3042 ) ;
1765: }
1766: }
1767:
1768: static void valueFlowGlobalStaticVar ( TokenList * tokenList@var3048 , const Settings * settings@var3049 )
1769: {
1770:
1771: std ::@expr1073753734 map < const Variable *@expr11911 , ValueFlow ::@expr11912 Value > vars@var3050 ;
1772: for (@expr1073753737 const Token *@expr11911 tok@var3051 =@expr1073753739 tokenList@var3048 .@expr11916 front (@expr11917 ) ; tok@var3051 ; tok@var3051 =@expr1073753742 tok@var3051 .@expr11919 next (@expr11920 ) ) {
1773: if (@expr1073753745 !@expr1073753746 tok@var3051 .@expr11923 variable (@expr11924 ) ) {
1774: continue ; }
1775:
1776: if (@expr1073753749 tok@var3051 ==@expr1073753750 tok@var3051 .@expr11923 variable (@expr11924 ) .@expr1073753753 nameToken (@expr1073753754 ) &&@expr1073753755
1777: tok@var3051 .@expr11923 variable (@expr11924 ) .@expr1073753758 isStatic (@expr1073753759 ) &&@expr1073753760
1778: !@expr1073753761 tok@var3051 .@expr11923 variable (@expr11924 ) .@expr1073753764 isConst (@expr1073753765 ) &&@expr1073753766
1779: tok@var3051 .@expr11943 valueType (@expr11944 ) &&@expr1073753769
1780: tok@var3051 .@expr11943 valueType (@expr11944 ) .@expr1073753772 isIntegral (@expr1073753773 ) &&@expr1073753774
1781: tok@var3051 .@expr11943 valueType (@expr11944 ) .@expr1073753777 pointer@var5317 ==@expr1073753778 0 &&@expr1073753779
1782: tok@var3051 .@expr11943 valueType (@expr11944 ) .@expr1073753782 constness@var5325 ==@expr1073753783 0 &&@expr1073753784
1783: Token ::@expr11961 Match (@expr1073753786 tok@var3051 , "%name% =" ) &&@expr1073753787
1784: tok@var3051 .@expr11919 next (@expr11920 ) .@expr11966 astOperand2 (@expr11967 ) &&@expr1073753792
1785: tok@var3051 .@expr11919 next (@expr11920 ) .@expr11966 astOperand2 (@expr11967 ) .@expr1073753797 hasKnownIntValue (@expr1073753798 ) ) {
1786: vars@var3050 [@expr1073753799 tok@var3051 .@expr11923 variable (@expr11924 ) ] =@expr1073753802 tok@var3051 .@expr11919 next (@expr11920 ) .@expr11966 astOperand2 (@expr11967 ) .@expr1073753807 values (@expr1073753808 ) .@expr1073753809 front (@expr1073753810 ) ;
1787: } else {
1788:
1789: if (@expr1073753811 !@expr1073753812 tok@var3051 .@expr11989 astParent (@expr11990 ) ) {
1790: continue ; }
1791: if (@expr1073753815 Token ::@expr11961 Match (@expr1073753817 tok@var3051 .@expr11989 astParent (@expr11990 ) , "++|--|&" ) &&@expr1073753820 !@expr1073753821 tok@var3051 .@expr11989 astParent (@expr11990 ) .@expr1073753824 astOperand2 (@expr1073753825 ) ) {
1792: vars@var3050 .@expr12002 erase (@expr12003 tok@var3051 .@expr11923 variable (@expr11924 ) ) ; }
1793: else { if (@expr1073753830 tok@var3051 .@expr11989 astParent (@expr11990 ) .@expr1073753833 isAssignmentOp (@expr1073753834 ) ) {
1794: if (@expr1073753835 tok@var3051 ==@expr1073753836 tok@var3051 .@expr11989 astParent (@expr11990 ) .@expr1073753839 astOperand1 (@expr1073753840 ) ) {
1795: vars@var3050 .@expr12002 erase (@expr12003 tok@var3051 .@expr11923 variable (@expr11924 ) ) ; }
1796: else { if (@expr1073753845 tokenList@var3048 .@expr12022 isCPP (@expr12023 ) &&@expr1073753848 Token ::@expr11961 Match (@expr1073753850 tok@var3051 .@expr11989 astParent (@expr11990 ) .@expr1073753853 tokAt (@expr1073753854 -2 ) , "& %name% =" ) ) {
1797: vars@var3050 .@expr12002 erase (@expr12003 tok@var3051 .@expr11923 variable (@expr11924 ) ) ; } }
1798: } else { if (@expr1073753859 isLikelyStreamRead (@expr1073753860 tokenList@var3048 .@expr12022 isCPP (@expr12023 ) , tok@var3051 .@expr11989 astParent (@expr11990 ) ) ) {
1799: vars@var3050 .@expr12002 erase (@expr12003 tok@var3051 .@expr11923 variable (@expr11924 ) ) ;
1800: } else { if (@expr1073753869 Token ::@expr11961 Match (@expr1073753871 tok@var3051 .@expr11989 astParent (@expr11990 ) , "[(,]" ) ) {
1801: vars@var3050 .@expr12002 erase (@expr12003 tok@var3051 .@expr11923 variable (@expr11924 ) ) ; } } } }
1802: }
1803: }
1804:
1805:
1806: for (@expr1073753878 Token *@expr11911 tok@var3052 =@expr1073753880 tokenList@var3048 .@expr11916 front (@expr11917 ) ; tok@var3052 ; tok@var3052 =@expr1073753883 tok@var3052 .@expr1073753884 next (@expr1073753885 ) ) {
1807: if (@expr1073753886 !@expr1073753887 tok@var3052 .@expr12064 variable (@expr12065 ) ) {
1808: continue ; }
1809: std ::@expr1073753890 map < const Variable *@expr11911 , ValueFlow ::@expr11912 Value > ::@expr1073753893 const_iterator var@var3053 ; var@var3053 =@expr1073753894 vars@var3050 .@expr1073753895 find (@expr1073753896 tok@var3052 .@expr12064 variable (@expr12065 ) ) ;
1810: if (@expr1073753899 var@var3053 ==@expr1073753900 vars@var3050 .@expr1073753901 end (@expr1073753902 ) ) {
1811: continue ; }
1812: setTokenValue (@expr1073753903 tok@var3052 , var@var3053 .@expr1073753904 second@var3054 , settings@var3049 ) ;
1813: }
1814: }
1815:
1816: static Analyzer :: Result valueFlowForward ( Token * startToken@var3055 ,
1817: const Token * endToken@var3056 ,
1818: const Token * exprTok@var3057 ,
1819: const std :: list < ValueFlow :: Value > & values@var3058 ,
1820: TokenList * const tokenlist@var3059 ,
1821: const Settings * settings@var3060 ) ;
1822:
1823: static void valueFlowReverse ( TokenList * tokenlist@var3061 ,
1824: Token * tok@var3062 ,
1825: const Token * const varToken@var3063 ,
1826: ValueFlow :: Value val@var3064 ,
1827: const ValueFlow :: Value & val2@var3065 ,
1828: ErrorLogger * errorLogger@var3066 ,
1829: const Settings * settings@var3067 ) ;
1830:
1831: static bool isConditionKnown ( const Token * tok@var3068 , bool then@var3069 )
1832: {
1833: const char * op@var3070 ; op@var3070 =@expr1073753905 "||" ;
1834: if (@expr1073753906 then@var3069 ) {
1835: op@var3070 =@expr1073753907 "&&" ; }
1836: const Token * parent@var3071 ; parent@var3071 =@expr1073753908 tok@var3068 .@expr1073753909 astParent (@expr1073753910 ) ;
1837: while (@expr1073753911 parent@var3071 &&@expr1073753912 (@expr1073753913 parent@var3071 .@expr12090 str (@expr12091 ) ==@expr1073753916 op@var3070 ||@expr1073753917 parent@var3071 .@expr12090 str (@expr12091 ) ==@expr1073753920 "!" ) ) {
1838: parent@var3071 =@expr1073753921 parent@var3071 .@expr1073753922 astParent (@expr1073753923 ) ; }
1839: return Token ::@expr1073753924 Match (@expr1073753925 parent@var3071 , "(|;" ) ;
1840: }
1841:
1842: static const std :: string & invertAssign ( const std :: string & assign@var3072 )
1843: {
1844: static std ::@expr1073753926 unordered_map < std ::@expr12103 string , std ::@expr12103 string > lookup@var3073 =@expr1073753929 {@expr1073753930 {@expr1073753931 "=" , "=" } ,
1845: {@expr1073753932 "+=" , "-=" } ,
1846: {@expr1073753933 "-=" , "+=" } ,
1847: {@expr1073753934 "*=" , "/=" } ,
1848: {@expr1073753935 "/=" , "*=" } ,
1849: {@expr1073753936 "<<=" , ">>=" } ,
1850: {@expr1073753937 ">>=" , "<<=" } ,
1851: {@expr1073753938 "^=" , "^=" } } ;
1852: auto it@var3074 ; it@var3074 =@expr1073753939 lookup@var3073 .@expr1073753940 find (@expr1073753941 assign@var3072 ) ;
1853: if (@expr1073753942 it@var3074 ==@expr1073753943 lookup@var3073 .@expr1073753944 end (@expr1073753945 ) ) {
1854: static std ::@expr1073753946 string empty@var3075 ;
1855: return empty@var3075 ;
1856: }
1857: else {
1858: return it@var3074 .@expr1073753947 second@var3076 ; }
1859: }
1860:
1861: static std :: string removeAssign ( const std :: string & assign@var3077 ) {
1862: return std ::@expr1073753948 string {@expr1073753949 assign@var3077 .@expr1073753950 begin (@expr1073753951 ) , assign@var3077 .@expr1073753952 end (@expr1073753953 ) -@expr1073753954 1 } ;
1863: }
1864:
1865: template < class T , class U >
1866: static T calculateAssign ( const std :: string & assign@var3078 , const T & x@var3079 , const U & y@var3080 , bool * error@var3081 = nullptr )
1867: {
1868: if (@expr1073753955 assign@var3078 .@expr1073753956 empty (@expr1073753957 ) ||@expr1073753958 assign@var3078 .@expr1073753959 back (@expr1073753960 ) !=@expr1073753961 '=' ) {
1869: if (@expr1073753962 error@var3081 ) {
1870: *@expr1073753963 error@var3081 =@expr1073753964 true ; }
1871: return T {@expr1073753965 } ;
1872: }
1873: if (@expr1073753966 assign@var3078 ==@expr1073753967 "=" ) {
1874: return y@var3080 ; }
1875: return calculate < T , T > (@expr1073753968 removeAssign (@expr1073753969 assign@var3078 ) , x@var3079 , y@var3080 , error@var3081 ) ;
1876: }
1877:
1878: template < class T , class U >
1879: static void assignValueIfMutable ( T & x@var3082 , const U & y@var3083 )
1880: {
1881: x@var3082 =@expr1073753970 y@var3083 ;
1882: }
1883:
1884: template < class T , class U >
1885: static void assignValueIfMutable ( const T & , const U & )
1886: { }
1887:
1888: template < class Value , $class $= $typename $std $:: $enable_if $< std :: is_convertible < Value & , const ValueFlow :: Value & > $:: $value $> $:: $type >
1889: static bool evalAssignment ( Value & lhsValue@var3084 , const std :: string & assign@var3085 , const ValueFlow :: Value & rhsValue@var3086 )
1890: {
1891: bool error@var3087 ; error@var3087 =@expr1073753971 false ;
1892: if (@expr1073753972 lhsValue@var3084 .@expr1073753973 isSymbolicValue (@expr1073753974 ) &&@expr1073753975 rhsValue@var3086 .@expr12152 isIntValue (@expr12153 ) ) {
1893: if (@expr1073753978 assign@var3085 !=@expr1073753979 "+=" &&@expr1073753980 assign@var3085 !=@expr1073753981 "-=" ) {
1894: return false ; }
1895: assignValueIfMutable (@expr12158 lhsValue@var3084 .@expr12159 intvalue@var3088 , calculateAssign (@expr12160 assign@var3085 , lhsValue@var3084 .@expr12159 intvalue@var3088 , rhsValue@var3086 .@expr12162 intvalue@var3089 , &@expr12163 error@var3087 ) ) ;
1896: } else { if (@expr1073753988 lhsValue@var3084 .@expr1073753989 isIntValue (@expr1073753990 ) &&@expr1073753991 rhsValue@var3086 .@expr12152 isIntValue (@expr12153 ) ) {
1897: assignValueIfMutable (@expr12158 lhsValue@var3084 .@expr12159 intvalue@var3088 , calculateAssign (@expr12160 assign@var3085 , lhsValue@var3084 .@expr12159 intvalue@var3088 , rhsValue@var3086 .@expr12162 intvalue@var3089 , &@expr12163 error@var3087 ) ) ;
1898: } else { if (@expr1073754000 lhsValue@var3084 .@expr1073754001 isFloatValue (@expr1073754002 ) &&@expr1073754003 rhsValue@var3086 .@expr12152 isIntValue (@expr12153 ) ) {
1899: assignValueIfMutable (@expr1073754006 lhsValue@var3084 .@expr12183 floatValue@var3090 ,
1900: calculateAssign (@expr1073754008 assign@var3085 , lhsValue@var3084 .@expr12183 floatValue@var3090 , rhsValue@var3086 .@expr12162 intvalue@var3089 , &@expr12163 error@var3087 ) ) ;
1901: } else {
1902: return false ;
1903: } } }
1904: return !@expr1073754012 error@var3087 ;
1905: }
1906:
1907: template < class T >
1908: struct SingleRange {
1909: T * x@var3091 ;
1910: T * begin ( ) const {
1911: return x@var3091 ;
1912: }
1913: T * end ( ) const {
1914: return x@var3091 +@expr1073754013 1 ;
1915: }
1916: } ;
1917:
1918: template < class T >
1919: SingleRange < T > MakeSingleRange ( T & x@var3092 )
1920: {
1921: return {@expr1073754014 &@expr1073754015 x@var3092 } ;
1922: }
1923:
1924: class SelectValueFromVarIdMapRange {
1925:
1926:
1927: struct Iterator {
1928:
|
1932:
1933: explicit Iterator ( const std :: unordered_map < int , ValueFlow :: Value > :: const_iterator & it@var3093 )
1934: : mIt@var3102 ( it@var3093 ) { }
1935:
1936: const ValueFlow :: Value & operator* ( ) const {
1937: return mIt@var3102 .@expr1073754016 second@var3103 ;
1938: }
1939:
1940: const ValueFlow :: Value * operator-> ( ) const {
1941: return &@expr1073754017 mIt@var3102 .@expr1073754018 second@var3103 ;
1942: }
1943:
1944: Iterator & operator++ ( ) {
1945:
1946: mIt@var3102 ++@expr1073754019 ;
1947: return *@expr1073754020 this@expr1073754021 ;
1948: }
1949:
1950: friend bool operator== ( const Iterator & a@var3094 , const Iterator & b@var3095 ) {
1951: return a@var3094 .@expr1073754022 mIt@var3096 ==@expr1073754023 b@var3095 .@expr1073754024 mIt@var3097 ;
1952: }
1953:
1954: friend bool operator!= ( const Iterator & a@var3098 , const Iterator & b@var3099 ) {
1955: return a@var3098 .@expr1073754025 mIt@var3100 !=@expr1073754026 b@var3099 .@expr1073754027 mIt@var3101 ;
1956: }
1957:
1958: private:
1959: std :: unordered_map < int , ValueFlow :: Value > :: const_iterator mIt@var3102 ;
1960: } ;
1961:
1962: public:
1963: explicit SelectValueFromVarIdMapRange ( const std :: unordered_map < int , ValueFlow :: Value > * m@var3104 )
1964: : mMap@var3105 ( m@var3104 ) { }
1965:
1966: Iterator begin ( ) const {
1967: return Iterator (@expr1073754028 mMap@var3105 .@expr1073754029 begin (@expr1073754030 ) ) ;
1968: }
1969: Iterator end ( ) const {
1970: return Iterator (@expr1073754031 mMap@var3105 .@expr1073754032 end (@expr1073754033 ) ) ;
1971: }
1972:
1973: private:
1974: const std :: unordered_map < int , ValueFlow :: Value > * mMap@var3105 ;
1975: } ;
1976:
1977:
1978: template < typename V >
1979: static bool isAliasOf ( const Variable * var@var3106 , const Token * tok@var3107 , int varid@var3108 , const V & values@var3109 , bool * inconclusive@var3110 = nullptr )
1980: {
1981: if (@expr1073754034 tok@var3107 .@expr12211 varId (@expr12212 ) ==@expr1073754037 varid@var3108 ) {
1982: return false ; }
1983: if (@expr1073754038 tok@var3107 .@expr12211 varId (@expr12212 ) ==@expr1073754041 0 ) {
1984: return false ; }
1985: if (@expr1073754042 isAliasOf (@expr1073754043 tok@var3107 , varid@var3108 , inconclusive@var3110 ) ) {
1986: return true ; }
1987: if (@expr1073754044 var@var3106 &&@expr1073754045 !@expr1073754046 var@var3106 .@expr1073754047 isPointer (@expr1073754048 ) ) {
1988: return false ; }
1989:
1990: for (@expr1073754049 const ValueFlow ::@expr1073754050 Value &@expr1073754051 val@var3111 :@expr1073754052 values@var3109 ) {
1991: if (@expr1073754053 !@expr1073754054 val@var3111 .@expr1073754055 isNonValue (@expr1073754056 ) ) {
1992: continue ; }
1993: if (@expr1073754057 val@var3111 .@expr1073754058 isInconclusive (@expr1073754059 ) ) {
1994: continue ; }
1995: if (@expr1073754060 val@var3111 .@expr12237 isLifetimeValue (@expr12238 ) &&@expr1073754063 !@expr1073754064 val@var3111 .@expr1073754065 isLocalLifetimeValue (@expr1073754066 ) ) {
1996: continue ; }
1997: if (@expr1073754067 val@var3111 .@expr12237 isLifetimeValue (@expr12238 ) &&@expr1073754070 val@var3111 .@expr1073754071 lifetimeKind@var3112 !=@expr1073754072 ValueFlow ::@expr1073754073 Value ::@expr1073754074 LifetimeKind ::@expr1073754075 Address ) {
1998: continue ; }
1999: if (@expr1073754076 !@expr1073754077 Token ::@expr1073754078 Match (@expr1073754079 val@var3111 .@expr12256 tokvalue@var3113 , ".|&|*|%var%" ) ) {
2000: continue ; }
2001: if (@expr1073754081 astHasVar (@expr1073754082 val@var3111 .@expr12256 tokvalue@var3113 , tok@var3107 .@expr12211 varId (@expr12212 ) ) ) {
2002: return true ; }
2003: }
2004: return false ;
2005: }
2006:
2007: static bool bifurcate ( const Token * tok@var3114 , const std :: set < int > & varids@var3115 , const Settings * settings@var3116 , int depth@var3117 = 20 ) ;
2008:
2009: static bool bifurcateVariableChanged ( const Variable * var@var3118 ,
2010: const std :: set < int > & varids@var3119 ,
2011: const Token * start@var3120 ,
2012: const Token * end@var3121 ,
2013: const Settings * settings@var3122 ,
2014: int depth@var3123 = 20 )
2015: {
2016: bool result@var3124 ; result@var3124 =@expr1073754086 false ;
2017: const Token * tok@var3125 ; tok@var3125 =@expr1073754087 start@var3120 ;
2018: while (@expr1073754088 tok@var3125 =@expr1073754089 findVariableChanged (@expr1073754090
2019: tok@var3125 .@expr1073754091 next (@expr1073754092 ) , end@var3121 , var@var3118 .@expr1073754093 isPointer (@expr1073754094 ) , var@var3118 .@expr1073754095 declarationId (@expr1073754096 ) , var@var3118 .@expr1073754097 isGlobal (@expr1073754098 ) , settings@var3122 , true ) ) {
2020: if (@expr1073754099 Token ::@expr1073754100 Match (@expr1073754101 tok@var3125 .@expr12278 astParent (@expr12279 ) , "%assign%" ) ) {
2021: if (@expr1073754104 !@expr1073754105 bifurcate (@expr1073754106 tok@var3125 .@expr12278 astParent (@expr12279 ) .@expr1073754109 astOperand2 (@expr1073754110 ) , varids@var3119 , settings@var3122 , depth@var3123 -@expr1073754111 1 ) ) {
2022: return true ; }
2023: } else {
2024: result@var3124 =@expr1073754112 true ;
2025: }
2026: }
2027: return result@var3124 ;
2028: }
2029:
2030: static bool bifurcate ( const Token * tok@var3126 , const std :: set < int > & varids@var3127 , const Settings * settings@var3128 , int depth@var3129 )
2031: {
2032: if (@expr1073754113 depth@var3129 <@expr1073754114 0 ) {
2033: return false ; }
2034: if (@expr1073754115 !@expr1073754116 tok@var3126 ) {
2035: return true ; }
2036: if (@expr1073754117 tok@var3126 .@expr1073754118 hasKnownIntValue (@expr1073754119 ) ) {
2037: return true ; }
2038: if (@expr1073754120 Token ::@expr12297 Match (@expr1073754122 tok@var3126 , "%cop%" ) ) {
2039: return bifurcate (@expr1073754123 tok@var3126 .@expr1073754124 astOperand1 (@expr1073754125 ) , varids@var3127 , settings@var3128 , depth@var3129 ) &&@expr1073754126 bifurcate (@expr1073754127 tok@var3126 .@expr1073754128 astOperand2 (@expr1073754129 ) , varids@var3127 , settings@var3128 , depth@var3129 ) ; }
2040: if (@expr1073754130 Token ::@expr12297 Match (@expr1073754132 tok@var3126 , "%var%" ) ) {
2041: if (@expr1073754133 varids@var3127 .@expr1073754134 count (@expr1073754135 tok@var3126 .@expr1073754136 varId (@expr1073754137 ) ) >@expr1073754138 0 ) {
2042: return true ; }
2043: const Variable * var@var3130 ; var@var3130 =@expr1073754139 tok@var3126 .@expr1073754140 variable (@expr1073754141 ) ;
2044: if (@expr1073754142 !@expr1073754143 var@var3130 ) {
2045: return false ; }
2046: const Token * start@var3131 ; start@var3131 =@expr1073754144 var@var3130 .@expr1073754145 declEndToken (@expr1073754146 ) ;
2047: if (@expr1073754147 !@expr1073754148 start@var3131 ) {
2048: return false ; }
2049: if (@expr1073754149 start@var3131 .@expr12326 strAt (@expr12327 -1 ) ==@expr1073754152 ")" ||@expr1073754153 start@var3131 .@expr12326 strAt (@expr12327 -1 ) ==@expr1073754156 "}" ) {
2050: return false ; }
2051: if (@expr1073754157 Token ::@expr12297 Match (@expr1073754159 start@var3131 , "; %varid% =" , var@var3130 .@expr1073754160 declarationId (@expr1073754161 ) ) ) {
2052: start@var3131 =@expr1073754162 start@var3131 .@expr1073754163 tokAt (@expr1073754164 2 ) ; }
2053: if (@expr1073754165 var@var3130 .@expr1073754166 isConst (@expr1073754167 ) ||@expr1073754168 !@expr1073754169 bifurcateVariableChanged (@expr1073754170 var@var3130 , varids@var3127 , start@var3131 , tok@var3126 , settings@var3128 , depth@var3129 ) ) {
2054: return var@var3130 .@expr1073754171 isArgument (@expr1073754172 ) ||@expr1073754173 bifurcate (@expr1073754174 start@var3131 .@expr1073754175 astOperand2 (@expr1073754176 ) , varids@var3127 , settings@var3128 , depth@var3129 -@expr1073754177 1 ) ; }
2055: return false ;
2056: }
2057: return false ;
2058: }
2059:
2060: struct ValueFlowAnalyzer : Analyzer {
2061: const TokenList * tokenlist@var3132 ;
2062: ProgramMemoryState pms@var3133 ;
2063:
2064: ValueFlowAnalyzer ( ) : tokenlist@var3132 ( nullptr ) , pms@var3133 ( nullptr ) { }
2065:
2066: explicit ValueFlowAnalyzer ( const TokenList * t@var3134 ) : tokenlist@var3132 ( t@var3134 ) , pms@var3133 ( tokenlist@var3132 . getSettings ( ) ) { }
2067:
2068: const virtual ValueFlow :: Value * getValue ( const Token * tok@var3135 ) const = 0 ;
2069: virtual ValueFlow :: Value * getValue ( const Token * tok@var3136 ) = 0 ;
2070:
2071: virtual void makeConditional ( ) = 0 ;
2072:
2073: virtual void addErrorPath ( const Token * tok@var3137 , const std :: string & s@var3138 ) = 0 ;
2074:
2075: virtual bool match ( const Token * tok@var3139 ) const = 0 ;
2076:
2077: virtual bool internalMatch ( const Token * ) const {
2078: return false ;
2079: }
2080:
2081: virtual bool isAlias ( const Token * tok@var3140 , bool & inconclusive@var3141 ) const = 0 ;
2082:
2083:
2084:
2085: virtual std :: unordered_map < ExprIdToken , ValueFlow :: Value , ExprIdToken :: Hash > getProgramState ( ) const = 0 ;
2086:
2087: virtual int getIndirect ( const Token * tok@var3142 ) const {
2088: const ValueFlow ::@expr1073754178 Value * value@var3143 ; value@var3143 =@expr1073754179 getValue (@expr1073754180 tok@var3142 ) ;
2089: if (@expr1073754181 value@var3143 ) {
2090: return value@var3143 .@expr1073754182 indirect@var3144 ; }
2091: return 0 ;
2092: }
2093:
2094: virtual bool isGlobal ( ) const {
2095: return false ;
2096: }
2097: virtual bool dependsOnThis ( ) const {
2098: return false ;
2099: }
2100: virtual bool isVariable ( ) const {
2101: return false ;
2102: }
2103:
2104: virtual bool invalid ( ) const {
2105: return false ;
2106: }
2107:
2108: bool isCPP ( ) const {
2109: return tokenlist@var3132 .@expr1073754183 isCPP (@expr1073754184 ) ;
2110: }
2111:
2112: const Settings * getSettings ( ) const {
2113: return tokenlist@var3132 .@expr1073754185 getSettings (@expr1073754186 ) ;
2114: }
2115:
2116: struct ConditionState {
2117: bool dependent@var3145 ; dependent@var3145 = true ;
2118: bool unknown@var3146 ; unknown@var3146 = true ;
2119:
2120: bool isUnknownDependent ( ) const {
2121: return unknown@var3146 &&@expr1073754187 dependent@var3145 ;
2122: }
2123: } ;
2124:
2125: std :: unordered_map < int , const Token * > getSymbols ( const Token * tok@var3147 ) const
2126: {
2127: std ::@expr1073754188 unordered_map < int , const Token *@expr1073754189 > result@var3148 ;
2128: if (@expr1073754190 !@expr1073754191 tok@var3147 ) {
2129: return result@var3148 ; }
2130: for (@expr1073754192 const ValueFlow ::@expr1073754193 Value &@expr1073754194 v@var3149 :@expr1073754195 tok@var3147 .@expr1073754196 values (@expr1073754197 ) ) {
2131: if (@expr1073754198 !@expr1073754199 v@var3149 .@expr1073754200 isSymbolicValue (@expr1073754201 ) ) {
2132: continue ; }
2133: if (@expr1073754202 v@var3149 .@expr1073754203 isImpossible (@expr1073754204 ) ) {
2134: continue ; }
2135: if (@expr1073754205 !@expr1073754206 v@var3149 .@expr12383 tokvalue@var3150 ) {
2136: continue ; }
2137: if (@expr1073754208 v@var3149 .@expr12383 tokvalue@var3150 .@expr12386 exprId (@expr12387 ) ==@expr1073754212 0 ) {
2138: continue ; }
2139: if (@expr1073754213 match (@expr1073754214 v@var3149 .@expr12383 tokvalue@var3150 ) ) {
2140: continue ; }
2141: result@var3148 [@expr1073754216 v@var3149 .@expr12383 tokvalue@var3150 .@expr12386 exprId (@expr12387 ) ] =@expr1073754220 v@var3149 .@expr12383 tokvalue@var3150 ;
2142: }
2143: return result@var3148 ;
2144: }
2145:
2146: ConditionState analyzeCondition ( const Token * tok@var3151 , int depth@var3152 = 20 ) const
2147: {
2148: ConditionState result@var3153 ;
2149: if (@expr1073754224 !@expr1073754225 tok@var3151 ) {
2150: return result@var3153 ; }
2151: if (@expr1073754226 depth@var3152 <@expr1073754227 0 ) {
2152: return result@var3153 ; }
2153: depth@var3152 --@expr1073754228 ;
2154: if (@expr1073754229 analyze (@expr1073754230 tok@var3151 , Direction ::@expr1073754231 Forward@expr1073754222 ) .@expr1073754232 isRead (@expr1073754233 ) ) {
2155: result@var3153 .@expr12410 dependent@var3154 =@expr1073754235 true ;
2156: result@var3153 .@expr12412 unknown@var3155 =@expr1073754237 false ;
2157: return result@var3153 ;
2158: } else { if (@expr1073754238 tok@var3151 .@expr1073754239 hasKnownIntValue (@expr1073754240 ) ||@expr1073754241 tok@var3151 .@expr1073754242 isLiteral (@expr1073754243 ) ) {
2159: result@var3153 .@expr12410 dependent@var3154 =@expr1073754245 false ;
2160: result@var3153 .@expr12412 unknown@var3155 =@expr1073754247 false ;
2161: return result@var3153 ;
2162: } else { if (@expr1073754248 Token ::@expr12425 Match (@expr1073754250 tok@var3151 , "%cop%" ) ) {
2163: if (@expr1073754251 isLikelyStream (@expr1073754252 isCPP (@expr1073754253 ) , tok@var3151 .@expr12430 astOperand1 (@expr12431 ) ) ) {
2164: result@var3153 .@expr12410 dependent@var3154 =@expr1073754257 false ;
2165: return result@var3153 ;
2166: }
2167: ConditionState lhs@var3156 ; lhs@var3156 =@expr1073754258 analyzeCondition (@expr1073754259 tok@var3151 .@expr12430 astOperand1 (@expr12431 ) , depth@var3152 -@expr12438 1 ) ;
2168: if (@expr1073754263 lhs@var3156 .@expr1073754264 isUnknownDependent (@expr1073754265 ) ) {
2169: return lhs@var3156 ; }
2170: ConditionState rhs@var3157 ; rhs@var3157 =@expr1073754266 analyzeCondition (@expr1073754267 tok@var3151 .@expr1073754268 astOperand2 (@expr1073754269 ) , depth@var3152 -@expr12438 1 ) ;
2171: if (@expr1073754271 rhs@var3157 .@expr1073754272 isUnknownDependent (@expr1073754273 ) ) {
2172: return rhs@var3157 ; }
2173: if (@expr1073754274 Token ::@expr12425 Match (@expr1073754276 tok@var3151 , "%comp%" ) ) {
2174: result@var3153 .@expr12410 dependent@var3154 =@expr1073754278 lhs@var3156 .@expr12455 dependent@var3158 &&@expr1073754280 rhs@var3157 .@expr12457 dependent@var3159 ; }
2175: else {
2176: result@var3153 .@expr12410 dependent@var3154 =@expr1073754283 lhs@var3156 .@expr12455 dependent@var3158 ||@expr1073754285 rhs@var3157 .@expr12457 dependent@var3159 ; }
2177: result@var3153 .@expr12412 unknown@var3155 =@expr1073754288 lhs@var3156 .@expr1073754289 unknown@var3160 ||@expr1073754290 rhs@var3157 .@expr1073754291 unknown@var3161 ;
2178: return result@var3153 ;
2179: } else { if (@expr1073754292 Token ::@expr12425 Match (@expr1073754294 tok@var3151 .@expr12471 previous (@expr12472 ) , "%name% (" ) ) {
2180: std ::@expr1073754297 vector < const Token *@expr12474 > args@var3162 ; args@var3162 =@expr1073754299 getArguments (@expr1073754300 tok@var3151 .@expr12471 previous (@expr12472 ) ) ;
2181: if (@expr1073754303 Token ::@expr12425 Match (@expr1073754305 tok@var3151 .@expr12482 tokAt (@expr12483 -2 ) , ". %name% (" ) ) {
2182: args@var3162 .@expr1073754308 push_back (@expr1073754309 tok@var3151 .@expr12482 tokAt (@expr12483 -2 ) .@expr1073754312 astOperand1 (@expr1073754313 ) ) ;
2183: }
2184: result@var3153 .@expr12410 dependent@var3154 =@expr1073754315 std ::@expr1073754316 any_of (@expr1073754317 args@var3162 .@expr1073754318 begin (@expr1073754319 ) , args@var3162 .@expr1073754320 end (@expr1073754321 ) , [@expr1073754322 &@expr1073754323 ] (@expr1073754324 const Token *@expr12474 arg@var3163 ) {
2185: ConditionState cs@var3164 ; cs@var3164 =@expr1073754326 analyzeCondition (@expr1073754327 arg@var3163 , depth@var3152 -@expr12438 1 ) ;
2186: return cs@var3164 .@expr1073754329 dependent@var3165 ;
2187: } ) ;
2188: if (@expr12506 result@var3153 .@expr12410 dependent@var3154 ) {
2189:
2190: if (@expr12508 !@expr12509 evaluate (@expr12510 Evaluate ::@expr12511 Integral@expr12399 , tok@var3151 ) .@expr12512 empty (@expr12513 ) ) {
2191: result@var3153 .@expr12412 unknown@var3155 =@expr1073754339 false ; }
2192: }
2193: return result@var3153 ;
2194: } else {
2195: std ::@expr1073754340 unordered_map < int , const Token *@expr12474 > symbols@var3166 ; symbols@var3166 =@expr1073754342 getSymbols (@expr1073754343 tok@var3151 ) ;
2196: result@var3153 .@expr12410 dependent@var3154 =@expr1073754345 false ;
2197: for (@expr1073754346 auto && p@var3167 :@expr1073754347 symbols@var3166 ) {
2198: const Token * arg@var3168 ; arg@var3168 =@expr1073754348 p@var3167 .@expr1073754349 second@var3169 ;
2199: ConditionState cs@var3170 ; cs@var3170 =@expr1073754350 analyzeCondition (@expr1073754351 arg@var3168 , depth@var3152 -@expr12438 1 ) ;
2200: result@var3153 .@expr12410 dependent@var3154 =@expr1073754354 cs@var3170 .@expr1073754355 dependent@var3171 ;
2201: if (@expr12506 result@var3153 .@expr12410 dependent@var3154 ) {
2202: break ; }
2203: }
2204: if (@expr12506 result@var3153 .@expr12410 dependent@var3154 ) {
2205:
2206: if (@expr12508 !@expr12509 evaluate (@expr12510 Evaluate ::@expr12511 Integral@expr12399 , tok@var3151 ) .@expr12512 empty (@expr12513 ) ) {
2207: result@var3153 .@expr12412 unknown@var3155 =@expr1073754367 false ; }
2208: }
2209: return result@var3153 ;
2210: } } } }
2211: }
2212:
2213: virtual Action isModified ( const Token * tok@var3172 ) const {
2214: Action read@var3173 ; read@var3173 =@expr1073754372 Action ::@expr1073754373 Read@expr1073754368 ;
2215: bool inconclusive@var3174 ; inconclusive@var3174 =@expr1073754374 false ;
2216: if (@expr1073754375 isVariableChangedByFunctionCall (@expr1073754376 tok@var3172 , getIndirect (@expr12553 tok@var3172 ) , getSettings (@expr12554 ) , &@expr1073754379 inconclusive@var3174 ) ) {
2217: return read@var3173 |@expr12556 Action ::@expr12557 Invalid@expr12545 ; }
2218: if (@expr1073754382 inconclusive@var3174 ) {
2219: return read@var3173 |@expr1073754383 Action ::@expr1073754384 Inconclusive@expr1073754370 ; }
2220: if (@expr1073754385 isVariableChanged (@expr1073754386 tok@var3172 , getIndirect (@expr12553 tok@var3172 ) , getSettings (@expr12554 ) , isCPP (@expr1073754389 ) ) ) {
2221: if (@expr1073754390 Token ::@expr1073754391 Match (@expr1073754392 tok@var3172 .@expr12569 astParent (@expr12570 ) , "*|[|.|++|--" ) ) {
2222: return read@var3173 |@expr12556 Action ::@expr12557 Invalid@expr12545 ; }
2223: const ValueFlow ::@expr1073754397 Value * value@var3175 ; value@var3175 =@expr1073754398 getValue (@expr1073754399 tok@var3172 ) ;
2224:
2225: if (@expr1073754400 value@var3175 &&@expr1073754401 !@expr1073754402 value@var3175 .@expr1073754403 isImpossible (@expr1073754404 ) &&@expr1073754405 Token ::@expr1073754406 simpleMatch (@expr1073754407 tok@var3172 .@expr12569 astParent (@expr12570 ) , "=" ) &&@expr1073754410 astIsLHS (@expr1073754411 tok@var3172 ) &&@expr1073754412
2226: astIsIntegral (@expr1073754413 tok@var3172 .@expr12569 astParent (@expr12570 ) .@expr12592 astOperand2 (@expr12593 ) , false ) ) {
2227: std ::@expr1073754418 vector < long long > result@var3176 ; result@var3176 =@expr1073754419
2228: evaluateInt (@expr1073754420 tok@var3172 .@expr12569 astParent (@expr12570 ) .@expr12592 astOperand2 (@expr12593 ) , [@expr1073754425 &@expr1073754426 ] {
2229: return ProgramMemory {@expr1073754427 getProgramState (@expr1073754428 ) } ;
2230: } ) ;
2231: if (@expr1073754429 !@expr1073754430 result@var3176 .@expr1073754431 empty (@expr1073754432 ) &&@expr1073754433 value@var3175 .@expr1073754434 equalTo (@expr1073754435 result@var3176 .@expr1073754436 front (@expr1073754437 ) ) ) {
2232: return Action ::@expr1073754438 Idempotent@expr1073754371 ; }
2233: }
2234: return Action ::@expr12557 Invalid@expr12545 ;
2235: }
2236: return read@var3173 ;
2237: }
2238:
2239: virtual Action isAliasModified ( const Token * tok@var3177 ) const {
2240:
2241: if (@expr1073754442 Token ::@expr1073754443 Match (@expr1073754444 tok@var3177 , "%var% (" ) ) {
2242:
2243: return Action ::@expr12621 Invalid@expr12616 ; }
2244: int indirect@var3178 ; indirect@var3178 =@expr1073754446 0 ;
2245: if (@expr1073754447 tok@var3177 .@expr12624 valueType (@expr12625 ) ) {
2246: indirect@var3178 =@expr1073754450 tok@var3177 .@expr12624 valueType (@expr12625 ) .@expr1073754453 pointer@var5317 ; }
2247: if (@expr1073754454 isVariableChanged (@expr1073754455 tok@var3177 , indirect@var3178 , getSettings (@expr1073754456 ) , isCPP (@expr1073754457 ) ) ) {
2248: return Action ::@expr12621 Invalid@expr12616 ; }
2249: return Action ::@expr1073754459 None@expr1073754441 ;
2250: }
2251:
2252: virtual Action isThisModified ( const Token * tok@var3179 ) const {
2253: if (@expr1073754462 isThisChanged (@expr1073754463 tok@var3179 , 0 , getSettings (@expr1073754464 ) , isCPP (@expr1073754465 ) ) ) {
2254: return Action ::@expr1073754466 Invalid@expr1073754460 ; }
2255: return Action ::@expr1073754467 None@expr1073754461 ;
2256: }
2257:
2258: Action isGlobalModified ( const Token * tok@var3180 ) const
2259: {
2260: if (@expr1073754470 tok@var3180 .@expr12647 function (@expr12648 ) ) {
2261: if (@expr1073754473 !@expr1073754474 tok@var3180 .@expr12647 function (@expr12648 ) .@expr1073754477 isConstexpr (@expr1073754478 ) &&@expr1073754479 !@expr1073754480 isConstFunctionCall (@expr1073754481 tok@var3180 , getSettings (@expr12658 ) .@expr12659 library@var5315 ) ) {
2262: return Action ::@expr12660 Invalid@expr12644 ; }
2263: } else { if (@expr1073754485 getSettings (@expr12658 ) .@expr12659 library@var5315 .@expr1073754488 getFunction (@expr1073754489 tok@var3180 ) ) {
2264:
2265: return Action ::@expr12666 None@expr12645 ;
2266: } else { if (@expr1073754491 Token ::@expr1073754492 simpleMatch (@expr1073754493 tok@var3180 .@expr12670 astParent (@expr12671 ) , "." ) &&@expr1073754496 astIsContainer (@expr1073754497 tok@var3180 .@expr12670 astParent (@expr12671 ) .@expr1073754500 astOperand1 (@expr1073754501 ) ) ) {
2267:
2268: return Action ::@expr12666 None@expr12645 ;
2269: } else { if (@expr1073754503 tok@var3180 .@expr1073754504 tokType (@expr1073754505 ) ==@expr1073754506 Token ::@expr1073754507 eType &&@expr1073754508 astIsPrimitive (@expr1073754509 tok@var3180 .@expr1073754510 next (@expr1073754511 ) ) ) {
2270:
2271: return Action ::@expr12666 None@expr12645 ;
2272: } else { if (@expr1073754513 !@expr1073754514 tok@var3180 .@expr1073754515 isKeyword (@expr1073754516 ) &&@expr1073754517 Token ::@expr1073754518 Match (@expr1073754519 tok@var3180 , "%name% (" ) ) {
2273: return Action ::@expr12660 Invalid@expr12644 ;
2274: } } } } }
2275: return Action ::@expr12666 None@expr12645 ;
2276: }
2277:
2278: static const std :: string & getAssign ( const Token * tok@var3181 , Direction d@var3182 )
2279: {
2280: if (@expr1073754523 d@var3182 ==@expr1073754524 Direction ::@expr1073754525 Forward@expr1073754522 ) {
2281: return tok@var3181 .@expr12702 str (@expr12703 ) ; }
2282: else {
2283: return invertAssign (@expr1073754528 tok@var3181 .@expr12702 str (@expr12703 ) ) ; }
2284: }
2285:
2286: virtual Action isWritable ( const Token * tok@var3183 , Direction d@var3184 ) const {
2287: const ValueFlow ::@expr12713 Value * value@var3185 ; value@var3185 =@expr1073754538 getValue (@expr1073754539 tok@var3183 ) ;
2288: if (@expr1073754540 !@expr1073754541 value@var3185 ) {
2289: return Action ::@expr12718 None@expr12707 ; }
2290: if (@expr1073754543 !@expr1073754544 (@expr1073754545 value@var3185 .@expr1073754546 isIntValue (@expr1073754547 ) ||@expr1073754548 value@var3185 .@expr1073754549 isFloatValue (@expr1073754550 ) ||@expr1073754551 value@var3185 .@expr1073754552 isSymbolicValue (@expr1073754553 ) ||@expr1073754554 value@var3185 .@expr12731 isLifetimeValue (@expr12732 ) ) ) {
2291: return Action ::@expr12718 None@expr12707 ; }
2292: const Token * parent@var3186 ; parent@var3186 =@expr1073754558 tok@var3183 .@expr12735 astParent (@expr12736 ) ;
2293:
2294: if (@expr1073754561 value@var3185 .@expr12738 isImpossible (@expr12739 ) &&@expr1073754564 !@expr1073754565 Token ::@expr12742 Match (@expr1073754567 parent@var3186 , "+=|-=|*=|++|--" ) ) {
2295: return Action ::@expr12718 None@expr12707 ; }
2296: if (@expr1073754569 value@var3185 .@expr12731 isLifetimeValue (@expr12732 ) ) {
2297: if (@expr1073754572 value@var3185 .@expr1073754573 lifetimeKind@var3187 !=@expr1073754574 ValueFlow ::@expr12713 Value ::@expr1073754576 LifetimeKind ::@expr1073754577 Iterator ) {
2298: return Action ::@expr12718 None@expr12707 ; }
2299: if (@expr1073754579 !@expr1073754580 Token ::@expr12742 Match (@expr1073754582 parent@var3186 , "++|--|+=" ) ) {
2300: return Action ::@expr12718 None@expr12707 ; }
2301: return Action ::@expr12760 Read@expr12708 |@expr12761 Action ::@expr12762 Write@expr12709 ;
2302: }
2303: if (@expr1073754587 parent@var3186 &&@expr1073754588 parent@var3186 .@expr1073754589 isAssignmentOp (@expr1073754590 ) &&@expr1073754591 astIsLHS (@expr1073754592 tok@var3183 ) &&@expr1073754593
2304: parent@var3186 .@expr12770 astOperand2 (@expr12771 ) .@expr1073754596 hasKnownValue (@expr1073754597 ) ) {
2305: const Token * rhs@var3188 ; rhs@var3188 =@expr1073754598 parent@var3186 .@expr12770 astOperand2 (@expr12771 ) ;
2306: const ValueFlow ::@expr12713 Value * rhsValue@var3189 ; rhsValue@var3189 =@expr1073754602 rhs@var3188 .@expr1073754603 getKnownValue (@expr1073754604 ValueFlow ::@expr12713 Value ::@expr1073754606 ValueType ::@expr1073754607 INT ) ;
2307: Action a@var3190 ;
2308: if (@expr1073754608 !@expr1073754609 rhsValue@var3189 ||@expr1073754610 !@expr1073754611 evalAssignment (@expr1073754612 *@expr1073754613 value@var3185 , getAssign (@expr1073754614 parent@var3186 , d@var3184 ) , *@expr12791 rhsValue@var3189 ) ) {
2309: a@var3190 =@expr1073754616 Action ::@expr1073754617 Invalid@expr1073754534 ; }
2310: else {
2311: a@var3190 =@expr1073754618 Action ::@expr12762 Write@expr12709 ; }
2312: if (@expr1073754620 parent@var3186 .@expr1073754621 str (@expr1073754622 ) !=@expr1073754623 "=" ) {
2313: a@var3190 |=@expr1073754624 Action ::@expr12760 Read@expr12708 ;
2314: } else {
2315: if (@expr1073754626 rhsValue@var3189 &&@expr1073754627 !@expr1073754628 value@var3185 .@expr12738 isImpossible (@expr12739 ) &&@expr1073754631 value@var3185 .@expr1073754632 equalValue (@expr1073754633 *@expr12791 rhsValue@var3189 ) ) {
2316: a@var3190 =@expr1073754635 Action ::@expr1073754636 Idempotent@expr1073754535 ; }
2317: a@var3190 |=@expr1073754637 Action ::@expr12814 Incremental@expr12712 ;
2318: }
2319: return a@var3190 ;
2320: }
2321:
2322:
2323: if (@expr1073754639 Token ::@expr12742 Match (@expr1073754641 tok@var3183 .@expr12735 astParent (@expr12736 ) , "++|--" ) ) {
2324: return Action ::@expr12760 Read@expr12708 |@expr12761 Action ::@expr12762 Write@expr12709 |@expr1073754647 Action ::@expr12814 Incremental@expr12712 ;
2325: }
2326: return Action ::@expr12718 None@expr12707 ;
2327: }
2328:
2329: virtual void writeValue ( ValueFlow :: Value * value@var3191 , const Token * tok@var3192 , Direction d@var3193 ) const {
2330: if (@expr1073754651 !@expr1073754652 value@var3191 ) {
2331: return ; }
2332: if (@expr1073754653 !@expr1073754654 tok@var3192 .@expr12831 astParent (@expr12832 ) ) {
2333: return ; }
2334:
2335: if (@expr1073754657 value@var3191 .@expr1073754658 isLifetimeValue (@expr1073754659 ) ) {
2336: return ; }
2337: if (@expr1073754660 tok@var3192 .@expr12831 astParent (@expr12832 ) .@expr1073754663 isAssignmentOp (@expr1073754664 ) ) {
2338: const ValueFlow ::@expr12841 Value * rhsValue@var3194 ; rhsValue@var3194 =@expr1073754666
2339: tok@var3192 .@expr12831 astParent (@expr12832 ) .@expr1073754669 astOperand2 (@expr1073754670 ) .@expr1073754671 getKnownValue (@expr1073754672 ValueFlow ::@expr12841 Value ::@expr1073754674 ValueType ::@expr1073754675 INT ) ;
2340: assert (@expr1073754676 rhsValue@var3194 ) ;
2341: if (@expr1073754677 evalAssignment (@expr1073754678 *@expr1073754679 value@var3191 , getAssign (@expr1073754680 tok@var3192 .@expr12831 astParent (@expr12832 ) , d@var3193 ) , *@expr1073754683 rhsValue@var3194 ) ) {
2342: const std ::@expr1073754684 string info@var3195 (@expr1073754685 "Compound assignment '" +@expr1073754686 tok@var3192 .@expr12831 astParent (@expr12832 ) .@expr12865 str (@expr12866 ) +@expr1073754691 "', assigned value is " +@expr1073754692
2343: value@var3191 .@expr12869 infoString (@expr12870 ) ) ;
2344: if (@expr1073754695 tok@var3192 .@expr12831 astParent (@expr12832 ) .@expr12865 str (@expr12866 ) ==@expr1073754700 "=" ) {
2345: value@var3191 .@expr12877 errorPath@var3196 .@expr1073754702 clear (@expr1073754703 ) ; }
2346: value@var3191 .@expr12877 errorPath@var3196 .@expr12881 emplace_back (@expr1073754706 tok@var3192 , info@var3195 ) ;
2347: } else {
2348: assert (@expr1073754707 false &&@expr1073754708 "Writable value cannot be evaluated" ) ;
2349:
2350: value@var3191 .@expr12885 intvalue@var3197 =@expr1073754710 0 ;
2351: }
2352: } else { if (@expr1073754711 tok@var3192 .@expr12831 astParent (@expr12832 ) .@expr1073754714 tokType (@expr1073754715 ) ==@expr1073754716 Token ::@expr1073754717 eIncDecOp ) {
2353: bool inc@var3198 ; inc@var3198 =@expr1073754718 tok@var3192 .@expr12831 astParent (@expr12832 ) .@expr12865 str (@expr12866 ) ==@expr1073754723 "++" ;
2354: std ::@expr1073754724 string opName@var3199 (@expr1073754725 inc@var3198 ?@expr1073754726 "incremented" :@expr1073754727 "decremented" ) ;
2355: if (@expr1073754728 d@var3193 ==@expr1073754729 Direction ::@expr1073754730 Reverse@expr1073754650 ) {
2356: inc@var3198 =@expr1073754731 !@expr1073754732 inc@var3198 ; }
2357: value@var3191 .@expr12885 intvalue@var3197 +=@expr1073754734 (@expr1073754735 inc@var3198 ?@expr1073754736 1 :@expr1073754737 -1 ) ;
2358: const std ::@expr1073754738 string info@var3200 (@expr1073754739 tok@var3192 .@expr1073754740 str (@expr1073754741 ) +@expr1073754742 " is " +@expr1073754743 opName@var3199 +@expr1073754744 "', new value is " +@expr1073754745 value@var3191 .@expr12869 infoString (@expr12870 ) ) ;
2359: value@var3191 .@expr12877 errorPath@var3196 .@expr12881 emplace_back (@expr1073754750 tok@var3192 , info@var3200 ) ;
2360: } }
2361: }
2362:
2363: virtual bool useSymbolicValues ( ) const {
2364: return true ;
2365: }
2366:
2367: const Token * findMatch ( const Token * tok@var3201 ) const
2368: {
2369: return findAstNode (@expr1073754751 tok@var3201 , [@expr1073754752 &@expr1073754753 ] (@expr1073754754 const Token *@expr1073754755 child@var3202 ) {
2370: return match (@expr1073754756 child@var3202 ) ;
2371: } ) ;
2372: }
2373:
2374: bool isSameSymbolicValue ( const Token * tok@var3203 , ValueFlow :: Value * value@var3204 = nullptr ) const
2375: {
2376: if (@expr1073754759 !@expr1073754760 useSymbolicValues (@expr1073754761 ) ) {
2377: return false ; }
2378: if (@expr1073754762 Token ::@expr1073754763 Match (@expr1073754764 tok@var3203 , "%assign%" ) ) {
2379: return false ; }
2380: const ValueFlow ::@expr12941 Value * currValue@var3205 ; currValue@var3205 =@expr1073754766 getValue (@expr1073754767 tok@var3203 ) ;
2381: if (@expr1073754768 !@expr1073754769 currValue@var3205 ) {
2382: return false ; }
2383:
2384: if (@expr1073754770 currValue@var3205 .@expr1073754771 isSymbolicValue (@expr1073754772 ) &&@expr1073754773
2385: std ::@expr1073754774 any_of (@expr1073754775 tok@var3203 .@expr12952 values (@expr12953 ) .@expr1073754778 begin (@expr1073754779 ) , tok@var3203 .@expr12952 values (@expr12953 ) .@expr1073754782 end (@expr1073754783 ) , [@expr1073754784 &@expr12961 ] (@expr1073754786 const ValueFlow ::@expr12963 Value &@expr12961 v@var3206 ) {
2386: return v@var3206 .@expr1073754789 isSymbolicValue (@expr1073754790 ) &&@expr1073754791 currValue@var3205 .@expr12968 equalValue (@expr1073754793 v@var3206 ) ;
2387: } ) ) {
2388: return false ; }
2389: const bool isPoint@var3207 =@expr1073754794 currValue@var3205 .@expr12971 bound@var3208 ==@expr1073754796 ValueFlow ::@expr12941 Value ::@expr12974 Bound ::@expr12975 Point &&@expr1073754800 currValue@var3205 .@expr12977 isIntValue (@expr12978 ) ;
2390: const bool exact@var3209 =@expr1073754803 !@expr1073754804 currValue@var3205 .@expr12977 isIntValue (@expr12978 ) ||@expr1073754807 currValue@var3205 .@expr1073754808 isImpossible (@expr1073754809 ) ;
2391: for (@expr1073754810 const ValueFlow ::@expr12963 Value &@expr12961 v@var3210 :@expr1073754813 tok@var3203 .@expr12952 values (@expr12953 ) ) {
2392: if (@expr1073754816 !@expr1073754817 v@var3210 .@expr1073754818 isSymbolicValue (@expr1073754819 ) ) {
2393: continue ; }
2394: if (@expr1073754820 currValue@var3205 .@expr12968 equalValue (@expr1073754822 v@var3210 ) ) {
2395: continue ; }
2396: const bool toImpossible@var3211 =@expr1073754823 v@var3210 .@expr1073754824 isImpossible (@expr1073754825 ) &&@expr1073754826 currValue@var3205 .@expr1073754827 isKnown (@expr1073754828 ) ;
2397: if (@expr1073754829 !@expr1073754830 v@var3210 .@expr1073754831 isKnown (@expr1073754832 ) &&@expr1073754833 !@expr1073754834 toImpossible@var3211 ) {
2398: continue ; }
2399: if (@expr1073754835 exact@var3209 &&@expr1073754836 v@var3210 .@expr13013 intvalue@var3212 !=@expr1073754838 0 &&@expr1073754839 !@expr1073754840 isPoint@var3207 ) {
2400: continue ; }
2401: std ::@expr1073754841 vector < long long > r@var3213 ;
2402: ValueFlow ::@expr12941 Value ::@expr1073754843 Bound bound@var3214 ; bound@var3214 =@expr1073754844 currValue@var3205 .@expr12971 bound@var3208 ;
2403: if (@expr1073754846 match (@expr1073754847 v@var3210 .@expr13024 tokvalue@var3215 ) ) {
2404: r@var3213 =@expr1073754849 {@expr1073754850 currValue@var3205 .@expr1073754851 intvalue@var3216 } ;
2405: } else { if (@expr1073754852 !@expr1073754853 exact@var3209 &&@expr1073754854 findMatch (@expr1073754855 v@var3210 .@expr13024 tokvalue@var3215 ) ) {
2406: r@var3213 =@expr1073754857 evaluate (@expr1073754858 Evaluate ::@expr1073754859 Integral@expr1073754757 , v@var3210 .@expr13024 tokvalue@var3215 , tok@var3203 ) ;
2407: if (@expr1073754861 bound@var3214 ==@expr1073754862 ValueFlow ::@expr12941 Value ::@expr12974 Bound ::@expr12975 Point@expr1073754758 ) {
2408: bound@var3214 =@expr1073754866 v@var3210 .@expr1073754867 bound@var3217 ; }
2409: } }
2410: if (@expr1073754868 !@expr1073754869 r@var3213 .@expr1073754870 empty (@expr1073754871 ) ) {
2411: if (@expr1073754872 value@var3204 ) {
2412: value@var3204 .@expr13049 errorPath@var3218 .@expr1073754874 insert (@expr1073754875 value@var3204 .@expr13049 errorPath@var3218 .@expr1073754877 end (@expr1073754878 ) , v@var3210 .@expr13055 errorPath@var3219 .@expr1073754880 begin (@expr1073754881 ) , v@var3210 .@expr13055 errorPath@var3219 .@expr1073754883 end (@expr1073754884 ) ) ;
2413: value@var3204 .@expr1073754885 intvalue@var3220 =@expr1073754886 r@var3213 .@expr1073754887 front (@expr1073754888 ) +@expr1073754889 v@var3210 .@expr13013 intvalue@var3212 ;
2414: if (@expr1073754891 toImpossible@var3211 ) {
2415: value@var3204 .@expr1073754892 setImpossible (@expr1073754893 ) ; }
2416: value@var3204 .@expr1073754894 bound@var3221 =@expr1073754895 bound@var3214 ;
2417: }
2418: return true ;
2419: }
2420: }
2421: return false ;
2422: }
2423:
2424: Action analyzeMatch ( const Token * tok@var3222 , Direction d@var3223 ) const {
2425: const Token * parent@var3224 ; parent@var3224 =@expr1073754899 tok@var3222 .@expr1073754900 astParent (@expr1073754901 ) ;
2426: if (@expr1073754902 d@var3223 ==@expr1073754903 Direction ::@expr1073754904 Reverse@expr1073754896 &&@expr1073754905 isGlobal (@expr1073754906 ) &&@expr1073754907 !@expr1073754908 dependsOnThis (@expr1073754909 ) &&@expr1073754910 Token ::@expr13087 Match (@expr1073754912 parent@var3224 , ". %name% (" ) ) {
2427: Action a@var3225 ; a@var3225 =@expr1073754913 isGlobalModified (@expr1073754914 parent@var3224 .@expr1073754915 next (@expr1073754916 ) ) ;
2428: if (@expr1073754917 a@var3225 !=@expr1073754918 Action ::@expr13095 None@expr13073 ) {
2429: return a@var3225 ; }
2430: }
2431: if (@expr1073754920 (@expr1073754921 astIsPointer (@expr1073754922 tok@var3222 ) ||@expr1073754923 astIsSmartPointer (@expr1073754924 tok@var3222 ) ) &&@expr1073754925
2432: (@expr1073754926 Token ::@expr13087 Match (@expr1073754928 parent@var3224 , "*|[" ) ||@expr1073754929 (@expr1073754930 parent@var3224 &&@expr1073754931 parent@var3224 .@expr1073754932 originalName (@expr1073754933 ) ==@expr1073754934 "->" ) ) &&@expr1073754935 getIndirect (@expr1073754936 tok@var3222 ) <=@expr1073754937 0 ) {
2433: return Action ::@expr1073754938 Read@expr1073754898 ; }
2434:
2435: Action w@var3226 ; w@var3226 =@expr1073754939 isWritable (@expr1073754940 tok@var3222 , d@var3223 ) ;
2436: if (@expr1073754941 w@var3226 !=@expr1073754942 Action ::@expr13095 None@expr13073 ) {
2437: return w@var3226 ; }
2438:
2439:
2440: return isModified (@expr1073754944 tok@var3222 ) ;
2441: }
2442:
2443: Action analyzeToken ( const Token * ref@var3227 , const Token * tok@var3228 , Direction d@var3229 , bool inconclusiveRef@var3230 ) const {
2444: if (@expr1073754951 !@expr1073754952 ref@var3227 ) {
2445: return Action ::@expr13129 None@expr13121 ; }
2446:
2447: assert (@expr1073754954 !@expr1073754955 inconclusiveRef@var3230 ||@expr1073754956 ref@var3227 !=@expr1073754957 tok@var3228 ) ;
2448: bool inconclusive@var3231 ; inconclusive@var3231 =@expr1073754958 false ;
2449: if (@expr1073754959 match (@expr1073754960 ref@var3227 ) ) {
2450: if (@expr1073754961 inconclusiveRef@var3230 ) {
2451: Action a@var3232 ; a@var3232 =@expr1073754962 isModified (@expr13139 tok@var3228 ) ;
2452: if (@expr1073754964 a@var3232 .@expr1073754965 isModified (@expr1073754966 ) ||@expr1073754967 a@var3232 .@expr1073754968 isInconclusive (@expr1073754969 ) ) {
2453: return Action ::@expr13146 Inconclusive@expr13122 ; }
2454: } else {
2455: return analyzeMatch (@expr1073754971 tok@var3228 , d@var3229 ) |@expr1073754972 Action ::@expr1073754973 Match@expr1073754947 ;
2456: }
2457: } else { if (@expr1073754974 ref@var3227 .@expr1073754975 isUnaryOp (@expr1073754976 "*" ) &&@expr1073754977 !@expr1073754978 match (@expr1073754979 ref@var3227 .@expr13156 astOperand1 (@expr13157 ) ) ) {
2458: const Token * lifeTok@var3233 ; lifeTok@var3233 =@expr1073754982 nullptr ;
2459: for (@expr1073754983 const ValueFlow ::@expr1073754984 Value &@expr1073754985 v@var3234 :@expr1073754986 ref@var3227 .@expr13156 astOperand1 (@expr13157 ) .@expr1073754989 values (@expr1073754990 ) ) {
2460: if (@expr1073754991 !@expr1073754992 v@var3234 .@expr1073754993 isLocalLifetimeValue (@expr1073754994 ) ) {
2461: continue ; }
2462: if (@expr1073754995 lifeTok@var3233 ) {
2463: return Action ::@expr13129 None@expr13121 ; }
2464: lifeTok@var3233 =@expr1073754997 v@var3234 .@expr1073754998 tokvalue@var3235 ;
2465: }
2466: if (@expr1073754999 lifeTok@var3233 &&@expr1073755000 match (@expr1073755001 lifeTok@var3233 ) ) {
2467: Action a@var3236 ; a@var3236 =@expr1073755002 Action ::@expr13179 Read@expr13124 ;
2468: if (@expr1073755004 isModified (@expr13139 tok@var3228 ) .@expr1073755006 isModified (@expr1073755007 ) ) {
2469: a@var3236 =@expr1073755008 Action ::@expr13185 Invalid@expr13125 ; }
2470: if (@expr1073755010 Token ::@expr1073755011 Match (@expr1073755012 tok@var3228 .@expr1073755013 astParent (@expr1073755014 ) , "%assign%" ) &&@expr1073755015 astIsLHS (@expr1073755016 tok@var3228 ) ) {
2471: a@var3236 |=@expr1073755017 Action ::@expr13185 Invalid@expr13125 ; }
2472: if (@expr1073755019 inconclusiveRef@var3230 &&@expr1073755020 a@var3236 .@expr1073755021 isModified (@expr1073755022 ) ) {
2473: return Action ::@expr13146 Inconclusive@expr13122 ; }
2474: return a@var3236 ;
2475: }
2476: return Action ::@expr13129 None@expr13121 ;
2477:
2478: } else { if (@expr1073755025 isAlias (@expr1073755026 ref@var3227 , inconclusive@var3231 ) ) {
2479: inconclusive@var3231 |=@expr1073755027 inconclusiveRef@var3230 ;
2480: Action a@var3237 ; a@var3237 =@expr1073755028 isAliasModified (@expr1073755029 tok@var3228 ) ;
2481: if (@expr1073755030 inconclusive@var3231 &&@expr1073755031 a@var3237 .@expr1073755032 isModified (@expr1073755033 ) ) {
2482: return Action ::@expr13146 Inconclusive@expr13122 ; }
2483: else {
2484: return a@var3237 ; }
2485: } else { if (@expr1073755035 isSameSymbolicValue (@expr1073755036 ref@var3227 ) ) {
2486: return Action ::@expr13179 Read@expr13124 |@expr1073755038 Action ::@expr1073755039 SymbolicMatch@expr1073754950 ;
2487: } } } }
2488: return Action ::@expr13129 None@expr13121 ;
2489: }
2490:
2491: virtual Action analyze ( const Token * tok@var3238 , Direction d@var3239 ) const override {
2492: if (@expr1073755044 invalid (@expr1073755045 ) ) {
2493: return Action ::@expr1073755046 Invalid@expr1073755041 ; }
2494:
2495: std ::@expr1073755047 vector < ReferenceToken > refs@var3240 ; refs@var3240 =@expr1073755048 followAllReferences (@expr1073755049 tok@var3238 ) ;
2496: const bool inconclusiveRefs@var3241 =@expr1073755050 refs@var3240 .@expr1073755051 size (@expr1073755052 ) !=@expr1073755053 1 ;
2497: if (@expr1073755054 std ::@expr1073755055 none_of (@expr1073755056 refs@var3240 .@expr1073755057 begin (@expr1073755058 ) , refs@var3240 .@expr1073755059 end (@expr1073755060 ) , [@expr1073755061 &@expr13238 ] (@expr1073755063 const ReferenceToken &@expr13238 ref@var3242 ) {
2498: return tok@var3238 ==@expr1073755065 ref@var3242 .@expr1073755066 token@var3243 ;
2499: } ) ) {
2500: refs@var3240 .@expr1073755067 push_back (@expr1073755068 ReferenceToken {@expr1073755069 tok@var3238 , { } } ) ; }
2501: for (@expr1073755070 const ReferenceToken &@expr13238 ref@var3244 :@expr1073755072 refs@var3240 ) {
2502: Action a@var3245 ; a@var3245 =@expr1073755073 analyzeToken (@expr1073755074 ref@var3244 .@expr13251 token@var3246 , tok@var3238 , d@var3239 , inconclusiveRefs@var3241 &&@expr1073755076 ref@var3244 .@expr13251 token@var3246 !=@expr1073755078 tok@var3238 ) ;
2503: if (@expr1073755079 internalMatch (@expr1073755080 ref@var3244 .@expr13251 token@var3246 ) ) {
2504: a@var3245 |=@expr1073755082 Action ::@expr1073755083 Internal@expr1073755042 ; }
2505: if (@expr1073755084 a@var3245 !=@expr1073755085 Action ::@expr13262 None@expr13219 ) {
2506: return a@var3245 ; }
2507: }
2508: if (@expr1073755087 dependsOnThis (@expr13264 ) &&@expr1073755089 exprDependsOnThis (@expr1073755090 tok@var3238 , !@expr1073755091 isVariable (@expr1073755092 ) ) ) {
2509: return isThisModified (@expr1073755093 tok@var3238 ) ; }
2510:
2511:
2512: if (@expr1073755094 isGlobal (@expr1073755095 ) &&@expr1073755096 !@expr1073755097 dependsOnThis (@expr13264 ) &&@expr1073755099 Token ::@expr1073755100 Match (@expr1073755101 tok@var3238 , "%name% (" ) &&@expr1073755102
2513: !@expr1073755103 Token ::@expr1073755104 simpleMatch (@expr1073755105 tok@var3238 .@expr1073755106 linkAt (@expr1073755107 1 ) , ") {" ) ) {
2514: return isGlobalModified (@expr1073755108 tok@var3238 ) ;
2515: }
2516: return Action ::@expr13262 None@expr13219 ;
2517: }
2518:
2519: template < class F >
2520: std :: vector < long long > evaluateInt ( const Token * tok@var3247 , F getProgramMemory@var3248 ) const
2521: {
2522: if (@expr1073755111 tok@var3247 .@expr1073755112 hasKnownIntValue (@expr1073755113 ) ) {
2523: return {@expr1073755114 static_cast < int > (@expr1073755115 tok@var3247 .@expr1073755116 values (@expr1073755117 ) .@expr1073755118 front (@expr1073755119 ) .@expr1073755120 intvalue@expr1073755110 ) } ; }
2524: std ::@expr1073755121 vector < long long > result@var3249 ;
2525: ProgramMemory pm@var3250 ; pm@var3250 =@expr1073755122 getProgramMemory@var3248 (@expr1073755123 ) ;
2526: if (@expr1073755124 Token ::@expr1073755125 Match (@expr1073755126 tok@var3247 , "&&|%oror%" ) ) {
2527: if (@expr1073755127 conditionIsTrue (@expr1073755128 tok@var3247 , pm@var3250 , getSettings (@expr13305 ) ) ) {
2528: result@var3249 .@expr13306 push_back (@expr1073755131 1 ) ; }
2529: if (@expr1073755132 conditionIsFalse (@expr1073755133 tok@var3247 , pm@var3250 , getSettings (@expr13305 ) ) ) {
2530: result@var3249 .@expr13306 push_back (@expr1073755136 0 ) ; }
2531: } else {
2532: long long out@var3251 ; out@var3251 =@expr1073755137 0 ;
2533: bool error@var3252 ; error@var3252 =@expr1073755138 false ;
2534: execute (@expr1073755139 tok@var3247 , &@expr1073755140 pm@var3250 , &@expr1073755141 out@var3251 , &@expr1073755142 error@var3252 , getSettings (@expr13305 ) ) ;
2535: if (@expr1073755144 !@expr1073755145 error@var3252 ) {
2536: result@var3249 .@expr13306 push_back (@expr1073755147 out@var3251 ) ; }
2537: }
2538: return result@var3249 ;
2539: }
2540:
2541: virtual std :: vector < long long > evaluate ( Evaluate e@var3253 , const Token * tok@var3254 , const Token * ctx@var3255 = nullptr ) const override
2542: {
2543: if (@expr1073755150 e@var3253 ==@expr1073755151 Evaluate ::@expr1073755152 Integral@expr1073755148 ) {
2544: return evaluateInt (@expr1073755153 tok@var3254 , [@expr1073755154 &@expr13331 ] {
2545: return pms@var3133 .@expr13332 get (@expr13333 tok@var3254 , ctx@var3255 , getProgramState (@expr13334 ) ) ;
2546: } ) ;
2547: } else { if (@expr1073755159 e@var3253 ==@expr1073755160 Evaluate ::@expr1073755161 ContainerEmpty@expr1073755149 ) {
2548: const ValueFlow ::@expr1073755162 Value * value@var3256 ; value@var3256 =@expr1073755163 ValueFlow ::@expr1073755164 findValue (@expr1073755165 tok@var3254 .@expr1073755166 values (@expr1073755167 ) , nullptr , [@expr1073755168 ] (@expr1073755169 const ValueFlow ::@expr1073755170 Value &@expr13331 v@var3257 ) {
2549: return v@var3257 .@expr1073755172 isKnown (@expr1073755173 ) &&@expr1073755174 v@var3257 .@expr1073755175 isContainerSizeValue (@expr1073755176 ) ;
2550: } ) ;
2551: if (@expr1073755177 value@var3256 ) {
2552: return {@expr1073755178 value@var3256 .@expr1073755179 intvalue@var3258 ==@expr1073755180 0 } ; }
2553: ProgramMemory pm@var3259 ; pm@var3259 =@expr1073755181 pms@var3133 .@expr13332 get (@expr13333 tok@var3254 , ctx@var3255 , getProgramState (@expr13334 ) ) ;
2554: long long out@var3260 ; out@var3260 =@expr1073755185 0 ;
2555: if (@expr1073755186 pm@var3259 .@expr1073755187 getContainerEmptyValue (@expr1073755188 tok@var3254 .@expr1073755189 exprId (@expr1073755190 ) , &@expr1073755191 out@var3260 ) ) {
2556: return {@expr1073755192 static_cast < int > (@expr1073755193 out@var3260 ) } ; }
2557: return { } ;
2558: } else {
2559: return { } ;
2560: } }
2561: }
2562:
2563: virtual void assume ( const Token * tok@var3261 , bool state@var3262 , unsigned int flags@var3263 ) override {
2564:
2565: pms@var3133 .@expr13373 removeModifiedVars (@expr1073755198 tok@var3261 ) ;
2566: pms@var3133 .@expr13375 addState (@expr1073755200 tok@var3261 , getProgramState (@expr13377 ) ) ;
2567: pms@var3133 .@expr1073755202 assume (@expr1073755203 tok@var3261 , state@var3262 , flags@var3263 &@expr13380 Assume ::@expr13381 ContainerEmpty@expr13370 ) ;
2568:
2569: bool isCondBlock@var3264 ; isCondBlock@var3264 =@expr1073755206 false ;
2570: const Token * parent@var3265 ; parent@var3265 =@expr1073755207 tok@var3261 .@expr1073755208 astParent (@expr1073755209 ) ;
2571: if (@expr1073755210 parent@var3265 ) {
2572: isCondBlock@var3264 =@expr1073755211 Token ::@expr1073755212 Match (@expr1073755213 parent@var3265 .@expr1073755214 previous (@expr1073755215 ) , "if|while (" ) ;
2573: }
2574:
2575: if (@expr1073755216 isCondBlock@var3264 ) {
2576: const Token * startBlock@var3266 ; startBlock@var3266 =@expr1073755217 parent@var3265 .@expr1073755218 link (@expr1073755219 ) .@expr1073755220 next (@expr1073755221 ) ;
2577: if (@expr1073755222 Token ::@expr13399 simpleMatch (@expr1073755224 startBlock@var3266 , ";" ) &&@expr1073755225 Token ::@expr13399 simpleMatch (@expr1073755227 parent@var3265 .@expr1073755228 tokAt (@expr1073755229 -2 ) , "} while (" ) ) {
2578: startBlock@var3266 =@expr1073755230 parent@var3265 .@expr1073755231 linkAt (@expr1073755232 -2 ) ; }
2579: const Token * endBlock@var3267 ; endBlock@var3267 =@expr1073755233 startBlock@var3266 .@expr1073755234 link (@expr1073755235 ) ;
2580: pms@var3133 .@expr13373 removeModifiedVars (@expr1073755237 endBlock@var3267 ) ;
2581: if (@expr1073755238 state@var3262 ) {
2582: pms@var3133 .@expr13375 addState (@expr1073755240 endBlock@var3267 .@expr1073755241 previous (@expr1073755242 ) , getProgramState (@expr13377 ) ) ; }
2583: else { if (@expr1073755244 Token ::@expr13399 simpleMatch (@expr1073755246 endBlock@var3267 , "} else {" ) ) {
2584: pms@var3133 .@expr13375 addState (@expr1073755248 endBlock@var3267 .@expr1073755249 linkAt (@expr1073755250 2 ) .@expr1073755251 previous (@expr1073755252 ) , getProgramState (@expr13377 ) ) ; } }
2585: }
2586:
2587: if (@expr1073755254 !@expr1073755255 (@expr1073755256 flags@var3263 &@expr1073755257 Assume ::@expr1073755258 Quiet@expr1073755195 ) ) {
2588: if (@expr1073755259 flags@var3263 &@expr13380 Assume ::@expr13381 ContainerEmpty@expr13370 ) {
2589: std ::@expr1073755262 string s@var3268 ; s@var3268 =@expr1073755263 state@var3262 ?@expr1073755264 "empty" :@expr1073755265 "not empty" ;
2590: addErrorPath (@expr1073755266 tok@var3261 , "Assuming container is " +@expr1073755267 s@var3268 ) ;
2591: } else {
2592: std ::@expr1073755268 string s@var3269 ; s@var3269 =@expr1073755269 state@var3262 ?@expr1073755270 "true" :@expr1073755271 "false" ;
2593: addErrorPath (@expr1073755272 tok@var3261 , "Assuming condition is " +@expr1073755273 s@var3269 ) ;
2594: }
2595: }
2596: if (@expr1073755274 !@expr1073755275 (@expr1073755276 flags@var3263 &@expr1073755277 Assume ::@expr1073755278 Absolute@expr1073755196 ) ) {
2597: makeConditional (@expr1073755279 ) ; }
2598: }
2599:
2600: virtual void internalUpdate ( Token * , const ValueFlow :: Value & , Direction )
2601: {
2602: assert (@expr1073755280 false &&@expr1073755281 "Internal update unimplemented." ) ;
2603: }
2604:
2605: virtual void update ( Token * tok@var3270 , Action a@var3271 , Direction d@var3272 ) override {
2606: ValueFlow ::@expr1073755282 Value * value@var3273 ; value@var3273 =@expr1073755283 getValue (@expr1073755284 tok@var3270 ) ;
2607: if (@expr1073755285 !@expr1073755286 value@var3273 ) {
2608: return ; }
2609: ValueFlow ::@expr1073755287 Value localValue@var3274 ;
2610: if (@expr1073755288 a@var3271 .@expr1073755289 isSymbolicMatch (@expr1073755290 ) ) {
2611:
2612: localValue@var3274 =@expr1073755291 *@expr13468 value@var3273 ;
2613: value@var3273 =@expr1073755293 &@expr13470 localValue@var3274 ;
2614: isSameSymbolicValue (@expr1073755295 tok@var3270 , &@expr13470 localValue@var3274 ) ;
2615: }
2616: if (@expr1073755297 a@var3271 .@expr1073755298 isInternal (@expr1073755299 ) ) {
2617: internalUpdate (@expr1073755300 tok@var3270 , *@expr13468 value@var3273 , d@var3272 ) ; }
2618:
2619: if (@expr1073755302 d@var3272 ==@expr1073755303 Direction ::@expr1073755304 Forward &&@expr1073755305 a@var3271 .@expr13482 isRead (@expr13483 ) ) {
2620: setTokenValue (@expr13484 tok@var3270 , *@expr13468 value@var3273 , getSettings (@expr13486 ) ) ; }
2621: if (@expr1073755311 a@var3271 .@expr1073755312 isInconclusive (@expr1073755313 ) ) {
2622: lowerToInconclusive (@expr1073755314 ) ; }
2623: if (@expr1073755315 a@var3271 .@expr1073755316 isWrite (@expr1073755317 ) &&@expr1073755318 tok@var3270 .@expr1073755319 astParent (@expr1073755320 ) ) {
2624: writeValue (@expr1073755321 value@var3273 , tok@var3270 , d@var3272 ) ;
2625: }
2626:
2627: if (@expr1073755322 d@var3272 ==@expr1073755323 Direction ::@expr1073755324 Reverse &&@expr1073755325 a@var3271 .@expr13482 isRead (@expr13483 ) ) {
2628: setTokenValue (@expr13484 tok@var3270 , *@expr13468 value@var3273 , getSettings (@expr13486 ) ) ; }
2629: }
2630:
2631: virtual ValuePtr<Analyzer> reanalyze ( Token * , const std :: string & ) const override {
2632: return { } ;
2633: }
2634: } ;
2635:
2636: ValuePtr<Analyzer> makeAnalyzer ( const Token * exprTok@var3275 , ValueFlow :: Value value@var3276 , const TokenList * tokenlist@var3277 ) ;
2637:
2638: struct SingleValueFlowAnalyzer : ValueFlowAnalyzer {
2639: std :: unordered_map < int , const Variable * > varids@var3278 ;
2640: std :: unordered_map < int , const Variable * > aliases@var3279 ;
2641: ValueFlow :: Value value@var3280 ;
2642:
2643: SingleValueFlowAnalyzer ( ) : ValueFlowAnalyzer ( ) { }
2644:
2645: SingleValueFlowAnalyzer ( const ValueFlow :: Value & v@var3281 , const TokenList * t@var3282 ) : ValueFlowAnalyzer ( t@var3282 ) , value@var3280 ( v@var3281 ) { }
2646:
2647: const std :: unordered_map < int , const Variable * > & getVars ( ) const {
2648: return varids@var3278 ;
2649: }
2650:
2651: const std :: unordered_map < int , const Variable * > & getAliasedVars ( ) const {
2652: return aliases@var3279 ;
2653: }
2654:
2655: const virtual ValueFlow :: Value * getValue ( const Token * ) const override {
2656: return &@expr1073755331 value@var3280 ;
2657: }
2658: virtual ValueFlow :: Value * getValue ( const Token * ) override {
2659: return &@expr1073755332 value@var3280 ;
2660: }
2661:
2662: virtual void makeConditional ( ) override {
2663: value@var3280 .@expr1073755333 conditional@var3283 =@expr1073755334 true ;
2664: }
2665:
2666: virtual bool useSymbolicValues ( ) const override
2667: {
2668: if (@expr1073755335 value@var3280 .@expr1073755336 isUninitValue (@expr1073755337 ) ) {
2669: return false ; }
2670: if (@expr1073755338 value@var3280 .@expr1073755339 isLifetimeValue (@expr1073755340 ) ) {
2671: return false ; }
2672: return true ;
2673: }
2674:
2675: virtual void addErrorPath ( const Token * tok@var3284 , const std :: string & s@var3285 ) override {
2676: value@var3280 .@expr1073755341 errorPath@var3286 .@expr1073755342 emplace_back (@expr1073755343 tok@var3284 , s@var3285 ) ;
2677: }
2678:
2679: virtual bool isAlias ( const Token * tok@var3287 , bool & inconclusive@var3288 ) const override {
2680: if (@expr1073755344 value@var3280 .@expr1073755345 isLifetimeValue (@expr1073755346 ) ) {
2681: return false ; }
2682: for (@expr1073755347 const auto &@expr13524 m@var3289 :@expr1073755349 {@expr1073755350
2683: std ::@expr13527 ref (@expr1073755352 getVars (@expr1073755353 ) ) , std ::@expr13527 ref (@expr1073755355 getAliasedVars (@expr1073755356 ) )
2684: } ) {
2685: for (@expr1073755357 const auto &@expr13524 p@var3290 :@expr1073755359 m@var3289 .@expr1073755360 get (@expr1073755361 ) ) {
2686: int varid@var3291 ; varid@var3291 =@expr1073755362 p@var3290 .@expr1073755363 first@var3292 ;
2687: const Variable * var@var3293 ; var@var3293 =@expr1073755364 p@var3290 .@expr1073755365 second@var3294 ;
2688: if (@expr1073755366 tok@var3287 .@expr1073755367 varId (@expr1073755368 ) ==@expr1073755369 varid@var3291 ) {
2689: return true ; }
2690: if (@expr1073755370 isAliasOf (@expr1073755371 var@var3293 , tok@var3287 , varid@var3291 , MakeSingleRange (@expr1073755372 value@var3280 ) , &@expr1073755373 inconclusive@var3288 ) ) {
2691: return true ; }
2692: }
2693: }
2694: return false ;
2695: }
2696:
2697: virtual bool isGlobal ( ) const override {
2698: for (@expr1073755374 const auto &@expr1073755375 p@var3295 :@expr1073755376 getVars (@expr1073755377 ) ) {
2699: const Variable * var@var3296 ; var@var3296 =@expr1073755378 p@var3295 .@expr1073755379 second@var3297 ;
2700: if (@expr1073755380 !@expr1073755381 var@var3296 .@expr1073755382 isLocal (@expr1073755383 ) &&@expr1073755384 !@expr1073755385 var@var3296 .@expr1073755386 isArgument (@expr1073755387 ) &&@expr1073755388 !@expr1073755389 var@var3296 .@expr1073755390 isConst (@expr1073755391 ) ) {
2701: return true ; }
2702: }
2703: return false ;
2704: }
2705:
2706: virtual bool lowerToPossible ( ) override {
2707: if (@expr1073755392 value@var3280 .@expr1073755393 isImpossible (@expr1073755394 ) ) {
2708: return false ; }
2709: value@var3280 .@expr1073755395 changeKnownToPossible (@expr1073755396 ) ;
2710: return true ;
2711: }
2712: virtual bool lowerToInconclusive ( ) override {
2713: if (@expr1073755397 value@var3280 .@expr1073755398 isImpossible (@expr1073755399 ) ) {
2714: return false ; }
2715: value@var3280 .@expr1073755400 setInconclusive (@expr1073755401 ) ;
2716: return true ;
2717: }
2718:
2719: virtual bool isConditional ( ) const override {
2720: if (@expr1073755402 value@var3280 .@expr1073755403 conditional@var3283 ) {
2721: return true ; }
2722: if (@expr1073755404 value@var3280 .@expr1073755405 condition@var3298 ) {
2723: return !@expr1073755406 value@var3280 .@expr1073755407 isKnown (@expr1073755408 ) &&@expr1073755409 !@expr1073755410 value@var3280 .@expr1073755411 isImpossible (@expr1073755412 ) ; }
2724: return false ;
2725: }
2726:
2727: virtual bool stopOnCondition ( const Token * condTok@var3299 ) const override
2728: {
2729: if (@expr1073755413 value@var3280 .@expr1073755414 isNonValue (@expr1073755415 ) ) {
2730: return false ; }
2731: if (@expr1073755416 value@var3280 .@expr13593 isImpossible (@expr13594 ) ) {
2732: return false ; }
2733: if (@expr1073755419 isConditional (@expr1073755420 ) &&@expr1073755421 !@expr1073755422 value@var3280 .@expr1073755423 isKnown (@expr1073755424 ) &&@expr1073755425 !@expr1073755426 value@var3280 .@expr13593 isImpossible (@expr13594 ) ) {
2734: return true ; }
2735: if (@expr1073755429 value@var3280 .@expr1073755430 isSymbolicValue (@expr1073755431 ) ) {
2736: return false ; }
2737: ConditionState cs@var3300 ; cs@var3300 =@expr1073755432 analyzeCondition (@expr1073755433 condTok@var3299 ) ;
2738: return cs@var3300 .@expr1073755434 isUnknownDependent (@expr1073755435 ) ;
2739: }
2740:
2741: virtual bool updateScope ( const Token * endBlock@var3301 , bool ) const override {
2742: const Scope * scope@var3302 ; scope@var3302 =@expr1073755436 endBlock@var3301 .@expr1073755437 scope (@expr1073755438 ) ;
2743: if (@expr1073755439 !@expr1073755440 scope@var3302 ) {
2744: return false ; }
2745: if (@expr1073755441 scope@var3302 .@expr13618 type@var3303 ==@expr1073755443 Scope ::@expr1073755444 eLambda ) {
2746: return value@var3280 .@expr13621 isLifetimeValue (@expr13622 ) ;
2747: } else { if (@expr1073755447 scope@var3302 .@expr13618 type@var3303 ==@expr1073755449 Scope ::@expr1073755450 eIf ||@expr1073755451 scope@var3302 .@expr13618 type@var3303 ==@expr1073755453 Scope ::@expr1073755454 eElse ||@expr1073755455 scope@var3302 .@expr13618 type@var3303 ==@expr1073755457 Scope ::@expr1073755458 eWhile ||@expr1073755459
2748: scope@var3302 .@expr13618 type@var3303 ==@expr1073755461 Scope ::@expr1073755462 eFor ) {
2749: if (@expr1073755463 value@var3280 .@expr1073755464 isKnown (@expr1073755465 ) ||@expr1073755466 value@var3280 .@expr1073755467 isImpossible (@expr1073755468 ) ) {
2750: return true ; }
2751: if (@expr1073755469 value@var3280 .@expr13621 isLifetimeValue (@expr13622 ) ) {
2752: return true ; }
2753: if (@expr1073755472 isConditional (@expr1073755473 ) ) {
2754: return false ; }
2755: const Token * condTok@var3304 ; condTok@var3304 =@expr1073755474 getCondTokFromEnd (@expr1073755475 endBlock@var3301 ) ;
2756: std ::@expr1073755476 set < int > varids2@var3305 ;
2757: std ::@expr1073755477 transform (@expr1073755478 getVars (@expr13655 ) .@expr1073755480 begin (@expr1073755481 ) , getVars (@expr13655 ) .@expr1073755483 end (@expr1073755484 ) , std ::@expr1073755485 inserter (@expr1073755486 varids2@var3305 , varids2@var3305 .@expr1073755487 begin (@expr1073755488 ) ) , SelectMapKeys {@expr1073755489 } ) ;
2758: return bifurcate (@expr1073755490 condTok@var3304 , varids2@var3305 , getSettings (@expr1073755491 ) ) ;
2759: } }
2760:
2761: return false ;
2762: }
2763:
2764: virtual ValuePtr<Analyzer> reanalyze ( Token * tok@var3306 , const std :: string & msg@var3307 ) const override {
2765: ValueFlow ::@expr1073755492 Value newValue@var3308 ; newValue@var3308 =@expr1073755493 value@var3280 ;
2766: newValue@var3308 .@expr1073755494 errorPath@var3309 .@expr1073755495 emplace_back (@expr1073755496 tok@var3306 , msg@var3307 ) ;
2767: return makeAnalyzer (@expr1073755497 tok@var3306 , newValue@var3308 , tokenlist@var3132 ) ;
2768: }
2769: } ;
2770:
2771: struct ExpressionAnalyzer : SingleValueFlowAnalyzer {
2772: const Token * expr@var3310 ;
2773: bool local@var3311 ;
2774: bool unknown@var3312 ;
2775: bool dependOnThis@var3313 ;
2776:
2777: ExpressionAnalyzer ( ) : SingleValueFlowAnalyzer ( ) , expr@var3310 ( nullptr ) , local@var3311 ( true ) , unknown@var3312 ( false ) , dependOnThis@var3313 ( false ) { }
2778:
2779: ExpressionAnalyzer ( const Token * e@var3314 , const ValueFlow :: Value & val@var3315 , const TokenList * t@var3316 )
2780: : SingleValueFlowAnalyzer ( val@var3315 , t@var3316 ) , expr@var3310 ( e@var3314 ) , local@var3311 ( true ) , unknown@var3312 ( false ) , dependOnThis@var3313 ( false ) {
2781:
2782: assert (@expr1073755498 e@var3314 &&@expr1073755499 e@var3314 .@expr1073755500 exprId (@expr1073755501 ) !=@expr1073755502 0 &&@expr1073755503 "Not a valid expression" ) ;
2783: dependOnThis@var3313 =@expr1073755504 exprDependsOnThis (@expr1073755505 expr@var3310 ) ;
2784: setupExprVarIds (@expr1073755506 expr@var3310 ) ;
2785: if (@expr1073755507 val@var3315 .@expr1073755508 isSymbolicValue (@expr1073755509 ) ) {
2786: setupExprVarIds (@expr1073755510 val@var3315 .@expr1073755511 tokvalue@var3317 ) ; }
2787: }
2788:
2789: static bool nonLocal ( const Variable * var@var3318 , bool deref@var3319 ) {
2790: return !@expr1073755512 var@var3318 ||@expr1073755513 (@expr1073755514 !@expr1073755515 var@var3318 .@expr1073755516 isLocal (@expr1073755517 ) &&@expr1073755518 !@expr1073755519 var@var3318 .@expr13696 isArgument (@expr13697 ) ) ||@expr1073755522 (@expr1073755523 deref@var3319 &&@expr1073755524 var@var3318 .@expr13696 isArgument (@expr13697 ) &&@expr1073755527 var@var3318 .@expr1073755528 isPointer (@expr1073755529 ) ) ||@expr1073755530
2791: var@var3318 .@expr1073755531 isStatic (@expr1073755532 ) ||@expr1073755533 var@var3318 .@expr1073755534 isReference (@expr1073755535 ) ||@expr1073755536 var@var3318 .@expr1073755537 isExtern (@expr1073755538 ) ;
2792: }
2793:
2794: void setupExprVarIds ( const Token * start@var3320 , int depth@var3321 = 0 ) {
2795: const int maxDepth@var3322 =@expr1073755539 4 ;
2796: if (@expr1073755540 depth@var3321 >@expr1073755541 maxDepth@var3322 ) {
2797: return ; }
2798: visitAstNodes (@expr1073755542 start@var3320 , [@expr1073755543 &@expr13720 ] (@expr1073755545 const Token *@expr1073755546 tok@var3323 ) {
2799: const bool top@var3324 =@expr1073755547 depth@var3321 ==@expr13724 0 &&@expr1073755549 tok@var3323 ==@expr1073755550 start@var3320 ;
2800: const bool ispointer@var3325 =@expr1073755551 astIsPointer (@expr1073755552 tok@var3323 ) ||@expr1073755553 astIsSmartPointer (@expr1073755554 tok@var3323 ) ||@expr1073755555 astIsIterator (@expr1073755556 tok@var3323 ) ;
2801: if (@expr1073755557 !@expr1073755558 top@var3324 ||@expr1073755559 !@expr1073755560 ispointer@var3325 ||@expr1073755561 value@var3280 .@expr1073755562 indirect@var5305 !=@expr1073755563 0 ) {
2802: for (@expr1073755564 const ValueFlow ::@expr1073755565 Value &@expr13720 v@var3326 :@expr1073755567 tok@var3323 .@expr1073755568 values (@expr1073755569 ) ) {
2803: if (@expr1073755570 !@expr1073755571 (@expr1073755572 v@var3326 .@expr1073755573 isLocalLifetimeValue (@expr1073755574 ) ||@expr1073755575 (@expr1073755576 ispointer@var3325 &&@expr1073755577 v@var3326 .@expr1073755578 isSymbolicValue (@expr1073755579 ) &&@expr1073755580 v@var3326 .@expr1073755581 isKnown (@expr1073755582 ) ) ) ) {
2804: continue ; }
2805: if (@expr1073755583 !@expr1073755584 v@var3326 .@expr13761 tokvalue@var3327 ) {
2806: continue ; }
2807: if (@expr1073755586 v@var3326 .@expr13761 tokvalue@var3327 ==@expr1073755588 tok@var3323 ) {
2808: continue ; }
2809: setupExprVarIds (@expr1073755589 v@var3326 .@expr13761 tokvalue@var3327 , depth@var3321 +@expr1073755591 1 ) ;
2810: }
2811: }
2812: if (@expr1073755592 depth@var3321 ==@expr13724 0 &&@expr1073755594 tok@var3323 .@expr1073755595 isIncompleteVar (@expr1073755596 ) ) {
2813:
2814:
2815:
2816: unknown@var3312 =@expr1073755597 true ;
2817: return ChildrenToVisit ::@expr13774 none ;
2818: }
2819: if (@expr1073755599 tok@var3323 .@expr13776 varId (@expr13777 ) >@expr1073755602 0 ) {
2820: varids@var3278 [@expr1073755603 tok@var3323 .@expr13776 varId (@expr13777 ) ] =@expr1073755606 tok@var3323 .@expr13783 variable (@expr13784 ) ;
2821: if (@expr1073755609 !@expr1073755610 Token ::@expr1073755611 simpleMatch (@expr1073755612 tok@var3323 .@expr1073755613 previous (@expr1073755614 ) , "." ) ) {
2822: const Variable * var@var3328 ; var@var3328 =@expr1073755615 tok@var3323 .@expr13783 variable (@expr13784 ) ;
2823: if (@expr1073755618 var@var3328 &&@expr1073755619 var@var3328 .@expr1073755620 isReference (@expr1073755621 ) &&@expr1073755622 var@var3328 .@expr1073755623 isLocal (@expr1073755624 ) &&@expr1073755625 Token ::@expr1073755626 Match (@expr1073755627 var@var3328 .@expr13804 nameToken (@expr13805 ) , "%var% [=(]" ) &&@expr1073755630
2824: !@expr1073755631 isGlobalData (@expr1073755632 var@var3328 .@expr13804 nameToken (@expr13805 ) .@expr1073755635 next (@expr1073755636 ) .@expr1073755637 astOperand2 (@expr1073755638 ) , isCPP (@expr1073755639 ) ) ) {
2825: return ChildrenToVisit ::@expr13774 none ; }
2826: const bool deref@var3329 =@expr1073755641 tok@var3323 .@expr13818 astParent (@expr13819 ) &&@expr1073755644
2827: (@expr1073755645 tok@var3323 .@expr13818 astParent (@expr13819 ) .@expr1073755648 isUnaryOp (@expr1073755649 "*" ) ||@expr1073755650
2828: (@expr1073755651 tok@var3323 .@expr13818 astParent (@expr13819 ) .@expr1073755654 str (@expr1073755655 ) ==@expr1073755656 "[" &&@expr1073755657 tok@var3323 ==@expr1073755658 tok@var3323 .@expr13818 astParent (@expr13819 ) .@expr1073755661 astOperand1 (@expr1073755662 ) ) ) ;
2829: local@var3311 &=@expr1073755663 !@expr1073755664 nonLocal (@expr1073755665 tok@var3323 .@expr13783 variable (@expr13784 ) , deref@var3329 ) ;
2830: }
2831: }
2832: return ChildrenToVisit ::@expr1073755668 op1_and_op2 ;
2833: } ) ;
2834: }
2835:
2836: virtual bool invalid ( ) const override {
2837: return unknown@var3312 ;
2838: }
2839:
2840: virtual std :: unordered_map < ExprIdToken , ValueFlow :: Value , ExprIdToken :: Hash > getProgramState ( ) const override {
2841: ProgramState ps@var3330 ;
2842: ps@var3330 [@expr1073755669 expr@var3310 ] =@expr1073755670 value@var3280 ;
2843: return ps@var3330 ;
2844: }
2845:
2846: virtual bool match ( const Token * tok@var3331 ) const override {
2847: return tok@var3331 .@expr1073755671 exprId (@expr1073755672 ) ==@expr1073755673 expr@var3310 .@expr1073755674 exprId (@expr1073755675 ) ;
2848: }
2849:
2850: virtual bool dependsOnThis ( ) const override {
2851: return dependOnThis@var3313 ;
2852: }
2853:
2854: virtual bool isGlobal ( ) const override {
2855: return !@expr1073755676 local@var3311 ;
2856: }
2857:
2858: virtual bool isVariable ( ) const override {
2859: return expr@var3310 .@expr1073755677 varId (@expr1073755678 ) >@expr1073755679 0 ;
2860: }
2861: } ;
2862:
2863: struct OppositeExpressionAnalyzer : ExpressionAnalyzer {
2864: bool isNot@var3332 ;
2865:
2866: OppositeExpressionAnalyzer ( ) : ExpressionAnalyzer ( ) , isNot@var3332 ( false ) { }
2867:
2868: OppositeExpressionAnalyzer ( bool pIsNot@var3333 , const Token * e@var3334 , const ValueFlow :: Value & val@var3335 , const TokenList * t@var3336 )
2869: : ExpressionAnalyzer ( e@var3334 , val@var3335 , t@var3336 ) , isNot@var3332 ( pIsNot@var3333 )
2870: { }
2871:
2872: virtual bool match ( const Token * tok@var3337 ) const override {
2873: return isOppositeCond (@expr1073755680 isNot@var3332 , isCPP (@expr1073755681 ) , expr@var3310 , tok@var3337 , getSettings (@expr1073755682 ) .@expr1073755683 library@var5315 , true , true ) ;
2874: }
2875: } ;
2876:
2877: struct SubExpressionAnalyzer : ExpressionAnalyzer {
2878:
2879:
2880: std :: shared_ptr < std :: vector < std :: pair < Token * , ValueFlow :: Value > > > partialReads@var3338 ;
2881: SubExpressionAnalyzer ( ) : ExpressionAnalyzer ( ) , partialReads@var3338 ( nullptr ) { }
2882:
2883: SubExpressionAnalyzer ( const Token * e@var3339 , const ValueFlow :: Value & val@var3340 , const TokenList * t@var3341 )
2884: : ExpressionAnalyzer ( e@var3339 , val@var3340 , t@var3341 ) , partialReads@var3338 ( std :: make_shared < std :: vector < std :: pair < Token * , ValueFlow :: Value > > > ( ) )
2885: { }
2886:
2887: virtual bool submatch ( const Token * tok@var3342 , bool exact@var3343 = true ) const = 0 ;
2888:
2889: virtual bool isAlias ( const Token * tok@var3344 , bool & inconclusive@var3345 ) const override
2890: {
2891: if (@expr1073755684 tok@var3344 .@expr1073755685 exprId (@expr1073755686 ) ==@expr1073755687 expr@var3310 .@expr1073755688 exprId (@expr1073755689 ) &&@expr1073755690 tok@var3344 .@expr13867 astParent (@expr13868 ) &&@expr1073755693 submatch (@expr1073755694 tok@var3344 .@expr13867 astParent (@expr13868 ) , false ) ) {
2892: return false ; }
2893: return ExpressionAnalyzer ::@expr1073755697 isAlias (@expr1073755698 tok@var3344 , inconclusive@var3345 ) ;
2894: }
2895:
2896: virtual bool match ( const Token * tok@var3346 ) const override
2897: {
2898: return tok@var3346 .@expr13875 astOperand1 (@expr13876 ) &&@expr1073755701 tok@var3346 .@expr13875 astOperand1 (@expr13876 ) .@expr1073755704 exprId (@expr1073755705 ) ==@expr1073755706 expr@var3310 .@expr1073755707 exprId (@expr1073755708 ) &&@expr1073755709 submatch (@expr1073755710 tok@var3346 ) ;
2899: }
2900: virtual bool internalMatch ( const Token * tok@var3347 ) const override
2901: {
2902: return tok@var3347 .@expr1073755711 exprId (@expr1073755712 ) ==@expr1073755713 expr@var3310 .@expr1073755714 exprId (@expr1073755715 ) &&@expr1073755716 !@expr1073755717 (@expr1073755718 astIsLHS (@expr1073755719 tok@var3347 ) &&@expr1073755720 submatch (@expr1073755721 tok@var3347 .@expr1073755722 astParent (@expr1073755723 ) , false ) ) ;
2903: }
2904: virtual void internalUpdate ( Token * tok@var3348 , const ValueFlow :: Value & v@var3349 , Direction ) override
2905: {
2906: partialReads@var3338 .@expr1073755724 push_back (@expr1073755725 std ::@expr1073755726 make_pair (@expr1073755727 tok@var3348 , v@var3349 ) ) ;
2907: }
2908:
2909:
2910: virtual ValuePtr<Analyzer> reanalyze ( Token * , const std :: string & ) const override {
2911: return { } ;
2912: }
2913: } ;
2914:
2915: struct MemberExpressionAnalyzer : SubExpressionAnalyzer {
2916: std :: string varname@var3350 ;
2917: MemberExpressionAnalyzer ( ) : SubExpressionAnalyzer ( ) , varname@var3350 ( ) { }
2918:
2919: MemberExpressionAnalyzer ( std :: string varname@var3351 , const Token * e@var3352 , const ValueFlow :: Value & val@var3353 , const TokenList * t@var3354 )
2920: : SubExpressionAnalyzer ( e@var3352 , val@var3353 , t@var3354 ) , varname@var3350 ( std :: move ( varname@var3351 ) )
2921: { }
2922:
2923: virtual bool submatch ( const Token * tok@var3355 , bool exact@var3356 ) const override
2924: {
2925: if (@expr1073755728 !@expr1073755729 Token ::@expr1073755730 Match (@expr1073755731 tok@var3355 , ". %var%" ) ) {
2926: return false ; }
2927: if (@expr1073755732 !@expr1073755733 exact@var3356 ) {
2928: return true ; }
2929: return tok@var3355 .@expr1073755734 next (@expr1073755735 ) .@expr1073755736 str (@expr1073755737 ) ==@expr1073755738 varname@var3350 ;
2930: }
2931: } ;
2932:
2933: static Analyzer :: Result valueFlowForwardExpression ( Token * startToken@var3357 ,
2934: const Token * endToken@var3358 ,
2935: const Token * exprTok@var3359 ,
2936: const std :: list < ValueFlow :: Value > & values@var3360 ,
2937: const TokenList * const tokenlist@var3361 ,
2938: const Settings * settings@var3362 )
2939: {
2940: Analyzer ::@expr13915 Result result@var3363 {@expr1073755740 } ;
2941: for (@expr1073755741 const ValueFlow ::@expr13915 Value &@expr1073755743 v@var3364 :@expr1073755744 values@var3360 ) {
2942: ExpressionAnalyzer a@var3365 (@expr1073755745 exprTok@var3359 , v@var3364 , tokenlist@var3361 ) ;
2943: result@var3363 .@expr1073755746 update (@expr1073755747 valueFlowGenericForward (@expr1073755748 startToken@var3357 , endToken@var3358 , a@var3365 , settings@var3362 ) ) ;
2944: }
2945: return result@var3363 ;
2946: }
2947:
2948: static const Token * parseBinaryIntOp ( const Token * expr@var3366 ,
2949: const std :: function < std :: vector < long long > ( const Token * ) > & eval@var3367 ,
2950: long long & known@var3368 )
2951: {
2952: if (@expr1073755749 !@expr1073755750 expr@var3366 ) {
2953: return nullptr ; }
2954: if (@expr1073755751 !@expr1073755752 expr@var3366 .@expr13929 astOperand1 (@expr13930 ) ||@expr1073755755 !@expr1073755756 expr@var3366 .@expr13933 astOperand2 (@expr13934 ) ) {
2955: return nullptr ; }
2956: if (@expr1073755759 expr@var3366 .@expr13929 astOperand1 (@expr13930 ) .@expr13938 exprId (@expr13939 ) ==@expr13940 0 &&@expr1073755765 expr@var3366 .@expr13933 astOperand2 (@expr13934 ) .@expr13944 exprId (@expr13945 ) ==@expr13946 0 ) {
2957: return nullptr ; }
2958: std ::@expr1073755771 vector < long long > x1@var3369 ; x1@var3369 =@expr1073755772 eval@var3367 (@expr1073755773 expr@var3366 .@expr13929 astOperand1 (@expr13930 ) ) ;
2959: std ::@expr1073755776 vector < long long > x2@var3370 ; x2@var3370 =@expr1073755777 eval@var3367 (@expr1073755778 expr@var3366 .@expr13933 astOperand2 (@expr13934 ) ) ;
2960: if (@expr1073755781 expr@var3366 .@expr13929 astOperand1 (@expr13930 ) .@expr13938 exprId (@expr13939 ) ==@expr13940 0 &&@expr1073755787 x1@var3369 .@expr13964 empty (@expr13965 ) ) {
2961: return nullptr ; }
2962: if (@expr1073755790 expr@var3366 .@expr13933 astOperand2 (@expr13934 ) .@expr13944 exprId (@expr13945 ) ==@expr13946 0 &&@expr1073755796 x2@var3370 .@expr13973 empty (@expr13974 ) ) {
2963: return nullptr ; }
2964: const Token * varTok@var3371 ; varTok@var3371 =@expr1073755799 nullptr ;
2965: if (@expr1073755800 !@expr1073755801 x1@var3369 .@expr13964 empty (@expr13965 ) &&@expr1073755804 x2@var3370 .@expr13973 empty (@expr13974 ) ) {
2966: varTok@var3371 =@expr1073755807 expr@var3366 .@expr13933 astOperand2 (@expr13934 ) ;
2967: known@var3368 =@expr1073755810 x1@var3369 .@expr1073755811 front (@expr1073755812 ) ;
2968: } else { if (@expr1073755813 x1@var3369 .@expr13964 empty (@expr13965 ) &&@expr1073755816 !@expr1073755817 x2@var3370 .@expr13973 empty (@expr13974 ) ) {
2969: varTok@var3371 =@expr1073755820 expr@var3366 .@expr13929 astOperand1 (@expr13930 ) ;
2970: known@var3368 =@expr1073755823 x2@var3370 .@expr1073755824 front (@expr1073755825 ) ;
2971: } }
2972: return varTok@var3371 ;
2973: }
2974:
2975: const Token * solveExprValue ( const Token * expr@var3372 ,
2976: const std :: function < std :: vector < long long > ( const Token * ) > & eval@var3373 ,
2977: ValueFlow :: Value & value@var3374 )
2978: {
2979: if (@expr1073755826 !@expr1073755827 value@var3374 .@expr1073755828 isIntValue (@expr1073755829 ) &&@expr1073755830 !@expr1073755831 value@var3374 .@expr1073755832 isIteratorValue (@expr1073755833 ) &&@expr1073755834 !@expr1073755835 value@var3374 .@expr14012 isSymbolicValue (@expr14013 ) ) {
2980: return expr@var3372 ; }
2981: if (@expr1073755838 value@var3374 .@expr14012 isSymbolicValue (@expr14013 ) &&@expr1073755841 !@expr1073755842 Token ::@expr1073755843 Match (@expr1073755844 expr@var3372 , "+|-" ) ) {
2982: return expr@var3372 ; }
2983: long long intval@var3375 ;
2984: const Token * binaryTok@var3376 ; binaryTok@var3376 =@expr1073755845 parseBinaryIntOp (@expr1073755846 expr@var3372 , eval@var3373 , intval@var3375 ) ;
2985: bool rhs@var3377 ; rhs@var3377 =@expr1073755847 astIsRHS (@expr1073755848 binaryTok@var3376 ) ;
2986:
2987: if (@expr1073755849 value@var3374 .@expr14012 isSymbolicValue (@expr14013 ) &&@expr1073755852 rhs@var3377 &&@expr1073755853 Token ::@expr1073755854 simpleMatch (@expr1073755855 expr@var3372 , "-" ) ) {
2988: return expr@var3372 ; }
2989: if (@expr1073755856 binaryTok@var3376 &&@expr1073755857 expr@var3372 .@expr14034 str (@expr14035 ) .@expr1073755860 size (@expr1073755861 ) ==@expr1073755862 1 ) {
2990: switch (@expr1073755863 expr@var3372 .@expr14034 str (@expr14035 ) [@expr1073755866 0 ] ) {
2991: case '+' :@expr14043 ; {
2992: value@var3374 .@expr14044 intvalue@var3378 -=@expr1073755869 intval@var3375 ;
2993: return solveExprValue (@expr14046 binaryTok@var3376 , eval@var3373 , value@var3374 ) ;
2994: }
2995: case '-' :@expr14043 ; {
2996: if (@expr1073755872 rhs@var3377 ) {
2997: value@var3374 .@expr14044 intvalue@var3378 =@expr1073755874 intval@var3375 -@expr1073755875 value@var3374 .@expr14044 intvalue@var3378 ; }
2998: else {
2999: value@var3374 .@expr14044 intvalue@var3378 +=@expr1073755878 intval@var3375 ; }
3000: return solveExprValue (@expr14046 binaryTok@var3376 , eval@var3373 , value@var3374 ) ;
3001: }
3002: case '*' :@expr14043 ; {
3003: if (@expr1073755881 intval@var3375 ==@expr1073755882 0 ) {
3004: break ; }
3005: value@var3374 .@expr14044 intvalue@var3378 /=@expr1073755884 intval@var3375 ;
3006: return solveExprValue (@expr14046 binaryTok@var3376 , eval@var3373 , value@var3374 ) ;
3007: }
3008: case '^' :@expr14043 ; {
3009: value@var3374 .@expr14044 intvalue@var3378 ^=@expr1073755888 intval@var3375 ;
3010: return solveExprValue (@expr14046 binaryTok@var3376 , eval@var3373 , value@var3374 ) ;
3011: }
3012: }
3013: }
3014: return expr@var3372 ;
3015: }
3016:
3017: static const Token * solveExprValue ( const Token * expr@var3379 , ValueFlow :: Value & value@var3380 )
3018: {
3019: return solveExprValue (@expr1073755891
3020: expr@var3379 ,
3021: [@expr1073755892 ] (@expr1073755893 const Token *@expr1073755894 tok@var3381 ) .@expr1073755895 std ::@expr1073755896 vector < long long > {
3022: if (@expr1073755897 tok@var3381 .@expr1073755898 hasKnownIntValue (@expr1073755899 ) ) {
3023: return {@expr1073755900 tok@var3381 .@expr1073755901 values (@expr1073755902 ) .@expr1073755903 front (@expr1073755904 ) .@expr1073755905 intvalue@expr1073755890 } ; }
3024: return { } ;
3025: } ,
3026: value@var3380 ) ;
3027: }
3028:
3029: ValuePtr<Analyzer> makeAnalyzer ( const Token * exprTok@var3382 , ValueFlow :: Value value@var3383 , const TokenList * tokenlist@var3384 )
3030: {
3031: const Token * expr@var3385 ; expr@var3385 =@expr1073755906 solveExprValue (@expr1073755907 exprTok@var3382 , value@var3383 ) ;
3032: return ExpressionAnalyzer (@expr1073755908 expr@var3385 , value@var3383 , tokenlist@var3384 ) ;
3033: }
3034:
3035: static Analyzer :: Result valueFlowForward ( Token * startToken@var3386 ,
3036: const Token * endToken@var3387 ,
3037: const Token * exprTok@var3388 ,
3038: const std :: list < ValueFlow :: Value > & values@var3389 ,
3039: TokenList * const tokenlist@var3390 ,
3040: const Settings * settings@var3391 )
3041: {
3042: Analyzer ::@expr14085 Result result@var3392 {@expr1073755910 } ;
3043: for (@expr1073755911 const ValueFlow ::@expr14085 Value &@expr1073755913 v@var3393 :@expr1073755914 values@var3389 ) {
3044: result@var3392 .@expr1073755915 update (@expr1073755916 valueFlowGenericForward (@expr1073755917 startToken@var3386 , endToken@var3387 , makeAnalyzer (@expr1073755918 exprTok@var3388 , v@var3393 , tokenlist@var3390 ) , settings@var3391 ) ) ;
3045: }
3046: return result@var3392 ;
3047: }
3048:
3049: static Analyzer :: Result valueFlowForward ( Token * top@var3394 ,
3050: const Token * exprTok@var3395 ,
3051: const std :: list < ValueFlow :: Value > & values@var3396 ,
3052: TokenList * const tokenlist@var3397 ,
3053: const Settings * settings@var3398 )
3054: {
3055: Analyzer ::@expr14095 Result result@var3399 {@expr1073755920 } ;
3056: for (@expr1073755921 const ValueFlow ::@expr14095 Value &@expr1073755923 v@var3400 :@expr1073755924 values@var3396 ) {
3057: result@var3399 .@expr1073755925 update (@expr1073755926 valueFlowGenericForward (@expr1073755927 top@var3394 , makeAnalyzer (@expr1073755928 exprTok@var3395 , v@var3400 , tokenlist@var3397 ) , settings@var3398 ) ) ;
3058: }
3059: return result@var3399 ;
3060: }
3061:
3062: static void valueFlowReverse ( Token * tok@var3401 ,
3063: const Token * const endToken@var3402 ,
3064: const Token * const varToken@var3403 ,
3065: const std :: list < ValueFlow :: Value > & values@var3404 ,
3066: TokenList * tokenlist@var3405 ,
3067: const Settings * settings@var3406 )
3068: {
3069: for (@expr1073755929 const ValueFlow ::@expr1073755930 Value &@expr1073755931 v@var3407 :@expr1073755932 values@var3404 ) {
3070: ExpressionAnalyzer a@var3408 (@expr1073755933 varToken@var3403 , v@var3407 , tokenlist@var3405 ) ;
3071: valueFlowGenericReverse (@expr1073755934 tok@var3401 , endToken@var3402 , a@var3408 , settings@var3406 ) ;
3072: }
3073: }
3074:
3075: static void valueFlowReverse ( TokenList * tokenlist@var3409 ,
3076: Token * tok@var3410 ,
3077: const Token * const varToken@var3411 ,
3078: ValueFlow :: Value val@var3412 ,
3079: const ValueFlow :: Value & val2@var3413 ,
3080: ErrorLogger * ,
3081: const Settings * settings@var3414 )
3082: {
3083: std ::@expr1073755935 list < ValueFlow ::@expr1073755936 Value > values@var3415 ; values@var3415 =@expr1073755937 {@expr1073755938 val@var3412 } ;
3084: if (@expr1073755939 val2@var3413 .@expr1073755940 varId@var3416 !=@expr1073755941 0 ) {
3085: values@var3415 .@expr1073755942 push_back (@expr1073755943 val2@var3413 ) ; }
3086: valueFlowReverse (@expr1073755944 tok@var3410 , nullptr , varToken@var3411 , values@var3415 , tokenlist@var3409 , settings@var3414 ) ;
3087: }
3088:
3089: enum class LifetimeCapture { Undefined , ByValue , ByReference } ;
3090:
3091: std :: string lifetimeType ( const Token * tok@var3417 , const ValueFlow :: Value * val@var3418 )
3092: {
3093: std ::@expr1073755945 string result@var3419 ;
3094: if (@expr1073755946 !@expr1073755947 val@var3418 ) {
3095: return "object" ; }
3096: switch (@expr1073755948 val@var3418 .@expr1073755949 lifetimeKind@var3420 ) {
3097: case ValueFlow ::@expr14126 Value ::@expr14127 LifetimeKind ::@expr1073755952 Lambda :@expr14129 ;
3098: result@var3419 =@expr1073755954 "lambda" ;
3099: break ;
3100: case ValueFlow ::@expr14126 Value ::@expr14127 LifetimeKind ::@expr1073755957 Iterator :@expr14129 ;
3101: result@var3419 =@expr1073755959 "iterator" ;
3102: break ;
3103: case ValueFlow ::@expr14126 Value ::@expr14127 LifetimeKind ::@expr1073755962 Object :@expr14129
3104: case ValueFlow ::@expr14126 Value ::@expr14127 LifetimeKind ::@expr1073755966 SubObject :@expr14129
3105: case ValueFlow ::@expr14126 Value ::@expr14127 LifetimeKind ::@expr1073755970 Address :@expr14129 ;
3106: if (@expr1073755972 astIsPointer (@expr1073755973 tok@var3417 ) ) {
3107: result@var3419 =@expr1073755974 "pointer" ; }
3108: else {
3109: result@var3419 =@expr1073755975 "object" ; }
3110: break ;
3111: }
3112: return result@var3419 ;
3113: }
3114:
3115: std :: string lifetimeMessage ( const Token * tok@var3421 , const ValueFlow :: Value * val@var3422 , std :: list < std :: pair < const Token * , std :: string > > & errorPath@var3423 )
3116: {
3117: const Token * tokvalue@var3424 ; tokvalue@var3424 =@expr1073755976 val@var3422 ?@expr1073755977 val@var3422 .@expr1073755978 tokvalue@var3425 :@expr1073755979 nullptr ;
3118: const Variable * tokvar@var3426 ; tokvar@var3426 =@expr1073755980 tokvalue@var3424 ?@expr1073755981 tokvalue@var3424 .@expr1073755982 variable (@expr1073755983 ) :@expr1073755984 nullptr ;
3119: const Token * vartok@var3427 ; vartok@var3427 =@expr1073755985 tokvar@var3426 ?@expr1073755986 tokvar@var3426 .@expr1073755987 nameToken (@expr1073755988 ) :@expr1073755989 nullptr ;
3120: const bool classVar@var3428 =@expr1073755990 tokvar@var3426 ?@expr1073755991 (@expr1073755992 !@expr1073755993 tokvar@var3426 .@expr1073755994 isLocal (@expr1073755995 ) &&@expr1073755996 !@expr1073755997 tokvar@var3426 .@expr1073755998 isArgument (@expr1073755999 ) &&@expr1073756000 !@expr1073756001 tokvar@var3426 .@expr1073756002 isGlobal (@expr1073756003 ) ) :@expr1073756004 false ;
3121: std ::@expr1073756005 string type@var3429 ; type@var3429 =@expr1073756006 lifetimeType (@expr1073756007 tok@var3421 , val@var3422 ) ;
3122: std ::@expr1073756008 string msg@var3430 ; msg@var3430 =@expr1073756009 type@var3429 ;
3123: if (@expr1073756010 vartok@var3427 ) {
3124: if (@expr1073756011 !@expr1073756012 classVar@var3428 ) {
3125: errorPath@var3423 .@expr1073756013 emplace_back (@expr1073756014 vartok@var3427 , "Variable created here." ) ; }
3126: const Variable * var@var3431 ; var@var3431 =@expr1073756015 vartok@var3427 .@expr1073756016 variable (@expr1073756017 ) ;
3127: if (@expr1073756018 var@var3431 ) {
3128: std ::@expr1073756019 string submessage@var3432 ;
3129: switch (@expr1073756020 val@var3422 .@expr1073756021 lifetimeKind@var3433 ) {
3130: case ValueFlow ::@expr14198 Value ::@expr14199 LifetimeKind ::@expr1073756024 SubObject :@expr14201
3131: case ValueFlow ::@expr14198 Value ::@expr14199 LifetimeKind ::@expr1073756028 Object :@expr14201
3132: case ValueFlow ::@expr14198 Value ::@expr14199 LifetimeKind ::@expr1073756032 Address :@expr14201 ;
3133: if (@expr1073756034 type@var3429 ==@expr1073756035 "pointer" ) {
3134: submessage@var3432 =@expr1073756036 " to local variable" ; }
3135: else {
3136: submessage@var3432 =@expr1073756037 " that points to local variable" ; }
3137: break ;
3138: case ValueFlow ::@expr14198 Value ::@expr14199 LifetimeKind ::@expr1073756040 Lambda :@expr14201 ;
3139: submessage@var3432 =@expr1073756042 " that captures local variable" ;
3140: break ;
3141: case ValueFlow ::@expr14198 Value ::@expr14199 LifetimeKind ::@expr1073756045 Iterator :@expr14201 ;
3142: submessage@var3432 =@expr1073756047 " to local container" ;
3143: break ;
3144: }
3145: if (@expr1073756048 classVar@var3428 ) {
3146: submessage@var3432 .@expr1073756049 replace (@expr1073756050 submessage@var3432 .@expr1073756051 find (@expr1073756052 "local" ) , 5 , "member" ) ; }
3147: msg@var3430 +=@expr1073756053 submessage@var3432 +@expr1073756054 " '" +@expr1073756055 var@var3431 .@expr1073756056 name (@expr1073756057 ) +@expr1073756058 "'" ;
3148: }
3149: }
3150: return msg@var3430 ;
3151: }
3152:
3153: std :: vector < ValueFlow :: Value > getLifetimeObjValues ( const Token * tok@var3434 , bool inconclusive@var3435 , long long path@var3436 )
3154: {
3155: std ::@expr1073756059 vector < ValueFlow ::@expr14236 Value > result@var3437 ;
3156: auto pred@var3438 ; pred@var3438 =@expr1073756061 [@expr1073756062 &@expr14239 ] (@expr1073756064 const ValueFlow ::@expr14236 Value &@expr14239 v@var3439 ) {
3157: if (@expr1073756067 !@expr1073756068 v@var3439 .@expr1073756069 isLocalLifetimeValue (@expr1073756070 ) &&@expr1073756071 !@expr1073756072 (@expr1073756073 path@var3436 !=@expr1073756074 0 &&@expr1073756075 v@var3439 .@expr1073756076 isSubFunctionLifetimeValue (@expr1073756077 ) ) ) {
3158: return false ; }
3159: if (@expr1073756078 !@expr1073756079 inconclusive@var3435 &&@expr1073756080 v@var3439 .@expr1073756081 isInconclusive (@expr1073756082 ) ) {
3160: return false ; }
3161: if (@expr1073756083 !@expr1073756084 v@var3439 .@expr1073756085 tokvalue@var3440 ) {
3162: return false ; }
3163: if (@expr1073756086 path@var3436 >=@expr1073756087 0 &&@expr1073756088 v@var3439 .@expr14265 path@var3441 !=@expr1073756090 0 &&@expr1073756091 v@var3439 .@expr14265 path@var3441 !=@expr1073756093 path@var3436 ) {
3164: return false ; }
3165: return true ;
3166: } ;
3167: std ::@expr1073756094 copy_if (@expr1073756095 tok@var3434 .@expr14272 values (@expr14273 ) .@expr1073756098 begin (@expr1073756099 ) , tok@var3434 .@expr14272 values (@expr14273 ) .@expr1073756102 end (@expr1073756103 ) , std ::@expr1073756104 back_inserter (@expr1073756105 result@var3437 ) , pred@var3438 ) ;
3168: return result@var3437 ;
3169: }
3170:
3171: ValueFlow :: Value getLifetimeObjValue ( const Token * tok@var3442 , bool inconclusive@var3443 )
3172: {
3173: std ::@expr1073756106 vector < ValueFlow ::@expr1073756107 Value > values@var3444 ; values@var3444 =@expr1073756108 getLifetimeObjValues (@expr1073756109 tok@var3442 , inconclusive@var3443 ) ;
3174:
3175: if (@expr1073756110 values@var3444 .@expr1073756111 size (@expr1073756112 ) !=@expr1073756113 1 ) {
3176: return ValueFlow ::@expr1073756114 Value {@expr1073756115 } ; }
3177: return values@var3444 .@expr1073756116 front (@expr1073756117 ) ;
3178: }
3179:
3180: template < class Predicate >
3181: static std :: vector < LifetimeToken > getLifetimeTokens ( const Token * tok@var3445 ,
3182: bool escape@var3446 ,
3183: ValueFlow :: Value :: ErrorPath errorPath@var3447 ,
3184: Predicate pred@var3448 ,
3185: int depth@var3449 = 20 )
3186: {
3187: if (@expr1073756118 !@expr1073756119 tok@var3445 ) {
3188: return std ::@expr14296 vector < LifetimeToken > {@expr1073756121 } ; }
3189: if (@expr1073756122 Token ::@expr14299 simpleMatch (@expr1073756124 tok@var3445 , "..." ) ) {
3190: return std ::@expr14296 vector < LifetimeToken > {@expr1073756126 } ; }
3191: const Variable * var@var3450 ; var@var3450 =@expr1073756127 tok@var3445 .@expr1073756128 variable (@expr1073756129 ) ;
3192: if (@expr1073756130 pred@var3448 (@expr1073756131 tok@var3445 ) ) {
3193: return {@expr1073756132 tok@var3445 , std ::@expr14309 move (@expr14310 errorPath@var3447 ) } ; }
3194: if (@expr1073756135 depth@var3449 <@expr1073756136 0 ) {
3195: return {@expr1073756137 tok@var3445 , std ::@expr14309 move (@expr14310 errorPath@var3447 ) } ; }
3196: if (@expr1073756140 var@var3450 &&@expr1073756141 var@var3450 .@expr1073756142 declarationId (@expr1073756143 ) ==@expr1073756144 tok@var3445 .@expr1073756145 varId (@expr1073756146 ) ) {
3197: if (@expr1073756147 var@var3450 .@expr1073756148 isReference (@expr1073756149 ) ||@expr1073756150 var@var3450 .@expr14327 isRValueReference (@expr14328 ) ) {
3198: if (@expr1073756153 !@expr1073756154 var@var3450 .@expr14331 declEndToken (@expr14332 ) ) {
3199: return {@expr1073756157 tok@var3445 , true , std ::@expr14309 move (@expr14310 errorPath@var3447 ) } ; }
3200: if (@expr1073756160 var@var3450 .@expr1073756161 isArgument (@expr1073756162 ) ) {
3201: errorPath@var3447 .@expr14339 emplace_back (@expr1073756164 var@var3450 .@expr14331 declEndToken (@expr14332 ) , "Passed to reference." ) ;
3202: return {@expr1073756167 tok@var3445 , true , std ::@expr14309 move (@expr14310 errorPath@var3447 ) } ;
3203: } else { if (@expr1073756170 Token ::@expr14299 simpleMatch (@expr1073756172 var@var3450 .@expr14331 declEndToken (@expr14332 ) , "=" ) ) {
3204: errorPath@var3447 .@expr14339 emplace_back (@expr1073756176 var@var3450 .@expr14331 declEndToken (@expr14332 ) , "Assigned to reference." ) ;
3205: const Token * vartok@var3451 ; vartok@var3451 =@expr1073756179 var@var3450 .@expr14331 declEndToken (@expr14332 ) .@expr1073756182 astOperand2 (@expr1073756183 ) ;
3206: const bool temporary@var3452 =@expr1073756184 isTemporary (@expr1073756185 true , vartok@var3451 , nullptr , true ) ;
3207: const bool nonlocal@var3453 =@expr1073756186 var@var3450 .@expr1073756187 isStatic (@expr1073756188 ) ||@expr1073756189 var@var3450 .@expr1073756190 isGlobal (@expr1073756191 ) ;
3208: if (@expr1073756192 vartok@var3451 ==@expr1073756193 tok@var3445 ||@expr1073756194 (@expr1073756195 nonlocal@var3453 &&@expr1073756196 temporary@var3452 ) ||@expr1073756197
3209: (@expr1073756198 !@expr1073756199 escape@var3446 &&@expr1073756200 (@expr1073756201 var@var3450 .@expr1073756202 isConst (@expr1073756203 ) ||@expr1073756204 var@var3450 .@expr14327 isRValueReference (@expr14328 ) ) &&@expr1073756207 temporary@var3452 ) ) {
3210: return {@expr1073756208 tok@var3445 , true , std ::@expr14309 move (@expr14310 errorPath@var3447 ) } ; }
3211: if (@expr1073756211 vartok@var3451 ) {
3212: return getLifetimeTokens (@expr1073756212 vartok@var3451 , escape@var3446 , std ::@expr14309 move (@expr14310 errorPath@var3447 ) , pred@var3448 , depth@var3449 -@expr14391 1 ) ; }
3213: } else { if (@expr1073756216 Token ::@expr14299 simpleMatch (@expr1073756218 var@var3450 .@expr14395 nameToken (@expr14396 ) .@expr14397 astParent (@expr14398 ) , ":" ) &&@expr1073756223
3214: var@var3450 .@expr14395 nameToken (@expr14396 ) .@expr14397 astParent (@expr14398 ) .@expr14404 astParent (@expr14405 ) &&@expr1073756230
3215: Token ::@expr14299 simpleMatch (@expr1073756232 var@var3450 .@expr14395 nameToken (@expr14396 ) .@expr14397 astParent (@expr14398 ) .@expr14404 astParent (@expr14405 ) .@expr1073756239 previous (@expr1073756240 ) , "for (" ) ) {
3216: errorPath@var3447 .@expr14339 emplace_back (@expr1073756242 var@var3450 .@expr14395 nameToken (@expr14396 ) , "Assigned to reference." ) ;
3217: const Token * vartok@var3454 ; vartok@var3454 =@expr1073756245 var@var3450 .@expr14395 nameToken (@expr14396 ) ;
3218: if (@expr1073756248 vartok@var3454 ==@expr1073756249 tok@var3445 ) {
3219: return {@expr1073756250 tok@var3445 , true , std ::@expr14309 move (@expr14310 errorPath@var3447 ) } ; }
3220: const Token * contok@var3455 ; contok@var3455 =@expr1073756253 var@var3450 .@expr14395 nameToken (@expr14396 ) .@expr14397 astParent (@expr14398 ) .@expr1073756258 astOperand2 (@expr1073756259 ) ;
3221: if (@expr1073756260 astIsContainer (@expr1073756261 contok@var3455 ) ) {
3222: return getLifetimeTokens (@expr1073756262 contok@var3455 , escape@var3446 , std ::@expr14309 move (@expr14310 errorPath@var3447 ) , pred@var3448 , depth@var3449 -@expr14391 1 ) ; }
3223: else {
3224: return std ::@expr14296 vector < LifetimeToken > {@expr1073756267 } ; }
3225: } else {
3226: return std ::@expr14296 vector < LifetimeToken > {@expr1073756269 } ;
3227: } } }
3228: }
3229: } else { if (@expr1073756270 Token ::@expr14447 Match (@expr1073756272 tok@var3445 .@expr14449 previous (@expr14450 ) , "%name% (" ) ) {
3230: const Function * f@var3456 ; f@var3456 =@expr1073756275 tok@var3445 .@expr14449 previous (@expr14450 ) .@expr1073756278 function (@expr1073756279 ) ;
3231: if (@expr1073756280 f@var3456 ) {
3232: if (@expr1073756281 !@expr1073756282 Function ::@expr1073756283 returnsReference (@expr1073756284 f@var3456 ) ) {
3233: return {@expr1073756285 tok@var3445 , std ::@expr14309 move (@expr14310 errorPath@var3447 ) } ; }
3234: std ::@expr1073756288 vector < LifetimeToken > result@var3457 ;
3235: std ::@expr1073756289 vector < const Token *@expr14466 > returns@var3458 ; returns@var3458 =@expr1073756291 Function ::@expr1073756292 findReturns (@expr1073756293 f@var3456 ) ;
3236: for (@expr1073756294 const Token *@expr14466 returnTok@var3459 :@expr1073756296 returns@var3458 ) {
3237: if (@expr1073756297 returnTok@var3459 ==@expr1073756298 tok@var3445 ) {
3238: continue ; }
3239: for (@expr1073756299 LifetimeToken &@expr14476 lt@var3460 :@expr1073756301 getLifetimeTokens (@expr1073756302 returnTok@var3459 , escape@var3446 , errorPath@var3447 , pred@var3448 , depth@var3449 -@expr14479 returns@var3458 .@expr14480 size (@expr14481 ) ) ) {
3240: const Token * argvarTok@var3461 ; argvarTok@var3461 =@expr1073756306 lt@var3460 .@expr1073756307 token@var3462 ;
3241: const Variable * argvar@var3463 ; argvar@var3463 =@expr1073756308 argvarTok@var3461 .@expr1073756309 variable (@expr1073756310 ) ;
3242: if (@expr1073756311 !@expr1073756312 argvar@var3463 ) {
3243: continue ; }
3244: if (@expr1073756313 argvar@var3463 .@expr1073756314 isArgument (@expr1073756315 ) &&@expr1073756316 (@expr1073756317 argvar@var3463 .@expr1073756318 isReference (@expr1073756319 ) ||@expr1073756320 argvar@var3463 .@expr1073756321 isRValueReference (@expr1073756322 ) ) ) {
3245: int n@var3464 ; n@var3464 =@expr1073756323 getArgumentPos (@expr1073756324 argvar@var3463 , f@var3456 ) ;
3246: if (@expr1073756325 n@var3464 <@expr1073756326 0 ) {
3247: return std ::@expr14296 vector < LifetimeToken > {@expr1073756328 } ; }
3248: std ::@expr1073756329 vector < const Token *@expr14466 > args@var3465 ; args@var3465 =@expr1073756331 getArguments (@expr1073756332 tok@var3445 .@expr14449 previous (@expr14450 ) ) ;
3249:
3250: if (@expr1073756335 n@var3464 >=@expr1073756336 args@var3465 .@expr1073756337 size (@expr1073756338 ) ) {
3251: return std ::@expr14296 vector < LifetimeToken > {@expr1073756340 } ; }
3252: const Token * argTok@var3466 ; argTok@var3466 =@expr1073756341 args@var3465 [@expr1073756342 n@var3464 ] ;
3253: lt@var3460 .@expr14519 errorPath@var3467 .@expr14520 emplace_back (@expr1073756345 returnTok@var3459 , "Return reference." ) ;
3254: lt@var3460 .@expr14519 errorPath@var3467 .@expr14520 emplace_back (@expr1073756348 tok@var3445 .@expr14449 previous (@expr14450 ) , "Called function passing '" +@expr1073756351 argTok@var3466 .@expr1073756352 expressionString (@expr1073756353 ) +@expr1073756354 "'." ) ;
3255: std ::@expr1073756355 vector < LifetimeToken > arglts@var3468 ; arglts@var3468 =@expr1073756356 LifetimeToken ::@expr1073756357 setInconclusive (@expr1073756358
3256: getLifetimeTokens (@expr1073756359 argTok@var3466 , escape@var3446 , std ::@expr14309 move (@expr1073756361 lt@var3460 .@expr14519 errorPath@var3467 ) , pred@var3448 , depth@var3449 -@expr14479 returns@var3458 .@expr14480 size (@expr14481 ) ) ,
3257: returns@var3458 .@expr14480 size (@expr14481 ) >@expr1073756368 1 ) ;
3258: result@var3457 .@expr1073756369 insert (@expr1073756370 result@var3457 .@expr1073756371 end (@expr1073756372 ) , arglts@var3468 .@expr1073756373 begin (@expr1073756374 ) , arglts@var3468 .@expr1073756375 end (@expr1073756376 ) ) ;
3259: }
3260: }
3261: }
3262: return result@var3457 ;
3263: } else { if (@expr1073756377 Token ::@expr14447 Match (@expr1073756379 tok@var3445 .@expr14556 tokAt (@expr14557 -2 ) , ". %name% (" ) &&@expr1073756382 tok@var3445 .@expr14556 tokAt (@expr14557 -2 ) .@expr1073756385 originalName (@expr1073756386 ) !=@expr1073756387 "->" &&@expr1073756388 astIsContainer (@expr1073756389 tok@var3445 .@expr14556 tokAt (@expr14557 -2 ) .@expr14568 astOperand1 (@expr14569 ) ) ) {
3264: const Library ::@expr14570 Container * library@var3469 ; library@var3469 =@expr1073756395 getLibraryContainer (@expr1073756396 tok@var3445 .@expr14556 tokAt (@expr14557 -2 ) .@expr14568 astOperand1 (@expr14569 ) ) ;
3265: Library ::@expr14570 Container ::@expr1073756402 Yield y@var3470 ; y@var3470 =@expr1073756403 library@var3469 .@expr1073756404 getYield (@expr1073756405 tok@var3445 .@expr14449 previous (@expr14450 ) .@expr1073756408 str (@expr1073756409 ) ) ;
3266: if (@expr1073756410 y@var3470 ==@expr1073756411 Library ::@expr14570 Container ::@expr14589 Yield ::@expr1073756414 AT_INDEX ||@expr1073756415 y@var3470 ==@expr1073756416 Library ::@expr14570 Container ::@expr14589 Yield ::@expr1073756419 ITEM ) {
3267: errorPath@var3447 .@expr14339 emplace_back (@expr1073756421 tok@var3445 .@expr14449 previous (@expr14450 ) , "Accessing container." ) ;
3268: return LifetimeToken ::@expr14600 setAddressOf (@expr1073756425
3269: getLifetimeTokens (@expr1073756426 tok@var3445 .@expr14556 tokAt (@expr14557 -2 ) .@expr14568 astOperand1 (@expr14569 ) , escape@var3446 , std ::@expr14309 move (@expr14310 errorPath@var3447 ) , pred@var3448 , depth@var3449 -@expr14391 1 ) ,
3270: false ) ;
3271: }
3272: } }
3273: } else { if (@expr1073756434 Token ::@expr14447 Match (@expr1073756436 tok@var3445 , ".|::|[" ) ||@expr1073756437 tok@var3445 .@expr14614 isUnaryOp (@expr14615 "*" ) ) {
3274:
3275: const Token * vartok@var3471 ; vartok@var3471 =@expr1073756440 tok@var3445 ;
3276: if (@expr1073756441 tok@var3445 .@expr14614 isUnaryOp (@expr14615 "*" ) ) {
3277: vartok@var3471 =@expr1073756444 tok@var3445 .@expr1073756445 astOperand1 (@expr1073756446 ) ; }
3278: while (@expr1073756447 vartok@var3471 ) {
3279: if (@expr1073756448 vartok@var3471 .@expr14625 str (@expr14626 ) ==@expr1073756451 "[" ||@expr1073756452 vartok@var3471 .@expr1073756453 originalName (@expr1073756454 ) ==@expr1073756455 "->" ) {
3280: vartok@var3471 =@expr1073756456 vartok@var3471 .@expr1073756457 astOperand1 (@expr1073756458 ) ; }
3281: else { if (@expr1073756459 vartok@var3471 .@expr14625 str (@expr14626 ) ==@expr1073756462 "." ||@expr1073756463 vartok@var3471 .@expr14625 str (@expr14626 ) ==@expr1073756466 "::" ) {
3282: vartok@var3471 =@expr1073756467 vartok@var3471 .@expr1073756468 astOperand2 (@expr1073756469 ) ; }
3283: else {
3284: break ; } }
3285: }
3286:
3287: if (@expr1073756470 !@expr1073756471 vartok@var3471 ) {
3288: return {@expr1073756472 tok@var3445 , std ::@expr14309 move (@expr14310 errorPath@var3447 ) } ; }
3289: const Variable * tokvar@var3472 ; tokvar@var3472 =@expr1073756475 vartok@var3471 .@expr1073756476 variable (@expr1073756477 ) ;
3290: const bool isContainer@var3473 =@expr1073756478 astIsContainer (@expr14655 vartok@var3471 ) &&@expr1073756480 !@expr1073756481 astIsPointer (@expr1073756482 vartok@var3471 ) ;
3291: if (@expr1073756483 !@expr1073756484 astIsUniqueSmartPointer (@expr1073756485 vartok@var3471 ) &&@expr1073756486 !@expr1073756487 isContainer@var3473 &&@expr1073756488 !@expr1073756489 (@expr1073756490 tokvar@var3472 &&@expr1073756491 tokvar@var3472 .@expr1073756492 isArray (@expr1073756493 ) &&@expr1073756494 !@expr1073756495 tokvar@var3472 .@expr1073756496 isArgument (@expr1073756497 ) ) &&@expr1073756498
3292: (@expr1073756499 Token ::@expr14447 Match (@expr1073756501 vartok@var3471 .@expr14678 astParent (@expr14679 ) , "[|*" ) ||@expr1073756504 vartok@var3471 .@expr14678 astParent (@expr14679 ) .@expr1073756507 originalName (@expr1073756508 ) ==@expr1073756509 "->" ) ) {
3293: for (@expr1073756510 const ValueFlow ::@expr1073756511 Value &@expr14476 v@var3474 :@expr1073756513 vartok@var3471 .@expr1073756514 values (@expr1073756515 ) ) {
3294: if (@expr1073756516 !@expr1073756517 v@var3474 .@expr1073756518 isLocalLifetimeValue (@expr1073756519 ) ) {
3295: continue ; }
3296: if (@expr1073756520 v@var3474 .@expr14697 tokvalue@var3475 ==@expr1073756522 tok@var3445 ) {
3297: continue ; }
3298: errorPath@var3447 .@expr1073756523 insert (@expr1073756524 errorPath@var3447 .@expr1073756525 end (@expr1073756526 ) , v@var3474 .@expr14703 errorPath@var3476 .@expr1073756528 begin (@expr1073756529 ) , v@var3474 .@expr14703 errorPath@var3476 .@expr1073756531 end (@expr1073756532 ) ) ;
3299: return getLifetimeTokens (@expr1073756533 v@var3474 .@expr14697 tokvalue@var3475 , escape@var3446 , std ::@expr14309 move (@expr14310 errorPath@var3447 ) , pred@var3448 , depth@var3449 -@expr14391 1 ) ;
3300: }
3301: } else {
3302: return LifetimeToken ::@expr14600 setAddressOf (@expr1073756539 getLifetimeTokens (@expr1073756540 vartok@var3471 , escape@var3446 , std ::@expr14309 move (@expr14310 errorPath@var3447 ) , pred@var3448 , depth@var3449 -@expr14391 1 ) ,
3303: !@expr1073756544 (@expr1073756545 astIsContainer (@expr14655 vartok@var3471 ) &&@expr1073756547 Token ::@expr14299 simpleMatch (@expr1073756549 vartok@var3471 .@expr14678 astParent (@expr14679 ) , "[" ) ) ) ;
3304: }
3305: } else { if (@expr1073756552 Token ::@expr14299 simpleMatch (@expr1073756554 tok@var3445 , "{" ) &&@expr1073756555 getArgumentStart (@expr14732 tok@var3445 ) &&@expr1073756557
3306: !@expr1073756558 Token ::@expr14299 simpleMatch (@expr1073756560 getArgumentStart (@expr14732 tok@var3445 ) , "," ) &&@expr1073756562 getArgumentStart (@expr14732 tok@var3445 ) .@expr1073756564 valueType (@expr1073756565 ) ) {
3307: const Token * vartok@var3477 ; vartok@var3477 =@expr1073756566 getArgumentStart (@expr14732 tok@var3445 ) ;
3308: auto vts@var3478 ; vts@var3478 =@expr1073756568 getParentValueTypes (@expr1073756569 tok@var3445 ) ;
3309: for (@expr1073756570 const ValueType &@expr14476 vt@var3479 :@expr1073756572 vts@var3478 ) {
3310: if (@expr1073756573 vt@var3479 .@expr1073756574 isTypeEqual (@expr1073756575 vartok@var3477 .@expr1073756576 valueType (@expr1073756577 ) ) ) {
3311: return getLifetimeTokens (@expr1073756578 vartok@var3477 , escape@var3446 , std ::@expr14309 move (@expr14310 errorPath@var3447 ) , pred@var3448 , depth@var3449 -@expr14391 1 ) ; }
3312: }
3313: } } } }
3314: return {@expr1073756582 tok@var3445 , std ::@expr14309 move (@expr14310 errorPath@var3447 ) } ;
3315: }
3316:
3317: std :: vector < LifetimeToken > getLifetimeTokens ( const Token * tok@var3480 , bool escape@var3481 , ValueFlow :: Value :: ErrorPath errorPath@var3482 )
3318: {
3319: return getLifetimeTokens (@expr1073756585 tok@var3480 , escape@var3481 , std ::@expr1073756586 move (@expr1073756587 errorPath@var3482 ) , [@expr1073756588 ] (@expr1073756589 const Token *@expr1073756590 ) {
3320: return false ;
3321: } ) ;
3322: }
3323:
3324: bool hasLifetimeToken ( const Token * tok@var3483 , const Token * lifetime@var3484 )
3325: {
3326: bool result@var3485 ; result@var3485 =@expr1073756591 false ;
3327: getLifetimeTokens (@expr1073756592 tok@var3483 , false , ValueFlow ::@expr1073756593 Value ::@expr1073756594 ErrorPath {@expr1073756595 } , [@expr1073756596 &@expr1073756597 ] (@expr1073756598 const Token *@expr1073756599 tok2@var3486 ) {
3328: result@var3485 =@expr1073756600 tok2@var3486 .@expr1073756601 exprId (@expr1073756602 ) ==@expr1073756603 lifetime@var3484 .@expr1073756604 exprId (@expr1073756605 ) ;
3329: return result@var3485 ;
3330: } ) ;
3331: return result@var3485 ;
3332: }
3333:
3334: static const Token * getLifetimeToken ( const Token * tok@var3487 , ValueFlow :: Value :: ErrorPath & errorPath@var3488 , bool * addressOf@var3489 = nullptr )
3335: {
3336: std ::@expr1073756606 vector < LifetimeToken > lts@var3490 ; lts@var3490 =@expr1073756607 getLifetimeTokens (@expr1073756608 tok@var3487 ) ;
3337: if (@expr1073756609 lts@var3490 .@expr1073756610 size (@expr1073756611 ) !=@expr1073756612 1 ) {
3338: return nullptr ; }
3339: if (@expr1073756613 lts@var3490 .@expr14790 front (@expr14791 ) .@expr1073756616 inconclusive@var5326 ) {
3340: return nullptr ; }
3341: if (@expr1073756617 addressOf@var3489 ) {
3342: *@expr1073756618 addressOf@var3489 =@expr1073756619 lts@var3490 .@expr14790 front (@expr14791 ) .@expr1073756622 addressOf@var5327 ; }
3343: errorPath@var3488 .@expr1073756623 insert (@expr1073756624 errorPath@var3488 .@expr1073756625 end (@expr1073756626 ) , lts@var3490 .@expr14790 front (@expr14791 ) .@expr14805 errorPath@var5328 .@expr1073756630 begin (@expr1073756631 ) , lts@var3490 .@expr14790 front (@expr14791 ) .@expr14805 errorPath@var5328 .@expr1073756635 end (@expr1073756636 ) ) ;
3344: return lts@var3490 .@expr14790 front (@expr14791 ) .@expr1073756639 token@var5329 ;
3345: }
3346:
3347: const Variable * getLifetimeVariable ( const Token * tok@var3491 , ValueFlow :: Value :: ErrorPath & errorPath@var3492 , bool * addressOf@var3493 )
3348: {
3349: const Token * tok2@var3494 ; tok2@var3494 =@expr1073756640 getLifetimeToken (@expr1073756641 tok@var3491 , errorPath@var3492 , addressOf@var3493 ) ;
3350: if (@expr1073756642 tok2@var3494 &&@expr1073756643 tok2@var3494 .@expr14820 variable (@expr14821 ) ) {
3351: return tok2@var3494 .@expr14820 variable (@expr14821 ) ; }
3352: return nullptr ;
3353: }
3354:
3355: const Variable * getLifetimeVariable ( const Token * tok@var3495 )
3356: {
3357: ValueFlow ::@expr1073756648 Value ::@expr1073756649 ErrorPath errorPath@var3496 ;
3358: return getLifetimeVariable (@expr1073756650 tok@var3495 , errorPath@var3496 , nullptr ) ;
3359: }
3360:
3361: static bool isNotLifetimeValue ( const ValueFlow :: Value & val@var3497 )
3362: {
3363: return !@expr1073756651 val@var3497 .@expr1073756652 isLifetimeValue (@expr1073756653 ) ;
3364: }
3365:
3366: static bool isLifetimeOwned ( const ValueType * vtParent@var3498 )
3367: {
3368: if (@expr1073756654 vtParent@var3498 .@expr14831 container@var3499 ) {
3369: return !@expr1073756656 vtParent@var3498 .@expr14831 container@var3499 .@expr1073756658 view@var3500 ; }
3370: return vtParent@var3498 .@expr1073756659 type@var3501 ==@expr1073756660 ValueType ::@expr1073756661 CONTAINER ;
3371: }
3372:
3373: static bool isLifetimeOwned ( const ValueType * vt@var3502 , const ValueType * vtParent@var3503 )
3374: {
3375: if (@expr1073756662 !@expr1073756663 vtParent@var3503 ) {
3376: return false ; }
3377: if (@expr14840 isLifetimeOwned (@expr14841 vtParent@var3503 ) ) {
3378: return true ; }
3379: if (@expr1073756666 !@expr1073756667 vt@var3502 ) {
3380: return false ; }
3381:
3382: if (@expr1073756668 vtParent@var3503 .@expr14845 pointer@var3504 ==@expr1073756670 1 &&@expr1073756671 vt@var3502 .@expr14848 pointer@var3505 ==@expr1073756673 0 &&@expr1073756674 vt@var3502 .@expr14851 type@var3506 ==@expr1073756676 ValueType ::@expr1073756677 ITERATOR ) {
3383: return false ; }
3384: if (@expr1073756678 vt@var3502 .@expr14851 type@var3506 !=@expr1073756680 ValueType ::@expr14857 UNKNOWN_TYPE &&@expr1073756682 vtParent@var3503 .@expr14859 type@var3507 !=@expr1073756684 ValueType ::@expr14857 UNKNOWN_TYPE ) {
3385: if (@expr1073756686 vt@var3502 .@expr14848 pointer@var3505 !=@expr1073756688 vtParent@var3503 .@expr14845 pointer@var3504 ) {
3386: return true ; }
3387: if (@expr1073756690 vt@var3502 .@expr14851 type@var3506 !=@expr1073756692 vtParent@var3503 .@expr14859 type@var3507 ) {
3388: if (@expr1073756694 vtParent@var3503 .@expr14859 type@var3507 ==@expr1073756696 ValueType ::@expr1073756697 RECORD ) {
3389: return true ; }
3390: if (@expr14840 isLifetimeOwned (@expr14841 vtParent@var3503 ) ) {
3391: return true ; }
3392: }
3393: }
3394:
3395: return false ;
3396: }
3397:
3398: static bool isLifetimeBorrowed ( const ValueType * vt@var3508 , const ValueType * vtParent@var3509 )
3399: {
3400: if (@expr1073756700 !@expr1073756701 vtParent@var3509 ) {
3401: return false ; }
3402: if (@expr1073756702 !@expr1073756703 vt@var3508 ) {
3403: return false ; }
3404: if (@expr1073756704 vt@var3508 .@expr14881 pointer@var3510 >@expr1073756706 0 &&@expr1073756707 vt@var3508 .@expr14881 pointer@var3510 ==@expr1073756709 vtParent@var3509 .@expr14886 pointer@var3511 ) {
3405: return true ; }
3406: if (@expr1073756711 vtParent@var3509 .@expr14888 container@var3512 &&@expr1073756713 vtParent@var3509 .@expr14888 container@var3512 .@expr1073756715 view@var3513 ) {
3407: return true ; }
3408: if (@expr1073756716 vt@var3508 .@expr1073756717 type@var3514 !=@expr1073756718 ValueType ::@expr14895 UNKNOWN_TYPE &&@expr1073756720 vtParent@var3509 .@expr1073756721 type@var3515 !=@expr1073756722 ValueType ::@expr14895 UNKNOWN_TYPE &&@expr1073756724 vtParent@var3509 .@expr14888 container@var3512 ==@expr1073756726 vt@var3508 .@expr1073756727 container@var3516 ) {
3409: if (@expr1073756728 vtParent@var3509 .@expr14886 pointer@var3511 >@expr1073756730 vt@var3508 .@expr14881 pointer@var3510 ) {
3410: return true ; }
3411: if (@expr1073756732 vtParent@var3509 .@expr14886 pointer@var3511 <@expr1073756734 vt@var3508 .@expr14881 pointer@var3510 &&@expr1073756736 vtParent@var3509 .@expr1073756737 isIntegral (@expr1073756738 ) ) {
3412: return true ; }
3413: if (@expr1073756739 vtParent@var3509 .@expr1073756740 str (@expr1073756741 ) ==@expr1073756742 vt@var3508 .@expr1073756743 str (@expr1073756744 ) ) {
3414: return true ; }
3415: }
3416:
3417: return false ;
3418: }
3419:
3420: static const Token * skipCVRefs ( const Token * tok@var3517 , const Token * endTok@var3518 )
3421: {
3422: while (@expr1073756745 tok@var3517 !=@expr1073756746 endTok@var3518 &&@expr1073756747 Token ::@expr1073756748 Match (@expr1073756749 tok@var3517 , "const|volatile|auto|&|&&" ) ) {
3423: tok@var3517 =@expr1073756750 tok@var3517 .@expr1073756751 next (@expr1073756752 ) ; }
3424: return tok@var3517 ;
3425: }
3426:
3427: static bool isNotEqual ( std :: pair < const Token * , const Token * > x@var3519 , std :: pair < const Token * , const Token * > y@var3520 )
3428: {
3429: const Token * start1@var3521 ; start1@var3521 =@expr1073756753 x@var3519 .@expr1073756754 first@var3522 ;
3430: const Token * start2@var3523 ; start2@var3523 =@expr1073756755 y@var3520 .@expr1073756756 first@var3524 ;
3431: if (@expr1073756757 start1@var3521 ==@expr1073756758 nullptr ||@expr1073756759 start2@var3523 ==@expr1073756760 nullptr ) {
3432: return false ; }
3433: while (@expr1073756761 start1@var3521 !=@expr1073756762 x@var3519 .@expr14939 second@var3525 &&@expr1073756764 start2@var3523 !=@expr1073756765 y@var3520 .@expr14942 second@var3526 ) {
3434: const Token * tok1@var3527 ; tok1@var3527 =@expr1073756767 skipCVRefs (@expr14944 start1@var3521 , x@var3519 .@expr14939 second@var3525 ) ;
3435: if (@expr1073756770 tok1@var3527 !=@expr1073756771 start1@var3521 ) {
3436: start1@var3521 =@expr1073756772 tok1@var3527 ;
3437: continue ;
3438: }
3439: const Token * tok2@var3528 ; tok2@var3528 =@expr1073756773 skipCVRefs (@expr14950 start2@var3523 , y@var3520 .@expr14942 second@var3526 ) ;
3440: if (@expr1073756776 tok2@var3528 !=@expr1073756777 start2@var3523 ) {
3441: start2@var3523 =@expr1073756778 tok2@var3528 ;
3442: continue ;
3443: }
3444: if (@expr1073756779 start1@var3521 .@expr1073756780 str (@expr1073756781 ) !=@expr1073756782 start2@var3523 .@expr1073756783 str (@expr1073756784 ) ) {
3445: return true ; }
3446: start1@var3521 =@expr1073756785 start1@var3521 .@expr1073756786 next (@expr1073756787 ) ;
3447: start2@var3523 =@expr1073756788 start2@var3523 .@expr1073756789 next (@expr1073756790 ) ;
3448: }
3449: start1@var3521 =@expr1073756791 skipCVRefs (@expr14944 start1@var3521 , x@var3519 .@expr14939 second@var3525 ) ;
3450: start2@var3523 =@expr1073756794 skipCVRefs (@expr14950 start2@var3523 , y@var3520 .@expr14942 second@var3526 ) ;
3451: return !@expr1073756797 (@expr1073756798 start1@var3521 ==@expr1073756799 x@var3519 .@expr14939 second@var3525 &&@expr1073756801 start2@var3523 ==@expr1073756802 y@var3520 .@expr14942 second@var3526 ) ;
3452: }
3453: static bool isNotEqual ( std :: pair < const Token * , const Token * > x@var3529 , const std :: string & y@var3530 )
3454: {
3455: TokenList tokenList@var3531 (@expr1073756804 nullptr ) ;
3456: std ::@expr1073756805 istringstream istr@var3532 (@expr1073756806 y@var3530 ) ;
3457: tokenList@var3531 .@expr1073756807 createTokens (@expr1073756808 istr@var3532 ) ;
3458: return isNotEqual (@expr1073756809 x@var3529 , std ::@expr1073756810 make_pair (@expr1073756811 tokenList@var3531 .@expr1073756812 front (@expr1073756813 ) , tokenList@var3531 .@expr1073756814 back (@expr1073756815 ) ) ) ;
3459: }
3460: static bool isNotEqual ( std :: pair < const Token * , const Token * > x@var3533 , const ValueType * y@var3534 )
3461: {
3462: if (@expr1073756816 y@var3534 ==@expr1073756817 nullptr ) {
3463: return false ; }
3464: if (@expr1073756818 y@var3534 .@expr14995 originalTypeName@var3535 .@expr1073756820 empty (@expr1073756821 ) ) {
3465: return false ; }
3466: return isNotEqual (@expr1073756822 x@var3533 , y@var3534 .@expr14995 originalTypeName@var3535 ) ;
3467: }
3468:
3469: static bool isDifferentType ( const Token * src@var3536 , const Token * dst@var3537 )
3470: {
3471: const Type * t@var3538 ; t@var3538 =@expr1073756824 Token ::@expr15001 typeOf (@expr1073756826 src@var3536 ) ;
3472: const Type * parentT@var3539 ; parentT@var3539 =@expr1073756827 Token ::@expr15001 typeOf (@expr1073756829 dst@var3537 ) ;
3473: if (@expr1073756830 t@var3538 &&@expr1073756831 parentT@var3539 ) {
3474: if (@expr1073756832 t@var3538 .@expr15009 classDef@var3540 &&@expr1073756834 parentT@var3539 .@expr15011 classDef@var3541 &&@expr1073756836 t@var3538 .@expr15009 classDef@var3540 !=@expr1073756838 parentT@var3539 .@expr15011 classDef@var3541 ) {
3475: return true ; }
3476: } else {
3477: std ::@expr1073756840 pair < const Token *@expr15017 , const Token *@expr15017 > decl@var3542 ; decl@var3542 =@expr1073756843 Token ::@expr15020 typeDecl (@expr1073756845 src@var3536 ) ;
3478: std ::@expr1073756846 pair < const Token *@expr15017 , const Token *@expr15017 > parentdecl@var3543 ; parentdecl@var3543 =@expr1073756849 Token ::@expr15020 typeDecl (@expr1073756851 dst@var3537 ) ;
3479: if (@expr1073756852 isNotEqual (@expr1073756853 decl@var3542 , parentdecl@var3543 ) ) {
3480: return true ; }
3481: if (@expr1073756854 isNotEqual (@expr1073756855 decl@var3542 , dst@var3537 .@expr1073756856 valueType (@expr1073756857 ) ) ) {
3482: return true ; }
3483: if (@expr1073756858 isNotEqual (@expr1073756859 parentdecl@var3543 , src@var3536 .@expr1073756860 valueType (@expr1073756861 ) ) ) {
3484: return true ; }
3485: }
3486: return false ;
3487: }
3488:
3489: bool isLifetimeBorrowed ( const Token * tok@var3544 , const Settings * settings@var3545 )
3490: {
3491: if (@expr1073756862 !@expr1073756863 tok@var3544 ) {
3492: return true ; }
3493: if (@expr1073756864 tok@var3544 .@expr1073756865 str (@expr1073756866 ) ==@expr1073756867 "," ) {
3494: return true ; }
3495: if (@expr1073756868 !@expr1073756869 tok@var3544 .@expr1073756870 astParent (@expr1073756871 ) ) {
3496: return true ; }
3497: const Token * parent@var3546 ; parent@var3546 =@expr1073756872 nullptr ;
3498: const ValueType * vt@var3547 ; vt@var3547 =@expr1073756873 tok@var3544 .@expr1073756874 valueType (@expr1073756875 ) ;
3499: std ::@expr1073756876 vector < ValueType > vtParents@var3548 ; vtParents@var3548 =@expr1073756877 getParentValueTypes (@expr1073756878 tok@var3544 , settings@var3545 , &@expr1073756879 parent@var3546 ) ;
3500: for (@expr1073756880 const ValueType &@expr1073756881 vtParent@var3549 :@expr1073756882 vtParents@var3548 ) {
3501: if (@expr1073756883 isLifetimeBorrowed (@expr1073756884 vt@var3547 , &@expr15061 vtParent@var3549 ) ) {
3502: return true ; }
3503: if (@expr1073756886 isLifetimeOwned (@expr1073756887 vt@var3547 , &@expr15061 vtParent@var3549 ) ) {
3504: return false ; }
3505: }
3506: if (@expr1073756889 parent@var3546 ) {
3507: if (@expr1073756890 isDifferentType (@expr1073756891 tok@var3544 , parent@var3546 ) ) {
3508: return false ; }
3509: }
3510: return true ;
3511: }
3512:
3513: static void valueFlowLifetimeFunction ( Token * tok@var3550 , TokenList * tokenlist@var3551 , ErrorLogger * errorLogger@var3552 , const Settings * settings@var3553 ) ;
3514:
3515: static void valueFlowLifetimeConstructor ( Token * tok@var3554 ,
3516: TokenList * tokenlist@var3555 ,
3517: ErrorLogger * errorLogger@var3556 ,
3518: const Settings * settings@var3557 ) ;
3519:
3520: static const Token * getEndOfVarScope ( const Variable * var@var3558 )
3521: {
3522: if (@expr1073756892 !@expr1073756893 var@var3558 ) {
3523: return nullptr ; }
3524: const Scope * innerScope@var3559 ; innerScope@var3559 =@expr1073756894 var@var3558 .@expr1073756895 scope (@expr1073756896 ) ;
3525: const Scope * outerScope@var3560 ; outerScope@var3560 =@expr1073756897 innerScope@var3559 ;
3526: if (@expr1073756898 var@var3558 .@expr15075 typeStartToken (@expr15076 ) &&@expr1073756901 var@var3558 .@expr15075 typeStartToken (@expr15076 ) .@expr15080 scope (@expr15081 ) ) {
3527: outerScope@var3560 =@expr1073756906 var@var3558 .@expr15075 typeStartToken (@expr15076 ) .@expr15080 scope (@expr15081 ) ; }
3528: if (@expr1073756911 !@expr15088 innerScope@var3559 &&@expr1073756913 outerScope@var3560 ) {
3529: innerScope@var3559 =@expr1073756914 outerScope@var3560 ; }
3530: if (@expr1073756915 !@expr15088 innerScope@var3559 ||@expr1073756917 !@expr1073756918 outerScope@var3560 ) {
3531: return nullptr ; }
3532: if (@expr1073756919 !@expr1073756920 innerScope@var3559 .@expr1073756921 isExecutable (@expr1073756922 ) ) {
3533: return nullptr ; }
3534:
3535:
3536:
3537: if (@expr1073756923 innerScope@var3559 !=@expr1073756924 outerScope@var3560 &&@expr1073756925 outerScope@var3560 .@expr1073756926 isExecutable (@expr1073756927 ) &&@expr1073756928 innerScope@var3559 .@expr1073756929 isLocal (@expr1073756930 ) ) {
3538: return innerScope@var3559 .@expr15107 bodyEnd@var3561 .@expr1073756932 next (@expr1073756933 ) ; }
3539: return innerScope@var3559 .@expr15107 bodyEnd@var3561 ;
3540: }
3541:
3542: const Token * getEndOfExprScope ( const Token * tok@var3562 , const Scope * defaultScope@var3563 , bool smallest@var3564 )
3543: {
3544: const Token * end@var3565 ; end@var3565 =@expr1073756935 nullptr ;
3545: bool local@var3566 ; local@var3566 =@expr1073756936 false ;
3546: visitAstNodes (@expr1073756937 tok@var3562 , [@expr1073756938 &@expr1073756939 ] (@expr1073756940 const Token *@expr15117 child@var3567 ) {
3547: if (@expr1073756942 const Variable *@expr15117 var@var3568 =@expr1073756944 child@var3567 .@expr1073756945 variable (@expr1073756946 ) ) {
3548: local@var3566 |=@expr1073756947 var@var3568 .@expr15124 isLocal (@expr15125 ) ;
3549: if (@expr1073756950 var@var3568 .@expr15124 isLocal (@expr15125 ) ||@expr1073756953 var@var3568 .@expr1073756954 isArgument (@expr1073756955 ) ) {
3550: const Token * varEnd@var3569 ; varEnd@var3569 =@expr1073756956 getEndOfVarScope (@expr1073756957 var@var3568 ) ;
3551: if (@expr1073756958 !@expr15135 end@var3565 ||@expr1073756960 (@expr1073756961 smallest@var3564 ?@expr1073756962 precedes (@expr1073756963 varEnd@var3569 , end@var3565 ) :@expr1073756964 succeeds (@expr1073756965 varEnd@var3569 , end@var3565 ) ) ) {
3552: end@var3565 =@expr1073756966 varEnd@var3569 ; }
3553: }
3554: }
3555: return ChildrenToVisit ::@expr1073756967 op1_and_op2 ;
3556: } ) ;
3557: if (@expr1073756968 !@expr15135 end@var3565 &&@expr1073756970 defaultScope@var3563 ) {
3558: end@var3565 =@expr1073756971 defaultScope@var3563 .@expr1073756972 bodyEnd@var3570 ; }
3559: if (@expr1073756973 !@expr15135 end@var3565 ) {
3560: const Scope * scope@var3571 ; scope@var3571 =@expr1073756975 tok@var3562 .@expr1073756976 scope (@expr1073756977 ) ;
3561: if (@expr1073756978 scope@var3571 ) {
3562: end@var3565 =@expr1073756979 scope@var3571 .@expr15156 bodyEnd@var3572 ; }
3563:
3564: if (@expr1073756981 !@expr1073756982 local@var3566 ) {
3565: while (@expr1073756983 scope@var3571 &&@expr1073756984 scope@var3571 .@expr1073756985 isLocal (@expr1073756986 ) ) {
3566: scope@var3571 =@expr1073756987 scope@var3571 .@expr1073756988 nestedIn@var3573 ; }
3567: if (@expr1073756989 scope@var3571 &&@expr1073756990 scope@var3571 .@expr1073756991 isExecutable (@expr1073756992 ) ) {
3568: end@var3565 =@expr1073756993 scope@var3571 .@expr15156 bodyEnd@var3572 ; }
3569: }
3570: }
3571: return end@var3565 ;
3572: }
3573:
3574: static void valueFlowForwardLifetime ( Token * tok@var3574 , TokenList * tokenlist@var3575 , ErrorLogger * errorLogger@var3576 , const Settings * settings@var3577 )
3575: {
3576:
3577: if (@expr1073756995 Token ::@expr15172 Match (@expr1073756997 tok@var3574 .@expr15174 previous (@expr15175 ) , "%var% {|(" ) &&@expr1073757000 isVariableDecl (@expr1073757001 tok@var3574 .@expr15174 previous (@expr15175 ) ) ) {
3578: std ::@expr1073757004 list < ValueFlow ::@expr15181 Value > values@var3578 ; values@var3578 =@expr1073757006 tok@var3574 .@expr15183 values (@expr15184 ) ;
3579: values@var3578 .@expr1073757009 remove_if (@expr1073757010 &@expr15187 isNotLifetimeValue ) ;
3580: valueFlowForward (@expr1073757012 nextAfterAstRightmostLeaf (@expr1073757013 tok@var3574 ) , getEndOfExprScope (@expr1073757014 tok@var3574 ) , tok@var3574 .@expr15174 previous (@expr15175 ) , values@var3578 , tokenlist@var3575 , settings@var3577 ) ;
3581: return ;
3582: }
3583: Token * parent@var3579 ; parent@var3579 =@expr1073757017 tok@var3574 .@expr1073757018 astParent (@expr1073757019 ) ;
3584: while (@expr1073757020 parent@var3579 &&@expr1073757021 parent@var3579 .@expr15198 str (@expr15199 ) ==@expr1073757024 "," ) {
3585: parent@var3579 =@expr1073757025 parent@var3579 .@expr15202 astParent (@expr15203 ) ; }
3586: if (@expr1073757028 !@expr1073757029 parent@var3579 ) {
3587: return ; }
3588:
3589: if (@expr1073757030 parent@var3579 .@expr15198 str (@expr15199 ) ==@expr1073757033 "=" &&@expr1073757034 (@expr1073757035 !@expr1073757036 parent@var3579 .@expr15202 astParent (@expr15203 ) ||@expr1073757039 Token ::@expr15216 simpleMatch (@expr1073757041 parent@var3579 .@expr15202 astParent (@expr15203 ) , ";" ) ) ) {
3590:
3591: if (@expr1073757044 !@expr1073757045 parent@var3579 .@expr15222 astOperand2 (@expr15223 ) ||@expr1073757048 parent@var3579 .@expr15222 astOperand2 (@expr15223 ) .@expr15227 values (@expr15228 ) .@expr1073757053 empty (@expr1073757054 ) ) {
3592: return ; }
3593:
3594: if (@expr1073757055 !@expr1073757056 isLifetimeBorrowed (@expr1073757057 parent@var3579 .@expr15222 astOperand2 (@expr15223 ) , settings@var3577 ) ) {
3595: return ; }
3596:
3597: const Token * expr@var3580 ; expr@var3580 =@expr1073757060 getLHSVariableToken (@expr1073757061 parent@var3579 ) ;
3598: if (@expr1073757062 !@expr1073757063 expr@var3580 ) {
3599: return ; }
3600:
3601: if (@expr1073757064 expr@var3580 .@expr15241 exprId (@expr15242 ) ==@expr1073757067 0 ) {
3602: return ; }
3603:
3604: const Token * endOfVarScope@var3581 ; endOfVarScope@var3581 =@expr1073757068 getEndOfExprScope (@expr1073757069 expr@var3580 ) ;
3605:
3606:
3607: std ::@expr1073757070 list < ValueFlow ::@expr15181 Value > values@var3582 ; values@var3582 =@expr1073757072 parent@var3579 .@expr15222 astOperand2 (@expr15223 ) .@expr15227 values (@expr15228 ) ;
3608: values@var3582 .@expr15253 remove_if (@expr1073757078 &@expr15187 isNotLifetimeValue ) ;
3609:
3610: values@var3582 .@expr15253 remove_if (@expr1073757081 [@expr1073757082 &@expr15259 ] (@expr1073757084 const ValueFlow ::@expr15181 Value &@expr15259 value@var3583 ) {
3611: return findAstNode (@expr1073757087 value@var3583 .@expr1073757088 tokvalue@var3584 , [@expr1073757089 &@expr15259 ] (@expr1073757091 const Token *@expr15268 child@var3585 ) {
3612: return child@var3585 .@expr1073757093 exprId (@expr1073757094 ) ==@expr1073757095 expr@var3580 .@expr15241 exprId (@expr15242 ) ;
3613: } ) ;
3614: } ) ;
3615:
3616:
3617: const Token * nextExpression@var3586 ; nextExpression@var3586 =@expr1073757098 nextAfterAstRightmostLeaf (@expr15275 parent@var3579 ) ;
3618:
3619: if (@expr1073757100 expr@var3580 .@expr15241 exprId (@expr15242 ) >@expr1073757103 0 ) {
3620: valueFlowForwardExpression (@expr1073757104 const_cast < Token *@expr15268 > (@expr15282 nextExpression@var3586 ) ,
3621: endOfVarScope@var3581 .@expr1073757107 next (@expr1073757108 ) ,
3622: expr@var3580 ,
3623: values@var3582 ,
3624: tokenlist@var3575 ,
3625: settings@var3577 ) ;
3626:
3627: for (@expr1073757109 ValueFlow ::@expr15181 Value &@expr15259 val@var3587 :@expr1073757112 values@var3582 ) {
3628: if (@expr1073757113 val@var3587 .@expr15290 lifetimeKind@var3588 ==@expr1073757115 ValueFlow ::@expr15292 Value ::@expr15293 LifetimeKind ::@expr1073757118 Address ) {
3629: val@var3587 .@expr15290 lifetimeKind@var3588 =@expr1073757120 ValueFlow ::@expr15292 Value ::@expr15293 LifetimeKind ::@expr1073757123 SubObject ; }
3630: }
3631:
3632: if (@expr1073757124 Token ::@expr15216 simpleMatch (@expr1073757126 parent@var3579 .@expr15303 astOperand1 (@expr15304 ) , "." ) ) {
3633: const Token * parentLifetime@var3589 ; parentLifetime@var3589 =@expr1073757129
3634: getParentLifetime (@expr1073757130 tokenlist@var3575 .@expr1073757131 isCPP (@expr1073757132 ) , parent@var3579 .@expr15303 astOperand1 (@expr15304 ) .@expr1073757135 astOperand2 (@expr1073757136 ) , &@expr1073757137 settings@var3577 .@expr1073757138 library@var3590 ) ;
3635: if (@expr1073757139 parentLifetime@var3589 &&@expr1073757140 parentLifetime@var3589 .@expr1073757141 exprId (@expr1073757142 ) >@expr1073757143 0 ) {
3636: valueFlowForward (@expr1073757144 const_cast < Token *@expr15268 > (@expr15282 nextExpression@var3586 ) ,
3637: endOfVarScope@var3581 ,
3638: parentLifetime@var3589 ,
3639: values@var3582 ,
3640: tokenlist@var3575 ,
3641: settings@var3577 ) ;
3642: }
3643: }
3644: }
3645:
3646: } else { if (@expr1073757147 Token ::@expr15216 simpleMatch (@expr1073757149 parent@var3579 , "{" ) &&@expr1073757150 !@expr1073757151 isScopeBracket (@expr1073757152 parent@var3579 ) ) {
3647: valueFlowLifetimeConstructor (@expr1073757153 parent@var3579 , tokenlist@var3575 , errorLogger@var3576 , settings@var3577 ) ;
3648: valueFlowForwardLifetime (@expr15330 parent@var3579 , tokenlist@var3575 , errorLogger@var3576 , settings@var3577 ) ;
3649:
3650: } else { if (@expr1073757155 Token ::@expr15172 Match (@expr1073757157 parent@var3579 .@expr15334 previous (@expr15335 ) , "%name% (" ) ) {
3651: valueFlowLifetimeFunction (@expr1073757160 parent@var3579 .@expr15334 previous (@expr15335 ) , tokenlist@var3575 , errorLogger@var3576 , settings@var3577 ) ;
3652: valueFlowForwardLifetime (@expr15330 parent@var3579 , tokenlist@var3575 , errorLogger@var3576 , settings@var3577 ) ;
3653:
3654: } else { if (@expr1073757164 tok@var3574 .@expr15341 variable (@expr15342 ) ) {
3655: const Variable * var@var3591 ; var@var3591 =@expr1073757167 tok@var3574 .@expr15341 variable (@expr15342 ) ;
3656: const Token * endOfVarScope@var3592 ; endOfVarScope@var3592 =@expr1073757170 var@var3591 .@expr1073757171 scope (@expr1073757172 ) .@expr1073757173 bodyEnd@var5330 ;
3657:
3658: std ::@expr1073757174 list < ValueFlow ::@expr15181 Value > values@var3593 ; values@var3593 =@expr1073757176 tok@var3574 .@expr15183 values (@expr15184 ) ;
3659: const Token * nextExpression@var3594 ; nextExpression@var3594 =@expr1073757179 nextAfterAstRightmostLeaf (@expr15275 parent@var3579 ) ;
3660:
3661: values@var3593 .@expr1073757181 remove_if (@expr1073757182 &@expr15187 isNotLifetimeValue ) ;
3662: valueFlowForward (@expr1073757184 const_cast < Token *@expr15268 > (@expr1073757186 nextExpression@var3594 ) , endOfVarScope@var3592 , tok@var3574 , values@var3593 , tokenlist@var3575 , settings@var3577 ) ;
3663:
3664: } else { if (@expr1073757187 parent@var3579 .@expr1073757188 isCast (@expr1073757189 ) ) {
3665: std ::@expr1073757190 list < ValueFlow ::@expr15181 Value > values@var3595 ; values@var3595 =@expr1073757192 tok@var3574 .@expr15183 values (@expr15184 ) ;
3666:
3667: values@var3595 .@expr1073757195 remove_if (@expr1073757196 &@expr15187 isNotLifetimeValue ) ;
3668: for (@expr1073757198 const ValueFlow ::@expr15181 Value &@expr15259 value@var3596 :@expr1073757201 values@var3595 ) {
3669: setTokenValue (@expr1073757202 parent@var3579 , value@var3596 , tokenlist@var3575 .@expr1073757203 getSettings (@expr1073757204 ) ) ; }
3670: valueFlowForwardLifetime (@expr15330 parent@var3579 , tokenlist@var3575 , errorLogger@var3576 , settings@var3577 ) ;
3671: } } } } }
3672: }
3673:
3674: struct LifetimeStore {
3675: const Token * argtok@var3597 ;
3676: std :: string message@var3598 ;
3677: ValueFlow :: Value :: LifetimeKind type@var3599 ;
3678: std :: list < std :: pair < const Token * , std :: string > > errorPath@var3600 ;
3679: bool inconclusive@var3601 ;
3680: bool forward@var3602 ;
3681:
3682: struct Context {
3683: Token * tok@var3603 ;
3684: TokenList * tokenlist@var3604 ;
3685: ErrorLogger * errorLogger@var3605 ;
3686: const Settings * settings@var3606 ;
3687: } ;
3688:
3689: LifetimeStore ( )
3690: : argtok@var3597 ( nullptr ) , message@var3598 ( ) , type@var3599 ( ) , errorPath@var3600 ( ) , inconclusive@var3601 ( false ) , forward@var3602 ( true ) , mContext@var3718 ( nullptr )
3691: { }
3692:
3693: LifetimeStore ( const Token * argtok@var3607 ,
3694: const std :: string & message@var3608 ,
3695: ValueFlow :: Value :: LifetimeKind type@var3609 = ValueFlow :: Value :: LifetimeKind :: Object ,
3696: bool inconclusive@var3610 = false )
3697: : argtok@var3597 ( argtok@var3607 ) ,
3698: message@var3598 ( message@var3608 ) ,
3699: type@var3599 ( type@var3609 ) ,
3700: errorPath@var3600 ( ) ,
3701: inconclusive@var3601 ( inconclusive@var3610 ) ,
3702: forward@var3602 ( true ) ,
3703: mContext@var3718 ( nullptr )
3704: { }
3705:
3706: template < class F >
3707: static void forEach ( const std :: vector < const Token * > & argtoks@var3611 ,
3708: const std :: string & message@var3612 ,
3709: ValueFlow :: Value :: LifetimeKind type@var3613 ,
3710: F f@var3614 ) {
3711: std ::@expr1073757206 map < const Token *@expr15383 , Context > forwardToks@var3615 ;
3712: for (@expr1073757208 const Token *@expr15383 arg@var3616 :@expr1073757210 argtoks@var3611 ) {
3713: LifetimeStore ls@var3617 {@expr1073757211 arg@var3616 , message@var3612 , type@var3613 } ;
3714: Context c@var3618 {@expr1073757212 } ;
3715: ls@var3617 .@expr1073757213 mContext@var3619 =@expr1073757214 &@expr1073757215 c@var3618 ;
3716: ls@var3617 .@expr1073757216 forward@var3620 =@expr1073757217 false ;
3717: f@var3614 (@expr1073757218 ls@var3617 ) ;
3718: if (@expr1073757219 c@var3618 .@expr15396 tok@var3621 ) {
3719: forwardToks@var3615 [@expr1073757221 c@var3618 .@expr15396 tok@var3621 ] =@expr1073757223 c@var3618 ; }
3720: }
3721: for (@expr1073757224 const auto &@expr15401 p@var3622 :@expr1073757226 forwardToks@var3615 ) {
3722: const Context &@expr15401 c@var3623 =@expr1073757228 p@var3622 .@expr1073757229 second@var3624 ;
3723: valueFlowForwardLifetime (@expr1073757230 c@var3623 .@expr1073757231 tok@var3625 , c@var3623 .@expr1073757232 tokenlist@var3626 , c@var3623 .@expr1073757233 errorLogger@var3627 , c@var3623 .@expr1073757234 settings@var3628 ) ;
3724: }
3725: }
3726:
3727: static LifetimeStore fromFunctionArg ( const Function * f@var3629 , Token * tok@var3630 , const Variable * var@var3631 , TokenList * tokenlist@var3632 , ErrorLogger * errorLogger@var3633 ) {
3728: if (@expr1073757236 !@expr1073757237 var@var3631 ) {
3729: return LifetimeStore {@expr1073757238 } ; }
3730: if (@expr1073757239 !@expr1073757240 var@var3631 .@expr1073757241 isArgument (@expr1073757242 ) ) {
3731: return LifetimeStore {@expr1073757243 } ; }
3732: int n@var3634 ; n@var3634 =@expr1073757244 getArgumentPos (@expr1073757245 var@var3631 , f@var3629 ) ;
3733: if (@expr1073757246 n@var3634 <@expr1073757247 0 ) {
3734: return LifetimeStore {@expr1073757248 } ; }
3735: std ::@expr1073757249 vector < const Token *@expr1073757250 > args@var3635 ; args@var3635 =@expr1073757251 getArguments (@expr1073757252 tok@var3630 ) ;
3736: if (@expr1073757253 n@var3634 >=@expr1073757254 args@var3635 .@expr15431 size (@expr15432 ) ) {
3737: if (@expr1073757257 tokenlist@var3632 .@expr1073757258 getSettings (@expr1073757259 ) .@expr1073757260 debugwarnings@var5331 ) {
3738: $bailoutInternal $(@expr1073757261 $"valueFlowBailout" $, tokenlist@var3632 $, errorLogger@var3633 $, tok@var3630 $, "Argument mismatch: Function '" +@expr1073757262 tok@var3630 .@expr1073757263 str (@expr1073757264 ) +@expr1073757265 "' returning lifetime from argument index " +@expr1073757266 std ::@expr15443 to_string (@expr1073757268 n@var3634 ) +@expr1073757269 " but only " +@expr1073757270 std ::@expr15443 to_string (@expr1073757272 args@var3635 .@expr15431 size (@expr15432 ) ) +@expr1073757275 " arguments are available." $, "cppcheck-2.8/lib/valueflow.cpp" $, 3738 $, $__func__ $)
3739:
|
3742:
3743: ; }
3744: return LifetimeStore {@expr1073757276 } ;
3745: }
3746: const Token * argtok2@var3636 ; argtok2@var3636 =@expr1073757277 args@var3635 [@expr1073757278 n@var3634 ] ;
3747: return LifetimeStore {@expr1073757279 argtok2@var3636 , "Passed to '" +@expr1073757280 tok@var3630 .@expr1073757281 expressionString (@expr1073757282 ) +@expr1073757283 "'." , ValueFlow ::@expr1073757284 Value ::@expr1073757285 LifetimeKind ::@expr1073757286 Object@expr1073757235 } ;
3748: }
3749:
3750: template < class Predicate >
3751: bool byRef ( Token * tok@var3637 , TokenList * tokenlist@var3638 , ErrorLogger * errorLogger@var3639 , const Settings * settings@var3640 , Predicate pred@var3641 ) const {
3752: if (@expr1073757289 !@expr1073757290 argtok@var3597 ) {
3753: return false ; }
3754: bool update@var3642 ; update@var3642 =@expr1073757291 false ;
3755: for (@expr1073757292 const LifetimeToken &@expr1073757293 lt@var3643 :@expr1073757294 getLifetimeTokens (@expr1073757295 argtok@var3597 ) ) {
3756: if (@expr1073757296 !@expr1073757297 settings@var3640 .@expr1073757298 certainty@var3644 .@expr1073757299 isEnabled (@expr1073757300 Certainty ::@expr1073757301 inconclusive@expr1073757287 ) &&@expr1073757302 lt@var3643 .@expr15479 inconclusive@var3645 ) {
3757: continue ; }
3758: std ::@expr1073757304 list < std ::@expr15481 pair < const Token *@expr1073757306 , std ::@expr15481 string > > er@var3646 ; er@var3646 =@expr1073757308 errorPath@var3600 ;
3759: er@var3646 .@expr1073757309 insert (@expr1073757310 er@var3646 .@expr1073757311 end (@expr1073757312 ) , lt@var3643 .@expr15489 errorPath@var3647 .@expr1073757314 begin (@expr1073757315 ) , lt@var3643 .@expr15489 errorPath@var3647 .@expr1073757317 end (@expr1073757318 ) ) ;
3760: if (@expr1073757319 !@expr1073757320 lt@var3643 .@expr15497 token@var3648 ) {
3761: return false ; }
3762: if (@expr1073757322 !@expr1073757323 pred@var3641 (@expr1073757324 lt@var3643 .@expr15497 token@var3648 ) ) {
3763: return false ; }
3764: er@var3646 .@expr1073757326 emplace_back (@expr1073757327 argtok@var3597 , message@var3598 ) ;
3765:
3766: ValueFlow ::@expr1073757328 Value value@var3649 ;
3767: value@var3649 .@expr1073757329 valueType@var3650 =@expr1073757330 ValueFlow ::@expr15507 Value ::@expr1073757332 ValueType ::@expr1073757333 LIFETIME ;
3768: value@var3649 .@expr1073757334 lifetimeScope@var3651 =@expr1073757335 ValueFlow ::@expr15507 Value ::@expr1073757337 LifetimeScope ::@expr1073757338 Local@expr1073757288 ;
3769: value@var3649 .@expr1073757339 tokvalue@var3652 =@expr1073757340 lt@var3643 .@expr15497 token@var3648 ;
3770: value@var3649 .@expr1073757342 errorPath@var3653 =@expr1073757343 std ::@expr1073757344 move (@expr1073757345 er@var3646 ) ;
3771: value@var3649 .@expr1073757346 lifetimeKind@var3654 =@expr1073757347 type@var3599 ;
3772: value@var3649 .@expr1073757348 setInconclusive (@expr1073757349 lt@var3643 .@expr15479 inconclusive@var3645 ||@expr1073757351 inconclusive@var3601 ) ;
3773:
3774: if (@expr1073757352 std ::@expr1073757353 find (@expr1073757354 tok@var3637 .@expr15531 values (@expr15532 ) .@expr1073757357 begin (@expr1073757358 ) , tok@var3637 .@expr15531 values (@expr15532 ) .@expr15537 end (@expr15538 ) , value@var3649 ) !=@expr1073757363 tok@var3637 .@expr15531 values (@expr15532 ) .@expr15537 end (@expr15538 ) ) {
3775: return false ; }
3776: setTokenValue (@expr1073757368 tok@var3637 , value@var3649 , tokenlist@var3638 .@expr1073757369 getSettings (@expr1073757370 ) ) ;
3777: update@var3642 =@expr1073757371 true ;
3778: }
3779: if (@expr1073757372 update@var3642 &&@expr1073757373 forward@var3602 ) {
3780: forwardLifetime (@expr1073757374 tok@var3637 , tokenlist@var3638 , errorLogger@var3639 , settings@var3640 ) ; }
3781: return update@var3642 ;
3782: }
3783:
3784: bool byRef ( Token * tok@var3655 , TokenList * tokenlist@var3656 , ErrorLogger * errorLogger@var3657 , const Settings * settings@var3658 ) const {
3785: return byRef (@expr1073757375 tok@var3655 , tokenlist@var3656 , errorLogger@var3657 , settings@var3658 , [@expr1073757376 ] (@expr1073757377 const Token *@expr1073757378 ) {
3786: return true ;
3787: } ) ;
3788: }
3789:
3790: template < class Predicate >
3791: bool byVal ( Token * tok@var3659 , TokenList * tokenlist@var3660 , ErrorLogger * errorLogger@var3661 , const Settings * settings@var3662 , Predicate pred@var3663 ) const {
3792: if (@expr1073757380 !@expr1073757381 argtok@var3597 ) {
3793: return false ; }
3794: bool update@var3664 ; update@var3664 =@expr1073757382 false ;
3795: if (@expr1073757383 argtok@var3597 .@expr15560 values (@expr15561 ) .@expr1073757386 empty (@expr1073757387 ) ) {
3796: std ::@expr1073757388 list < std ::@expr15565 pair < const Token *@expr15566 , std ::@expr15565 string > > er@var3665 ;
3797: er@var3665 .@expr1073757392 emplace_back (@expr1073757393 argtok@var3597 , message@var3598 ) ;
3798: for (@expr1073757394 const LifetimeToken &@expr15571 lt@var3666 :@expr1073757396 getLifetimeTokens (@expr1073757397 argtok@var3597 ) ) {
3799: if (@expr1073757398 !@expr15575 settings@var3662 .@expr15576 certainty@var3667 .@expr15577 isEnabled (@expr15578 Certainty ::@expr15579 inconclusive@expr15555 ) &&@expr1073757404 lt@var3666 .@expr15581 inconclusive@var3668 ) {
3800: continue ; }
3801: ValueFlow ::@expr1073757406 Value value@var3669 ;
3802: value@var3669 .@expr1073757407 valueType@var3670 =@expr1073757408 ValueFlow ::@expr15585 Value ::@expr15586 ValueType ::@expr15587 LIFETIME ;
3803: value@var3669 .@expr1073757412 tokvalue@var3671 =@expr1073757413 lt@var3666 .@expr15590 token@var3672 ;
3804: value@var3669 .@expr1073757415 capturetok@var3673 =@expr1073757416 argtok@var3597 ;
3805: value@var3669 .@expr1073757417 errorPath@var3674 =@expr1073757418 er@var3665 ;
3806: value@var3669 .@expr1073757419 lifetimeKind@var3675 =@expr1073757420 type@var3599 ;
3807: value@var3669 .@expr1073757421 setInconclusive (@expr1073757422 inconclusive@var3601 ||@expr1073757423 lt@var3666 .@expr15581 inconclusive@var3668 ) ;
3808: const Variable * var@var3676 ; var@var3676 =@expr1073757425 lt@var3666 .@expr15590 token@var3672 .@expr1073757427 variable (@expr1073757428 ) ;
3809: if (@expr1073757429 var@var3676 &&@expr1073757430 var@var3676 .@expr1073757431 isArgument (@expr1073757432 ) ) {
3810: value@var3669 .@expr1073757433 lifetimeScope@var3677 =@expr1073757434 ValueFlow ::@expr15585 Value ::@expr1073757436 LifetimeScope ::@expr1073757437 Argument ;
3811: } else {
3812: continue ;
3813: }
3814:
3815: if (@expr1073757438 std ::@expr15615 find (@expr1073757440 tok@var3659 .@expr15617 values (@expr15618 ) .@expr15619 begin (@expr15620 ) , tok@var3659 .@expr15617 values (@expr15618 ) .@expr15623 end (@expr15624 ) , value@var3669 ) !=@expr1073757449 tok@var3659 .@expr15617 values (@expr15618 ) .@expr15623 end (@expr15624 ) ) {
3816: continue ; }
3817:
3818: setTokenValue (@expr1073757454 tok@var3659 , value@var3669 , tokenlist@var3660 .@expr15631 getSettings (@expr15632 ) ) ;
3819: update@var3664 =@expr1073757457 true ;
3820: }
3821: }
3822: for (@expr1073757458 const ValueFlow ::@expr15565 Value &@expr15571 v@var3678 :@expr1073757461 argtok@var3597 .@expr15560 values (@expr15561 ) ) {
3823: if (@expr1073757464 !@expr1073757465 v@var3678 .@expr1073757466 isLifetimeValue (@expr1073757467 ) ) {
3824: continue ; }
3825: const Token * tok3@var3679 ; tok3@var3679 =@expr1073757468 v@var3678 .@expr1073757469 tokvalue@var3680 ;
3826: for (@expr1073757470 const LifetimeToken &@expr15571 lt@var3681 :@expr1073757472 getLifetimeTokens (@expr1073757473 tok3@var3679 ) ) {
3827: if (@expr1073757474 !@expr15575 settings@var3662 .@expr15576 certainty@var3667 .@expr15577 isEnabled (@expr15578 Certainty ::@expr15579 inconclusive@expr15555 ) &&@expr1073757480 lt@var3681 .@expr15657 inconclusive@var3682 ) {
3828: continue ; }
3829: std ::@expr1073757482 list < std ::@expr15565 pair < const Token *@expr15566 , std ::@expr15565 string > > er@var3683 ; er@var3683 =@expr1073757486 v@var3678 .@expr1073757487 errorPath@var3684 ;
3830: er@var3683 .@expr15664 insert (@expr1073757489 er@var3683 .@expr15666 end (@expr15667 ) , lt@var3681 .@expr15668 errorPath@var3685 .@expr1073757493 begin (@expr1073757494 ) , lt@var3681 .@expr15668 errorPath@var3685 .@expr1073757496 end (@expr1073757497 ) ) ;
3831: if (@expr1073757498 !@expr1073757499 lt@var3681 .@expr15676 token@var3686 ) {
3832: return false ; }
3833: if (@expr1073757501 !@expr1073757502 pred@var3663 (@expr1073757503 lt@var3681 .@expr15676 token@var3686 ) ) {
3834: return false ; }
3835: er@var3683 .@expr1073757505 emplace_back (@expr1073757506 argtok@var3597 , message@var3598 ) ;
3836: er@var3683 .@expr15664 insert (@expr1073757508 er@var3683 .@expr15666 end (@expr15667 ) , errorPath@var3600 .@expr1073757511 begin (@expr1073757512 ) , errorPath@var3600 .@expr1073757513 end (@expr1073757514 ) ) ;
3837:
3838: ValueFlow ::@expr1073757515 Value value@var3687 ;
3839: value@var3687 .@expr1073757516 valueType@var3688 =@expr1073757517 ValueFlow ::@expr15585 Value ::@expr15586 ValueType ::@expr15587 LIFETIME ;
3840: value@var3687 .@expr1073757521 lifetimeScope@var3689 =@expr1073757522 v@var3678 .@expr1073757523 lifetimeScope@var3690 ;
3841: value@var3687 .@expr1073757524 path@var3691 =@expr1073757525 v@var3678 .@expr1073757526 path@var3692 ;
3842: value@var3687 .@expr1073757527 tokvalue@var3693 =@expr1073757528 lt@var3681 .@expr15676 token@var3686 ;
3843: value@var3687 .@expr1073757530 capturetok@var3694 =@expr1073757531 argtok@var3597 ;
3844: value@var3687 .@expr1073757532 errorPath@var3695 =@expr1073757533 std ::@expr1073757534 move (@expr1073757535 er@var3683 ) ;
3845: value@var3687 .@expr1073757536 lifetimeKind@var3696 =@expr1073757537 type@var3599 ;
3846: value@var3687 .@expr1073757538 setInconclusive (@expr1073757539 lt@var3681 .@expr15657 inconclusive@var3682 ||@expr1073757541 v@var3678 .@expr1073757542 isInconclusive (@expr1073757543 ) ||@expr1073757544 inconclusive@var3601 ) ;
3847:
3848: if (@expr1073757545 std ::@expr15615 find (@expr1073757547 tok@var3659 .@expr15617 values (@expr15618 ) .@expr15619 begin (@expr15620 ) , tok@var3659 .@expr15617 values (@expr15618 ) .@expr15623 end (@expr15624 ) , value@var3687 ) !=@expr1073757556 tok@var3659 .@expr15617 values (@expr15618 ) .@expr15623 end (@expr15624 ) ) {
3849: continue ; }
3850: setTokenValue (@expr1073757561 tok@var3659 , value@var3687 , tokenlist@var3660 .@expr15631 getSettings (@expr15632 ) ) ;
3851: update@var3664 =@expr1073757564 true ;
3852: }
3853: }
3854: if (@expr1073757565 update@var3664 &&@expr1073757566 forward@var3602 ) {
3855: forwardLifetime (@expr1073757567 tok@var3659 , tokenlist@var3660 , errorLogger@var3661 , settings@var3662 ) ; }
3856: return update@var3664 ;
3857: }
3858:
3859: bool byVal ( Token * tok@var3697 , TokenList * tokenlist@var3698 , ErrorLogger * errorLogger@var3699 , const Settings * settings@var3700 ) const {
3860: return byVal (@expr1073757568 tok@var3697 , tokenlist@var3698 , errorLogger@var3699 , settings@var3700 , [@expr1073757569 ] (@expr1073757570 const Token *@expr1073757571 ) {
3861: return true ;
3862: } ) ;
3863: }
3864:
3865: template < class Predicate >
3866: void byDerefCopy ( Token * tok@var3701 , TokenList * tokenlist@var3702 , ErrorLogger * errorLogger@var3703 , const Settings * settings@var3704 , Predicate pred@var3705 ) const {
3867: if (@expr1073757573 !@expr1073757574 settings@var3704 .@expr1073757575 certainty@var3706 .@expr1073757576 isEnabled (@expr1073757577 Certainty ::@expr1073757578 inconclusive@expr1073757572 ) &&@expr1073757579 inconclusive@var3601 ) {
3868: return ; }
3869: if (@expr1073757580 !@expr1073757581 argtok@var3597 ) {
3870: return ; }
3871: for (@expr1073757582 const ValueFlow ::@expr15759 Value &@expr1073757584 v@var3707 :@expr1073757585 argtok@var3597 .@expr1073757586 values (@expr1073757587 ) ) {
3872: if (@expr1073757588 !@expr1073757589 v@var3707 .@expr1073757590 isLifetimeValue (@expr1073757591 ) ) {
3873: continue ; }
3874: const Token * tok2@var3708 ; tok2@var3708 =@expr1073757592 v@var3707 .@expr1073757593 tokvalue@var3709 ;
3875: std ::@expr1073757594 list < std ::@expr15759 pair < const Token *@expr15772 , std ::@expr15759 string > > er@var3710 ; er@var3710 =@expr1073757598 v@var3707 .@expr1073757599 errorPath@var3711 ;
3876: const Variable * var@var3712 ; var@var3712 =@expr1073757600 getLifetimeVariable (@expr1073757601 tok2@var3708 , er@var3710 ) ;
3877: er@var3710 .@expr1073757602 insert (@expr1073757603 er@var3710 .@expr1073757604 end (@expr1073757605 ) , errorPath@var3600 .@expr1073757606 begin (@expr1073757607 ) , errorPath@var3600 .@expr1073757608 end (@expr1073757609 ) ) ;
3878: if (@expr1073757610 !@expr1073757611 var@var3712 ) {
3879: continue ; }
3880: for (@expr1073757612 const Token *@expr15772 tok3@var3713 =@expr1073757614 tok@var3701 ; tok3@var3713 &&@expr1073757615 tok3@var3713 !=@expr1073757616 var@var3712 .@expr1073757617 declEndToken (@expr1073757618 ) ; tok3@var3713 =@expr1073757619 tok3@var3713 .@expr1073757620 previous (@expr1073757621 ) ) {
3881: if (@expr1073757622 tok3@var3713 .@expr1073757623 varId (@expr1073757624 ) ==@expr1073757625 var@var3712 .@expr1073757626 declarationId (@expr1073757627 ) ) {
3882: LifetimeStore {@expr1073757628 tok3@var3713 , message@var3598 , type@var3599 , inconclusive@var3601 } .@expr1073757629 byVal (@expr1073757630 tok@var3701 , tokenlist@var3702 , errorLogger@var3703 , settings@var3704 , pred@var3705 ) ;
3883: break ;
3884: }
3885: }
3886: }
3887: }
3888:
3889: void byDerefCopy ( Token * tok@var3714 , TokenList * tokenlist@var3715 , ErrorLogger * errorLogger@var3716 , const Settings * settings@var3717 ) const {
3890: byDerefCopy (@expr1073757631 tok@var3714 , tokenlist@var3715 , errorLogger@var3716 , settings@var3717 , [@expr1073757632 ] (@expr1073757633 const Token *@expr1073757634 ) {
3891: return true ;
3892: } ) ;
3893: }
3894:
3895: private:
3896: Context * mContext@var3718 ;
3897: void forwardLifetime ( Token * tok@var3719 , TokenList * tokenlist@var3720 , ErrorLogger * errorLogger@var3721 , const Settings * settings@var3722 ) const {
3898: if (@expr1073757635 mContext@var3718 ) {
3899: mContext@var3718 .@expr1073757636 tok@var3723 =@expr1073757637 tok@var3719 ;
3900: mContext@var3718 .@expr1073757638 tokenlist@var3724 =@expr1073757639 tokenlist@var3720 ;
3901: mContext@var3718 .@expr1073757640 errorLogger@var3725 =@expr1073757641 errorLogger@var3721 ;
3902: mContext@var3718 .@expr1073757642 settings@var3726 =@expr1073757643 settings@var3722 ;
3903: }
3904: valueFlowForwardLifetime (@expr1073757644 tok@var3719 , tokenlist@var3720 , errorLogger@var3721 , settings@var3722 ) ;
3905: }
3906: } ;
3907:
3908: static void valueFlowLifetimeUserConstructor ( Token * tok@var3727 ,
3909: const Function * constructor@var3728 ,
3910: const std :: string & name@var3729 ,
3911: std :: vector < const Token * > args@var3730 ,
3912: TokenList * tokenlist@var3731 ,
3913: ErrorLogger * errorLogger@var3732 ,
3914: const Settings * settings@var3733 )
3915: {
3916: if (@expr1073757645 !@expr1073757646 constructor@var3728 ) {
3917: return ; }
3918: std ::@expr1073757647 unordered_map < const Token *@expr15824 , const Variable *@expr15824 > argToParam@var3734 ;
3919: for (@expr1073757650 unsigned long i@var3735 =@expr1073757651 0 ; i@var3735 <@expr1073757652 args@var3730 .@expr1073757653 size (@expr1073757654 ) ; i@var3735 ++@expr1073757655 ) {
3920: argToParam@var3734 [@expr1073757656 args@var3730 [@expr1073757657 i@var3735 ] ] =@expr1073757658 constructor@var3728 .@expr1073757659 getArgumentVar (@expr1073757660 i@var3735 ) ; }
3921: if (@expr1073757661 const Token *@expr15824 initList@var3736 =@expr1073757663 constructor@var3728 .@expr1073757664 constructorMemberInitialization (@expr1073757665 ) ) {
3922: std ::@expr1073757666 unordered_map < const Variable *@expr15824 , LifetimeCapture > paramCapture@var3737 ;
3923: for (@expr1073757668 const Token *@expr15824 tok2@var3738 :@expr1073757670 astFlatten (@expr1073757671 initList@var3736 .@expr1073757672 astOperand2 (@expr1073757673 ) , "," ) ) {
3924: if (@expr1073757674 !@expr1073757675 Token ::@expr1073757676 simpleMatch (@expr1073757677 tok2@var3738 , "(" ) ) {
3925: continue ; }
3926: if (@expr1073757678 !@expr1073757679 tok2@var3738 .@expr15856 astOperand1 (@expr15857 ) ) {
3927: continue ; }
3928: if (@expr1073757682 !@expr1073757683 tok2@var3738 .@expr15860 astOperand2 (@expr15861 ) ) {
3929: continue ; }
3930: const Variable * var@var3739 ; var@var3739 =@expr1073757686 tok2@var3738 .@expr15856 astOperand1 (@expr15857 ) .@expr1073757689 variable (@expr1073757690 ) ;
3931: const Token * expr@var3740 ; expr@var3740 =@expr1073757691 tok2@var3738 .@expr15860 astOperand2 (@expr15861 ) ;
3932: if (@expr1073757694 !@expr1073757695 var@var3739 ) {
3933: continue ; }
3934: if (@expr1073757696 !@expr1073757697 isLifetimeBorrowed (@expr1073757698 expr@var3740 , settings@var3733 ) ) {
3935: continue ; }
3936: const Variable * argvar@var3741 ; argvar@var3741 =@expr1073757699 getLifetimeVariable (@expr1073757700 expr@var3740 ) ;
3937: if (@expr1073757701 var@var3739 .@expr1073757702 isReference (@expr1073757703 ) ||@expr1073757704 var@var3739 .@expr1073757705 isRValueReference (@expr1073757706 ) ) {
3938: if (@expr1073757707 argvar@var3741 &&@expr1073757708 argvar@var3741 .@expr15885 isArgument (@expr15886 ) &&@expr1073757711 (@expr1073757712 argvar@var3741 .@expr1073757713 isReference (@expr1073757714 ) ||@expr1073757715 argvar@var3741 .@expr1073757716 isRValueReference (@expr1073757717 ) ) ) {
3939: paramCapture@var3737 [@expr15894 argvar@var3741 ] =@expr1073757719 LifetimeCapture ::@expr15896 ByReference ;
3940: }
3941: } else {
3942: bool found@var3742 ; found@var3742 =@expr1073757721 false ;
3943: for (@expr1073757722 const ValueFlow ::@expr1073757723 Value &@expr15900 v@var3743 :@expr1073757725 expr@var3740 .@expr1073757726 values (@expr1073757727 ) ) {
3944: if (@expr1073757728 !@expr1073757729 v@var3743 .@expr1073757730 isLifetimeValue (@expr1073757731 ) ) {
3945: continue ; }
3946: if (@expr1073757732 v@var3743 .@expr1073757733 path@var3744 >@expr1073757734 0 ) {
3947: continue ; }
3948: if (@expr1073757735 !@expr1073757736 v@var3743 .@expr15913 tokvalue@var3745 ) {
3949: continue ; }
3950: const Variable * lifeVar@var3746 ; lifeVar@var3746 =@expr1073757738 v@var3743 .@expr15913 tokvalue@var3745 .@expr1073757740 variable (@expr1073757741 ) ;
3951: if (@expr1073757742 !@expr1073757743 lifeVar@var3746 ) {
3952: continue ; }
3953: LifetimeCapture c@var3747 ; c@var3747 =@expr1073757744 LifetimeCapture ::@expr15921 Undefined ;
3954: if (@expr1073757746 !@expr1073757747 v@var3743 .@expr15924 isArgumentLifetimeValue (@expr15925 ) &&@expr1073757750 (@expr1073757751 lifeVar@var3746 .@expr1073757752 isReference (@expr1073757753 ) ||@expr1073757754 lifeVar@var3746 .@expr1073757755 isRValueReference (@expr1073757756 ) ) ) {
3955: c@var3747 =@expr1073757757 LifetimeCapture ::@expr15896 ByReference ; }
3956: else { if (@expr1073757759 v@var3743 .@expr15924 isArgumentLifetimeValue (@expr15925 ) ) {
3957: c@var3747 =@expr1073757762 LifetimeCapture ::@expr15939 ByValue ; } }
3958: if (@expr1073757764 c@var3747 !=@expr1073757765 LifetimeCapture ::@expr15921 Undefined ) {
3959: paramCapture@var3737 [@expr1073757767 lifeVar@var3746 ] =@expr1073757768 c@var3747 ;
3960: found@var3742 =@expr1073757769 true ;
3961: }
3962: }
3963: if (@expr1073757770 !@expr1073757771 found@var3742 &&@expr1073757772 argvar@var3741 &&@expr1073757773 argvar@var3741 .@expr15885 isArgument (@expr15886 ) ) {
3964: paramCapture@var3737 [@expr15894 argvar@var3741 ] =@expr1073757777 LifetimeCapture ::@expr15939 ByValue ; }
3965: }
3966: }
3967:
3968: LifetimeStore ::@expr15955 forEach (@expr1073757780 args@var3730 ,
3969: "Passed to constructor of '" +@expr15957 name@var3729 +@expr15958 "'." ,
3970: ValueFlow ::@expr15959 Value ::@expr15960 LifetimeKind ::@expr15961 SubObject ,
3971: [@expr1073757786 &@expr15900 ] (@expr1073757788 const LifetimeStore &@expr15900 ls@var3748 ) {
3972: const Variable * paramVar@var3749 ; paramVar@var3749 =@expr1073757790 argToParam@var3734 .@expr15967 at (@expr1073757792 ls@var3748 .@expr1073757793 argtok@var3750 ) ;
3973: if (@expr1073757794 paramCapture@var3737 .@expr1073757795 count (@expr1073757796 paramVar@var3749 ) ==@expr1073757797 0 ) {
3974: return ; }
3975: LifetimeCapture c@var3751 ; c@var3751 =@expr1073757798 paramCapture@var3737 .@expr1073757799 at (@expr1073757800 paramVar@var3749 ) ;
3976: if (@expr1073757801 c@var3751 ==@expr1073757802 LifetimeCapture ::@expr15896 ByReference ) {
3977: ls@var3748 .@expr1073757804 byRef (@expr1073757805 tok@var3727 , tokenlist@var3731 , errorLogger@var3732 , settings@var3733 ) ; }
3978: else {
3979: ls@var3748 .@expr1073757806 byVal (@expr1073757807 tok@var3727 , tokenlist@var3731 , errorLogger@var3732 , settings@var3733 ) ; }
3980: } ) ;
3981: } else { if (@expr1073757808 !@expr1073757809 constructor@var3728 .@expr1073757810 nestedIn@var3752 .@expr1073757811 varlist@var3753 .@expr1073757812 empty (@expr1073757813 ) ) {
3982: LifetimeStore ::@expr15955 forEach (@expr1073757815 args@var3730 ,
3983: "Passed to constructor of '" +@expr15957 name@var3729 +@expr15958 "'." ,
3984: ValueFlow ::@expr15959 Value ::@expr15960 LifetimeKind ::@expr15961 SubObject ,
3985: [@expr1073757821 &@expr15900 ] (@expr1073757823 LifetimeStore &@expr15900 ls@var3754 ) {
3986: ls@var3754 .@expr1073757825 inconclusive@var3755 =@expr1073757826 true ;
3987: const Variable * var@var3756 ; var@var3756 =@expr1073757827 argToParam@var3734 .@expr15967 at (@expr1073757829 ls@var3754 .@expr1073757830 argtok@var3757 ) ;
3988: if (@expr1073757831 var@var3756 &&@expr1073757832 !@expr1073757833 var@var3756 .@expr1073757834 isConst (@expr1073757835 ) &&@expr1073757836 var@var3756 .@expr1073757837 isReference (@expr1073757838 ) ) {
3989: ls@var3754 .@expr1073757839 byRef (@expr1073757840 tok@var3727 , tokenlist@var3731 , errorLogger@var3732 , settings@var3733 ) ; }
3990: else {
3991: ls@var3754 .@expr1073757841 byVal (@expr1073757842 tok@var3727 , tokenlist@var3731 , errorLogger@var3732 , settings@var3733 ) ; }
3992: } ) ;
3993: } }
3994: }
3995:
3996: static void valueFlowLifetimeFunction ( Token * tok@var3758 , TokenList * tokenlist@var3759 , ErrorLogger * errorLogger@var3760 , const Settings * settings@var3761 )
3997: {
3998: if (@expr1073757844 !@expr1073757845 Token ::@expr16022 Match (@expr1073757847 tok@var3758 , "%name% (" ) ) {
3999: return ; }
4000: Token * memtok@var3762 ; memtok@var3762 =@expr1073757848 nullptr ;
4001: if (@expr1073757849 Token ::@expr16022 Match (@expr1073757851 tok@var3758 .@expr16028 astParent (@expr16029 ) , ". %name% (" ) &&@expr1073757854 astIsRHS (@expr1073757855 tok@var3758 ) ) {
4002: memtok@var3762 =@expr1073757856 tok@var3758 .@expr16028 astParent (@expr16029 ) .@expr1073757859 astOperand1 (@expr1073757860 ) ; }
4003: int returnContainer@var3763 ; returnContainer@var3763 =@expr1073757861 settings@var3761 .@expr16038 library@var3764 .@expr1073757863 returnValueContainer (@expr1073757864 tok@var3758 ) ;
4004: if (@expr1073757865 returnContainer@var3763 >=@expr1073757866 0 ) {
4005: std ::@expr1073757867 vector < const Token *@expr16044 > args@var3765 ; args@var3765 =@expr1073757869 getArguments (@expr16046 tok@var3758 ) ;
4006: for (@expr1073757871 int argnr@var3766 =@expr1073757872 1 ; argnr@var3766 <=@expr1073757873 args@var3765 .@expr1073757874 size (@expr1073757875 ) ; ++@expr1073757876 argnr@var3766 ) {
4007: const Library ::@expr1073757877 ArgumentChecks ::@expr1073757878 IteratorInfo * i@var3767 ; i@var3767 =@expr1073757879 settings@var3761 .@expr16038 library@var3764 .@expr1073757881 getArgIteratorInfo (@expr1073757882 tok@var3758 , argnr@var3766 ) ;
4008: if (@expr1073757883 !@expr1073757884 i@var3767 ) {
4009: continue ; }
4010: if (@expr1073757885 i@var3767 .@expr1073757886 container@var3768 !=@expr1073757887 returnContainer@var3763 ) {
4011: continue ; }
4012: const Token * const argTok@var3769 ; argTok@var3769 =@expr1073757888 args@var3765 [@expr1073757889 argnr@var3766 -@expr1073757890 1 ] ;
4013: bool forward@var3770 ; forward@var3770 =@expr1073757891 false ;
4014: for (@expr1073757892 ValueFlow ::@expr16069 Value val@var3771 :@expr1073757894 argTok@var3769 .@expr1073757895 values (@expr1073757896 ) ) {
4015: if (@expr1073757897 !@expr1073757898 val@var3771 .@expr1073757899 isLifetimeValue (@expr1073757900 ) ) {
4016: continue ; }
4017: val@var3771 .@expr1073757901 errorPath@var3772 .@expr1073757902 emplace_back (@expr1073757903 argTok@var3769 , "Passed to '" +@expr16080 tok@var3758 .@expr16081 str (@expr16082 ) +@expr16083 "'." ) ;
4018: setTokenValue (@expr1073757908 tok@var3758 .@expr16085 next (@expr16086 ) , val@var3771 , settings@var3761 ) ;
4019: forward@var3770 =@expr1073757911 true ;
4020: }
4021:
4022: if (@expr1073757912 forward@var3770 ) {
4023: valueFlowForwardLifetime (@expr1073757913 tok@var3758 , tokenlist@var3759 , errorLogger@var3760 , settings@var3761 ) ;
4024: break ;
4025: }
4026: }
4027: } else { if (@expr1073757914 Token ::@expr16022 Match (@expr1073757916 tok@var3758 .@expr16093 tokAt (@expr16094 -2 ) , "std :: ref|cref|tie|front_inserter|back_inserter" ) ) {
4028: for (@expr1073757919 const Token *@expr16044 argtok@var3773 :@expr1073757921 getArguments (@expr16046 tok@var3758 ) ) {
4029: LifetimeStore {@expr1073757923 argtok@var3773 , "Passed to '" +@expr16080 tok@var3758 .@expr16081 str (@expr16082 ) +@expr16083 "'." , ValueFlow ::@expr16104 Value ::@expr16105 LifetimeKind ::@expr16106 Object@expr16019 } .@expr1073757931 byRef (@expr1073757932
4030: tok@var3758 .@expr16085 next (@expr16086 ) , tokenlist@var3759 , errorLogger@var3760 , settings@var3761 ) ;
4031: }
4032: } else { if (@expr1073757935 Token ::@expr16022 Match (@expr1073757937 tok@var3758 .@expr16093 tokAt (@expr16094 -2 ) , "std :: make_tuple|tuple_cat|make_pair|make_reverse_iterator|next|prev|move|bind" ) ) {
4033: for (@expr1073757940 const Token *@expr16044 argtok@var3774 :@expr1073757942 getArguments (@expr16046 tok@var3758 ) ) {
4034: LifetimeStore {@expr1073757944 argtok@var3774 , "Passed to '" +@expr16080 tok@var3758 .@expr16081 str (@expr16082 ) +@expr16083 "'." , ValueFlow ::@expr16104 Value ::@expr16105 LifetimeKind ::@expr16106 Object@expr16019 } .@expr1073757952 byVal (@expr1073757953
4035: tok@var3758 .@expr16085 next (@expr16086 ) , tokenlist@var3759 , errorLogger@var3760 , settings@var3761 ) ;
4036: }
4037: } else { if (@expr1073757956 memtok@var3762 &&@expr1073757957 Token ::@expr16022 Match (@expr1073757959 tok@var3758 .@expr16028 astParent (@expr16029 ) , ". push_back|push_front|insert|push|assign" ) &&@expr1073757962
4038: astIsContainer (@expr1073757963 memtok@var3762 ) ) {
4039: std ::@expr1073757964 vector < const Token *@expr16044 > args@var3775 ; args@var3775 =@expr1073757966 getArguments (@expr16046 tok@var3758 ) ;
4040: unsigned long n@var3776 ; n@var3776 =@expr1073757968 args@var3775 .@expr1073757969 size (@expr1073757970 ) ;
4041: if (@expr1073757971 n@var3776 >@expr1073757972 1 &&@expr1073757973 Token ::@expr16150 typeStr (@expr1073757975 args@var3775 [@expr16152 n@var3776 -@expr16153 2 ] ) ==@expr1073757978 Token ::@expr16150 typeStr (@expr1073757980 args@var3775 [@expr16157 n@var3776 -@expr16158 1 ] ) &&@expr1073757983
4042: (@expr1073757984 (@expr1073757985 astIsIterator (@expr1073757986 args@var3775 [@expr16152 n@var3776 -@expr16153 2 ] ) &&@expr1073757989 astIsIterator (@expr1073757990 args@var3775 [@expr16157 n@var3776 -@expr16158 1 ] ) ) ||@expr1073757993
4043: (@expr1073757994 astIsPointer (@expr1073757995 args@var3775 [@expr16152 n@var3776 -@expr16153 2 ] ) &&@expr1073757998 astIsPointer (@expr1073757999 args@var3775 [@expr16157 n@var3776 -@expr16158 1 ] ) ) ) ) {
4044: LifetimeStore {@expr1073758002
4045: args@var3775 .@expr16179 back (@expr16180 ) , "Added to container '" +@expr16181 memtok@var3762 .@expr16182 str (@expr16183 ) +@expr16184 "'." , ValueFlow ::@expr16104 Value ::@expr16105 LifetimeKind ::@expr16106 Object@expr16019 }
4046: .@expr1073758012 byDerefCopy (@expr1073758013 memtok@var3762 , tokenlist@var3759 , errorLogger@var3760 , settings@var3761 ) ;
4047: } else { if (@expr1073758014 !@expr1073758015 args@var3775 .@expr1073758016 empty (@expr1073758017 ) &&@expr1073758018 isLifetimeBorrowed (@expr1073758019 args@var3775 .@expr16179 back (@expr16180 ) , settings@var3761 ) ) {
4048: LifetimeStore {@expr1073758022
4049: args@var3775 .@expr16179 back (@expr16180 ) , "Added to container '" +@expr16181 memtok@var3762 .@expr16182 str (@expr16183 ) +@expr16184 "'." , ValueFlow ::@expr16104 Value ::@expr16105 LifetimeKind ::@expr16106 Object@expr16019 }
4050: .@expr1073758032 byVal (@expr1073758033 memtok@var3762 , tokenlist@var3759 , errorLogger@var3760 , settings@var3761 ) ;
4051: } }
4052: } else { if (@expr1073758034 tok@var3758 .@expr16211 function (@expr16212 ) ) {
4053: const Function * f@var3777 ; f@var3777 =@expr1073758037 tok@var3758 .@expr16211 function (@expr16212 ) ;
4054: if (@expr1073758040 f@var3777 .@expr1073758041 isConstructor (@expr1073758042 ) ) {
4055: valueFlowLifetimeUserConstructor (@expr1073758043 tok@var3758 .@expr16085 next (@expr16086 ) , f@var3777 , tok@var3758 .@expr16081 str (@expr16082 ) , getArguments (@expr16046 tok@var3758 ) , tokenlist@var3759 , errorLogger@var3760 , settings@var3761 ) ;
4056: return ;
4057: }
4058: if (@expr1073758049 Function ::@expr1073758050 returnsReference (@expr1073758051 f@var3777 ) ) {
4059: return ; }
4060: std ::@expr1073758052 vector < const Token *@expr16044 > returns@var3778 ; returns@var3778 =@expr1073758054 Function ::@expr1073758055 findReturns (@expr1073758056 f@var3777 ) ;
4061: const bool inconclusive@var3779 =@expr1073758057 returns@var3778 .@expr1073758058 size (@expr1073758059 ) >@expr1073758060 1 ;
4062: bool update@var3780 ; update@var3780 =@expr1073758061 false ;
4063: for (@expr1073758062 const Token *@expr16044 returnTok@var3781 :@expr1073758064 returns@var3778 ) {
4064: if (@expr1073758065 returnTok@var3781 ==@expr1073758066 tok@var3758 ) {
4065: continue ; }
4066: const Variable * returnVar@var3782 ; returnVar@var3782 =@expr1073758067 getLifetimeVariable (@expr1073758068 returnTok@var3781 ) ;
4067: if (@expr1073758069 returnVar@var3782 &&@expr1073758070 returnVar@var3782 .@expr1073758071 isArgument (@expr1073758072 ) &&@expr1073758073 (@expr1073758074 returnVar@var3782 .@expr1073758075 isConst (@expr1073758076 ) ||@expr1073758077 !@expr1073758078 isVariableChanged (@expr1073758079 returnVar@var3782 , settings@var3761 , tokenlist@var3759 .@expr1073758080 isCPP (@expr1073758081 ) ) ) ) {
4068: LifetimeStore ls@var3783 ; ls@var3783 =@expr1073758082 LifetimeStore ::@expr16259 fromFunctionArg (@expr1073758084 f@var3777 , tok@var3758 , returnVar@var3782 , tokenlist@var3759 , errorLogger@var3760 ) ;
4069: ls@var3783 .@expr1073758085 inconclusive@var3784 =@expr1073758086 inconclusive@var3779 ;
4070: ls@var3783 .@expr1073758087 forward@var3785 =@expr1073758088 false ;
4071: update@var3780 |=@expr1073758089 ls@var3783 .@expr1073758090 byVal (@expr1073758091 tok@var3758 .@expr16085 next (@expr16086 ) , tokenlist@var3759 , errorLogger@var3760 , settings@var3761 ) ;
4072: }
4073: for (@expr1073758094 const ValueFlow ::@expr16069 Value &@expr1073758096 v@var3786 :@expr1073758097 returnTok@var3781 .@expr1073758098 values (@expr1073758099 ) ) {
4074: if (@expr1073758100 !@expr1073758101 v@var3786 .@expr1073758102 isLifetimeValue (@expr1073758103 ) ) {
4075: continue ; }
4076: if (@expr1073758104 !@expr1073758105 v@var3786 .@expr16282 tokvalue@var3787 ) {
4077: continue ; }
4078: if (@expr1073758107 memtok@var3762 &&@expr1073758108
4079: (@expr1073758109 contains (@expr1073758110 {@expr1073758111 ValueFlow ::@expr16104 Value ::@expr16289 LifetimeScope ::@expr1073758114 ThisPointer , ValueFlow ::@expr16104 Value ::@expr16289 LifetimeScope ::@expr16293 ThisValue } ,
4080: v@var3786 .@expr16294 lifetimeScope@var3788 ) ||@expr1073758119
4081: exprDependsOnThis (@expr1073758120 v@var3786 .@expr16282 tokvalue@var3787 ) ) ) {
4082: LifetimeStore ls@var3789 ; ls@var3789 =@expr1073758122 LifetimeStore {@expr1073758123 memtok@var3762 ,
4083: "Passed to member function '" +@expr1073758124 tok@var3758 .@expr1073758125 expressionString (@expr1073758126 ) +@expr1073758127 "'." ,
4084: ValueFlow ::@expr16104 Value ::@expr16105 LifetimeKind ::@expr16106 Object@expr16019 } ;
4085: ls@var3789 .@expr1073758131 inconclusive@var3790 =@expr1073758132 inconclusive@var3779 ;
4086: ls@var3789 .@expr1073758133 forward@var3791 =@expr1073758134 false ;
4087: ls@var3789 .@expr16311 errorPath@var3792 =@expr1073758136 v@var3786 .@expr16313 errorPath@var3793 ;
4088: ls@var3789 .@expr16311 errorPath@var3792 .@expr1073758139 emplace_front (@expr1073758140 returnTok@var3781 , "Return " +@expr16317 lifetimeType (@expr16318 returnTok@var3781 , &@expr16319 v@var3786 ) +@expr16320 "." ) ;
4089: if (@expr1073758145 v@var3786 .@expr16294 lifetimeScope@var3788 ==@expr1073758147 ValueFlow ::@expr16104 Value ::@expr16289 LifetimeScope ::@expr16293 ThisValue ) {
4090: update@var3780 |=@expr1073758151 ls@var3789 .@expr1073758152 byVal (@expr1073758153 tok@var3758 .@expr16085 next (@expr16086 ) , tokenlist@var3759 , errorLogger@var3760 , settings@var3761 ) ; }
4091: else {
4092: update@var3780 |=@expr1073758156 ls@var3789 .@expr1073758157 byRef (@expr1073758158 tok@var3758 .@expr16085 next (@expr16086 ) , tokenlist@var3759 , errorLogger@var3760 , settings@var3761 ) ; }
4093: continue ;
4094: }
4095: const Variable * var@var3794 ; var@var3794 =@expr1073758161 v@var3786 .@expr16282 tokvalue@var3787 .@expr1073758163 variable (@expr1073758164 ) ;
4096: LifetimeStore ls@var3795 ; ls@var3795 =@expr1073758165 LifetimeStore ::@expr16259 fromFunctionArg (@expr1073758167 f@var3777 , tok@var3758 , var@var3794 , tokenlist@var3759 , errorLogger@var3760 ) ;
4097: if (@expr1073758168 !@expr1073758169 ls@var3795 .@expr1073758170 argtok@var3796 ) {
4098: continue ; }
4099: ls@var3795 .@expr1073758171 forward@var3797 =@expr1073758172 false ;
4100: ls@var3795 .@expr1073758173 inconclusive@var3798 =@expr1073758174 inconclusive@var3779 ;
4101: ls@var3795 .@expr16351 errorPath@var3799 =@expr1073758176 v@var3786 .@expr16313 errorPath@var3793 ;
4102: ls@var3795 .@expr16351 errorPath@var3799 .@expr1073758179 emplace_front (@expr1073758180 returnTok@var3781 , "Return " +@expr16317 lifetimeType (@expr16318 returnTok@var3781 , &@expr16319 v@var3786 ) +@expr16320 "." ) ;
4103: if (@expr1073758185 !@expr1073758186 v@var3786 .@expr16363 isArgumentLifetimeValue (@expr16364 ) &&@expr1073758189 (@expr1073758190 var@var3794 .@expr1073758191 isReference (@expr1073758192 ) ||@expr1073758193 var@var3794 .@expr1073758194 isRValueReference (@expr1073758195 ) ) ) {
4104: update@var3780 |=@expr1073758196 ls@var3795 .@expr1073758197 byRef (@expr1073758198 tok@var3758 .@expr16085 next (@expr16086 ) , tokenlist@var3759 , errorLogger@var3760 , settings@var3761 ) ;
4105: } else { if (@expr1073758201 v@var3786 .@expr16363 isArgumentLifetimeValue (@expr16364 ) ) {
4106: update@var3780 |=@expr1073758204 ls@var3795 .@expr1073758205 byVal (@expr1073758206 tok@var3758 .@expr16085 next (@expr16086 ) , tokenlist@var3759 , errorLogger@var3760 , settings@var3761 ) ;
4107: } }
4108: }
4109: }
4110: if (@expr1073758209 update@var3780 ) {
4111: valueFlowForwardLifetime (@expr16386 tok@var3758 .@expr16085 next (@expr16086 ) , tokenlist@var3759 , errorLogger@var3760 , settings@var3761 ) ; }
4112: } else { if (@expr1073758213 tok@var3758 .@expr1073758214 valueType (@expr1073758215 ) ) {
4113:
4114: if (@expr1073758216 settings@var3761 .@expr16038 library@var3764 .@expr1073758218 getFunction (@expr1073758219 tok@var3758 .@expr1073758220 previous (@expr1073758221 ) ) ) {
4115: return ; }
4116:
4117: valueFlowLifetimeConstructor (@expr1073758222 tok@var3758 .@expr16085 next (@expr16086 ) , tokenlist@var3759 , errorLogger@var3760 , settings@var3761 ) ;
4118: valueFlowForwardLifetime (@expr16386 tok@var3758 .@expr16085 next (@expr16086 ) , tokenlist@var3759 , errorLogger@var3760 , settings@var3761 ) ;
4119: } } } } } }
4120: }
4121:
4122: static bool isScope ( const Token * tok@var3800 )
4123: {
4124: if (@expr1073758228 !@expr1073758229 tok@var3800 ) {
4125: return false ; }
4126: if (@expr1073758230 !@expr1073758231 Token ::@expr1073758232 simpleMatch (@expr1073758233 tok@var3800 , "{" ) ) {
4127: return false ; }
4128: const Scope * scope@var3801 ; scope@var3801 =@expr1073758234 tok@var3800 .@expr1073758235 scope (@expr1073758236 ) ;
4129: if (@expr1073758237 !@expr1073758238 scope@var3801 ) {
4130: return false ; }
4131: if (@expr1073758239 !@expr1073758240 scope@var3801 .@expr16417 bodyStart@var3802 ) {
4132: return false ; }
4133: return scope@var3801 .@expr16417 bodyStart@var3802 ==@expr1073758243 tok@var3800 ;
4134: }
4135:
4136: static const Function * findConstructor ( const Scope * scope@var3803 , const Token * tok@var3804 , const std :: vector < const Token * > & args@var3805 )
4137: {
4138: if (@expr1073758244 !@expr1073758245 tok@var3804 ) {
4139: return nullptr ; }
4140: const Function * f@var3806 ; f@var3806 =@expr1073758246 tok@var3804 .@expr1073758247 function (@expr1073758248 ) ;
4141: if (@expr1073758249 !@expr16426 f@var3806 &&@expr1073758251 tok@var3804 .@expr16428 astOperand1 (@expr16429 ) ) {
4142: f@var3806 =@expr1073758254 tok@var3804 .@expr16428 astOperand1 (@expr16429 ) .@expr1073758257 function (@expr1073758258 ) ; }
4143:
4144: if (@expr1073758259 !@expr16426 f@var3806 ||@expr1073758261 !@expr1073758262 f@var3806 .@expr1073758263 isConstructor (@expr1073758264 ) ) {
4145: f@var3806 =@expr1073758265 nullptr ;
4146: std ::@expr1073758266 vector < const Function *@expr1073758267 > candidates@var3807 ;
4147: for (@expr1073758268 const Function &@expr1073758269 function@var3808 :@expr1073758270 scope@var3803 .@expr1073758271 functionList@var3809 ) {
4148: if (@expr1073758272 function@var3808 .@expr1073758273 argCount (@expr1073758274 ) !=@expr1073758275 args@var3805 .@expr1073758276 size (@expr1073758277 ) ) {
4149: continue ; }
4150: if (@expr1073758278 !@expr1073758279 function@var3808 .@expr1073758280 isConstructor (@expr1073758281 ) ) {
4151: continue ; }
4152: candidates@var3807 .@expr1073758282 push_back (@expr1073758283 &@expr1073758284 function@var3808 ) ;
4153: }
4154:
4155: if (@expr1073758285 candidates@var3807 .@expr1073758286 size (@expr1073758287 ) ==@expr1073758288 1 ) {
4156: f@var3806 =@expr1073758289 candidates@var3807 .@expr1073758290 front (@expr1073758291 ) ; }
4157: }
4158: if (@expr1073758292 !@expr16426 f@var3806 ) {
4159: return nullptr ; }
4160: return f@var3806 ;
4161: }
4162:
4163: static void valueFlowLifetimeClassConstructor ( Token * tok@var3810 ,
4164: const Type * t@var3811 ,
4165: TokenList * tokenlist@var3812 ,
4166: ErrorLogger * errorLogger@var3813 ,
4167: const Settings * settings@var3814 )
4168: {
4169: if (@expr1073758294 !@expr1073758295 Token ::@expr16472 Match (@expr1073758297 tok@var3810 , "(|{" ) ) {
4170: return ; }
4171: if (@expr1073758298 isScope (@expr1073758299 tok@var3810 ) ) {
4172: return ; }
4173: if (@expr1073758300 !@expr1073758301 t@var3811 ) {
4174: if (@expr1073758302 tok@var3810 .@expr16479 valueType (@expr16480 ) &&@expr1073758305 tok@var3810 .@expr16479 valueType (@expr16480 ) .@expr1073758308 type@var5318 !=@expr1073758309 ValueType ::@expr1073758310 RECORD ) {
4175: return ; }
4176: if (@expr1073758311 tok@var3810 .@expr1073758312 str (@expr1073758313 ) !=@expr1073758314 "{" &&@expr1073758315 !@expr1073758316 Token ::@expr16472 Match (@expr1073758318 tok@var3810 .@expr16495 previous (@expr16496 ) , "%var% (" ) &&@expr1073758321 !@expr1073758322 isVariableDecl (@expr1073758323 tok@var3810 .@expr16495 previous (@expr16496 ) ) ) {
4177: return ; }
4178:
4179:
4180: std ::@expr1073758326 vector < const Token *@expr16503 > args@var3815 ; args@var3815 =@expr1073758328 getArguments (@expr16505 tok@var3810 ) ;
4181: LifetimeStore ::@expr16506 forEach (@expr1073758331 args@var3815 ,
4182: "Passed to initializer list." ,
4183: ValueFlow ::@expr16508 Value ::@expr16509 LifetimeKind ::@expr16510 SubObject ,
4184: [@expr1073758335 &@expr16512 ] (@expr1073758337 LifetimeStore &@expr16512 ls@var3816 ) {
4185: ls@var3816 .@expr1073758339 inconclusive@var3817 =@expr1073758340 true ;
4186: ls@var3816 .@expr1073758341 byVal (@expr1073758342 tok@var3810 , tokenlist@var3812 , errorLogger@var3813 , settings@var3814 ) ;
4187: } ) ;
4188: return ;
4189: }
4190: const Scope * scope@var3818 ; scope@var3818 =@expr1073758343 t@var3811 .@expr1073758344 classScope@var3819 ;
4191: if (@expr1073758345 !@expr1073758346 scope@var3818 ) {
4192: return ; }
4193:
4194: if (@expr1073758347 t@var3811 .@expr1073758348 derivedFrom@var3820 .@expr1073758349 empty (@expr1073758350 ) &&@expr1073758351 (@expr1073758352 t@var3811 .@expr1073758353 isClassType (@expr1073758354 ) ||@expr1073758355 t@var3811 .@expr1073758356 isStructType (@expr1073758357 ) ) ) {
4195: std ::@expr1073758358 vector < const Token *@expr16503 > args@var3821 ; args@var3821 =@expr1073758360 getArguments (@expr16505 tok@var3810 ) ;
4196: if (@expr1073758362 scope@var3818 .@expr1073758363 numConstructors@var3822 ==@expr1073758364 0 ) {
4197: auto it@var3823 ; it@var3823 =@expr1073758365 scope@var3818 .@expr16542 varlist@var3824 .@expr1073758367 begin (@expr1073758368 ) ;
4198: LifetimeStore ::@expr16506 forEach (@expr1073758370 args@var3821 ,
4199: "Passed to constructor of '" +@expr1073758371 t@var3811 .@expr16548 name (@expr16549 ) +@expr1073758374 "'." ,
4200: ValueFlow ::@expr16508 Value ::@expr16509 LifetimeKind ::@expr16510 SubObject ,
4201: [@expr1073758378 &@expr16512 ] (@expr1073758380 const LifetimeStore &@expr16512 ls@var3825 ) {
4202: if (@expr1073758382 it@var3823 ==@expr1073758383 scope@var3818 .@expr16542 varlist@var3824 .@expr1073758385 end (@expr1073758386 ) ) {
4203: return ; }
4204: const Variable &@expr16512 var@var3826 =@expr1073758388 *@expr1073758389 it@var3823 ;
4205: if (@expr1073758390 var@var3826 .@expr1073758391 isReference (@expr1073758392 ) ||@expr1073758393 var@var3826 .@expr1073758394 isRValueReference (@expr1073758395 ) ) {
4206: ls@var3825 .@expr1073758396 byRef (@expr1073758397 tok@var3810 , tokenlist@var3812 , errorLogger@var3813 , settings@var3814 ) ;
4207: } else {
4208: ls@var3825 .@expr1073758398 byVal (@expr1073758399 tok@var3810 , tokenlist@var3812 , errorLogger@var3813 , settings@var3814 ) ;
4209: }
4210: it@var3823 ++@expr1073758400 ;
4211: } ) ;
4212: } else {
4213: const Function * constructor@var3827 ; constructor@var3827 =@expr1073758401 findConstructor (@expr1073758402 scope@var3818 , tok@var3810 , args@var3821 ) ;
4214: valueFlowLifetimeUserConstructor (@expr1073758403 tok@var3810 , constructor@var3827 , t@var3811 .@expr16548 name (@expr16549 ) , args@var3821 , tokenlist@var3812 , errorLogger@var3813 , settings@var3814 ) ;
4215: }
4216: }
4217: }
4218:
4219: static void valueFlowLifetimeConstructor ( Token * tok@var3828 , TokenList * tokenlist@var3829 , ErrorLogger * errorLogger@var3830 , const Settings * settings@var3831 )
4220: {
4221: if (@expr1073758406 !@expr1073758407 Token ::@expr16584 Match (@expr1073758409 tok@var3828 , "(|{" ) ) {
4222: return ; }
4223: if (@expr1073758410 isScope (@expr1073758411 tok@var3828 ) ) {
4224: return ; }
4225: std ::@expr1073758412 vector < ValueType > vts@var3832 ;
4226: if (@expr1073758413 tok@var3828 .@expr16590 valueType (@expr16591 ) ) {
4227: vts@var3832 =@expr1073758416 {@expr1073758417 *@expr1073758418 tok@var3828 .@expr16590 valueType (@expr16591 ) } ;
4228: } else { if (@expr1073758421 Token ::@expr16584 Match (@expr1073758423 tok@var3828 .@expr16600 previous (@expr16601 ) , "%var% {|(" ) &&@expr1073758426 isVariableDecl (@expr1073758427 tok@var3828 .@expr16600 previous (@expr16601 ) ) &&@expr1073758430
4229: tok@var3828 .@expr16600 previous (@expr16601 ) .@expr16609 valueType (@expr16610 ) ) {
4230: vts@var3832 =@expr1073758435 {@expr1073758436 *@expr1073758437 tok@var3828 .@expr16600 previous (@expr16601 ) .@expr16609 valueType (@expr16610 ) } ;
4231: } else { if (@expr1073758442 Token ::@expr1073758443 simpleMatch (@expr1073758444 tok@var3828 , "{" ) &&@expr1073758445 !@expr1073758446 Token ::@expr16584 Match (@expr1073758448 tok@var3828 .@expr16600 previous (@expr16601 ) , "%name%" ) ) {
4232: vts@var3832 =@expr1073758451 getParentValueTypes (@expr1073758452 tok@var3828 , settings@var3831 ) ;
4233: } } }
4234:
4235: for (@expr1073758453 const ValueType &@expr16630 vt@var3833 :@expr1073758455 vts@var3832 ) {
4236: if (@expr1073758456 vt@var3833 .@expr1073758457 pointer@var3834 >@expr1073758458 0 ) {
4237: std ::@expr1073758459 vector < const Token *@expr16636 > args@var3835 ; args@var3835 =@expr1073758461 getArguments (@expr16638 tok@var3828 ) ;
4238: LifetimeStore ::@expr16639 forEach (@expr1073758464 args@var3835 ,
4239: "Passed to initializer list." ,
4240: ValueFlow ::@expr16641 Value ::@expr16642 LifetimeKind ::@expr16643 SubObject ,
4241: [@expr1073758468 &@expr16630 ] (@expr1073758470 const LifetimeStore &@expr16630 ls@var3836 ) {
4242: ls@var3836 .@expr1073758472 byVal (@expr1073758473 tok@var3828 , tokenlist@var3829 , errorLogger@var3830 , settings@var3831 ) ;
4243: } ) ;
4244: } else { if (@expr1073758474 vt@var3833 .@expr16651 container@var3837 &&@expr1073758476 vt@var3833 .@expr1073758477 type@var3838 ==@expr1073758478 ValueType ::@expr1073758479 CONTAINER ) {
4245: std ::@expr1073758480 vector < const Token *@expr16636 > args@var3839 ; args@var3839 =@expr1073758482 getArguments (@expr16638 tok@var3828 ) ;
4246: if (@expr1073758484 args@var3839 .@expr16661 size (@expr16662 ) ==@expr1073758487 1 &&@expr1073758488 vt@var3833 .@expr16651 container@var3837 .@expr1073758490 view@var3840 &&@expr1073758491 astIsContainerOwned (@expr1073758492 args@var3839 .@expr16669 front (@expr16670 ) ) ) {
4247: LifetimeStore {@expr1073758495 args@var3839 .@expr16669 front (@expr16670 ) , "Passed to container view." , ValueFlow ::@expr16641 Value ::@expr16642 LifetimeKind ::@expr16643 SubObject }
4248: .@expr1073758501 byRef (@expr1073758502 tok@var3828 , tokenlist@var3829 , errorLogger@var3830 , settings@var3831 ) ;
4249: } else { if (@expr1073758503 args@var3839 .@expr16661 size (@expr16662 ) ==@expr1073758506 2 &&@expr1073758507 astIsIterator (@expr1073758508 args@var3839 [@expr1073758509 0 ] ) &&@expr1073758510 astIsIterator (@expr1073758511 args@var3839 [@expr1073758512 1 ] ) ) {
4250: LifetimeStore ::@expr16639 forEach (@expr1073758514
4251: args@var3839 ,
4252: "Passed to initializer list." ,
4253: ValueFlow ::@expr16641 Value ::@expr16642 LifetimeKind ::@expr16643 SubObject ,
4254: [@expr1073758518 &@expr16630 ] (@expr1073758520 const LifetimeStore &@expr16630 ls@var3841 ) {
4255: ls@var3841 .@expr1073758522 byDerefCopy (@expr1073758523 tok@var3828 , tokenlist@var3829 , errorLogger@var3830 , settings@var3831 ) ;
4256: } ) ;
4257: } else { if (@expr1073758524 vt@var3833 .@expr16651 container@var3837 .@expr1073758526 hasInitializerListConstructor@var3842 ) {
4258: LifetimeStore ::@expr16639 forEach (@expr1073758528 args@var3839 ,
4259: "Passed to initializer list." ,
4260: ValueFlow ::@expr16641 Value ::@expr16642 LifetimeKind ::@expr16643 SubObject ,
4261: [@expr1073758532 &@expr16630 ] (@expr1073758534 const LifetimeStore &@expr16630 ls@var3843 ) {
4262: ls@var3843 .@expr1073758536 byVal (@expr1073758537 tok@var3828 , tokenlist@var3829 , errorLogger@var3830 , settings@var3831 ) ;
4263: } ) ;
4264: } } }
4265: } else {
4266: const Type * t@var3844 ; t@var3844 =@expr1073758538 nullptr ;
4267: if (@expr1073758539 vt@var3833 .@expr16716 typeScope@var3845 &&@expr1073758541 vt@var3833 .@expr16716 typeScope@var3845 .@expr16719 definedType@var3846 ) {
4268: t@var3844 =@expr1073758544 vt@var3833 .@expr16716 typeScope@var3845 .@expr16719 definedType@var3846 ; }
4269: else {
4270: t@var3844 =@expr1073758547 Token ::@expr1073758548 typeOf (@expr1073758549 tok@var3828 .@expr16600 previous (@expr16601 ) ) ; }
4271: valueFlowLifetimeClassConstructor (@expr1073758552 tok@var3828 , t@var3844 , tokenlist@var3829 , errorLogger@var3830 , settings@var3831 ) ;
4272: } }
4273: }
4274: }
4275:
4276: struct Lambda {
4277: explicit Lambda ( const Token * tok@var3847 )
4278: : capture@var3851 ( nullptr ) ,
4279: arguments@var3852 ( nullptr ) ,
4280: returnTok@var3853 ( nullptr ) ,
4281: bodyTok@var3854 ( nullptr ) ,
4282: explicitCaptures@var3855 ( ) ,
4283: implicitCapture@var3856 ( LifetimeCapture :: Undefined )
4284: {
4285: if (@expr1073758553 !@expr1073758554 Token ::@expr16731 simpleMatch (@expr1073758556 tok@var3847 , "[" ) ||@expr1073758557 !@expr1073758558 tok@var3847 .@expr1073758559 link (@expr1073758560 ) ) {
4286: return ; }
4287: capture@var3851 =@expr1073758561 tok@var3847 ;
4288:
4289: if (@expr1073758562 Token ::@expr16731 simpleMatch (@expr1073758564 capture@var3851 .@expr16741 link (@expr16742 ) , "] (" ) ) {
4290: arguments@var3852 =@expr1073758567 capture@var3851 .@expr16741 link (@expr16742 ) .@expr16746 next (@expr16747 ) ;
4291: }
4292: const Token * afterArguments@var3848 ; afterArguments@var3848 =@expr1073758572 arguments@var3852 ?@expr1073758573 arguments@var3852 .@expr1073758574 link (@expr1073758575 ) .@expr1073758576 next (@expr1073758577 ) :@expr1073758578 capture@var3851 .@expr16741 link (@expr16742 ) .@expr16746 next (@expr16747 ) ;
4293: if (@expr1073758583 afterArguments@var3848 &&@expr1073758584 afterArguments@var3848 .@expr1073758585 originalName (@expr1073758586 ) ==@expr1073758587 "->" ) {
4294: returnTok@var3853 =@expr1073758588 afterArguments@var3848 .@expr1073758589 next (@expr1073758590 ) ;
4295: bodyTok@var3854 =@expr1073758591 Token ::@expr1073758592 findsimplematch (@expr1073758593 returnTok@var3853 , "{" ) ;
4296: } else { if (@expr1073758594 Token ::@expr16731 simpleMatch (@expr1073758596 afterArguments@var3848 , "{" ) ) {
4297: bodyTok@var3854 =@expr1073758597 afterArguments@var3848 ;
4298: } }
4299: for (@expr1073758598 const Token *@expr1073758599 c@var3849 :@expr1073758600 getCaptures (@expr1073758601 ) ) {
4300: if (@expr1073758602 Token ::@expr16779 Match (@expr1073758604 c@var3849 , "this !!." ) ) {
4301: explicitCaptures@var3855 [@expr16781 c@var3849 .@expr16782 variable (@expr16783 ) ] =@expr1073758608 std ::@expr16785 make_pair (@expr1073758610 c@var3849 , LifetimeCapture ::@expr16787 ByReference ) ;
4302: } else { if (@expr1073758612 Token ::@expr16731 simpleMatch (@expr1073758614 c@var3849 , "* this" ) ) {
4303: explicitCaptures@var3855 [@expr1073758615 c@var3849 .@expr16792 next (@expr16793 ) .@expr1073758618 variable (@expr1073758619 ) ] =@expr1073758620 std ::@expr16785 make_pair (@expr1073758622 c@var3849 .@expr16792 next (@expr16793 ) , LifetimeCapture ::@expr16801 ByValue ) ;
4304: } else { if (@expr1073758626 c@var3849 .@expr16782 variable (@expr16783 ) ) {
4305: explicitCaptures@var3855 [@expr16781 c@var3849 .@expr16782 variable (@expr16783 ) ] =@expr1073758632 std ::@expr16785 make_pair (@expr1073758634 c@var3849 , LifetimeCapture ::@expr16801 ByValue ) ;
4306: } else { if (@expr1073758636 c@var3849 .@expr1073758637 isUnaryOp (@expr1073758638 "&" ) &&@expr1073758639 Token ::@expr16779 Match (@expr1073758641 c@var3849 .@expr16818 astOperand1 (@expr16819 ) , "%var%" ) ) {
4307: explicitCaptures@var3855 [@expr1073758644 c@var3849 .@expr16818 astOperand1 (@expr16819 ) .@expr1073758647 variable (@expr1073758648 ) ] =@expr1073758649
4308: std ::@expr16785 make_pair (@expr1073758651 c@var3849 .@expr16818 astOperand1 (@expr16819 ) , LifetimeCapture ::@expr16787 ByReference ) ;
4309: } else {
4310: const std ::@expr1073758655 string &@expr1073758656 s@var3850 =@expr1073758657 c@var3849 .@expr1073758658 expressionString (@expr1073758659 ) ;
4311: if (@expr1073758660 s@var3850 ==@expr1073758661 "=" ) {
4312: implicitCapture@var3856 =@expr1073758662 LifetimeCapture ::@expr16801 ByValue ; }
4313: else { if (@expr1073758664 s@var3850 ==@expr1073758665 "&" ) {
4314: implicitCapture@var3856 =@expr1073758666 LifetimeCapture ::@expr16787 ByReference ; } }
4315: } } } }
4316: }
4317: }
4318:
4319: const Token * capture@var3851 ;
4320: const Token * arguments@var3852 ;
4321: const Token * returnTok@var3853 ;
4322: const Token * bodyTok@var3854 ;
4323: std :: unordered_map < const Variable * , std :: pair < const Token * , LifetimeCapture > > explicitCaptures@var3855 ;
4324: LifetimeCapture implicitCapture@var3856 ;
4325:
4326: std :: vector < const Token * > getCaptures ( ) {
4327: return getArguments (@expr1073758668 capture@var3851 ) ;
4328: }
4329:
4330: bool isLambda ( ) const {
4331: return capture@var3851 &&@expr1073758669 bodyTok@var3854 ;
4332: }
4333: } ;
4334:
4335: static bool isDecayedPointer ( const Token * tok@var3857 )
4336: {
4337: if (@expr1073758670 !@expr1073758671 tok@var3857 ) {
4338: return false ; }
4339: if (@expr1073758672 !@expr1073758673 tok@var3857 .@expr16850 astParent (@expr16851 ) ) {
4340: return false ; }
4341: if (@expr1073758676 astIsPointer (@expr16853 tok@var3857 .@expr16850 astParent (@expr16851 ) ) &&@expr1073758680 !@expr16857 Token ::@expr16858 simpleMatch (@expr16859 tok@var3857 .@expr16850 astParent (@expr16851 ) , "return" ) ) {
4342: return true ; }
4343: if (@expr1073758686 tok@var3857 .@expr16850 astParent (@expr16851 ) .@expr1073758689 isConstOp (@expr1073758690 ) ) {
4344: return true ; }
4345: if (@expr1073758691 !@expr16857 Token ::@expr16858 simpleMatch (@expr16859 tok@var3857 .@expr16850 astParent (@expr16851 ) , "return" ) ) {
4346: return false ; }
4347: return astIsPointer (@expr16853 tok@var3857 .@expr16850 astParent (@expr16851 ) ) ;
4348: }
4349:
4350: static bool isConvertedToView ( const Token * tok@var3858 , const Settings * settings@var3859 )
4351: {
4352: std ::@expr1073758700 vector < ValueType > vtParents@var3860 ; vtParents@var3860 =@expr1073758701 getParentValueTypes (@expr1073758702 tok@var3858 , settings@var3859 ) ;
4353: return std ::@expr1073758703 any_of (@expr1073758704 vtParents@var3860 .@expr1073758705 begin (@expr1073758706 ) , vtParents@var3860 .@expr1073758707 end (@expr1073758708 ) , [@expr1073758709 &@expr16886 ] (@expr1073758711 const ValueType &@expr16886 vt@var3861 ) {
4354: if (@expr1073758713 !@expr1073758714 vt@var3861 .@expr16891 container@var3862 ) {
4355: return false ; }
4356: return vt@var3861 .@expr16891 container@var3862 .@expr1073758717 view@var3863 ;
4357: } ) ;
4358: }
4359:
4360: static void valueFlowLifetime ( TokenList * tokenlist@var3864 , SymbolDatabase * , ErrorLogger * errorLogger@var3865 , const Settings * settings@var3866 )
4361: {
4362: for (@expr1073758721 Token *@expr16898 tok@var3867 =@expr1073758723 tokenlist@var3864 .@expr1073758724 front (@expr1073758725 ) ; tok@var3867 ; tok@var3867 =@expr1073758726 tok@var3867 .@expr16903 next (@expr16904 ) ) {
4363: if (@expr1073758729 !@expr1073758730 tok@var3867 .@expr16907 scope (@expr16908 ) ) {
4364: continue ; }
4365: if (@expr1073758733 tok@var3867 .@expr16907 scope (@expr16908 ) .@expr1073758736 type@var5332 ==@expr1073758737 Scope ::@expr1073758738 eGlobal ) {
4366: continue ; }
4367: Lambda lam@var3868 (@expr1073758739 tok@var3867 ) ;
4368:
4369: if (@expr1073758740 lam@var3868 .@expr1073758741 isLambda (@expr1073758742 ) ) {
4370: const Scope * bodyScope@var3869 ; bodyScope@var3869 =@expr1073758743 lam@var3868 .@expr16920 bodyTok@var3870 .@expr1073758745 scope (@expr1073758746 ) ;
4371:
4372: std ::@expr1073758747 set < const Scope *@expr16898 > scopes@var3871 ;
4373:
4374: std ::@expr1073758749 set < int > varids@var3872 ;
4375: bool capturedThis@var3873 ; capturedThis@var3873 =@expr1073758750 false ;
4376:
4377: auto isImplicitCapturingVariable@var3874 ; isImplicitCapturingVariable@var3874 =@expr1073758751 [@expr1073758752 &@expr16929 ] (@expr1073758754 const Token *@expr16898 varTok@var3875 ) {
4378: const Variable * var@var3876 ; var@var3876 =@expr1073758756 varTok@var3875 .@expr1073758757 variable (@expr1073758758 ) ;
4379: if (@expr1073758759 !@expr1073758760 var@var3876 ) {
4380: return false ; }
4381: if (@expr1073758761 varids@var3872 .@expr16938 count (@expr1073758763 var@var3876 .@expr16940 declarationId (@expr16941 ) ) >@expr1073758766 0 ) {
4382: return false ; }
4383: if (@expr1073758767 !@expr1073758768 var@var3876 .@expr1073758769 isLocal (@expr1073758770 ) &&@expr1073758771 !@expr1073758772 var@var3876 .@expr1073758773 isArgument (@expr1073758774 ) ) {
4384: return false ; }
4385: const Scope * scope@var3877 ; scope@var3877 =@expr1073758775 var@var3876 .@expr1073758776 scope (@expr1073758777 ) ;
4386: if (@expr1073758778 !@expr1073758779 scope@var3877 ) {
4387: return false ; }
4388: if (@expr1073758780 scopes@var3871 .@expr1073758781 count (@expr1073758782 scope@var3877 ) >@expr1073758783 0 ) {
4389: return false ; }
4390: if (@expr1073758784 scope@var3877 .@expr1073758785 isNestedIn (@expr1073758786 bodyScope@var3869 ) ) {
4391: return false ; }
4392: scopes@var3871 .@expr1073758787 insert (@expr1073758788 scope@var3877 ) ;
4393: varids@var3872 .@expr16965 insert (@expr1073758790 var@var3876 .@expr16940 declarationId (@expr16941 ) ) ;
4394: return true ;
4395: } ;
4396:
4397: bool update@var3878 ; update@var3878 =@expr1073758793 false ;
4398: auto captureVariable@var3879 ; captureVariable@var3879 =@expr1073758794 [@expr1073758795 &@expr16929 ] (@expr1073758797 const Token *@expr16898 tok2@var3880 , LifetimeCapture c@var3881 , std ::@expr16975 function < bool (@expr16976 const Token *@expr16898 ) > pred@var3882 ) {
4399: if (@expr1073758802 varids@var3872 .@expr16938 count (@expr1073758804 tok@var3867 .@expr1073758805 varId (@expr1073758806 ) ) >@expr1073758807 0 ) {
4400: return ; }
4401: std ::@expr1073758808 list < std ::@expr16975 pair < const Token *@expr16898 , std ::@expr16975 string > > errorPath@var3883 ;
4402: if (@expr1073758812 c@var3881 ==@expr1073758813 LifetimeCapture ::@expr16990 ByReference ) {
4403: LifetimeStore ls@var3884 {@expr1073758815
4404: tok2@var3880 , "Lambda captures variable by reference here." , ValueFlow ::@expr16992 Value ::@expr16993 LifetimeKind ::@expr16994 Lambda } ;
4405: ls@var3884 .@expr1073758819 forward@var3885 =@expr1073758820 false ;
4406: update@var3878 |=@expr1073758821 ls@var3884 .@expr1073758822 byRef (@expr1073758823 tok@var3867 , tokenlist@var3864 , errorLogger@var3865 , settings@var3866 , pred@var3882 ) ;
4407: } else { if (@expr1073758824 c@var3881 ==@expr1073758825 LifetimeCapture ::@expr17002 ByValue ) {
4408: LifetimeStore ls@var3886 {@expr1073758827
4409: tok2@var3880 , "Lambda captures variable by value here." , ValueFlow ::@expr16992 Value ::@expr16993 LifetimeKind ::@expr16994 Lambda } ;
4410: ls@var3886 .@expr1073758831 forward@var3887 =@expr1073758832 false ;
4411: update@var3878 |=@expr1073758833 ls@var3886 .@expr1073758834 byVal (@expr1073758835 tok@var3867 , tokenlist@var3864 , errorLogger@var3865 , settings@var3866 , pred@var3882 ) ;
4412: pred@var3882 (@expr1073758836 tok2@var3880 ) ;
4413: } }
4414: } ;
4415:
4416: auto captureThisVariable@var3888 ; captureThisVariable@var3888 =@expr1073758837 [@expr1073758838 &@expr16929 ] (@expr1073758840 const Token *@expr16898 tok2@var3889 , LifetimeCapture c@var3890 ) {
4417: ValueFlow ::@expr1073758842 Value value@var3891 ;
4418: value@var3891 .@expr1073758843 valueType@var3892 =@expr1073758844 ValueFlow ::@expr16992 Value ::@expr17022 ValueType ::@expr17023 LIFETIME ;
4419: if (@expr1073758848 c@var3890 ==@expr1073758849 LifetimeCapture ::@expr16990 ByReference ) {
4420: value@var3891 .@expr17027 lifetimeScope@var3893 =@expr1073758852 ValueFlow ::@expr16992 Value ::@expr17030 LifetimeScope ::@expr1073758855 ThisPointer ; }
4421: else { if (@expr1073758856 c@var3890 ==@expr1073758857 LifetimeCapture ::@expr17002 ByValue ) {
4422: value@var3891 .@expr17027 lifetimeScope@var3893 =@expr1073758860 ValueFlow ::@expr16992 Value ::@expr17030 LifetimeScope ::@expr1073758863 ThisValue ; } }
4423: value@var3891 .@expr1073758864 tokvalue@var3894 =@expr1073758865 tok2@var3889 ;
4424: value@var3891 .@expr1073758866 errorPath@var3895 .@expr1073758867 push_back (@expr1073758868 {@expr1073758869 tok2@var3889 , "Lambda captures the 'this' variable here." } ) ;
4425: value@var3891 .@expr1073758870 lifetimeKind@var3896 =@expr1073758871 ValueFlow ::@expr16992 Value ::@expr16993 LifetimeKind ::@expr16994 Lambda ;
4426: capturedThis@var3873 =@expr1073758875 true ;
4427:
4428: if (@expr1073758876 std ::@expr1073758877 find (@expr1073758878 tok@var3867 .@expr17055 values (@expr17056 ) .@expr17057 begin (@expr17058 ) , tok@var3867 .@expr17055 values (@expr17056 ) .@expr17061 end (@expr17062 ) , value@var3891 ) !=@expr1073758887 tok@var3867 .@expr17055 values (@expr17056 ) .@expr17061 end (@expr17062 ) ) {
4429: return ; }
4430: setTokenValue (@expr1073758892 tok@var3867 , value@var3891 , tokenlist@var3864 .@expr17069 getSettings (@expr17070 ) ) ;
4431: update@var3878 |=@expr1073758895 true ;
4432: } ;
4433:
4434:
4435: for (@expr1073758896 const auto &@expr16929 p@var3897 :@expr1073758898 lam@var3868 .@expr1073758899 explicitCaptures@var3898 ) {
4436: const Variable * var@var3899 ; var@var3899 =@expr1073758900 p@var3897 .@expr1073758901 first@var3900 ;
4437: const Token * tok2@var3901 ; tok2@var3901 =@expr1073758902 p@var3897 .@expr17079 second@var3902 .@expr1073758904 first@var3903 ;
4438: LifetimeCapture c@var3904 ; c@var3904 =@expr1073758905 p@var3897 .@expr17079 second@var3902 .@expr1073758907 second@var3905 ;
4439: if (@expr1073758908 Token ::@expr17085 Match (@expr1073758910 tok2@var3901 , "this !!." ) ) {
4440: captureThisVariable@var3888 (@expr1073758911 tok2@var3901 , c@var3904 ) ;
4441: } else { if (@expr1073758912 var@var3899 ) {
4442: captureVariable@var3879 (@expr1073758913 tok2@var3901 , c@var3904 , [@expr1073758914 ] (@expr1073758915 const Token *@expr16898 ) {
4443: return true ;
4444: } ) ;
4445: varids@var3872 .@expr16965 insert (@expr1073758918 var@var3899 .@expr1073758919 declarationId (@expr1073758920 ) ) ;
4446: } }
4447: }
4448:
4449: auto isImplicitCapturingThis@var3906 ; isImplicitCapturingThis@var3906 =@expr1073758921 [@expr1073758922 &@expr16929 ] (@expr1073758924 const Token *@expr16898 tok2@var3907 ) {
4450: if (@expr1073758926 capturedThis@var3873 ) {
4451: return false ; }
4452: if (@expr1073758927 Token ::@expr17104 simpleMatch (@expr1073758929 tok2@var3907 , "this" ) ) {
4453: return true ;
4454: } else { if (@expr1073758930 tok2@var3907 .@expr17107 variable (@expr17108 ) ) {
4455: if (@expr1073758933 Token ::@expr17104 simpleMatch (@expr1073758935 tok2@var3907 .@expr1073758936 previous (@expr1073758937 ) , "." ) ) {
4456: return false ; }
4457: const Variable * var@var3908 ; var@var3908 =@expr1073758938 tok2@var3907 .@expr17107 variable (@expr17108 ) ;
4458: if (@expr1073758941 var@var3908 .@expr1073758942 isLocal (@expr1073758943 ) ) {
4459: return false ; }
4460: if (@expr1073758944 var@var3908 .@expr1073758945 isArgument (@expr1073758946 ) ) {
4461: return false ; }
4462: return exprDependsOnThis (@expr17123 tok2@var3907 ) ;
4463: } else { if (@expr1073758948 Token ::@expr17104 simpleMatch (@expr1073758950 tok2@var3907 , "(" ) ) {
4464: return exprDependsOnThis (@expr17123 tok2@var3907 ) ;
4465: } } }
4466: return false ;
4467: } ;
4468:
4469: for (@expr1073758952 const Token *@expr16898 tok2@var3909 =@expr1073758954 lam@var3868 .@expr16920 bodyTok@var3870 ; tok2@var3909 !=@expr1073758956 lam@var3868 .@expr16920 bodyTok@var3870 .@expr1073758958 link (@expr1073758959 ) ; tok2@var3909 =@expr1073758960 tok2@var3909 .@expr1073758961 next (@expr1073758962 ) ) {
4470: if (@expr1073758963 isImplicitCapturingThis@var3906 (@expr1073758964 tok2@var3909 ) ) {
4471: captureThisVariable@var3888 (@expr1073758965 tok2@var3909 , LifetimeCapture ::@expr16990 ByReference ) ;
4472: } else { if (@expr1073758967 tok2@var3909 .@expr1073758968 variable (@expr1073758969 ) ) {
4473: captureVariable@var3879 (@expr1073758970 tok2@var3909 , lam@var3868 .@expr1073758971 implicitCapture@var3910 , isImplicitCapturingVariable@var3874 ) ;
4474: } }
4475: }
4476: if (@expr1073758972 update@var3878 ) {
4477: valueFlowForwardLifetime (@expr17149 tok@var3867 , tokenlist@var3864 , errorLogger@var3865 , settings@var3866 ) ; }
4478: }
4479:
4480: else { if (@expr1073758974 tok@var3867 .@expr17151 isUnaryOp (@expr1073758976 "&" ) ) {
4481: for (@expr1073758977 const LifetimeToken &@expr16929 lt@var3911 :@expr1073758979 getLifetimeTokens (@expr1073758980 tok@var3867 .@expr1073758981 astOperand1 (@expr1073758982 ) ) ) {
4482: if (@expr1073758983 !@expr1073758984 settings@var3866 .@expr1073758985 certainty@var3912 .@expr1073758986 isEnabled (@expr1073758987 Certainty ::@expr1073758988 inconclusive@expr1073758718 ) &&@expr1073758989 lt@var3911 .@expr17166 inconclusive@var3913 ) {
4483: continue ; }
4484: std ::@expr1073758991 list < std ::@expr16975 pair < const Token *@expr16898 , std ::@expr16975 string > > errorPath@var3914 ; errorPath@var3914 =@expr1073758995 lt@var3911 .@expr1073758996 errorPath@var3915 ;
4485: errorPath@var3914 .@expr1073758997 emplace_back (@expr1073758998 tok@var3867 , "Address of variable taken here." ) ;
4486:
4487: ValueFlow ::@expr1073758999 Value value@var3916 ;
4488: value@var3916 .@expr1073759000 valueType@var3917 =@expr1073759001 ValueFlow ::@expr16992 Value ::@expr17022 ValueType ::@expr17023 LIFETIME ;
4489: value@var3916 .@expr1073759005 lifetimeScope@var3918 =@expr1073759006 ValueFlow ::@expr16992 Value ::@expr17030 LifetimeScope ::@expr17185 Local@expr16895 ;
4490: value@var3916 .@expr1073759010 tokvalue@var3919 =@expr1073759011 lt@var3911 .@expr17188 token@var3920 ;
4491: value@var3916 .@expr1073759013 errorPath@var3921 =@expr1073759014 std ::@expr1073759015 move (@expr1073759016 errorPath@var3914 ) ;
4492: if (@expr1073759017 lt@var3911 .@expr1073759018 addressOf@var3922 ||@expr1073759019 astIsPointer (@expr1073759020 lt@var3911 .@expr17188 token@var3920 ) ||@expr1073759022 !@expr1073759023 Token ::@expr17085 Match (@expr1073759025 lt@var3911 .@expr17188 token@var3920 .@expr1073759027 astParent (@expr1073759028 ) , ".|[" ) ) {
4493: value@var3916 .@expr1073759029 lifetimeKind@var3923 =@expr1073759030 ValueFlow ::@expr16992 Value ::@expr16993 LifetimeKind ::@expr17209 Address ; }
4494: value@var3916 .@expr1073759034 setInconclusive (@expr1073759035 lt@var3911 .@expr17166 inconclusive@var3913 ) ;
4495: setTokenValue (@expr1073759037 tok@var3867 , value@var3916 , tokenlist@var3864 .@expr17069 getSettings (@expr17070 ) ) ;
4496:
4497: valueFlowForwardLifetime (@expr17149 tok@var3867 , tokenlist@var3864 , errorLogger@var3865 , settings@var3866 ) ;
4498: }
4499: }
4500:
4501: else { if (@expr1073759041 astIsContainerOwned (@expr1073759042 tok@var3867 ) &&@expr1073759043 isConvertedToView (@expr1073759044 tok@var3867 , settings@var3866 ) ) {
4502: LifetimeStore ls@var3924 ; ls@var3924 =@expr1073759045
4503: LifetimeStore {@expr1073759046 tok@var3867 , "Converted to container view" , ValueFlow ::@expr16992 Value ::@expr16993 LifetimeKind ::@expr17225 SubObject } ;
4504: ls@var3924 .@expr1073759050 byRef (@expr1073759051 tok@var3867 , tokenlist@var3864 , errorLogger@var3865 , settings@var3866 ) ;
4505: valueFlowForwardLifetime (@expr17149 tok@var3867 , tokenlist@var3864 , errorLogger@var3865 , settings@var3866 ) ;
4506: }
4507:
4508: else { if (@expr1073759053 astIsContainer (@expr1073759054 tok@var3867 ) ) {
4509: Token * parent@var3925 ; parent@var3925 =@expr1073759055 astParentSkipParens (@expr1073759056 tok@var3867 ) ;
4510: if (@expr1073759057 !@expr1073759058 Token ::@expr17085 Match (@expr1073759060 parent@var3925 , ". %name% (" ) ) {
4511: continue ; }
4512:
4513: bool isContainerOfPointers@var3926 ; isContainerOfPointers@var3926 =@expr1073759061 true ;
4514: const Token * containerTypeToken@var3927 ; containerTypeToken@var3927 =@expr1073759062 tok@var3867 .@expr1073759063 valueType (@expr1073759064 ) .@expr1073759065 containerTypeToken@var5333 ;
4515: if (@expr1073759066 containerTypeToken@var3927 ) {
4516: ValueType vt@var3928 ; vt@var3928 =@expr1073759067 ValueType ::@expr1073759068 parseDecl (@expr1073759069 containerTypeToken@var3927 , settings@var3866 ) ;
4517: isContainerOfPointers@var3926 =@expr1073759070 vt@var3928 .@expr1073759071 pointer@var3929 >@expr1073759072 0 ;
4518: }
4519:
4520: ValueFlow ::@expr1073759073 Value master@var3930 ;
4521: master@var3930 .@expr1073759074 valueType@var3931 =@expr1073759075 ValueFlow ::@expr16992 Value ::@expr17022 ValueType ::@expr17023 LIFETIME ;
4522: master@var3930 .@expr1073759079 lifetimeScope@var3932 =@expr1073759080 ValueFlow ::@expr16992 Value ::@expr17030 LifetimeScope ::@expr17185 Local@expr16895 ;
4523:
4524: if (@expr1073759084 astIsIterator (@expr1073759085 parent@var3925 .@expr17262 tokAt (@expr17263 2 ) ) ) {
4525: master@var3930 .@expr17264 errorPath@var3933 .@expr17265 emplace_back (@expr1073759090 parent@var3925 .@expr17262 tokAt (@expr17263 2 ) , "Iterator to container is created here." ) ;
4526: master@var3930 .@expr17269 lifetimeKind@var3934 =@expr1073759094 ValueFlow ::@expr16992 Value ::@expr16993 LifetimeKind ::@expr1073759097 Iterator ;
4527: } else { if (@expr1073759098 (@expr16976 astIsPointer (@expr1073759100 parent@var3925 .@expr17262 tokAt (@expr17263 2 ) ) &&@expr1073759103 !@expr1073759104 isContainerOfPointers@var3926 ) ||@expr1073759105
4528: Token ::@expr17085 Match (@expr1073759107 parent@var3925 .@expr1073759108 next (@expr1073759109 ) , "data|c_str" ) ) {
4529: master@var3930 .@expr17264 errorPath@var3933 .@expr17265 emplace_back (@expr1073759112 parent@var3925 .@expr17262 tokAt (@expr17263 2 ) , "Pointer to container is created here." ) ;
4530: master@var3930 .@expr17269 lifetimeKind@var3934 =@expr1073759116 ValueFlow ::@expr16992 Value ::@expr16993 LifetimeKind ::@expr17295 Object@expr16896 ;
4531: } else {
4532: continue ;
4533: } }
4534:
4535: std ::@expr1073759120 vector < const Token *@expr16898 > toks@var3935 ; toks@var3935 =@expr1073759122 { } ;
4536: if (@expr1073759123 tok@var3867 .@expr17151 isUnaryOp (@expr1073759125 "*" ) ||@expr1073759126 parent@var3925 .@expr1073759127 originalName (@expr1073759128 ) ==@expr1073759129 "->" ) {
4537: for (@expr1073759130 const ValueFlow ::@expr16975 Value &@expr16929 v@var3936 :@expr1073759133 tok@var3867 .@expr17055 values (@expr17056 ) ) {
4538: if (@expr1073759136 !@expr1073759137 v@var3936 .@expr1073759138 isLocalLifetimeValue (@expr1073759139 ) ) {
4539: continue ; }
4540: if (@expr1073759140 v@var3936 .@expr1073759141 lifetimeKind@var3937 !=@expr1073759142 ValueFlow ::@expr16992 Value ::@expr16993 LifetimeKind ::@expr17209 Address ) {
4541: continue ; }
4542: if (@expr1073759146 !@expr1073759147 v@var3936 .@expr17324 tokvalue@var3938 ) {
4543: continue ; }
4544: toks@var3935 .@expr17325 push_back (@expr1073759150 v@var3936 .@expr17324 tokvalue@var3938 ) ;
4545: }
4546: } else { if (@expr1073759152 astIsContainerView (@expr1073759153 tok@var3867 ) ) {
4547: for (@expr1073759154 const ValueFlow ::@expr16975 Value &@expr16929 v@var3939 :@expr1073759157 tok@var3867 .@expr17055 values (@expr17056 ) ) {
4548: if (@expr1073759160 !@expr1073759161 v@var3939 .@expr1073759162 isLifetimeValue (@expr1073759163 ) ) {
4549: continue ; }
4550: if (@expr1073759164 !@expr1073759165 v@var3939 .@expr17342 tokvalue@var3940 ) {
4551: continue ; }
4552: if (@expr1073759167 !@expr1073759168 astIsContainerOwned (@expr1073759169 v@var3939 .@expr17342 tokvalue@var3940 ) ) {
4553: continue ; }
4554: toks@var3935 .@expr17325 push_back (@expr1073759172 v@var3939 .@expr17342 tokvalue@var3940 ) ;
4555: }
4556: } else {
4557: toks@var3935 =@expr1073759174 {@expr1073759175 tok@var3867 } ;
4558: } }
4559:
4560: for (@expr1073759176 const Token *@expr16898 tok2@var3941 :@expr1073759178 toks@var3935 ) {
4561: for (@expr1073759179 const ReferenceToken &@expr16929 rt@var3942 :@expr1073759181 followAllReferences (@expr1073759182 tok2@var3941 , false ) ) {
4562: ValueFlow ::@expr1073759183 Value value@var3943 ; value@var3943 =@expr1073759184 master@var3930 ;
4563: value@var3943 .@expr1073759185 tokvalue@var3944 =@expr1073759186 rt@var3942 .@expr17363 token@var3945 ;
4564: value@var3943 .@expr17364 errorPath@var3946 .@expr1073759189 insert (@expr1073759190 value@var3943 .@expr17364 errorPath@var3946 .@expr1073759192 begin (@expr1073759193 ) , rt@var3942 .@expr17370 errors@var3947 .@expr1073759195 begin (@expr1073759196 ) , rt@var3942 .@expr17370 errors@var3947 .@expr1073759198 end (@expr1073759199 ) ) ;
4565: setTokenValue (@expr1073759200 parent@var3925 .@expr17262 tokAt (@expr17263 2 ) , value@var3943 , tokenlist@var3864 .@expr17069 getSettings (@expr17070 ) ) ;
4566:
4567: if (@expr1073759205 !@expr1073759206 rt@var3942 .@expr17363 token@var3945 .@expr1073759208 variable (@expr1073759209 ) ) {
4568: LifetimeStore ls@var3948 ; ls@var3948 =@expr1073759210 LifetimeStore {@expr1073759211
4569: rt@var3942 .@expr17363 token@var3945 , master@var3930 .@expr17264 errorPath@var3933 .@expr1073759214 back (@expr1073759215 ) .@expr1073759216 second , ValueFlow ::@expr16992 Value ::@expr16993 LifetimeKind ::@expr17295 Object@expr16896 } ;
4570: ls@var3948 .@expr1073759220 byRef (@expr1073759221 parent@var3925 .@expr17262 tokAt (@expr17263 2 ) , tokenlist@var3864 , errorLogger@var3865 , settings@var3866 ) ;
4571: }
4572: }
4573: }
4574: valueFlowForwardLifetime (@expr1073759224 parent@var3925 .@expr17262 tokAt (@expr17263 2 ) , tokenlist@var3864 , errorLogger@var3865 , settings@var3866 ) ;
4575: }
4576:
4577: else { if (@expr1073759227 Token ::@expr17085 Match (@expr1073759229 tok@var3867 , "=|return|%name%|{|,|> {" ) &&@expr1073759230 !@expr1073759231 isScope (@expr1073759232 tok@var3867 .@expr16903 next (@expr16904 ) ) ) {
4578: valueFlowLifetimeConstructor (@expr1073759235 tok@var3867 .@expr16903 next (@expr16904 ) , tokenlist@var3864 , errorLogger@var3865 , settings@var3866 ) ;
4579: }
4580:
4581: else { if (@expr1073759238 Token ::@expr17085 Match (@expr1073759240 tok@var3867 , "%name% (" ) &&@expr1073759241 !@expr1073759242 Token ::@expr17104 simpleMatch (@expr1073759244 tok@var3867 .@expr16903 next (@expr16904 ) .@expr1073759247 link (@expr1073759248 ) , ") {" ) ) {
4582: valueFlowLifetimeFunction (@expr1073759249 tok@var3867 , tokenlist@var3864 , errorLogger@var3865 , settings@var3866 ) ;
4583: }
4584:
4585: else { if (@expr1073759250 astIsUniqueSmartPointer (@expr1073759251 tok@var3867 ) &&@expr1073759252 astIsLHS (@expr1073759253 tok@var3867 ) &&@expr1073759254 Token ::@expr17104 simpleMatch (@expr1073759256 tok@var3867 .@expr17433 astParent (@expr17434 ) , ". get ( )" ) ) {
4586: Token * ptok@var3949 ; ptok@var3949 =@expr1073759259 tok@var3867 .@expr17433 astParent (@expr17434 ) .@expr1073759262 tokAt (@expr1073759263 2 ) ;
4587: std ::@expr1073759264 list < std ::@expr16975 pair < const Token *@expr16898 , std ::@expr16975 string > > errorPath@var3950 ; errorPath@var3950 =@expr1073759268 {@expr1073759269 {@expr1073759270 ptok@var3949 , "Raw pointer to smart pointer created here." } } ;
4588: ValueFlow ::@expr1073759271 Value value@var3951 ;
4589: value@var3951 .@expr1073759272 valueType@var3952 =@expr1073759273 ValueFlow ::@expr16992 Value ::@expr17022 ValueType ::@expr17023 LIFETIME ;
4590: value@var3951 .@expr1073759277 lifetimeScope@var3953 =@expr1073759278 ValueFlow ::@expr16992 Value ::@expr17030 LifetimeScope ::@expr17185 Local@expr16895 ;
4591: value@var3951 .@expr1073759282 lifetimeKind@var3954 =@expr1073759283 ValueFlow ::@expr16992 Value ::@expr16993 LifetimeKind ::@expr17225 SubObject ;
4592: value@var3951 .@expr1073759287 tokvalue@var3955 =@expr1073759288 tok@var3867 ;
4593: value@var3951 .@expr1073759289 errorPath@var3956 =@expr1073759290 errorPath@var3950 ;
4594: setTokenValue (@expr1073759291 ptok@var3949 , value@var3951 , tokenlist@var3864 .@expr17069 getSettings (@expr17070 ) ) ;
4595: valueFlowForwardLifetime (@expr1073759294 ptok@var3949 , tokenlist@var3864 , errorLogger@var3865 , settings@var3866 ) ;
4596: }
4597:
4598: else { if (@expr1073759295 tok@var3867 .@expr1073759296 variable (@expr1073759297 ) ) {
4599: std ::@expr1073759298 list < std ::@expr16975 pair < const Token *@expr16898 , std ::@expr16975 string > > errorPath@var3957 ;
4600: const Variable * var@var3958 ; var@var3958 =@expr1073759302 getLifetimeVariable (@expr1073759303 tok@var3867 , errorPath@var3957 ) ;
4601: if (@expr1073759304 !@expr1073759305 var@var3958 ) {
4602: continue ; }
4603: if (@expr1073759306 var@var3958 .@expr17483 nameToken (@expr17484 ) ==@expr1073759309 tok@var3867 ) {
4604: continue ; }
4605: if (@expr1073759310 var@var3958 .@expr1073759311 isArray (@expr1073759312 ) &&@expr1073759313 !@expr1073759314 var@var3958 .@expr1073759315 isStlType (@expr1073759316 ) &&@expr1073759317 !@expr1073759318 var@var3958 .@expr1073759319 isArgument (@expr1073759320 ) &&@expr1073759321 isDecayedPointer (@expr1073759322 tok@var3867 ) ) {
4606: errorPath@var3957 .@expr1073759323 emplace_back (@expr1073759324 tok@var3867 , "Array decayed to pointer here." ) ;
4607:
4608: ValueFlow ::@expr1073759325 Value value@var3959 ;
4609: value@var3959 .@expr1073759326 valueType@var3960 =@expr1073759327 ValueFlow ::@expr16992 Value ::@expr17022 ValueType ::@expr17023 LIFETIME ;
4610: value@var3959 .@expr1073759331 lifetimeScope@var3961 =@expr1073759332 ValueFlow ::@expr16992 Value ::@expr17030 LifetimeScope ::@expr17185 Local@expr16895 ;
4611: value@var3959 .@expr1073759336 tokvalue@var3962 =@expr1073759337 var@var3958 .@expr17483 nameToken (@expr17484 ) ;
4612: value@var3959 .@expr1073759340 errorPath@var3963 =@expr1073759341 errorPath@var3957 ;
4613: setTokenValue (@expr1073759342 tok@var3867 , value@var3959 , tokenlist@var3864 .@expr17069 getSettings (@expr17070 ) ) ;
4614:
4615: valueFlowForwardLifetime (@expr17149 tok@var3867 , tokenlist@var3864 , errorLogger@var3865 , settings@var3866 ) ;
4616: }
4617: }
4618:
4619: else { if (@expr1073759346 std ::@expr1073759347 any_of (@expr1073759348 tok@var3867 .@expr17055 values (@expr17056 ) .@expr17057 begin (@expr17058 ) , tok@var3867 .@expr17055 values (@expr17056 ) .@expr17061 end (@expr17062 ) , std ::@expr1073759357 mem_fn (@expr1073759358 &@expr1073759359 ValueFlow ::@expr16992 Value ::@expr1073759361 isLifetimeValue ) ) ) {
4620: valueFlowForwardLifetime (@expr17149 tok@var3867 , tokenlist@var3864 , errorLogger@var3865 , settings@var3866 ) ;
4621: } } } } } } } } }
4622: }
4623: }
4624:
4625: static bool isStdMoveOrStdForwarded ( Token * tok@var3964 , ValueFlow :: Value :: MoveKind * moveKind@var3965 , Token * * varTok@var3966 = nullptr )
4626: {
4627: if (@expr1073759364 tok@var3964 .@expr1073759365 str (@expr1073759366 ) !=@expr1073759367 "std" ) {
4628: return false ; }
4629: ValueFlow ::@expr17544 Value ::@expr1073759369 MoveKind kind@var3967 ; kind@var3967 =@expr1073759370 ValueFlow ::@expr17544 Value ::@expr17548 MoveKind ::@expr1073759373 NonMovedVariable@expr1073759363 ;
4630: Token * variableToken@var3968 ; variableToken@var3968 =@expr1073759374 nullptr ;
4631: if (@expr1073759375 Token ::@expr17552 Match (@expr1073759377 tok@var3964 , "std :: move ( %var% )" ) ) {
4632: variableToken@var3968 =@expr1073759378 tok@var3964 .@expr17555 tokAt (@expr1073759380 4 ) ;
4633: kind@var3967 =@expr1073759381 ValueFlow ::@expr17544 Value ::@expr17548 MoveKind ::@expr1073759384 MovedVariable ;
4634: } else { if (@expr1073759385 Token ::@expr1073759386 simpleMatch (@expr1073759387 tok@var3964 , "std :: forward <" ) ) {
4635: const Token * const leftAngle@var3969 ; leftAngle@var3969 =@expr1073759388 tok@var3964 .@expr17555 tokAt (@expr1073759390 3 ) ;
4636: Token * rightAngle@var3970 ; rightAngle@var3970 =@expr1073759391 leftAngle@var3969 .@expr1073759392 link (@expr1073759393 ) ;
4637: if (@expr1073759394 Token ::@expr17552 Match (@expr1073759396 rightAngle@var3970 , "> ( %var% )" ) ) {
4638: variableToken@var3968 =@expr1073759397 rightAngle@var3970 .@expr1073759398 tokAt (@expr1073759399 2 ) ;
4639: kind@var3967 =@expr1073759400 ValueFlow ::@expr17544 Value ::@expr17548 MoveKind ::@expr1073759403 ForwardedVariable ;
4640: }
4641: } }
4642: if (@expr1073759404 !@expr1073759405 variableToken@var3968 ) {
4643: return false ; }
4644: if (@expr1073759406 variableToken@var3968 .@expr1073759407 strAt (@expr1073759408 2 ) ==@expr1073759409 "." ) {
4645: return false ; }
4646: if (@expr1073759410 variableToken@var3968 .@expr17587 valueType (@expr17588 ) &&@expr1073759413 variableToken@var3968 .@expr17587 valueType (@expr17588 ) .@expr1073759416 type@var5318 >=@expr1073759417 ValueType ::@expr1073759418 Type ::@expr1073759419 VOID ) {
4647: return false ; }
4648: if (@expr1073759420 moveKind@var3965 !=@expr1073759421 nullptr ) {
4649: *@expr1073759422 moveKind@var3965 =@expr1073759423 kind@var3967 ; }
4650: if (@expr1073759424 varTok@var3966 !=@expr1073759425 nullptr ) {
4651: *@expr1073759426 varTok@var3966 =@expr1073759427 variableToken@var3968 ; }
4652: return true ;
4653: }
4654:
4655: static bool isOpenParenthesisMemberFunctionCallOfVarId ( const Token * openParenthesisToken@var3971 , int varId@var3972 )
4656: {
4657: const Token * varTok@var3973 ; varTok@var3973 =@expr1073759428 openParenthesisToken@var3971 .@expr1073759429 tokAt (@expr1073759430 -3 ) ;
4658: return Token ::@expr1073759431 Match (@expr1073759432 varTok@var3973 , "%varid% . %name% (" , varId@var3972 ) &&@expr1073759433
4659: varTok@var3973 .@expr1073759434 next (@expr1073759435 ) .@expr1073759436 originalName (@expr1073759437 ) .@expr1073759438 empty (@expr1073759439 ) ;
4660: }
4661:
4662: static const Token * findOpenParentesisOfMove ( const Token * moveVarTok@var3974 )
4663: {
4664: const Token * tok@var3975 ; tok@var3975 =@expr1073759440 moveVarTok@var3974 ;
4665: while (@expr1073759441 tok@var3975 &&@expr1073759442 tok@var3975 .@expr1073759443 str (@expr1073759444 ) !=@expr1073759445 "(" ) {
4666: tok@var3975 =@expr1073759446 tok@var3975 .@expr1073759447 previous (@expr1073759448 ) ; }
4667: return tok@var3975 ;
4668: }
4669:
4670: static const Token * findEndOfFunctionCallForParameter ( const Token * parameterToken@var3976 )
4671: {
4672: if (@expr1073759449 !@expr1073759450 parameterToken@var3976 ) {
4673: return nullptr ; }
4674: const Token * parent@var3977 ; parent@var3977 =@expr1073759451 parameterToken@var3976 .@expr1073759452 astParent (@expr1073759453 ) ;
4675: while (@expr1073759454 parent@var3977 &&@expr1073759455 !@expr1073759456 parent@var3977 .@expr1073759457 isOp (@expr1073759458 ) &&@expr1073759459 parent@var3977 .@expr1073759460 str (@expr1073759461 ) !=@expr1073759462 "(" ) {
4676: parent@var3977 =@expr1073759463 parent@var3977 .@expr1073759464 astParent (@expr1073759465 ) ; }
4677: if (@expr1073759466 !@expr1073759467 parent@var3977 ) {
4678: return nullptr ; }
4679: return nextAfterAstRightmostLeaf (@expr1073759468 parent@var3977 ) ;
4680: }
4681:
4682: static void valueFlowAfterMove ( TokenList * tokenlist@var3978 , SymbolDatabase * symboldatabase@var3979 , const Settings * settings@var3980 )
4683: {
4684: if (@expr1073759470 !@expr1073759471 tokenlist@var3978 .@expr1073759472 isCPP (@expr1073759473 ) ||@expr1073759474 settings@var3980 .@expr1073759475 standards@var3981 .@expr1073759476 cpp@var3982 <@expr1073759477 Standards ::@expr1073759478 CPP11 ) {
4685: return ; }
4686: for (@expr1073759479 const Scope *@expr17656 scope@var3983 :@expr1073759481 symboldatabase@var3979 .@expr1073759482 functionScopes@var3984 ) {
4687: if (@expr1073759483 !@expr1073759484 scope@var3983 ) {
4688: continue ; }
4689: const Token * start@var3985 ; start@var3985 =@expr1073759485 scope@var3983 .@expr1073759486 bodyStart@var3986 ;
4690: if (@expr1073759487 scope@var3983 .@expr17664 function@var3987 ) {
4691: const Token * memberInitializationTok@var3988 ; memberInitializationTok@var3988 =@expr1073759489 scope@var3983 .@expr17664 function@var3987 .@expr1073759491 constructorMemberInitialization (@expr1073759492 ) ;
4692: if (@expr1073759493 memberInitializationTok@var3988 ) {
4693: start@var3985 =@expr1073759494 memberInitializationTok@var3988 ; }
4694: }
4695:
4696: for (@expr1073759495 Token *@expr17656 tok@var3989 =@expr1073759497 const_cast < Token *@expr17656 > (@expr1073759499 start@var3985 ) ; tok@var3989 !=@expr1073759500 scope@var3983 .@expr1073759501 bodyEnd@var3990 ; tok@var3989 =@expr1073759502 tok@var3989 .@expr17679 next (@expr17680 ) ) {
4697: Token * varTok@var3991 ;
4698: if (@expr1073759505 Token ::@expr1073759506 Match (@expr1073759507 tok@var3989 , "%var% . reset|clear (" ) &&@expr1073759508 tok@var3989 .@expr17679 next (@expr17680 ) .@expr1073759511 originalName (@expr1073759512 ) .@expr1073759513 empty (@expr1073759514 ) ) {
4699: varTok@var3991 =@expr1073759515 tok@var3989 ;
4700: ValueFlow ::@expr1073759516 Value value@var3992 ;
4701: value@var3992 .@expr1073759517 valueType@var3993 =@expr1073759518 ValueFlow ::@expr17695 Value ::@expr17696 ValueType ::@expr17697 MOVED ;
4702: value@var3992 .@expr1073759522 moveKind@var3994 =@expr1073759523 ValueFlow ::@expr17695 Value ::@expr17701 MoveKind ::@expr1073759526 NonMovedVariable@expr1073759469 ;
4703: value@var3992 .@expr1073759527 errorPath@var3995 .@expr1073759528 emplace_back (@expr1073759529 tok@var3989 , "Calling " +@expr1073759530 tok@var3989 .@expr17679 next (@expr17680 ) .@expr1073759533 expressionString (@expr1073759534 ) +@expr1073759535 " makes " +@expr1073759536 tok@var3989 .@expr1073759537 str (@expr1073759538 ) +@expr1073759539 " 'non-moved'" ) ;
4704: value@var3992 .@expr1073759540 setKnown (@expr1073759541 ) ;
4705: std ::@expr1073759542 list < ValueFlow ::@expr17719 Value > values@var3996 ;
4706: values@var3996 .@expr1073759544 push_back (@expr1073759545 value@var3992 ) ;
4707:
4708: const Variable * var@var3997 ; var@var3997 =@expr1073759546 varTok@var3991 .@expr17723 variable (@expr17724 ) ;
4709: if (@expr1073759549 !@expr1073759550 var@var3997 ||@expr1073759551 (@expr1073759552 !@expr1073759553 var@var3997 .@expr1073759554 isLocal (@expr1073759555 ) &&@expr1073759556 !@expr1073759557 var@var3997 .@expr1073759558 isArgument (@expr1073759559 ) ) ) {
4710: continue ; }
4711: const Token * const endOfVarScope@var3998 ; endOfVarScope@var3998 =@expr1073759560 var@var3997 .@expr1073759561 scope (@expr1073759562 ) .@expr1073759563 bodyEnd@var5330 ;
4712: setTokenValue (@expr1073759564 varTok@var3991 , value@var3992 , settings@var3980 ) ;
4713: valueFlowForward (@expr1073759565 varTok@var3991 .@expr1073759566 next (@expr1073759567 ) , endOfVarScope@var3998 , varTok@var3991 , values@var3996 , tokenlist@var3978 , settings@var3980 ) ;
4714: continue ;
4715: }
4716: ValueFlow ::@expr17695 Value ::@expr1073759569 MoveKind moveKind@var3999 ;
4717: if (@expr1073759570 !@expr1073759571 isStdMoveOrStdForwarded (@expr1073759572 tok@var3989 , &@expr1073759573 moveKind@var3999 , &@expr1073759574 varTok@var3991 ) ) {
4718: continue ; }
4719: const int varId@var4000 =@expr1073759575 varTok@var3991 .@expr1073759576 varId (@expr1073759577 ) ;
4720:
4721: const Token * parent@var4001 ; parent@var4001 =@expr1073759578 tok@var3989 .@expr1073759579 astParent (@expr1073759580 ) ;
4722: while (@expr1073759581 parent@var4001 &&@expr1073759582 parent@var4001 .@expr17759 str (@expr17760 ) !=@expr1073759585 "=" &&@expr1073759586 parent@var4001 .@expr17759 str (@expr17760 ) !=@expr1073759589 "return" &&@expr1073759590
4723: !@expr1073759591 (@expr1073759592 parent@var4001 .@expr17759 str (@expr17760 ) ==@expr17771 "(" &&@expr1073759596 isOpenParenthesisMemberFunctionCallOfVarId (@expr1073759597 parent@var4001 , varId@var4000 ) ) ) {
4724: parent@var4001 =@expr1073759598 parent@var4001 .@expr1073759599 astParent (@expr1073759600 ) ; }
4725: if (@expr1073759601 parent@var4001 &&@expr1073759602
4726: (@expr1073759603 parent@var4001 .@expr17759 str (@expr17760 ) ==@expr1073759606 "return" ||@expr1073759607
4727: parent@var4001 .@expr17759 str (@expr17760 ) ==@expr17771 "(" ) ) {
4728: continue ; }
4729: if (@expr1073759611 parent@var4001 &&@expr1073759612 parent@var4001 .@expr17789 astOperand1 (@expr17790 ) &&@expr1073759615 parent@var4001 .@expr17789 astOperand1 (@expr17790 ) .@expr1073759618 varId (@expr1073759619 ) ==@expr1073759620 varId@var4000 ) {
4730: continue ; }
4731: const Variable * var@var4002 ; var@var4002 =@expr1073759621 varTok@var3991 .@expr17723 variable (@expr17724 ) ;
4732: if (@expr1073759624 !@expr1073759625 var@var4002 ) {
4733: continue ; }
4734: const Token * const endOfVarScope@var4003 ; endOfVarScope@var4003 =@expr1073759626 var@var4002 .@expr1073759627 scope (@expr1073759628 ) .@expr1073759629 bodyEnd@var5330 ;
4735:
4736: ValueFlow ::@expr1073759630 Value value@var4004 ;
4737: value@var4004 .@expr1073759631 valueType@var4005 =@expr1073759632 ValueFlow ::@expr17695 Value ::@expr17696 ValueType ::@expr17697 MOVED ;
4738: value@var4004 .@expr1073759636 moveKind@var4006 =@expr1073759637 moveKind@var3999 ;
4739: if (@expr1073759638 moveKind@var3999 ==@expr1073759639 ValueFlow ::@expr17695 Value ::@expr17701 MoveKind ::@expr1073759642 MovedVariable ) {
4740: value@var4004 .@expr17819 errorPath@var4007 .@expr17820 emplace_back (@expr1073759645 tok@var3989 , "Calling std::move(" +@expr1073759646 varTok@var3991 .@expr17823 str (@expr17824 ) +@expr1073759649 ")" ) ; }
4741: else {
4742: value@var4004 .@expr17819 errorPath@var4007 .@expr17820 emplace_back (@expr1073759652 tok@var3989 , "Calling std::forward(" +@expr1073759653 varTok@var3991 .@expr17823 str (@expr17824 ) +@expr1073759656 ")" ) ; }
4743: value@var4004 .@expr1073759657 setKnown (@expr1073759658 ) ;
4744: std ::@expr1073759659 list < ValueFlow ::@expr17719 Value > values@var4008 ;
4745: values@var4008 .@expr1073759661 push_back (@expr1073759662 value@var4004 ) ;
4746: const Token * openParentesisOfMove@var4009 ; openParentesisOfMove@var4009 =@expr1073759663 findOpenParentesisOfMove (@expr1073759664 varTok@var3991 ) ;
4747: const Token * endOfFunctionCall@var4010 ; endOfFunctionCall@var4010 =@expr1073759665 findEndOfFunctionCallForParameter (@expr1073759666 openParentesisOfMove@var4009 ) ;
4748: if (@expr1073759667 endOfFunctionCall@var4010 ) {
4749: valueFlowForward (@expr1073759668
4750: const_cast < Token *@expr17656 > (@expr1073759670 endOfFunctionCall@var4010 ) , endOfVarScope@var4003 , varTok@var3991 , values@var4008 , tokenlist@var3978 , settings@var3980 ) ; }
4751: }
4752: }
4753: }
4754:
4755: static const Token * findIncompleteVar ( const Token * start@var4011 , const Token * end@var4012 )
4756: {
4757: for (@expr1073759671 const Token *@expr1073759672 tok@var4013 =@expr1073759673 start@var4011 ; tok@var4013 !=@expr1073759674 end@var4012 ; tok@var4013 =@expr1073759675 tok@var4013 .@expr1073759676 next (@expr1073759677 ) ) {
4758: if (@expr1073759678 tok@var4013 .@expr1073759679 isIncompleteVar (@expr1073759680 ) ) {
4759: return tok@var4013 ; }
4760: }
4761: return nullptr ;
4762: }
4763:
4764: static ValueFlow :: Value makeConditionValue ( long long val@var4014 , const Token * condTok@var4015 , bool assume@var4016 )
4765: {
4766: ValueFlow ::@expr1073759681 Value v@var4017 (@expr1073759682 val@var4014 ) ;
4767: v@var4017 .@expr1073759683 setKnown (@expr1073759684 ) ;
4768: v@var4017 .@expr1073759685 condition@var4018 =@expr1073759686 condTok@var4015 ;
4769: if (@expr1073759687 assume@var4016 ) {
4770: v@var4017 .@expr17864 errorPath@var4019 .@expr17865 emplace_back (@expr1073759690 condTok@var4015 , "Assuming condition '" +@expr17867 condTok@var4015 .@expr17868 expressionString (@expr17869 ) +@expr1073759694 "' is true" ) ; }
4771: else {
4772: v@var4017 .@expr17864 errorPath@var4019 .@expr17865 emplace_back (@expr1073759697 condTok@var4015 , "Assuming condition '" +@expr17867 condTok@var4015 .@expr17868 expressionString (@expr17869 ) +@expr1073759701 "' is false" ) ; }
4773: return v@var4017 ;
4774: }
4775:
4776: static std :: vector < const Token * > getConditions ( const Token * tok@var4020 , const char * op@var4021 )
4777: {
4778: std ::@expr1073759702 vector < const Token *@expr17879 > conds@var4022 ; conds@var4022 =@expr1073759704 {@expr1073759705 tok@var4020 } ;
4779: if (@expr1073759706 tok@var4020 .@expr1073759707 str (@expr1073759708 ) ==@expr1073759709 op@var4021 ) {
4780: std ::@expr1073759710 vector < const Token *@expr17879 > args@var4023 ; args@var4023 =@expr1073759712 astFlatten (@expr1073759713 tok@var4020 , op@var4021 ) ;
4781: std ::@expr1073759714 copy_if (@expr1073759715 args@var4023 .@expr1073759716 begin (@expr1073759717 ) , args@var4023 .@expr1073759718 end (@expr1073759719 ) , std ::@expr1073759720 back_inserter (@expr1073759721 conds@var4022 ) , [@expr1073759722 &@expr1073759723 ] (@expr1073759724 const Token *@expr17879 tok2@var4024 ) {
4782: if (@expr1073759726 tok2@var4024 .@expr1073759727 exprId (@expr1073759728 ) ==@expr1073759729 0 ) {
4783: return false ; }
4784: if (@expr1073759730 tok2@var4024 .@expr1073759731 hasKnownIntValue (@expr1073759732 ) ) {
4785: return false ; }
4786: if (@expr1073759733 Token ::@expr1073759734 Match (@expr1073759735 tok2@var4024 , "%var%|." ) &&@expr1073759736 !@expr1073759737 astIsBool (@expr1073759738 tok2@var4024 ) ) {
4787: return false ; }
4788: return true ;
4789: } ) ;
4790: }
4791: return conds@var4022 ;
4792: }
4793:
4794:
4795: static void valueFlowConditionExpressions ( TokenList * tokenlist@var4025 , SymbolDatabase * symboldatabase@var4026 , ErrorLogger * errorLogger@var4027 , const Settings * settings@var4028 )
4796: {
4797: for (@expr1073759739 const Scope *@expr17916 scope@var4029 :@expr1073759741 symboldatabase@var4026 .@expr1073759742 functionScopes@var4030 ) {
4798: if (@expr1073759743 const Token *@expr17916 incompleteTok@var4031 =@expr1073759745 findIncompleteVar (@expr1073759746 scope@var4029 .@expr17923 bodyStart@var4032 , scope@var4029 .@expr17924 bodyEnd@var4033 ) ) {
4799: if (@expr1073759749 incompleteTok@var4031 .@expr1073759750 isIncompleteVar (@expr1073759751 ) ) {
4800: if (@expr1073759752 settings@var4028 .@expr1073759753 debugwarnings@var4034 ) {
4801: $bailoutInternal $(@expr1073759754 $"valueFlowBailoutIncompleteVar" $, tokenlist@var4025 $, errorLogger@var4027 $, incompleteTok@var4031 $, "Skipping function due to incomplete variable " +@expr1073759755 incompleteTok@var4031 .@expr1073759756 str (@expr1073759757 ) $, "cppcheck-2.8/lib/valueflow.cpp" $, 4801 $, $__func__ $) ; }
4802: break ;
4803: }
4804: }
4805:
4806: for (@expr1073759758 const Token *@expr17916 tok@var4035 =@expr1073759760 scope@var4029 .@expr17923 bodyStart@var4032 ; tok@var4035 !=@expr1073759762 scope@var4029 .@expr17924 bodyEnd@var4033 ; tok@var4035 =@expr1073759764 tok@var4035 .@expr17941 next (@expr17942 ) ) {
4807: if (@expr1073759767 !@expr1073759768 Token ::@expr17945 simpleMatch (@expr1073759770 tok@var4035 , "if (" ) ) {
4808: continue ; }
4809: Token * parenTok@var4036 ; parenTok@var4036 =@expr1073759771 tok@var4035 .@expr17941 next (@expr17942 ) ;
4810: if (@expr1073759774 !@expr1073759775 Token ::@expr17945 simpleMatch (@expr1073759777 parenTok@var4036 .@expr17954 link (@expr17955 ) , ") {" ) ) {
4811: continue ; }
4812: Token * blockTok@var4037 ; blockTok@var4037 =@expr1073759780 parenTok@var4036 .@expr17954 link (@expr17955 ) .@expr1073759783 tokAt (@expr1073759784 1 ) ;
4813: const Token * condTok@var4038 ; condTok@var4038 =@expr1073759785 parenTok@var4036 .@expr1073759786 astOperand2 (@expr1073759787 ) ;
4814: if (@expr1073759788 condTok@var4038 .@expr1073759789 exprId (@expr1073759790 ) ==@expr1073759791 0 ) {
4815: continue ; }
4816: if (@expr1073759792 condTok@var4038 .@expr1073759793 hasKnownIntValue (@expr1073759794 ) ) {
4817: continue ; }
4818: if (@expr1073759795 !@expr1073759796 isConstExpression (@expr1073759797 condTok@var4038 , settings@var4028 .@expr1073759798 library@var4039 , true , tokenlist@var4025 .@expr1073759799 isCPP (@expr1073759800 ) ) ) {
4819: continue ; }
4820: const bool is1@var4040 =@expr1073759801 condTok@var4038 .@expr1073759802 isComparisonOp (@expr1073759803 ) ||@expr1073759804 condTok@var4038 .@expr1073759805 tokType (@expr1073759806 ) ==@expr1073759807 Token ::@expr1073759808 eLogicalOp ||@expr1073759809 astIsBool (@expr1073759810 condTok@var4038 ) ;
4821:
4822: Token * startTok@var4041 ; startTok@var4041 =@expr1073759811 blockTok@var4037 ;
4823:
4824: {
4825: for (@expr1073759812 const Token *@expr17916 condTok2@var4042 :@expr1073759814 getConditions (@expr1073759815 condTok@var4038 , "&&" ) ) {
4826: if (@expr17992 is1@var4040 ) {
4827: ExpressionAnalyzer a1@var4043 (@expr1073759817 condTok2@var4042 , makeConditionValue (@expr1073759818 1 , condTok2@var4042 , true ) , tokenlist@var4025 ) ;
4828: valueFlowGenericForward (@expr1073759819 startTok@var4041 , startTok@var4041 .@expr17996 link (@expr17997 ) , a1@var4043 , settings@var4028 ) ;
4829: }
4830:
4831: OppositeExpressionAnalyzer a2@var4044 (@expr1073759822 true , condTok2@var4042 , makeConditionValue (@expr1073759823 0 , condTok2@var4042 , true ) , tokenlist@var4025 ) ;
4832: valueFlowGenericForward (@expr1073759824 startTok@var4041 , startTok@var4041 .@expr17996 link (@expr17997 ) , a2@var4044 , settings@var4028 ) ;
4833: }
4834: }
4835:
4836: std ::@expr1073759827 vector < const Token *@expr17916 > conds@var4045 ; conds@var4045 =@expr1073759829 getConditions (@expr1073759830 condTok@var4038 , "||" ) ;
4837:
4838:
4839: if (@expr1073759831 Token ::@expr17945 simpleMatch (@expr1073759833 startTok@var4041 .@expr17996 link (@expr17997 ) , "} else {" ) ) {
4840: startTok@var4041 =@expr1073759836 startTok@var4041 .@expr17996 link (@expr17997 ) .@expr1073759839 tokAt (@expr1073759840 2 ) ;
4841: for (@expr1073759841 const Token *@expr17916 condTok2@var4046 :@expr1073759843 conds@var4045 ) {
4842: ExpressionAnalyzer a1@var4047 (@expr1073759844 condTok2@var4046 , makeConditionValue (@expr1073759845 0 , condTok2@var4046 , false ) , tokenlist@var4025 ) ;
4843: valueFlowGenericForward (@expr1073759846 startTok@var4041 , startTok@var4041 .@expr17996 link (@expr17997 ) , a1@var4047 , settings@var4028 ) ;
4844:
4845: if (@expr17992 is1@var4040 ) {
4846: OppositeExpressionAnalyzer a2@var4048 (@expr1073759850 true , condTok2@var4046 , makeConditionValue (@expr1073759851 1 , condTok2@var4046 , false ) , tokenlist@var4025 ) ;
4847: valueFlowGenericForward (@expr1073759852 startTok@var4041 , startTok@var4041 .@expr17996 link (@expr17997 ) , a2@var4048 , settings@var4028 ) ;
4848: }
4849: }
4850: }
4851:
4852:
4853: if (@expr1073759855 isEscapeScope (@expr1073759856 blockTok@var4037 , tokenlist@var4025 ) ) {
4854: for (@expr1073759857 const Token *@expr17916 condTok2@var4049 :@expr1073759859 conds@var4045 ) {
4855: ExpressionAnalyzer a1@var4050 (@expr1073759860 condTok2@var4049 , makeConditionValue (@expr1073759861 0 , condTok2@var4049 , false ) , tokenlist@var4025 ) ;
4856: valueFlowGenericForward (@expr1073759862 startTok@var4041 .@expr17996 link (@expr17997 ) .@expr18041 next (@expr18042 ) , scope@var4029 .@expr17924 bodyEnd@var4033 , a1@var4050 , settings@var4028 ) ;
4857:
4858: if (@expr17992 is1@var4040 ) {
4859: OppositeExpressionAnalyzer a2@var4051 (@expr1073759869 true , condTok2@var4049 , makeConditionValue (@expr1073759870 1 , condTok2@var4049 , false ) , tokenlist@var4025 ) ;
4860: valueFlowGenericForward (@expr1073759871 startTok@var4041 .@expr17996 link (@expr17997 ) .@expr18041 next (@expr18042 ) , scope@var4029 .@expr17924 bodyEnd@var4033 , a2@var4051 , settings@var4028 ) ;
4861: }
4862: }
4863: }
4864:
4865: }
4866: }
4867: }
4868:
4869: static bool isTruncated ( const ValueType * src@var4052 , const ValueType * dst@var4053 , const Settings * settings@var4054 )
4870: {
4871: if (@expr1073759877 src@var4052 .@expr18054 pointer@var4055 >@expr1073759879 0 ||@expr1073759880 dst@var4053 .@expr18057 pointer@var4056 >@expr1073759882 0 ) {
4872: return src@var4052 .@expr18054 pointer@var4055 !=@expr1073759884 dst@var4053 .@expr18057 pointer@var4056 ; }
4873: if (@expr1073759886 src@var4052 .@expr1073759887 smartPointer@var4057 &&@expr1073759888 dst@var4053 .@expr1073759889 smartPointer@var4058 ) {
4874: return false ; }
4875: if (@expr1073759890 (@expr1073759891 src@var4052 .@expr1073759892 isIntegral (@expr1073759893 ) &&@expr1073759894 dst@var4053 .@expr1073759895 isIntegral (@expr1073759896 ) ) ||@expr1073759897 (@expr1073759898 src@var4052 .@expr1073759899 isFloat (@expr1073759900 ) &&@expr1073759901 dst@var4053 .@expr1073759902 isFloat (@expr1073759903 ) ) ) {
4876: unsigned long srcSize@var4059 ; srcSize@var4059 =@expr1073759904 ValueFlow ::@expr18081 getSizeOf (@expr1073759906 *@expr1073759907 src@var4052 , settings@var4054 ) ;
4877: unsigned long dstSize@var4060 ; dstSize@var4060 =@expr1073759908 ValueFlow ::@expr18081 getSizeOf (@expr1073759910 *@expr1073759911 dst@var4053 , settings@var4054 ) ;
4878: if (@expr1073759912 srcSize@var4059 >@expr1073759913 dstSize@var4060 ) {
4879: return true ; }
4880: if (@expr1073759914 srcSize@var4059 ==@expr1073759915 dstSize@var4060 &&@expr1073759916 src@var4052 .@expr1073759917 sign@var4061 !=@expr1073759918 dst@var4053 .@expr1073759919 sign@var4062 ) {
4881: return true ; }
4882: } else { if (@expr1073759920 src@var4052 .@expr18097 type@var4063 ==@expr1073759922 dst@var4053 .@expr1073759923 type@var4064 ) {
4883: if (@expr1073759924 src@var4052 .@expr18097 type@var4063 ==@expr1073759926 ValueType ::@expr1073759927 Type ::@expr1073759928 RECORD ) {
4884: return src@var4052 .@expr1073759929 typeScope@var4065 !=@expr1073759930 dst@var4053 .@expr1073759931 typeScope@var4066 ; }
4885: } else {
4886: return true ;
4887: } }
4888: return false ;
4889: }
4890:
4891: static void setSymbolic ( ValueFlow :: Value & value@var4067 , const Token * tok@var4068 )
4892: {
4893: assert (@expr1073759932 tok@var4068 &&@expr1073759933 tok@var4068 .@expr1073759934 exprId (@expr1073759935 ) >@expr1073759936 0 &&@expr1073759937 "Missing expr id for symbolic value" ) ;
4894: value@var4067 .@expr1073759938 valueType@var4069 =@expr1073759939 ValueFlow ::@expr1073759940 Value ::@expr1073759941 ValueType ::@expr1073759942 SYMBOLIC ;
4895: value@var4067 .@expr1073759943 tokvalue@var4070 =@expr1073759944 tok@var4068 ;
4896: }
4897:
4898: static ValueFlow :: Value makeSymbolic ( const Token * tok@var4071 , long long delta@var4072 = 0 )
4899: {
4900: ValueFlow ::@expr1073759945 Value value@var4073 ;
4901: value@var4073 .@expr1073759946 setKnown (@expr1073759947 ) ;
4902: setSymbolic (@expr1073759948 value@var4073 , tok@var4071 ) ;
4903: value@var4073 .@expr1073759949 intvalue@var4074 =@expr1073759950 delta@var4072 ;
4904: return value@var4073 ;
4905: }
4906:
4907: static std :: set < int > getVarIds ( const Token * tok@var4075 )
4908: {
4909: std ::@expr1073759951 set < int > result@var4076 ;
4910: visitAstNodes (@expr1073759952 tok@var4075 , [@expr1073759953 &@expr1073759954 ] (@expr1073759955 const Token *@expr1073759956 child@var4077 ) {
4911: if (@expr1073759957 child@var4077 .@expr18134 varId (@expr18135 ) >@expr1073759960 0 ) {
4912: result@var4076 .@expr1073759961 insert (@expr1073759962 child@var4077 .@expr18134 varId (@expr18135 ) ) ; }
4913: return ChildrenToVisit ::@expr1073759965 op1_and_op2 ;
4914: } ) ;
4915: return result@var4076 ;
4916: }
4917:
4918: static void valueFlowSymbolic ( TokenList * tokenlist@var4078 , SymbolDatabase * symboldatabase@var4079 )
4919: {
4920: for (@expr1073759966 const Scope *@expr18143 scope@var4080 :@expr1073759968 symboldatabase@var4079 .@expr1073759969 functionScopes@var4081 ) {
4921: for (@expr1073759970 Token *@expr18143 tok@var4082 =@expr1073759972 const_cast < Token *@expr18143 > (@expr1073759974 scope@var4080 .@expr1073759975 bodyStart@var4083 ) ; tok@var4082 !=@expr1073759976 scope@var4080 .@expr1073759977 bodyEnd@var4084 ; tok@var4082 =@expr1073759978 tok@var4082 .@expr1073759979 next (@expr1073759980 ) ) {
4922: if (@expr1073759981 !@expr1073759982 Token ::@expr1073759983 simpleMatch (@expr1073759984 tok@var4082 , "=" ) ) {
4923: continue ; }
4924: if (@expr1073759985 tok@var4082 .@expr1073759986 astParent (@expr1073759987 ) ) {
4925: continue ; }
4926: if (@expr1073759988 !@expr1073759989 tok@var4082 .@expr18166 astOperand1 (@expr18167 ) ) {
4927: continue ; }
4928: if (@expr1073759992 !@expr1073759993 tok@var4082 .@expr18170 astOperand2 (@expr18171 ) ) {
4929: continue ; }
4930: if (@expr1073759996 tok@var4082 .@expr18166 astOperand1 (@expr18167 ) .@expr1073759999 hasKnownIntValue (@expr1073760000 ) ) {
4931: continue ; }
4932: if (@expr1073760001 tok@var4082 .@expr18170 astOperand2 (@expr18171 ) .@expr1073760004 hasKnownIntValue (@expr1073760005 ) ) {
4933: continue ; }
4934: if (@expr1073760006 tok@var4082 .@expr18166 astOperand1 (@expr18167 ) .@expr1073760009 exprId (@expr1073760010 ) ==@expr1073760011 0 ) {
4935: continue ; }
4936: if (@expr1073760012 tok@var4082 .@expr18170 astOperand2 (@expr18171 ) .@expr1073760015 exprId (@expr1073760016 ) ==@expr1073760017 0 ) {
4937: continue ; }
4938: if (@expr1073760018 !@expr1073760019 isConstExpression (@expr1073760020 tok@var4082 .@expr18170 astOperand2 (@expr18171 ) , tokenlist@var4078 .@expr18199 getSettings (@expr18200 ) .@expr1073760025 library@var5315 , true , tokenlist@var4078 .@expr1073760026 isCPP (@expr1073760027 ) ) ) {
4939: continue ; }
4940: if (@expr1073760028 tok@var4082 .@expr18166 astOperand1 (@expr18167 ) .@expr18207 valueType (@expr18208 ) &&@expr1073760033 tok@var4082 .@expr18170 astOperand2 (@expr18171 ) .@expr18212 valueType (@expr18213 ) ) {
4941: if (@expr1073760038 isTruncated (@expr1073760039
4942: tok@var4082 .@expr18170 astOperand2 (@expr18171 ) .@expr18212 valueType (@expr18213 ) , tok@var4082 .@expr18166 astOperand1 (@expr18167 ) .@expr18207 valueType (@expr18208 ) , tokenlist@var4078 .@expr18199 getSettings (@expr18200 ) ) ) {
4943: continue ; }
4944: } else { if (@expr1073760050 isDifferentType (@expr1073760051 tok@var4082 .@expr18170 astOperand2 (@expr18171 ) , tok@var4082 .@expr18166 astOperand1 (@expr18167 ) ) ) {
4945: continue ;
4946: } }
4947: const std ::@expr1073760056 set < int > rhsVarIds@var4085 =@expr1073760057 getVarIds (@expr1073760058 tok@var4082 .@expr18170 astOperand2 (@expr18171 ) ) ;
4948: const std ::@expr1073760061 vector < const Variable *@expr18143 > vars@var4086 =@expr1073760063 getLHSVariables (@expr1073760064 tok@var4082 ) ;
4949: if (@expr1073760065 std ::@expr1073760066 any_of (@expr1073760067 vars@var4086 .@expr1073760068 begin (@expr1073760069 ) , vars@var4086 .@expr1073760070 end (@expr1073760071 ) , [@expr1073760072 &@expr1073760073 ] (@expr1073760074 const Variable *@expr18143 var@var4087 ) {
4950: if (@expr1073760076 rhsVarIds@var4085 .@expr1073760077 count (@expr1073760078 var@var4087 .@expr1073760079 declarationId (@expr1073760080 ) ) >@expr1073760081 0 ) {
4951: return true ; }
4952: if (@expr1073760082 var@var4087 .@expr1073760083 isLocal (@expr1073760084 ) ) {
4953: return var@var4087 .@expr1073760085 isStatic (@expr1073760086 ) ; }
4954: return !@expr1073760087 var@var4087 .@expr1073760088 isArgument (@expr1073760089 ) ;
4955: } ) ) {
4956: continue ; }
4957:
4958: if (@expr1073760090 findAstNode (@expr1073760091 tok@var4082 , [@expr1073760092 ] (@expr1073760093 const Token *@expr18143 child@var4088 ) {
4959: return child@var4088 .@expr1073760095 isIncompleteVar (@expr1073760096 ) ;
4960: } ) ) {
4961: continue ; }
4962:
4963: Token * start@var4089 ; start@var4089 =@expr1073760097 nextAfterAstRightmostLeaf (@expr1073760098 tok@var4082 ) ;
4964: const Token * end@var4090 ; end@var4090 =@expr1073760099 getEndOfExprScope (@expr1073760100 tok@var4082 .@expr18166 astOperand1 (@expr18167 ) , scope@var4080 ) ;
4965:
4966: ValueFlow ::@expr1073760103 Value rhs@var4091 ; rhs@var4091 =@expr1073760104 makeSymbolic (@expr1073760105 tok@var4082 .@expr18170 astOperand2 (@expr18171 ) ) ;
4967: rhs@var4091 .@expr1073760108 errorPath@var4092 .@expr1073760109 emplace_back (@expr1073760110 tok@var4082 ,
4968: tok@var4082 .@expr18166 astOperand1 (@expr18167 ) .@expr18289 expressionString (@expr18290 ) +@expr18291 " is assigned '" +@expr18292
4969: tok@var4082 .@expr18170 astOperand2 (@expr18171 ) .@expr18295 expressionString (@expr18296 ) +@expr18297 "' here." ) ;
4970: valueFlowForward (@expr1073760122 start@var4089 , end@var4090 , tok@var4082 .@expr18166 astOperand1 (@expr18167 ) , {@expr1073760125 rhs@var4091 } , tokenlist@var4078 , tokenlist@var4078 .@expr18199 getSettings (@expr18200 ) ) ;
4971:
4972: ValueFlow ::@expr1073760128 Value lhs@var4093 ; lhs@var4093 =@expr1073760129 makeSymbolic (@expr1073760130 tok@var4082 .@expr18166 astOperand1 (@expr18167 ) ) ;
4973: lhs@var4093 .@expr1073760133 errorPath@var4094 .@expr1073760134 emplace_back (@expr1073760135 tok@var4082 ,
4974: tok@var4082 .@expr18166 astOperand1 (@expr18167 ) .@expr18289 expressionString (@expr18290 ) +@expr18291 " is assigned '" +@expr18292
4975: tok@var4082 .@expr18170 astOperand2 (@expr18171 ) .@expr18295 expressionString (@expr18296 ) +@expr18297 "' here." ) ;
4976: valueFlowForward (@expr1073760147 start@var4089 , end@var4090 , tok@var4082 .@expr18170 astOperand2 (@expr18171 ) , {@expr1073760150 lhs@var4093 } , tokenlist@var4078 , tokenlist@var4078 .@expr18199 getSettings (@expr18200 ) ) ;
4977: }
4978: }
4979: }
4980:
4981: static void valueFlowSymbolicIdentity ( TokenList * tokenlist@var4095 )
4982: {
4983: for (@expr1073760154 Token *@expr1073760155 tok@var4096 =@expr1073760156 tokenlist@var4095 .@expr1073760157 front (@expr1073760158 ) ; tok@var4096 ; tok@var4096 =@expr1073760159 tok@var4096 .@expr1073760160 next (@expr1073760161 ) ) {
4984: if (@expr1073760162 tok@var4096 .@expr1073760163 hasKnownIntValue (@expr1073760164 ) ) {
4985: continue ; }
4986: if (@expr1073760165 !@expr1073760166 Token ::@expr18343 Match (@expr1073760168 tok@var4096 , "*|/|<<|>>|^|+|-|%or%" ) ) {
4987: continue ; }
4988: if (@expr1073760169 !@expr1073760170 tok@var4096 .@expr18347 astOperand1 (@expr18348 ) ) {
4989: continue ; }
4990: if (@expr1073760173 !@expr1073760174 tok@var4096 .@expr18351 astOperand2 (@expr18352 ) ) {
4991: continue ; }
4992: if (@expr1073760177 !@expr1073760178 astIsIntegral (@expr1073760179 tok@var4096 .@expr18347 astOperand1 (@expr18348 ) , false ) &&@expr1073760182 !@expr1073760183 astIsIntegral (@expr1073760184 tok@var4096 .@expr18351 astOperand2 (@expr18352 ) , false ) ) {
4993: continue ; }
4994: const ValueFlow ::@expr1073760187 Value * constant@var4097 ; constant@var4097 =@expr1073760188 nullptr ;
4995: const Token * vartok@var4098 ; vartok@var4098 =@expr1073760189 nullptr ;
4996: if (@expr1073760190 tok@var4096 .@expr18347 astOperand1 (@expr18348 ) .@expr1073760193 hasKnownIntValue (@expr1073760194 ) ) {
4997: constant@var4097 =@expr1073760195 &@expr1073760196 tok@var4096 .@expr18347 astOperand1 (@expr18348 ) .@expr1073760199 values (@expr1073760200 ) .@expr1073760201 front (@expr1073760202 ) ;
4998: vartok@var4098 =@expr1073760203 tok@var4096 .@expr18351 astOperand2 (@expr18352 ) ;
4999: }
5000: if (@expr1073760206 tok@var4096 .@expr18351 astOperand2 (@expr18352 ) .@expr1073760209 hasKnownIntValue (@expr1073760210 ) ) {
5001: constant@var4097 =@expr1073760211 &@expr1073760212 tok@var4096 .@expr18351 astOperand2 (@expr18352 ) .@expr1073760215 values (@expr1073760216 ) .@expr1073760217 front (@expr1073760218 ) ;
5002: vartok@var4098 =@expr1073760219 tok@var4096 .@expr18347 astOperand1 (@expr18348 ) ;
5003: }
5004: if (@expr1073760222 !@expr1073760223 constant@var4097 ) {
5005: continue ; }
5006: if (@expr1073760224 !@expr1073760225 vartok@var4098 ) {
5007: continue ; }
5008: if (@expr1073760226 vartok@var4098 .@expr18403 exprId (@expr18404 ) ==@expr1073760229 0 ) {
5009: continue ; }
5010: if (@expr1073760230 Token ::@expr18343 Match (@expr1073760232 tok@var4096 , "<<|>>|/" ) &&@expr1073760233 !@expr1073760234 astIsLHS (@expr1073760235 vartok@var4098 ) ) {
5011: continue ; }
5012: if (@expr1073760236 Token ::@expr18343 Match (@expr1073760238 tok@var4096 , "<<|>>|^|+|-|%or%" ) &&@expr1073760239 constant@var4097 .@expr18416 intvalue@var4099 !=@expr1073760241 0 ) {
5013: continue ; }
5014: if (@expr1073760242 Token ::@expr18343 Match (@expr1073760244 tok@var4096 , "*|/" ) &&@expr1073760245 constant@var4097 .@expr18416 intvalue@var4099 !=@expr1073760247 1 ) {
5015: continue ; }
5016: std ::@expr1073760248 vector < ValueFlow ::@expr18425 Value > values@var4100 ; values@var4100 =@expr1073760250 {@expr1073760251 makeSymbolic (@expr1073760252 vartok@var4098 ) } ;
5017: std ::@expr1073760253 unordered_set < int > ids@var4101 ; ids@var4101 =@expr1073760254 {@expr1073760255 vartok@var4098 .@expr18403 exprId (@expr18404 ) } ;
5018: std ::@expr1073760258 copy_if (@expr1073760259
5019: vartok@var4098 .@expr18436 values (@expr18437 ) .@expr1073760262 begin (@expr1073760263 ) , vartok@var4098 .@expr18436 values (@expr18437 ) .@expr1073760266 end (@expr1073760267 ) , std ::@expr1073760268 back_inserter (@expr1073760269 values@var4100 ) , [@expr1073760270 &@expr18447 ] (@expr1073760272 const ValueFlow ::@expr18425 Value &@expr18447 v@var4102 ) {
5020: if (@expr1073760275 !@expr1073760276 v@var4102 .@expr1073760277 isSymbolicValue (@expr1073760278 ) ) {
5021: return false ; }
5022: if (@expr1073760279 !@expr1073760280 v@var4102 .@expr18457 tokvalue@var4103 ) {
5023: return false ; }
5024: return ids@var4101 .@expr1073760282 insert (@expr1073760283 v@var4102 .@expr18457 tokvalue@var4103 .@expr1073760285 exprId (@expr1073760286 ) ) .@expr1073760287 second@expr1073760153 ;
5025: } ) ;
5026: for (@expr1073760288 const ValueFlow ::@expr18425 Value &@expr18447 v@var4104 :@expr1073760291 values@var4100 ) {
5027: setTokenValue (@expr1073760292 tok@var4096 , v@var4104 , tokenlist@var4095 .@expr1073760293 getSettings (@expr1073760294 ) ) ; }
5028: }
5029: }
5030:
5031: static void valueFlowSymbolicAbs ( TokenList * tokenlist@var4105 , SymbolDatabase * symboldatabase@var4106 )
5032: {
5033: for (@expr1073760295 const Scope *@expr18472 scope@var4107 :@expr1073760297 symboldatabase@var4106 .@expr1073760298 functionScopes@var4108 ) {
5034: for (@expr1073760299 Token *@expr18472 tok@var4109 =@expr1073760301 const_cast < Token *@expr18472 > (@expr1073760303 scope@var4107 .@expr1073760304 bodyStart@var4110 ) ; tok@var4109 !=@expr1073760305 scope@var4107 .@expr1073760306 bodyEnd@var4111 ; tok@var4109 =@expr1073760307 tok@var4109 .@expr18484 next (@expr18485 ) ) {
5035: if (@expr1073760310 !@expr1073760311 Token ::@expr1073760312 Match (@expr1073760313 tok@var4109 , "abs|labs|llabs|fabs|fabsf|fabsl (" ) ) {
5036: continue ; }
5037: if (@expr1073760314 tok@var4109 .@expr1073760315 hasKnownIntValue (@expr1073760316 ) ) {
5038: continue ; }
5039:
5040: const Token * arg@var4112 ; arg@var4112 =@expr1073760317 tok@var4109 .@expr18484 next (@expr18485 ) .@expr1073760320 astOperand2 (@expr1073760321 ) ;
5041: if (@expr1073760322 !@expr1073760323 arg@var4112 ) {
5042: continue ; }
5043: ValueFlow ::@expr1073760324 Value c@var4113 ; c@var4113 =@expr1073760325 inferCondition (@expr1073760326 ">=" , arg@var4112 , 0 ) ;
5044: if (@expr1073760327 !@expr1073760328 c@var4113 .@expr1073760329 isKnown (@expr1073760330 ) ) {
5045: continue ; }
5046:
5047: ValueFlow ::@expr1073760331 Value v@var4114 ; v@var4114 =@expr1073760332 makeSymbolic (@expr1073760333 arg@var4112 ) ;
5048: v@var4114 .@expr18510 errorPath@var4115 =@expr1073760335 c@var4113 .@expr1073760336 errorPath@var4116 ;
5049: v@var4114 .@expr18510 errorPath@var4115 .@expr1073760338 emplace_back (@expr1073760339 tok@var4109 , "Passed to " +@expr1073760340 tok@var4109 .@expr1073760341 str (@expr1073760342 ) ) ;
5050: if (@expr1073760343 c@var4113 .@expr1073760344 intvalue@var4117 ==@expr1073760345 0 ) {
5051: v@var4114 .@expr1073760346 setImpossible (@expr1073760347 ) ; }
5052: else {
5053: v@var4114 .@expr1073760348 setKnown (@expr1073760349 ) ; }
5054: setTokenValue (@expr1073760350 tok@var4109 .@expr18484 next (@expr18485 ) , v@var4114 , tokenlist@var4105 .@expr1073760353 getSettings (@expr1073760354 ) ) ;
5055: }
5056: }
5057: }
5058:
5059: struct SymbolicInferModel : InferModel {
5060: const Token * expr@var4118 ;
5061: explicit SymbolicInferModel ( const Token * tok@var4119 ) : expr@var4118 ( tok@var4119 ) {
5062: assert (@expr1073760355 expr@var4118 .@expr1073760356 exprId (@expr1073760357 ) !=@expr1073760358 0 ) ;
5063: }
5064: virtual bool match ( const ValueFlow :: Value & value@var4120 ) const override
5065: {
5066: return value@var4120 .@expr1073760359 isSymbolicValue (@expr1073760360 ) &&@expr1073760361 value@var4120 .@expr18538 tokvalue@var4121 &&@expr1073760363 value@var4120 .@expr18538 tokvalue@var4121 .@expr1073760365 exprId (@expr1073760366 ) ==@expr1073760367 expr@var4118 .@expr1073760368 exprId (@expr1073760369 ) ;
5067: }
5068: virtual ValueFlow :: Value yield ( long long value@var4122 ) const override
5069: {
5070: ValueFlow ::@expr1073760370 Value result@var4123 (@expr1073760371 value@var4122 ) ;
5071: result@var4123 .@expr1073760372 valueType@var4124 =@expr1073760373 ValueFlow ::@expr1073760374 Value ::@expr1073760375 ValueType ::@expr1073760376 SYMBOLIC ;
5072: result@var4123 .@expr1073760377 tokvalue@var4125 =@expr1073760378 expr@var4118 ;
5073: result@var4123 .@expr1073760379 setKnown (@expr1073760380 ) ;
5074: return result@var4123 ;
5075: }
5076: } ;
5077:
5078: static void valueFlowSymbolicInfer ( TokenList * tokenlist@var4126 , SymbolDatabase * symboldatabase@var4127 )
5079: {
5080: for (@expr1073760381 const Scope *@expr18558 scope@var4128 :@expr1073760383 symboldatabase@var4127 .@expr1073760384 functionScopes@var4129 ) {
5081: for (@expr1073760385 Token *@expr18558 tok@var4130 =@expr1073760387 const_cast < Token *@expr18558 > (@expr1073760389 scope@var4128 .@expr1073760390 bodyStart@var4131 ) ; tok@var4130 !=@expr1073760391 scope@var4128 .@expr1073760392 bodyEnd@var4132 ; tok@var4130 =@expr1073760393 tok@var4130 .@expr1073760394 next (@expr1073760395 ) ) {
5082: if (@expr1073760396 !@expr1073760397 Token ::@expr1073760398 Match (@expr1073760399 tok@var4130 , "-|%comp%" ) ) {
5083: continue ; }
5084: if (@expr1073760400 tok@var4130 .@expr1073760401 hasKnownIntValue (@expr1073760402 ) ) {
5085: continue ; }
5086: if (@expr1073760403 !@expr1073760404 tok@var4130 .@expr18581 astOperand1 (@expr18582 ) ) {
5087: continue ; }
5088: if (@expr1073760407 !@expr1073760408 tok@var4130 .@expr18585 astOperand2 (@expr18586 ) ) {
5089: continue ; }
5090: if (@expr1073760411 tok@var4130 .@expr18581 astOperand1 (@expr18582 ) .@expr1073760414 exprId (@expr1073760415 ) ==@expr1073760416 0 ) {
5091: continue ; }
5092: if (@expr1073760417 tok@var4130 .@expr18585 astOperand2 (@expr18586 ) .@expr1073760420 exprId (@expr1073760421 ) ==@expr1073760422 0 ) {
5093: continue ; }
5094: if (@expr1073760423 tok@var4130 .@expr18581 astOperand1 (@expr18582 ) .@expr1073760426 hasKnownIntValue (@expr1073760427 ) ) {
5095: continue ; }
5096: if (@expr1073760428 tok@var4130 .@expr18585 astOperand2 (@expr18586 ) .@expr1073760431 hasKnownIntValue (@expr1073760432 ) ) {
5097: continue ; }
5098: if (@expr1073760433 astIsFloat (@expr1073760434 tok@var4130 .@expr18581 astOperand1 (@expr18582 ) , false ) ) {
5099: continue ; }
5100: if (@expr1073760437 astIsFloat (@expr1073760438 tok@var4130 .@expr18585 astOperand2 (@expr18586 ) , false ) ) {
5101: continue ; }
5102:
5103: SymbolicInferModel leftModel@var4133 {@expr1073760441 tok@var4130 .@expr18581 astOperand1 (@expr18582 ) } ;
5104: std ::@expr1073760444 vector < ValueFlow ::@expr18621 Value > values@var4134 ; values@var4134 =@expr1073760446 infer (@expr1073760447 leftModel@var4133 , tok@var4130 .@expr18624 str (@expr18625 ) , 0 , tok@var4130 .@expr18585 astOperand2 (@expr18586 ) .@expr1073760452 values (@expr1073760453 ) ) ;
5105: if (@expr1073760454 values@var4134 .@expr1073760455 empty (@expr1073760456 ) ) {
5106: SymbolicInferModel rightModel@var4135 {@expr1073760457 tok@var4130 .@expr18585 astOperand2 (@expr18586 ) } ;
5107: values@var4134 =@expr1073760460 infer (@expr1073760461 rightModel@var4135 , tok@var4130 .@expr18624 str (@expr18625 ) , tok@var4130 .@expr18581 astOperand1 (@expr18582 ) .@expr1073760466 values (@expr1073760467 ) , 0 ) ;
5108: }
5109: for (@expr1073760468 const ValueFlow ::@expr18621 Value &@expr1073760470 value@var4136 :@expr1073760471 values@var4134 ) {
5110: setTokenValue (@expr1073760472 tok@var4130 , value@var4136 , tokenlist@var4126 .@expr1073760473 getSettings (@expr1073760474 ) ) ;
5111: }
5112: }
5113: }
5114: }
5115:
5116: template < class ContainerOfValue >
5117: static void valueFlowForwardConst ( Token * start@var4137 ,
5118: const Token * end@var4138 ,
5119: const Variable * var@var4139 ,
5120: const ContainerOfValue & values@var4140 ,
5121: const Settings * const settings@var4141 )
5122: {
5123: for (@expr1073760475 Token *@expr1073760476 tok@var4142 =@expr1073760477 start@var4137 ; tok@var4142 !=@expr1073760478 end@var4138 ; tok@var4142 =@expr1073760479 tok@var4142 .@expr1073760480 next (@expr1073760481 ) ) {
5124: if (@expr1073760482 tok@var4142 .@expr1073760483 varId (@expr1073760484 ) ==@expr1073760485 var@var4139 .@expr18662 declarationId (@expr18663 ) ) {
5125: for (@expr1073760488 const ValueFlow ::@expr18665 Value &@expr18666 value@var4143 :@expr1073760491 values@var4140 ) {
5126: setTokenValue (@expr1073760492 tok@var4142 , value@var4143 , settings@var4141 ) ; }
5127: } else {
5128: [@expr1073760493 &@expr18666 ] {
5129:
5130: std ::@expr1073760495 vector < ReferenceToken > refs@var4144 ; refs@var4144 =@expr1073760496 followAllReferences (@expr1073760497 tok@var4142 ) ;
5131: for (@expr1073760498 const ReferenceToken &@expr18666 ref@var4145 :@expr1073760500 refs@var4144 ) {
5132: if (@expr1073760501 ref@var4145 .@expr1073760502 token@var4146 .@expr1073760503 varId (@expr1073760504 ) ==@expr1073760505 var@var4139 .@expr18662 declarationId (@expr18663 ) ) {
5133: for (@expr1073760508 ValueFlow ::@expr18665 Value value@var4147 :@expr1073760510 values@var4140 ) {
5134: if (@expr1073760511 refs@var4144 .@expr1073760512 size (@expr1073760513 ) >@expr1073760514 1 ) {
5135: value@var4147 .@expr1073760515 setInconclusive (@expr1073760516 ) ; }
5136: value@var4147 .@expr18693 errorPath@var4148 .@expr1073760518 insert (@expr1073760519 value@var4147 .@expr18693 errorPath@var4148 .@expr1073760521 end (@expr1073760522 ) , ref@var4145 .@expr18699 errors@var4149 .@expr1073760524 begin (@expr1073760525 ) , ref@var4145 .@expr18699 errors@var4149 .@expr1073760527 end (@expr1073760528 ) ) ;
5137: setTokenValue (@expr1073760529 tok@var4142 , value@var4147 , settings@var4141 ) ;
5138: }
5139: return ;
5140: }
5141: }
5142:
5143: for (@expr1073760530 const ValueFlow ::@expr18665 Value &@expr18666 v@var4150 :@expr1073760533 tok@var4142 .@expr1073760534 values (@expr1073760535 ) ) {
5144: if (@expr1073760536 !@expr1073760537 v@var4150 .@expr1073760538 isSymbolicValue (@expr1073760539 ) ) {
5145: continue ; }
5146: if (@expr1073760540 !@expr1073760541 v@var4150 .@expr18718 tokvalue@var4151 ) {
5147: continue ; }
5148: if (@expr1073760543 v@var4150 .@expr18718 tokvalue@var4151 .@expr1073760545 varId (@expr1073760546 ) !=@expr1073760547 var@var4139 .@expr18662 declarationId (@expr18663 ) ) {
5149: continue ; }
5150: for (@expr1073760550 ValueFlow ::@expr18665 Value value@var4152 :@expr1073760552 values@var4140 ) {
5151: if (@expr1073760553 v@var4150 .@expr18730 intvalue@var4153 !=@expr1073760555 0 ) {
5152: if (@expr1073760556 !@expr1073760557 value@var4152 .@expr1073760558 isIntValue (@expr1073760559 ) ) {
5153: continue ; }
5154: value@var4152 .@expr1073760560 intvalue@var4154 +=@expr1073760561 v@var4150 .@expr18730 intvalue@var4153 ;
5155: }
5156: value@var4152 .@expr1073760563 valueKind@var4155 =@expr1073760564 v@var4150 .@expr1073760565 valueKind@var4156 ;
5157: value@var4152 .@expr1073760566 bound@var4157 =@expr1073760567 v@var4150 .@expr1073760568 bound@var4158 ;
5158: value@var4152 .@expr18745 errorPath@var4159 .@expr1073760570 insert (@expr1073760571 value@var4152 .@expr18745 errorPath@var4159 .@expr1073760573 end (@expr1073760574 ) , v@var4150 .@expr18751 errorPath@var4160 .@expr1073760576 begin (@expr1073760577 ) , v@var4150 .@expr18751 errorPath@var4160 .@expr1073760579 end (@expr1073760580 ) ) ;
5159: setTokenValue (@expr1073760581 tok@var4142 , value@var4152 , settings@var4141 ) ;
5160: }
5161: }
5162: } (@expr1073760582 ) ;
5163: }
5164: }
5165: }
5166:
5167: static void valueFlowForwardAssign ( Token * const tok@var4161 ,
5168: const Token * expr@var4162 ,
5169: std :: vector < const Variable * > vars@var4163 ,
5170: std :: list < ValueFlow :: Value > values@var4164 ,
5171: const bool init@var4165 ,
5172: TokenList * const tokenlist@var4166 ,
5173: ErrorLogger * const errorLogger@var4167 ,
5174: const Settings * const settings@var4168 )
5175: {
5176: if (@expr1073760584 Token ::@expr1073760585 simpleMatch (@expr1073760586 tok@var4161 .@expr18763 astParent (@expr18764 ) , "return" ) ) {
5177: return ; }
5178: const Token * endOfVarScope@var4169 ; endOfVarScope@var4169 =@expr1073760589 getEndOfExprScope (@expr1073760590 expr@var4162 ) ;
5179: if (@expr1073760591 std ::@expr18768 any_of (@expr1073760593 values@var4164 .@expr18770 begin (@expr18771 ) , values@var4164 .@expr18772 end (@expr18773 ) , std ::@expr18774 mem_fn (@expr18775 &@expr18776 ValueFlow ::@expr18777 Value ::@expr18778 isLifetimeValue ) ) ) {
5180: valueFlowForwardLifetime (@expr1073760603 tok@var4161 , tokenlist@var4166 , errorLogger@var4167 , settings@var4168 ) ;
5181: values@var4164 .@expr18780 remove_if (@expr1073760605 std ::@expr18774 mem_fn (@expr18775 &@expr18776 ValueFlow ::@expr18777 Value ::@expr18778 isLifetimeValue ) ) ;
5182: }
5183: if (@expr1073760611 std ::@expr1073760612 all_of (@expr1073760613
5184: vars@var4163 .@expr18790 begin (@expr18791 ) , vars@var4163 .@expr18792 end (@expr18793 ) , [@expr1073760618 &@expr18795 ] (@expr1073760620 const Variable *@expr18797 var@var4170 ) {
5185: return !@expr1073760622 var@var4170 .@expr1073760623 isPointer (@expr1073760624 ) &&@expr1073760625 !@expr1073760626 var@var4170 .@expr1073760627 isSmartPointer (@expr1073760628 ) ;
5186: } ) ) {
5187: values@var4164 .@expr18780 remove_if (@expr1073760630 std ::@expr18774 mem_fn (@expr1073760632 &@expr1073760633 ValueFlow ::@expr18777 Value ::@expr1073760635 isTokValue ) ) ; }
5188: if (@expr1073760636 tok@var4161 .@expr18763 astParent (@expr18764 ) ) {
5189: for (@expr1073760639 ValueFlow ::@expr18816 Value &@expr18795 value@var4171 :@expr1073760642 values@var4164 ) {
5190: std ::@expr1073760643 string valueKind@var4172 ;
5191: if (@expr1073760644 value@var4171 .@expr1073760645 valueKind@var4173 ==@expr1073760646 ValueFlow ::@expr18777 Value ::@expr1073760648 ValueKind ::@expr1073760649 Impossible ) {
5192: if (@expr1073760650 value@var4171 .@expr18827 bound@var4174 ==@expr1073760652 ValueFlow ::@expr18777 Value ::@expr18830 Bound ::@expr1073760655 Point@expr1073760583 ) {
5193: valueKind@var4172 =@expr1073760656 "never " ; }
5194: else { if (@expr1073760657 value@var4171 .@expr18827 bound@var4174 ==@expr1073760659 ValueFlow ::@expr18777 Value ::@expr18830 Bound ::@expr1073760662 Lower ) {
5195: valueKind@var4172 =@expr1073760663 "less than " ; }
5196: else { if (@expr1073760664 value@var4171 .@expr18827 bound@var4174 ==@expr1073760666 ValueFlow ::@expr18777 Value ::@expr18830 Bound ::@expr1073760669 Upper ) {
5197: valueKind@var4172 =@expr1073760670 "greater than " ; } } }
5198: }
5199: const std ::@expr18816 string info@var4175 =@expr1073760672 "Assignment '" +@expr1073760673 tok@var4161 .@expr18763 astParent (@expr18764 ) .@expr1073760676 expressionString (@expr1073760677 ) +@expr1073760678 "', assigned value is " +@expr1073760679 valueKind@var4172 +@expr1073760680 value@var4171 .@expr1073760681 infoString (@expr1073760682 ) ;
5200: value@var4171 .@expr1073760683 errorPath@var4176 .@expr1073760684 emplace_back (@expr1073760685 tok@var4161 , info@var4175 ) ;
5201: }
5202: }
5203:
5204: if (@expr1073760686 tokenlist@var4166 .@expr1073760687 isCPP (@expr1073760688 ) &&@expr1073760689 vars@var4163 .@expr18866 size (@expr18867 ) ==@expr18868 1 &&@expr1073760693 Token ::@expr1073760694 Match (@expr1073760695 vars@var4163 .@expr18872 front (@expr18873 ) .@expr1073760698 typeStartToken (@expr1073760699 ) , "bool|_Bool" ) ) {
5205: for (@expr1073760700 ValueFlow ::@expr18816 Value &@expr18795 value@var4177 :@expr1073760703 values@var4164 ) {
5206: if (@expr1073760704 value@var4177 .@expr1073760705 isImpossible (@expr1073760706 ) ) {
5207: continue ; }
5208: if (@expr1073760707 value@var4177 .@expr1073760708 isIntValue (@expr1073760709 ) ) {
5209: value@var4177 .@expr18886 intvalue@var4178 =@expr1073760711 value@var4177 .@expr18886 intvalue@var4178 !=@expr1073760713 0 ; }
5210: if (@expr1073760714 value@var4177 .@expr1073760715 isTokValue (@expr1073760716 ) ) {
5211: value@var4177 .@expr18886 intvalue@var4178 =@expr1073760718 value@var4177 .@expr1073760719 tokvalue@var4179 !=@expr1073760720 nullptr ; }
5212: }
5213: }
5214:
5215:
5216: if (@expr1073760721 vars@var4163 .@expr18866 size (@expr18867 ) ==@expr18868 1 &&@expr1073760725 vars@var4163 .@expr18872 front (@expr18873 ) .@expr1073760728 isStatic (@expr1073760729 ) &&@expr1073760730 init@var4165 ) {
5217: lowerToPossible (@expr18907 values@var4164 ) ; }
5218:
5219:
5220: if (@expr1073760732 std ::@expr18768 any_of (@expr1073760734 vars@var4163 .@expr18790 begin (@expr18791 ) , vars@var4163 .@expr18792 end (@expr18793 ) , [@expr1073760739 &@expr18795 ] (@expr1073760741 const Variable *@expr18797 var@var4180 ) {
5221: return var@var4180 .@expr1073760743 isVolatile (@expr1073760744 ) ;
5222: } ) ) {
5223: lowerToPossible (@expr18907 values@var4164 ) ; }
5224:
5225:
5226: const Token * nextExpression@var4181 ; nextExpression@var4181 =@expr1073760746 tok@var4161 .@expr18763 astParent (@expr18764 ) ?@expr1073760749 nextAfterAstRightmostLeaf (@expr1073760750 tok@var4161 .@expr18763 astParent (@expr18764 ) ) :@expr1073760753 tok@var4161 .@expr1073760754 next (@expr1073760755 ) ;
5227: if (@expr1073760756 !@expr1073760757 nextExpression@var4181 ) {
5228: return ; }
5229:
5230: for (@expr1073760758 ValueFlow ::@expr18816 Value &@expr18795 value@var4182 :@expr1073760761 values@var4164 ) {
5231: if (@expr1073760762 value@var4182 .@expr1073760763 isSymbolicValue (@expr1073760764 ) ) {
5232: continue ; }
5233: if (@expr1073760765 value@var4182 .@expr1073760766 isTokValue (@expr1073760767 ) ) {
5234: continue ; }
5235: value@var4182 .@expr1073760768 tokvalue@var4183 =@expr1073760769 tok@var4161 ;
5236: }
5237:
5238: if (@expr1073760770 expr@var4162 .@expr18947 variable (@expr18948 ) &&@expr1073760773 expr@var4162 .@expr18947 variable (@expr18948 ) .@expr1073760776 isConst (@expr1073760777 ) &&@expr1073760778 !@expr1073760779 expr@var4162 .@expr18947 variable (@expr18948 ) .@expr1073760782 isReference (@expr1073760783 ) ) {
5239: auto it@var4184 ; it@var4184 =@expr1073760784 std ::@expr1073760785 remove_if (@expr1073760786 values@var4164 .@expr18770 begin (@expr18771 ) , values@var4164 .@expr18772 end (@expr18773 ) , [@expr1073760791 ] (@expr1073760792 const ValueFlow ::@expr18816 Value &@expr18795 value@var4185 ) {
5240: if (@expr1073760795 !@expr1073760796 value@var4185 .@expr1073760797 isKnown (@expr1073760798 ) ) {
5241: return false ; }
5242: if (@expr1073760799 value@var4185 .@expr1073760800 isIntValue (@expr1073760801 ) ) {
5243: return true ; }
5244: if (@expr1073760802 value@var4185 .@expr1073760803 isFloatValue (@expr1073760804 ) ) {
5245: return true ; }
5246: if (@expr1073760805 value@var4185 .@expr1073760806 isContainerSizeValue (@expr1073760807 ) ) {
5247: return true ; }
5248: if (@expr1073760808 value@var4185 .@expr1073760809 isIteratorValue (@expr1073760810 ) ) {
5249: return true ; }
5250: return false ;
5251: } ) ;
5252: std ::@expr1073760811 list < ValueFlow ::@expr18816 Value > constValues@var4186 ;
5253: constValues@var4186 .@expr1073760813 splice (@expr1073760814 constValues@var4186 .@expr1073760815 end (@expr1073760816 ) , values@var4164 , it@var4184 , values@var4164 .@expr18772 end (@expr18773 ) ) ;
5254: valueFlowForwardConst (@expr1073760819 const_cast < Token *@expr18797 > (@expr18997 nextExpression@var4181 ) , endOfVarScope@var4169 , expr@var4162 .@expr18947 variable (@expr18948 ) , constValues@var4186 , settings@var4168 ) ;
5255: }
5256: valueFlowForward (@expr1073760824 const_cast < Token *@expr18797 > (@expr18997 nextExpression@var4181 ) , endOfVarScope@var4169 , expr@var4162 , values@var4164 , tokenlist@var4166 , settings@var4168 ) ;
5257: }
5258:
5259: static void valueFlowForwardAssign ( Token * const tok@var4187 ,
5260: const Variable * const var@var4188 ,
5261: const std :: list < ValueFlow :: Value > & values@var4189 ,
5262: const bool ,
5263: const bool init@var4190 ,
5264: TokenList * const tokenlist@var4191 ,
5265: ErrorLogger * const errorLogger@var4192 ,
5266: const Settings * const settings@var4193 )
5267: {
5268: valueFlowForwardAssign (@expr1073760827 tok@var4187 , var@var4188 .@expr1073760828 nameToken (@expr1073760829 ) , {@expr1073760830 var@var4188 } , values@var4189 , init@var4190 , tokenlist@var4191 , errorLogger@var4192 , settings@var4193 ) ;
5269: }
5270:
5271: static std :: list < ValueFlow :: Value > truncateValues ( std :: list < ValueFlow :: Value > values@var4194 ,
5272: const ValueType * dst@var4195 ,
5273: const ValueType * src@var4196 ,
5274: const Settings * settings@var4197 )
5275: {
5276: if (@expr1073760831 !@expr1073760832 dst@var4195 ||@expr1073760833 !@expr1073760834 dst@var4195 .@expr1073760835 isIntegral (@expr1073760836 ) ) {
5277: return values@var4194 ; }
5278:
5279: const unsigned long sz@var4198 =@expr1073760837 ValueFlow ::@expr19014 getSizeOf (@expr1073760839 *@expr1073760840 dst@var4195 , settings@var4197 ) ;
5280:
5281: if (@expr1073760841 src@var4196 ) {
5282: const unsigned long osz@var4199 =@expr1073760842 ValueFlow ::@expr19014 getSizeOf (@expr1073760844 *@expr1073760845 src@var4196 , settings@var4197 ) ;
5283: if (@expr1073760846 osz@var4199 >=@expr1073760847 sz@var4198 &&@expr1073760848 dst@var4195 .@expr19025 sign@var4200 ==@expr19026 ValueType ::@expr19027 Sign ::@expr19028 SIGNED &&@expr1073760853 src@var4196 .@expr1073760854 sign@var4201 ==@expr1073760855 ValueType ::@expr19027 Sign ::@expr1073760857 UNSIGNED ) {
5284: values@var4194 .@expr1073760858 remove_if (@expr1073760859 [@expr1073760860 &@expr19037 ] (@expr1073760862 const ValueFlow ::@expr19039 Value &@expr19037 value@var4202 ) {
5285: if (@expr1073760865 !@expr1073760866 value@var4202 .@expr1073760867 isIntValue (@expr1073760868 ) ) {
5286: return false ; }
5287: if (@expr1073760869 !@expr1073760870 value@var4202 .@expr1073760871 isImpossible (@expr1073760872 ) ) {
5288: return false ; }
5289: if (@expr1073760873 value@var4202 .@expr1073760874 bound@var4203 !=@expr1073760875 ValueFlow ::@expr19052 Value ::@expr1073760877 Bound ::@expr1073760878 Upper ) {
5290: return false ; }
5291: if (@expr1073760879 osz@var4199 ==@expr1073760880 sz@var4198 &&@expr1073760881 value@var4202 .@expr1073760882 intvalue@var4204 <@expr1073760883 0 ) {
5292: return true ; }
5293: if (@expr1073760884 osz@var4199 >@expr1073760885 sz@var4198 ) {
5294: return true ; }
5295: return false ;
5296: } ) ;
5297: }
5298: }
5299:
5300: for (@expr1073760886 ValueFlow ::@expr19039 Value &@expr19037 value@var4205 :@expr1073760889 values@var4194 ) {
5301:
5302: if (@expr1073760890 value@var4205 .@expr1073760891 isImpossible (@expr1073760892 ) ) {
5303: continue ; }
5304: if (@expr1073760893 value@var4205 .@expr1073760894 isFloatValue (@expr1073760895 ) ) {
5305: value@var4205 .@expr19072 intvalue@var4206 =@expr1073760897 value@var4205 .@expr1073760898 floatValue@var4207 ;
5306: value@var4205 .@expr1073760899 valueType@var4208 =@expr1073760900 ValueFlow ::@expr19052 Value ::@expr1073760902 ValueType ::@expr1073760903 INT ;
5307: }
5308:
5309: if (@expr1073760904 value@var4205 .@expr1073760905 isIntValue (@expr1073760906 ) &&@expr1073760907 sz@var4198 >@expr1073760908 0 &&@expr1073760909 sz@var4198 <@expr1073760910 8 ) {
5310: const unsigned long long unsignedMaxValue@var4209 =@expr1073760911 (@expr1073760912 1ULL <<@expr1073760913 (@expr1073760914 sz@var4198 *@expr19091 8 ) ) -@expr1073760916 1ULL ;
5311: const unsigned long long signBit@var4210 =@expr1073760917 1ULL <<@expr1073760918 (@expr1073760919 sz@var4198 *@expr19091 8 -@expr1073760921 1 ) ;
5312: value@var4205 .@expr19072 intvalue@var4206 &=@expr1073760923 unsignedMaxValue@var4209 ;
5313: if (@expr1073760924 dst@var4195 .@expr19025 sign@var4200 ==@expr19026 ValueType ::@expr19027 Sign ::@expr19028 SIGNED &&@expr1073760929 (@expr1073760930 value@var4205 .@expr19072 intvalue@var4206 &@expr1073760932 signBit@var4210 ) ) {
5314: value@var4205 .@expr19072 intvalue@var4206 |=@expr1073760934 ~@expr1073760935 unsignedMaxValue@var4209 ; }
5315: }
5316: }
5317: return values@var4194 ;
5318: }
5319:
5320: static bool isVariableInit ( const Token * tok@var4211 )
5321: {
5322: return (@expr1073760936 tok@var4211 .@expr19113 str (@expr19114 ) ==@expr1073760939 "(" ||@expr1073760940 tok@var4211 .@expr19113 str (@expr19114 ) ==@expr1073760943 "{" ) &&@expr1073760944
5323: tok@var4211 .@expr1073760945 isBinaryOp (@expr1073760946 ) &&@expr1073760947
5324: tok@var4211 .@expr19124 astOperand1 (@expr19125 ) .@expr19126 variable (@expr19127 ) &&@expr1073760952
5325: tok@var4211 .@expr19124 astOperand1 (@expr19125 ) .@expr19126 variable (@expr19127 ) .@expr1073760957 nameToken (@expr1073760958 ) ==@expr1073760959 tok@var4211 .@expr19124 astOperand1 (@expr19125 ) &&@expr1073760962
5326: tok@var4211 .@expr19124 astOperand1 (@expr19125 ) .@expr19126 variable (@expr19127 ) .@expr19143 valueType (@expr19144 ) &&@expr1073760969
5327: tok@var4211 .@expr19124 astOperand1 (@expr19125 ) .@expr19126 variable (@expr19127 ) .@expr19143 valueType (@expr19144 ) .@expr1073760976 type@var5342 >=@expr1073760977 ValueType ::@expr1073760978 Type ::@expr1073760979 VOID &&@expr1073760980
5328: !@expr1073760981 Token ::@expr1073760982 simpleMatch (@expr1073760983 tok@var4211 .@expr1073760984 astOperand2 (@expr1073760985 ) , "," ) ;
5329: }
5330:
5331:
5332: template < class C1 , class C2 >
5333: static bool intersects ( const C1 & c1@var4212 , const C2 & c2@var4213 )
5334: {
5335: if (@expr1073760986 c1@var4212 .@expr1073760987 size (@expr1073760988 ) >@expr1073760989 c2@var4213 .@expr1073760990 size (@expr1073760991 ) ) {
5336: return intersects (@expr1073760992 c2@var4213 , c1@var4212 ) ; }
5337: for (@expr1073760993 auto && x@var4214 :@expr1073760994 c1@var4212 ) {
5338: if (@expr1073760995 c2@var4213 .@expr1073760996 find (@expr1073760997 x@var4214 ) !=@expr1073760998 c2@var4213 .@expr1073760999 end (@expr1073761000 ) ) {
5339: return true ; }
5340: }
5341: return false ;
5342: }
5343:
5344: static void valueFlowAfterAssign ( TokenList * tokenlist@var4215 , SymbolDatabase * symboldatabase@var4216 , ErrorLogger * errorLogger@var4217 , const Settings * settings@var4218 )
5345: {
5346: for (@expr1073761001 const Scope *@expr19178 scope@var4219 :@expr1073761003 symboldatabase@var4216 .@expr1073761004 functionScopes@var4220 ) {
5347: std ::@expr1073761005 unordered_map < int , std ::@expr19182 unordered_set < int > > backAssigns@var4221 ;
5348: for (@expr1073761007 Token *@expr19178 tok@var4222 =@expr1073761009 const_cast < Token *@expr19178 > (@expr1073761011 scope@var4219 .@expr1073761012 bodyStart@var4223 ) ; tok@var4222 !=@expr1073761013 scope@var4219 .@expr19190 bodyEnd@var4224 ; tok@var4222 =@expr1073761015 tok@var4222 .@expr1073761016 next (@expr1073761017 ) ) {
5349:
5350: if (@expr1073761018 (@expr1073761019 tok@var4222 .@expr1073761020 str (@expr1073761021 ) !=@expr1073761022 "=" &&@expr1073761023 !@expr1073761024 isVariableInit (@expr1073761025 tok@var4222 ) ) ||@expr1073761026 (@expr1073761027 tok@var4222 .@expr1073761028 astParent (@expr1073761029 ) ) ) {
5351: continue ; }
5352:
5353:
5354: if (@expr1073761030 !@expr1073761031 tok@var4222 .@expr19208 astOperand1 (@expr19209 ) ||@expr1073761034 !@expr1073761035 tok@var4222 .@expr19208 astOperand1 (@expr19209 ) .@expr19214 exprId (@expr19215 ) ) {
5355: continue ; }
5356: std ::@expr1073761040 vector < const Variable *@expr19178 > vars@var4225 ; vars@var4225 =@expr1073761042 getLHSVariables (@expr1073761043 tok@var4222 ) ;
5357:
5358:
5359: if (@expr1073761044 !@expr1073761045 tok@var4222 .@expr19222 astOperand2 (@expr19223 ) ||@expr1073761048 tok@var4222 .@expr19222 astOperand2 (@expr19223 ) .@expr19227 values (@expr19228 ) .@expr1073761053 empty (@expr1073761054 ) ) {
5360: continue ; }
5361:
5362: std ::@expr1073761055 list < ValueFlow ::@expr19182 Value > values@var4226 ; values@var4226 =@expr1073761057 truncateValues (@expr1073761058
5363: tok@var4222 .@expr19222 astOperand2 (@expr19223 ) .@expr19227 values (@expr19228 ) , tok@var4222 .@expr19208 astOperand1 (@expr19209 ) .@expr19241 valueType (@expr19242 ) , tok@var4222 .@expr19222 astOperand2 (@expr19223 ) .@expr1073761069 valueType (@expr1073761070 ) , settings@var4218 ) ;
5364:
5365: std ::@expr1073761071 set < ValueFlow ::@expr19182 Value ::@expr19182 ValueType > types@var4227 ;
5366: if (@expr1073761074 tok@var4222 .@expr19208 astOperand1 (@expr19209 ) .@expr1073761077 hasKnownValue (@expr1073761078 ) ) {
5367: for (@expr1073761079 const ValueFlow ::@expr19182 Value &@expr19257 value@var4228 :@expr1073761082 tok@var4222 .@expr19208 astOperand1 (@expr19209 ) .@expr1073761085 values (@expr1073761086 ) ) {
5368: if (@expr1073761087 value@var4228 .@expr1073761088 isKnown (@expr1073761089 ) &&@expr1073761090 !@expr1073761091 value@var4228 .@expr1073761092 isSymbolicValue (@expr1073761093 ) ) {
5369: types@var4227 .@expr1073761094 insert (@expr1073761095 value@var4228 .@expr1073761096 valueType@var4229 ) ; }
5370: }
5371: }
5372: values@var4226 .@expr19273 remove_if (@expr1073761098 [@expr1073761099 &@expr19257 ] (@expr1073761101 const ValueFlow ::@expr19182 Value &@expr19257 value@var4230 ) {
5373: return types@var4227 .@expr1073761104 count (@expr1073761105 value@var4230 .@expr1073761106 valueType@var4231 ) >@expr1073761107 0 ;
5374: } ) ;
5375:
5376: if (@expr1073761108 !@expr1073761109 astIsContainer (@expr1073761110 tok@var4222 .@expr19222 astOperand2 (@expr19223 ) ) ) {
5377: values@var4226 .@expr19273 remove_if (@expr1073761114 [@expr1073761115 &@expr19257 ] (@expr1073761117 const ValueFlow ::@expr19182 Value &@expr19257 value@var4232 ) {
5378: return value@var4232 .@expr1073761120 valueType@var4233 ==@expr1073761121 ValueFlow ::@expr1073761122 Value ::@expr1073761123 ValueType ::@expr1073761124 CONTAINER_SIZE ;
5379: } ) ; }
5380:
5381: values@var4226 .@expr19273 remove_if (@expr1073761126 [@expr1073761127 &@expr19257 ] (@expr1073761129 const ValueFlow ::@expr19182 Value &@expr19257 value@var4234 ) {
5382: if (@expr1073761132 value@var4234 .@expr1073761133 isSymbolicValue (@expr1073761134 ) &&@expr1073761135 value@var4234 .@expr19312 tokvalue@var4235 ) {
5383: return value@var4234 .@expr19312 tokvalue@var4235 .@expr1073761138 exprId (@expr1073761139 ) ==@expr1073761140 tok@var4222 .@expr19208 astOperand1 (@expr19209 ) .@expr19214 exprId (@expr19215 ) ; }
5384: return false ;
5385: } ) ;
5386:
5387: if (@expr1073761145 (@expr1073761146 tok@var4222 .@expr19208 astOperand1 (@expr19209 ) .@expr19241 valueType (@expr19242 ) &&@expr1073761151 tok@var4222 .@expr19208 astOperand1 (@expr19209 ) .@expr19241 valueType (@expr19242 ) .@expr1073761156 pointer@var5340 ==@expr1073761157 0 ) ||@expr1073761158
5388: (@expr1073761159 tok@var4222 .@expr19208 astOperand1 (@expr19209 ) .@expr19338 variable (@expr19339 ) &&@expr1073761164 tok@var4222 .@expr19208 astOperand1 (@expr19209 ) .@expr19338 variable (@expr19339 ) .@expr1073761169 isReference (@expr1073761170 ) &&@expr1073761171 tok@var4222 .@expr19208 astOperand1 (@expr19209 ) .@expr19338 variable (@expr19339 ) .@expr1073761176 nameToken (@expr1073761177 ) ==@expr1073761178 tok@var4222 .@expr19208 astOperand1 (@expr19209 ) ) ) {
5389: values@var4226 .@expr19273 remove_if (@expr1073761182 [@expr1073761183 &@expr19257 ] (@expr1073761185 const ValueFlow ::@expr19182 Value &@expr19257 value@var4236 ) {
5390: return value@var4236 .@expr1073761188 isUninitValue (@expr1073761189 ) ;
5391: } ) ; }
5392: if (@expr1073761190 values@var4226 .@expr1073761191 empty (@expr1073761192 ) ) {
5393: continue ; }
5394: const bool init@var4237 =@expr1073761193 vars@var4225 .@expr1073761194 size (@expr1073761195 ) ==@expr1073761196 1 &&@expr1073761197 (@expr1073761198 vars@var4225 .@expr1073761199 front (@expr1073761200 ) .@expr1073761201 nameToken (@expr1073761202 ) ==@expr1073761203 tok@var4222 .@expr19208 astOperand1 (@expr19209 ) ||@expr1073761206 tok@var4222 .@expr1073761207 isSplittedVarDeclEq (@expr1073761208 ) ) ;
5395: valueFlowForwardAssign (@expr1073761209
5396: tok@var4222 .@expr19222 astOperand2 (@expr19223 ) , tok@var4222 .@expr19208 astOperand1 (@expr19209 ) , vars@var4225 , values@var4226 , init@var4237 , tokenlist@var4215 , errorLogger@var4217 , settings@var4218 ) ;
5397:
5398: if (@expr1073761214 tok@var4222 .@expr19208 astOperand1 (@expr19209 ) .@expr19214 exprId (@expr19215 ) >@expr1073761219 0 ) {
5399: Token * start@var4238 ; start@var4238 =@expr1073761220 nextAfterAstRightmostLeaf (@expr1073761221 tok@var4222 ) ;
5400: const Token * end@var4239 ; end@var4239 =@expr1073761222 scope@var4219 .@expr19190 bodyEnd@var4224 ;
5401:
5402: std ::@expr1073761224 unordered_set < int > ids@var4240 ;
5403: for (@expr1073761225 const ValueFlow ::@expr19182 Value &@expr19257 value@var4241 :@expr1073761228 values@var4226 ) {
5404: if (@expr1073761229 !@expr1073761230 value@var4241 .@expr1073761231 isSymbolicValue (@expr1073761232 ) ) {
5405: continue ; }
5406: if (@expr1073761233 !@expr1073761234 value@var4241 .@expr19411 tokvalue@var4242 ) {
5407: continue ; }
5408: if (@expr1073761236 value@var4241 .@expr19411 tokvalue@var4242 .@expr19414 exprId (@expr19415 ) ==@expr1073761240 0 ) {
5409: continue ; }
5410: ids@var4240 .@expr1073761241 insert (@expr1073761242 value@var4241 .@expr19411 tokvalue@var4242 .@expr19414 exprId (@expr19415 ) ) ;
5411: }
5412: for (@expr1073761246 ValueFlow ::@expr19182 Value value@var4243 :@expr1073761248 values@var4226 ) {
5413: if (@expr1073761249 !@expr1073761250 value@var4243 .@expr1073761251 isSymbolicValue (@expr1073761252 ) ) {
5414: continue ; }
5415: const Token * expr@var4244 ; expr@var4244 =@expr1073761253 value@var4243 .@expr19430 tokvalue@var4245 ;
5416: value@var4243 .@expr19431 intvalue@var4246 =@expr1073761256 -@expr1073761257 value@var4243 .@expr19431 intvalue@var4246 ;
5417: value@var4243 .@expr19430 tokvalue@var4245 =@expr1073761260 tok@var4222 .@expr19208 astOperand1 (@expr19209 ) ;
5418:
5419:
5420: auto &@expr19257 s@var4247 =@expr1073761264 backAssigns@var4221 [@expr1073761265 value@var4243 .@expr19430 tokvalue@var4245 .@expr1073761267 exprId (@expr1073761268 ) ] ;
5421: if (@expr1073761269 intersects (@expr1073761270 s@var4247 , ids@var4240 ) ) {
5422: continue ; }
5423: s@var4247 .@expr1073761271 insert (@expr1073761272 expr@var4244 .@expr1073761273 exprId (@expr1073761274 ) ) ;
5424:
5425: value@var4243 .@expr1073761275 errorPath@var4248 .@expr1073761276 emplace_back (@expr1073761277 tok@var4222 ,
5426: tok@var4222 .@expr19208 astOperand1 (@expr19209 ) .@expr1073761280 expressionString (@expr1073761281 ) +@expr1073761282 " is assigned '" +@expr1073761283
5427: tok@var4222 .@expr19222 astOperand2 (@expr19223 ) .@expr1073761286 expressionString (@expr1073761287 ) +@expr1073761288 "' here." ) ;
5428: valueFlowForward (@expr1073761289 start@var4238 , end@var4239 , expr@var4244 , {@expr1073761290 value@var4243 } , tokenlist@var4215 , settings@var4218 ) ;
5429: }
5430: }
5431: }
5432: }
5433: }
5434:
5435: static std :: vector < const Variable * > getVariables ( const Token * tok@var4249 )
5436: {
5437: std ::@expr1073761291 vector < const Variable *@expr19468 > result@var4250 ;
5438: visitAstNodes (@expr1073761293 tok@var4249 , [@expr1073761294 &@expr1073761295 ] (@expr1073761296 const Token *@expr19468 child@var4251 ) {
5439: if (@expr1073761298 child@var4251 .@expr19475 variable (@expr19476 ) ) {
5440: result@var4250 .@expr1073761301 push_back (@expr1073761302 child@var4251 .@expr19475 variable (@expr19476 ) ) ; }
5441: return ChildrenToVisit ::@expr1073761305 op1_and_op2 ;
5442: } ) ;
5443: return result@var4250 ;
5444: }
5445:
5446: static void valueFlowAfterSwap ( TokenList * tokenlist@var4252 ,
5447: SymbolDatabase * symboldatabase@var4253 ,
5448: ErrorLogger * errorLogger@var4254 ,
5449: const Settings * settings@var4255 )
5450: {
5451: for (@expr1073761306 const Scope *@expr19483 scope@var4256 :@expr1073761308 symboldatabase@var4253 .@expr1073761309 functionScopes@var4257 ) {
5452: for (@expr1073761310 Token *@expr19483 tok@var4258 =@expr1073761312 const_cast < Token *@expr19483 > (@expr1073761314 scope@var4256 .@expr1073761315 bodyStart@var4259 ) ; tok@var4258 !=@expr1073761316 scope@var4256 .@expr1073761317 bodyEnd@var4260 ; tok@var4258 =@expr1073761318 tok@var4258 .@expr19495 next (@expr19496 ) ) {
5453: if (@expr1073761321 !@expr1073761322 Token ::@expr19499 simpleMatch (@expr1073761324 tok@var4258 , "swap (" ) ) {
5454: continue ; }
5455: if (@expr1073761325 !@expr1073761326 Token ::@expr19499 simpleMatch (@expr1073761328 tok@var4258 .@expr19495 next (@expr19496 ) .@expr19507 astOperand2 (@expr19508 ) , "," ) ) {
5456: continue ; }
5457: std ::@expr1073761333 vector < Token *@expr19483 > args@var4261 ; args@var4261 =@expr1073761335 astFlatten (@expr1073761336 tok@var4258 .@expr19495 next (@expr19496 ) .@expr19507 astOperand2 (@expr19508 ) , "," ) ;
5458: if (@expr1073761341 args@var4261 .@expr1073761342 size (@expr1073761343 ) !=@expr1073761344 2 ) {
5459: continue ; }
5460: if (@expr1073761345 args@var4261 [@expr19522 0 ] .@expr1073761347 exprId (@expr1073761348 ) ==@expr1073761349 0 ) {
5461: continue ; }
5462: if (@expr1073761350 args@var4261 [@expr19527 1 ] .@expr1073761352 exprId (@expr1073761353 ) ==@expr1073761354 0 ) {
5463: continue ; }
5464: for (@expr1073761355 int i@var4262 =@expr1073761356 0 ; i@var4262 <@expr1073761357 2 ; i@var4262 ++@expr1073761358 ) {
5465: std ::@expr1073761359 vector < const Variable *@expr19483 > vars@var4263 ; vars@var4263 =@expr1073761361 getVariables (@expr1073761362 args@var4261 [@expr19522 0 ] ) ;
5466: std ::@expr1073761364 list < ValueFlow ::@expr1073761365 Value > values@var4264 ; values@var4264 =@expr1073761366 args@var4261 [@expr19522 0 ] .@expr1073761368 values (@expr1073761369 ) ;
5467: valueFlowForwardAssign (@expr1073761370 args@var4261 [@expr19522 0 ] , args@var4261 [@expr19527 1 ] , vars@var4263 , values@var4264 , false , tokenlist@var4252 , errorLogger@var4254 , settings@var4255 ) ;
5468: std ::@expr1073761373 swap (@expr1073761374 args@var4261 [@expr19522 0 ] , args@var4261 [@expr19527 1 ] ) ;
5469: }
5470: }
5471: }
5472: }
5473:
5474: static void valueFlowSetConditionToKnown ( const Token * tok@var4265 , std :: list < ValueFlow :: Value > & values@var4266 , bool then@var4267 )
5475: {
5476: if (@expr1073761377 values@var4266 .@expr1073761378 empty (@expr1073761379 ) ) {
5477: return ; }
5478: if (@expr1073761380 then@var4267 &&@expr1073761381 !@expr1073761382 Token ::@expr19559 Match (@expr1073761384 tok@var4265 , "==|!|(" ) ) {
5479: return ; }
5480: if (@expr1073761385 !@expr1073761386 then@var4267 &&@expr1073761387 !@expr1073761388 Token ::@expr19559 Match (@expr1073761390 tok@var4265 , "!=|%var%|(" ) ) {
5481: return ; }
5482: if (@expr1073761391 isConditionKnown (@expr1073761392 tok@var4265 , then@var4267 ) ) {
5483: changePossibleToKnown (@expr1073761393 values@var4266 ) ; }
5484: }
5485:
5486: static bool isBreakScope ( const Token * const endToken@var4268 )
5487: {
5488: if (@expr1073761394 !@expr1073761395 Token ::@expr19572 simpleMatch (@expr1073761397 endToken@var4268 , "}" ) ) {
5489: return false ; }
5490: if (@expr1073761398 !@expr1073761399 Token ::@expr19572 simpleMatch (@expr1073761401 endToken@var4268 .@expr19578 link (@expr19579 ) , "{" ) ) {
5491: return false ; }
5492: return Token ::@expr1073761404 findmatch (@expr1073761405 endToken@var4268 .@expr19578 link (@expr19579 ) , "break|goto" , endToken@var4268 ) ;
5493: }
5494:
5495: ValueFlow :: Value asImpossible ( ValueFlow :: Value v@var4269 )
5496: {
5497: v@var4269 .@expr1073761408 invertRange (@expr1073761409 ) ;
5498: v@var4269 .@expr1073761410 setImpossible (@expr1073761411 ) ;
5499: return v@var4269 ;
5500: }
5501:
5502: static void insertImpossible ( std :: list < ValueFlow :: Value > & values@var4270 , const std :: list < ValueFlow :: Value > & input@var4271 )
5503: {
5504: std ::@expr1073761412 transform (@expr1073761413 input@var4271 .@expr1073761414 begin (@expr1073761415 ) , input@var4271 .@expr1073761416 end (@expr1073761417 ) , std ::@expr1073761418 back_inserter (@expr1073761419 values@var4270 ) , &@expr1073761420 asImpossible ) ;
5505: }
5506:
5507: static void insertNegateKnown ( std :: list < ValueFlow :: Value > & values@var4272 , const std :: list < ValueFlow :: Value > & input@var4273 )
5508: {
5509: for (@expr1073761421 ValueFlow ::@expr1073761422 Value value@var4274 :@expr1073761423 input@var4273 ) {
5510: if (@expr1073761424 !@expr1073761425 value@var4274 .@expr1073761426 isIntValue (@expr1073761427 ) &&@expr1073761428 !@expr1073761429 value@var4274 .@expr1073761430 isContainerSizeValue (@expr1073761431 ) ) {
5511: continue ; }
5512: value@var4274 .@expr19608 intvalue@var4275 =@expr1073761433 !@expr1073761434 value@var4274 .@expr19608 intvalue@var4275 ;
5513: value@var4274 .@expr1073761436 setKnown (@expr1073761437 ) ;
5514: values@var4272 .@expr1073761438 push_back (@expr1073761439 value@var4274 ) ;
5515: }
5516: }
5517:
5518: struct ConditionHandler {
5519: struct Condition {
5520: const Token * vartok@var4276 ;
5521: std :: list < ValueFlow :: Value > true_values@var4277 ;
5522: std :: list < ValueFlow :: Value > false_values@var4278 ;
5523: bool inverted@var4279 ; inverted@var4279 = false ;
5524:
5525: bool impossible@var4280 ; impossible@var4280 = true ;
5526:
5527: bool isBool ( ) const {
5528: return astIsBool (@expr1073761440 vartok@var4276 ) ;
5529: }
5530:
5531: Condition ( ) : vartok@var4276 ( nullptr ) , true_values@var4277 ( ) , false_values@var4278 ( ) , inverted@var4279 ( false ) , impossible@var4280 ( true ) { }
5532: } ;
5533:
5534: virtual Analyzer :: Result forward ( Token * start@var4281 ,
5535: const Token * stop@var4282 ,
5536: const Token * exprTok@var4283 ,
5537: const std :: list < ValueFlow :: Value > & values@var4284 ,
5538: TokenList * tokenlist@var4285 ,
5539: const Settings * settings@var4286 ) const = 0 ;
5540:
5541: virtual Analyzer :: Result forward ( Token * top@var4287 ,
5542: const Token * exprTok@var4288 ,
5543: const std :: list < ValueFlow :: Value > & values@var4289 ,
5544: TokenList * tokenlist@var4290 ,
5545: const Settings * settings@var4291 ) const = 0 ;
5546:
5547: virtual void reverse ( Token * start@var4292 ,
5548: const Token * endToken@var4293 ,
5549: const Token * exprTok@var4294 ,
5550: const std :: list < ValueFlow :: Value > & values@var4295 ,
5551: TokenList * tokenlist@var4296 ,
5552: const Settings * settings@var4297 ) const = 0 ;
5553:
5554: virtual std :: vector < Condition > parse ( const Token * tok@var4298 , const Settings * settings@var4299 ) const = 0 ;
5555:
5556: void traverseCondition ( TokenList * tokenlist@var4300 ,
5557: SymbolDatabase * symboldatabase@var4301 ,
5558: const std :: function < void ( const Condition & cond , Token * tok , const Scope * scope ) > & f@var4302 ) const
5559: {
5560: for (@expr1073761441 const Scope *@expr19618 scope@var4303 :@expr1073761443 symboldatabase@var4301 .@expr1073761444 functionScopes@var4304 ) {
5561: for (@expr1073761445 Token *@expr19618 tok@var4305 =@expr1073761447 const_cast < Token *@expr19618 > (@expr1073761449 scope@var4303 .@expr1073761450 bodyStart@var4306 ) ; tok@var4305 !=@expr1073761451 scope@var4303 .@expr1073761452 bodyEnd@var4307 ; tok@var4305 =@expr1073761453 tok@var4305 .@expr1073761454 next (@expr1073761455 ) ) {
5562: if (@expr1073761456 Token ::@expr19633 Match (@expr1073761458 tok@var4305 , "if|while|for (" ) ) {
5563: continue ; }
5564: if (@expr1073761459 Token ::@expr19633 Match (@expr1073761461 tok@var4305 , ":|;|," ) ) {
5565: continue ; }
5566:
5567: const Token * top@var4308 ; top@var4308 =@expr1073761462 tok@var4305 .@expr1073761463 astTop (@expr1073761464 ) ;
5568: if (@expr1073761465 !@expr1073761466 top@var4308 ) {
5569: continue ; }
5570:
5571: if (@expr1073761467 !@expr1073761468 Token ::@expr19633 Match (@expr1073761470 top@var4308 .@expr1073761471 previous (@expr1073761472 ) , "if|while|for (" ) &&@expr1073761473 !@expr1073761474 Token ::@expr19633 Match (@expr1073761476 tok@var4305 .@expr1073761477 astParent (@expr1073761478 ) , "&&|%oror%|?|!" ) ) {
5572: continue ; }
5573: for (@expr1073761479 const Condition &@expr1073761480 cond@var4309 :@expr1073761481 parse (@expr1073761482 tok@var4305 , tokenlist@var4300 .@expr19659 getSettings (@expr19660 ) ) ) {
5574: if (@expr1073761485 !@expr1073761486 cond@var4309 .@expr19663 vartok@var4310 ) {
5575: continue ; }
5576: if (@expr1073761488 cond@var4309 .@expr19663 vartok@var4310 .@expr1073761490 exprId (@expr1073761491 ) ==@expr1073761492 0 ) {
5577: continue ; }
5578: if (@expr1073761493 cond@var4309 .@expr19663 vartok@var4310 .@expr1073761495 hasKnownIntValue (@expr1073761496 ) ) {
5579: continue ; }
5580: if (@expr1073761497 cond@var4309 .@expr1073761498 true_values@var4311 .@expr1073761499 empty (@expr1073761500 ) ||@expr1073761501 cond@var4309 .@expr1073761502 false_values@var4312 .@expr1073761503 empty (@expr1073761504 ) ) {
5581: continue ; }
5582: if (@expr1073761505 !@expr1073761506 isConstExpression (@expr1073761507 cond@var4309 .@expr19663 vartok@var4310 , tokenlist@var4300 .@expr19659 getSettings (@expr19660 ) .@expr1073761511 library@var5315 , true , tokenlist@var4300 .@expr1073761512 isCPP (@expr1073761513 ) ) ) {
5583: continue ; }
5584: f@var4302 (@expr1073761514 cond@var4309 , tok@var4305 , scope@var4303 ) ;
5585: }
5586: }
5587: }
5588: }
5589:
5590: void beforeCondition ( TokenList * tokenlist@var4313 ,
5591: SymbolDatabase * symboldatabase@var4314 ,
5592: ErrorLogger * errorLogger@var4315 ,
5593: const Settings * settings@var4316 ) const {
5594: traverseCondition (@expr1073761515 tokenlist@var4313 , symboldatabase@var4314 , [@expr1073761516 &@expr19693 ] (@expr1073761518 const Condition &@expr19693 cond@var4317 , Token *@expr19696 tok@var4318 , const Scope *@expr19696 ) {
5595: if (@expr1073761522 cond@var4317 .@expr19699 vartok@var4319 .@expr19700 exprId (@expr19701 ) ==@expr1073761526 0 ) {
5596: return ; }
5597:
5598:
5599: if (@expr1073761527 tok@var4318 .@expr1073761528 hasKnownIntValue (@expr1073761529 ) ) {
5600: return ; }
5601:
5602: const Token * top@var4320 ; top@var4320 =@expr1073761530 tok@var4318 .@expr1073761531 astTop (@expr1073761532 ) ;
5603:
5604: if (@expr1073761533 Token ::@expr19710 Match (@expr1073761535 top@var4320 , "%assign%" ) ) {
5605: return ; }
5606: if (@expr1073761536 Token ::@expr19710 Match (@expr1073761538 cond@var4317 .@expr19699 vartok@var4319 .@expr1073761540 astParent (@expr1073761541 ) , "%assign%|++|--" ) ) {
5607: return ; }
5608:
5609: if (@expr1073761542 Token ::@expr19719 simpleMatch (@expr1073761544 tok@var4318 .@expr19721 astParent (@expr19722 ) , "?" ) &&@expr1073761547 tok@var4318 .@expr19721 astParent (@expr19722 ) .@expr1073761550 isExpandedMacro (@expr1073761551 ) ) {
5610: if (@expr19728 settings@var4316 .@expr19729 debugwarnings@var4321 ) {
5611: $bailoutInternal $(@expr1073761554 $"valueFlowBailout" $, tokenlist@var4313 $, errorLogger@var4315 $, tok@var4318 $, "variable '" +@expr19731 cond@var4317 .@expr19699 vartok@var4319 .@expr19733 expressionString (@expr19734 ) +@expr19735 "', condition is defined in macro" $, "cppcheck-2.8/lib/valueflow.cpp" $, 5611 $, $__func__ $)
5612:
5613:
5614: ; }
5615: return ;
5616: }
5617:
5618:
5619: if (@expr1073761560 Token ::@expr19719 simpleMatch (@expr1073761562 top@var4320 .@expr19739 previous (@expr19740 ) , "if (" ) &&@expr1073761565 top@var4320 .@expr19739 previous (@expr19740 ) .@expr1073761568 isExpandedMacro (@expr1073761569 ) ) {
5620: if (@expr19728 settings@var4316 .@expr19729 debugwarnings@var4321 ) {
5621: $bailoutInternal $(@expr1073761572 $"valueFlowBailout" $, tokenlist@var4313 $, errorLogger@var4315 $, tok@var4318 $, "variable '" +@expr19731 cond@var4317 .@expr19699 vartok@var4319 .@expr19733 expressionString (@expr19734 ) +@expr19735 "', condition is defined in macro" $, "cppcheck-2.8/lib/valueflow.cpp" $, 5621 $, $__func__ $)
5622:
5623:
5624: ; }
5625: return ;
5626: }
5627:
5628: std ::@expr1073761578 list < ValueFlow ::@expr19755 Value > values@var4322 ; values@var4322 =@expr1073761580 cond@var4317 .@expr19757 true_values@var4323 ;
5629: if (@expr1073761582 cond@var4317 .@expr19757 true_values@var4323 !=@expr1073761584 cond@var4317 .@expr19761 false_values@var4324 ) {
5630: values@var4322 .@expr1073761586 insert (@expr1073761587 values@var4322 .@expr1073761588 end (@expr1073761589 ) , cond@var4317 .@expr19761 false_values@var4324 .@expr1073761591 begin (@expr1073761592 ) , cond@var4317 .@expr19761 false_values@var4324 .@expr1073761594 end (@expr1073761595 ) ) ; }
5631:
5632:
5633: if (@expr1073761596 Token ::@expr19710 Match (@expr1073761598 tok@var4318 , "<|>" ) ) {
5634: values@var4322 .@expr1073761599 remove_if (@expr1073761600 [@expr1073761601 ] (@expr1073761602 const ValueFlow ::@expr19755 Value &@expr19693 v@var4325 ) {
5635: if (@expr1073761605 v@var4325 .@expr1073761606 isIntValue (@expr1073761607 ) ) {
5636: return v@var4325 .@expr1073761608 intvalue@var4326 !=@expr1073761609 0 ; }
5637: return false ;
5638: } ) ;
5639: if (@expr1073761610 cond@var4317 .@expr19699 vartok@var4319 .@expr19788 valueType (@expr19789 ) &&@expr1073761614 cond@var4317 .@expr19699 vartok@var4319 .@expr19788 valueType (@expr19789 ) .@expr1073761618 sign@var5316 !=@expr1073761619 ValueType ::@expr1073761620 Sign ::@expr1073761621 UNSIGNED ) {
5640: return ; }
5641: }
5642: if (@expr1073761622 values@var4322 .@expr1073761623 empty (@expr1073761624 ) ) {
5643: return ; }
5644:
5645:
5646: if (@expr1073761625 Token ::@expr19710 Match (@expr1073761627 top@var4320 .@expr19739 previous (@expr19740 ) , "for|while (" ) &&@expr1073761630 Token ::@expr19719 simpleMatch (@expr1073761632 top@var4320 .@expr19809 link (@expr19810 ) , ") {" ) ) {
5647:
5648:
5649: if (@expr1073761635 Token ::@expr19719 simpleMatch (@expr1073761637 top@var4320 .@expr19739 previous (@expr19740 ) , "for (" ) ) {
5650: if (@expr1073761640 top@var4320 .@expr19817 astOperand2 (@expr19818 ) &&@expr1073761643 top@var4320 .@expr19817 astOperand2 (@expr19818 ) .@expr19822 astOperand2 (@expr19823 ) &&@expr1073761648
5651: isExpressionChanged (@expr1073761649
5652: cond@var4317 .@expr19699 vartok@var4319 , top@var4320 .@expr19817 astOperand2 (@expr19818 ) .@expr19822 astOperand2 (@expr19823 ) , top@var4320 .@expr19809 link (@expr19810 ) , settings@var4316 , tokenlist@var4313 .@expr19833 isCPP (@expr19834 ) ) ) {
5653: if (@expr19728 settings@var4316 .@expr19729 debugwarnings@var4321 ) {
5654: $bailoutInternal $(@expr1073761661 $"valueFlowBailout" $, tokenlist@var4313 $, errorLogger@var4315 $, tok@var4318 $, "variable '" +@expr19731 cond@var4317 .@expr19699 vartok@var4319 .@expr19733 expressionString (@expr19734 ) +@expr19842 "' used in loop" $, "cppcheck-2.8/lib/valueflow.cpp" $, 5654 $, $__func__ $)
5655:
5656:
5657: ; }
5658: return ;
5659: }
5660: }
5661:
5662:
5663: const Token * const start@var4327 ; start@var4327 =@expr1073761667 top@var4320 ;
5664: const Token * const block@var4328 ; block@var4328 =@expr1073761668 top@var4320 .@expr19809 link (@expr19810 ) .@expr19847 next (@expr19848 ) ;
5665: const Token * const end@var4329 ; end@var4329 =@expr1073761673 block@var4328 .@expr1073761674 link (@expr1073761675 ) ;
5666:
5667: if (@expr1073761676 isExpressionChanged (@expr1073761677 cond@var4317 .@expr19699 vartok@var4319 , start@var4327 , end@var4329 , settings@var4316 , tokenlist@var4313 .@expr19833 isCPP (@expr19834 ) ) ) {
5668:
5669: if (@expr1073761681 !@expr1073761682 Token ::@expr19710 Match (@expr1073761684 tok@var4318 , "%assign%|++|--" ) &&@expr1073761685
5670: findExpression (@expr1073761686 cond@var4317 .@expr19699 vartok@var4319 .@expr19700 exprId (@expr19701 ) , start@var4327 , end@var4329 , [@expr1073761690 &@expr19693 ] (@expr1073761692 const Token *@expr19696 tok2@var4330 ) {
5671: return Token ::@expr19710 Match (@expr1073761695 tok2@var4330 .@expr1073761696 astParent (@expr1073761697 ) , "%assign%" ) &&@expr1073761698 astIsLHS (@expr1073761699 tok2@var4330 ) ;
5672: } ) ) {
5673:
5674: Token * bodyTok@var4331 ; bodyTok@var4331 =@expr1073761700 top@var4320 .@expr19809 link (@expr19810 ) .@expr19847 next (@expr19848 ) ;
5675: reverse (@expr1073761705 bodyTok@var4331 .@expr1073761706 link (@expr1073761707 ) , bodyTok@var4331 , cond@var4317 .@expr19699 vartok@var4319 , values@var4322 , tokenlist@var4313 , settings@var4316 ) ;
5676: }
5677: if (@expr19728 settings@var4316 .@expr19729 debugwarnings@var4321 ) {
5678: $bailoutInternal $(@expr1073761711 $"valueFlowBailout" $, tokenlist@var4313 $, errorLogger@var4315 $, tok@var4318 $, "variable '" +@expr19731 cond@var4317 .@expr19699 vartok@var4319 .@expr19733 expressionString (@expr19734 ) +@expr19842 "' used in loop" $, "cppcheck-2.8/lib/valueflow.cpp" $, 5678 $, $__func__ $)
5679:
5680:
5681: ; }
5682: return ;
5683: }
5684: }
5685:
5686: Token * startTok@var4332 ; startTok@var4332 =@expr1073761717 nullptr ;
5687: if (@expr1073761718 astIsRHS (@expr1073761719 tok@var4318 ) ) {
5688: startTok@var4332 =@expr1073761720 tok@var4318 .@expr19721 astParent (@expr19722 ) ; }
5689: else { if (@expr1073761723 astIsLHS (@expr1073761724 tok@var4318 ) ) {
5690: startTok@var4332 =@expr1073761725 previousBeforeAstLeftmostLeaf (@expr1073761726 tok@var4318 .@expr19721 astParent (@expr19722 ) ) ; } }
5691: if (@expr1073761729 !@expr1073761730 startTok@var4332 ) {
5692: startTok@var4332 =@expr1073761731 tok@var4318 .@expr1073761732 previous (@expr1073761733 ) ; }
5693:
5694: reverse (@expr1073761734 startTok@var4332 , nullptr , cond@var4317 .@expr19699 vartok@var4319 , values@var4322 , tokenlist@var4313 , settings@var4316 ) ;
5695: } ) ;
5696: }
5697:
5698: static Token * skipNotAndCasts ( Token * tok@var4333 , bool * inverted@var4334 = nullptr )
5699: {
5700: for (@expr1073761737 ; tok@var4333 .@expr19914 astParent (@expr19915 ) ; tok@var4333 =@expr1073761740 tok@var4333 .@expr19914 astParent (@expr19915 ) ) {
5701: if (@expr1073761743 Token ::@expr19920 simpleMatch (@expr1073761745 tok@var4333 .@expr19914 astParent (@expr19915 ) , "!" ) ) {
5702: if (@expr19924 inverted@var4334 ) {
5703: *@expr19925 inverted@var4334 ^=@expr1073761750 true ; }
5704: continue ;
5705: }
5706: if (@expr1073761751 Token ::@expr1073761752 Match (@expr1073761753 tok@var4333 .@expr19914 astParent (@expr19915 ) , "==|!=" ) ) {
5707: Token * sibling@var4335 ; sibling@var4335 =@expr1073761756 tok@var4333 .@expr1073761757 astSibling (@expr1073761758 ) ;
5708: if (@expr1073761759 sibling@var4335 .@expr1073761760 hasKnownIntValue (@expr1073761761 ) &&@expr1073761762 (@expr1073761763 astIsBool (@expr1073761764 tok@var4333 ) ||@expr1073761765 astIsBool (@expr1073761766 sibling@var4335 ) ) ) {
5709: bool value@var4336 ; value@var4336 =@expr1073761767 sibling@var4335 .@expr1073761768 values (@expr1073761769 ) .@expr1073761770 front (@expr1073761771 ) .@expr1073761772 intvalue@expr1073761736 ;
5710: if (@expr19924 inverted@var4334 ) {
5711: *@expr19925 inverted@var4334 ^=@expr1073761775 value@var4336 ==@expr1073761776 Token ::@expr19920 simpleMatch (@expr1073761778 tok@var4333 .@expr19914 astParent (@expr19915 ) , "!=" ) ; }
5712: continue ;
5713: }
5714: }
5715: if (@expr1073761781 tok@var4333 .@expr19914 astParent (@expr19915 ) .@expr1073761784 isCast (@expr1073761785 ) &&@expr1073761786 astIsBool (@expr1073761787 tok@var4333 .@expr19914 astParent (@expr19915 ) ) ) {
5716: continue ; }
5717: return tok@var4333 ;
5718: }
5719: return tok@var4333 ;
5720: }
5721:
5722: void afterCondition ( TokenList * tokenlist@var4337 ,
5723: SymbolDatabase * symboldatabase@var4338 ,
5724: ErrorLogger * errorLogger@var4339 ,
5725: const Settings * settings@var4340 ) const {
5726: traverseCondition (@expr1073761791 tokenlist@var4337 , symboldatabase@var4338 , [@expr1073761792 &@expr19969 ] (@expr1073761794 const Condition &@expr19969 cond@var4341 , Token *@expr19972 condTok@var4342 , const Scope *@expr19972 scope@var4343 ) {
5727: const Token * top@var4344 ; top@var4344 =@expr1073761798 condTok@var4342 .@expr1073761799 astTop (@expr1073761800 ) ;
5728:
5729: std ::@expr1073761801 list < ValueFlow ::@expr19978 Value > thenValues@var4345 ;
5730: std ::@expr1073761803 list < ValueFlow ::@expr19978 Value > elseValues@var4346 ;
5731:
5732: if (@expr1073761805 !@expr1073761806 Token ::@expr19983 Match (@expr1073761808 condTok@var4342 , "!=|=|(|." ) &&@expr1073761809 condTok@var4342 !=@expr1073761810 cond@var4341 .@expr19987 vartok@var4347 ) {
5733: thenValues@var4345 .@expr1073761812 insert (@expr1073761813 thenValues@var4345 .@expr19990 end (@expr19991 ) , cond@var4341 .@expr19992 true_values@var4348 .@expr1073761817 begin (@expr1073761818 ) , cond@var4341 .@expr19992 true_values@var4348 .@expr1073761820 end (@expr1073761821 ) ) ;
5734: if (@expr1073761822 cond@var4341 .@expr19999 impossible@var4349 &&@expr1073761824 isConditionKnown (@expr1073761825 condTok@var4342 , false ) ) {
5735: insertImpossible (@expr1073761826 elseValues@var4346 , cond@var4341 .@expr20003 false_values@var4350 ) ; }
5736: }
5737: if (@expr1073761828 !@expr1073761829 Token ::@expr19983 Match (@expr1073761831 condTok@var4342 , "==|!" ) ) {
5738: elseValues@var4346 .@expr1073761832 insert (@expr1073761833 elseValues@var4346 .@expr20010 end (@expr20011 ) , cond@var4341 .@expr20003 false_values@var4350 .@expr1073761837 begin (@expr1073761838 ) , cond@var4341 .@expr20003 false_values@var4350 .@expr1073761840 end (@expr1073761841 ) ) ;
5739: if (@expr1073761842 cond@var4341 .@expr19999 impossible@var4349 &&@expr1073761844 isConditionKnown (@expr1073761845 condTok@var4342 , true ) ) {
5740: insertImpossible (@expr1073761846 thenValues@var4345 , cond@var4341 .@expr19992 true_values@var4348 ) ;
5741: if (@expr1073761848 cond@var4341 .@expr20025 isBool (@expr20026 ) ) {
5742: insertNegateKnown (@expr1073761851 thenValues@var4345 , cond@var4341 .@expr19992 true_values@var4348 ) ; }
5743: }
5744: }
5745:
5746: bool inverted@var4351 ; inverted@var4351 =@expr1073761853 cond@var4341 .@expr1073761854 inverted@var4352 ;
5747: Token * ctx@var4353 ; ctx@var4353 =@expr1073761855 skipNotAndCasts (@expr1073761856 condTok@var4342 , &@expr1073761857 inverted@var4351 ) ;
5748: if (@expr1073761858 inverted@var4351 ) {
5749: std ::@expr20035 swap (@expr20036 thenValues@var4345 , elseValues@var4346 ) ; }
5750:
5751: if (@expr1073761861 Token ::@expr19983 Match (@expr1073761863 ctx@var4353 .@expr20040 astParent (@expr20041 ) , "%oror%|&&" ) ) {
5752: Token * parent@var4354 ; parent@var4354 =@expr1073761866 ctx@var4353 .@expr20040 astParent (@expr20041 ) ;
5753: if (@expr1073761869 astIsRHS (@expr1073761870 ctx@var4353 ) &&@expr1073761871 astIsLHS (@expr20048 parent@var4354 ) &&@expr1073761873 parent@var4354 .@expr20050 astParent (@expr20051 ) &&@expr1073761876
5754: parent@var4354 .@expr20053 str (@expr20054 ) ==@expr20055 parent@var4354 .@expr20050 astParent (@expr20051 ) .@expr20058 str (@expr20059 ) ) {
5755: parent@var4354 =@expr1073761884 parent@var4354 .@expr20050 astParent (@expr20051 ) ; }
5756: else { if (@expr1073761887 !@expr1073761888 astIsLHS (@expr1073761889 ctx@var4353 ) ) {
5757: parent@var4354 =@expr1073761890 nullptr ;
5758: } }
5759: if (@expr1073761891 parent@var4354 ) {
5760: std ::@expr1073761892 vector < Token *@expr19972 > nextExprs@var4355 ; nextExprs@var4355 =@expr1073761894 {@expr1073761895 parent@var4354 .@expr1073761896 astOperand2 (@expr1073761897 ) } ;
5761: if (@expr1073761898 astIsLHS (@expr20048 parent@var4354 ) &&@expr1073761900 parent@var4354 .@expr20050 astParent (@expr20051 ) &&@expr1073761903 parent@var4354 .@expr20050 astParent (@expr20051 ) .@expr20058 str (@expr20059 ) ==@expr20055 parent@var4354 .@expr20053 str (@expr20054 ) ) {
5762: nextExprs@var4355 .@expr1073761911 push_back (@expr1073761912 parent@var4354 .@expr20050 astParent (@expr20051 ) .@expr1073761915 astOperand2 (@expr1073761916 ) ) ;
5763: }
5764: const std ::@expr1073761917 string & op@var4356 (@expr1073761918 parent@var4354 .@expr20053 str (@expr20054 ) ) ;
5765: std ::@expr1073761921 list < ValueFlow ::@expr19978 Value > values@var4357 ;
5766: if (@expr1073761923 op@var4356 ==@expr1073761924 "&&" ) {
5767: values@var4357 =@expr1073761925 thenValues@var4345 ; }
5768: else { if (@expr1073761926 op@var4356 ==@expr1073761927 "||" ) {
5769: values@var4357 =@expr1073761928 elseValues@var4346 ; } }
5770: if (@expr1073761929 Token ::@expr19983 Match (@expr1073761931 condTok@var4342 , "==|!=" ) ||@expr1073761932 cond@var4341 .@expr20025 isBool (@expr20026 ) ) {
5771: changePossibleToKnown (@expr1073761935 values@var4357 ) ; }
5772: if (@expr1073761936 astIsFloat (@expr1073761937 cond@var4341 .@expr19987 vartok@var4347 , false ) ||@expr1073761939
5773: (@expr1073761940 !@expr1073761941 cond@var4341 .@expr19987 vartok@var4347 .@expr1073761943 valueType (@expr1073761944 ) &&@expr1073761945
5774: std ::@expr1073761946 all_of (@expr1073761947 values@var4357 .@expr1073761948 begin (@expr1073761949 ) , values@var4357 .@expr1073761950 end (@expr1073761951 ) , [@expr1073761952 ] (@expr1073761953 const ValueFlow ::@expr19978 Value &@expr19969 v@var4358 ) {
5775: return v@var4358 .@expr1073761956 isIntValue (@expr1073761957 ) ||@expr1073761958 v@var4358 .@expr1073761959 isFloatValue (@expr1073761960 ) ;
5776: } ) ) ) {
5777: values@var4357 .@expr1073761961 remove_if (@expr1073761962 [@expr1073761963 &@expr19969 ] (@expr1073761965 const ValueFlow ::@expr19978 Value &@expr19969 v@var4359 ) {
5778: return v@var4359 .@expr1073761968 isImpossible (@expr1073761969 ) ;
5779: } ) ; }
5780: for (@expr1073761970 Token *@expr19972 start@var4360 :@expr1073761972 nextExprs@var4355 ) {
5781: Analyzer ::@expr1073761973 Result r@var4361 ; r@var4361 =@expr1073761974 forward (@expr1073761975 start@var4360 , cond@var4341 .@expr19987 vartok@var4347 , values@var4357 , tokenlist@var4337 , settings@var4340 ) ;
5782: if (@expr1073761977 r@var4361 .@expr1073761978 terminate@var4362 !=@expr1073761979 Analyzer ::@expr20156 Terminate ::@expr20157 None@expr1073761790 ) {
5783: return ; }
5784: }
5785: }
5786: }
5787:
5788: {
5789: const Token * tok2@var4363 ; tok2@var4363 =@expr1073761982 condTok@var4342 ;
5790: std ::@expr1073761983 string op@var4364 ;
5791: bool mixedOperators@var4365 ; mixedOperators@var4365 =@expr1073761984 false ;
5792: while (@expr1073761985 tok2@var4363 .@expr20162 astParent (@expr20163 ) ) {
5793: const Token * parent@var4366 ; parent@var4366 =@expr1073761988 tok2@var4363 .@expr20162 astParent (@expr20163 ) ;
5794: if (@expr1073761991 Token ::@expr19983 Match (@expr1073761993 parent@var4366 , "%oror%|&&" ) ) {
5795: if (@expr1073761994 op@var4364 .@expr1073761995 empty (@expr1073761996 ) ) {
5796: op@var4364 =@expr1073761997 parent@var4366 .@expr20174 str (@expr20175 ) ;
5797: } else { if (@expr1073762000 op@var4364 !=@expr1073762001 parent@var4366 .@expr20174 str (@expr20175 ) ) {
5798: mixedOperators@var4365 =@expr1073762004 true ;
5799: break ;
5800: } }
5801: }
5802: if (@expr1073762005 parent@var4366 .@expr20174 str (@expr20175 ) ==@expr1073762008 "!" ) {
5803: op@var4364 =@expr1073762009 op@var4364 ==@expr1073762010 "&&" ?@expr1073762011 "||" :@expr1073762012 "&&" ;
5804: }
5805: tok2@var4363 =@expr1073762013 parent@var4366 ;
5806: }
5807:
5808: if (@expr1073762014 mixedOperators@var4365 ) {
5809: return ;
5810: }
5811: }
5812:
5813: if (@expr1073762015 !@expr1073762016 top@var4344 ) {
5814: return ; }
5815:
5816: if (@expr1073762017 top@var4344 .@expr20194 previous (@expr20195 ) .@expr1073762020 isExpandedMacro (@expr1073762021 ) ) {
5817: for (@expr1073762022 std ::@expr19978 list < ValueFlow ::@expr19978 Value > *@expr19972 values@var4367 :@expr1073762026 {@expr1073762027 &@expr20204 thenValues@var4345 , &@expr20205 elseValues@var4346 } ) {
5818: for (@expr1073762030 ValueFlow ::@expr19978 Value &@expr19969 v@var4368 :@expr1073762033 *@expr1073762034 values@var4367 ) {
5819: v@var4368 .@expr1073762035 macro@var4369 =@expr1073762036 true ; }
5820: }
5821: }
5822:
5823: Token * condTop@var4370 ; condTop@var4370 =@expr1073762037 ctx@var4353 .@expr20040 astParent (@expr20041 ) ;
5824: {
5825: bool inverted2@var4371 ; inverted2@var4371 =@expr1073762040 false ;
5826: while (@expr1073762041 Token ::@expr19983 Match (@expr1073762043 condTop@var4370 , "%oror%|&&" ) ) {
5827: Token * parent@var4372 ; parent@var4372 =@expr1073762044 skipNotAndCasts (@expr1073762045 condTop@var4370 , &@expr1073762046 inverted2@var4371 ) .@expr1073762047 astParent (@expr1073762048 ) ;
5828: if (@expr1073762049 !@expr1073762050 parent@var4372 ) {
5829: break ; }
5830: condTop@var4370 =@expr1073762051 parent@var4372 ;
5831: }
5832: if (@expr1073762052 inverted2@var4371 ) {
5833: std ::@expr20035 swap (@expr20036 thenValues@var4345 , elseValues@var4346 ) ; }
5834: }
5835:
5836: if (@expr1073762055 !@expr1073762056 condTop@var4370 ) {
5837: return ; }
5838:
5839: if (@expr1073762057 Token ::@expr20234 simpleMatch (@expr1073762059 condTop@var4370 , "?" ) ) {
5840: Token * colon@var4373 ; colon@var4373 =@expr1073762060 condTop@var4370 .@expr1073762061 astOperand2 (@expr1073762062 ) ;
5841: forward (@expr1073762063 colon@var4373 .@expr1073762064 astOperand1 (@expr1073762065 ) , cond@var4341 .@expr19987 vartok@var4347 , thenValues@var4345 , tokenlist@var4337 , settings@var4340 ) ;
5842: forward (@expr1073762067 colon@var4373 .@expr1073762068 astOperand2 (@expr1073762069 ) , cond@var4341 .@expr19987 vartok@var4347 , elseValues@var4346 , tokenlist@var4337 , settings@var4340 ) ;
5843:
5844: return ;
5845: }
5846:
5847: if (@expr1073762071 condTop@var4370 !=@expr1073762072 top@var4344 &&@expr1073762073 condTop@var4370 .@expr1073762074 str (@expr1073762075 ) !=@expr1073762076 ";" ) {
5848: return ; }
5849:
5850: if (@expr1073762077 !@expr1073762078 Token ::@expr19983 Match (@expr1073762080 top@var4344 .@expr20194 previous (@expr20195 ) , "if|while|for (" ) ) {
5851: return ; }
5852:
5853: if (@expr1073762083 top@var4344 .@expr20194 previous (@expr20195 ) .@expr1073762086 str (@expr1073762087 ) ==@expr1073762088 "for" ) {
5854: if (@expr1073762089 !@expr1073762090 Token ::@expr19983 Match (@expr1073762092 condTok@var4342 , "%comp%" ) ) {
5855: return ; }
5856: if (@expr1073762093 !@expr1073762094 Token ::@expr20234 simpleMatch (@expr1073762096 condTok@var4342 .@expr20273 astParent (@expr20274 ) , ";" ) ) {
5857: return ; }
5858: const Token * stepTok@var4374 ; stepTok@var4374 =@expr1073762099 getStepTok (@expr1073762100 top@var4344 ) ;
5859: if (@expr1073762101 cond@var4341 .@expr19987 vartok@var4347 .@expr20279 varId (@expr20280 ) ==@expr1073762105 0 ) {
5860: return ; }
5861: if (@expr1073762106 !@expr1073762107 cond@var4341 .@expr19987 vartok@var4347 .@expr20285 variable (@expr20286 ) ) {
5862: return ; }
5863: if (@expr1073762111 !@expr1073762112 Token ::@expr19983 Match (@expr1073762114 stepTok@var4374 , "++|--" ) ) {
5864: return ; }
5865: std ::@expr1073762115 set < ValueFlow ::@expr19978 Value ::@expr19978 Bound > bounds@var4375 ;
5866: for (@expr1073762118 const ValueFlow ::@expr19978 Value &@expr19969 v@var4376 :@expr1073762121 thenValues@var4345 ) {
5867: if (@expr1073762122 v@var4376 .@expr20299 bound@var4377 !=@expr1073762124 ValueFlow ::@expr20301 Value ::@expr20302 Bound ::@expr1073762127 Point &&@expr1073762128 v@var4376 .@expr1073762129 isImpossible (@expr1073762130 ) ) {
5868: continue ; }
5869: bounds@var4375 .@expr1073762131 insert (@expr1073762132 v@var4376 .@expr20299 bound@var4377 ) ;
5870: }
5871: if (@expr1073762134 Token ::@expr20234 simpleMatch (@expr1073762136 stepTok@var4374 , "++" ) &&@expr1073762137 bounds@var4375 .@expr20314 count (@expr1073762139 ValueFlow ::@expr20301 Value ::@expr20302 Bound ::@expr1073762142 Lower ) >@expr1073762143 0 ) {
5872: return ; }
5873: if (@expr1073762144 Token ::@expr20234 simpleMatch (@expr1073762146 stepTok@var4374 , "--" ) &&@expr1073762147 bounds@var4375 .@expr20314 count (@expr1073762149 ValueFlow ::@expr20301 Value ::@expr20302 Bound ::@expr1073762152 Upper ) >@expr1073762153 0 ) {
5874: return ; }
5875: const Token * childTok@var4378 ; childTok@var4378 =@expr1073762154 condTok@var4342 .@expr1073762155 astOperand1 (@expr1073762156 ) ;
5876: if (@expr20333 !@expr20334 childTok@var4378 ) {
5877: childTok@var4378 =@expr1073762159 condTok@var4342 .@expr1073762160 astOperand2 (@expr1073762161 ) ; }
5878: if (@expr20333 !@expr20334 childTok@var4378 ) {
5879: return ; }
5880: if (@expr1073762164 childTok@var4378 .@expr1073762165 varId (@expr1073762166 ) !=@expr1073762167 cond@var4341 .@expr19987 vartok@var4347 .@expr20279 varId (@expr20280 ) ) {
5881: return ; }
5882: const Token * startBlock@var4379 ; startBlock@var4379 =@expr1073762171 top@var4344 .@expr20348 link (@expr20349 ) .@expr20350 next (@expr20351 ) ;
5883: if (@expr1073762176 isVariableChanged (@expr1073762177 startBlock@var4379 ,
5884: startBlock@var4379 .@expr1073762178 link (@expr1073762179 ) ,
5885: cond@var4341 .@expr19987 vartok@var4347 .@expr20279 varId (@expr20280 ) ,
5886: cond@var4341 .@expr19987 vartok@var4347 .@expr20285 variable (@expr20286 ) .@expr1073762186 isGlobal (@expr1073762187 ) ,
5887: settings@var4340 ,
5888: tokenlist@var4337 .@expr1073762188 isCPP (@expr1073762189 ) ) ) {
5889: return ; }
5890:
5891: const Token * initTok@var4380 ; initTok@var4380 =@expr1073762190 getInitTok (@expr1073762191 top@var4344 ) ;
5892: ProgramMemory pm@var4381 ;
5893: execute (@expr1073762192 initTok@var4380 , &@expr20369 pm@var4381 , nullptr , nullptr ) ;
5894: long long result@var4382 ; result@var4382 =@expr1073762194 1 ;
5895: execute (@expr1073762195 condTok@var4342 , &@expr20369 pm@var4381 , &@expr1073762197 result@var4382 , nullptr ) ;
5896: if (@expr1073762198 result@var4382 ==@expr1073762199 0 ) {
5897: return ; }
5898:
5899: for (@expr1073762200 std ::@expr19978 list < ValueFlow ::@expr19978 Value > *@expr19972 values@var4383 :@expr1073762204 {@expr1073762205 &@expr20204 thenValues@var4345 , &@expr20205 elseValues@var4346 } ) {
5900: for (@expr1073762208 ValueFlow ::@expr19978 Value &@expr19969 v@var4384 :@expr1073762211 *@expr1073762212 values@var4383 ) {
5901: v@var4384 .@expr1073762213 condition@var4385 =@expr1073762214 nullptr ;
5902: v@var4384 .@expr1073762215 conditional@var4386 =@expr1073762216 true ;
5903: }
5904: }
5905: }
5906:
5907: bool deadBranch@var4387 [@expr1073762217 2 ] =@expr1073762218 {@expr1073762219 false , false } ;
5908:
5909: Token * startTokens@var4388 [@expr1073762220 2 ] =@expr1073762221 {@expr1073762222 nullptr , nullptr } ;
5910:
5911: if (@expr20399 Token ::@expr20234 simpleMatch (@expr20401 top@var4344 .@expr20348 link (@expr20349 ) , ") {" ) ) {
5912: startTokens@var4388 [@expr1073762228 0 ] =@expr1073762229 top@var4344 .@expr20348 link (@expr20349 ) .@expr20350 next (@expr20351 ) ; }
5913: if (@expr1073762234 Token ::@expr20234 simpleMatch (@expr1073762236 top@var4344 .@expr20348 link (@expr20349 ) .@expr20415 linkAt (@expr20416 1 ) , "} else {" ) ) {
5914: startTokens@var4388 [@expr1073762241 1 ] =@expr1073762242 top@var4344 .@expr20348 link (@expr20349 ) .@expr20415 linkAt (@expr20416 1 ) .@expr1073762247 tokAt (@expr1073762248 2 ) ; }
5915:
5916: int changeBlock@var4389 ; changeBlock@var4389 =@expr1073762249 -1 ;
5917: int bailBlock@var4390 ; bailBlock@var4390 =@expr1073762250 -1 ;
5918:
5919: for (@expr1073762251 int i@var4391 =@expr1073762252 0 ; i@var4391 <@expr1073762253 2 ; i@var4391 ++@expr1073762254 ) {
5920: const Token * const startToken@var4392 ; startToken@var4392 =@expr1073762255 startTokens@var4388 [@expr20432 i@var4391 ] ;
5921: if (@expr1073762257 !@expr1073762258 startToken@var4392 ) {
5922: continue ; }
5923: std ::@expr1073762259 list < ValueFlow ::@expr19978 Value > & values@var4393 =@expr1073762261 i@var4391 ==@expr20438 0 ?@expr1073762263 thenValues@var4345 :@expr1073762264 elseValues@var4346 ;
5924: valueFlowSetConditionToKnown (@expr1073762265 condTok@var4342 , values@var4393 , i@var4391 ==@expr20438 0 ) ;
5925:
5926: Analyzer ::@expr1073762267 Result r@var4394 ; r@var4394 =@expr1073762268
5927: forward (@expr1073762269 startTokens@var4388 [@expr20432 i@var4391 ] , startTokens@var4388 [@expr20432 i@var4391 ] .@expr1073762272 link (@expr1073762273 ) , cond@var4341 .@expr19987 vartok@var4347 , values@var4393 , tokenlist@var4337 , settings@var4340 ) ;
5928: deadBranch@var4387 [@expr20451 i@var4391 ] =@expr1073762276 r@var4394 .@expr20453 terminate@var4395 ==@expr1073762278 Analyzer ::@expr20156 Terminate ::@expr20456 Escape ;
5929: if (@expr1073762281 r@var4394 .@expr1073762282 action@var4396 .@expr1073762283 isModified (@expr1073762284 ) &&@expr1073762285 !@expr1073762286 deadBranch@var4387 [@expr20451 i@var4391 ] ) {
5930: changeBlock@var4389 =@expr1073762288 i@var4391 ; }
5931: if (@expr1073762289 r@var4394 .@expr20453 terminate@var4395 !=@expr1073762291 Analyzer ::@expr20156 Terminate ::@expr20157 None &&@expr1073762294 r@var4394 .@expr20453 terminate@var4395 !=@expr1073762296 Analyzer ::@expr20156 Terminate ::@expr20456 Escape &&@expr1073762299
5932: r@var4394 .@expr20453 terminate@var4395 !=@expr1073762301 Analyzer ::@expr20156 Terminate ::@expr1073762303 Modified ) {
5933: bailBlock@var4390 =@expr1073762304 i@var4391 ; }
5934: changeKnownToPossible (@expr1073762305 values@var4393 ) ;
5935: }
5936: if (@expr1073762306 changeBlock@var4389 >=@expr1073762307 0 &&@expr1073762308 !@expr1073762309 Token ::@expr20234 simpleMatch (@expr1073762311 top@var4344 .@expr20194 previous (@expr20195 ) , "while (" ) ) {
5937: if (@expr20490 settings@var4340 .@expr20491 debugwarnings@var4397 ) {
5938: $bailoutInternal $(@expr1073762316 $"valueFlowBailout" $, tokenlist@var4337 $, errorLogger@var4339 $, startTokens@var4388 [@expr1073762317 changeBlock@var4389 ] .@expr1073762318 link (@expr1073762319 ) $, "valueFlowAfterCondition: " +@expr1073762320 cond@var4341 .@expr19987 vartok@var4347 .@expr1073762322 expressionString (@expr1073762323 ) +@expr1073762324 " is changed in conditional block" $, "cppcheck-2.8/lib/valueflow.cpp" $, 5938 $, $__func__ $)
5939:
5940:
5941:
5942: ; }
5943: return ;
5944: } else { if (@expr1073762325 bailBlock@var4390 >=@expr1073762326 0 ) {
5945: if (@expr20490 settings@var4340 .@expr20491 debugwarnings@var4397 ) {
5946: $bailoutInternal $(@expr1073762329 $"valueFlowBailout" $, tokenlist@var4337 $, errorLogger@var4339 $, startTokens@var4388 [@expr1073762330 bailBlock@var4390 ] .@expr1073762331 link (@expr1073762332 ) $, "valueFlowAfterCondition: bailing in conditional block" $, "cppcheck-2.8/lib/valueflow.cpp" $, 5946 $, $__func__ $)
5947:
5948:
5949: ; }
5950: return ;
5951: } }
5952:
5953:
5954: if (@expr20399 Token ::@expr20234 simpleMatch (@expr20401 top@var4344 .@expr20348 link (@expr20349 ) , ") {" ) ) {
5955: Token * after@var4398 ; after@var4398 =@expr1073762338 top@var4344 .@expr20348 link (@expr20349 ) .@expr20415 linkAt (@expr20416 1 ) ;
5956: bool dead_if@var4399 ; dead_if@var4399 =@expr1073762343 deadBranch@var4387 [@expr1073762344 0 ] ;
5957: bool dead_else@var4400 ; dead_else@var4400 =@expr1073762345 deadBranch@var4387 [@expr1073762346 1 ] ;
5958: const Token * unknownFunction@var4401 ; unknownFunction@var4401 =@expr1073762347 nullptr ;
5959: if (@expr1073762348 condTok@var4342 .@expr20273 astParent (@expr20274 ) &&@expr1073762351 Token ::@expr19983 Match (@expr1073762353 top@var4344 .@expr20194 previous (@expr20195 ) , "while|for (" ) ) {
5960: dead_if@var4399 =@expr1073762356 !@expr1073762357 isBreakScope (@expr1073762358 after@var4398 ) ; }
5961: else { if (@expr1073762359 !@expr20536 dead_if@var4399 ) {
5962: dead_if@var4399 =@expr1073762361 isReturnScope (@expr20538 after@var4398 , &@expr20539 settings@var4340 .@expr20540 library@var4402 , &@expr20541 unknownFunction@var4401 ) ; } }
5963:
5964: if (@expr1073762366 !@expr20536 dead_if@var4399 &&@expr1073762368 unknownFunction@var4401 ) {
5965: if (@expr20490 settings@var4340 .@expr20491 debugwarnings@var4397 ) {
5966: $bailoutInternal $(@expr1073762371 $"valueFlowBailout" $, tokenlist@var4337 $, errorLogger@var4339 $, unknownFunction@var4401 $, "possible noreturn scope" $, "cppcheck-2.8/lib/valueflow.cpp" $, 5966 $, $__func__ $) ; }
5967: return ;
5968: }
5969:
5970: if (@expr1073762372 Token ::@expr20234 simpleMatch (@expr1073762374 after@var4398 , "} else {" ) ) {
5971: after@var4398 =@expr1073762375 after@var4398 .@expr1073762376 linkAt (@expr1073762377 2 ) ;
5972: unknownFunction@var4401 =@expr1073762378 nullptr ;
5973: if (@expr1073762379 !@expr20556 dead_else@var4400 ) {
5974: dead_else@var4400 =@expr1073762381 isReturnScope (@expr20538 after@var4398 , &@expr20539 settings@var4340 .@expr20540 library@var4402 , &@expr20541 unknownFunction@var4401 ) ; }
5975: if (@expr1073762386 !@expr20556 dead_else@var4400 &&@expr1073762388 unknownFunction@var4401 ) {
5976: if (@expr20490 settings@var4340 .@expr20491 debugwarnings@var4397 ) {
5977: $bailoutInternal $(@expr1073762391 $"valueFlowBailout" $, tokenlist@var4337 $, errorLogger@var4339 $, unknownFunction@var4401 $, "possible noreturn scope" $, "cppcheck-2.8/lib/valueflow.cpp" $, 5977 $, $__func__ $) ; }
5978: return ;
5979: }
5980: }
5981:
5982: if (@expr1073762392 dead_if@var4399 &&@expr1073762393 dead_else@var4400 ) {
5983: return ; }
5984:
5985: std ::@expr1073762394 list < ValueFlow ::@expr19978 Value > values@var4403 ;
5986: if (@expr1073762396 dead_if@var4399 ) {
5987: values@var4403 =@expr1073762397 elseValues@var4346 ;
5988: } else { if (@expr1073762398 dead_else@var4400 ) {
5989: values@var4403 =@expr1073762399 thenValues@var4345 ;
5990: } else {
5991: std ::@expr20576 copy_if (@expr1073762401 thenValues@var4345 .@expr1073762402 begin (@expr1073762403 ) ,
5992: thenValues@var4345 .@expr19990 end (@expr19991 ) ,
5993: std ::@expr20582 back_inserter (@expr20583 values@var4403 ) ,
5994: std ::@expr20584 mem_fn (@expr20585 &@expr20586 ValueFlow ::@expr20301 Value ::@expr20588 isPossible ) ) ;
5995: std ::@expr20576 copy_if (@expr1073762414 elseValues@var4346 .@expr1073762415 begin (@expr1073762416 ) ,
5996: elseValues@var4346 .@expr20010 end (@expr20011 ) ,
5997: std ::@expr20582 back_inserter (@expr20583 values@var4403 ) ,
5998: std ::@expr20584 mem_fn (@expr20585 &@expr20586 ValueFlow ::@expr20301 Value ::@expr20588 isPossible ) ) ;
5999: } }
6000:
6001: if (@expr20602 values@var4403 .@expr20603 empty (@expr20604 ) ) {
6002: return ; }
6003:
6004: if (@expr1073762429 dead_if@var4399 ||@expr1073762430 dead_else@var4400 ) {
6005: const Token * parent@var4404 ; parent@var4404 =@expr1073762431 condTok@var4342 .@expr20273 astParent (@expr20274 ) ;
6006:
6007: while (@expr1073762434 Token ::@expr20234 simpleMatch (@expr20612 parent@var4404 , "!" ) ) {
6008: parent@var4404 =@expr1073762437 parent@var4404 .@expr20614 astParent (@expr20615 ) ; }
6009: bool possible@var4405 ; possible@var4405 =@expr1073762440 false ;
6010: if (@expr1073762441 Token ::@expr19983 Match (@expr1073762443 parent@var4404 , "&&|%oror%" ) ) {
6011: std ::@expr1073762444 string op@var4406 ; op@var4406 =@expr1073762445 parent@var4404 .@expr20622 str (@expr20623 ) ;
6012: while (@expr1073762448 parent@var4404 &&@expr1073762449 parent@var4404 .@expr20622 str (@expr20623 ) ==@expr1073762452 op@var4406 ) {
6013: parent@var4404 =@expr1073762453 parent@var4404 .@expr20614 astParent (@expr20615 ) ; }
6014: if (@expr1073762456 Token ::@expr20234 simpleMatch (@expr20612 parent@var4404 , "!" ) ||@expr1073762459 Token ::@expr20234 simpleMatch (@expr1073762461 parent@var4404 , "== false" ) ) {
6015: possible@var4405 =@expr1073762462 op@var4406 ==@expr1073762463 "||" ; }
6016: else {
6017: possible@var4405 =@expr1073762464 op@var4406 ==@expr1073762465 "&&" ; }
6018: }
6019: if (@expr1073762466 possible@var4405 ) {
6020: values@var4403 .@expr1073762467 remove_if (@expr1073762468 std ::@expr20584 mem_fn (@expr1073762470 &@expr1073762471 ValueFlow ::@expr20301 Value ::@expr1073762473 isImpossible ) ) ;
6021: changeKnownToPossible (@expr1073762474 values@var4403 ) ;
6022: } else {
6023: valueFlowSetConditionToKnown (@expr1073762475 condTok@var4342 , values@var4403 , true ) ;
6024: valueFlowSetConditionToKnown (@expr1073762476 condTok@var4342 , values@var4403 , false ) ;
6025: }
6026: }
6027: if (@expr20602 values@var4403 .@expr20603 empty (@expr20604 ) ) {
6028: return ; }
6029: forward (@expr1073762480 after@var4398 , getEndOfExprScope (@expr1073762481 cond@var4341 .@expr19987 vartok@var4347 , scope@var4343 ) , cond@var4341 .@expr19987 vartok@var4347 , values@var4403 , tokenlist@var4337 , settings@var4340 ) ;
6030: }
6031: } ) ;
6032: }
6033: virtual ~ ConditionHandler ( ) { }
6034: } ;
6035:
6036: static void valueFlowCondition ( const ValuePtr<ConditionHandler> & handler@var4407 ,
6037: TokenList * tokenlist@var4408 ,
6038: SymbolDatabase * symboldatabase@var4409 ,
6039: ErrorLogger * errorLogger@var4410 ,
6040: const Settings * settings@var4411 )
6041: {
6042: handler@var4407 .@expr1073762484 beforeCondition (@expr1073762485 tokenlist@var4408 , symboldatabase@var4409 , errorLogger@var4410 , settings@var4411 ) ;
6043: handler@var4407 .@expr1073762486 afterCondition (@expr1073762487 tokenlist@var4408 , symboldatabase@var4409 , errorLogger@var4410 , settings@var4411 ) ;
6044: }
6045:
6046: struct SimpleConditionHandler : ConditionHandler {
6047: virtual Analyzer :: Result forward ( Token * start@var4412 ,
6048: const Token * stop@var4413 ,
6049: const Token * exprTok@var4414 ,
6050: const std :: list < ValueFlow :: Value > & values@var4415 ,
6051: TokenList * tokenlist@var4416 ,
6052: const Settings * settings@var4417 ) const override {
6053: return valueFlowForward (@expr1073762488 start@var4412 .@expr1073762489 next (@expr1073762490 ) , stop@var4413 , exprTok@var4414 , values@var4415 , tokenlist@var4416 , settings@var4417 ) ;
6054: }
6055:
6056: virtual Analyzer :: Result forward ( Token * top@var4418 ,
6057: const Token * exprTok@var4419 ,
6058: const std :: list < ValueFlow :: Value > & values@var4420 ,
6059: TokenList * tokenlist@var4421 ,
6060: const Settings * settings@var4422 ) const override {
6061: return valueFlowForward (@expr1073762491 top@var4418 , exprTok@var4419 , values@var4420 , tokenlist@var4421 , settings@var4422 ) ;
6062: }
6063:
6064: virtual void reverse ( Token * start@var4423 ,
6065: const Token * endToken@var4424 ,
6066: const Token * exprTok@var4425 ,
6067: const std :: list < ValueFlow :: Value > & values@var4426 ,
6068: TokenList * tokenlist@var4427 ,
6069: const Settings * settings@var4428 ) const override {
6070: return valueFlowReverse (@expr1073762492 start@var4423 , endToken@var4424 , exprTok@var4425 , values@var4426 , tokenlist@var4427 , settings@var4428 ) ;
6071: }
6072:
6073: virtual std :: vector < Condition > parse ( const Token * tok@var4429 , const Settings * ) const override {
6074: Condition cond@var4430 ;
6075: ValueFlow ::@expr1073762493 Value true_value@var4431 ;
6076: ValueFlow ::@expr1073762494 Value false_value@var4432 ;
6077: const Token * vartok@var4433 ; vartok@var4433 =@expr1073762495 parseCompareInt (@expr1073762496 tok@var4429 , true_value@var4431 , false_value@var4432 ) ;
6078: if (@expr1073762497 vartok@var4433 ) {
6079: if (@expr1073762498 vartok@var4433 .@expr1073762499 hasKnownIntValue (@expr1073762500 ) ) {
6080: return { } ; }
6081: if (@expr1073762501 vartok@var4433 .@expr1073762502 str (@expr1073762503 ) ==@expr1073762504 "=" &&@expr1073762505 vartok@var4433 .@expr20682 astOperand1 (@expr20683 ) &&@expr1073762508 vartok@var4433 .@expr1073762509 astOperand2 (@expr1073762510 ) ) {
6082: vartok@var4433 =@expr1073762511 vartok@var4433 .@expr20682 astOperand1 (@expr20683 ) ; }
6083: cond@var4430 .@expr20690 true_values@var4434 .@expr1073762515 push_back (@expr1073762516 true_value@var4431 ) ;
6084: cond@var4430 .@expr20693 false_values@var4435 .@expr1073762518 push_back (@expr1073762519 false_value@var4432 ) ;
6085: cond@var4430 .@expr20696 vartok@var4436 =@expr1073762521 vartok@var4433 ;
6086: return {@expr1073762522 cond@var4430 } ;
6087: }
6088:
6089: if (@expr1073762523 tok@var4429 .@expr1073762524 str (@expr1073762525 ) ==@expr1073762526 "!" ) {
6090: vartok@var4433 =@expr1073762527 tok@var4429 .@expr20704 astOperand1 (@expr20705 ) ;
6091:
6092: } else { if (@expr1073762530 tok@var4429 .@expr20707 astParent (@expr20708 ) &&@expr1073762533 (@expr1073762534 Token ::@expr20711 Match (@expr1073762536 tok@var4429 .@expr20707 astParent (@expr20708 ) , "%oror%|&&|?" ) ||@expr1073762539
6093: Token ::@expr20711 Match (@expr1073762541 tok@var4429 .@expr20707 astParent (@expr20708 ) .@expr1073762544 previous (@expr1073762545 ) , "if|while (" ) ) ) {
6094: if (@expr1073762546 Token ::@expr1073762547 simpleMatch (@expr1073762548 tok@var4429 , "=" ) ) {
6095: vartok@var4433 =@expr1073762549 tok@var4429 .@expr20704 astOperand1 (@expr20705 ) ; }
6096: else { if (@expr1073762552 !@expr1073762553 Token ::@expr20711 Match (@expr1073762555 tok@var4429 , "%comp%|%assign%" ) ) {
6097: vartok@var4433 =@expr1073762556 tok@var4429 ; } }
6098: } }
6099:
6100: if (@expr1073762557 !@expr1073762558 vartok@var4433 ) {
6101: return { } ; }
6102: cond@var4430 .@expr20690 true_values@var4434 .@expr1073762560 emplace_back (@expr1073762561 tok@var4429 , 0LL ) ;
6103: cond@var4430 .@expr20693 false_values@var4435 .@expr1073762563 emplace_back (@expr1073762564 tok@var4429 , 0LL ) ;
6104: cond@var4430 .@expr20696 vartok@var4436 =@expr1073762566 vartok@var4433 ;
6105:
6106: return {@expr1073762567 cond@var4430 } ;
6107: }
6108: } ;
6109:
6110: struct IntegralInferModel : InferModel {
6111: virtual bool match ( const ValueFlow :: Value & value@var4437 ) const override {
6112: return value@var4437 .@expr1073762568 isIntValue (@expr1073762569 ) ;
6113: }
6114: virtual ValueFlow :: Value yield ( long long value@var4438 ) const override
6115: {
6116: ValueFlow ::@expr1073762570 Value result@var4439 (@expr1073762571 value@var4438 ) ;
6117: result@var4439 .@expr1073762572 valueType@var4440 =@expr1073762573 ValueFlow ::@expr1073762574 Value ::@expr1073762575 ValueType ::@expr1073762576 INT ;
6118: result@var4439 .@expr1073762577 setKnown (@expr1073762578 ) ;
6119: return result@var4439 ;
6120: }
6121: } ;
6122:
6123: ValuePtr<InferModel> makeIntegralInferModel ( ) {
6124: return IntegralInferModel {@expr1073762579 } ;
6125: }
6126:
6127: ValueFlow :: Value inferCondition ( const std :: string & op@var4441 , const Token * varTok@var4442 , long long val@var4443 )
6128: {
6129: if (@expr1073762580 !@expr1073762581 varTok@var4442 ) {
6130: return ValueFlow ::@expr20758 Value {@expr1073762583 } ; }
6131: if (@expr1073762584 varTok@var4442 .@expr1073762585 hasKnownIntValue (@expr1073762586 ) ) {
6132: return ValueFlow ::@expr20758 Value {@expr1073762588 } ; }
6133: std ::@expr1073762589 vector < ValueFlow ::@expr1073762590 Value > r@var4444 ; r@var4444 =@expr1073762591 infer (@expr1073762592 IntegralInferModel {@expr1073762593 } , op@var4441 , varTok@var4442 .@expr1073762594 values (@expr1073762595 ) , val@var4443 ) ;
6134: if (@expr1073762596 r@var4444 .@expr1073762597 size (@expr1073762598 ) ==@expr1073762599 1 &&@expr1073762600 r@var4444 .@expr20777 front (@expr20778 ) .@expr1073762603 isKnown (@expr1073762604 ) ) {
6135: return r@var4444 .@expr20777 front (@expr20778 ) ; }
6136: return ValueFlow ::@expr20758 Value {@expr1073762608 } ;
6137: }
6138:
6139: ValueFlow :: Value inferCondition ( std :: string op@var4445 , long long val@var4446 , const Token * varTok@var4447 )
6140: {
6141: if (@expr1073762609 !@expr1073762610 varTok@var4447 ) {
6142: return ValueFlow ::@expr20787 Value {@expr1073762612 } ; }
6143: if (@expr1073762613 varTok@var4447 .@expr1073762614 hasKnownIntValue (@expr1073762615 ) ) {
6144: return ValueFlow ::@expr20787 Value {@expr1073762617 } ; }
6145: std ::@expr1073762618 vector < ValueFlow ::@expr1073762619 Value > r@var4448 ; r@var4448 =@expr1073762620 infer (@expr1073762621 IntegralInferModel {@expr1073762622 } , op@var4445 , val@var4446 , varTok@var4447 .@expr1073762623 values (@expr1073762624 ) ) ;
6146: if (@expr1073762625 r@var4448 .@expr1073762626 size (@expr1073762627 ) ==@expr1073762628 1 &&@expr1073762629 r@var4448 .@expr20806 front (@expr20807 ) .@expr1073762632 isKnown (@expr1073762633 ) ) {
6147: return r@var4448 .@expr20806 front (@expr20807 ) ; }
6148: return ValueFlow ::@expr20787 Value {@expr1073762637 } ;
6149: }
6150:
6151: struct IteratorInferModel : InferModel {
6152: virtual ValueFlow :: Value :: ValueType getType ( ) const = 0 ;
6153: virtual bool match ( const ValueFlow :: Value & value@var4449 ) const override {
6154: return value@var4449 .@expr1073762638 valueType@var4450 ==@expr1073762639 getType (@expr1073762640 ) ;
6155: }
6156: virtual ValueFlow :: Value yield ( long long value@var4451 ) const override
6157: {
6158: ValueFlow ::@expr1073762641 Value result@var4452 (@expr1073762642 value@var4451 ) ;
6159: result@var4452 .@expr1073762643 valueType@var4453 =@expr1073762644 getType (@expr1073762645 ) ;
6160: result@var4452 .@expr1073762646 setKnown (@expr1073762647 ) ;
6161: return result@var4452 ;
6162: }
6163: } ;
6164:
6165: struct EndIteratorInferModel : IteratorInferModel {
6166: virtual ValueFlow :: Value :: ValueType getType ( ) const override {
6167: return ValueFlow ::@expr1073762648 Value ::@expr1073762649 ValueType ::@expr1073762650 ITERATOR_END ;
6168: }
6169: } ;
6170:
6171: struct StartIteratorInferModel : IteratorInferModel {
6172: virtual ValueFlow :: Value :: ValueType getType ( ) const override {
6173: return ValueFlow ::@expr1073762651 Value ::@expr1073762652 ValueType ::@expr1073762653 ITERATOR_END ;
6174: }
6175: } ;
6176:
6177: static void valueFlowInferCondition ( TokenList * tokenlist@var4454 ,
6178: const Settings * settings@var4455 )
6179: {
6180: for (@expr1073762655 Token *@expr1073762656 tok@var4456 =@expr1073762657 tokenlist@var4454 .@expr1073762658 front (@expr1073762659 ) ; tok@var4456 ; tok@var4456 =@expr1073762660 tok@var4456 .@expr1073762661 next (@expr1073762662 ) ) {
6181: if (@expr1073762663 !@expr1073762664 tok@var4456 .@expr20841 astParent (@expr20842 ) ) {
6182: continue ; }
6183: if (@expr1073762667 tok@var4456 .@expr1073762668 hasKnownIntValue (@expr1073762669 ) ) {
6184: continue ; }
6185: if (@expr1073762670 tok@var4456 .@expr1073762671 variable (@expr1073762672 ) &&@expr1073762673 (@expr1073762674 Token ::@expr20851 Match (@expr1073762676 tok@var4456 .@expr20841 astParent (@expr20842 ) , "?|&&|!|%oror%" ) ||@expr1073762679
6186: Token ::@expr20851 Match (@expr1073762681 tok@var4456 .@expr20841 astParent (@expr20842 ) .@expr1073762684 previous (@expr1073762685 ) , "if|while (" ) ) ) {
6187: std ::@expr1073762686 vector < ValueFlow ::@expr20863 Value > result@var4457 ; result@var4457 =@expr1073762688 infer (@expr1073762689 IntegralInferModel {@expr1073762690 } , "!=" , tok@var4456 .@expr1073762691 values (@expr1073762692 ) , 0 ) ;
6188: if (@expr1073762693 result@var4457 .@expr1073762694 size (@expr1073762695 ) !=@expr1073762696 1 ) {
6189: continue ; }
6190: ValueFlow ::@expr1073762697 Value value@var4458 ; value@var4458 =@expr1073762698 result@var4457 .@expr1073762699 front (@expr1073762700 ) ;
6191: value@var4458 .@expr1073762701 intvalue@var4459 =@expr1073762702 1 ;
6192: value@var4458 .@expr1073762703 bound@var4460 =@expr1073762704 ValueFlow ::@expr20881 Value ::@expr1073762706 Bound ::@expr1073762707 Point@expr1073762654 ;
6193: setTokenValue (@expr1073762708 tok@var4456 , value@var4458 , settings@var4455 ) ;
6194: } else { if (@expr1073762709 Token ::@expr20851 Match (@expr1073762711 tok@var4456 , "%comp%|-" ) &&@expr1073762712 tok@var4456 .@expr20889 astOperand1 (@expr20890 ) &&@expr1073762715 tok@var4456 .@expr20892 astOperand2 (@expr20893 ) ) {
6195: if (@expr1073762718 astIsIterator (@expr1073762719 tok@var4456 .@expr20889 astOperand1 (@expr20890 ) ) ||@expr1073762722 astIsIterator (@expr1073762723 tok@var4456 .@expr20892 astOperand2 (@expr20893 ) ) ) {
6196: static const std ::@expr1073762726 array < ValuePtr<InferModel> , 2 > iteratorModels@var4461 =@expr1073762727 {@expr1073762728 EndIteratorInferModel {@expr1073762729 } ,
6197: StartIteratorInferModel {@expr1073762730 } } ;
6198: for (@expr1073762731 const ValuePtr<InferModel> &@expr20908 model@var4462 :@expr1073762733 iteratorModels@var4461 ) {
6199: std ::@expr1073762734 vector < ValueFlow ::@expr20863 Value > result@var4463 ; result@var4463 =@expr1073762736
6200: infer (@expr1073762737 model@var4462 , tok@var4456 .@expr20914 str (@expr20915 ) , tok@var4456 .@expr20889 astOperand1 (@expr20890 ) .@expr20918 values (@expr20919 ) , tok@var4456 .@expr20892 astOperand2 (@expr20893 ) .@expr20922 values (@expr20923 ) ) ;
6201: for (@expr1073762748 ValueFlow ::@expr20863 Value value@var4464 :@expr1073762750 result@var4463 ) {
6202: value@var4464 .@expr1073762751 valueType@var4465 =@expr1073762752 ValueFlow ::@expr20881 Value ::@expr1073762754 ValueType ::@expr1073762755 INT ;
6203: setTokenValue (@expr1073762756 tok@var4456 , value@var4464 , settings@var4455 ) ;
6204: }
6205: }
6206: } else {
6207: std ::@expr1073762757 vector < ValueFlow ::@expr20863 Value > result@var4466 ; result@var4466 =@expr1073762759
6208: infer (@expr1073762760 IntegralInferModel {@expr1073762761 } , tok@var4456 .@expr20914 str (@expr20915 ) , tok@var4456 .@expr20889 astOperand1 (@expr20890 ) .@expr20918 values (@expr20919 ) , tok@var4456 .@expr20892 astOperand2 (@expr20893 ) .@expr20922 values (@expr20923 ) ) ;
6209: for (@expr1073762772 const ValueFlow ::@expr20863 Value &@expr20908 value@var4467 :@expr1073762775 result@var4466 ) {
6210: setTokenValue (@expr1073762776 tok@var4456 , value@var4467 , settings@var4455 ) ;
6211: }
6212: }
6213: } }
6214: }
6215: }
6216:
6217: struct SymbolicConditionHandler : SimpleConditionHandler {
6218:
6219: static bool isNegatedBool ( const Token * tok@var4468 )
6220: {
6221: if (@expr1073762777 !@expr1073762778 Token ::@expr1073762779 simpleMatch (@expr1073762780 tok@var4468 , "!" ) ) {
6222: return false ; }
6223: return (@expr1073762781 astIsBool (@expr1073762782 tok@var4468 .@expr1073762783 astOperand1 (@expr1073762784 ) ) ) ;
6224: }
6225:
6226: static const Token * skipNot ( const Token * tok@var4469 )
6227: {
6228: if (@expr1073762785 !@expr1073762786 Token ::@expr1073762787 simpleMatch (@expr1073762788 tok@var4469 , "!" ) ) {
6229: return tok@var4469 ; }
6230: return tok@var4469 .@expr1073762789 astOperand1 (@expr1073762790 ) ;
6231: }
6232:
6233: virtual std :: vector < Condition > parse ( const Token * tok@var4470 , const Settings * settings@var4471 ) const override
6234: {
6235: if (@expr1073762791 !@expr1073762792 Token ::@expr20969 Match (@expr1073762794 tok@var4470 , "%comp%" ) ) {
6236: return { } ; }
6237: if (@expr1073762795 tok@var4470 .@expr1073762796 hasKnownIntValue (@expr1073762797 ) ) {
6238: return { } ; }
6239: if (@expr1073762798 !@expr1073762799 tok@var4470 .@expr20976 astOperand1 (@expr20977 ) ||@expr1073762802 tok@var4470 .@expr20976 astOperand1 (@expr20977 ) .@expr1073762805 hasKnownIntValue (@expr1073762806 ) ||@expr1073762807 tok@var4470 .@expr20976 astOperand1 (@expr20977 ) .@expr1073762810 isLiteral (@expr1073762811 ) ) {
6240: return { } ; }
6241: if (@expr1073762812 !@expr1073762813 tok@var4470 .@expr20990 astOperand2 (@expr20991 ) ||@expr1073762816 tok@var4470 .@expr20990 astOperand2 (@expr20991 ) .@expr1073762819 hasKnownIntValue (@expr1073762820 ) ||@expr1073762821 tok@var4470 .@expr20990 astOperand2 (@expr20991 ) .@expr1073762824 isLiteral (@expr1073762825 ) ) {
6242: return { } ; }
6243: if (@expr1073762826 !@expr1073762827 isConstExpression (@expr1073762828 tok@var4470 , settings@var4471 .@expr1073762829 library@var4472 , true , true ) ) {
6244: return { } ; }
6245:
6246: std ::@expr1073762830 vector < Condition > result@var4473 ;
6247: auto addCond@var4474 ; addCond@var4474 =@expr1073762831 [@expr1073762832 &@expr1073762833 ] (@expr1073762834 const Token *@expr21011 lhsTok@var4475 , const Token *@expr21011 rhsTok@var4476 , bool inverted@var4477 ) {
6248: for (@expr1073762837 int i@var4478 =@expr1073762838 0 ; i@var4478 <@expr1073762839 2 ; i@var4478 ++@expr1073762840 ) {
6249: const bool lhs@var4479 =@expr1073762841 i@var4478 ==@expr1073762842 0 ;
6250: const Token * vartok@var4480 ; vartok@var4480 =@expr1073762843 lhs@var4479 ?@expr1073762844 lhsTok@var4475 :@expr1073762845 rhsTok@var4476 ;
6251: const Token * valuetok@var4481 ; valuetok@var4481 =@expr1073762846 lhs@var4479 ?@expr1073762847 rhsTok@var4476 :@expr1073762848 lhsTok@var4475 ;
6252: if (@expr1073762849 valuetok@var4481 .@expr1073762850 exprId (@expr1073762851 ) ==@expr1073762852 0 ) {
6253: continue ; }
6254: if (@expr1073762853 valuetok@var4481 .@expr1073762854 hasKnownSymbolicValue (@expr1073762855 vartok@var4480 ) ) {
6255: continue ; }
6256: if (@expr1073762856 vartok@var4480 .@expr1073762857 hasKnownSymbolicValue (@expr1073762858 valuetok@var4481 ) ) {
6257: continue ; }
6258: ValueFlow ::@expr1073762859 Value true_value@var4482 ;
6259: ValueFlow ::@expr1073762860 Value false_value@var4483 ;
6260: setConditionalValues (@expr1073762861 tok@var4470 , !@expr1073762862 lhs@var4479 , 0 , true_value@var4482 , false_value@var4483 ) ;
6261: setSymbolic (@expr1073762863 true_value@var4482 , valuetok@var4481 ) ;
6262: setSymbolic (@expr1073762864 false_value@var4483 , valuetok@var4481 ) ;
6263:
6264: Condition cond@var4484 ;
6265: cond@var4484 .@expr1073762865 true_values@var4485 =@expr1073762866 {@expr1073762867 true_value@var4482 } ;
6266: cond@var4484 .@expr1073762868 false_values@var4486 =@expr1073762869 {@expr1073762870 false_value@var4483 } ;
6267: cond@var4484 .@expr1073762871 vartok@var4487 =@expr1073762872 vartok@var4480 ;
6268: cond@var4484 .@expr1073762873 inverted@var4488 =@expr1073762874 inverted@var4477 ;
6269: result@var4473 .@expr1073762875 push_back (@expr1073762876 cond@var4484 ) ;
6270: }
6271: } ;
6272: addCond@var4474 (@expr1073762877 tok@var4470 .@expr20976 astOperand1 (@expr20977 ) , tok@var4470 .@expr20990 astOperand2 (@expr20991 ) , false ) ;
6273: if (@expr1073762882 Token ::@expr20969 Match (@expr1073762884 tok@var4470 , "==|!=" ) &&@expr1073762885 (@expr1073762886 isNegatedBool (@expr21063 tok@var4470 .@expr20976 astOperand1 (@expr20977 ) ) ||@expr1073762890 isNegatedBool (@expr21067 tok@var4470 .@expr20990 astOperand2 (@expr20991 ) ) ) ) {
6274: const Token * lhsTok@var4489 ; lhsTok@var4489 =@expr1073762894 skipNot (@expr1073762895 tok@var4470 .@expr20976 astOperand1 (@expr20977 ) ) ;
6275: const Token * rhsTok@var4490 ; rhsTok@var4490 =@expr1073762898 skipNot (@expr1073762899 tok@var4470 .@expr20990 astOperand2 (@expr20991 ) ) ;
6276: addCond@var4474 (@expr1073762902 lhsTok@var4489 , rhsTok@var4490 , !@expr1073762903 (@expr1073762904 isNegatedBool (@expr21063 tok@var4470 .@expr20976 astOperand1 (@expr20977 ) ) &&@expr1073762908 isNegatedBool (@expr21067 tok@var4470 .@expr20990 astOperand2 (@expr20991 ) ) ) ) ;
6277: }
6278: return result@var4473 ;
6279: }
6280: } ;
6281:
6282: static bool valueFlowForLoop2 ( const Token * tok@var4491 ,
6283: ProgramMemory * memory1@var4492 ,
6284: ProgramMemory * memory2@var4493 ,
6285: ProgramMemory * memoryAfter@var4494 )
6286: {
6287:
6288: const Token * firstExpression@var4495 ; firstExpression@var4495 =@expr1073762912 tok@var4491 .@expr21089 next (@expr21090 ) .@expr21091 astOperand2 (@expr21092 ) .@expr1073762917 astOperand1 (@expr1073762918 ) ;
6289: const Token * secondExpression@var4496 ; secondExpression@var4496 =@expr1073762919 tok@var4491 .@expr21089 next (@expr21090 ) .@expr21091 astOperand2 (@expr21092 ) .@expr21100 astOperand2 (@expr21101 ) .@expr1073762926 astOperand1 (@expr1073762927 ) ;
6290: const Token * thirdExpression@var4497 ; thirdExpression@var4497 =@expr1073762928 tok@var4491 .@expr21089 next (@expr21090 ) .@expr21091 astOperand2 (@expr21092 ) .@expr21100 astOperand2 (@expr21101 ) .@expr1073762935 astOperand2 (@expr1073762936 ) ;
6291:
6292: ProgramMemory programMemory@var4498 ;
6293: long long result@var4499 ; result@var4499 =@expr1073762937 0 ;
6294: bool error@var4500 ; error@var4500 =@expr1073762938 false ;
6295: execute (@expr1073762939 firstExpression@var4495 , &@expr21116 programMemory@var4498 , &@expr21117 result@var4499 , &@expr21118 error@var4500 ) ;
6296: if (@expr21119 error@var4500 ) {
6297: return false ; }
6298: execute (@expr21120 secondExpression@var4496 , &@expr21116 programMemory@var4498 , &@expr21117 result@var4499 , &@expr21118 error@var4500 ) ;
6299: if (@expr1073762948 result@var4499 ==@expr1073762949 0 ) {
6300: return false ; }
6301: if (@expr21119 error@var4500 ) {
6302:
6303: bool reassign@var4501 ; reassign@var4501 =@expr1073762951 false ;
6304: visitAstNodes (@expr1073762952 secondExpression@var4496 ,
6305: [@expr1073762953 &@expr1073762954 ] (@expr1073762955 const Token *@expr1073762956 t@var4502 ) {
6306: if (@expr1073762957 t@var4502 .@expr1073762958 str (@expr1073762959 ) ==@expr1073762960 "=" &&@expr1073762961 t@var4502 .@expr21138 astOperand1 (@expr21139 ) &&@expr1073762964 programMemory@var4498 .@expr1073762965 hasValue (@expr1073762966 t@var4502 .@expr21138 astOperand1 (@expr21139 ) .@expr1073762969 varId (@expr1073762970 ) ) ) {
6307:
6308: reassign@var4501 =@expr1073762971 true ; }
6309: return reassign@var4501 ?@expr1073762972 ChildrenToVisit ::@expr1073762973 done :@expr1073762974 ChildrenToVisit ::@expr1073762975 op1_and_op2 ;
6310: } ) ;
6311: if (@expr1073762976 reassign@var4501 ) {
6312: return false ; }
6313: }
6314:
6315: ProgramMemory startMemory@var4503 (@expr1073762977 programMemory@var4498 ) ;
6316: ProgramMemory endMemory@var4504 ;
6317:
6318: int maxcount@var4505 ; maxcount@var4505 =@expr1073762978 10000 ;
6319: while (@expr1073762979 result@var4499 !=@expr1073762980 0 &&@expr1073762981 !@expr21158 error@var4500 &&@expr1073762983 --@expr1073762984 maxcount@var4505 >@expr1073762985 0 ) {
6320: endMemory@var4504 =@expr1073762986 programMemory@var4498 ;
6321: execute (@expr1073762987 thirdExpression@var4497 , &@expr21116 programMemory@var4498 , &@expr21117 result@var4499 , &@expr21118 error@var4500 ) ;
6322: if (@expr21167 !@expr21158 error@var4500 ) {
6323: execute (@expr21120 secondExpression@var4496 , &@expr21116 programMemory@var4498 , &@expr21117 result@var4499 , &@expr21118 error@var4500 ) ; }
6324: }
6325:
6326: if (@expr1073762997 memory1@var4492 ) {
6327: memory1@var4492 .@expr1073762998 swap (@expr1073762999 startMemory@var4503 ) ; }
6328: if (@expr21167 !@expr21158 error@var4500 ) {
6329: if (@expr1073763002 memory2@var4493 ) {
6330: memory2@var4493 .@expr1073763003 swap (@expr1073763004 endMemory@var4504 ) ; }
6331: if (@expr1073763005 memoryAfter@var4494 ) {
6332: memoryAfter@var4494 .@expr1073763006 swap (@expr1073763007 programMemory@var4498 ) ; }
6333: }
6334:
6335: return true ;
6336: }
6337:
6338: static void valueFlowForLoopSimplify ( Token * const bodyStart@var4506 ,
6339: const Token * expr@var4507 ,
6340: bool globalvar@var4508 ,
6341: const long long value@var4509 ,
6342: TokenList * tokenlist@var4510 ,
6343: ErrorLogger * errorLogger@var4511 ,
6344: const Settings * settings@var4512 )
6345: {
6346:
6347: assert (@expr1073763008 expr@var4507 .@expr21185 varId (@expr21186 ) >@expr1073763011 0 ) ;
6348: const Token * const bodyEnd@var4513 ; bodyEnd@var4513 =@expr1073763012 bodyStart@var4506 .@expr1073763013 link (@expr1073763014 ) ;
6349:
6350:
6351: if (@expr1073763015 isVariableChanged (@expr1073763016 bodyStart@var4506 , bodyEnd@var4513 , expr@var4507 .@expr21185 varId (@expr21186 ) , globalvar@var4508 , settings@var4512 , tokenlist@var4510 .@expr1073763019 isCPP (@expr1073763020 ) ) ) {
6352: return ; }
6353:
6354: for (@expr1073763021 Token *@expr1073763022 tok2@var4514 =@expr1073763023 bodyStart@var4506 .@expr1073763024 next (@expr1073763025 ) ; tok2@var4514 !=@expr1073763026 bodyEnd@var4513 ; tok2@var4514 =@expr1073763027 tok2@var4514 .@expr21204 next (@expr21205 ) ) {
6355: if (@expr1073763030 tok2@var4514 .@expr21207 varId (@expr21208 ) ==@expr1073763033 expr@var4507 .@expr21185 varId (@expr21186 ) ) {
6356: const Token * parent@var4515 ; parent@var4515 =@expr1073763036 tok2@var4514 .@expr1073763037 astParent (@expr1073763038 ) ;
6357: while (@expr1073763039 parent@var4515 ) {
6358: const Token * const p@var4516 ; p@var4516 =@expr1073763040 parent@var4515 ;
6359: parent@var4515 =@expr1073763041 parent@var4515 .@expr1073763042 astParent (@expr1073763043 ) ;
6360: if (@expr1073763044 !@expr1073763045 parent@var4515 ||@expr1073763046 parent@var4515 .@expr21223 str (@expr21224 ) ==@expr1073763049 ":" ) {
6361: break ; }
6362: if (@expr1073763050 parent@var4515 .@expr21223 str (@expr21224 ) ==@expr1073763053 "?" ) {
6363: if (@expr1073763054 parent@var4515 .@expr1073763055 astOperand2 (@expr1073763056 ) !=@expr1073763057 p@var4516 ) {
6364: parent@var4515 =@expr1073763058 nullptr ; }
6365: break ;
6366: }
6367: }
6368: if (@expr1073763059 parent@var4515 ) {
6369: if (@expr21236 settings@var4512 .@expr21237 debugwarnings@var4517 ) {
6370: $bailoutInternal $(@expr1073763062 $"valueFlowBailout" $, tokenlist@var4510 $, errorLogger@var4511 $, tok2@var4514 $, "For loop variable " +@expr1073763063 tok2@var4514 .@expr21240 str (@expr21241 ) +@expr1073763066 " stopping on ?" $, "cppcheck-2.8/lib/valueflow.cpp" $, 6370 $, $__func__ $) ; }
6371: continue ;
6372: }
6373:
6374: ValueFlow ::@expr1073763067 Value value1@var4518 (@expr1073763068 value@var4509 ) ;
6375: value1@var4518 .@expr1073763069 varId@var4519 =@expr1073763070 tok2@var4514 .@expr21207 varId (@expr21208 ) ;
6376: setTokenValue (@expr1073763073 tok2@var4514 , value1@var4518 , settings@var4512 ) ;
6377: }
6378:
6379: if (@expr1073763074 Token ::@expr1073763075 Match (@expr1073763076 tok2@var4514 , "%oror%|&&" ) ) {
6380: const ProgramMemory programMemory@var4520 (@expr1073763077 getProgramMemory (@expr21254 tok2@var4514 .@expr21255 astTop (@expr21256 ) , expr@var4507 , ValueFlow ::@expr21257 Value (@expr21258 value@var4509 ) , settings@var4512 ) ) ;
6381: if (@expr1073763083 (@expr1073763084 tok2@var4514 .@expr21240 str (@expr21241 ) ==@expr21263 "&&" &&@expr1073763088 !@expr1073763089 conditionIsTrue (@expr1073763090 tok2@var4514 .@expr21267 astOperand1 (@expr21268 ) , programMemory@var4520 ) ) ||@expr1073763093
6382: (@expr1073763094 tok2@var4514 .@expr21240 str (@expr21241 ) ==@expr21273 "||" &&@expr1073763098 !@expr1073763099 conditionIsFalse (@expr1073763100 tok2@var4514 .@expr21267 astOperand1 (@expr21268 ) , programMemory@var4520 ) ) ) {
6383:
6384: const Token * parent@var4521 ; parent@var4521 =@expr1073763103 tok2@var4514 ;
6385: while (@expr1073763104 parent@var4521 &&@expr1073763105 parent@var4521 .@expr21282 str (@expr21283 ) ==@expr1073763108 tok2@var4514 .@expr21240 str (@expr21241 ) ) {
6386: parent@var4521 =@expr1073763111 parent@var4521 .@expr1073763112 astParent (@expr1073763113 ) ; }
6387:
6388: if (@expr1073763114 parent@var4521 &&@expr1073763115 parent@var4521 .@expr21282 str (@expr21283 ) ==@expr1073763118 "(" ) {
6389: tok2@var4514 =@expr1073763119 parent@var4521 .@expr1073763120 link (@expr1073763121 ) ;
6390:
6391: if (@expr1073763122 Token ::@expr21299 simpleMatch (@expr1073763124 tok2@var4514 , ") (" ) ) {
6392: tok2@var4514 =@expr1073763125 tok2@var4514 .@expr21302 linkAt (@expr21303 1 ) ; }
6393: }
6394: }
6395:
6396: }
6397: const Token * vartok@var4522 ; vartok@var4522 =@expr1073763128 expr@var4507 ;
6398: const Token * rml@var4523 ; rml@var4523 =@expr1073763129 nextAfterAstRightmostLeaf (@expr1073763130 vartok@var4522 ) ;
6399: if (@expr1073763131 rml@var4523 ) {
6400: vartok@var4522 =@expr1073763132 rml@var4523 .@expr1073763133 str (@expr1073763134 ) ==@expr1073763135 "]" ?@expr1073763136 rml@var4523 :@expr1073763137 rml@var4523 .@expr1073763138 previous (@expr1073763139 ) ; }
6401: if (@expr1073763140 vartok@var4522 .@expr1073763141 str (@expr1073763142 ) ==@expr1073763143 "]" &&@expr1073763144 vartok@var4522 .@expr21321 link (@expr21322 ) .@expr21323 previous (@expr21324 ) ) {
6402: vartok@var4522 =@expr1073763149 vartok@var4522 .@expr21321 link (@expr21322 ) .@expr21323 previous (@expr21324 ) ; }
6403:
6404: if (@expr1073763154 (@expr1073763155 tok2@var4514 .@expr21240 str (@expr21241 ) ==@expr21263 "&&" &&@expr1073763159
6405: conditionIsFalse (@expr1073763160 tok2@var4514 .@expr21267 astOperand1 (@expr21268 ) ,
6406: getProgramMemory (@expr21254 tok2@var4514 .@expr21255 astTop (@expr21256 ) , expr@var4507 , ValueFlow ::@expr21257 Value (@expr21258 value@var4509 ) , settings@var4512 ) ) ) ||@expr1073763168
6407: (@expr1073763169 tok2@var4514 .@expr21240 str (@expr21241 ) ==@expr21273 "||" &&@expr1073763173
6408: conditionIsTrue (@expr1073763174 tok2@var4514 .@expr21267 astOperand1 (@expr21268 ) ,
6409: getProgramMemory (@expr21254 tok2@var4514 .@expr21255 astTop (@expr21256 ) , expr@var4507 , ValueFlow ::@expr21257 Value (@expr21258 value@var4509 ) , settings@var4512 ) ) ) ) {
6410: break ; }
6411:
6412: else { if (@expr1073763182 Token ::@expr21299 simpleMatch (@expr1073763184 tok2@var4514 , ") {" ) ) {
6413: if (@expr1073763185 vartok@var4522 .@expr21362 varId (@expr21363 ) &&@expr1073763188 Token ::@expr21365 findmatch (@expr1073763190 tok2@var4514 .@expr1073763191 link (@expr1073763192 ) , "%varid%" , tok2@var4514 , vartok@var4522 .@expr21362 varId (@expr21363 ) ) ) {
6414: if (@expr1073763195 Token ::@expr21365 findmatch (@expr1073763197 tok2@var4514 , "continue|break|return" , tok2@var4514 .@expr21302 linkAt (@expr21303 1 ) , vartok@var4522 .@expr21362 varId (@expr21363 ) ) ) {
6415: if (@expr21236 settings@var4512 .@expr21237 debugwarnings@var4517 ) {
6416: $bailoutInternal $(@expr1073763204 $"valueFlowBailout" $, tokenlist@var4510 $, errorLogger@var4511 $, tok2@var4514 $, "For loop variable bailout on conditional continue|break|return" $, "cppcheck-2.8/lib/valueflow.cpp" $, 6416 $, $__func__ $) ; }
6417: break ;
6418: }
6419: if (@expr21236 settings@var4512 .@expr21237 debugwarnings@var4517 ) {
6420: $bailoutInternal $(@expr1073763207 $"valueFlowBailout" $, tokenlist@var4510 $, errorLogger@var4511 $, tok2@var4514 $, "For loop variable skipping conditional scope" $, "cppcheck-2.8/lib/valueflow.cpp" $, 6420 $, $__func__ $) ; }
6421: tok2@var4514 =@expr1073763208 tok2@var4514 .@expr21204 next (@expr21205 ) .@expr1073763211 link (@expr1073763212 ) ;
6422: if (@expr21389 Token ::@expr21299 simpleMatch (@expr21391 tok2@var4514 , "} else {" ) ) {
6423: if (@expr1073763216 Token ::@expr21365 findmatch (@expr1073763218 tok2@var4514 , "continue|break|return" , tok2@var4514 .@expr21302 linkAt (@expr21396 2 ) , vartok@var4522 .@expr21362 varId (@expr21363 ) ) ) {
6424: if (@expr21236 settings@var4512 .@expr21237 debugwarnings@var4517 ) {
6425: $bailoutInternal $(@expr1073763225 $"valueFlowBailout" $, tokenlist@var4510 $, errorLogger@var4511 $, tok2@var4514 $, "For loop variable bailout on conditional continue|break|return" $, "cppcheck-2.8/lib/valueflow.cpp" $, 6425 $, $__func__ $) ; }
6426: break ;
6427: }
6428: tok2@var4514 =@expr1073763226 tok2@var4514 .@expr21302 linkAt (@expr21396 2 ) ;
6429: }
6430: }
6431: else {
6432: if (@expr21236 settings@var4512 .@expr21237 debugwarnings@var4517 ) {
6433: $bailoutInternal $(@expr1073763231 $"valueFlowBailout" $, tokenlist@var4510 $, errorLogger@var4511 $, tok2@var4514 $, "For loop skipping {} code" $, "cppcheck-2.8/lib/valueflow.cpp" $, 6433 $, $__func__ $) ; }
6434: tok2@var4514 =@expr1073763232 tok2@var4514 .@expr21302 linkAt (@expr21303 1 ) ;
6435: if (@expr21389 Token ::@expr21299 simpleMatch (@expr21391 tok2@var4514 , "} else {" ) ) {
6436: tok2@var4514 =@expr1073763238 tok2@var4514 .@expr21302 linkAt (@expr21396 2 ) ; }
6437: }
6438: } }
6439: }
6440: }
6441:
6442: static void valueFlowForLoopSimplifyAfter ( Token * fortok@var4524 ,
6443: int varid@var4525 ,
6444: const long long num@var4526 ,
6445: TokenList * tokenlist@var4527 ,
6446: const Settings * settings@var4528 )
6447: {
6448: const Token * vartok@var4529 ; vartok@var4529 =@expr1073763241 nullptr ;
6449: for (@expr1073763242 const Token *@expr1073763243 tok@var4530 =@expr1073763244 fortok@var4524 ; tok@var4530 ; tok@var4530 =@expr1073763245 tok@var4530 .@expr1073763246 next (@expr1073763247 ) ) {
6450: if (@expr1073763248 tok@var4530 .@expr1073763249 varId (@expr1073763250 ) ==@expr1073763251 varid@var4525 ) {
6451: vartok@var4529 =@expr1073763252 tok@var4530 ;
6452: break ;
6453: }
6454: }
6455: if (@expr1073763253 !@expr1073763254 vartok@var4529 ||@expr1073763255 !@expr1073763256 vartok@var4529 .@expr21433 variable (@expr21434 ) ) {
6456: return ; }
6457:
6458: const Variable * var@var4531 ; var@var4531 =@expr1073763259 vartok@var4529 .@expr21433 variable (@expr21434 ) ;
6459: const Token * endToken@var4532 ; endToken@var4532 =@expr1073763262 nullptr ;
6460: if (@expr1073763263 var@var4531 .@expr1073763264 isLocal (@expr1073763265 ) ) {
6461: endToken@var4532 =@expr1073763266 var@var4531 .@expr1073763267 scope (@expr1073763268 ) .@expr1073763269 bodyEnd@var5330 ; }
6462: else {
6463: endToken@var4532 =@expr1073763270 fortok@var4524 .@expr1073763271 scope (@expr1073763272 ) .@expr1073763273 bodyEnd@var5330 ; }
6464:
6465: Token * blockTok@var4533 ; blockTok@var4533 =@expr1073763274 fortok@var4524 .@expr1073763275 linkAt (@expr1073763276 1 ) .@expr1073763277 linkAt (@expr1073763278 1 ) ;
6466: std ::@expr1073763279 list < ValueFlow ::@expr1073763280 Value > values@var4534 ;
6467: values@var4534 .@expr1073763281 emplace_back (@expr1073763282 num@var4526 ) ;
6468: values@var4534 .@expr21459 back (@expr21460 ) .@expr1073763285 errorPath .@expr1073763286 emplace_back (@expr1073763287 fortok@var4524 , "After for loop, " +@expr1073763288 var@var4531 .@expr1073763289 name (@expr1073763290 ) +@expr1073763291 " has value " +@expr1073763292 values@var4534 .@expr21459 back (@expr21460 ) .@expr1073763295 infoString (@expr1073763296 ) ) ;
6469:
6470: if (@expr1073763297 blockTok@var4533 !=@expr1073763298 endToken@var4532 ) {
6471: valueFlowForward (@expr1073763299 blockTok@var4533 .@expr1073763300 next (@expr1073763301 ) , endToken@var4532 , vartok@var4529 , values@var4534 , tokenlist@var4527 , settings@var4528 ) ;
6472: }
6473: }
6474:
6475: static void valueFlowForLoop ( TokenList * tokenlist@var4535 , SymbolDatabase * symboldatabase@var4536 , ErrorLogger * errorLogger@var4537 , const Settings * settings@var4538 )
6476: {
6477: for (@expr1073763303 const Scope &@expr21480 scope@var4539 :@expr1073763305 symboldatabase@var4536 .@expr1073763306 scopeList@var4540 ) {
6478: if (@expr1073763307 scope@var4539 .@expr1073763308 type@var4541 !=@expr1073763309 Scope ::@expr1073763310 eFor ) {
6479: continue ; }
6480:
6481: Token * tok@var4542 ; tok@var4542 =@expr1073763311 const_cast < Token *@expr21488 > (@expr1073763313 scope@var4539 .@expr1073763314 classDef@var4543 ) ;
6482: Token * const bodyStart@var4544 ; bodyStart@var4544 =@expr1073763315 const_cast < Token *@expr21488 > (@expr1073763317 scope@var4539 .@expr1073763318 bodyStart@var4545 ) ;
6483:
6484: if (@expr1073763319 !@expr1073763320 Token ::@expr21497 simpleMatch (@expr1073763322 tok@var4542 .@expr21499 next (@expr21500 ) .@expr21501 astOperand2 (@expr21502 ) , ";" ) ||@expr1073763327
6485: !@expr1073763328 Token ::@expr21497 simpleMatch (@expr1073763330 tok@var4542 .@expr21499 next (@expr21500 ) .@expr21501 astOperand2 (@expr21502 ) .@expr1073763335 astOperand2 (@expr1073763336 ) , ";" ) ) {
6486: continue ; }
6487:
6488: int varid@var4546 ;
6489: bool knownInitValue@var4547 ; bool partialCond@var4548 ;
6490: long long initValue@var4549 ; long long stepValue@var4550 ; long long lastValue@var4551 ;
6491:
6492: if (@expr1073763337 extractForLoopValues (@expr1073763338 tok@var4542 , &@expr1073763339 varid@var4546 , &@expr1073763340 knownInitValue@var4547 , &@expr1073763341 initValue@var4549 , &@expr1073763342 partialCond@var4548 , &@expr1073763343 stepValue@var4550 , &@expr1073763344 lastValue@var4551 ) ) {
6493: const bool executeBody@var4552 =@expr1073763345 !@expr1073763346 knownInitValue@var4547 ||@expr1073763347 initValue@var4549 <=@expr1073763348 lastValue@var4551 ;
6494: const Token * vartok@var4553 ; vartok@var4553 =@expr1073763349 Token ::@expr1073763350 findmatch (@expr1073763351 tok@var4542 , "%varid%" , bodyStart@var4544 , varid@var4546 ) ;
6495: if (@expr1073763352 executeBody@var4552 &&@expr1073763353 vartok@var4553 ) {
6496: std ::@expr1073763354 list < ValueFlow ::@expr21531 Value > initValues@var4554 ;
6497: initValues@var4554 .@expr1073763356 emplace_back (@expr1073763357 initValue@var4549 , ValueFlow ::@expr21534 Value ::@expr21535 Bound ::@expr1073763360 Lower ) ;
6498: initValues@var4554 .@expr1073763361 push_back (@expr1073763362 asImpossible (@expr1073763363 initValues@var4554 .@expr1073763364 back (@expr1073763365 ) ) ) ;
6499: Analyzer ::@expr1073763366 Result result@var4555 ; result@var4555 =@expr1073763367
6500: valueFlowForward (@expr1073763368 bodyStart@var4544 , bodyStart@var4544 .@expr21545 link (@expr21546 ) , vartok@var4553 , initValues@var4554 , tokenlist@var4535 , settings@var4538 ) ;
6501:
6502: if (@expr1073763371 !@expr1073763372 result@var4555 .@expr1073763373 action@var4556 .@expr1073763374 isModified (@expr1073763375 ) ) {
6503: std ::@expr1073763376 list < ValueFlow ::@expr21531 Value > lastValues@var4557 ;
6504: lastValues@var4557 .@expr1073763378 emplace_back (@expr1073763379 lastValue@var4551 , ValueFlow ::@expr21534 Value ::@expr21535 Bound ::@expr1073763382 Upper ) ;
6505: lastValues@var4557 .@expr21559 back (@expr21560 ) .@expr1073763385 conditional@expr1073763302 =@expr1073763386 true ;
6506: lastValues@var4557 .@expr1073763387 push_back (@expr1073763388 asImpossible (@expr1073763389 lastValues@var4557 .@expr21559 back (@expr21560 ) ) ) ;
6507: if (@expr1073763392 stepValue@var4550 !=@expr1073763393 1 ) {
6508: lastValues@var4557 .@expr1073763394 pop_front (@expr1073763395 ) ; }
6509: valueFlowForward (@expr1073763396 bodyStart@var4544 , bodyStart@var4544 .@expr21545 link (@expr21546 ) , vartok@var4553 , lastValues@var4557 , tokenlist@var4535 , settings@var4538 ) ;
6510: }
6511: }
6512: const long long afterValue@var4558 =@expr1073763399 executeBody@var4552 ?@expr1073763400 lastValue@var4551 +@expr1073763401 stepValue@var4550 :@expr1073763402 initValue@var4549 ;
6513: valueFlowForLoopSimplifyAfter (@expr1073763403 tok@var4542 , varid@var4546 , afterValue@var4558 , tokenlist@var4535 , settings@var4538 ) ;
6514: } else {
6515: ProgramMemory mem1@var4559 ; ProgramMemory mem2@var4560 ; ProgramMemory memAfter@var4561 ;
6516: if (@expr1073763404 valueFlowForLoop2 (@expr1073763405 tok@var4542 , &@expr1073763406 mem1@var4559 , &@expr1073763407 mem2@var4560 , &@expr1073763408 memAfter@var4561 ) ) {
6517: for (@expr1073763409 const auto &@expr21480 p@var4562 :@expr1073763411 mem1@var4559 ) {
6518: if (@expr1073763412 !@expr1073763413 p@var4562 .@expr21590 second@var4563 .@expr1073763415 isIntValue (@expr1073763416 ) ) {
6519: continue ; }
6520: if (@expr1073763417 p@var4562 .@expr21594 first@var4564 .@expr21595 tok@var4565 .@expr1073763420 varId (@expr1073763421 ) ==@expr1073763422 0 ) {
6521: continue ; }
6522: valueFlowForLoopSimplify (@expr1073763423 bodyStart@var4544 , p@var4562 .@expr21594 first@var4564 .@expr21595 tok@var4565 , false , p@var4562 .@expr21590 second@var4563 .@expr1073763427 intvalue@var4566 , tokenlist@var4535 , errorLogger@var4537 , settings@var4538 ) ;
6523: }
6524: for (@expr1073763428 const auto &@expr21480 p@var4567 :@expr1073763430 mem2@var4560 ) {
6525: if (@expr1073763431 !@expr1073763432 p@var4567 .@expr21609 second@var4568 .@expr1073763434 isIntValue (@expr1073763435 ) ) {
6526: continue ; }
6527: if (@expr1073763436 p@var4567 .@expr21613 first@var4569 .@expr21614 tok@var4570 .@expr1073763439 varId (@expr1073763440 ) ==@expr1073763441 0 ) {
6528: continue ; }
6529: valueFlowForLoopSimplify (@expr1073763442 bodyStart@var4544 , p@var4567 .@expr21613 first@var4569 .@expr21614 tok@var4570 , false , p@var4567 .@expr21609 second@var4568 .@expr1073763446 intvalue@var4571 , tokenlist@var4535 , errorLogger@var4537 , settings@var4538 ) ;
6530: }
6531: for (@expr1073763447 const auto &@expr21480 p@var4572 :@expr1073763449 memAfter@var4561 ) {
6532: if (@expr1073763450 !@expr1073763451 p@var4572 .@expr21628 second@var4573 .@expr1073763453 isIntValue (@expr1073763454 ) ) {
6533: continue ; }
6534: if (@expr1073763455 p@var4572 .@expr21632 first@var4574 .@expr1073763457 tok@var4575 .@expr1073763458 varId (@expr1073763459 ) ==@expr1073763460 0 ) {
6535: continue ; }
6536: valueFlowForLoopSimplifyAfter (@expr1073763461 tok@var4542 , p@var4572 .@expr21632 first@var4574 .@expr1073763463 getExpressionId (@expr1073763464 ) , p@var4572 .@expr21628 second@var4573 .@expr1073763466 intvalue@var4576 , tokenlist@var4535 , settings@var4538 ) ;
6537: }
6538: }
6539: }
6540: }
6541: }
6542:
6543: struct MultiValueFlowAnalyzer : ValueFlowAnalyzer {
6544: std :: unordered_map < int , ValueFlow :: Value > values@var4577 ;
6545: std :: unordered_map < int , const Variable * > vars@var4578 ;
6546: SymbolDatabase * symboldatabase@var4579 ;
6547:
6548: MultiValueFlowAnalyzer ( ) : ValueFlowAnalyzer ( ) , values@var4577 ( ) , vars@var4578 ( ) , symboldatabase@var4579 ( nullptr ) { }
6549:
6550: MultiValueFlowAnalyzer ( const std :: unordered_map < const Variable * , ValueFlow :: Value > & args@var4580 , const TokenList * t@var4581 , SymbolDatabase * s@var4582 )
6551: : ValueFlowAnalyzer ( t@var4581 ) , values@var4577 ( ) , vars@var4578 ( ) , symboldatabase@var4579 ( s@var4582 ) {
6552: for (@expr1073763467 const auto &@expr1073763468 p@var4583 :@expr1073763469 args@var4580 ) {
6553: values@var4577 [@expr1073763470 p@var4583 .@expr21647 first@var4584 .@expr21648 declarationId (@expr21649 ) ] =@expr1073763474 p@var4583 .@expr1073763475 second@var4585 ;
6554: vars@var4578 [@expr1073763476 p@var4583 .@expr21647 first@var4584 .@expr21648 declarationId (@expr21649 ) ] =@expr1073763480 p@var4583 .@expr21647 first@var4584 ;
6555: }
6556: }
6557:
6558: const virtual std :: unordered_map < int , const Variable * > & getVars ( ) const {
6559: return vars@var4578 ;
6560: }
6561:
6562: const virtual ValueFlow :: Value * getValue ( const Token * tok@var4586 ) const override {
6563: if (@expr1073763482 tok@var4586 .@expr21659 varId (@expr21660 ) ==@expr1073763485 0 ) {
6564: return nullptr ; }
6565: auto it@var4587 ; it@var4587 =@expr1073763486 values@var4577 .@expr1073763487 find (@expr1073763488 tok@var4586 .@expr21659 varId (@expr21660 ) ) ;
6566: if (@expr1073763491 it@var4587 ==@expr1073763492 values@var4577 .@expr1073763493 end (@expr1073763494 ) ) {
6567: return nullptr ; }
6568: return &@expr1073763495 it@var4587 .@expr1073763496 second@var4588 ;
6569: }
6570: virtual ValueFlow :: Value * getValue ( const Token * tok@var4589 ) override {
6571: if (@expr1073763497 tok@var4589 .@expr21674 varId (@expr21675 ) ==@expr1073763500 0 ) {
6572: return nullptr ; }
6573: auto it@var4590 ; it@var4590 =@expr1073763501 values@var4577 .@expr1073763502 find (@expr1073763503 tok@var4589 .@expr21674 varId (@expr21675 ) ) ;
6574: if (@expr1073763506 it@var4590 ==@expr1073763507 values@var4577 .@expr1073763508 end (@expr1073763509 ) ) {
6575: return nullptr ; }
6576: return &@expr1073763510 it@var4590 .@expr1073763511 second@var4591 ;
6577: }
6578:
6579: virtual void makeConditional ( ) override {
6580: for (@expr1073763512 auto && p@var4592 :@expr1073763513 values@var4577 ) {
6581: p@var4592 .@expr1073763514 second@var4593 .@expr1073763515 conditional@var4594 =@expr1073763516 true ;
6582: }
6583: }
6584:
6585: virtual void addErrorPath ( const Token * tok@var4595 , const std :: string & s@var4596 ) override {
6586: for (@expr1073763517 auto && p@var4597 :@expr1073763518 values@var4577 ) {
6587: p@var4597 .@expr1073763519 second@var4598 .@expr1073763520 errorPath@var4599 .@expr1073763521 emplace_back (@expr1073763522 tok@var4595 , "Assuming condition is " +@expr1073763523 s@var4596 ) ;
6588: }
6589: }
6590:
6591: virtual bool isAlias ( const Token * tok@var4600 , bool & inconclusive@var4601 ) const override {
6592: const auto range@var4602 =@expr1073763524 SelectValueFromVarIdMapRange (@expr1073763525 &@expr1073763526 values@var4577 ) ;
6593:
6594: for (@expr1073763527 const auto &@expr1073763528 p@var4603 :@expr1073763529 getVars (@expr1073763530 ) ) {
6595: int varid@var4604 ; varid@var4604 =@expr1073763531 p@var4603 .@expr1073763532 first@var4605 ;
6596: const Variable * var@var4606 ; var@var4606 =@expr1073763533 p@var4603 .@expr1073763534 second@var4607 ;
6597: if (@expr1073763535 tok@var4600 .@expr1073763536 varId (@expr1073763537 ) ==@expr1073763538 varid@var4604 ) {
6598: return true ; }
6599: if (@expr1073763539 isAliasOf (@expr1073763540 var@var4606 , tok@var4600 , varid@var4604 , range@var4602 , &@expr1073763541 inconclusive@var4601 ) ) {
6600: return true ; }
6601: }
6602: return false ;
6603: }
6604:
6605: virtual bool isGlobal ( ) const override {
6606: return false ;
6607: }
6608:
6609: virtual bool lowerToPossible ( ) override {
6610: for (@expr1073763542 auto && p@var4608 :@expr1073763543 values@var4577 ) {
6611: if (@expr1073763544 p@var4608 .@expr21721 second@var4609 .@expr1073763546 isImpossible (@expr1073763547 ) ) {
6612: return false ; }
6613: p@var4608 .@expr21721 second@var4609 .@expr1073763549 changeKnownToPossible (@expr1073763550 ) ;
6614: }
6615: return true ;
6616: }
6617: virtual bool lowerToInconclusive ( ) override {
6618: for (@expr1073763551 auto && p@var4610 :@expr1073763552 values@var4577 ) {
6619: if (@expr1073763553 p@var4610 .@expr21730 second@var4611 .@expr1073763555 isImpossible (@expr1073763556 ) ) {
6620: return false ; }
6621: p@var4610 .@expr21730 second@var4611 .@expr1073763558 setInconclusive (@expr1073763559 ) ;
6622: }
6623: return true ;
6624: }
6625:
6626: virtual bool isConditional ( ) const override {
6627: for (@expr1073763560 auto && p@var4612 :@expr1073763561 values@var4577 ) {
6628: if (@expr1073763562 p@var4612 .@expr21739 second@var4613 .@expr1073763564 conditional@var4614 ) {
6629: return true ; }
6630: if (@expr1073763565 p@var4612 .@expr21739 second@var4613 .@expr1073763567 condition@var4615 ) {
6631: return !@expr1073763568 p@var4612 .@expr21739 second@var4613 .@expr1073763570 isImpossible (@expr1073763571 ) ; }
6632: }
6633: return false ;
6634: }
6635:
6636: virtual bool stopOnCondition ( const Token * ) const override {
6637: return isConditional (@expr1073763572 ) ;
6638: }
6639:
6640: virtual bool updateScope ( const Token * endBlock@var4616 , bool ) const override {
6641: const Scope * scope@var4617 ; scope@var4617 =@expr1073763574 endBlock@var4616 .@expr1073763575 scope (@expr1073763576 ) ;
6642: if (@expr1073763577 !@expr1073763578 scope@var4617 ) {
6643: return false ; }
6644: if (@expr1073763579 scope@var4617 .@expr21756 type@var4618 ==@expr1073763581 Scope ::@expr1073763582 eLambda ) {
6645: for (@expr1073763583 const auto &@expr21760 p@var4619 :@expr1073763585 values@var4577 ) {
6646: if (@expr1073763586 !@expr1073763587 p@var4619 .@expr1073763588 second@var4620 .@expr1073763589 isLifetimeValue (@expr1073763590 ) ) {
6647: return false ; }
6648: }
6649: return true ;
6650: } else { if (@expr1073763591 scope@var4617 .@expr21756 type@var4618 ==@expr1073763593 Scope ::@expr1073763594 eIf ||@expr1073763595 scope@var4617 .@expr21756 type@var4618 ==@expr1073763597 Scope ::@expr1073763598 eElse ||@expr1073763599 scope@var4617 .@expr21756 type@var4618 ==@expr1073763601 Scope ::@expr1073763602 eWhile ||@expr1073763603
6651: scope@var4617 .@expr21756 type@var4618 ==@expr1073763605 Scope ::@expr1073763606 eFor ) {
6652: auto pred@var4621 ; pred@var4621 =@expr1073763607 [@expr1073763608 ] (@expr1073763609 const ValueFlow ::@expr1073763610 Value &@expr21760 value@var4622 ) {
6653: if (@expr1073763612 value@var4622 .@expr1073763613 isKnown (@expr1073763614 ) ) {
6654: return true ; }
6655: if (@expr1073763615 value@var4622 .@expr1073763616 isImpossible (@expr1073763617 ) ) {
6656: return true ; }
6657: if (@expr1073763618 value@var4622 .@expr1073763619 isLifetimeValue (@expr1073763620 ) ) {
6658: return true ; }
6659: return false ;
6660: } ;
6661: if (@expr1073763621 std ::@expr1073763622 all_of (@expr1073763623 values@var4577 .@expr1073763624 begin (@expr1073763625 ) , values@var4577 .@expr1073763626 end (@expr1073763627 ) , std ::@expr21804 bind (@expr1073763629 pred@var4621 , std ::@expr21804 bind (@expr1073763631 SelectMapValues {@expr1073763632 } , std ::@expr1073763633 placeholders ::@expr1073763634 _1@expr1073763573 ) ) ) ) {
6662: return true ; }
6663: if (@expr1073763635 isConditional (@expr1073763636 ) ) {
6664: return false ; }
6665: const Token * condTok@var4623 ; condTok@var4623 =@expr1073763637 getCondTokFromEnd (@expr1073763638 endBlock@var4616 ) ;
6666: std ::@expr1073763639 set < int > varids@var4624 ;
6667: std ::@expr1073763640 transform (@expr1073763641 getVars (@expr21818 ) .@expr1073763643 begin (@expr1073763644 ) , getVars (@expr21818 ) .@expr1073763646 end (@expr1073763647 ) , std ::@expr1073763648 inserter (@expr1073763649 varids@var4624 , varids@var4624 .@expr1073763650 begin (@expr1073763651 ) ) , SelectMapKeys {@expr1073763652 } ) ;
6668: return bifurcate (@expr1073763653 condTok@var4623 , varids@var4624 , getSettings (@expr1073763654 ) ) ;
6669: } }
6670:
6671: return false ;
6672: }
6673:
6674: virtual bool match ( const Token * tok@var4625 ) const override {
6675: return values@var4577 .@expr1073763655 count (@expr1073763656 tok@var4625 .@expr1073763657 varId (@expr1073763658 ) ) >@expr1073763659 0 ;
6676: }
6677:
6678: virtual std :: unordered_map < ExprIdToken , ValueFlow :: Value , ExprIdToken :: Hash > getProgramState ( ) const override {
6679: ProgramState ps@var4626 ;
6680: for (@expr1073763660 const auto &@expr1073763661 p@var4627 :@expr1073763662 values@var4577 ) {
6681: const Variable * var@var4628 ; var@var4628 =@expr1073763663 vars@var4578 .@expr1073763664 at (@expr1073763665 p@var4627 .@expr1073763666 first@var4629 ) ;
6682: if (@expr1073763667 !@expr1073763668 var@var4628 ) {
6683: continue ; }
6684: ps@var4626 [@expr1073763669 var@var4628 .@expr1073763670 nameToken (@expr1073763671 ) ] =@expr1073763672 p@var4627 .@expr1073763673 second@var4630 ;
6685: }
6686: return ps@var4626 ;
6687: }
6688:
6689: virtual void forkScope ( const Token * endBlock@var4631 ) override {
6690: ProgramMemory pm@var4632 {@expr1073763674 getProgramState (@expr1073763675 ) } ;
6691: const Scope * scope@var4633 ; scope@var4633 =@expr1073763676 endBlock@var4631 .@expr1073763677 scope (@expr1073763678 ) ;
6692: const Token * condTok@var4634 ; condTok@var4634 =@expr1073763679 getCondTokFromEnd (@expr1073763680 endBlock@var4631 ) ;
6693: if (@expr1073763681 scope@var4633 &&@expr1073763682 condTok@var4634 ) {
6694: programMemoryParseCondition (@expr1073763683 pm@var4632 , condTok@var4634 , nullptr , getSettings (@expr1073763684 ) , scope@var4633 .@expr1073763685 type@var4635 !=@expr1073763686 Scope ::@expr1073763687 eElse ) ; }
6695: if (@expr1073763688 condTok@var4634 &&@expr1073763689 Token ::@expr1073763690 simpleMatch (@expr1073763691 condTok@var4634 .@expr1073763692 astParent (@expr1073763693 ) , ";" ) ) {
6696: ProgramMemory endMemory@var4636 ;
6697: if (@expr1073763694 valueFlowForLoop2 (@expr1073763695 condTok@var4634 .@expr1073763696 astTop (@expr1073763697 ) .@expr1073763698 previous (@expr1073763699 ) , nullptr , &@expr1073763700 endMemory@var4636 , nullptr ) ) {
6698: pm@var4632 .@expr1073763701 replace (@expr1073763702 endMemory@var4636 ) ; }
6699: }
6700:
6701: for (@expr1073763703 const auto &@expr1073763704 p@var4637 :@expr1073763705 pm@var4632 ) {
6702: int varid@var4638 ; varid@var4638 =@expr1073763706 p@var4637 .@expr1073763707 first@var4639 .@expr1073763708 getExpressionId (@expr1073763709 ) ;
6703: if (@expr1073763710 symboldatabase@var4579 &&@expr1073763711 !@expr1073763712 symboldatabase@var4579 .@expr1073763713 isVarId (@expr1073763714 varid@var4638 ) ) {
6704: continue ; }
6705: ValueFlow ::@expr1073763715 Value value@var4640 ; value@var4640 =@expr1073763716 p@var4637 .@expr1073763717 second@var4641 ;
6706: if (@expr1073763718 vars@var4578 .@expr1073763719 count (@expr1073763720 varid@var4638 ) !=@expr1073763721 0 ) {
6707: continue ; }
6708: if (@expr1073763722 value@var4640 .@expr1073763723 isImpossible (@expr1073763724 ) ) {
6709: continue ; }
6710: value@var4640 .@expr1073763725 setPossible (@expr1073763726 ) ;
6711: values@var4577 [@expr1073763727 varid@var4638 ] =@expr1073763728 value@var4640 ;
6712: if (@expr1073763729 symboldatabase@var4579 ) {
6713: vars@var4578 [@expr1073763730 varid@var4638 ] =@expr1073763731 symboldatabase@var4579 .@expr1073763732 getVariableFromVarId (@expr1073763733 varid@var4638 ) ; }
6714: }
6715: }
6716: } ;
6717:
6718: template < class Key , class F >
6719: bool productParams ( const std :: unordered_map < Key , std :: list < ValueFlow :: Value > > & vars@var4642 , F f@var4643 )
6720: {
6721: using Args =@expr1073763735 std ::@expr1073763736 vector < std ::@expr21913 unordered_map < Key , ValueFlow ::@expr21913 Value > > ;
6722: Args args@var4644 (@expr1073763739 1 ) ;
6723:
6724: for (@expr1073763740 const auto &@expr21917 p@var4645 :@expr1073763742 vars@var4642 ) {
6725: if (@expr1073763743 p@var4645 .@expr21920 second@var4646 .@expr1073763745 empty (@expr1073763746 ) ) {
6726: continue ; }
6727: args@var4644 .@expr1073763747 back (@expr1073763748 ) [@expr1073763749 p@var4645 .@expr1073763750 first@var4647 ] =@expr1073763751 p@var4645 .@expr21920 second@var4646 .@expr1073763753 front (@expr1073763754 ) ;
6728: }
6729: for (@expr1073763755 const auto &@expr21917 p@var4648 :@expr1073763757 vars@var4642 ) {
6730: if (@expr1073763758 args@var4644 .@expr1073763759 size (@expr1073763760 ) >@expr1073763761 256 ) {
6731: return false ; }
6732: if (@expr1073763762 p@var4648 .@expr21939 second@var4649 .@expr1073763764 empty (@expr1073763765 ) ) {
6733: continue ; }
6734: std ::@expr1073763766 for_each (@expr1073763767 std ::@expr1073763768 next (@expr1073763769 p@var4648 .@expr21939 second@var4649 .@expr1073763771 begin (@expr1073763772 ) ) , p@var4648 .@expr21939 second@var4649 .@expr1073763774 end (@expr1073763775 ) , [@expr1073763776 &@expr21917 ] (@expr1073763778 const ValueFlow ::@expr21913 Value &@expr21917 value@var4650 ) {
6735: Args new_args@var4651 ;
6736: for (@expr1073763781 auto arg@var4652 :@expr1073763782 args@var4644 ) {
6737: if (@expr1073763783 value@var4650 .@expr21960 path@var4653 !=@expr1073763785 0 ) {
6738: for (@expr1073763786 const auto &@expr21917 q@var4654 :@expr1073763788 arg@var4652 ) {
6739: if (@expr1073763789 q@var4654 .@expr21966 second@var4655 .@expr21967 path@var4656 ==@expr1073763792 0 ) {
6740: continue ; }
6741: if (@expr1073763793 q@var4654 .@expr21966 second@var4655 .@expr21967 path@var4656 !=@expr1073763796 value@var4650 .@expr21960 path@var4653 ) {
6742: return ; }
6743: }
6744: }
6745: arg@var4652 [@expr1073763798 p@var4648 .@expr1073763799 first@var4657 ] =@expr1073763800 value@var4650 ;
6746: new_args@var4651 .@expr1073763801 push_back (@expr1073763802 arg@var4652 ) ;
6747: }
6748: std ::@expr1073763803 copy (@expr1073763804 new_args@var4651 .@expr1073763805 begin (@expr1073763806 ) , new_args@var4651 .@expr1073763807 end (@expr1073763808 ) , std ::@expr1073763809 back_inserter (@expr1073763810 args@var4644 ) ) ;
6749: } ) ;
6750: }
6751:
6752: for (@expr1073763811 const auto &@expr21917 arg@var4658 :@expr1073763813 args@var4644 ) {
6753: if (@expr1073763814 arg@var4658 .@expr1073763815 empty (@expr1073763816 ) ) {
6754: continue ; }
6755: bool skip@var4659 ; skip@var4659 =@expr1073763817 false ;
6756:
6757: long long path@var4660 ; path@var4660 =@expr1073763818 arg@var4658 .@expr1073763819 begin (@expr1073763820 ) .@expr1073763821 second .@expr1073763822 path@expr1073763734 ;
6758: for (@expr1073763823 const auto &@expr21917 p@var4661 :@expr1073763825 arg@var4658 ) {
6759: if (@expr1073763826 p@var4661 .@expr1073763827 second@var4662 .@expr1073763828 path@var4663 !=@expr1073763829 path@var4660 ) {
6760: skip@var4659 =@expr1073763830 true ;
6761: break ;
6762: }
6763: }
6764: if (@expr1073763831 skip@var4659 ) {
6765: continue ; }
6766: f@var4643 (@expr1073763832 arg@var4658 ) ;
6767: }
6768: return true ;
6769: }
6770:
6771: static void valueFlowInjectParameter ( TokenList * tokenlist@var4664 ,
6772: SymbolDatabase * symboldatabase@var4665 ,
6773: ErrorLogger * errorLogger@var4666 ,
6774: const Settings * settings@var4667 ,
6775: const Scope * functionScope@var4668 ,
6776: const std :: unordered_map < const Variable * , std :: list < ValueFlow :: Value > > & vars@var4669 )
6777: {
6778: bool r@var4670 ; r@var4670 =@expr1073763833 productParams (@expr1073763834 vars@var4669 , [@expr1073763835 &@expr22012 ] (@expr1073763837 const std ::@expr22014 unordered_map < const Variable *@expr22015 , ValueFlow ::@expr22014 Value > &@expr22012 arg@var4671 ) {
6779: MultiValueFlowAnalyzer a@var4672 (@expr1073763842 arg@var4671 , tokenlist@var4664 , symboldatabase@var4665 ) ;
6780: valueFlowGenericForward (@expr1073763843 const_cast < Token *@expr22015 > (@expr1073763845 functionScope@var4668 .@expr22022 bodyStart@var4673 ) , functionScope@var4668 .@expr1073763847 bodyEnd@var4674 , a@var4672 , settings@var4667 ) ;
6781: } ) ;
6782: if (@expr1073763848 !@expr1073763849 r@var4670 ) {
6783: std ::@expr1073763850 string fname@var4675 ; fname@var4675 =@expr1073763851 "<unknown>" ;
6784: Function * f@var4676 ; f@var4676 =@expr1073763852 functionScope@var4668 .@expr1073763853 function@var4677 ;
6785: if (@expr1073763854 f@var4676 ) {
6786: fname@var4675 =@expr1073763855 f@var4676 .@expr1073763856 name (@expr1073763857 ) ; }
6787: if (@expr1073763858 settings@var4667 .@expr1073763859 debugwarnings@var4678 ) {
6788: $bailoutInternal $(@expr1073763860 $"valueFlowBailout" $, tokenlist@var4664 $, errorLogger@var4666 $, functionScope@var4668 .@expr22022 bodyStart@var4673 $, "Too many argument passed to " +@expr1073763862 fname@var4675 $, "cppcheck-2.8/lib/valueflow.cpp" $, 6788 $, $__func__ $) ; }
6789: }
6790: }
6791:
6792: static void valueFlowInjectParameter ( TokenList * tokenlist@var4679 ,
6793: const Settings * settings@var4680 ,
6794: const Variable * arg@var4681 ,
6795: const Scope * functionScope@var4682 ,
6796: const std :: list < ValueFlow :: Value > & argvalues@var4683 )
6797: {
6798:
6799: if (@expr1073763863 arg@var4681 .@expr1073763864 isReference (@expr1073763865 ) &&@expr1073763866 !@expr1073763867 arg@var4681 .@expr1073763868 isConst (@expr1073763869 ) &&@expr1073763870 !@expr1073763871 arg@var4681 .@expr1073763872 isClass (@expr1073763873 ) ) {
6800: return ; }
6801:
6802:
6803: const int varid2@var4684 =@expr1073763874 arg@var4681 .@expr1073763875 declarationId (@expr1073763876 ) ;
6804: if (@expr1073763877 !@expr1073763878 varid2@var4684 ) {
6805: return ; }
6806:
6807: valueFlowForward (@expr1073763879 const_cast < Token *@expr1073763880 > (@expr1073763881 functionScope@var4682 .@expr1073763882 bodyStart@var4685 .@expr1073763883 next (@expr1073763884 ) ) ,
6808: functionScope@var4682 .@expr1073763885 bodyEnd@var4686 ,
6809: arg@var4681 .@expr1073763886 nameToken (@expr1073763887 ) ,
6810: argvalues@var4683 ,
6811: tokenlist@var4679 ,
6812: settings@var4680 ) ;
6813: }
6814:
6815: static void valueFlowSwitchVariable ( TokenList * tokenlist@var4687 , SymbolDatabase * symboldatabase@var4688 , ErrorLogger * errorLogger@var4689 , const Settings * settings@var4690 )
6816: {
6817: for (@expr1073763889 const Scope &@expr1073763890 scope@var4691 :@expr1073763891 symboldatabase@var4688 .@expr1073763892 scopeList@var4692 ) {
6818: if (@expr1073763893 scope@var4691 .@expr1073763894 type@var4693 !=@expr1073763895 Scope ::@expr1073763896 ScopeType ::@expr1073763897 eSwitch ) {
6819: continue ; }
6820: if (@expr1073763898 !@expr1073763899 Token ::@expr22076 Match (@expr1073763901 scope@var4691 .@expr22078 classDef@var4694 , "switch ( %var% ) {" ) ) {
6821: continue ; }
6822: const Token * vartok@var4695 ; vartok@var4695 =@expr1073763903 scope@var4691 .@expr22078 classDef@var4694 .@expr1073763905 tokAt (@expr1073763906 2 ) ;
6823: const Variable * var@var4696 ; var@var4696 =@expr1073763907 vartok@var4695 .@expr22084 variable (@expr22085 ) ;
6824: if (@expr1073763910 !@expr1073763911 var@var4696 ) {
6825: continue ; }
6826:
6827:
6828: if (@expr1073763912 !@expr1073763913 (@expr1073763914 var@var4696 .@expr1073763915 isLocal (@expr1073763916 ) ||@expr1073763917 var@var4696 .@expr1073763918 isArgument (@expr1073763919 ) ) &&@expr1073763920 !@expr1073763921 var@var4696 .@expr1073763922 isConst (@expr1073763923 ) ) {
6829: if (@expr1073763924 settings@var4690 .@expr1073763925 debugwarnings@var4697 ) {
6830: $bailoutInternal $(@expr1073763926 $"valueFlowBailout" $, tokenlist@var4687 $, errorLogger@var4689 $, vartok@var4695 $, "switch variable " +@expr1073763927 var@var4696 .@expr1073763928 name (@expr1073763929 ) +@expr1073763930 " is global" $, "cppcheck-2.8/lib/valueflow.cpp" $, 6830 $, $__func__ $) ; }
6831: continue ;
6832: }
6833:
6834: for (@expr1073763931 Token *@expr22108 tok@var4698 =@expr1073763933 scope@var4691 .@expr1073763934 bodyStart@var4699 .@expr1073763935 next (@expr1073763936 ) ; tok@var4698 !=@expr1073763937 scope@var4691 .@expr1073763938 bodyEnd@var4700 ; tok@var4698 =@expr1073763939 tok@var4698 .@expr22116 next (@expr22117 ) ) {
6835: if (@expr1073763942 tok@var4698 .@expr1073763943 str (@expr1073763944 ) ==@expr1073763945 "{" ) {
6836: tok@var4698 =@expr1073763946 tok@var4698 .@expr1073763947 link (@expr1073763948 ) ;
6837: continue ;
6838: }
6839: if (@expr1073763949 Token ::@expr22076 Match (@expr1073763951 tok@var4698 , "case %num% :" ) ) {
6840: std ::@expr1073763952 list < ValueFlow ::@expr22129 Value > values@var4701 ;
6841: values@var4701 .@expr22130 emplace_back (@expr22131 MathLib ::@expr22132 toLongNumber (@expr22133 tok@var4698 .@expr22116 next (@expr22117 ) .@expr22136 str (@expr22137 ) ) ) ;
6842: values@var4701 .@expr22138 back (@expr22139 ) .@expr22140 condition@expr22064 =@expr1073763965 tok@var4698 ;
6843: const std ::@expr1073763966 string info@var4702 (@expr1073763967 "case " +@expr22144 tok@var4698 .@expr22116 next (@expr22117 ) .@expr22136 str (@expr22137 ) +@expr22149 ": " +@expr22150 vartok@var4695 .@expr22151 str (@expr22152 ) +@expr22153 " is " +@expr22154 tok@var4698 .@expr22116 next (@expr22117 ) .@expr22136 str (@expr22137 ) +@expr22159 " here." ) ;
6844: values@var4701 .@expr22138 back (@expr22139 ) .@expr22162 errorPath .@expr22163 emplace_back (@expr1073763988 tok@var4698 , info@var4702 ) ;
6845: bool known@var4703 ; known@var4703 =@expr1073763989 false ;
6846: if (@expr1073763990 (@expr1073763991 Token ::@expr22168 simpleMatch (@expr1073763993 tok@var4698 .@expr1073763994 previous (@expr1073763995 ) , "{" ) ||@expr1073763996 Token ::@expr22168 simpleMatch (@expr1073763998 tok@var4698 .@expr22175 tokAt (@expr1073764000 -2 ) , "break ;" ) ) &&@expr1073764001 !@expr1073764002 Token ::@expr22076 Match (@expr1073764004 tok@var4698 .@expr22175 tokAt (@expr22182 3 ) , ";| case" ) ) {
6847: known@var4703 =@expr1073764007 true ; }
6848: while (@expr1073764008 Token ::@expr22076 Match (@expr1073764010 tok@var4698 .@expr22175 tokAt (@expr22182 3 ) , ";| case %num% :" ) ) {
6849: known@var4703 =@expr1073764013 false ;
6850: tok@var4698 =@expr1073764014 tok@var4698 .@expr22175 tokAt (@expr22182 3 ) ;
6851: if (@expr1073764017 !@expr1073764018 tok@var4698 .@expr1073764019 isName (@expr1073764020 ) ) {
6852: tok@var4698 =@expr1073764021 tok@var4698 .@expr22116 next (@expr22117 ) ; }
6853: values@var4701 .@expr22130 emplace_back (@expr22131 MathLib ::@expr22132 toLongNumber (@expr22133 tok@var4698 .@expr22116 next (@expr22117 ) .@expr22136 str (@expr22137 ) ) ) ;
6854: values@var4701 .@expr22138 back (@expr22139 ) .@expr22140 condition@expr22064 =@expr1073764035 tok@var4698 ;
6855: const std ::@expr1073764036 string info2@var4704 (@expr1073764037 "case " +@expr22144 tok@var4698 .@expr22116 next (@expr22117 ) .@expr22136 str (@expr22137 ) +@expr22149 ": " +@expr22150 vartok@var4695 .@expr22151 str (@expr22152 ) +@expr22153 " is " +@expr22154 tok@var4698 .@expr22116 next (@expr22117 ) .@expr22136 str (@expr22137 ) +@expr22159 " here." ) ;
6856: values@var4701 .@expr22138 back (@expr22139 ) .@expr22162 errorPath .@expr22163 emplace_back (@expr1073764058 tok@var4698 , info2@var4704 ) ;
6857: }
6858: for (@expr1073764059 std ::@expr22129 list < ValueFlow ::@expr22129 Value > ::@expr22129 const_iterator val@var4705 =@expr1073764063 values@var4701 .@expr1073764064 begin (@expr1073764065 ) ; val@var4705 !=@expr1073764066 values@var4701 .@expr1073764067 end (@expr1073764068 ) ; ++@expr1073764069 val@var4705 ) {
6859: valueFlowReverse (@expr1073764070 tokenlist@var4687 ,
6860: const_cast < Token *@expr22108 > (@expr1073764072 scope@var4691 .@expr22078 classDef@var4694 ) ,
6861: vartok@var4695 ,
6862: *@expr1073764074 val@var4705 ,
6863: ValueFlow ::@expr1073764075 Value (@expr1073764076 ) ,
6864: errorLogger@var4689 ,
6865: settings@var4690 ) ;
6866: }
6867: if (@expr1073764077 vartok@var4695 .@expr22084 variable (@expr22085 ) .@expr1073764080 scope (@expr1073764081 ) ) {
6868: if (@expr1073764082 known@var4703 ) {
6869: values@var4701 .@expr22138 back (@expr22139 ) .@expr1073764085 setKnown (@expr1073764086 ) ; }
6870:
|
6883:
6884: }
6885: }
6886: }
6887: }
6888: }
6889:
6890: static std :: list < ValueFlow :: Value > getFunctionArgumentValues ( const Token * argtok@var4706 )
6891: {
6892: std ::@expr1073764087 list < ValueFlow ::@expr1073764088 Value > argvalues@var4707 (@expr1073764089 argtok@var4706 .@expr1073764090 values (@expr1073764091 ) ) ;
6893: removeImpossible (@expr1073764092 argvalues@var4707 ) ;
6894: if (@expr1073764093 argvalues@var4707 .@expr1073764094 empty (@expr1073764095 ) &&@expr1073764096 Token ::@expr1073764097 Match (@expr1073764098 argtok@var4706 , "%comp%|%oror%|&&|!" ) ) {
6895: argvalues@var4707 .@expr22275 emplace_back (@expr1073764100 0 ) ;
6896: argvalues@var4707 .@expr22275 emplace_back (@expr1073764102 1 ) ;
6897: }
6898: return argvalues@var4707 ;
6899: }
6900:
6901: static void valueFlowLibraryFunction ( Token * tok@var4708 , const std :: string & returnValue@var4709 , const Settings * settings@var4710 )
6902: {
6903: std ::@expr1073764103 unordered_map < int , std ::@expr22280 list < ValueFlow ::@expr22280 Value > > argValues@var4711 ;
6904: int argn@var4712 ; argn@var4712 =@expr1073764106 1 ;
6905: for (@expr1073764107 const Token *@expr1073764108 argtok@var4713 :@expr1073764109 getArguments (@expr1073764110 tok@var4708 .@expr1073764111 previous (@expr1073764112 ) ) ) {
6906: argValues@var4711 [@expr1073764113 argn@var4712 ] =@expr1073764114 getFunctionArgumentValues (@expr1073764115 argtok@var4713 ) ;
6907: argn@var4712 ++@expr1073764116 ;
6908: }
6909: if (@expr1073764117 returnValue@var4709 .@expr1073764118 find (@expr1073764119 "arg" ) !=@expr1073764120 std ::@expr1073764121 string ::@expr1073764122 npos &&@expr1073764123 argValues@var4711 .@expr1073764124 empty (@expr1073764125 ) ) {
6910: return ; }
6911: productParams (@expr1073764126 argValues@var4711 , [@expr1073764127 &@expr22304 ] (@expr1073764129 const std ::@expr22280 unordered_map < int , ValueFlow ::@expr22280 Value > &@expr22304 arg@var4714 ) {
6912: ValueFlow ::@expr1073764133 Value value@var4715 ; value@var4715 =@expr1073764134 evaluateLibraryFunction (@expr1073764135 arg@var4714 , returnValue@var4709 , settings@var4710 ) ;
6913: if (@expr1073764136 value@var4715 .@expr1073764137 isUninitValue (@expr1073764138 ) ) {
6914: return ; }
6915: ValueFlow ::@expr22315 Value ::@expr1073764140 ValueKind kind@var4716 ; kind@var4716 =@expr1073764141 ValueFlow ::@expr22315 Value ::@expr22319 ValueKind ::@expr22320 Known ;
6916: for (@expr1073764145 auto && p@var4717 :@expr1073764146 arg@var4714 ) {
6917: if (@expr1073764147 p@var4717 .@expr22324 second@var4718 .@expr1073764149 isPossible (@expr1073764150 ) ) {
6918: kind@var4716 =@expr1073764151 p@var4717 .@expr22324 second@var4718 .@expr22329 valueKind@var4719 ; }
6919: if (@expr1073764154 p@var4717 .@expr22324 second@var4718 .@expr1073764156 isInconclusive (@expr1073764157 ) ) {
6920: kind@var4716 =@expr1073764158 p@var4717 .@expr22324 second@var4718 .@expr22329 valueKind@var4719 ;
6921: break ;
6922: }
6923: }
6924: if (@expr1073764161 value@var4715 .@expr22338 isImpossible (@expr22339 ) &&@expr1073764164 kind@var4716 !=@expr1073764165 ValueFlow ::@expr22315 Value ::@expr22319 ValueKind ::@expr22320 Known ) {
6925: return ; }
6926: if (@expr1073764169 !@expr1073764170 value@var4715 .@expr22338 isImpossible (@expr22339 ) ) {
6927: value@var4715 .@expr1073764173 valueKind@var4720 =@expr1073764174 kind@var4716 ; }
6928: setTokenValue (@expr1073764175 tok@var4708 , value@var4715 , settings@var4710 ) ;
6929: } ) ;
6930: }
6931:
6932: template < class Iterator >
6933: struct IteratorRange
6934: {
6935: Iterator mBegin@var4721 ;
6936: Iterator mEnd@var4722 ;
6937:
6938: Iterator begin ( ) const {
6939: return mBegin@var4721 ;
6940: }
6941:
6942: Iterator end ( ) const {
6943: return mEnd@var4722 ;
6944: }
6945: } ;
6946:
6947: template < class Iterator >
6948: IteratorRange < Iterator > MakeIteratorRange ( Iterator start@var4723 , Iterator last@var4724 )
6949: {
6950: return {@expr1073764176 start@var4723 , last@var4724 } ;
6951: }
6952:
6953: static void valueFlowSubFunction ( TokenList * tokenlist@var4725 , SymbolDatabase * symboldatabase@var4726 , ErrorLogger * errorLogger@var4727 , const Settings * settings@var4728 )
6954: {
6955: int id@var4729 ; id@var4729 =@expr1073764177 0 ;
6956: for (@expr1073764178 const Scope *@expr22355 scope@var4730 :@expr1073764180 MakeIteratorRange (@expr1073764181 symboldatabase@var4726 .@expr22358 functionScopes@var4731 .@expr1073764183 rbegin (@expr1073764184 ) , symboldatabase@var4726 .@expr22358 functionScopes@var4731 .@expr1073764186 rend (@expr1073764187 ) ) ) {
6957: const Function * function@var4732 ; function@var4732 =@expr1073764188 scope@var4730 .@expr1073764189 function@var4733 ;
6958: if (@expr1073764190 !@expr1073764191 function@var4732 ) {
6959: continue ; }
6960: for (@expr1073764192 const Token *@expr22355 tok@var4734 =@expr1073764194 scope@var4730 .@expr1073764195 bodyStart@var4735 ; tok@var4734 !=@expr1073764196 scope@var4730 .@expr1073764197 bodyEnd@var4736 ; tok@var4734 =@expr1073764198 tok@var4734 .@expr22375 next (@expr22376 ) ) {
6961: if (@expr1073764201 !@expr1073764202 Token ::@expr1073764203 Match (@expr1073764204 tok@var4734 , "%name% (" ) ) {
6962: continue ; }
6963:
6964: const Function * const calledFunction@var4737 ; calledFunction@var4737 =@expr1073764205 tok@var4734 .@expr1073764206 function (@expr1073764207 ) ;
6965: if (@expr1073764208 !@expr1073764209 calledFunction@var4737 ) {
6966:
6967: const std ::@expr1073764210 string & returnValue@var4738 (@expr1073764211 settings@var4728 .@expr22388 library@var4739 .@expr1073764213 returnValue (@expr1073764214 tok@var4734 ) ) ;
6968: if (@expr1073764215 !@expr1073764216 returnValue@var4738 .@expr1073764217 empty (@expr1073764218 ) ) {
6969: valueFlowLibraryFunction (@expr1073764219 tok@var4734 .@expr22375 next (@expr22376 ) , returnValue@var4738 , settings@var4728 ) ; }
6970: continue ;
6971: }
6972:
6973: const Scope * const calledFunctionScope@var4740 ; calledFunctionScope@var4740 =@expr1073764222 calledFunction@var4737 .@expr1073764223 functionScope@var4741 ;
6974: if (@expr1073764224 !@expr1073764225 calledFunctionScope@var4740 ) {
6975: continue ; }
6976:
6977: id@var4729 ++@expr1073764226 ;
6978: std ::@expr1073764227 unordered_map < const Variable *@expr22355 , std ::@expr22405 list < ValueFlow ::@expr22405 Value > > argvars@var4742 ;
6979:
6980: const std ::@expr1073764231 vector < const Token *@expr22355 > & callArguments@var4743 =@expr1073764233 getArguments (@expr1073764234 tok@var4734 ) ;
6981: for (@expr1073764235 int argnr@var4744 =@expr1073764236 0U ; argnr@var4744 <@expr1073764237 callArguments@var4743 .@expr1073764238 size (@expr1073764239 ) ; ++@expr1073764240 argnr@var4744 ) {
6982: const Token * argtok@var4745 ; argtok@var4745 =@expr1073764241 callArguments@var4743 [@expr1073764242 argnr@var4744 ] ;
6983:
6984: const Variable * const argvar@var4746 ; argvar@var4746 =@expr1073764243 calledFunction@var4737 .@expr1073764244 getArgumentVar (@expr1073764245 argnr@var4744 ) ;
6985: if (@expr1073764246 !@expr1073764247 argvar@var4746 ) {
6986: break ; }
6987:
6988:
6989: std ::@expr1073764248 list < ValueFlow ::@expr22405 Value > argvalues@var4747 (@expr1073764250 getFunctionArgumentValues (@expr1073764251 argtok@var4745 ) ) ;
6990:
6991:
6992: argvalues@var4747 .@expr1073764252 remove_if (@expr1073764253 [@expr1073764254 ] (@expr1073764255 const ValueFlow ::@expr22405 Value &@expr22433 v@var4748 ) {
6993: if (@expr1073764258 v@var4748 .@expr1073764259 isLifetimeValue (@expr1073764260 ) ) {
6994: return !@expr1073764261 v@var4748 .@expr1073764262 isLocalLifetimeValue (@expr1073764263 ) &&@expr1073764264 !@expr1073764265 v@var4748 .@expr1073764266 isSubFunctionLifetimeValue (@expr1073764267 ) ; }
6995: return false ;
6996: } ) ;
6997:
6998: if (@expr1073764268 argtok@var4745 .@expr22445 variable (@expr22446 ) &&@expr1073764271 !@expr1073764272 argtok@var4745 .@expr22445 variable (@expr22446 ) .@expr1073764275 isPointer (@expr1073764276 ) &&@expr1073764277 argvalues@var4747 .@expr1073764278 size (@expr1073764279 ) ==@expr1073764280 1 &&@expr1073764281 argvalues@var4747 .@expr1073764282 front (@expr1073764283 ) .@expr1073764284 isUninitValue (@expr1073764285 ) ) {
6999: if (@expr1073764286 CheckUninitVar ::@expr1073764287 isVariableUsage (@expr1073764288 tokenlist@var4725 .@expr1073764289 isCPP (@expr1073764290 ) , argtok@var4745 , settings@var4728 .@expr22388 library@var4739 , false , CheckUninitVar ::@expr1073764292 Alloc ::@expr1073764293 NO_ALLOC , 0 ) ) {
7000: continue ; }
7001: }
7002:
7003: if (@expr1073764294 argvalues@var4747 .@expr1073764295 empty (@expr1073764296 ) ) {
7004: continue ; }
7005:
7006:
7007: for (@expr1073764297 ValueFlow ::@expr22405 Value &@expr22433 v@var4749 :@expr1073764300 argvalues@var4747 ) {
7008: const std ::@expr22405 string nr@var4750 =@expr1073764302 MathLib ::@expr1073764303 toString (@expr1073764304 argnr@var4744 +@expr22481 1 ) +@expr1073764306 getOrdinalText (@expr1073764307 argnr@var4744 +@expr22481 1 ) ;
7009:
7010: v@var4749 .@expr1073764309 errorPath@var4751 .@expr1073764310 emplace_back (@expr1073764311 argtok@var4745 ,
7011: "Calling function '" +@expr1073764312
7012: calledFunction@var4737 .@expr1073764313 name (@expr1073764314 ) +@expr1073764315
7013: "', " +@expr1073764316
7014: nr@var4750 +@expr1073764317
7015: " argument '" +@expr1073764318
7016: argtok@var4745 .@expr1073764319 expressionString (@expr1073764320 ) +@expr1073764321
7017: "' value is " +@expr1073764322
7018: v@var4749 .@expr1073764323 infoString (@expr1073764324 ) ) ;
7019: v@var4749 .@expr22501 path@var4752 =@expr1073764326 256 *@expr1073764327 v@var4749 .@expr22501 path@var4752 +@expr1073764329 id@var4729 %@expr1073764330 256 ;
7020:
7021: if (@expr1073764331 v@var4749 .@expr1073764332 isLifetimeValue (@expr1073764333 ) ) {
7022: v@var4749 .@expr1073764334 lifetimeScope@var4753 =@expr1073764335 ValueFlow ::@expr1073764336 Value ::@expr1073764337 LifetimeScope ::@expr1073764338 SubFunction ; }
7023: }
7024:
7025:
7026: lowerToPossible (@expr1073764339 argvalues@var4747 ) ;
7027:
7028: argvars@var4742 [@expr1073764340 argvar@var4746 ] =@expr1073764341 argvalues@var4747 ;
7029: }
7030: valueFlowInjectParameter (@expr1073764342 tokenlist@var4725 , symboldatabase@var4726 , errorLogger@var4727 , settings@var4728 , calledFunctionScope@var4740 , argvars@var4742 ) ;
7031: }
7032: }
7033: }
7034:
7035: static void valueFlowFunctionDefaultParameter ( TokenList * tokenlist@var4754 , SymbolDatabase * symboldatabase@var4755 , const Settings * settings@var4756 )
7036: {
7037: if (@expr1073764343 !@expr1073764344 tokenlist@var4754 .@expr1073764345 isCPP (@expr1073764346 ) ) {
7038: return ; }
7039:
7040: for (@expr1073764347 const Scope *@expr1073764348 scope@var4757 :@expr1073764349 symboldatabase@var4755 .@expr1073764350 functionScopes@var4758 ) {
7041: const Function * function@var4759 ; function@var4759 =@expr1073764351 scope@var4757 .@expr1073764352 function@var4760 ;
7042: if (@expr1073764353 !@expr1073764354 function@var4759 ) {
7043: continue ; }
7044: for (@expr1073764355 unsigned long arg@var4761 =@expr1073764356 function@var4759 .@expr1073764357 minArgCount (@expr1073764358 ) ; arg@var4761 <@expr1073764359 function@var4759 .@expr1073764360 argCount (@expr1073764361 ) ; arg@var4761 ++@expr1073764362 ) {
7045: const Variable * var@var4762 ; var@var4762 =@expr1073764363 function@var4759 .@expr1073764364 getArgumentVar (@expr1073764365 arg@var4761 ) ;
7046: if (@expr1073764366 var@var4762 &&@expr1073764367 var@var4762 .@expr1073764368 hasDefault (@expr1073764369 ) &&@expr1073764370 Token ::@expr1073764371 Match (@expr1073764372 var@var4762 .@expr22549 nameToken (@expr22550 ) , "%var% = %num%|%str% [,)]" ) ) {
7047: const std ::@expr1073764375 list < ValueFlow ::@expr22552 Value > & values@var4763 =@expr1073764377 var@var4762 .@expr22549 nameToken (@expr22550 ) .@expr1073764380 tokAt (@expr1073764381 2 ) .@expr1073764382 values (@expr1073764383 ) ;
7048: std ::@expr1073764384 list < ValueFlow ::@expr22552 Value > argvalues@var4764 ;
7049: for (@expr1073764386 const ValueFlow ::@expr22552 Value &@expr1073764388 value@var4765 :@expr1073764389 values@var4763 ) {
7050: ValueFlow ::@expr1073764390 Value v@var4766 (@expr1073764391 value@var4765 ) ;
7051: v@var4766 .@expr1073764392 defaultArg@var4767 =@expr1073764393 true ;
7052: v@var4766 .@expr1073764394 changeKnownToPossible (@expr1073764395 ) ;
7053: if (@expr1073764396 v@var4766 .@expr1073764397 isPossible (@expr1073764398 ) ) {
7054: argvalues@var4764 .@expr1073764399 push_back (@expr1073764400 v@var4766 ) ; }
7055: }
7056: if (@expr1073764401 !@expr1073764402 argvalues@var4764 .@expr1073764403 empty (@expr1073764404 ) ) {
7057: valueFlowInjectParameter (@expr1073764405 tokenlist@var4754 , settings@var4756 , var@var4762 , scope@var4757 , argvalues@var4764 ) ; }
7058: }
7059: }
7060: }
7061: }
7062:
7063: static bool isKnown ( const Token * tok@var4768 )
7064: {
7065: return tok@var4768 &&@expr1073764406 tok@var4768 .@expr1073764407 hasKnownIntValue (@expr1073764408 ) ;
7066: }
7067:
7068: static void valueFlowFunctionReturn ( TokenList * tokenlist@var4769 , ErrorLogger * errorLogger@var4770 )
7069: {
7070: for (@expr1073764411 Token *@expr1073764412 tok@var4771 =@expr1073764413 tokenlist@var4769 .@expr1073764414 back (@expr1073764415 ) ; tok@var4771 ; tok@var4771 =@expr1073764416 tok@var4771 .@expr22593 previous (@expr22594 ) ) {
7071: if (@expr1073764419 tok@var4771 .@expr1073764420 str (@expr1073764421 ) !=@expr1073764422 "(" ||@expr1073764423 !@expr1073764424 tok@var4771 .@expr22601 astOperand1 (@expr22602 ) ) {
7072: continue ; }
7073:
7074: const Function * function@var4772 ; function@var4772 =@expr1073764427 nullptr ;
7075: if (@expr1073764428 Token ::@expr22605 Match (@expr1073764430 tok@var4771 .@expr22593 previous (@expr22594 ) , "%name% (" ) ) {
7076: function@var4772 =@expr1073764433 tok@var4771 .@expr22593 previous (@expr22594 ) .@expr1073764436 function (@expr1073764437 ) ; }
7077: else {
7078: function@var4772 =@expr1073764438 tok@var4771 .@expr22601 astOperand1 (@expr22602 ) .@expr1073764441 function (@expr1073764442 ) ; }
7079: if (@expr1073764443 !@expr1073764444 function@var4772 ) {
7080: continue ; }
7081:
7082: if (@expr1073764445 function@var4772 .@expr1073764446 isImplicitlyVirtual (@expr1073764447 ) &&@expr1073764448 !@expr1073764449 function@var4772 .@expr1073764450 hasFinalSpecifier (@expr1073764451 ) ) {
7083: continue ; }
7084:
7085: if (@expr1073764452 tok@var4771 .@expr1073764453 hasKnownValue (@expr1073764454 ) ) {
7086: continue ; }
7087:
7088:
7089: std ::@expr1073764455 vector < long long > parvalues@var4773 ;
7090: if (@expr1073764456 tok@var4771 .@expr22633 astOperand2 (@expr22634 ) ) {
7091: const Token * partok@var4774 ; partok@var4774 =@expr1073764459 tok@var4771 .@expr22633 astOperand2 (@expr22634 ) ;
7092: while (@expr1073764462 partok@var4774 &&@expr22639 partok@var4774 .@expr22640 str (@expr22641 ) ==@expr22642 "," &&@expr1073764467 isKnown (@expr1073764468 partok@var4774 .@expr22645 astOperand2 (@expr22646 ) ) ) {
7093: partok@var4774 =@expr1073764471 partok@var4774 .@expr1073764472 astOperand1 (@expr1073764473 ) ; }
7094: if (@expr1073764474 !@expr1073764475 isKnown (@expr1073764476 partok@var4774 ) ) {
7095: continue ; }
7096: parvalues@var4773 .@expr22653 push_back (@expr1073764478 partok@var4774 .@expr1073764479 values (@expr1073764480 ) .@expr1073764481 front (@expr1073764482 ) .@expr1073764483 intvalue@expr1073764409 ) ;
7097: partok@var4774 =@expr1073764484 partok@var4774 .@expr22661 astParent (@expr22662 ) ;
7098: while (@expr1073764487 partok@var4774 &&@expr22639 partok@var4774 .@expr22640 str (@expr22641 ) ==@expr22642 "," ) {
7099: parvalues@var4773 .@expr22653 push_back (@expr1073764493 partok@var4774 .@expr22645 astOperand2 (@expr22646 ) .@expr1073764496 values (@expr1073764497 ) .@expr1073764498 front (@expr1073764499 ) .@expr1073764500 intvalue@expr1073764410 ) ;
7100: partok@var4774 =@expr1073764501 partok@var4774 .@expr22661 astParent (@expr22662 ) ;
7101: }
7102: if (@expr1073764504 partok@var4774 !=@expr1073764505 tok@var4771 ) {
7103: continue ; }
7104: }
7105:
7106:
7107: const Scope * const functionScope@var4775 ; functionScope@var4775 =@expr1073764506 function@var4772 .@expr1073764507 functionScope@var4776 ;
7108: if (@expr1073764508 !@expr1073764509 functionScope@var4775 ||@expr1073764510 !@expr1073764511 Token ::@expr1073764512 simpleMatch (@expr1073764513 functionScope@var4775 .@expr22690 bodyStart@var4777 , "{ return" ) ) {
7109: if (@expr1073764515 functionScope@var4775 &&@expr1073764516 tokenlist@var4769 .@expr22693 getSettings (@expr22694 ) .@expr22695 debugwarnings@var5331 &&@expr1073764520 Token ::@expr1073764521 findsimplematch (@expr1073764522 functionScope@var4775 .@expr22690 bodyStart@var4777 , "return" , functionScope@var4775 .@expr1073764524 bodyEnd@var4778 ) ) {
7110: $bailoutInternal $(@expr1073764525 $"valueFlowBailout" $, tokenlist@var4769 $, errorLogger@var4770 $, tok@var4771 $, "function return; nontrivial function body" $, "cppcheck-2.8/lib/valueflow.cpp" $, 7110 $, $__func__ $) ; }
7111: continue ;
7112: }
7113:
7114: ProgramMemory programMemory@var4779 ;
7115: for (@expr1073764526 unsigned long i@var4780 =@expr1073764527 0 ; i@var4780 <@expr1073764528 parvalues@var4773 .@expr1073764529 size (@expr1073764530 ) ; ++@expr1073764531 i@var4780 ) {
7116: const Variable * const arg@var4781 ; arg@var4781 =@expr1073764532 function@var4772 .@expr1073764533 getArgumentVar (@expr1073764534 i@var4780 ) ;
7117: if (@expr1073764535 !@expr1073764536 arg@var4781 ||@expr1073764537 !@expr1073764538 Token ::@expr22605 Match (@expr1073764540 arg@var4781 .@expr1073764541 typeStartToken (@expr1073764542 ) , "%type% %name% ,|)" ) ) {
7118: if (@expr1073764543 tokenlist@var4769 .@expr22693 getSettings (@expr22694 ) .@expr22695 debugwarnings@var5331 ) {
7119: $bailoutInternal $(@expr1073764547 $"valueFlowBailout" $, tokenlist@var4769 $, errorLogger@var4770 $, tok@var4771 $, "function return; unhandled argument type" $, "cppcheck-2.8/lib/valueflow.cpp" $, 7119 $, $__func__ $) ; }
7120: programMemory@var4779 .@expr1073764548 clear (@expr1073764549 ) ;
7121: break ;
7122: }
7123: programMemory@var4779 .@expr1073764550 setIntValue (@expr1073764551 arg@var4781 .@expr1073764552 nameToken (@expr1073764553 ) , parvalues@var4773 [@expr1073764554 i@var4780 ] ) ;
7124: }
7125: if (@expr1073764555 programMemory@var4779 .@expr1073764556 empty (@expr1073764557 ) &&@expr1073764558 !@expr1073764559 parvalues@var4773 .@expr1073764560 empty (@expr1073764561 ) ) {
7126: continue ; }
7127:
7128:
7129: long long result@var4782 ; result@var4782 =@expr1073764562 0 ;
7130: bool error@var4783 ; error@var4783 =@expr1073764563 false ;
7131: execute (@expr1073764564 functionScope@var4775 .@expr22690 bodyStart@var4777 .@expr1073764566 next (@expr1073764567 ) .@expr1073764568 astOperand1 (@expr1073764569 ) ,
7132: &@expr1073764570 programMemory@var4779 ,
7133: &@expr1073764571 result@var4782 ,
7134: &@expr1073764572 error@var4783 ) ;
7135: if (@expr1073764573 !@expr1073764574 error@var4783 ) {
7136: ValueFlow ::@expr1073764575 Value v@var4784 (@expr1073764576 result@var4782 ) ;
7137: if (@expr1073764577 function@var4772 .@expr1073764578 hasVirtualSpecifier (@expr1073764579 ) ) {
7138: v@var4784 .@expr1073764580 setPossible (@expr1073764581 ) ; }
7139: else {
7140: v@var4784 .@expr1073764582 setKnown (@expr1073764583 ) ; }
7141: setTokenValue (@expr1073764584 tok@var4771 , v@var4784 , tokenlist@var4769 .@expr22693 getSettings (@expr22694 ) ) ;
7142: }
7143: }
7144: }
7145:
7146: static bool needsInitialization ( const Variable * var@var4785 , bool cpp@var4786 )
7147: {
7148: if (@expr1073764587 !@expr1073764588 var@var4785 ) {
7149: return false ; }
7150: if (@expr1073764589 var@var4785 .@expr1073764590 isPointer (@expr1073764591 ) ) {
7151: return true ; }
7152: if (@expr1073764592 var@var4785 .@expr22769 type (@expr22770 ) &&@expr1073764595 var@var4785 .@expr22769 type (@expr22770 ) .@expr1073764598 isUnionType (@expr1073764599 ) ) {
7153: return false ; }
7154: if (@expr1073764600 !@expr1073764601 cpp@var4786 ) {
7155: return true ; }
7156: if (@expr1073764602 var@var4785 .@expr22769 type (@expr22770 ) &&@expr1073764605 var@var4785 .@expr22769 type (@expr22770 ) .@expr1073764608 needInitialization@var5334 ==@expr1073764609 Type ::@expr1073764610 NeedInitialization ::@expr1073764611 True ) {
7157: return true ; }
7158: if (@expr1073764612 var@var4785 .@expr22789 valueType (@expr22790 ) &&@expr1073764615 (@expr1073764616 var@var4785 .@expr22789 valueType (@expr22790 ) .@expr1073764619 isPrimitive (@expr1073764620 ) ||@expr1073764621 var@var4785 .@expr22789 valueType (@expr22790 ) .@expr1073764624 type@var5318 ==@expr1073764625 ValueType ::@expr1073764626 Type ::@expr1073764627 POD ) ) {
7159: return true ; }
7160: return false ;
7161: }
7162:
7163: static void addToErrorPath ( ValueFlow :: Value & value@var4787 , const ValueFlow :: Value & from@var4788 )
7164: {
7165: std ::@expr1073764628 unordered_set < const Token *@expr22805 > locations@var4789 ;
7166: std ::@expr1073764630 transform (@expr1073764631 value@var4787 .@expr22808 errorPath@var4790 .@expr1073764633 begin (@expr1073764634 ) ,
7167: value@var4787 .@expr22808 errorPath@var4790 .@expr1073764636 end (@expr1073764637 ) ,
7168: std ::@expr1073764638 inserter (@expr1073764639 locations@var4789 , locations@var4789 .@expr1073764640 begin (@expr1073764641 ) ) ,
7169: [@expr1073764642 ] (@expr1073764643 const std ::@expr22820 pair < const Token *@expr22805 , std ::@expr22820 string > &@expr22823 e@var4791 ) {
7170: return e@var4791 .@expr1073764648 first@var4792 ;
7171: } ) ;
7172: if (@expr1073764649 from@var4788 .@expr22826 condition@var4793 &&@expr1073764651 !@expr1073764652 value@var4787 .@expr22829 condition@var4794 ) {
7173: value@var4787 .@expr22829 condition@var4794 =@expr1073764655 from@var4788 .@expr22826 condition@var4793 ; }
7174: std ::@expr1073764657 copy_if (@expr1073764658 from@var4788 .@expr22835 errorPath@var4795 .@expr1073764660 begin (@expr1073764661 ) ,
7175: from@var4788 .@expr22835 errorPath@var4795 .@expr1073764663 end (@expr1073764664 ) ,
7176: std ::@expr1073764665 back_inserter (@expr1073764666 value@var4787 .@expr22808 errorPath@var4790 ) ,
7177: [@expr1073764668 &@expr22823 ] (@expr1073764670 const std ::@expr22820 pair < const Token *@expr22805 , std ::@expr22820 string > &@expr22823 e@var4796 ) {
7178: return locations@var4789 .@expr1073764675 insert (@expr1073764676 e@var4796 .@expr1073764677 first@var4797 ) .@expr1073764678 second@var4798 ;
7179: } ) ;
7180: }
7181:
7182: static void valueFlowUninit ( TokenList * tokenlist@var4799 , SymbolDatabase * , const Settings * settings@var4800 )
7183: {
7184: for (@expr1073764679 Token *@expr22856 tok@var4801 =@expr1073764681 tokenlist@var4799 .@expr1073764682 front (@expr1073764683 ) ; tok@var4801 ; tok@var4801 =@expr1073764684 tok@var4801 .@expr22861 next (@expr22862 ) ) {
7185: if (@expr1073764687 !@expr1073764688 tok@var4801 .@expr22865 scope (@expr22866 ) .@expr1073764691 isExecutable (@expr1073764692 ) ) {
7186: continue ; }
7187: if (@expr1073764693 !@expr1073764694 Token ::@expr1073764695 Match (@expr1073764696 tok@var4801 , "%var% ;|[" ) ) {
7188: continue ; }
7189: const Variable * var@var4802 ; var@var4802 =@expr1073764697 tok@var4801 .@expr1073764698 variable (@expr1073764699 ) ;
7190: if (@expr1073764700 !@expr1073764701 var@var4802 ) {
7191: continue ; }
7192: if (@expr1073764702 var@var4802 .@expr22879 nameToken (@expr22880 ) !=@expr1073764705 tok@var4801 ||@expr1073764706 var@var4802 .@expr1073764707 isInit (@expr1073764708 ) ) {
7193: continue ; }
7194: if (@expr1073764709 !@expr1073764710 needsInitialization (@expr1073764711 var@var4802 , tokenlist@var4799 .@expr22888 isCPP (@expr22889 ) ) ) {
7195: continue ; }
7196: if (@expr1073764714 !@expr1073764715 var@var4802 .@expr1073764716 isLocal (@expr1073764717 ) ||@expr1073764718 var@var4802 .@expr1073764719 isStatic (@expr1073764720 ) ||@expr1073764721 var@var4802 .@expr1073764722 isExtern (@expr1073764723 ) ||@expr1073764724 var@var4802 .@expr1073764725 isReference (@expr1073764726 ) ||@expr1073764727 var@var4802 .@expr1073764728 isThrow (@expr1073764729 ) ) {
7197: continue ; }
7198:
7199: ValueFlow ::@expr1073764730 Value uninitValue@var4803 ;
7200: uninitValue@var4803 .@expr1073764731 setKnown (@expr1073764732 ) ;
7201: uninitValue@var4803 .@expr1073764733 valueType@var4804 =@expr1073764734 ValueFlow ::@expr1073764735 Value ::@expr1073764736 ValueType ::@expr1073764737 UNINIT ;
7202: uninitValue@var4803 .@expr1073764738 tokvalue@var4805 =@expr1073764739 tok@var4801 ;
7203: if (@expr1073764740 var@var4802 .@expr1073764741 isArray (@expr1073764742 ) ) {
7204: uninitValue@var4803 .@expr1073764743 indirect@var4806 =@expr1073764744 var@var4802 .@expr1073764745 dimensions (@expr1073764746 ) .@expr1073764747 size (@expr1073764748 ) ; }
7205:
7206: bool partial@var4807 ; partial@var4807 =@expr1073764749 false ;
7207:
7208: std ::@expr1073764750 map < Token *@expr22856 , ValueFlow ::@expr22928 Value > partialReads@var4808 ;
7209: if (@expr1073764753 const Scope *@expr22856 scope@var4809 =@expr1073764755 var@var4802 .@expr1073764756 typeScope (@expr1073764757 ) ) {
7210: if (@expr1073764758 Token ::@expr1073764759 findsimplematch (@expr1073764760 scope@var4809 .@expr1073764761 bodyStart@var4810 , "union" , scope@var4809 .@expr1073764762 bodyEnd@var4811 ) ) {
7211: continue ; }
7212: for (@expr1073764763 const Variable &@expr22940 memVar@var4812 :@expr1073764765 scope@var4809 .@expr1073764766 varlist@var4813 ) {
7213: if (@expr1073764767 !@expr1073764768 memVar@var4812 .@expr1073764769 isPublic (@expr1073764770 ) ) {
7214: continue ; }
7215:
7216: if (@expr1073764771 memVar@var4812 .@expr1073764772 isArray (@expr1073764773 ) ) {
7217: continue ; }
7218: if (@expr1073764774 !@expr1073764775 needsInitialization (@expr1073764776 &@expr1073764777 memVar@var4812 , tokenlist@var4799 .@expr22888 isCPP (@expr22889 ) ) ) {
7219: partial@var4807 =@expr1073764780 true ;
7220: continue ;
7221: }
7222: MemberExpressionAnalyzer analyzer@var4814 (@expr1073764781 memVar@var4812 .@expr22958 nameToken (@expr22959 ) .@expr22960 str (@expr22961 ) , tok@var4801 , uninitValue@var4803 , tokenlist@var4799 ) ;
7223: valueFlowGenericForward (@expr1073764786 tok@var4801 .@expr22861 next (@expr22862 ) , tok@var4801 .@expr22865 scope (@expr22866 ) .@expr22967 bodyEnd@var5330 , analyzer@var4814 , settings@var4800 ) ;
7224:
7225: for (@expr1073764792 auto && p@var4815 :@expr1073764793 *@expr1073764794 analyzer@var4814 .@expr1073764795 partialReads@var4816 ) {
7226: Token * tok2@var4817 ; tok2@var4817 =@expr1073764796 p@var4815 .@expr1073764797 first@var4818 ;
7227: const ValueFlow ::@expr22928 Value &@expr22940 v@var4819 =@expr1073764800 p@var4815 .@expr1073764801 second@var4820 ;
7228:
7229: auto pp@var4821 ; pp@var4821 =@expr1073764802 partialReads@var4808 .@expr1073764803 insert (@expr1073764804 std ::@expr1073764805 make_pair (@expr1073764806 tok2@var4817 , v@var4819 ) ) ;
7230: ValueFlow ::@expr22928 Value &@expr22940 v2@var4822 =@expr1073764809 pp@var4821 .@expr1073764810 first@var4823 .@expr1073764811 second@var4824 ;
7231: bool inserted@var4825 ; inserted@var4825 =@expr1073764812 pp@var4821 .@expr1073764813 second@var4826 ;
7232:
7233: if (@expr1073764814 !@expr1073764815 inserted@var4825 ) {
7234: if (@expr1073764816 v@var4819 .@expr1073764817 valueType@var4827 !=@expr1073764818 v2@var4822 .@expr1073764819 valueType@var4828 ) {
7235: continue ; }
7236: addToErrorPath (@expr1073764820 v2@var4822 , v@var4819 ) ;
7237: }
7238: v2@var4822 .@expr1073764821 subexpressions@var4829 .@expr1073764822 push_back (@expr1073764823 memVar@var4812 .@expr22958 nameToken (@expr22959 ) .@expr22960 str (@expr22961 ) ) ;
7239: }
7240: }
7241: }
7242:
7243: for (@expr1073764828 auto && p@var4830 :@expr1073764829 partialReads@var4808 ) {
7244: Token * tok2@var4831 ; tok2@var4831 =@expr1073764830 p@var4830 .@expr1073764831 first@var4832 ;
7245: const ValueFlow ::@expr22928 Value &@expr22940 v@var4833 =@expr1073764834 p@var4830 .@expr1073764835 second@var4834 ;
7246:
7247: setTokenValue (@expr1073764836 tok2@var4831 , v@var4833 , settings@var4800 ) ;
7248: }
7249:
7250: if (@expr1073764837 partial@var4807 ) {
7251: continue ; }
7252:
7253: valueFlowForward (@expr1073764838 tok@var4801 .@expr22861 next (@expr22862 ) , tok@var4801 .@expr22865 scope (@expr22866 ) .@expr22967 bodyEnd@var5330 , var@var4802 .@expr22879 nameToken (@expr22880 ) , {@expr1073764846 uninitValue@var4803 } , tokenlist@var4799 , settings@var4800 ) ;
7254: }
7255: }
7256:
7257: static bool isContainerSizeChanged ( int varId@var4835 ,
7258: const Token * start@var4836 ,
7259: const Token * end@var4837 ,
7260: const Settings * settings@var4838 = nullptr ,
7261: int depth@var4839 = 20 ) ;
7262:
7263: static bool isContainerSizeChangedByFunction ( const Token * tok@var4840 , const Settings * settings@var4841 = nullptr , int depth@var4842 = 20 )
7264: {
7265: if (@expr1073764847 !@expr1073764848 tok@var4840 .@expr23025 valueType (@expr23026 ) ) {
7266: return false ; }
7267: if (@expr1073764851 !@expr1073764852 astIsContainer (@expr1073764853 tok@var4840 ) ) {
7268: return false ; }
7269:
7270: if (@expr1073764854 Token ::@expr1073764855 Match (@expr1073764856 tok@var4840 , "%name% . %name% (" ) ) {
7271: Library ::@expr23033 Container ::@expr1073764858 Yield yield@var4843 ; yield@var4843 =@expr1073764859 getLibraryContainer (@expr1073764860 tok@var4840 ) .@expr1073764861 getYield (@expr1073764862 tok@var4840 .@expr1073764863 strAt (@expr1073764864 2 ) ) ;
7272: if (@expr1073764865 yield@var4843 !=@expr1073764866 Library ::@expr23033 Container ::@expr1073764868 Yield ::@expr1073764869 NO_YIELD ) {
7273: return false ; }
7274: }
7275: if (@expr1073764870 Token ::@expr1073764871 simpleMatch (@expr1073764872 tok@var4840 .@expr23049 astParent (@expr23050 ) , "[" ) ) {
7276: return false ; }
7277:
7278:
7279: const bool addressOf@var4844 =@expr1073764875 tok@var4840 .@expr23025 valueType (@expr23026 ) .@expr1073764878 pointer@var5317 ||@expr1073764879 (@expr1073764880 tok@var4840 .@expr23049 astParent (@expr23050 ) &&@expr1073764883 tok@var4840 .@expr23049 astParent (@expr23050 ) .@expr1073764886 isUnaryOp (@expr1073764887 "&" ) ) ;
7280:
7281: int narg@var4845 ;
7282: const Token * ftok@var4846 ; ftok@var4846 =@expr1073764888 getTokenArgumentFunction (@expr1073764889 tok@var4840 , narg@var4845 ) ;
7283: if (@expr1073764890 !@expr1073764891 ftok@var4846 ) {
7284: return false ; }
7285: const Function * fun@var4847 ; fun@var4847 =@expr1073764892 ftok@var4846 .@expr1073764893 function (@expr1073764894 ) ;
7286: if (@expr1073764895 fun@var4847 &&@expr1073764896 !@expr1073764897 fun@var4847 .@expr1073764898 hasVirtualSpecifier (@expr1073764899 ) ) {
7287: const Variable * arg@var4848 ; arg@var4848 =@expr1073764900 fun@var4847 .@expr1073764901 getArgumentVar (@expr1073764902 narg@var4845 ) ;
7288: if (@expr1073764903 arg@var4848 ) {
7289: if (@expr1073764904 !@expr1073764905 arg@var4848 .@expr1073764906 isReference (@expr1073764907 ) &&@expr1073764908 !@expr23085 addressOf@var4844 ) {
7290: return false ; }
7291: if (@expr1073764910 !@expr23085 addressOf@var4844 &&@expr1073764912 arg@var4848 .@expr1073764913 isConst (@expr1073764914 ) ) {
7292: return false ; }
7293: if (@expr1073764915 arg@var4848 .@expr23092 valueType (@expr23093 ) &&@expr1073764918 arg@var4848 .@expr23092 valueType (@expr23093 ) .@expr1073764921 constness@var5325 ==@expr1073764922 1 ) {
7294: return false ; }
7295: const Scope * scope@var4849 ; scope@var4849 =@expr1073764923 fun@var4847 .@expr1073764924 functionScope@var4850 ;
7296: if (@expr1073764925 scope@var4849 ) {
7297:
7298: if (@expr1073764926 !@expr1073764927 arg@var4848 .@expr1073764928 nameToken (@expr1073764929 ) ) {
7299: return false ; }
7300: if (@expr1073764930 depth@var4842 >@expr1073764931 0 ) {
7301: return isContainerSizeChanged (@expr1073764932
7302: arg@var4848 .@expr1073764933 declarationId (@expr1073764934 ) , scope@var4849 .@expr1073764935 bodyStart@var4851 , scope@var4849 .@expr1073764936 bodyEnd@var4852 , settings@var4841 , depth@var4842 -@expr1073764937 1 ) ; }
7303: }
7304:
7305: return true ;
7306: }
7307: }
7308:
7309: bool inconclusive@var4853 ; inconclusive@var4853 =@expr1073764938 false ;
7310: const bool isChanged@var4854 =@expr1073764939 isVariableChangedByFunctionCall (@expr1073764940 tok@var4840 , 0 , settings@var4841 , &@expr1073764941 inconclusive@var4853 ) ;
7311: return (@expr1073764942 isChanged@var4854 ||@expr1073764943 inconclusive@var4853 ) ;
7312: }
7313:
7314: struct ContainerExpressionAnalyzer : ExpressionAnalyzer {
7315: ContainerExpressionAnalyzer ( ) : ExpressionAnalyzer ( ) { }
7316:
7317: ContainerExpressionAnalyzer ( const Token * expr@var4855 , const ValueFlow :: Value & val@var4856 , const TokenList * t@var4857 )
7318: : ExpressionAnalyzer ( expr@var4855 , val@var4856 , t@var4857 )
7319: { }
7320:
7321: virtual bool match ( const Token * tok@var4858 ) const override {
7322: return tok@var4858 .@expr1073764944 exprId (@expr1073764945 ) ==@expr1073764946 expr@var3310 .@expr23123 exprId (@expr23124 ) ||@expr1073764949 (@expr1073764950 astIsIterator (@expr1073764951 tok@var4858 ) &&@expr1073764952 isAliasOf (@expr1073764953 tok@var4858 , expr@var3310 .@expr23123 exprId (@expr23124 ) ) ) ;
7323: }
7324:
7325: virtual Action isWritable ( const Token * tok@var4859 , Direction d@var4860 ) const override {
7326: if (@expr1073764961 astIsIterator (@expr1073764962 tok@var4859 ) ) {
7327: return Action ::@expr23139 None@expr23132 ; }
7328: if (@expr1073764964 d@var4860 ==@expr1073764965 Direction ::@expr1073764966 Reverse@expr1073764957 ) {
7329: return Action ::@expr23139 None@expr23132 ; }
7330: if (@expr1073764968 !@expr1073764969 getValue (@expr1073764970 tok@var4859 ) ) {
7331: return Action ::@expr23139 None@expr23132 ; }
7332: if (@expr1073764972 !@expr1073764973 tok@var4859 .@expr1073764974 valueType (@expr1073764975 ) ) {
7333: return Action ::@expr23139 None@expr23132 ; }
7334: if (@expr1073764977 !@expr1073764978 astIsContainer (@expr1073764979 tok@var4859 ) ) {
7335: return Action ::@expr23139 None@expr23132 ; }
7336: const Token * parent@var4861 ; parent@var4861 =@expr1073764981 tok@var4859 .@expr1073764982 astParent (@expr1073764983 ) ;
7337: const Library ::@expr23160 Container * container@var4862 ; container@var4862 =@expr1073764985 getLibraryContainer (@expr1073764986 tok@var4859 ) ;
7338:
7339: if (@expr1073764987 container@var4862 .@expr1073764988 stdStringLike@var4863 &&@expr1073764989 Token ::@expr1073764990 simpleMatch (@expr1073764991 parent@var4861 , "+=" ) &&@expr1073764992 astIsLHS (@expr1073764993 tok@var4859 ) &&@expr1073764994 parent@var4861 .@expr23171 astOperand2 (@expr23172 ) ) {
7340: const Token * rhs@var4864 ; rhs@var4864 =@expr1073764997 parent@var4861 .@expr23171 astOperand2 (@expr23172 ) ;
7341: if (@expr1073765000 rhs@var4864 .@expr1073765001 tokType (@expr1073765002 ) ==@expr1073765003 Token ::@expr1073765004 eString ) {
7342: return Action ::@expr23181 Read@expr23134 |@expr23182 Action ::@expr23183 Write@expr23135 |@expr23184 Action ::@expr23185 Incremental@expr23136 ; }
7343: const Library ::@expr23160 Container * rhsContainer@var4865 ; rhsContainer@var4865 =@expr1073765011 getLibraryContainer (@expr1073765012 rhs@var4864 ) ;
7344: if (@expr1073765013 rhsContainer@var4865 &&@expr1073765014 rhsContainer@var4865 .@expr1073765015 stdStringLike@var4866 ) {
7345: if (@expr1073765016 std ::@expr1073765017 any_of (@expr1073765018 rhs@var4864 .@expr23195 values (@expr23196 ) .@expr1073765021 begin (@expr1073765022 ) , rhs@var4864 .@expr23195 values (@expr23196 ) .@expr1073765025 end (@expr1073765026 ) , [@expr1073765027 &@expr23204 ] (@expr1073765029 const ValueFlow ::@expr1073765030 Value &@expr23204 rhsval@var4867 ) {
7346: return rhsval@var4867 .@expr1073765032 isKnown (@expr1073765033 ) &&@expr1073765034 rhsval@var4867 .@expr1073765035 isContainerSizeValue (@expr1073765036 ) ;
7347: } ) ) {
7348: return Action ::@expr23181 Read@expr23134 |@expr23182 Action ::@expr23183 Write@expr23135 |@expr23184 Action ::@expr23185 Incremental@expr23136 ; }
7349: }
7350: } else { if (@expr1073765042 Token ::@expr1073765043 Match (@expr1073765044 tok@var4859 , "%name% . %name% (" ) ) {
7351: Library ::@expr23160 Container ::@expr1073765046 Action action@var4868 ; action@var4868 =@expr1073765047 container@var4862 .@expr1073765048 getAction (@expr1073765049 tok@var4859 .@expr1073765050 strAt (@expr1073765051 2 ) ) ;
7352: if (@expr1073765052 action@var4868 ==@expr1073765053 Library ::@expr23160 Container ::@expr23231 Action ::@expr1073765056 PUSH ||@expr1073765057 action@var4868 ==@expr1073765058 Library ::@expr23160 Container ::@expr23231 Action ::@expr1073765061 POP ) {
7353: std ::@expr1073765062 vector < const Token *@expr1073765063 > args@var4869 ; args@var4869 =@expr1073765064 getArguments (@expr1073765065 tok@var4859 .@expr1073765066 tokAt (@expr1073765067 3 ) ) ;
7354: if (@expr1073765068 args@var4869 .@expr1073765069 size (@expr1073765070 ) <@expr1073765071 2 ) {
7355: return Action ::@expr23181 Read@expr23134 |@expr23182 Action ::@expr23183 Write@expr23135 |@expr23184 Action ::@expr23185 Incremental@expr23136 ; }
7356: }
7357: } }
7358: return Action ::@expr23139 None@expr23132 ;
7359: }
7360:
7361: virtual void writeValue ( ValueFlow :: Value * val@var4870 , const Token * tok@var4871 , Direction d@var4872 ) const override {
7362: if (@expr1073765079 d@var4872 ==@expr1073765080 Direction ::@expr1073765081 Reverse@expr1073765078 ) {
7363: return ; }
7364: if (@expr1073765082 !@expr1073765083 val@var4870 ) {
7365: return ; }
7366: if (@expr1073765084 !@expr1073765085 tok@var4871 .@expr23262 astParent (@expr23263 ) ) {
7367: return ; }
7368: if (@expr1073765088 !@expr1073765089 tok@var4871 .@expr1073765090 valueType (@expr1073765091 ) ) {
7369: return ; }
7370: if (@expr1073765092 !@expr1073765093 astIsContainer (@expr1073765094 tok@var4871 ) ) {
7371: return ; }
7372: const Token * parent@var4873 ; parent@var4873 =@expr1073765095 tok@var4871 .@expr23262 astParent (@expr23263 ) ;
7373: const Library ::@expr23274 Container * container@var4874 ; container@var4874 =@expr1073765099 getLibraryContainer (@expr1073765100 tok@var4871 ) ;
7374:
7375: if (@expr1073765101 container@var4874 .@expr1073765102 stdStringLike@var4875 &&@expr1073765103 Token ::@expr1073765104 simpleMatch (@expr1073765105 parent@var4873 , "+=" ) &&@expr1073765106 parent@var4873 .@expr23283 astOperand2 (@expr23284 ) ) {
7376: const Token * rhs@var4876 ; rhs@var4876 =@expr1073765109 parent@var4873 .@expr23283 astOperand2 (@expr23284 ) ;
7377: const Library ::@expr23274 Container * rhsContainer@var4877 ; rhsContainer@var4877 =@expr1073765113 getLibraryContainer (@expr1073765114 rhs@var4876 ) ;
7378: if (@expr1073765115 rhs@var4876 .@expr1073765116 tokType (@expr1073765117 ) ==@expr1073765118 Token ::@expr1073765119 eString ) {
7379: val@var4870 .@expr23296 intvalue@var4878 +=@expr1073765121 Token ::@expr1073765122 getStrLength (@expr1073765123 rhs@var4876 ) ; }
7380: else { if (@expr1073765124 rhsContainer@var4877 &&@expr1073765125 rhsContainer@var4877 .@expr1073765126 stdStringLike@var4879 ) {
7381: for (@expr1073765127 const ValueFlow ::@expr1073765128 Value &@expr1073765129 rhsval@var4880 :@expr1073765130 rhs@var4876 .@expr1073765131 values (@expr1073765132 ) ) {
7382: if (@expr1073765133 rhsval@var4880 .@expr1073765134 isKnown (@expr1073765135 ) &&@expr1073765136 rhsval@var4880 .@expr1073765137 isContainerSizeValue (@expr1073765138 ) ) {
7383: val@var4870 .@expr23296 intvalue@var4878 +=@expr1073765140 rhsval@var4880 .@expr1073765141 intvalue@var4881 ;
7384: }
7385: }
7386: } }
7387: } else { if (@expr1073765142 Token ::@expr1073765143 Match (@expr1073765144 tok@var4871 , "%name% . %name% (" ) ) {
7388: Library ::@expr23274 Container ::@expr1073765146 Action action@var4882 ; action@var4882 =@expr1073765147 container@var4874 .@expr1073765148 getAction (@expr1073765149 tok@var4871 .@expr1073765150 strAt (@expr1073765151 2 ) ) ;
7389: if (@expr1073765152 action@var4882 ==@expr1073765153 Library ::@expr23274 Container ::@expr23331 Action ::@expr1073765156 PUSH ) {
7390: val@var4870 .@expr23296 intvalue@var4878 ++@expr1073765158 ; }
7391: if (@expr1073765159 action@var4882 ==@expr1073765160 Library ::@expr23274 Container ::@expr23331 Action ::@expr1073765163 POP ) {
7392: val@var4870 .@expr23296 intvalue@var4878 --@expr1073765165 ; }
7393: } }
7394: }
7395:
7396: virtual Action isModified ( const Token * tok@var4883 ) const override {
7397: Action read@var4884 ; read@var4884 =@expr1073765168 Action ::@expr1073765169 Read@expr1073765166 ;
7398:
7399: if (@expr1073765170 astIsIterator (@expr1073765171 tok@var4883 ) ) {
7400: return read@var4884 ; }
7401: if (@expr1073765172 Token ::@expr1073765173 Match (@expr1073765174 tok@var4883 .@expr23351 astParent (@expr23352 ) , "%assign%" ) &&@expr1073765177 astIsLHS (@expr1073765178 tok@var4883 ) ) {
7402: return Action ::@expr23355 Invalid@expr23343 ; }
7403: if (@expr1073765180 isLikelyStreamRead (@expr1073765181 isCPP (@expr1073765182 ) , tok@var4883 .@expr23351 astParent (@expr23352 ) ) ) {
7404: return Action ::@expr23355 Invalid@expr23343 ; }
7405: if (@expr1073765186 astIsContainer (@expr1073765187 tok@var4883 ) &&@expr1073765188 isContainerSizeChanged (@expr1073765189 tok@var4883 , getSettings (@expr1073765190 ) ) ) {
7406: return Action ::@expr23355 Invalid@expr23343 ; }
7407: return read@var4884 ;
7408: }
7409: } ;
7410:
7411: static Analyzer :: Result valueFlowContainerForward ( Token * startToken@var4885 ,
7412: const Token * endToken@var4886 ,
7413: const Token * exprTok@var4887 ,
7414: const ValueFlow :: Value & value@var4888 ,
7415: TokenList * tokenlist@var4889 )
7416: {
7417: ContainerExpressionAnalyzer a@var4890 (@expr1073765192 exprTok@var4887 , value@var4888 , tokenlist@var4889 ) ;
7418: return valueFlowGenericForward (@expr1073765193 startToken@var4885 , endToken@var4886 , a@var4890 , tokenlist@var4889 .@expr1073765194 getSettings (@expr1073765195 ) ) ;
7419: }
7420:
7421: static Analyzer :: Result valueFlowContainerForwardRecursive ( Token * top@var4891 ,
7422: const Token * exprTok@var4892 ,
7423: const ValueFlow :: Value & value@var4893 ,
7424: TokenList * tokenlist@var4894 )
7425: {
7426: ContainerExpressionAnalyzer a@var4895 (@expr1073765196 exprTok@var4892 , value@var4893 , tokenlist@var4894 ) ;
7427: return valueFlowGenericForward (@expr1073765197 top@var4891 , a@var4895 , tokenlist@var4894 .@expr1073765198 getSettings (@expr1073765199 ) ) ;
7428: }
7429:
7430: static Analyzer :: Result valueFlowContainerForward ( Token * startToken@var4896 ,
7431: const Token * exprTok@var4897 ,
7432: const ValueFlow :: Value & value@var4898 ,
7433: TokenList * tokenlist@var4899 )
7434: {
7435: const Token * endToken@var4900 ; endToken@var4900 =@expr1073765200 nullptr ;
7436: const Function * f@var4901 ; f@var4901 =@expr1073765201 Scope ::@expr1073765202 nestedInFunction (@expr1073765203 startToken@var4896 .@expr1073765204 scope (@expr1073765205 ) ) ;
7437: if (@expr1073765206 f@var4901 &&@expr1073765207 f@var4901 .@expr23384 functionScope@var4902 ) {
7438: endToken@var4900 =@expr1073765209 f@var4901 .@expr23384 functionScope@var4902 .@expr1073765211 bodyEnd@var4903 ; }
7439: return valueFlowContainerForward (@expr1073765212 startToken@var4896 , endToken@var4900 , exprTok@var4897 , value@var4898 , tokenlist@var4899 ) ;
7440: }
7441:
7442: static void valueFlowContainerReverse ( Token * tok@var4904 ,
7443: const Token * const endToken@var4905 ,
7444: const Token * const varToken@var4906 ,
7445: const std :: list < ValueFlow :: Value > & values@var4907 ,
7446: TokenList * tokenlist@var4908 ,
7447: const Settings * settings@var4909 )
7448: {
7449: for (@expr1073765213 const ValueFlow ::@expr1073765214 Value &@expr1073765215 value@var4910 :@expr1073765216 values@var4907 ) {
7450: ContainerExpressionAnalyzer a@var4911 (@expr1073765217 varToken@var4906 , value@var4910 , tokenlist@var4908 ) ;
7451: valueFlowGenericReverse (@expr1073765218 tok@var4904 , endToken@var4905 , a@var4911 , settings@var4909 ) ;
7452: }
7453: }
7454:
7455: bool isContainerSizeChanged ( const Token * tok@var4912 , const Settings * settings@var4913 , int depth@var4914 )
7456: {
7457: if (@expr1073765219 !@expr1073765220 tok@var4912 ) {
7458: return false ; }
7459: if (@expr1073765221 !@expr1073765222 tok@var4912 .@expr23399 valueType (@expr23400 ) ||@expr1073765225 !@expr1073765226 tok@var4912 .@expr23399 valueType (@expr23400 ) .@expr23405 container@var5335 ) {
7460: return true ; }
7461: if (@expr1073765230 Token ::@expr23407 Match (@expr1073765232 tok@var4912 , "%name% %assign%|<<" ) ) {
7462: return true ; }
7463: if (@expr1073765233 Token ::@expr23407 Match (@expr1073765235 tok@var4912 , "%var% [" ) &&@expr1073765236 tok@var4912 .@expr23399 valueType (@expr23400 ) .@expr23405 container@var5335 .@expr1073765240 stdAssociativeLike@var5336 ) {
7464: return true ; }
7465: if (@expr1073765241 Token ::@expr23407 Match (@expr1073765243 tok@var4912 , "%name% . %name% (" ) ) {
7466: Library ::@expr23420 Container ::@expr1073765245 Action action@var4915 ; action@var4915 =@expr1073765246 tok@var4912 .@expr23399 valueType (@expr23400 ) .@expr23405 container@var5335 .@expr1073765250 getAction (@expr1073765251 tok@var4912 .@expr23428 strAt (@expr23429 2 ) ) ;
7467: Library ::@expr23420 Container ::@expr1073765255 Yield yield@var4916 ; yield@var4916 =@expr1073765256 tok@var4912 .@expr23399 valueType (@expr23400 ) .@expr23405 container@var5335 .@expr1073765260 getYield (@expr1073765261 tok@var4912 .@expr23428 strAt (@expr23429 2 ) ) ;
7468: switch (@expr1073765264 action@var4915 ) {
7469: case Library ::@expr23420 Container ::@expr23442 Action ::@expr1073765267 RESIZE :@expr23444
7470: case Library ::@expr23420 Container ::@expr23442 Action ::@expr1073765271 CLEAR :@expr23444
7471: case Library ::@expr23420 Container ::@expr23442 Action ::@expr1073765275 PUSH :@expr23444
7472: case Library ::@expr23420 Container ::@expr23442 Action ::@expr1073765279 POP :@expr23444
7473: case Library ::@expr23420 Container ::@expr23442 Action ::@expr1073765283 CHANGE :@expr23444
7474: case Library ::@expr23420 Container ::@expr23442 Action ::@expr1073765287 INSERT :@expr23444
7475: case Library ::@expr23420 Container ::@expr23442 Action ::@expr1073765291 ERASE :@expr23444 ;
7476: return true ;
7477: case Library ::@expr23420 Container ::@expr23442 Action ::@expr1073765295 NO_ACTION :@expr23444 ;
7478: return yield@var4916 ==@expr1073765297 Library ::@expr23420 Container ::@expr1073765299 Yield ::@expr1073765300 NO_YIELD ;
7479: case Library ::@expr23420 Container ::@expr23442 Action ::@expr1073765303 FIND :@expr23444
7480: case Library ::@expr23420 Container ::@expr23442 Action ::@expr1073765307 CHANGE_CONTENT :@expr23444
7481: case Library ::@expr23420 Container ::@expr23442 Action ::@expr1073765311 CHANGE_INTERNAL :@expr23444 ;
7482: break ;
7483: }
7484: }
7485: if (@expr1073765313 isContainerSizeChangedByFunction (@expr1073765314 tok@var4912 , settings@var4913 , depth@var4914 ) ) {
7486: return true ; }
7487: return false ;
7488: }
7489:
7490: static bool isContainerSizeChanged ( int varId@var4917 ,
7491: const Token * start@var4918 ,
7492: const Token * end@var4919 ,
7493: const Settings * settings@var4920 ,
7494: int depth@var4921 )
7495: {
7496: for (@expr1073765315 const Token *@expr1073765316 tok@var4922 =@expr1073765317 start@var4918 ; tok@var4922 !=@expr1073765318 end@var4919 ; tok@var4922 =@expr1073765319 tok@var4922 .@expr1073765320 next (@expr1073765321 ) ) {
7497: if (@expr1073765322 tok@var4922 .@expr1073765323 varId (@expr1073765324 ) !=@expr1073765325 varId@var4917 ) {
7498: continue ; }
7499: if (@expr1073765326 isContainerSizeChanged (@expr1073765327 tok@var4922 , settings@var4920 , depth@var4921 ) ) {
7500: return true ; }
7501: }
7502: return false ;
7503: }
7504:
7505: static void valueFlowSmartPointer ( TokenList * tokenlist@var4923 , ErrorLogger * errorLogger@var4924 , const Settings * settings@var4925 )
7506: {
7507: for (@expr1073765328 Token *@expr23505 tok@var4926 =@expr1073765330 tokenlist@var4923 .@expr1073765331 front (@expr1073765332 ) ; tok@var4926 ; tok@var4926 =@expr1073765333 tok@var4926 .@expr23510 next (@expr23511 ) ) {
7508: if (@expr1073765336 !@expr1073765337 tok@var4926 .@expr23514 scope (@expr23515 ) ) {
7509: continue ; }
7510: if (@expr1073765340 !@expr1073765341 tok@var4926 .@expr23514 scope (@expr23515 ) .@expr1073765344 isExecutable (@expr1073765345 ) ) {
7511: continue ; }
7512: if (@expr1073765346 !@expr1073765347 astIsSmartPointer (@expr23524 tok@var4926 ) ) {
7513: continue ; }
7514: if (@expr1073765349 tok@var4926 .@expr23526 variable (@expr23527 ) &&@expr1073765352 Token ::@expr23529 Match (@expr1073765354 tok@var4926 , "%var% (|{|;" ) ) {
7515: const Variable * var@var4927 ; var@var4927 =@expr1073765355 tok@var4926 .@expr23526 variable (@expr23527 ) ;
7516: if (@expr1073765358 !@expr1073765359 var@var4927 .@expr1073765360 isSmartPointer (@expr1073765361 ) ) {
7517: continue ; }
7518: if (@expr1073765362 var@var4927 .@expr1073765363 nameToken (@expr1073765364 ) ==@expr1073765365 tok@var4926 ) {
7519: if (@expr1073765366 Token ::@expr23529 Match (@expr1073765368 tok@var4926 , "%var% (|{" ) &&@expr1073765369 tok@var4926 .@expr23510 next (@expr23511 ) .@expr23548 astOperand2 (@expr23549 ) &&@expr1073765374
7520: tok@var4926 .@expr23510 next (@expr23511 ) .@expr23548 astOperand2 (@expr23549 ) .@expr1073765379 str (@expr1073765380 ) !=@expr1073765381 "," ) {
7521: Token * inTok@var4928 ; inTok@var4928 =@expr1073765382 tok@var4926 .@expr23510 next (@expr23511 ) .@expr23548 astOperand2 (@expr23549 ) ;
7522: std ::@expr1073765387 list < ValueFlow ::@expr23564 Value > values@var4929 ; values@var4929 =@expr1073765389 inTok@var4928 .@expr1073765390 values (@expr1073765391 ) ;
7523: const bool constValue@var4930 =@expr1073765392 inTok@var4928 .@expr1073765393 isNumber (@expr1073765394 ) ;
7524: valueFlowForwardAssign (@expr1073765395 inTok@var4928 , var@var4927 , values@var4929 , constValue@var4930 , true , tokenlist@var4923 , errorLogger@var4924 , settings@var4925 ) ;
7525:
7526: } else { if (@expr1073765396 Token ::@expr23529 Match (@expr1073765398 tok@var4926 , "%var% ;" ) ) {
7527: std ::@expr1073765399 list < ValueFlow ::@expr23564 Value > values@var4931 ;
7528: ValueFlow ::@expr1073765401 Value v@var4932 (@expr1073765402 0 ) ;
7529: v@var4932 .@expr1073765403 setKnown (@expr1073765404 ) ;
7530: values@var4931 .@expr1073765405 push_back (@expr1073765406 v@var4932 ) ;
7531: valueFlowForwardAssign (@expr1073765407 tok@var4926 , var@var4927 , values@var4931 , false , true , tokenlist@var4923 , errorLogger@var4924 , settings@var4925 ) ;
7532: } }
7533: }
7534: } else { if (@expr1073765408 astIsLHS (@expr1073765409 tok@var4926 ) &&@expr1073765410 Token ::@expr23529 Match (@expr1073765412 tok@var4926 .@expr23589 astParent (@expr23590 ) , ". %name% (" ) &&@expr1073765415
7535: tok@var4926 .@expr23589 astParent (@expr23590 ) .@expr1073765418 originalName (@expr1073765419 ) !=@expr1073765420 "->" ) {
7536: std ::@expr1073765421 vector < const Variable *@expr23505 > vars@var4933 ; vars@var4933 =@expr1073765423 getVariables (@expr1073765424 tok@var4926 ) ;
7537: Token * ftok@var4934 ; ftok@var4934 =@expr1073765425 tok@var4926 .@expr23589 astParent (@expr23590 ) .@expr23604 tokAt (@expr23605 2 ) ;
7538: if (@expr1073765430 Token ::@expr23607 simpleMatch (@expr1073765432 tok@var4926 .@expr23589 astParent (@expr23590 ) , ". reset (" ) ) {
7539: if (@expr1073765435 Token ::@expr23607 simpleMatch (@expr1073765437 ftok@var4934 , "( )" ) ) {
7540: std ::@expr1073765438 list < ValueFlow ::@expr23564 Value > values@var4935 ;
7541: ValueFlow ::@expr1073765440 Value v@var4936 (@expr1073765441 0 ) ;
7542: v@var4936 .@expr1073765442 setKnown (@expr1073765443 ) ;
7543: values@var4935 .@expr1073765444 push_back (@expr1073765445 v@var4936 ) ;
7544: valueFlowForwardAssign (@expr1073765446 ftok@var4934 , tok@var4926 , vars@var4933 , values@var4935 , false , tokenlist@var4923 , errorLogger@var4924 , settings@var4925 ) ;
7545: } else {
7546: tok@var4926 .@expr1073765447 removeValues (@expr1073765448 std ::@expr1073765449 mem_fn (@expr1073765450 &@expr1073765451 ValueFlow ::@expr1073765452 Value ::@expr1073765453 isIntValue ) ) ;
7547: Token * inTok@var4937 ; inTok@var4937 =@expr1073765454 ftok@var4934 .@expr1073765455 astOperand2 (@expr1073765456 ) ;
7548: if (@expr1073765457 !@expr1073765458 inTok@var4937 ) {
7549: continue ; }
7550: std ::@expr1073765459 list < ValueFlow ::@expr23564 Value > values@var4938 ; values@var4938 =@expr1073765461 inTok@var4937 .@expr1073765462 values (@expr1073765463 ) ;
7551: valueFlowForwardAssign (@expr1073765464 inTok@var4937 , tok@var4926 , vars@var4933 , values@var4938 , false , tokenlist@var4923 , errorLogger@var4924 , settings@var4925 ) ;
7552: }
7553: } else { if (@expr1073765465 Token ::@expr23607 simpleMatch (@expr1073765467 tok@var4926 .@expr23589 astParent (@expr23590 ) , ". release ( )" ) ) {
7554: const Token * parent@var4939 ; parent@var4939 =@expr1073765470 ftok@var4934 .@expr1073765471 astParent (@expr1073765472 ) ;
7555: bool hasParentReset@var4940 ; hasParentReset@var4940 =@expr1073765473 false ;
7556: while (@expr1073765474 parent@var4939 ) {
7557: if (@expr1073765475 Token ::@expr23529 Match (@expr1073765477 parent@var4939 .@expr23654 tokAt (@expr23655 -2 ) , ". release|reset (" ) &&@expr1073765480
7558: parent@var4939 .@expr23654 tokAt (@expr23655 -2 ) .@expr1073765483 astOperand1 (@expr1073765484 ) .@expr1073765485 exprId (@expr1073765486 ) ==@expr1073765487 tok@var4926 .@expr1073765488 exprId (@expr1073765489 ) ) {
7559: hasParentReset@var4940 =@expr1073765490 true ;
7560: break ;
7561: }
7562: parent@var4939 =@expr1073765491 parent@var4939 .@expr1073765492 astParent (@expr1073765493 ) ;
7563: }
7564: if (@expr1073765494 hasParentReset@var4940 ) {
7565: continue ; }
7566: std ::@expr1073765495 list < ValueFlow ::@expr23564 Value > values@var4941 ;
7567: ValueFlow ::@expr1073765497 Value v@var4942 (@expr1073765498 0 ) ;
7568: v@var4942 .@expr1073765499 setKnown (@expr1073765500 ) ;
7569: values@var4941 .@expr1073765501 push_back (@expr1073765502 v@var4942 ) ;
7570: valueFlowForwardAssign (@expr1073765503 ftok@var4934 , tok@var4926 , vars@var4933 , values@var4941 , false , tokenlist@var4923 , errorLogger@var4924 , settings@var4925 ) ;
7571: } else { if (@expr1073765504 Token ::@expr23607 simpleMatch (@expr1073765506 tok@var4926 .@expr23589 astParent (@expr23590 ) , ". get ( )" ) ) {
7572: ValueFlow ::@expr1073765509 Value v@var4943 ; v@var4943 =@expr1073765510 makeSymbolic (@expr1073765511 tok@var4926 ) ;
7573: setTokenValue (@expr1073765512 tok@var4926 .@expr23589 astParent (@expr23590 ) .@expr23604 tokAt (@expr23605 2 ) , v@var4943 , settings@var4925 ) ;
7574: } } }
7575: } else { if (@expr1073765517 Token ::@expr23529 Match (@expr1073765519 tok@var4926 .@expr1073765520 previous (@expr1073765521 ) , "%name%|> (|{" ) &&@expr1073765522 astIsSmartPointer (@expr23524 tok@var4926 ) &&@expr1073765524
7576: astIsSmartPointer (@expr1073765525 tok@var4926 .@expr1073765526 astOperand1 (@expr1073765527 ) ) ) {
7577: std ::@expr1073765528 vector < const Token *@expr23505 > args@var4944 ; args@var4944 =@expr1073765530 getArguments (@expr1073765531 tok@var4926 ) ;
7578: if (@expr1073765532 args@var4944 .@expr1073765533 empty (@expr1073765534 ) ) {
7579: continue ; }
7580: for (@expr1073765535 const ValueFlow ::@expr23564 Value &@expr1073765537 v@var4945 :@expr1073765538 args@var4944 .@expr1073765539 front (@expr1073765540 ) .@expr1073765541 values (@expr1073765542 ) ) {
7581: setTokenValue (@expr1073765543 tok@var4926 , v@var4945 , settings@var4925 ) ; }
7582: } } }
7583: }
7584: }
7585:
7586: static void valueFlowIterators ( TokenList * tokenlist@var4946 , const Settings * settings@var4947 )
7587: {
7588: for (@expr1073765544 Token *@expr1073765545 tok@var4948 =@expr1073765546 tokenlist@var4946 .@expr1073765547 front (@expr1073765548 ) ; tok@var4948 ; tok@var4948 =@expr1073765549 tok@var4948 .@expr1073765550 next (@expr1073765551 ) ) {
7589: if (@expr1073765552 !@expr1073765553 tok@var4948 .@expr23730 scope (@expr23731 ) ) {
7590: continue ; }
7591: if (@expr1073765556 !@expr1073765557 tok@var4948 .@expr23730 scope (@expr23731 ) .@expr1073765560 isExecutable (@expr1073765561 ) ) {
7592: continue ; }
7593: if (@expr1073765562 !@expr1073765563 astIsContainer (@expr1073765564 tok@var4948 ) ) {
7594: continue ; }
7595: if (@expr1073765565 Token ::@expr1073765566 Match (@expr1073765567 tok@var4948 .@expr23744 astParent (@expr23745 ) , ". %name% (" ) ) {
7596: Library ::@expr23746 Container ::@expr1073765571 Yield yield@var4949 ; yield@var4949 =@expr1073765572 getLibraryContainer (@expr1073765573 tok@var4948 ) .@expr1073765574 getYield (@expr1073765575 tok@var4948 .@expr23744 astParent (@expr23745 ) .@expr1073765578 strAt (@expr1073765579 1 ) ) ;
7597: ValueFlow ::@expr1073765580 Value v@var4950 (@expr1073765581 0 ) ;
7598: v@var4950 .@expr1073765582 setKnown (@expr1073765583 ) ;
7599: if (@expr1073765584 yield@var4949 ==@expr1073765585 Library ::@expr23746 Container ::@expr23763 Yield ::@expr1073765588 START_ITERATOR ) {
7600: v@var4950 .@expr23765 valueType@var4951 =@expr1073765590 ValueFlow ::@expr23767 Value ::@expr23768 ValueType ::@expr1073765593 ITERATOR_START ;
7601: setTokenValue (@expr23770 tok@var4948 .@expr23744 astParent (@expr23745 ) .@expr23773 tokAt (@expr23774 2 ) , v@var4950 , settings@var4947 ) ;
7602: } else { if (@expr1073765599 yield@var4949 ==@expr1073765600 Library ::@expr23746 Container ::@expr23763 Yield ::@expr1073765603 END_ITERATOR ) {
7603: v@var4950 .@expr23765 valueType@var4951 =@expr1073765605 ValueFlow ::@expr23767 Value ::@expr23768 ValueType ::@expr1073765608 ITERATOR_END ;
7604: setTokenValue (@expr23770 tok@var4948 .@expr23744 astParent (@expr23745 ) .@expr23773 tokAt (@expr23774 2 ) , v@var4950 , settings@var4947 ) ;
7605: } }
7606: }
7607: }
7608: }
7609:
7610: static std :: list < ValueFlow :: Value > getIteratorValues ( std :: list < ValueFlow :: Value > values@var4952 , const ValueFlow :: Value :: ValueKind * kind@var4953 = nullptr )
7611: {
7612: values@var4952 .@expr1073765614 remove_if (@expr1073765615 [@expr1073765616 &@expr23793 ] (@expr1073765618 const ValueFlow ::@expr1073765619 Value &@expr23793 v@var4954 ) {
7613: if (@expr1073765621 kind@var4953 &&@expr1073765622 v@var4954 .@expr1073765623 valueKind@var4955 !=@expr1073765624 *@expr1073765625 kind@var4953 ) {
7614: return true ; }
7615: return !@expr1073765626 v@var4954 .@expr1073765627 isIteratorValue (@expr1073765628 ) ;
7616: } ) ;
7617: return values@var4952 ;
7618: }
7619:
7620: struct IteratorConditionHandler : SimpleConditionHandler {
7621: virtual std :: vector < Condition > parse ( const Token * tok@var4956 , const Settings * ) const override {
7622: Condition cond@var4957 ;
7623:
7624: ValueFlow ::@expr1073765629 Value true_value@var4958 ;
7625: ValueFlow ::@expr1073765630 Value false_value@var4959 ;
7626:
7627: if (@expr1073765631 Token ::@expr1073765632 Match (@expr1073765633 tok@var4956 , "==|!=" ) ) {
7628: if (@expr1073765634 !@expr1073765635 tok@var4956 .@expr23812 astOperand1 (@expr23813 ) ||@expr1073765638 !@expr1073765639 tok@var4956 .@expr23816 astOperand2 (@expr23817 ) ) {
7629: return { } ; }
7630:
7631: ValueFlow ::@expr23818 Value ::@expr1073765643 ValueKind kind@var4960 ; kind@var4960 =@expr1073765644 ValueFlow ::@expr23818 Value ::@expr1073765646 ValueKind ::@expr1073765647 Known ;
7632: std ::@expr1073765648 list < ValueFlow ::@expr23825 Value > values@var4961 ; values@var4961 =@expr1073765650 getIteratorValues (@expr1073765651 tok@var4956 .@expr23812 astOperand1 (@expr23813 ) .@expr1073765654 values (@expr1073765655 ) , &@expr23832 kind@var4960 ) ;
7633: if (@expr23833 !@expr23834 values@var4961 .@expr23835 empty (@expr23836 ) ) {
7634: cond@var4957 .@expr23837 vartok@var4962 =@expr1073765662 tok@var4956 .@expr23816 astOperand2 (@expr23817 ) ;
7635: } else {
7636: values@var4961 =@expr1073765665 getIteratorValues (@expr1073765666 tok@var4956 .@expr23816 astOperand2 (@expr23817 ) .@expr1073765669 values (@expr1073765670 ) , &@expr23832 kind@var4960 ) ;
7637: if (@expr23833 !@expr23834 values@var4961 .@expr23835 empty (@expr23836 ) ) {
7638: cond@var4957 .@expr23837 vartok@var4962 =@expr1073765677 tok@var4956 .@expr23812 astOperand1 (@expr23813 ) ; }
7639: }
7640: for (@expr1073765680 ValueFlow ::@expr23825 Value &@expr1073765682 v@var4963 :@expr1073765683 values@var4961 ) {
7641: v@var4963 .@expr1073765684 setPossible (@expr1073765685 ) ;
7642: v@var4963 .@expr1073765686 assumeCondition (@expr1073765687 tok@var4956 ) ;
7643: }
7644: cond@var4957 .@expr1073765688 true_values@var4964 =@expr1073765689 values@var4961 ;
7645: cond@var4957 .@expr1073765690 false_values@var4965 =@expr1073765691 values@var4961 ;
7646: }
7647:
7648: return {@expr1073765692 cond@var4957 } ;
7649: }
7650: } ;
7651:
7652: static void valueFlowIteratorInfer ( TokenList * tokenlist@var4966 , const Settings * settings@var4967 )
7653: {
7654: for (@expr1073765694 Token *@expr1073765695 tok@var4968 =@expr1073765696 tokenlist@var4966 .@expr1073765697 front (@expr1073765698 ) ; tok@var4968 ; tok@var4968 =@expr1073765699 tok@var4968 .@expr1073765700 next (@expr1073765701 ) ) {
7655: if (@expr1073765702 !@expr1073765703 tok@var4968 .@expr23880 scope (@expr23881 ) ) {
7656: continue ; }
7657: if (@expr1073765706 !@expr1073765707 tok@var4968 .@expr23880 scope (@expr23881 ) .@expr1073765710 isExecutable (@expr1073765711 ) ) {
7658: continue ; }
7659: std ::@expr1073765712 list < ValueFlow ::@expr23889 Value > values@var4969 ; values@var4969 =@expr1073765714 getIteratorValues (@expr1073765715 tok@var4968 .@expr1073765716 values (@expr1073765717 ) ) ;
7660: values@var4969 .@expr1073765718 remove_if (@expr1073765719 [@expr1073765720 &@expr23897 ] (@expr1073765722 const ValueFlow ::@expr23889 Value &@expr23897 v@var4970 ) {
7661: if (@expr1073765725 !@expr1073765726 v@var4970 .@expr1073765727 isImpossible (@expr1073765728 ) ) {
7662: return true ; }
7663: if (@expr1073765729 !@expr1073765730 v@var4970 .@expr1073765731 condition@var4971 ) {
7664: return true ; }
7665: if (@expr1073765732 v@var4970 .@expr1073765733 bound@var4972 !=@expr1073765734 ValueFlow ::@expr1073765735 Value ::@expr1073765736 Bound ::@expr1073765737 Point@expr1073765693 ) {
7666: return true ; }
7667: if (@expr1073765738 v@var4970 .@expr1073765739 isIteratorEndValue (@expr1073765740 ) &&@expr1073765741 v@var4970 .@expr23918 intvalue@var4973 <=@expr1073765743 0 ) {
7668: return true ; }
7669: if (@expr1073765744 v@var4970 .@expr1073765745 isIteratorStartValue (@expr1073765746 ) &&@expr1073765747 v@var4970 .@expr23918 intvalue@var4973 >=@expr1073765749 0 ) {
7670: return true ; }
7671: return false ;
7672: } ) ;
7673: for (@expr1073765750 ValueFlow ::@expr23889 Value &@expr23897 v@var4974 :@expr1073765753 values@var4969 ) {
7674: v@var4974 .@expr1073765754 setPossible (@expr1073765755 ) ;
7675: if (@expr1073765756 v@var4974 .@expr1073765757 isIteratorStartValue (@expr1073765758 ) ) {
7676: v@var4974 .@expr23935 intvalue@var4975 ++@expr1073765760 ; }
7677: if (@expr1073765761 v@var4974 .@expr1073765762 isIteratorEndValue (@expr1073765763 ) ) {
7678: v@var4974 .@expr23935 intvalue@var4975 --@expr1073765765 ; }
7679: setTokenValue (@expr1073765766 tok@var4968 , v@var4974 , settings@var4967 ) ;
7680: }
7681: }
7682: }
7683:
7684: static std :: vector < ValueFlow :: Value > getContainerValues ( const Token * tok@var4976 )
7685: {
7686: std ::@expr1073765767 vector < ValueFlow ::@expr1073765768 Value > values@var4977 ;
7687: if (@expr1073765769 tok@var4976 ) {
7688: std ::@expr1073765770 copy_if (@expr1073765771 tok@var4976 .@expr23948 values (@expr23949 ) .@expr1073765774 begin (@expr1073765775 ) ,
7689: tok@var4976 .@expr23948 values (@expr23949 ) .@expr1073765778 end (@expr1073765779 ) ,
7690: std ::@expr1073765780 back_inserter (@expr1073765781 values@var4977 ) ,
7691: std ::@expr1073765782 mem_fn (@expr1073765783 &@expr1073765784 ValueFlow ::@expr1073765785 Value ::@expr1073765786 isContainerSizeValue ) ) ;
7692: }
7693: return values@var4977 ;
7694: }
7695:
7696: static ValueFlow :: Value makeContainerSizeValue ( unsigned long s@var4978 , bool known@var4979 = true )
7697: {
7698: ValueFlow ::@expr1073765787 Value value@var4980 (@expr1073765788 s@var4978 ) ;
7699: value@var4980 .@expr1073765789 valueType@var4981 =@expr1073765790 ValueFlow ::@expr1073765791 Value ::@expr1073765792 ValueType ::@expr1073765793 CONTAINER_SIZE ;
7700: if (@expr1073765794 known@var4979 ) {
7701: value@var4980 .@expr1073765795 setKnown (@expr1073765796 ) ; }
7702: return value@var4980 ;
7703: }
7704:
7705: static std :: vector < ValueFlow :: Value > makeContainerSizeValue ( const Token * tok@var4982 , bool known@var4983 = true )
7706: {
7707: if (@expr1073765798 tok@var4982 .@expr1073765799 hasKnownIntValue (@expr1073765800 ) ) {
7708: return {@expr1073765801 makeContainerSizeValue (@expr1073765802 tok@var4982 .@expr1073765803 values (@expr1073765804 ) .@expr1073765805 front (@expr1073765806 ) .@expr1073765807 intvalue@expr1073765797 , known@var4983 ) } ; }
7709: return { } ;
7710: }
7711:
7712: static std :: vector < ValueFlow :: Value > getContainerSizeFromConstructorArgs ( const std :: vector < const Token * > & args@var4984 ,
7713: const Library :: Container * container@var4985 ,
7714: bool known@var4986 )
7715: {
7716: if (@expr1073765808 astIsIntegral (@expr1073765809 args@var4984 [@expr23986 0 ] , false ) ) {
7717: if (@expr1073765811 args@var4984 .@expr23988 size (@expr23989 ) ==@expr23990 1 ||@expr1073765815 (@expr1073765816 args@var4984 .@expr23988 size (@expr23989 ) >@expr1073765819 1 &&@expr1073765820 !@expr1073765821 astIsIntegral (@expr23998 args@var4984 [@expr23999 1 ] , false ) ) ) {
7718: return {@expr1073765824 makeContainerSizeValue (@expr1073765825 args@var4984 [@expr23986 0 ] , known@var4986 ) } ; }
7719: } else { if (@expr1073765827 astIsContainer (@expr24004 args@var4984 [@expr23986 0 ] ) &&@expr1073765830 args@var4984 .@expr23988 size (@expr23989 ) ==@expr23990 1 ) {
7720: return getContainerValues (@expr24010 args@var4984 [@expr23986 0 ] ) ;
7721: } else { if (@expr1073765836 isIteratorPair (@expr1073765837 args@var4984 ) ) {
7722: std ::@expr1073765838 vector < ValueFlow ::@expr1073765839 Value > result@var4987 ; result@var4987 =@expr1073765840 getContainerValues (@expr24010 args@var4984 [@expr23986 0 ] ) ;
7723: if (@expr1073765843 !@expr1073765844 result@var4987 .@expr1073765845 empty (@expr1073765846 ) ) {
7724: return result@var4987 ; }
7725:
7726: if (@expr1073765847 astIsPointer (@expr24024 args@var4984 [@expr23986 0 ] ) &&@expr1073765850 args@var4984 [@expr23986 0 ] .@expr24028 exprId (@expr24029 ) !=@expr1073765854 0 ) {
7727:
7728:
7729: if (@expr1073765855 args@var4984 [@expr23986 0 ] .@expr24028 exprId (@expr24029 ) ==@expr1073765859 args@var4984 [@expr23999 1 ] .@expr1073765861 exprId (@expr1073765862 ) ) {
7730: return {@expr1073765863 makeContainerSizeValue (@expr1073765864 unsigned long {@expr1073765865 0 } , known@var4986 ) } ; }
7731:
7732: if (@expr1073765866 Token ::@expr1073765867 simpleMatch (@expr1073765868 args@var4984 [@expr23999 1 ] , "+" ) ) {
7733: int eid@var4988 ; eid@var4988 =@expr1073765870 args@var4984 [@expr23986 0 ] .@expr24028 exprId (@expr24029 ) ;
7734: const Token * vartok@var4989 ; vartok@var4989 =@expr1073765874 args@var4984 [@expr23999 1 ] .@expr1073765876 astOperand1 (@expr1073765877 ) ;
7735: const Token * sizetok@var4990 ; sizetok@var4990 =@expr1073765878 args@var4984 [@expr23999 1 ] .@expr1073765880 astOperand2 (@expr1073765881 ) ;
7736: if (@expr1073765882 sizetok@var4990 .@expr1073765883 exprId (@expr1073765884 ) ==@expr1073765885 eid@var4988 ) {
7737: std ::@expr1073765886 swap (@expr1073765887 vartok@var4989 , sizetok@var4990 ) ; }
7738: if (@expr1073765888 vartok@var4989 .@expr1073765889 exprId (@expr1073765890 ) ==@expr1073765891 eid@var4988 &&@expr1073765892 sizetok@var4990 .@expr1073765893 hasKnownIntValue (@expr1073765894 ) ) {
7739: return {@expr1073765895 makeContainerSizeValue (@expr1073765896 sizetok@var4990 , known@var4986 ) } ; }
7740: }
7741: }
7742: } else { if (@expr1073765897 container@var4985 .@expr1073765898 stdStringLike@var4991 ) {
7743: if (@expr1073765899 astIsPointer (@expr24024 args@var4984 [@expr23986 0 ] ) ) {
7744:
7745: if (@expr1073765902 args@var4984 .@expr23988 size (@expr23989 ) ==@expr1073765905 2 &&@expr1073765906 astIsIntegral (@expr23998 args@var4984 [@expr23999 1 ] , false ) ) {
7746: return {@expr1073765909 makeContainerSizeValue (@expr1073765910 args@var4984 [@expr23999 1 ] , known@var4986 ) } ; }
7747: } else { if (@expr1073765912 astIsContainer (@expr24004 args@var4984 [@expr23986 0 ] ) ) {
7748: if (@expr1073765915 args@var4984 .@expr23988 size (@expr23989 ) ==@expr23990 1 ) {
7749: return getContainerValues (@expr24010 args@var4984 [@expr23986 0 ] ) ; }
7750: if (@expr1073765921 args@var4984 .@expr23988 size (@expr23989 ) ==@expr1073765924 3 ) {
7751: return {@expr1073765925 makeContainerSizeValue (@expr1073765926 args@var4984 [@expr1073765927 2 ] , known@var4986 ) } ; }
7752:
7753: } }
7754: } } } }
7755: return { } ;
7756: }
7757:
7758: static std :: vector < ValueFlow :: Value > getInitListSize ( const Token * tok@var4992 ,
7759: const ValueType * valueType@var4993 ,
7760: const Settings * settings@var4994 ,
7761: bool known@var4995 = true )
7762: {
7763: std ::@expr1073765928 vector < const Token *@expr1073765929 > args@var4996 ; args@var4996 =@expr1073765930 getArguments (@expr1073765931 tok@var4992 ) ;
7764: if (@expr1073765932 args@var4996 .@expr1073765933 empty (@expr1073765934 ) ) {
7765: return {@expr1073765935 makeContainerSizeValue (@expr1073765936 unsigned long {@expr1073765937 0 } , known@var4995 ) } ; }
7766: bool initList@var4997 ; initList@var4997 =@expr1073765938 true ;
7767:
7768: if (@expr1073765939 args@var4996 .@expr24116 size (@expr24117 ) <@expr1073765942 4 ) {
7769: initList@var4997 =@expr1073765943 !@expr1073765944 isIteratorPair (@expr1073765945 args@var4996 ) &&@expr1073765946 !@expr1073765947 (@expr1073765948 args@var4996 .@expr24116 size (@expr24117 ) <@expr1073765951 3 &&@expr1073765952 astIsIntegral (@expr24129 args@var4996 [@expr24130 0 ] , false ) ) ;
7770: const Token * containerTypeToken@var4998 ; containerTypeToken@var4998 =@expr1073765955 valueType@var4993 .@expr1073765956 containerTypeToken@var4999 ;
7771: if (@expr1073765957 valueType@var4993 .@expr24134 container@var5000 .@expr1073765959 stdStringLike@var5001 ) {
7772: initList@var4997 =@expr1073765960 astIsGenericChar (@expr1073765961 args@var4996 [@expr24130 0 ] ) &&@expr1073765963 !@expr1073765964 astIsPointer (@expr24141 args@var4996 [@expr24130 0 ] ) ;
7773: } else { if (@expr1073765967 containerTypeToken@var4998 &&@expr1073765968 settings@var4994 ) {
7774: ValueType vt@var5002 ; vt@var5002 =@expr1073765969 ValueType ::@expr1073765970 parseDecl (@expr1073765971 containerTypeToken@var4998 , settings@var4994 ) ;
7775: if (@expr1073765972 vt@var5002 .@expr1073765973 pointer@var5003 >@expr1073765974 0 &&@expr1073765975 astIsPointer (@expr24141 args@var4996 [@expr24130 0 ] ) ) {
7776: initList@var4997 =@expr1073765978 true ; }
7777: else { if (@expr1073765979 vt@var5002 .@expr1073765980 type@var5004 ==@expr1073765981 ValueType ::@expr1073765982 ITERATOR &&@expr1073765983 astIsIterator (@expr1073765984 args@var4996 [@expr24130 0 ] ) ) {
7778: initList@var4997 =@expr1073765986 true ; }
7779: else { if (@expr1073765987 vt@var5002 .@expr1073765988 isIntegral (@expr1073765989 ) &&@expr1073765990 astIsIntegral (@expr24129 args@var4996 [@expr24130 0 ] , false ) ) {
7780: initList@var4997 =@expr1073765993 true ; } } }
7781: } }
7782: }
7783: if (@expr1073765994 !@expr1073765995 initList@var4997 ) {
7784: return getContainerSizeFromConstructorArgs (@expr1073765996 args@var4996 , valueType@var4993 .@expr24134 container@var5000 , known@var4995 ) ; }
7785: return {@expr1073765998 makeContainerSizeValue (@expr1073765999 args@var4996 .@expr24116 size (@expr24117 ) , known@var4995 ) } ;
7786: }
7787:
7788: static std :: vector < ValueFlow :: Value > getContainerSizeFromConstructor ( const Token * tok@var5005 ,
7789: const ValueType * valueType@var5006 ,
7790: const Settings * settings@var5007 ,
7791: bool known@var5008 = true )
7792: {
7793: std ::@expr1073766002 vector < const Token *@expr1073766003 > args@var5009 ; args@var5009 =@expr1073766004 getArguments (@expr1073766005 tok@var5005 ) ;
7794: if (@expr1073766006 args@var5009 .@expr1073766007 empty (@expr1073766008 ) ) {
7795: return {@expr1073766009 makeContainerSizeValue (@expr1073766010 unsigned long {@expr1073766011 0 } , known@var5008 ) } ; }
7796:
7797: if (@expr1073766012 args@var5009 .@expr1073766013 size (@expr1073766014 ) ==@expr1073766015 1 &&@expr1073766016 Token ::@expr1073766017 simpleMatch (@expr1073766018 args@var5009 [@expr24195 0 ] , "{" ) ) {
7798: return getInitListSize (@expr1073766020 args@var5009 [@expr24195 0 ] , valueType@var5006 , settings@var5007 , known@var5008 ) ; }
7799: return getContainerSizeFromConstructorArgs (@expr1073766022 args@var5009 , valueType@var5006 .@expr1073766023 container@var5010 , known@var5008 ) ;
7800: }
7801:
7802: static void valueFlowContainerSize ( TokenList * tokenlist@var5011 ,
7803: SymbolDatabase * symboldatabase@var5012 ,
7804: ErrorLogger * ,
7805: const Settings * settings@var5013 )
7806: {
7807:
7808: for (@expr1073766026 const Variable *@expr24203 var@var5014 :@expr1073766028 symboldatabase@var5012 .@expr1073766029 variableList (@expr1073766030 ) ) {
7809: if (@expr1073766031 !@expr1073766032 var@var5014 ) {
7810: continue ; }
7811: if (@expr1073766033 !@expr1073766034 var@var5014 .@expr24211 scope (@expr24212 ) ||@expr1073766037 !@expr1073766038 var@var5014 .@expr24211 scope (@expr24212 ) .@expr24217 bodyEnd@var5330 ||@expr1073766042 !@expr1073766043 var@var5014 .@expr24211 scope (@expr24212 ) .@expr1073766046 bodyStart@var5337 ) {
7812: continue ; }
7813: if (@expr1073766047 !@expr1073766048 var@var5014 .@expr24225 valueType (@expr24226 ) ||@expr1073766051 !@expr1073766052 var@var5014 .@expr24225 valueType (@expr24226 ) .@expr24231 container@var5335 ) {
7814: continue ; }
7815: if (@expr1073766056 !@expr1073766057 astIsContainer (@expr1073766058 var@var5014 .@expr24235 nameToken (@expr24236 ) ) ) {
7816: continue ; }
7817:
7818: bool known@var5015 ; known@var5015 =@expr1073766061 true ;
7819: int size@var5016 ; size@var5016 =@expr1073766062 0 ;
7820: bool nonLocal@var5017 ; nonLocal@var5017 =@expr1073766063 !@expr1073766064 var@var5014 .@expr1073766065 isLocal (@expr1073766066 ) ||@expr1073766067 var@var5014 .@expr1073766068 isPointer (@expr1073766069 ) ||@expr1073766070 var@var5014 .@expr1073766071 isReference (@expr1073766072 ) ||@expr1073766073 var@var5014 .@expr1073766074 isStatic (@expr1073766075 ) ;
7821: bool constSize@var5018 ; constSize@var5018 =@expr1073766076 var@var5014 .@expr1073766077 isConst (@expr1073766078 ) &&@expr1073766079 !@expr1073766080 nonLocal@var5017 ;
7822: bool staticSize@var5019 ; staticSize@var5019 =@expr1073766081 false ;
7823: if (@expr1073766082 var@var5014 .@expr24225 valueType (@expr24226 ) .@expr24231 container@var5335 .@expr1073766086 size_templateArgNo@var5338 >=@expr1073766087 0 ) {
7824: staticSize@var5019 =@expr1073766088 true ;
7825: constSize@var5018 =@expr1073766089 true ;
7826: size@var5016 =@expr1073766090 -1 ;
7827: if (@expr1073766091 var@var5014 .@expr24268 dimensions (@expr24269 ) .@expr1073766094 size (@expr1073766095 ) ==@expr1073766096 1 ) {
7828: const Dimension &@expr24273 dim@var5020 =@expr1073766098 var@var5014 .@expr24268 dimensions (@expr24269 ) .@expr1073766101 front (@expr1073766102 ) ;
7829: if (@expr1073766103 dim@var5020 .@expr1073766104 known@var5021 ) {
7830: size@var5016 =@expr1073766105 dim@var5020 .@expr1073766106 num@var5022 ;
7831: } else { if (@expr1073766107 dim@var5020 .@expr24284 tok@var5023 &&@expr1073766109 dim@var5020 .@expr24284 tok@var5023 .@expr1073766111 hasKnownIntValue (@expr1073766112 ) ) {
7832: size@var5016 =@expr1073766113 dim@var5020 .@expr24284 tok@var5023 .@expr1073766115 values (@expr1073766116 ) .@expr1073766117 front (@expr1073766118 ) .@expr1073766119 intvalue@expr1073766024 ;
7833: } }
7834: }
7835: if (@expr1073766120 size@var5016 <@expr1073766121 0 ) {
7836: continue ; }
7837: }
7838: if (@expr1073766122 !@expr24299 staticSize@var5019 &&@expr1073766124 nonLocal@var5017 ) {
7839: continue ; }
7840: if (@expr1073766125 var@var5014 .@expr24235 nameToken (@expr24236 ) .@expr1073766128 hasKnownValue (@expr1073766129 ValueFlow ::@expr24306 Value ::@expr24307 ValueType ::@expr24308 CONTAINER_SIZE ) ) {
7841: continue ; }
7842: if (@expr24309 !@expr24299 staticSize@var5019 ) {
7843: if (@expr1073766135 !@expr1073766136 Token ::@expr24313 Match (@expr1073766138 var@var5014 .@expr24235 nameToken (@expr24236 ) , "%name% ;" ) &&@expr1073766141
7844: !@expr1073766142 (@expr1073766143 Token ::@expr24313 Match (@expr1073766145 var@var5014 .@expr24235 nameToken (@expr24236 ) , "%name% {" ) &&@expr1073766148
7845: Token ::@expr24325 simpleMatch (@expr1073766150 var@var5014 .@expr24235 nameToken (@expr24236 ) .@expr24329 next (@expr24330 ) .@expr1073766155 link (@expr1073766156 ) , "} ;" ) ) &&@expr1073766157
7846: !@expr1073766158 Token ::@expr24313 Match (@expr1073766160 var@var5014 .@expr24235 nameToken (@expr24236 ) , "%name% (" ) ) {
7847: continue ; }
7848: }
7849: if (@expr1073766163 var@var5014 .@expr24235 nameToken (@expr24236 ) .@expr24342 astTop (@expr24343 ) &&@expr1073766168 Token ::@expr24313 Match (@expr1073766170 var@var5014 .@expr24235 nameToken (@expr24236 ) .@expr24342 astTop (@expr24343 ) .@expr1073766175 previous (@expr1073766176 ) , "for|while" ) ) {
7850: known@var5015 =@expr1073766177 !@expr1073766178 isVariableChanged (@expr1073766179 var@var5014 , settings@var5013 , true ) ; }
7851: std ::@expr24356 vector < ValueFlow ::@expr24356 Value > values@var5024 {@expr1073766182 ValueFlow ::@expr24306 Value {@expr1073766184 size@var5016 } } ;
7852: values@var5024 .@expr24361 back (@expr24362 ) .@expr1073766187 valueType@expr1073766025 =@expr1073766188 ValueFlow ::@expr24306 Value ::@expr24307 ValueType ::@expr24308 CONTAINER_SIZE ;
7853: if (@expr1073766192 known@var5015 ) {
7854: values@var5024 .@expr24361 back (@expr24362 ) .@expr1073766195 setKnown (@expr1073766196 ) ; }
7855: if (@expr24309 !@expr24299 staticSize@var5019 ) {
7856: if (@expr1073766199 Token ::@expr24325 simpleMatch (@expr1073766201 var@var5014 .@expr24235 nameToken (@expr24236 ) .@expr24329 next (@expr24330 ) , "{" ) ) {
7857: const Token * initList@var5025 ; initList@var5025 =@expr1073766206 var@var5014 .@expr24235 nameToken (@expr24236 ) .@expr24329 next (@expr24330 ) ;
7858: values@var5024 =@expr1073766211 getInitListSize (@expr1073766212 initList@var5025 , var@var5014 .@expr24225 valueType (@expr24226 ) , settings@var5013 , known@var5015 ) ;
7859: } else { if (@expr1073766215 Token ::@expr24325 simpleMatch (@expr1073766217 var@var5014 .@expr24235 nameToken (@expr24236 ) .@expr24329 next (@expr24330 ) , "(" ) ) {
7860: const Token * constructorArgs@var5026 ; constructorArgs@var5026 =@expr1073766222 var@var5014 .@expr24235 nameToken (@expr24236 ) .@expr24329 next (@expr24330 ) ;
7861: values@var5024 =@expr1073766227 getContainerSizeFromConstructor (@expr1073766228 constructorArgs@var5026 , var@var5014 .@expr24225 valueType (@expr24226 ) , settings@var5013 , known@var5015 ) ;
7862: } }
7863: }
7864: for (@expr1073766231 const ValueFlow ::@expr24356 Value &@expr24273 value@var5027 :@expr1073766234 values@var5024 ) {
7865: if (@expr1073766235 constSize@var5018 ) {
7866: valueFlowForwardConst (@expr1073766236 var@var5014 .@expr24235 nameToken (@expr24236 ) .@expr24329 next (@expr24330 ) , var@var5014 .@expr24211 scope (@expr24212 ) .@expr24217 bodyEnd@var5330 , var@var5014 , values@var5024 , settings@var5013 ) ; }
7867: else {
7868: valueFlowContainerForward (@expr1073766244 var@var5014 .@expr24235 nameToken (@expr24236 ) .@expr24329 next (@expr24330 ) , var@var5014 .@expr24235 nameToken (@expr24236 ) , value@var5027 , tokenlist@var5011 ) ; }
7869: }
7870: }
7871:
7872:
7873: for (@expr1073766251 const Scope *@expr24203 functionScope@var5028 :@expr1073766253 symboldatabase@var5012 .@expr1073766254 functionScopes@var5029 ) {
7874: for (@expr1073766255 const Token *@expr24203 tok@var5030 =@expr1073766257 functionScope@var5028 .@expr1073766258 bodyStart@var5031 ; tok@var5030 !=@expr1073766259 functionScope@var5028 .@expr1073766260 bodyEnd@var5032 ; tok@var5030 =@expr1073766261 tok@var5030 .@expr24438 next (@expr24439 ) ) {
7875: if (@expr1073766264 Token ::@expr24313 Match (@expr1073766266 tok@var5030 , "%name%|;|{|} %var% = %str% ;" ) ) {
7876: const Token * containerTok@var5033 ; containerTok@var5033 =@expr1073766267 tok@var5030 .@expr24438 next (@expr24439 ) ;
7877: if (@expr1073766270 containerTok@var5033 .@expr1073766271 exprId (@expr1073766272 ) ==@expr1073766273 0 ) {
7878: continue ; }
7879: if (@expr1073766274 containerTok@var5033 .@expr24451 valueType (@expr24452 ) &&@expr1073766277 containerTok@var5033 .@expr24451 valueType (@expr24452 ) .@expr24456 container@var5335 &&@expr1073766281 containerTok@var5033 .@expr24451 valueType (@expr24452 ) .@expr24456 container@var5335 .@expr1073766285 stdStringLike@var5339 ) {
7880: ValueFlow ::@expr1073766286 Value value@var5034 (@expr1073766287 Token ::@expr1073766288 getStrLength (@expr1073766289 containerTok@var5033 .@expr1073766290 tokAt (@expr1073766291 2 ) ) ) ;
7881: value@var5034 .@expr1073766292 valueType@var5035 =@expr1073766293 ValueFlow ::@expr24306 Value ::@expr24307 ValueType ::@expr24308 CONTAINER_SIZE ;
7882: value@var5034 .@expr1073766297 setKnown (@expr1073766298 ) ;
7883: valueFlowContainerForward (@expr1073766299 containerTok@var5033 .@expr1073766300 next (@expr1073766301 ) , containerTok@var5033 , value@var5034 , tokenlist@var5011 ) ;
7884: }
7885: } else { if (@expr1073766302 Token ::@expr24313 Match (@expr1073766304 tok@var5030 , "%name%|;|{|}|> %var% = {" ) &&@expr1073766305 Token ::@expr24325 simpleMatch (@expr1073766307 tok@var5030 .@expr1073766308 linkAt (@expr1073766309 3 ) , "} ;" ) ) {
7886: const Token * containerTok@var5036 ; containerTok@var5036 =@expr1073766310 tok@var5030 .@expr24438 next (@expr24439 ) ;
7887: if (@expr1073766313 containerTok@var5036 .@expr1073766314 exprId (@expr1073766315 ) ==@expr1073766316 0 ) {
7888: continue ; }
7889: if (@expr1073766317 astIsContainer (@expr1073766318 containerTok@var5036 ) &&@expr1073766319 containerTok@var5036 .@expr24496 valueType (@expr24497 ) .@expr1073766322 container@var5335 .@expr1073766323 size_templateArgNo@var5338 <@expr1073766324 0 ) {
7890: std ::@expr1073766325 vector < ValueFlow ::@expr24356 Value > values@var5037 ; values@var5037 =@expr1073766327
7891: getInitListSize (@expr1073766328 tok@var5030 .@expr24505 tokAt (@expr1073766330 3 ) , containerTok@var5036 .@expr24496 valueType (@expr24497 ) , settings@var5013 ) ;
7892: for (@expr1073766333 const ValueFlow ::@expr24356 Value &@expr24273 value@var5038 :@expr1073766336 values@var5037 ) {
7893: valueFlowContainerForward (@expr1073766337 containerTok@var5036 .@expr1073766338 next (@expr1073766339 ) , containerTok@var5036 , value@var5038 , tokenlist@var5011 ) ; }
7894: }
7895: } else { if (@expr1073766340 Token ::@expr24313 Match (@expr1073766342 tok@var5030 , ". %name% (" ) &&@expr1073766343 tok@var5030 .@expr24520 astOperand1 (@expr24521 ) &&@expr1073766346 tok@var5030 .@expr24520 astOperand1 (@expr24521 ) .@expr24525 valueType (@expr24526 ) &&@expr1073766351
7896: tok@var5030 .@expr24520 astOperand1 (@expr24521 ) .@expr24525 valueType (@expr24526 ) .@expr1073766356 container@var5343 ) {
7897: const Token * containerTok@var5039 ; containerTok@var5039 =@expr1073766357 tok@var5030 .@expr24520 astOperand1 (@expr24521 ) ;
7898: if (@expr1073766360 containerTok@var5039 .@expr1073766361 exprId (@expr1073766362 ) ==@expr1073766363 0 ) {
7899: continue ; }
7900: Library ::@expr24540 Container ::@expr1073766365 Action action@var5040 ; action@var5040 =@expr1073766366 containerTok@var5039 .@expr1073766367 valueType (@expr1073766368 ) .@expr1073766369 container@var5335 .@expr1073766370 getAction (@expr1073766371 tok@var5030 .@expr1073766372 strAt (@expr1073766373 1 ) ) ;
7901: if (@expr1073766374 action@var5040 ==@expr1073766375 Library ::@expr24540 Container ::@expr24553 Action ::@expr1073766378 CLEAR ) {
7902: ValueFlow ::@expr1073766379 Value value@var5041 (@expr1073766380 0 ) ;
7903: value@var5041 .@expr1073766381 valueType@var5042 =@expr1073766382 ValueFlow ::@expr24306 Value ::@expr24307 ValueType ::@expr24308 CONTAINER_SIZE ;
7904: value@var5041 .@expr1073766386 setKnown (@expr1073766387 ) ;
7905: valueFlowContainerForward (@expr1073766388 tok@var5030 .@expr24438 next (@expr24439 ) , containerTok@var5039 , value@var5041 , tokenlist@var5011 ) ;
7906: } else { if (@expr1073766391 action@var5040 ==@expr1073766392 Library ::@expr24540 Container ::@expr24553 Action ::@expr1073766395 RESIZE &&@expr1073766396 tok@var5030 .@expr24505 tokAt (@expr24574 2 ) .@expr24575 astOperand2 (@expr24576 ) &&@expr1073766401
7907: tok@var5030 .@expr24505 tokAt (@expr24574 2 ) .@expr24575 astOperand2 (@expr24576 ) .@expr1073766406 hasKnownIntValue (@expr1073766407 ) ) {
7908: ValueFlow ::@expr1073766408 Value value@var5043 (@expr1073766409 tok@var5030 .@expr24505 tokAt (@expr24574 2 ) .@expr24575 astOperand2 (@expr24576 ) .@expr1073766414 values (@expr1073766415 ) .@expr1073766416 front (@expr1073766417 ) ) ;
7909: value@var5043 .@expr1073766418 valueType@var5044 =@expr1073766419 ValueFlow ::@expr24306 Value ::@expr24307 ValueType ::@expr24308 CONTAINER_SIZE ;
7910: value@var5043 .@expr1073766423 setKnown (@expr1073766424 ) ;
7911: valueFlowContainerForward (@expr1073766425 tok@var5030 .@expr24438 next (@expr24439 ) , containerTok@var5039 , value@var5043 , tokenlist@var5011 ) ;
7912: } }
7913: } } }
7914: }
7915: }
7916: }
7917:
7918: struct ContainerConditionHandler : ConditionHandler {
7919: virtual Analyzer :: Result forward ( Token * start@var5045 ,
7920: const Token * stop@var5046 ,
7921: const Token * exprTok@var5047 ,
7922: const std :: list < ValueFlow :: Value > & values@var5048 ,
7923: TokenList * tokenlist@var5049 ,
7924: const Settings * ) const override {
7925: Analyzer ::@expr24604 Result result@var5050 {@expr1073766429 } ;
7926: for (@expr1073766430 const ValueFlow ::@expr24604 Value &@expr1073766432 value@var5051 :@expr1073766433 values@var5048 ) {
7927: result@var5050 .@expr1073766434 update (@expr1073766435 valueFlowContainerForward (@expr1073766436 start@var5045 .@expr1073766437 next (@expr1073766438 ) , stop@var5046 , exprTok@var5047 , value@var5051 , tokenlist@var5049 ) ) ; }
7928: return result@var5050 ;
7929: }
7930:
7931: virtual Analyzer :: Result forward ( Token * top@var5052 ,
7932: const Token * exprTok@var5053 ,
7933: const std :: list < ValueFlow :: Value > & values@var5054 ,
7934: TokenList * tokenlist@var5055 ,
7935: const Settings * ) const override {
7936: Analyzer ::@expr24615 Result result@var5056 {@expr1073766440 } ;
7937: for (@expr1073766441 const ValueFlow ::@expr24615 Value &@expr1073766443 value@var5057 :@expr1073766444 values@var5054 ) {
7938: result@var5056 .@expr1073766445 update (@expr1073766446 valueFlowContainerForwardRecursive (@expr1073766447 top@var5052 , exprTok@var5053 , value@var5057 , tokenlist@var5055 ) ) ; }
7939: return result@var5056 ;
7940: }
7941:
7942: virtual void reverse ( Token * start@var5058 ,
7943: const Token * endTok@var5059 ,
7944: const Token * exprTok@var5060 ,
7945: const std :: list < ValueFlow :: Value > & values@var5061 ,
7946: TokenList * tokenlist@var5062 ,
7947: const Settings * settings@var5063 ) const override {
7948: return valueFlowContainerReverse (@expr1073766448 start@var5058 , endTok@var5059 , exprTok@var5060 , values@var5061 , tokenlist@var5062 , settings@var5063 ) ;
7949: }
7950:
7951: virtual std :: vector < Condition > parse ( const Token * tok@var5064 , const Settings * settings@var5065 ) const override
7952: {
7953: Condition cond@var5066 ;
7954: ValueFlow ::@expr1073766449 Value true_value@var5067 ;
7955: ValueFlow ::@expr1073766450 Value false_value@var5068 ;
7956: const Token * vartok@var5069 ; vartok@var5069 =@expr1073766451 parseCompareInt (@expr1073766452 tok@var5064 , true_value@var5067 , false_value@var5068 ) ;
7957: if (@expr1073766453 vartok@var5069 ) {
7958: vartok@var5069 =@expr1073766454 settings@var5065 .@expr24631 library@var5070 .@expr24632 getContainerFromYield (@expr1073766457 vartok@var5069 , Library ::@expr24634 Container ::@expr24635 Yield ::@expr1073766460 SIZE ) ;
7959: if (@expr24637 !@expr24638 vartok@var5069 ) {
7960: return { } ; }
7961: true_value@var5067 .@expr1073766463 valueType@var5071 =@expr1073766464 ValueFlow ::@expr24641 Value ::@expr24642 ValueType ::@expr24643 CONTAINER_SIZE ;
7962: false_value@var5068 .@expr1073766468 valueType@var5072 =@expr1073766469 ValueFlow ::@expr24641 Value ::@expr24642 ValueType ::@expr24643 CONTAINER_SIZE ;
7963: cond@var5066 .@expr24649 true_values@var5073 .@expr1073766474 push_back (@expr1073766475 true_value@var5067 ) ;
7964: cond@var5066 .@expr24652 false_values@var5074 .@expr1073766477 push_back (@expr1073766478 false_value@var5068 ) ;
7965: cond@var5066 .@expr24655 vartok@var5075 =@expr1073766480 vartok@var5069 ;
7966: return {@expr1073766481 cond@var5066 } ;
7967: }
7968:
7969:
7970: if (@expr1073766482 tok@var5064 .@expr1073766483 str (@expr1073766484 ) ==@expr1073766485 "(" ) {
7971: vartok@var5069 =@expr1073766486 settings@var5065 .@expr24631 library@var5070 .@expr24632 getContainerFromYield (@expr1073766489 tok@var5064 , Library ::@expr24634 Container ::@expr24635 Yield ::@expr1073766492 EMPTY ) ;
7972:
7973: if (@expr24637 !@expr24638 vartok@var5069 ) {
7974: return { } ; }
7975: const Token * parent@var5076 ; parent@var5076 =@expr1073766495 tok@var5064 .@expr1073766496 astParent (@expr1073766497 ) ;
7976: while (@expr1073766498 parent@var5076 ) {
7977: if (@expr1073766499 Token ::@expr24676 Match (@expr1073766501 parent@var5076 , "%comp%" ) ) {
7978: return { } ; }
7979: parent@var5076 =@expr1073766502 parent@var5076 .@expr1073766503 astParent (@expr1073766504 ) ;
7980: }
7981: ValueFlow ::@expr1073766505 Value value@var5077 (@expr1073766506 tok@var5064 , 0LL ) ;
7982: value@var5077 .@expr1073766507 valueType@var5078 =@expr1073766508 ValueFlow ::@expr24641 Value ::@expr24642 ValueType ::@expr24643 CONTAINER_SIZE ;
7983: cond@var5066 .@expr24649 true_values@var5073 .@expr24689 emplace_back (@expr1073766514 value@var5077 ) ;
7984: cond@var5066 .@expr24652 false_values@var5074 .@expr24692 emplace_back (@expr1073766517 std ::@expr24694 move (@expr1073766519 value@var5077 ) ) ;
7985: cond@var5066 .@expr24655 vartok@var5075 =@expr1073766521 vartok@var5069 ;
7986: cond@var5066 .@expr1073766522 inverted@var5079 =@expr1073766523 true ;
7987: return {@expr1073766524 cond@var5066 } ;
7988: }
7989:
7990: if (@expr1073766525 Token ::@expr24676 Match (@expr1073766527 tok@var5064 , "==|!=" ) ) {
7991: const Token * strtok@var5080 ; strtok@var5080 =@expr1073766528 nullptr ;
7992: if (@expr1073766529 Token ::@expr24676 Match (@expr1073766531 tok@var5064 .@expr24708 astOperand1 (@expr24709 ) , "%str%" ) ) {
7993: strtok@var5080 =@expr1073766534 tok@var5064 .@expr24708 astOperand1 (@expr24709 ) ;
7994: vartok@var5069 =@expr1073766537 tok@var5064 .@expr24714 astOperand2 (@expr24715 ) ;
7995: } else { if (@expr1073766540 Token ::@expr24676 Match (@expr1073766542 tok@var5064 .@expr24714 astOperand2 (@expr24715 ) , "%str%" ) ) {
7996: strtok@var5080 =@expr1073766545 tok@var5064 .@expr24714 astOperand2 (@expr24715 ) ;
7997: vartok@var5069 =@expr1073766548 tok@var5064 .@expr24708 astOperand1 (@expr24709 ) ;
7998: } }
7999: if (@expr1073766551 !@expr1073766552 strtok@var5080 ) {
8000: return { } ; }
8001: if (@expr1073766553 !@expr1073766554 astIsContainer (@expr1073766555 vartok@var5069 ) ) {
8002: return { } ; }
8003: ValueFlow ::@expr1073766556 Value value@var5081 (@expr1073766557 tok@var5064 , Token ::@expr1073766558 getStrLength (@expr1073766559 strtok@var5080 ) ) ;
8004: value@var5081 .@expr1073766560 valueType@var5082 =@expr1073766561 ValueFlow ::@expr24641 Value ::@expr24642 ValueType ::@expr24643 CONTAINER_SIZE ;
8005: cond@var5066 .@expr24652 false_values@var5074 .@expr24692 emplace_back (@expr1073766567 value@var5081 ) ;
8006: cond@var5066 .@expr24649 true_values@var5073 .@expr24689 emplace_back (@expr1073766570 std ::@expr24694 move (@expr1073766572 value@var5081 ) ) ;
8007: cond@var5066 .@expr24655 vartok@var5075 =@expr1073766574 vartok@var5069 ;
8008: cond@var5066 .@expr1073766575 impossible@var5083 =@expr1073766576 false ;
8009: return {@expr1073766577 cond@var5066 } ;
8010: }
8011: return { } ;
8012: }
8013: } ;
8014:
8015: static void valueFlowDynamicBufferSize ( TokenList * tokenlist@var5084 , SymbolDatabase * symboldatabase@var5085 , const Settings * settings@var5086 )
8016: {
8017: auto getBufferSizeFromAllocFunc@var5087 ; getBufferSizeFromAllocFunc@var5087 =@expr1073766578 [@expr1073766579 &@expr24756 ] (@expr1073766581 const Token *@expr24758 funcTok@var5088 ) .@expr24759 long long {
8018: long long sizeValue@var5089 ; sizeValue@var5089 =@expr1073766584 -1 ;
8019: const Library ::@expr24761 AllocFunc * allocFunc@var5090 ; allocFunc@var5090 =@expr1073766586 settings@var5086 .@expr24763 library@var5091 .@expr1073766588 getAllocFuncInfo (@expr1073766589 funcTok@var5088 ) ;
8020: if (@expr1073766590 !@expr24767 allocFunc@var5090 ) {
8021: allocFunc@var5090 =@expr1073766592 settings@var5086 .@expr24763 library@var5091 .@expr1073766594 getReallocFuncInfo (@expr1073766595 funcTok@var5088 ) ; }
8022: if (@expr1073766596 !@expr24767 allocFunc@var5090 ||@expr1073766598 allocFunc@var5090 .@expr24775 bufferSize@var5092 ==@expr1073766600 Library ::@expr24761 AllocFunc ::@expr24778 BufferSize ::@expr24779 none ) {
8023: return sizeValue@var5089 ; }
8024:
8025: const std ::@expr1073766604 vector < const Token *@expr24758 > args@var5093 =@expr1073766606 getArguments (@expr1073766607 funcTok@var5088 ) ;
8026:
8027: const Token * const arg1@var5094 ; arg1@var5094 =@expr1073766608 (@expr1073766609 args@var5093 .@expr24786 size (@expr24787 ) >=@expr1073766612 allocFunc@var5090 .@expr24789 bufferSizeArg1@var5095 ) ?@expr1073766614 args@var5093 [@expr1073766615 allocFunc@var5090 .@expr24789 bufferSizeArg1@var5095 -@expr1073766617 1 ] :@expr1073766618 nullptr ;
8028: const Token * const arg2@var5096 ; arg2@var5096 =@expr1073766619 (@expr1073766620 args@var5093 .@expr24786 size (@expr24787 ) >=@expr1073766623 allocFunc@var5090 .@expr24800 bufferSizeArg2@var5097 ) ?@expr1073766625 args@var5093 [@expr1073766626 allocFunc@var5090 .@expr24800 bufferSizeArg2@var5097 -@expr1073766628 1 ] :@expr1073766629 nullptr ;
8029:
8030: switch (@expr1073766630 allocFunc@var5090 .@expr24775 bufferSize@var5092 ) {
8031: case Library ::@expr24761 AllocFunc ::@expr24778 BufferSize ::@expr24779 none :@expr24811 ;
8032: break ;
8033: case Library ::@expr24761 AllocFunc ::@expr24778 BufferSize ::@expr1073766638 malloc :@expr24811 ;
8034: if (@expr1073766640 arg1@var5094 &&@expr1073766641 arg1@var5094 .@expr24818 hasKnownIntValue (@expr24819 ) ) {
8035: sizeValue@var5089 =@expr1073766644 arg1@var5094 .@expr24821 getKnownIntValue (@expr24822 ) ; }
8036: break ;
8037: case Library ::@expr24761 AllocFunc ::@expr24778 BufferSize ::@expr1073766649 calloc :@expr24811 ;
8038: if (@expr1073766651 arg1@var5094 &&@expr1073766652 arg2@var5096 &&@expr1073766653 arg1@var5094 .@expr24818 hasKnownIntValue (@expr24819 ) &&@expr1073766656 arg2@var5096 .@expr1073766657 hasKnownIntValue (@expr1073766658 ) ) {
8039: sizeValue@var5089 =@expr1073766659 arg1@var5094 .@expr24821 getKnownIntValue (@expr24822 ) *@expr1073766662 arg2@var5096 .@expr1073766663 getKnownIntValue (@expr1073766664 ) ; }
8040: break ;
8041: case Library ::@expr24761 AllocFunc ::@expr24778 BufferSize ::@expr1073766667 strdup :@expr24811 ;
8042: if (@expr1073766669 arg1@var5094 &&@expr1073766670 arg1@var5094 .@expr1073766671 hasKnownValue (@expr1073766672 ) ) {
8043: const ValueFlow ::@expr24849 Value &@expr24756 value@var5098 =@expr1073766675 arg1@var5094 .@expr1073766676 values (@expr1073766677 ) .@expr1073766678 back (@expr1073766679 ) ;
8044: if (@expr1073766680 value@var5098 .@expr1073766681 isTokValue (@expr1073766682 ) &&@expr1073766683 value@var5098 .@expr24860 tokvalue@var5099 .@expr1073766685 tokType (@expr1073766686 ) ==@expr1073766687 Token ::@expr1073766688 eString ) {
8045: sizeValue@var5089 =@expr1073766689 Token ::@expr1073766690 getStrLength (@expr1073766691 value@var5098 .@expr24860 tokvalue@var5099 ) +@expr1073766693 1 ; }
8046: }
8047: break ;
8048: }
8049: return sizeValue@var5089 ;
8050: } ;
8051:
8052: auto getBufferSizeFromNew@var5100 ; getBufferSizeFromNew@var5100 =@expr1073766694 [@expr1073766695 &@expr24756 ] (@expr1073766697 const Token *@expr24758 newTok@var5101 ) .@expr24759 long long {
8053: long long sizeValue@var5102 ; sizeValue@var5102 =@expr1073766700 -1 ; long long numElem@var5103 ; numElem@var5103 =@expr1073766701 -1 ;
8054:
8055: if (@expr1073766702 newTok@var5101 &&@expr1073766703 newTok@var5101 .@expr24880 astOperand1 (@expr24881 ) ) {
8056: const Token * bracTok@var5104 ; bracTok@var5104 =@expr1073766706 nullptr ; const Token * typeTok@var5105 ; typeTok@var5105 =@expr1073766707 nullptr ;
8057: if (@expr1073766708 newTok@var5101 .@expr24880 astOperand1 (@expr24881 ) .@expr24887 str (@expr24888 ) ==@expr1073766713 "[" ) {
8058: bracTok@var5104 =@expr1073766714 newTok@var5101 .@expr24880 astOperand1 (@expr24881 ) ; }
8059: else { if (@expr1073766717 newTok@var5101 .@expr24880 astOperand1 (@expr24881 ) .@expr24887 str (@expr24888 ) ==@expr1073766722 "(" ) {
8060: if (@expr1073766723 newTok@var5101 .@expr24880 astOperand1 (@expr24881 ) .@expr24902 astOperand1 (@expr24903 ) &&@expr1073766728 newTok@var5101 .@expr24880 astOperand1 (@expr24881 ) .@expr24902 astOperand1 (@expr24903 ) .@expr1073766733 str (@expr1073766734 ) ==@expr1073766735 "[" ) {
8061: bracTok@var5104 =@expr1073766736 newTok@var5101 .@expr24880 astOperand1 (@expr24881 ) .@expr24902 astOperand1 (@expr24903 ) ; }
8062: else {
8063: typeTok@var5105 =@expr1073766741 newTok@var5101 .@expr24880 astOperand1 (@expr24881 ) .@expr24902 astOperand1 (@expr24903 ) ; }
8064: }
8065: else {
8066: typeTok@var5105 =@expr1073766746 newTok@var5101 .@expr24880 astOperand1 (@expr24881 ) ;
8067: if (@expr1073766749 typeTok@var5105 .@expr1073766750 str (@expr1073766751 ) ==@expr1073766752 "{" ) {
8068: typeTok@var5105 =@expr1073766753 typeTok@var5105 .@expr1073766754 astOperand1 (@expr1073766755 ) ; }
8069: } }
8070: if (@expr1073766756 bracTok@var5104 &&@expr1073766757 bracTok@var5104 .@expr24934 astOperand2 (@expr24935 ) &&@expr1073766760 bracTok@var5104 .@expr24934 astOperand2 (@expr24935 ) .@expr1073766763 hasKnownIntValue (@expr1073766764 ) ) {
8071: numElem@var5103 =@expr1073766765 bracTok@var5104 .@expr24934 astOperand2 (@expr24935 ) .@expr1073766768 getKnownIntValue (@expr1073766769 ) ; }
8072: else { if (@expr1073766770 Token ::@expr24947 Match (@expr1073766772 typeTok@var5105 , "%type%" ) ) {
8073: numElem@var5103 =@expr1073766773 1 ; } }
8074: }
8075:
8076: if (@expr1073766774 numElem@var5103 >=@expr1073766775 0 &&@expr1073766776 newTok@var5101 .@expr24953 astParent (@expr24954 ) &&@expr1073766779 newTok@var5101 .@expr24953 astParent (@expr24954 ) .@expr1073766782 isAssignmentOp (@expr1073766783 ) ) {
8077: const Token * typeTok@var5106 ; typeTok@var5106 =@expr1073766784 newTok@var5101 .@expr24953 astParent (@expr24954 ) .@expr1073766787 astOperand1 (@expr1073766788 ) ;
8078: if (@expr1073766789 !@expr1073766790 typeTok@var5106 ||@expr1073766791 !@expr1073766792 typeTok@var5106 .@expr1073766793 varId (@expr1073766794 ) ) {
8079: typeTok@var5106 =@expr1073766795 newTok@var5101 .@expr24953 astParent (@expr24954 ) .@expr1073766798 previous (@expr1073766799 ) ; }
8080: if (@expr1073766800 typeTok@var5106 &&@expr1073766801 typeTok@var5106 .@expr24978 valueType (@expr24979 ) ) {
8081: const long long typeSize@var5107 =@expr1073766804 typeTok@var5106 .@expr24978 valueType (@expr24979 ) .@expr1073766807 typeSize (@expr1073766808 *@expr1073766809 settings@var5086 , typeTok@var5106 .@expr24978 valueType (@expr24979 ) .@expr1073766812 pointer@var5317 >@expr1073766813 1 ) ;
8082: if (@expr1073766814 typeSize@var5107 >=@expr1073766815 0 ) {
8083: sizeValue@var5102 =@expr1073766816 numElem@var5103 *@expr1073766817 typeSize@var5107 ; }
8084: }
8085: }
8086: return sizeValue@var5102 ;
8087: } ;
8088:
8089: for (@expr1073766818 const Scope *@expr24758 functionScope@var5108 :@expr1073766820 symboldatabase@var5085 .@expr1073766821 functionScopes@var5109 ) {
8090: for (@expr1073766822 const Token *@expr24758 tok@var5110 =@expr1073766824 functionScope@var5108 .@expr1073766825 bodyStart@var5111 ; tok@var5110 !=@expr1073766826 functionScope@var5108 .@expr25003 bodyEnd@var5112 ; tok@var5110 =@expr1073766828 tok@var5110 .@expr25005 next (@expr25006 ) ) {
8091: if (@expr1073766831 !@expr1073766832 Token ::@expr24947 Match (@expr1073766834 tok@var5110 , "[;{}] %var% =" ) ) {
8092: continue ; }
8093:
8094: if (@expr1073766835 !@expr1073766836 tok@var5110 .@expr25005 next (@expr25006 ) .@expr1073766839 variable (@expr1073766840 ) ) {
8095: continue ; }
8096:
8097: const Token * rhs@var5113 ; rhs@var5113 =@expr1073766841 tok@var5110 .@expr25018 tokAt (@expr25019 2 ) .@expr1073766844 astOperand2 (@expr1073766845 ) ;
8098: while (@expr1073766846 rhs@var5113 &&@expr1073766847 rhs@var5113 .@expr1073766848 isCast (@expr1073766849 ) ) {
8099: rhs@var5113 =@expr1073766850 rhs@var5113 .@expr25027 astOperand2 (@expr25028 ) ?@expr1073766853 rhs@var5113 .@expr25027 astOperand2 (@expr25028 ) :@expr1073766856 rhs@var5113 .@expr1073766857 astOperand1 (@expr1073766858 ) ; }
8100: if (@expr1073766859 !@expr1073766860 rhs@var5113 ) {
8101: continue ; }
8102:
8103: const bool isNew@var5114 =@expr1073766861 symboldatabase@var5085 .@expr1073766862 isCPP (@expr1073766863 ) &&@expr1073766864 rhs@var5113 .@expr1073766865 str (@expr1073766866 ) ==@expr1073766867 "new" ;
8104: if (@expr1073766868 !@expr1073766869 isNew@var5114 &&@expr1073766870 !@expr1073766871 Token ::@expr24947 Match (@expr1073766873 rhs@var5113 .@expr25050 previous (@expr25051 ) , "%name% (" ) ) {
8105: continue ; }
8106:
8107: const long long sizeValue@var5115 =@expr1073766876 isNew@var5114 ?@expr1073766877 getBufferSizeFromNew@var5100 (@expr1073766878 rhs@var5113 ) :@expr1073766879 getBufferSizeFromAllocFunc@var5087 (@expr1073766880 rhs@var5113 .@expr25050 previous (@expr25051 ) ) ;
8108: if (@expr1073766883 sizeValue@var5115 <@expr1073766884 0 ) {
8109: continue ; }
8110:
8111: ValueFlow ::@expr1073766885 Value value@var5116 (@expr1073766886 sizeValue@var5115 ) ;
8112: value@var5116 .@expr1073766887 errorPath@var5117 .@expr1073766888 emplace_back (@expr1073766889 tok@var5110 .@expr25018 tokAt (@expr25019 2 ) , "Assign " +@expr1073766892 tok@var5110 .@expr1073766893 strAt (@expr1073766894 1 ) +@expr1073766895 ", buffer with size " +@expr1073766896 MathLib ::@expr1073766897 toString (@expr1073766898 sizeValue@var5115 ) ) ;
8113: value@var5116 .@expr1073766899 valueType@var5118 =@expr1073766900 ValueFlow ::@expr1073766901 Value ::@expr1073766902 ValueType ::@expr1073766903 BUFFER_SIZE ;
8114: value@var5116 .@expr1073766904 setKnown (@expr1073766905 ) ;
8115: const std ::@expr24849 list < ValueFlow ::@expr24849 Value > values@var5119 {@expr1073766908 value@var5116 } ;
8116: valueFlowForward (@expr1073766909 const_cast < Token *@expr24758 > (@expr1073766911 rhs@var5113 ) , functionScope@var5108 .@expr25003 bodyEnd@var5112 , tok@var5110 .@expr25005 next (@expr25006 ) , values@var5119 , tokenlist@var5084 , settings@var5086 ) ;
8117: }
8118: }
8119: }
8120:
8121: static bool getMinMaxValues ( const ValueType * vt@var5120 , const cppcheck :: Platform & platform@var5121 , long long * minValue@var5122 , long long * maxValue@var5123 )
8122: {
8123: if (@expr1073766917 !@expr1073766918 vt@var5120 ||@expr1073766919 !@expr1073766920 vt@var5120 .@expr1073766921 isIntegral (@expr1073766922 ) ||@expr1073766923 vt@var5120 .@expr1073766924 pointer@var5124 ) {
8124: return false ; }
8125:
8126: int bits@var5125 ;
8127: switch (@expr1073766925 vt@var5120 .@expr1073766926 type@var5126 ) {
8128: case ValueType ::@expr25103 Type ::@expr1073766928 BOOL :@expr25105 ;
8129: bits@var5125 =@expr1073766930 1 ;
8130: break ;
8131: case ValueType ::@expr25103 Type ::@expr1073766932 CHAR :@expr25105 ;
8132: bits@var5125 =@expr1073766934 platform@var5121 .@expr1073766935 char_bit@var5127 ;
8133: break ;
8134: case ValueType ::@expr25103 Type ::@expr1073766937 SHORT :@expr25105 ;
8135: bits@var5125 =@expr1073766939 platform@var5121 .@expr1073766940 short_bit@var5128 ;
8136: break ;
8137: case ValueType ::@expr25103 Type ::@expr1073766942 INT :@expr25105 ;
8138: bits@var5125 =@expr1073766944 platform@var5121 .@expr1073766945 int_bit@var5129 ;
8139: break ;
8140: case ValueType ::@expr25103 Type ::@expr1073766947 LONG :@expr25105 ;
8141: bits@var5125 =@expr1073766949 platform@var5121 .@expr1073766950 long_bit@var5130 ;
8142: break ;
8143: case ValueType ::@expr25103 Type ::@expr1073766952 LONGLONG :@expr25105 ;
8144: bits@var5125 =@expr1073766954 platform@var5121 .@expr1073766955 long_long_bit@var5131 ;
8145: break ;
8146: default :@expr25105 ;
8147: return false ;
8148: }
8149:
8150: if (@expr1073766957 bits@var5125 ==@expr1073766958 1 ) {
8151: *@expr25135 minValue@var5122 =@expr1073766960 0 ;
8152: *@expr25137 maxValue@var5123 =@expr1073766962 1 ;
8153: } else { if (@expr1073766963 bits@var5125 <@expr1073766964 62 ) {
8154: if (@expr25141 vt@var5120 .@expr25142 sign@var5132 ==@expr25143 ValueType ::@expr25144 Sign ::@expr25145 UNSIGNED ) {
8155: *@expr25135 minValue@var5122 =@expr1073766971 0 ;
8156: *@expr25137 maxValue@var5123 =@expr1073766973 (@expr1073766974 1LL <<@expr1073766975 bits@var5125 ) -@expr1073766976 1 ;
8157: } else {
8158: *@expr25135 minValue@var5122 =@expr1073766978 -@expr1073766979 (@expr1073766980 1LL <<@expr25157 (@expr1073766982 bits@var5125 -@expr25159 1 ) ) ;
8159: *@expr25137 maxValue@var5123 =@expr1073766985 (@expr1073766986 1LL <<@expr25157 (@expr1073766988 bits@var5125 -@expr25159 1 ) ) -@expr1073766990 1 ;
8160: }
8161: } else { if (@expr1073766991 bits@var5125 ==@expr1073766992 64 ) {
8162: if (@expr25141 vt@var5120 .@expr25142 sign@var5132 ==@expr25143 ValueType ::@expr25144 Sign ::@expr25145 UNSIGNED ) {
8163: *@expr25135 minValue@var5122 =@expr1073766999 0 ;
8164: *@expr25137 maxValue@var5123 =@expr1073767001 LLONG_MAX@expr25091 ;
8165: } else {
8166: *@expr25135 minValue@var5122 =@expr1073767003 LLONG_MIN@expr1073766916 ;
8167: *@expr25137 maxValue@var5123 =@expr1073767005 LLONG_MAX@expr25091 ;
8168: }
8169: } else {
8170: return false ;
8171: } } }
8172:
8173: return true ;
8174: }
8175:
8176: static bool getMinMaxValues ( const std :: string & typestr@var5133 , const Settings * settings@var5134 , long long * minvalue@var5135 , long long * maxvalue@var5136 )
8177: {
8178: TokenList typeTokens@var5137 (@expr1073767006 settings@var5134 ) ;
8179: std ::@expr1073767007 istringstream istr@var5138 (@expr1073767008 typestr@var5133 +@expr1073767009 ";" ) ;
8180: if (@expr1073767010 !@expr1073767011 typeTokens@var5137 .@expr1073767012 createTokens (@expr1073767013 istr@var5138 ) ) {
8181: return false ; }
8182: typeTokens@var5137 .@expr1073767014 simplifyPlatformTypes (@expr1073767015 ) ;
8183: typeTokens@var5137 .@expr1073767016 simplifyStdType (@expr1073767017 ) ;
8184: const ValueType &@expr1073767018 vt@var5139 =@expr1073767019 ValueType ::@expr1073767020 parseDecl (@expr1073767021 typeTokens@var5137 .@expr1073767022 front (@expr1073767023 ) , settings@var5134 ) ;
8185: return getMinMaxValues (@expr1073767024 &@expr1073767025 vt@var5139 , *@expr1073767026 settings@var5134 , minvalue@var5135 , maxvalue@var5136 ) ;
8186: }
8187:
8188: static void valueFlowSafeFunctions ( TokenList * tokenlist@var5140 , SymbolDatabase * symboldatabase@var5141 , const Settings * settings@var5142 )
8189: {
8190: for (@expr1073767030 const Scope *@expr25207 functionScope@var5143 :@expr1073767032 symboldatabase@var5141 .@expr1073767033 functionScopes@var5144 ) {
8191: if (@expr1073767034 !@expr1073767035 functionScope@var5143 .@expr25212 bodyStart@var5145 ) {
8192: continue ; }
8193: const Function * function@var5146 ; function@var5146 =@expr1073767037 functionScope@var5143 .@expr1073767038 function@var5147 ;
8194: if (@expr1073767039 !@expr1073767040 function@var5146 ) {
8195: continue ; }
8196:
8197: const bool safe@var5148 =@expr1073767041 function@var5146 .@expr1073767042 isSafe (@expr1073767043 settings@var5142 ) ;
8198: const bool all@var5149 =@expr1073767044 safe@var5148 &&@expr1073767045 settings@var5142 .@expr1073767046 platformType@var5150 !=@expr1073767047 cppcheck ::@expr1073767048 Platform ::@expr1073767049 PlatformType ::@expr1073767050 Unspecified ;
8199:
8200: for (@expr1073767051 const Variable &@expr25228 arg@var5151 :@expr1073767053 function@var5146 .@expr1073767054 argumentList@var5152 ) {
8201: if (@expr1073767055 !@expr1073767056 arg@var5151 .@expr25233 nameToken (@expr25234 ) ||@expr1073767059 !@expr1073767060 arg@var5151 .@expr25237 valueType (@expr25238 ) ) {
8202: continue ; }
8203:
8204: if (@expr1073767063 arg@var5151 .@expr25237 valueType (@expr25238 ) .@expr25242 type@var5318 ==@expr1073767067 ValueType ::@expr25244 Type ::@expr1073767069 CONTAINER ) {
8205: if (@expr1073767070 !@expr1073767071 safe@var5148 ) {
8206: continue ; }
8207: std ::@expr1073767072 list < ValueFlow ::@expr25249 Value > argValues@var5153 ;
8208: argValues@var5153 .@expr25250 emplace_back (@expr1073767075 0 ) ;
8209: argValues@var5153 .@expr25252 back (@expr25253 ) .@expr25254 valueType@expr25203 =@expr1073767079 ValueFlow ::@expr25256 Value ::@expr25257 ValueType ::@expr25258 CONTAINER_SIZE ;
8210: argValues@var5153 .@expr25252 back (@expr25253 ) .@expr25261 errorPath .@expr25262 emplace_back (@expr1073767087 arg@var5151 .@expr25233 nameToken (@expr25234 ) , "Assuming " +@expr25266 arg@var5151 .@expr25267 name (@expr25268 ) +@expr1073767093 " is empty" ) ;
8211: argValues@var5153 .@expr25252 back (@expr25253 ) .@expr25272 safe@expr25204 =@expr1073767097 true ;
8212: argValues@var5153 .@expr25250 emplace_back (@expr1073767099 1000000 ) ;
8213: argValues@var5153 .@expr25252 back (@expr25253 ) .@expr25254 valueType@expr25203 =@expr1073767103 ValueFlow ::@expr25256 Value ::@expr25257 ValueType ::@expr25258 CONTAINER_SIZE ;
8214: argValues@var5153 .@expr25252 back (@expr25253 ) .@expr25261 errorPath .@expr25262 emplace_back (@expr1073767111 arg@var5151 .@expr25233 nameToken (@expr25234 ) , "Assuming " +@expr25266 arg@var5151 .@expr25267 name (@expr25268 ) +@expr1073767117 " size is 1000000" ) ;
8215: argValues@var5153 .@expr25252 back (@expr25253 ) .@expr25272 safe@expr25204 =@expr1073767121 true ;
8216: for (@expr1073767122 const ValueFlow ::@expr25249 Value &@expr25228 value@var5154 :@expr1073767125 argValues@var5153 ) {
8217: valueFlowContainerForward (@expr1073767126
8218: const_cast < Token *@expr25207 > (@expr1073767128 functionScope@var5143 .@expr25212 bodyStart@var5145 ) , arg@var5151 .@expr25233 nameToken (@expr25234 ) , value@var5154 , tokenlist@var5140 ) ; }
8219: continue ;
8220: }
8221:
8222: long long low@var5155 ; long long high@var5156 ;
8223: bool isLow@var5157 ; isLow@var5157 =@expr1073767132 arg@var5151 .@expr25233 nameToken (@expr25234 ) .@expr25311 getCppcheckAttribute (@expr1073767136 TokenImpl ::@expr25313 CppcheckAttributes ::@expr25314 Type ::@expr1073767139 LOW , &@expr1073767140 low@var5155 ) ;
8224: bool isHigh@var5158 ; isHigh@var5158 =@expr1073767141 arg@var5151 .@expr25233 nameToken (@expr25234 ) .@expr25311 getCppcheckAttribute (@expr1073767145 TokenImpl ::@expr25313 CppcheckAttributes ::@expr25314 Type ::@expr1073767148 HIGH , &@expr1073767149 high@var5156 ) ;
8225:
8226: if (@expr1073767150 !@expr25327 isLow@var5157 &&@expr1073767152 !@expr25329 isHigh@var5158 &&@expr1073767154 !@expr1073767155 all@var5149 ) {
8227: continue ; }
8228:
8229: const bool safeLow@var5159 =@expr1073767156 !@expr25327 isLow@var5157 ;
8230: const bool safeHigh@var5160 =@expr1073767158 !@expr25329 isHigh@var5158 ;
8231:
8232: if (@expr1073767160 (@expr1073767161 !@expr25327 isLow@var5157 ||@expr1073767163 !@expr25329 isHigh@var5158 ) &&@expr1073767165 all@var5149 ) {
8233: long long minValue@var5161 ; long long maxValue@var5162 ;
8234: if (@expr1073767166 getMinMaxValues (@expr1073767167 arg@var5151 .@expr25237 valueType (@expr25238 ) , *@expr1073767170 settings@var5142 , &@expr1073767171 minValue@var5161 , &@expr1073767172 maxValue@var5162 ) ) {
8235: if (@expr1073767173 !@expr25327 isLow@var5157 ) {
8236: low@var5155 =@expr1073767175 minValue@var5161 ; }
8237: if (@expr1073767176 !@expr25329 isHigh@var5158 ) {
8238: high@var5156 =@expr1073767178 maxValue@var5162 ; }
8239: isLow@var5157 =@expr1073767179 isHigh@var5158 =@expr1073767180 true ;
8240: } else { if (@expr1073767181 arg@var5151 .@expr25237 valueType (@expr25238 ) .@expr25242 type@var5318 ==@expr1073767185 ValueType ::@expr25244 Type ::@expr1073767187 FLOAT ||@expr1073767188 arg@var5151 .@expr25237 valueType (@expr25238 ) .@expr25242 type@var5318 ==@expr1073767192 ValueType ::@expr25244 Type ::@expr1073767194 DOUBLE ||@expr1073767195 arg@var5151 .@expr25237 valueType (@expr25238 ) .@expr25242 type@var5318 ==@expr1073767199 ValueType ::@expr25244 Type ::@expr1073767201 LONGDOUBLE ) {
8241: std ::@expr1073767202 list < ValueFlow ::@expr25249 Value > argValues@var5163 ;
8242: argValues@var5163 .@expr25380 emplace_back (@expr25381 0 ) ;
8243: argValues@var5163 .@expr25382 back (@expr25383 ) .@expr25384 valueType@expr25203 =@expr1073767209 ValueFlow ::@expr25256 Value ::@expr25257 ValueType ::@expr25388 FLOAT ;
8244: argValues@var5163 .@expr25382 back (@expr25383 ) .@expr25391 floatValue@expr25205 =@expr1073767216 isLow@var5157 ?@expr1073767217 low@var5155 :@expr1073767218 -1E25f ;
8245: argValues@var5163 .@expr25382 back (@expr25383 ) .@expr25397 errorPath .@expr25398 emplace_back (@expr25399 arg@var5151 .@expr25233 nameToken (@expr25234 ) , "Safe checks: Assuming argument has value " +@expr25402 MathLib ::@expr25403 toString (@expr25404 argValues@var5163 .@expr25382 back (@expr25383 ) .@expr25391 floatValue@expr25205 ) ) ;
8246: argValues@var5163 .@expr25382 back (@expr25383 ) .@expr25410 safe@expr25204 =@expr1073767235 true ;
8247: argValues@var5163 .@expr25380 emplace_back (@expr25381 0 ) ;
8248: argValues@var5163 .@expr25382 back (@expr25383 ) .@expr25384 valueType@expr25203 =@expr1073767241 ValueFlow ::@expr25256 Value ::@expr25257 ValueType ::@expr25388 FLOAT ;
8249: argValues@var5163 .@expr25382 back (@expr25383 ) .@expr25391 floatValue@expr25205 =@expr1073767248 isHigh@var5158 ?@expr1073767249 high@var5156 :@expr1073767250 1E25f ;
8250: argValues@var5163 .@expr25382 back (@expr25383 ) .@expr25397 errorPath .@expr25398 emplace_back (@expr25399 arg@var5151 .@expr25233 nameToken (@expr25234 ) , "Safe checks: Assuming argument has value " +@expr25402 MathLib ::@expr25403 toString (@expr25404 argValues@var5163 .@expr25382 back (@expr25383 ) .@expr25391 floatValue@expr25205 ) ) ;
8251: argValues@var5163 .@expr25382 back (@expr25383 ) .@expr25410 safe@expr25204 =@expr1073767267 true ;
8252: valueFlowForward (@expr1073767268 const_cast < Token *@expr25207 > (@expr25446 functionScope@var5143 .@expr25212 bodyStart@var5145 .@expr25448 next (@expr25449 ) ) ,
8253: functionScope@var5143 .@expr25450 bodyEnd@var5164 ,
8254: arg@var5151 .@expr25233 nameToken (@expr25234 ) ,
8255: argValues@var5163 ,
8256: tokenlist@var5140 ,
8257: settings@var5142 ) ;
8258: continue ;
8259: } }
8260: }
8261:
8262: std ::@expr1073767277 list < ValueFlow ::@expr25249 Value > argValues@var5165 ;
8263: if (@expr1073767279 isLow@var5157 ) {
8264: argValues@var5165 .@expr25456 emplace_back (@expr1073767281 low@var5155 ) ;
8265: argValues@var5165 .@expr25458 back (@expr25459 ) .@expr25460 errorPath .@expr25461 emplace_back (@expr1073767286 arg@var5151 .@expr25233 nameToken (@expr25234 ) , std ::@expr25465 string (@expr1073767290 safeLow@var5159 ?@expr1073767291 "Safe checks: " :@expr25468 "" ) +@expr1073767293 "Assuming argument has value " +@expr1073767294 MathLib ::@expr25403 toString (@expr1073767296 low@var5155 ) ) ;
8266: argValues@var5165 .@expr25458 back (@expr25459 ) .@expr25475 safe@expr25204 =@expr1073767300 safeLow@var5159 ;
8267: }
8268: if (@expr1073767301 isHigh@var5158 ) {
8269: argValues@var5165 .@expr25456 emplace_back (@expr1073767303 high@var5156 ) ;
8270: argValues@var5165 .@expr25458 back (@expr25459 ) .@expr25460 errorPath .@expr25461 emplace_back (@expr1073767308 arg@var5151 .@expr25233 nameToken (@expr25234 ) , std ::@expr25465 string (@expr1073767312 safeHigh@var5160 ?@expr1073767313 "Safe checks: " :@expr25468 "" ) +@expr1073767315 "Assuming argument has value " +@expr1073767316 MathLib ::@expr25403 toString (@expr1073767318 high@var5156 ) ) ;
8271: argValues@var5165 .@expr25458 back (@expr25459 ) .@expr25475 safe@expr25204 =@expr1073767322 safeHigh@var5160 ;
8272: }
8273:
8274: if (@expr1073767323 !@expr1073767324 argValues@var5165 .@expr1073767325 empty (@expr1073767326 ) ) {
8275: valueFlowForward (@expr1073767327 const_cast < Token *@expr25207 > (@expr25446 functionScope@var5143 .@expr25212 bodyStart@var5145 .@expr25448 next (@expr25449 ) ) ,
8276: functionScope@var5143 .@expr25450 bodyEnd@var5164 ,
8277: arg@var5151 .@expr25233 nameToken (@expr25234 ) ,
8278: argValues@var5165 ,
8279: tokenlist@var5140 ,
8280: settings@var5142 ) ; }
8281: }
8282: }
8283: }
8284:
8285: static void valueFlowUnknownFunctionReturn ( TokenList * tokenlist@var5166 , const Settings * settings@var5167 )
8286: {
8287: if (@expr1073767336 settings@var5167 .@expr25513 checkUnknownFunctionReturn@var5168 .@expr1073767338 empty (@expr1073767339 ) ) {
8288: return ; }
8289: for (@expr1073767340 Token *@expr25517 tok@var5169 =@expr1073767342 tokenlist@var5166 .@expr1073767343 front (@expr1073767344 ) ; tok@var5169 ; tok@var5169 =@expr1073767345 tok@var5169 .@expr1073767346 next (@expr1073767347 ) ) {
8290: if (@expr1073767348 !@expr1073767349 tok@var5169 .@expr1073767350 astParent (@expr1073767351 ) ||@expr1073767352 tok@var5169 .@expr1073767353 str (@expr1073767354 ) !=@expr1073767355 "(" ||@expr1073767356 !@expr1073767357 tok@var5169 .@expr25534 previous (@expr25535 ) .@expr1073767360 isName (@expr1073767361 ) ) {
8291: continue ; }
8292: if (@expr1073767362 settings@var5167 .@expr25513 checkUnknownFunctionReturn@var5168 .@expr1073767364 find (@expr1073767365 tok@var5169 .@expr25534 previous (@expr25535 ) .@expr1073767368 str (@expr1073767369 ) ) ==@expr1073767370 settings@var5167 .@expr25513 checkUnknownFunctionReturn@var5168 .@expr1073767372 end (@expr1073767373 ) ) {
8293: continue ; }
8294: std ::@expr1073767374 vector < long long > unknownValues@var5170 ; unknownValues@var5170 =@expr1073767375 settings@var5167 .@expr25552 library@var5171 .@expr1073767377 unknownReturnValues (@expr1073767378 tok@var5169 .@expr1073767379 astOperand1 (@expr1073767380 ) ) ;
8295: if (@expr1073767381 unknownValues@var5170 .@expr1073767382 empty (@expr1073767383 ) ) {
8296: continue ; }
8297:
8298:
8299: const std ::@expr1073767384 string &@expr1073767385 typestr@var5172 =@expr1073767386 settings@var5167 .@expr25552 library@var5171 .@expr1073767388 returnValueType (@expr1073767389 tok@var5169 .@expr25534 previous (@expr25535 ) ) ;
8300: long long minvalue@var5173 ; long long maxvalue@var5174 ;
8301: if (@expr1073767392 !@expr1073767393 getMinMaxValues (@expr1073767394 typestr@var5172 , settings@var5167 , &@expr1073767395 minvalue@var5173 , &@expr1073767396 maxvalue@var5174 ) ) {
8302: continue ; }
8303:
8304: for (@expr1073767397 long long value@var5175 :@expr1073767398 unknownValues@var5170 ) {
8305: if (@expr1073767399 value@var5175 <@expr1073767400 minvalue@var5173 ) {
8306: value@var5175 =@expr1073767401 minvalue@var5173 ; }
8307: else { if (@expr1073767402 value@var5175 >@expr1073767403 maxvalue@var5174 ) {
8308: value@var5175 =@expr1073767404 maxvalue@var5174 ; } }
8309: setTokenValue (@expr1073767405 const_cast < Token *@expr25517 > (@expr1073767407 tok@var5169 ) , ValueFlow ::@expr1073767408 Value (@expr1073767409 value@var5175 ) , settings@var5167 ) ;
8310: }
8311: }
8312: }
8313:
8314: ValueFlow :: Value :: Value ( const Token * c@var5176 , long long val@var5177 , Bound b@var5178 )
8315: : valueType@var141 ( ValueType :: INT ) ,
8316: bound@var142 ( b@var5178 ) ,
8317: intvalue@var143 ( val@var5177 ) ,
8318: tokvalue@var144 ( nullptr ) ,
8319: floatValue@var145 ( 0.0 ) ,
8320: moveKind@var146 ( MoveKind :: NonMovedVariable ) ,
8321: varvalue@var147 ( val@var5177 ) ,
8322: condition@var148 ( c@var5176 ) ,
8323: varId@var150 ( 0 ) ,
8324: safe@var151 ( false ) ,
8325: conditional@var152 ( false ) ,
8326: macro@var153 ( false ) ,
8327: defaultArg@var154 ( false ) ,
8328: indirect@var155 ( 0 ) ,
8329: path@var156 ( 0 ) ,
8330: wideintvalue@var157 ( 0 ) ,
8331: subexpressions@var158 ( ) ,
8332: capturetok@var159 ( nullptr ) ,
8333: lifetimeKind@var160 ( LifetimeKind :: Object ) ,
8334: lifetimeScope@var161 ( LifetimeScope :: Local ) ,
8335: valueKind@var166 ( ValueKind :: Possible )
8336: {
8337: errorPath@var149 .@expr1073767410 emplace_back (@expr1073767411 c@var5176 , "Assuming that condition '" +@expr1073767412 c@var5176 .@expr1073767413 expressionString (@expr1073767414 ) +@expr1073767415 "' is not redundant" ) ;
8338: }
8339:
8340: void ValueFlow :: Value :: assumeCondition ( const Token * tok@var5179 )
8341: {
8342: condition@var148 =@expr1073767416 tok@var5179 ;
8343: errorPath@var149 .@expr1073767417 emplace_back (@expr1073767418 tok@var5179 , "Assuming that condition '" +@expr1073767419 tok@var5179 .@expr1073767420 expressionString (@expr1073767421 ) +@expr1073767422 "' is not redundant" ) ;
8344: }
8345:
8346: std :: string ValueFlow :: Value :: infoString ( ) const
8347: {
8348: switch (@expr1073767423 valueType@var141 ) {
8349: case ValueType ::@expr1073767424 INT :@expr25601 ;
8350: return MathLib ::@expr25602 toString (@expr25603 intvalue@var143 ) ;
8351: case ValueType ::@expr1073767428 TOK :@expr25601 ;
8352: return tokvalue@var144 .@expr25606 str (@expr25607 ) ;
8353: case ValueType ::@expr1073767432 FLOAT :@expr25601 ;
8354: return MathLib ::@expr25602 toString (@expr1073767435 floatValue@var145 ) ;
8355: case ValueType ::@expr1073767436 MOVED :@expr25601 ;
8356: return "<Moved>" ;
8357: case ValueType ::@expr1073767438 UNINIT :@expr25601 ;
8358: return "<Uninit>" ;
8359: case ValueType ::@expr1073767440 BUFFER_SIZE :@expr25601
8360: case ValueType ::@expr1073767442 CONTAINER_SIZE :@expr25601 ;
8361: return "size=" +@expr1073767444 MathLib ::@expr25602 toString (@expr25603 intvalue@var143 ) ;
8362: case ValueType ::@expr1073767447 ITERATOR_START :@expr25601 ;
8363: return "start=" +@expr1073767449 MathLib ::@expr25602 toString (@expr25603 intvalue@var143 ) ;
8364: case ValueType ::@expr1073767452 ITERATOR_END :@expr25601 ;
8365: return "end=" +@expr1073767454 MathLib ::@expr25602 toString (@expr25603 intvalue@var143 ) ;
8366: case ValueType ::@expr1073767457 LIFETIME :@expr25601 ;
8367: return "lifetime=" +@expr1073767459 tokvalue@var144 .@expr25606 str (@expr25607 ) ;
8368: case ValueType ::@expr1073767462 SYMBOLIC :@expr25601 ;
8369: std ::@expr1073767464 string result@var5180 ; result@var5180 =@expr1073767465 "symbolic=" +@expr1073767466 tokvalue@var144 .@expr1073767467 expressionString (@expr1073767468 ) ;
8370: if (@expr1073767469 intvalue@var143 >@expr1073767470 0 ) {
8371: result@var5180 +=@expr1073767471 "+" +@expr1073767472 MathLib ::@expr25602 toString (@expr25603 intvalue@var143 ) ; }
8372: else { if (@expr1073767475 intvalue@var143 <@expr1073767476 0 ) {
8373: result@var5180 +=@expr1073767477 "-" +@expr1073767478 MathLib ::@expr25602 toString (@expr1073767480 -@expr1073767481 intvalue@var143 ) ; } }
8374: return result@var5180 ;
8375: }
8376: throw InternalError (@expr1073767482 nullptr , "Invalid ValueFlow Value type" ) ;
8377: }
8378:
8379: const char * ValueFlow :: Value :: toString ( MoveKind moveKind@var5181 )
8380: {
8381: switch (@expr1073767483 moveKind@var5181 ) {
8382: case MoveKind ::@expr1073767484 NonMovedVariable :@expr25661 ;
8383: return "NonMovedVariable" ;
8384: case MoveKind ::@expr1073767486 MovedVariable :@expr25661 ;
8385: return "MovedVariable" ;
8386: case MoveKind ::@expr1073767488 ForwardedVariable :@expr25661 ;
8387: return "ForwardedVariable" ;
8388: }
8389: return "" ;
8390: }
8391:
8392: const char * ValueFlow :: Value :: toString ( LifetimeKind lifetimeKind@var5182 )
8393: {
8394: switch (@expr1073767490 lifetimeKind@var5182 ) {
8395: case LifetimeKind ::@expr1073767491 Object :@expr25668 ;
8396: return "Object" ;
8397: case LifetimeKind ::@expr1073767493 SubObject :@expr25668 ;
8398: return "SubObject" ;
8399: case LifetimeKind ::@expr1073767495 Lambda :@expr25668 ;
8400: return "Lambda" ;
8401: case LifetimeKind ::@expr1073767497 Iterator :@expr25668 ;
8402: return "Iterator" ;
8403: case LifetimeKind ::@expr1073767499 Address :@expr25668 ;
8404: return "Address" ;
8405: }
8406: return "" ;
8407: }
8408:
8409: bool ValueFlow :: Value :: sameToken ( const Token * tok1@var5183 , const Token * tok2@var5184 )
8410: {
8411: if (@expr1073767501 tok1@var5183 ==@expr1073767502 tok2@var5184 ) {
8412: return true ; }
8413: if (@expr1073767503 !@expr1073767504 tok1@var5183 ) {
8414: return false ; }
8415: if (@expr1073767505 tok1@var5183 .@expr25682 exprId (@expr25683 ) ==@expr1073767508 0 ||@expr1073767509 tok2@var5184 .@expr25686 exprId (@expr25687 ) ==@expr1073767512 0 ) {
8416: return false ; }
8417: return tok1@var5183 .@expr25682 exprId (@expr25683 ) ==@expr1073767515 tok2@var5184 .@expr25686 exprId (@expr25687 ) ;
8418: }
8419: const char * ValueFlow :: Value :: toString ( LifetimeScope lifetimeScope@var5185 )
8420: {
8421: switch (@expr1073767518 lifetimeScope@var5185 ) {
8422: case ValueFlow ::@expr25695 Value ::@expr25696 LifetimeScope ::@expr1073767521 Local :@expr25698 ;
8423: return "Local" ;
8424: case ValueFlow ::@expr25695 Value ::@expr25696 LifetimeScope ::@expr1073767525 Argument :@expr25698 ;
8425: return "Argument" ;
8426: case ValueFlow ::@expr25695 Value ::@expr25696 LifetimeScope ::@expr1073767529 SubFunction :@expr25698 ;
8427: return "SubFunction" ;
8428: case ValueFlow ::@expr25695 Value ::@expr25696 LifetimeScope ::@expr1073767533 ThisPointer :@expr25698 ;
8429: return "ThisPointer" ;
8430: case ValueFlow ::@expr25695 Value ::@expr25696 LifetimeScope ::@expr1073767537 ThisValue :@expr25698 ;
8431: return "ThisValue" ;
8432: }
8433: return "" ;
8434: }
8435: const char * ValueFlow :: Value :: toString ( Bound bound@var5186 )
8436: {
8437: switch (@expr1073767539 bound@var5186 ) {
8438: case ValueFlow ::@expr25716 Value ::@expr25717 Bound ::@expr1073767542 Point :@expr25719 ;
8439: return "Point" ;
8440: case ValueFlow ::@expr25716 Value ::@expr25717 Bound ::@expr1073767546 Upper :@expr25719 ;
8441: return "Upper" ;
8442: case ValueFlow ::@expr25716 Value ::@expr25717 Bound ::@expr1073767550 Lower :@expr25719 ;
8443: return "Lower" ;
8444: }
8445: return "" ;
8446: }
8447:
8448: const ValueFlow :: Value * ValueFlow :: valueFlowConstantFoldAST ( Token * expr@var5187 , const Settings * settings@var5188 )
8449: {
8450: if (@expr1073767552 expr@var5187 &&@expr1073767553 expr@var5187 .@expr25730 values (@expr25731 ) .@expr1073767556 empty (@expr1073767557 ) ) {
8451: valueFlowConstantFoldAST (@expr1073767558 expr@var5187 .@expr1073767559 astOperand1 (@expr1073767560 ) , settings@var5188 ) ;
8452: valueFlowConstantFoldAST (@expr1073767561 expr@var5187 .@expr1073767562 astOperand2 (@expr1073767563 ) , settings@var5188 ) ;
8453: valueFlowSetConstantValue (@expr1073767564 expr@var5187 , settings@var5188 , true ) ;
8454: }
8455: return expr@var5187 &&@expr1073767565 expr@var5187 .@expr1073767566 hasKnownValue (@expr1073767567 ) ?@expr1073767568 &@expr1073767569 expr@var5187 .@expr25730 values (@expr25731 ) .@expr1073767572 front (@expr1073767573 ) :@expr1073767574 nullptr ;
8456: }
8457:
8458: static unsigned long getTotalValues ( TokenList * tokenlist@var5189 )
8459: {
8460: unsigned long n@var5190 ; n@var5190 =@expr1073767575 1 ;
8461: for (@expr1073767576 Token *@expr1073767577 tok@var5191 =@expr1073767578 tokenlist@var5189 .@expr1073767579 front (@expr1073767580 ) ; tok@var5191 ; tok@var5191 =@expr1073767581 tok@var5191 .@expr1073767582 next (@expr1073767583 ) ) {
8462: n@var5190 +=@expr1073767584 tok@var5191 .@expr1073767585 values (@expr1073767586 ) .@expr1073767587 size (@expr1073767588 ) ; }
8463: return n@var5190 ;
8464: }
8465:
8466: void ValueFlow :: setValues ( TokenList * tokenlist@var5192 , SymbolDatabase * symboldatabase@var5193 , ErrorLogger * errorLogger@var5194 , const Settings * settings@var5195 )
8467: {
8468: for (@expr1073767589 Token *@expr1073767590 tok@var5196 =@expr1073767591 tokenlist@var5192 .@expr1073767592 front (@expr1073767593 ) ; tok@var5196 ; tok@var5196 =@expr1073767594 tok@var5196 .@expr1073767595 next (@expr1073767596 ) ) {
8469: tok@var5196 .@expr1073767597 clearValueFlow (@expr1073767598 ) ; }
8470:
8471: valueFlowEnumValue (@expr25775 symboldatabase@var5193 , settings@var5195 ) ;
8472: valueFlowNumber (@expr25776 tokenlist@var5192 ) ;
8473: valueFlowString (@expr1073767601 tokenlist@var5192 ) ;
8474: valueFlowArray (@expr1073767602 tokenlist@var5192 ) ;
8475: valueFlowUnknownFunctionReturn (@expr1073767603 tokenlist@var5192 , settings@var5195 ) ;
8476: valueFlowGlobalConstVar (@expr1073767604 tokenlist@var5192 , settings@var5195 ) ;
8477: valueFlowEnumValue (@expr25775 symboldatabase@var5193 , settings@var5195 ) ;
8478: valueFlowNumber (@expr25776 tokenlist@var5192 ) ;
8479: valueFlowGlobalStaticVar (@expr1073767607 tokenlist@var5192 , settings@var5195 ) ;
8480: valueFlowPointerAlias (@expr1073767608 tokenlist@var5192 ) ;
8481: valueFlowLifetime (@expr25785 tokenlist@var5192 , symboldatabase@var5193 , errorLogger@var5194 , settings@var5195 ) ;
8482: valueFlowSymbolic (@expr1073767610 tokenlist@var5192 , symboldatabase@var5193 ) ;
8483: valueFlowBitAnd (@expr1073767611 tokenlist@var5192 ) ;
8484: valueFlowSameExpressions (@expr1073767612 tokenlist@var5192 ) ;
8485: valueFlowConditionExpressions (@expr1073767613 tokenlist@var5192 , symboldatabase@var5193 , errorLogger@var5194 , settings@var5195 ) ;
8486:
8487: unsigned long values@var5197 ; values@var5197 =@expr1073767614 0 ;
8488: unsigned long n@var5198 ; n@var5198 =@expr1073767615 4 ;
8489: while (@expr1073767616 n@var5198 >@expr1073767617 0 &&@expr1073767618 values@var5197 <@expr1073767619 getTotalValues (@expr25796 tokenlist@var5192 ) ) {
8490: values@var5197 =@expr1073767621 getTotalValues (@expr25796 tokenlist@var5192 ) ;
8491: valueFlowImpossibleValues (@expr1073767623 tokenlist@var5192 , settings@var5195 ) ;
8492: valueFlowSymbolicIdentity (@expr1073767624 tokenlist@var5192 ) ;
8493: valueFlowSymbolicAbs (@expr1073767625 tokenlist@var5192 , symboldatabase@var5193 ) ;
8494: valueFlowCondition (@expr1073767626 SymbolicConditionHandler {@expr1073767627 } , tokenlist@var5192 , symboldatabase@var5193 , errorLogger@var5194 , settings@var5195 ) ;
8495: valueFlowSymbolicInfer (@expr1073767628 tokenlist@var5192 , symboldatabase@var5193 ) ;
8496: valueFlowArrayBool (@expr1073767629 tokenlist@var5192 ) ;
8497: valueFlowRightShift (@expr1073767630 tokenlist@var5192 , settings@var5195 ) ;
8498: valueFlowAfterAssign (@expr1073767631 tokenlist@var5192 , symboldatabase@var5193 , errorLogger@var5194 , settings@var5195 ) ;
8499: valueFlowAfterSwap (@expr1073767632 tokenlist@var5192 , symboldatabase@var5193 , errorLogger@var5194 , settings@var5195 ) ;
8500: valueFlowCondition (@expr1073767633 SimpleConditionHandler {@expr1073767634 } , tokenlist@var5192 , symboldatabase@var5193 , errorLogger@var5194 , settings@var5195 ) ;
8501: valueFlowInferCondition (@expr1073767635 tokenlist@var5192 , settings@var5195 ) ;
8502: valueFlowSwitchVariable (@expr1073767636 tokenlist@var5192 , symboldatabase@var5193 , errorLogger@var5194 , settings@var5195 ) ;
8503: valueFlowForLoop (@expr1073767637 tokenlist@var5192 , symboldatabase@var5193 , errorLogger@var5194 , settings@var5195 ) ;
8504: valueFlowSubFunction (@expr1073767638 tokenlist@var5192 , symboldatabase@var5193 , errorLogger@var5194 , settings@var5195 ) ;
8505: valueFlowFunctionReturn (@expr1073767639 tokenlist@var5192 , errorLogger@var5194 ) ;
8506: valueFlowLifetime (@expr25785 tokenlist@var5192 , symboldatabase@var5193 , errorLogger@var5194 , settings@var5195 ) ;
8507: valueFlowFunctionDefaultParameter (@expr1073767641 tokenlist@var5192 , symboldatabase@var5193 , settings@var5195 ) ;
8508: valueFlowUninit (@expr1073767642 tokenlist@var5192 , symboldatabase@var5193 , settings@var5195 ) ;
8509: if (@expr1073767643 tokenlist@var5192 .@expr1073767644 isCPP (@expr1073767645 ) ) {
8510: valueFlowAfterMove (@expr1073767646 tokenlist@var5192 , symboldatabase@var5193 , settings@var5195 ) ;
8511: valueFlowSmartPointer (@expr1073767647 tokenlist@var5192 , errorLogger@var5194 , settings@var5195 ) ;
8512: valueFlowIterators (@expr1073767648 tokenlist@var5192 , settings@var5195 ) ;
8513: valueFlowCondition (@expr1073767649 IteratorConditionHandler {@expr1073767650 } , tokenlist@var5192 , symboldatabase@var5193 , errorLogger@var5194 , settings@var5195 ) ;
8514: valueFlowIteratorInfer (@expr1073767651 tokenlist@var5192 , settings@var5195 ) ;
8515: valueFlowContainerSize (@expr1073767652 tokenlist@var5192 , symboldatabase@var5193 , errorLogger@var5194 , settings@var5195 ) ;
8516: valueFlowCondition (@expr1073767653 ContainerConditionHandler {@expr1073767654 } , tokenlist@var5192 , symboldatabase@var5193 , errorLogger@var5194 , settings@var5195 ) ;
8517: }
8518: valueFlowSafeFunctions (@expr1073767655 tokenlist@var5192 , symboldatabase@var5193 , settings@var5195 ) ;
8519: n@var5198 --@expr1073767656 ;
8520: }
8521:
8522: valueFlowDynamicBufferSize (@expr1073767657 tokenlist@var5192 , symboldatabase@var5193 , settings@var5195 ) ;
8523: }
8524:
8525: ValueFlow :: Value ValueFlow :: Value :: unknown ( )
8526: {
8527: Value v@var5199 ;
8528: v@var5199 .@expr1073767659 valueType@var5200 =@expr1073767660 Value ::@expr1073767661 ValueType ::@expr1073767662 UNINIT@expr1073767658 ;
8529: return v@var5199 ;
8530: }
8531:
8532: std :: string ValueFlow :: eitherTheConditionIsRedundant ( const Token * condition@var5201 )
8533: {
8534: if (@expr1073767663 !@expr1073767664 condition@var5201 ) {
8535: return "Either the condition is redundant" ; }
8536: if (@expr1073767665 condition@var5201 .@expr1073767666 str (@expr1073767667 ) ==@expr1073767668 "case" ) {
8537: std ::@expr1073767669 string expr@var5202 ;
8538: for (@expr1073767670 const Token *@expr1073767671 tok@var5203 =@expr1073767672 condition@var5201 ; tok@var5203 &&@expr1073767673 tok@var5203 .@expr25850 str (@expr25851 ) !=@expr1073767676 ":" ; tok@var5203 =@expr1073767677 tok@var5203 .@expr1073767678 next (@expr1073767679 ) ) {
8539: expr@var5202 +=@expr1073767680 tok@var5203 .@expr25850 str (@expr25851 ) ;
8540: if (@expr1073767683 Token ::@expr1073767684 Match (@expr1073767685 tok@var5203 , "%name%|%num% %name%|%num%" ) ) {
8541: expr@var5202 +=@expr1073767686 ' ' ; }
8542: }
8543: return "Either the switch case '" +@expr1073767687 expr@var5202 +@expr1073767688 "' is redundant" ;
8544: }
8545: return "Either the condition '" +@expr1073767689 condition@var5201 .@expr1073767690 expressionString (@expr1073767691 ) +@expr1073767692 "' is redundant" ;
8546: }
8547:
8548: const ValueFlow :: Value * ValueFlow :: findValue ( const std :: list < ValueFlow :: Value > & values@var5204 ,
8549: const Settings * settings@var5205 ,
8550: std :: function < bool ( const ValueFlow :: Value & ) > pred@var5206 )
8551: {
8552: const ValueFlow ::@expr1073767694 Value * ret@var5207 ; ret@var5207 =@expr1073767695 nullptr ;
8553: for (@expr1073767696 const ValueFlow ::@expr1073767697 Value &@expr1073767698 v@var5208 :@expr1073767699 values@var5204 ) {
8554: if (@expr1073767700 pred@var5206 (@expr1073767701 v@var5208 ) ) {
8555: if (@expr1073767702 !@expr1073767703 ret@var5207 ||@expr1073767704 ret@var5207 .@expr25881 isInconclusive (@expr25882 ) ||@expr1073767707 (@expr1073767708 ret@var5207 .@expr25885 condition@var5209 &&@expr1073767710 !@expr1073767711 v@var5208 .@expr1073767712 isInconclusive (@expr1073767713 ) ) ) {
8556: ret@var5207 =@expr1073767714 &@expr1073767715 v@var5208 ; }
8557: if (@expr1073767716 !@expr1073767717 ret@var5207 .@expr25881 isInconclusive (@expr25882 ) &&@expr1073767720 !@expr1073767721 ret@var5207 .@expr25885 condition@var5209 ) {
8558: break ; }
8559: }
8560: }
8561: if (@expr1073767723 settings@var5205 &&@expr1073767724 ret@var5207 ) {
8562: if (@expr1073767725 ret@var5207 .@expr25881 isInconclusive (@expr25882 ) &&@expr1073767728 !@expr1073767729 settings@var5205 .@expr1073767730 certainty@var5210 .@expr1073767731 isEnabled (@expr1073767732 Certainty ::@expr1073767733 inconclusive@expr1073767693 ) ) {
8563: return nullptr ; }
8564: if (@expr1073767734 ret@var5207 .@expr25885 condition@var5209 &&@expr1073767736 !@expr1073767737 settings@var5205 .@expr1073767738 severity@var5211 .@expr1073767739 isEnabled (@expr1073767740 Severity ::@expr1073767741 warning ) ) {
8565: return nullptr ; }
8566: }
8567: return ret@var5207 ;
8568: }
8569:
8570: static std :: vector < ValueFlow :: Value > isOutOfBoundsImpl ( const ValueFlow :: Value & size@var5212 ,
8571: const Token * indexTok@var5213 ,
8572: bool condition@var5214 )
8573: {
8574: if (@expr1073767742 !@expr1073767743 indexTok@var5213 ) {
8575: return { } ; }
8576: const ValueFlow ::@expr25920 Value * indexValue@var5215 ; indexValue@var5215 =@expr1073767745 indexTok@var5213 .@expr1073767746 getMaxValue (@expr1073767747 condition@var5214 , size@var5212 .@expr1073767748 path@var5216 ) ;
8577: if (@expr1073767749 !@expr1073767750 indexValue@var5215 ) {
8578: return { } ; }
8579: if (@expr1073767751 indexValue@var5215 .@expr25928 intvalue@var5217 >=@expr1073767753 size@var5212 .@expr25930 intvalue@var5218 ) {
8580: return {@expr1073767755 *@expr1073767756 indexValue@var5215 } ; }
8581: if (@expr1073767757 !@expr1073767758 condition@var5214 ) {
8582: return { } ; }
8583:
8584: if (@expr1073767759 !@expr1073767760 indexTok@var5213 .@expr25937 variable (@expr25938 ) ||@expr1073767763 !@expr1073767764 indexTok@var5213 .@expr25937 variable (@expr25938 ) .@expr1073767767 isArgument (@expr1073767768 ) ) {
8585: return { } ; }
8586: if (@expr1073767769 std ::@expr1073767770 any_of (@expr1073767771 indexTok@var5213 .@expr25948 values (@expr25949 ) .@expr1073767774 begin (@expr1073767775 ) , indexTok@var5213 .@expr25948 values (@expr25949 ) .@expr1073767778 end (@expr1073767779 ) , [@expr1073767780 &@expr25957 ] (@expr1073767782 const ValueFlow ::@expr1073767783 Value &@expr25957 v@var5219 ) {
8587: return v@var5219 .@expr1073767785 isSymbolicValue (@expr1073767786 ) &&@expr1073767787 v@var5219 .@expr1073767788 isPossible (@expr1073767789 ) &&@expr1073767790 v@var5219 .@expr1073767791 bound@var5220 ==@expr1073767792 ValueFlow ::@expr25920 Value ::@expr25970 Bound ::@expr1073767795 Upper ;
8588: } ) ) {
8589: return { } ; }
8590: if (@expr1073767796 indexValue@var5215 .@expr1073767797 bound@var5221 !=@expr1073767798 ValueFlow ::@expr25920 Value ::@expr25970 Bound ::@expr25977 Lower ) {
8591: return { } ; }
8592: if (@expr1073767802 size@var5212 .@expr1073767803 bound@var5222 ==@expr1073767804 ValueFlow ::@expr25920 Value ::@expr25970 Bound ::@expr25977 Lower ) {
8593: return { } ; }
8594: ValueFlow ::@expr1073767808 Value value@var5223 ; value@var5223 =@expr1073767809 inferCondition (@expr1073767810 ">=" , indexTok@var5213 , indexValue@var5215 .@expr25928 intvalue@var5217 ) ;
8595: if (@expr1073767812 !@expr1073767813 value@var5223 .@expr1073767814 isKnown (@expr1073767815 ) ) {
8596: return { } ; }
8597: if (@expr1073767816 value@var5223 .@expr25993 intvalue@var5224 ==@expr1073767818 0 ) {
8598: return { } ; }
8599: value@var5223 .@expr25993 intvalue@var5224 =@expr1073767820 size@var5212 .@expr25930 intvalue@var5218 ;
8600: value@var5223 .@expr1073767822 bound@var5225 =@expr1073767823 ValueFlow ::@expr25920 Value ::@expr25970 Bound ::@expr25977 Lower ;
8601: return {@expr1073767827 value@var5223 } ;
8602: }
8603:
8604: std :: vector < ValueFlow :: Value > ValueFlow :: isOutOfBounds ( const Value & size@var5226 , const Token * indexTok@var5227 , bool possible@var5228 )
8605: {
8606: ValueFlow ::@expr1073767828 Value inBoundsValue@var5229 ; inBoundsValue@var5229 =@expr1073767829 inferCondition (@expr1073767830 "<" , indexTok@var5227 , size@var5226 .@expr1073767831 intvalue@var5230 ) ;
8607: if (@expr1073767832 inBoundsValue@var5229 .@expr1073767833 isKnown (@expr1073767834 ) &&@expr1073767835 inBoundsValue@var5229 .@expr1073767836 intvalue@var5231 !=@expr1073767837 0 ) {
8608: return { } ; }
8609: std ::@expr1073767838 vector < ValueFlow ::@expr1073767839 Value > result@var5232 ; result@var5232 =@expr1073767840 isOutOfBoundsImpl (@expr1073767841 size@var5226 , indexTok@var5227 , false ) ;
8610: if (@expr1073767842 !@expr1073767843 result@var5232 .@expr1073767844 empty (@expr1073767845 ) ) {
8611: return result@var5232 ; }
8612: if (@expr1073767846 !@expr1073767847 possible@var5228 ) {
8613: return result@var5232 ; }
8614: return isOutOfBoundsImpl (@expr1073767848 size@var5226 , indexTok@var5227 , true ) ;
8615: }

##file cppcheck-2.8/lib/valueptr.h

1:
|
28:
29: class ValuePtr<InferModel> {
30: struct cloner<InferModel> ;
31:
|
36:
37: public:
38:
39:
40: using cloner_type = decltype ( & cloner<InferModel> :: apply ) ;
41:
42: ValuePtr<InferModel> ( ) : mPtr@var5243 ( nullptr ) , mClone@var5244 ( ) { }
43:
44: template < class U >
45:
46: ValuePtr<InferModel> ( const U & value@var5233 ) : mPtr@var5243 ( cloner < U > :: apply ( & value@var5233 ) ) , mClone@var5244 ( & cloner < U > :: apply )
47: { }
48:
49: ValuePtr<InferModel> ( const ValuePtr<InferModel> & rhs@var5234 ) : mPtr@var5243 ( nullptr ) , mClone@var5244 ( rhs@var5234 . mClone@var5235 ) {
50: if (@expr1073767849 rhs@var5234 ) {
51: mPtr@var5243 .@expr1073767850 reset (@expr1073767851 mClone@var5244 (@expr1073767852 rhs@var5234 .@expr1073767853 get (@expr1073767854 ) ) ) ;
52: }
53: }
54: ValuePtr<InferModel> ( ValuePtr<InferModel> && rhs@var5236 ) : mPtr@var5243 ( std :: move ( rhs@var5236 . mPtr@var5237 ) ) , mClone@var5244 ( std :: move ( rhs@var5236 . mClone@var5238 ) ) { }
55:
56: InferModel * release ( ) {
57: return mPtr@var5243 .@expr1073767855 release (@expr1073767856 ) ;
58: }
59:
60: InferModel * get ( ) {
61: return mPtr@var5243 .@expr1073767857 get (@expr1073767858 ) ;
62: }
63: const InferModel * get ( ) const {
64: return mPtr@var5243 .@expr1073767859 get (@expr1073767860 ) ;
65: }
66:
67: InferModel & operator* ( ) {
68: return *@expr1073767861 get (@expr1073767862 ) ;
69: }
70: const InferModel & operator* ( ) const {
71: return *@expr1073767863 get (@expr1073767864 ) ;
72: }
73:
74: InferModel * operator-> ( ) {
75: return get (@expr1073767865 ) ;
76: }
77: const InferModel * operator-> ( ) const {
78: return get (@expr1073767866 ) ;
79: }
80:
81: void swap ( ValuePtr<InferModel> & rhs@var5239 ) {
82:
83: std ::@expr26043 swap (@expr1073767868 mPtr@var5243 , rhs@var5239 .@expr1073767869 mPtr@var5240 ) ;
84: std ::@expr26043 swap (@expr1073767871 mClone@var5244 , rhs@var5239 .@expr1073767872 mClone@var5241 ) ;
85: }
86:
87: ValuePtr<InferModel> & operator= ( ValuePtr<InferModel> rhs@var5242 ) {
88: swap (@expr1073767873 rhs@var5242 ) ;
89: return *@expr1073767874 this@expr1073767875 ;
90: }
91:
92: operatorbool ( ) const {
93: return !@expr1073767876 !@expr1073767877 mPtr@var5243 ;
94: }
95: ~ ValuePtr<InferModel> ( ) { }
96:
97: private:
98: std :: shared_ptr < InferModel > mPtr@var5243 ;
99: cloner_type mClone@var5244 ;
100: } ;
29: class ValuePtr<Analyzer> {
30: struct cloner<Analyzer> ;
31:
|
36:
37: public:
38:
39:
40: using cloner_type = decltype ( & cloner<Analyzer> :: apply ) ;
41:
42: ValuePtr<Analyzer> ( ) : mPtr@var5255 ( nullptr ) , mClone@var5256 ( ) { }
43:
44: template < class U >
45:
46: ValuePtr<Analyzer> ( const U & value@var5245 ) : mPtr@var5255 ( cloner < U > :: apply ( & value@var5245 ) ) , mClone@var5256 ( & cloner < U > :: apply )
47: { }
48:
49: ValuePtr<Analyzer> ( const ValuePtr<Analyzer> & rhs@var5246 ) : mPtr@var5255 ( nullptr ) , mClone@var5256 ( rhs@var5246 . mClone@var5247 ) {
50: if (@expr1073767878 rhs@var5246 ) {
51: mPtr@var5255 .@expr1073767879 reset (@expr1073767880 mClone@var5256 (@expr1073767881 rhs@var5246 .@expr1073767882 get (@expr1073767883 ) ) ) ;
52: }
53: }
54: ValuePtr<Analyzer> ( ValuePtr<Analyzer> && rhs@var5248 ) : mPtr@var5255 ( std :: move ( rhs@var5248 . mPtr@var5249 ) ) , mClone@var5256 ( std :: move ( rhs@var5248 . mClone@var5250 ) ) { }
55:
56: Analyzer * release ( ) {
57: return mPtr@var5255 .@expr1073767884 release (@expr1073767885 ) ;
58: }
59:
60: Analyzer * get ( ) {
61: return mPtr@var5255 .@expr1073767886 get (@expr1073767887 ) ;
62: }
63: const Analyzer * get ( ) const {
64: return mPtr@var5255 .@expr1073767888 get (@expr1073767889 ) ;
65: }
66:
67: Analyzer & operator* ( ) {
68: return *@expr1073767890 get (@expr1073767891 ) ;
69: }
70: const Analyzer & operator* ( ) const {
71: return *@expr1073767892 get (@expr1073767893 ) ;
72: }
73:
74: Analyzer * operator-> ( ) {
75: return get (@expr1073767894 ) ;
76: }
77: const Analyzer * operator-> ( ) const {
78: return get (@expr1073767895 ) ;
79: }
80:
81: void swap ( ValuePtr<Analyzer> & rhs@var5251 ) {
82:
83: std ::@expr26072 swap (@expr1073767897 mPtr@var5255 , rhs@var5251 .@expr1073767898 mPtr@var5252 ) ;
84: std ::@expr26072 swap (@expr1073767900 mClone@var5256 , rhs@var5251 .@expr1073767901 mClone@var5253 ) ;
85: }
86:
87: ValuePtr<Analyzer> & operator= ( ValuePtr<Analyzer> rhs@var5254 ) {
88: swap (@expr1073767902 rhs@var5254 ) ;
89: return *@expr1073767903 this@expr1073767904 ;
90: }
91:
92: operatorbool ( ) const {
93: return !@expr1073767905 !@expr1073767906 mPtr@var5255 ;
94: }
95: ~ ValuePtr<Analyzer> ( ) { }
96:
97: private:
98: std :: shared_ptr < Analyzer > mPtr@var5255 ;
99: cloner_type mClone@var5256 ;
100: } ;
29: class ValuePtr<ConditionHandler> {
30: struct cloner<ConditionHandler> ;
31:
|
36:
37: public:
38:
39:
40: using cloner_type = decltype ( & cloner<ConditionHandler> :: apply ) ;
41:
42: ValuePtr<ConditionHandler> ( ) : mPtr@var5267 ( nullptr ) , mClone@var5268 ( ) { }
43:
44: template < class U >
45:
46: ValuePtr<ConditionHandler> ( const U & value@var5257 ) : mPtr@var5267 ( cloner < U > :: apply ( & value@var5257 ) ) , mClone@var5268 ( & cloner < U > :: apply )
47: { }
48:
49: ValuePtr<ConditionHandler> ( const ValuePtr<ConditionHandler> & rhs@var5258 ) : mPtr@var5267 ( nullptr ) , mClone@var5268 ( rhs@var5258 . mClone@var5259 ) {
50: if (@expr1073767907 rhs@var5258 ) {
51: mPtr@var5267 .@expr1073767908 reset (@expr1073767909 mClone@var5268 (@expr1073767910 rhs@var5258 .@expr1073767911 get (@expr1073767912 ) ) ) ;
52: }
53: }
54: ValuePtr<ConditionHandler> ( ValuePtr<ConditionHandler> && rhs@var5260 ) : mPtr@var5267 ( std :: move ( rhs@var5260 . mPtr@var5261 ) ) , mClone@var5268 ( std :: move ( rhs@var5260 . mClone@var5262 ) ) { }
55:
56: ConditionHandler * release ( ) {
57: return mPtr@var5267 .@expr1073767913 release (@expr1073767914 ) ;
58: }
59:
60: ConditionHandler * get ( ) {
61: return mPtr@var5267 .@expr1073767915 get (@expr1073767916 ) ;
62: }
63: const ConditionHandler * get ( ) const {
64: return mPtr@var5267 .@expr1073767917 get (@expr1073767918 ) ;
65: }
66:
67: ConditionHandler & operator* ( ) {
68: return *@expr1073767919 get (@expr1073767920 ) ;
69: }
70: const ConditionHandler & operator* ( ) const {
71: return *@expr1073767921 get (@expr1073767922 ) ;
72: }
73:
74: ConditionHandler * operator-> ( ) {
75: return get (@expr1073767923 ) ;
76: }
77: const ConditionHandler * operator-> ( ) const {
78: return get (@expr1073767924 ) ;
79: }
80:
81: void swap ( ValuePtr<ConditionHandler> & rhs@var5263 ) {
82:
83: std ::@expr26101 swap (@expr1073767926 mPtr@var5267 , rhs@var5263 .@expr1073767927 mPtr@var5264 ) ;
84: std ::@expr26101 swap (@expr1073767929 mClone@var5268 , rhs@var5263 .@expr1073767930 mClone@var5265 ) ;
85: }
86:
87: ValuePtr<ConditionHandler> & operator= ( ValuePtr<ConditionHandler> rhs@var5266 ) {
88: swap (@expr1073767931 rhs@var5266 ) ;
89: return *@expr1073767932 this@expr1073767933 ;
90: }
91:
92: operatorbool ( ) const {
93: return !@expr1073767934 !@expr1073767935 mPtr@var5267 ;
94: }
95: ~ ValuePtr<ConditionHandler> ( ) { }
96:
97: private:
98: std :: shared_ptr < ConditionHandler > mPtr@var5267 ;
99: cloner_type mClone@var5268 ;
100: } ;

##file cppcheck-2.8/lib/settings.h

22:
|
48:
49: class SimpleEnableGroup<Severity::SeverityType> {
50: uint32_t mFlags@var5269 ; mFlags@var5269 = 0 ;
51: public:
52: uint32_t intValue ( ) const {
53: return mFlags@var5269 ;
54: }
55: void clear ( ) {
56: mFlags@var5269 =@expr1073767936 0 ;
57: }
58: void fill ( ) {
59: mFlags@var5269 =@expr1073767937 0xFFFFFFFF ;
60: }
61: void setEnabledAll ( bool enabled@var5270 ) {
62: if (@expr1073767938 enabled@var5270 ) {
63: fill (@expr1073767939 ) ; }
64: else {
65: clear (@expr1073767940 ) ; }
66: }
67: bool isEnabled ( Severity :: SeverityType flag@var5271 ) const {
68: return (@expr26117 mFlags@var5269 &@expr1073767942 (@expr26117 1U <<@expr1073767944 (@expr1073767945 uint32_t ) flag@var5271 ) ) !=@expr1073767946 0 ;
69: }
70: void enable ( Severity :: SeverityType flag@var5272 ) {
71: mFlags@var5269 |=@expr1073767947 (@expr1073767948 1U <<@expr1073767949 (@expr1073767950 uint32_t ) flag@var5272 ) ;
72: }
73: void disable ( Severity :: SeverityType flag@var5273 ) {
74: mFlags@var5269 &=@expr1073767951 ~@expr1073767952 (@expr1073767953 1U <<@expr1073767954 (@expr1073767955 uint32_t ) flag@var5273 ) ;
75: }
76: void setEnabled ( Severity :: SeverityType flag@var5274 , bool enabled@var5275 ) {
77: if (@expr1073767956 enabled@var5275 ) {
78: enable (@expr1073767957 flag@var5274 ) ; }
79: else {
80: disable (@expr1073767958 flag@var5274 ) ; }
81: }
82: } ;
49: class SimpleEnableGroup<Certainty::CertaintyLevel> {
50: uint32_t mFlags@var5276 ; mFlags@var5276 = 0 ;
51: public:
52: uint32_t intValue ( ) const {
53: return mFlags@var5276 ;
54: }
55: void clear ( ) {
56: mFlags@var5276 =@expr1073767959 0 ;
57: }
58: void fill ( ) {
59: mFlags@var5276 =@expr1073767960 0xFFFFFFFF ;
60: }
61: void setEnabledAll ( bool enabled@var5277 ) {
62: if (@expr1073767961 enabled@var5277 ) {
63: fill (@expr1073767962 ) ; }
64: else {
65: clear (@expr1073767963 ) ; }
66: }
67: bool isEnabled ( Certainty :: CertaintyLevel flag@var5278 ) const {
68: return (@expr26140 mFlags@var5276 &@expr1073767965 (@expr26140 1U <<@expr1073767967 (@expr1073767968 uint32_t ) flag@var5278 ) ) !=@expr1073767969 0 ;
69: }
70: void enable ( Certainty :: CertaintyLevel flag@var5279 ) {
71: mFlags@var5276 |=@expr1073767970 (@expr1073767971 1U <<@expr1073767972 (@expr1073767973 uint32_t ) flag@var5279 ) ;
72: }
73: void disable ( Certainty :: CertaintyLevel flag@var5280 ) {
74: mFlags@var5276 &=@expr1073767974 ~@expr1073767975 (@expr1073767976 1U <<@expr1073767977 (@expr1073767978 uint32_t ) flag@var5280 ) ;
75: }
76: void setEnabled ( Certainty :: CertaintyLevel flag@var5281 , bool enabled@var5282 ) {
77: if (@expr1073767979 enabled@var5282 ) {
78: enable (@expr1073767980 flag@var5281 ) ; }
79: else {
80: disable (@expr1073767981 flag@var5281 ) ; }
81: }
82: } ;
49: class SimpleEnableGroup<Checks::CheckList> {
50: uint32_t mFlags@var5283 ; mFlags@var5283 = 0 ;
51: public:
52: uint32_t intValue ( ) const {
53: return mFlags@var5283 ;
54: }
55: void clear ( ) {
56: mFlags@var5283 =@expr1073767982 0 ;
57: }
58: void fill ( ) {
59: mFlags@var5283 =@expr1073767983 0xFFFFFFFF ;
60: }
61: void setEnabledAll ( bool enabled@var5284 ) {
62: if (@expr1073767984 enabled@var5284 ) {
63: fill (@expr1073767985 ) ; }
64: else {
65: clear (@expr1073767986 ) ; }
66: }
67: bool isEnabled ( Checks :: CheckList flag@var5285 ) const {
68: return (@expr26163 mFlags@var5283 &@expr1073767988 (@expr26163 1U <<@expr1073767990 (@expr1073767991 uint32_t ) flag@var5285 ) ) !=@expr1073767992 0 ;
69: }
70: void enable ( Checks :: CheckList flag@var5286 ) {
71: mFlags@var5283 |=@expr1073767993 (@expr1073767994 1U <<@expr1073767995 (@expr1073767996 uint32_t ) flag@var5286 ) ;
72: }
73: void disable ( Checks :: CheckList flag@var5287 ) {
74: mFlags@var5283 &=@expr1073767997 ~@expr1073767998 (@expr1073767999 1U <<@expr1073768000 (@expr1073768001 uint32_t ) flag@var5287 ) ;
75: }
76: void setEnabled ( Checks :: CheckList flag@var5288 , bool enabled@var5289 ) {
77: if (@expr1073768002 enabled@var5289 ) {
78: enable (@expr1073768003 flag@var5288 ) ; }
79: else {
80: disable (@expr1073768004 flag@var5288 ) ; }
81: }
82: } ;

##file cppcheck-2.8/lib/calculate.h

30:
|
120:
121: std :: vector < long long > calculate<std::vector<longlong>> ( const std :: string & s@var5290 , const std :: vector < long long > & x@var5291 , const std :: vector < long long > & y@var5292 , bool * error@var5293 = nullptr )
122: {
123: return calculate<std::vector<longlong>,std::vector<longlong>> (@expr1073768005 s@var5290 , x@var5291 , y@var5292 , error@var5293 ) ;
124: }

##file cppcheck-2.8/lib/valueptr.h

18:
|
30:
31: struct ValuePtr<ConditionHandler> :: cloner<ConditionHandler> {
32: static ConditionHandler * apply ( const ConditionHandler * x@var5294 ) {
33: return new ConditionHandler (@expr1073768006 *@expr1073768007 static_cast < const ConditionHandler *@expr1073768008 > (@expr1073768009 x@var5294 ) ) ;
34: }
35: } ;
31: struct ValuePtr<Analyzer> :: cloner<Analyzer> {
32: static Analyzer * apply ( const Analyzer * x@var5295 ) {
33: return new Analyzer (@expr1073768010 *@expr1073768011 static_cast < const Analyzer *@expr1073768012 > (@expr1073768013 x@var5295 ) ) ;
34: }
35: } ;
31: struct ValuePtr<InferModel> :: cloner<InferModel> {
32: static InferModel * apply ( const InferModel * x@var5296 ) {
33: return new InferModel (@expr1073768014 *@expr1073768015 static_cast < const InferModel *@expr1073768016 > (@expr1073768017 x@var5296 ) ) ;
34: }
35: } ;

##file cppcheck-2.8/lib/calculate.h

24:
|
48:
49: std :: vector < long long > calculate<std::vector<longlong>,std::vector<longlong>> ( const std :: string & s@var5297 , const std :: vector < long long > & x@var5298 , const std :: vector < long long > & y@var5299 , bool * error@var5300 = nullptr )
50: {
51: auto wrap@var5301 ; wrap@var5301 =@expr1073768018 [@expr1073768019 ] (@expr1073768020 std ::@expr1073768021 vector < long long > z@var5302 ) {
52: return std ::@expr1073768022 vector < long long > {@expr1073768023 z@var5302 } ;
53: } ;
54: const long long maxBitsShift@var5303 =@expr1073768024 sizeof (@expr1073768025 long long ) *@expr1073768026 8 ;
55:
56: const long long maxBitsSignedShift@var5304 =@expr1073768027 maxBitsShift@var5303 -@expr1073768028 1 ;
57: switch (@expr1073768029 MathLib ::@expr1073768030 encodeMultiChar (@expr1073768031 s@var5297 ) ) {
58: case '+' :@expr26208 ;
59: return wrap@var5301 (@expr1073768033 x@var5298 +@expr1073768034 y@var5299 ) ;
60: case '-' :@expr26208 ;
61: return wrap@var5301 (@expr26212 x@var5298 -@expr26213 y@var5299 ) ;
62: case '*' :@expr26208 ;
63: return wrap@var5301 (@expr1073768039 x@var5298 *@expr1073768040 y@var5299 ) ;
64: case '/' :@expr26208 ;
65: if (@expr1073768042 isZero (@expr26219 y@var5299 ) ) {
66: if (@expr26220 error@var5300 ) {
67: *@expr26221 error@var5300 =@expr1073768046 true ; }
68: return std ::@expr1073768047 vector < long long > {@expr1073768048 } ;
69: }
70: return wrap@var5301 (@expr1073768049 x@var5298 /@expr1073768050 y@var5299 ) ;
71: case '%' :@expr26208 ;
72: if (@expr1073768052 isZero (@expr1073768053 long long (@expr26230 y@var5299 ) ) ) {
73: if (@expr26220 error@var5300 ) {
74: *@expr26221 error@var5300 =@expr1073768057 true ; }
75: return std ::@expr1073768058 vector < long long > {@expr1073768059 } ;
76: }
77: return wrap@var5301 (@expr1073768060 long long (@expr26237 x@var5298 ) %@expr1073768062 long long (@expr26230 y@var5299 ) ) ;
78: case '&' :@expr26208 ;
79: return wrap@var5301 (@expr1073768065 long long (@expr26237 x@var5298 ) &@expr1073768067 long long (@expr26230 y@var5299 ) ) ;
80: case '|' :@expr26208 ;
81: return wrap@var5301 (@expr1073768070 long long (@expr26237 x@var5298 ) |@expr1073768072 long long (@expr26230 y@var5299 ) ) ;
82: case '^' :@expr26208 ;
83: return wrap@var5301 (@expr1073768075 long long (@expr26237 x@var5298 ) ^@expr1073768077 long long (@expr26230 y@var5299 ) ) ;
84: case '>' :@expr26208 ;
85: return wrap@var5301 (@expr1073768080 x@var5298 >@expr1073768081 y@var5299 ) ;
86: case '<' :@expr26208 ;
87: return wrap@var5301 (@expr1073768083 x@var5298 <@expr1073768084 y@var5299 ) ;
88: case '<<' :@expr26208 ;
89: if (@expr26262 y@var5299 >=@expr26263 maxBitsSignedShift@var5304 ||@expr26264 y@var5299 <@expr26265 0 ||@expr26266 x@var5298 <@expr26267 0 ) {
90: if (@expr26220 error@var5300 ) {
91: *@expr26221 error@var5300 =@expr1073768094 true ; }
92: return std ::@expr1073768095 vector < long long > {@expr1073768096 } ;
93: }
94: return wrap@var5301 (@expr1073768097 long long (@expr26237 x@var5298 ) <<@expr1073768099 long long (@expr26230 y@var5299 ) ) ;
95: case '>>' :@expr26208 ;
96: if (@expr26262 y@var5299 >=@expr26263 maxBitsSignedShift@var5304 ||@expr26264 y@var5299 <@expr26265 0 ||@expr26266 x@var5298 <@expr26267 0 ) {
97: if (@expr26220 error@var5300 ) {
98: *@expr26221 error@var5300 =@expr1073768110 true ; }
99: return std ::@expr1073768111 vector < long long > {@expr1073768112 } ;
100: }
101: return wrap@var5301 (@expr1073768113 long long (@expr26237 x@var5298 ) >>@expr1073768115 long long (@expr26230 y@var5299 ) ) ;
102: case '&&' :@expr26208 ;
103: return wrap@var5301 (@expr1073768118 !@expr26295 isZero (@expr26296 x@var5298 ) &&@expr1073768121 !@expr26298 isZero (@expr26219 y@var5299 ) ) ;
104: case '||' :@expr26208 ;
105: return wrap@var5301 (@expr1073768125 !@expr26295 isZero (@expr26296 x@var5298 ) ||@expr1073768128 !@expr26298 isZero (@expr26219 y@var5299 ) ) ;
106: case '==' :@expr26208 ;
107: return wrap@var5301 (@expr1073768132 isEqual (@expr26309 x@var5298 , y@var5299 ) ) ;
108: case '!=' :@expr26208 ;
109: return wrap@var5301 (@expr1073768135 !@expr1073768136 isEqual (@expr26309 x@var5298 , y@var5299 ) ) ;
110: case '>=' :@expr26208 ;
111: return wrap@var5301 (@expr1073768139 x@var5298 >=@expr1073768140 y@var5299 ) ;
112: case '<=' :@expr26208 ;
113: return wrap@var5301 (@expr1073768142 x@var5298 <=@expr1073768143 y@var5299 ) ;
114: case '<=>' :@expr26208 ;
115: return wrap@var5301 (@expr26212 x@var5298 -@expr26213 y@var5299 ) ;
116: }
117: throw InternalError (@expr1073768147 nullptr , "Unknown operator: " +@expr1073768148 s@var5297 ) ;
118: }



##Value flow
Line 43
  INT always 0
  LONG always 1
  LONGLONG always 2
  FLOAT always 3
Line 44
  mIsUnsigned always {!<=-1,!>=2}
Line 51
  ( always {!<=-1,!>=2}
Line 52
  return always {!<=-1,!>=2}
  != always {!<=-1,!>=2}
  :: always 3
  FLOAT always 3
Line 54
  ( always {!<=-1,!>=2}
Line 55
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 3
  FLOAT always 3
Line 59
  ( always {!<=-1,!>=2}
Line 74
  ( always !<=-1
Line 78
  value possible {>=0@227,7110@21156,7119@21924,6830@35492,6788@46244}
Line 83
  ( always {!<=-1,!>=2}
Line 84
  ( always {!<=-1,!>=2}
Line 85
  ( always {!<=-1,!>=2}
Line 86
  ( always {!<=-1,!>=2}
Line 87
  ( always {!<=-1,!>=2}
Line 88
  ( always {!<=-1,!>=2}
Line 89
  ( always {!<=-1,!>=2}
Line 90
  ( always {!<=-1,!>=2}
Line 91
  ( always {!<=-1,!>=2}
Line 92
  ( always {!<=-1,!>=2}
Line 102
  ( always {!<=-1,!>=2}
  , always 1
  supportMicrosoftExtensions always {!<=-1,!>=2}
  = always 1
  true always 1
Line 115
  ( always !<=-1
Line 116
  ( always {!<=-1,!>=2}
Line 117
  ( always {!<=-1,!>=2}
Line 118
  ( always {!<=-1,!>=2}
Line 119
  ( always {!<=-1,!>=2}
Line 120
  ( always {!<=-1,!>=2}
Line 121
  ( always {!<=-1,!>=2}
Line 122
  ( always {!<=-1,!>=2}
Line 128
  ( always {!<=-1,!>=2}
Line 130
  ( always !<=-1
Line 137
  ( always {!<=-1,!>=2}
  , always !<=-1
  :: always !<=-1
  iPos always !<=-1
Line 66
  ( always {!<=-1,!>=2}
Line 67
  return always {!<=-1,!>=2}
  < always {!<=-1,!>=2}
Line 73
  ( always {!<=-1,!>=2}
Line 74
  return always {!<=-1,!>=2}
  ( always !<=-1
  == always {!<=-1,!>=2}
  1 always 1
Line 80
  result always {!<=-1,!>=2}
Line 81
  result always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  > always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  x {!>=symbolic=(y+1),<=symbolic=(y)}
  < always {!<=-1,!>=2}
  y {!<=symbolic=(x-1),>=symbolic=(x)}
Line 88
  Upper always 0
  Lower always 1
  Point always 2
Line 90
  = always 0
  0 always 0
Line 91
  :: always 12
  INT always 12
Line 94
  nullptr always 0
Line 95
  0.0 always 0
Line 98
  nullptr always 0
Line 99
  0U always 0
Line 100
  safe always {!<=-1,!>=2}
  false always 0
Line 101
  conditional always {!<=-1,!>=2}
  false always 0
Line 102
  macro always {!<=-1,!>=2}
  false always 0
Line 103
  defaultArg always {!<=-1,!>=2}
  false always 0
Line 104
  0 always 0
Line 105
  0 always 0
Line 108
  nullptr always 0
Line 117
  ( always {!<=-1,!>=2}
Line 118
  != always {!<=-1,!>=2}
Line 119
  return always {!<=-1,!>=2}
  false always 0
Line 120
  valueType always symbolic=(rhs.valueType)
Line 121
  :: always 0
  INT always 0
Line 122
  :: always 5
  CONTAINER_SIZE always 5
Line 123
  :: always 7
  BUFFER_SIZE always 7
Line 124
  :: always 8
  ITERATOR_START always 8
Line 125
  :: always 9
  ITERATOR_END always 9
Line 126
  != always {!<=-1,!>=2}
Line 127
  return always {!<=-1,!>=2}
  false always 0
Line 129
  :: always 1
  TOK always 1
Line 130
  != always {!<=-1,!>=2}
Line 131
  return always {!<=-1,!>=2}
  false always 0
Line 133
  :: always 2
  FLOAT always 2
Line 135
  > always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  floatValue possible <=symbolic=(rhs.floatValue)
  < always {!<=-1,!>=2}
  . possible >=symbolic=(floatValue)
Line 136
  return always {!<=-1,!>=2}
  false always 0
Line 138
  :: always 3
  MOVED always 3
Line 139
  != always {!<=-1,!>=2}
Line 140
  return always {!<=-1,!>=2}
  false always 0
Line 142
  :: always 4
  UNINIT always 4
Line 144
  :: always 6
  LIFETIME always 6
Line 145
  != always {!<=-1,!>=2}
Line 146
  return always {!<=-1,!>=2}
  false always 0
Line 148
  :: always 10
  SYMBOLIC always 10
Line 149
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 150
  return always {!<=-1,!>=2}
  false always 0
Line 151
  != always {!<=-1,!>=2}
Line 152
  return always {!<=-1,!>=2}
  false always 0
Line 155
  return always {!<=-1,!>=2}
  true always 1
Line 161
  :: always 0
  INT always 0
Line 162
  :: always 10
  SYMBOLIC always 10
Line 163
  :: always 7
  BUFFER_SIZE always 7
Line 164
  :: always 5
  CONTAINER_SIZE always 5
Line 165
  :: always 8
  ITERATOR_START always 8
Line 166
  :: always 9
  ITERATOR_END always 9
Line 170
  :: always 2
  FLOAT always 2
Line 174
  :: always 4
  UNINIT always 4
Line 175
  :: always 1
  TOK always 1
Line 176
  :: always 6
  LIFETIME always 6
Line 177
  :: always 3
  MOVED always 3
Line 185
  result always {!<=-1,!>=2}
Line 186
  result always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
Line 190
  result always {!<=-1,!>=2}
Line 192
  ( possible {lifetime[Object]=(x),lifetime[Object]=(result),lifetime[Object]=(compare)}
  ( possible lifetime[Object]=(result)
  result always {!<=-1,!>=2}
  ( possible lifetime[Object]=(compare)
Line 197
  ( always {!<=-1,!>=2}
Line 198
  ! always {!<=-1,!>=2}
  this always !0
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
Line 199
  this always !0
  == always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  this always !0
Line 200
  result always {!<=-1,!>=2}
  result always {!<=-1,!>=2}
  = always 0
  false always 0
Line 202
  this always !0
Line 203
  ( possible {lifetime[Object]=(result),lifetime[Object]=(rhs),lifetime[Object]=(compare)}
  ( possible lifetime[Object]=(result)
  result always 0
  ( possible lifetime[Object]=(rhs)
  ( possible lifetime[Object]=(compare)
Line 204
  return always {!<=-1,!>=2}
  result {!<=-1,!>=2,0}
Line 207
  ( always {!<=-1,!>=2}
Line 208
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 209
  return always {!<=-1,!>=2}
  false always 0
Line 211
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 212
  == always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 213
  == always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 214
  conditional always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  . always {!<=-1,!>=2}
  conditional always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 215
  defaultArg always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  . always {!<=-1,!>=2}
  defaultArg always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 216
  == always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 217
  == always {!<=-1,!>=2}
Line 220
  ( always {!<=-1,!>=2}
Line 221
  return always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  this always !0
  == always {!<=-1,!>=2}
Line 225
  ( always {!<=-1,!>=2}
Line 226
  result always {!<=-1,!>=2}
  result always {!<=-1,!>=2}
  = always 0
  false always 0
Line 227
  this always !0
  ( possible {lifetime[Object]=(x),lifetime[Object]=(result)}
  ( possible lifetime[Object]=(result)
  result always 0
Line 228
  return always {!<=-1,!>=2}
  result {!<=-1,!>=2,0}
Line 232
  bound possible 0
  == {!<=-1,!>=2,0}
  :: always 1
  Lower always 1
Line 233
  this always !0
Line 234
  bound always !1
  == always {!<=-1,!>=2}
  :: always 0
  Upper always 0
Line 235
  this always !0
Line 239
  bound possible 0
  == {!<=-1,!>=2,0}
  :: always 1
  Lower always 1
Line 240
  = always 0
  :: always 0
  Upper always 0
Line 241
  bound always !1
  == always {!<=-1,!>=2}
  :: always 0
  Upper always 0
Line 242
  = always 1
  :: always 1
  Lower always 1
Line 255
  INT always 0
Line 256
  TOK always 1
Line 257
  FLOAT always 2
Line 258
  MOVED always 3
Line 259
  UNINIT always 4
Line 260
  CONTAINER_SIZE always 5
Line 261
  LIFETIME always 6
Line 262
  BUFFER_SIZE always 7
Line 263
  ITERATOR_START always 8
Line 264
  ITERATOR_END always 9
Line 265
  SYMBOLIC always 10
Line 267
  ( always {!<=-1,!>=2}
Line 268
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 0
  INT always 0
Line 270
  ( always {!<=-1,!>=2}
Line 271
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 1
  TOK always 1
Line 273
  ( always {!<=-1,!>=2}
Line 274
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 2
  FLOAT always 2
Line 276
  ( always {!<=-1,!>=2}
Line 277
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 3
  MOVED always 3
Line 279
  ( always {!<=-1,!>=2}
Line 280
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 4
  UNINIT always 4
Line 282
  ( always {!<=-1,!>=2}
Line 283
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 5
  CONTAINER_SIZE always 5
Line 285
  ( always {!<=-1,!>=2}
Line 286
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 6
  LIFETIME always 6
Line 288
  ( always {!<=-1,!>=2}
Line 289
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 7
  BUFFER_SIZE always 7
Line 291
  ( always {!<=-1,!>=2}
Line 292
  return always {!<=-1,!>=2}
  valueType possible 9
  == {!<=-1,!>=2,0}
  :: always 8
  ITERATOR_START always 8
  || always {!<=-1,!>=2}
  valueType always !8
  == always {!<=-1,!>=2}
  :: always 9
  ITERATOR_END always 9
Line 294
  ( always {!<=-1,!>=2}
Line 295
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 8
  ITERATOR_START always 8
Line 297
  ( always {!<=-1,!>=2}
Line 298
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 9
  ITERATOR_END always 9
Line 300
  ( always {!<=-1,!>=2}
Line 301
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 10
  SYMBOLIC always 10
Line 304
  ( always {!<=-1,!>=2}
Line 305
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 6
  LIFETIME always 6
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
Line 308
  ( always {!<=-1,!>=2}
Line 309
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 6
  LIFETIME always 6
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 1
  Argument always 1
Line 312
  ( always {!<=-1,!>=2}
Line 313
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 6
  LIFETIME always 6
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 2
  SubFunction always 2
Line 316
  ( always {!<=-1,!>=2}
Line 317
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 333
  NonMovedVariable always 0
  MovedVariable always 1
  ForwardedVariable always 2
Line 347
  safe always {!<=-1,!>=2}
Line 350
  conditional always {!<=-1,!>=2}
Line 353
  macro always {!<=-1,!>=2}
Line 356
  defaultArg always {!<=-1,!>=2}
Line 373
  Object always 0
Line 375
  SubObject always 1
Line 377
  Lambda always 2
Line 379
  Iterator always 3
Line 381
  Address always 4
Line 384
  Local always 0
  Argument always 1
  SubFunction always 2
  ThisPointer always 3
  ThisValue always 4
Line 394
  Possible always 0
Line 396
  Known always 1
Line 398
  Inconclusive always 2
Line 400
  Impossible always 3
Line 404
  = always 1
  :: always 1
  Known always 1
Line 407
  ( always {!<=-1,!>=2}
Line 408
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 1
  Known always 1
Line 415
  ( always {!<=-1,!>=2}
Line 416
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
Line 419
  ( always {!<=-1,!>=2}
Line 420
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 3
  Impossible always 3
Line 424
  = always 3
  :: always 3
  Impossible always 3
Line 427
  inconclusive always {!<=-1,!>=2}
  = always 1
  true always 1
Line 428
  inconclusive {!<=-1,!>=2,0@202,1@202}
Line 429
  = always 2
  :: always 2
  Inconclusive always 2
Line 432
  ( always {!<=-1,!>=2}
Line 433
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 2
  Inconclusive always 2
Line 437
  ( always {!<=-1,!>=2}
Line 441
  ( always {!<=-1,!>=2}
Line 442
  return always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  defaultArg always {!<=-1,!>=2}
Line 445
  ( always {!<=-1,!>=2}
Line 456
  ( always !<=-1
Line 460
  ( always {!<=-1,!>=2}
Line 462
  = always 1
  true always 1
Line 467
  ( always {!<=-1,!>=2}
  , always 0
  = always 0
  nullptr always 0
  , always 20
  = always 20
  20 always 20
Line 471
  addressOf always {!<=-1,!>=2}
Line 473
  inconclusive always {!<=-1,!>=2}
Line 475
  nullptr always 0
  addressOf always {!<=-1,!>=2}
  false always 0
  inconclusive always {!<=-1,!>=2}
  false always 0
Line 478
  addressOf always {!<=-1,!>=2}
  false always 0
  ( possible lifetime[Object]=(errorPath)
  inconclusive always {!<=-1,!>=2}
  false always 0
Line 481
  addressOf always {!<=-1,!>=2}
Line 482
  addressOf always {!<=-1,!>=2}
  addressOf always {!<=-1,!>=2}
  ( possible lifetime[Object]=(errorPath)
  inconclusive always {!<=-1,!>=2}
  false always 0
Line 485
  b always {!<=-1,!>=2}
Line 487
  . always {!<=-1,!>=2}
  addressOf always {!<=-1,!>=2}
  = {!<=-1,!>=2,0@137,1@158}
  b {!<=-1,!>=2,0@137,1@158}
Line 491
  b always {!<=-1,!>=2}
Line 493
  . always {!<=-1,!>=2}
  inconclusive always {!<=-1,!>=2}
  = {!<=-1,!>=2,0@128,1@128}
  b {!<=-1,!>=2,0@128,1@128}
Line 511
  = always 0
  false always 0
Line 514
  ( always {!<=-1,!>=2}
Line 516
  , always 0
  = always 0
  nullptr always 0
Line 520
  ( always {!<=-1,!>=2}
Line 526
  , always 0
  = always 0
  false always 0
Line 529
  = always 0
  false always 0
Line 530
  = always 0
  0 always 0
Line 532
  , always 0
  = always 0
  nullptr always 0
  , always 1
  = always 1
  true always 1
Line 35
  mFlag always !<=-1
  0 always 0
Line 39
  ! always {!<=-1,!>=2}
Line 40
  mFlag always !<=-1
Line 44
  None always 0
  = always 0
  0 always 0
  , always 1
Line 45
  Read always 1
  = always 1
  1 always 1
  << always 1
  0 always 0
  , always 2
Line 46
  Write always 2
  = always 2
  1 always 1
  << always 2
  1 always 1
  , always 4
Line 47
  Invalid always 4
  = always 4
  1 always 1
  << always 4
  2 always 2
  , always 8
Line 48
  Inconclusive always 8
  = always 8
  1 always 1
  << always 8
  3 always 3
  , always 16
Line 49
  Match always 16
  = always 16
  1 always 1
  << always 16
  4 always 4
  , always 32
Line 50
  Idempotent always 32
  = always 32
  1 always 1
  << always 32
  5 always 5
  , always 64
Line 51
  Incremental always 64
  = always 64
  1 always 1
  << always 64
  6 always 6
  , always 128
Line 52
  SymbolicMatch always 128
  = always 128
  1 always 1
  << always 128
  7 always 7
  , always 256
Line 53
  Internal always 256
  = always 256
  1 always 1
  << always 256
  8 always 8
Line 56
  f always !<=-1
  state always {!<=-1,!>=2}
  = always 1
  true always 1
Line 57
  mFlag always !<=-1
  = always !<=-1
  state always {!<=-1,!>=2}
  ? always !<=-1
  mFlag always !<=-1
  | always !<=-1
  f always !<=-1
  : always !<=-1
  mFlag always !<=-1
  & always !<=-1
  ~ always !<=0
  f always !<=-1
Line 60
  ( always {!<=-1,!>=2}
  f always !<=-1
Line 61
  return always {!<=-1,!>=2}
  mFlag always !<=-1
  & always !<=-1
  f {!<=-1,16@178,256@179,128@180,64@181,32@182,8@185,4@186,2@187,1@188}
  != always {!<=-1,!>=2}
  0 always 0
Line 64
  ( always {!<=-1,!>=2}
Line 65
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  Read always 1
Line 68
  ( always {!<=-1,!>=2}
Line 69
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  Write always 2
Line 72
  ( always {!<=-1,!>=2}
Line 73
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  Invalid always 4
Line 76
  ( always {!<=-1,!>=2}
Line 77
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  Inconclusive always 8
Line 80
  ( always {!<=-1,!>=2}
Line 81
  return always {!<=-1,!>=2}
  mFlag always !<=-1
  == always {!<=-1,!>=2}
  None always 0
Line 84
  ( always {!<=-1,!>=2}
Line 85
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 88
  ( always {!<=-1,!>=2}
Line 89
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  Idempotent always 32
Line 92
  ( always {!<=-1,!>=2}
Line 93
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  Incremental always 64
Line 96
  ( always {!<=-1,!>=2}
Line 97
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  SymbolicMatch always 128
Line 100
  ( always {!<=-1,!>=2}
Line 101
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  Internal always 256
Line 104
  ( always {!<=-1,!>=2}
Line 105
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  Match always 16
Line 109
  . always !<=-1
  mFlag always !<=-1
Line 110
  this always !0
Line 118
  ( always {!<=-1,!>=2}
Line 119
  return always {!<=-1,!>=2}
  . always !<=-1
  mFlag always !<=-1
  == always {!<=-1,!>=2}
  . always !<=-1
  mFlag always !<=-1
Line 122
  ( always {!<=-1,!>=2}
Line 123
  return always {!<=-1,!>=2}
  . always !<=-1
  mFlag always !<=-1
  != always {!<=-1,!>=2}
  . always !<=-1
  mFlag always !<=-1
Line 127
  mFlag always !<=-1
Line 130
  None always 0
  Bail always 1
  Escape always 2
  Modified always 3
  Inconclusive always 4
  Conditional always 5
Line 133
  = always 0
  :: always 0
  None always 0
  = always 0
  :: always 0
  None always 0
Line 140
  == always {!<=-1,!>=2}
  :: always 0
  None always 0
Line 146
  Forward always 0
  Reverse always 1
Line 150
  None always 0
  = always 0
  0 always 0
  , always 1
Line 151
  Quiet always 1
  = always 1
  1 always 1
  << always 1
  0 always 0
  , always 2
Line 152
  Absolute always 2
  = always 2
  1 always 1
  << always 2
  1 always 1
  , always 4
Line 153
  ContainerEmpty always 4
  = always 4
  1 always 1
  << always 4
  2 always 2
Line 157
  Integral always 0
  ContainerEmpty always 1
Line 160
  = always 0
  0 always 0
Line 162
  = always 0
  0 always 0
Line 164
  = always 0
  nullptr always 0
  = always 0
  0 always 0
Line 165
  = always 0
  nullptr always 0
Line 167
  :: always 0
  Integral always 0
Line 170
  ( always {!<=-1,!>=2}
  = always 0
  0 always 0
Line 172
  ( always {!<=-1,!>=2}
  = always 0
  0 always 0
Line 174
  ( always {!<=-1,!>=2}
  , always {!<=-1,!>=2}
  modified always {!<=-1,!>=2}
  = always 0
  0 always 0
Line 178
  ( always {!<=-1,!>=2}
  = always 0
  0 always 0
Line 180
  ( always {!<=-1,!>=2}
  = always 0
  0 always 0
Line 182
  state always {!<=-1,!>=2}
  flags always !<=-1
  = always 0
  0 always 0
  = always 0
  0 always 0
Line 184
  , always ""
  = always ""
  "" always ""
  = always 0
  0 always 0
Line 36
  AST always 0
  SYNTAX always 1
  UNKNOWN_MACRO always 2
  INTERNAL always 3
  LIMIT always 4
  INSTANTIATION always 5
Line 37
  = always 3
  INTERNAL always 3
Line 47
  normal always 0
  inconclusive always 1
  safe always 2
  experimental always 3
Line 54
  unusedFunction always 0
  missingInclude always 1
  internalCheck always 2
Line 68
  none always 0
Line 74
  error always 1
Line 80
  warning always 2
Line 87
  style always 3
Line 93
  performance always 4
Line 101
  portability always 5
Line 108
  information always 6
Line 113
  debug always 7
Line 121
  ( possible lifetime[SubObject]=(cweId)
  cweId always !<=-1
  id always !<=-1
  cweId always !<=-1
Line 122
  id always !<=-1
Line 47
  ( always {!<=-1,!>=2}
Line 49
  return always {!<=-1,!>=2}
  != always {!<=-1,!>=2}
Line 53
  ( always {!<=-1,!>=2}
Line 55
  return always {!<=-1,!>=2}
  != always {!<=-1,!>=2}
Line 59
  ( always {!<=-1,!>=2}
Line 61
  return always {!<=-1,!>=2}
  != always {!<=-1,!>=2}
Line 67
  ( always !<=-1
Line 69
  return always !<=-1
  ( always !<=-1
Line 73
  ( always {!<=-1,!>=2}
Line 75
  return always {!<=-1,!>=2}
  ! {!<=-1,!>=2,0}
  str possible size=0
  ( {!<=-1,!>=2,1}
  && always {!<=-1,!>=2}
  str always !size=0
  == always {!<=-1,!>=2}
  c possible {39@13999,34@14255}
Line 78
  ( always {!<=-1,!>=2}
  , always !<=-1
  endlen always !<=-1
Line 80
  return always {!<=-1,!>=2}
  ( always !<=-1
  >= always {!<=-1,!>=2}
  endlen always !<=-1
  && always {!<=-1,!>=2}
  ( {!<=-1,>=symbolic=(endlen),!<=symbolic=(endlen-1)}
  - always !<=-1
  endlen {!<=-1,<=symbolic=(str.size()),!>=symbolic=(str.size()+1)}
  endlen {!<=-1,<=symbolic=(str.size()),!>=symbolic=(str.size()+1)}
  == always {!<=-1,!>=2}
  0 always 0
Line 84
  ( always {!<=-1,!>=2}
  ( always !0
  & always !0
Line 86
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  1 always 1
Line 89
  ( always {!<=-1,!>=2}
Line 91
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  q possible {39@54,34@55}
Line 92
  return always {!<=-1,!>=2}
  false always 0
Line 93
  ( always !<=-1
  + always !<=0
  1 always 1
  > always {!<=-1,!>=2}
  p possible {""@54,""@55,""@56,"U"@57,"U"@58,"u"@59,"u"@60,"u8"@61,"u8"@62}
  ( always !<=-1
  && always {!<=-1,!>=2}
  0 always 0
  ( always !<=-1
  + always !<=0
  1 always 1
  == always {!<=-1,!>=2}
  0 always 0
Line 94
  return always {!<=-1,!>=2}
  true always 1
Line 95
  return always {!<=-1,!>=2}
  false always 0
Line 98
  ( always {!<=-1,!>=2}
Line 100
  "" always ""
  "u8" always "u8"
  "u" always "u"
  "U" always "U"
  "L" always "L"
Line 102
  ( always {!<=-1,!>=2}
  q possible {39@172,34@173}
Line 103
  return always {!<=-1,!>=2}
  true always 1
Line 105
  return always {!<=-1,!>=2}
  false always 0
Line 108
  ( always {!<=-1,!>=2}
Line 110
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  '"' always 34
Line 113
  ( always {!<=-1,!>=2}
Line 115
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  '\'' always 39
Line 120
  quotePos always !<=-1
  = always !<=-1
  ( always !<=-1
  q possible {39@169,34@171}
Line 121
  quotePos {symbolic=(str.find(q)),!<=-1}
  + always !<=0
  1U always 1
  ( always !<=-1
  - always !<=-1
  quotePos {symbolic=(str.find(q)),!<=-1}
  - always !<=-1
  2U always 2
Line 126
  ( always {!<=-1,!>=2}
Line 127
  '"' always 34
Line 128
  "" always ""
Line 133
  ( always {!<=-1,!>=2}
Line 134
  '\'' always 39
Line 135
  "" always ""
Line 140
  i possible {2,3}
  == {!<=-1,!>=2,0}
  1 always 1
Line 141
  "st" always "st"
Line 142
  i {3,!1}
  == {!<=-1,!>=2,0}
  2 always 2
Line 143
  "nd" always "nd"
Line 144
  i always {!1,!2}
  == always {!<=-1,!>=2}
  3 always 3
Line 145
  "rd" always "rd"
Line 146
  "th" always "th"
Line 151
  ( always {!<=-1,!>=2}
Line 153
  ( always {!<=-1,!>=2}
Line 155
  ( always {!<=-1,!>=2}
Line 38
  C89 always 0
  C99 always 1
  C11 always 2
  CLatest always 2
  = always 2
  C11 always 2
Line 41
  CPP03 always 0
  CPP11 always 1
  CPP14 always 2
  CPP17 always 3
  CPP20 always 4
  CPP23 always 5
  CPPLatest always 5
  = always 5
  CPP23 always 5
Line 47
  CLatest always 2
  CPPLatest always 5
Line 49
  ( always {!<=-1,!>=2}
Line 50
  = possible size=3
  str possible size=3
Line 51
  str possible size=3
  == always {!<=-1,!>=2}
  "c89" always "c89"
  || always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  "C89" always "C89"
Line 52
  = always 0
  C89 always 0
Line 53
  return always {!<=-1,!>=2}
  true always 1
Line 55
  str possible size=3
  == always {!<=-1,!>=2}
  "c99" always "c99"
  || always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  "C99" always "C99"
Line 56
  = always 1
  C99 always 1
Line 57
  return always {!<=-1,!>=2}
  true always 1
Line 59
  str possible size=3
  == always {!<=-1,!>=2}
  "c11" always "c11"
  || always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  "C11" always "C11"
Line 60
  = always 2
  C11 always 2
Line 61
  return always {!<=-1,!>=2}
  true always 1
Line 63
  return always {!<=-1,!>=2}
  false always 0
Line 67
  C89 always 0
Line 68
  "c89" always "c89"
Line 69
  C99 always 1
Line 70
  "c99" always "c99"
Line 71
  C11 always 2
Line 72
  "c11" always "c11"
Line 74
  "" always ""
Line 77
  std possible size=3
  == always {!<=-1,!>=2}
  "c89" always "c89"
Line 78
  :: always 0
  C89 always 0
Line 80
  std possible size=3
  == always {!<=-1,!>=2}
  "c99" always "c99"
Line 81
  :: always 1
  C99 always 1
Line 83
  == always {!<=-1,!>=2}
  "c11" always "c11"
Line 84
  :: always 2
  C11 always 2
Line 86
  :: always 2
  CLatest always 2
Line 88
  ( always {!<=-1,!>=2}
Line 92
  return always {!<=-1,!>=2}
  ! {!<=-1,!>=2,0}
  stdValue possible size=0
  ( {!<=-1,!>=2,1}
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
Line 99
  CPP03 always 0
Line 100
  "c++03" always "c++03"
Line 101
  CPP11 always 1
Line 102
  "c++11" always "c++11"
Line 103
  CPP14 always 2
Line 104
  "c++14" always "c++14"
Line 105
  CPP17 always 3
Line 106
  "c++17" always "c++17"
Line 107
  CPP20 always 4
Line 108
  "c++20" always "c++20"
Line 109
  CPP23 always 5
Line 110
  "c++23" always "c++23"
Line 112
  "" always ""
Line 115
  std possible size=5
  == always {!<=-1,!>=2}
  "c++03" always "c++03"
Line 116
  :: always 0
  CPP03 always 0
Line 118
  std possible size=5
  == always {!<=-1,!>=2}
  "c++11" always "c++11"
Line 119
  :: always 1
  CPP11 always 1
Line 121
  std possible size=5
  == always {!<=-1,!>=2}
  "c++14" always "c++14"
Line 122
  :: always 2
  CPP14 always 2
Line 124
  std possible size=5
  == always {!<=-1,!>=2}
  "c++17" always "c++17"
Line 125
  :: always 3
  CPP17 always 3
Line 127
  std possible size=5
  == always {!<=-1,!>=2}
  "c++20" always "c++20"
Line 128
  :: always 4
  CPP20 always 4
Line 130
  == always {!<=-1,!>=2}
  "c++23" always "c++23"
Line 131
  :: always 5
  CPP23 always 5
Line 133
  :: always 5
  CPPLatest always 5
Line 58
  OK always 0
  FILE_NOT_FOUND always 1
  BAD_XML always 2
  UNKNOWN_ELEMENT always 3
  MISSING_ATTRIBUTE always 4
  BAD_ATTRIBUTE_VALUE always 5
  UNSUPPORTED_FORMAT always 6
  DUPLICATE_PLATFORM_TYPE always 7
  PLATFORM_TYPE_REDEFINED always 8
Line 62
  :: always 0
  OK always 0
Line 63
  ( possible lifetime[SubObject]=(e)
Line 65
  ( possible lifetime[SubObject]=(e)
  && always {!<=-1,!>=2}
Line 74
  ( always {!<=-1,!>=2}
  , always !<=-1
  len always !<=-1
Line 79
  none always 0
  malloc always 1
  calloc always 2
  strdup always 3
Line 84
  initData always {!<=-1,!>=2}
Line 118
  ? possible 0
  af always !0
  : always 0
  0 always 0
Line 124
  ? possible 0
  af always !0
  : always 0
  0 always 0
Line 138
  , always 1
  = always 1
  1 always 1
Line 141
  = possible 1
  reallocArg possible 1
Line 145
  , always {!<=-1,!>=2}
  noreturn always {!<=-1,!>=2}
Line 146
  = possible {1,0}
  noreturn always {!<=-1,!>=2}
  ? possible {1,0}
  :: always 1
  True always 1
  : always 0
  :: always 0
  False always 0
Line 149
  ( always {!<=-1,!>=2}
Line 152
  ( always {!<=-1,!>=2}
Line 153
  return always {!<=-1,!>=2}
  > always {!<=-1,!>=2}
  0 always 0
  && always {!<=-1,!>=2}
  id {>=1,!<=0}
  & possible {0,1}
  1 always 1
  == {1,0,!<=-1,!>=2}
  0 always 0
Line 155
  ( always {!<=-1,!>=2}
Line 156
  return always {!<=-1,!>=2}
  > always {!<=-1,!>=2}
  0 always 0
  && always {!<=-1,!>=2}
  . {>=1,!<=0}
  & possible {0,1}
  1 always 1
  == {1,0,!<=-1,!>=2}
  0 always 0
Line 160
  ( always {!<=-1,!>=2}
Line 161
  return always {!<=-1,!>=2}
  > always {!<=-1,!>=2}
  0 always 0
  && always {!<=-1,!>=2}
  id {>=1,!<=0}
  & possible {0,1}
  1 always 1
  == {0,1,!<=-1,!>=2}
  1 always 1
Line 163
  ( always {!<=-1,!>=2}
Line 164
  return always {!<=-1,!>=2}
  > always {!<=-1,!>=2}
  0 always 0
  && always {!<=-1,!>=2}
  . {>=1,!<=0}
  & possible {0,1}
  1 always 1
  == {0,1,!<=-1,!>=2}
  1 always 1
Line 167
  ( always {!<=-1,!>=2}
Line 169
  ( always {!<=-1,!>=2}
Line 170
  ( always {!<=-1,!>=2}
Line 190
  ( always {!<=-1,!>=2}
Line 191
  ( always {!<=-1,!>=2}
Line 193
  NONE always 0
  DEFAULT always 1
  ERROR_CODE always 2
Line 201
  ( always {!<=-1,!>=2}
Line 202
  ( always {!<=-1,!>=2}
Line 204
  ( always {!<=-1,!>=2}
Line 209
  -1 always -1
Line 210
  -1 always -1
Line 211
  arrayLike_indexOp always {!<=-1,!>=2}
  false always 0
Line 212
  stdStringLike always {!<=-1,!>=2}
  false always 0
Line 213
  stdAssociativeLike always {!<=-1,!>=2}
  false always 0
Line 214
  opLessAllowed always {!<=-1,!>=2}
  true always 1
Line 215
  hasInitializerListConstructor always {!<=-1,!>=2}
  false always 0
Line 216
  unstableErase always {!<=-1,!>=2}
  false always 0
Line 217
  unstableInsert always {!<=-1,!>=2}
  false always 0
Line 218
  view always {!<=-1,!>=2}
  false always 0
Line 222
  RESIZE always 0
Line 223
  CLEAR always 1
Line 224
  PUSH always 2
Line 225
  POP always 3
Line 226
  FIND always 4
Line 227
  INSERT always 5
Line 228
  ERASE always 6
Line 229
  CHANGE_CONTENT always 7
Line 230
  CHANGE always 8
Line 231
  CHANGE_INTERNAL always 9
Line 232
  NO_ACTION always 10
Line 235
  AT_INDEX always 0
Line 236
  ITEM always 1
Line 237
  BUFFER always 2
Line 238
  BUFFER_NT always 3
Line 239
  START_ITERATOR always 4
Line 240
  END_ITERATOR always 5
Line 241
  ITERATOR always 6
Line 242
  SIZE always 7
Line 243
  EMPTY always 8
Line 244
  NO_YIELD always 9
Line 259
  arrayLike_indexOp always {!<=-1,!>=2}
Line 260
  stdStringLike always {!<=-1,!>=2}
Line 261
  stdAssociativeLike always {!<=-1,!>=2}
Line 262
  opLessAllowed always {!<=-1,!>=2}
Line 263
  hasInitializerListConstructor always {!<=-1,!>=2}
Line 264
  unstableErase always {!<=-1,!>=2}
Line 265
  unstableInsert always {!<=-1,!>=2}
Line 266
  view always {!<=-1,!>=2}
Line 269
  :: possible {symbolic=(functions.end()),end=0}
  i possible {symbolic=(functions.end()),end=0}
  = possible lifetime[Iterator]=(functions)
  ( possible lifetime[Iterator]=(functions)
Line 270
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(functions),end=0}
Line 271
  i always {!symbolic=(functions.end()),!end=0}
Line 272
  :: always 10
  NO_ACTION always 10
Line 276
  :: possible {symbolic=(functions.end()),end=0}
  i possible {symbolic=(functions.end()),end=0}
  = possible lifetime[Iterator]=(functions)
  ( possible lifetime[Iterator]=(functions)
Line 277
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(functions),end=0}
Line 278
  i always {!symbolic=(functions.end()),!end=0}
Line 279
  :: always 9
  NO_YIELD always 9
Line 286
  , always 0
  iterator always {!<=-1,!>=2}
  = always 0
  false always 0
Line 287
  , always 0
  = always 0
  nullptr always 0
Line 292
  notbool always {!<=-1,!>=2}
  false always 0
Line 293
  notnull always {!<=-1,!>=2}
  false always 0
Line 294
  -1 always -1
Line 295
  formatstr always {!<=-1,!>=2}
  false always 0
Line 296
  strz always {!<=-1,!>=2}
  false always 0
Line 297
  optional always {!<=-1,!>=2}
  false always 0
Line 298
  variadic always {!<=-1,!>=2}
  false always 0
Line 302
  notbool always {!<=-1,!>=2}
Line 303
  notnull always {!<=-1,!>=2}
Line 305
  formatstr always {!<=-1,!>=2}
Line 306
  strz always {!<=-1,!>=2}
Line 307
  optional always {!<=-1,!>=2}
Line 308
  variadic always {!<=-1,!>=2}
Line 313
  0 always 0
  it always {!<=-1,!>=2}
  false always 0
  first always {!<=-1,!>=2}
  false always 0
  last always {!<=-1,!>=2}
  false always 0
Line 316
  it always {!<=-1,!>=2}
Line 317
  first always {!<=-1,!>=2}
Line 318
  last always {!<=-1,!>=2}
Line 324
  NONE always 0
  STRLEN always 1
  ARGVALUE always 2
  SIZEOF always 3
  MUL always 4
  VALUE always 5
Line 325
  ( possible lifetime[SubObject]=(t)
  0 always 0
  0 always 0
Line 334
  DIR_IN always 0
Line 335
  DIR_OUT always 1
Line 336
  DIR_INOUT always 2
Line 337
  DIR_UNKNOWN always 3
Line 344
  use always {!<=-1,!>=2}
Line 345
  leakignore always {!<=-1,!>=2}
Line 346
  isconst always {!<=-1,!>=2}
Line 347
  ispure always {!<=-1,!>=2}
Line 349
  ignore always {!<=-1,!>=2}
Line 350
  formatstr always {!<=-1,!>=2}
Line 351
  formatstr_scan always {!<=-1,!>=2}
Line 352
  formatstr_secure always {!<=-1,!>=2}
Line 356
  use always {!<=-1,!>=2}
  false always 0
Line 357
  leakignore always {!<=-1,!>=2}
  false always 0
Line 358
  isconst always {!<=-1,!>=2}
  false always 0
Line 359
  ispure always {!<=-1,!>=2}
  false always 0
Line 360
  :: always 0
  NONE always 0
Line 361
  ignore always {!<=-1,!>=2}
  false always 0
Line 362
  formatstr always {!<=-1,!>=2}
  false always 0
Line 363
  formatstr_scan always {!<=-1,!>=2}
  false always 0
Line 364
  formatstr_secure always {!<=-1,!>=2}
  false always 0
Line 365
  :: always 10
  NO_ACTION always 10
Line 366
  :: always 9
  NO_YIELD always 9
Line 372
  ( always {!<=-1,!>=2}
Line 373
  ( always {!<=-1,!>=2}
Line 374
  ( always {!<=-1,!>=2}
  , always {!<=-1,!>=2}
  pure always {!<=-1,!>=2}
Line 375
  ( always {!<=-1,!>=2}
Line 377
  ( always {!<=-1,!>=2}
Line 379
  return always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  arg always !0
  . always {!<=-1,!>=2}
  notbool always {!<=-1,!>=2}
Line 382
  ( always {!<=-1,!>=2}
Line 383
  ( always {!<=-1,!>=2}
  , always 0
  = always 0
  0 always 0
  , always 0
  = always 0
  nullptr always 0
Line 385
  ( always {!<=-1,!>=2}
Line 387
  return always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  arg always !0
  . always {!<=-1,!>=2}
  formatstr always {!<=-1,!>=2}
Line 390
  ( always {!<=-1,!>=2}
Line 392
  return always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  arg always !0
  . always {!<=-1,!>=2}
  strz always {!<=-1,!>=2}
Line 395
  ( always {!<=-1,!>=2}
Line 396
  ( always {!<=-1,!>=2}
Line 400
  arg always !0
Line 404
  le always 0
  lt always 1
  eq always 2
  ge always 3
  gt always 4
  range always 5
Line 407
  ( always {!<=-1,!>=2}
Line 408
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 413
  argnr possible {<=symbolic=(args.size())@98,1@98}
Line 414
  && always {!<=-1,!>=2}
  arg always !0
  . always {!<=-1,!>=2}
  it always {!<=-1,!>=2}
  & {lifetime[Address]=(arg->iteratorInfo),!0}
  arg always !0
  nullptr always 0
Line 417
  ( always {!<=-1,!>=2}
Line 421
  ? possible 0
  & {lifetime[Address]=(arg->minsizes),!0}
  arg always !0
  nullptr always 0
Line 426
  ( always {!<=-1,!>=2}
Line 428
  ( always {!<=-1,!>=2}
Line 434
  ( always {!<=-1,!>=2}
Line 436
  ( always {!<=-1,!>=2}
Line 438
  ( always {!<=-1,!>=2}
Line 445
  ( always {!<=-1,!>=2}
Line 447
  ( always {!<=-1,!>=2}
Line 448
  return always {!<=-1,!>=2}
  ( possible lifetime[Iterator]=(mExporters)
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(mExporters),end=0}
Line 451
  ( always {!<=-1,!>=2}
Line 452
  = possible lifetime[Iterator]=(mExporters)
  ( possible lifetime[Iterator]=(mExporters)
Line 453
  return always {!<=-1,!>=2}
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(mExporters),end=0}
  && always {!<=-1,!>=2}
  it always {!symbolic=(mExporters.end()),!end=0}
Line 456
  ( always {!<=-1,!>=2}
Line 457
  = possible lifetime[Iterator]=(mExporters)
  ( possible lifetime[Iterator]=(mExporters)
Line 458
  return always {!<=-1,!>=2}
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(mExporters),end=0}
  && always {!<=-1,!>=2}
  it always {!symbolic=(mExporters.end()),!end=0}
Line 461
  ( always {!<=-1,!>=2}
Line 466
  ( always {!<=-1,!>=2}
Line 467
  return always {!<=-1,!>=2}
  ( possible lifetime[Iterator]=(mReflection)
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(mReflection),end=0}
Line 471
  :: possible {symbolic=(mReflection.end()),end=0}
  it possible {symbolic=(mReflection.end()),end=0}
  = possible lifetime[Iterator]=(mReflection)
  ( possible lifetime[Iterator]=(mReflection)
Line 472
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(mReflection),end=0}
Line 473
  it always {!symbolic=(mReflection.end()),!end=0}
Line 474
  -1 always -1
Line 480
  = always ""
  "" always ""
Line 481
  unique always {!<=-1,!>=2}
  unique always {!<=-1,!>=2}
  = always 0
  false always 0
Line 485
  ( always {!<=-1,!>=2}
Line 489
  size always !<=-1
Line 491
  NO always 0
  BOOL always 1
  CHAR always 2
  SHORT always 3
  INT always 4
  LONG always 5
  LONGLONG always 6
Line 494
  = possible lifetime[Iterator]=(mPodTypes)
  ( possible lifetime[Iterator]=(mPodTypes)
Line 495
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(mPodTypes),end=0}
  & {lifetime[Address]=(it->second),!0}
  it always {!symbolic=(mPodTypes.end()),!end=0}
  nullptr always 0
Line 500
  mSigned always {!<=-1,!>=2}
  false always 0
Line 501
  mUnsigned always {!<=-1,!>=2}
  false always 0
Line 502
  mLong always {!<=-1,!>=2}
  false always 0
Line 503
  mPointer always {!<=-1,!>=2}
  false always 0
Line 504
  mPtrPtr always {!<=-1,!>=2}
  false always 0
Line 505
  mConstPtr always {!<=-1,!>=2}
  false always 0
Line 506
  ( always {!<=-1,!>=2}
Line 507
  return always {!<=-1,!>=2}
  mSigned always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  . always {!<=-1,!>=2}
  mSigned always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 508
  mUnsigned always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  . always {!<=-1,!>=2}
  mUnsigned always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 509
  mLong always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  . always {!<=-1,!>=2}
  mLong always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 510
  mPointer always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  . always {!<=-1,!>=2}
  mPointer always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 511
  mPtrPtr always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  . always {!<=-1,!>=2}
  mPtrPtr always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 512
  mConstPtr always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  . always {!<=-1,!>=2}
  mConstPtr always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 513
  == always {!<=-1,!>=2}
Line 515
  ( always {!<=-1,!>=2}
Line 516
  return always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  this always !0
  == always {!<=-1,!>=2}
Line 519
  mSigned always {!<=-1,!>=2}
Line 520
  mUnsigned always {!<=-1,!>=2}
Line 521
  mLong always {!<=-1,!>=2}
Line 522
  mPointer always {!<=-1,!>=2}
Line 523
  mPtrPtr always {!<=-1,!>=2}
Line 524
  mConstPtr always {!<=-1,!>=2}
Line 529
  = possible lifetime[Iterator]=(mPlatformTypes)
  ( possible lifetime[Iterator]=(mPlatformTypes)
Line 530
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(mPlatformTypes),end=0}
  & {lifetime[Address]=(it->second),!0}
  it always {!symbolic=(mPlatformTypes.end()),!end=0}
  nullptr always 0
Line 536
  :: possible {symbolic=(mPlatforms.end()),end=0}
  it possible {symbolic=(mPlatforms.end()),end=0}
  = possible lifetime[Iterator]=(mPlatforms)
  ( possible lifetime[Iterator]=(mPlatforms)
Line 537
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(mPlatforms),end=0}
Line 538
  it always {!symbolic=(mPlatforms.end()),!end=0}
Line 540
  type always !0
Line 543
  = possible lifetime[Iterator]=(mPlatformTypes)
  ( possible lifetime[Iterator]=(mPlatformTypes)
Line 544
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(mPlatformTypes),end=0}
  & {lifetime[Address]=(it2->second),!0}
  it2 always {!symbolic=(mPlatformTypes.end()),!end=0}
  nullptr always 0
Line 552
  ( always {!<=-1,!>=2}
  , always ""
  = always ""
  "" always ""
Line 555
  def always 0
  check always 1
  suppress always 2
Line 570
  ( always {!<=-1,!>=2}
Line 571
  return always {!<=-1,!>=2}
  ( possible lifetime[Iterator]=(mPrefixes)
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(mPrefixes),end=0}
Line 573
  ( always {!<=-1,!>=2}
Line 574
  return always {!<=-1,!>=2}
  ( possible lifetime[Iterator]=(mSuffixes)
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(mSuffixes),end=0}
Line 583
  0 always 0
Line 606
  ( always {!<=-1,!>=2}
Line 607
  return always {!<=-1,!>=2}
  ( possible lifetime[Iterator]=(mBlocks)
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(mBlocks),end=0}
Line 616
  False always 0
  True always 1
  Maybe always 2
Line 646
  = possible lifetime[Iterator]=(data)
  ( possible lifetime[Iterator]=(data)
Line 647
  == always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(data),end=0}
  nullptr always 0
  & {lifetime[Address]=(it->second),!0}
  it always {!symbolic=(data.end()),!end=0}
Line 655
  = always 0
  nullptr always 0
Line 62
  ( always !<=-1
Line 74
  mFlags always !<=-1
Line 77
  fIsClass always 1
  = always 1
  1 always 1
  << always 1
  0 always 0
  , always 2
Line 78
  fIsFunction always 2
  = always 2
  1 always 1
  << always 2
  1 always 1
  , always 4
Line 79
  fIsVariable always 4
  = always 4
  1 always 1
  << always 4
  2 always 2
  , always 8
Line 80
  fIsAlias always 8
  = always 8
  1 always 1
  << always 8
  3 always 3
  , always 16
Line 81
  fIsSpecialization always 16
  = always 16
  1 always 1
  << always 16
  4 always 4
  , always 32
Line 82
  fIsPartialSpecialization always 32
  = always 32
  1 always 1
  << always 32
  5 always 5
  , always 64
Line 83
  fIsForwardDeclaration always 64
  = always 64
  1 always 1
  << always 64
  6 always 6
  , always 128
Line 84
  fIsVariadic always 128
  = always 128
  1 always 1
  << always 128
  7 always 7
  , always 256
Line 85
  fIsFriend always 256
  = always 256
  1 always 1
  << always 256
  8 always 8
  , always 7
Line 86
  fFamilyMask always 7
  = always 7
  fIsClass always 1
  | always 3
  fIsFunction always 2
  | always 7
  fIsVariable always 4
Line 89
  state always {!<=-1,!>=2}
Line 90
  fIsClass always 1
  state always {!<=-1,!>=2}
Line 92
  state always {!<=-1,!>=2}
Line 93
  fIsFunction always 2
  state always {!<=-1,!>=2}
Line 95
  state always {!<=-1,!>=2}
Line 96
  fIsVariable always 4
  state always {!<=-1,!>=2}
Line 98
  state always {!<=-1,!>=2}
Line 99
  fIsAlias always 8
  state always {!<=-1,!>=2}
Line 101
  state always {!<=-1,!>=2}
Line 102
  fIsSpecialization always 16
  state always {!<=-1,!>=2}
Line 104
  state always {!<=-1,!>=2}
Line 105
  fIsPartialSpecialization always 32
  state always {!<=-1,!>=2}
Line 107
  state always {!<=-1,!>=2}
Line 108
  fIsForwardDeclaration always 64
  state always {!<=-1,!>=2}
Line 110
  state always {!<=-1,!>=2}
Line 111
  fIsVariadic always 128
  state always {!<=-1,!>=2}
Line 113
  state always {!<=-1,!>=2}
Line 114
  fIsFriend always 256
  state always {!<=-1,!>=2}
Line 122
  ( always {!<=-1,!>=2}
  flag always !<=-1
Line 123
  return always {!<=-1,!>=2}
  mFlags always !<=-1
  & always !<=-1
  flag {!<=-1,256@144,128@145,64@146,32@147,16@148,8@149,4@150,2@151,1@152}
  != always {!<=-1,!>=2}
  0 always 0
Line 131
  flag always !<=-1
  state always {!<=-1,!>=2}
Line 132
  mFlags always !<=-1
  = always !<=-1
  state always {!<=-1,!>=2}
  ? always !<=-1
  mFlags always !<=-1
  | always !<=-1
  flag {!<=-1,256@153,128@154,64@155,32@156,16@157,8@158,4@159,2@160,1@161}
  : always !<=-1
  mFlags always !<=-1
  & always !<=-1
  ~ {!<=0,4294967039@153,4294967167@154,4294967231@155,4294967263@156,4294967279@157,4294967287@158,4294967291@159,4294967293@160,4294967294@161}
  flag {!<=-1,256@153,128@154,64@155,32@156,16@157,8@158,4@159,2@160,1@161}
Line 153
  ( always {!<=-1,!>=2}
Line 154
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 155
  == always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  mFlags always !<=-1
  == always {!<=-1,!>=2}
  . always !<=-1
  mFlags always !<=-1
Line 183
  ( always {!<=-1,!>=2}
Line 184
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsClass always 1
Line 186
  ( always {!<=-1,!>=2}
Line 187
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsFunction always 2
Line 189
  ( always {!<=-1,!>=2}
Line 190
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsVariable always 4
Line 192
  ( always {!<=-1,!>=2}
Line 193
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsAlias always 8
Line 195
  ( always {!<=-1,!>=2}
Line 196
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsSpecialization always 16
Line 198
  ( always {!<=-1,!>=2}
Line 199
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsPartialSpecialization always 32
Line 201
  ( always {!<=-1,!>=2}
Line 202
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsForwardDeclaration always 64
Line 204
  ( always {!<=-1,!>=2}
Line 205
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsVariadic always 128
Line 207
  ( always {!<=-1,!>=2}
Line 208
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsFriend always 256
Line 234
  ( always {!<=-1,!>=2}
Line 242
  ( always {!<=-1,!>=2}
Line 245
  return always {!<=-1,!>=2}
  mFlags always !<=-1
  & always !<=-1
  fFamilyMask always 7
  & always !<=-1
  . always !<=-1
  mFlags always !<=-1
  & always !<=-1
  fFamilyMask always 7
  != always {!<=-1,!>=2}
  0 always 0
Line 265
  ( always {!<=-1,!>=2}
  , always !<=-1
  numberOfArguments always !<=-1
  , always {!<=-1,!>=2}
  variadic always {!<=-1,!>=2}
Line 281
  ( always {!<=-1,!>=2}
Line 289
  ( always {!<=-1,!>=2}
Line 297
  ( always {!<=-1,!>=2}
Line 306
  codeWithTemplates always {!<=-1,!>=2}
Line 314
  ( always {!<=-1,!>=2}
  , always 1
  isTemplate always {!<=-1,!>=2}
  = always 1
  true always 1
Line 322
  ( always {!<=-1,!>=2}
  = always 0
  nullptr always 0
  , always 0
  = always 0
  nullptr always 0
  , always 1
  isTemplate always {!<=-1,!>=2}
  = always 1
  true always 1
Line 335
  ( always {!<=-1,!>=2}
Line 391
  ( always {!<=-1,!>=2}
Line 410
  ( always {!<=-1,!>=2}
Line 424
  , always {!<=-1,!>=2}
Line 425
  copy always {!<=-1,!>=2}
Line 451
  ( always {!<=-1,!>=2}
Line 456
  ( always {!<=-1,!>=2}
Line 486
  , always "    "
Line 487
  = always "    "
  "    " always "    "
Line 488
  = always ""
  "" always ""
Line 494
  mChanged always {!<=-1,!>=2}
Line 118
  LOW always 0
  HIGH always 1
Line 125
  UNKNOWN always 0
  CPP11INIT always 1
  NOINIT always 2
Line 128
  mBits always !<=-1
Line 131
  ( always {!<=-1,!>=2}
Line 134
  0 always 0
Line 135
  0 always 0
Line 136
  0 always 0
Line 137
  0 always 0
Line 138
  0 always 0
Line 139
  nullptr always 0
Line 140
  nullptr always 0
Line 141
  nullptr always 0
Line 142
  nullptr always 0
Line 143
  nullptr always 0
Line 144
  0 always 0
Line 145
  0 always 0
Line 146
  nullptr always 0
Line 147
  nullptr always 0
Line 148
  nullptr always 0
Line 149
  nullptr always 0
Line 150
  nullptr always 0
Line 151
  nullptr always 0
Line 153
  mBits always !<=-1
  0 always 0
Line 182
  eVariable always 0
  eType always 1
  eFunction always 2
  eKeyword always 3
  eName always 4
Line 183
  eNumber always 5
  eString always 6
  eChar always 7
  eBoolean always 8
  eLiteral always 9
  eEnumerator always 10
Line 184
  eArithmeticalOp always 11
  eComparisonOp always 12
  eAssignmentOp always 13
  eLogicalOp always 14
  eBitOp always 15
  eIncDecOp always 16
  eExtendedOp always 17
Line 185
  eBracket always 18
Line 186
  eLambda always 19
Line 187
  eEllipsis always 20
Line 188
  eOther always 21
Line 189
  eNone always 22
Line 192
  = always 0
  nullptr always 0
Line 198
  && always {!<=-1,!>=2}
Line 200
  = always 0
  0 always 0
Line 218
  = always 1
  1 always 1
Line 223
  = always 1
  1 always 1
Line 237
  ( always !0
  this always !0
  index possible {2@147,-2@154,3@155,1@91,4@167,6@199}
Line 246
  ( always !0
  this always !0
  index possible {1@239,2@42}
Line 275
  ( always {!<=-1,!>=2}
  ( always !0
  & {lifetime[Address]=(pattern),!0}
Line 276
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  tok possible {symbolic=(tok->astParent())@230,symbolic=(tok->astParent())@241,symbolic=(parent->link())@16,symbolic=(condTok->astParent())@241,0@246,symbolic=(arguments?arguments->link()->next():capture->link()->next())@36,symbolic=(parent->link()->next())@77,symbolic=(startBlock->link())@81,symbolic=(tok->astParent())@33}
  pattern possible {"} ;"@10,"{"@21,"("@28,"} ;"@52,"{"@80,"+"@94,". reset ("@178,"( )"@180,". release ( )"@187,". get ( )"@196}
  1 always 1
Line 279
  ( always {!<=-1,!>=2}
  , always !<=-1
  pattern_len always !<=-1
Line 324
  ( always {!<=-1,!>=2}
  , always 0
  = always 0
  0 always 0
Line 370
  = always !0
  this always !0
Line 371
  top possible {symbolic=(this),0}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  top {symbolic=(this),!0}
  ",|(" always ",|("
Line 372
  top always !0
Line 373
  top possible {symbolic=(this),0}
  ? possible 0
  top always !0
  : always 0
  nullptr always 0
Line 380
  = possible {10@43,4@44,0@45}
  t possible {10@43,4@44,0@45}
Line 382
  memoizedIsName always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  mTokType possible {10@43,4@44,0@45}
  == always {!<=-1,!>=2}
  eName always 4
  || always {!<=-1,!>=2}
  mTokType {!4,10@43,0@45}
  == always {!<=-1,!>=2}
  eType always 1
  || always {!<=-1,!>=2}
  mTokType {!4,!1,10@43,0@45}
  == always {!<=-1,!>=2}
  eVariable always 0
  || always {!<=-1,!>=2}
Line 383
  mTokType {!1,!0,10@43}
  == always {!<=-1,!>=2}
  eFunction always 2
  || always {!<=-1,!>=2}
  mTokType {!0,!2,10@43}
  == always {!<=-1,!>=2}
  eKeyword always 3
  || always {!<=-1,!>=2}
  mTokType {!2,!3,10@43}
  == always {!<=-1,!>=2}
  eBoolean always 8
  || always {!<=-1,!>=2}
Line 384
  mTokType {!3,!8,10@43}
  == always {!<=-1,!>=2}
  eEnumerator always 10
Line 385
  fIsName always 2097152
  memoizedIsName {symbolic=(mTokType==eName||mTokType==eType||mTokType==eVariable||mTokType==eFunction||mTokType==eKeyword||mTokType==eBoolean||mTokType==eEnumerator),!<=-1,!>=2,1@43}
Line 387
  memoizedIsLiteral always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  eNumber always 5
  || always {!<=-1,!>=2}
  mTokType always !5
  == always {!<=-1,!>=2}
  eString always 6
  || always {!<=-1,!>=2}
  mTokType always {!5,!6}
  == always {!<=-1,!>=2}
  eChar always 7
  || always {!<=-1,!>=2}
Line 388
  mTokType always {!6,!7}
  == always {!<=-1,!>=2}
  eBoolean always 8
  || always {!<=-1,!>=2}
  mTokType always {!7,!8}
  == always {!<=-1,!>=2}
  eLiteral always 9
  || always {!<=-1,!>=2}
  mTokType always {!8,!9}
  == always {!<=-1,!>=2}
  eEnumerator always 10
Line 389
  fIsLiteral always 4194304
  memoizedIsLiteral {symbolic=(mTokType==eNumber||mTokType==eString||mTokType==eChar||mTokType==eBoolean||mTokType==eLiteral||mTokType==eEnumerator),!<=-1,!>=2}
Line 391
  ( always {!<=-1,!>=2}
Line 392
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  eKeyword always 3
Line 394
  ( always {!<=-1,!>=2}
Line 395
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsName always 2097152
Line 397
  ( always {!<=-1,!>=2}
Line 398
  return always {!<=-1,!>=2}
  mFlags always !<=-1
  == always {!<=-1,!>=2}
  fIsName always 2097152
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  eName always 4
Line 400
  ( always {!<=-1,!>=2}
Line 401
  ( always {!<=-1,!>=2}
Line 402
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsLiteral always 4194304
Line 404
  ( always {!<=-1,!>=2}
Line 405
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  eNumber always 5
Line 407
  ( always {!<=-1,!>=2}
Line 408
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  eEnumerator always 10
Line 410
  ( always {!<=-1,!>=2}
Line 411
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
Line 412
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
Line 413
  == always {!<=-1,!>=2}
  eIncDecOp always 16
Line 415
  ( always {!<=-1,!>=2}
Line 416
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
Line 417
  == always {!<=-1,!>=2}
  eLogicalOp always 14
  || always {!<=-1,!>=2}
Line 418
  mTokType always !14
  == always {!<=-1,!>=2}
  eComparisonOp always 12
  || always {!<=-1,!>=2}
Line 419
  mTokType always {!14,!12}
  == always {!<=-1,!>=2}
  eBitOp always 15
Line 421
  ( always {!<=-1,!>=2}
Line 422
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
Line 423
  == always {!<=-1,!>=2}
  eExtendedOp always 17
Line 425
  ( always {!<=-1,!>=2}
Line 426
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  eArithmeticalOp always 11
Line 428
  ( always {!<=-1,!>=2}
Line 429
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  eComparisonOp always 12
Line 431
  ( always {!<=-1,!>=2}
Line 432
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  eAssignmentOp always 13
Line 434
  ( always {!<=-1,!>=2}
Line 435
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  eBoolean always 8
Line 437
  ( always {!<=-1,!>=2}
Line 438
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  eIncDecOp always 16
Line 440
  ( always {!<=-1,!>=2}
Line 441
  return always {!<=-1,!>=2}
  != always {!<=-1,!>=2}
  nullptr always 0
  && always {!<=-1,!>=2}
  != always {!<=-1,!>=2}
  nullptr always 0
Line 443
  ( always {!<=-1,!>=2}
Line 444
  return always {!<=-1,!>=2}
  s possible {"&"@2,"&"@208,"*"@226,"&"@45,"*"@140,"*"@141,"*"@4,"*"@107,"-"@142,"&"@254}
  == always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  != always {!<=-1,!>=2}
  nullptr always 0
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  nullptr always 0
Line 446
  ( always {!<=-1,!>=2}
Line 448
  ( always !<=-1
Line 449
  return always !<=-1
  mFlags always !<=-1
Line 451
  flags_ always !<=-1
Line 452
  mFlags always !<=-1
  = always !<=-1
  flags_ always !<=-1
Line 454
  ( always {!<=-1,!>=2}
Line 455
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsUnsigned always 1
Line 457
  sign always {!<=-1,!>=2}
Line 458
  fIsUnsigned always 1
  sign always {!<=-1,!>=2}
Line 460
  ( always {!<=-1,!>=2}
Line 461
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsSigned always 2
Line 463
  sign always {!<=-1,!>=2}
Line 464
  fIsSigned always 2
  sign always {!<=-1,!>=2}
Line 466
  ( always {!<=-1,!>=2}
Line 467
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsPointerCompare always 4
Line 469
  b always {!<=-1,!>=2}
Line 470
  fIsPointerCompare always 4
  b always {!<=-1,!>=2}
Line 472
  ( always {!<=-1,!>=2}
Line 473
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsLong always 8
Line 475
  size always {!<=-1,!>=2}
Line 476
  fIsLong always 8
  size always {!<=-1,!>=2}
Line 478
  ( always {!<=-1,!>=2}
Line 479
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsStandardType always 16
Line 481
  b always {!<=-1,!>=2}
Line 482
  fIsStandardType always 16
  b {!<=-1,!>=2,0@51}
Line 484
  ( always {!<=-1,!>=2}
Line 485
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsExpandedMacro always 32
Line 487
  m always {!<=-1,!>=2}
Line 488
  fIsExpandedMacro always 32
  m always {!<=-1,!>=2}
Line 490
  ( always {!<=-1,!>=2}
Line 491
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsCast always 64
Line 493
  c always {!<=-1,!>=2}
Line 494
  fIsCast always 64
  c always {!<=-1,!>=2}
Line 496
  ( always {!<=-1,!>=2}
Line 497
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsAttributeConstructor always 128
Line 499
  ac always {!<=-1,!>=2}
Line 500
  fIsAttributeConstructor always 128
  ac always {!<=-1,!>=2}
Line 502
  ( always {!<=-1,!>=2}
Line 503
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsAttributeDestructor always 256
Line 505
  value always {!<=-1,!>=2}
Line 506
  fIsAttributeDestructor always 256
  value always {!<=-1,!>=2}
Line 508
  ( always {!<=-1,!>=2}
Line 509
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsAttributeUnused always 512
Line 511
  unused always {!<=-1,!>=2}
Line 512
  fIsAttributeUnused always 512
  unused always {!<=-1,!>=2}
Line 514
  ( always {!<=-1,!>=2}
Line 515
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsAttributeUsed always 16384
Line 517
  unused always {!<=-1,!>=2}
Line 518
  fIsAttributeUsed always 16384
  unused always {!<=-1,!>=2}
Line 520
  ( always {!<=-1,!>=2}
Line 521
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsAttributePure always 1024
Line 523
  value always {!<=-1,!>=2}
Line 524
  fIsAttributePure always 1024
  value always {!<=-1,!>=2}
Line 526
  ( always {!<=-1,!>=2}
Line 527
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsAttributeConst always 2048
Line 529
  value always {!<=-1,!>=2}
Line 530
  fIsAttributeConst always 2048
  value always {!<=-1,!>=2}
Line 532
  ( always {!<=-1,!>=2}
Line 533
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsAttributeNoreturn always 4096
Line 535
  value always {!<=-1,!>=2}
Line 536
  fIsAttributeNoreturn always 4096
  value always {!<=-1,!>=2}
Line 538
  ( always {!<=-1,!>=2}
Line 539
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsAttributeNothrow always 8192
Line 541
  value always {!<=-1,!>=2}
Line 542
  fIsAttributeNothrow always 8192
  value always {!<=-1,!>=2}
Line 544
  ( always {!<=-1,!>=2}
Line 545
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsAttributePacked always 32768
Line 547
  value always {!<=-1,!>=2}
Line 548
  fIsAttributePacked always 32768
  value always {!<=-1,!>=2}
Line 550
  ( always {!<=-1,!>=2}
Line 551
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsAttributeNodiscard always 16777216
Line 553
  value always {!<=-1,!>=2}
Line 554
  fIsAttributeNodiscard always 16777216
  value always {!<=-1,!>=2}
Line 556
  ( always {!<=-1,!>=2}
Line 557
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsAttributeMaybeUnused always 65536
Line 559
  value always {!<=-1,!>=2}
Line 560
  fIsAttributeMaybeUnused always 65536
  value always {!<=-1,!>=2}
Line 565
  ( always {!<=-1,!>=2}
Line 566
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  type possible {0@152,1@154}
  value possible {lifetime[Address]=(low)@152,lifetime[Address]=(high)@154,Uninit*@152}
Line 568
  ( always {!<=-1,!>=2}
Line 569
  return always {!<=-1,!>=2}
  nullptr always 0
  != always {!<=-1,!>=2}
Line 571
  ( always {!<=-1,!>=2}
Line 572
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsControlFlowKeyword always 131072
Line 574
  ( always {!<=-1,!>=2}
Line 575
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsOperatorKeyword always 262144
Line 577
  value always {!<=-1,!>=2}
Line 578
  fIsOperatorKeyword always 262144
  value always {!<=-1,!>=2}
Line 580
  ( always {!<=-1,!>=2}
Line 581
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsComplex always 524288
Line 583
  value always {!<=-1,!>=2}
Line 584
  fIsComplex always 524288
  value always {!<=-1,!>=2}
Line 586
  ( always {!<=-1,!>=2}
Line 587
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsEnumType always 1048576
Line 589
  value always {!<=-1,!>=2}
Line 590
  fIsEnumType always 1048576
  value always {!<=-1,!>=2}
Line 592
  ( always {!<=-1,!>=2}
Line 593
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fAtAddress always 33554432
Line 595
  b always {!<=-1,!>=2}
Line 596
  fAtAddress always 33554432
  b always {!<=-1,!>=2}
Line 598
  ( always {!<=-1,!>=2}
Line 599
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIncompleteVar always 67108864
Line 601
  b always {!<=-1,!>=2}
Line 602
  fIncompleteVar always 67108864
  b always {!<=-1,!>=2}
Line 605
  ( always {!<=-1,!>=2}
Line 606
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsIncompleteConstant always 68719476736
Line 608
  b always {!<=-1,!>=2}
Line 609
  fIsIncompleteConstant always 68719476736
  b always {!<=-1,!>=2}
Line 612
  ( always {!<=-1,!>=2}
Line 613
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fConstexpr always 134217728
Line 615
  b always {!<=-1,!>=2}
Line 616
  fConstexpr always 134217728
  b always {!<=-1,!>=2}
Line 619
  ( always {!<=-1,!>=2}
Line 620
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fExternC always 268435456
Line 622
  b always {!<=-1,!>=2}
Line 623
  fExternC always 268435456
  b always {!<=-1,!>=2}
Line 626
  ( always {!<=-1,!>=2}
Line 627
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsSplitVarDeclComma always 536870912
Line 629
  b always {!<=-1,!>=2}
Line 630
  fIsSplitVarDeclComma always 536870912
  b always {!<=-1,!>=2}
Line 633
  ( always {!<=-1,!>=2}
Line 634
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsSplitVarDeclEq always 1073741824
Line 636
  b always {!<=-1,!>=2}
Line 637
  fIsSplitVarDeclEq always 1073741824
  b always {!<=-1,!>=2}
Line 640
  ( always {!<=-1,!>=2}
Line 641
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsImplicitInt always 2147483648
Line 643
  b always {!<=-1,!>=2}
Line 644
  fIsImplicitInt always 2147483648
  b always {!<=-1,!>=2}
Line 647
  ( always {!<=-1,!>=2}
Line 648
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsInline always 4294967296
Line 650
  b always {!<=-1,!>=2}
Line 651
  fIsInline always 4294967296
  b always {!<=-1,!>=2}
Line 654
  ( always {!<=-1,!>=2}
Line 655
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsRemovedVoidParameter always 34359738368
Line 657
  b always {!<=-1,!>=2}
Line 658
  fIsRemovedVoidParameter always 34359738368
  b always {!<=-1,!>=2}
Line 661
  ( always {!<=-1,!>=2}
Line 662
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsTemplate always 8589934592
Line 664
  b always {!<=-1,!>=2}
Line 665
  fIsTemplate always 8589934592
  b always {!<=-1,!>=2}
Line 668
  ( always {!<=-1,!>=2}
Line 669
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsSimplifedScope always 17179869184
Line 671
  b always {!<=-1,!>=2}
Line 672
  fIsSimplifedScope always 17179869184
  b always {!<=-1,!>=2}
Line 675
  ( always {!<=-1,!>=2}
Line 676
  return always {!<=-1,!>=2}
  . always !<=-1
  mBits always !<=-1
  > always {!<=-1,!>=2}
  0 always 0
Line 678
  ( always !<=-1
Line 679
  return always !<=-1
  . always !<=-1
  mBits always !<=-1
Line 685
  ! always {!<=-1,!>=2}
Line 687
  . possible lifetime[Object]=(tokenAndName)
Line 689
  b always !<=-1
Line 690
  . always !<=-1
  mBits always !<=-1
  = always !<=-1
  b always !<=-1
Line 693
  ( always {!<=-1,!>=2}
Line 694
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  eString always 6
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  '"' always 34
  "u8" always "u8"
  || always {!<=-1,!>=2}
Line 695
  == always {!<=-1,!>=2}
  eChar always 7
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  '\'' always 39
  "u8" always "u8"
Line 698
  ( always {!<=-1,!>=2}
Line 699
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  eString always 6
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  '"' always 34
  "u" always "u"
  || always {!<=-1,!>=2}
Line 700
  == always {!<=-1,!>=2}
  eChar always 7
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  '\'' always 39
  "u" always "u"
Line 703
  ( always {!<=-1,!>=2}
Line 704
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  eString always 6
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  '"' always 34
  "U" always "U"
  || always {!<=-1,!>=2}
Line 705
  == always {!<=-1,!>=2}
  eChar always 7
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  '\'' always 39
  "U" always "U"
Line 708
  ( always {!<=-1,!>=2}
Line 709
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  eString always 6
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  '"' always 34
  "" always ""
  || always {!<=-1,!>=2}
Line 710
  == always {!<=-1,!>=2}
  eChar always 7
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  '\'' always 39
  "" always ""
  && always {!<=-1,!>=2}
  ( always !<=-1
  == always {!<=-1,!>=2}
  3 always 3
Line 713
  ( always {!<=-1,!>=2}
Line 714
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  eChar always 7
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  '\'' always 39
  "" always ""
  && always {!<=-1,!>=2}
Line 715
  ( always !<=-1
  > always {!<=-1,!>=2}
  3 always 3
Line 734
  ( always {!<=-1,!>=2}
Line 735
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsTemplateArg always 8388608
Line 737
  value always {!<=-1,!>=2}
Line 738
  fIsTemplateArg always 8388608
  value always {!<=-1,!>=2}
Line 742
  ( always !0
  & {lifetime[Address]=(pattern),!0}
Line 743
  pattern possible "{"@35
  1 always 1
Line 745
  , always !<=-1
  pattern_len always !<=-1
Line 748
  ( always !0
  & {lifetime[Address]=(pattern),!0}
Line 749
  pattern possible {"union"@30,"return"@81}
  1 always 1
Line 751
  , always !<=-1
  pattern_len always !<=-1
Line 753
  , always 0
  = always 0
  0 always 0
Line 754
  , always 0
  = always 0
  0 always 0
Line 757
  ( always !0
  & {lifetime[Address]=(pattern),!0}
Line 758
  1 always 1
Line 760
  , always !<=-1
  pattern_len always !<=-1
Line 761
  pattern_len always !<=-1
Line 764
  ( always !0
  & {lifetime[Address]=(pattern),!0}
Line 765
  1 always 1
Line 767
  , always !<=-1
  pattern_len always !<=-1
Line 768
  pattern_len always !<=-1
Line 771
  , always 0
  = always 0
  0 always 0
Line 772
  varId possible 0
Line 774
  , always 0
  = always 0
  0 always 0
Line 775
  varId possible 0
Line 837
  , always 0
  prepend always {!<=-1,!>=2}
  = always 0
  false always 0
Line 841
  true always 1
Line 853
  = possible 0
  id possible 0
Line 854
  != always {!<=-1,!>=2}
  0 always 0
Line 855
  eVariable always 0
Line 856
  false always 0
Line 864
  . always !0
Line 877
  = always 0
  nullptr always 0
Line 892
  = always 5
  5 always 5
Line 904
  varid always {!<=-1,!>=2}
  varid always {!<=-1,!>=2}
  = always 0
  false always 0
Line 905
  exprid always {!<=-1,!>=2}
  exprid always {!<=-1,!>=2}
  = always 0
  false always 0
Line 906
  idtype always {!<=-1,!>=2}
  idtype always {!<=-1,!>=2}
  = always 0
  false always 0
Line 907
  attributes always {!<=-1,!>=2}
  attributes always {!<=-1,!>=2}
  = always 0
  false always 0
Line 908
  macro always {!<=-1,!>=2}
  macro always {!<=-1,!>=2}
  = always 0
  false always 0
Line 909
  linenumbers always {!<=-1,!>=2}
  linenumbers always {!<=-1,!>=2}
  = always 0
  false always 0
Line 910
  linebreaks always {!<=-1,!>=2}
  linebreaks always {!<=-1,!>=2}
  = always 0
  false always 0
Line 911
  files always {!<=-1,!>=2}
  files always {!<=-1,!>=2}
  = always 0
  false always 0
Line 914
  . always {!<=-1,!>=2}
  attributes always {!<=-1,!>=2}
  = always 1
  true always 1
Line 915
  . always {!<=-1,!>=2}
  macro always {!<=-1,!>=2}
  = always 1
  true always 1
Line 916
  . always {!<=-1,!>=2}
  linenumbers always {!<=-1,!>=2}
  = always 1
  true always 1
Line 917
  . always {!<=-1,!>=2}
  linebreaks always {!<=-1,!>=2}
  = always 1
  true always 1
Line 918
  . always {!<=-1,!>=2}
  files always {!<=-1,!>=2}
  = always 1
  true always 1
Line 923
  . always {!<=-1,!>=2}
  varid always {!<=-1,!>=2}
  = always 1
  true always 1
Line 928
  . always {!<=-1,!>=2}
  exprid always {!<=-1,!>=2}
  = always 1
  true always 1
Line 933
  . always {!<=-1,!>=2}
  exprid always {!<=-1,!>=2}
  = always 1
  true always 1
Line 934
  . always {!<=-1,!>=2}
  varid always {!<=-1,!>=2}
  = always 1
  true always 1
Line 935
  . always {!<=-1,!>=2}
  idtype always {!<=-1,!>=2}
  = always 1
  true always 1
Line 948
  varid always {!<=-1,!>=2}
  attributes always {!<=-1,!>=2}
  macro always {!<=-1,!>=2}
Line 950
  , always 0
  = always 0
  nullptr always 0
  , always 0
  = always 0
  nullptr always 0
Line 951
  , always 1
  attributes always {!<=-1,!>=2}
  = always 1
  true always 1
Line 952
  varid always {!<=-1,!>=2}
  = always 0
  false always 0
Line 965
  varid always {!<=-1,!>=2}
  attributes always {!<=-1,!>=2}
  linenumbers always {!<=-1,!>=2}
  linebreaks always {!<=-1,!>=2}
  files always {!<=-1,!>=2}
  = always 0
  nullptr always 0
  , always 0
  = always 0
  nullptr always 0
Line 984
  mStr possible size=1
  == always {!<=-1,!>=2}
  "<" always "<"
  || always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  ">" always ">"
Line 1026
  mTokType possible 19
  == {!<=-1,!>=2,0}
  eFunction always 2
  || always {!<=-1,!>=2}
  mTokType always !2
  == always {!<=-1,!>=2}
  eLambda always 19
  : always 0
  nullptr always 0
Line 1034
  = possible 0
  v possible 0
Line 1035
  || always {!<=-1,!>=2}
Line 1036
  eVariable always 0
Line 1037
  == always {!<=-1,!>=2}
  eVariable always 0
Line 1038
  eName always 4
Line 1045
  == always {!<=-1,!>=2}
  eVariable always 0
  ? possible 0
  : always 0
  nullptr always 0
Line 1058
  == always {!<=-1,!>=2}
  eType always 1
  ? possible 0
  : always 0
  nullptr always 0
Line 1061
  , always 0
  = always 0
  nullptr always 0
Line 1071
  == always {!<=-1,!>=2}
  eEnumerator always 10
  ? possible 0
  : always 0
  nullptr always 0
Line 1079
  = possible 0
  e possible 0
Line 1081
  eEnumerator always 10
Line 1082
  == always {!<=-1,!>=2}
  eEnumerator always 10
Line 1083
  eName always 4
Line 1152
  . always !0
Line 1156
  . always !0
Line 1163
  && always {!<=-1,!>=2}
Line 1164
  ! always {!<=-1,!>=2}
Line 1170
  ( always {!<=-1,!>=2}
Line 1171
  ( always {!<=-1,!>=2}
Line 1172
  ( always {!<=-1,!>=2}
Line 1173
  ( always {!<=-1,!>=2}
Line 1182
  condition always {!<=-1,!>=2}
  = always 0
  0 always 0
Line 1197
  ( always {!<=-1,!>=2}
Line 1199
  ( always {!<=-1,!>=2}
Line 1227
  ( always {!<=-1,!>=2}
Line 1243
  fIsUnsigned always 1
  = always 1
  1 always 1
  << always 1
  0 always 0
  , always 2
Line 1244
  fIsSigned always 2
  = always 2
  1 always 1
  << always 2
  1 always 1
  , always 4
Line 1245
  fIsPointerCompare always 4
  = always 4
  1 always 1
  << always 4
  2 always 2
  , always 8
Line 1246
  fIsLong always 8
  = always 8
  1 always 1
  << always 8
  3 always 3
  , always 16
Line 1247
  fIsStandardType always 16
  = always 16
  1 always 1
  << always 16
  4 always 4
  , always 32
Line 1248
  fIsExpandedMacro always 32
  = always 32
  1 always 1
  << always 32
  5 always 5
  , always 64
Line 1249
  fIsCast always 64
  = always 64
  1 always 1
  << always 64
  6 always 6
  , always 128
Line 1250
  fIsAttributeConstructor always 128
  = always 128
  1 always 1
  << always 128
  7 always 7
  , always 256
Line 1251
  fIsAttributeDestructor always 256
  = always 256
  1 always 1
  << always 256
  8 always 8
  , always 512
Line 1252
  fIsAttributeUnused always 512
  = always 512
  1 always 1
  << always 512
  9 always 9
  , always 1024
Line 1253
  fIsAttributePure always 1024
  = always 1024
  1 always 1
  << always 1024
  10 always 10
  , always 2048
Line 1254
  fIsAttributeConst always 2048
  = always 2048
  1 always 1
  << always 2048
  11 always 11
  , always 4096
Line 1255
  fIsAttributeNoreturn always 4096
  = always 4096
  1 always 1
  << always 4096
  12 always 12
  , always 8192
Line 1256
  fIsAttributeNothrow always 8192
  = always 8192
  1 always 1
  << always 8192
  13 always 13
  , always 16384
Line 1257
  fIsAttributeUsed always 16384
  = always 16384
  1 always 1
  << always 16384
  14 always 14
  , always 32768
Line 1258
  fIsAttributePacked always 32768
  = always 32768
  1 always 1
  << always 32768
  15 always 15
  , always 65536
Line 1259
  fIsAttributeMaybeUnused always 65536
  = always 65536
  1 always 1
  << always 65536
  16 always 16
  , always 131072
Line 1260
  fIsControlFlowKeyword always 131072
  = always 131072
  1 always 1
  << always 131072
  17 always 17
  , always 262144
Line 1261
  fIsOperatorKeyword always 262144
  = always 262144
  1 always 1
  << always 262144
  18 always 18
  , always 524288
Line 1262
  fIsComplex always 524288
  = always 524288
  1 always 1
  << always 524288
  19 always 19
  , always 1048576
Line 1263
  fIsEnumType always 1048576
  = always 1048576
  1 always 1
  << always 1048576
  20 always 20
  , always 2097152
Line 1264
  fIsName always 2097152
  = always 2097152
  1 always 1
  << always 2097152
  21 always 21
  , always 4194304
Line 1265
  fIsLiteral always 4194304
  = always 4194304
  1 always 1
  << always 4194304
  22 always 22
  , always 8388608
Line 1266
  fIsTemplateArg always 8388608
  = always 8388608
  1 always 1
  << always 8388608
  23 always 23
  , always 16777216
Line 1267
  fIsAttributeNodiscard always 16777216
  = always 16777216
  1 always 1
  << always 16777216
  24 always 24
  , always 33554432
Line 1268
  fAtAddress always 33554432
  = always 33554432
  1 always 1
  << always 33554432
  25 always 25
  , always 67108864
Line 1269
  fIncompleteVar always 67108864
  = always 67108864
  1 always 1
  << always 67108864
  26 always 26
  , always 134217728
Line 1270
  fConstexpr always 134217728
  = always 134217728
  1 always 1
  << always 134217728
  27 always 27
  , always 268435456
Line 1271
  fExternC always 268435456
  = always 268435456
  1 always 1
  << always 268435456
  28 always 28
  , always 536870912
Line 1272
  fIsSplitVarDeclComma always 536870912
  = always 536870912
  1 always 1
  << always 536870912
  29 always 29
  , always 1073741824
Line 1273
  fIsSplitVarDeclEq always 1073741824
  = always 1073741824
  1 always 1
  << always 1073741824
  30 always 30
  , always 2147483648
Line 1274
  fIsImplicitInt always 2147483648
  = always 2147483648
  1U always 1
  << always 2147483648
  31 always 31
  , always 4294967296
Line 1275
  fIsInline always 4294967296
  = always 4294967296
  1ULL always 1
  << always 4294967296
  32 always 32
  , always 8589934592
Line 1276
  fIsTemplate always 8589934592
  = always 8589934592
  1ULL always 1
  << always 8589934592
  33 always 33
  , always 17179869184
Line 1277
  fIsSimplifedScope always 17179869184
  = always 17179869184
  1ULL always 1
  << always 17179869184
  34 always 34
  , always 34359738368
Line 1278
  fIsRemovedVoidParameter always 34359738368
  = always 34359738368
  1ULL always 1
  << always 34359738368
  35 always 35
  , always 68719476736
Line 1279
  fIsIncompleteConstant always 68719476736
  = always 68719476736
  1ULL always 1
  << always 68719476736
  36 always 36
Line 1284
  mFlags always !<=-1
Line 1293
  ( always {!<=-1,!>=2}
  flag_ always !<=-1
Line 1294
  return always {!<=-1,!>=2}
  mFlags always !<=-1
  & always !<=-1
  flag_ {!<=-1,8388608@53,17179869184@64,8589934592@66,34359738368@68,4294967296@70,2147483648@72,1073741824@74,536870912@76,268435456@78}
  != always {!<=-1,!>=2}
  0 always 0
Line 1302
  flag_ always !<=-1
  state_ always {!<=-1,!>=2}
Line 1303
  mFlags always !<=-1
  = always !<=-1
  state_ {!<=-1,!>=2,symbolic=(mTokType==eName||mTokType==eType||mTokType==eVariable||mTokType==eFunction||mTokType==eKeyword||mTokType==eBoolean||mTokType==eEnumerator)@140,symbolic=(mTokType==eNumber||mTokType==eString||mTokType==eChar||mTokType==eBoolean||mTokType==eLiteral||mTokType==eEnumerator)@141}
  ? always !<=-1
  mFlags always !<=-1
  | always !<=-1
  flag_ {!<=-1,8388608@52,17179869184@63,8589934592@65,34359738368@67,4294967296@69,2147483648@71,1073741824@73,536870912@75,268435456@77}
  : always !<=-1
  mFlags always !<=-1
  & always !<=-1
  ~ always !<=0
  flag_ {!<=-1,8388608@52,17179869184@63,8589934592@65,34359738368@67,4294967296@69,2147483648@71,1073741824@73,536870912@75,268435456@77}
Line 1317
  , always 0
  = always 0
  0 always 0
  , always 0
  = always 0
  0 always 0
Line 1343
  ! always {!<=-1,!>=2}
Line 1344
  nullptr always 0
Line 1345
  this {!0,symbolic=(astParent()->astOperand2())}
  == always {!<=-1,!>=2}
  ( always !0
Line 1346
  ( always !0
Line 1347
  this always {!0,!symbolic=(astParent()->astOperand1())}
  == always {!<=-1,!>=2}
  ( always !0
Line 1348
  ( always !0
Line 1349
  nullptr always 0
Line 1353
  ! always {!<=-1,!>=2}
Line 1354
  nullptr always 0
Line 1355
  this {!0,symbolic=(astParent()->astOperand2())}
  == always {!<=-1,!>=2}
  ( always !0
Line 1356
  ( always !0
Line 1357
  this always {!0,!symbolic=(astParent()->astOperand1())}
  == always {!<=-1,!>=2}
  ( always !0
Line 1358
  ( always !0
Line 1359
  nullptr always 0
Line 1363
  = always !0
  this always !0
Line 1364
  ret possible symbolic=(this)
Line 1365
  = always !0
  . always !0
Line 1366
  ret possible symbolic=(this)
Line 1370
  = always !0
  this always !0
Line 1371
  ret possible symbolic=(this)
Line 1372
  = always !0
  . always !0
Line 1373
  ret possible symbolic=(this)
Line 1385
  ( always {!<=-1,!>=2}
Line 1388
  = always 0
  = always 0
  = always 0
  nullptr always 0
Line 1393
  = always 0
  nullptr always 0
Line 1396
  = always ""
  "" always ""
Line 1402
  sep possible ""
Line 1411
  verbose always {!<=-1,!>=2}
  xml always {!<=-1,!>=2}
Line 1413
  xml always {!<=-1,!>=2}
Line 1418
  cpp11init always {!<=-1,!>=2}
Line 1419
  = possible {1,2}
  cpp11init always {!<=-1,!>=2}
  ? possible {1,2}
  :: always 1
  CPP11INIT always 1
  : always 2
  :: always 2
  NOINIT always 2
Line 55
  Public always 0
  Protected always 1
  Private always 2
  Global always 3
  Namespace always 4
  Argument always 5
  Local always 6
  Throw always 7
Line 61
  nullptr always 0
  0 always 0
  known always {!<=-1,!>=2}
  true always 1
Line 65
  known always {!<=-1,!>=2}
Line 75
  Unknown always 0
  True always 1
  False always 2
Line 81
  nullptr always 0
  nullptr always 0
  :: always 0
  Public always 0
  isVirtual always {!<=-1,!>=2}
  false always 0
Line 87
  isVirtual always {!<=-1,!>=2}
Line 89
  ( always {!<=-1,!>=2}
Line 90
  return always {!<=-1,!>=2}
  this always !0
  < always {!<=-1,!>=2}
Line 96
  nullptr always 0
  nullptr always 0
  nullptr always 0
Line 110
  = always 0
  nullptr always 0
  = always 0
  nullptr always 0
  = always 0
  nullptr always 0
Line 111
  classDef_ inconclusive 0
Line 115
  nullptr always 0
Line 116
  nullptr always 0
Line 117
  0 always 0
Line 118
  classDef_ possible 0
  && always {!<=-1,!>=2}
  classDef_ always !0
  == always {!<=-1,!>=2}
  "enum" always "enum"
Line 119
  = always 1
  :: always 1
  True always 1
Line 120
  classDef_ possible 0
  && always {!<=-1,!>=2}
  classDef_ always !0
  == always {!<=-1,!>=2}
  "using" always "using"
Line 121
  3 always 3
Line 123
  && always {!<=-1,!>=2}
  ( always !0
  != always {!<=-1,!>=2}
  ";" always ";"
Line 124
  = always !0
  ( always !0
Line 131
  classDef always !0
Line 134
  ( always {!<=-1,!>=2}
Line 135
  ( always {!<=-1,!>=2}
Line 136
  ( always {!<=-1,!>=2}
Line 137
  ( always {!<=-1,!>=2}
Line 139
  ( always {!<=-1,!>=2}
Line 140
  return always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  classDef always !0
  == always {!<=-1,!>=2}
  "using" always "using"
Line 152
  ( always {!<=-1,!>=2}
  = always 0
  nullptr always 0
Line 159
  ( always {!<=-1,!>=2}
Line 161
  ( always {!<=-1,!>=2}
Line 166
  nullptr always 0
  0 always 0
  nullptr always 0
  nullptr always 0
  value_known always {!<=-1,!>=2}
  false always 0
Line 172
  value_known always {!<=-1,!>=2}
Line 179
  fIsMutable always 1
  = always 1
  1 always 1
  << always 1
  0 always 0
  , always 2
Line 180
  fIsStatic always 2
  = always 2
  1 always 1
  << always 2
  1 always 1
  , always 4
Line 181
  fIsConst always 4
  = always 4
  1 always 1
  << always 4
  2 always 2
  , always 8
Line 182
  fIsExtern always 8
  = always 8
  1 always 1
  << always 8
  3 always 3
  , always 16
Line 183
  fIsClass always 16
  = always 16
  1 always 1
  << always 16
  4 always 4
  , always 32
Line 184
  fIsArray always 32
  = always 32
  1 always 1
  << always 32
  5 always 5
  , always 64
Line 185
  fIsPointer always 64
  = always 64
  1 always 1
  << always 64
  6 always 6
  , always 128
Line 186
  fIsReference always 128
  = always 128
  1 always 1
  << always 128
  7 always 7
  , always 256
Line 187
  fIsRValueRef always 256
  = always 256
  1 always 1
  << always 256
  8 always 8
  , always 512
Line 188
  fHasDefault always 512
  = always 512
  1 always 1
  << always 512
  9 always 9
  , always 1024
Line 189
  fIsStlType always 1024
  = always 1024
  1 always 1
  << always 1024
  10 always 10
  , always 2048
Line 190
  fIsStlString always 2048
  = always 2048
  1 always 1
  << always 2048
  11 always 11
  , always 4096
Line 191
  fIsFloatType always 4096
  = always 4096
  1 always 1
  << always 4096
  12 always 12
  , always 8192
Line 192
  fIsVolatile always 8192
  = always 8192
  1 always 1
  << always 8192
  13 always 13
  , always 16384
Line 193
  fIsSmartPointer always 16384
  = always 16384
  1 always 1
  << always 16384
  14 always 14
  , always 32768
Line 194
  fIsMaybeUnused always 32768
  = always 32768
  1 always 1
  << always 32768
  15 always 15
  , always 65536
Line 195
  fIsInit always 65536
  = always 65536
  1 always 1
  << always 65536
  16 always 16
Line 203
  ( always {!<=-1,!>=2}
  flag_ always !<=-1
Line 204
  return always {!<=-1,!>=2}
  mFlags always !<=-1
  & always !<=-1
  flag_ {!<=-1,32768@242,4096@245,16384@248,2048@249,1024@250,65536@251,512@252,256@253,128@254}
  != always {!<=-1,!>=2}
  0 always 0
Line 212
  flag_ always !<=-1
  state_ always {!<=-1,!>=2}
Line 213
  mFlags always !<=-1
  = always !<=-1
  state_ always {!<=-1,!>=2}
  ? always !<=-1
  mFlags always !<=-1
  | always !<=-1
  flag_ always !<=-1
  : always !<=-1
  mFlags always !<=-1
  & always !<=-1
  ~ always !<=0
  flag_ always !<=-1
Line 222
  ( always {!<=-1,!>=2}
Line 233
  mFlags always !<=-1
  0 always 0
  , possible lifetime[SubObject]=(type_)
Line 234
  ( possible lifetime[SubObject]=(type_)
Line 236
  nullptr always 0
Line 300
  mNameToken always !0
Line 312
  mNameToken always !0
Line 314
  0 always 0
Line 329
  ( always {!<=-1,!>=2}
Line 330
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 0
  Public always 0
Line 337
  ( always {!<=-1,!>=2}
Line 338
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 1
  Protected always 1
Line 345
  ( always {!<=-1,!>=2}
Line 346
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 2
  Private always 2
Line 353
  ( always {!<=-1,!>=2}
Line 354
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 3
  Global always 3
Line 361
  ( always {!<=-1,!>=2}
Line 362
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 4
  Namespace always 4
Line 369
  ( always {!<=-1,!>=2}
Line 370
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 5
  Argument always 5
Line 377
  ( always {!<=-1,!>=2}
Line 378
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 385
  ( always {!<=-1,!>=2}
Line 386
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsMutable always 1
Line 393
  ( always {!<=-1,!>=2}
Line 394
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsVolatile always 8192
Line 401
  ( always {!<=-1,!>=2}
Line 402
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsStatic always 2
Line 409
  ( always {!<=-1,!>=2}
Line 410
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsExtern always 8
Line 417
  ( always {!<=-1,!>=2}
Line 418
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsConst always 4
Line 425
  ( always {!<=-1,!>=2}
Line 426
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 7
  Throw always 7
Line 433
  ( always {!<=-1,!>=2}
Line 434
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsClass always 16
Line 441
  ( always {!<=-1,!>=2}
Line 442
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsArray always 32
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsPointer always 64
Line 449
  ( always {!<=-1,!>=2}
Line 450
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsPointer always 64
Line 457
  ( always {!<=-1,!>=2}
Line 458
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsArray always 32
Line 465
  ( always {!<=-1,!>=2}
Line 471
  ( always {!<=-1,!>=2}
Line 472
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsArray always 32
  || always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsPointer always 64
Line 479
  ( always {!<=-1,!>=2}
Line 480
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsReference always 128
Line 487
  ( always {!<=-1,!>=2}
Line 488
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsRValueRef always 256
Line 495
  ( always {!<=-1,!>=2}
Line 501
  ( always {!<=-1,!>=2}
Line 502
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fHasDefault always 512
Line 509
  ( always {!<=-1,!>=2}
Line 510
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsInit always 65536
Line 526
  ? possible 0
  mType always !0
  : always 0
  nullptr always 0
Line 550
  index_ possible 0@212
Line 557
  ( always {!<=-1,!>=2}
Line 558
  return always {!<=-1,!>=2}
  index_ possible {0@207,<=symbolic=(var->dimensions().size()-1)@232}
  . always {!<=-1,!>=2}
  known always {!<=-1,!>=2}
Line 569
  ( always {!<=-1,!>=2}
Line 570
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsStlType always 1024
Line 581
  ( always {!<=-1,!>=2}
Line 582
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsStlString always 2048
Line 585
  ( always {!<=-1,!>=2}
Line 586
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsSmartPointer always 16384
Line 601
  ( always {!<=-1,!>=2}
Line 602
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  2 always 2
Line 615
  ( always {!<=-1,!>=2}
Line 616
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( possible lifetime[Iterator]=(stlTypes)
  2 always 2
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(stlTypes),end=0}
Line 623
  ( always {!<=-1,!>=2}
Line 624
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsFloatType always 4096
Line 631
  ( always {!<=-1,!>=2}
Line 632
  return always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always !0
  ( always {!<=-1,!>=2}
Line 635
  ( always {!<=-1,!>=2}
Line 636
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsMaybeUnused always 32768
Line 679
  mFlags always !<=-1
Line 702
  fHasBody always 1
  = always 1
  1 always 1
  << always 1
  0 always 0
  , always 2
Line 703
  fIsInline always 2
  = always 2
  1 always 1
  << always 2
  1 always 1
  , always 4
Line 704
  fIsConst always 4
  = always 4
  1 always 1
  << always 4
  2 always 2
  , always 8
Line 705
  fHasVirtualSpecifier always 8
  = always 8
  1 always 1
  << always 8
  3 always 3
  , always 16
Line 706
  fIsPure always 16
  = always 16
  1 always 1
  << always 16
  4 always 4
  , always 32
Line 707
  fIsStatic always 32
  = always 32
  1 always 1
  << always 32
  5 always 5
  , always 64
Line 708
  fIsStaticLocal always 64
  = always 64
  1 always 1
  << always 64
  6 always 6
  , always 128
Line 709
  fIsExtern always 128
  = always 128
  1 always 1
  << always 128
  7 always 7
  , always 256
Line 710
  fIsFriend always 256
  = always 256
  1 always 1
  << always 256
  8 always 8
  , always 512
Line 711
  fIsExplicit always 512
  = always 512
  1 always 1
  << always 512
  9 always 9
  , always 1024
Line 712
  fIsDefault always 1024
  = always 1024
  1 always 1
  << always 1024
  10 always 10
  , always 2048
Line 713
  fIsDelete always 2048
  = always 2048
  1 always 1
  << always 2048
  11 always 11
  , always 4096
Line 714
  fHasOverrideSpecifier always 4096
  = always 4096
  1 always 1
  << always 4096
  12 always 12
  , always 8192
Line 715
  fHasFinalSpecifier always 8192
  = always 8192
  1 always 1
  << always 8192
  13 always 13
  , always 16384
Line 716
  fIsNoExcept always 16384
  = always 16384
  1 always 1
  << always 16384
  14 always 14
  , always 32768
Line 717
  fIsThrow always 32768
  = always 32768
  1 always 1
  << always 32768
  15 always 15
  , always 65536
Line 718
  fIsOperator always 65536
  = always 65536
  1 always 1
  << always 65536
  16 always 16
  , always 131072
Line 719
  fHasLvalRefQual always 131072
  = always 131072
  1 always 1
  << always 131072
  17 always 17
  , always 262144
Line 720
  fHasRvalRefQual always 262144
  = always 262144
  1 always 1
  << always 262144
  18 always 18
  , always 524288
Line 721
  fIsVariadic always 524288
  = always 524288
  1 always 1
  << always 524288
  19 always 19
  , always 1048576
Line 722
  fIsVolatile always 1048576
  = always 1048576
  1 always 1
  << always 1048576
  20 always 20
  , always 2097152
Line 723
  fHasTrailingReturnType always 2097152
  = always 2097152
  1 always 1
  << always 2097152
  21 always 21
  , always 4194304
Line 724
  fIsEscapeFunction always 4194304
  = always 4194304
  1 always 1
  << always 4194304
  22 always 22
  , always 8388608
Line 725
  fIsInlineKeyword always 8388608
  = always 8388608
  1 always 1
  << always 8388608
  23 always 23
  , always 16777216
Line 726
  fIsConstexpr always 16777216
  = always 16777216
  1 always 1
  << always 16777216
  24 always 24
Line 734
  ( always {!<=-1,!>=2}
  flag always !<=-1
Line 735
  return always {!<=-1,!>=2}
  mFlags always !<=-1
  & always !<=-1
  flag {!<=-1,16777216@207,4194304@209,8388608@210,2097152@212,1048576@213,524288@214,262144@215,131072@216,65536@217}
  != always {!<=-1,!>=2}
  0 always 0
Line 743
  flag always !<=-1
  state always {!<=-1,!>=2}
Line 744
  mFlags always !<=-1
  = always !<=-1
  state always {!<=-1,!>=2}
  ? always !<=-1
  mFlags always !<=-1
  | always !<=-1
  flag {!<=-1,8388608@185,2097152@186,1048576@187,524288@188,262144@189,131072@190,65536@191,32768@192,16384@193}
  : always !<=-1
  mFlags always !<=-1
  & always !<=-1
  ~ {!<=0,4286578687@185,4292870143@186,4293918719@187,4294443007@188,4294705151@189,4294836223@190,4294901759@191,4294934527@192,4294950911@193}
  flag {!<=-1,8388608@185,2097152@186,1048576@187,524288@188,262144@189,131072@190,65536@191,32768@192,16384@193}
Line 748
  eConstructor always 0
  eCopyConstructor always 1
  eMoveConstructor always 2
  eOperatorEqual always 3
  eDestructor always 4
  eFunction always 5
  eLambda always 6
Line 760
  ( always !<=-1
Line 763
  ( always !<=-1
  - always !<=-1
Line 772
  ( always {!<=-1,!>=2}
  defaultVal always {!<=-1,!>=2}
  = always 0
  false always 0
Line 777
  = always 0
  nullptr always 0
Line 779
  ( always {!<=-1,!>=2}
Line 780
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  eLambda always 6
Line 783
  ( always {!<=-1,!>=2}
Line 784
  return always {!<=-1,!>=2}
  type possible {1,2}
  == {!<=-1,!>=2,0}
  eConstructor always 0
  || always {!<=-1,!>=2}
Line 785
  type {2,!0}
  == {!<=-1,!>=2,0}
  eCopyConstructor always 1
  || always {!<=-1,!>=2}
Line 786
  type always {!0,!1}
  == always {!<=-1,!>=2}
  eMoveConstructor always 2
Line 789
  ( always {!<=-1,!>=2}
Line 790
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  eDestructor always 4
Line 792
  ( always {!<=-1,!>=2}
Line 793
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 795
  ( always {!<=-1,!>=2}
Line 796
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 798
  ( always {!<=-1,!>=2}
Line 799
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 801
  ( always {!<=-1,!>=2}
Line 802
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 804
  ( always {!<=-1,!>=2}
Line 805
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 807
  ( always {!<=-1,!>=2}
Line 808
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 810
  ( always {!<=-1,!>=2}
Line 811
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 814
  ( always {!<=-1,!>=2}
Line 815
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fHasBody always 1
Line 817
  ( always {!<=-1,!>=2}
Line 818
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsInline always 2
Line 820
  ( always {!<=-1,!>=2}
Line 821
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsConst always 4
Line 823
  ( always {!<=-1,!>=2}
Line 824
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fHasVirtualSpecifier always 8
Line 826
  ( always {!<=-1,!>=2}
Line 827
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsPure always 16
Line 829
  ( always {!<=-1,!>=2}
Line 830
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsStatic always 32
Line 832
  ( always {!<=-1,!>=2}
Line 833
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsStaticLocal always 64
Line 835
  ( always {!<=-1,!>=2}
Line 836
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsExtern always 128
Line 838
  ( always {!<=-1,!>=2}
Line 839
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsFriend always 256
Line 841
  ( always {!<=-1,!>=2}
Line 842
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsExplicit always 512
Line 844
  ( always {!<=-1,!>=2}
Line 845
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsDefault always 1024
Line 847
  ( always {!<=-1,!>=2}
Line 848
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsDelete always 2048
Line 850
  ( always {!<=-1,!>=2}
Line 851
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsNoExcept always 16384
Line 853
  ( always {!<=-1,!>=2}
Line 854
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsThrow always 32768
Line 856
  ( always {!<=-1,!>=2}
Line 857
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fHasOverrideSpecifier always 4096
Line 859
  ( always {!<=-1,!>=2}
Line 860
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fHasFinalSpecifier always 8192
Line 862
  ( always {!<=-1,!>=2}
Line 863
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsOperator always 65536
Line 865
  ( always {!<=-1,!>=2}
Line 866
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fHasLvalRefQual always 131072
Line 868
  ( always {!<=-1,!>=2}
Line 869
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fHasRvalRefQual always 262144
Line 871
  ( always {!<=-1,!>=2}
Line 872
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsVariadic always 524288
Line 874
  ( always {!<=-1,!>=2}
Line 875
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsVolatile always 1048576
Line 877
  ( always {!<=-1,!>=2}
Line 878
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fHasTrailingReturnType always 2097152
Line 880
  state always {!<=-1,!>=2}
Line 881
  fHasBody always 1
  state always {!<=-1,!>=2}
Line 883
  ( always {!<=-1,!>=2}
Line 884
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsInlineKeyword always 8388608
Line 887
  ( always {!<=-1,!>=2}
Line 888
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsEscapeFunction always 4194304
Line 890
  state always {!<=-1,!>=2}
Line 891
  fIsEscapeFunction always 4194304
  state always {!<=-1,!>=2}
Line 894
  ( always {!<=-1,!>=2}
Line 895
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsConstexpr always 16777216
Line 897
  state always {!<=-1,!>=2}
Line 898
  fIsConstexpr always 16777216
  state always {!<=-1,!>=2}
Line 900
  ( always {!<=-1,!>=2}
Line 919
  ( always {!<=-1,!>=2}
Line 921
  ( always {!<=-1,!>=2}
  , always 0
  unknown always {!<=-1,!>=2}
  = always 0
  false always 0
Line 923
  ( always {!<=-1,!>=2}
  , always 0
  unknown always {!<=-1,!>=2}
  = always 0
  false always 0
Line 925
  ( always {!<=-1,!>=2}
  , always 0
  unknown always {!<=-1,!>=2}
  = always 0
  false always 0
Line 930
  this always !0
  ( always {!<=-1,!>=2}
Line 931
  "{|;" always "{|;"
Line 947
  mFlags always !<=-1
Line 949
  state always {!<=-1,!>=2}
Line 950
  fIsInline always 2
  state always {!<=-1,!>=2}
Line 952
  state always {!<=-1,!>=2}
Line 953
  fIsConst always 4
  state always {!<=-1,!>=2}
Line 955
  state always {!<=-1,!>=2}
Line 956
  fHasVirtualSpecifier always 8
  state always {!<=-1,!>=2}
Line 958
  state always {!<=-1,!>=2}
Line 959
  fIsPure always 16
  state always {!<=-1,!>=2}
Line 961
  state always {!<=-1,!>=2}
Line 962
  fIsStatic always 32
  state always {!<=-1,!>=2}
Line 964
  state always {!<=-1,!>=2}
Line 965
  fIsStaticLocal always 64
  state always {!<=-1,!>=2}
Line 967
  state always {!<=-1,!>=2}
Line 968
  fIsExtern always 128
  state always {!<=-1,!>=2}
Line 970
  state always {!<=-1,!>=2}
Line 971
  fIsFriend always 256
  state always {!<=-1,!>=2}
Line 973
  state always {!<=-1,!>=2}
Line 974
  fIsExplicit always 512
  state always {!<=-1,!>=2}
Line 976
  state always {!<=-1,!>=2}
Line 977
  fIsDefault always 1024
  state always {!<=-1,!>=2}
Line 979
  state always {!<=-1,!>=2}
Line 980
  fIsDelete always 2048
  state always {!<=-1,!>=2}
Line 982
  state always {!<=-1,!>=2}
Line 983
  fIsNoExcept always 16384
  state always {!<=-1,!>=2}
Line 985
  state always {!<=-1,!>=2}
Line 986
  fIsThrow always 32768
  state always {!<=-1,!>=2}
Line 988
  state always {!<=-1,!>=2}
Line 989
  fIsOperator always 65536
  state always {!<=-1,!>=2}
Line 991
  state always {!<=-1,!>=2}
Line 992
  fHasLvalRefQual always 131072
  state always {!<=-1,!>=2}
Line 994
  state always {!<=-1,!>=2}
Line 995
  fHasRvalRefQual always 262144
  state always {!<=-1,!>=2}
Line 997
  state always {!<=-1,!>=2}
Line 998
  fIsVariadic always 524288
  state always {!<=-1,!>=2}
Line 1000
  state always {!<=-1,!>=2}
Line 1001
  fIsVolatile always 1048576
  state always {!<=-1,!>=2}
Line 1003
  state always {!<=-1,!>=2}
Line 1004
  fHasTrailingReturnType always 2097152
  state always {!<=-1,!>=2}
Line 1006
  state always {!<=-1,!>=2}
Line 1007
  fIsInlineKeyword always 8388608
  state always {!<=-1,!>=2}
Line 1022
  eGlobal always 0
  eClass always 1
  eStruct always 2
  eUnion always 3
  eNamespace always 4
  eFunction always 5
  eIf always 6
  eElse always 7
  eFor always 8
  eWhile always 9
  eDo always 10
  eSwitch always 11
  eUnconditional always 12
  eTry always 13
  eCatch always 14
  eLambda always 15
  eEnum always 16
Line 1051
  enumClass always {!<=-1,!>=2}
Line 1056
  = possible 0
  start possible 0
Line 1057
  = possible 0
  start possible 0
  ? possible 0
  start always !0
  : always 0
  nullptr always 0
Line 1059
  bodyStartList possible lifetime[Object]=(start)
  start always !0
Line 1062
  ( always {!<=-1,!>=2}
Line 1064
  return always {!<=-1,!>=2}
  ( always !<=-1
  > always {!<=-1,!>=2}
  9 always 9
  && always {!<=-1,!>=2}
  className {>=size=10,!<=size=9}
  0 always 0
  9 always 9
  "Anonymous" always "Anonymous"
  == always {!<=-1,!>=2}
  0 always 0
  && always {!<=-1,!>=2}
  9 always 9
Line 1069
  == always {!<=-1,!>=2}
Line 1070
  & {lifetime[Address]=(enumeratorList),!0}
Line 1072
  nullptr always 0
Line 1075
  ( always {!<=-1,!>=2}
Line 1076
  ! always {!<=-1,!>=2}
  outer possible symbolic=(this)
Line 1077
  return always {!<=-1,!>=2}
  false always 0
Line 1078
  outer always !0
  == always {!<=-1,!>=2}
  this always !0
Line 1079
  return always {!<=-1,!>=2}
  true always 1
Line 1081
  outer {symbolic=(parent),!symbolic=(this),!0}
  != {!<=-1,!>=2,0,1}
  parent possible {symbolic=(nestedIn),symbolic=(outer),0}
  && {!<=-1,!>=2,0}
  parent {symbolic=(nestedIn),!symbolic=(outer),0}
Line 1082
  parent {symbolic=(nestedIn),!symbolic=(outer),!0}
Line 1083
  parent possible {symbolic=(nestedIn),symbolic=(outer),0}
  && always {!<=-1,!>=2}
  parent always !0
  == always {!<=-1,!>=2}
  outer always {!symbolic=(this),!0}
Line 1084
  return always {!<=-1,!>=2}
  true always 1
Line 1085
  return always {!<=-1,!>=2}
  false always 0
Line 1090
  scope always !0
  == always {!<=-1,!>=2}
  :: always 5
  eFunction always 5
Line 1092
  scope always !0
Line 1094
  ! {!<=-1,!>=2,1}
  scope possible 0
Line 1095
  nullptr always 0
Line 1096
  scope always !0
Line 1099
  ( always {!<=-1,!>=2}
Line 1100
  return always {!<=-1,!>=2}
  type possible 2
  == {!<=-1,!>=2,0}
  eClass always 1
  || always {!<=-1,!>=2}
  type always !1
  == always {!<=-1,!>=2}
  eStruct always 2
Line 1103
  ( always {!<=-1,!>=2}
Line 1104
  return always {!<=-1,!>=2}
  type possible {2,3}
  == {!<=-1,!>=2,0}
  eClass always 1
  || always {!<=-1,!>=2}
  type {3,!1}
  == {!<=-1,!>=2,0}
  eStruct always 2
  || always {!<=-1,!>=2}
  type always {!1,!2}
  == always {!<=-1,!>=2}
  eUnion always 3
Line 1107
  ( always {!<=-1,!>=2}
Line 1108
  return always {!<=-1,!>=2}
  type possible {2,3,0,4,16}
  != {!<=-1,!>=2,1}
  eClass always 1
  && always {!<=-1,!>=2}
  type {3,0,4,16,!1}
  != {!<=-1,!>=2,1}
  eStruct always 2
  && always {!<=-1,!>=2}
  type {0,4,16,!1,!2}
  != {!<=-1,!>=2,1}
  eUnion always 3
  && always {!<=-1,!>=2}
  type {4,16,!2,!3}
  != {!<=-1,!>=2,1}
  eGlobal always 0
  && always {!<=-1,!>=2}
  type {16,!3,!0}
  != {!<=-1,!>=2,1}
  eNamespace always 4
  && always {!<=-1,!>=2}
  type always {!0,!4}
  != always {!<=-1,!>=2}
  eEnum always 16
Line 1111
  ( always {!<=-1,!>=2}
Line 1112
  return always {!<=-1,!>=2}
  type possible {9,10}
  == {!<=-1,!>=2,0}
  :: always 8
  eFor always 8
  || always {!<=-1,!>=2}
  type {10,!8}
  == {!<=-1,!>=2,0}
  :: always 9
  eWhile always 9
  || always {!<=-1,!>=2}
  type always {!8,!9}
  == always {!<=-1,!>=2}
  :: always 10
  eDo always 10
Line 1115
  ( always {!<=-1,!>=2}
Line 1116
  return always {!<=-1,!>=2}
  type possible {7,8,9,10,11,12,13,14}
  == {!<=-1,!>=2,0}
  eIf always 6
  || always {!<=-1,!>=2}
  type {8,9,10,11,12,13,14,!6}
  == {!<=-1,!>=2,0}
  eElse always 7
  || always {!<=-1,!>=2}
Line 1117
  type {9,10,11,12,13,14,!6,!7}
  == {!<=-1,!>=2,0}
  eFor always 8
  || always {!<=-1,!>=2}
  type {10,11,12,13,14,!7,!8}
  == {!<=-1,!>=2,0}
  eWhile always 9
  || always {!<=-1,!>=2}
  type {11,12,13,14,!8,!9}
  == {!<=-1,!>=2,0}
  eDo always 10
  || always {!<=-1,!>=2}
Line 1118
  type {12,13,14,!9,!10}
  == {!<=-1,!>=2,0}
  eSwitch always 11
  || always {!<=-1,!>=2}
  type {13,14,!10,!11}
  == {!<=-1,!>=2,0}
  eUnconditional always 12
  || always {!<=-1,!>=2}
Line 1119
  type {14,!11,!12}
  == {!<=-1,!>=2,0}
  eTry always 13
  || always {!<=-1,!>=2}
  type always {!12,!13}
  == always {!<=-1,!>=2}
  eCatch always 14
Line 1123
  ( always {!<=-1,!>=2}
Line 1131
  , always 0
  requireConst always {!<=-1,!>=2}
  = always 0
  false always 0
Line 1133
  , always 0
  isC always {!<=-1,!>=2}
  = always 0
  false always 0
Line 1135
  ( always !0
  this always !0
Line 1140
  ( always !0
  this always !0
Line 1159
  functionList possible lifetime[Object]=(func)
Line 1161
  = {lifetime[Object]=(functionList),!0}
  & {lifetime[Object]=(functionList),!0}
  functionList {lifetime[Object]=(func),!size=0}
Line 1163
  ( possible lifetime[Iterator]=(functionMap)
  back {lifetime[Object]=(functionList),symbolic=(&functionList.back()),!0}
  back {lifetime[Object]=(functionList),symbolic=(&functionList.back()),!0}
Line 1166
  ( always {!<=-1,!>=2}
Line 1186
  , always {!<=-1,!>=2}
  isCpp always {!<=-1,!>=2}
Line 1200
  ( always {!<=-1,!>=2}
  & {lifetime[Address]=(vartok),!0}
  & {lifetime[Address]=(typetok),!0}
Line 1209
  None always 0
Line 1210
  LValue always 1
Line 1211
  RValue always 2
Line 1217
  UNKNOWN_SIGN always 0
  SIGNED always 1
  UNSIGNED always 2
Line 1219
  UNKNOWN_TYPE always 0
Line 1220
  POD always 1
Line 1221
  NONSTD always 2
Line 1222
  RECORD always 3
Line 1223
  SMART_POINTER always 4
Line 1224
  CONTAINER always 5
Line 1225
  ITERATOR always 6
Line 1226
  VOID always 7
Line 1227
  BOOL always 8
Line 1228
  CHAR always 9
Line 1229
  SHORT always 10
Line 1230
  WCHAR_T always 11
Line 1231
  INT always 12
Line 1232
  LONG always 13
Line 1233
  LONGLONG always 14
Line 1234
  UNKNOWN_INT always 15
Line 1235
  FLOAT always 16
Line 1236
  DOUBLE always 17
Line 1237
  LONGDOUBLE always 18
Line 1242
  = always 0
  :: always 0
  None always 0
Line 1256
  UNKNOWN_SIGN always 0
Line 1257
  UNKNOWN_TYPE always 0
Line 1258
  0 always 0
Line 1259
  0U always 0
Line 1260
  0U always 0
Line 1261
  nullptr always 0
Line 1262
  nullptr always 0
Line 1263
  nullptr always 0
Line 1264
  nullptr always 0
Line 1265
  nullptr always 0
Line 1266
  nullptr always 0
Line 1268
  ( possible lifetime[SubObject]=(s)
Line 1271
  0 always 0
Line 1273
  0U always 0
Line 1274
  nullptr always 0
Line 1275
  nullptr always 0
Line 1276
  nullptr always 0
Line 1277
  nullptr always 0
Line 1278
  nullptr always 0
Line 1279
  nullptr always 0
Line 1281
  ( possible lifetime[SubObject]=(s)
Line 1284
  0 always 0
Line 1287
  nullptr always 0
Line 1288
  nullptr always 0
Line 1289
  nullptr always 0
Line 1290
  nullptr always 0
Line 1291
  nullptr always 0
Line 1292
  nullptr always 0
Line 1294
  ( possible lifetime[SubObject]=(s)
Line 1297
  0 always 0
Line 1300
  nullptr always 0
Line 1301
  nullptr always 0
Line 1302
  nullptr always 0
Line 1303
  nullptr always 0
Line 1304
  nullptr always 0
Line 1305
  nullptr always 0
Line 1311
  , always {!<=-1,!>=2}
  longType always {!<=-1,!>=2}
Line 1313
  UNKNOWN always 0
  SAME always 1
  FALLBACK1 always 2
  FALLBACK2 always 3
  NOMATCH always 4
Line 1317
  ( always {!<=-1,!>=2}
Line 1318
  return always {!<=-1,!>=2}
  >= always {!<=-1,!>=2}
  :: always 8
  BOOL always 8
Line 1321
  ( always {!<=-1,!>=2}
Line 1322
  return always {!<=-1,!>=2}
  type possible {<=15,>=16}
  >= {!<=-1,!>=2,<=1}
  :: always 8
  BOOL always 8
  && always {!<=-1,!>=2}
  type {>=8,!<=7}
  <= {!<=-1,!>=2,>=1}
  :: always 15
  UNKNOWN_INT always 15
Line 1325
  ( always {!<=-1,!>=2}
Line 1326
  return always {!<=-1,!>=2}
  type possible {<=18,>=19}
  >= {!<=-1,!>=2,<=1}
  :: always 16
  FLOAT always 16
  && always {!<=-1,!>=2}
  type {>=16,!<=15}
  <= {!<=-1,!>=2,>=1}
  :: always 18
  LONGDOUBLE always 18
Line 1329
  ( always {!<=-1,!>=2}
Line 1331
  ( always {!<=-1,!>=2}
Line 1332
  return always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  typeScope always !0
  == always {!<=-1,!>=2}
  :: always 16
  eEnum always 16
Line 1335
  , always 0
  p always {!<=-1,!>=2}
  = always 0
  false always 0
Line 1338
  ( always {!<=-1,!>=2}
Line 1381
  , always 0
  lookOutside always {!<=-1,!>=2}
  = always 0
  false always 0
Line 1382
  , always 0
  lookOutside always {!<=-1,!>=2}
  = always 0
  false always 0
Line 1383
  this always !0
  lookOutside always {!<=-1,!>=2}
Line 1388
  this always !0
Line 1391
  ( always {!<=-1,!>=2}
Line 1392
  return always {!<=-1,!>=2}
  < always {!<=-1,!>=2}
  ( always !<=-1
Line 1408
  = always 0
  nullptr always 0
Line 1412
  ( always {!<=-1,!>=2}
Line 1426
  reportDebugWarnings always {!<=-1,!>=2}
  = always 0
  nullptr always 0
Line 1456
  firstPass always {!<=-1,!>=2}
Line 1467
  & {lifetime[Address]=(scope),!0}
Line 1468
  & {lifetime[Address]=(scope),!0}
  & {lifetime[Address]=(tok),!0}
Line 1470
  ( always {!<=-1,!>=2}
Line 1482
  ( always {!<=-1,!>=2}
Line 1500
  mIsCpp always {!<=-1,!>=2}
Line 40
  none always 0
Line 41
  op1 always 1
Line 42
  op2 always 2
Line 43
  op1_and_op2 always 3
Line 44
  done always 4
Line 53
  ! always {!<=-1,!>=2}
Line 57
  = always !0
  ast always !0
Line 59
  visitor possible {lifetime[Lambda]=(programMemory)@61,lifetime[Lambda]=(reassign)@61,lifetime[Lambda]=(result)@81,lifetime[Lambda]=(result)@69,lifetime[Lambda]=(local)@31,lifetime[Lambda]=(depth)@238,lifetime[Lambda]=(varId)@135,lifetime[Lambda]=(value)@135}
  tok inconclusive symbolic=(ast)
Line 61
  c possible {2,3,1}
  == {!<=-1,!>=2,0}
  :: always 4
  done always 4
Line 63
  c {3,1,!4}
  == {!<=-1,!>=2,0}
  :: always 2
  op2 always 2
  || {!<=-1,!>=2,1}
  c {1,3,!4,!2}
  == {!<=-1,!>=2,0,1}
  :: always 3
  op1_and_op2 always 3
Line 66
  t2 always !0
Line 68
  c {3,!4,2}
  == {!<=-1,!>=2,0}
  :: always 1
  op1 always 1
  || {!<=-1,!>=2,1}
  c {!4,2,3,!1}
  == {!<=-1,!>=2,0,1}
  :: always 3
  op1_and_op2 always 3
Line 71
  t1 always !0
Line 74
  ( always {!<=-1,!>=2}
Line 77
  tokens always !size=0
Line 78
  tokens always !size=0
Line 79
  true always 1
Line 82
  ( always {!<=-1,!>=2}
Line 86
  ( always {!<=-1,!>=2}
Line 92
  , always 100
  = always 100
  100 always 100
Line 94
  ( always {!<=-1,!>=2}
Line 96
  ( always {!<=-1,!>=2}
Line 98
  ( always {!<=-1,!>=2}
Line 100
  ( always {!<=-1,!>=2}
Line 102
  ( always {!<=-1,!>=2}
Line 104
  ( always {!<=-1,!>=2}
Line 106
  ( always {!<=-1,!>=2}
  , always {!<=-1,!>=2}
  unknown always {!<=-1,!>=2}
Line 107
  ( always {!<=-1,!>=2}
Line 109
  ( always {!<=-1,!>=2}
  , always {!<=-1,!>=2}
  unknown always {!<=-1,!>=2}
Line 111
  ( always {!<=-1,!>=2}
Line 113
  ( always {!<=-1,!>=2}
Line 115
  ( always {!<=-1,!>=2}
Line 116
  ( always {!<=-1,!>=2}
Line 118
  ( always {!<=-1,!>=2}
Line 120
  ( always {!<=-1,!>=2}
Line 122
  ( always {!<=-1,!>=2}
Line 123
  ( always {!<=-1,!>=2}
Line 137
  , always 0
  = always 0
  nullptr always 0
Line 139
  ( always {!<=-1,!>=2}
Line 141
  ( always {!<=-1,!>=2}
  cpp always {!<=-1,!>=2}
  , always 0
  unknown always {!<=-1,!>=2}
  = always 0
  false always 0
Line 155
  cpp always {!<=-1,!>=2}
Line 157
  ( always {!<=-1,!>=2}
Line 158
  ( always {!<=-1,!>=2}
Line 179
  ( always {!<=-1,!>=2}
Line 187
  ( always {!<=-1,!>=2}
Line 188
  ( always {!<=-1,!>=2}
Line 190
  ( always {!<=-1,!>=2}
  , always 1
  onVar always {!<=-1,!>=2}
  = always 1
  true always 1
  , always 0
  = always 0
  0 always 0
Line 198
  temporary always {!<=-1,!>=2}
  = always 1
  true always 1
Line 199
  inconclusive always {!<=-1,!>=2}
  = always 1
  true always 1
Line 201
  = always 20
  20 always 20
Line 202
  , always 0
  = always 0
  nullptr always 0
Line 204
  ( always {!<=-1,!>=2}
  cpp always {!<=-1,!>=2}
  macro always {!<=-1,!>=2}
  , always {!<=-1,!>=2}
  pure always {!<=-1,!>=2}
  , always {!<=-1,!>=2}
  followVar always {!<=-1,!>=2}
  , always 0
  = always 0
  nullptr always 0
Line 206
  ( always {!<=-1,!>=2}
Line 211
  ( always {!<=-1,!>=2}
Line 222
  ( always {!<=-1,!>=2}
  isNot always {!<=-1,!>=2}
  cpp always {!<=-1,!>=2}
  , always {!<=-1,!>=2}
  pure always {!<=-1,!>=2}
  , always {!<=-1,!>=2}
  followVar always {!<=-1,!>=2}
  , always 0
  = always 0
  nullptr always 0
Line 224
  ( always {!<=-1,!>=2}
  cpp always {!<=-1,!>=2}
  , always {!<=-1,!>=2}
  pure always {!<=-1,!>=2}
  , always {!<=-1,!>=2}
  followVar always {!<=-1,!>=2}
  , always 0
  = always 0
  nullptr always 0
Line 226
  ( always {!<=-1,!>=2}
Line 228
  ( always {!<=-1,!>=2}
  , always {!<=-1,!>=2}
  pure always {!<=-1,!>=2}
  , always {!<=-1,!>=2}
  cpp always {!<=-1,!>=2}
Line 230
  ( always {!<=-1,!>=2}
  cpp always {!<=-1,!>=2}
  , always 0
  checkArrayAccess always {!<=-1,!>=2}
  = always 0
  false always 0
  , always 1
  checkReference always {!<=-1,!>=2}
  = always 1
  true always 1
Line 232
  ( always {!<=-1,!>=2}
Line 234
  ( always {!<=-1,!>=2}
Line 237
  ( always {!<=-1,!>=2}
  , always 0
Line 238
  = always 0
  nullptr always 0
  , always 0
Line 239
  = always 0
  nullptr always 0
  , always 0
Line 240
  functionScope always {!<=-1,!>=2}
  = always 0
  false always 0
Line 243
  ( always {!<=-1,!>=2}
Line 262
  ( always {!<=-1,!>=2}
Line 272
  ( always {!<=-1,!>=2}
Line 275
  ( always {!<=-1,!>=2}
  , always {!<=-1,!>=2}
  globalvar always {!<=-1,!>=2}
  , always {!<=-1,!>=2}
  cpp always {!<=-1,!>=2}
  , always 20
  = always 20
  20 always 20
Line 276
  ( always {!<=-1,!>=2}
  , always {!<=-1,!>=2}
  globalvar always {!<=-1,!>=2}
  , always {!<=-1,!>=2}
  cpp always {!<=-1,!>=2}
  , always 20
  = always 20
  20 always 20
Line 278
  ( always {!<=-1,!>=2}
  , always {!<=-1,!>=2}
  cpp always {!<=-1,!>=2}
  , always 20
  = always 20
  20 always 20
Line 280
  ( always {!<=-1,!>=2}
  , always {!<=-1,!>=2}
  cpp always {!<=-1,!>=2}
  , always 20
  = always 20
  20 always 20
Line 282
  ( always {!<=-1,!>=2}
Line 286
  , always {!<=-1,!>=2}
Line 287
  cpp always {!<=-1,!>=2}
Line 289
  ( always {!<=-1,!>=2}
  , always {!<=-1,!>=2}
  cpp always {!<=-1,!>=2}
Line 290
  ( always {!<=-1,!>=2}
  , always {!<=-1,!>=2}
  cpp always {!<=-1,!>=2}
Line 292
  , always {!<=-1,!>=2}
  globalvar always {!<=-1,!>=2}
  , always {!<=-1,!>=2}
  cpp always {!<=-1,!>=2}
  , always 20
  = always 20
  20 always 20
Line 293
  , always {!<=-1,!>=2}
  globalvar always {!<=-1,!>=2}
  , always {!<=-1,!>=2}
  cpp always {!<=-1,!>=2}
  , always 20
  = always 20
  20 always 20
Line 295
  ( always {!<=-1,!>=2}
Line 298
  , always {!<=-1,!>=2}
Line 299
  cpp always {!<=-1,!>=2}
  , always 20
Line 300
  = always 20
  20 always 20
Line 302
  ( always {!<=-1,!>=2}
Line 304
  , always {!<=-1,!>=2}
Line 305
  globalvar always {!<=-1,!>=2}
Line 306
  , always {!<=-1,!>=2}
Line 307
  cpp always {!<=-1,!>=2}
  , always 20
Line 308
  = always 20
  20 always 20
Line 311
  ( always {!<=-1,!>=2}
  , always 0
  = always 0
  nullptr always 0
Line 313
  ( always {!<=-1,!>=2}
Line 336
  ( always {!<=-1,!>=2}
Line 348
  ( always {!<=-1,!>=2}
  cpp always {!<=-1,!>=2}
Line 355
  ( always {!<=-1,!>=2}
  cpp always {!<=-1,!>=2}
Line 357
  ( always {!<=-1,!>=2}
Line 359
  ( always {!<=-1,!>=2}
  , always 0
  = always 0
  nullptr always 0
Line 370
  ( always {!<=-1,!>=2}
Line 372
  ( always {!<=-1,!>=2}
Line 374
  ( always {!<=-1,!>=2}
  , always {!<=-1,!>=2}
  cpp always {!<=-1,!>=2}
Line 383
  ( possible lifetime[SubObject]=(cpp)
  cpp always {!<=-1,!>=2}
  mCpp always {!<=-1,!>=2}
  cpp always {!<=-1,!>=2}
  mValueFlowKnown always {!<=-1,!>=2}
  true always 1
Line 385
  ( always {!<=-1,!>=2}
Line 403
  ( always {!<=-1,!>=2}
Line 406
  known always {!<=-1,!>=2}
Line 411
  ( always {!<=-1,!>=2}
Line 413
  = always 0
  nullptr always 0
  = always 0
  nullptr always 0
Line 415
  ( always {!<=-1,!>=2}
Line 419
  NONE always 0
  READ always 1
  WRITE always 2
  BREAK always 3
  RETURN always 4
  BAILOUT always 5
Line 420
  ( possible lifetime[SubObject]=(type)
  nullptr always 0
Line 421
  ( possible lifetime[SubObject]=(type)
Line 426
  , always {!<=-1,!>=2}
  local always {!<=-1,!>=2}
  , always {!<=-1,!>=2}
  inInnerClass always {!<=-1,!>=2}
  , always 0
  = always 0
  0 always 0
Line 429
  ( always {!<=-1,!>=2}
Line 431
  mCpp always {!<=-1,!>=2}
Line 433
  Reassign always 0
  UnusedValue always 1
  ValueFlow always 2
Line 435
  mValueFlowKnown always {!<=-1,!>=2}
Line 438
  ( always {!<=-1,!>=2}
Line 27
  ( always {!<=-1,!>=2}
Line 29
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
Line 32
  ( always {!<=-1,!>=2}
Line 34
  > always {!<=-1,!>=2}
  x {>=symbolic=(y+1),!<=symbolic=(y)}
  y {<=symbolic=(x-1),!>=symbolic=(x)}
  y {!<=symbolic=(x-1),>=symbolic=(x)}
  x {!>=symbolic=(y+1),<=symbolic=(y)}
Line 35
  return always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  diff always symbolic=((x>y)?x-y:y-x)
  2 always 2
  < always {!<=-1,!>=2}
  diff always symbolic=((x>y)?x-y:y-x)
Line 37
  ( always {!<=-1,!>=2}
Line 39
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 43
  ( always {!<=-1,!>=2}
Line 45
  return always {!<=-1,!>=2}
  0 always 0
Line 49
  = always 0
  nullptr always 0
Line 121
  = always 0
  nullptr always 0
Line 65
  , inconclusive lifetime[SubObject]=(errorLogger)
  ( inconclusive lifetime[SubObject]=(errorLogger)
Line 68
  ! always {!<=-1,!>=2}
Line 69
  this always !0
Line 76
  = always 0
  0 always 0
Line 79
  = always 0
  0 always 0
Line 87
  = always 0
  0 always 0
Line 109
  nullptr always 0
Line 114
  nullptr always 0
Line 118
  ( always {!<=-1,!>=2}
Line 123
  return always {!<=-1,!>=2}
  false always 0
Line 135
  0U always 0
  :: always 0
  normal always 0
Line 140
  1 always 1
Line 141
  callstack always size=1
  certainty possible 0@179
Line 146
  0U always 0
  :: always 0
  normal always 0
Line 160
  ( always {!<=-1,!>=2}
Line 42
  hash always !<=-1
Line 56
  NO_LINE always -1
  hash always !<=-1
  0 always 0
  thisAndNextLine always {!<=-1,!>=2}
  false always 0
  matched always {!<=-1,!>=2}
  false always 0
  checked always {!<=-1,!>=2}
  false always 0
Line 58
  this always !0
Line 60
  = always -1
  NO_LINE always -1
  hash always !<=-1
  0 always 0
  thisAndNextLine always {!<=-1,!>=2}
  false always 0
  matched always {!<=-1,!>=2}
  false always 0
  checked always {!<=-1,!>=2}
  false always 0
Line 67
  hash always !<=-1
  = always !<=-1
  . always !<=-1
  hash always !<=-1
Line 68
  thisAndNextLine always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  . always {!<=-1,!>=2}
  thisAndNextLine always {!<=-1,!>=2}
Line 69
  matched always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  . always {!<=-1,!>=2}
  matched always {!<=-1,!>=2}
Line 70
  checked always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  . always {!<=-1,!>=2}
  checked always {!<=-1,!>=2}
Line 71
  this always !0
Line 74
  ( always {!<=-1,!>=2}
Line 75
  != always {!<=-1,!>=2}
Line 76
  return always {!<=-1,!>=2}
  errorId always !symbolic=(other.errorId)
  < always {!<=-1,!>=2}
  . always !symbolic=(errorId)
Line 77
  < always {!<=-1,!>=2}
Line 78
  return always {!<=-1,!>=2}
  true always 1
Line 79
  != always {!<=-1,!>=2}
Line 80
  return always {!<=-1,!>=2}
  fileName always !symbolic=(other.fileName)
  < always {!<=-1,!>=2}
  . always !symbolic=(fileName)
Line 81
  != always {!<=-1,!>=2}
Line 82
  return always {!<=-1,!>=2}
  symbolName always !symbolic=(other.symbolName)
  < always {!<=-1,!>=2}
  . always !symbolic=(symbolName)
Line 83
  hash always !<=-1
  != always {!<=-1,!>=2}
  . always !<=-1
  hash always !<=-1
Line 84
  return always {!<=-1,!>=2}
  hash always {!<=-1,!symbolic=(other.hash)}
  < always {!<=-1,!>=2}
  . always {!<=-1,!symbolic=(hash)}
  hash always !<=-1
Line 85
  thisAndNextLine always {!<=-1,!>=2}
  != always {!<=-1,!>=2}
  . always {!<=-1,!>=2}
  thisAndNextLine always {!<=-1,!>=2}
Line 86
  return always {!<=-1,!>=2}
  thisAndNextLine always {!<=-1,!>=2,!symbolic=(other.thisAndNextLine)}
Line 87
  return always {!<=-1,!>=2}
  false always 0
Line 96
  ( always {!<=-1,!>=2}
Line 98
  ( always {!<=-1,!>=2}
Line 100
  ( always {!<=-1,!>=2}
Line 104
  ( always {!<=-1,!>=2}
Line 105
  return always {!<=-1,!>=2}
  ! {!<=-1,!>=2,0}
  fileName possible size=0
  ( {!<=-1,!>=2,1}
  && always {!<=-1,!>=2}
  fileName always !size=0
  ( always !<=-1
  "?*" always "?*"
  == always {!<=-1,!>=2}
Line 108
  ( always {!<=-1,!>=2}
Line 109
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 110
  == always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 111
  == always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 112
  == always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 113
  hash always !<=-1
  == always {!<=-1,!>=2}
  . always !<=-1
  hash always !<=-1
  && always {!<=-1,!>=2}
Line 114
  thisAndNextLine always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  . always {!<=-1,!>=2}
  thisAndNextLine always {!<=-1,!>=2}
Line 121
  hash always !<=-1
Line 122
  thisAndNextLine always {!<=-1,!>=2}
Line 123
  matched always {!<=-1,!>=2}
Line 124
  checked always {!<=-1,!>=2}
Line 126
  NO_LINE always -1
  = always -1
  -1 always -1
Line 178
  ( always {!<=-1,!>=2}
Line 185
  ( always {!<=-1,!>=2}
Line 197
  unusedFunctionChecking always {!<=-1,!>=2}
Line 203
  unusedFunctionChecking always {!<=-1,!>=2}
Line 28
  Reset always 0
  = always 0
  0 always 0
  , always 1
Line 29
  Bold always 1
  = always 1
  1 always 1
  , always 2
Line 30
  Dim always 2
  = always 2
  2 always 2
  , always 31
Line 31
  FgRed always 31
  = always 31
  31 always 31
  , always 32
Line 32
  FgGreen always 32
  = always 32
  32 always 32
  , always 34
Line 33
  FgBlue always 34
  = always 34
  34 always 34
  , always 35
Line 34
  FgMagenta always 35
  = always 35
  35 always 35
  , always 39
Line 35
  FgDefault always 39
  = always 39
  39 always 39
  , always 41
Line 36
  BgRed always 41
  = always 41
  41 always 41
  , always 42
Line 37
  BgGreen always 42
  = always 42
  42 always 42
  , always 44
Line 38
  BgBlue always 44
  = always 44
  44 always 44
  , always 49
Line 39
  BgDefault always 49
  = always 49
  49 always 49
Line 40
  457U always 457
Line 41
  476U always 476
Line 42
  676U always 676
Line 43
  682U always 682
Line 44
  825U always 825
Line 70
  fileIndex always !<=-1
  0 always 0
  0 always 0
  column always !<=-1
  0 always 0
Line 72
  column always !<=-1
Line 73
  fileIndex always !<=-1
  0 always 0
  column always !<=-1
  column always !<=-1
Line 75
  column always !<=-1
Line 76
  fileIndex always !<=-1
  0 always 0
  column always !<=-1
  column always !<=-1
Line 86
  convert always {!<=-1,!>=2}
  = always 1
  true always 1
Line 93
  convert always {!<=-1,!>=2}
  = always 1
  true always 1
Line 106
  fileIndex always !<=-1
Line 108
  column always !<=-1
Line 175
  verbose always {!<=-1,!>=2}
Line 180
  ( always {!<=-1,!>=2}
Line 190
  incomplete always {!<=-1,!>=2}
Line 197
  hash always !<=-1
Line 243
  ( always " </array>\r\n</dict>\r\n</plist>"
Line 254
  = always 0
  :: always 0
  Reset always 0
  = always 0
  0 always 0
Line 262
  = always 0
  0 always 0
Line 270
  , always !<=-1
  value always !<=-1
Line 273
  ( always !<=-1
  value always !<=-1
Line 289
  ( always {!<=-1,!>=2}
Line 303
  " </array>\r\n</dict>\r\n</plist>" always " </array>\r\n</dict>\r\n</plist>"
Line 54
  null always 0
  uninit always 1
  bufferOverflow always 2
Line 63
  { always 0
Line 64
  { always 0
Line 71
  { always 0
Line 74
  { always 0
Line 87
  { always 0
Line 92
  ( always {!<=-1,!>=2}
Line 101
  warning always {!<=-1,!>=2}
Line 104
  ( always {!<=-1,!>=2}
Line 119
  ( always {!<=-1,!>=2}
Line 122
  { always 0
Line 136
  warning always {!<=-1,!>=2}
Line 148
  ( always {!<=-1,!>=2}
  * always {!<=-1,!>=2}
Line 51
  = always 0
  0 always 0
  notEqual always {!<=-1,!>=2}
  false always 0
Line 53
  notEqual always {!<=-1,!>=2}
Line 65
  ( always "Uninitialized variables"
Line 69
  ( always "Uninitialized variables"
Line 78
  ( always {!<=-1,!>=2}
Line 83
  NO_ALLOC always 0
  NO_CTOR_CALL always 1
  CTOR_CALL always 2
  ARRAY always 3
Line 84
  ( always {!<=-1,!>=2}
Line 85
  , always {!<=-1,!>=2}
  known always {!<=-1,!>=2}
  , always 0
  = always 0
  nullptr always 0
Line 86
  ( always {!<=-1,!>=2}
  , always {!<=-1,!>=2}
  suppressErrors always {!<=-1,!>=2}
  , always {!<=-1,!>=2}
  isuninit always {!<=-1,!>=2}
Line 87
  ( always {!<=-1,!>=2}
  , always {!<=-1,!>=2}
  suppressErrors always {!<=-1,!>=2}
Line 88
  bailout always {!<=-1,!>=2}
Line 90
  cpp always {!<=-1,!>=2}
  , always {!<=-1,!>=2}
  pointer always {!<=-1,!>=2}
  , always 0
  = always 0
  0 always 0
Line 91
  , always {!<=-1,!>=2}
  pointer always {!<=-1,!>=2}
  , always 0
  = always 0
  0 always 0
Line 92
  , always {!<=-1,!>=2}
  pointer always {!<=-1,!>=2}
  , always 0
  = always 0
  0 always 0
Line 93
  , always {!<=-1,!>=2}
  pointer always {!<=-1,!>=2}
  , always 0
  = always 0
  0 always 0
Line 94
  ( always {!<=-1,!>=2}
Line 95
  ( always {!<=-1,!>=2}
  , always {!<=-1,!>=2}
  isPointer always {!<=-1,!>=2}
Line 116
  ( always {!<=-1,!>=2}
Line 119
  , always {!<=-1,!>=2}
  strncpy_ always {!<=-1,!>=2}
Line 124
  errorPath always size=0
Line 127
  alloc possible 2
  == {!<=-1,!>=2,0}
  NO_CTOR_CALL always 1
  || always {!<=-1,!>=2}
  alloc always !1
  == always {!<=-1,!>=2}
  CTOR_CALL always 2
Line 137
  ( always {!<=-1,!>=2}
Line 141
  nullptr always 0
Line 146
  nullptr always 0
Line 147
  nullptr always 0
  "varname" always "varname"
  true always 1
Line 148
  nullptr always 0
  "varname" always "varname"
Line 149
  nullptr always 0
  "a.b" always "a.b"
Line 153
  "Uninitialized variables" always "Uninitialized variables"
Line 157
  "Uninitialized variables\n- using uninitialized local variables\n- using allocated data before it has been initialized\n" always "Uninitialized variables\n- using uninitialized local variables\n- using allocated data before it has been initialized\n"
Line 34
  ( always {!<=-1,!>=2}
  = always 0
  0 always 0
Line 35
  = always 0
  0 always 0
Line 77
  ( always {!<=-1,!>=2}
Line 111
  ( always {!<=-1,!>=2}
Line 134
  ( always {!<=-1,!>=2}
Line 136
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  extra always size=0
Line 146
  ( always {!<=-1,!>=2}
Line 153
  ( always {!<=-1,!>=2}
Line 160
  ( always {!<=-1,!>=2}
Line 167
  ( always {!<=-1,!>=2}
Line 181
  ( always {!<=-1,!>=2}
Line 44
  >= always {!<=-1,!>=2}
  64 always 64
Line 46
  - possible >=-4611686018427387904
  1LL always 1
  << possible <=4611686018427387904
  bit {!>=64,<=63}
  - {!>=63,<=62}
  1 always 1
Line 50
  >= always {!<=-1,!>=2}
  64 always 64
Line 51
  ~ always !<=-1
  0ULL always 0
  >> always !<=-1
  1 always 1
Line 52
  1LL always 1
  << possible <=4611686018427387904
  bit {!>=64,<=63}
  - {!>=63,<=62}
  1 always 1
  - {<=4611686018427387903,!>=4611686018427387904}
  1LL always 1
Line 58
  ( always {!<=-1,!>=2}
Line 59
  return always {!<=-1,!>=2}
  >= always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  <= always {!<=-1,!>=2}
Line 62
  ( always {!<=-1,!>=2}
  value always !<=-1
Line 63
  intMax always !<=-1
  intMax always !<=-1
  = always !<=-1
Line 64
  return always {!<=-1,!>=2}
  value always !<=-1
  <= always {!<=-1,!>=2}
  intMax always !<=-1
Line 67
  ( always {!<=-1,!>=2}
Line 68
  return always {!<=-1,!>=2}
  >= always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  <= always {!<=-1,!>=2}
Line 71
  ( always {!<=-1,!>=2}
  value always !<=-1
Line 72
  longMax always !<=-1
  longMax always !<=-1
  = always !<=-1
Line 73
  return always {!<=-1,!>=2}
  value always !<=-1
  <= always {!<=-1,!>=2}
  longMax always !<=-1
Line 76
  ( always {!<=-1,!>=2}
  value always !<=-1
Line 77
  longLongMax always !<=-1
  longLongMax always !<=-1
  = always !<=-1
Line 78
  return always {!<=-1,!>=2}
  value always !<=-1
  <= always {!<=-1,!>=2}
  longLongMax always !<=-1
Line 103
  Unspecified always 0
Line 104
  Native always 1
Line 105
  Win32A always 2
Line 106
  Win32W always 3
Line 107
  Win64 always 4
Line 108
  Unix32 always 5
Line 109
  Unix64 always 6
Line 110
  PlatformFile always 7
Line 117
  ( always {!<=-1,!>=2}
Line 125
  ( always {!<=-1,!>=2}
Line 128
  ( always {!<=-1,!>=2}
Line 134
  ( always {!<=-1,!>=2}
Line 135
  return always {!<=-1,!>=2}
  platformType possible {3,4}
  == {!<=-1,!>=2,0}
  Win32A always 2
  || always {!<=-1,!>=2}
Line 136
  platformType {4,!2}
  == {!<=-1,!>=2,0}
  Win32W always 3
  || always {!<=-1,!>=2}
Line 137
  platformType always {!2,!3}
  == always {!<=-1,!>=2}
  Win64 always 4
Line 146
  Unspecified always 0
Line 147
  "Unspecified" always "Unspecified"
Line 148
  Native always 1
Line 149
  "Native" always "Native"
Line 150
  Win32A always 2
Line 151
  "win32A" always "win32A"
Line 152
  Win32W always 3
Line 153
  "win32W" always "win32W"
Line 154
  Win64 always 4
Line 155
  "win64" always "win64"
Line 156
  Unix32 always 5
Line 157
  "unix32" always "unix32"
Line 158
  Unix64 always 6
Line 159
  "unix64" always "unix64"
Line 160
  PlatformFile always 7
Line 161
  "platformFile" always "platformFile"
Line 163
  "unknown" always "unknown"
Line 168
  1 always 1
Line 37
  = always 0
  nullptr always 0
Line 38
  = always 0
  0 always 0
Line 45
  ( possible lifetime[SubObject]=(exprid)
Line 49
  ( always {!<=-1,!>=2}
Line 50
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
Line 54
  ( always {!<=-1,!>=2}
Line 56
  return always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
Line 60
  ( always !<=-1
Line 72
  impossible always {!<=-1,!>=2}
  = always 0
  false always 0
Line 74
  ( always {!<=-1,!>=2}
Line 75
  , always 0
  impossible always {!<=-1,!>=2}
  = always 0
  false always 0
Line 77
  ( always {!<=-1,!>=2}
Line 78
  ( always {!<=-1,!>=2}
Line 79
  , always 1
  isEqual always {!<=-1,!>=2}
  = always 1
  true always 1
Line 83
  ( always {!<=-1,!>=2}
Line 84
  ( always {!<=-1,!>=2}
Line 89
  ( always {!<=-1,!>=2}
Line 95
  ( always {!<=-1,!>=2}
Line 101
  ( always start=0
Line 102
  return possible lifetime[Iterator]=(mValues)
  ( {lifetime[Iterator]=(mValues),start=0}
Line 105
  ( always end=0
Line 106
  return possible lifetime[Iterator]=(mValues)
  ( {lifetime[Iterator]=(mValues),end=0}
Line 109
  ( always start=0
Line 110
  return possible lifetime[Iterator]=(mValues)
  ( {lifetime[Iterator]=(mValues),start=0}
Line 113
  ( always end=0
Line 114
  return possible lifetime[Iterator]=(mValues)
  ( {lifetime[Iterator]=(mValues),end=0}
Line 121
  , always {!<=-1,!>=2}
  then always {!<=-1,!>=2}
Line 130
  , always 0
  = always 0
  nullptr always 0
Line 131
  , always 0
  = always 0
  nullptr always 0
Line 135
  , always {!<=-1,!>=2}
  b always {!<=-1,!>=2}
  , always 0
  isEmpty always {!<=-1,!>=2}
  = always 0
  false always 0
Line 145
  , always 0
Line 146
  = always 0
  nullptr always 0
Line 153
  ( always {!<=-1,!>=2}
  , always 0
  = always 0
  nullptr always 0
Line 160
  ( always {!<=-1,!>=2}
  , always 0
  = always 0
  nullptr always 0
Line 40
  ( always {!<=-1,!>=2}
Line 41
  return always {!<=-1,!>=2}
  < always {!<=-1,!>=2}
  0 always 0
Line 54
  UNKNOWN always 0
Line 55
  MISSING always 1
Line 56
  FAILURE always 2
Line 57
  COMPILE_DB always 3
Line 58
  VS_SLN always 4
Line 59
  VS_VCXPROJ always 5
Line 60
  BORLAND always 6
Line 61
  CPPCHECK_GUI always 7
Line 66
  :: always 0
  Unspecified always 0
  msc always {!<=-1,!>=2}
  false always 0
  useMfc always {!<=-1,!>=2}
  false always 0
Line 71
  msc always {!<=-1,!>=2}
  ? possible {";_MSC_VER=1900",""}
  ";_MSC_VER=1900" always ";_MSC_VER=1900"
  : always ""
  "" always ""
  useMfc always {!<=-1,!>=2}
  ? possible {";__AFXWIN_H__=1",""}
  ";__AFXWIN_H__=1" always ";__AFXWIN_H__=1"
  : always ""
  "" always ""
Line 78
  msc always {!<=-1,!>=2}
Line 79
  useMfc always {!<=-1,!>=2}
Line 108
  , always 0
  = always 0
  nullptr always 0
Line 110
  ( always {!<=-1,!>=2}
Line 111
  ( always {!<=-1,!>=2}
Line 112
  ( always {!<=-1,!>=2}
Line 114
  ( always {!<=-1,!>=2}
Line 115
  ( always {!<=-1,!>=2}
Line 116
  ( always {!<=-1,!>=2}
Line 128
  8 always 8
  = always "project"
  "project" always "project"
Line 129
  8 always 8
  = always "version"
  "version" always "version"
Line 130
  2 always 2
  = always "1"
  "1" always "1"
Line 131
  9 always 9
  = always "builddir"
  "builddir" always "builddir"
Line 132
  14 always 14
  = always "importproject"
  "importproject" always "importproject"
Line 133
  23 always 23
  = always "analyze-all-vs-configs"
  "analyze-all-vs-configs" always "analyze-all-vs-configs"
Line 134
  7 always 7
  = always "parser"
  "parser" always "parser"
Line 135
  12 always 12
  = always "bug-hunting"
  "bug-hunting" always "bug-hunting"
Line 136
  11 always 11
  = always "includedir"
  "includedir" always "includedir"
Line 137
  4 always 4
  = always "dir"
  "dir" always "dir"
Line 138
  5 always 5
  = always "name"
  "name" always "name"
Line 139
  8 always 8
  = always "defines"
  "defines" always "defines"
Line 140
  7 always 7
  = always "define"
  "define" always "define"
Line 141
  5 always 5
  = always "name"
  "name" always "name"
Line 142
  10 always 10
  = always "undefines"
  "undefines" always "undefines"
Line 143
  9 always 9
  = always "undefine"
  "undefine" always "undefine"
Line 144
  6 always 6
  = always "paths"
  "paths" always "paths"
Line 145
  4 always 4
  = always "dir"
  "dir" always "dir"
Line 146
  5 always 5
  = always "name"
  "name" always "name"
Line 147
  5 always 5
  = always "root"
  "root" always "root"
Line 148
  5 always 5
  = always "name"
  "name" always "name"
Line 149
  7 always 7
  = always "ignore"
  "ignore" always "ignore"
Line 150
  5 always 5
  = always "path"
  "path" always "path"
Line 151
  5 always 5
  = always "name"
  "name" always "name"
Line 152
  8 always 8
  = always "exclude"
  "exclude" always "exclude"
Line 153
  5 always 5
  = always "path"
  "path" always "path"
Line 154
  5 always 5
  = always "name"
  "name" always "name"
Line 155
  19 always 19
  = always "function-contracts"
  "function-contracts" always "function-contracts"
Line 156
  19 always 19
  = always "variable-contracts"
  "variable-contracts" always "variable-contracts"
Line 157
  10 always 10
  = always "libraries"
  "libraries" always "libraries"
Line 158
  8 always 8
  = always "library"
  "library" always "library"
Line 159
  9 always 9
  = always "platform"
  "platform" always "platform"
Line 160
  13 always 13
  = always "suppressions"
  "suppressions" always "suppressions"
Line 161
  12 always 12
  = always "suppression"
  "suppression" always "suppression"
Line 162
  6 always 6
  = always "addon"
  "addon" always "addon"
Line 163
  7 always 7
  = always "addons"
  "addons" always "addons"
Line 164
  5 always 5
  = always "tool"
  "tool" always "tool"
Line 165
  6 always 6
  = always "tools"
  "tools" always "tools"
Line 166
  5 always 5
  = always "tags"
  "tags" always "tags"
Line 167
  4 always 4
  = always "tag"
  "tag" always "tag"
Line 168
  13 always 13
  = always "tag-warnings"
  "tag-warnings" always "tag-warnings"
Line 169
  4 always 4
  = always "tag"
  "tag" always "tag"
Line 170
  8 always 8
  = always "warning"
  "warning" always "warning"
Line 171
  5 always 5
  = always "hash"
  "hash" always "hash"
Line 172
  14 always 14
  = always "check-headers"
  "check-headers" always "check-headers"
Line 173
  23 always 23
  = always "check-unused-templates"
  "check-unused-templates" always "check-unused-templates"
Line 174
  14 always 14
  = always "max-ctu-depth"
  "max-ctu-depth" always "max-ctu-depth"
Line 175
  23 always 23
  = always "max-template-recursion"
  "max-template-recursion" always "max-template-recursion"
Line 176
  37 always 37
  = always "check-unknown-function-return-values"
  "check-unknown-function-return-values" always "check-unknown-function-return-values"
Line 177
  11 always 11
  = always "clang-tidy"
  "clang-tidy" always "clang-tidy"
Line 178
  5 always 5
  = always "name"
  "name" always "name"
Line 179
  18 always 18
  = always "vs-configurations"
  "vs-configurations" always "vs-configurations"
Line 180
  7 always 7
  = always "config"
  "config" always "config"
Line 30
  SHOWTIME_NONE always 0
  = always 0
  0 always 0
  , always 1
Line 31
  SHOWTIME_FILE always 1
  , always 2
Line 32
  SHOWTIME_SUMMARY always 2
  , always 3
Line 33
  SHOWTIME_TOP5 always 3
Line 40
  = always 0
  0 always 0
Line 48
  0 always 0
Line 49
  0 always 0
Line 52
  ( always !<=-1
  ( always !<=-1
Line 70
  , always 0
  = always 0
  nullptr always 0
Line 82
  mStopped always {!<=-1,!>=2}
Line 114
  checkAllConfigurations always {!<=-1,!>=2}
Line 117
  checkConfiguration always {!<=-1,!>=2}
Line 122
  checkHeaders always {!<=-1,!>=2}
Line 125
  checkLibrary always {!<=-1,!>=2}
Line 131
  checkUnusedTemplates always {!<=-1,!>=2}
Line 134
  clang always {!<=-1,!>=2}
Line 140
  clangTidy always {!<=-1,!>=2}
Line 152
  daca always {!<=-1,!>=2}
Line 155
  debugnormal always {!<=-1,!>=2}
Line 158
  debugSimplified always {!<=-1,!>=2}
Line 161
  debugtemplate always {!<=-1,!>=2}
Line 164
  debugwarnings always {!<=-1,!>=2}
Line 167
  dump always {!<=-1,!>=2}
Line 171
  None always 0
  C always 1
  CPP always 2
Line 178
  exceptionHandling always {!<=-1,!>=2}
Line 191
  force always {!<=-1,!>=2}
Line 198
  inlineSuppressions always {!<=-1,!>=2}
Line 202
  jobs always !<=-1
Line 207
  jointSuppressionReport always {!<=-1,!>=2}
Line 243
  preprocessOnly always {!<=-1,!>=2}
Line 248
  quiet always {!<=-1,!>=2}
Line 251
  relativePaths always {!<=-1,!>=2}
Line 254
  reportProgress always {!<=-1,!>=2}
Line 260
  "simple" always "simple"
Line 261
  "rule" always "rule"
Line 262
  :: always 3
  style always 3
Line 280
  classes always {!<=-1,!>=2}
  false always 0
  externalFunctions always {!<=-1,!>=2}
  false always 0
  internalFunctions always {!<=-1,!>=2}
  false always 0
  externalVariables always {!<=-1,!>=2}
  false always 0
Line 289
  classes always {!<=-1,!>=2}
  = always 0
  externalFunctions always {!<=-1,!>=2}
  = always 0
  internalFunctions always {!<=-1,!>=2}
  = always 0
  externalVariables always {!<=-1,!>=2}
  = always 0
  false always 0
Line 298
  classes always {!<=-1,!>=2}
Line 305
  externalFunctions always {!<=-1,!>=2}
Line 311
  internalFunctions always {!<=-1,!>=2}
Line 317
  externalVariables always {!<=-1,!>=2}
Line 350
  verbose always {!<=-1,!>=2}
Line 353
  xml always {!<=-1,!>=2}
Line 362
  ( always {!<=-1,!>=2}
Line 364
  ( always !<=-1
  >= always {!<=-1,!>=2}
  ( always !<=-1
  && always {!<=-1,!>=2}
  0 always 0
  ( {!<=-1,<=symbolic=(file.length()),!>=symbolic=(file.length()+1)}
  == always {!<=-1,!>=2}
  0 always 0
Line 365
  return always {!<=-1,!>=2}
  true always 1
Line 368
  return always {!<=-1,!>=2}
  false always 0
Line 383
  ( always {!<=-1,!>=2}
  , always 0
  inconclusiveCheck always {!<=-1,!>=2}
  = always 0
  false always 0
Line 386
  ( always {!<=-1,!>=2}
Line 387
  return always {!<=-1,!>=2}
  ( possible lifetime[Iterator]=(libraries)
  ( {lifetime[Iterator]=(libraries),start=0}
  ( {lifetime[Iterator]=(libraries),end=0}
  "posix" always "posix"
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(libraries),end=0}
Line 391
  t always {!<=-1,!>=2}
  = always 1
  true always 1
Line 392
  = always {!<=-1,!>=2}
  t always {!<=-1,!>=2}
Line 396
  ( always {!<=-1,!>=2}
Line 397
  return always {!<=-1,!>=2}
Line 58
  ( always {!<=-1,!>=2}
Line 59
  return always {!<=-1,!>=2}
  mIsC always {!<=-1,!>=2}
Line 63
  ( always {!<=-1,!>=2}
Line 64
  return always {!<=-1,!>=2}
  mIsCpp always {!<=-1,!>=2}
Line 73
  , always 0
  split always {!<=-1,!>=2}
  = always 0
  false always 0
Line 90
  , always 1
  one_line always {!<=-1,!>=2}
  = always 1
  true always 1
Line 101
  ( always {!<=-1,!>=2}
Line 103
  && always {!<=-1,!>=2}
Line 156
  ( always !<=-1
Line 175
  ( always {!<=-1,!>=2}
Line 192
  ( always {!<=-1,!>=2}
Line 219
  mIsC always {!<=-1,!>=2}
Line 220
  mIsCpp always {!<=-1,!>=2}
Line 126
  ( always !<=-1
  "operator" always "operator"
  != always {!<=-1,!>=2}
Line 127
  = always "(valueFlow)"
  "(valueFlow)" always "(valueFlow)"
Line 128
  1 always 1
Line 129
  callstack always size=1
  :: always 7
  debug always 7
Line 130
  file possible {"cppcheck-2.8/lib/valueflow.cpp"@82,"cppcheck-2.8/lib/valueflow.cpp"@85,"cppcheck-2.8/lib/valueflow.cpp"@138,"cppcheck-2.8/lib/valueflow.cpp"@180,"cppcheck-2.8/lib/valueflow.cpp"@2,"cppcheck-2.8/lib/valueflow.cpp"@37,"cppcheck-2.8/lib/valueflow.cpp"@38,"cppcheck-2.8/lib/valueflow.cpp"@44,"cppcheck-2.8/lib/valueflow.cpp"@46,"cppcheck-2.8/lib/valueflow.cpp"@225}
  ":" always ":"
  line possible {7110@82,7119@85,6830@138,6788@180,6370@2,6416@37,6420@38,6425@44,6433@46,5938@225}
  ":" always ":"
  function possible {"(valueFlow)",size=11}
  " bailout: " always " bailout: "
  what possible {"function return; nontrivial function body"@82,"function return; unhandled argument type"@85,"For loop variable bailout on conditional continue|break|return"@37,"For loop variable skipping conditional scope"@38,"For loop variable bailout on conditional continue|break|return"@44,"For loop skipping {} code"@46,"valueFlowAfterCondition: bailing in conditional block"@227,"possible noreturn scope"@236,"possible noreturn scope"@239}
  type possible {"valueFlowBailout"@82,"valueFlowBailout"@85,"valueFlowBailout"@138,"valueFlowBailout"@180,"valueFlowBailout"@2,"valueFlowBailout"@37,"valueFlowBailout"@38,"valueFlowBailout"@44,"valueFlowBailout"@46,"valueFlowBailout"@225}
  :: always 0
  normal always 0
Line 140
  , always -1
  = always -1
  -1 always -1
Line 143
  indirect possible {symbolic=(v.indirect),<=-1}
  >= {!<=-1,!>=2,<=0}
  0 always 0
  && always {!<=-1,!>=2}
  != always {!<=-1,!>=2}
  indirect {>=0,!<=-1}
Line 149
  , always -1
  = always -1
  -1 always -1
Line 151
  [ possible lifetime[Lambda]=(indirect)
Line 152
  indirect possible symbolic=(v.indirect)
  >= always {!<=-1,!>=2}
  0 always 0
  && always {!<=-1,!>=2}
  != always {!<=-1,!>=2}
  indirect {>=0,!<=-1}
Line 153
  false always 0
Line 154
  ( always {!<=-1,!>=2}
Line 158
  , always -1
  = always -1
  -1 always -1
Line 160
  indirect possible -1
Line 161
  indirect possible -1
Line 164
  , always -1
  = always -1
  -1 always -1
Line 167
  indirect possible {symbolic=(v.indirect),-1}
  >= {!<=-1,!>=2,0}
  0 always 0
  && always {!<=-1,!>=2}
  != always {!<=-1,!>=2}
  indirect {>=0,!<=-1}
Line 169
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 171
  != always {!<=-1,!>=2}
Line 177
  , always {!<=-1,!>=2}
  upper always {!<=-1,!>=2}
Line 179
  upper {!<=-1,!>=2,0@156,1@156}
Line 180
  = always 0
  :: always 0
  Upper always 0
Line 182
  = always 1
  :: always 1
  Lower always 1
Line 185
  , always {!<=-1,!>=2}
  invert always {!<=-1,!>=2}
Line 187
  ( always {!<=-1,!>=2}
  "<|<=" always "<|<="
Line 188
  ! always {!<=-1,!>=2}
  invert always {!<=-1,!>=2}
Line 189
  ( always {!<=-1,!>=2}
  ">|>=" always ">|>="
Line 190
  invert always {!<=-1,!>=2}
Line 194
  , always {!<=-1,!>=2}
Line 195
  lhs always {!<=-1,!>=2}
Line 200
  ( always {!<=-1,!>=2}
  "==|!=|>=|<=" always "==|!=|>=|<="
Line 201
  = inconclusive {lifetime[SubObject]=(tok),lifetime[SubObject]=(value)}
  { inconclusive {lifetime[SubObject]=(tok),lifetime[SubObject]=(value)}
Line 202
  = always ">="
  ">=" always ">="
Line 203
  = always "<="
  "<=" always "<="
Line 204
  lhs always {!<=-1,!>=2}
Line 205
  greaterThan always ">="
  lessThan always "<="
Line 206
  ( always {!<=-1,!>=2}
  greaterThan {">=","<="}
  ( {!<=-1,2}
  greaterThan {">=","<="}
Line 207
  = inconclusive lifetime[SubObject]=(tok)
  { inconclusive lifetime[SubObject]=(tok)
  1 always 1
Line 208
  ( always {!<=-1,!>=2}
  ( always !<=-1
Line 209
  = inconclusive lifetime[SubObject]=(tok)
  { inconclusive lifetime[SubObject]=(tok)
  1 always 1
Line 211
  = inconclusive {lifetime[SubObject]=(tok),lifetime[SubObject]=(value)}
  { inconclusive {lifetime[SubObject]=(tok),lifetime[SubObject]=(value)}
Line 214
  = always ">"
  ">" always ">"
Line 215
  = always "<"
  "<" always "<"
Line 216
  lhs always {!<=-1,!>=2}
Line 217
  greaterThan always ">"
  lessThan always "<"
Line 218
  ( always {!<=-1,!>=2}
  greaterThan {">","<"}
  ( {!<=-1,1}
  greaterThan {">","<"}
Line 219
  = inconclusive lifetime[SubObject]=(tok)
  { inconclusive lifetime[SubObject]=(tok)
  1 always 1
Line 220
  = inconclusive {lifetime[SubObject]=(tok),lifetime[SubObject]=(value)}
  { inconclusive {lifetime[SubObject]=(tok),lifetime[SubObject]=(value)}
Line 221
  ( always {!<=-1,!>=2}
  ( always !<=-1
Line 222
  = inconclusive lifetime[SubObject]=(tok)
  { inconclusive lifetime[SubObject]=(tok)
  1 always 1
Line 223
  = inconclusive {lifetime[SubObject]=(tok),lifetime[SubObject]=(value)}
  { inconclusive {lifetime[SubObject]=(tok),lifetime[SubObject]=(value)}
Line 226
  lhs {!<=-1,!>=2,0@75,1@75}
Line 227
  ! {!<=-1,!>=2,1@75,0@75}
  lhs {!<=-1,!>=2,0@75,1@75}
Line 230
  ( always {!<=-1,!>=2}
Line 232
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
Line 237
  ! always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
Line 238
  nullptr always 0
Line 239
  ( always {!<=-1,!>=2}
Line 240
  ( always !0
Line 241
  ( always !0
Line 242
  ! {!<=-1,!>=2,0}
  value1 possible size=0
  ( {!<=-1,!>=2,1}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 243
  ( always {!<=-1,!>=2}
Line 244
  value2 {!size=0,NonMovedVariable}
Line 245
  ( always {!<=-1,!>=2}
Line 246
  value1 always NonMovedVariable
Line 248
  ! {!<=-1,!>=2,0}
  value1 possible {NonMovedVariable,size=0}
  ( {!<=-1,!>=2,1}
Line 249
  ( always {!<=-1,!>=2}
  value1 always !size=0
  || always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  false always 0
Line 250
  nullptr always 0
Line 251
  true always 1
  value1 always !size=0
Line 253
  ! {!<=-1,!>=2,0}
  value2 possible size=0
  ( {!<=-1,!>=2,1}
Line 254
  ( always {!<=-1,!>=2}
  value2 always !size=0
  || always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  false always 0
Line 255
  nullptr always 0
Line 256
  false always 0
  value2 always !size=0
Line 260
  nullptr always 0
Line 266
  ( always {!<=-1,!>=2}
Line 268
  { always {size=0,{}
Line 272
  ( always {!<=-1,!>=2}
Line 274
  ! always {!<=-1,!>=2}
Line 275
  return always {!<=-1,!>=2}
  false always 0
Line 276
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  tok always !0
Line 277
  return always {!<=-1,!>=2}
  false always 0
Line 278
  tok always !0
Line 279
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  parent always symbolic=(tok->astParent())
  "{|(" always "{|("
Line 280
  return always {!<=-1,!>=2}
  false always 0
Line 281
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  parent always symbolic=(tok->astParent())
  "%var% {|(" always "%var% {|("
Line 282
  return always {!<=-1,!>=2}
  false always 0
Line 283
  ! always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
Line 284
  return always {!<=-1,!>=2}
  false always 0
Line 287
  ( always {!<=-1,!>=2}
  "," always ","
Line 288
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  ":" always ":"
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "?" always "?"
Line 292
  = always 0
  nullptr always 0
Line 293
  = always 0
  nullptr always 0
Line 295
  ! always {!<=-1,!>=2}
Line 296
  { always {size=0,{}
Line 297
  ! always {!<=-1,!>=2}
  tok always !0
Line 298
  { always {size=0,{}
Line 299
  ( always {!<=-1,!>=2}
  tok always !0
Line 301
  parent always !0
  tok always !0
  ( always !0
Line 302
  tok always !0
  ( always !0
  ( possible symbolic=(*parent)
Line 303
  { always {size=1,{}
  tok always !0
  ( always !0
  ( always !0
Line 304
  { always {size=0,{}
Line 305
  ( always {!<=-1,!>=2}
  tok always !0
  ( always !0
  "(|{|," always "(|{|,"
Line 306
  = always -1
  -1 always -1
Line 307
  tok always !0
  argn always -1
Line 308
  = always 0
  nullptr always 0
Line 309
  && always {!<=-1,!>=2}
  >= always {!<=-1,!>=2}
  0 always 0
Line 310
  ftok always !0
Line 312
  ftok always !0
  argn always !<=-1
Line 313
  = always 0
  nullptr always 0
Line 314
  ftok always !0
  argn always !<=-1
Line 315
  ! always {!<=-1,!>=2}
Line 317
  ! always {!<=-1,!>=2}
  var always !0
Line 319
  var always !0
Line 320
  var always !0
  ( always !0
Line 322
  ( always !<=-1
  == always {!<=-1,!>=2}
  1 always 1
  && always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 323
  parent always !0
  = always !0
  nameTok always !0
Line 325
  result possible size=1
Line 326
  ftok always !0
  & {lifetime[Address]=(typeTok),!0}
  typeTok always 0
Line 327
  ( always {!<=-1,!>=2}
Line 328
  { always {size=1,{}
Line 329
  t always !0
Line 331
  scope always symbolic=(t->classScope)
  && always {!<=-1,!>=2}
  scope {symbolic=(t->classScope),!0}
  == always {!<=-1,!>=2}
  0 always 0
  && always {!<=-1,!>=2}
  t always !0
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 332
  t always !0
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  t always !0
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ftok always !0
  < always {!<=-1,!>=2}
  scope always symbolic=(t->classScope)
  ( always !<=-1
Line 333
  argn always !<=-1
  < always {!<=-1,!>=2}
  scope {symbolic=(t->classScope),!0}
  ( always !<=-1
Line 334
  = possible lifetime[Object]=(scope->varlist)
  ( possible lifetime[Object]=(scope->varlist)
  scope {symbolic=(t->classScope),!0}
  ( {lifetime[Iterator]=(scope->varlist),start=0}
  argn always !<=-1
Line 335
  it possible lifetime[Object]=(scope->varlist)
Line 336
  { always {size=1,{}
Line 341
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  tok always !0
  ( always !0
  -2 always -2
  ". push_back|push_front|insert|push (" always ". push_back|push_front|insert|push ("
  && always {!<=-1,!>=2}
Line 342
  ( always {!<=-1,!>=2}
  tok always !0
  ( always !0
  -2 always -2
Line 343
  tok always !0
  ( always !0
  -2 always -2
Line 345
  ! always {!<=-1,!>=2}
  vtCont always symbolic=(contTok->valueType())
Line 346
  { always {size=0,{}
Line 347
  vtCont always symbolic=(contTok->valueType())
  . always !0
  settings always !0
Line 348
  { always {size=1,{}
Line 350
  ( always {!<=-1,!>=2}
  ( always !0
  "return|(|{|%assign%" always "return|(|{|%assign%"
  && always {!<=-1,!>=2}
Line 351
  parent always !0
  = always !0
  ( always !0
Line 353
  ( {symbolic=(*parent),!0}
Line 354
  { always {size=1,{}
  ( always !0
  ( always !0
Line 355
  { always {size=0,{}
Line 358
  ( always {!<=-1,!>=2}
  , always 0
  unknown always {!<=-1,!>=2}
  = always 0
  false always 0
Line 360
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "{" always "{"
Line 361
  return always {!<=-1,!>=2}
  false always 0
Line 363
  "return|continue|break|throw|goto" always "return|continue|break|throw|goto"
Line 364
  && always {!<=-1,!>=2}
  termTok always !0
  == always {!<=-1,!>=2}
Line 365
  return always {!<=-1,!>=2}
  true always 1
Line 367
  && always {!<=-1,!>=2}
  tokenlist always !0
  ( always {!<=-1,!>=2}
  & {lifetime[Address]=(unknownFunction),!0}
  unknownFunction always size=0
Line 368
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  unknown always {!<=-1,!>=2}
Line 369
  return always {!<=-1,!>=2}
  false always 0
Line 374
  ( always {!<=-1,!>=2}
Line 375
  = always 0
  :: always 0
  INT always 0
Line 376
  >= always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  <= always {!<=-1,!>=2}
Line 379
  = always 0
  0 always 0
Line 382
  < always {!<=-1,!>=2}
Line 383
  one always 1
  = always 1
  1 always 1
Line 384
  one always 1
  << always !<=-1
  bit {<=symbolic=(MathLib::bigint_bits-1),!>=symbolic=(MathLib::bigint_bits)}
  - always !<=-1
  1 always 1
Line 385
  == always {!<=-1,!>=2}
  :: always 1
  SIGNED always 1
  && always {!<=-1,!>=2}
  & always !<=-1
  one always 1
  << always !<=-1
  bit always !>=symbolic=(MathLib::bigint_bits)
  1 always 1
Line 386
  ~ always !<=1
  one always 1
  << always !<=-1
  bit always !>=symbolic=(MathLib::bigint_bits)
  - always !<=-1
  1ULL always 1
Line 392
  ( always {!<=-1,!>=2}
Line 393
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 398
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 399
  result possible {lifetime[Address]=(result)@56,lifetime[Address]=(result)@187}
Line 400
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 401
  result possible {lifetime[Address]=(result)@56,lifetime[Address]=(result)@187}
Line 402
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 403
  result possible {lifetime[Address]=(result)@56,lifetime[Address]=(result)@187}
Line 405
  result possible {lifetime[Address]=(result)@56,lifetime[Address]=(result)@187}
Line 406
  ( always {!<=-1,!>=2}
Line 407
  result possible {lifetime[Address]=(result)@56,lifetime[Address]=(result)@187}
Line 408
  result possible {lifetime[Address]=(result)@56,lifetime[Address]=(result)@187}
Line 410
  ( always {!<=-1,!>=2}
Line 411
  result possible {lifetime[Address]=(result)@56,lifetime[Address]=(result)@187}
Line 412
  result possible {lifetime[Address]=(result)@56,lifetime[Address]=(result)@187}
Line 414
  ( always {!<=-1,!>=2}
Line 415
  result possible {lifetime[Address]=(result)@56,lifetime[Address]=(result)@187}
Line 416
  ( always {!<=-1,!>=2}
Line 417
  result possible {lifetime[Address]=(result)@56,lifetime[Address]=(result)@187}
Line 418
  result possible {lifetime[Address]=(result)@56,lifetime[Address]=(result)@187}
  . always !0
  : always 1
Line 419
  result possible {lifetime[Address]=(result)@56,lifetime[Address]=(result)@187}
  != always {!<=-1,!>=2}
  0 always 0
  . always !0
  : always 1
Line 420
  result possible {lifetime[Address]=(result)@56,lifetime[Address]=(result)@187}
  result possible {lifetime[Address]=(result)@56,lifetime[Address]=(result)@187}
  == always {!<=-1,!>=2}
Line 421
  result possible {lifetime[Address]=(result)@56,lifetime[Address]=(result)@187}
  ( always {!<=-1,!>=2}
Line 422
  result possible {lifetime[Address]=(result)@56,lifetime[Address]=(result)@187}
  . always {!<=-1,!>=2}
  safe always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  . always {!<=-1,!>=2}
  safe always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  . always {!<=-1,!>=2}
  safe always {!<=-1,!>=2}
Line 423
  . possible {0,1}
  == always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
Line 424
  . possible 1
  == {!<=-1,!>=2,0}
  :: always 0
  Upper always 0
  || always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 0
  Upper always 0
Line 425
  result possible {lifetime[Address]=(result)@56,lifetime[Address]=(result)@187}
  = always 0
  :: always 0
  Upper always 0
Line 426
  . possible 0
  == {!<=-1,!>=2,0}
  :: always 1
  Lower always 1
  || always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 1
  Lower always 1
Line 427
  result possible {lifetime[Address]=(result)@56,lifetime[Address]=(result)@187}
  = always 1
  :: always 1
  Lower always 1
Line 429
  != always {!<=-1,!>=2}
Line 430
  result possible {lifetime[Address]=(result)@56,lifetime[Address]=(result)@187}
  = always -1
  -1 always -1
Line 432
  result possible {lifetime[Address]=(result)@56,lifetime[Address]=(result)@187}
  = always symbolic=(value2.path)
  . always symbolic=(value2.path)
Line 438
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "{|(" always "{|("
Line 439
  nullptr always 0
Line 441
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "%type% (|{" always "%type% (|{"
  && always {!<=-1,!>=2}
Line 442
  == always {!<=-1,!>=2}
  :: always 1
  eType always 1
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 444
  != always {!<=-1,!>=2}
  "(" always "("
Line 445
  nullptr always 0
Line 446
  ! {!<=-1,!>=2,1}
  ( possible 0
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "( %name%" always "( %name%"
Line 448
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "const_cast|dynamic_cast|reinterpret_cast|static_cast <" always "const_cast|dynamic_cast|reinterpret_cast|static_cast <"
Line 449
  2 always 2
Line 450
  nullptr always 0
Line 454
  ( always {!<=-1,!>=2}
Line 456
  return always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "+|-" always "+|-"
Line 459
  ( always {!<=-1,!>=2}
Line 461
  noninvertible always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 462
  noninvertible always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 463
  return always {!<=-1,!>=2}
  false always 0
Line 464
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 465
  return always {!<=-1,!>=2}
  false always 0
Line 466
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "+|-" always "+|-"
Line 467
  return always {!<=-1,!>=2}
  false always 0
Line 468
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  != always {!<=-1,!>=2}
  :: always 6
  eString always 6
Line 469
  return always {!<=-1,!>=2}
  false always 0
Line 470
  return always {!<=-1,!>=2}
  true always 1
Line 476
  ( always {!<=-1,!>=2}
Line 482
  :: always 0
  INT always 0
Line 483
  :: always 2
  FLOAT always 2
Line 484
  :: always 10
  SYMBOLIC always 10
Line 485
  :: always 1
  TOK always 1
Line 486
  :: always 2
  FLOAT always 2
  :: always 0
  INT always 0
Line 487
  :: always 1
  TOK always 1
  :: always 0
  INT always 0
Line 488
  :: always 8
  ITERATOR_START always 8
  :: always 0
  INT always 0
Line 489
  :: always 9
  ITERATOR_END always 9
  :: always 0
  INT always 0
Line 491
  == always {!<=-1,!>=2}
Line 492
  return always {!<=-1,!>=2}
  true always 1
Line 493
  = {lifetime[Iterator]=(compatibleTypes),size=5}
  compatibleTypes always {{,size=5}
  ( {lifetime[Iterator]=(compatibleTypes),size=5}
  x always !symbolic=(y)
Line 494
  it {lifetime[Iterator]=(compatibleTypes),symbolic=(compatibleTypes.find(x)),size=5}
  == always {!<=-1,!>=2}
  compatibleTypes always {{,size=5}
  ( {lifetime[Iterator]=(compatibleTypes),end=0,size=5}
Line 495
  return always {!<=-1,!>=2}
  false always 0
Line 496
  return always {!<=-1,!>=2}
  it {lifetime[Iterator]=(compatibleTypes),symbolic=(compatibleTypes.find(x)),!symbolic=(compatibleTypes.end()),!end=0}
  > always {!<=-1,!>=2}
  0 always 0
Line 499
  ( always {!<=-1,!>=2}
Line 501
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  != always {!<=-1,!>=2}
Line 502
  return always {!<=-1,!>=2}
  false always 0
Line 503
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 504
  return always {!<=-1,!>=2}
  false always 0
Line 505
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 506
  return always {!<=-1,!>=2}
  true always 1
Line 507
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 508
  return always {!<=-1,!>=2}
  false always 0
Line 509
  . possible symbolic=(value2.varId)
  == always {!<=-1,!>=2}
  0 always 0
  || always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  0 always 0
Line 510
  return always {!<=-1,!>=2}
  true always 1
Line 511
  . always !0
  == always {!<=-1,!>=2}
  . always !0
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 512
  return always {!<=-1,!>=2}
  true always 1
Line 513
  return always {!<=-1,!>=2}
  false always 0
Line 518
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 520
  ! always {!<=-1,!>=2}
Line 522
  ! always {!<=-1,!>=2}
  parent always !0
  ( always {!<=-1,!>=2}
Line 524
  ! always {!<=-1,!>=2}
  parent always !0
  ( always {!<=-1,!>=2}
Line 526
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  false always 0
Line 528
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  false always 0
Line 533
  == always {!<=-1,!>=2}
  vt2 always symbolic=(parent->astOperand2()->valueType())
Line 535
  n1 always !<=-1
  n1 always !<=-1
  = always !<=-1
  ( always !<=-1
Line 536
  n2 always !<=-1
  n2 always !<=-1
  = always !<=-1
  ( always !<=-1
  vt2 always symbolic=(parent->astOperand2()->valueType())
Line 537
  = always 2
  :: always 2
  UNSIGNED always 2
Line 538
  n1 {!<=-1,>=symbolic=(n2+1),<=symbolic=(n2)}
  < always {!<=-1,!>=2}
  n2 {!<=-1,<=symbolic=(n1-1),>=symbolic=(n1)}
Line 539
  = always !symbolic=(vt1->sign)
  vt2 always symbolic=(parent->astOperand2()->valueType())
  . always !symbolic=(vt1->sign)
Line 540
  n1 {!<=-1,!<=symbolic=(n2-1),>=symbolic=(n2)}
  > always {!<=-1,!>=2}
  n2 {!<=-1,!>=symbolic=(n1+1),<=symbolic=(n1)}
Line 541
  = always !symbolic=(vt2->sign)
  . always !symbolic=(vt2->sign)
Line 542
  sign possible {symbolic=(vt2->sign),symbolic=(vt1->sign)}
  n1 {!<=-1,<=symbolic=(n2-1),>=symbolic=(n2)}
  n2 {!<=-1,>=symbolic=(n1+1),<=symbolic=(n1)}
  8 always 8
Line 551
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  < always {!<=-1,!>=2}
  0 always 0
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 552
  ( always !<=-1
  >= always {!<=-1,!>=2}
  ( always 8
Line 555
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 556
  = inconclusive lifetime[Object]=(value)
  ( inconclusive lifetime[Object]=(value)
Line 558
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 561
  < always {!<=-1,!>=2}
  0 always 0
Line 565
  ! always {!<=-1,!>=2}
  parent always symbolic=(tok->astParent())
Line 568
  ( always {!<=-1,!>=2}
  parent always symbolic=(tok->astParent())
  "=" always "="
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 569
  parent always symbolic=(tok->astParent())
Line 573
  ( always {!<=-1,!>=2}
Line 575
  ( always {!<=-1,!>=2}
  "+|==|!=" always "+|==|!="
  && always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 577
  ( always {!<=-1,!>=2}
Line 580
  ( always {!<=-1,!>=2}
Line 582
  != always {!<=-1,!>=2}
Line 585
  ( always {!<=-1,!>=2}
  "%comp%" always "%comp%"
Line 586
  = always 0
  :: always 0
  INT always 0
Line 588
  = always 5
  :: always 5
  CONTAINER_SIZE always 5
Line 590
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 592
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 6
  eString always 6
Line 594
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 6
  eString always 6
Line 599
  & {lifetime[Address]=(result),!0}
Line 601
  ( always {!<=-1,!>=2}
  "==" always "=="
  && always {!<=-1,!>=2}
Line 603
  ( always {!<=-1,!>=2}
  "!=" always "!="
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
Line 611
  ( always {!<=-1,!>=2}
  ". %name% (" always ". %name% ("
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  2 always 2
  && always {!<=-1,!>=2}
Line 612
  && always {!<=-1,!>=2}
Line 614
  = possible 9
  ? possible 9
  1 always 1
  : always 9
  :: always 9
  NO_YIELD always 9
Line 615
  == always {!<=-1,!>=2}
  :: always 7
  SIZE always 7
Line 617
  = always 0
  :: always 0
  INT always 0
Line 619
  == always {!<=-1,!>=2}
  :: always 8
  EMPTY always 8
Line 621
  = always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
Line 622
  = always 0
  :: always 0
  INT always 0
Line 625
  ( always {!<=-1,!>=2}
  "%name% (" always "%name% ("
Line 627
  == always {!<=-1,!>=2}
  :: always 7
  SIZE always 7
Line 629
  = always 0
  :: always 0
  INT always 0
Line 631
  == always {!<=-1,!>=2}
  :: always 8
  EMPTY always 8
Line 633
  = always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
Line 634
  = always 0
  :: always 0
  INT always 0
Line 643
  ( always {!<=-1,!>=2}
Line 644
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 646
  == always {!<=-1,!>=2}
  :: always 3
  Iterator always 3
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 648
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "*" always "*"
  && always {!<=-1,!>=2}
Line 649
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 655
  ( always {!<=-1,!>=2}
Line 656
  ( always {!<=-1,!>=2}
  ". %var%" always ". %var%"
Line 658
  ( always {!<=-1,!>=2}
Line 663
  ! always {!<=-1,!>=2}
  value always symbolic=(pvalue)
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  ". %var%" always ". %var%"
Line 669
  ( always {!<=-1,!>=2}
  "&" always "&"
Line 672
  ( always {!<=-1,!>=2}
  ". %var%" always ". %var%"
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
Line 673
  == always {!<=-1,!>=2}
  "->" always "->"
  && always {!<=-1,!>=2}
  > always {!<=-1,!>=2}
  0 always 0
Line 676
  ( always {!<=-1,!>=2}
  ". %var%" always ". %var%"
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
Line 677
  == always {!<=-1,!>=2}
  "->" always "->"
  && always {!<=-1,!>=2}
  > always {!<=-1,!>=2}
  0 always 0
Line 680
  ( always {!<=-1,!>=2}
  "*" always "*"
  && always {!<=-1,!>=2}
  > always {!<=-1,!>=2}
  0 always 0
Line 689
  == always {!<=-1,!>=2}
  nullptr always 0
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 690
  :: always 0
  INT always 0
  :: always 10
  SYMBOLIC always 10
  && always {!<=-1,!>=2}
Line 691
  ( always {!<=-1,!>=2}
  "dynamic_cast" always "dynamic_cast"
Line 694
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  < always {!<=-1,!>=2}
  0 always 0
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 695
  == always {!<=-1,!>=2}
  :: always 1
  SIGNED always 1
  && always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 696
  ( always !<=-1
  >= always {!<=-1,!>=2}
  ( always !<=-1
Line 701
  == always {!<=-1,!>=2}
  ":" always ":"
Line 705
  == always {!<=-1,!>=2}
  "?" always "?"
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  ":" always ":"
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 707
  ( always {!<=-1,!>=2}
Line 709
  cond always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  != always {!<=-1,!>=2}
  0 always 0
Line 710
  cond always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
Line 713
  cond always {!<=-1,!>=2}
Line 714
  ! always {!<=-1,!>=2}
  op always symbolic=(cond?tok->astOperand1():tok->astOperand2())
Line 716
  op always symbolic=(cond?tok->astOperand1():tok->astOperand2())
Line 717
  ( possible lifetime[Iterator]=(op->values())
  ( {lifetime[Iterator]=(op->values()),start=0}
  ( {lifetime[Iterator]=(op->values()),end=0}
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(op->values()),end=0}
Line 720
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 723
  = always 0
  0 always 0
Line 724
  ret always {!<=-1,!>=2}
  ret always {!<=-1,!>=2}
  = always 0
  false always 0
Line 726
  [ possible {lifetime[Lambda]=(varId),lifetime[Lambda]=(value)}
Line 728
  > always {!<=-1,!>=2}
  0 always 0
  || always {!<=-1,!>=2}
  != always {!<=-1,!>=2}
  0 always 0
Line 729
  ret always {!<=-1,!>=2}
  = always 1
  true always 1
Line 731
  == always {!<=-1,!>=2}
  "(" always "("
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "%name%" always "%name%"
Line 732
  ret always {!<=-1,!>=2}
  = always 1
  true always 1
Line 733
  ret always {!<=-1,!>=2}
  ? possible {4,3}
  :: always 4
  done always 4
  : always 3
  :: always 3
  op1_and_op2 always 3
Line 735
  ret always {!<=-1,!>=2}
Line 739
  . always {!<=-1,!>=2}
  conditional always {!<=-1,!>=2}
  = always 1
  true always 1
Line 746
  == always {!<=-1,!>=2}
  "?" always "?"
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 747
  && always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 748
  == always {!<=-1,!>=2}
  0 always 0
Line 757
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 15
  eBitOp always 15
  || always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 14
  eLogicalOp always 14
  && always {!<=-1,!>=2}
Line 758
  && always {!<=-1,!>=2}
Line 761
  noninvertible always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 764
  noninvertible always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 768
  ( always {!<=-1,!>=2}
  "[&*]" always "[&*]"
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  true always 1
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 769
  == always {!<=-1,!>=2}
  0 always 0
Line 775
  ( always {!<=-1,!>=2}
  "&&" always "&&"
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  0 always 0
Line 781
  ( always {!<=-1,!>=2}
  "||" always "||"
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  != always {!<=-1,!>=2}
  0 always 0
Line 787
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 790
  != always {!<=-1,!>=2}
Line 792
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 794
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 796
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 798
  0 always 0
Line 799
  & {lifetime[Address]=(result),!0}
Line 800
  ( always {!<=-1,!>=2}
  false always 0
Line 801
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 803
  = always 2
  :: always 2
  FLOAT always 2
Line 805
  ( always {!<=-1,!>=2}
Line 806
  ( always {!<=-1,!>=2}
Line 808
  ( always {!<=-1,!>=2}
Line 810
  ( always {!<=-1,!>=2}
Line 811
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "&|^|%|<<|>>|==|!=|%or%" always "&|^|%|<<|>>|==|!=|%or%"
Line 813
  ( always {!<=-1,!>=2}
  "==|!=" always "==|!="
Line 814
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 815
  == always {!<=-1,!>=2}
  "==" always "=="
Line 816
  = always 0
  0 always 0
Line 817
  == always {!<=-1,!>=2}
  "!=" always "!="
Line 818
  = always 1
  1 always 1
Line 819
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 820
  error always {!<=-1,!>=2}
  error always {!<=-1,!>=2}
  = always 0
  false always 0
Line 821
  & {lifetime[Address]=(error),!0}
  error always {!<=-1,!>=2}
Line 822
  error always {!<=-1,!>=2}
Line 828
  ( always {!<=-1,!>=2}
  "%op%" always "%op%"
Line 829
  ( always {!<=-1,!>=2}
  "%comp%" always "%comp%"
Line 830
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 833
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 836
  error always {!<=-1,!>=2}
  error always {!<=-1,!>=2}
  = always 0
  false always 0
Line 837
  ( always {!<=-1,!>=2}
Line 838
  & {lifetime[Address]=(error),!0}
  error always {!<=-1,!>=2}
Line 840
  & {lifetime[Address]=(error),!0}
  error always {!<=-1,!>=2}
Line 842
  error always {!<=-1,!>=2}
Line 845
  ( always {!<=-1,!>=2}
  "-" always "-"
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 846
  != always {!<=-1,!>=2}
Line 855
  == always {!<=-1,!>=2}
  "!" always "!"
Line 857
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 859
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  != always {!<=-1,!>=2}
  0 always 0
Line 862
  = always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
Line 868
  == always {!<=-1,!>=2}
  "~" always "~"
Line 870
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 874
  = always 0
  0 always 0
Line 875
  && always {!<=-1,!>=2}
Line 876
  && always {!<=-1,!>=2}
Line 877
  == always {!<=-1,!>=2}
  :: always 2
  UNSIGNED always 2
  && always {!<=-1,!>=2}
Line 878
  == always {!<=-1,!>=2}
  0 always 0
Line 879
  == always {!<=-1,!>=2}
  :: always 12
  INT always 12
Line 881
  == always {!<=-1,!>=2}
  :: always 13
  LONG always 13
Line 884
  bits possible {symbolic=(settings->int_bit),symbolic=(settings->long_bit)}
  > always {!<=-1,!>=2}
  0 always 0
  && always {!<=-1,!>=2}
  < always {!<=-1,!>=2}
Line 885
  ( always 1
  1 always 1
  << always !<=-1
  - always !<=-1
  1 always 1
Line 891
  ( always {!<=-1,!>=2}
  "-" always "-"
Line 893
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 896
  ( always {!<=-1,!>=2}
Line 897
  == always {!<=-1,!>=2}
Line 909
  == always {!<=-1,!>=2}
  "++" always "++"
Line 911
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 914
  == always {!<=-1,!>=2}
Line 915
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 916
  1 always 1
Line 918
  1.0 always 1
Line 925
  == always {!<=-1,!>=2}
  "--" always "--"
Line 927
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 930
  == always {!<=-1,!>=2}
Line 931
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 932
  1 always 1
Line 934
  1.0 always 1
Line 941
  == always {!<=-1,!>=2}
  "[" always "["
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 943
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 946
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 948
  == always {!<=-1,!>=2}
  0 always 0
  || always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  0 always 0
  || always {!<=-1,!>=2}
Line 949
  == always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
Line 950
  0 always 0
Line 952
  ( always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 953
  != always {!<=-1,!>=2}
  0 always 0
Line 954
  == always {!<=-1,!>=2}
Line 955
  == always {!<=-1,!>=2}
Line 957
  == always {!<=-1,!>=2}
  :: always 6
  eString always 6
Line 960
  index always symbolic=(value2.intvalue)
  == always {!<=-1,!>=2}
  s always symbolic=(value1.tokvalue->strValue())
  ( always !<=-1
Line 961
  = always 0
  0 always 0
Line 963
  index always symbolic=(value2.intvalue)
  >= always {!<=-1,!>=2}
  0 always 0
  && always {!<=-1,!>=2}
  index always symbolic=(value2.intvalue)
  < always {!<=-1,!>=2}
  s always symbolic=(value1.tokvalue->strValue())
  ( always !<=-1
Line 964
  s always symbolic=(value1.tokvalue->strValue())
  index always symbolic=(value2.intvalue)
Line 967
  == always {!<=-1,!>=2}
  "{" always "{"
Line 970
  index possible symbolic=(value2.intvalue)
  > always {!<=-1,!>=2}
  0 always 0
  && always {!<=-1,!>=2}
  element possible symbolic=(value1.tokvalue->next())
  != always {!<=-1,!>=2}
  "}" always "}"
Line 971
  == always {!<=-1,!>=2}
  "," always ","
Line 973
  ( always {!<=-1,!>=2}
  "[{}()[]]" always "[{}()[]]"
Line 977
  ( always {!<=-1,!>=2}
  element possible symbolic=(value1.tokvalue->next())
  "%num% [,}]" always "%num% [,}]"
Line 987
  ( always {!<=-1,!>=2}
  ":: %name%" always ":: %name%"
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
Line 991
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "{" always "{"
  && always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 992
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "%name% (" always "%name% ("
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 995
  == always {!<=-1,!>=2}
  :: always 7
  SIZE always 7
Line 997
  = always 0
  :: always 0
  INT always 0
Line 998
  = always !<=-1
  ( always !<=-1
Line 1000
  == always {!<=-1,!>=2}
  :: always 8
  EMPTY always 8
Line 1002
  = always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 1003
  = always 0
  :: always 0
  INT always 0
Line 1012
  || always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 1014
  . possible {10,12,13,14}
  == {!<=-1,!>=2,0}
  :: always 9
  CHAR always 9
Line 1016
  . {12,13,14,!9}
  == {!<=-1,!>=2,0}
  :: always 10
  SHORT always 10
Line 1018
  . {13,14,!9,!10}
  == {!<=-1,!>=2,0}
  :: always 12
  INT always 12
Line 1020
  . {14,!9,!10,!12}
  == {!<=-1,!>=2,0}
  :: always 13
  LONG always 13
Line 1022
  . always {!9,!10,!12,!13}
  == always {!<=-1,!>=2}
  :: always 14
  LONGLONG always 14
Line 1024
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 1026
  floatValue always symbolic=(value)
  = always 2
  :: always 2
  FLOAT always 2
Line 1027
  ( always {!<=-1,!>=2}
Line 1030
  ( always {!<=-1,!>=2}
Line 1033
  charMin always symbolic=(settings->signedCharMin())
  <= always {!<=-1,!>=2}
  . possible {<=symbolic=(charMax),>=symbolic=(charMax+1)}
  && always {!<=-1,!>=2}
  . {>=symbolic=(charMin),!<=symbolic=(charMin-1)}
  <= always {!<=-1,!>=2}
  charMax always symbolic=(settings->signedCharMax())
Line 1042
  typeTok possible {symbolic=(tok2->enumerator()->scope->enumType)@178,symbolic=(tok2->type()->classScope->enumType)@189,symbolic=(var->typeEndToken())@229}
Line 1043
  > always {!<=-1,!>=2}
  0 always 0
Line 1045
  . possible {9,10,12,13,14,11}
  == {!<=-1,!>=2,0}
  :: always 8
  BOOL always 8
  || {!<=-1,!>=2,0}
  . {10,12,13,14,11,!8}
  == {!<=-1,!>=2,0}
  :: always 9
  CHAR always 9
Line 1046
  1 always 1
Line 1047
  . {12,13,14,11,!8,!9}
  == {!<=-1,!>=2,0}
  :: always 10
  SHORT always 10
Line 1049
  . {13,14,11,!8,!9,!10}
  == {!<=-1,!>=2,0}
  :: always 12
  INT always 12
Line 1051
  . {14,11,!10,!12}
  == {!<=-1,!>=2,0}
  :: always 13
  LONG always 13
Line 1053
  . {11,!12,!13}
  == {!<=-1,!>=2,0}
  :: always 14
  LONGLONG always 14
Line 1055
  . always {!13,!14}
  == always {!<=-1,!>=2}
  :: always 11
  WCHAR_T always 11
Line 1058
  0 always 0
Line 1061
  ( always !<=-1
Line 1064
  return always !<=-1
Line 1065
  . possible {10,11,12,13,14,16,17,18}
  == {!<=-1,!>=2,0}
  :: always 9
  CHAR always 9
Line 1066
  return always !<=-1
  1 always 1
Line 1067
  . {11,12,13,14,16,17,18,!9}
  == {!<=-1,!>=2,0}
  :: always 10
  SHORT always 10
Line 1068
  return always !<=-1
Line 1069
  . {12,13,14,16,17,18,!9,!10}
  == {!<=-1,!>=2,0}
  :: always 11
  WCHAR_T always 11
Line 1070
  return always !<=-1
Line 1071
  . {13,14,16,17,18,!10,!11}
  == {!<=-1,!>=2,0}
  :: always 12
  INT always 12
Line 1072
  return always !<=-1
Line 1073
  . {14,16,17,18,!11,!12}
  == {!<=-1,!>=2,0}
  :: always 13
  LONG always 13
Line 1074
  return always !<=-1
Line 1075
  . {16,17,18,!12,!13}
  == {!<=-1,!>=2,0}
  :: always 14
  LONGLONG always 14
Line 1076
  return always !<=-1
Line 1077
  . {17,18,!13,!14}
  == {!<=-1,!>=2,0}
  :: always 16
  FLOAT always 16
Line 1078
  return always !<=-1
Line 1079
  . {18,!14,!16}
  == {!<=-1,!>=2,0}
  :: always 17
  DOUBLE always 17
Line 1080
  return always !<=-1
Line 1081
  . always {!16,!17}
  == always {!<=-1,!>=2}
  :: always 18
  LONGDOUBLE always 18
Line 1082
  return always !<=-1
Line 1084
  return always !<=-1
  0 always 0
Line 1088
  , always {!<=-1,!>=2}
  cpp always {!<=-1,!>=2}
Line 1090
  ( {!<=-1,!>=2,0}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 7
  eChar always 7
Line 1093
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 1099
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 1101
  = always 2
  :: always 2
  FLOAT always 2
Line 1103
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 1106
  && always {!<=-1,!>=2}
  ( always !0
  . always {!<=-1,!>=2}
  value_known always {!<=-1,!>=2}
Line 1107
  ( always !0
Line 1108
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 1111
  ( possible size=7
  == {!<=-1,!>=2,0}
  "NULL" always "NULL"
  || always {!<=-1,!>=2}
  cpp always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  "nullptr" always "nullptr"
Line 1112
  0 always 0
Line 1113
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 1116
  ( always {!<=-1,!>=2}
  "sizeof (" always "sizeof ("
Line 1117
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always !0
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always !0
  && always {!<=-1,!>=2}
Line 1118
  ( always !0
  == always {!<=-1,!>=2}
  0 always 0
  && always {!<=-1,!>=2}
Line 1119
  ! always {!<=-1,!>=2}
  ( always !0
  ( always {!<=-1,!>=2}
Line 1120
  sz always !<=-1
  = always !<=-1
  ( always !<=-1
  ( always !0
  ( always !0
Line 1121
  sz always !<=-1
Line 1122
  sz always !<=0
Line 1125
  1 always 1
Line 1129
  2 always 2
Line 1131
  ( always {!<=-1,!>=2}
  "%name% ::|.|[" always "%name% ::|.|["
Line 1132
  == always {!<=-1,!>=2}
  "[" always "["
Line 1133
  1 always 1
Line 1135
  2 always 2
Line 1137
  ( always {!<=-1,!>=2}
  "sizeof ( *" always "sizeof ( *"
Line 1138
  2 always 2
Line 1139
  sz always !<=-1
  = {0,!<=-1}
  ? {0,!<=-1}
  ( always !<=-1
  vt always !0
  : always 0
  0 always 0
Line 1140
  sz {!<=-1,0}
  > {!<=-1,!>=2,0}
  0 always 0
Line 1141
  sz {>=1,!<=0}
Line 1142
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  != always {!<=-1,!>=2}
  :: always 0
  Unspecified always 0
Line 1146
  && always {!<=-1,!>=2}
  ( always !0
Line 1148
  ( always !0
  . always !0
Line 1149
  type always symbolic=(tok2->enumerator()->scope->enumType)
Line 1150
  type {symbolic=(tok2->enumerator()->scope->enumType),!0}
Line 1151
  == always {!<=-1,!>=2}
  0 always 0
Line 1152
  1 always 1
Line 1154
  size possible {symbolic=(settings->sizeof_int),0}
Line 1155
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  != always {!<=-1,!>=2}
  :: always 0
  Unspecified always 0
Line 1159
  ( possible 0
  && always {!<=-1,!>=2}
  ( always !0
  ( always {!<=-1,!>=2}
Line 1161
  ( always !0
Line 1162
  ( always !0
  . always !0
Line 1163
  type always symbolic=(tok2->type()->classScope->enumType)
Line 1164
  type {symbolic=(tok2->type()->classScope->enumType),!0}
Line 1167
  size possible symbolic=(settings->sizeof_int)
Line 1168
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  != always {!<=-1,!>=2}
  :: always 0
  Unspecified always 0
Line 1172
  ( always {!<=-1,!>=2}
  "sizeof ( %var% ) / sizeof (" always "sizeof ( %var% ) / sizeof ("
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  4 always 4
Line 1174
  2 always 2
Line 1175
  6 always 6
Line 1177
  varid1 always symbolic=(sz1->varId())
  && always {!<=-1,!>=2}
Line 1178
  && always {!<=-1,!>=2}
Line 1179
  ( always !0
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 1180
  ! always {!<=-1,!>=2}
  ( always !0
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 1181
  ( always {!<=-1,!>=2}
  0 always 0
  && always {!<=-1,!>=2}
Line 1182
  ( always {!<=-1,!>=2}
  "*|[" always "*|["
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "%varid%" always "%varid%"
  varid1 always symbolic=(sz1->varId())
Line 1183
  ( always !0
  0 always 0
Line 1184
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  != always {!<=-1,!>=2}
  :: always 0
  Unspecified always 0
Line 1186
  4 always 4
Line 1188
  ( always {!<=-1,!>=2}
  "%var% )" always "%var% )"
Line 1191
  var always symbolic=(tok2->variable())
  && always {!<=-1,!>=2}
  var {symbolic=(tok2->variable()),!0}
  == always {!<=-1,!>=2}
  var {symbolic=(tok2->variable()),!0}
Line 1193
  size always !<=-1
  size always !<=-1
  = always 0
  0 always 0
Line 1194
  var {symbolic=(tok2->variable()),!0}
  ( always {!<=-1,!>=2}
Line 1195
  size always !<=-1
  = always !<=-1
Line 1196
  var {symbolic=(tok2->variable()),!0}
  && always {!<=-1,!>=2}
  var {symbolic=(tok2->variable()),!0}
  . always !0
Line 1197
  size always !<=-1
  = always !<=-1
  var {symbolic=(tok2->variable()),!0}
  . always !0
  . always !0
Line 1198
  var {symbolic=(tok2->variable()),!0}
Line 1199
  size always !<=-1
  = always !<=-1
  ( always !<=-1
  var {symbolic=(tok2->variable()),!0}
  ( always !0
Line 1200
  ! always {!<=-1,!>=2}
  var {symbolic=(tok2->variable()),!0}
Line 1201
  size always !<=-1
  = always !<=-1
  var {symbolic=(tok2->variable()),!0}
  ( always symbolic=(var->typeEndToken())
Line 1204
  count always !<=-1
  count always !<=-1
  = always 1
  1 always 1
Line 1205
  i always !<=-1
  = always 0
  0 always 0
  i {!<=-1,0}
  < always {!<=-1,!>=2}
  var {symbolic=(tok2->variable()),!0}
  ( always !<=-1
  ++ always !<=0
  i always !<=-1
Line 1206
  var {symbolic=(tok2->variable()),!0}
  ( always {!<=-1,!>=2}
  i {!<=-1,<=symbolic=(var->dimensions().size()-1),!>=symbolic=(var->dimensions().size())}
Line 1207
  count always !<=-1
  *= always !<=-1
  var {symbolic=(tok2->variable()),!0}
  i always {!<=-1,!>=symbolic=(var->dimensions().size())}
Line 1209
  count always !<=-1
  = always 0
  0 always 0
Line 1211
  size always !<=-1
  && always {!<=-1,!>=2}
  count always !<=-1
  > always {!<=-1,!>=2}
  0 always 0
Line 1212
  count {>=1,!<=0}
  * always !<=-1
  size always !<=0
Line 1213
  != always {!<=-1,!>=2}
  :: always 0
  Unspecified always 0
Line 1219
  ( possible 7
  == {!<=-1,!>=2,0}
  :: always 6
  eString always 6
Line 1220
  sz always !<=-1
  sz always !<=-1
  = always !<=-1
Line 1221
  sz always !<=-1
  > always {!<=-1,!>=2}
  0 always 0
Line 1222
  sz {>=1,!<=0}
Line 1226
  ( always !6
  == always {!<=-1,!>=2}
  :: always 7
  eChar always 7
Line 1227
  = always 0
  0 always 0
Line 1228
  cpp {!<=-1,!>=2,0}
  && always {!<=-1,!>=2}
  >= always {!<=-1,!>=2}
  :: always 4
  CPP20 always 4
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 1229
  = always 1
  1 always 1
Line 1230
  ( always {!<=-1,!>=2}
Line 1231
  = always 2
  2 always 2
Line 1232
  ( always {!<=-1,!>=2}
Line 1233
  = always 4
  4 always 4
Line 1234
  ( always {!<=-1,!>=2}
Line 1236
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  cpp always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 1239
  = always 1
  1 always 1
Line 1241
  sz possible {symbolic=(settings->sizeof_wchar_t),symbolic=(settings->sizeof_int),1,2,4}
  > {!<=-1,!>=2,1}
  0 always 0
Line 1242
  sz {1,2,4,!<=0}
Line 1246
  ! always {!<=-1,!>=2}
Line 1248
  sz always !<=-1
  = always !<=-1
  ( always !<=-1
Line 1249
  sz always !<=-1
  > always {!<=-1,!>=2}
  0 always 0
Line 1250
  sz {>=1,!<=0}
Line 1251
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  != always {!<=-1,!>=2}
  :: always 0
  Unspecified always 0
Line 1257
  1 always 1
Line 1266
  ( always {!<=-1,!>=2}
Line 1269
  ( always {!<=-1,!>=2}
Line 1271
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "false|true" always "false|true"
Line 1272
  == always {!<=-1,!>=2}
  "true" always "true"
Line 1273
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 1276
  ( always {!<=-1,!>=2}
  "[(,] NULL [,)]" always "[(,] NULL [,)]"
Line 1279
  0 always 0
Line 1280
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 1291
  == always {!<=-1,!>=2}
  :: always 6
  eString always 6
Line 1293
  = always 1
  :: always 1
  TOK always 1
Line 1306
  tok possible symbolic=(tok->variable()->nameToken())
  > always {!<=-1,!>=2}
  0 always 0
Line 1308
  :: possible {symbolic=(constantArrays.end()),end=0}
  it possible {symbolic=(constantArrays.end()),end=0}
  = possible lifetime[Iterator]=(constantArrays)
  ( possible lifetime[Iterator]=(constantArrays)
  tok possible symbolic=(tok->variable()->nameToken())
  ( {>=1,!<=0}
Line 1309
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(constantArrays),end=0}
Line 1311
  = always 1
  :: always 1
  TOK always 1
Line 1312
  it always {!symbolic=(constantArrays.end()),!end=0}
Line 1318
  tok possible symbolic=(tok->variable()->nameToken())
  ( possible 0
  && always {!<=-1,!>=2}
  ( always !0
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always !0
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 1319
  == always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  tok always symbolic=(tok->variable()->nameToken())
  "%var% [ %num%| ] = {" always "%var% [ %num%| ] = {"
Line 1320
  tok always symbolic=(tok->variable()->nameToken())
  2 always 2
Line 1321
  tok always symbolic=(tok->variable()->nameToken())
Line 1322
  rhstok always symbolic=(constantArrays[tok->varId()])
Line 1326
  ( possible 0
  && always {!<=-1,!>=2}
  ( always !0
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "=" always "="
  && always {!<=-1,!>=2}
Line 1327
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 1328
  ( always !0
  && always {!<=-1,!>=2}
Line 1329
  ( always !0
  ( always {!<=-1,!>=2}
Line 1331
  = always 1
  :: always 1
  TOK always 1
Line 1339
  ( always {!<=-1,!>=2}
  "const %type% %var% [ %num%| ] = {" always "const %type% %var% [ %num%| ] = {"
Line 1340
  2 always 2
Line 1341
  2 always 2
Line 1343
  rhstok always symbolic=(constantArrays[vartok->varId()])
Line 1347
  ( always {!<=-1,!>=2}
  "const char %var% [ %num%| ] = %str% ;" always "const char %var% [ %num%| ] = %str% ;"
Line 1348
  2 always 2
Line 1349
  2 always 2
Line 1351
  strtok always symbolic=(constantArrays[vartok->varId()])
Line 1357
  ( always {!<=-1,!>=2}
Line 1359
  return always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  tok always !0
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  tok always !0
  != always {!<=-1,!>=2}
  0 always 0
Line 1364
  ! always {!<=-1,!>=2}
  tok possible symbolic=(tok->astParent()->astOperand1())
Line 1365
  nullptr always 0
Line 1366
  ! always {!<=-1,!>=2}
  tok {symbolic=(tok->astParent()->astOperand1()),!0}
Line 1367
  nullptr always 0
Line 1368
  tok always !0
  ( always !0
  != always {!<=-1,!>=2}
  tok always !0
Line 1369
  tok always {!symbolic=(tok->astParent()->astOperand1()),!0}
  ( always !0
  ( always !symbolic=(tok)
Line 1370
  tok always symbolic=(tok->astParent()->astOperand1())
  ( always !0
  != always {!<=-1,!>=2}
  tok always symbolic=(tok->astParent()->astOperand1())
Line 1371
  tok {!symbolic=(tok->astParent()->astOperand2()),symbolic=(tok->astParent()->astOperand1())}
  ( always !0
  ( always {!symbolic=(tok),!symbolic=(tok->astParent()->astOperand1())}
Line 1372
  nullptr always 0
Line 1378
  ( always {!<=-1,!>=2}
Line 1380
  = always 0
  nullptr always 0
Line 1381
  known always {!<=-1,!>=2}
  known always {!<=-1,!>=2}
  = always 0
  false always 0
Line 1382
  = possible lifetime[Iterator]=(tok->values())
Line 1383
  ( possible lifetime[Iterator]=(tok->values())
  ( {lifetime[Iterator]=(tok->values()),start=0}
  ( {lifetime[Iterator]=(tok->values()),end=0}
  & {lifetime[Address]=(isTokValue),!0}
Line 1384
  == always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(tok->values()),end=0}
Line 1386
  known always {!<=-1,!>=2}
  = always 1
  true always 1
Line 1388
  val always {!symbolic=(tok->values().end()),!end=0}
Line 1389
  known always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  val always {!symbolic=(tok->values().end()),!end=0}
Line 1391
  ! always {!<=-1,!>=2}
  var possible symbolic=(tok->variable())
Line 1393
  ! always {!<=-1,!>=2}
  var always !0
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  var always !0
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  var always !0
  ( always {!<=-1,!>=2}
Line 1395
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "%comp%" always "%comp%"
Line 1398
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "(|%name%" always "(|%name%"
  || always {!<=-1,!>=2}
Line 1399
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  ( always !0
  "if|while|for (" always "if|while|for ("
Line 1400
  1 always 1
Line 1401
  known always {!<=-1,!>=2}
Line 1412
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "&" always "&"
Line 1416
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "=" always "="
Line 1421
  vartok possible symbolic=(tok->astOperand1())
Line 1422
  vartok {symbolic=(tok->astOperand1()),!0}
  ( possible {size=1,size=2}
  == {!<=-1,!>=2,0}
  "[" always "["
Line 1423
  vartok always !0
Line 1424
  vartok always !0
  ( possible size=2
  == {!<=-1,!>=2,0}
  "." always "."
  || always {!<=-1,!>=2}
  vartok always !0
  == always {!<=-1,!>=2}
  "::" always "::"
Line 1425
  vartok always !0
Line 1429
  ! always {!<=-1,!>=2}
  vartok possible {symbolic=(tok->astOperand1()),0}
  && always {!<=-1,!>=2}
  vartok always !0
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  vartok always !0
  ( always !0
  ( always {!<=-1,!>=2}
Line 1433
  = always 1
  :: always 1
  TOK always 1
Line 1442
  != always {!<=-1,!>=2}
  "&" always "&"
Line 1445
  ( always {!<=-1,!>=2}
Line 1448
  ! always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
Line 1452
  ( always {!<=-1,!>=2}
Line 1454
  ( always {!<=-1,!>=2}
Line 1459
  = always 0
  0 always 0
Line 1460
  bit possible 0
  <= always {!<=-1,!>=2}
  2 always 2
  && always {!<=-1,!>=2}
  ( always 1
  1 always 1
  << possible 1
  bit {<=symbolic=(MathLib::bigint_bits-2),!>=symbolic=(MathLib::bigint_bits-2+1),0}
  < always {!<=-1,!>=2}
Line 1461
  ++ {<=symbolic=(MathLib::bigint_bits-2+1),!>=symbolic=(MathLib::bigint_bits-2+2)}
  bit {<=symbolic=(MathLib::bigint_bits-2),!>=symbolic=(MathLib::bigint_bits-2+1)}
Line 1463
  ( always 1
  1 always 1
  << possible >=symbolic=(number)
  bit possible >=symbolic=(MathLib::bigint_bits-2+1)
  == always {!<=-1,!>=2}
  number possible <=symbolic=(((long long)1)<<bit)
Line 1464
  0 always 0
Line 1465
  number always symbolic=(((long long)1)<<bit)
Line 1473
  ( always {!<=-1,!>=2}
Line 1476
  ! always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
Line 1479
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 1482
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  false always 0
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  false always 0
Line 1487
  ( always {!<=-1,!>=2}
  "==|>=|<=|/" always "==|>=|<=|/"
Line 1488
  1 always 1
Line 1492
  ( always {!<=-1,!>=2}
  "!=|>|<|%|-" always "!=|>|<|%|-"
Line 1493
  0 always 0
Line 1497
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 1500
  ( always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  false always 0
  true always 1
  true always 1
  & {lifetime[Address]=(errorPath),!0}
Line 1506
  ( always {!<=-1,!>=2}
Line 1508
  ( always {!<=-1,!>=2}
Line 1509
  minvalue possible {lifetime[Address]=(vals)@201,lifetime[Address]=(vals)@203,lifetime[Address]=(vals)@208,lifetime[Address]=(vals)@210}
Line 1510
  minvalue {!0,lifetime[Address]=(vals)@201,lifetime[Address]=(vals)@203,lifetime[Address]=(vals)@208,lifetime[Address]=(vals)@210}
Line 1511
  maxvalue possible {lifetime[Address]=(vals)@201,lifetime[Address]=(vals)@203,lifetime[Address]=(vals)@208,lifetime[Address]=(vals)@210}
Line 1512
  maxvalue {!0,lifetime[Address]=(vals)@201,lifetime[Address]=(vals)@203,lifetime[Address]=(vals)@208,lifetime[Address]=(vals)@210}
Line 1513
  return always {!<=-1,!>=2}
  true always 1
Line 1516
  ( possible size=1
  == always {!<=-1,!>=2}
  "&" always "&"
  && always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 1517
  4 always 4
Line 1518
  lhsHasKnownRange always {!<=-1,!>=2}
  lhsHasKnownRange always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  ( always !0
  & {lifetime[Address]=(vals),!0}
  vals always Uninit*
  0 always 0
  & {lifetime[Address]=(vals),!0}
  1 always 1
Line 1519
  rhsHasKnownRange always {!<=-1,!>=2}
  rhsHasKnownRange always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  ( always !0
  & {lifetime[Address]=(vals),!0}
  2 always 2
  & {lifetime[Address]=(vals),!0}
  3 always 3
Line 1520
  ! {!<=-1,!>=2,1}
  lhsHasKnownRange {!<=-1,!>=2,0}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  rhsHasKnownRange always {!<=-1,!>=2}
Line 1521
  return always {!<=-1,!>=2}
  false always 0
Line 1522
  ! always {!<=-1,!>=2}
  lhsHasKnownRange always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  rhsHasKnownRange always {!<=-1,!>=2}
Line 1524
  minvalue always !0
  lhsHasKnownRange always {!<=-1,!>=2}
  0 always 0
  2 always 2
Line 1526
  maxvalue always !0
  lhsHasKnownRange always {!<=-1,!>=2}
  1 always 1
  3 always 3
Line 1529
  minvalue always !0
  0 always 0
  2 always 2
Line 1531
  maxvalue always !0
  1 always 1
  3 always 3
Line 1533
  return always {!<=-1,!>=2}
  true always 1
Line 1536
  == always {!<=-1,!>=2}
  "%" always "%"
  && always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 1537
  4 always 4
Line 1538
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  ( always !0
  & {lifetime[Address]=(vals),!0}
  vals always Uninit*
  2 always 2
  & {lifetime[Address]=(vals),!0}
  3 always 3
Line 1539
  return always {!<=-1,!>=2}
  false always 0
Line 1540
  2 always 2
  <= always {!<=-1,!>=2}
  0 always 0
Line 1541
  return always {!<=-1,!>=2}
  false always 0
Line 1542
  lhsHasKnownRange always {!<=-1,!>=2}
  lhsHasKnownRange always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  & {lifetime[Address]=(vals),!0}
  0 always 0
  & {lifetime[Address]=(vals),!0}
  1 always 1
Line 1543
  lhsHasKnownRange {!<=-1,!>=2,0}
  && always {!<=-1,!>=2}
  0 always 0
  < always {!<=-1,!>=2}
  0 always 0
Line 1544
  return always {!<=-1,!>=2}
  false always 0
Line 1546
  ! {!<=-1,!>=2,1}
  lhsHasKnownRange {!<=-1,!>=2,0}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  ( always !0
  != always {!<=-1,!>=2}
  :: always 2
  UNSIGNED always 2
Line 1547
  return always {!<=-1,!>=2}
  false always 0
Line 1549
  minvalue always !0
  = always 0
  0 always 0
Line 1551
  maxvalue always !0
  3 always 3
  1 always 1
Line 1552
  return always {!<=-1,!>=2}
  true always 1
Line 1555
  return always {!<=-1,!>=2}
  false always 0
Line 1561
  != always {!<=-1,!>=2}
  ">>" always ">>"
Line 1564
  ( always {!<=-1,!>=2}
Line 1567
  ! always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
Line 1570
  ! always {!<=-1,!>=2}
  ( always !0
  ( always {!<=-1,!>=2}
Line 1574
  < always {!<=-1,!>=2}
  0 always 0
Line 1577
  ! always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always !0
  ( always {!<=-1,!>=2}
Line 1580
  ! always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always !0
  ( always {!<=-1,!>=2}
Line 1583
  = always 0
  0 always 0
Line 1584
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  nullptr always 0
  & {lifetime[Address]=(lhsmax),!0}
  lhsmax {0,>=symbolic=(1ULL<<rhsvalue),<=symbolic=(1ULL<<rhsvalue-1)}
Line 1586
  lhsmax possible {>=symbolic=(1ULL<<rhsvalue),<=symbolic=(1ULL<<rhsvalue-1)}
  < always {!<=-1,!>=2}
  0 always 0
Line 1589
  == always {!<=-1,!>=2}
  :: always 9
  CHAR always 9
  || always {!<=-1,!>=2}
Line 1590
  == always {!<=-1,!>=2}
  :: always 10
  SHORT always 10
  || always {!<=-1,!>=2}
Line 1591
  == always {!<=-1,!>=2}
  :: always 11
  WCHAR_T always 11
  || always {!<=-1,!>=2}
Line 1592
  == always {!<=-1,!>=2}
  :: always 8
  BOOL always 8
  || always {!<=-1,!>=2}
Line 1593
  == always {!<=-1,!>=2}
  :: always 12
  INT always 12
Line 1595
  == always {!<=-1,!>=2}
  :: always 13
  LONG always 13
Line 1597
  == always {!<=-1,!>=2}
  :: always 14
  LONGLONG always 14
Line 1601
  rhsvalue possible {>=symbolic=(MathLib::bigint_bits),<=symbolic=(MathLib::bigint_bits-1)}
  >= always {!<=-1,!>=2}
  lhsbits possible {symbolic=(settings->int_bit),symbolic=(settings->long_bit),symbolic=(settings->long_long_bit)}
  || always {!<=-1,!>=2}
  rhsvalue {!>=symbolic=(lhsbits),<=symbolic=(lhsbits-1)}
  >= always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  1ULL always 1
  << always !<=-1
  rhsvalue {!>=symbolic=(lhsbits),<=symbolic=(lhsbits-1),!>=symbolic=(MathLib::bigint_bits),<=symbolic=(MathLib::bigint_bits-1)}
  <= always {!<=-1,!>=2}
  lhsmax always !<=-1
Line 1604
  0 always 0
Line 1610
  = always 8
  8 always 8
Line 1613
  ! always {!<=-1,!>=2}
Line 1615
  < always {!<=-1,!>=2}
  0 always 0
Line 1617
  tok always !0
  ( always {!<=-1,!>=2}
Line 1618
  tok always !0
Line 1619
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  tok always !0
  "-|%|&|^" always "-|%|&|^"
  && always {!<=-1,!>=2}
  tok always !0
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  tok always !0
  && always {!<=-1,!>=2}
  tok always !0
Line 1620
  tok always !0
  ( always !0
  depth always !<=-1
  - always !<=-2
  1 always 1
Line 1621
  tok always !0
  ( always !0
  depth always !<=-1
  - always !<=-2
  1 always 1
Line 1622
  ! {!<=-1,!>=2,0}
  op1 possible size=0
  ( {!<=-1,!>=2,1}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 1623
  tok always !0
  op1 always !size=0
  op2 always !size=0
Line 1626
  result possible {{,size=1}
  ( {!<=-1,!>=2,0}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  tok always !0
Line 1627
  0 always 0
Line 1628
  result possible {size=1,{}
Line 1631
  ( always {!<=-1,!>=2}
Line 1633
  ! always {!<=-1,!>=2}
Line 1634
  return always {!<=-1,!>=2}
  false always 0
Line 1635
  tok always !0
Line 1636
  ( always {!<=-1,!>=2}
Line 1637
  return always {!<=-1,!>=2}
  false always 0
Line 1638
  parentTypes always !size=0
Line 1639
  return always {!<=-1,!>=2}
  vt always symbolic=(parentTypes.front())
  != always {!<=-1,!>=2}
  :: always 15
  UNKNOWN_INT always 15
  && always {!<=-1,!>=2}
  vt always symbolic=(parentTypes.front())
  ( always {!<=-1,!>=2}
Line 1645
  ( always {!<=-1,!>=2}
Line 1647
  ( always {!<=-1,!>=2}
  "true|false" always "true|false"
Line 1649
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "%comp%" always "%comp%"
Line 1650
  -1 always -1
Line 1651
  = always 0
  :: always 0
  Upper always 0
Line 1655
  2 always 2
Line 1656
  = always 1
  :: always 1
  Lower always 1
Line 1659
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 1661
  ( always {!<=-1,!>=2}
Line 1663
  0 always 0
  minvalue always !size=0
  1 always 1
Line 1664
  = always 0
  :: always 0
  Upper always 0
Line 1668
  ( always {!<=-1,!>=2}
  "%" always "%"
  && always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always !0
  ( always {!<=-1,!>=2}
Line 1670
  = always 1
  :: always 1
  Lower always 1
Line 1673
  ( always {!<=-1,!>=2}
  "abs|labs|llabs|fabs|fabsf|fabsl (" always "abs|labs|llabs|fabs|fabsf|fabsl ("
Line 1674
  -1 always -1
Line 1675
  = always 0
  :: always 0
  Upper always 0
Line 1678
  ( always {!<=-1,!>=2}
  ". data|c_str (" always ". data|c_str ("
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 1680
  ! always {!<=-1,!>=2}
Line 1682
  ! always {!<=-1,!>=2}
  container always !0
  . always {!<=-1,!>=2}
  stdStringLike always {!<=-1,!>=2}
Line 1684
  container always !0
  . always {!<=-1,!>=2}
  view always {!<=-1,!>=2}
Line 1686
  0 always 0
Line 1688
  2 always 2
Line 1689
  ( always {!<=-1,!>=2}
  "make_shared|make_unique <" always "make_shared|make_unique <"
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  1 always 1
  "> (" always "> ("
Line 1690
  0 always 0
Line 1692
  1 always 1
Line 1693
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "this" always "this"
Line 1694
  0 always 0
Line 1697
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always !0
  ( always {!<=-1,!>=2}
  "-" always "-"
  && always {!<=-1,!>=2}
Line 1698
  ( always {!<=-1,!>=2}
Line 1699
  0 always 0
Line 1710
  != always {!<=-1,!>=2}
  :: always 16
  eEnum always 16
Line 1712
  = always 0
  0 always 0
Line 1713
  prev_enum_is_known always {!<=-1,!>=2}
  prev_enum_is_known always {!<=-1,!>=2}
  = always 1
  true always 1
Line 1718
  rhs possible 0
Line 1719
  && always {!<=-1,!>=2}
  rhs always !0
  ( always {!<=-1,!>=2}
Line 1720
  rhs always !0
Line 1721
  . always {!<=-1,!>=2}
  value_known always {!<=-1,!>=2}
  = always 1
  true always 1
Line 1722
  1 always 1
Line 1723
  prev_enum_is_known always {!<=-1,!>=2}
  = always 1
  true always 1
Line 1725
  prev_enum_is_known always {!<=-1,!>=2}
  = always 0
  false always 0
Line 1726
  prev_enum_is_known {!<=-1,!>=2,1,0}
Line 1728
  . always {!<=-1,!>=2}
  value_known always {!<=-1,!>=2}
  = always 1
  true always 1
Line 1738
  tok possible symbolic=(tok->variable()->nameToken())
  tok possible symbolic=(tok->variable()->nameToken())
Line 1739
  ! always {!<=-1,!>=2}
  tok possible symbolic=(tok->variable()->nameToken())
Line 1742
  == always {!<=-1,!>=2}
  ( always !0
  && always {!<=-1,!>=2}
Line 1743
  ! always {!<=-1,!>=2}
  tok always symbolic=(tok->variable()->nameToken())
  ( always !0
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 1744
  ! always {!<=-1,!>=2}
  tok always symbolic=(tok->variable()->nameToken())
  ( always !0
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 1745
  ( always !0
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 1746
  && always {!<=-1,!>=2}
Line 1747
  ( always !0
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 1748
  ( always !0
  == always {!<=-1,!>=2}
  0 always 0
  && always {!<=-1,!>=2}
Line 1749
  == always {!<=-1,!>=2}
  1 always 1
  && always {!<=-1,!>=2}
Line 1750
  ( always {!<=-1,!>=2}
  "%name% =" always "%name% ="
  && always {!<=-1,!>=2}
Line 1751
  && always {!<=-1,!>=2}
Line 1752
  ( always !0
  ( always {!<=-1,!>=2}
Line 1753
  tok always symbolic=(tok->variable()->nameToken())
  ( always !0
  tok always symbolic=(tok->variable()->nameToken())
  ( always !0
Line 1759
  ! always {!<=-1,!>=2}
Line 1761
  = possible lifetime[Iterator]=(vars)
  ( possible lifetime[Iterator]=(vars)
  ( always !0
Line 1762
  var {lifetime[Iterator]=(vars),symbolic=(vars.find(tok->variable()))}
  == always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(vars),end=0}
Line 1764
  var {lifetime[Iterator]=(vars),!symbolic=(vars.end()),!end=0}
Line 1772
  tok possible {symbolic=(tok->variable()->nameToken()),symbolic=(tok->astParent()->astOperand1())}
  tok possible {symbolic=(tok->variable()->nameToken()),symbolic=(tok->astParent()->astOperand1())}
Line 1773
  ! always {!<=-1,!>=2}
  tok possible {symbolic=(tok->variable()->nameToken()),symbolic=(tok->astParent()->astOperand1())}
Line 1776
  tok possible symbolic=(tok->astParent()->astOperand1())
  == always {!<=-1,!>=2}
  tok possible symbolic=(tok->astParent()->astOperand1())
  ( always !0
  && always {!<=-1,!>=2}
Line 1777
  tok always symbolic=(tok->variable()->nameToken())
  ( always !0
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 1778
  ! always {!<=-1,!>=2}
  tok always symbolic=(tok->variable()->nameToken())
  ( always !0
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 1779
  && always {!<=-1,!>=2}
Line 1780
  ( always !0
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 1781
  ( always !0
  == always {!<=-1,!>=2}
  0 always 0
  && always {!<=-1,!>=2}
Line 1782
  == always {!<=-1,!>=2}
  0 always 0
  && always {!<=-1,!>=2}
Line 1783
  ( always {!<=-1,!>=2}
  "%name% =" always "%name% ="
  && always {!<=-1,!>=2}
Line 1784
  && always {!<=-1,!>=2}
Line 1785
  ( always !0
  ( always {!<=-1,!>=2}
Line 1786
  tok always symbolic=(tok->variable()->nameToken())
  ( always !0
  tok always symbolic=(tok->variable()->nameToken())
  ( always !0
Line 1789
  ! always {!<=-1,!>=2}
  tok possible symbolic=(tok->astParent()->astOperand1())
Line 1791
  ( always {!<=-1,!>=2}
  tok possible symbolic=(tok->astParent()->astOperand1())
  ( always !0
  "++|--|&" always "++|--|&"
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always !0
Line 1792
  ( always !0
Line 1793
  tok possible symbolic=(tok->astParent()->astOperand1())
  ( always !0
  ( always {!<=-1,!>=2}
Line 1794
  == always {!<=-1,!>=2}
  ( always !0
Line 1795
  tok always symbolic=(tok->astParent()->astOperand1())
  ( always !0
Line 1796
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  tok always !symbolic=(tok->astParent()->astOperand1())
  ( always !0
  -2 always -2
  "& %name% =" always "& %name% ="
Line 1797
  tok always !symbolic=(tok->astParent()->astOperand1())
  ( always !0
Line 1798
  ( always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  ( always !0
Line 1799
  ( always !0
Line 1800
  ( always {!<=-1,!>=2}
  ( always !0
  "[(,]" always "[(,]"
Line 1801
  ( always !0
Line 1807
  ! always {!<=-1,!>=2}
Line 1809
  = possible lifetime[Iterator]=(vars)
  ( possible lifetime[Iterator]=(vars)
  ( always !0
Line 1810
  var {lifetime[Iterator]=(vars),symbolic=(vars.find(tok->variable()))}
  == always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(vars),end=0}
Line 1812
  var {lifetime[Iterator]=(vars),!symbolic=(vars.end()),!end=0}
Line 1831
  ( always {!<=-1,!>=2}
  , always {!<=-1,!>=2}
  then always {!<=-1,!>=2}
Line 1833
  = always "||"
  "||" always "||"
Line 1834
  then {!<=-1,!>=2,0@147,1@149}
Line 1835
  = always "&&"
  "&&" always "&&"
Line 1837
  parent possible symbolic=(tok->astParent())
  && always {!<=-1,!>=2}
  parent {symbolic=(tok->astParent()),!0}
  == always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  parent {symbolic=(tok->astParent()),!0}
  ( always !symbolic=(op)
  == always {!<=-1,!>=2}
  "!" always "!"
Line 1838
  parent always !0
Line 1839
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  parent possible {symbolic=(tok->astParent()),0}
  "(|;" always "(|;"
Line 1844
  "=" always "="
  "=" always "="
Line 1845
  "+=" always "+="
  "-=" always "-="
Line 1846
  "-=" always "-="
  "+=" always "+="
Line 1847
  "*=" always "*="
  "/=" always "/="
Line 1848
  "/=" always "/="
  "*=" always "*="
Line 1849
  "<<=" always "<<="
  ">>=" always ">>="
Line 1850
  ">>=" always ">>="
  "<<=" always "<<="
Line 1851
  "^=" always "^="
  "^=" always "^="
Line 1852
  = {lifetime[Iterator]=(lookup),size=8}
  lookup always {{,size=8}
  ( {lifetime[Iterator]=(lookup),size=8}
Line 1853
  it {lifetime[Iterator]=(lookup),symbolic=(lookup.find(assign)),size=8}
  == always {!<=-1,!>=2}
  lookup always {{,size=8}
  ( {lifetime[Iterator]=(lookup),end=0,size=8}
Line 1858
  it {lifetime[Iterator]=(lookup),symbolic=(lookup.find(assign)),!symbolic=(lookup.end()),!end=0,size=8}
Line 1862
  ( {lifetime[Iterator]=(assign),start=0}
  ( {lifetime[Iterator]=(assign),end=0}
  - {lifetime[Iterator]=(assign),end=-1}
  1 always 1
Line 1866
  , always 0
  = always 0
  nullptr always 0
Line 1868
  assign possible size=1
  ( {!<=-1,!>=2,0}
  || always {!<=-1,!>=2}
  assign {size=1,!size=0}
  != always {!<=-1,!>=2}
  '=' always 61
Line 1869
  error possible {lifetime[Address]=(error)@17,lifetime[Address]=(error)@19,lifetime[Address]=(error)@21}
Line 1870
  * always {!<=-1,!>=2}
  error {!0,lifetime[Address]=(error)@17,lifetime[Address]=(error)@19,lifetime[Address]=(error)@21}
  = always 1
  true always 1
Line 1873
  assign always !size=0
  == always {!<=-1,!>=2}
  "=" always "="
Line 1875
  assign always !size=0
Line 1889
  ( always {!<=-1,!>=2}
Line 1891
  error always {!<=-1,!>=2}
  error always {!<=-1,!>=2}
  = always 0
  false always 0
Line 1892
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 1893
  assign possible size=2
  != always {!<=-1,!>=2}
  "+=" always "+="
  && always {!<=-1,!>=2}
  != always {!<=-1,!>=2}
  "-=" always "-="
Line 1894
  return always {!<=-1,!>=2}
  false always 0
Line 1895
  & {lifetime[Address]=(error),!0}
  error always 0
Line 1896
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 1897
  & {lifetime[Address]=(error),!0}
  error always 0
Line 1898
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 1900
  & {lifetime[Address]=(error),!0}
  error always 0
Line 1902
  return always {!<=-1,!>=2}
  false always 0
Line 1904
  return always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  error always {!<=-1,!>=2}
Line 1914
  1 always 1
Line 1921
  { possible lifetime[SubObject]=(x)
  & {lifetime[Address]=(x),!0}
Line 1940
  ( always !0
Line 1941
  & {lifetime[Address]=(mIt->second),!0}
Line 1947
  this always !0
Line 1950
  ( always {!<=-1,!>=2}
Line 1951
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
Line 1954
  ( always {!<=-1,!>=2}
Line 1955
  return always {!<=-1,!>=2}
  != always {!<=-1,!>=2}
Line 1967
  ( always start=0
Line 1970
  ( always end=0
Line 1979
  ( always {!<=-1,!>=2}
  , always 0
  = always 0
  nullptr always 0
Line 1981
  ( possible 0
  == always {!<=-1,!>=2}
  varid possible {symbolic=(p.first)@208,symbolic=(p.first)@55}
Line 1982
  return always {!<=-1,!>=2}
  false always 0
Line 1983
  ( always !symbolic=(varid)
  == always {!<=-1,!>=2}
  0 always 0
Line 1984
  return always {!<=-1,!>=2}
  false always 0
Line 1985
  ( always {!<=-1,!>=2}
  varid always !symbolic=(tok->varId())
Line 1986
  return always {!<=-1,!>=2}
  true always 1
Line 1987
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  var always !0
  ( always {!<=-1,!>=2}
Line 1988
  return always {!<=-1,!>=2}
  false always 0
Line 1991
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 1993
  ( always {!<=-1,!>=2}
Line 1995
  ( {!<=-1,!>=2,0}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 1997
  ( {!<=-1,!>=2,0}
  && always {!<=-1,!>=2}
  != always {!<=-1,!>=2}
  :: always 4
  Address always 4
Line 1999
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  ".|&|*|%var%" always ".|&|*|%var%"
Line 2001
  ( always {!<=-1,!>=2}
Line 2002
  return always {!<=-1,!>=2}
  true always 1
Line 2004
  return always {!<=-1,!>=2}
  false always 0
Line 2007
  ( always {!<=-1,!>=2}
  , always 20
  = always 20
  20 always 20
Line 2009
  ( always {!<=-1,!>=2}
Line 2013
  , always 20
Line 2014
  = always 20
  20 always 20
Line 2016
  result always {!<=-1,!>=2}
  result always {!<=-1,!>=2}
  = always 0
  false always 0
Line 2019
  tok possible symbolic=(start)
  ( always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  true always 1
Line 2020
  ( always {!<=-1,!>=2}
  tok always !0
  "%assign%" always "%assign%"
Line 2021
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  tok always !0
  1 always 1
Line 2022
  return always {!<=-1,!>=2}
  true always 1
Line 2024
  result always {!<=-1,!>=2}
  = always 1
  true always 1
Line 2027
  return always {!<=-1,!>=2}
  result {!<=-1,!>=2,0}
Line 2030
  ( always {!<=-1,!>=2}
Line 2032
  < always {!<=-1,!>=2}
  0 always 0
Line 2033
  return always {!<=-1,!>=2}
  false always 0
Line 2034
  ! always {!<=-1,!>=2}
Line 2035
  return always {!<=-1,!>=2}
  true always 1
Line 2036
  tok always !0
  ( always {!<=-1,!>=2}
Line 2037
  return always {!<=-1,!>=2}
  true always 1
Line 2038
  ( always {!<=-1,!>=2}
  tok always !0
  "%cop%" always "%cop%"
Line 2039
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  tok always !0
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  tok always !0
Line 2040
  ( always {!<=-1,!>=2}
  "%var%" always "%var%"
Line 2041
  ( always !<=-1
  > always {!<=-1,!>=2}
  0 always 0
Line 2042
  return always {!<=-1,!>=2}
  true always 1
Line 2044
  ! always {!<=-1,!>=2}
  var always symbolic=(tok->variable())
Line 2045
  return always {!<=-1,!>=2}
  false always 0
Line 2046
  var {symbolic=(tok->variable()),!0}
Line 2047
  ! always {!<=-1,!>=2}
  start always symbolic=(var->declEndToken())
Line 2048
  return always {!<=-1,!>=2}
  false always 0
Line 2049
  start {symbolic=(var->declEndToken()),!0}
  -1 always -1
  == always {!<=-1,!>=2}
  ")" always ")"
  || always {!<=-1,!>=2}
  start {symbolic=(var->declEndToken()),!0}
  -1 always -1
  == always {!<=-1,!>=2}
  "}" always "}"
Line 2050
  return always {!<=-1,!>=2}
  false always 0
Line 2051
  ( always {!<=-1,!>=2}
  start always !0
  "; %varid% =" always "; %varid% ="
Line 2052
  start always !0
  2 always 2
Line 2053
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 2054
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  1 always 1
Line 2055
  return always {!<=-1,!>=2}
  false always 0
Line 2057
  return always {!<=-1,!>=2}
  false always 0
Line 2064
  nullptr always 0
  nullptr always 0
Line 2068
  = always 0
  0 always 0
Line 2069
  = always 0
  0 always 0
Line 2071
  = always 0
  0 always 0
Line 2073
  = always 0
  0 always 0
Line 2075
  ( always {!<=-1,!>=2}
  = always 0
  0 always 0
Line 2077
  ( always {!<=-1,!>=2}
Line 2078
  return always {!<=-1,!>=2}
  false always 0
Line 2081
  ( always {!<=-1,!>=2}
  inconclusive always {!<=-1,!>=2}
  = always 0
  0 always 0
Line 2085
  = always 0
  0 always 0
Line 2090
  value always !0
Line 2091
  0 always 0
Line 2094
  ( always {!<=-1,!>=2}
Line 2095
  return always {!<=-1,!>=2}
  false always 0
Line 2097
  ( always {!<=-1,!>=2}
Line 2098
  return always {!<=-1,!>=2}
  false always 0
Line 2100
  ( always {!<=-1,!>=2}
Line 2101
  return always {!<=-1,!>=2}
  false always 0
Line 2104
  ( always {!<=-1,!>=2}
Line 2105
  return always {!<=-1,!>=2}
  false always 0
Line 2108
  ( always {!<=-1,!>=2}
Line 2109
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 2117
  dependent always {!<=-1,!>=2}
  dependent always {!<=-1,!>=2}
  = always 1
  true always 1
Line 2118
  unknown always {!<=-1,!>=2}
  unknown always {!<=-1,!>=2}
  = always 1
  true always 1
Line 2120
  ( always {!<=-1,!>=2}
Line 2121
  return always {!<=-1,!>=2}
  unknown always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  dependent always {!<=-1,!>=2}
Line 2128
  ! always {!<=-1,!>=2}
Line 2130
  tok always !0
Line 2131
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 2133
  ( always {!<=-1,!>=2}
Line 2135
  ! always {!<=-1,!>=2}
Line 2137
  . always !0
  == always {!<=-1,!>=2}
  0 always 0
Line 2139
  ( always {!<=-1,!>=2}
  . always !0
Line 2146
  , always 20
  = always 20
  20 always 20
Line 2149
  ! always {!<=-1,!>=2}
  tok possible symbolic=(p.second)@233
Line 2151
  < always {!<=-1,!>=2}
  0 always 0
Line 2153
  depth {!<=-1,>=0}
  -- {!<=-1,>=0}
Line 2154
  tok always !0
  ( always {!<=-1,!>=2}
Line 2155
  . always {!<=-1,!>=2}
  dependent always {!<=-1,!>=2}
  = always 1
  true always 1
Line 2156
  . always {!<=-1,!>=2}
  unknown always {!<=-1,!>=2}
  = always 0
  false always 0
Line 2158
  tok always !0
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  tok always !0
  ( always {!<=-1,!>=2}
Line 2159
  . always {!<=-1,!>=2}
  dependent always {!<=-1,!>=2}
  = always 0
  false always 0
Line 2160
  . always {!<=-1,!>=2}
  unknown always {!<=-1,!>=2}
  = always 0
  false always 0
Line 2162
  ( always {!<=-1,!>=2}
  tok always !0
  "%cop%" always "%cop%"
Line 2163
  ( always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  tok always !0
Line 2164
  . always {!<=-1,!>=2}
  dependent always {!<=-1,!>=2}
  = always 0
  false always 0
Line 2167
  depth always !<=-2
  - always !<=-3
  1 always 1
Line 2168
  ( always {!<=-1,!>=2}
Line 2170
  1 always 1
Line 2171
  ( always {!<=-1,!>=2}
Line 2173
  ( always {!<=-1,!>=2}
  "%comp%" always "%comp%"
Line 2174
  . always {!<=-1,!>=2}
  dependent always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  . always {!<=-1,!>=2}
  dependent always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  . always {!<=-1,!>=2}
  dependent always {!<=-1,!>=2}
Line 2176
  . always {!<=-1,!>=2}
  dependent always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  . always {!<=-1,!>=2}
  dependent always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  . always {!<=-1,!>=2}
  dependent always {!<=-1,!>=2}
Line 2177
  . always {!<=-1,!>=2}
  unknown always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  . always {!<=-1,!>=2}
  unknown always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  . always {!<=-1,!>=2}
  unknown always {!<=-1,!>=2}
Line 2179
  ( always {!<=-1,!>=2}
  tok always !0
  "%name% (" always "%name% ("
Line 2180
  tok always !0
Line 2181
  ( always {!<=-1,!>=2}
  tok always !0
  -2 always -2
  ". %name% (" always ". %name% ("
Line 2182
  tok always !0
  -2 always -2
Line 2184
  . always {!<=-1,!>=2}
  dependent always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(args),start=0}
  ( {lifetime[Iterator]=(args),end=0}
  [ possible {lifetime[Lambda]=(analyzeCondition(arg,depth-1)),lifetime[Lambda]=(depth)}
Line 2185
  1 always 1
Line 2186
  . always {!<=-1,!>=2}
  dependent always {!<=-1,!>=2}
Line 2188
  . always {!<=-1,!>=2}
  dependent always {!<=-1,!>=2}
Line 2190
  ! always {!<=-1,!>=2}
  tok always !0
Line 2191
  . always {!<=-1,!>=2}
  unknown always {!<=-1,!>=2}
  = always 0
  false always 0
Line 2195
  tok always !0
Line 2196
  . always {!<=-1,!>=2}
  dependent always {!<=-1,!>=2}
  = always 0
  false always 0
Line 2197
  && always {!<=-1,!>=2}
  : always {!<=-1,!>=2}
Line 2199
  arg always symbolic=(p.second)
  depth always !<=-2
  - always !<=-3
  1 always 1
Line 2200
  . always {!<=-1,!>=2}
  dependent always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  . always {!<=-1,!>=2}
  dependent always {!<=-1,!>=2}
Line 2201
  . always {!<=-1,!>=2}
  dependent always {!<=-1,!>=2}
Line 2204
  . always {!<=-1,!>=2}
  dependent always {!<=-1,!>=2}
Line 2206
  ! always {!<=-1,!>=2}
Line 2207
  . always {!<=-1,!>=2}
  unknown always {!<=-1,!>=2}
  = always 0
  false always 0
Line 2215
  inconclusive always {!<=-1,!>=2}
  inconclusive always {!<=-1,!>=2}
  = always 0
  false always 0
Line 2216
  ( always {!<=-1,!>=2}
  & {lifetime[Address]=(inconclusive),!0}
  inconclusive always 0
Line 2218
  inconclusive always {!<=-1,!>=2}
Line 2220
  ( always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 2221
  ( always {!<=-1,!>=2}
  "*|[|.|++|--" always "*|[|.|++|--"
Line 2225
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  value always !0
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "=" always "="
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 2226
  ( always {!<=-1,!>=2}
  false always 0
Line 2228
  [ possible lifetime[Lambda]=(getProgramState())
Line 2231
  ! {!<=-1,!>=2,0}
  result possible size=0
  ( {!<=-1,!>=2,1}
  && always {!<=-1,!>=2}
  value always !0
  ( always {!<=-1,!>=2}
  result always !size=0
Line 2241
  ( always {!<=-1,!>=2}
  "%var% (" always "%var% ("
Line 2244
  = always 0
  0 always 0
Line 2246
  ( always !0
Line 2247
  ( always {!<=-1,!>=2}
  indirect possible {symbolic=(tok->valueType()->pointer),0}
  ( always {!<=-1,!>=2}
Line 2253
  ( always {!<=-1,!>=2}
  0 always 0
  ( always {!<=-1,!>=2}
Line 2261
  ! always {!<=-1,!>=2}
  ( always !0
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 2266
  ( always {!<=-1,!>=2}
  "." always "."
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 2269
  == always {!<=-1,!>=2}
  :: always 1
  eType always 1
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 2272
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "%name% (" always "%name% ("
Line 2280
  == always {!<=-1,!>=2}
Line 2288
  ! always {!<=-1,!>=2}
Line 2290
  ! always {!<=-1,!>=2}
  value always !0
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  value always !0
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  value always !0
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  value always !0
  ( always {!<=-1,!>=2}
Line 2294
  value always !0
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  parent always symbolic=(tok->astParent())
  "+=|-=|*=|++|--" always "+=|-=|*=|++|--"
Line 2296
  ( always {!<=-1,!>=2}
Line 2297
  != always {!<=-1,!>=2}
  :: always 3
  Iterator always 3
Line 2299
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "++|--|+=" always "++|--|+="
Line 2303
  && always {!<=-1,!>=2}
  parent always !0
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 2304
  ( always {!<=-1,!>=2}
Line 2305
  parent always !0
Line 2306
  rhs always symbolic=(parent->astOperand2())
  :: always 0
  INT always 0
Line 2308
  ! {!<=-1,!>=2,1}
  rhsValue possible 0
  || always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  parent always !0
  rhsValue always !0
Line 2312
  parent always !0
  != always {!<=-1,!>=2}
  "=" always "="
Line 2315
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  rhsValue always !0
Line 2323
  ( always {!<=-1,!>=2}
  "++|--" always "++|--"
Line 2330
  ! always {!<=-1,!>=2}
  value possible lifetime[Address]=(localValue)@69
Line 2332
  ! always {!<=-1,!>=2}
Line 2335
  value always !0
  ( always {!<=-1,!>=2}
Line 2337
  ( always !0
  ( always {!<=-1,!>=2}
Line 2339
  ( always !0
  :: always 0
  INT always 0
Line 2341
  ( always {!<=-1,!>=2}
  ( always !0
Line 2342
  "Compound assignment '" always "Compound assignment '"
  + possible size=22
  ( always !0
  ( possible size=1
  + possible size=43
  "', assigned value is " always "', assigned value is "
Line 2344
  ( always !0
  == always {!<=-1,!>=2}
  "=" always "="
Line 2348
  false always 0
  && always 0
  "Writable value cannot be evaluated" always "Writable value cannot be evaluated"
Line 2350
  = always 0
  0 always 0
Line 2352
  ( always !0
  == always {!<=-1,!>=2}
  :: always 16
  eIncDecOp always 16
Line 2353
  inc always {!<=-1,!>=2}
  inc always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  ( always !0
  == always {!<=-1,!>=2}
  "++" always "++"
Line 2354
  inc {symbolic=(tok->astParent()->str()=="++"),!<=-1,!>=2}
  ? possible {"incremented","decremented"}
  "incremented" always "incremented"
  : always "decremented"
  "decremented" always "decremented"
Line 2355
  == always {!<=-1,!>=2}
Line 2356
  inc always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  inc {symbolic=(tok->astParent()->str()=="++"),!<=-1,!>=2}
Line 2357
  inc {symbolic=(tok->astParent()->str()=="++"),!<=-1,!>=2}
  ? possible {1,-1}
  1 always 1
  : always -1
  -1 always -1
Line 2358
  " is " always " is "
  "', new value is " always "', new value is "
Line 2363
  ( always {!<=-1,!>=2}
Line 2364
  return always {!<=-1,!>=2}
  true always 1
Line 2369
  [ possible lifetime[Lambda]=(match(child))
Line 2370
  ( always {!<=-1,!>=2}
Line 2374
  ( always {!<=-1,!>=2}
  , always 0
  = always 0
  nullptr always 0
Line 2376
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 2377
  return always {!<=-1,!>=2}
  false always 0
Line 2378
  ( always {!<=-1,!>=2}
  "%assign%" always "%assign%"
Line 2379
  return always {!<=-1,!>=2}
  false always 0
Line 2381
  ! always {!<=-1,!>=2}
Line 2382
  return always {!<=-1,!>=2}
  false always 0
Line 2384
  currValue always !0
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 2385
  ( always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(tok->values()),start=0}
  ( {lifetime[Iterator]=(tok->values()),end=0}
Line 2386
  return always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 2388
  return always {!<=-1,!>=2}
  false always 0
Line 2389
  isPoint always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  currValue always !0
  == always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  currValue always !0
  ( always {!<=-1,!>=2}
Line 2390
  exact always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  currValue always !0
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  currValue always !0
  ( always {!<=-1,!>=2}
Line 2392
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 2394
  ( always {!<=-1,!>=2}
Line 2396
  toImpossible always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 2397
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  toImpossible {symbolic=(v.isImpossible()&&currValue->isKnown()),!<=-1,!>=2}
Line 2399
  exact {!<=-1,!>=2,0}
  && always {!<=-1,!>=2}
  != always {!<=-1,!>=2}
  0 always 0
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  isPoint always {!<=-1,!>=2}
Line 2403
  ( always {!<=-1,!>=2}
Line 2405
  ! always {!<=-1,!>=2}
  exact always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 2407
  bound always symbolic=(currValue->bound)
  == always {!<=-1,!>=2}
Line 2410
  ! {!<=-1,!>=2,1,0}
  r possible {{,size=1,size=0}
  ( {!<=-1,!>=2,0,1}
Line 2412
  value always !0
  ( possible lifetime[Iterator]=(value->errorPath)
  value always !0
  ( {lifetime[Iterator]=(value->errorPath),end=0}
  ( {lifetime[Iterator]=(v.errorPath),lifetime[Object]=(errorPath),start=0}
  ( {lifetime[Iterator]=(v.errorPath),lifetime[Object]=(errorPath),end=0}
Line 2413
  value always !0
  r always !size=0
Line 2414
  toImpossible always {!<=-1,!>=2}
Line 2415
  value always !0
Line 2416
  value always !0
Line 2418
  return always {!<=-1,!>=2}
  true always 1
Line 2421
  return always {!<=-1,!>=2}
  false always 0
Line 2426
  == always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  parent always symbolic=(tok->astParent())
  ". %name% (" always ". %name% ("
Line 2427
  parent always symbolic=(tok->astParent())
Line 2428
  != always {!<=-1,!>=2}
Line 2431
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 2432
  ( always {!<=-1,!>=2}
  parent always symbolic=(tok->astParent())
  "*|[" always "*|["
  || always {!<=-1,!>=2}
  parent always symbolic=(tok->astParent())
  && always {!<=-1,!>=2}
  parent {symbolic=(tok->astParent()),!0}
  == always {!<=-1,!>=2}
  "->" always "->"
  && always {!<=-1,!>=2}
  <= always {!<=-1,!>=2}
  0 always 0
Line 2436
  != always {!<=-1,!>=2}
Line 2443
  , always {!<=-1,!>=2}
  inconclusiveRef always {!<=-1,!>=2}
Line 2444
  ! always {!<=-1,!>=2}
  ref possible symbolic=(tok)
Line 2447
  ! {!<=-1,!>=2,1,0@94}
  inconclusiveRef {!<=-1,!>=2,0,1@94}
  || always {!<=-1,!>=2}
  ref always !0
  != always {!<=-1,!>=2}
Line 2448
  inconclusive always {!<=-1,!>=2}
  inconclusive always {!<=-1,!>=2}
  = always 0
  false always 0
Line 2449
  ( always {!<=-1,!>=2}
  ref always !0
Line 2450
  inconclusiveRef always {!<=-1,!>=2}
Line 2452
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 2457
  ref always !0
  ( always {!<=-1,!>=2}
  "*" always "*"
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  ref always !0
Line 2458
  = always 0
  nullptr always 0
Line 2459
  ref always !0
Line 2460
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 2462
  lifeTok possible symbolic=(v.tokvalue)
Line 2466
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  lifeTok always !0
Line 2468
  ( always {!<=-1,!>=2}
Line 2470
  ( always {!<=-1,!>=2}
  "%assign%" always "%assign%"
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 2472
  inconclusiveRef always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 2478
  ( always {!<=-1,!>=2}
  ref always !0
  inconclusive always {!<=-1,!>=2}
Line 2479
  inconclusive always {!<=-1,!>=2}
  |= always {!<=-1,!>=2}
  inconclusiveRef always {!<=-1,!>=2}
Line 2481
  inconclusive always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 2485
  ( always {!<=-1,!>=2}
  ref always !0
Line 2492
  ( always {!<=-1,!>=2}
Line 2496
  inconclusiveRefs always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  ( always !<=-1
  != always {!<=-1,!>=2}
  1 always 1
Line 2497
  ( always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(refs),start=0}
  ( {lifetime[Iterator]=(refs),end=0}
Line 2498
  == always {!<=-1,!>=2}
Line 2500
  refs possible lifetime[Object]=(tok)
  { possible lifetime[SubObject]=(tok)
Line 2501
  refs possible lifetime[Object]=(tok)
Line 2502
  inconclusiveRefs always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  != always {!<=-1,!>=2}
Line 2503
  ( always {!<=-1,!>=2}
Line 2505
  != always {!<=-1,!>=2}
Line 2508
  ( {!<=-1,!>=2,0}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 2512
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "%name% (" always "%name% ("
  && always {!<=-1,!>=2}
Line 2513
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  1 always 1
  ") {" always ") {"
Line 2522
  ( always {!<=-1,!>=2}
Line 2523
  { always {size=1,{}
Line 2525
  getProgramMemory possible lifetime[Lambda]=(tok)@83
Line 2526
  ( always {!<=-1,!>=2}
  "&&|%oror%" always "&&|%oror%"
Line 2527
  ( always {!<=-1,!>=2}
Line 2528
  result always size=0
  1 always 1
Line 2529
  ( always {!<=-1,!>=2}
Line 2530
  0 always 0
Line 2532
  = always 0
  0 always 0
Line 2533
  error always {!<=-1,!>=2}
  error always {!<=-1,!>=2}
  = always 0
  false always 0
Line 2534
  & {lifetime[Address]=(pm),!0}
  & {lifetime[Address]=(out),!0}
  out always 0
  & {lifetime[Address]=(error),!0}
  error always 0
Line 2535
  ! always {!<=-1,!>=2}
  error always {!<=-1,!>=2}
Line 2541
  = always 0
  nullptr always 0
Line 2543
  == always {!<=-1,!>=2}
Line 2544
  [ possible {lifetime[Lambda]=(pms),lifetime[Lambda]=(tok)}
Line 2547
  == always {!<=-1,!>=2}
Line 2548
  nullptr always 0
Line 2549
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 2552
  { always {size=1,{}
  value always !0
  == always {!<=-1,!>=2}
  0 always 0
Line 2554
  = always 0
  0 always 0
Line 2555
  ( always {!<=-1,!>=2}
  & {lifetime[Address]=(out),!0}
  out always 0
Line 2556
  { always {size=1,{}
Line 2557
  { always {size=0,{}
Line 2559
  { always {size=0,{}
Line 2563
  state always {!<=-1,!>=2}
  flags always !<=-1
Line 2567
  state {!<=-1,!>=2,0}
  flags always !<=-1
Line 2569
  isCondBlock always {!<=-1,!>=2}
  isCondBlock always {!<=-1,!>=2}
  = always 0
  false always 0
Line 2571
  parent always symbolic=(tok->astParent())
Line 2572
  isCondBlock always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  parent {symbolic=(tok->astParent()),!0}
  "if|while (" always "if|while ("
Line 2575
  isCondBlock {!<=-1,!>=2,0}
Line 2576
  parent always symbolic=(tok->astParent())
Line 2577
  ( always {!<=-1,!>=2}
  startBlock always symbolic=(parent->link()->next())
  ";" always ";"
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  parent always symbolic=(tok->astParent())
  -2 always -2
  "} while (" always "} while ("
Line 2578
  parent always symbolic=(tok->astParent())
  -2 always -2
Line 2579
  startBlock possible symbolic=(parent->link()->next())
Line 2580
  endBlock always symbolic=(startBlock->link())
Line 2581
  state always {!<=-1,!>=2}
Line 2582
  endBlock always symbolic=(startBlock->link())
Line 2583
  ( always {!<=-1,!>=2}
  endBlock always symbolic=(startBlock->link())
  "} else {" always "} else {"
Line 2584
  endBlock always symbolic=(startBlock->link())
  2 always 2
Line 2587
  ! always {!<=-1,!>=2}
  flags always !<=-1
Line 2588
  flags always !<=-1
Line 2589
  = possible {"empty","not empty"}
  state always {!<=-1,!>=2}
  ? possible {"empty","not empty"}
  "empty" always "empty"
  : always "not empty"
  "not empty" always "not empty"
Line 2590
  "Assuming container is " always "Assuming container is "
Line 2592
  = possible {"true","false"}
  state always {!<=-1,!>=2}
  ? possible {"true","false"}
  "true" always "true"
  : always "false"
  "false" always "false"
Line 2593
  "Assuming condition is " always "Assuming condition is "
Line 2596
  ! always {!<=-1,!>=2}
  flags always !<=-1
Line 2602
  false always 0
  && always 0
  "Internal update unimplemented." always "Internal update unimplemented."
Line 2607
  ! always {!<=-1,!>=2}
Line 2610
  ( always {!<=-1,!>=2}
Line 2612
  value always !0
Line 2613
  = {&,lifetime[Address]=(localValue),!0}
  & {&,lifetime[Address]=(localValue),!0}
  localValue always symbolic=(*value)
Line 2614
  ( always {!<=-1,!>=2}
  & {lifetime[Address]=(localValue),symbolic=(value),!0,&}
Line 2616
  ( always {!<=-1,!>=2}
Line 2617
  value possible lifetime[Address]=(localValue)
Line 2619
  == always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 2620
  value possible lifetime[Address]=(localValue)
Line 2621
  ( always {!<=-1,!>=2}
Line 2622
  ( always {!<=-1,!>=2}
Line 2623
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 2624
  value possible lifetime[Address]=(localValue)
Line 2627
  == always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 2628
  value possible lifetime[Address]=(localValue)
Line 2645
  ( possible lifetime[SubObject]=(t)
Line 2656
  & {lifetime[Address]=(value),!0}
Line 2659
  & {lifetime[Address]=(value),!0}
Line 2663
  . always {!<=-1,!>=2}
  conditional always {!<=-1,!>=2}
  = always 1
  true always 1
Line 2666
  ( always {!<=-1,!>=2}
Line 2668
  ( always {!<=-1,!>=2}
Line 2669
  return always {!<=-1,!>=2}
  false always 0
Line 2670
  ( always {!<=-1,!>=2}
Line 2671
  return always {!<=-1,!>=2}
  false always 0
Line 2672
  return always {!<=-1,!>=2}
  true always 1
Line 2679
  ( always {!<=-1,!>=2}
  inconclusive always {!<=-1,!>=2}
Line 2680
  ( always {!<=-1,!>=2}
Line 2681
  return always {!<=-1,!>=2}
  false always 0
Line 2688
  == always {!<=-1,!>=2}
  varid always symbolic=(p.first)
Line 2689
  return always {!<=-1,!>=2}
  true always 1
Line 2690
  ( always {!<=-1,!>=2}
  var always symbolic=(p.second)
  varid {symbolic=(p.first),!symbolic=(tok->varId())}
  ( possible lifetime[Object]=(value)
  & {lifetime[Address]=(inconclusive),!0}
  inconclusive always {!<=-1,!>=2}
Line 2691
  return always {!<=-1,!>=2}
  true always 1
Line 2694
  return always {!<=-1,!>=2}
  false always 0
Line 2697
  ( always {!<=-1,!>=2}
Line 2700
  ! always {!<=-1,!>=2}
  var always symbolic=(p.second)
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  var always symbolic=(p.second)
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  var always symbolic=(p.second)
  ( always {!<=-1,!>=2}
Line 2701
  return always {!<=-1,!>=2}
  true always 1
Line 2703
  return always {!<=-1,!>=2}
  false always 0
Line 2706
  ( always {!<=-1,!>=2}
Line 2707
  ( always {!<=-1,!>=2}
Line 2708
  return always {!<=-1,!>=2}
  false always 0
Line 2710
  return always {!<=-1,!>=2}
  true always 1
Line 2712
  ( always {!<=-1,!>=2}
Line 2713
  ( always {!<=-1,!>=2}
Line 2714
  return always {!<=-1,!>=2}
  false always 0
Line 2716
  return always {!<=-1,!>=2}
  true always 1
Line 2719
  ( always {!<=-1,!>=2}
Line 2720
  . always {!<=-1,!>=2}
  conditional always {!<=-1,!>=2}
Line 2721
  return always {!<=-1,!>=2}
  true always 1
Line 2723
  return always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 2724
  return always {!<=-1,!>=2}
  false always 0
Line 2727
  ( always {!<=-1,!>=2}
Line 2729
  ( always {!<=-1,!>=2}
Line 2730
  return always {!<=-1,!>=2}
  false always 0
Line 2731
  ( {!<=-1,!>=2,0}
Line 2732
  return always {!<=-1,!>=2}
  false always 0
Line 2733
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 2734
  return always {!<=-1,!>=2}
  true always 1
Line 2735
  ( always {!<=-1,!>=2}
Line 2736
  return always {!<=-1,!>=2}
  false always 0
Line 2738
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 2741
  ( always {!<=-1,!>=2}
Line 2743
  ! always {!<=-1,!>=2}
  scope always symbolic=(endBlock->scope())
Line 2744
  return always {!<=-1,!>=2}
  false always 0
Line 2745
  scope {symbolic=(endBlock->scope()),!0}
  . possible {6,7,9,8}
  == {!<=-1,!>=2,0}
  :: always 15
  eLambda always 15
Line 2746
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 2747
  scope {symbolic=(endBlock->scope()),!0}
  . {7,9,8,!15}
  == {!<=-1,!>=2,0}
  :: always 6
  eIf always 6
  || {!<=-1,!>=2,0}
  scope {symbolic=(endBlock->scope()),!0}
  . {9,8,!15,!6}
  == {!<=-1,!>=2,0}
  :: always 7
  eElse always 7
  || {!<=-1,!>=2,0}
  scope {symbolic=(endBlock->scope()),!0}
  . {8,!15,!6,!7}
  == {!<=-1,!>=2,0}
  :: always 9
  eWhile always 9
  || always {!<=-1,!>=2}
Line 2748
  scope {symbolic=(endBlock->scope()),!0}
  . always {!15,!7,!9}
  == always {!<=-1,!>=2}
  :: always 8
  eFor always 8
Line 2749
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 2750
  return always {!<=-1,!>=2}
  true always 1
Line 2751
  ( always {!<=-1,!>=2}
Line 2752
  return always {!<=-1,!>=2}
  true always 1
Line 2753
  ( always {!<=-1,!>=2}
Line 2754
  return always {!<=-1,!>=2}
  false always 0
Line 2757
  ( {lifetime[Iterator]=(getVars()),start=0}
  ( {lifetime[Iterator]=(getVars()),end=0}
  varids2 always size=0
  ( {lifetime[Iterator]=(varids2),start=0}
Line 2758
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 2761
  return always {!<=-1,!>=2}
  false always 0
Line 2766
  newValue always symbolic=(value)
Line 2773
  local always {!<=-1,!>=2}
Line 2774
  unknown always {!<=-1,!>=2}
Line 2775
  dependOnThis always {!<=-1,!>=2}
Line 2777
  nullptr always 0
  local always {!<=-1,!>=2}
  true always 1
  unknown always {!<=-1,!>=2}
  false always 0
  dependOnThis always {!<=-1,!>=2}
  false always 0
Line 2780
  e inconclusive 0
  local always {!<=-1,!>=2}
  true always 1
  unknown always {!<=-1,!>=2}
  false always 0
  dependOnThis always {!<=-1,!>=2}
  false always 0
Line 2782
  && always {!<=-1,!>=2}
  e always !0
  != always {!<=-1,!>=2}
  0 always 0
  && always {!<=-1,!>=2}
  "Not a valid expression" always "Not a valid expression"
Line 2783
  dependOnThis always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 2785
  ( always {!<=-1,!>=2}
Line 2789
  ( always {!<=-1,!>=2}
  , always {!<=-1,!>=2}
  deref always {!<=-1,!>=2}
Line 2790
  return always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  var possible symbolic=(var)@9
  || always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  var always !0
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  var always !0
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  deref always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  var always !0
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  var always !0
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
Line 2791
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 2794
  , always 0
  = always 0
  0 always 0
Line 2795
  maxDepth always 4
  = always 4
  4 always 4
Line 2796
  depth possible 0
  > {!<=-1,!>=2,0}
  maxDepth always 4
Line 2798
  [ possible {lifetime[Lambda]=(depth),lifetime[Lambda]=(if(!top||!ispointer||value.indirect!=0))}
Line 2799
  top always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  0 always 0
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
Line 2800
  ispointer always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 2801
  ! always {!<=-1,!>=2}
  top {symbolic=(depth==0&&tok==start),!<=-1,!>=2}
  || always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ispointer always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  != always {!<=-1,!>=2}
  0 always 0
Line 2803
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  ispointer always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 2805
  ! always {!<=-1,!>=2}
  . possible symbolic=(tok)
Line 2807
  . always !0
  == always {!<=-1,!>=2}
Line 2809
  1 always 1
Line 2812
  == always {!<=-1,!>=2}
  0 always 0
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 2816
  unknown always {!<=-1,!>=2}
  = always 1
  true always 1
Line 2817
  :: always 0
  none always 0
Line 2819
  > always {!<=-1,!>=2}
  0 always 0
Line 2820
  ( {>=1,!<=0}
  = possible 0
  ( possible 0
Line 2821
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "." always "."
Line 2823
  var {symbolic=(tok->variable()),0}
  && always {!<=-1,!>=2}
  var {symbolic=(tok->variable()),!0}
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  var {symbolic=(tok->variable()),!0}
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  var always symbolic=(tok->variable())
  "%var% [=(]" always "%var% [=(]"
  && always {!<=-1,!>=2}
Line 2824
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  var always symbolic=(tok->variable())
  ( always {!<=-1,!>=2}
Line 2825
  :: always 0
  none always 0
Line 2826
  deref always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 2827
  ( always !0
  ( always {!<=-1,!>=2}
  "*" always "*"
  || always {!<=-1,!>=2}
Line 2828
  ( always !0
  == always {!<=-1,!>=2}
  "[" always "["
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  ( always !0
Line 2829
  local always {!<=-1,!>=2}
  &= always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  ( always symbolic=(var)
  deref {symbolic=(tok->astParent()&&(tok->astParent()->isUnaryOp("*")||(tok->astParent()->str()=="["&&tok==tok->astParent()->astOperand1()))),!<=-1,!>=2}
Line 2832
  :: always 3
  op1_and_op2 always 3
Line 2836
  ( always {!<=-1,!>=2}
Line 2837
  return always {!<=-1,!>=2}
  unknown always {!<=-1,!>=2}
Line 2846
  ( always {!<=-1,!>=2}
Line 2847
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
Line 2850
  ( always {!<=-1,!>=2}
Line 2851
  return always {!<=-1,!>=2}
  dependOnThis always {!<=-1,!>=2}
Line 2854
  ( always {!<=-1,!>=2}
Line 2855
  return always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  local always {!<=-1,!>=2}
Line 2858
  ( always {!<=-1,!>=2}
Line 2859
  return always {!<=-1,!>=2}
  > always {!<=-1,!>=2}
  0 always 0
Line 2864
  isNot always {!<=-1,!>=2}
Line 2866
  isNot always {!<=-1,!>=2}
  false always 0
Line 2868
  pIsNot always {!<=-1,!>=2}
Line 2869
  isNot always {!<=-1,!>=2}
  pIsNot always {!<=-1,!>=2}
Line 2872
  ( always {!<=-1,!>=2}
Line 2873
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  isNot always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  true always 1
  true always 1
Line 2881
  nullptr always 0
Line 2884
  ( always !0
Line 2887
  ( always {!<=-1,!>=2}
  , always 1
  exact always {!<=-1,!>=2}
  = always 1
  true always 1
  = always 0
  0 always 0
Line 2889
  ( always {!<=-1,!>=2}
  inconclusive always {!<=-1,!>=2}
Line 2891
  == always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  ( always !0
  false always 0
Line 2892
  return always {!<=-1,!>=2}
  false always 0
Line 2893
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  inconclusive always {!<=-1,!>=2}
Line 2896
  ( always {!<=-1,!>=2}
Line 2898
  return always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always !0
  == always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 2900
  ( always {!<=-1,!>=2}
Line 2902
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  false always 0
Line 2906
  ( possible {lifetime[Object]=(tok),lifetime[Object]=(v)}
Line 2920
  ( possible lifetime[Object]=(varname)
Line 2923
  ( always {!<=-1,!>=2}
  , always {!<=-1,!>=2}
  exact always {!<=-1,!>=2}
Line 2925
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  ". %var%" always ". %var%"
Line 2926
  return always {!<=-1,!>=2}
  false always 0
Line 2927
  ! always {!<=-1,!>=2}
  exact always {!<=-1,!>=2}
Line 2928
  return always {!<=-1,!>=2}
  true always 1
Line 2929
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
Line 2952
  ! always {!<=-1,!>=2}
Line 2953
  nullptr always 0
Line 2954
  ! always {!<=-1,!>=2}
  expr always !0
  || always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  expr always !0
Line 2955
  nullptr always 0
Line 2956
  expr always !0
  ( always !0
  ( possible 0
  == {!<=-1,!>=2,1}
  0 always 0
  && always {!<=-1,!>=2}
  expr always !0
  ( always !0
  == always {!<=-1,!>=2}
  0 always 0
Line 2957
  nullptr always 0
Line 2958
  ( always !0
Line 2959
  ( always !0
Line 2960
  == always {!<=-1,!>=2}
  0 always 0
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 2961
  nullptr always 0
Line 2962
  == always {!<=-1,!>=2}
  0 always 0
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 2963
  nullptr always 0
Line 2964
  = always 0
  nullptr always 0
Line 2965
  ! {!<=-1,!>=2,1,0}
  x1 possible size=0
  ( {!<=-1,!>=2,0,1}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 2967
  x1 always !size=0
Line 2968
  x1 possible size=0
  ( {!<=-1,!>=2,1}
  && {!<=-1,!>=2,0}
  ! {!<=-1,!>=2,0}
  x2 possible size=0
  ( {!<=-1,!>=2,1}
Line 2970
  x2 always !size=0
Line 2972
  varTok possible {symbolic=(expr->astOperand2()),symbolic=(expr->astOperand1())}
Line 2979
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 2981
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "+|-" always "+|-"
Line 2984
  intval always Uninit
Line 2985
  rhs always {!<=-1,!>=2}
  rhs always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  binaryTok possible 0
Line 2987
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  rhs always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "-" always "-"
Line 2989
  && always {!<=-1,!>=2}
  ( always !<=-1
  == always {!<=-1,!>=2}
  1 always 1
Line 2990
  ( always size=1
  0 always 0
Line 2991
  '+' always 43
Line 2995
  '-' always 45
Line 2996
  rhs always {!<=-1,!>=2}
Line 3002
  '*' always 42
Line 3003
  == always {!<=-1,!>=2}
  0 always 0
Line 3005
  intval always !0
Line 3008
  '^' always 94
Line 3019
  ( inconclusive lifetime[Object]=(expr)
Line 3022
  ( always {!<=-1,!>=2}
Line 3031
  = possible lifetime[Object]=(exprTok)
  ( possible lifetime[Object]=(exprTok)
Line 3032
  expr possible lifetime[Object]=(exprTok)
Line 3043
  : possible {@229
  values possible {size=2@164,{@229,size=1@229}
Line 3044
  endToken possible {symbolic=(var->scope()->bodyEnd)@157,symbolic=(var->scope()->bodyEnd)@25}
Line 3069
  : possible {@182
  values possible {{@182,size=1@182}
Line 3071
  endToken possible 0@182
Line 3084
  != always {!<=-1,!>=2}
  0 always 0
Line 3085
  values {lifetime[Object]=(val2),{,size=1}
Line 3086
  nullptr always 0
  values possible {lifetime[Object]=(val2),{,size=1}
Line 3089
  Undefined always 0
  ByValue always 1
  ByReference always 2
Line 3094
  ! always {!<=-1,!>=2}
Line 3095
  "object" always "object"
Line 3096
  val always !0
Line 3097
  :: always 2
  Lambda always 2
Line 3098
  = always "lambda"
  "lambda" always "lambda"
Line 3100
  :: always 3
  Iterator always 3
Line 3101
  = always "iterator"
  "iterator" always "iterator"
Line 3104
  :: always 1
  SubObject always 1
Line 3105
  :: always 4
  Address always 4
Line 3106
  ( always {!<=-1,!>=2}
Line 3107
  = always "pointer"
  "pointer" always "pointer"
Line 3109
  = always "object"
  "object" always "object"
Line 3112
  result possible {"lambda",size=6,"iterator",size=8,"pointer",size=7,"object"}
Line 3117
  = possible 0
  ? possible 0
  val always !0
  : always 0
  nullptr always 0
Line 3118
  = possible 0
  tokvalue {symbolic=(val?val->tokvalue:nullptr),0}
  ? possible 0
  tokvalue {symbolic=(val?val->tokvalue:nullptr),!0}
  : always 0
  nullptr always 0
Line 3119
  = possible 0
  tokvar {symbolic=(tokvalue?tokvalue->variable():nullptr),0}
  ? possible 0
  tokvar {symbolic=(tokvalue?tokvalue->variable():nullptr),!0}
  : always 0
  nullptr always 0
Line 3120
  classVar always {!<=-1,!>=2}
  = {0,!<=-1,!>=2}
  tokvar {symbolic=(tokvalue?tokvalue->variable():nullptr),0}
  ? {0,!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  tokvar {symbolic=(tokvalue?tokvalue->variable():nullptr),!0}
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  tokvar {symbolic=(tokvalue?tokvalue->variable():nullptr),!0}
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  tokvar {symbolic=(tokvalue?tokvalue->variable():nullptr),!0}
  ( always {!<=-1,!>=2}
  : always 0
  false always 0
Line 3123
  vartok {symbolic=(tokvar?tokvar->nameToken():nullptr),0}
Line 3124
  ! {!<=-1,!>=2,1}
  classVar {symbolic=(tokvar?(!tokvar->isLocal()&&!tokvar->isArgument()&&!tokvar->isGlobal()):false),!<=-1,!>=2,0}
Line 3125
  vartok {symbolic=(tokvar?tokvar->nameToken():nullptr),!0}
  "Variable created here." always "Variable created here."
Line 3126
  vartok inconclusive symbolic=(tokvar?tokvar->nameToken():nullptr)
Line 3127
  var always symbolic=(vartok->variable())
Line 3130
  :: always 1
  SubObject always 1
Line 3132
  :: always 4
  Address always 4
Line 3133
  == always {!<=-1,!>=2}
  "pointer" always "pointer"
Line 3134
  = always " to local variable"
  " to local variable" always " to local variable"
Line 3136
  = always " that points to local variable"
  " that points to local variable" always " that points to local variable"
Line 3138
  :: always 2
  Lambda always 2
Line 3139
  = always " that captures local variable"
  " that captures local variable" always " that captures local variable"
Line 3141
  :: always 3
  Iterator always 3
Line 3142
  = always " to local container"
  " to local container" always " to local container"
Line 3145
  classVar always {!<=-1,!>=2}
Line 3146
  ( always !<=-1
  "local" always "local"
  5 always 5
  "member" always "member"
Line 3147
  submessage possible {" that captures local variable",size=29," to local container",size=19}
  + possible {size=31,size=21}
  " '" always " '"
  "'" always "'"
Line 3150
  msg possible symbolic=(type)
Line 3153
  inconclusive always {!<=-1,!>=2}
Line 3156
  = possible lifetime[Lambda]=(path)
  [ possible lifetime[Lambda]=(path)
Line 3157
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  != always {!<=-1,!>=2}
  0 always 0
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 3158
  false always 0
Line 3159
  ! always {!<=-1,!>=2}
  inconclusive always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 3160
  false always 0
Line 3161
  ! always {!<=-1,!>=2}
Line 3162
  false always 0
Line 3163
  path possible symbolic=(v.path)
  >= always {!<=-1,!>=2}
  0 always 0
  && always {!<=-1,!>=2}
  != always {!<=-1,!>=2}
  0 always 0
  && always {!<=-1,!>=2}
  . always !0
  != always {!<=-1,!>=2}
  path {>=0,!<=-1}
Line 3164
  false always 0
Line 3165
  true always 1
Line 3167
  ( {lifetime[Iterator]=(tok->values()),start=0}
  ( {lifetime[Iterator]=(tok->values()),end=0}
  ( possible lifetime[Object]=(result)
  result always size=0
  pred possible lifetime[Lambda]=(path)
Line 3171
  , always {!<=-1,!>=2}
  inconclusive always {!<=-1,!>=2}
Line 3173
  inconclusive always {!<=-1,!>=2}
Line 3175
  ( always !<=-1
  != always {!<=-1,!>=2}
  1 always 1
Line 3177
  values always size=1
Line 3182
  escape always {!<=-1,!>=2}
Line 3185
  = always 20
  20 always 20
Line 3187
  ! always {!<=-1,!>=2}
  tok possible {symbolic=(v.tokvalue)@54358,symbolic=(var->declEndToken()->astOperand2())@100,symbolic=(var->nameToken()->astParent()->astOperand2())@117,symbolic=(args[n])@129}
Line 3188
  { always {size=0,{}
Line 3189
  ( always {!<=-1,!>=2}
  tok {!0,symbolic=(v.tokvalue)@54358,symbolic=(var->nameToken()->astParent()->astOperand2())@117,symbolic=(args[n])@129}
  "..." always "..."
Line 3190
  { always {size=0,{}
Line 3191
  tok always !0
Line 3192
  tok always !0
Line 3193
  { {lifetime[SubObject]=(tok),lifetime[SubObject]=(errorPath),size=2,{}
  ( possible lifetime[Object]=(errorPath)
Line 3194
  < always {!<=-1,!>=2}
  0 always 0
Line 3195
  { {lifetime[SubObject]=(tok),lifetime[SubObject]=(errorPath),size=2,{}
  ( possible lifetime[Object]=(errorPath)
Line 3196
  && always {!<=-1,!>=2}
  var always !0
  == always {!<=-1,!>=2}
Line 3197
  var always !0
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  var always !0
  ( always {!<=-1,!>=2}
Line 3198
  ! always {!<=-1,!>=2}
  var always !0
Line 3199
  { {lifetime[SubObject]=(tok),lifetime[SubObject]=(errorPath),size=3,{}
  true always 1
  ( possible lifetime[Object]=(errorPath)
Line 3200
  var always !0
  ( always {!<=-1,!>=2}
Line 3201
  var always !0
  ( always !0
  "Passed to reference." always "Passed to reference."
Line 3202
  { {lifetime[SubObject]=(tok),lifetime[SubObject]=(errorPath),size=3,{}
  true always 1
  ( possible lifetime[Object]=(errorPath)
Line 3203
  ( always {!<=-1,!>=2}
  var always !0
  ( always !0
  "=" always "="
Line 3204
  var always !0
  ( always !0
  "Assigned to reference." always "Assigned to reference."
Line 3205
  var always !0
Line 3206
  temporary always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  true always 1
  vartok {symbolic=(var->declEndToken()->astOperand2()),symbolic=(tok),0}
  nullptr always 0
  true always 1
Line 3207
  nonlocal always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  var always !0
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  var always !0
  ( always {!<=-1,!>=2}
Line 3208
  vartok {symbolic=(var->declEndToken()->astOperand2()),0}
  == always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  nonlocal {symbolic=(var->isStatic()||var->isGlobal()),!<=-1,!>=2}
  && always {!<=-1,!>=2}
  temporary always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
Line 3209
  ! always {!<=-1,!>=2}
  escape always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  var always !0
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  var always !0
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  temporary always {!<=-1,!>=2}
Line 3210
  { {lifetime[SubObject]=(tok),lifetime[SubObject]=(errorPath),size=3,{}
  tok possible symbolic=(vartok)
  true always 1
  ( possible lifetime[Object]=(errorPath)
Line 3211
  vartok {symbolic=(var->declEndToken()->astOperand2()),!symbolic=(tok)}
Line 3212
  ( inconclusive lifetime[Object]=(errorPath)
  vartok {symbolic=(var->declEndToken()->astOperand2()),!symbolic=(tok),!0}
  escape always {!<=-1,!>=2}
  ( possible lifetime[Object]=(errorPath)
  1 always 1
Line 3213
  ( always {!<=-1,!>=2}
  var always !0
  ":" always ":"
  && always {!<=-1,!>=2}
Line 3214
  var always !0
  && always {!<=-1,!>=2}
Line 3215
  ( always {!<=-1,!>=2}
  var always !0
  ( always !0
  "for (" always "for ("
Line 3216
  var always !0
  "Assigned to reference." always "Assigned to reference."
Line 3217
  var always !0
Line 3218
  vartok {symbolic=(var->nameToken()),symbolic=(tok)}
  == {!<=-1,!>=2,1}
Line 3219
  { {lifetime[SubObject]=(tok),lifetime[SubObject]=(errorPath),size=3,{}
  tok always symbolic=(vartok)
  true always 1
  ( possible lifetime[Object]=(errorPath)
Line 3220
  ( {symbolic=(vartok),!symbolic=(tok)}
Line 3221
  ( always {!<=-1,!>=2}
  contok always symbolic=(var->nameToken()->astParent()->astOperand2())
Line 3222
  ( inconclusive lifetime[Object]=(errorPath)
  contok always symbolic=(var->nameToken()->astParent()->astOperand2())
  escape always {!<=-1,!>=2}
  ( possible lifetime[Object]=(errorPath)
  1 always 1
Line 3224
  { always {size=0,{}
Line 3226
  { always {size=0,{}
Line 3229
  ( always {!<=-1,!>=2}
  "%name% (" always "%name% ("
Line 3231
  f always symbolic=(tok->previous()->function())
Line 3232
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  f {symbolic=(tok->previous()->function()),!0}
Line 3233
  { {lifetime[SubObject]=(tok),lifetime[SubObject]=(errorPath),size=2,{}
  ( possible lifetime[Object]=(errorPath)
Line 3235
  f {symbolic=(tok->previous()->function()),!0}
Line 3237
  == always {!<=-1,!>=2}
Line 3239
  ( inconclusive lifetime[Object]=(errorPath)
  returnTok always !symbolic=(tok)
  escape always {!<=-1,!>=2}
  - always !<=-1
  ( always !<=-1
Line 3241
  argvarTok always symbolic=(lt.token)
Line 3242
  ! always {!<=-1,!>=2}
  argvar always symbolic=(argvarTok->variable())
Line 3244
  argvar {symbolic=(argvarTok->variable()),!0}
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  argvar {symbolic=(argvarTok->variable()),!0}
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  argvar {symbolic=(argvarTok->variable()),!0}
  ( always {!<=-1,!>=2}
Line 3245
  argvar {symbolic=(argvarTok->variable()),!0}
Line 3246
  < always {!<=-1,!>=2}
  0 always 0
Line 3247
  { always {size=0,{}
Line 3250
  n {!<=-1,>=0}
  >= always {!<=-1,!>=2}
  ( always !<=-1
Line 3251
  { always {size=0,{}
Line 3252
  n {!>=symbolic=(args.size()),<=symbolic=(args.size()-1),!<=-1}
Line 3253
  "Return reference." always "Return reference."
Line 3254
  "Called function passing '" always "Called function passing '"
  argTok always symbolic=(args[n])
  "'." always "'."
Line 3256
  argTok always symbolic=(args[n])
  escape always {!<=-1,!>=2}
  - always !<=-1
  ( always !<=-1
Line 3257
  ( always !<=-1
  > always {!<=-1,!>=2}
  1 always 1
Line 3258
  ( possible lifetime[Iterator]=(result)
  ( {lifetime[Iterator]=(result),end=0}
  ( {lifetime[Iterator]=(arglts),start=0}
  ( {lifetime[Iterator]=(arglts),end=0}
Line 3263
  ( always {!<=-1,!>=2}
  -2 always -2
  ". %name% (" always ". %name% ("
  && always {!<=-1,!>=2}
  -2 always -2
  != always {!<=-1,!>=2}
  "->" always "->"
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  -2 always -2
Line 3264
  -2 always -2
Line 3266
  y {symbolic=(library->getYield(tok->previous()->str())),1}
  == {!<=-1,!>=2,0}
  :: always 0
  AT_INDEX always 0
  || always {!<=-1,!>=2}
  y {symbolic=(library->getYield(tok->previous()->str())),!0}
  == always {!<=-1,!>=2}
  :: always 1
  ITEM always 1
Line 3267
  "Accessing container." always "Accessing container."
Line 3269
  ( inconclusive lifetime[Object]=(errorPath)
  -2 always -2
  escape always {!<=-1,!>=2}
  ( possible lifetime[Object]=(errorPath)
  depth always !<=-1
  - always !<=-2
  1 always 1
Line 3270
  false always 0
Line 3273
  ( always {!<=-1,!>=2}
  ".|::|[" always ".|::|["
  || always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "*" always "*"
Line 3276
  tok always symbolic=(vartok)
  ( always {!<=-1,!>=2}
  "*" always "*"
Line 3277
  tok always symbolic=(vartok)
Line 3278
  vartok possible {symbolic=(tok),symbolic=(tok->astOperand1())}
Line 3279
  vartok always !0
  ( possible {size=1,size=2}
  == {!<=-1,!>=2,0}
  "[" always "["
  || always {!<=-1,!>=2}
  vartok always !0
  == always {!<=-1,!>=2}
  "->" always "->"
Line 3280
  vartok always !0
Line 3281
  vartok always !0
  ( possible size=2
  == {!<=-1,!>=2,0}
  "." always "."
  || always {!<=-1,!>=2}
  vartok always !0
  == always {!<=-1,!>=2}
  "::" always "::"
Line 3282
  vartok always !0
Line 3287
  ! {!<=-1,!>=2,1}
  vartok possible 0
Line 3288
  { {lifetime[SubObject]=(tok),lifetime[SubObject]=(errorPath),size=2,{}
  ( possible lifetime[Object]=(errorPath)
Line 3289
  vartok always !0
Line 3290
  isContainer always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  vartok always !0
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  vartok always !0
Line 3291
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  vartok always !0
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  isContainer always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  tokvar always symbolic=(vartok->variable())
  && always {!<=-1,!>=2}
  tokvar {symbolic=(vartok->variable()),!0}
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  tokvar {symbolic=(vartok->variable()),!0}
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 3292
  ( always {!<=-1,!>=2}
  vartok always !0
  "[|*" always "[|*"
  || always {!<=-1,!>=2}
  vartok always !0
  == always {!<=-1,!>=2}
  "->" always "->"
Line 3293
  vartok always !0
Line 3294
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 3296
  == always {!<=-1,!>=2}
Line 3298
  ( {lifetime[Iterator]=(v.errorPath),lifetime[Object]=(errorPath),start=0}
  ( {lifetime[Iterator]=(v.errorPath),lifetime[Object]=(errorPath),end=0}
Line 3299
  ( inconclusive lifetime[Object]=(errorPath)
  escape always {!<=-1,!>=2}
  ( possible lifetime[Object]=(errorPath)
  1 always 1
Line 3302
  ( inconclusive lifetime[Object]=(errorPath)
  vartok always !0
  escape always {!<=-1,!>=2}
  ( possible lifetime[Object]=(errorPath)
  depth always !<=-1
  - always !<=-2
  1 always 1
Line 3303
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  vartok always !0
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  vartok always !0
  "[" always "["
Line 3305
  ( always {!<=-1,!>=2}
  "{" always "{"
  && always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 3306
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "," always ","
  && always {!<=-1,!>=2}
Line 3310
  ( always {!<=-1,!>=2}
Line 3311
  ( inconclusive lifetime[Object]=(errorPath)
  escape always {!<=-1,!>=2}
  ( possible lifetime[Object]=(errorPath)
  depth always !<=-1
  - always !<=-2
  1 always 1
Line 3314
  { {lifetime[SubObject]=(tok),lifetime[SubObject]=(errorPath),size=2,{}
  ( possible lifetime[Object]=(errorPath)
Line 3317
  escape always {!<=-1,!>=2}
Line 3319
  ( inconclusive {lifetime[Object]=(tok),lifetime[Object]=(errorPath)}
  tok possible symbolic=(v.tokvalue)@212
  escape always {!<=-1,!>=2}
  ( possible lifetime[Object]=(errorPath)
Line 3320
  false always 0
Line 3324
  ( always {!<=-1,!>=2}
Line 3326
  result always {!<=-1,!>=2}
  result always {!<=-1,!>=2}
  = always 0
  false always 0
Line 3327
  ( inconclusive lifetime[Object]=(tok)
  false always 0
  [ possible lifetime[Lambda]=(result)
Line 3328
  result always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
Line 3329
  result {symbolic=(tok2->exprId()==lifetime->exprId()),!<=-1,!>=2}
Line 3331
  return always {!<=-1,!>=2}
  result always {!<=-1,!>=2}
Line 3334
  , always 0
  = always 0
  nullptr always 0
Line 3336
  = possible lifetime[Object]=(tok)
  ( possible lifetime[Object]=(tok)
Line 3337
  lts possible lifetime[Object]=(tok)
  ( always !<=-1
  != always {!<=-1,!>=2}
  1 always 1
Line 3338
  nullptr always 0
Line 3339
  lts {lifetime[Object]=(tok),size=1}
  . always {!<=-1,!>=2}
  inconclusive always {!<=-1,!>=2}
Line 3340
  nullptr always 0
Line 3342
  * always {!<=-1,!>=2}
  addressOf always !0
  = always {!<=-1,!>=2}
  lts always size=1
  . always {!<=-1,!>=2}
  addressOf always {!<=-1,!>=2}
Line 3343
  lts always size=1
  lts always size=1
Line 3344
  lts always size=1
Line 3349
  tok possible symbolic=(v.tokvalue)@193
  errorPath possible {symbolic=(v.errorPath)@193,size=0}
  addressOf possible 0@78
Line 3350
  && always {!<=-1,!>=2}
  tok2 always !0
Line 3351
  tok2 always !0
  ( always !0
Line 3352
  nullptr always 0
Line 3358
  nullptr always 0
Line 3361
  ( always {!<=-1,!>=2}
Line 3363
  return always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 3366
  ( always {!<=-1,!>=2}
Line 3368
  vtParent possible lifetime[Address]=(vtParents)@14155
Line 3369
  return always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  . always !0
  . always {!<=-1,!>=2}
  view always {!<=-1,!>=2}
Line 3370
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 5
  CONTAINER always 5
Line 3373
  ( always {!<=-1,!>=2}
Line 3375
  ! always {!<=-1,!>=2}
  vtParent possible lifetime[Address]=(vtParents)@55
Line 3376
  return always {!<=-1,!>=2}
  false always 0
Line 3377
  ( always {!<=-1,!>=2}
  vtParent {!0,lifetime[Address]=(vtParents)@55}
Line 3378
  return always {!<=-1,!>=2}
  true always 1
Line 3379
  ! always {!<=-1,!>=2}
Line 3380
  return always {!<=-1,!>=2}
  false always 0
Line 3382
  . possible symbolic=(vt->pointer)
  == always {!<=-1,!>=2}
  1 always 1
  && always {!<=-1,!>=2}
  vt always !0
  == always {!<=-1,!>=2}
  0 always 0
  && always {!<=-1,!>=2}
  vt always !0
  == always {!<=-1,!>=2}
  :: always 6
  ITERATOR always 6
Line 3383
  return always {!<=-1,!>=2}
  false always 0
Line 3384
  vt always !0
  . possible symbolic=(vtParent->type)
  != always {!<=-1,!>=2}
  :: always 0
  UNKNOWN_TYPE always 0
  && always {!<=-1,!>=2}
  != always {!<=-1,!>=2}
  :: always 0
  UNKNOWN_TYPE always 0
Line 3385
  vt always !0
  != always {!<=-1,!>=2}
Line 3386
  return always {!<=-1,!>=2}
  true always 1
Line 3387
  . always !0
  != always {!<=-1,!>=2}
  . {3,!0}
Line 3388
  . always {!symbolic=(vt->type),!0}
  == always {!<=-1,!>=2}
  :: always 3
  RECORD always 3
Line 3389
  return always {!<=-1,!>=2}
  true always 1
Line 3390
  ( always {!<=-1,!>=2}
Line 3391
  return always {!<=-1,!>=2}
  true always 1
Line 3395
  return always {!<=-1,!>=2}
  false always 0
Line 3398
  ( always {!<=-1,!>=2}
Line 3400
  ! always {!<=-1,!>=2}
  vtParent possible lifetime[Address]=(vtParents)@54
Line 3401
  return always {!<=-1,!>=2}
  false always 0
Line 3402
  ! always {!<=-1,!>=2}
Line 3403
  return always {!<=-1,!>=2}
  false always 0
Line 3404
  vt always !0
  . possible symbolic=(vtParent->pointer)
  > always {!<=-1,!>=2}
  0 always 0
  && always {!<=-1,!>=2}
  vt always !0
  . {>=1,!<=0}
  == always {!<=-1,!>=2}
  vtParent always !0
Line 3405
  return always {!<=-1,!>=2}
  true always 1
Line 3406
  . possible symbolic=(vt->container)
  && always {!<=-1,!>=2}
  . always !0
  . always {!<=-1,!>=2}
  view always {!<=-1,!>=2}
Line 3407
  return always {!<=-1,!>=2}
  true always 1
Line 3408
  != always {!<=-1,!>=2}
  :: always 0
  UNKNOWN_TYPE always 0
  && always {!<=-1,!>=2}
  != always {!<=-1,!>=2}
  :: always 0
  UNKNOWN_TYPE always 0
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
Line 3409
  > always {!<=-1,!>=2}
Line 3410
  return always {!<=-1,!>=2}
  true always 1
Line 3411
  . {!>=symbolic=(vt->pointer+1),<=symbolic=(vt->pointer)}
  < always {!<=-1,!>=2}
  . {!<=symbolic=(vtParent->pointer-1),>=symbolic=(vtParent->pointer)}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 3412
  return always {!<=-1,!>=2}
  true always 1
Line 3413
  == always {!<=-1,!>=2}
Line 3414
  return always {!<=-1,!>=2}
  true always 1
Line 3417
  return always {!<=-1,!>=2}
  false always 0
Line 3422
  tok possible {symbolic=(x.second)@71,symbolic=(y.second)@72}
  != always {!<=-1,!>=2}
  endTok possible {symbolic=(start1)@71,symbolic=(start2)@72}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  tok always !symbolic=(endTok)
  "const|volatile|auto|&|&&" always "const|volatile|auto|&|&&"
Line 3423
  tok always !symbolic=(endTok)
Line 3424
  tok possible symbolic=(endTok)
Line 3427
  ( always {!<=-1,!>=2}
Line 3431
  start1 always symbolic=(x.first)
  == always {!<=-1,!>=2}
  nullptr always 0
  || always {!<=-1,!>=2}
  start2 always symbolic=(y.first)
  == always {!<=-1,!>=2}
  nullptr always 0
Line 3432
  return always {!<=-1,!>=2}
  false always 0
Line 3433
  start1 possible symbolic=(x.first)
  != always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  != always {!<=-1,!>=2}
Line 3434
  start1 always !symbolic=(x.second)
  . always !symbolic=(start1)
Line 3435
  != always {!<=-1,!>=2}
  start1 always !symbolic=(x.second)
Line 3436
  = always !symbolic=(start1)
  tok1 always !symbolic=(start1)
Line 3439
  start2 always !symbolic=(y.second)
  . always !symbolic=(start2)
Line 3440
  != always {!<=-1,!>=2}
  start2 always !symbolic=(y.second)
Line 3441
  = always !symbolic=(start2)
  tok2 always !symbolic=(start2)
Line 3444
  != always {!<=-1,!>=2}
Line 3445
  return always {!<=-1,!>=2}
  true always 1
Line 3449
  start1 possible symbolic=(x.second)
  . possible symbolic=(start1)
Line 3450
  start2 possible symbolic=(y.second)
  . possible symbolic=(start2)
Line 3451
  return always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
Line 3453
  ( always {!<=-1,!>=2}
Line 3455
  nullptr always 0
Line 3457
  ( always {!<=-1,!>=2}
Line 3458
  return always {!<=-1,!>=2}
Line 3460
  ( always {!<=-1,!>=2}
Line 3462
  == always {!<=-1,!>=2}
  nullptr always 0
Line 3463
  return always {!<=-1,!>=2}
  false always 0
Line 3464
  y always !0
  ( always {!<=-1,!>=2}
Line 3465
  return always {!<=-1,!>=2}
  false always 0
Line 3466
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  y always !0
  . always !size=0
Line 3469
  ( always {!<=-1,!>=2}
Line 3473
  && always {!<=-1,!>=2}
Line 3474
  t always !0
  . possible symbolic=(parentT->classDef)
  && always {!<=-1,!>=2}
  parentT always !0
  && always {!<=-1,!>=2}
  t always !0
  . always !0
  != always {!<=-1,!>=2}
  parentT always !0
  . always !0
Line 3475
  return always {!<=-1,!>=2}
  true always 1
Line 3479
  ( always {!<=-1,!>=2}
Line 3480
  return always {!<=-1,!>=2}
  true always 1
Line 3481
  ( always {!<=-1,!>=2}
Line 3482
  return always {!<=-1,!>=2}
  true always 1
Line 3483
  ( always {!<=-1,!>=2}
Line 3484
  return always {!<=-1,!>=2}
  true always 1
Line 3486
  return always {!<=-1,!>=2}
  false always 0
Line 3489
  ( always {!<=-1,!>=2}
Line 3491
  ! always {!<=-1,!>=2}
  tok possible symbolic=(tok2->astOperand2())@165
Line 3492
  return always {!<=-1,!>=2}
  true always 1
Line 3493
  tok always !0
  == always {!<=-1,!>=2}
  "," always ","
Line 3494
  return always {!<=-1,!>=2}
  true always 1
Line 3495
  ! always {!<=-1,!>=2}
  tok always !0
Line 3496
  return always {!<=-1,!>=2}
  true always 1
Line 3497
  = always 0
  nullptr always 0
Line 3499
  & {lifetime[Address]=(parent),!0}
  parent always 0
Line 3501
  ( always {!<=-1,!>=2}
  vt always symbolic=(tok->valueType())
  & {lifetime[Address]=(vtParents),!0}
Line 3502
  return always {!<=-1,!>=2}
  true always 1
Line 3503
  ( always {!<=-1,!>=2}
  & {lifetime[Address]=(vtParents),!0}
Line 3504
  return always {!<=-1,!>=2}
  false always 0
Line 3507
  ( always {!<=-1,!>=2}
  parent always !0
Line 3508
  return always {!<=-1,!>=2}
  false always 0
Line 3510
  return always {!<=-1,!>=2}
  true always 1
Line 3522
  ! always {!<=-1,!>=2}
Line 3523
  nullptr always 0
Line 3524
  var always !0
Line 3525
  = {symbolic=(var->scope()),0}
  innerScope {symbolic=(var->scope()),0}
Line 3526
  var always !0
  && always {!<=-1,!>=2}
  var always !0
  ( always !0
Line 3527
  = always !0
  var always !0
  ( always !0
  ( always !0
Line 3528
  ! always {!<=-1,!>=2}
  innerScope {symbolic=(var->scope()),symbolic=(outerScope)}
  && always {!<=-1,!>=2}
Line 3529
  = always !0
  outerScope always !0
Line 3530
  ! always {!<=-1,!>=2}
  innerScope possible {symbolic=(var->scope()),symbolic=(outerScope)}
  || always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  outerScope possible symbolic=(innerScope)
Line 3531
  nullptr always 0
Line 3532
  ! always {!<=-1,!>=2}
  innerScope {symbolic=(outerScope),!0}
  ( always {!<=-1,!>=2}
Line 3533
  nullptr always 0
Line 3537
  innerScope always !0
  != always {!<=-1,!>=2}
  outerScope always !0
  && always {!<=-1,!>=2}
  outerScope always {!symbolic=(innerScope),!0}
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  innerScope always {!symbolic=(outerScope),!0}
  ( always {!<=-1,!>=2}
Line 3538
  innerScope always {!symbolic=(outerScope),!0}
Line 3539
  innerScope possible symbolic=(outerScope)
Line 3542
  , always {!<=-1,!>=2}
  smallest always {!<=-1,!>=2}
Line 3544
  end possible 0
  = always 0
  nullptr always 0
Line 3545
  local {!<=-1,!>=2,0}
  local always {!<=-1,!>=2}
  = always 0
  false always 0
Line 3546
  [ possible lifetime[Lambda]=(local)
Line 3548
  local always {!<=-1,!>=2}
  |= always {!<=-1,!>=2}
  var always !0
  ( {!<=-1,!>=2,0}
Line 3549
  var always !0
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  var always !0
  ( always {!<=-1,!>=2}
Line 3550
  var always !0
Line 3551
  ! always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  smallest always {!<=-1,!>=2}
  ? always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  end always !0
  : always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  end always !0
Line 3555
  :: always 3
  op1_and_op2 always 3
Line 3557
  ! always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 3558
  defaultScope always !0
Line 3559
  ! always {!<=-1,!>=2}
  end possible symbolic=(defaultScope->bodyEnd)
Line 3561
  scope always symbolic=(tok->scope())
Line 3562
  scope {symbolic=(tok->scope()),!0}
Line 3564
  ! always {!<=-1,!>=2}
  local always {!<=-1,!>=2}
Line 3565
  scope possible {symbolic=(tok->scope()),0}
  && always {!<=-1,!>=2}
  scope {symbolic=(tok->scope()),!0}
  ( always {!<=-1,!>=2}
Line 3566
  scope always !0
Line 3567
  scope possible {symbolic=(tok->scope()),0}
  && always {!<=-1,!>=2}
  scope always !0
  ( always {!<=-1,!>=2}
Line 3568
  scope always !0
Line 3571
  end possible symbolic=(scope->bodyEnd)
Line 3577
  ( always {!<=-1,!>=2}
  "%var% {|(" always "%var% {|("
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 3579
  values always symbolic=(tok->values())
  & {lifetime[Address]=(isNotLifetimeValue),!0}
Line 3584
  parent possible {symbolic=(tok->astParent()),0}
  && always {!<=-1,!>=2}
  parent {symbolic=(tok->astParent()),!0}
  == always {!<=-1,!>=2}
  "," always ","
Line 3585
  parent always !0
Line 3586
  ! {!<=-1,!>=2,1}
  parent possible {symbolic=(tok->astParent()),0}
Line 3589
  parent always !0
  == always {!<=-1,!>=2}
  "=" always "="
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  parent always !0
  || always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  parent always !0
  ( always !0
  ";" always ";"
Line 3591
  ! always {!<=-1,!>=2}
  parent always !0
  || always {!<=-1,!>=2}
  parent always !0
  ( always !0
  ( always {!<=-1,!>=2}
Line 3594
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  parent always !0
Line 3598
  ! always {!<=-1,!>=2}
Line 3601
  expr always !0
  == always {!<=-1,!>=2}
  0 always 0
Line 3604
  expr always !0
Line 3608
  values always symbolic=(parent->astOperand2()->values())
  & {lifetime[Address]=(isNotLifetimeValue),!0}
Line 3610
  [ possible lifetime[Lambda]=(expr)
Line 3611
  [ possible lifetime[Lambda]=(expr)
Line 3612
  == always {!<=-1,!>=2}
Line 3619
  expr always !0
  ( always !0
  > always {!<=-1,!>=2}
  0 always 0
Line 3622
  expr always !0
Line 3628
  == always {!<=-1,!>=2}
  :: always 4
  Address always 4
Line 3629
  = always 1
  :: always 1
  SubObject always 1
Line 3632
  ( always {!<=-1,!>=2}
  "." always "."
Line 3634
  ( always {!<=-1,!>=2}
  & {lifetime[Address]=(settings->library),!0}
Line 3635
  && always {!<=-1,!>=2}
  parentLifetime always !0
  > always {!<=-1,!>=2}
  0 always 0
Line 3638
  parentLifetime always !0
Line 3646
  ( always {!<=-1,!>=2}
  parent always !0
  "{" always "{"
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  parent always !0
Line 3647
  parent always !0
Line 3648
  parent always !0
Line 3650
  ( always {!<=-1,!>=2}
  parent always !0
  "%name% (" always "%name% ("
Line 3651
  parent always !0
Line 3652
  parent always !0
Line 3655
  = always !0
  ( always !0
Line 3656
  var {symbolic=(tok->variable()),!0}
Line 3659
  parent always !0
Line 3661
  values always symbolic=(tok->values())
  & {lifetime[Address]=(isNotLifetimeValue),!0}
Line 3662
  endOfVarScope always symbolic=(var->scope()->bodyEnd)
Line 3664
  parent always !0
  ( always {!<=-1,!>=2}
Line 3667
  values always symbolic=(tok->values())
  & {lifetime[Address]=(isNotLifetimeValue),!0}
Line 3669
  parent always !0
Line 3670
  parent always !0
Line 3679
  inconclusive always {!<=-1,!>=2}
Line 3680
  forward always {!<=-1,!>=2}
Line 3690
  nullptr always 0
  inconclusive always {!<=-1,!>=2}
  false always 0
  forward always {!<=-1,!>=2}
  true always 1
  nullptr always 0
Line 3696
  inconclusive always {!<=-1,!>=2}
  = always 0
  false always 0
Line 3701
  inconclusive always {!<=-1,!>=2}
  inconclusive always {!<=-1,!>=2}
Line 3702
  forward always {!<=-1,!>=2}
  true always 1
Line 3703
  nullptr always 0
Line 3712
  argtoks possible size=2@65
Line 3713
  message possible {"Passed to initializer list."@62,"Passed to initializer list."@65,"Passed to initializer list."@67,"Passed to initializer list."@77}
  type possible 1@62
Line 3715
  = {&,lifetime[Address]=(c),!0}
  & {&,lifetime[Address]=(c),!0}
Line 3716
  ls possible lifetime[SubObject]=(c)
  . always {!<=-1,!>=2}
  forward always {!<=-1,!>=2}
  = always 0
  false always 0
Line 3717
  f possible {lifetime[Lambda]=(tok)@62,lifetime[Lambda]=(tok)@65,lifetime[Lambda]=(tok)@67,lifetime[Lambda]=(tok)@77,lifetime[Lambda]=(it)@79,lifetime[Lambda]=(scope)@79,lifetime[Lambda]=(argToParam)@180,lifetime[Lambda]=(paramCapture)@180,lifetime[Lambda]=(argToParam)@183}
Line 3719
  . always !0
Line 3728
  ! always {!<=-1,!>=2}
  var possible symbolic=(v.tokvalue->variable())@140
Line 3730
  ! always {!<=-1,!>=2}
  var {!0,symbolic=(v.tokvalue->variable())@140}
  ( always {!<=-1,!>=2}
Line 3732
  var always !0
Line 3733
  < always {!<=-1,!>=2}
  0 always 0
Line 3736
  n {!<=-1,>=0}
  >= always {!<=-1,!>=2}
  ( always !<=-1
Line 3737
  . always {!<=-1,!>=2}
  debugwarnings always {!<=-1,!>=2}
Line 3738
  "valueFlowBailout" always "valueFlowBailout"
  "Argument mismatch: Function '" always "Argument mismatch: Function '"
  "' returning lifetime from argument index " always "' returning lifetime from argument index "
  n always {!<=symbolic=(args.size()-1),!<=-1}
  " but only " always " but only "
  ( always {!<=-1,!>=symbolic=(n+1)}
  " arguments are available." always " arguments are available."
  "cppcheck-2.8/lib/valueflow.cpp" always "cppcheck-2.8/lib/valueflow.cpp"
  3738 always 3738
Line 3746
  n {!>=symbolic=(args.size()),<=symbolic=(args.size()-1),!<=-1}
Line 3747
  argtok2 always symbolic=(args[n])
  "Passed to '" always "Passed to '"
  "'." always "'."
Line 3751
  ( always {!<=-1,!>=2}
Line 3752
  ! always {!<=-1,!>=2}
Line 3753
  return always {!<=-1,!>=2}
  false always 0
Line 3754
  update always {!<=-1,!>=2}
  update always {!<=-1,!>=2}
  = always 0
  false always 0
Line 3755
  argtok always !0
Line 3756
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  . always {!<=-1,!>=2}
  inconclusive always {!<=-1,!>=2}
Line 3759
  er always symbolic=(errorPath)
  ( possible lifetime[Iterator]=(er)
  ( {lifetime[Iterator]=(er),end=0}
Line 3760
  ! always {!<=-1,!>=2}
Line 3761
  return always {!<=-1,!>=2}
  false always 0
Line 3762
  ! always {!<=-1,!>=2}
  . always !0
Line 3763
  return always {!<=-1,!>=2}
  false always 0
Line 3767
  = always 6
  :: always 6
  LIFETIME always 6
Line 3770
  er always !size=0
Line 3772
  . always {!<=-1,!>=2}
  inconclusive always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  inconclusive always {!<=-1,!>=2}
Line 3774
  ( possible lifetime[Iterator]=(tok->values())
  ( {lifetime[Iterator]=(tok->values()),start=0}
  ( {lifetime[Iterator]=(tok->values()),end=0}
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(tok->values()),end=0}
Line 3775
  return always {!<=-1,!>=2}
  false always 0
Line 3777
  update always {!<=-1,!>=2}
  = always 1
  true always 1
Line 3779
  update always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  forward always {!<=-1,!>=2}
Line 3781
  return always {!<=-1,!>=2}
  update {!<=-1,!>=2,1,0}
Line 3784
  ( always {!<=-1,!>=2}
Line 3785
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 3786
  true always 1
Line 3791
  ( always {!<=-1,!>=2}
Line 3792
  ! always {!<=-1,!>=2}
Line 3793
  return always {!<=-1,!>=2}
  false always 0
Line 3794
  update always {!<=-1,!>=2}
  update always {!<=-1,!>=2}
  = always 0
  false always 0
Line 3795
  argtok always !0
  ( always {!<=-1,!>=2}
Line 3797
  er always size=0
  argtok always !0
Line 3799
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  . always {!<=-1,!>=2}
  inconclusive always {!<=-1,!>=2}
Line 3802
  = always 6
  :: always 6
  LIFETIME always 6
Line 3807
  inconclusive always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  . always {!<=-1,!>=2}
  inconclusive always {!<=-1,!>=2}
Line 3809
  var always symbolic=(lt.token->variable())
  && always {!<=-1,!>=2}
  var {symbolic=(lt.token->variable()),!0}
  ( always {!<=-1,!>=2}
Line 3810
  = always 1
  :: always 1
  Argument always 1
Line 3815
  ( possible lifetime[Iterator]=(tok->values())
  ( {lifetime[Iterator]=(tok->values()),start=0}
  ( {lifetime[Iterator]=(tok->values()),end=0}
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(tok->values()),end=0}
Line 3819
  update always {!<=-1,!>=2}
  = always 1
  true always 1
Line 3823
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 3826
  tok3 always symbolic=(v.tokvalue)
Line 3827
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  . always {!<=-1,!>=2}
  inconclusive always {!<=-1,!>=2}
Line 3830
  er always symbolic=(v.errorPath)
  ( possible lifetime[Iterator]=(er)
  ( {lifetime[Iterator]=(er),end=0}
Line 3831
  ! always {!<=-1,!>=2}
Line 3832
  return always {!<=-1,!>=2}
  false always 0
Line 3833
  ! always {!<=-1,!>=2}
  . always !0
Line 3834
  return always {!<=-1,!>=2}
  false always 0
Line 3836
  er always !size=0
  ( possible lifetime[Iterator]=(er)
  ( {lifetime[Iterator]=(er),end=0}
  ( {lifetime[Iterator]=(errorPath),start=0}
  ( {lifetime[Iterator]=(errorPath),end=0}
Line 3839
  = always 6
  :: always 6
  LIFETIME always 6
Line 3846
  . always {!<=-1,!>=2}
  inconclusive always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  inconclusive always {!<=-1,!>=2}
Line 3848
  ( possible lifetime[Iterator]=(tok->values())
  ( {lifetime[Iterator]=(tok->values()),start=0}
  ( {lifetime[Iterator]=(tok->values()),end=0}
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(tok->values()),end=0}
Line 3851
  update always {!<=-1,!>=2}
  = always 1
  true always 1
Line 3854
  update always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  forward always {!<=-1,!>=2}
Line 3856
  return always {!<=-1,!>=2}
  update {!<=-1,!>=2,1,0}
Line 3859
  ( always {!<=-1,!>=2}
Line 3860
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 3861
  true always 1
Line 3867
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  inconclusive always {!<=-1,!>=2}
Line 3869
  ! always {!<=-1,!>=2}
Line 3871
  argtok always !0
Line 3872
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 3876
  tok2 always symbolic=(v.tokvalue)
  er always symbolic=(v.errorPath)
Line 3877
  ( possible lifetime[Iterator]=(er)
  ( {lifetime[Iterator]=(er),end=0}
  ( {lifetime[Iterator]=(errorPath),start=0}
  ( {lifetime[Iterator]=(errorPath),end=0}
Line 3878
  ! always {!<=-1,!>=2}
Line 3880
  && always {!<=-1,!>=2}
  tok3 always !0
  != always {!<=-1,!>=2}
  var always !0
Line 3881
  == always {!<=-1,!>=2}
  var always !0
Line 3882
  inconclusive always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 3891
  true always 1
Line 3899
  mContext always !0
Line 3900
  mContext always !0
Line 3901
  mContext always !0
Line 3902
  mContext always !0
Line 3916
  ! always {!<=-1,!>=2}
  constructor possible symbolic=(tok->function())@122
Line 3919
  i always !<=-1
  = always 0
  0 always 0
  i {!<=-1,0}
  < always {!<=-1,!>=2}
  ( always !<=-1
  i always !<=-1
  ++ always !<=-1
Line 3920
  i {!<=-1,<=symbolic=(args.size()-1),!>=symbolic=(args.size())}
  constructor always !0
  i {!<=-1,<=symbolic=(args.size()-1),!>=symbolic=(args.size())}
Line 3921
  constructor always !0
Line 3923
  initList always !0
  "," always ","
Line 3924
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "(" always "("
Line 3926
  ! always {!<=-1,!>=2}
Line 3928
  ! always {!<=-1,!>=2}
Line 3930
  ( always !0
Line 3931
  = always !0
  ( always !0
Line 3932
  ! always {!<=-1,!>=2}
  var always symbolic=(tok2->astOperand1()->variable())
Line 3934
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  expr {symbolic=(tok2->astOperand2()),!0}
Line 3937
  var always !0
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  var always !0
  ( always {!<=-1,!>=2}
Line 3938
  && always {!<=-1,!>=2}
  argvar always !0
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  argvar always !0
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  argvar always !0
  ( always {!<=-1,!>=2}
Line 3939
  argvar always !0
  = always 2
  :: always 2
  ByReference always 2
Line 3942
  found always {!<=-1,!>=2}
  found always {!<=-1,!>=2}
  = always 0
  false always 0
Line 3944
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 3946
  > always {!<=-1,!>=2}
  0 always 0
Line 3948
  ! always {!<=-1,!>=2}
Line 3950
  . always !0
Line 3951
  ! always {!<=-1,!>=2}
  lifeVar always symbolic=(v.tokvalue->variable())
Line 3953
  c possible 0
  = always 0
  :: always 0
  Undefined always 0
Line 3954
  ! {!<=-1,!>=2,1}
  ( {!<=-1,!>=2,0}
  && always {!<=-1,!>=2}
  lifeVar {symbolic=(v.tokvalue->variable()),!0}
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  lifeVar {symbolic=(v.tokvalue->variable()),!0}
  ( always {!<=-1,!>=2}
Line 3955
  = always 2
  :: always 2
  ByReference always 2
Line 3956
  ( always {!<=-1,!>=2}
Line 3957
  = always 1
  :: always 1
  ByValue always 1
Line 3958
  c possible {2,1}
  != {!<=-1,!>=2,1}
  :: always 0
  Undefined always 0
Line 3959
  lifeVar {symbolic=(v.tokvalue->variable()),!0}
  = {2,1,!0}
  c {2,1,!0}
Line 3960
  found always {!<=-1,!>=2}
  = always 1
  true always 1
Line 3963
  ! always {!<=-1,!>=2}
  found always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  argvar always !0
  ( always {!<=-1,!>=2}
Line 3964
  argvar always !0
  = always 1
  :: always 1
  ByValue always 1
Line 3969
  "Passed to constructor of '" always "Passed to constructor of '"
  "'." always "'."
Line 3970
  :: always 1
  SubObject always 1
Line 3971
  [ possible {lifetime[Lambda]=(argToParam),lifetime[Lambda]=(paramCapture)}
Line 3973
  ( always !<=-1
  paramVar always symbolic=(argToParam.at(ls.argtok))
  == always {!<=-1,!>=2}
  0 always 0
Line 3975
  paramVar always symbolic=(argToParam.at(ls.argtok))
Line 3976
  c always symbolic=(paramCapture.at(paramVar))
  == always {!<=-1,!>=2}
  :: always 2
  ByReference always 2
Line 3977
  ( always {!<=-1,!>=2}
Line 3979
  ( always {!<=-1,!>=2}
Line 3981
  ! always {!<=-1,!>=2}
  constructor always !0
  ( always {!<=-1,!>=2}
Line 3983
  "Passed to constructor of '" always "Passed to constructor of '"
  "'." always "'."
Line 3984
  :: always 1
  SubObject always 1
Line 3985
  [ possible lifetime[Lambda]=(argToParam)
Line 3986
  . always {!<=-1,!>=2}
  inconclusive always {!<=-1,!>=2}
  = always 1
  true always 1
Line 3988
  var always symbolic=(argToParam.at(ls.argtok))
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  var {symbolic=(argToParam.at(ls.argtok)),!0}
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  var {symbolic=(argToParam.at(ls.argtok)),!0}
  ( always {!<=-1,!>=2}
Line 3989
  ( always {!<=-1,!>=2}
Line 3991
  ( always {!<=-1,!>=2}
Line 3998
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "%name% (" always "%name% ("
Line 4000
  = always 0
  nullptr always 0
Line 4001
  ( always {!<=-1,!>=2}
  ". %name% (" always ". %name% ("
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 4004
  >= always {!<=-1,!>=2}
  0 always 0
Line 4006
  = always 1
  1 always 1
  argnr possible 1
  <= always {!<=-1,!>=2}
  ( always !<=-1
Line 4007
  argnr {<=symbolic=(args.size()),!>=symbolic=(args.size()+1),1}
Line 4008
  ! always {!<=-1,!>=2}
Line 4010
  i always !0
  != always {!<=-1,!>=2}
  returnContainer always !<=-1
Line 4012
  argnr possible 1
  - possible 0
  1 always 1
Line 4013
  forward always {!<=-1,!>=2}
  forward always {!<=-1,!>=2}
  = always 0
  false always 0
Line 4014
  argTok always symbolic=(args[argnr-1])
Line 4015
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 4017
  "Passed to '" always "Passed to '"
  "'." always "'."
Line 4019
  forward always {!<=-1,!>=2}
  = always 1
  true always 1
Line 4022
  forward always {!<=-1,!>=2}
Line 4027
  ( always {!<=-1,!>=2}
  -2 always -2
  "std :: ref|cref|tie|front_inserter|back_inserter" always "std :: ref|cref|tie|front_inserter|back_inserter"
Line 4029
  "Passed to '" always "Passed to '"
  "'." always "'."
  ( always {!<=-1,!>=2}
Line 4032
  ( always {!<=-1,!>=2}
  -2 always -2
  "std :: make_tuple|tuple_cat|make_pair|make_reverse_iterator|next|prev|move|bind" always "std :: make_tuple|tuple_cat|make_pair|make_reverse_iterator|next|prev|move|bind"
Line 4034
  "Passed to '" always "Passed to '"
  "'." always "'."
  ( always {!<=-1,!>=2}
Line 4037
  memtok possible 0
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  ". push_back|push_front|insert|push|assign" always ". push_back|push_front|insert|push|assign"
  && always {!<=-1,!>=2}
Line 4038
  ( always {!<=-1,!>=2}
  memtok always !0
Line 4040
  n always !<=-1
  n always !<=-1
  = {!<=-1,0}
  args possible size=0
  ( {!<=-1,0}
Line 4041
  n {symbolic=(args.size()),!<=-1,0}
  > {!<=-1,!>=2,0}
  1 always 1
  && always {!<=-1,!>=2}
  n {symbolic=(args.size()),>=2,!<=1}
  - {!<=-1,>=0}
  2 always 2
  == always {!<=-1,!>=2}
  n {symbolic=(args.size()),>=2,!<=1}
  - {>=1,!<=0}
  1 always 1
  && always {!<=-1,!>=2}
Line 4042
  ( always {!<=-1,!>=2}
  n {symbolic=(args.size()),>=2,!<=1}
  - {!<=-1,>=0}
  2 always 2
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  n {symbolic=(args.size()),!<=1}
  - always !<=0
  1 always 1
  || always {!<=-1,!>=2}
Line 4043
  ( always {!<=-1,!>=2}
  n {symbolic=(args.size()),!<=1}
  - always !<=-1
  2 always 2
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  n {symbolic=(args.size()),!<=1}
  - always !<=0
  1 always 1
Line 4045
  "Added to container '" always "Added to container '"
  memtok always !0
  "'." always "'."
Line 4046
  memtok always !0
Line 4047
  ! {!<=-1,!>=2,0}
  args possible size=0
  ( {!<=-1,!>=2,1}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  args always !size=0
Line 4049
  args always !size=0
  "Added to container '" always "Added to container '"
  memtok always !0
  "'." always "'."
Line 4050
  ( always {!<=-1,!>=2}
  memtok always !0
Line 4053
  = always !0
  ( always !0
Line 4054
  f {symbolic=(tok->function()),!0}
  ( always {!<=-1,!>=2}
Line 4055
  f {symbolic=(tok->function()),!0}
Line 4058
  ( always {!<=-1,!>=2}
  f {symbolic=(tok->function()),!0}
Line 4061
  inconclusive always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  ( always !<=-1
  > always {!<=-1,!>=2}
  1 always 1
Line 4062
  update always {!<=-1,!>=2}
  update always {!<=-1,!>=2}
  = always 0
  false always 0
Line 4064
  == always {!<=-1,!>=2}
Line 4066
  returnTok always !symbolic=(tok)
Line 4067
  && always {!<=-1,!>=2}
  returnVar always !0
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  returnVar always !0
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  returnVar always !0
  ( always {!<=-1,!>=2}
Line 4068
  tok always !symbolic=(returnTok)
  returnVar always !0
Line 4069
  . always {!<=-1,!>=2}
  inconclusive always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  inconclusive always {!<=-1,!>=2}
Line 4070
  . always {!<=-1,!>=2}
  forward always {!<=-1,!>=2}
  = always 0
  false always 0
Line 4071
  update always {!<=-1,!>=2}
  |= always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  tok always !symbolic=(returnTok)
Line 4073
  returnTok always !symbolic=(tok)
Line 4074
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 4076
  ! always {!<=-1,!>=2}
Line 4078
  && always {!<=-1,!>=2}
Line 4079
  :: always 3
  ThisPointer always 3
  :: always 4
  ThisValue always 4
Line 4080
  || always {!<=-1,!>=2}
Line 4081
  ( always {!<=-1,!>=2}
Line 4082
  memtok always !0
Line 4083
  "Passed to member function '" always "Passed to member function '"
  "'." always "'."
Line 4085
  . always {!<=-1,!>=2}
  inconclusive always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  inconclusive always {!<=-1,!>=2}
Line 4086
  . always {!<=-1,!>=2}
  forward always {!<=-1,!>=2}
  = always 0
  false always 0
Line 4088
  "Return " always "Return "
  & always !0
  "." always "."
Line 4089
  == always {!<=-1,!>=2}
  :: always 4
  ThisValue always 4
Line 4090
  update always {!<=-1,!>=2}
  |= always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 4092
  update always {!<=-1,!>=2}
  |= always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 4096
  var always symbolic=(v.tokvalue->variable())
Line 4097
  ! always {!<=-1,!>=2}
Line 4099
  . always {!<=-1,!>=2}
  forward always {!<=-1,!>=2}
  = always 0
  false always 0
Line 4100
  . always {!<=-1,!>=2}
  inconclusive always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  inconclusive always {!<=-1,!>=2}
Line 4102
  "Return " always "Return "
  & always !0
  "." always "."
Line 4103
  ! {!<=-1,!>=2,1}
  ( {!<=-1,!>=2,0}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 4104
  update always {!<=-1,!>=2}
  |= always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 4105
  ( always {!<=-1,!>=2}
Line 4106
  update always {!<=-1,!>=2}
  |= always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 4110
  update always {!<=-1,!>=2}
Line 4122
  ( always {!<=-1,!>=2}
Line 4124
  ! always {!<=-1,!>=2}
Line 4125
  return always {!<=-1,!>=2}
  false always 0
Line 4126
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  tok always !0
  "{" always "{"
Line 4127
  return always {!<=-1,!>=2}
  false always 0
Line 4128
  tok always !0
Line 4129
  ! always {!<=-1,!>=2}
  scope always symbolic=(tok->scope())
Line 4130
  return always {!<=-1,!>=2}
  false always 0
Line 4131
  ! always {!<=-1,!>=2}
  scope {symbolic=(tok->scope()),!0}
Line 4132
  return always {!<=-1,!>=2}
  false always 0
Line 4133
  return always {!<=-1,!>=2}
  scope always !0
  . always !0
  == always {!<=-1,!>=2}
Line 4138
  ! always {!<=-1,!>=2}
Line 4139
  nullptr always 0
Line 4140
  tok always !0
Line 4141
  ! always {!<=-1,!>=2}
  f always symbolic=(tok->function())
  && always {!<=-1,!>=2}
  tok always !0
Line 4142
  tok always !0
  ( always !0
Line 4144
  ! always {!<=-1,!>=2}
  f possible {symbolic=(tok->function()),symbolic=(tok->astOperand1()->function())}
  || always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  f always !0
  ( always {!<=-1,!>=2}
Line 4145
  = always 0
  nullptr always 0
Line 4148
  ( always !<=-1
  != always {!<=-1,!>=2}
  ( always !<=-1
Line 4150
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 4152
  candidates possible lifetime[Object]=(scope->functionList)
  & {lifetime[Address]=(scope->functionList),!0}
Line 4155
  ( always !<=-1
  == always {!<=-1,!>=2}
  1 always 1
Line 4156
  candidates always size=1
Line 4158
  ! always {!<=-1,!>=2}
  f possible symbolic=(candidates.front())
Line 4159
  nullptr always 0
Line 4160
  f always !0
Line 4169
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "(|{" always "(|{"
Line 4171
  ( always {!<=-1,!>=2}
Line 4173
  ! always {!<=-1,!>=2}
Line 4174
  && always {!<=-1,!>=2}
  ( always !0
  != always {!<=-1,!>=2}
  :: always 3
  RECORD always 3
Line 4176
  != always {!<=-1,!>=2}
  "{" always "{"
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "%var% (" always "%var% ("
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 4182
  "Passed to initializer list." always "Passed to initializer list."
Line 4183
  :: always 1
  SubObject always 1
Line 4184
  [ possible lifetime[Lambda]=(tok)
Line 4185
  . always {!<=-1,!>=2}
  inconclusive always {!<=-1,!>=2}
  = always 1
  true always 1
Line 4186
  ( always {!<=-1,!>=2}
Line 4190
  t always !0
Line 4191
  ! always {!<=-1,!>=2}
  scope always symbolic=(t->classScope)
Line 4194
  t always !0
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  t always !0
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  t always !0
  ( always {!<=-1,!>=2}
Line 4196
  scope {symbolic=(t->classScope),!0}
  == always {!<=-1,!>=2}
  0 always 0
Line 4197
  = {lifetime[Iterator]=(scope->varlist),start=0}
  scope {symbolic=(t->classScope),!0}
  ( {lifetime[Iterator]=(scope->varlist),start=0}
Line 4199
  "Passed to constructor of '" always "Passed to constructor of '"
  t always !0
  "'." always "'."
Line 4200
  :: always 1
  SubObject always 1
Line 4201
  [ possible {lifetime[Lambda]=(it),lifetime[Lambda]=(scope)}
Line 4202
  it possible lifetime[Iterator]=(scope->varlist)
  == always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(scope->varlist),end=0}
Line 4204
  it {lifetime[Iterator]=(scope->varlist),!symbolic=(scope->varlist.end()),!end=0}
Line 4205
  var always symbolic=(*it)
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  var always symbolic=(*it)
  ( always {!<=-1,!>=2}
Line 4206
  ( always {!<=-1,!>=2}
Line 4208
  ( always {!<=-1,!>=2}
Line 4210
  it {lifetime[Iterator]=(scope->varlist),!symbolic=(scope->varlist.end()),!end=0}
  ++ always !symbolic=(scope->varlist.end())
Line 4213
  scope {symbolic=(t->classScope),!0}
Line 4214
  t always !0
Line 4221
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "(|{" always "(|{"
Line 4223
  ( always {!<=-1,!>=2}
Line 4227
  ( always !0
Line 4228
  ( always {!<=-1,!>=2}
  "%var% {|(" always "%var% {|("
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 4230
  ( always !0
Line 4231
  ( always {!<=-1,!>=2}
  "{" always "{"
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "%name%" always "%name%"
Line 4235
  : possible {{,{}
  vts possible {{,size=1,{}
Line 4236
  > always {!<=-1,!>=2}
  0 always 0
Line 4239
  "Passed to initializer list." always "Passed to initializer list."
Line 4240
  :: always 1
  SubObject always 1
Line 4241
  [ possible lifetime[Lambda]=(tok)
Line 4242
  ( always {!<=-1,!>=2}
Line 4244
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 5
  CONTAINER always 5
Line 4246
  args possible size=2
  ( {!<=-1,2}
  == {!<=-1,!>=2,0}
  1 always 1
  && always {!<=-1,!>=2}
  . always {!<=-1,!>=2}
  view always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  args always size=1
Line 4247
  args always size=1
  "Passed to container view." always "Passed to container view."
  :: always 1
  SubObject always 1
Line 4248
  ( always {!<=-1,!>=2}
Line 4249
  ( always !<=-1
  == always {!<=-1,!>=2}
  2 always 2
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  args always size=2
  0 always 0
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  args always size=2
  1 always 1
Line 4251
  args always size=2
Line 4252
  "Passed to initializer list." always "Passed to initializer list."
Line 4253
  :: always 1
  SubObject always 1
Line 4254
  [ possible lifetime[Lambda]=(tok)
Line 4257
  . always {!<=-1,!>=2}
  hasInitializerListConstructor always {!<=-1,!>=2}
Line 4259
  "Passed to initializer list." always "Passed to initializer list."
Line 4260
  :: always 1
  SubObject always 1
Line 4261
  [ possible lifetime[Lambda]=(tok)
Line 4262
  ( always {!<=-1,!>=2}
Line 4266
  = always 0
  nullptr always 0
Line 4267
  && always {!<=-1,!>=2}
  . always !0
Line 4268
  = always !0
  . always !0
  . always !0
Line 4278
  nullptr always 0
Line 4279
  nullptr always 0
Line 4280
  nullptr always 0
Line 4281
  nullptr always 0
Line 4283
  :: always 0
  Undefined always 0
Line 4285
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "[" always "["
  || always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
Line 4289
  ( always {!<=-1,!>=2}
  "] (" always "] ("
Line 4292
  arguments always !0
Line 4293
  afterArguments always symbolic=(arguments?arguments->link()->next():capture->link()->next())
  && always {!<=-1,!>=2}
  afterArguments {symbolic=(arguments?arguments->link()->next():capture->link()->next()),!0}
  == always {!<=-1,!>=2}
  "->" always "->"
Line 4294
  afterArguments {symbolic=(arguments?arguments->link()->next():capture->link()->next()),!0}
Line 4295
  "{" always "{"
Line 4296
  ( always {!<=-1,!>=2}
  afterArguments {symbolic=(arguments?arguments->link()->next():capture->link()->next()),0}
  "{" always "{"
Line 4297
  = always symbolic=(arguments?arguments->link()->next():capture->link()->next())
  afterArguments always symbolic=(arguments?arguments->link()->next():capture->link()->next())
Line 4300
  ( always {!<=-1,!>=2}
  "this !!." always "this !!."
Line 4301
  :: always 2
  ByReference always 2
Line 4302
  ( always {!<=-1,!>=2}
  "* this" always "* this"
Line 4303
  :: always 1
  ByValue always 1
Line 4305
  :: always 1
  ByValue always 1
Line 4306
  ( always {!<=-1,!>=2}
  "&" always "&"
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "%var%" always "%var%"
Line 4308
  :: always 2
  ByReference always 2
Line 4311
  s {symbolic=(c->expressionString()),size=1}
  == always {!<=-1,!>=2}
  "=" always "="
Line 4312
  = always 1
  :: always 1
  ByValue always 1
Line 4313
  s always symbolic=(c->expressionString())
  == always {!<=-1,!>=2}
  "&" always "&"
Line 4314
  = always 2
  :: always 2
  ByReference always 2
Line 4330
  ( always {!<=-1,!>=2}
Line 4331
  return always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 4335
  ( always {!<=-1,!>=2}
Line 4337
  ! always {!<=-1,!>=2}
Line 4338
  return always {!<=-1,!>=2}
  false always 0
Line 4339
  ! always {!<=-1,!>=2}
  tok always !0
Line 4340
  return always {!<=-1,!>=2}
  false always 0
Line 4341
  ( always {!<=-1,!>=2}
  tok always !0
  ( always !0
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  tok always !0
  ( always !0
  "return" always "return"
Line 4342
  return always {!<=-1,!>=2}
  true always 1
Line 4343
  ( always !0
  ( always {!<=-1,!>=2}
Line 4344
  return always {!<=-1,!>=2}
  true always 1
Line 4345
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "return" always "return"
Line 4346
  return always {!<=-1,!>=2}
  false always 0
Line 4347
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 4350
  ( always {!<=-1,!>=2}
Line 4353
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(vtParents),start=0}
  ( {lifetime[Iterator]=(vtParents),end=0}
Line 4354
  ! always {!<=-1,!>=2}
Line 4355
  false always 0
Line 4356
  . always !0
  . always {!<=-1,!>=2}
  view always {!<=-1,!>=2}
Line 4363
  ! always {!<=-1,!>=2}
Line 4365
  ( always !0
  == always {!<=-1,!>=2}
  :: always 0
  eGlobal always 0
Line 4369
  ( always {!<=-1,!>=2}
Line 4375
  capturedThis always {!<=-1,!>=2}
  capturedThis always {!<=-1,!>=2}
  = always 0
  false always 0
Line 4377
  = possible lifetime[Lambda]=(varids)
  [ possible lifetime[Lambda]=(varids)
Line 4379
  ! always {!<=-1,!>=2}
  var always symbolic=(varTok->variable())
Line 4380
  false always 0
Line 4381
  ( always !<=-1
  var {symbolic=(varTok->variable()),!0}
  > always {!<=-1,!>=2}
  0 always 0
Line 4382
  false always 0
Line 4383
  ! always {!<=-1,!>=2}
  var always !0
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  var always !0
  ( always {!<=-1,!>=2}
Line 4384
  false always 0
Line 4386
  ! always {!<=-1,!>=2}
  scope always symbolic=(var->scope())
Line 4387
  false always 0
Line 4388
  ( always !<=-1
  scope {symbolic=(var->scope()),!0}
  > always {!<=-1,!>=2}
  0 always 0
Line 4389
  false always 0
Line 4390
  scope always !0
  ( always {!<=-1,!>=2}
Line 4391
  false always 0
Line 4394
  true always 1
Line 4397
  update always {!<=-1,!>=2}
  update always {!<=-1,!>=2}
  = always 0
  false always 0
Line 4398
  = possible {lifetime[Lambda]=(varids),lifetime[Lambda]=(tok),lifetime[Lambda]=(tokenlist)}
  [ possible {lifetime[Lambda]=(varids),lifetime[Lambda]=(tok),lifetime[Lambda]=(tokenlist)}
  ( always {!<=-1,!>=2}
Line 4399
  ( always !<=-1
  > always {!<=-1,!>=2}
  0 always 0
Line 4402
  c possible 1
  == {!<=-1,!>=2,0}
  :: always 2
  ByReference always 2
Line 4404
  "Lambda captures variable by reference here." always "Lambda captures variable by reference here."
  :: always 2
  Lambda always 2
Line 4405
  . always {!<=-1,!>=2}
  forward always {!<=-1,!>=2}
  = always 0
  false always 0
Line 4406
  update always {!<=-1,!>=2}
  |= always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 4407
  c always !2
  == always {!<=-1,!>=2}
  :: always 1
  ByValue always 1
Line 4409
  "Lambda captures variable by value here." always "Lambda captures variable by value here."
  :: always 2
  Lambda always 2
Line 4410
  . always {!<=-1,!>=2}
  forward always {!<=-1,!>=2}
  = always 0
  false always 0
Line 4411
  update always {!<=-1,!>=2}
  |= always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 4416
  = possible {lifetime[Lambda]=(capturedThis),lifetime[Lambda]=(tok),lifetime[Lambda]=(tokenlist)}
  [ possible {lifetime[Lambda]=(capturedThis),lifetime[Lambda]=(tok),lifetime[Lambda]=(tokenlist)}
Line 4418
  = always 6
  :: always 6
  LIFETIME always 6
Line 4419
  c possible 1
  == {!<=-1,!>=2,0}
  :: always 2
  ByReference always 2
Line 4420
  = always 3
  :: always 3
  ThisPointer always 3
Line 4421
  c always !2
  == always {!<=-1,!>=2}
  :: always 1
  ByValue always 1
Line 4422
  = always 4
  :: always 4
  ThisValue always 4
Line 4424
  "Lambda captures the 'this' variable here." always "Lambda captures the 'this' variable here."
Line 4425
  = always 2
  :: always 2
  Lambda always 2
Line 4426
  capturedThis always {!<=-1,!>=2}
  = always 1
  true always 1
Line 4428
  ( possible lifetime[Iterator]=(tok->values())
  ( {lifetime[Iterator]=(tok->values()),start=0}
  ( {lifetime[Iterator]=(tok->values()),end=0}
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(tok->values()),end=0}
Line 4431
  update always {!<=-1,!>=2}
  |= always {!<=-1,!>=2}
  true always 1
Line 4439
  ( always {!<=-1,!>=2}
  tok2 always symbolic=(p.second.first)
  "this !!." always "this !!."
Line 4440
  captureThisVariable possible {lifetime[Lambda]=(capturedThis),lifetime[Lambda]=(tok),lifetime[Lambda]=(tokenlist)}
Line 4442
  captureVariable possible {lifetime[Lambda]=(varids),lifetime[Lambda]=(tok),lifetime[Lambda]=(tokenlist)}
Line 4443
  true always 1
Line 4445
  var always !0
Line 4449
  = possible lifetime[Lambda]=(capturedThis)
  [ possible lifetime[Lambda]=(capturedThis)
Line 4450
  capturedThis always {!<=-1,!>=2}
Line 4451
  false always 0
Line 4452
  ( always {!<=-1,!>=2}
  "this" always "this"
Line 4453
  true always 1
Line 4455
  ( always {!<=-1,!>=2}
  "." always "."
Line 4456
  false always 0
Line 4457
  = always !0
  ( always !0
Line 4458
  var {symbolic=(tok2->variable()),!0}
  ( always {!<=-1,!>=2}
Line 4459
  false always 0
Line 4460
  var always symbolic=(tok2->variable())
  ( always {!<=-1,!>=2}
Line 4461
  false always 0
Line 4462
  ( always {!<=-1,!>=2}
Line 4463
  ( always {!<=-1,!>=2}
  "(" always "("
Line 4464
  ( always {!<=-1,!>=2}
Line 4466
  false always 0
Line 4469
  != always {!<=-1,!>=2}
Line 4470
  isImplicitCapturingThis possible lifetime[Lambda]=(capturedThis)
Line 4471
  captureThisVariable possible {lifetime[Lambda]=(capturedThis),lifetime[Lambda]=(tok),lifetime[Lambda]=(tokenlist)}
  :: always 2
  ByReference always 2
Line 4473
  captureVariable possible {lifetime[Lambda]=(varids),lifetime[Lambda]=(tok),lifetime[Lambda]=(tokenlist)}
  isImplicitCapturingVariable inconclusive lifetime[Lambda]=(varids)
Line 4476
  update always {!<=-1,!>=2}
Line 4480
  ( always {!<=-1,!>=2}
  "&" always "&"
Line 4482
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  . always {!<=-1,!>=2}
  inconclusive always {!<=-1,!>=2}
Line 4485
  "Address of variable taken here." always "Address of variable taken here."
Line 4488
  = always 6
  :: always 6
  LIFETIME always 6
Line 4492
  . always {!<=-1,!>=2}
  addressOf always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  ".|[" always ".|["
Line 4493
  = always 4
  :: always 4
  Address always 4
Line 4494
  . always {!<=-1,!>=2}
  inconclusive always {!<=-1,!>=2}
Line 4501
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 4503
  "Converted to container view" always "Converted to container view"
  :: always 1
  SubObject always 1
Line 4504
  ( always {!<=-1,!>=2}
Line 4508
  ( always {!<=-1,!>=2}
Line 4510
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  ". %name% (" always ". %name% ("
Line 4513
  isContainerOfPointers always {!<=-1,!>=2}
  isContainerOfPointers always {!<=-1,!>=2}
  = always 1
  true always 1
Line 4515
  containerTypeToken always symbolic=(tok->valueType()->containerTypeToken)
Line 4516
  containerTypeToken {symbolic=(tok->valueType()->containerTypeToken),!0}
Line 4517
  isContainerOfPointers always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  > always {!<=-1,!>=2}
  0 always 0
Line 4521
  = always 6
  :: always 6
  LIFETIME always 6
Line 4524
  ( always {!<=-1,!>=2}
  2 always 2
Line 4525
  2 always 2
  "Iterator to container is created here." always "Iterator to container is created here."
Line 4526
  = always 3
  :: always 3
  Iterator always 3
Line 4527
  ( always {!<=-1,!>=2}
  2 always 2
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  isContainerOfPointers always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
Line 4528
  ( always {!<=-1,!>=2}
  "data|c_str" always "data|c_str"
Line 4529
  2 always 2
  "Pointer to container is created here." always "Pointer to container is created here."
Line 4536
  ( always {!<=-1,!>=2}
  "*" always "*"
  || always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  "->" always "->"
Line 4538
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 4540
  != always {!<=-1,!>=2}
  :: always 4
  Address always 4
Line 4542
  ! always {!<=-1,!>=2}
Line 4544
  . always !0
Line 4546
  ( always {!<=-1,!>=2}
Line 4548
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 4550
  ! always {!<=-1,!>=2}
Line 4552
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  . always !0
Line 4560
  : possible {
  toks possible {{,size=1}
Line 4561
  false always 0
Line 4563
  value always symbolic=(master)
Line 4564
  ( possible {lifetime[Iterator]=(value.errorPath),lifetime[Object]=(errorPath)}
  ( {lifetime[Iterator]=(value.errorPath),lifetime[Object]=(errorPath),start=0}
  ( {lifetime[Iterator]=(rt.errors),lifetime[Object]=(errors),start=0}
  ( {lifetime[Iterator]=(rt.errors),lifetime[Object]=(errors),end=0}
Line 4565
  2 always 2
Line 4567
  ! always {!<=-1,!>=2}
Line 4570
  ( always {!<=-1,!>=2}
  2 always 2
Line 4574
  2 always 2
Line 4577
  ( always {!<=-1,!>=2}
  "=|return|%name%|{|,|> {" always "=|return|%name%|{|,|> {"
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 4581
  ( always {!<=-1,!>=2}
  "%name% (" always "%name% ("
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  ") {" always ") {"
Line 4585
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  ". get ( )" always ". get ( )"
Line 4586
  2 always 2
Line 4587
  "Raw pointer to smart pointer created here." always "Raw pointer to smart pointer created here."
Line 4589
  = always 6
  :: always 6
  LIFETIME always 6
Line 4591
  = always 1
  :: always 1
  SubObject always 1
Line 4593
  = always {{,size=1}
  errorPath always {{,size=1}
Line 4600
  errorPath always size=0
Line 4601
  ! always {!<=-1,!>=2}
Line 4603
  var always !0
  == always {!<=-1,!>=2}
Line 4605
  var always !0
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  var always !0
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  var always !0
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  tok always !symbolic=(var->nameToken())
Line 4606
  tok always !symbolic=(var->nameToken())
  "Array decayed to pointer here." always "Array decayed to pointer here."
Line 4609
  = always 6
  :: always 6
  LIFETIME always 6
Line 4611
  var always !0
Line 4619
  ( always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(tok->values()),start=0}
  ( {lifetime[Iterator]=(tok->values()),end=0}
  & {lifetime[Address]=(isLifetimeValue),!0}
Line 4625
  ( always {!<=-1,!>=2}
  , always 0
  = always 0
  nullptr always 0
Line 4627
  != always {!<=-1,!>=2}
  "std" always "std"
Line 4628
  return always {!<=-1,!>=2}
  false always 0
Line 4630
  = always 0
  nullptr always 0
Line 4631
  ( always {!<=-1,!>=2}
  "std :: move ( %var% )" always "std :: move ( %var% )"
Line 4632
  4 always 4
Line 4633
  = always 1
  :: always 1
  MovedVariable always 1
Line 4634
  ( always {!<=-1,!>=2}
  "std :: forward <" always "std :: forward <"
Line 4635
  3 always 3
Line 4637
  ( always {!<=-1,!>=2}
  rightAngle always symbolic=(leftAngle->link())
  "> ( %var% )" always "> ( %var% )"
Line 4638
  rightAngle always symbolic=(leftAngle->link())
  2 always 2
Line 4639
  = always 2
  :: always 2
  ForwardedVariable always 2
Line 4642
  ! always {!<=-1,!>=2}
Line 4643
  return always {!<=-1,!>=2}
  false always 0
Line 4644
  variableToken always !0
  2 always 2
  == always {!<=-1,!>=2}
  "." always "."
Line 4645
  return always {!<=-1,!>=2}
  false always 0
Line 4646
  variableToken always !0
  && always {!<=-1,!>=2}
  variableToken always !0
  ( always !0
  >= always {!<=-1,!>=2}
  :: always 7
  VOID always 7
Line 4647
  return always {!<=-1,!>=2}
  false always 0
Line 4648
  != always {!<=-1,!>=2}
  nullptr always 0
Line 4649
  moveKind always !0
Line 4650
  != always {!<=-1,!>=2}
  nullptr always 0
Line 4651
  varTok always !0
Line 4652
  return always {!<=-1,!>=2}
  true always 1
Line 4655
  ( always {!<=-1,!>=2}
Line 4657
  openParenthesisToken possible symbolic=(tok->astParent())@143
  -3 always -3
Line 4658
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "%varid% . %name% (" always "%varid% . %name% ("
  varId possible symbolic=(varTok->varId())@143
  && always {!<=-1,!>=2}
Line 4659
  ( always {!<=-1,!>=2}
Line 4665
  tok possible symbolic=(moveVarTok)
  && always {!<=-1,!>=2}
  tok {symbolic=(moveVarTok),!0}
  != always {!<=-1,!>=2}
  "(" always "("
Line 4666
  tok always !0
Line 4667
  tok possible {symbolic=(moveVarTok),0}
Line 4672
  ! always {!<=-1,!>=2}
Line 4673
  nullptr always 0
Line 4674
  parameterToken always !0
Line 4675
  parent possible {symbolic=(parameterToken->astParent()),0}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  parent {symbolic=(parameterToken->astParent()),!0}
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  parent {symbolic=(parameterToken->astParent()),!0}
  != always {!<=-1,!>=2}
  "(" always "("
Line 4676
  parent always !0
Line 4677
  ! {!<=-1,!>=2,1}
  parent possible {symbolic=(parameterToken->astParent()),0}
Line 4678
  nullptr always 0
Line 4679
  parent always !0
Line 4684
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  < always {!<=-1,!>=2}
  :: always 1
  CPP11 always 1
Line 4687
  ! always {!<=-1,!>=2}
Line 4689
  scope always !0
Line 4690
  scope always !0
Line 4691
  scope always !0
  . always !0
Line 4692
  memberInitializationTok always symbolic=(scope->function->constructorMemberInitialization())
Line 4693
  = {symbolic=(scope->function->constructorMemberInitialization()),!0}
  memberInitializationTok {symbolic=(scope->function->constructorMemberInitialization()),!0}
Line 4696
  = possible {symbolic=(scope->bodyStart),symbolic=(memberInitializationTok),symbolic=(scope->function->constructorMemberInitialization())}
  ( possible {symbolic=(scope->bodyStart),symbolic=(memberInitializationTok),symbolic=(scope->function->constructorMemberInitialization())}
  start possible {symbolic=(scope->bodyStart),symbolic=(memberInitializationTok),symbolic=(scope->function->constructorMemberInitialization())}
  tok inconclusive {symbolic=(scope->bodyStart),symbolic=(memberInitializationTok),symbolic=(scope->function->constructorMemberInitialization())}
  != always {!<=-1,!>=2}
  scope always !0
Line 4698
  ( always {!<=-1,!>=2}
  "%var% . reset|clear (" always "%var% . reset|clear ("
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 4701
  = always 3
  :: always 3
  MOVED always 3
Line 4703
  tok always symbolic=(varTok)
  "Calling " always "Calling "
  tok inconclusive symbolic=(varTok)
  " makes " always " makes "
  tok inconclusive symbolic=(varTok)
  " 'non-moved'" always " 'non-moved'"
Line 4706
  values always size=0
Line 4709
  ! {!<=-1,!>=2,1}
  var {symbolic=(varTok->variable()),0}
  || always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  var {symbolic=(varTok->variable()),!0}
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  var {symbolic=(varTok->variable()),!0}
  ( always {!<=-1,!>=2}
Line 4711
  var {symbolic=(varTok->variable()),!0}
Line 4713
  values always !size=0
Line 4717
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  & {lifetime[Address]=(moveKind),!0,Uninit*}
  moveKind {1,Uninit}
  & {lifetime[Address]=(varTok),!0,Uninit*}
  varTok always Uninit
Line 4722
  parent possible {symbolic=(tok->astParent()),0}
  && always {!<=-1,!>=2}
  parent {symbolic=(tok->astParent()),!0}
  != always {!<=-1,!>=2}
  "=" always "="
  && always {!<=-1,!>=2}
  parent {symbolic=(tok->astParent()),!0}
  != always {!<=-1,!>=2}
  "return" always "return"
  && always {!<=-1,!>=2}
Line 4723
  ! always {!<=-1,!>=2}
  parent possible symbolic=(tok->astParent())
  == always {!<=-1,!>=2}
  "(" always "("
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  parent possible symbolic=(tok->astParent())
  varId always symbolic=(varTok->varId())
Line 4724
  parent always !0
Line 4725
  parent possible {symbolic=(tok->astParent()),0}
  && always {!<=-1,!>=2}
Line 4726
  parent always !0
  == always {!<=-1,!>=2}
  "return" always "return"
  || always {!<=-1,!>=2}
Line 4727
  parent always !0
  == always {!<=-1,!>=2}
  "(" always "("
Line 4729
  parent possible 0
  && always {!<=-1,!>=2}
  parent always !0
  && always {!<=-1,!>=2}
  parent always !0
  ( always !0
  == always {!<=-1,!>=2}
  varId always symbolic=(varTok->varId())
Line 4732
  ! {!<=-1,!>=2,1}
  var {symbolic=(varTok->variable()),0}
Line 4734
  var {symbolic=(varTok->variable()),!0}
Line 4737
  = always 3
  :: always 3
  MOVED always 3
Line 4738
  = possible 1
  moveKind possible 1
Line 4739
  == always {!<=-1,!>=2}
  :: always 1
  MovedVariable always 1
Line 4740
  "Calling std::move(" always "Calling std::move("
  ")" always ")"
Line 4742
  "Calling std::forward(" always "Calling std::forward("
  ")" always ")"
Line 4745
  values always size=0
Line 4750
  ( always !0
  endOfFunctionCall always !0
  endOfVarScope always symbolic=(var->scope()->bodyEnd)
  values always size=1
Line 4757
  != always {!<=-1,!>=2}
Line 4758
  ( always {!<=-1,!>=2}
Line 4761
  nullptr always 0
Line 4764
  , always {!<=-1,!>=2}
  assume always {!<=-1,!>=2}
Line 4766
  val possible {1@98,0@100}
Line 4769
  assume {!<=-1,!>=2,1@98,0@107}
Line 4770
  "Assuming condition '" always "Assuming condition '"
  "' is true" always "' is true"
Line 4772
  "Assuming condition '" always "Assuming condition '"
  "' is false" always "' is false"
Line 4779
  == always {!<=-1,!>=2}
  op possible {"&&"@97,"||"@102}
Line 4780
  op always symbolic=(tok->str())
Line 4781
  ( {lifetime[Iterator]=(args),start=0}
  ( {lifetime[Iterator]=(args),end=0}
  ( possible lifetime[Object]=(conds)
  conds always {{,size=1}
Line 4782
  == always {!<=-1,!>=2}
  0 always 0
Line 4783
  false always 0
Line 4784
  ( always {!<=-1,!>=2}
Line 4785
  false always 0
Line 4786
  ( always {!<=-1,!>=2}
  "%var%|." always "%var%|."
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 4787
  false always 0
Line 4788
  true always 1
Line 4791
  conds {{,size=1}
Line 4799
  incompleteTok always !0
  ( always {!<=-1,!>=2}
Line 4800
  . always {!<=-1,!>=2}
  debugwarnings always {!<=-1,!>=2}
Line 4801
  "valueFlowBailoutIncompleteVar" always "valueFlowBailoutIncompleteVar"
  incompleteTok always !0
  "Skipping function due to incomplete variable " always "Skipping function due to incomplete variable "
  incompleteTok always !0
  "cppcheck-2.8/lib/valueflow.cpp" always "cppcheck-2.8/lib/valueflow.cpp"
  4801 always 4801
Line 4806
  != always {!<=-1,!>=2}
Line 4807
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "if (" always "if ("
Line 4810
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  parenTok always symbolic=(tok->next())
  ") {" always ") {"
Line 4812
  parenTok always symbolic=(tok->next())
  1 always 1
Line 4813
  parenTok always symbolic=(tok->next())
Line 4814
  condTok always symbolic=(parenTok->astOperand2())
  == always {!<=-1,!>=2}
  0 always 0
Line 4816
  condTok always symbolic=(parenTok->astOperand2())
  ( always {!<=-1,!>=2}
Line 4818
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  true always 1
  ( always {!<=-1,!>=2}
Line 4820
  is1 always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 14
  eLogicalOp always 14
  || always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 4825
  "&&" always "&&"
Line 4826
  is1 {!<=-1,!>=2,1,0}
Line 4827
  1 always 1
  true always 1
Line 4828
  startTok always symbolic=(blockTok)
  startTok always symbolic=(blockTok)
Line 4831
  true always 1
  0 always 0
  true always 1
Line 4832
  startTok always symbolic=(blockTok)
  startTok always symbolic=(blockTok)
Line 4836
  "||" always "||"
Line 4839
  ( always {!<=-1,!>=2}
  startTok always symbolic=(blockTok)
  "} else {" always "} else {"
Line 4840
  startTok always symbolic=(blockTok)
  2 always 2
Line 4842
  0 always 0
  false always 0
Line 4845
  is1 {!<=-1,!>=2,1,0}
Line 4846
  true always 1
  1 always 1
  false always 0
Line 4853
  ( always {!<=-1,!>=2}
Line 4855
  0 always 0
  false always 0
Line 4858
  is1 {!<=-1,!>=2,1,0}
Line 4859
  true always 1
  1 always 1
  false always 0
Line 4869
  ( always {!<=-1,!>=2}
Line 4871
  > always {!<=-1,!>=2}
  0 always 0
  || always {!<=-1,!>=2}
  > always {!<=-1,!>=2}
  0 always 0
Line 4872
  return always {!<=-1,!>=2}
  . possible >=1
  != {!<=-1,!>=2,0}
  . possible >=1
Line 4873
  && always {!<=-1,!>=2}
Line 4874
  return always {!<=-1,!>=2}
  false always 0
Line 4875
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 4876
  srcSize always !<=-1
  srcSize always !<=-1
  = always !<=-1
  ( always !<=-1
Line 4877
  dstSize always !<=-1
  dstSize always !<=-1
  = always !<=-1
  ( always !<=-1
Line 4878
  srcSize {!<=-1,symbolic=(dstSize)}
  > {!<=-1,!>=2,0}
  dstSize {!<=-1,symbolic=(srcSize)}
Line 4879
  return always {!<=-1,!>=2}
  true always 1
Line 4880
  srcSize {!<=-1,!>=symbolic=(dstSize+1),<=symbolic=(dstSize)}
  == always {!<=-1,!>=2}
  dstSize {!<=-1,!<=symbolic=(srcSize-1),>=symbolic=(srcSize)}
  && always {!<=-1,!>=2}
  != always {!<=-1,!>=2}
Line 4881
  return always {!<=-1,!>=2}
  true always 1
Line 4882
  . possible 3
  == always {!<=-1,!>=2}
Line 4883
  . always symbolic=(dst->type)
  == always {!<=-1,!>=2}
  :: always 3
  RECORD always 3
Line 4884
  return always {!<=-1,!>=2}
  != always {!<=-1,!>=2}
Line 4886
  return always {!<=-1,!>=2}
  true always 1
Line 4888
  return always {!<=-1,!>=2}
  false always 0
Line 4893
  && always {!<=-1,!>=2}
  tok always !0
  > always {!<=-1,!>=2}
  0 always 0
  && always {!<=-1,!>=2}
  "Missing expr id for symbolic value" always "Missing expr id for symbolic value"
Line 4894
  = always 10
  :: always 10
  SYMBOLIC always 10
Line 4898
  , always 0
  = always 0
  0 always 0
Line 4903
  = possible 0
  delta possible 0
Line 4910
  [ possible lifetime[Lambda]=(result)
Line 4911
  > always {!<=-1,!>=2}
  0 always 0
Line 4912
  ( {>=1,!<=0}
Line 4913
  :: always 3
  op1_and_op2 always 3
Line 4921
  != always {!<=-1,!>=2}
Line 4922
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "=" always "="
Line 4926
  ! always {!<=-1,!>=2}
Line 4928
  ! always {!<=-1,!>=2}
Line 4930
  ( always {!<=-1,!>=2}
Line 4932
  ( always {!<=-1,!>=2}
Line 4934
  == always {!<=-1,!>=2}
  0 always 0
Line 4936
  == always {!<=-1,!>=2}
  0 always 0
Line 4938
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  true always 1
  ( always {!<=-1,!>=2}
Line 4940
  && always {!<=-1,!>=2}
Line 4941
  ( always {!<=-1,!>=2}
Line 4942
  ( always !0
Line 4944
  ( always {!<=-1,!>=2}
Line 4949
  ( always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(vars),start=0}
  ( {lifetime[Iterator]=(vars),end=0}
Line 4950
  ( always !<=-1
  > always {!<=-1,!>=2}
  0 always 0
Line 4951
  true always 1
Line 4954
  ! always {!<=-1,!>=2}
Line 4968
  " is assigned '" always " is assigned '"
Line 4969
  "' here." always "' here."
Line 4974
  " is assigned '" always " is assigned '"
Line 4975
  "' here." always "' here."
Line 4984
  ( always {!<=-1,!>=2}
Line 4986
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "*|/|<<|>>|^|+|-|%or%" always "*|/|<<|>>|^|+|-|%or%"
Line 4988
  ! always {!<=-1,!>=2}
Line 4990
  ! always {!<=-1,!>=2}
Line 4992
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  false always 0
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  false always 0
Line 4994
  = always 0
  nullptr always 0
Line 4995
  = always 0
  nullptr always 0
Line 4996
  ( always {!<=-1,!>=2}
Line 4997
  = always !0
  & always !0
Line 5000
  ( possible symbolic=(vartok)
  ( always {!<=-1,!>=2}
Line 5001
  = always !0
  & always !0
Line 5004
  ! always {!<=-1,!>=2}
Line 5006
  ! always {!<=-1,!>=2}
Line 5008
  vartok always !0
  == always {!<=-1,!>=2}
  0 always 0
Line 5010
  ( always {!<=-1,!>=2}
  "<<|>>|/" always "<<|>>|/"
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  vartok always !0
Line 5012
  ( always {!<=-1,!>=2}
  "<<|>>|^|+|-|%or%" always "<<|>>|^|+|-|%or%"
  && always {!<=-1,!>=2}
  != always {!<=-1,!>=2}
  0 always 0
Line 5014
  ( always {!<=-1,!>=2}
  "*|/" always "*|/"
  && always {!<=-1,!>=2}
  != always {!<=-1,!>=2}
  1 always 1
Line 5019
  ( {lifetime[Iterator]=(vartok->values()),start=0}
  ( {lifetime[Iterator]=(vartok->values()),end=0}
  ( possible lifetime[Object]=(values)
  values always {{,size=1}
  [ possible lifetime[Lambda]=(ids)
Line 5020
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 5021
  false always 0
Line 5022
  ! always {!<=-1,!>=2}
Line 5023
  false always 0
Line 5024
  . always !0
Line 5026
  : inconclusive {
  values inconclusive {
Line 5034
  != always {!<=-1,!>=2}
Line 5035
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "abs|labs|llabs|fabs|fabsf|fabsl (" always "abs|labs|llabs|fabs|fabsf|fabsl ("
Line 5037
  ( always {!<=-1,!>=2}
Line 5041
  ! always {!<=-1,!>=2}
  arg always symbolic=(tok->next()->astOperand2())
Line 5043
  ">=" always ">="
  arg {symbolic=(tok->next()->astOperand2()),!0}
  0 always 0
Line 5044
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 5047
  arg always !0
Line 5049
  "Passed to " always "Passed to "
Line 5050
  == always {!<=-1,!>=2}
  0 always 0
Line 5062
  != always {!<=-1,!>=2}
  0 always 0
Line 5064
  ( always {!<=-1,!>=2}
Line 5066
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  . always !0
  == always {!<=-1,!>=2}
Line 5071
  = always 10
  :: always 10
  SYMBOLIC always 10
Line 5081
  != always {!<=-1,!>=2}
Line 5082
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "-|%comp%" always "-|%comp%"
Line 5084
  ( always {!<=-1,!>=2}
Line 5086
  ! always {!<=-1,!>=2}
Line 5088
  ! always {!<=-1,!>=2}
Line 5090
  == always {!<=-1,!>=2}
  0 always 0
Line 5092
  == always {!<=-1,!>=2}
  0 always 0
Line 5094
  ( always {!<=-1,!>=2}
Line 5096
  ( always {!<=-1,!>=2}
Line 5098
  ( always {!<=-1,!>=2}
  false always 0
Line 5100
  ( always {!<=-1,!>=2}
  false always 0
Line 5104
  0 always 0
Line 5105
  ( always {!<=-1,!>=2}
Line 5107
  0 always 0
Line 5123
  != always {!<=-1,!>=2}
Line 5124
  == always {!<=-1,!>=2}
Line 5132
  == always {!<=-1,!>=2}
Line 5134
  refs possible {>=size=2,<=size=1}
  ( {!<=-1,>=2,<=1}
  > {!<=-1,!>=2,>=1,<=0}
  1 always 1
Line 5136
  ( possible {lifetime[Iterator]=(value.errorPath),lifetime[Object]=(errorPath)}
  ( {lifetime[Iterator]=(value.errorPath),lifetime[Object]=(errorPath),end=0}
  ( {lifetime[Iterator]=(ref.errors),lifetime[Object]=(errors),start=0}
  ( {lifetime[Iterator]=(ref.errors),lifetime[Object]=(errors),end=0}
Line 5144
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 5146
  ! always {!<=-1,!>=2}
Line 5148
  . always !0
  != always {!<=-1,!>=2}
Line 5151
  != always {!<=-1,!>=2}
  0 always 0
Line 5152
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 5154
  . always !0
Line 5158
  ( possible {lifetime[Iterator]=(value.errorPath),lifetime[Object]=(errorPath)}
  ( {lifetime[Iterator]=(value.errorPath),lifetime[Object]=(errorPath),end=0}
  ( {lifetime[Iterator]=(v.errorPath),lifetime[Object]=(errorPath),start=0}
  ( {lifetime[Iterator]=(v.errorPath),lifetime[Object]=(errorPath),end=0}
Line 5170
  , always {!<=-1,!>=2}
Line 5171
  init always {!<=-1,!>=2}
Line 5176
  ( always {!<=-1,!>=2}
  tok possible {symbolic=(ftok->astOperand2())@186,symbolic=(var->nameToken())@43946}
  "return" always "return"
Line 5179
  ( always {!<=-1,!>=2}
  values possible {symbolic=(args[0]->values())@80,size=1@182}
  ( {lifetime[Iterator]=(values),start=0}
  ( {lifetime[Iterator]=(values),end=0}
  & {lifetime[Address]=(isLifetimeValue),!0}
Line 5181
  & {lifetime[Address]=(isLifetimeValue),!0}
Line 5183
  ( always {!<=-1,!>=2}
Line 5184
  vars possible size=1
  ( {lifetime[Iterator]=(vars),size=1,start=0}
  vars possible size=1
  ( {lifetime[Iterator]=(vars),size=1,end=0}
Line 5185
  ! always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
Line 5187
  & {lifetime[Address]=(isTokValue),!0}
Line 5190
  :: possible {"never ","less than ","greater than "}
  valueKind possible {size=0,"never ",size=6,"less than ",size=10,"greater than ",size=13}
Line 5191
  == always {!<=-1,!>=2}
  :: always 3
  Impossible always 3
Line 5192
  . possible {1,0}
  == always {!<=-1,!>=2}
Line 5193
  = always "never "
  "never " always "never "
Line 5194
  . possible 0
  == {!<=-1,!>=2,0}
  :: always 1
  Lower always 1
Line 5195
  = always "less than "
  "less than " always "less than "
Line 5196
  . always !1
  == always {!<=-1,!>=2}
  :: always 0
  Upper always 0
Line 5197
  = always "greater than "
  "greater than " always "greater than "
Line 5199
  "Assignment '" always "Assignment '"
  "', assigned value is " always "', assigned value is "
  valueKind possible {size=0,"never ",size=6,"less than ",size=10,"greater than ",size=13}
Line 5204
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always !<=-1
  == always {!<=-1,!>=2}
  1 always 1
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  vars always size=1
  "bool|_Bool" always "bool|_Bool"
Line 5206
  ( always {!<=-1,!>=2}
Line 5208
  ( always {!<=-1,!>=2}
Line 5209
  = always {!<=-1,!>=2}
  != always {!<=-1,!>=2}
  0 always 0
Line 5210
  ( always {!<=-1,!>=2}
Line 5211
  = always {!<=-1,!>=2}
  != always {!<=-1,!>=2}
  nullptr always 0
Line 5216
  vars possible size=1
  ( {!<=-1,1}
  == {!<=-1,!>=2,1}
  1 always 1
  && always {!<=-1,!>=2}
  vars always size=1
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  init always {!<=-1,!>=2}
Line 5220
  ( always {!<=-1,!>=2}
  vars possible size=1
  ( {lifetime[Iterator]=(vars),size=1,start=0}
  vars possible size=1
  ( {lifetime[Iterator]=(vars),size=1,end=0}
Line 5226
  ( always !0
Line 5227
  ! always {!<=-1,!>=2}
Line 5231
  ( always {!<=-1,!>=2}
Line 5233
  ( always {!<=-1,!>=2}
Line 5238
  && always {!<=-1,!>=2}
  ( always !0
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always !0
  ( always {!<=-1,!>=2}
Line 5239
  = possible lifetime[Iterator]=(values)
  ( possible lifetime[Iterator]=(values)
  ( {lifetime[Iterator]=(values),start=0}
  ( {lifetime[Iterator]=(values),end=0}
Line 5240
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 5241
  false always 0
Line 5242
  ( always {!<=-1,!>=2}
Line 5243
  true always 1
Line 5244
  ( always {!<=-1,!>=2}
Line 5245
  true always 1
Line 5246
  ( always {!<=-1,!>=2}
Line 5247
  true always 1
Line 5248
  ( always {!<=-1,!>=2}
Line 5249
  true always 1
Line 5250
  false always 0
Line 5253
  constValues always size=0
  ( {lifetime[Iterator]=(constValues),end=0}
  it possible lifetime[Iterator]=(values)
  ( {lifetime[Iterator]=(values),end=0}
Line 5254
  ( always !0
Line 5262
  , always {!<=-1,!>=2}
Line 5263
  init always {!<=-1,!>=2}
Line 5268
  tok possible {symbolic=(tok->next()->astOperand2())@169,symbolic=(var->nameToken())@171}
  var possible symbolic=(tok->variable())@169
  { possible lifetime[SubObject]=(var)
  var possible symbolic=(tok->variable())@169
  values possible size=1@171
  init {!<=-1,!>=2,1@171}
Line 5276
  ! always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  dst always !0
  ( always {!<=-1,!>=2}
Line 5279
  sz always !<=-1
  = always !<=-1
  ( always !<=-1
  dst always !0
Line 5282
  osz always !<=-1
  = always !<=-1
  ( always !<=-1
  src always !0
Line 5283
  osz always !<=-1
  >= always {!<=-1,!>=2}
  sz always !<=-1
  && always {!<=-1,!>=2}
  dst always !0
  == always {!<=-1,!>=2}
  :: always 1
  SIGNED always 1
  && always {!<=-1,!>=2}
  src always !0
  == always {!<=-1,!>=2}
  :: always 2
  UNSIGNED always 2
Line 5284
  [ possible {lifetime[Lambda]=(osz),lifetime[Lambda]=(sz)}
Line 5285
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 5286
  false always 0
Line 5287
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 5288
  false always 0
Line 5289
  != always {!<=-1,!>=2}
  :: always 0
  Upper always 0
Line 5290
  false always 0
Line 5291
  osz {!<=-1,>=symbolic=(sz+1),<=symbolic=(sz)}
  == always {!<=-1,!>=2}
  sz {!<=-1,<=symbolic=(osz-1),>=symbolic=(osz)}
  && always {!<=-1,!>=2}
  < always {!<=-1,!>=2}
  0 always 0
Line 5292
  true always 1
Line 5293
  osz always !<=-1
  > always {!<=-1,!>=2}
  sz always !<=-1
Line 5294
  true always 1
Line 5295
  false always 0
Line 5302
  ( always {!<=-1,!>=2}
Line 5304
  ( always {!<=-1,!>=2}
Line 5306
  = always 0
  :: always 0
  INT always 0
Line 5309
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  sz always !<=-1
  > always {!<=-1,!>=2}
  0 always 0
  && always {!<=-1,!>=2}
  sz {>=1,!<=0}
  < {!<=-1,!>=2,>=1}
  8 always 8
Line 5310
  unsignedMaxValue always !<=-1
  = {!<=-1,>=255,<=72057594037927935,!>=72057594037927936}
  1ULL always 1
  << {!<=0,>=256,<=72057594037927936}
  sz {>=1,!<=0,<=7,!>=8}
  * {!<=-1,>=8,<=56}
  8 always 8
  - {!<=-1,>=255,<=72057594037927935,!>=72057594037927936}
  1ULL always 1
Line 5311
  signBit always !<=-1
  = {!<=0,>=128,<=36028797018963968}
  1ULL always 1
  << {!<=0,>=128,<=36028797018963968}
  sz {>=1,!<=0,<=7,!>=8}
  * {!<=-1,>=8,<=56}
  8 always 8
  - {!<=-1,>=7,<=55,!>=56}
  1 always 1
Line 5312
  unsignedMaxValue {symbolic=((1ULL<<(sz*8))-1ULL),!<=-1,>=255,<=72057594037927935,!>=72057594037927936}
Line 5313
  == always {!<=-1,!>=2}
  :: always 1
  SIGNED always 1
  && always {!<=-1,!>=2}
  & always !<=-1
  signBit {symbolic=(1ULL<<(sz*8-1)),!<=0}
Line 5314
  ~ always {!<=0,!>=-72057594037927937}
  unsignedMaxValue {symbolic=((1ULL<<(sz*8))-1ULL),!<=-1,!>=72057594037927936}
Line 5320
  ( always {!<=-1,!>=2}
Line 5322
  return always {!<=-1,!>=2}
  ( possible size=1
  == always {!<=-1,!>=2}
  "(" always "("
  || always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  "{" always "{"
  && always {!<=-1,!>=2}
Line 5323
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 5324
  && always {!<=-1,!>=2}
Line 5325
  ( always !0
  == always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 5326
  ( always symbolic=(tok->astOperand1()->variable()->nameToken())
  ( always !0
  && always {!<=-1,!>=2}
Line 5327
  ( always symbolic=(tok->astOperand1()->variable()->nameToken())
  ( always !0
  >= always {!<=-1,!>=2}
  :: always 7
  VOID always 7
  && always {!<=-1,!>=2}
Line 5328
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "," always ","
Line 5333
  ( always {!<=-1,!>=2}
Line 5335
  c1 possible {symbolic=(backAssigns[value.tokvalue->exprId()])@139,symbolic=(s)@139}
  > always {!<=-1,!>=2}
Line 5336
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 5337
  && always {!<=-1,!>=2}
  : {!<=-1,!>=2,symbolic=(backAssigns[value.tokvalue->exprId()])@139,symbolic=(s)@139}
  c1 possible {symbolic=(backAssigns[value.tokvalue->exprId()])@139,symbolic=(s)@139}
Line 5338
  != always {!<=-1,!>=2}
Line 5339
  return always {!<=-1,!>=2}
  true always 1
Line 5341
  return always {!<=-1,!>=2}
  false always 0
Line 5347
  backAssigns possible size=0
Line 5348
  != always {!<=-1,!>=2}
Line 5350
  != always {!<=-1,!>=2}
  "=" always "="
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
Line 5354
  ! always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always !0
Line 5359
  ! always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  ( always !0
  ( always {!<=-1,!>=2}
Line 5363
  ( always !size=0
Line 5366
  ( always {!<=-1,!>=2}
Line 5368
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 5372
  [ possible lifetime[Lambda]=(types)
Line 5373
  ( always !<=-1
  > always {!<=-1,!>=2}
  0 always 0
Line 5376
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 5378
  == always {!<=-1,!>=2}
  :: always 5
  CONTAINER_SIZE always 5
Line 5381
  [ possible lifetime[Lambda]=(tok)
Line 5382
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 5383
  . always !0
  == always {!<=-1,!>=2}
Line 5384
  false always 0
Line 5387
  ( possible symbolic=(tok->astOperand1()->variable()->nameToken())
  && always {!<=-1,!>=2}
  ( always !0
  == always {!<=-1,!>=2}
  0 always 0
  || always {!<=-1,!>=2}
Line 5388
  && always {!<=-1,!>=2}
  ( always !0
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
Line 5390
  ( always {!<=-1,!>=2}
Line 5392
  ( always {!<=-1,!>=2}
Line 5394
  init always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  ( always !<=-1
  == always {!<=-1,!>=2}
  1 always 1
  && always {!<=-1,!>=2}
  vars always size=1
  == always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 5396
  values always !size=0
  init always {!<=-1,!>=2}
Line 5398
  > always {!<=-1,!>=2}
  0 always 0
Line 5403
  values always !size=0
Line 5404
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 5406
  ! always {!<=-1,!>=2}
Line 5408
  . always !0
  == always {!<=-1,!>=2}
  0 always 0
Line 5410
  . always !0
  ( always !0
Line 5413
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 5421
  ( always {!<=-1,!>=2}
  s always {symbolic=(backAssigns[value.tokvalue->exprId()]),symbolic=(s)}
Line 5423
  s always {symbolic=(backAssigns[value.tokvalue->exprId()]),symbolic=(s)}
Line 5426
  " is assigned '" always " is assigned '"
Line 5427
  "' here." always "' here."
Line 5438
  [ possible lifetime[Lambda]=(result)
Line 5440
  ( always !0
Line 5441
  :: always 3
  op1_and_op2 always 3
Line 5452
  != always {!<=-1,!>=2}
Line 5453
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "swap (" always "swap ("
Line 5455
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "," always ","
Line 5457
  "," always ","
Line 5458
  ( always !<=-1
  != always {!<=-1,!>=2}
  2 always 2
Line 5460
  args always size=2
  0 always 0
  == always {!<=-1,!>=2}
  0 always 0
Line 5462
  args always size=2
  1 always 1
  == always {!<=-1,!>=2}
  0 always 0
Line 5464
  = always 0
  0 always 0
  i possible {0,1}
  < {!<=-1,!>=2,1}
  2 always 2
  i possible 0
  ++ possible 0
Line 5465
  0 always 0
Line 5466
  0 always 0
Line 5467
  0 always 0
  1 always 1
  values always symbolic=(args[0]->values())
  false always 0
Line 5468
  0 always 0
  1 always 1
Line 5474
  , always {!<=-1,!>=2}
  then always {!<=-1,!>=2}
Line 5476
  ( always {!<=-1,!>=2}
Line 5478
  then {!<=-1,!>=2,0,1@219}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "==|!|(" always "==|!|("
Line 5480
  ! {!<=-1,!>=2,1}
  then {!<=-1,!>=2,0}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "!=|%var%|(" always "!=|%var%|("
Line 5482
  ( always {!<=-1,!>=2}
  then always {!<=-1,!>=2}
Line 5486
  ( always {!<=-1,!>=2}
Line 5488
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "}" always "}"
Line 5489
  return always {!<=-1,!>=2}
  false always 0
Line 5490
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "{" always "{"
Line 5491
  return always {!<=-1,!>=2}
  false always 0
Line 5492
  return always {!<=-1,!>=2}
  "break|goto" always "break|goto"
Line 5504
  ( {lifetime[Iterator]=(input),start=0}
  ( {lifetime[Iterator]=(input),end=0}
  ( possible lifetime[Object]=(values)
  & {lifetime[Address]=(asImpossible),!0}
Line 5510
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 5512
  = always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
Line 5523
  inverted always {!<=-1,!>=2}
  inverted always {!<=-1,!>=2}
  = always 0
  false always 0
Line 5525
  impossible always {!<=-1,!>=2}
  impossible always {!<=-1,!>=2}
  = always 1
  true always 1
Line 5527
  ( always {!<=-1,!>=2}
Line 5528
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 5531
  nullptr always 0
  inverted always {!<=-1,!>=2}
  false always 0
  impossible always {!<=-1,!>=2}
  true always 1
Line 5539
  = always 0
  0 always 0
Line 5545
  = always 0
  0 always 0
Line 5552
  = always 0
  0 always 0
Line 5554
  = always 0
  0 always 0
Line 5561
  != always {!<=-1,!>=2}
Line 5562
  ( always {!<=-1,!>=2}
  "if|while|for (" always "if|while|for ("
Line 5564
  ( always {!<=-1,!>=2}
  ":|;|," always ":|;|,"
Line 5568
  ! always {!<=-1,!>=2}
  top always symbolic=(tok->astTop())
Line 5571
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  top {symbolic=(tok->astTop()),!0}
  "if|while|for (" always "if|while|for ("
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "&&|%oror%|?|!" always "&&|%oror%|?|!"
Line 5574
  ! always {!<=-1,!>=2}
Line 5576
  . always !0
  == always {!<=-1,!>=2}
  0 always 0
Line 5578
  . always !0
  ( always {!<=-1,!>=2}
Line 5580
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 5582
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  true always 1
  ( always {!<=-1,!>=2}
Line 5594
  [ possible {lifetime[Lambda]=(settings),lifetime[Lambda]=(reverse(bodyTok->link(),bodyTok,cond.vartok,values,tokenlist,settings))}
Line 5595
  == always {!<=-1,!>=2}
  0 always 0
Line 5599
  ( always {!<=-1,!>=2}
Line 5604
  ( always {!<=-1,!>=2}
  top always symbolic=(tok->astTop())
  "%assign%" always "%assign%"
Line 5606
  ( always {!<=-1,!>=2}
  "%assign%|++|--" always "%assign%|++|--"
Line 5609
  ( always {!<=-1,!>=2}
  "?" always "?"
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 5610
  . always {!<=-1,!>=2}
  debugwarnings always {!<=-1,!>=2}
Line 5611
  "valueFlowBailout" always "valueFlowBailout"
  "variable '" always "variable '"
  "', condition is defined in macro" always "', condition is defined in macro"
  "cppcheck-2.8/lib/valueflow.cpp" always "cppcheck-2.8/lib/valueflow.cpp"
  5611 always 5611
Line 5619
  ( always {!<=-1,!>=2}
  "if (" always "if ("
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 5620
  . always {!<=-1,!>=2}
  debugwarnings always {!<=-1,!>=2}
Line 5621
  "valueFlowBailout" always "valueFlowBailout"
  "variable '" always "variable '"
  "', condition is defined in macro" always "', condition is defined in macro"
  "cppcheck-2.8/lib/valueflow.cpp" always "cppcheck-2.8/lib/valueflow.cpp"
  5621 always 5621
Line 5628
  = possible symbolic=(cond.false_values)
  . possible symbolic=(cond.false_values)
Line 5629
  . {symbolic=(values),symbolic=(cond.false_values)}
  != {!<=-1,!>=2,0}
  . possible symbolic=(values)
Line 5630
  values {symbolic=(cond.true_values),!symbolic=(cond.false_values)}
  ( possible lifetime[Iterator]=(values)
  ( {lifetime[Iterator]=(values),end=0}
  . always !symbolic=(cond.true_values)
  ( {lifetime[Iterator]=(cond.false_values),lifetime[Object]=(false_values),start=0}
  ( {lifetime[Iterator]=(cond.false_values),lifetime[Object]=(false_values),end=0}
Line 5633
  ( always {!<=-1,!>=2}
  "<|>" always "<|>"
Line 5635
  ( always {!<=-1,!>=2}
Line 5636
  != always {!<=-1,!>=2}
  0 always 0
Line 5637
  false always 0
Line 5639
  && always {!<=-1,!>=2}
  ( always !0
  != always {!<=-1,!>=2}
  :: always 2
  UNSIGNED always 2
Line 5642
  ( always {!<=-1,!>=2}
Line 5646
  ( always {!<=-1,!>=2}
  "for|while (" always "for|while ("
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  ") {" always ") {"
Line 5649
  ( always {!<=-1,!>=2}
  "for (" always "for ("
Line 5650
  && always {!<=-1,!>=2}
  ( always !0
  && always {!<=-1,!>=2}
Line 5651
  ( always {!<=-1,!>=2}
Line 5652
  ( always !0
  ( always !0
  ( always {!<=-1,!>=2}
Line 5653
  . always {!<=-1,!>=2}
  debugwarnings always {!<=-1,!>=2}
Line 5654
  "valueFlowBailout" always "valueFlowBailout"
  "variable '" always "variable '"
  "' used in loop" always "' used in loop"
  "cppcheck-2.8/lib/valueflow.cpp" always "cppcheck-2.8/lib/valueflow.cpp"
  5654 always 5654
Line 5664
  top always symbolic=(start)
Line 5665
  block always symbolic=(top->link()->next())
Line 5667
  ( always {!<=-1,!>=2}
  start always symbolic=(top)
  end always symbolic=(block->link())
  ( always {!<=-1,!>=2}
Line 5669
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "%assign%|++|--" always "%assign%|++|--"
  && always {!<=-1,!>=2}
Line 5670
  start always symbolic=(top)
  end always symbolic=(block->link())
Line 5671
  ( always {!<=-1,!>=2}
  "%assign%" always "%assign%"
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 5674
  = always symbolic=(block)
  top always symbolic=(start)
  ( always symbolic=(block)
Line 5675
  bodyTok always {symbolic=(top->link()->next()),symbolic=(block)}
  bodyTok always {symbolic=(top->link()->next()),symbolic=(block)}
  values always !size=0
Line 5677
  . always {!<=-1,!>=2}
  debugwarnings always {!<=-1,!>=2}
Line 5678
  "valueFlowBailout" always "valueFlowBailout"
  "variable '" always "variable '"
  "' used in loop" always "' used in loop"
  "cppcheck-2.8/lib/valueflow.cpp" always "cppcheck-2.8/lib/valueflow.cpp"
  5678 always 5678
Line 5686
  = always 0
  nullptr always 0
Line 5687
  ( always {!<=-1,!>=2}
Line 5689
  ( always {!<=-1,!>=2}
Line 5691
  ! always {!<=-1,!>=2}
  startTok possible symbolic=(tok->astParent())
Line 5694
  startTok possible symbolic=(tok->previous())
  nullptr always 0
  values always !size=0
Line 5698
  , always 0
  = always 0
  nullptr always 0
Line 5701
  ( always {!<=-1,!>=2}
  "!" always "!"
Line 5702
  inverted possible {lifetime[Address]=(inverted)@153,lifetime[Address]=(inverted2)@181}
Line 5703
  * always {!<=-1,!>=2}
  inverted {!0,lifetime[Address]=(inverted)@153,lifetime[Address]=(inverted2)@181}
  ^= always {!<=-1,!>=2}
  true always 1
Line 5706
  ( always {!<=-1,!>=2}
  "==|!=" always "==|!="
Line 5708
  sibling always symbolic=(tok->astSibling())
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  sibling always symbolic=(tok->astSibling())
Line 5709
  value always {!<=-1,!>=2}
  value always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  sibling always symbolic=(tok->astSibling())
Line 5711
  * always {!<=-1,!>=2}
  inverted always !0
  ^= always {!<=-1,!>=2}
  value always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "!=" always "!="
Line 5715
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 5726
  [ possible {lifetime[Lambda]=(forward(start,cond.vartok,values,tokenlist,settings)),lifetime[Lambda]=(tokenlist)}
Line 5732
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "!=|=|(|." always "!=|=|(|."
  && always {!<=-1,!>=2}
  != always {!<=-1,!>=2}
Line 5733
  ( possible lifetime[Iterator]=(thenValues)
  ( {lifetime[Iterator]=(thenValues),end=0}
  ( {lifetime[Iterator]=(cond.true_values),lifetime[Object]=(true_values),start=0}
  ( {lifetime[Iterator]=(cond.true_values),lifetime[Object]=(true_values),end=0}
Line 5734
  . always {!<=-1,!>=2}
  impossible always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  condTok always !symbolic=(cond.vartok)
  false always 0
Line 5737
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "==|!" always "==|!"
Line 5738
  ( possible lifetime[Iterator]=(elseValues)
  ( {lifetime[Iterator]=(elseValues),end=0}
  ( {lifetime[Iterator]=(cond.false_values),lifetime[Object]=(false_values),start=0}
  ( {lifetime[Iterator]=(cond.false_values),lifetime[Object]=(false_values),end=0}
Line 5739
  . always {!<=-1,!>=2}
  impossible always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  true always 1
Line 5741
  ( always {!<=-1,!>=2}
Line 5746
  inverted always {!<=-1,!>=2}
  inverted always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  . always {!<=-1,!>=2}
  inverted always {!<=-1,!>=2}
Line 5747
  & {lifetime[Address]=(inverted),!0}
  inverted {symbolic=(cond.inverted),!<=-1,!>=2}
Line 5748
  inverted always {!<=-1,!>=2}
Line 5751
  ( always {!<=-1,!>=2}
  "%oror%|&&" always "%oror%|&&"
Line 5753
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  parent always symbolic=(ctx->astParent())
  && always {!<=-1,!>=2}
  parent always symbolic=(ctx->astParent())
  && always {!<=-1,!>=2}
Line 5754
  parent always symbolic=(ctx->astParent())
  == always {!<=-1,!>=2}
  parent always symbolic=(ctx->astParent())
  ( always !0
Line 5755
  parent always symbolic=(ctx->astParent())
Line 5756
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 5757
  = always 0
  nullptr always 0
Line 5759
  parent possible 0
Line 5760
  parent always !0
Line 5761
  ( always {!<=-1,!>=2}
  parent always !0
  && always {!<=-1,!>=2}
  parent always !0
  && always {!<=-1,!>=2}
  parent always !0
  ( always !0
  == always {!<=-1,!>=2}
  parent always !0
Line 5762
  nextExprs always {{,size=1}
  parent always !0
Line 5764
  op possible size=2
  parent always !0
Line 5766
  op possible size=2
  == always {!<=-1,!>=2}
  "&&" always "&&"
Line 5768
  == always {!<=-1,!>=2}
  "||" always "||"
Line 5770
  ( always {!<=-1,!>=2}
  "==|!=" always "==|!="
  || always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 5772
  ( always {!<=-1,!>=2}
  false always 0
  || always {!<=-1,!>=2}
Line 5773
  ! always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 5774
  ( always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(values),start=0}
  ( {lifetime[Iterator]=(values),end=0}
Line 5775
  || always {!<=-1,!>=2}
Line 5778
  ( always {!<=-1,!>=2}
Line 5782
  != always {!<=-1,!>=2}
Line 5791
  mixedOperators always {!<=-1,!>=2}
  mixedOperators always {!<=-1,!>=2}
  = always 0
  false always 0
Line 5792
  tok2 possible {symbolic=(condTok),symbolic=(parent),symbolic=(tok2->astParent())}
  ( possible symbolic=(tok2)
Line 5793
  = always !0
  ( always !0
Line 5794
  ( always {!<=-1,!>=2}
  parent {symbolic=(tok2->astParent()),!0}
  "%oror%|&&" always "%oror%|&&"
Line 5795
  op possible symbolic=(parent->str())
  ( always {!<=-1,!>=2}
Line 5796
  parent {symbolic=(tok2->astParent()),!0}
Line 5797
  op always !size=0
  != always {!<=-1,!>=2}
  parent {symbolic=(tok2->astParent()),!0}
Line 5798
  mixedOperators always {!<=-1,!>=2}
  = always 1
  true always 1
Line 5802
  parent {symbolic=(tok2->astParent()),!0}
  ( possible symbolic=(op)
  == always {!<=-1,!>=2}
  "!" always "!"
Line 5803
  = possible {"||","&&"}
  == always {!<=-1,!>=2}
  "&&" always "&&"
  ? possible {"||","&&"}
  "||" always "||"
  : always "&&"
  "&&" always "&&"
Line 5805
  = {symbolic=(tok2->astParent()),!0}
  parent {symbolic=(tok2->astParent()),!0}
Line 5808
  mixedOperators {!<=-1,!>=2,0,1}
Line 5813
  ! always {!<=-1,!>=2}
Line 5816
  top always !0
  ( always {!<=-1,!>=2}
Line 5817
  & {lifetime[Address]=(thenValues),!0}
  & {lifetime[Address]=(elseValues),!0}
Line 5819
  . always {!<=-1,!>=2}
  macro always {!<=-1,!>=2}
  = always 1
  true always 1
Line 5825
  inverted2 always {!<=-1,!>=2}
  inverted2 always {!<=-1,!>=2}
  = always 0
  false always 0
Line 5826
  ( always {!<=-1,!>=2}
  condTop possible {symbolic=(ctx->astParent()),symbolic=(parent)}
  "%oror%|&&" always "%oror%|&&"
Line 5827
  & {lifetime[Address]=(inverted2),!0}
  inverted2 always {!<=-1,!>=2}
Line 5828
  ! always {!<=-1,!>=2}
Line 5830
  = always !0
  parent always !0
Line 5832
  inverted2 {!<=-1,!>=2,0}
Line 5836
  ! always {!<=-1,!>=2}
  condTop possible symbolic=(ctx->astParent())
Line 5839
  ( always {!<=-1,!>=2}
  condTop always !0
  "?" always "?"
Line 5840
  condTop always !0
Line 5841
  colon always symbolic=(condTop->astOperand2())
Line 5842
  colon always symbolic=(condTop->astOperand2())
Line 5847
  condTop always !0
  != always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  condTop always {!symbolic=(top),!0}
  != always {!<=-1,!>=2}
  ";" always ";"
Line 5850
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  top possible symbolic=(condTop)
  "if|while|for (" always "if|while|for ("
Line 5853
  == always {!<=-1,!>=2}
  "for" always "for"
Line 5854
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "%comp%" always "%comp%"
Line 5856
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  ";" always ";"
Line 5859
  == always {!<=-1,!>=2}
  0 always 0
Line 5861
  ! always {!<=-1,!>=2}
Line 5863
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "++|--" always "++|--"
Line 5867
  != always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 5869
  . possible symbolic=(ValueFlow::Value::Bound::Point)
Line 5871
  ( always {!<=-1,!>=2}
  "++" always "++"
  && always {!<=-1,!>=2}
  ( always !<=-1
  :: always 1
  Lower always 1
  > always {!<=-1,!>=2}
  0 always 0
Line 5873
  ( always {!<=-1,!>=2}
  "--" always "--"
  && always {!<=-1,!>=2}
  ( always !<=-1
  :: always 0
  Upper always 0
  > always {!<=-1,!>=2}
  0 always 0
Line 5876
  ! always {!<=-1,!>=2}
  childTok always symbolic=(condTok->astOperand1())
Line 5878
  ! always {!<=-1,!>=2}
  childTok possible {symbolic=(condTok->astOperand1()),symbolic=(condTok->astOperand2())}
Line 5880
  childTok always !0
  != always {!<=-1,!>=2}
Line 5883
  ( always {!<=-1,!>=2}
  startBlock always symbolic=(top->link()->next())
Line 5884
  startBlock always symbolic=(top->link()->next())
Line 5885
  ( always symbolic=(childTok->varId())
Line 5886
  ( always {!<=-1,!>=2}
Line 5888
  ( always {!<=-1,!>=2}
Line 5893
  & {lifetime[Address]=(pm),!0}
  nullptr always 0
  nullptr always 0
Line 5894
  = always 1
  1 always 1
Line 5895
  & {lifetime[Address]=(pm),!0}
  & {lifetime[Address]=(result),!0}
  result always 1
  nullptr always 0
Line 5896
  == always {!<=-1,!>=2}
  0 always 0
Line 5899
  & {lifetime[Address]=(thenValues),!0}
  & {lifetime[Address]=(elseValues),!0}
Line 5901
  = always 0
  nullptr always 0
Line 5902
  . always {!<=-1,!>=2}
  conditional always {!<=-1,!>=2}
  = always 1
  true always 1
Line 5907
  2 always 2
  false always 0
  false always 0
Line 5909
  2 always 2
  nullptr always 0
  nullptr always 0
Line 5911
  ( always {!<=-1,!>=2}
  ") {" always ") {"
Line 5912
  startTokens possible lifetime[Object]=(startTokens)
  0 always 0
Line 5913
  ( always {!<=-1,!>=2}
  1 always 1
  "} else {" always "} else {"
Line 5914
  startTokens possible lifetime[Object]=(startTokens)
  1 always 1
  1 always 1
  2 always 2
Line 5916
  = always -1
  -1 always -1
Line 5917
  = always -1
  -1 always -1
Line 5919
  = always 0
  0 always 0
  i possible {symbolic=(bailBlock+1),0}
  < {!<=-1,!>=2,1}
  2 always 2
  i possible symbolic=(bailBlock)
  ++ possible symbolic=(bailBlock)
Line 5920
  startTokens possible lifetime[Object]=(startTokens)
  i {0,!<=-1,<=1,!>=2}
Line 5921
  ! {!<=-1,!>=2,1}
  startToken {symbolic=(startTokens[i]),0}
Line 5923
  i always !<=-1
  == always {!<=-1,!>=2}
  0 always 0
Line 5924
  i always !<=-1
  == always {!<=-1,!>=2}
  0 always 0
Line 5927
  startTokens possible lifetime[Object]=(startTokens)
  i always !<=-1
  startTokens possible lifetime[Object]=(startTokens)
  i always !<=-1
Line 5928
  deadBranch always 1
  [ always {!<=-1,!>=2}
  i always !<=-1
  = always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 2
  Escape always 2
Line 5929
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  deadBranch always 1
  [ always {!<=-1,!>=2}
  i always !<=-1
Line 5930
  = always !<=-1
  i always !<=-1
Line 5931
  . possible {2,3}
  != always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  . always !symbolic=(Analyzer::Terminate::None)
  != always {!<=-1,!>=2}
  :: always 2
  Escape always 2
  && always {!<=-1,!>=2}
Line 5932
  . always {!symbolic=(Analyzer::Terminate::None),!2}
  != always {!<=-1,!>=2}
  :: always 3
  Modified always 3
Line 5933
  = always !<=-1
  i always !<=-1
Line 5936
  >= always {!<=-1,!>=2}
  0 always 0
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "while (" always "while ("
Line 5937
  . always {!<=-1,!>=2}
  debugwarnings always {!<=-1,!>=2}
Line 5938
  "valueFlowBailout" always "valueFlowBailout"
  startTokens possible lifetime[Object]=(startTokens)
  changeBlock always !<=-1
  "valueFlowAfterCondition: " always "valueFlowAfterCondition: "
  " is changed in conditional block" always " is changed in conditional block"
  "cppcheck-2.8/lib/valueflow.cpp" always "cppcheck-2.8/lib/valueflow.cpp"
  5938 always 5938
Line 5944
  >= always {!<=-1,!>=2}
  0 always 0
Line 5945
  . always {!<=-1,!>=2}
  debugwarnings always {!<=-1,!>=2}
Line 5946
  "valueFlowBailout" always "valueFlowBailout"
  startTokens possible lifetime[Object]=(startTokens)
  [ possible lifetime[Lambda]=(forward(after,getEndOfExprScope(cond.vartok,scope),cond.vartok,values,tokenlist,settings))
  bailBlock always !<=-1
  "valueFlowAfterCondition: bailing in conditional block" always "valueFlowAfterCondition: bailing in conditional block"
  "cppcheck-2.8/lib/valueflow.cpp" always "cppcheck-2.8/lib/valueflow.cpp"
  5946 always 5946
Line 5954
  ( always {!<=-1,!>=2}
  ") {" always ") {"
Line 5955
  1 always 1
Line 5956
  dead_if always {!<=-1,!>=2}
  dead_if always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  deadBranch always 1
  [ always {!<=-1,!>=2}
  0 always 0
Line 5957
  dead_else always {!<=-1,!>=2}
  dead_else always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  deadBranch always 1
  [ always {!<=-1,!>=2}
  1 always 1
Line 5958
  = always 0
  nullptr always 0
Line 5959
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "while|for (" always "while|for ("
Line 5960
  dead_if always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 5961
  ! always {!<=-1,!>=2}
  dead_if {symbolic=(deadBranch[0]),!<=-1,!>=2}
Line 5962
  dead_if always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  & {lifetime[Address]=(settings->library),!0}
  & {lifetime[Address]=(unknownFunction),!0}
Line 5964
  ! {!<=-1,!>=2,1}
  dead_if {symbolic=(!isBreakScope(after)),!<=-1,!>=2,0}
  && always {!<=-1,!>=2}
Line 5965
  . always {!<=-1,!>=2}
  debugwarnings always {!<=-1,!>=2}
Line 5966
  "valueFlowBailout" always "valueFlowBailout"
  unknownFunction always !0
  "possible noreturn scope" always "possible noreturn scope"
  "cppcheck-2.8/lib/valueflow.cpp" always "cppcheck-2.8/lib/valueflow.cpp"
  5966 always 5966
Line 5970
  ( always {!<=-1,!>=2}
  "} else {" always "} else {"
Line 5971
  2 always 2
Line 5972
  = always 0
  nullptr always 0
Line 5973
  ! always {!<=-1,!>=2}
  dead_else {symbolic=(deadBranch[1]),!<=-1,!>=2}
Line 5974
  dead_else always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  & {lifetime[Address]=(settings->library),!0}
  & {lifetime[Address]=(unknownFunction),!0}
Line 5975
  ! always {!<=-1,!>=2}
  dead_else always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 5976
  . always {!<=-1,!>=2}
  debugwarnings always {!<=-1,!>=2}
Line 5977
  "valueFlowBailout" always "valueFlowBailout"
  unknownFunction always !0
  "possible noreturn scope" always "possible noreturn scope"
  "cppcheck-2.8/lib/valueflow.cpp" always "cppcheck-2.8/lib/valueflow.cpp"
  5977 always 5977
Line 5982
  dead_if {!<=-1,!>=2,0}
  && always {!<=-1,!>=2}
  dead_else always {!<=-1,!>=2}
Line 5986
  dead_if {!<=-1,!>=2,0}
Line 5988
  dead_else always {!<=-1,!>=2}
Line 5991
  ( {lifetime[Iterator]=(thenValues),start=0}
Line 5992
  ( {lifetime[Iterator]=(thenValues),end=0}
Line 5993
  ( possible lifetime[Object]=(values)
  values always size=0
Line 5994
  & {lifetime[Address]=(isPossible),!0}
Line 5995
  ( {lifetime[Iterator]=(elseValues),start=0}
Line 5996
  ( {lifetime[Iterator]=(elseValues),end=0}
Line 5997
  ( possible lifetime[Object]=(values)
Line 5998
  & {lifetime[Address]=(isPossible),!0}
Line 6001
  values possible {symbolic=(elseValues),symbolic=(thenValues)}
  ( always {!<=-1,!>=2}
Line 6004
  dead_if always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  dead_else always {!<=-1,!>=2}
Line 6007
  ( always {!<=-1,!>=2}
  parent possible symbolic=(condTok->astParent())
  "!" always "!"
Line 6009
  possible always {!<=-1,!>=2}
  possible always {!<=-1,!>=2}
  = always 0
  false always 0
Line 6010
  ( always {!<=-1,!>=2}
  parent possible symbolic=(condTok->astParent())
  "&&|%oror%" always "&&|%oror%"
Line 6012
  && always {!<=-1,!>=2}
  parent always !0
  ( possible symbolic=(op)
  == {!<=-1,!>=2,1}
  op possible symbolic=(parent->str())
Line 6013
  parent always !0
Line 6014
  ( always {!<=-1,!>=2}
  parent possible 0
  "!" always "!"
  || always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "== false" always "== false"
Line 6015
  possible always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  "||" always "||"
Line 6017
  possible always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  "&&" always "&&"
Line 6019
  possible {symbolic=(op=="||"),symbolic=(op=="&&"),!<=-1,!>=2,0}
Line 6020
  values always !size=0
  & {lifetime[Address]=(isImpossible),!0}
Line 6023
  values always !size=0
  true always 1
Line 6024
  values always !size=0
  false always 0
Line 6027
  ( {!<=-1,!>=2,0}
Line 6029
  values always !size=0
Line 6079
  vartok always !0
  ( always {!<=-1,!>=2}
Line 6080
  { always {size=0,{}
Line 6081
  vartok always !0
  == always {!<=-1,!>=2}
  "=" always "="
  && always {!<=-1,!>=2}
  vartok always !0
  && always {!<=-1,!>=2}
  vartok always !0
Line 6082
  = always !0
  vartok always !0
  ( always !0
Line 6086
  { always {size=1,{}
Line 6089
  == always {!<=-1,!>=2}
  "!" always "!"
Line 6092
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  ( always !0
  "%oror%|&&|?" always "%oror%|&&|?"
  || always {!<=-1,!>=2}
Line 6093
  ( always {!<=-1,!>=2}
  ( always !0
  "if|while (" always "if|while ("
Line 6094
  ( always {!<=-1,!>=2}
  "=" always "="
Line 6096
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "%comp%|%assign%" always "%comp%|%assign%"
Line 6100
  ! always {!<=-1,!>=2}
  vartok possible {symbolic=(tok->astOperand1()),symbolic=(tok)}
Line 6101
  { always {size=0,{}
Line 6102
  0LL always 0
Line 6103
  0LL always 0
Line 6104
  = always !0
  vartok always !0
Line 6106
  { always {size=1,{}
Line 6111
  ( always {!<=-1,!>=2}
Line 6112
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 6117
  = always 0
  :: always 0
  INT always 0
Line 6129
  ! always {!<=-1,!>=2}
  varTok possible symbolic=(tok->next()->astOperand2())@248
Line 6131
  varTok always !0
  ( always {!<=-1,!>=2}
Line 6133
  varTok always !0
Line 6134
  ( always !<=-1
  == always {!<=-1,!>=2}
  1 always 1
  && always {!<=-1,!>=2}
  r always size=1
  ( always {!<=-1,!>=2}
Line 6135
  r always size=1
Line 6141
  ! always {!<=-1,!>=2}
Line 6143
  varTok always !0
  ( always {!<=-1,!>=2}
Line 6145
  varTok always !0
Line 6146
  ( always !<=-1
  == always {!<=-1,!>=2}
  1 always 1
  && always {!<=-1,!>=2}
  r always size=1
  ( always {!<=-1,!>=2}
Line 6147
  r always size=1
Line 6152
  = always 0
  0 always 0
Line 6153
  ( always {!<=-1,!>=2}
Line 6154
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
Line 6167
  :: always 9
  ITERATOR_END always 9
Line 6173
  :: always 9
  ITERATOR_END always 9
Line 6181
  ! always {!<=-1,!>=2}
Line 6183
  ( always {!<=-1,!>=2}
Line 6185
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  ( always !0
  "?|&&|!|%oror%" always "?|&&|!|%oror%"
  || always {!<=-1,!>=2}
Line 6186
  ( always {!<=-1,!>=2}
  "if|while (" always "if|while ("
Line 6187
  "!=" always "!="
  0 always 0
Line 6188
  ( always !<=-1
  != always {!<=-1,!>=2}
  1 always 1
Line 6190
  result always size=1
Line 6191
  value always symbolic=(result.front())
  = always 1
  1 always 1
Line 6194
  ( always {!<=-1,!>=2}
  "%comp%|-" always "%comp%|-"
  && always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 6195
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 6196
  2 always 2
Line 6198
  iteratorModels always size=2
Line 6202
  = always 0
  :: always 0
  INT always 0
Line 6219
  ( always {!<=-1,!>=2}
Line 6221
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "!" always "!"
Line 6222
  return always {!<=-1,!>=2}
  false always 0
Line 6223
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 6228
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "!" always "!"
Line 6235
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "%comp%" always "%comp%"
Line 6236
  { always {size=0,{}
Line 6237
  ( always {!<=-1,!>=2}
Line 6238
  { always {size=0,{}
Line 6239
  ! always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  ( always !0
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  ( always !0
  ( always {!<=-1,!>=2}
Line 6240
  { always {size=0,{}
Line 6241
  ! always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  ( always !0
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  ( always !0
  ( always {!<=-1,!>=2}
Line 6242
  { always {size=0,{}
Line 6243
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  true always 1
  true always 1
Line 6244
  { always {size=0,{}
Line 6247
  = possible lifetime[Lambda]=(tok)
  [ possible lifetime[Lambda]=(tok)
  inverted always {!<=-1,!>=2}
Line 6248
  = always 0
  0 always 0
  i possible 0
  < {!<=-1,!>=2,1}
  2 always 2
Line 6249
  lhs always {!<=-1,!>=2}
  = {!<=-1,!>=2,<=1}
  i {0,<=1,!>=2,!<=-1}
  == {!<=-1,!>=2,<=1}
  0 always 0
Line 6250
  lhs {symbolic=(i==0),!<=-1,!>=2,<=1}
Line 6251
  lhs {symbolic=(i==0),!<=-1,!>=2,<=1}
Line 6252
  valuetok always symbolic=(lhs?rhsTok:lhsTok)
  == always {!<=-1,!>=2}
  0 always 0
Line 6254
  valuetok always symbolic=(lhs?rhsTok:lhsTok)
  ( always {!<=-1,!>=2}
  vartok always symbolic=(lhs?lhsTok:rhsTok)
Line 6256
  ( always {!<=-1,!>=2}
Line 6260
  ! always {!<=-1,!>=2}
  lhs always {!<=-1,!>=2}
  0 always 0
Line 6268
  . always {!<=-1,!>=2}
  inverted always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  inverted always {!<=-1,!>=2}
Line 6272
  addCond possible lifetime[Lambda]=(tok)
  false always 0
Line 6273
  ( always {!<=-1,!>=2}
  "==|!=" always "==|!="
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 6276
  addCond possible lifetime[Lambda]=(tok)
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 6282
  ( always {!<=-1,!>=2}
Line 6293
  = always 0
  0 always 0
Line 6294
  error always {!<=-1,!>=2}
  error always {!<=-1,!>=2}
  = always 0
  false always 0
Line 6295
  firstExpression always symbolic=(tok->next()->astOperand2()->astOperand1())
  & {lifetime[Address]=(programMemory),!0}
  & {lifetime[Address]=(result),!0}
  result always 0
  & {lifetime[Address]=(error),!0}
  error always 0
Line 6296
  error always {!<=-1,!>=2}
Line 6297
  return always {!<=-1,!>=2}
  false always 0
Line 6298
  secondExpression always symbolic=(tok->next()->astOperand2()->astOperand2()->astOperand1())
  & {lifetime[Address]=(programMemory),!0}
  & {lifetime[Address]=(result),!0}
  & {lifetime[Address]=(error),!0}
  error always 0
Line 6299
  == always {!<=-1,!>=2}
  0 always 0
Line 6300
  return always {!<=-1,!>=2}
  false always 0
Line 6301
  error always {!<=-1,!>=2}
Line 6303
  reassign {!<=-1,!>=2,0}
  reassign always {!<=-1,!>=2}
  = always 0
  false always 0
Line 6305
  [ possible {lifetime[Lambda]=(programMemory),lifetime[Lambda]=(reassign)}
Line 6306
  == always {!<=-1,!>=2}
  "=" always "="
  && always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  ( always !0
Line 6308
  reassign always {!<=-1,!>=2}
  = always 1
  true always 1
Line 6309
  reassign {!<=-1,!>=2,1}
  ? possible {4,3}
  :: always 4
  done always 4
  : always 3
  :: always 3
  op1_and_op2 always 3
Line 6311
  reassign always {!<=-1,!>=2}
Line 6312
  return always {!<=-1,!>=2}
  false always 0
Line 6318
  = always 10000
  10000 always 10000
Line 6319
  != always {!<=-1,!>=2}
  0 always 0
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  error always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  > always {!<=-1,!>=2}
  0 always 0
Line 6321
  & {lifetime[Address]=(programMemory),!0}
  programMemory always symbolic=(endMemory)
  & {lifetime[Address]=(result),!0}
  result always !0
  & {lifetime[Address]=(error),!0}
  error always 0
Line 6322
  ! always {!<=-1,!>=2}
  error always {!<=-1,!>=2}
Line 6323
  & {lifetime[Address]=(programMemory),!0}
  & {lifetime[Address]=(result),!0}
  & {lifetime[Address]=(error),!0}
  error always 0
Line 6327
  memory1 always !0
Line 6328
  ! always {!<=-1,!>=2}
  error always {!<=-1,!>=2}
Line 6330
  memory2 always !0
Line 6332
  memoryAfter always !0
Line 6335
  return always {!<=-1,!>=2}
  true always 1
Line 6339
  , always {!<=-1,!>=2}
Line 6340
  globalvar always {!<=-1,!>=2}
Line 6347
  > always {!<=-1,!>=2}
  0 always 0
Line 6351
  ( always {!<=-1,!>=2}
  bodyEnd always symbolic=(bodyStart->link())
  globalvar {!<=-1,!>=2,0@229}
  ( always {!<=-1,!>=2}
Line 6354
  != always {!<=-1,!>=2}
  bodyEnd always symbolic=(bodyStart->link())
Line 6355
  == always {!<=-1,!>=2}
Line 6357
  parent possible symbolic=(tok2->astParent())
Line 6358
  = {symbolic=(tok2->astParent()),!0}
  parent {symbolic=(tok2->astParent()),!0}
Line 6359
  parent {symbolic=(tok2->astParent()),symbolic=(p),!0}
Line 6360
  ! always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  parent always !0
  == always {!<=-1,!>=2}
  ":" always ":"
Line 6362
  parent always !0
  == always {!<=-1,!>=2}
  "?" always "?"
Line 6363
  parent always !0
  != always {!<=-1,!>=2}
  p always !0
Line 6364
  = always 0
  nullptr always 0
Line 6368
  parent possible {symbolic=(tok2->astParent()),0}
Line 6369
  . always {!<=-1,!>=2}
  debugwarnings always {!<=-1,!>=2}
Line 6370
  "valueFlowBailout" always "valueFlowBailout"
  "For loop variable " always "For loop variable "
  " stopping on ?" always " stopping on ?"
  "cppcheck-2.8/lib/valueflow.cpp" always "cppcheck-2.8/lib/valueflow.cpp"
  6370 always 6370
Line 6379
  ( always {!<=-1,!>=2}
  "%oror%|&&" always "%oror%|&&"
Line 6381
  == always {!<=-1,!>=2}
  "&&" always "&&"
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
Line 6382
  == always {!<=-1,!>=2}
  "||" always "||"
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 6385
  parent possible {symbolic=(tok2),0}
  && always {!<=-1,!>=2}
  parent {symbolic=(tok2),!0}
  == always {!<=-1,!>=2}
  tok2 possible symbolic=(parent)
Line 6386
  parent always !0
Line 6388
  parent possible {symbolic=(tok2),0}
  && always {!<=-1,!>=2}
  parent always !0
  == always {!<=-1,!>=2}
  "(" always "("
Line 6389
  parent always !0
Line 6391
  ( always {!<=-1,!>=2}
  tok2 always symbolic=(parent->link())
  ") (" always ") ("
Line 6392
  tok2 always symbolic=(parent->link())
  1 always 1
Line 6398
  vartok always symbolic=(expr)
Line 6400
  rml always !0
  == always {!<=-1,!>=2}
  "]" always "]"
  rml always !0
  : always 1
  rml always !0
Line 6401
  vartok possible {symbolic=(expr),symbolic=(rml->str()=="]"?rml:rml->previous())}
  == always {!<=-1,!>=2}
  "]" always "]"
  && always {!<=-1,!>=2}
Line 6402
  = always !0
  ( always !0
Line 6404
  == always {!<=-1,!>=2}
  "&&" always "&&"
  && always {!<=-1,!>=2}
Line 6405
  ( always {!<=-1,!>=2}
Line 6406
  || always {!<=-1,!>=2}
Line 6407
  == always {!<=-1,!>=2}
  "||" always "||"
  && always {!<=-1,!>=2}
Line 6408
  ( always {!<=-1,!>=2}
Line 6412
  ( always {!<=-1,!>=2}
  ") {" always ") {"
Line 6413
  && always {!<=-1,!>=2}
  "%varid%" always "%varid%"
  ( always !0
Line 6414
  "continue|break|return" always "continue|break|return"
  1 always 1
  ( always !0
Line 6415
  . always {!<=-1,!>=2}
  debugwarnings always {!<=-1,!>=2}
Line 6416
  "valueFlowBailout" always "valueFlowBailout"
  "For loop variable bailout on conditional continue|break|return" always "For loop variable bailout on conditional continue|break|return"
  "cppcheck-2.8/lib/valueflow.cpp" always "cppcheck-2.8/lib/valueflow.cpp"
  6416 always 6416
Line 6419
  . {!<=-1,!>=2,0}
  debugwarnings always {!<=-1,!>=2}
Line 6420
  "valueFlowBailout" always "valueFlowBailout"
  "For loop variable skipping conditional scope" always "For loop variable skipping conditional scope"
  "cppcheck-2.8/lib/valueflow.cpp" always "cppcheck-2.8/lib/valueflow.cpp"
  6420 always 6420
Line 6422
  ( always {!<=-1,!>=2}
  "} else {" always "} else {"
Line 6423
  "continue|break|return" always "continue|break|return"
  2 always 2
  ( always !0
Line 6424
  . always {!<=-1,!>=2}
  debugwarnings always {!<=-1,!>=2}
Line 6425
  "valueFlowBailout" always "valueFlowBailout"
  "For loop variable bailout on conditional continue|break|return" always "For loop variable bailout on conditional continue|break|return"
  "cppcheck-2.8/lib/valueflow.cpp" always "cppcheck-2.8/lib/valueflow.cpp"
  6425 always 6425
Line 6428
  2 always 2
Line 6432
  . always {!<=-1,!>=2}
  debugwarnings always {!<=-1,!>=2}
Line 6433
  "valueFlowBailout" always "valueFlowBailout"
  "For loop skipping {} code" always "For loop skipping {} code"
  "cppcheck-2.8/lib/valueflow.cpp" always "cppcheck-2.8/lib/valueflow.cpp"
  6433 always 6433
Line 6434
  1 always 1
Line 6435
  ( always {!<=-1,!>=2}
  "} else {" always "} else {"
Line 6436
  2 always 2
Line 6448
  = always 0
  nullptr always 0
Line 6450
  == always {!<=-1,!>=2}
Line 6455
  ! {!<=-1,!>=2,1}
  vartok possible {symbolic=(tok),0}
  || always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  vartok {symbolic=(tok),!0}
Line 6458
  = always !0
  vartok {symbolic=(tok),!0}
  ( always !0
Line 6459
  = always 0
  nullptr always 0
Line 6460
  var {symbolic=(vartok->variable()),!0}
  ( always {!<=-1,!>=2}
Line 6461
  var {symbolic=(vartok->variable()),!0}
Line 6465
  1 always 1
  1 always 1
Line 6467
  values always size=0
Line 6468
  values always size=1
  "After for loop, " always "After for loop, "
  var {symbolic=(vartok->variable()),!0}
  " has value " always " has value "
  values always size=1
Line 6470
  != always {!<=-1,!>=2}
  endToken possible symbolic=(var->scope()->bodyEnd)
Line 6471
  blockTok always !symbolic=(endToken)
  endToken always !symbolic=(blockTok)
  vartok always !0
  values always size=1
Line 6478
  != always {!<=-1,!>=2}
  :: always 8
  eFor always 8
Line 6484
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  tok always symbolic=(const_cast<Token*>(scope.classDef))
  ";" always ";"
  || always {!<=-1,!>=2}
Line 6485
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  ";" always ";"
Line 6489
  knownInitValue always {!<=-1,!>=2}
  partialCond always {!<=-1,!>=2}
Line 6492
  ( always {!<=-1,!>=2}
  & {lifetime[Address]=(varid),!0,Uninit*}
  varid always Uninit
  & {lifetime[Address]=(knownInitValue),!0,Uninit*}
  knownInitValue {!<=-1,!>=2,Uninit}
  & {lifetime[Address]=(initValue),!0,Uninit*}
  initValue always Uninit
  & {lifetime[Address]=(partialCond),!0,Uninit*}
  partialCond {!<=-1,!>=2,Uninit}
  & {lifetime[Address]=(stepValue),!0,Uninit*}
  stepValue {1,Uninit}
  & {lifetime[Address]=(lastValue),!0,Uninit*}
  lastValue always Uninit
Line 6493
  executeBody always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  knownInitValue always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  <= always {!<=-1,!>=2}
Line 6494
  "%varid%" always "%varid%"
Line 6495
  executeBody {symbolic=(!knownInitValue||initValue<=lastValue),!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 6497
  initValues always size=0
  :: always 1
  Lower always 1
Line 6498
  initValues always !size=0
  initValues always !size=1
Line 6500
  vartok always !0
  initValues always {!size=1,!size=0}
Line 6502
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 6504
  lastValues always size=0
  :: always 0
  Upper always 0
Line 6505
  lastValues always !size=0
  . always {!<=-1,!>=2}
  = always 1
  true always 1
Line 6506
  lastValues always !size=0
  lastValues always !size=1
Line 6507
  != always {!<=-1,!>=2}
  1 always 1
Line 6508
  lastValues always {!size=1,!size=0}
Line 6512
  executeBody {symbolic=(!knownInitValue||initValue<=lastValue),!<=-1,!>=2,1,0}
Line 6513
  afterValue always symbolic=(executeBody?lastValue+stepValue:initValue)
Line 6516
  ( always {!<=-1,!>=2}
  & {lifetime[Address]=(mem1),!0}
  & {lifetime[Address]=(mem2),!0}
  & {lifetime[Address]=(memAfter),!0}
Line 6518
  ! always {!<=-1,!>=2}
Line 6520
  == always {!<=-1,!>=2}
  0 always 0
Line 6522
  false always 0
Line 6525
  ! always {!<=-1,!>=2}
Line 6527
  == always {!<=-1,!>=2}
  0 always 0
Line 6529
  false always 0
Line 6532
  ! always {!<=-1,!>=2}
Line 6534
  == always {!<=-1,!>=2}
  0 always 0
Line 6548
  nullptr always 0
Line 6551
  ( possible lifetime[SubObject]=(t)
Line 6563
  == always {!<=-1,!>=2}
  0 always 0
Line 6564
  nullptr always 0
Line 6565
  = possible lifetime[Iterator]=(values)
  ( possible lifetime[Iterator]=(values)
  ( always !0
Line 6566
  it {lifetime[Iterator]=(values),symbolic=(values.find(tok->varId()))}
  == always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(values),end=0}
Line 6567
  nullptr always 0
Line 6568
  & {lifetime[Object]=(values),!0}
  it {lifetime[Iterator]=(values),symbolic=(values.find(tok->varId())),!symbolic=(values.end()),!end=0}
Line 6571
  == always {!<=-1,!>=2}
  0 always 0
Line 6572
  nullptr always 0
Line 6573
  = possible lifetime[Iterator]=(values)
  ( possible lifetime[Iterator]=(values)
  ( always !0
Line 6574
  it {lifetime[Iterator]=(values),symbolic=(values.find(tok->varId()))}
  == always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(values),end=0}
Line 6575
  nullptr always 0
Line 6576
  & {lifetime[Object]=(values),!0}
  it {lifetime[Iterator]=(values),symbolic=(values.find(tok->varId())),!symbolic=(values.end()),!end=0}
Line 6580
  && always {!<=-1,!>=2}
  : always {!<=-1,!>=2}
Line 6581
  = always 1
  true always 1
Line 6586
  && always {!<=-1,!>=2}
  : always {!<=-1,!>=2}
Line 6587
  "Assuming condition is " always "Assuming condition is "
Line 6591
  ( always {!<=-1,!>=2}
  inconclusive always {!<=-1,!>=2}
Line 6592
  = possible lifetime[SubObject]=(values)
  ( possible lifetime[SubObject]=(values)
  & {lifetime[Address]=(values),!0}
Line 6597
  == always {!<=-1,!>=2}
  varid always symbolic=(p.first)
Line 6598
  return always {!<=-1,!>=2}
  true always 1
Line 6599
  ( always {!<=-1,!>=2}
  var always symbolic=(p.second)
  varid {symbolic=(p.first),!symbolic=(tok->varId())}
  & {lifetime[Address]=(inconclusive),!0}
  inconclusive always {!<=-1,!>=2}
Line 6600
  return always {!<=-1,!>=2}
  true always 1
Line 6602
  return always {!<=-1,!>=2}
  false always 0
Line 6605
  ( always {!<=-1,!>=2}
Line 6606
  return always {!<=-1,!>=2}
  false always 0
Line 6609
  ( always {!<=-1,!>=2}
Line 6610
  && always {!<=-1,!>=2}
  : always {!<=-1,!>=2}
Line 6612
  return always {!<=-1,!>=2}
  false always 0
Line 6615
  return always {!<=-1,!>=2}
  true always 1
Line 6617
  ( always {!<=-1,!>=2}
Line 6618
  && always {!<=-1,!>=2}
  : always {!<=-1,!>=2}
Line 6620
  return always {!<=-1,!>=2}
  false always 0
Line 6623
  return always {!<=-1,!>=2}
  true always 1
Line 6626
  ( always {!<=-1,!>=2}
Line 6627
  && always {!<=-1,!>=2}
  : always {!<=-1,!>=2}
Line 6629
  return always {!<=-1,!>=2}
  true always 1
Line 6631
  return always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
Line 6633
  return always {!<=-1,!>=2}
  false always 0
Line 6636
  ( always {!<=-1,!>=2}
Line 6637
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 6640
  ( always {!<=-1,!>=2}
Line 6642
  ! always {!<=-1,!>=2}
  scope always symbolic=(endBlock->scope())
Line 6643
  return always {!<=-1,!>=2}
  false always 0
Line 6644
  scope {symbolic=(endBlock->scope()),!0}
  . possible {6,7,9,8}
  == {!<=-1,!>=2,0}
  :: always 15
  eLambda always 15
Line 6646
  ! always {!<=-1,!>=2}
Line 6647
  return always {!<=-1,!>=2}
  false always 0
Line 6649
  return always {!<=-1,!>=2}
  true always 1
Line 6650
  scope {symbolic=(endBlock->scope()),!0}
  . {7,9,8,!15}
  == {!<=-1,!>=2,0}
  :: always 6
  eIf always 6
  || {!<=-1,!>=2,0}
  scope {symbolic=(endBlock->scope()),!0}
  . {9,8,!15,!6}
  == {!<=-1,!>=2,0}
  :: always 7
  eElse always 7
  || {!<=-1,!>=2,0}
  scope {symbolic=(endBlock->scope()),!0}
  . {8,!15,!6,!7}
  == {!<=-1,!>=2,0}
  :: always 9
  eWhile always 9
  || always {!<=-1,!>=2}
Line 6651
  scope {symbolic=(endBlock->scope()),!0}
  . always {!15,!7,!9}
  == always {!<=-1,!>=2}
  :: always 8
  eFor always 8
Line 6653
  ( always {!<=-1,!>=2}
Line 6654
  true always 1
Line 6655
  ( always {!<=-1,!>=2}
Line 6656
  true always 1
Line 6657
  ( always {!<=-1,!>=2}
Line 6658
  true always 1
Line 6659
  false always 0
Line 6661
  ( always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(values),start=0}
  ( {lifetime[Iterator]=(values),end=0}
Line 6662
  return always {!<=-1,!>=2}
  true always 1
Line 6663
  ( always {!<=-1,!>=2}
Line 6664
  return always {!<=-1,!>=2}
  false always 0
Line 6667
  ( {lifetime[Iterator]=(getVars()),start=0}
  ( {lifetime[Iterator]=(getVars()),end=0}
  varids always size=0
  ( {lifetime[Iterator]=(varids),start=0}
Line 6668
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 6671
  return always {!<=-1,!>=2}
  false always 0
Line 6674
  ( always {!<=-1,!>=2}
Line 6675
  return always {!<=-1,!>=2}
  ( always !<=-1
  > always {!<=-1,!>=2}
  0 always 0
Line 6682
  ! always {!<=-1,!>=2}
  var always symbolic=(vars.at(p.first))
Line 6684
  var {symbolic=(vars.at(p.first)),!0}
Line 6693
  scope always symbolic=(endBlock->scope())
  && always {!<=-1,!>=2}
Line 6694
  condTok always !0
  nullptr always 0
  scope {symbolic=(endBlock->scope()),!0}
  != always {!<=-1,!>=2}
  :: always 7
  eElse always 7
Line 6695
  condTok possible 0
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  condTok always !0
  ";" always ";"
Line 6697
  ( always {!<=-1,!>=2}
  condTok always !0
  nullptr always 0
  & {lifetime[Address]=(endMemory),!0}
  nullptr always 0
Line 6703
  symboldatabase possible 0
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  symboldatabase always !0
  ( always {!<=-1,!>=2}
Line 6706
  ( always !<=-1
  != always {!<=-1,!>=2}
  0 always 0
Line 6708
  value always symbolic=(p.second)
  ( always {!<=-1,!>=2}
Line 6713
  symboldatabase always !0
Line 6719
  ( always {!<=-1,!>=2}
Line 6722
  1 always 1
Line 6730
  ( always !<=-1
  > always {!<=-1,!>=2}
  256 always 256
Line 6731
  return always {!<=-1,!>=2}
  false always 0
Line 6734
  [ possible lifetime[Lambda]=(args)
Line 6737
  . possible {symbolic=(q.second.path),0}
  != {!<=-1,!>=2,0}
  0 always 0
Line 6739
  . possible symbolic=(value.path)
  == always {!<=-1,!>=2}
  0 always 0
Line 6741
  . always !0
  != always {!<=-1,!>=2}
Line 6748
  ( possible lifetime[Object]=(args)
  ( {lifetime[Iterator]=(new_args),start=0}
  ( {lifetime[Iterator]=(new_args),end=0}
  ( possible lifetime[Object]=(args)
Line 6753
  ( always {!<=-1,!>=2}
Line 6755
  skip always {!<=-1,!>=2}
  skip always {!<=-1,!>=2}
  = always 0
  false always 0
Line 6757
  arg always !size=0
  ( {lifetime[Iterator]=(arg),!size=0,start=0}
Line 6758
  arg always !size=0
Line 6759
  != {!<=-1,!>=2,0}
  path possible symbolic=(p.second.path)
Line 6760
  skip always {!<=-1,!>=2}
  = always 1
  true always 1
Line 6764
  skip {!<=-1,!>=2,1}
Line 6768
  return always {!<=-1,!>=2}
  true always 1
Line 6778
  r always {!<=-1,!>=2}
  r always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  vars possible size=0@124
  [ possible lifetime[Lambda]=(tokenlist)
Line 6782
  ! always {!<=-1,!>=2}
  r always {!<=-1,!>=2}
Line 6783
  = always "<unknown>"
  "<unknown>" always "<unknown>"
Line 6785
  f always symbolic=(functionScope->function)
Line 6786
  f {symbolic=(functionScope->function),!0}
Line 6787
  . always {!<=-1,!>=2}
  debugwarnings always {!<=-1,!>=2}
Line 6788
  "valueFlowBailout" always "valueFlowBailout"
  "Too many argument passed to " always "Too many argument passed to "
  "cppcheck-2.8/lib/valueflow.cpp" always "cppcheck-2.8/lib/valueflow.cpp"
  6788 always 6788
Line 6799
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 6804
  ! always {!<=-1,!>=2}
  varid2 always symbolic=(arg->declarationId())
Line 6818
  != always {!<=-1,!>=2}
  :: always 11
  eSwitch always 11
Line 6820
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "switch ( %var% ) {" always "switch ( %var% ) {"
Line 6822
  2 always 2
Line 6824
  ! {!<=-1,!>=2,1}
  var {symbolic=(vartok->variable()),0}
Line 6828
  ! always {!<=-1,!>=2}
  var {symbolic=(vartok->variable()),!0}
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  var {symbolic=(vartok->variable()),!0}
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  var {symbolic=(vartok->variable()),!0}
  ( always {!<=-1,!>=2}
Line 6829
  . always {!<=-1,!>=2}
  debugwarnings always {!<=-1,!>=2}
Line 6830
  "valueFlowBailout" always "valueFlowBailout"
  "switch variable " always "switch variable "
  var {symbolic=(vartok->variable()),!0}
  " is global" always " is global"
  "cppcheck-2.8/lib/valueflow.cpp" always "cppcheck-2.8/lib/valueflow.cpp"
  6830 always 6830
Line 6834
  != always {!<=-1,!>=2}
Line 6835
  == always {!<=-1,!>=2}
  "{" always "{"
Line 6839
  ( always {!<=-1,!>=2}
  "case %num% :" always "case %num% :"
Line 6841
  values always size=0
Line 6842
  values always size=1
Line 6843
  "case " always "case "
  ": " always ": "
  " is " always " is "
  " here." always " here."
Line 6844
  values always size=1
Line 6845
  known always {!<=-1,!>=2}
  known always {!<=-1,!>=2}
  = always 0
  false always 0
Line 6846
  ( always {!<=-1,!>=2}
  "{" always "{"
  || always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  -2 always -2
  "break ;" always "break ;"
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  3 always 3
  ";| case" always ";| case"
Line 6847
  known always {!<=-1,!>=2}
  = always 1
  true always 1
Line 6848
  ( always {!<=-1,!>=2}
  3 always 3
  ";| case %num% :" always ";| case %num% :"
Line 6849
  known always {!<=-1,!>=2}
  = always 0
  false always 0
Line 6850
  3 always 3
Line 6851
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 6854
  values always !size=0
Line 6855
  "case " always "case "
  ": " always ": "
  " is " always " is "
  " here." always " here."
Line 6856
  values always !size=0
Line 6858
  = {lifetime[Iterator]=(values),start=0}
  ( {lifetime[Iterator]=(values),start=0}
  val possible {lifetime[Iterator]=(values),start=0}
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(values),end=0}
  val possible lifetime[Iterator]=(values)
Line 6862
  val {lifetime[Iterator]=(values),!symbolic=(values.end()),!end=0}
Line 6868
  known always {!<=-1,!>=2}
Line 6894
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "%comp%|%oror%|&&|!" always "%comp%|%oror%|&&|!"
Line 6895
  argvalues always size=0
  0 always 0
Line 6896
  argvalues always size=1
  1 always 1
Line 6904
  = always 1
  1 always 1
Line 6906
  argValues possible size=0
  argn possible 1
Line 6907
  argn possible 1
  ++ possible 1
Line 6909
  ( always !<=-1
  "arg" always "arg"
  != always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 6911
  ( always {!<=-1,!>=2}
  [ possible lifetime[Lambda]=(returnValue)
Line 6913
  ( always {!<=-1,!>=2}
Line 6915
  = always 1
  :: always 1
  Known always 1
Line 6916
  && always {!<=-1,!>=2}
  : always {!<=-1,!>=2}
Line 6924
  ( {!<=-1,!>=2,0}
  && always {!<=-1,!>=2}
  kind possible symbolic=(p.second.valueKind)
  != always {!<=-1,!>=2}
  :: always 1
  Known always 1
Line 6926
  ! {!<=-1,!>=2,1}
  ( {!<=-1,!>=2,0}
Line 6950
  { possible {lifetime[SubObject]=(start),lifetime[SubObject]=(last),lifetime[SubObject]=(symboldatabase->functionScopes)@104,lifetime[SubObject]=(symboldatabase->functionScopes)@104}
  start possible {lifetime[Iterator]=(symboldatabase->functionScopes)@104,start=0@104}
  last possible {lifetime[Iterator]=(symboldatabase->functionScopes)@104,end=0@104}
Line 6955
  = always 0
  0 always 0
Line 6956
  ( possible {lifetime[Object]=(symboldatabase->functionScopes),lifetime[Object]=(symboldatabase->functionScopes)}
  ( {lifetime[Iterator]=(symboldatabase->functionScopes),start=0}
  ( {lifetime[Iterator]=(symboldatabase->functionScopes),end=0}
Line 6958
  ! always {!<=-1,!>=2}
  function always symbolic=(scope->function)
Line 6960
  != always {!<=-1,!>=2}
Line 6961
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "%name% (" always "%name% ("
Line 6965
  ! always {!<=-1,!>=2}
  calledFunction always symbolic=(tok->function())
Line 6967
  returnValue possible size=0
Line 6968
  ! {!<=-1,!>=2,0}
  returnValue possible size=0
  ( {!<=-1,!>=2,1}
Line 6973
  calledFunction {symbolic=(tok->function()),!0}
Line 6974
  ! always {!<=-1,!>=2}
  calledFunctionScope always symbolic=(calledFunction->functionScope)
Line 6981
  = always 0
  0U always 0
  argnr possible 0
  < always {!<=-1,!>=2}
  ( always !<=-1
Line 6982
  argnr {<=symbolic=(callArguments.size()-1),!>=symbolic=(callArguments.size())}
Line 6984
  calledFunction always !0
  argnr {<=symbolic=(callArguments.size()-1),!>=symbolic=(callArguments.size())}
Line 6985
  ! always {!<=-1,!>=2}
Line 6993
  ( always {!<=-1,!>=2}
Line 6994
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 6995
  false always 0
Line 6998
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always !0
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always !<=-1
  == always {!<=-1,!>=2}
  1 always 1
  && always {!<=-1,!>=2}
  argvalues always size=1
  ( always {!<=-1,!>=2}
Line 6999
  ( always {!<=-1,!>=2}
  false always 0
  :: always 0
  NO_ALLOC always 0
  0 always 0
Line 7003
  argvalues possible size=1
  ( {!<=-1,!>=2,0}
Line 7007
  argvalues {size=1,!size=0}
Line 7008
  1 always 1
  1 always 1
Line 7011
  "Calling function '" always "Calling function '"
Line 7013
  "', " always "', "
Line 7015
  " argument '" always " argument '"
Line 7017
  "' value is " always "' value is "
Line 7019
  256 always 256
  % always !>=256
  256 always 256
Line 7021
  ( always {!<=-1,!>=2}
Line 7022
  = always 2
  :: always 2
  SubFunction always 2
Line 7026
  argvalues always !size=0
Line 7028
  argvar always !0
Line 7030
  argvars possible size=0
Line 7037
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 7042
  ! always {!<=-1,!>=2}
  function always symbolic=(scope->function)
Line 7044
  arg always !<=-1
  = always !<=-1
  function {symbolic=(scope->function),!0}
  ( always !<=-1
  arg always !<=-1
  < always {!<=-1,!>=2}
  function {symbolic=(scope->function),!0}
  ( always !<=-1
  arg always !<=-1
  ++ always !<=-1
Line 7045
  function {symbolic=(scope->function),!0}
  arg {!<=-1,<=symbolic=(function->argCount()-1),!>=symbolic=(function->argCount())}
Line 7046
  && always {!<=-1,!>=2}
  var always !0
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  var always !0
  "%var% = %num%|%str% [,)]" always "%var% = %num%|%str% [,)]"
Line 7047
  var always !0
  2 always 2
Line 7051
  . always {!<=-1,!>=2}
  defaultArg always {!<=-1,!>=2}
  = always 1
  true always 1
Line 7053
  ( always {!<=-1,!>=2}
Line 7056
  ! {!<=-1,!>=2,0}
  argvalues possible size=0
  ( {!<=-1,!>=2,1}
Line 7057
  var always !0
  argvalues always !size=0
Line 7063
  ( always {!<=-1,!>=2}
Line 7065
  return always {!<=-1,!>=2}
  tok possible {symbolic=(tok->astOperand2())@72,0@72}
  && always {!<=-1,!>=2}
  tok always !0
  ( always {!<=-1,!>=2}
Line 7071
  != always {!<=-1,!>=2}
  "(" always "("
  || always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
Line 7074
  = always 0
  nullptr always 0
Line 7075
  ( always {!<=-1,!>=2}
  "%name% (" always "%name% ("
Line 7078
  ( always !0
Line 7079
  ! always {!<=-1,!>=2}
  function possible {symbolic=(tok->previous()->function()),symbolic=(tok->astOperand1()->function())}
Line 7082
  function always !0
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  function always !0
  ( always {!<=-1,!>=2}
Line 7085
  ( always {!<=-1,!>=2}
Line 7091
  = always !0
  ( always !0
Line 7092
  partok possible symbolic=(tok->astOperand2())
  && always {!<=-1,!>=2}
  partok {symbolic=(tok->astOperand2()),!0}
  == always {!<=-1,!>=2}
  "," always ","
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  partok {symbolic=(tok->astOperand2()),!0}
Line 7093
  partok always !0
Line 7094
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  partok possible {symbolic=(tok->astOperand2()),0}
Line 7098
  partok possible symbolic=(tok)
  && always {!<=-1,!>=2}
  partok always !0
  == always {!<=-1,!>=2}
  "," always ","
Line 7099
  partok always !0
Line 7100
  partok always !0
Line 7102
  partok possible 0
  != always {!<=-1,!>=2}
Line 7108
  ! {!<=-1,!>=2,1}
  functionScope {symbolic=(function->functionScope),0}
  || always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  functionScope {symbolic=(function->functionScope),!0}
  "{ return" always "{ return"
Line 7109
  functionScope {symbolic=(function->functionScope),0}
  && always {!<=-1,!>=2}
  . always {!<=-1,!>=2}
  debugwarnings always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  functionScope {symbolic=(function->functionScope),!0}
  "return" always "return"
  functionScope {symbolic=(function->functionScope),!0}
Line 7110
  "valueFlowBailout" always "valueFlowBailout"
  "function return; nontrivial function body" always "function return; nontrivial function body"
  "cppcheck-2.8/lib/valueflow.cpp" always "cppcheck-2.8/lib/valueflow.cpp"
  7110 always 7110
Line 7115
  i always !<=-1
  = always 0
  0 always 0
  i {!<=-1,0}
  < always {!<=-1,!>=2}
  ( always !<=-1
  ++ always !<=0
  i always !<=-1
Line 7116
  i {!<=-1,<=symbolic=(parvalues.size()-1),!>=symbolic=(parvalues.size())}
Line 7117
  ! always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  arg always !0
  "%type% %name% ,|)" always "%type% %name% ,|)"
Line 7118
  . always {!<=-1,!>=2}
  debugwarnings always {!<=-1,!>=2}
Line 7119
  "valueFlowBailout" always "valueFlowBailout"
  "function return; unhandled argument type" always "function return; unhandled argument type"
  "cppcheck-2.8/lib/valueflow.cpp" always "cppcheck-2.8/lib/valueflow.cpp"
  7119 always 7119
Line 7120
  programMemory always NonMovedVariable
Line 7123
  arg always !0
  i always !<=-1
Line 7125
  programMemory possible NonMovedVariable
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 7129
  = always 0
  0 always 0
Line 7130
  error always {!<=-1,!>=2}
  error always {!<=-1,!>=2}
  = always 0
  false always 0
Line 7132
  & {lifetime[Address]=(programMemory),!0}
  programMemory possible NonMovedVariable
Line 7133
  & {lifetime[Address]=(result),!0}
  result always 0
Line 7134
  & {lifetime[Address]=(error),!0}
  error always 0
Line 7135
  ! always {!<=-1,!>=2}
  error always {!<=-1,!>=2}
Line 7137
  ( always {!<=-1,!>=2}
Line 7146
  ( always {!<=-1,!>=2}
  , always {!<=-1,!>=2}
  cpp always {!<=-1,!>=2}
Line 7148
  ! always {!<=-1,!>=2}
  var possible lifetime[Address]=(scope->varlist)@33
Line 7149
  return always {!<=-1,!>=2}
  false always 0
Line 7150
  var {!0,lifetime[Address]=(scope->varlist)@33}
  ( always {!<=-1,!>=2}
Line 7151
  return always {!<=-1,!>=2}
  true always 1
Line 7152
  var always !0
  ( possible 0
  && always {!<=-1,!>=2}
  var always !0
  ( always !0
  ( always {!<=-1,!>=2}
Line 7153
  return always {!<=-1,!>=2}
  false always 0
Line 7154
  ! always {!<=-1,!>=2}
  cpp always {!<=-1,!>=2}
Line 7155
  return always {!<=-1,!>=2}
  true always 1
Line 7156
  && always {!<=-1,!>=2}
  ( always !0
  == always {!<=-1,!>=2}
  :: always 1
  True always 1
Line 7157
  return always {!<=-1,!>=2}
  true always 1
Line 7158
  && always {!<=-1,!>=2}
  ( always !0
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  ( always !0
  == always {!<=-1,!>=2}
  :: always 1
  POD always 1
Line 7159
  return always {!<=-1,!>=2}
  true always 1
Line 7160
  return always {!<=-1,!>=2}
  false always 0
Line 7166
  ( {lifetime[Iterator]=(value.errorPath),lifetime[Object]=(errorPath),start=0}
Line 7167
  ( {lifetime[Iterator]=(value.errorPath),lifetime[Object]=(errorPath),end=0}
Line 7168
  locations always size=0
  ( {lifetime[Iterator]=(locations),start=0}
Line 7172
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
Line 7173
  = always !0
  . always !0
Line 7174
  ( {lifetime[Iterator]=(from.errorPath),lifetime[Object]=(errorPath),start=0}
Line 7175
  ( {lifetime[Iterator]=(from.errorPath),lifetime[Object]=(errorPath),end=0}
Line 7176
  ( possible lifetime[Object]=(errorPath)
Line 7177
  [ possible lifetime[Lambda]=(locations)
Line 7185
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 7187
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "%var% ;|[" always "%var% ;|["
Line 7190
  ! always {!<=-1,!>=2}
  var always symbolic=(tok->variable())
Line 7192
  var {symbolic=(tok->variable()),!0}
  != always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  var {symbolic=(tok->variable()),!0}
  ( always {!<=-1,!>=2}
Line 7194
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  var always !0
  ( always {!<=-1,!>=2}
Line 7196
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 7201
  = always 4
  :: always 4
  UNINIT always 4
Line 7203
  ( always {!<=-1,!>=2}
Line 7204
  = always !<=-1
  ( always !<=-1
Line 7206
  partial {!<=-1,!>=2,0}
  partial always {!<=-1,!>=2}
  = always 0
  false always 0
Line 7210
  scope always !0
  "union" always "union"
  scope always !0
Line 7212
  scope always !0
Line 7213
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 7216
  ( always {!<=-1,!>=2}
Line 7218
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  & {lifetime[Address]=(scope->varlist),!0}
  ( always {!<=-1,!>=2}
Line 7219
  partial always {!<=-1,!>=2}
  = always 1
  true always 1
Line 7225
  && always {!<=-1,!>=2}
  : always {!<=-1,!>=2}
Line 7229
  tok2 always symbolic=(p.first)
  v always symbolic=(p.second)
Line 7231
  inserted always {!<=-1,!>=2}
  inserted always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
Line 7233
  ! always {!<=-1,!>=2}
  inserted {symbolic=(pp.second),!<=-1,!>=2}
Line 7234
  != always {!<=-1,!>=2}
  v2 always {symbolic=(pp.first->second),symbolic=(v2)}
Line 7238
  v2 possible {symbolic=(pp.first->second),symbolic=(v2)}
Line 7243
  && always {!<=-1,!>=2}
  : always {!<=-1,!>=2}
  partialReads possible size=0
Line 7250
  partial {!<=-1,!>=2,0}
Line 7257
  ( always {!<=-1,!>=2}
Line 7259
  , always 0
Line 7260
  = always 0
  nullptr always 0
  , always 20
Line 7261
  = always 20
  20 always 20
Line 7263
  ( always {!<=-1,!>=2}
  , always 0
  = always 0
  nullptr always 0
  , always 20
  = always 20
  20 always 20
Line 7265
  ! always {!<=-1,!>=2}
Line 7266
  return always {!<=-1,!>=2}
  false always 0
Line 7267
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 7268
  return always {!<=-1,!>=2}
  false always 0
Line 7270
  ( always {!<=-1,!>=2}
  "%name% . %name% (" always "%name% . %name% ("
Line 7271
  2 always 2
Line 7272
  != always {!<=-1,!>=2}
  :: always 9
  NO_YIELD always 9
Line 7273
  return always {!<=-1,!>=2}
  false always 0
Line 7275
  ( always {!<=-1,!>=2}
  "[" always "["
Line 7276
  return always {!<=-1,!>=2}
  false always 0
Line 7279
  addressOf always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always !0
  ( always {!<=-1,!>=2}
  "&" always "&"
Line 7282
  narg always Uninit
Line 7283
  ! always {!<=-1,!>=2}
Line 7284
  return always {!<=-1,!>=2}
  false always 0
Line 7285
  ftok always !0
Line 7286
  fun always symbolic=(ftok->function())
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  fun {symbolic=(ftok->function()),!0}
  ( always {!<=-1,!>=2}
Line 7287
  fun {symbolic=(ftok->function()),!0}
Line 7289
  ! always {!<=-1,!>=2}
  arg always !0
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  addressOf {symbolic=(tok->valueType()->pointer||(tok->astParent()&&tok->astParent()->isUnaryOp("&"))),!<=-1,!>=2}
Line 7290
  return always {!<=-1,!>=2}
  false always 0
Line 7291
  ! always {!<=-1,!>=2}
  addressOf always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  arg always !0
  ( always {!<=-1,!>=2}
Line 7292
  return always {!<=-1,!>=2}
  false always 0
Line 7293
  && always {!<=-1,!>=2}
  ( always !0
  == always {!<=-1,!>=2}
  1 always 1
Line 7294
  return always {!<=-1,!>=2}
  false always 0
Line 7296
  scope always symbolic=(fun->functionScope)
Line 7298
  ! always {!<=-1,!>=2}
Line 7299
  return always {!<=-1,!>=2}
  false always 0
Line 7300
  > always {!<=-1,!>=2}
  0 always 0
Line 7301
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 7302
  scope {symbolic=(fun->functionScope),!0}
  scope {symbolic=(fun->functionScope),!0}
  depth {>=1,!<=0}
  - {>=0,!<=-1}
  1 always 1
Line 7305
  return always {!<=-1,!>=2}
  true always 1
Line 7309
  inconclusive always {!<=-1,!>=2}
  inconclusive always {!<=-1,!>=2}
  = always 0
  false always 0
Line 7310
  isChanged always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  0 always 0
  & {lifetime[Address]=(inconclusive),!0}
  inconclusive always 0
Line 7311
  return always {!<=-1,!>=2}
  isChanged always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  inconclusive always {!<=-1,!>=2}
Line 7321
  ( always {!<=-1,!>=2}
Line 7322
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  ( always !symbolic=(tok->exprId())
Line 7326
  ( always {!<=-1,!>=2}
Line 7328
  == always {!<=-1,!>=2}
Line 7330
  ! always {!<=-1,!>=2}
Line 7332
  ! always {!<=-1,!>=2}
Line 7334
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 7339
  . always {!<=-1,!>=2}
  stdStringLike always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  parent always symbolic=(tok->astParent())
  "+=" always "+="
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  parent always symbolic=(tok->astParent())
Line 7340
  = always !0
  parent always symbolic=(tok->astParent())
  ( always !0
Line 7341
  rhs {symbolic=(parent->astOperand2()),!0}
  == always {!<=-1,!>=2}
  :: always 6
  eString always 6
Line 7343
  rhs {symbolic=(parent->astOperand2()),!0}
Line 7344
  && always {!<=-1,!>=2}
  rhsContainer always !0
  . always {!<=-1,!>=2}
  stdStringLike always {!<=-1,!>=2}
Line 7345
  ( always {!<=-1,!>=2}
  rhs {symbolic=(parent->astOperand2()),!0}
  ( {lifetime[Iterator]=(rhs->values()),start=0}
  rhs {symbolic=(parent->astOperand2()),!0}
  ( {lifetime[Iterator]=(rhs->values()),end=0}
Line 7346
  && always {!<=-1,!>=2}
Line 7350
  ( always {!<=-1,!>=2}
  "%name% . %name% (" always "%name% . %name% ("
Line 7351
  2 always 2
Line 7352
  action possible 3
  == {!<=-1,!>=2,0}
  :: always 2
  PUSH always 2
  || always {!<=-1,!>=2}
  action always !2
  == always {!<=-1,!>=2}
  :: always 3
  POP always 3
Line 7353
  3 always 3
Line 7354
  ( always !<=-1
  < always {!<=-1,!>=2}
  2 always 2
Line 7362
  == always {!<=-1,!>=2}
Line 7364
  ! always {!<=-1,!>=2}
Line 7366
  ! always {!<=-1,!>=2}
Line 7368
  ! always {!<=-1,!>=2}
Line 7370
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 7375
  . always {!<=-1,!>=2}
  stdStringLike always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  parent always symbolic=(tok->astParent())
  "+=" always "+="
  && always {!<=-1,!>=2}
  parent always symbolic=(tok->astParent())
Line 7376
  = always !0
  parent always symbolic=(tok->astParent())
  ( always !0
Line 7377
  rhs {symbolic=(parent->astOperand2()),!0}
Line 7378
  rhs {symbolic=(parent->astOperand2()),!0}
  == always {!<=-1,!>=2}
  :: always 6
  eString always 6
Line 7379
  rhs {symbolic=(parent->astOperand2()),!0}
Line 7380
  && always {!<=-1,!>=2}
  rhsContainer always !0
  . always {!<=-1,!>=2}
  stdStringLike always {!<=-1,!>=2}
Line 7381
  rhs {symbolic=(parent->astOperand2()),!0}
Line 7382
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 7387
  ( always {!<=-1,!>=2}
  "%name% . %name% (" always "%name% . %name% ("
Line 7388
  2 always 2
Line 7389
  action possible 3
  == {!<=-1,!>=2,0}
  :: always 2
  PUSH always 2
Line 7391
  action possible 2
  == {!<=-1,!>=2,0}
  :: always 3
  POP always 3
Line 7399
  ( always {!<=-1,!>=2}
Line 7401
  ( always {!<=-1,!>=2}
  "%assign%" always "%assign%"
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 7403
  ( always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 7405
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 7418
  endToken possible {symbolic=(f->functionScope->bodyEnd)@219,0@219}
Line 7435
  = always 0
  nullptr always 0
Line 7437
  && always {!<=-1,!>=2}
  f always !0
Line 7438
  f always !0
  . always !0
Line 7439
  endToken possible {symbolic=(f->functionScope->bodyEnd),0}
Line 7455
  ( always {!<=-1,!>=2}
Line 7457
  ! always {!<=-1,!>=2}
Line 7458
  return always {!<=-1,!>=2}
  false always 0
Line 7459
  ! always {!<=-1,!>=2}
  tok always !0
  || always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  tok always !0
  ( always !0
Line 7460
  return always {!<=-1,!>=2}
  true always 1
Line 7461
  ( always {!<=-1,!>=2}
  tok always !0
  "%name% %assign%|<<" always "%name% %assign%|<<"
Line 7462
  return always {!<=-1,!>=2}
  true always 1
Line 7463
  ( always {!<=-1,!>=2}
  "%var% [" always "%var% ["
  && always {!<=-1,!>=2}
  ( always !0
  . always !0
  . always {!<=-1,!>=2}
  stdAssociativeLike always {!<=-1,!>=2}
Line 7464
  return always {!<=-1,!>=2}
  true always 1
Line 7465
  ( always {!<=-1,!>=2}
  "%name% . %name% (" always "%name% . %name% ("
Line 7466
  2 always 2
Line 7467
  2 always 2
Line 7469
  :: always 0
  RESIZE always 0
Line 7470
  :: always 1
  CLEAR always 1
Line 7471
  :: always 2
  PUSH always 2
Line 7472
  :: always 3
  POP always 3
Line 7473
  :: always 8
  CHANGE always 8
Line 7474
  :: always 5
  INSERT always 5
Line 7475
  :: always 6
  ERASE always 6
Line 7476
  return always {!<=-1,!>=2}
  true always 1
Line 7477
  :: always 10
  NO_ACTION always 10
Line 7478
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 9
  NO_YIELD always 9
Line 7479
  :: always 4
  FIND always 4
Line 7480
  :: always 7
  CHANGE_CONTENT always 7
Line 7481
  :: always 9
  CHANGE_INTERNAL always 9
Line 7485
  ( always {!<=-1,!>=2}
Line 7486
  return always {!<=-1,!>=2}
  true always 1
Line 7487
  return always {!<=-1,!>=2}
  false always 0
Line 7490
  ( always {!<=-1,!>=2}
Line 7496
  != always {!<=-1,!>=2}
Line 7497
  != always {!<=-1,!>=2}
Line 7499
  ( always {!<=-1,!>=2}
Line 7500
  return always {!<=-1,!>=2}
  true always 1
Line 7502
  return always {!<=-1,!>=2}
  false always 0
Line 7507
  tok possible symbolic=(var->nameToken())
Line 7508
  ! always {!<=-1,!>=2}
Line 7510
  ! always {!<=-1,!>=2}
  ( always !0
  ( always {!<=-1,!>=2}
Line 7512
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 7514
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "%var% (|{|;" always "%var% (|{|;"
Line 7515
  = always !0
  ( always !0
Line 7516
  ! always {!<=-1,!>=2}
  var {symbolic=(tok->variable()),!0}
  ( always {!<=-1,!>=2}
Line 7518
  var {symbolic=(tok->variable()),!0}
  == always {!<=-1,!>=2}
Line 7519
  ( always {!<=-1,!>=2}
  tok always symbolic=(var->nameToken())
  "%var% (|{" always "%var% (|{"
  && always {!<=-1,!>=2}
  tok always symbolic=(var->nameToken())
  && always {!<=-1,!>=2}
Line 7520
  tok always symbolic=(var->nameToken())
  ( always !0
  != always {!<=-1,!>=2}
  "," always ","
Line 7521
  = always !0
  tok always symbolic=(var->nameToken())
  ( always !0
Line 7522
  inTok {symbolic=(tok->next()->astOperand2()),!0}
Line 7523
  constValue always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  inTok {symbolic=(tok->next()->astOperand2()),!0}
  ( always {!<=-1,!>=2}
Line 7524
  inTok {symbolic=(tok->next()->astOperand2()),!0}
  var {symbolic=(tok->variable()),!0}
  constValue always {!<=-1,!>=2}
  true always 1
Line 7526
  ( always {!<=-1,!>=2}
  tok always symbolic=(var->nameToken())
  "%var% ;" always "%var% ;"
Line 7528
  0 always 0
Line 7530
  values always size=0
Line 7531
  tok always symbolic=(var->nameToken())
  var always !0
  values always size=1
  false always 0
  true always 1
Line 7534
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  ". %name% (" always ". %name% ("
  && always {!<=-1,!>=2}
Line 7535
  != always {!<=-1,!>=2}
  "->" always "->"
Line 7537
  2 always 2
Line 7538
  ( always {!<=-1,!>=2}
  ". reset (" always ". reset ("
Line 7539
  ( always {!<=-1,!>=2}
  "( )" always "( )"
Line 7541
  0 always 0
Line 7543
  values always size=0
Line 7544
  values always size=1
  false always 0
Line 7546
  & {lifetime[Address]=(isIntValue),!0}
Line 7548
  ! always {!<=-1,!>=2}
  inTok always symbolic=(ftok->astOperand2())
Line 7550
  inTok {symbolic=(ftok->astOperand2()),!0}
Line 7551
  inTok {symbolic=(ftok->astOperand2()),!0}
  false always 0
Line 7553
  ( always {!<=-1,!>=2}
  ". release ( )" always ". release ( )"
Line 7555
  hasParentReset always {!<=-1,!>=2}
  hasParentReset always {!<=-1,!>=2}
  = always 0
  false always 0
Line 7556
  parent possible symbolic=(ftok->astParent())
Line 7557
  ( always {!<=-1,!>=2}
  parent {symbolic=(ftok->astParent()),!0}
  -2 always -2
  ". release|reset (" always ". release|reset ("
  && always {!<=-1,!>=2}
Line 7558
  parent always !0
  -2 always -2
  == always {!<=-1,!>=2}
Line 7559
  hasParentReset always {!<=-1,!>=2}
  = always 1
  true always 1
Line 7562
  parent always !0
Line 7564
  hasParentReset {!<=-1,!>=2,0,1}
Line 7567
  0 always 0
Line 7569
  values always size=0
Line 7570
  values always size=1
  false always 0
Line 7571
  ( always {!<=-1,!>=2}
  ". get ( )" always ". get ( )"
Line 7573
  2 always 2
Line 7575
  ( always {!<=-1,!>=2}
  "%name%|> (|{" always "%name%|> (|{"
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 7576
  ( always {!<=-1,!>=2}
Line 7578
  ( always {!<=-1,!>=2}
Line 7580
  args always !size=0
Line 7589
  ! always {!<=-1,!>=2}
Line 7591
  ! always {!<=-1,!>=2}
  ( always !0
  ( always {!<=-1,!>=2}
Line 7593
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 7595
  ( always {!<=-1,!>=2}
  ". %name% (" always ". %name% ("
Line 7596
  1 always 1
Line 7597
  0 always 0
Line 7599
  yield possible 5
  == {!<=-1,!>=2,0}
  :: always 4
  START_ITERATOR always 4
Line 7600
  = always 8
  :: always 8
  ITERATOR_START always 8
Line 7601
  2 always 2
Line 7602
  yield always !4
  == always {!<=-1,!>=2}
  :: always 5
  END_ITERATOR always 5
Line 7603
  = always 9
  :: always 9
  ITERATOR_END always 9
Line 7604
  2 always 2
Line 7610
  = always 0
  nullptr always 0
Line 7612
  [ possible lifetime[Lambda]=(kind)
Line 7613
  kind possible {lifetime[Address]=(kind)@125,lifetime[Address]=(kind)@129}
  && always {!<=-1,!>=2}
  != always {!<=-1,!>=2}
  kind {!0,lifetime[Address]=(kind)@125,lifetime[Address]=(kind)@129}
Line 7614
  true always 1
Line 7615
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 7627
  ( always {!<=-1,!>=2}
  "==|!=" always "==|!="
Line 7628
  ! always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
Line 7629
  { always {size=0,{}
Line 7631
  = always 1
  :: always 1
  Known always 1
Line 7632
  ( always !0
  & {lifetime[Address]=(kind),!0}
  kind always 1
Line 7633
  ! {!<=-1,!>=2,0}
  values possible size=0
  ( {!<=-1,!>=2,1}
Line 7634
  = always !0
  ( always !0
Line 7636
  ( always !0
  & {lifetime[Address]=(kind),!0}
Line 7637
  ! {!<=-1,!>=2,0}
  values possible size=0
  ( {!<=-1,!>=2,1}
Line 7638
  = always !0
  ( always !0
Line 7640
  values possible size=0
Line 7644
  = possible size=0
  values possible size=0
Line 7645
  = possible size=0
  values possible size=0
Line 7648
  { always {size=1,{}
Line 7655
  ! always {!<=-1,!>=2}
Line 7657
  ! always {!<=-1,!>=2}
  ( always !0
  ( always {!<=-1,!>=2}
Line 7661
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 7662
  true always 1
Line 7663
  ! always {!<=-1,!>=2}
Line 7664
  true always 1
Line 7665
  != always {!<=-1,!>=2}
Line 7666
  true always 1
Line 7667
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  <= always {!<=-1,!>=2}
  0 always 0
Line 7668
  true always 1
Line 7669
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  >= always {!<=-1,!>=2}
  0 always 0
Line 7670
  true always 1
Line 7671
  false always 0
Line 7675
  ( always {!<=-1,!>=2}
Line 7677
  ( always {!<=-1,!>=2}
Line 7688
  tok always !0
  ( {lifetime[Iterator]=(tok->values()),start=0}
Line 7689
  tok always !0
  ( {lifetime[Iterator]=(tok->values()),end=0}
Line 7690
  ( possible lifetime[Object]=(values)
  values always size=0
Line 7691
  & {lifetime[Address]=(isContainerSizeValue),!0}
Line 7693
  values possible size=0
Line 7696
  s always !<=-1
  known always {!<=-1,!>=2}
  = always 1
  true always 1
Line 7698
  s {!<=-1,0@79}
Line 7699
  = always 5
  :: always 5
  CONTAINER_SIZE always 5
Line 7700
  known always {!<=-1,!>=2}
Line 7705
  known always {!<=-1,!>=2}
  = always 1
  true always 1
Line 7707
  ( always {!<=-1,!>=2}
Line 7708
  { always {size=1,{}
  known always {!<=-1,!>=2}
Line 7709
  { always {size=0,{}
Line 7714
  known always {!<=-1,!>=2}
Line 7716
  ( always {!<=-1,!>=2}
  args possible size=1
  0 always 0
  false always 0
Line 7717
  ( always !<=-1
  == always {!<=-1,!>=2}
  1 always 1
  || always {!<=-1,!>=2}
  args always !size=1
  ( always {!<=-1,!1}
  > always {!<=-1,!>=2}
  1 always 1
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  args {!size=1,>=size=2}
  1 always 1
  false always 0
Line 7718
  { always {size=1,{}
  0 always 0
  known always {!<=-1,!>=2}
Line 7719
  ( always {!<=-1,!>=2}
  0 always 0
  && always {!<=-1,!>=2}
  ( always !<=-1
  == always {!<=-1,!>=2}
  1 always 1
Line 7720
  args always size=1
  0 always 0
Line 7721
  ( always {!<=-1,!>=2}
Line 7722
  0 always 0
Line 7723
  ! {!<=-1,!>=2,0}
  result possible size=0
  ( {!<=-1,!>=2,1}
Line 7724
  result always !size=0
Line 7726
  ( always {!<=-1,!>=2}
  0 always 0
  && always {!<=-1,!>=2}
  0 always 0
  != always {!<=-1,!>=2}
  0 always 0
Line 7729
  0 always 0
  ( always !0
  == always {!<=-1,!>=2}
  1 always 1
Line 7730
  { always {size=1,{}
  { always 0
  0 always 0
  known always {!<=-1,!>=2}
Line 7732
  ( always {!<=-1,!>=2}
  1 always 1
  "+" always "+"
Line 7733
  0 always 0
Line 7734
  1 always 1
Line 7735
  1 always 1
Line 7736
  sizetok always symbolic=(args[1]->astOperand2())
  == always {!<=-1,!>=2}
  eid always symbolic=(args[0]->exprId())
Line 7737
  vartok always symbolic=(args[1]->astOperand1())
  sizetok always symbolic=(args[1]->astOperand2())
Line 7738
  vartok {symbolic=(args[1]->astOperand1()),symbolic=(args[1]->astOperand2())}
  == always {!<=-1,!>=2}
  eid always symbolic=(args[0]->exprId())
  && always {!<=-1,!>=2}
  sizetok inconclusive symbolic=(args[1]->astOperand2())
  ( always {!<=-1,!>=2}
Line 7739
  { always {size=1,{}
  known always {!<=-1,!>=2}
Line 7742
  . always {!<=-1,!>=2}
  stdStringLike always {!<=-1,!>=2}
Line 7743
  ( always {!<=-1,!>=2}
  args possible size=2
  0 always 0
Line 7745
  ( always !<=-1
  == always {!<=-1,!>=2}
  2 always 2
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  args always size=2
  1 always 1
  false always 0
Line 7746
  { always {size=1,{}
  1 always 1
  known always {!<=-1,!>=2}
Line 7747
  ( always {!<=-1,!>=2}
  args possible size=1
  0 always 0
Line 7748
  ( always !<=-1
  == always {!<=-1,!>=2}
  1 always 1
Line 7749
  args always size=1
  0 always 0
Line 7750
  args always !size=1
  ( always {!<=-1,!1}
  == always {!<=-1,!>=2}
  3 always 3
Line 7751
  { always {size=1,{}
  args always size=3
  2 always 2
  known always {!<=-1,!>=2}
Line 7755
  { always {size=0,{}
Line 7761
  known always {!<=-1,!>=2}
  = always 1
  true always 1
Line 7763
  tok possible symbolic=(var->nameToken()->next())@26
Line 7764
  ( always {!<=-1,!>=2}
Line 7765
  { always {size=1,{}
  { always 0
  0 always 0
  known always {!<=-1,!>=2}
Line 7766
  initList always {!<=-1,!>=2}
  initList always {!<=-1,!>=2}
  = always 1
  true always 1
Line 7768
  args always !size=0
  ( always !<=0
  < always {!<=-1,!>=2}
  4 always 4
Line 7769
  initList always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  args {!size=0,<=size=3,!>=size=4}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  args always {!size=0,!>=size=4}
  ( always {!>=4,!<=0}
  < always {!<=-1,!>=2}
  3 always 3
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  args {!size=0,<=size=2,!>=size=3}
  0 always 0
  false always 0
Line 7771
  . always {!<=-1,!>=2}
  stdStringLike always {!<=-1,!>=2}
Line 7772
  initList always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  args always {!size=0,!>=size=4}
  0 always 0
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  args always {!size=0,!>=size=4}
  0 always 0
Line 7773
  containerTypeToken always symbolic=(valueType->containerTypeToken)
  && always {!<=-1,!>=2}
Line 7774
  containerTypeToken {symbolic=(valueType->containerTypeToken),!0}
  settings always !0
Line 7775
  > always {!<=-1,!>=2}
  0 always 0
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  args always {!size=0,!>=size=4}
  0 always 0
Line 7776
  initList always {!<=-1,!>=2}
  = always 1
  true always 1
Line 7777
  == always {!<=-1,!>=2}
  :: always 6
  ITERATOR always 6
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  args always {!size=0,!>=size=4}
  0 always 0
Line 7778
  initList always {!<=-1,!>=2}
  = always 1
  true always 1
Line 7779
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  args always {!size=0,!>=size=4}
  0 always 0
  false always 0
Line 7780
  initList always {!<=-1,!>=2}
  = always 1
  true always 1
Line 7783
  ! {!<=-1,!>=2,0}
  initList {!<=-1,!>=2,1}
Line 7784
  args always !size=0
  known always {!<=-1,!>=2}
Line 7785
  { always {size=1,{}
  args always !size=0
  ( always !<=0
  known always {!<=-1,!>=2}
Line 7791
  known always {!<=-1,!>=2}
  = always 1
  true always 1
Line 7793
  tok possible symbolic=(var->nameToken()->next())@33
Line 7794
  args possible size=1
  ( {!<=-1,!>=2,0}
Line 7795
  { always {size=1,{}
  { always 0
  0 always 0
  known always {!<=-1,!>=2}
Line 7797
  args always !size=0
  ( always !<=0
  == always {!<=-1,!>=2}
  1 always 1
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  args always size=1
  0 always 0
  "{" always "{"
Line 7798
  args always size=1
  0 always 0
  known always {!<=-1,!>=2}
Line 7799
  args always !size=0
  known always {!<=-1,!>=2}
Line 7809
  ! always {!<=-1,!>=2}
Line 7811
  ! always {!<=-1,!>=2}
  var always !0
  || always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  var always !0
  ( always !0
  || always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  var always !0
  ( always !0
Line 7813
  ! always {!<=-1,!>=2}
  var always !0
  || always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  var always !0
  ( always !0
Line 7815
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 7818
  known always {!<=-1,!>=2}
  known always {!<=-1,!>=2}
  = always 1
  true always 1
Line 7819
  = always 0
  0 always 0
Line 7820
  nonLocal always {!<=-1,!>=2}
  nonLocal always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 7821
  constSize always {!<=-1,!>=2}
  constSize always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  nonLocal {symbolic=(!var->isLocal()||var->isPointer()||var->isReference()||var->isStatic()),!<=-1,!>=2}
Line 7822
  staticSize {!<=-1,!>=2,0}
  staticSize always {!<=-1,!>=2}
  = always 0
  false always 0
Line 7823
  ( always !0
  . always !0
  >= always {!<=-1,!>=2}
  0 always 0
Line 7824
  staticSize always {!<=-1,!>=2}
  = always 1
  true always 1
Line 7825
  constSize always {!<=-1,!>=2}
  = always 1
  true always 1
Line 7826
  = always -1
  -1 always -1
Line 7827
  ( always !<=-1
  == always {!<=-1,!>=2}
  1 always 1
Line 7828
  ( always size=1
Line 7829
  dim always symbolic=(var->dimensions().front())
  . always {!<=-1,!>=2}
  known always {!<=-1,!>=2}
Line 7830
  dim always symbolic=(var->dimensions().front())
Line 7831
  dim always symbolic=(var->dimensions().front())
  && always {!<=-1,!>=2}
  dim always symbolic=(var->dimensions().front())
  . always !0
  ( always {!<=-1,!>=2}
Line 7832
  dim always symbolic=(var->dimensions().front())
  . always !0
Line 7835
  size possible -1
  < {!<=-1,!>=2,1}
  0 always 0
Line 7838
  ! {!<=-1,!>=2,1,0}
  staticSize {!<=-1,!>=2,0,1}
  && always {!<=-1,!>=2}
  nonLocal {symbolic=(!var->isLocal()||var->isPointer()||var->isReference()||var->isStatic()),!<=-1,!>=2}
Line 7840
  ( always {!<=-1,!>=2}
  :: always 5
  CONTAINER_SIZE always 5
Line 7842
  ! always {!<=-1,!>=2}
  staticSize always {!<=-1,!>=2}
Line 7843
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "%name% ;" always "%name% ;"
  && always {!<=-1,!>=2}
Line 7844
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "%name% {" always "%name% {"
  && always {!<=-1,!>=2}
Line 7845
  ( always {!<=-1,!>=2}
  "} ;" always "} ;"
  && always {!<=-1,!>=2}
Line 7846
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "%name% (" always "%name% ("
Line 7849
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  ( always !0
  "for|while" always "for|while"
Line 7850
  known always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  true always 1
Line 7852
  values always {{,size=1}
  = always 5
  :: always 5
  CONTAINER_SIZE always 5
Line 7853
  known always {!<=-1,!>=2}
Line 7854
  values always size=1
Line 7855
  ! always {!<=-1,!>=2}
  staticSize always {!<=-1,!>=2}
Line 7856
  ( always {!<=-1,!>=2}
  "{" always "{"
Line 7858
  initList always symbolic=(var->nameToken()->next())
  known always {!<=-1,!>=2}
Line 7859
  ( always {!<=-1,!>=2}
  "(" always "("
Line 7861
  constructorArgs always symbolic=(var->nameToken()->next())
  known always {!<=-1,!>=2}
Line 7865
  constSize {!<=-1,!>=2,1,0}
Line 7874
  != always {!<=-1,!>=2}
Line 7875
  ( always {!<=-1,!>=2}
  "%name%|;|{|} %var% = %str% ;" always "%name%|;|{|} %var% = %str% ;"
Line 7877
  containerTok always symbolic=(tok->next())
  == always {!<=-1,!>=2}
  0 always 0
Line 7879
  containerTok always symbolic=(tok->next())
  && always {!<=-1,!>=2}
  containerTok always symbolic=(tok->next())
  ( always !0
  && always {!<=-1,!>=2}
  containerTok always symbolic=(tok->next())
  ( always !0
  . always !0
  . always {!<=-1,!>=2}
  stdStringLike always {!<=-1,!>=2}
Line 7880
  containerTok always symbolic=(tok->next())
  2 always 2
Line 7881
  = always 5
  :: always 5
  CONTAINER_SIZE always 5
Line 7883
  containerTok always symbolic=(tok->next())
  containerTok always symbolic=(tok->next())
Line 7885
  ( always {!<=-1,!>=2}
  "%name%|;|{|}|> %var% = {" always "%name%|;|{|}|> %var% = {"
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  3 always 3
  "} ;" always "} ;"
Line 7887
  containerTok always symbolic=(tok->next())
  == always {!<=-1,!>=2}
  0 always 0
Line 7889
  ( always {!<=-1,!>=2}
  containerTok always symbolic=(tok->next())
  && always {!<=-1,!>=2}
  containerTok always symbolic=(tok->next())
  < always {!<=-1,!>=2}
  0 always 0
Line 7891
  3 always 3
  containerTok always symbolic=(tok->next())
Line 7893
  containerTok always symbolic=(tok->next())
  containerTok always symbolic=(tok->next())
Line 7895
  ( always {!<=-1,!>=2}
  ". %name% (" always ". %name% ("
  && always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always !0
  && always {!<=-1,!>=2}
Line 7896
  ( always !0
  ( always !0
Line 7897
  = always !0
  ( always !0
Line 7898
  containerTok {symbolic=(tok->astOperand1()),!0}
  == always {!<=-1,!>=2}
  0 always 0
Line 7900
  containerTok {symbolic=(tok->astOperand1()),!0}
  1 always 1
Line 7901
  action possible 0
  == {!<=-1,!>=2,0}
  :: always 1
  CLEAR always 1
Line 7902
  0 always 0
Line 7903
  = always 5
  :: always 5
  CONTAINER_SIZE always 5
Line 7905
  containerTok {symbolic=(tok->astOperand1()),!0}
Line 7906
  action always !1
  == always {!<=-1,!>=2}
  :: always 0
  RESIZE always 0
  && always {!<=-1,!>=2}
  2 always 2
  && always {!<=-1,!>=2}
Line 7907
  2 always 2
  ( always {!<=-1,!>=2}
Line 7908
  2 always 2
Line 7909
  = always 5
  :: always 5
  CONTAINER_SIZE always 5
Line 7911
  containerTok {symbolic=(tok->astOperand1()),!0}
Line 7958
  vartok always !0
  :: always 7
  SIZE always 7
Line 7959
  ! always {!<=-1,!>=2}
Line 7960
  { always {size=0,{}
Line 7961
  = always 5
  :: always 5
  CONTAINER_SIZE always 5
Line 7962
  = always 5
  :: always 5
  CONTAINER_SIZE always 5
Line 7965
  = always !0
  vartok always !0
Line 7966
  { always {size=1,{}
Line 7970
  == always {!<=-1,!>=2}
  "(" always "("
Line 7971
  :: always 8
  EMPTY always 8
Line 7973
  ! always {!<=-1,!>=2}
Line 7974
  { always {size=0,{}
Line 7976
  parent possible symbolic=(tok->astParent())
Line 7977
  ( always {!<=-1,!>=2}
  parent {symbolic=(tok->astParent()),!0}
  "%comp%" always "%comp%"
Line 7978
  { always {size=0,{}
Line 7979
  parent always !0
Line 7981
  0LL always 0
Line 7982
  = always 5
  :: always 5
  CONTAINER_SIZE always 5
Line 7985
  = always !0
  vartok always !0
Line 7986
  . always {!<=-1,!>=2}
  inverted always {!<=-1,!>=2}
  = always 1
  true always 1
Line 7987
  { always {size=1,{}
Line 7990
  ( always {!<=-1,!>=2}
  "==|!=" always "==|!="
Line 7991
  = always 0
  nullptr always 0
Line 7992
  ( always {!<=-1,!>=2}
  "%str%" always "%str%"
Line 7995
  ( always {!<=-1,!>=2}
  "%str%" always "%str%"
Line 7999
  ! always {!<=-1,!>=2}
  strtok possible {symbolic=(tok->astOperand1()),symbolic=(tok->astOperand2())}
Line 8000
  { always {size=0,{}
Line 8001
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 8002
  { always {size=0,{}
Line 8003
  strtok always !0
Line 8004
  = always 5
  :: always 5
  CONTAINER_SIZE always 5
Line 8008
  . always {!<=-1,!>=2}
  impossible always {!<=-1,!>=2}
  = always 0
  false always 0
Line 8009
  { always {size=1,{}
Line 8011
  { always {size=0,{}
Line 8017
  = possible lifetime[Lambda]=(settings)
  [ possible lifetime[Lambda]=(settings)
Line 8018
  = always -1
  -1 always -1
Line 8020
  ! always {!<=-1,!>=2}
Line 8022
  ! always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  allocFunc always !0
  == always {!<=-1,!>=2}
  :: always 0
  none always 0
Line 8027
  ( always !<=-1
  >= always {!<=-1,!>=2}
  allocFunc always !0
  allocFunc always !0
  . {<=symbolic=(args.size()),!>=symbolic=(args.size()+1)}
  1 always 1
  : always 0
  nullptr always 0
Line 8028
  ( always !<=-1
  >= always {!<=-1,!>=2}
  allocFunc always !0
  allocFunc always !0
  . {<=symbolic=(args.size()),!>=symbolic=(args.size()+1)}
  1 always 1
  : always 0
  nullptr always 0
Line 8030
  allocFunc always !0
  . always !0
Line 8031
  :: always 0
  none always 0
Line 8033
  :: always 1
  malloc always 1
Line 8034
  && always {!<=-1,!>=2}
  arg1 always !0
  ( always {!<=-1,!>=2}
Line 8035
  arg1 always !0
Line 8037
  :: always 2
  calloc always 2
Line 8038
  && always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  arg1 always !0
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  arg2 always !0
  ( always {!<=-1,!>=2}
Line 8039
  arg1 always !0
  arg2 always !0
Line 8041
  :: always 3
  strdup always 3
Line 8042
  && always {!<=-1,!>=2}
  arg1 always !0
  ( always {!<=-1,!>=2}
Line 8043
  arg1 always !0
Line 8044
  value always symbolic=(arg1->values().back())
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  value always symbolic=(arg1->values().back())
  == always {!<=-1,!>=2}
  :: always 6
  eString always 6
Line 8045
  value always symbolic=(arg1->values().back())
  1 always 1
Line 8049
  sizeValue possible {symbolic=(arg1->getKnownIntValue()),symbolic=(arg1->getKnownIntValue()*arg2->getKnownIntValue())}
Line 8052
  = possible lifetime[Lambda]=(settings)
  [ possible lifetime[Lambda]=(settings)
Line 8053
  = always -1
  -1 always -1
  = always -1
  -1 always -1
Line 8055
  && always {!<=-1,!>=2}
  newTok always !0
Line 8056
  = always 0
  nullptr always 0
  = always 0
  nullptr always 0
Line 8057
  newTok always !0
  ( always !0
  ( possible size=1
  == always {!<=-1,!>=2}
  "[" always "["
Line 8058
  = always !0
  newTok always !0
  ( always !0
Line 8059
  newTok always !0
  ( always !0
  == always {!<=-1,!>=2}
  "(" always "("
Line 8060
  newTok always !0
  ( always !0
  && always {!<=-1,!>=2}
  newTok always !0
  ( always !0
  ( always !0
  == always {!<=-1,!>=2}
  "[" always "["
Line 8061
  = always !0
  newTok always !0
  ( always !0
  ( always !0
Line 8063
  = possible 0
  newTok always !0
  ( always !0
  ( possible 0
Line 8066
  = always !0
  newTok always !0
  ( always !0
Line 8067
  typeTok {symbolic=(newTok->astOperand1()),!0}
  == always {!<=-1,!>=2}
  "{" always "{"
Line 8068
  typeTok {symbolic=(newTok->astOperand1()),!0}
Line 8070
  bracTok possible {symbolic=(newTok->astOperand1()),symbolic=(newTok->astOperand1()->astOperand1())}
  && always {!<=-1,!>=2}
  bracTok always !0
  && always {!<=-1,!>=2}
  bracTok always !0
  ( always !0
  ( always {!<=-1,!>=2}
Line 8071
  bracTok always !0
  ( always !0
Line 8072
  ( always {!<=-1,!>=2}
  typeTok possible {symbolic=(newTok->astOperand1()->astOperand1()),symbolic=(newTok->astOperand1()),0}
  "%type%" always "%type%"
Line 8073
  = always 1
  1 always 1
Line 8076
  numElem possible {symbolic=(bracTok->astOperand2()->getKnownIntValue()),-1,1}
  >= {!<=-1,!>=2,0,1}
  0 always 0
  && always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always !0
  ( always {!<=-1,!>=2}
Line 8077
  ( always !0
Line 8078
  ! always {!<=-1,!>=2}
  typeTok always symbolic=(newTok->astParent()->astOperand1())
  || always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  typeTok {symbolic=(newTok->astParent()->astOperand1()),!0}
Line 8079
  ( always !0
Line 8080
  typeTok possible {symbolic=(newTok->astParent()->astOperand1()),symbolic=(newTok->astParent()->previous())}
  && always {!<=-1,!>=2}
  typeTok always !0
Line 8081
  typeTok always !0
  ( always !0
  typeTok always !0
  ( always !0
  > always {!<=-1,!>=2}
  1 always 1
Line 8082
  >= always {!<=-1,!>=2}
  0 always 0
Line 8083
  numElem always !<=-1
  typeSize {>=0,!<=-1}
Line 8086
  sizeValue possible {symbolic=(numElem*typeSize),-1}
Line 8090
  != always {!<=-1,!>=2}
Line 8091
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "[;{}] %var% =" always "[;{}] %var% ="
Line 8094
  ! always {!<=-1,!>=2}
Line 8097
  2 always 2
Line 8098
  rhs possible 0
  && always {!<=-1,!>=2}
  rhs always !0
  ( always {!<=-1,!>=2}
Line 8099
  rhs always !0
  rhs always !0
  ( always !0
  : always 1
  rhs always !0
Line 8100
  ! {!<=-1,!>=2,1}
  rhs possible 0
Line 8103
  isNew always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  rhs always !0
  == always {!<=-1,!>=2}
  "new" always "new"
Line 8104
  ! always {!<=-1,!>=2}
  isNew {symbolic=(symboldatabase->isCPP()&&rhs->str()=="new"),!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  rhs always !0
  "%name% (" always "%name% ("
Line 8107
  isNew {symbolic=(symboldatabase->isCPP()&&rhs->str()=="new"),!<=-1,!>=2}
  rhs always !0
Line 8108
  < always {!<=-1,!>=2}
  0 always 0
Line 8111
  sizeValue {!<=-1,>=0}
Line 8112
  2 always 2
  "Assign " always "Assign "
  1 always 1
  ", buffer with size " always ", buffer with size "
  sizeValue {!<=-1,>=0}
Line 8113
  = always 7
  :: always 7
  BUFFER_SIZE always 7
Line 8116
  values always {{,size=1}
Line 8121
  ( always {!<=-1,!>=2}
Line 8123
  ! always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  vt always !0
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  vt always !0
Line 8124
  return always {!<=-1,!>=2}
  false always 0
Line 8126
  bits possible 64
Line 8127
  vt always !0
Line 8128
  :: always 8
  BOOL always 8
Line 8129
  = always 1
  1 always 1
Line 8131
  :: always 9
  CHAR always 9
Line 8134
  :: always 10
  SHORT always 10
Line 8137
  :: always 12
  INT always 12
Line 8140
  :: always 13
  LONG always 13
Line 8143
  :: always 14
  LONGLONG always 14
Line 8147
  return always {!<=-1,!>=2}
  false always 0
Line 8150
  bits possible {symbolic=(platform.char_bit),symbolic=(platform.short_bit),symbolic=(platform.int_bit),symbolic=(platform.long_bit),symbolic=(platform.long_long_bit),1,64}
  == {!<=-1,!>=2,1,0}
  1 always 1
Line 8151
  = always 0
  0 always 0
Line 8152
  = always 1
  1 always 1
Line 8153
  bits {symbolic=(platform.char_bit),symbolic=(platform.short_bit),symbolic=(platform.int_bit),symbolic=(platform.long_bit),symbolic=(platform.long_long_bit),64,!1}
  < {!<=-1,!>=2,0}
  62 always 62
Line 8154
  == always {!<=-1,!>=2}
  :: always 2
  UNSIGNED always 2
Line 8155
  = always 0
  0 always 0
Line 8156
  1LL always 1
  bits always {!1,!>=62}
  1 always 1
Line 8158
  1LL always 1
  bits always {!1,!>=62}
  - always {!0,!>=61}
  1 always 1
Line 8159
  1LL always 1
  bits always {!1,!>=62}
  - always {!0,!>=61}
  1 always 1
  1 always 1
Line 8161
  bits {symbolic=(platform.char_bit),symbolic=(platform.short_bit),symbolic=(platform.int_bit),symbolic=(platform.long_bit),symbolic=(platform.long_long_bit),!1,!<=61,>=62}
  == {!<=-1,!>=2,>=0}
  64 always 64
Line 8162
  == always {!<=-1,!>=2}
  :: always 2
  UNSIGNED always 2
Line 8163
  = always 0
  0 always 0
Line 8170
  return always {!<=-1,!>=2}
  false always 0
Line 8173
  return always {!<=-1,!>=2}
  true always 1
Line 8176
  ( always {!<=-1,!>=2}
Line 8179
  ";" always ";"
Line 8180
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 8181
  return always {!<=-1,!>=2}
  false always 0
Line 8185
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  & {lifetime[Address]=(vt),!0}
  minvalue possible {lifetime[Address]=(minvalue)@140,Uninit*@140}
  maxvalue possible {lifetime[Address]=(maxvalue)@140,Uninit*@140}
Line 8191
  ! always {!<=-1,!>=2}
Line 8194
  ! always {!<=-1,!>=2}
  function always symbolic=(functionScope->function)
Line 8197
  safe always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  function {symbolic=(functionScope->function),!0}
  ( always {!<=-1,!>=2}
Line 8198
  all always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  safe {!<=-1,!>=2,0}
  && always {!<=-1,!>=2}
  != always {!<=-1,!>=2}
  :: always 0
  Unspecified always 0
Line 8200
  function {symbolic=(functionScope->function),!0}
Line 8201
  ! always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
Line 8204
  ( always !0
  == always {!<=-1,!>=2}
  :: always 5
  CONTAINER always 5
Line 8205
  ! always {!<=-1,!>=2}
  safe always {!<=-1,!>=2}
Line 8208
  argValues always size=0
  0 always 0
Line 8209
  argValues always size=1
  = always 5
  :: always 5
  CONTAINER_SIZE always 5
Line 8210
  argValues always size=1
  ( always !0
  "Assuming " always "Assuming "
  " is empty" always " is empty"
Line 8211
  argValues always size=1
  . always {!<=-1,!>=2}
  = always 1
  true always 1
Line 8212
  argValues always size=1
  1000000 always 1000000
Line 8213
  argValues always size=2
  = always 5
  :: always 5
  CONTAINER_SIZE always 5
Line 8214
  argValues always size=2
  "Assuming " always "Assuming "
  " size is 1000000" always " size is 1000000"
Line 8215
  argValues always size=2
  . always {!<=-1,!>=2}
  = always 1
  true always 1
Line 8216
  argValues always size=2
Line 8223
  isLow always {!<=-1,!>=2}
  isLow always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  ( always !0
  ( always {!<=-1,!>=2}
  :: always 0
  LOW always 0
  & {lifetime[Address]=(low),!0,Uninit*}
  low always Uninit
Line 8224
  isHigh always {!<=-1,!>=2}
  isHigh always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  :: always 1
  HIGH always 1
  & {lifetime[Address]=(high),!0,Uninit*}
  high always Uninit
Line 8226
  ! {!<=-1,!>=2,1}
  isLow {!<=-1,!>=2,0}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  isHigh always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  all always {!<=-1,!>=2}
Line 8229
  safeLow always {!<=-1,!>=2}
  = {!<=-1,!>=2,1}
  ! {!<=-1,!>=2,1}
  isLow {!<=-1,!>=2,0}
Line 8230
  safeHigh always {!<=-1,!>=2}
  = {!<=-1,!>=2,1}
  ! {!<=-1,!>=2,1}
  isHigh {!<=-1,!>=2,0}
Line 8232
  ! {symbolic=(safeLow),!<=-1,!>=2,1}
  isLow {!<=-1,!>=2,0}
  || always {!<=-1,!>=2}
  ! {symbolic=(safeHigh),!<=-1,!>=2}
  isHigh always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  all always {!<=-1,!>=2}
Line 8234
  ( always {!<=-1,!>=2}
  & {lifetime[Address]=(minValue),!0,Uninit*}
  minValue always Uninit
  & {lifetime[Address]=(maxValue),!0,Uninit*}
  maxValue always Uninit
Line 8235
  ! {symbolic=(safeLow),!<=-1,!>=2}
  isLow always {!<=-1,!>=2}
Line 8237
  ! {symbolic=(safeHigh),!<=-1,!>=2}
  isHigh always {!<=-1,!>=2}
Line 8239
  isLow always {!<=-1,!>=2}
  = always 1
  isHigh always {!<=-1,!>=2}
  = always 1
  true always 1
Line 8240
  . possible {17,18}
  == {!<=-1,!>=2,0}
  :: always 16
  FLOAT always 16
  || {!<=-1,!>=2,0}
  . {18,!16}
  == {!<=-1,!>=2,0}
  :: always 17
  DOUBLE always 17
  || always {!<=-1,!>=2}
  . always {!16,!17}
  == always {!<=-1,!>=2}
  :: always 18
  LONGDOUBLE always 18
Line 8242
  argValues always size=0
  0 always 0
Line 8243
  argValues always size=1
  = always 2
  :: always 2
  FLOAT always 2
Line 8244
  argValues always size=1
  = possible -1e+25
  isLow always {!<=-1,!>=2}
  ? possible -1e+25
  : always -1e+25
  -1E25f always -1e+25
Line 8245
  argValues always size=1
  "Safe checks: Assuming argument has value " always "Safe checks: Assuming argument has value "
  argValues always size=1
Line 8246
  argValues always size=1
  . always {!<=-1,!>=2}
  = always 1
  true always 1
Line 8247
  argValues always size=1
  0 always 0
Line 8248
  argValues always size=2
  = always 2
  :: always 2
  FLOAT always 2
Line 8249
  argValues always size=2
  = possible 1e+25
  isHigh always {!<=-1,!>=2}
  ? possible 1e+25
  : always 1e+25
  1E25f always 1e+25
Line 8250
  argValues always size=2
  "Safe checks: Assuming argument has value " always "Safe checks: Assuming argument has value "
  argValues always size=2
Line 8251
  argValues always size=2
  . always {!<=-1,!>=2}
  = always 1
  true always 1
Line 8255
  argValues always size=2
Line 8262
  argValues possible size=0
Line 8263
  isLow {!<=-1,!>=2,1}
Line 8264
  argValues always size=0
Line 8265
  argValues always size=1
  safeLow {!<=-1,!>=2,0}
  ? possible {"Safe checks: ",""}
  "Safe checks: " always "Safe checks: "
  : always ""
  "" always ""
  "Assuming argument has value " always "Assuming argument has value "
Line 8266
  argValues always size=1
  . always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  safeLow always {!<=-1,!>=2}
Line 8268
  isHigh always {!<=-1,!>=2}
Line 8270
  argValues always !size=0
  safeHigh {!<=-1,!>=2,0}
  ? possible {"Safe checks: ",""}
  "Safe checks: " always "Safe checks: "
  : always ""
  "" always ""
  "Assuming argument has value " always "Assuming argument has value "
Line 8271
  argValues always !size=0
  . always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  safeHigh always {!<=-1,!>=2}
Line 8274
  ! {!<=-1,!>=2,0}
  argValues possible size=0
  ( {!<=-1,!>=2,1}
Line 8278
  argValues always !size=0
Line 8287
  ( always {!<=-1,!>=2}
Line 8290
  ! always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  != always {!<=-1,!>=2}
  "(" always "("
  || always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 8292
  . always !size=0
  ( possible lifetime[Iterator]=(settings->checkUnknownFunctionReturn)
  == always {!<=-1,!>=2}
  . always !size=0
  ( {lifetime[Iterator]=(settings->checkUnknownFunctionReturn),end=0}
Line 8295
  ( always {!<=-1,!>=2}
Line 8301
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  & {lifetime[Address]=(minvalue),!0,Uninit*}
  minvalue always Uninit
  & {lifetime[Address]=(maxvalue),!0,Uninit*}
  maxvalue always Uninit
Line 8304
  unknownValues always !size=0
Line 8305
  < always {!<=-1,!>=2}
Line 8306
  = {>=symbolic=(value+1),!<=symbolic=(value)}
  minvalue {>=symbolic=(value+1),!<=symbolic=(value)}
Line 8307
  value {!<=symbolic=(minvalue-1),>=symbolic=(minvalue)}
  > always {!<=-1,!>=2}
Line 8308
  = {<=symbolic=(value-1),!>=symbolic=(value)}
  maxvalue {<=symbolic=(value-1),!>=symbolic=(value)}
Line 8309
  value possible {symbolic=(minvalue),symbolic=(maxvalue)}
Line 8318
  nullptr always 0
Line 8319
  0.0 always 0
Line 8323
  0 always 0
Line 8324
  safe always {!<=-1,!>=2}
  false always 0
Line 8325
  conditional always {!<=-1,!>=2}
  false always 0
Line 8326
  macro always {!<=-1,!>=2}
  false always 0
Line 8327
  defaultArg always {!<=-1,!>=2}
  false always 0
Line 8328
  0 always 0
Line 8329
  0 always 0
Line 8330
  0 always 0
Line 8332
  nullptr always 0
Line 8337
  "Assuming that condition '" always "Assuming that condition '"
  "' is not redundant" always "' is not redundant"
Line 8343
  "Assuming that condition '" always "Assuming that condition '"
  "' is not redundant" always "' is not redundant"
Line 8353
  :: always 16
  FLOAT always 16
Line 8356
  "<Moved>" always "<Moved>"
Line 8358
  "<Uninit>" always "<Uninit>"
Line 8361
  "size=" always "size="
Line 8363
  "start=" always "start="
Line 8365
  "end=" always "end="
Line 8367
  "lifetime=" always "lifetime="
Line 8369
  "symbolic=" always "symbolic="
Line 8370
  > always {!<=-1,!>=2}
  0 always 0
Line 8371
  "+" always "+"
  intvalue {>=1,!<=0}
Line 8372
  intvalue {!>=1,<=0}
  < {!<=-1,!>=2,<=0}
  0 always 0
Line 8373
  "-" always "-"
  - {>=1,!<=0}
  intvalue {<=-1,!>=0}
Line 8376
  nullptr always 0
  "Invalid ValueFlow Value type" always "Invalid ValueFlow Value type"
Line 8383
  "NonMovedVariable" always "NonMovedVariable"
Line 8385
  "MovedVariable" always "MovedVariable"
Line 8387
  "ForwardedVariable" always "ForwardedVariable"
Line 8389
  "" always ""
Line 8396
  "Object" always "Object"
Line 8398
  "SubObject" always "SubObject"
Line 8400
  "Lambda" always "Lambda"
Line 8402
  "Iterator" always "Iterator"
Line 8404
  "Address" always "Address"
Line 8406
  "" always ""
Line 8409
  ( always {!<=-1,!>=2}
Line 8411
  tok1 possible 0
  == always {!<=-1,!>=2}
Line 8412
  return always {!<=-1,!>=2}
  true always 1
Line 8413
  ! always {!<=-1,!>=2}
  tok1 always !symbolic=(tok2)
Line 8414
  return always {!<=-1,!>=2}
  false always 0
Line 8415
  tok1 always {!symbolic=(tok2),!0}
  == always {!<=-1,!>=2}
  0 always 0
  || always {!<=-1,!>=2}
  tok2 always !symbolic=(tok1)
  == always {!<=-1,!>=2}
  0 always 0
Line 8416
  return always {!<=-1,!>=2}
  false always 0
Line 8417
  return always {!<=-1,!>=2}
  tok1 always !0
  ( always !0
  == always {!<=-1,!>=2}
  ( always !0
Line 8423
  "Local" always "Local"
Line 8424
  :: always 1
  Argument always 1
Line 8425
  "Argument" always "Argument"
Line 8426
  :: always 2
  SubFunction always 2
Line 8427
  "SubFunction" always "SubFunction"
Line 8428
  :: always 3
  ThisPointer always 3
Line 8429
  "ThisPointer" always "ThisPointer"
Line 8430
  :: always 4
  ThisValue always 4
Line 8431
  "ThisValue" always "ThisValue"
Line 8433
  "" always ""
Line 8439
  "Point" always "Point"
Line 8440
  :: always 0
  Upper always 0
Line 8441
  "Upper" always "Upper"
Line 8442
  :: always 1
  Lower always 1
Line 8443
  "Lower" always "Lower"
Line 8445
  "" always ""
Line 8450
  expr possible 0@103
  && always {!<=-1,!>=2}
  expr always !0
  ( always {!<=-1,!>=2}
Line 8451
  expr always !0
Line 8452
  expr always !0
Line 8453
  expr always !0
  true always 1
Line 8455
  expr possible 0
  && always {!<=-1,!>=2}
  expr always !0
  ( always {!<=-1,!>=2}
  & always !0
  expr always !0
  nullptr always 0
Line 8458
  ( always !<=-1
Line 8460
  n always !<=-1
  n always !<=-1
  = always 1
  1 always 1
Line 8462
  n always !<=-1
  += always !<=-1
  ( always !<=-1
Line 8463
  return always !<=-1
  n {!<=-1,1}
Line 8487
  values always !<=-1
  values always !<=-1
  = always 0
  0 always 0
Line 8488
  n always !<=-1
  n always !<=-1
  = always 4
  4 always 4
Line 8489
  n {!<=-1,4}
  > {!<=-1,!>=2,1}
  0 always 0
  && always {!<=-1,!>=2}
  values {!<=-1,0}
  < always {!<=-1,!>=2}
  ( always !<=-1
Line 8490
  values always !<=-1
  = always !<=-1
  ( always !<=-1
Line 8509
  ( always {!<=-1,!>=2}
Line 8519
  n always !<=0
  -- always !<=0
Line 8534
  ! always {!<=-1,!>=2}
Line 8535
  "Either the condition is redundant" always "Either the condition is redundant"
Line 8536
  condition always !0
  == always {!<=-1,!>=2}
  "case" always "case"
Line 8538
  = always !0
  condition always !0
  && always {!<=-1,!>=2}
  tok always !0
  != always {!<=-1,!>=2}
  ":" always ":"
Line 8540
  ( always {!<=-1,!>=2}
  "%name%|%num% %name%|%num%" always "%name%|%num% %name%|%num%"
Line 8541
  ' ' always 32
Line 8543
  "Either the switch case '" always "Either the switch case '"
  + possible size=24
  expr possible size=0
  + possible size=38
  "' is redundant" always "' is redundant"
Line 8545
  "Either the condition '" always "Either the condition '"
  condition always !0
  "' is redundant" always "' is redundant"
Line 8550
  ( always {!<=-1,!>=2}
Line 8552
  = always 0
  nullptr always 0
Line 8555
  ! always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  ret always !0
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  ret always !0
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 8556
  = {&,lifetime[Address]=(values),!0}
  & {&,lifetime[Address]=(values),!0}
Line 8557
  ! {!<=-1,!>=2,1}
  ret possible {lifetime[Address]=(values),symbolic=(&v),&}
  ( {!<=-1,!>=2,0}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ret possible lifetime[Address]=(values)
Line 8561
  && always {!<=-1,!>=2}
Line 8562
  ret always !0
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  settings always !0
  ( always {!<=-1,!>=2}
Line 8563
  nullptr always 0
Line 8564
  ret always !0
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  settings always !0
  ( always {!<=-1,!>=2}
  :: always 2
  warning always 2
Line 8565
  nullptr always 0
Line 8567
  ret possible 0
Line 8572
  condition always {!<=-1,!>=2}
Line 8574
  ! always {!<=-1,!>=2}
Line 8575
  { always {size=0,{}
Line 8576
  indexTok always !0
  condition {!<=-1,!>=2,0,1@41}
Line 8577
  ! always {!<=-1,!>=2}
Line 8578
  { always {size=0,{}
Line 8579
  indexValue always !0
  >= always {!<=-1,!>=2}
Line 8580
  { always {size=1,{}
  indexValue always !0
Line 8581
  ! always {!<=-1,!>=2}
  condition always {!<=-1,!>=2}
Line 8582
  { always {size=0,{}
Line 8584
  ! always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always !0
  ( always {!<=-1,!>=2}
Line 8585
  { always {size=0,{}
Line 8586
  ( always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(indexTok->values()),start=0}
  ( {lifetime[Iterator]=(indexTok->values()),end=0}
Line 8587
  && always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 0
  Upper always 0
Line 8589
  { always {size=0,{}
Line 8590
  != always {!<=-1,!>=2}
  :: always 1
  Lower always 1
Line 8591
  { always {size=0,{}
Line 8592
  == always {!<=-1,!>=2}
  :: always 1
  Lower always 1
Line 8593
  { always {size=0,{}
Line 8594
  ">=" always ">="
Line 8595
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 8596
  { always {size=0,{}
Line 8597
  == always {!<=-1,!>=2}
  0 always 0
Line 8598
  { always {size=0,{}
Line 8600
  = always 1
  :: always 1
  Lower always 1
Line 8601
  { always {size=1,{}
Line 8604
  possible always {!<=-1,!>=2}
Line 8606
  "<" always "<"
Line 8607
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  != always {!<=-1,!>=2}
  0 always 0
Line 8608
  { always {size=0,{}
Line 8609
  false always 0
Line 8610
  ! {!<=-1,!>=2,0}
  result possible size=0
  ( {!<=-1,!>=2,1}
Line 8611
  result always !size=0
Line 8612
  ! always {!<=-1,!>=2}
  possible always {!<=-1,!>=2}
Line 8614
  true always 1
Line 40
  & {lifetime[Address]=(apply),!0}
Line 42
  nullptr always 0
Line 46
  & {lifetime[Address]=(value),!0}
  & {lifetime[Address]=(apply),!0}
Line 49
  nullptr always 0
  rhs possible 0
Line 54
  && always {!<=-1,!>=2}
Line 61
  ( always symbolic=(mPtr)
Line 64
  ( always symbolic=(mPtr)
Line 89
  this always !0
Line 92
  ( always !>=2
Line 93
  ! always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
Line 40
  & {lifetime[Address]=(apply),!0}
Line 42
  nullptr always 0
Line 46
  & {lifetime[Address]=(value),!0}
  & {lifetime[Address]=(apply),!0}
Line 49
  nullptr always 0
  rhs possible 0
Line 54
  && always {!<=-1,!>=2}
Line 61
  ( always symbolic=(mPtr)
Line 64
  ( always symbolic=(mPtr)
Line 89
  this always !0
Line 92
  ( always !>=2
Line 93
  ! always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
Line 40
  & {lifetime[Address]=(apply),!0}
Line 42
  nullptr always 0
Line 46
  & {lifetime[Address]=(value),!0}
  & {lifetime[Address]=(apply),!0}
Line 49
  nullptr always 0
  rhs possible 0
Line 54
  && always {!<=-1,!>=2}
Line 61
  ( always symbolic=(mPtr)
Line 64
  ( always symbolic=(mPtr)
Line 89
  this always !0
Line 92
  ( always !>=2
Line 93
  ! always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
Line 50
  mFlags always !<=-1
  mFlags always !<=-1
  = always 0
  0 always 0
Line 52
  ( always !<=-1
Line 53
  return always !<=-1
  mFlags always !<=-1
Line 56
  mFlags always !<=-1
  = always 0
  0 always 0
Line 59
  mFlags always !<=-1
  = always 4294967295
  0xFFFFFFFF always 4294967295
Line 61
  enabled always {!<=-1,!>=2}
Line 62
  enabled always {!<=-1,!>=2}
Line 67
  ( always {!<=-1,!>=2}
Line 68
  return always {!<=-1,!>=2}
  mFlags always !<=-1
  & always !<=-1
  1U always 1
  << always !<=0
  ( {!<=-1,2@54}
  flag possible 2@54
  != always {!<=-1,!>=2}
  0 always 0
Line 71
  mFlags always !<=-1
  |= always !<=-1
  1U always 1
  << always !<=0
  ( always !<=-1
Line 74
  mFlags always !<=-1
  &= always !<=-1
  ~ always !<=4294967295
  1U always 1
  << always !<=0
  ( always !<=-1
Line 76
  , always {!<=-1,!>=2}
  enabled always {!<=-1,!>=2}
Line 77
  enabled always {!<=-1,!>=2}
Line 50
  mFlags always !<=-1
  mFlags always !<=-1
  = always 0
  0 always 0
Line 52
  ( always !<=-1
Line 53
  return always !<=-1
  mFlags always !<=-1
Line 56
  mFlags always !<=-1
  = always 0
  0 always 0
Line 59
  mFlags always !<=-1
  = always 4294967295
  0xFFFFFFFF always 4294967295
Line 61
  enabled always {!<=-1,!>=2}
Line 62
  enabled always {!<=-1,!>=2}
Line 67
  ( always {!<=-1,!>=2}
Line 68
  return always {!<=-1,!>=2}
  mFlags always !<=-1
  & always !<=-1
  1U always 1
  << always !<=0
  ( always !<=-1
  != always {!<=-1,!>=2}
  0 always 0
Line 71
  mFlags always !<=-1
  |= always !<=-1
  1U always 1
  << always !<=0
  ( always !<=-1
Line 74
  mFlags always !<=-1
  &= always !<=-1
  ~ always !<=4294967295
  1U always 1
  << always !<=0
  ( always !<=-1
Line 76
  , always {!<=-1,!>=2}
  enabled always {!<=-1,!>=2}
Line 77
  enabled always {!<=-1,!>=2}
Line 50
  mFlags always !<=-1
  mFlags always !<=-1
  = always 0
  0 always 0
Line 52
  ( always !<=-1
Line 53
  return always !<=-1
  mFlags always !<=-1
Line 56
  mFlags always !<=-1
  = always 0
  0 always 0
Line 59
  mFlags always !<=-1
  = always 4294967295
  0xFFFFFFFF always 4294967295
Line 61
  enabled always {!<=-1,!>=2}
Line 62
  enabled always {!<=-1,!>=2}
Line 67
  ( always {!<=-1,!>=2}
Line 68
  return always {!<=-1,!>=2}
  mFlags always !<=-1
  & always !<=-1
  1U always 1
  << always !<=0
  ( always !<=-1
  != always {!<=-1,!>=2}
  0 always 0
Line 71
  mFlags always !<=-1
  |= always !<=-1
  1U always 1
  << always !<=0
  ( always !<=-1
Line 74
  mFlags always !<=-1
  &= always !<=-1
  ~ always !<=4294967295
  1U always 1
  << always !<=0
  ( always !<=-1
Line 76
  , always {!<=-1,!>=2}
  enabled always {!<=-1,!>=2}
Line 77
  enabled always {!<=-1,!>=2}
Line 121
  = always 0
  nullptr always 0
Line 49
  = always 0
  nullptr always 0
Line 52
  { {lifetime[SubObject]=(z),{}
Line 54
  maxBitsShift always 64
  = always 64
  ( always 8
  * always 64
  8 always 8
Line 56
  = always 63
  maxBitsShift always 64
  - always 63
  1 always 1
Line 57
  ( always !<=-1
Line 58
  '+' always 43
Line 60
  '-' always 45
Line 62
  '*' always 42
Line 64
  '/' always 47
Line 65
  ( always {!<=-1,!>=2}
Line 67
  * always {!<=-1,!>=2}
  error always !0
  = always 1
  true always 1
Line 68
  { always {size=0,{}
Line 71
  '%' always 37
Line 72
  ( always {!<=-1,!>=2}
Line 74
  * always {!<=-1,!>=2}
  error always !0
  = always 1
  true always 1
Line 75
  { always {size=0,{}
Line 78
  '&' always 38
Line 80
  '|' always 124
Line 82
  '^' always 94
Line 84
  '>' always 62
Line 85
  > always {!<=-1,!>=2}
Line 86
  '<' always 60
Line 87
  < always {!<=-1,!>=2}
Line 88
  '<<' always 15420
Line 89
  >= always {!<=-1,!>=2}
  maxBitsSignedShift always 63
  || always {!<=-1,!>=2}
  y {!>=symbolic=(maxBitsSignedShift),<=symbolic=(maxBitsSignedShift-1),!>=63,<=62}
  < {!<=-1,!>=2,<=0}
  0 always 0
  || always {!<=-1,!>=2}
  < always {!<=-1,!>=2}
  0 always 0
Line 91
  * always {!<=-1,!>=2}
  error always !0
  = always 1
  true always 1
Line 92
  { always {size=0,{}
Line 94
  ( {!<=-1,>=0}
  x {!<=-1,>=0}
  << possible 0
  ( {!>=symbolic=(maxBitsSignedShift),<=symbolic=(maxBitsSignedShift-1),!>=63,<=62,!<=-1,>=0}
  y {!>=symbolic=(maxBitsSignedShift),<=symbolic=(maxBitsSignedShift-1),!>=63,<=62,!<=-1,>=0}
Line 95
  '>>' always 15934
Line 96
  >= always {!<=-1,!>=2}
  maxBitsSignedShift always 63
  || always {!<=-1,!>=2}
  y {!>=symbolic=(maxBitsSignedShift),<=symbolic=(maxBitsSignedShift-1),!>=63,<=62}
  < {!<=-1,!>=2,<=0}
  0 always 0
  || always {!<=-1,!>=2}
  < always {!<=-1,!>=2}
  0 always 0
Line 98
  * always {!<=-1,!>=2}
  error always !0
  = always 1
  true always 1
Line 99
  { always {size=0,{}
Line 101
  ( {!<=-1,>=0}
  x {!<=-1,>=0}
  >> possible 0
  ( {!>=symbolic=(maxBitsSignedShift),<=symbolic=(maxBitsSignedShift-1),!>=63,<=62,!<=-1,>=0}
  y {!>=symbolic=(maxBitsSignedShift),<=symbolic=(maxBitsSignedShift-1),!>=63,<=62,!<=-1,>=0}
Line 102
  '&&' always 9766
Line 103
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 104
  '||' always 31868
Line 105
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 106
  '==' always 15677
Line 108
  '!=' always 8509
Line 109
  ! always {!<=-1,!>=2}
Line 110
  '>=' always 15933
Line 111
  >= always {!<=-1,!>=2}
Line 112
  '<=' always 15421
Line 113
  <= always {!<=-1,!>=2}
Line 114
  '<=>' always 3947838
Line 117
  nullptr always 0
  "Unknown operator: " always "Unknown operator: "
