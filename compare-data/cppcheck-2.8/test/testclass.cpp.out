

##file cppcheck-2.8/test/testsuite.h

1:
|
31:
32: class options ;
33:
34: class TestFixture : public ErrorLogger {
35: private:
36: static std :: ostringstream errmsg@var1 ;
37: static unsigned int countTests@var2 ;
38: static unsigned long fails_counter@var3 ;
39: static unsigned long todos_counter@var4 ;
40: static unsigned long succeeded_todos_counter@var5 ;
41: static std :: set < std :: string > missingLibs@var6 ;
42: bool mVerbose@var7 ;
43: std :: string mTemplateFormat@var8 ;
44: std :: string mTemplateLocation@var9 ;
45: std :: string mTestname@var10 ;
46:
47: protected:
48: std :: string exename@var11 ;
49: std :: string testToRun@var12 ;
50: bool quiet_tests@var13 ;
51:
52: virtual void run ( ) = 0 ;
53:
54: bool prepareTest ( const char testname@var14 [ ] ) ;
55: std :: string getLocationStr ( const char * const filename@var15 , const unsigned int linenr@var16 ) const ;
56:
57: bool assert_ ( const char * const filename@var17 , const unsigned int linenr@var18 , const bool condition@var19 ) const ;
58:
59: template < typename T , typename U >
60: bool assertEquals ( const char * const filename@var20 , const unsigned int linenr@var21 , const T & expected@var22 , const U & actual@var23 , const std :: string & msg@var24 = emptyString ) const {
61: if (@expr1073742088 expected@var22 !=@expr1073742089 actual@var23 ) {
62: std ::@expr1073742090 ostringstream expectedStr@var25 ;
63: expectedStr@var25 <<@expr1073742091 expected@var22 ;
64: std ::@expr1073742092 ostringstream actualStr@var26 ;
65: actualStr@var26 <<@expr1073742093 actual@var23 ;
66:
67: assertEqualsFailed (@expr1073742094 filename@var20 , linenr@var21 , expectedStr@var25 .@expr1073742095 str (@expr1073742096 ) , actualStr@var26 .@expr1073742097 str (@expr1073742098 ) , msg@var24 ) ;
68: }
69: return expected@var22 ==@expr1073742099 actual@var23 ;
70: }
71:
72:
73:
74: void assertEqualsFailed ( const char * const filename@var27 , const unsigned int linenr@var28 , const std :: string & expected@var29 , const std :: string & actual@var30 , const std :: string & msg@var31 ) const ;
75:
76: bool assertEquals ( const char * const filename@var32 , const unsigned int linenr@var33 , const std :: string & expected@var34 , const std :: string & actual@var35 , const std :: string & msg@var36 = emptyString ) const ;
77: void assertEqualsWithoutLineNumbers ( const char * const filename@var37 , const unsigned int linenr@var38 , const std :: string & expected@var39 , const std :: string & actual@var40 , const std :: string & msg@var41 = emptyString ) const ;
78: bool assertEquals ( const char * const filename@var42 , const unsigned int linenr@var43 , const char expected@var44 [ ] , const std :: string & actual@var45 , const std :: string & msg@var46 = emptyString ) const ;
79: bool assertEquals ( const char * const filename@var47 , const unsigned int linenr@var48 , const char expected@var49 [ ] , const char actual@var50 [ ] , const std :: string & msg@var51 = emptyString ) const ;
80: bool assertEquals ( const char * const filename@var52 , const unsigned int linenr@var53 , const std :: string & expected@var54 , const char actual@var55 [ ] , const std :: string & msg@var56 = emptyString ) const ;
81: bool assertEquals ( const char * const filename@var57 , const unsigned int linenr@var58 , const long long expected@var59 , const long long actual@var60 , const std :: string & msg@var61 = emptyString ) const ;
82: void assertEqualsDouble ( const char * const filename@var62 , const unsigned int linenr@var63 , const double expected@var64 , const double actual@var65 , const double tolerance@var66 , const std :: string & msg@var67 = emptyString ) const ;
83:
84: void todoAssertEquals ( const char * const filename@var68 , const unsigned int linenr@var69 , const std :: string & wanted@var70 ,
85: const std :: string & current@var71 , const std :: string & actual@var72 ) const ;
86: void todoAssertEquals ( const char * const filename@var73 , const unsigned int linenr@var74 , const char wanted@var75 [ ] ,
87: const char current@var76 [ ] , const std :: string & actual@var77 ) const ;
88: void todoAssertEquals ( const char * const filename@var78 , const unsigned int linenr@var79 , const long long wanted@var80 ,
89: const long long current@var81 , const long long actual@var82 ) const ;
90: void assertThrow ( const char * const filename@var83 , const unsigned int linenr@var84 ) const ;
91: void assertThrowFail ( const char * const filename@var85 , const unsigned int linenr@var86 ) const ;
92: void assertNoThrowFail ( const char * const filename@var87 , const unsigned int linenr@var88 ) const ;
93: static void complainMissingLib ( const char * const libname@var89 ) ;
94: static std :: string deleteLineNumber ( const std :: string & message@var90 ) ;
95:
96: void setVerbose ( bool v@var91 ) {
97: mVerbose@var7 =@expr1073742100 v@var91 ;
98: }
99:
100: void setMultiline ( ) {
101: mTemplateFormat@var8 =@expr1073742101 "{file}:{line}:{severity}:{message}" ;
102: mTemplateLocation@var9 =@expr1073742102 "{file}:{line}:note:{info}" ;
103: }
104:
105: void processOptions ( const options & args@var92 ) ;
106: public:
107: void reportOut ( const std :: string & outmsg@var93 , Color c@var94 = Color :: Reset ) override ;
108: void reportErr ( const ErrorMessage & msg@var95 ) override ;
109: void run ( const std :: string & str@var96 ) ;
110: static void printHelp ( ) ;
111: const std :: string classname@var97 ;
112:
113: explicit TestFixture ( const char * const _name@var98 ) ;
114: ~ TestFixture ( ) override { }
115:
116: static unsigned long runTests ( const options & args@var99 ) ;
117: } ;
118:
119: extern std :: ostringstream errout@var100 ;
120: extern std :: ostringstream output@var101 ;

##file cppcheck-2.8/test/testclass.cpp

1:
|
34:
35: class TestClass : public TestFixture {
36: public:
37: TestClass ( ) : TestFixture ( "TestClass" ) { }
38:
39: private:
40: Settings settings0@var102 ;
41: Settings settings1@var103 ;
42:
43: void run ( ) override {
44: settings0@var102 .@expr1073742105 severity@var104 .@expr1073742106 enable (@expr1073742107 Severity ::@expr1073742108 style@expr1073742103 ) ;
45: settings1@var103 .@expr1073742109 severity@var105 .@expr1073742110 enable (@expr1073742111 Severity ::@expr1073742112 warning@expr1073742104 ) ;
46:
47:
48: {
49: const char xmldata@var106 [@expr1073742113 422 ] =@expr1073742114 "<?xml version=\"1.0\"?>\n<def>\n  <memory>\n    <alloc init=\"false\">malloc</alloc>\n    <dealloc>free</dealloc>\n  </memory>\n  <smart-pointer class-name=\"std::shared_ptr\"/>\n  <container id=\"stdVector\" startPattern=\"std :: vector &lt;\" itEndPattern=\"&gt; :: const_iterator\">\n    <access>\n      <function name=\"begin\" yields=\"start-iterator\"/>\n      <function name=\"end\" yields=\"end-iterator\"/>\n    </access>\n  </container>\n</def>"
50:
|
61:
62: ;
63: tinyxml2 ::@expr1073742115 XMLDocument doc@var107 ;
64: doc@var107 .@expr1073742116 Parse (@expr1073742117 xmldata@var106 , sizeof (@expr1073742118 xmldata@var106 ) ) ;
65: settings0@var102 .@expr1073742119 library@var108 .@expr1073742120 load (@expr1073742121 doc@var107 ) ;
66: settings1@var103 .@expr1073742122 library@var109 .@expr1073742123 load (@expr1073742124 doc@var107 ) ;
67: }
68:
69:
70: $do ${ $if $(@expr1073742125 $prepareTest $(@expr1073742126 "virtualDestructor1" $) $) ${ $setVerbose $(@expr1073742127 $false $) $; virtualDestructor1 $(@expr1073742128 $) $; $} $} $while $(@expr1073742129 $false $) ;
71: $do ${ $if $(@expr1073742130 $prepareTest $(@expr1073742131 "virtualDestructor2" $) $) ${ $setVerbose $(@expr1073742132 $false $) $; virtualDestructor2 $(@expr1073742133 $) $; $} $} $while $(@expr1073742134 $false $) ;
72: $do ${ $if $(@expr1073742135 $prepareTest $(@expr1073742136 "virtualDestructor3" $) $) ${ $setVerbose $(@expr1073742137 $false $) $; virtualDestructor3 $(@expr1073742138 $) $; $} $} $while $(@expr1073742139 $false $) ;
73: $do ${ $if $(@expr1073742140 $prepareTest $(@expr1073742141 "virtualDestructor4" $) $) ${ $setVerbose $(@expr1073742142 $false $) $; virtualDestructor4 $(@expr1073742143 $) $; $} $} $while $(@expr1073742144 $false $) ;
74: $do ${ $if $(@expr1073742145 $prepareTest $(@expr1073742146 "virtualDestructor5" $) $) ${ $setVerbose $(@expr1073742147 $false $) $; virtualDestructor5 $(@expr1073742148 $) $; $} $} $while $(@expr1073742149 $false $) ;
75: $do ${ $if $(@expr1073742150 $prepareTest $(@expr1073742151 "virtualDestructor6" $) $) ${ $setVerbose $(@expr1073742152 $false $) $; virtualDestructor6 $(@expr1073742153 $) $; $} $} $while $(@expr1073742154 $false $) ;
76: $do ${ $if $(@expr1073742155 $prepareTest $(@expr1073742156 "virtualDestructorProtected" $) $) ${ $setVerbose $(@expr1073742157 $false $) $; virtualDestructorProtected $(@expr1073742158 $) $; $} $} $while $(@expr1073742159 $false $) ;
77: $do ${ $if $(@expr1073742160 $prepareTest $(@expr1073742161 "virtualDestructorInherited" $) $) ${ $setVerbose $(@expr1073742162 $false $) $; virtualDestructorInherited $(@expr1073742163 $) $; $} $} $while $(@expr1073742164 $false $) ;
78: $do ${ $if $(@expr1073742165 $prepareTest $(@expr1073742166 "virtualDestructorTemplate" $) $) ${ $setVerbose $(@expr1073742167 $false $) $; virtualDestructorTemplate $(@expr1073742168 $) $; $} $} $while $(@expr1073742169 $false $) ;
79:
80: $do ${ $if $(@expr1073742170 $prepareTest $(@expr1073742171 "virtualDestructorInconclusive" $) $) ${ $setVerbose $(@expr1073742172 $false $) $; virtualDestructorInconclusive $(@expr1073742173 $) $; $} $} $while $(@expr1073742174 $false $) ;
81:
82: $do ${ $if $(@expr1073742175 $prepareTest $(@expr1073742176 "copyConstructor1" $) $) ${ $setVerbose $(@expr1073742177 $false $) $; copyConstructor1 $(@expr1073742178 $) $; $} $} $while $(@expr1073742179 $false $) ;
83: $do ${ $if $(@expr1073742180 $prepareTest $(@expr1073742181 "copyConstructor2" $) $) ${ $setVerbose $(@expr1073742182 $false $) $; copyConstructor2 $(@expr1073742183 $) $; $} $} $while $(@expr1073742184 $false $) ;
84: $do ${ $if $(@expr1073742185 $prepareTest $(@expr1073742186 "copyConstructor3" $) $) ${ $setVerbose $(@expr1073742187 $false $) $; copyConstructor3 $(@expr1073742188 $) $; $} $} $while $(@expr1073742189 $false $) ;
85: $do ${ $if $(@expr1073742190 $prepareTest $(@expr1073742191 "copyConstructor4" $) $) ${ $setVerbose $(@expr1073742192 $false $) $; copyConstructor4 $(@expr1073742193 $) $; $} $} $while $(@expr1073742194 $false $) ;
86: $do ${ $if $(@expr1073742195 $prepareTest $(@expr1073742196 "copyConstructor5" $) $) ${ $setVerbose $(@expr1073742197 $false $) $; copyConstructor5 $(@expr1073742198 $) $; $} $} $while $(@expr1073742199 $false $) ;
87: $do ${ $if $(@expr1073742200 $prepareTest $(@expr1073742201 "copyConstructor6" $) $) ${ $setVerbose $(@expr1073742202 $false $) $; copyConstructor6 $(@expr1073742203 $) $; $} $} $while $(@expr1073742204 $false $) ;
88: $do ${ $if $(@expr1073742205 $prepareTest $(@expr1073742206 "noOperatorEq" $) $) ${ $setVerbose $(@expr1073742207 $false $) $; noOperatorEq $(@expr1073742208 $) $; $} $} $while $(@expr1073742209 $false $) ;
89: $do ${ $if $(@expr1073742210 $prepareTest $(@expr1073742211 "noDestructor" $) $) ${ $setVerbose $(@expr1073742212 $false $) $; noDestructor $(@expr1073742213 $) $; $} $} $while $(@expr1073742214 $false $) ;
90:
91: $do ${ $if $(@expr1073742215 $prepareTest $(@expr1073742216 "operatorEqRetRefThis1" $) $) ${ $setVerbose $(@expr1073742217 $false $) $; operatorEqRetRefThis1 $(@expr1073742218 $) $; $} $} $while $(@expr1073742219 $false $) ;
92: $do ${ $if $(@expr1073742220 $prepareTest $(@expr1073742221 "operatorEqRetRefThis2" $) $) ${ $setVerbose $(@expr1073742222 $false $) $; operatorEqRetRefThis2 $(@expr1073742223 $) $; $} $} $while $(@expr1073742224 $false $) ;
93: $do ${ $if $(@expr1073742225 $prepareTest $(@expr1073742226 "operatorEqRetRefThis3" $) $) ${ $setVerbose $(@expr1073742227 $false $) $; operatorEqRetRefThis3 $(@expr1073742228 $) $; $} $} $while $(@expr1073742229 $false $) ;
94: $do ${ $if $(@expr1073742230 $prepareTest $(@expr1073742231 "operatorEqRetRefThis4" $) $) ${ $setVerbose $(@expr1073742232 $false $) $; operatorEqRetRefThis4 $(@expr1073742233 $) $; $} $} $while $(@expr1073742234 $false $) ;
95: $do ${ $if $(@expr1073742235 $prepareTest $(@expr1073742236 "operatorEqRetRefThis5" $) $) ${ $setVerbose $(@expr1073742237 $false $) $; operatorEqRetRefThis5 $(@expr1073742238 $) $; $} $} $while $(@expr1073742239 $false $) ;
96: $do ${ $if $(@expr1073742240 $prepareTest $(@expr1073742241 "operatorEqRetRefThis6" $) $) ${ $setVerbose $(@expr1073742242 $false $) $; operatorEqRetRefThis6 $(@expr1073742243 $) $; $} $} $while $(@expr1073742244 $false $) ;
97: $do ${ $if $(@expr1073742245 $prepareTest $(@expr1073742246 "operatorEqRetRefThis7" $) $) ${ $setVerbose $(@expr1073742247 $false $) $; operatorEqRetRefThis7 $(@expr1073742248 $) $; $} $} $while $(@expr1073742249 $false $) ;
98: $do ${ $if $(@expr1073742250 $prepareTest $(@expr1073742251 "operatorEqToSelf1" $) $) ${ $setVerbose $(@expr1073742252 $false $) $; operatorEqToSelf1 $(@expr1073742253 $) $; $} $} $while $(@expr1073742254 $false $) ;
99: $do ${ $if $(@expr1073742255 $prepareTest $(@expr1073742256 "operatorEqToSelf2" $) $) ${ $setVerbose $(@expr1073742257 $false $) $; operatorEqToSelf2 $(@expr1073742258 $) $; $} $} $while $(@expr1073742259 $false $) ;
100: $do ${ $if $(@expr1073742260 $prepareTest $(@expr1073742261 "operatorEqToSelf3" $) $) ${ $setVerbose $(@expr1073742262 $false $) $; operatorEqToSelf3 $(@expr1073742263 $) $; $} $} $while $(@expr1073742264 $false $) ;
101: $do ${ $if $(@expr1073742265 $prepareTest $(@expr1073742266 "operatorEqToSelf4" $) $) ${ $setVerbose $(@expr1073742267 $false $) $; operatorEqToSelf4 $(@expr1073742268 $) $; $} $} $while $(@expr1073742269 $false $) ;
102: $do ${ $if $(@expr1073742270 $prepareTest $(@expr1073742271 "operatorEqToSelf5" $) $) ${ $setVerbose $(@expr1073742272 $false $) $; operatorEqToSelf5 $(@expr1073742273 $) $; $} $} $while $(@expr1073742274 $false $) ;
103: $do ${ $if $(@expr1073742275 $prepareTest $(@expr1073742276 "operatorEqToSelf6" $) $) ${ $setVerbose $(@expr1073742277 $false $) $; operatorEqToSelf6 $(@expr1073742278 $) $; $} $} $while $(@expr1073742279 $false $) ;
104: $do ${ $if $(@expr1073742280 $prepareTest $(@expr1073742281 "operatorEqToSelf7" $) $) ${ $setVerbose $(@expr1073742282 $false $) $; operatorEqToSelf7 $(@expr1073742283 $) $; $} $} $while $(@expr1073742284 $false $) ;
105: $do ${ $if $(@expr1073742285 $prepareTest $(@expr1073742286 "operatorEqToSelf8" $) $) ${ $setVerbose $(@expr1073742287 $false $) $; operatorEqToSelf8 $(@expr1073742288 $) $; $} $} $while $(@expr1073742289 $false $) ;
106: $do ${ $if $(@expr1073742290 $prepareTest $(@expr1073742291 "operatorEqToSelf9" $) $) ${ $setVerbose $(@expr1073742292 $false $) $; operatorEqToSelf9 $(@expr1073742293 $) $; $} $} $while $(@expr1073742294 $false $) ;
107:
108: $do ${ $if $(@expr1073742295 $prepareTest $(@expr1073742296 "memsetOnStruct" $) $) ${ $setVerbose $(@expr1073742297 $false $) $; memsetOnStruct $(@expr1073742298 $) $; $} $} $while $(@expr1073742299 $false $) ;
109: $do ${ $if $(@expr1073742300 $prepareTest $(@expr1073742301 "memsetVector" $) $) ${ $setVerbose $(@expr1073742302 $false $) $; memsetVector $(@expr1073742303 $) $; $} $} $while $(@expr1073742304 $false $) ;
110: $do ${ $if $(@expr1073742305 $prepareTest $(@expr1073742306 "memsetOnClass" $) $) ${ $setVerbose $(@expr1073742307 $false $) $; memsetOnClass $(@expr1073742308 $) $; $} $} $while $(@expr1073742309 $false $) ;
111: $do ${ $if $(@expr1073742310 $prepareTest $(@expr1073742311 "memsetOnInvalid" $) $) ${ $setVerbose $(@expr1073742312 $false $) $; memsetOnInvalid $(@expr1073742313 $) $; $} $} $while $(@expr1073742314 $false $) ;
112: $do ${ $if $(@expr1073742315 $prepareTest $(@expr1073742316 "memsetOnStdPodType" $) $) ${ $setVerbose $(@expr1073742317 $false $) $; memsetOnStdPodType $(@expr1073742318 $) $; $} $} $while $(@expr1073742319 $false $) ;
113: $do ${ $if $(@expr1073742320 $prepareTest $(@expr1073742321 "memsetOnFloat" $) $) ${ $setVerbose $(@expr1073742322 $false $) $; memsetOnFloat $(@expr1073742323 $) $; $} $} $while $(@expr1073742324 $false $) ;
114: $do ${ $if $(@expr1073742325 $prepareTest $(@expr1073742326 "memsetOnUnknown" $) $) ${ $setVerbose $(@expr1073742327 $false $) $; memsetOnUnknown $(@expr1073742328 $) $; $} $} $while $(@expr1073742329 $false $) ;
115: $do ${ $if $(@expr1073742330 $prepareTest $(@expr1073742331 "mallocOnClass" $) $) ${ $setVerbose $(@expr1073742332 $false $) $; mallocOnClass $(@expr1073742333 $) $; $} $} $while $(@expr1073742334 $false $) ;
116:
117: $do ${ $if $(@expr1073742335 $prepareTest $(@expr1073742336 "this_subtraction" $) $) ${ $setVerbose $(@expr1073742337 $false $) $; this_subtraction $(@expr1073742338 $) $; $} $} $while $(@expr1073742339 $false $) ;
118:
119:
120: $do ${ $if $(@expr1073742340 $prepareTest $(@expr1073742341 "const1" $) $) ${ $setVerbose $(@expr1073742342 $false $) $; const1 $(@expr1073742343 $) $; $} $} $while $(@expr1073742344 $false $) ;
121: $do ${ $if $(@expr1073742345 $prepareTest $(@expr1073742346 "const2" $) $) ${ $setVerbose $(@expr1073742347 $false $) $; const2 $(@expr1073742348 $) $; $} $} $while $(@expr1073742349 $false $) ;
122: $do ${ $if $(@expr1073742350 $prepareTest $(@expr1073742351 "const3" $) $) ${ $setVerbose $(@expr1073742352 $false $) $; const3 $(@expr1073742353 $) $; $} $} $while $(@expr1073742354 $false $) ;
123: $do ${ $if $(@expr1073742355 $prepareTest $(@expr1073742356 "const4" $) $) ${ $setVerbose $(@expr1073742357 $false $) $; const4 $(@expr1073742358 $) $; $} $} $while $(@expr1073742359 $false $) ;
124: $do ${ $if $(@expr1073742360 $prepareTest $(@expr1073742361 "const5" $) $) ${ $setVerbose $(@expr1073742362 $false $) $; const5 $(@expr1073742363 $) $; $} $} $while $(@expr1073742364 $false $) ;
125: $do ${ $if $(@expr1073742365 $prepareTest $(@expr1073742366 "const6" $) $) ${ $setVerbose $(@expr1073742367 $false $) $; const6 $(@expr1073742368 $) $; $} $} $while $(@expr1073742369 $false $) ;
126: $do ${ $if $(@expr1073742370 $prepareTest $(@expr1073742371 "const7" $) $) ${ $setVerbose $(@expr1073742372 $false $) $; const7 $(@expr1073742373 $) $; $} $} $while $(@expr1073742374 $false $) ;
127: $do ${ $if $(@expr1073742375 $prepareTest $(@expr1073742376 "const8" $) $) ${ $setVerbose $(@expr1073742377 $false $) $; const8 $(@expr1073742378 $) $; $} $} $while $(@expr1073742379 $false $) ;
128: $do ${ $if $(@expr1073742380 $prepareTest $(@expr1073742381 "const9" $) $) ${ $setVerbose $(@expr1073742382 $false $) $; const9 $(@expr1073742383 $) $; $} $} $while $(@expr1073742384 $false $) ;
129: $do ${ $if $(@expr1073742385 $prepareTest $(@expr1073742386 "const10" $) $) ${ $setVerbose $(@expr1073742387 $false $) $; const10 $(@expr1073742388 $) $; $} $} $while $(@expr1073742389 $false $) ;
130: $do ${ $if $(@expr1073742390 $prepareTest $(@expr1073742391 "const11" $) $) ${ $setVerbose $(@expr1073742392 $false $) $; const11 $(@expr1073742393 $) $; $} $} $while $(@expr1073742394 $false $) ;
131: $do ${ $if $(@expr1073742395 $prepareTest $(@expr1073742396 "const12" $) $) ${ $setVerbose $(@expr1073742397 $false $) $; const12 $(@expr1073742398 $) $; $} $} $while $(@expr1073742399 $false $) ;
132: $do ${ $if $(@expr1073742400 $prepareTest $(@expr1073742401 "const13" $) $) ${ $setVerbose $(@expr1073742402 $false $) $; const13 $(@expr1073742403 $) $; $} $} $while $(@expr1073742404 $false $) ;
133: $do ${ $if $(@expr1073742405 $prepareTest $(@expr1073742406 "const14" $) $) ${ $setVerbose $(@expr1073742407 $false $) $; const14 $(@expr1073742408 $) $; $} $} $while $(@expr1073742409 $false $) ;
134: $do ${ $if $(@expr1073742410 $prepareTest $(@expr1073742411 "const15" $) $) ${ $setVerbose $(@expr1073742412 $false $) $; const15 $(@expr1073742413 $) $; $} $} $while $(@expr1073742414 $false $) ;
135: $do ${ $if $(@expr1073742415 $prepareTest $(@expr1073742416 "const16" $) $) ${ $setVerbose $(@expr1073742417 $false $) $; const16 $(@expr1073742418 $) $; $} $} $while $(@expr1073742419 $false $) ;
136: $do ${ $if $(@expr1073742420 $prepareTest $(@expr1073742421 "const17" $) $) ${ $setVerbose $(@expr1073742422 $false $) $; const17 $(@expr1073742423 $) $; $} $} $while $(@expr1073742424 $false $) ;
137: $do ${ $if $(@expr1073742425 $prepareTest $(@expr1073742426 "const18" $) $) ${ $setVerbose $(@expr1073742427 $false $) $; const18 $(@expr1073742428 $) $; $} $} $while $(@expr1073742429 $false $) ;
138: $do ${ $if $(@expr1073742430 $prepareTest $(@expr1073742431 "const19" $) $) ${ $setVerbose $(@expr1073742432 $false $) $; const19 $(@expr1073742433 $) $; $} $} $while $(@expr1073742434 $false $) ;
139: $do ${ $if $(@expr1073742435 $prepareTest $(@expr1073742436 "const20" $) $) ${ $setVerbose $(@expr1073742437 $false $) $; const20 $(@expr1073742438 $) $; $} $} $while $(@expr1073742439 $false $) ;
140: $do ${ $if $(@expr1073742440 $prepareTest $(@expr1073742441 "const21" $) $) ${ $setVerbose $(@expr1073742442 $false $) $; const21 $(@expr1073742443 $) $; $} $} $while $(@expr1073742444 $false $) ;
141: $do ${ $if $(@expr1073742445 $prepareTest $(@expr1073742446 "const22" $) $) ${ $setVerbose $(@expr1073742447 $false $) $; const22 $(@expr1073742448 $) $; $} $} $while $(@expr1073742449 $false $) ;
142: $do ${ $if $(@expr1073742450 $prepareTest $(@expr1073742451 "const23" $) $) ${ $setVerbose $(@expr1073742452 $false $) $; const23 $(@expr1073742453 $) $; $} $} $while $(@expr1073742454 $false $) ;
143: $do ${ $if $(@expr1073742455 $prepareTest $(@expr1073742456 "const24" $) $) ${ $setVerbose $(@expr1073742457 $false $) $; const24 $(@expr1073742458 $) $; $} $} $while $(@expr1073742459 $false $) ;
144: $do ${ $if $(@expr1073742460 $prepareTest $(@expr1073742461 "const25" $) $) ${ $setVerbose $(@expr1073742462 $false $) $; const25 $(@expr1073742463 $) $; $} $} $while $(@expr1073742464 $false $) ;
145: $do ${ $if $(@expr1073742465 $prepareTest $(@expr1073742466 "const26" $) $) ${ $setVerbose $(@expr1073742467 $false $) $; const26 $(@expr1073742468 $) $; $} $} $while $(@expr1073742469 $false $) ;
146: $do ${ $if $(@expr1073742470 $prepareTest $(@expr1073742471 "const27" $) $) ${ $setVerbose $(@expr1073742472 $false $) $; const27 $(@expr1073742473 $) $; $} $} $while $(@expr1073742474 $false $) ;
147: $do ${ $if $(@expr1073742475 $prepareTest $(@expr1073742476 "const28" $) $) ${ $setVerbose $(@expr1073742477 $false $) $; const28 $(@expr1073742478 $) $; $} $} $while $(@expr1073742479 $false $) ;
148: $do ${ $if $(@expr1073742480 $prepareTest $(@expr1073742481 "const29" $) $) ${ $setVerbose $(@expr1073742482 $false $) $; const29 $(@expr1073742483 $) $; $} $} $while $(@expr1073742484 $false $) ;
149: $do ${ $if $(@expr1073742485 $prepareTest $(@expr1073742486 "const30" $) $) ${ $setVerbose $(@expr1073742487 $false $) $; const30 $(@expr1073742488 $) $; $} $} $while $(@expr1073742489 $false $) ;
150: $do ${ $if $(@expr1073742490 $prepareTest $(@expr1073742491 "const31" $) $) ${ $setVerbose $(@expr1073742492 $false $) $; const31 $(@expr1073742493 $) $; $} $} $while $(@expr1073742494 $false $) ;
151: $do ${ $if $(@expr1073742495 $prepareTest $(@expr1073742496 "const32" $) $) ${ $setVerbose $(@expr1073742497 $false $) $; const32 $(@expr1073742498 $) $; $} $} $while $(@expr1073742499 $false $) ;
152: $do ${ $if $(@expr1073742500 $prepareTest $(@expr1073742501 "const33" $) $) ${ $setVerbose $(@expr1073742502 $false $) $; const33 $(@expr1073742503 $) $; $} $} $while $(@expr1073742504 $false $) ;
153: $do ${ $if $(@expr1073742505 $prepareTest $(@expr1073742506 "const34" $) $) ${ $setVerbose $(@expr1073742507 $false $) $; const34 $(@expr1073742508 $) $; $} $} $while $(@expr1073742509 $false $) ;
154: $do ${ $if $(@expr1073742510 $prepareTest $(@expr1073742511 "const35" $) $) ${ $setVerbose $(@expr1073742512 $false $) $; const35 $(@expr1073742513 $) $; $} $} $while $(@expr1073742514 $false $) ;
155: $do ${ $if $(@expr1073742515 $prepareTest $(@expr1073742516 "const36" $) $) ${ $setVerbose $(@expr1073742517 $false $) $; const36 $(@expr1073742518 $) $; $} $} $while $(@expr1073742519 $false $) ;
156: $do ${ $if $(@expr1073742520 $prepareTest $(@expr1073742521 "const37" $) $) ${ $setVerbose $(@expr1073742522 $false $) $; const37 $(@expr1073742523 $) $; $} $} $while $(@expr1073742524 $false $) ;
157: $do ${ $if $(@expr1073742525 $prepareTest $(@expr1073742526 "const38" $) $) ${ $setVerbose $(@expr1073742527 $false $) $; const38 $(@expr1073742528 $) $; $} $} $while $(@expr1073742529 $false $) ;
158: $do ${ $if $(@expr1073742530 $prepareTest $(@expr1073742531 "const39" $) $) ${ $setVerbose $(@expr1073742532 $false $) $; const39 $(@expr1073742533 $) $; $} $} $while $(@expr1073742534 $false $) ;
159: $do ${ $if $(@expr1073742535 $prepareTest $(@expr1073742536 "const40" $) $) ${ $setVerbose $(@expr1073742537 $false $) $; const40 $(@expr1073742538 $) $; $} $} $while $(@expr1073742539 $false $) ;
160: $do ${ $if $(@expr1073742540 $prepareTest $(@expr1073742541 "const41" $) $) ${ $setVerbose $(@expr1073742542 $false $) $; const41 $(@expr1073742543 $) $; $} $} $while $(@expr1073742544 $false $) ;
161: $do ${ $if $(@expr1073742545 $prepareTest $(@expr1073742546 "const42" $) $) ${ $setVerbose $(@expr1073742547 $false $) $; const42 $(@expr1073742548 $) $; $} $} $while $(@expr1073742549 $false $) ;
162: $do ${ $if $(@expr1073742550 $prepareTest $(@expr1073742551 "const43" $) $) ${ $setVerbose $(@expr1073742552 $false $) $; const43 $(@expr1073742553 $) $; $} $} $while $(@expr1073742554 $false $) ;
163: $do ${ $if $(@expr1073742555 $prepareTest $(@expr1073742556 "const44" $) $) ${ $setVerbose $(@expr1073742557 $false $) $; const44 $(@expr1073742558 $) $; $} $} $while $(@expr1073742559 $false $) ;
164: $do ${ $if $(@expr1073742560 $prepareTest $(@expr1073742561 "const45" $) $) ${ $setVerbose $(@expr1073742562 $false $) $; const45 $(@expr1073742563 $) $; $} $} $while $(@expr1073742564 $false $) ;
165: $do ${ $if $(@expr1073742565 $prepareTest $(@expr1073742566 "const46" $) $) ${ $setVerbose $(@expr1073742567 $false $) $; const46 $(@expr1073742568 $) $; $} $} $while $(@expr1073742569 $false $) ;
166: $do ${ $if $(@expr1073742570 $prepareTest $(@expr1073742571 "const47" $) $) ${ $setVerbose $(@expr1073742572 $false $) $; const47 $(@expr1073742573 $) $; $} $} $while $(@expr1073742574 $false $) ;
167: $do ${ $if $(@expr1073742575 $prepareTest $(@expr1073742576 "const48" $) $) ${ $setVerbose $(@expr1073742577 $false $) $; const48 $(@expr1073742578 $) $; $} $} $while $(@expr1073742579 $false $) ;
168: $do ${ $if $(@expr1073742580 $prepareTest $(@expr1073742581 "const49" $) $) ${ $setVerbose $(@expr1073742582 $false $) $; const49 $(@expr1073742583 $) $; $} $} $while $(@expr1073742584 $false $) ;
169: $do ${ $if $(@expr1073742585 $prepareTest $(@expr1073742586 "const50" $) $) ${ $setVerbose $(@expr1073742587 $false $) $; const50 $(@expr1073742588 $) $; $} $} $while $(@expr1073742589 $false $) ;
170: $do ${ $if $(@expr1073742590 $prepareTest $(@expr1073742591 "const51" $) $) ${ $setVerbose $(@expr1073742592 $false $) $; const51 $(@expr1073742593 $) $; $} $} $while $(@expr1073742594 $false $) ;
171: $do ${ $if $(@expr1073742595 $prepareTest $(@expr1073742596 "const52" $) $) ${ $setVerbose $(@expr1073742597 $false $) $; const52 $(@expr1073742598 $) $; $} $} $while $(@expr1073742599 $false $) ;
172: $do ${ $if $(@expr1073742600 $prepareTest $(@expr1073742601 "const53" $) $) ${ $setVerbose $(@expr1073742602 $false $) $; const53 $(@expr1073742603 $) $; $} $} $while $(@expr1073742604 $false $) ;
173: $do ${ $if $(@expr1073742605 $prepareTest $(@expr1073742606 "const54" $) $) ${ $setVerbose $(@expr1073742607 $false $) $; const54 $(@expr1073742608 $) $; $} $} $while $(@expr1073742609 $false $) ;
174: $do ${ $if $(@expr1073742610 $prepareTest $(@expr1073742611 "const55" $) $) ${ $setVerbose $(@expr1073742612 $false $) $; const55 $(@expr1073742613 $) $; $} $} $while $(@expr1073742614 $false $) ;
175: $do ${ $if $(@expr1073742615 $prepareTest $(@expr1073742616 "const56" $) $) ${ $setVerbose $(@expr1073742617 $false $) $; const56 $(@expr1073742618 $) $; $} $} $while $(@expr1073742619 $false $) ;
176: $do ${ $if $(@expr1073742620 $prepareTest $(@expr1073742621 "const57" $) $) ${ $setVerbose $(@expr1073742622 $false $) $; const57 $(@expr1073742623 $) $; $} $} $while $(@expr1073742624 $false $) ;
177: $do ${ $if $(@expr1073742625 $prepareTest $(@expr1073742626 "const58" $) $) ${ $setVerbose $(@expr1073742627 $false $) $; const58 $(@expr1073742628 $) $; $} $} $while $(@expr1073742629 $false $) ;
178: $do ${ $if $(@expr1073742630 $prepareTest $(@expr1073742631 "const59" $) $) ${ $setVerbose $(@expr1073742632 $false $) $; const59 $(@expr1073742633 $) $; $} $} $while $(@expr1073742634 $false $) ;
179: $do ${ $if $(@expr1073742635 $prepareTest $(@expr1073742636 "const60" $) $) ${ $setVerbose $(@expr1073742637 $false $) $; const60 $(@expr1073742638 $) $; $} $} $while $(@expr1073742639 $false $) ;
180: $do ${ $if $(@expr1073742640 $prepareTest $(@expr1073742641 "const61" $) $) ${ $setVerbose $(@expr1073742642 $false $) $; const61 $(@expr1073742643 $) $; $} $} $while $(@expr1073742644 $false $) ;
181: $do ${ $if $(@expr1073742645 $prepareTest $(@expr1073742646 "const62" $) $) ${ $setVerbose $(@expr1073742647 $false $) $; const62 $(@expr1073742648 $) $; $} $} $while $(@expr1073742649 $false $) ;
182: $do ${ $if $(@expr1073742650 $prepareTest $(@expr1073742651 "const63" $) $) ${ $setVerbose $(@expr1073742652 $false $) $; const63 $(@expr1073742653 $) $; $} $} $while $(@expr1073742654 $false $) ;
183: $do ${ $if $(@expr1073742655 $prepareTest $(@expr1073742656 "const64" $) $) ${ $setVerbose $(@expr1073742657 $false $) $; const64 $(@expr1073742658 $) $; $} $} $while $(@expr1073742659 $false $) ;
184: $do ${ $if $(@expr1073742660 $prepareTest $(@expr1073742661 "const65" $) $) ${ $setVerbose $(@expr1073742662 $false $) $; const65 $(@expr1073742663 $) $; $} $} $while $(@expr1073742664 $false $) ;
185: $do ${ $if $(@expr1073742665 $prepareTest $(@expr1073742666 "const66" $) $) ${ $setVerbose $(@expr1073742667 $false $) $; const66 $(@expr1073742668 $) $; $} $} $while $(@expr1073742669 $false $) ;
186: $do ${ $if $(@expr1073742670 $prepareTest $(@expr1073742671 "const67" $) $) ${ $setVerbose $(@expr1073742672 $false $) $; const67 $(@expr1073742673 $) $; $} $} $while $(@expr1073742674 $false $) ;
187: $do ${ $if $(@expr1073742675 $prepareTest $(@expr1073742676 "const68" $) $) ${ $setVerbose $(@expr1073742677 $false $) $; const68 $(@expr1073742678 $) $; $} $} $while $(@expr1073742679 $false $) ;
188: $do ${ $if $(@expr1073742680 $prepareTest $(@expr1073742681 "const69" $) $) ${ $setVerbose $(@expr1073742682 $false $) $; const69 $(@expr1073742683 $) $; $} $} $while $(@expr1073742684 $false $) ;
189: $do ${ $if $(@expr1073742685 $prepareTest $(@expr1073742686 "const70" $) $) ${ $setVerbose $(@expr1073742687 $false $) $; const70 $(@expr1073742688 $) $; $} $} $while $(@expr1073742689 $false $) ;
190: $do ${ $if $(@expr1073742690 $prepareTest $(@expr1073742691 "const71" $) $) ${ $setVerbose $(@expr1073742692 $false $) $; const71 $(@expr1073742693 $) $; $} $} $while $(@expr1073742694 $false $) ;
191: $do ${ $if $(@expr1073742695 $prepareTest $(@expr1073742696 "const72" $) $) ${ $setVerbose $(@expr1073742697 $false $) $; const72 $(@expr1073742698 $) $; $} $} $while $(@expr1073742699 $false $) ;
192: $do ${ $if $(@expr1073742700 $prepareTest $(@expr1073742701 "const73" $) $) ${ $setVerbose $(@expr1073742702 $false $) $; const73 $(@expr1073742703 $) $; $} $} $while $(@expr1073742704 $false $) ;
193: $do ${ $if $(@expr1073742705 $prepareTest $(@expr1073742706 "const74" $) $) ${ $setVerbose $(@expr1073742707 $false $) $; const74 $(@expr1073742708 $) $; $} $} $while $(@expr1073742709 $false $) ;
194: $do ${ $if $(@expr1073742710 $prepareTest $(@expr1073742711 "const75" $) $) ${ $setVerbose $(@expr1073742712 $false $) $; const75 $(@expr1073742713 $) $; $} $} $while $(@expr1073742714 $false $) ;
195: $do ${ $if $(@expr1073742715 $prepareTest $(@expr1073742716 "const76" $) $) ${ $setVerbose $(@expr1073742717 $false $) $; const76 $(@expr1073742718 $) $; $} $} $while $(@expr1073742719 $false $) ;
196: $do ${ $if $(@expr1073742720 $prepareTest $(@expr1073742721 "const77" $) $) ${ $setVerbose $(@expr1073742722 $false $) $; const77 $(@expr1073742723 $) $; $} $} $while $(@expr1073742724 $false $) ;
197: $do ${ $if $(@expr1073742725 $prepareTest $(@expr1073742726 "const78" $) $) ${ $setVerbose $(@expr1073742727 $false $) $; const78 $(@expr1073742728 $) $; $} $} $while $(@expr1073742729 $false $) ;
198: $do ${ $if $(@expr1073742730 $prepareTest $(@expr1073742731 "const79" $) $) ${ $setVerbose $(@expr1073742732 $false $) $; const79 $(@expr1073742733 $) $; $} $} $while $(@expr1073742734 $false $) ;
199: $do ${ $if $(@expr1073742735 $prepareTest $(@expr1073742736 "const_handleDefaultParameters" $) $) ${ $setVerbose $(@expr1073742737 $false $) $; const_handleDefaultParameters $(@expr1073742738 $) $; $} $} $while $(@expr1073742739 $false $) ;
200: $do ${ $if $(@expr1073742740 $prepareTest $(@expr1073742741 "const_passThisToMemberOfOtherClass" $) $) ${ $setVerbose $(@expr1073742742 $false $) $; const_passThisToMemberOfOtherClass $(@expr1073742743 $) $; $} $} $while $(@expr1073742744 $false $) ;
201: $do ${ $if $(@expr1073742745 $prepareTest $(@expr1073742746 "assigningPointerToPointerIsNotAConstOperation" $) $) ${ $setVerbose $(@expr1073742747 $false $) $; assigningPointerToPointerIsNotAConstOperation $(@expr1073742748 $) $; $} $} $while $(@expr1073742749 $false $) ;
202: $do ${ $if $(@expr1073742750 $prepareTest $(@expr1073742751 "assigningArrayElementIsNotAConstOperation" $) $) ${ $setVerbose $(@expr1073742752 $false $) $; assigningArrayElementIsNotAConstOperation $(@expr1073742753 $) $; $} $} $while $(@expr1073742754 $false $) ;
203: $do ${ $if $(@expr1073742755 $prepareTest $(@expr1073742756 "constoperator1" $) $) ${ $setVerbose $(@expr1073742757 $false $) $; constoperator1 $(@expr1073742758 $) $; $} $} $while $(@expr1073742759 $false $) ;
204: $do ${ $if $(@expr1073742760 $prepareTest $(@expr1073742761 "constoperator2" $) $) ${ $setVerbose $(@expr1073742762 $false $) $; constoperator2 $(@expr1073742763 $) $; $} $} $while $(@expr1073742764 $false $) ;
205: $do ${ $if $(@expr1073742765 $prepareTest $(@expr1073742766 "constoperator3" $) $) ${ $setVerbose $(@expr1073742767 $false $) $; constoperator3 $(@expr1073742768 $) $; $} $} $while $(@expr1073742769 $false $) ;
206: $do ${ $if $(@expr1073742770 $prepareTest $(@expr1073742771 "constoperator4" $) $) ${ $setVerbose $(@expr1073742772 $false $) $; constoperator4 $(@expr1073742773 $) $; $} $} $while $(@expr1073742774 $false $) ;
207: $do ${ $if $(@expr1073742775 $prepareTest $(@expr1073742776 "constoperator5" $) $) ${ $setVerbose $(@expr1073742777 $false $) $; constoperator5 $(@expr1073742778 $) $; $} $} $while $(@expr1073742779 $false $) ;
208: $do ${ $if $(@expr1073742780 $prepareTest $(@expr1073742781 "constoperator6" $) $) ${ $setVerbose $(@expr1073742782 $false $) $; constoperator6 $(@expr1073742783 $) $; $} $} $while $(@expr1073742784 $false $) ;
209: $do ${ $if $(@expr1073742785 $prepareTest $(@expr1073742786 "constincdec" $) $) ${ $setVerbose $(@expr1073742787 $false $) $; constincdec $(@expr1073742788 $) $; $} $} $while $(@expr1073742789 $false $) ;
210: $do ${ $if $(@expr1073742790 $prepareTest $(@expr1073742791 "constassign1" $) $) ${ $setVerbose $(@expr1073742792 $false $) $; constassign1 $(@expr1073742793 $) $; $} $} $while $(@expr1073742794 $false $) ;
211: $do ${ $if $(@expr1073742795 $prepareTest $(@expr1073742796 "constassign2" $) $) ${ $setVerbose $(@expr1073742797 $false $) $; constassign2 $(@expr1073742798 $) $; $} $} $while $(@expr1073742799 $false $) ;
212: $do ${ $if $(@expr1073742800 $prepareTest $(@expr1073742801 "constincdecarray" $) $) ${ $setVerbose $(@expr1073742802 $false $) $; constincdecarray $(@expr1073742803 $) $; $} $} $while $(@expr1073742804 $false $) ;
213: $do ${ $if $(@expr1073742805 $prepareTest $(@expr1073742806 "constassignarray" $) $) ${ $setVerbose $(@expr1073742807 $false $) $; constassignarray $(@expr1073742808 $) $; $} $} $while $(@expr1073742809 $false $) ;
214: $do ${ $if $(@expr1073742810 $prepareTest $(@expr1073742811 "constReturnReference" $) $) ${ $setVerbose $(@expr1073742812 $false $) $; constReturnReference $(@expr1073742813 $) $; $} $} $while $(@expr1073742814 $false $) ;
215: $do ${ $if $(@expr1073742815 $prepareTest $(@expr1073742816 "constDelete" $) $) ${ $setVerbose $(@expr1073742817 $false $) $; constDelete $(@expr1073742818 $) $; $} $} $while $(@expr1073742819 $false $) ;
216: $do ${ $if $(@expr1073742820 $prepareTest $(@expr1073742821 "constLPVOID" $) $) ${ $setVerbose $(@expr1073742822 $false $) $; constLPVOID $(@expr1073742823 $) $; $} $} $while $(@expr1073742824 $false $) ;
217: $do ${ $if $(@expr1073742825 $prepareTest $(@expr1073742826 "constFunc" $) $) ${ $setVerbose $(@expr1073742827 $false $) $; constFunc $(@expr1073742828 $) $; $} $} $while $(@expr1073742829 $false $) ;
218: $do ${ $if $(@expr1073742830 $prepareTest $(@expr1073742831 "constVirtualFunc" $) $) ${ $setVerbose $(@expr1073742832 $false $) $; constVirtualFunc $(@expr1073742833 $) $; $} $} $while $(@expr1073742834 $false $) ;
219: $do ${ $if $(@expr1073742835 $prepareTest $(@expr1073742836 "constIfCfg" $) $) ${ $setVerbose $(@expr1073742837 $false $) $; constIfCfg $(@expr1073742838 $) $; $} $} $while $(@expr1073742839 $false $) ;
220: $do ${ $if $(@expr1073742840 $prepareTest $(@expr1073742841 "constFriend" $) $) ${ $setVerbose $(@expr1073742842 $false $) $; constFriend $(@expr1073742843 $) $; $} $} $while $(@expr1073742844 $false $) ;
221: $do ${ $if $(@expr1073742845 $prepareTest $(@expr1073742846 "constUnion" $) $) ${ $setVerbose $(@expr1073742847 $false $) $; constUnion $(@expr1073742848 $) $; $} $} $while $(@expr1073742849 $false $) ;
222: $do ${ $if $(@expr1073742850 $prepareTest $(@expr1073742851 "constArrayOperator" $) $) ${ $setVerbose $(@expr1073742852 $false $) $; constArrayOperator $(@expr1073742853 $) $; $} $} $while $(@expr1073742854 $false $) ;
223: $do ${ $if $(@expr1073742855 $prepareTest $(@expr1073742856 "constRangeBasedFor" $) $) ${ $setVerbose $(@expr1073742857 $false $) $; constRangeBasedFor $(@expr1073742858 $) $; $} $} $while $(@expr1073742859 $false $) ;
224: $do ${ $if $(@expr1073742860 $prepareTest $(@expr1073742861 "const_shared_ptr" $) $) ${ $setVerbose $(@expr1073742862 $false $) $; const_shared_ptr $(@expr1073742863 $) $; $} $} $while $(@expr1073742864 $false $) ;
225: $do ${ $if $(@expr1073742865 $prepareTest $(@expr1073742866 "constPtrToConstPtr" $) $) ${ $setVerbose $(@expr1073742867 $false $) $; constPtrToConstPtr $(@expr1073742868 $) $; $} $} $while $(@expr1073742869 $false $) ;
226: $do ${ $if $(@expr1073742870 $prepareTest $(@expr1073742871 "constTrailingReturnType" $) $) ${ $setVerbose $(@expr1073742872 $false $) $; constTrailingReturnType $(@expr1073742873 $) $; $} $} $while $(@expr1073742874 $false $) ;
227: $do ${ $if $(@expr1073742875 $prepareTest $(@expr1073742876 "staticArrayPtrOverload" $) $) ${ $setVerbose $(@expr1073742877 $false $) $; staticArrayPtrOverload $(@expr1073742878 $) $; $} $} $while $(@expr1073742879 $false $) ;
228: $do ${ $if $(@expr1073742880 $prepareTest $(@expr1073742881 "qualifiedNameMember" $) $) ${ $setVerbose $(@expr1073742882 $false $) $; qualifiedNameMember $(@expr1073742883 $) $; $} $} $while $(@expr1073742884 $false $) ;
229:
230: $do ${ $if $(@expr1073742885 $prepareTest $(@expr1073742886 "initializerListOrder" $) $) ${ $setVerbose $(@expr1073742887 $false $) $; initializerListOrder $(@expr1073742888 $) $; $} $} $while $(@expr1073742889 $false $) ;
231: $do ${ $if $(@expr1073742890 $prepareTest $(@expr1073742891 "initializerListUsage" $) $) ${ $setVerbose $(@expr1073742892 $false $) $; initializerListUsage $(@expr1073742893 $) $; $} $} $while $(@expr1073742894 $false $) ;
232: $do ${ $if $(@expr1073742895 $prepareTest $(@expr1073742896 "selfInitialization" $) $) ${ $setVerbose $(@expr1073742897 $false $) $; selfInitialization $(@expr1073742898 $) $; $} $} $while $(@expr1073742899 $false $) ;
233:
234: $do ${ $if $(@expr1073742900 $prepareTest $(@expr1073742901 "virtualFunctionCallInConstructor" $) $) ${ $setVerbose $(@expr1073742902 $false $) $; virtualFunctionCallInConstructor $(@expr1073742903 $) $; $} $} $while $(@expr1073742904 $false $) ;
235: $do ${ $if $(@expr1073742905 $prepareTest $(@expr1073742906 "pureVirtualFunctionCall" $) $) ${ $setVerbose $(@expr1073742907 $false $) $; pureVirtualFunctionCall $(@expr1073742908 $) $; $} $} $while $(@expr1073742909 $false $) ;
236: $do ${ $if $(@expr1073742910 $prepareTest $(@expr1073742911 "pureVirtualFunctionCallOtherClass" $) $) ${ $setVerbose $(@expr1073742912 $false $) $; pureVirtualFunctionCallOtherClass $(@expr1073742913 $) $; $} $} $while $(@expr1073742914 $false $) ;
237: $do ${ $if $(@expr1073742915 $prepareTest $(@expr1073742916 "pureVirtualFunctionCallWithBody" $) $) ${ $setVerbose $(@expr1073742917 $false $) $; pureVirtualFunctionCallWithBody $(@expr1073742918 $) $; $} $} $while $(@expr1073742919 $false $) ;
238: $do ${ $if $(@expr1073742920 $prepareTest $(@expr1073742921 "pureVirtualFunctionCallPrevented" $) $) ${ $setVerbose $(@expr1073742922 $false $) $; pureVirtualFunctionCallPrevented $(@expr1073742923 $) $; $} $} $while $(@expr1073742924 $false $) ;
239:
240: $do ${ $if $(@expr1073742925 $prepareTest $(@expr1073742926 "duplInheritedMembers" $) $) ${ $setVerbose $(@expr1073742927 $false $) $; duplInheritedMembers $(@expr1073742928 $) $; $} $} $while $(@expr1073742929 $false $) ;
241: $do ${ $if $(@expr1073742930 $prepareTest $(@expr1073742931 "explicitConstructors" $) $) ${ $setVerbose $(@expr1073742932 $false $) $; explicitConstructors $(@expr1073742933 $) $; $} $} $while $(@expr1073742934 $false $) ;
242: $do ${ $if $(@expr1073742935 $prepareTest $(@expr1073742936 "copyCtorAndEqOperator" $) $) ${ $setVerbose $(@expr1073742937 $false $) $; copyCtorAndEqOperator $(@expr1073742938 $) $; $} $} $while $(@expr1073742939 $false $) ;
243:
244: $do ${ $if $(@expr1073742940 $prepareTest $(@expr1073742941 "override1" $) $) ${ $setVerbose $(@expr1073742942 $false $) $; override1 $(@expr1073742943 $) $; $} $} $while $(@expr1073742944 $false $) ;
245: $do ${ $if $(@expr1073742945 $prepareTest $(@expr1073742946 "overrideCVRefQualifiers" $) $) ${ $setVerbose $(@expr1073742947 $false $) $; overrideCVRefQualifiers $(@expr1073742948 $) $; $} $} $while $(@expr1073742949 $false $) ;
246:
247: $do ${ $if $(@expr1073742950 $prepareTest $(@expr1073742951 "thisUseAfterFree" $) $) ${ $setVerbose $(@expr1073742952 $false $) $; thisUseAfterFree $(@expr1073742953 $) $; $} $} $while $(@expr1073742954 $false $) ;
248:
249: $do ${ $if $(@expr1073742955 $prepareTest $(@expr1073742956 "unsafeClassRefMember" $) $) ${ $setVerbose $(@expr1073742957 $false $) $; unsafeClassRefMember $(@expr1073742958 $) $; $} $} $while $(@expr1073742959 $false $) ;
250:
251: $do ${ $if $(@expr1073742960 $prepareTest $(@expr1073742961 "ctuOneDefinitionRule" $) $) ${ $setVerbose $(@expr1073742962 $false $) $; ctuOneDefinitionRule $(@expr1073742963 $) $; $} $} $while $(@expr1073742964 $false $) ;
252:
253: $do ${ $if $(@expr1073742965 $prepareTest $(@expr1073742966 "testGetFileInfo" $) $) ${ $setVerbose $(@expr1073742967 $false $) $; testGetFileInfo $(@expr1073742968 $) $; $} $} $while $(@expr1073742969 $false $) ;
254: }
255:
256:
257: void checkCopyCtorAndEqOperator_ ( const char code@var110 [ ] , const char * file@var111 , int line@var112 ) {
258:
259: errout@var100 .@expr1073742971 str (@expr1073742972 "" ) ;
260: Settings settings@var113 ;
261: settings@var113 .@expr1073742973 severity@var114 .@expr1073742974 enable (@expr1073742975 Severity ::@expr1073742976 warning@expr1073742970 ) ;
262:
263:
264: Tokenizer tokenizer@var115 (@expr1073742977 &@expr1154 settings@var113 , this@expr1155 ) ;
265: std ::@expr1073742980 istringstream istr@var116 (@expr1073742981 code@var110 ) ;
266: $assert_ $(@expr1073742982 file@var111 $, line@var112 $, $(@expr1073742983 tokenizer@var115 .@expr1073742984 tokenize (@expr1073742985 istr@var116 , "test.cpp" ) $) $) ;
267:
268:
269: CheckClass checkClass@var117 (@expr1073742986 &@expr1073742987 tokenizer@var115 , &@expr1154 settings@var113 , this@expr1155 ) ;
270: checkClass@var117 .@expr1073742989 checkCopyCtorAndEqOperator (@expr1073742990 ) ;
271: }
272:
273: void copyCtorAndEqOperator ( ) {
274: $checkCopyCtorAndEqOperator_ $(@expr1073742991 "class A\n{\n    A(const A& other) { }\n    A& operator=(const A& other) { return *this; }\n};" $, "cppcheck-2.8/test/testclass.cpp" $, 274 $)
275:
276:
277:
278: ;
279: $if $(@expr1073742992 $!@expr1073742993 $assertEquals $(@expr1073742994 "cppcheck-2.8/test/testclass.cpp" $, 279 $, "" $, errout@var100 .@expr1171 str (@expr1172 ) $) $) { $return ; }
280:
281:
282: $checkCopyCtorAndEqOperator_ $(@expr1073742997 "class A\n{\n};" $, "cppcheck-2.8/test/testclass.cpp" $, 282 $)
283:
284: ;
285: $if $(@expr1073742998 $!@expr1073742999 $assertEquals $(@expr1073743000 "cppcheck-2.8/test/testclass.cpp" $, 285 $, "" $, errout@var100 .@expr1171 str (@expr1172 ) $) $) { $return ; }
286:
287: $checkCopyCtorAndEqOperator_ $(@expr1073743003 "class A\n{\n    A(const A& other) { }\n};" $, "cppcheck-2.8/test/testclass.cpp" $, 287 $)
288:
289:
290: ;
291: $if $(@expr1073743004 $!@expr1073743005 $assertEquals $(@expr1073743006 "cppcheck-2.8/test/testclass.cpp" $, 291 $, "" $, errout@var100 .@expr1171 str (@expr1172 ) $) $) { $return ; }
292:
293: $checkCopyCtorAndEqOperator_ $(@expr1073743009 "class A\n{\n    A& operator=(const A& other) { return *this; }\n};" $, "cppcheck-2.8/test/testclass.cpp" $, 293 $)
294:
295:
296: ;
297: $if $(@expr1073743010 $!@expr1073743011 $assertEquals $(@expr1073743012 "cppcheck-2.8/test/testclass.cpp" $, 297 $, "" $, errout@var100 .@expr1171 str (@expr1172 ) $) $) { $return ; }
298:
299:
300: $checkCopyCtorAndEqOperator_ $(@expr1073743015 "class A\n{\n    A(const A& other) { }\n    int x;\n};" $, "cppcheck-2.8/test/testclass.cpp" $, 300 $)
301:
302:
303:
304: ;
305: $todoAssertEquals $(@expr1073743016 "cppcheck-2.8/test/testclass.cpp" $, 305 $, "[test.cpp:1]: (warning) The class 'A' has 'copy constructor' but lack of 'operator='.\n" $, "" $, errout@var100 .@expr1171 str (@expr1172 ) $) ;
306:
307:
308: $checkCopyCtorAndEqOperator_ $(@expr1073743019 "class A\n{\n    A& operator=(const A& other) { return *this; }\n    int x;\n};" $, "cppcheck-2.8/test/testclass.cpp" $, 308 $)
309:
310:
311:
312: ;
313: $todoAssertEquals $(@expr1073743020 "cppcheck-2.8/test/testclass.cpp" $, 313 $, "[test.cpp:1]: (warning) The class 'A' has 'operator=' but lack of 'copy constructor'.\n" $, "" $, errout@var100 .@expr1171 str (@expr1172 ) $) ;
314:
315:
316: $checkCopyCtorAndEqOperator_ $(@expr1073743023 "class A\n{\n    A& operator=(const int &x) { this->x = x; return *this; }\n    int x;\n};" $, "cppcheck-2.8/test/testclass.cpp" $, 316 $)
317:
318:
319:
320: ;
321: $if $(@expr1073743024 $!@expr1073743025 $assertEquals $(@expr1073743026 "cppcheck-2.8/test/testclass.cpp" $, 321 $, "" $, errout@var100 .@expr1171 str (@expr1172 ) $) $) { $return ; }
322:
323: $checkCopyCtorAndEqOperator_ $(@expr1073743029 "class A {\npublic:\n    A() : x(0) { }\n    A(const A & a) { x = a.x; }\n    A & operator = (const A & a) {\n        x = a.x;\n        return *this;\n    }\nprivate:\n    int x;\n};\nclass B : public A {\npublic:\n    B() { }\n    B(const B & b) :A(b) { }\nprivate:\n    static int i;\n};" $, "cppcheck-2.8/test/testclass.cpp" $, 323 $)
324:
|
339:
340: ;
341: $if $(@expr1073743030 $!@expr1073743031 $assertEquals $(@expr1073743032 "cppcheck-2.8/test/testclass.cpp" $, 341 $, "" $, errout@var100 .@expr1171 str (@expr1172 ) $) $) { $return ; }
342:
343:
344: $checkCopyCtorAndEqOperator_ $(@expr1073743035 "struct S {\n  std::string test;\n  S(S&& s) : test(std::move(s.test)) { }\n  S& operator = (S &&s) {\n    test = std::move(s.test);\n    return *this;\n  }\n};" $, "cppcheck-2.8/test/testclass.cpp" $, 344 $)
345:
|
350:
351: ;
352: $if $(@expr1073743036 $!@expr1073743037 $assertEquals $(@expr1073743038 "cppcheck-2.8/test/testclass.cpp" $, 352 $, "" $, errout@var100 .@expr1171 str (@expr1172 ) $) $) { $return ; }
353:
354:
355: $checkCopyCtorAndEqOperator_ $(@expr1073743041 "struct StaticListNode {\n  StaticListNode(StaticListNode*& prev) : m_next(0) {}\n  StaticListNode* m_next;\n};" $, "cppcheck-2.8/test/testclass.cpp" $, 355 $)
356:
357:
358: ;
359: $if $(@expr1073743042 $!@expr1073743043 $assertEquals $(@expr1073743044 "cppcheck-2.8/test/testclass.cpp" $, 359 $, "" $, errout@var100 .@expr1171 str (@expr1172 ) $) $) { $return ; }
360: }
361:
362:
363: void checkExplicitConstructors_ ( const char code@var118 [ ] , const char * file@var119 , int line@var120 ) {
364:
365: errout@var100 .@expr1073743047 str (@expr1073743048 "" ) ;
366:
367:
368: Tokenizer tokenizer@var121 (@expr1073743049 &@expr1226 settings0@var102 , this@expr1227 ) ;
369: std ::@expr1073743052 istringstream istr@var122 (@expr1073743053 code@var118 ) ;
370: $assert_ $(@expr1073743054 file@var119 $, line@var120 $, $(@expr1073743055 tokenizer@var121 .@expr1073743056 tokenize (@expr1073743057 istr@var122 , "test.cpp" ) $) $) ;
371:
372:
373: CheckClass checkClass@var123 (@expr1073743058 &@expr1073743059 tokenizer@var121 , &@expr1226 settings0@var102 , this@expr1227 ) ;
374: checkClass@var123 .@expr1073743061 checkExplicitConstructors (@expr1073743062 ) ;
375: }
376:
377: void explicitConstructors ( ) {
378: $checkExplicitConstructors_ $(@expr1073743063 "class Class {\n    Class() = delete;\n    Class(const Class& other) { }\n    Class(Class&& other) { }\n    explicit Class(int i) { }\n    explicit Class(const std::string&) { }\n    Class(int a, int b) { }\n};" $, "cppcheck-2.8/test/testclass.cpp" $, 378 $)
379:
|
384:
385: ;
386: $if $(@expr1073743064 $!@expr1073743065 $assertEquals $(@expr1073743066 "cppcheck-2.8/test/testclass.cpp" $, 386 $, "" $, errout@var100 .@expr1243 str (@expr1244 ) $) $) { $return ; }
387:
388: $checkExplicitConstructors_ $(@expr1073743069 "class Class {\n    Class() = delete;\n    explicit Class(const Class& other) { }\n    explicit Class(Class&& other) { }\n    virtual int i() = 0;\n};" $, "cppcheck-2.8/test/testclass.cpp" $, 388 $)
389:
|
392:
393: ;
394: $if $(@expr1073743070 $!@expr1073743071 $assertEquals $(@expr1073743072 "cppcheck-2.8/test/testclass.cpp" $, 394 $, "" $, errout@var100 .@expr1243 str (@expr1244 ) $) $) { $return ; }
395:
396: $checkExplicitConstructors_ $(@expr1073743075 "class Class {\n    Class() = delete;\n    Class(const Class& other) = delete;\n    Class(Class&& other) = delete;\n    virtual int i() = 0;\n};" $, "cppcheck-2.8/test/testclass.cpp" $, 396 $)
397:
|
400:
401: ;
402: $if $(@expr1073743076 $!@expr1073743077 $assertEquals $(@expr1073743078 "cppcheck-2.8/test/testclass.cpp" $, 402 $, "" $, errout@var100 .@expr1243 str (@expr1244 ) $) $) { $return ; }
403:
404: $checkExplicitConstructors_ $(@expr1073743081 "class Class {\n    Class(int i) { }\n};" $, "cppcheck-2.8/test/testclass.cpp" $, 404 $)
405:
406: ;
407: $if $(@expr1073743082 $!@expr1073743083 $assertEquals $(@expr1073743084 "cppcheck-2.8/test/testclass.cpp" $, 407 $, "[test.cpp:2]: (style) Class 'Class' has a constructor with 1 argument that is not explicit.\n" $, errout@var100 .@expr1243 str (@expr1244 ) $) $) { $return ; }
408:
409: $checkExplicitConstructors_ $(@expr1073743087 "class Class {\n    Class(const Class& other) { }\n    virtual int i() = 0;\n};" $, "cppcheck-2.8/test/testclass.cpp" $, 409 $)
410:
411:
412: ;
413: $if $(@expr1073743088 $!@expr1073743089 $assertEquals $(@expr1073743090 "cppcheck-2.8/test/testclass.cpp" $, 413 $, "" $, errout@var100 .@expr1243 str (@expr1244 ) $) $) { $return ; }
414:
415: $checkExplicitConstructors_ $(@expr1073743093 "class Class {\n    Class(Class&& other) { }\n    virtual int i() = 0;\n};" $, "cppcheck-2.8/test/testclass.cpp" $, 415 $)
416:
417:
418: ;
419: $if $(@expr1073743094 $!@expr1073743095 $assertEquals $(@expr1073743096 "cppcheck-2.8/test/testclass.cpp" $, 419 $, "" $, errout@var100 .@expr1243 str (@expr1244 ) $) $) { $return ; }
420:
421:
422: $checkExplicitConstructors_ $(@expr1073743099 "class Class {\n    private: Class(const Class&);\n    virtual int i() = 0;\n};" $, "cppcheck-2.8/test/testclass.cpp" $, 422 $)
423:
424:
425: ;
426: $if $(@expr1073743100 $!@expr1073743101 $assertEquals $(@expr1073743102 "cppcheck-2.8/test/testclass.cpp" $, 426 $, "" $, errout@var100 .@expr1243 str (@expr1244 ) $) $) { $return ; }
427:
428: $checkExplicitConstructors_ $(@expr1073743105 "class Class {\n    public: Class(const Class&);\n    virtual int i() = 0;\n};" $, "cppcheck-2.8/test/testclass.cpp" $, 428 $)
429:
430:
431: ;
432: $if $(@expr1073743106 $!@expr1073743107 $assertEquals $(@expr1073743108 "cppcheck-2.8/test/testclass.cpp" $, 432 $, "" $, errout@var100 .@expr1243 str (@expr1244 ) $) $) { $return ; }
433:
434:
435: $checkExplicitConstructors_ $(@expr1073743111 "template <class T> struct Test {\n  Test(int) : fData(0) {}\n  T fData;\n};\nint main() {\n  Test <int> test;\n  return 0;\n}" $, "cppcheck-2.8/test/testclass.cpp" $, 435 $)
436:
|
441:
442: ;
443: $if $(@expr1073743112 $!@expr1073743113 $assertEquals $(@expr1073743114 "cppcheck-2.8/test/testclass.cpp" $, 443 $, "[test.cpp:2]: (style) Struct 'Test < int >' has a constructor with 1 argument that is not explicit.\n" $, errout@var100 .@expr1243 str (@expr1244 ) $) $) { $return ; }
444:
445:
446: $checkExplicitConstructors_ $(@expr1073743117 "template <class T> struct Test {\n  Test() : fData(0) {}\n  Test (const Test<T>& aOther) : fData(aOther.fData) {}\n  Test (Test<T>&& aOther) : fData(std::move(aOther.fData)) {}\n  T fData;\n};\nint main() {\n  Test <int> test;\n  return 0;\n}" $, "cppcheck-2.8/test/testclass.cpp" $, 446 $)
447:
|
454:
455: ;
456: $if $(@expr1073743118 $!@expr1073743119 $assertEquals $(@expr1073743120 "cppcheck-2.8/test/testclass.cpp" $, 456 $, "" $, errout@var100 .@expr1243 str (@expr1244 ) $) $) { $return ; }
457:
458:
459: $checkExplicitConstructors_ $(@expr1073743123 "struct A { struct B; };\nstruct A::B {\n    B() = default;\n    B(const B&) {}\n};" $, "cppcheck-2.8/test/testclass.cpp" $, 459 $)
460:
461:
462:
463: ;
464: $if $(@expr1073743124 $!@expr1073743125 $assertEquals $(@expr1073743126 "cppcheck-2.8/test/testclass.cpp" $, 464 $, "" $, errout@var100 .@expr1243 str (@expr1244 ) $) $) { $return ; }
465:
466: $checkExplicitConstructors_ $(@expr1073743129 "struct A{    A(int, int y=2) {}};" $, "cppcheck-2.8/test/testclass.cpp" $, 466 $)
467:
468: ;
469: $if $(@expr1073743130 $!@expr1073743131 $assertEquals $(@expr1073743132 "cppcheck-2.8/test/testclass.cpp" $, 469 $, "[test.cpp:1]: (style) Struct 'A' has a constructor with 1 argument that is not explicit.\n" $, errout@var100 .@expr1243 str (@expr1244 ) $) $) { $return ; }
470:
471: $checkExplicitConstructors_ $(@expr1073743135 "struct Foo {\n    template <typename T>\n    explicit constexpr Foo(T) {}\n};\nstruct Bar {\n    template <typename T>\n    constexpr explicit Bar(T) {}\n};\nstruct Baz {\n    explicit constexpr Baz(int) {}\n};\n" $, "cppcheck-2.8/test/testclass.cpp" $, 471 $)
472:
|
480:
481: ;
482: $if $(@expr1073743136 $!@expr1073743137 $assertEquals $(@expr1073743138 "cppcheck-2.8/test/testclass.cpp" $, 482 $, "" $, errout@var100 .@expr1243 str (@expr1244 ) $) $) { $return ; }
483: }
484:
485:
486: void checkDuplInheritedMembers_ ( const char code@var124 [ ] , const char * file@var125 , int line@var126 ) {
487:
488: errout@var100 .@expr1073743141 str (@expr1073743142 "" ) ;
489:
490:
491: Tokenizer tokenizer@var127 (@expr1073743143 &@expr1320 settings1@var103 , this@expr1321 ) ;
492: std ::@expr1073743146 istringstream istr@var128 (@expr1073743147 code@var124 ) ;
493: $assert_ $(@expr1073743148 file@var125 $, line@var126 $, $(@expr1073743149 tokenizer@var127 .@expr1073743150 tokenize (@expr1073743151 istr@var128 , "test.cpp" ) $) $) ;
494:
495:
496: CheckClass checkClass@var129 (@expr1073743152 &@expr1073743153 tokenizer@var127 , &@expr1320 settings1@var103 , this@expr1321 ) ;
497: checkClass@var129 .@expr1073743155 checkDuplInheritedMembers (@expr1073743156 ) ;
498: }
499:
500: void duplInheritedMembers ( ) {
501: $checkDuplInheritedMembers_ $(@expr1073743157 "class Base {\n   int x;\n};\nstruct Derived : Base {\n   int x;\n};" $, "cppcheck-2.8/test/testclass.cpp" $, 501 $)
502:
|
505:
506: ;
507: $if $(@expr1073743158 $!@expr1073743159 $assertEquals $(@expr1073743160 "cppcheck-2.8/test/testclass.cpp" $, 507 $, "" $, errout@var100 .@expr1337 str (@expr1338 ) $) $) { $return ; }
508:
509: $checkDuplInheritedMembers_ $(@expr1073743163 "class Base {\n   protected:\n   int x;\n};\nstruct Derived : Base {\n   int x;\n};" $, "cppcheck-2.8/test/testclass.cpp" $, 509 $)
510:
|
514:
515: ;
516: $if $(@expr1073743164 $!@expr1073743165 $assertEquals $(@expr1073743166 "cppcheck-2.8/test/testclass.cpp" $, 516 $, "[test.cpp:3] -> [test.cpp:6]: (warning) The struct 'Derived' defines member variable with name 'x' also defined in its parent class 'Base'.\n" $, errout@var100 .@expr1337 str (@expr1338 ) $) $) { $return ; }
517:
518: $checkDuplInheritedMembers_ $(@expr1073743169 "class Base {\n   protected:\n   int x;\n};\nstruct Derived : public Base {\n   int x;\n};" $, "cppcheck-2.8/test/testclass.cpp" $, 518 $)
519:
|
523:
524: ;
525: $if $(@expr1073743170 $!@expr1073743171 $assertEquals $(@expr1073743172 "cppcheck-2.8/test/testclass.cpp" $, 525 $, "[test.cpp:3] -> [test.cpp:6]: (warning) The struct 'Derived' defines member variable with name 'x' also defined in its parent class 'Base'.\n" $, errout@var100 .@expr1337 str (@expr1338 ) $) $) { $return ; }
526:
527: $checkDuplInheritedMembers_ $(@expr1073743175 "class Base0 {\n   int x;\n};\nclass Base1 {\n   int x;\n};\nstruct Derived : Base0, Base1 {\n   int x;\n};" $, "cppcheck-2.8/test/testclass.cpp" $, 527 $)
528:
|
534:
535: ;
536: $if $(@expr1073743176 $!@expr1073743177 $assertEquals $(@expr1073743178 "cppcheck-2.8/test/testclass.cpp" $, 536 $, "" $, errout@var100 .@expr1337 str (@expr1338 ) $) $) { $return ; }
537:
538: $checkDuplInheritedMembers_ $(@expr1073743181 "class Base0 {\n   protected:\n   int x;\n};\nclass Base1 {\n   int x;\n};\nstruct Derived : Base0, Base1 {\n   int x;\n};" $, "cppcheck-2.8/test/testclass.cpp" $, 538 $)
539:
|
546:
547: ;
548: $if $(@expr1073743182 $!@expr1073743183 $assertEquals $(@expr1073743184 "cppcheck-2.8/test/testclass.cpp" $, 548 $, "[test.cpp:3] -> [test.cpp:9]: (warning) The struct 'Derived' defines member variable with name 'x' also defined in its parent class 'Base0'.\n" $, errout@var100 .@expr1337 str (@expr1338 ) $) $) { $return ; }
549:
550: $checkDuplInheritedMembers_ $(@expr1073743187 "class Base0 {\n   protected:\n   int x;\n};\nclass Base1 {\n   public:\n   int x;\n};\nstruct Derived : Base0, Base1 {\n   int x;\n};" $, "cppcheck-2.8/test/testclass.cpp" $, 550 $)
551:
|
559:
560: ;
561: $if $(@expr1073743188 $!@expr1073743189 $assertEquals $(@expr1073743190 "cppcheck-2.8/test/testclass.cpp" $, 561 $, "[test.cpp:3] -> [test.cpp:10]: (warning) The struct 'Derived' defines member variable with name 'x' also defined in its parent class 'Base0'.\n[test.cpp:7] -> [test.cpp:10]: (warning) The struct 'Derived' defines member variable with name 'x' also defined in its parent class 'Base1'.\n" $, errout@var100 .@expr1337 str (@expr1338 ) $) $) { $return
562: ; }
563:
564: $checkDuplInheritedMembers_ $(@expr1073743193 "class Base {\n   int x;\n};\nstruct Derived : Base {\n   int y;\n};" $, "cppcheck-2.8/test/testclass.cpp" $, 564 $)
565:
|
568:
569: ;
570: $if $(@expr1073743194 $!@expr1073743195 $assertEquals $(@expr1073743196 "cppcheck-2.8/test/testclass.cpp" $, 570 $, "" $, errout@var100 .@expr1337 str (@expr1338 ) $) $) { $return ; }
571:
572: $checkDuplInheritedMembers_ $(@expr1073743199 "class A {\n   int x;\n};\nstruct B {\n   int x;\n};" $, "cppcheck-2.8/test/testclass.cpp" $, 572 $)
573:
|
576:
577: ;
578: $if $(@expr1073743200 $!@expr1073743201 $assertEquals $(@expr1073743202 "cppcheck-2.8/test/testclass.cpp" $, 578 $, "" $, errout@var100 .@expr1337 str (@expr1338 ) $) $) { $return ; }
579:
580:
581: $checkDuplInheritedMembers_ $(@expr1073743205 "class Derived : public UnknownBase {\n  int x;\n};" $, "cppcheck-2.8/test/testclass.cpp" $, 581 $)
582:
583: ;
584: $if $(@expr1073743206 $!@expr1073743207 $assertEquals $(@expr1073743208 "cppcheck-2.8/test/testclass.cpp" $, 584 $, "" $, errout@var100 .@expr1337 str (@expr1338 ) $) $) { $return ; }
585:
586: $checkDuplInheritedMembers_ $(@expr1073743211 "class Base {\n   int x;\n};\nclass Derived : public Base {\n};" $, "cppcheck-2.8/test/testclass.cpp" $, 586 $)
587:
588:
589:
590: ;
591: $if $(@expr1073743212 $!@expr1073743213 $assertEquals $(@expr1073743214 "cppcheck-2.8/test/testclass.cpp" $, 591 $, "" $, errout@var100 .@expr1337 str (@expr1338 ) $) $) { $return ; }
592:
593:
594: $checkDuplInheritedMembers_ $(@expr1073743217 "namespace test1 {\n   struct SWibble{};\n   typedef SWibble wibble;\n}\nnamespace test2 {\n   struct SWibble : public test1::wibble {\n   int Value;\n   };\n}" $, "cppcheck-2.8/test/testclass.cpp" $, 594 $)
595:
|
601:
602: ;
603: $if $(@expr1073743218 $!@expr1073743219 $assertEquals $(@expr1073743220 "cppcheck-2.8/test/testclass.cpp" $, 603 $, "" $, errout@var100 .@expr1337 str (@expr1338 ) $) $) { $return ; }
604:
605:
606: $checkDuplInheritedMembers_ $(@expr1073743223 "class Base {\n    public:\n        int i;\n};\nclass Derived1: public Base {\n    public:\n        int j;\n};\nclass Derived2 : public Derived1 {\n    int i;\n};" $, "cppcheck-2.8/test/testclass.cpp" $, 606 $)
607:
|
615:
616: ;
617: $if $(@expr1073743224 $!@expr1073743225 $assertEquals $(@expr1073743226 "cppcheck-2.8/test/testclass.cpp" $, 617 $, "[test.cpp:3] -> [test.cpp:10]: (warning) The class 'Derived2' defines member variable with name 'i' also defined in its parent class 'Base'.\n" $, errout@var100 .@expr1337 str (@expr1338 ) $) $) { $return ; }
618:
619:
620: $checkDuplInheritedMembers_ $(@expr1073743229 "template<size_t N>\nstruct BitInt : public BitInt<N+1> { };" $, "cppcheck-2.8/test/testclass.cpp" $, 620 $)
621: ;
622: $if $(@expr1073743230 $!@expr1073743231 $assertEquals $(@expr1073743232 "cppcheck-2.8/test/testclass.cpp" $, 622 $, "" $, errout@var100 .@expr1337 str (@expr1338 ) $) $) { $return ; }
623:
624:
625: $checkDuplInheritedMembers_ $(@expr1073743235 "namespace _impl {\n    template <typename AlwaysVoid, typename>\n    struct fn_traits;\n}\ntemplate <typename T>\nstruct function_traits\n    : public _impl::fn_traits<void, std::remove_reference_t<T>> {};\nnamespace _impl {\n    template <typename T>\n    struct fn_traits<decltype(void(&T::operator())), T>\n        : public fn_traits<void, decltype(&T::operator())> {};\n}" $, "cppcheck-2.8/test/testclass.cpp" $, 625 $)
626:
|
635:
636: ;
637: $if $(@expr1073743236 $!@expr1073743237 $assertEquals $(@expr1073743238 "cppcheck-2.8/test/testclass.cpp" $, 637 $, "" $, errout@var100 .@expr1337 str (@expr1338 ) $) $) { $return ; }
638: }
639:
640:
641: void checkCopyConstructor_ ( const char code@var130 [ ] , const char * file@var131 , int line@var132 ) {
642:
643: errout@var100 .@expr1073743241 str (@expr1073743242 "" ) ;
644:
645:
646: Tokenizer tokenizer@var133 (@expr1073743243 &@expr1420 settings0@var102 , this@expr1421 ) ;
647: std ::@expr1073743246 istringstream istr@var134 (@expr1073743247 code@var130 ) ;
648: $assert_ $(@expr1073743248 file@var131 $, line@var132 $, $(@expr1073743249 tokenizer@var133 .@expr1073743250 tokenize (@expr1073743251 istr@var134 , "test.cpp" ) $) $) ;
649:
650:
651: CheckClass checkClass@var135 (@expr1073743252 &@expr1073743253 tokenizer@var133 , &@expr1420 settings0@var102 , this@expr1421 ) ;
652: checkClass@var135 .@expr1073743255 copyconstructors (@expr1073743256 ) ;
653: }
654:
655: void copyConstructor1 ( ) {
656: $checkCopyConstructor_ $(@expr1073743257 "class F\n{\n   public:\n   char *c,*p,*d;\n   F(const F &f) : p(f.p), c(f.c)\n   {\n      p=(char *)malloc(strlen(f.p)+1);\n      strcpy(p,f.p);\n   }\n   F(char *str)\n   {\n      p=(char *)malloc(strlen(str)+1);\n      strcpy(p,str);\n   }\n   F&operator=(const F&);\n   ~F();\n};" $, "cppcheck-2.8/test/testclass.cpp" $, 656 $)
657:
|
671:
672: ;
673: $todoAssertEquals $(@expr1073743258 "cppcheck-2.8/test/testclass.cpp" $, 673 $, "[test.cpp:5]: (warning) Value of pointer 'p', which points to allocated memory, is copied in copy constructor instead of allocating new memory.\n" $, "" $, errout@var100 .@expr1435 str (@expr1436 ) $) ;
674:
675: $checkCopyConstructor_ $(@expr1073743261 "class F {\n   char *p;\n   F(const F &f) {\n      p = f.p;\n   }\n   F(char *str) {\n      p = malloc(strlen(str)+1);\n   }\n   ~F();\n   F& operator=(const F&f);\n};" $, "cppcheck-2.8/test/testclass.cpp" $, 675 $)
676:
|
684:
685: ;
686: $todoAssertEquals $(@expr1073743262 "cppcheck-2.8/test/testclass.cpp" $, 686 $, "[test.cpp:4]: (warning) Value of pointer 'p', which points to allocated memory, is copied in copy constructor instead of allocating new memory.\n[test.cpp:3] -> [test.cpp:7]: (warning) Copy constructor does not allocate memory for member 'p' although memory has been allocated in other constructors.\n" $, "[test.cpp:4]: (warning) Value of pointer 'p', which points to allocated memory, is copied in copy constructor instead of allocating new memory.\n" $, errout@var100 .@expr1435 str (@expr1436 ) $)
687:
688:
689: ;
690:
691: $checkCopyConstructor_ $(@expr1073743265 "class F\n{\n   public:\n   char *c,*p,*d;\n   F(const F &f) :p(f.p)\n   {\n   }\n   F(char *str)\n   {\n      p=(char *)malloc(strlen(str)+1);\n      strcpy(p,str);\n   }\n   ~F();\n   F& operator=(const F&f);\n};" $, "cppcheck-2.8/test/testclass.cpp" $, 691 $)
692:
|
704:
705: ;
706: $todoAssertEquals $(@expr1073743266 "cppcheck-2.8/test/testclass.cpp" $, 706 $, "[test.cpp:5]: (warning) Value of pointer 'p', which points to allocated memory, is copied in copy constructor instead of allocating new memory.\n[test.cpp:5] -> [test.cpp:10]: (warning) Copy constructor does not allocate memory for member 'p' although memory has been allocated in other constructors.\n" $, "" $, errout@var100 .@expr1435 str (@expr1436 ) $)
707:
708:
709: ;
710:
711: $checkCopyConstructor_ $(@expr1073743269 "class kalci\n{\n   public:\n   char *c,*p,*d;\n   kalci()\n   {\n      p=(char *)malloc(100);\n      strcpy(p,\"hello\");\n      c=(char *)malloc(100);\n      strcpy(p,\"hello\");\n      d=(char *)malloc(100);\n      strcpy(p,\"hello\");\n   }\n   kalci(const kalci &f)\n   {\n      p=(char *)malloc(strlen(str)+1);\n      strcpy(p,f.p);\n      c=(char *)malloc(strlen(str)+1);\n      strcpy(p,f.p);\n      d=(char *)malloc(strlen(str)+1);\n      strcpy(p,f.p);\n   }\n   ~kalci();\n   kalci& operator=(const kalci&kalci);\n};" $, "cppcheck-2.8/test/testclass.cpp" $, 711 $)
712:
|
734:
735: ;
736: $if $(@expr1073743270 $!@expr1073743271 $assertEquals $(@expr1073743272 "cppcheck-2.8/test/testclass.cpp" $, 736 $, "" $, errout@var100 .@expr1435 str (@expr1436 ) $) $) { $return ; }
737:
738: $checkCopyConstructor_ $(@expr1073743275 "class F\n{\n   public:\n   char *c,*p,*d;\n   F(char *str,char *st,char *string)\n   {\n      p=(char *)malloc(100);\n      strcpy(p,str);\n      c=(char *)malloc(100);\n      strcpy(p,st);\n      d=(char *)malloc(100);\n      strcpy(p,string);\n   }\n   F(const F &f)\n   {\n      p=(char *)malloc(strlen(str)+1);\n      strcpy(p,f.p);\n      c=(char *)malloc(strlen(str)+1);\n      strcpy(p,f.p);\n   }\n   ~F();\n   F& operator=(const F&f);\n};" $, "cppcheck-2.8/test/testclass.cpp" $, 738 $)
739:
|
759:
760: ;
761: $todoAssertEquals $(@expr1073743276 "cppcheck-2.8/test/testclass.cpp" $, 761 $, "[test.cpp:14] -> [test.cpp:11]: (warning) Copy constructor does not allocate memory for member 'd' although memory has been allocated in other constructors.\n" $, "" $, errout@var100 .@expr1435 str (@expr1436 ) $) ;
762:
763: $checkCopyConstructor_ $(@expr1073743279 "class F {\n   char *c;\n   F(char *str,char *st,char *string) {\n      p=(char *)malloc(100);\n   }\n   F(const F &f)\n      : p(malloc(size))\n   {\n   }\n   ~F();\n   F& operator=(const F&f);\n};" $, "cppcheck-2.8/test/testclass.cpp" $, 763 $)
764:
|
773:
774: ;
775: $if $(@expr1073743280 $!@expr1073743281 $assertEquals $(@expr1073743282 "cppcheck-2.8/test/testclass.cpp" $, 775 $, "" $, errout@var100 .@expr1435 str (@expr1436 ) $) $) { $return ; }
776:
777: $checkCopyConstructor_ $(@expr1073743285 "class F {\n   char *c;\n   F(char *str,char *st,char *string)\n      : p(malloc(size))\n   {\n   }\n   F(const F &f)\n   {\n   }\n   ~F();\n   F& operator=(const F&f);\n};" $, "cppcheck-2.8/test/testclass.cpp" $, 777 $)
778:
|
787:
788: ;
789: $todoAssertEquals $(@expr1073743286 "cppcheck-2.8/test/testclass.cpp" $, 789 $, "[test.cpp:7] -> [test.cpp:4]: (warning) Copy constructor does not allocate memory for member 'd' although memory has been allocated in other constructors.\n" $, "" $, errout@var100 .@expr1435 str (@expr1436 ) $) ;
790:
791: $checkCopyConstructor_ $(@expr1073743289 "class F\n{\n   public:\n   char *c,*p,*d;\n   F()\n   {\n      p=(char *)malloc(100);\n      c=(char *)malloc(100);\n      d=(char*)malloc(100);\n   }\n   ~F();\n   F& operator=(const F&f);\n};" $, "cppcheck-2.8/test/testclass.cpp" $, 791 $)
792:
|
802:
803: ;
804: $todoAssertEquals $(@expr1073743290 "cppcheck-2.8/test/testclass.cpp" $, 804 $, "[test.cpp:8]: (warning) Class 'F' does not have a copy constructor which is recommended since it has dynamic memory/resource allocation(s).\n" $, "" $, errout@var100 .@expr1435 str (@expr1436 ) $) ;
805:
806: $checkCopyConstructor_ $(@expr1073743293 "class F\n{\n   public:\n   char *c;\n   const char *p,*d;\n   F(char *str,char *st,char *string)\n   {\n      p=str;\n      d=st;\n      c=(char *)malloc(strlen(string)+1);\n      strcpy(d,string);\n   }\n   F(const F &f)\n   {\n      p=f.p;\n      d=f.d;\n      c=(char *)malloc(strlen(str)+1);\n      strcpy(d,f.p);\n   }\n   ~F();\n   F& operator=(const F&f);\n};" $, "cppcheck-2.8/test/testclass.cpp" $, 806 $)
807:
|
826:
827: ;
828: $if $(@expr1073743294 $!@expr1073743295 $assertEquals $(@expr1073743296 "cppcheck-2.8/test/testclass.cpp" $, 828 $, "" $, errout@var100 .@expr1435 str (@expr1436 ) $) $) { $return ; }
829:
830: $checkCopyConstructor_ $(@expr1073743299 "class F : E\n{\n   char *p;\n   F() {\n      p = malloc(100);\n   }\n   ~F();\n   F& operator=(const F&f);\n};" $, "cppcheck-2.8/test/testclass.cpp" $, 830 $)
831:
|
837:
838: ;
839: $if $(@expr1073743300 $!@expr1073743301 $assertEquals $(@expr1073743302 "cppcheck-2.8/test/testclass.cpp" $, 839 $, "" $, errout@var100 .@expr1435 str (@expr1436 ) $) $) { $return ; }
840:
841: $checkCopyConstructor_ $(@expr1073743305 "class E { E(E&); };\nclass F : E\n{\n   char *p;\n   F() {\n      p = malloc(100);\n   }\n   ~F();\n   F& operator=(const F&f);\n};" $, "cppcheck-2.8/test/testclass.cpp" $, 841 $)
842:
|
849:
850: ;
851: $if $(@expr1073743306 $!@expr1073743307 $assertEquals $(@expr1073743308 "cppcheck-2.8/test/testclass.cpp" $, 851 $, "" $, errout@var100 .@expr1435 str (@expr1436 ) $) $) { $return ; }
852:
853: $checkCopyConstructor_ $(@expr1073743311 "class E {};\nclass F : E {\n   char *p;\n   F() {\n      p = malloc(100);\n   }\n   ~F();\n   F& operator=(const F&f);\n};" $, "cppcheck-2.8/test/testclass.cpp" $, 853 $)
854:
|
860:
861: ;
862: $if $(@expr1073743312 $!@expr1073743313 $assertEquals $(@expr1073743314 "cppcheck-2.8/test/testclass.cpp" $, 862 $, "[test.cpp:5]: (warning) Class 'F' does not have a copy constructor which is recommended since it has dynamic memory/resource allocation(s).\n" $, errout@var100 .@expr1435 str (@expr1436 ) $) $) { $return ; }
863:
864: $checkCopyConstructor_ $(@expr1073743317 "class F {\n   char *p;\n   F() {\n      p = malloc(100);\n   }\n   F(F& f);\n   ~F();\n   F& operator=(const F&f);\n};" $, "cppcheck-2.8/test/testclass.cpp" $, 864 $)
865:
|
871:
872: ;
873: $if $(@expr1073743318 $!@expr1073743319 $assertEquals $(@expr1073743320 "cppcheck-2.8/test/testclass.cpp" $, 873 $, "" $, errout@var100 .@expr1435 str (@expr1436 ) $) $) { $return ; }
874:
875: $checkCopyConstructor_ $(@expr1073743323 "class F {\n   char *p;\n   F() : p(malloc(100)) {}\n   ~F();\n   F& operator=(const F&f);\n};" $, "cppcheck-2.8/test/testclass.cpp" $, 875 $)
876:
|
879:
880: ;
881: $if $(@expr1073743324 $!@expr1073743325 $assertEquals $(@expr1073743326 "cppcheck-2.8/test/testclass.cpp" $, 881 $, "[test.cpp:3]: (warning) Class 'F' does not have a copy constructor which is recommended since it has dynamic memory/resource allocation(s).\n" $, errout@var100 .@expr1435 str (@expr1436 ) $) $) { $return ; }
882:
883:
884: $checkCopyConstructor_ $(@expr1073743329 "struct F {\n   static char* c;\n   F() {\n      p = malloc(100);\n   }\n};" $, "cppcheck-2.8/test/testclass.cpp" $, 884 $)
885:
|
888:
889: ;
890: $if $(@expr1073743330 $!@expr1073743331 $assertEquals $(@expr1073743332 "cppcheck-2.8/test/testclass.cpp" $, 890 $, "" $, errout@var100 .@expr1435 str (@expr1436 ) $) $) { $return ; }
891: }
892:
893: void copyConstructor2 ( ) {
894: $checkCopyConstructor_ $(@expr1073743335 "template <class _Tp>\nclass Vector\n{\npublic:\n    Vector() {\n        _M_finish = new _Tp[ 42 ];\n    }\n    Vector( const Vector<_Tp>& v ) {\n    }\n     ~Vector();\n     Vector& operator=(const Vector&v);\n    _Tp* _M_finish;\n};" $, "cppcheck-2.8/test/testclass.cpp" $, 894 $)
895:
|
905:
906: ;
907: $if $(@expr1073743336 $!@expr1073743337 $assertEquals $(@expr1073743338 "cppcheck-2.8/test/testclass.cpp" $, 907 $, "" $, errout@var100 .@expr1073743339 str (@expr1073743340 ) $) $) { $return ; }
908: }
909:
910: void copyConstructor3 ( ) {
911: $checkCopyConstructor_ $(@expr1073743341 "struct F {\n   char* c;\n   F() { c = malloc(100); }\n   F(const F &f) = delete;\n   F&operator=(const F &f);\n   ~F();\n};" $, "cppcheck-2.8/test/testclass.cpp" $, 911 $)
912:
|
916:
917: ;
918: $if $(@expr1073743342 $!@expr1073743343 $assertEquals $(@expr1073743344 "cppcheck-2.8/test/testclass.cpp" $, 918 $, "" $, errout@var100 .@expr1521 str (@expr1522 ) $) $) { $return ; }
919:
920: $checkCopyConstructor_ $(@expr1073743347 "struct F {\n   char* c;\n   F() { c = malloc(100); }\n   F(const F &f) = default;\n   F&operator=(const F &f);\n   ~F();\n};" $, "cppcheck-2.8/test/testclass.cpp" $, 920 $)
921:
|
925:
926: ;
927: $if $(@expr1073743348 $!@expr1073743349 $assertEquals $(@expr1073743350 "cppcheck-2.8/test/testclass.cpp" $, 927 $, "[test.cpp:3]: (warning) Struct 'F' has dynamic memory/resource allocation(s). The copy constructor is explicitly defaulted but the default copy constructor does not work well. It is recommended to define or delete the copy constructor.\n" $, errout@var100 .@expr1521 str (@expr1522 ) $) $) { $return ; }
928: }
929:
930: void copyConstructor4 ( ) {
931: $checkCopyConstructor_ $(@expr1073743353 "class noncopyable {\nprotected:\n    noncopyable() {}\n    ~noncopyable() {}\n\nprivate:\n    noncopyable( const noncopyable& );\n    const noncopyable& operator=( const noncopyable& );\n};\n\nclass Base : private noncopyable {};\n\nclass Foo : public Base {\npublic:\n    Foo() : m_ptr(new int) {}\n    ~Foo() { delete m_ptr; }\nprivate:\n    int* m_ptr;\n};" $, "cppcheck-2.8/test/testclass.cpp" $, 931 $)
932:
|
948:
949: ;
950: $if $(@expr1073743354 $!@expr1073743355 $assertEquals $(@expr1073743356 "cppcheck-2.8/test/testclass.cpp" $, 950 $, "" $, errout@var100 .@expr1073743357 str (@expr1073743358 ) $) $) { $return ; }
951: }
952:
953: void copyConstructor5 ( ) {
954: $checkCopyConstructor_ $(@expr1073743359 "class Copyable {};\n\nclass Foo : public Copyable, public UnknownType {\npublic:\n    Foo() : m_ptr(new int) {}\n    ~Foo() { delete m_ptr; }\nprivate:\n    int* m_ptr;\n};" $, "cppcheck-2.8/test/testclass.cpp" $, 954 $)
955:
|
961:
962: ;
963: $if $(@expr1073743360 $!@expr1073743361 $assertEquals $(@expr1073743362 "cppcheck-2.8/test/testclass.cpp" $, 963 $, "" $, errout@var100 .@expr1539 str (@expr1540 ) $) $) { $return ; }
964:
965: $checkCopyConstructor_ $(@expr1073743365 "class Copyable {};\n\nclass Foo : public UnknownType, public Copyable {\npublic:\n    Foo() : m_ptr(new int) {}\n    ~Foo() { delete m_ptr; }\nprivate:\n    int* m_ptr;\n};" $, "cppcheck-2.8/test/testclass.cpp" $, 965 $)
966:
|
972:
973: ;
974: $if $(@expr1073743366 $!@expr1073743367 $assertEquals $(@expr1073743368 "cppcheck-2.8/test/testclass.cpp" $, 974 $, "" $, errout@var100 .@expr1539 str (@expr1540 ) $) $) { $return ; }
975: }
976:
977: void copyConstructor6 ( ) {
978: $checkCopyConstructor_ $(@expr1073743371 "struct S {\n    S() {\n        for (int i = 0; i < 5; i++)\n            a[i] = new char[3];\n    }\n    char* a[5];\n};\n" $, "cppcheck-2.8/test/testclass.cpp" $, 978 $)
979:
|
983:
984: ;
985: $todoAssertEquals $(@expr1073743372 "cppcheck-2.8/test/testclass.cpp" $, 985 $, "[test.cpp:4]: (warning) Struct 'S' does not have a copy constructor which is recommended since it has dynamic memory/resource allocation(s).\n[test.cpp:4]: (warning) Struct 'S' does not have a operator= which is recommended since it has dynamic memory/resource allocation(s).\n[test.cpp:4]: (warning) Struct 'S' does not have a destructor which is recommended since it has dynamic memory/resource allocation(s).\n" $, "" $, errout@var100 .@expr1073743373 str (@expr1073743374 ) $)
986:
987:
988:
989: ;
990: }
991:
992: void noOperatorEq ( ) {
993: $checkCopyConstructor_ $(@expr1073743375 "struct F {\n   char* c;\n   F() { c = malloc(100); }\n   F(const F &f);\n   ~F();\n};" $, "cppcheck-2.8/test/testclass.cpp" $, 993 $)
994:
|
997:
998: ;
999: $if $(@expr1073743376 $!@expr1073743377 $assertEquals $(@expr1073743378 "cppcheck-2.8/test/testclass.cpp" $, 999 $, "[test.cpp:3]: (warning) Struct 'F' does not have a operator= which is recommended since it has dynamic memory/resource allocation(s).\n" $, errout@var100 .@expr1555 str (@expr1556 ) $) $) { $return ; }
1000:
1001:
1002: $checkCopyConstructor_ $(@expr1073743381 "struct F {\n   char* c;\n   F() { c = malloc(100); }\n   F(const F &f);\n   F &operator=(const F &f) = default;\n   ~F();\n};" $, "cppcheck-2.8/test/testclass.cpp" $, 1002 $)
1003:
|
1007:
1008: ;
1009: $if $(@expr1073743382 $!@expr1073743383 $assertEquals $(@expr1073743384 "cppcheck-2.8/test/testclass.cpp" $, 1009 $, "[test.cpp:3]: (warning) Struct 'F' has dynamic memory/resource allocation(s). The operator= is explicitly defaulted but the default operator= does not work well. It is recommended to define or delete the operator=.\n" $, errout@var100 .@expr1555 str (@expr1556 ) $) $) { $return ; }
1010:
1011:
1012: $checkCopyConstructor_ $(@expr1073743387 "struct F {\n   char* c;\n   F() { c = malloc(100); }\n   F(const F &f);\n   F &operator=(const F &f) = delete;\n   ~F();\n};" $, "cppcheck-2.8/test/testclass.cpp" $, 1012 $)
1013:
|
1017:
1018: ;
1019: $if $(@expr1073743388 $!@expr1073743389 $assertEquals $(@expr1073743390 "cppcheck-2.8/test/testclass.cpp" $, 1019 $, "" $, errout@var100 .@expr1555 str (@expr1556 ) $) $) { $return ; }
1020:
1021:
1022: $checkCopyConstructor_ $(@expr1073743393 "struct F : NonCopyable {\n   char* c;\n   F() { c = malloc(100); }\n   F(const F &f);\n   ~F();\n};" $, "cppcheck-2.8/test/testclass.cpp" $, 1022 $)
1023:
|
1026:
1027: ;
1028: $if $(@expr1073743394 $!@expr1073743395 $assertEquals $(@expr1073743396 "cppcheck-2.8/test/testclass.cpp" $, 1028 $, "" $, errout@var100 .@expr1555 str (@expr1556 ) $) $) { $return ; }
1029: }
1030:
1031: void noDestructor ( ) {
1032: $checkCopyConstructor_ $(@expr1073743399 "struct F {\n   char* c;\n   F() { c = malloc(100); }\n   F(const F &f);\n   F&operator=(const F&);};" $, "cppcheck-2.8/test/testclass.cpp" $, 1032 $)
1033:
|
1036:
1037: ;
1038: $if $(@expr1073743400 $!@expr1073743401 $assertEquals $(@expr1073743402 "cppcheck-2.8/test/testclass.cpp" $, 1038 $, "[test.cpp:3]: (warning) Struct 'F' does not have a destructor which is recommended since it has dynamic memory/resource allocation(s).\n" $, errout@var100 .@expr1579 str (@expr1580 ) $) $) { $return ; }
1039:
1040: $checkCopyConstructor_ $(@expr1073743405 "struct F {\n   C* c;\n   F() { c = new C; }\n   F(const F &f);\n   F&operator=(const F&);};" $, "cppcheck-2.8/test/testclass.cpp" $, 1040 $)
1041:
|
1044:
1045: ;
1046: $if $(@expr1073743406 $!@expr1073743407 $assertEquals $(@expr1073743408 "cppcheck-2.8/test/testclass.cpp" $, 1046 $, "" $, errout@var100 .@expr1579 str (@expr1580 ) $) $) { $return ; }
1047:
1048: $checkCopyConstructor_ $(@expr1073743411 "struct F {\n   int* i;\n   F() { i = new int(); }\n   F(const F &f);\n   F& operator=(const F&);};" $, "cppcheck-2.8/test/testclass.cpp" $, 1048 $)
1049:
|
1052:
1053: ;
1054: $if $(@expr1073743412 $!@expr1073743413 $assertEquals $(@expr1073743414 "cppcheck-2.8/test/testclass.cpp" $, 1054 $, "[test.cpp:3]: (warning) Struct 'F' does not have a destructor which is recommended since it has dynamic memory/resource allocation(s).\n" $, errout@var100 .@expr1579 str (@expr1580 ) $) $) { $return ; }
1055:
1056: $checkCopyConstructor_ $(@expr1073743417 "struct Data { int x; int y; };\nstruct F {\n   Data* c;\n   F() { c = new Data; }\n   F(const F &f);\n   F&operator=(const F&);};" $, "cppcheck-2.8/test/testclass.cpp" $, 1056 $)
1057:
|
1061:
1062: ;
1063: $if $(@expr1073743418 $!@expr1073743419 $assertEquals $(@expr1073743420 "cppcheck-2.8/test/testclass.cpp" $, 1063 $, "[test.cpp:4]: (warning) Struct 'F' does not have a destructor which is recommended since it has dynamic memory/resource allocation(s).\n" $, errout@var100 .@expr1579 str (@expr1580 ) $) $) { $return ; }
1064:
1065:
1066: $checkCopyConstructor_ $(@expr1073743423 "struct F {\n   char* c;\n   F() { c = malloc(100); }\n   F(const F &f);\n   F &operator=(const F &f);\n   ~F() = default;\n};" $, "cppcheck-2.8/test/testclass.cpp" $, 1066 $)
1067:
|
1071:
1072: ;
1073: $if $(@expr1073743424 $!@expr1073743425 $assertEquals $(@expr1073743426 "cppcheck-2.8/test/testclass.cpp" $, 1073 $, "[test.cpp:3]: (warning) Struct 'F' has dynamic memory/resource allocation(s). The destructor is explicitly defaulted but the default destructor does not work well. It is recommended to define the destructor.\n" $, errout@var100 .@expr1579 str (@expr1580 ) $) $) { $return ; }
1074:
1075:
1076: $checkCopyConstructor_ $(@expr1073743429 "struct F {\n   char* c;\n   F() { c = malloc(100); }\n   F(const F &f);\n   F &operator=(const F &f);\n   ~F() = delete;\n};" $, "cppcheck-2.8/test/testclass.cpp" $, 1076 $)
1077:
|
1081:
1082: ;
1083: $if $(@expr1073743430 $!@expr1073743431 $assertEquals $(@expr1073743432 "cppcheck-2.8/test/testclass.cpp" $, 1083 $, "" $, errout@var100 .@expr1579 str (@expr1580 ) $) $) { $return ; }
1084: }
1085:
1086:
1087:
1088: void checkOpertorEqRetRefThis_ ( const char code@var136 [ ] , const char * file@var137 , int line@var138 ) {
1089:
1090: errout@var100 .@expr1073743435 str (@expr1073743436 "" ) ;
1091:
1092:
1093: Tokenizer tokenizer@var139 (@expr1073743437 &@expr1614 settings0@var102 , this@expr1615 ) ;
1094: std ::@expr1073743440 istringstream istr@var140 (@expr1073743441 code@var136 ) ;
1095: $assert_ $(@expr1073743442 file@var137 $, line@var138 $, $(@expr1073743443 tokenizer@var139 .@expr1073743444 tokenize (@expr1073743445 istr@var140 , "test.cpp" ) $) $) ;
1096:
1097:
1098: CheckClass checkClass@var141 (@expr1073743446 &@expr1073743447 tokenizer@var139 , &@expr1614 settings0@var102 , this@expr1615 ) ;
1099: checkClass@var141 .@expr1073743449 operatorEqRetRefThis (@expr1073743450 ) ;
1100: }
1101:
1102: void operatorEqRetRefThis1 ( ) {
1103: $checkOpertorEqRetRefThis_ $(@expr1073743451 "class A\n{\npublic:\n    A & operator=(const A &a) { return *this; }\n};" $, "cppcheck-2.8/test/testclass.cpp" $, 1103 $)
1104:
|
1107:
1108: ;
1109: $if $(@expr1073743452 $!@expr1073743453 $assertEquals $(@expr1073743454 "cppcheck-2.8/test/testclass.cpp" $, 1109 $, "" $, errout@var100 .@expr1631 str (@expr1632 ) $) $) { $return ; }
1110:
1111: $checkOpertorEqRetRefThis_ $(@expr1073743457 "class A\n{\npublic:\n    A & operator=(const A &a) { return a; }\n};" $, "cppcheck-2.8/test/testclass.cpp" $, 1111 $)
1112:
|
1115:
1116: ;
1117: $if $(@expr1073743458 $!@expr1073743459 $assertEquals $(@expr1073743460 "cppcheck-2.8/test/testclass.cpp" $, 1117 $, "[test.cpp:4]: (style) 'operator=' should return reference to 'this' instance.\n" $, errout@var100 .@expr1631 str (@expr1632 ) $) $) { $return ; }
1118:
1119: $checkOpertorEqRetRefThis_ $(@expr1073743463 "class A\n{\npublic:\n    A & operator=(const A &);\n};\nA & A::operator=(const A &a) { return *this; }" $, "cppcheck-2.8/test/testclass.cpp" $, 1119 $)
1120:
|
1124:
1125: ;
1126: $if $(@expr1073743464 $!@expr1073743465 $assertEquals $(@expr1073743466 "cppcheck-2.8/test/testclass.cpp" $, 1126 $, "" $, errout@var100 .@expr1631 str (@expr1632 ) $) $) { $return ; }
1127:
1128: $checkOpertorEqRetRefThis_ $(@expr1073743469 "class A\n{\npublic:\n    A & operator=(const A &a);\n};\nA & A::operator=(const A &a) { return *this; }" $, "cppcheck-2.8/test/testclass.cpp" $, 1128 $)
1129:
|
1133:
1134: ;
1135: $if $(@expr1073743470 $!@expr1073743471 $assertEquals $(@expr1073743472 "cppcheck-2.8/test/testclass.cpp" $, 1135 $, "" $, errout@var100 .@expr1631 str (@expr1632 ) $) $) { $return ; }
1136:
1137: $checkOpertorEqRetRefThis_ $(@expr1073743475 "class A\n{\npublic:\n    A & operator=(const A &);\n};\nA & A::operator=(const A &a) { return a; }" $, "cppcheck-2.8/test/testclass.cpp" $, 1137 $)
1138:
|
1142:
1143: ;
1144: $if $(@expr1073743476 $!@expr1073743477 $assertEquals $(@expr1073743478 "cppcheck-2.8/test/testclass.cpp" $, 1144 $, "[test.cpp:6]: (style) 'operator=' should return reference to 'this' instance.\n" $, errout@var100 .@expr1631 str (@expr1632 ) $) $) { $return ; }
1145:
1146: $checkOpertorEqRetRefThis_ $(@expr1073743481 "class A\n{\npublic:\n    A & operator=(const A &a);\n};\nA & A::operator=(const A &a) { return a; }" $, "cppcheck-2.8/test/testclass.cpp" $, 1146 $)
1147:
|
1151:
1152: ;
1153: $if $(@expr1073743482 $!@expr1073743483 $assertEquals $(@expr1073743484 "cppcheck-2.8/test/testclass.cpp" $, 1153 $, "[test.cpp:6]: (style) 'operator=' should return reference to 'this' instance.\n" $, errout@var100 .@expr1631 str (@expr1632 ) $) $) { $return ; }
1154:
1155: $checkOpertorEqRetRefThis_ $(@expr1073743487 "class A\n{\npublic:\n    class B\n    {\n    public:\n        B & operator=(const B &b) { return *this; }\n    };\n};" $, "cppcheck-2.8/test/testclass.cpp" $, 1155 $)
1156:
|
1163:
1164: ;
1165: $if $(@expr1073743488 $!@expr1073743489 $assertEquals $(@expr1073743490 "cppcheck-2.8/test/testclass.cpp" $, 1165 $, "" $, errout@var100 .@expr1631 str (@expr1632 ) $) $) { $return ; }
1166:
1167: $checkOpertorEqRetRefThis_ $(@expr1073743493 "class A\n{\npublic:\n    class B\n    {\n    public:\n        B & operator=(const B &b) { return b; }\n    };\n};" $, "cppcheck-2.8/test/testclass.cpp" $, 1167 $)
1168:
|
1175:
1176: ;
1177: $if $(@expr1073743494 $!@expr1073743495 $assertEquals $(@expr1073743496 "cppcheck-2.8/test/testclass.cpp" $, 1177 $, "[test.cpp:7]: (style) 'operator=' should return reference to 'this' instance.\n" $, errout@var100 .@expr1631 str (@expr1632 ) $) $) { $return ; }
1178:
1179: $checkOpertorEqRetRefThis_ $(@expr1073743499 "class A\n{\npublic:\n    class B\n    {\n    public:\n        B & operator=(const B &);\n    };\n};\nA::B & A::B::operator=(const A::B &b) { return *this; }" $, "cppcheck-2.8/test/testclass.cpp" $, 1179 $)
1180:
|
1188:
1189: ;
1190: $if $(@expr1073743500 $!@expr1073743501 $assertEquals $(@expr1073743502 "cppcheck-2.8/test/testclass.cpp" $, 1190 $, "" $, errout@var100 .@expr1631 str (@expr1632 ) $) $) { $return ; }
1191:
1192: $checkOpertorEqRetRefThis_ $(@expr1073743505 "class A\n{\npublic:\n    class B\n    {\n    public:\n        B & operator=(const B &);\n    };\n};\nA::B & A::B::operator=(const A::B &b) { return b; }" $, "cppcheck-2.8/test/testclass.cpp" $, 1192 $)
1193:
|
1201:
1202: ;
1203: $if $(@expr1073743506 $!@expr1073743507 $assertEquals $(@expr1073743508 "cppcheck-2.8/test/testclass.cpp" $, 1203 $, "[test.cpp:10]: (style) 'operator=' should return reference to 'this' instance.\n" $, errout@var100 .@expr1631 str (@expr1632 ) $) $) { $return ; }
1204:
1205: $checkOpertorEqRetRefThis_ $(@expr1073743511 "class A {\n    class B;\n};\nclass A::B\n{\n  B & operator=(const B & b) { return b; }\n};" $, "cppcheck-2.8/test/testclass.cpp" $, 1205 $)
1206:
|
1211:
1212: ;
1213: $if $(@expr1073743512 $!@expr1073743513 $assertEquals $(@expr1073743514 "cppcheck-2.8/test/testclass.cpp" $, 1213 $, "[test.cpp:6]: (style) 'operator=' should return reference to 'this' instance.\n" $, errout@var100 .@expr1631 str (@expr1632 ) $) $) { $return ; }
1214:
1215: $checkOpertorEqRetRefThis_ $(@expr1073743517 "class A {\n    class B;\n};\nclass A::B\n{\n  B & operator=(const B &);\n};\nA::B & A::B::operator=(const A::B & b) { return b; }" $, "cppcheck-2.8/test/testclass.cpp" $, 1215 $)
1216:
|
1222:
1223: ;
1224: $if $(@expr1073743518 $!@expr1073743519 $assertEquals $(@expr1073743520 "cppcheck-2.8/test/testclass.cpp" $, 1224 $, "[test.cpp:8]: (style) 'operator=' should return reference to 'this' instance.\n" $, errout@var100 .@expr1631 str (@expr1632 ) $) $) { $return ; }
1225:
1226: $checkOpertorEqRetRefThis_ $(@expr1073743523 "class A {\n    class B;\n};\nclass A::B\n{\n  A::B & operator=(const A::B & b) { return b; }\n};" $, "cppcheck-2.8/test/testclass.cpp" $, 1226 $)
1227:
|
1232:
1233: ;
1234: $if $(@expr1073743524 $!@expr1073743525 $assertEquals $(@expr1073743526 "cppcheck-2.8/test/testclass.cpp" $, 1234 $, "[test.cpp:6]: (style) 'operator=' should return reference to 'this' instance.\n" $, errout@var100 .@expr1631 str (@expr1632 ) $) $) { $return ; }
1235:
1236: $checkOpertorEqRetRefThis_ $(@expr1073743529 "class A {\n    class B;\n};\nclass A::B\n{\n  A::B & operator=(const A::B &);\n};\nA::B & A::B::operator=(const A::B & b) { return b; }" $, "cppcheck-2.8/test/testclass.cpp" $, 1236 $)
1237:
|
1243:
1244: ;
1245: $if $(@expr1073743530 $!@expr1073743531 $assertEquals $(@expr1073743532 "cppcheck-2.8/test/testclass.cpp" $, 1245 $, "[test.cpp:8]: (style) 'operator=' should return reference to 'this' instance.\n" $, errout@var100 .@expr1631 str (@expr1632 ) $) $) { $return ; }
1246:
1247: $checkOpertorEqRetRefThis_ $(@expr1073743535 "namespace A {\n    class B;\n}\nclass A::B\n{\n  B & operator=(const B & b) { return b; }\n};" $, "cppcheck-2.8/test/testclass.cpp" $, 1247 $)
1248:
|
1253:
1254: ;
1255: $if $(@expr1073743536 $!@expr1073743537 $assertEquals $(@expr1073743538 "cppcheck-2.8/test/testclass.cpp" $, 1255 $, "[test.cpp:6]: (style) 'operator=' should return reference to 'this' instance.\n" $, errout@var100 .@expr1631 str (@expr1632 ) $) $) { $return ; }
1256:
1257: $checkOpertorEqRetRefThis_ $(@expr1073743541 "namespace A {\n    class B;\n}\nclass A::B\n{\n  B & operator=(const B &);\n};\nA::B & A::B::operator=(const A::B & b) { return b; }" $, "cppcheck-2.8/test/testclass.cpp" $, 1257 $)
1258:
|
1264:
1265: ;
1266: $if $(@expr1073743542 $!@expr1073743543 $assertEquals $(@expr1073743544 "cppcheck-2.8/test/testclass.cpp" $, 1266 $, "[test.cpp:8]: (style) 'operator=' should return reference to 'this' instance.\n" $, errout@var100 .@expr1631 str (@expr1632 ) $) $) { $return ; }
1267:
1268: $checkOpertorEqRetRefThis_ $(@expr1073743547 "namespace A {\n    class B;\n}\nclass A::B\n{\n  A::B & operator=(const A::B & b) { return b; }\n};" $, "cppcheck-2.8/test/testclass.cpp" $, 1268 $)
1269:
|
1274:
1275: ;
1276: $if $(@expr1073743548 $!@expr1073743549 $assertEquals $(@expr1073743550 "cppcheck-2.8/test/testclass.cpp" $, 1276 $, "[test.cpp:6]: (style) 'operator=' should return reference to 'this' instance.\n" $, errout@var100 .@expr1631 str (@expr1632 ) $) $) { $return ; }
1277:
1278: $checkOpertorEqRetRefThis_ $(@expr1073743553 "namespace A {\n    class B;\n}\nclass A::B\n{\n  A::B & operator=(const A::B &);\n};\nA::B & A::B::operator=(const A::B & b) { return b; }" $, "cppcheck-2.8/test/testclass.cpp" $, 1278 $)
1279:
|
1285:
1286: ;
1287: $if $(@expr1073743554 $!@expr1073743555 $assertEquals $(@expr1073743556 "cppcheck-2.8/test/testclass.cpp" $, 1287 $, "[test.cpp:8]: (style) 'operator=' should return reference to 'this' instance.\n" $, errout@var100 .@expr1631 str (@expr1632 ) $) $) { $return ; }
1288: }
1289:
1290: void operatorEqRetRefThis2 ( ) {
1291:
1292: $checkOpertorEqRetRefThis_ $(@expr1073743559 "class szp\n{\n  szp &operator =(int *other) {}\n};" $, "cppcheck-2.8/test/testclass.cpp" $, 1292 $)
1293:
1294:
1295:
1296: ;
1297: $if $(@expr1073743560 $!@expr1073743561 $assertEquals $(@expr1073743562 "cppcheck-2.8/test/testclass.cpp" $, 1297 $, "[test.cpp:3]: (error) No 'return' statement in non-void function causes undefined behavior.\n" $, errout@var100 .@expr1739 str (@expr1740 ) $) $) { $return ; }
1298:
1299: $checkOpertorEqRetRefThis_ $(@expr1073743565 "class szp\n{\n  szp &operator =(int *other);\n};\nszp &szp::operator =(int *other) {}" $, "cppcheck-2.8/test/testclass.cpp" $, 1299 $)
1300:
|
1303:
1304: ;
1305: $if $(@expr1073743566 $!@expr1073743567 $assertEquals $(@expr1073743568 "cppcheck-2.8/test/testclass.cpp" $, 1305 $, "[test.cpp:5]: (error) No 'return' statement in non-void function causes undefined behavior.\n" $, errout@var100 .@expr1739 str (@expr1740 ) $) $) { $return ; }
1306:
1307: $checkOpertorEqRetRefThis_ $(@expr1073743571 "namespace NS {\n    class szp;\n}\nclass NS::szp\n{\n  szp &operator =(int *other) {}\n};" $, "cppcheck-2.8/test/testclass.cpp" $, 1307 $)
1308:
|
1313:
1314: ;
1315: $if $(@expr1073743572 $!@expr1073743573 $assertEquals $(@expr1073743574 "cppcheck-2.8/test/testclass.cpp" $, 1315 $, "[test.cpp:6]: (error) No 'return' statement in non-void function causes undefined behavior.\n" $, errout@var100 .@expr1739 str (@expr1740 ) $) $) { $return ; }
1316:
1317: $checkOpertorEqRetRefThis_ $(@expr1073743577 "namespace NS {\n    class szp;\n}\nclass NS::szp\n{\n  szp &operator =(int *other);\n};\nNS::szp &NS::szp::operator =(int *other) {}" $, "cppcheck-2.8/test/testclass.cpp" $, 1317 $)
1318:
|
1324:
1325: ;
1326: $if $(@expr1073743578 $!@expr1073743579 $assertEquals $(@expr1073743580 "cppcheck-2.8/test/testclass.cpp" $, 1326 $, "[test.cpp:8]: (error) No 'return' statement in non-void function causes undefined behavior.\n" $, errout@var100 .@expr1739 str (@expr1740 ) $) $) { $return ; }
1327:
1328: $checkOpertorEqRetRefThis_ $(@expr1073743583 "namespace NS {\n    class szp;\n}\nclass NS::szp\n{\n  NS::szp &operator =(int *other) {}\n};" $, "cppcheck-2.8/test/testclass.cpp" $, 1328 $)
1329:
|
1334:
1335: ;
1336: $if $(@expr1073743584 $!@expr1073743585 $assertEquals $(@expr1073743586 "cppcheck-2.8/test/testclass.cpp" $, 1336 $, "[test.cpp:6]: (error) No 'return' statement in non-void function causes undefined behavior.\n" $, errout@var100 .@expr1739 str (@expr1740 ) $) $) { $return ; }
1337:
1338: $checkOpertorEqRetRefThis_ $(@expr1073743589 "namespace NS {\n    class szp;\n}\nclass NS::szp\n{\n  NS::szp &operator =(int *other);\n};\nNS::szp &NS::szp::operator =(int *other) {}" $, "cppcheck-2.8/test/testclass.cpp" $, 1338 $)
1339:
|
1345:
1346: ;
1347: $if $(@expr1073743590 $!@expr1073743591 $assertEquals $(@expr1073743592 "cppcheck-2.8/test/testclass.cpp" $, 1347 $, "[test.cpp:8]: (error) No 'return' statement in non-void function causes undefined behavior.\n" $, errout@var100 .@expr1739 str (@expr1740 ) $) $) { $return ; }
1348:
1349: $checkOpertorEqRetRefThis_ $(@expr1073743595 "class A {\n    class szp;\n};\nclass A::szp\n{\n  szp &operator =(int *other) {}\n};" $, "cppcheck-2.8/test/testclass.cpp" $, 1349 $)
1350:
|
1355:
1356: ;
1357: $if $(@expr1073743596 $!@expr1073743597 $assertEquals $(@expr1073743598 "cppcheck-2.8/test/testclass.cpp" $, 1357 $, "[test.cpp:6]: (error) No 'return' statement in non-void function causes undefined behavior.\n" $, errout@var100 .@expr1739 str (@expr1740 ) $) $) { $return ; }
1358:
1359: $checkOpertorEqRetRefThis_ $(@expr1073743601 "class A {\n    class szp;\n};\nclass A::szp\n{\n  szp &operator =(int *other);\n};\nA::szp &A::szp::operator =(int *other) {}" $, "cppcheck-2.8/test/testclass.cpp" $, 1359 $)
1360:
|
1366:
1367: ;
1368: $if $(@expr1073743602 $!@expr1073743603 $assertEquals $(@expr1073743604 "cppcheck-2.8/test/testclass.cpp" $, 1368 $, "[test.cpp:8]: (error) No 'return' statement in non-void function causes undefined behavior.\n" $, errout@var100 .@expr1739 str (@expr1740 ) $) $) { $return ; }
1369:
1370: $checkOpertorEqRetRefThis_ $(@expr1073743607 "class A {\n    class szp;\n};\nclass A::szp\n{\n  A::szp &operator =(int *other) {}\n};" $, "cppcheck-2.8/test/testclass.cpp" $, 1370 $)
1371:
|
1376:
1377: ;
1378: $if $(@expr1073743608 $!@expr1073743609 $assertEquals $(@expr1073743610 "cppcheck-2.8/test/testclass.cpp" $, 1378 $, "[test.cpp:6]: (error) No 'return' statement in non-void function causes undefined behavior.\n" $, errout@var100 .@expr1739 str (@expr1740 ) $) $) { $return ; }
1379:
1380: $checkOpertorEqRetRefThis_ $(@expr1073743613 "class A {\n    class szp;\n};\nclass A::szp\n{\n  A::szp &operator =(int *other);\n};\nA::szp &A::szp::operator =(int *other) {}" $, "cppcheck-2.8/test/testclass.cpp" $, 1380 $)
1381:
|
1387:
1388: ;
1389: $if $(@expr1073743614 $!@expr1073743615 $assertEquals $(@expr1073743616 "cppcheck-2.8/test/testclass.cpp" $, 1389 $, "[test.cpp:8]: (error) No 'return' statement in non-void function causes undefined behavior.\n" $, errout@var100 .@expr1739 str (@expr1740 ) $) $) { $return ; }
1390: }
1391:
1392: void operatorEqRetRefThis3 ( ) {
1393:
1394: $checkOpertorEqRetRefThis_ $(@expr1073743619 "class A {\npublic:\n  inline A &operator =(int *other) { return (*this); };\n  inline A &operator =(long *other) { return (*this = 0); };\n};" $, "cppcheck-2.8/test/testclass.cpp" $, 1394 $)
1395:
|
1398:
1399: ;
1400: $if $(@expr1073743620 $!@expr1073743621 $assertEquals $(@expr1073743622 "cppcheck-2.8/test/testclass.cpp" $, 1400 $, "" $, errout@var100 .@expr1799 str (@expr1800 ) $) $) { $return ; }
1401:
1402: $checkOpertorEqRetRefThis_ $(@expr1073743625 "class A {\npublic:\n  A &operator =(int *other);\n  A &operator =(long *other);\n};\nA &A::operator =(int *other) { return (*this); };\nA &A::operator =(long *other) { return (*this = 0); };" $, "cppcheck-2.8/test/testclass.cpp" $, 1402 $)
1403:
|
1408:
1409: ;
1410: $if $(@expr1073743626 $!@expr1073743627 $assertEquals $(@expr1073743628 "cppcheck-2.8/test/testclass.cpp" $, 1410 $, "" $, errout@var100 .@expr1799 str (@expr1800 ) $) $) { $return ; }
1411:
1412: $checkOpertorEqRetRefThis_ $(@expr1073743631 "class A {\npublic:\n  inline A &operator =(int *other) { return (*this); };\n  inline A &operator =(long *other) { return operator = (*(int *)other); };\n};" $, "cppcheck-2.8/test/testclass.cpp" $, 1412 $)
1413:
|
1416:
1417: ;
1418: $if $(@expr1073743632 $!@expr1073743633 $assertEquals $(@expr1073743634 "cppcheck-2.8/test/testclass.cpp" $, 1418 $, "" $, errout@var100 .@expr1799 str (@expr1800 ) $) $) { $return ; }
1419:
1420: $checkOpertorEqRetRefThis_ $(@expr1073743637 "class A {\npublic:\n  A &operator =(int *other);\n  A &operator =(long *other);\n};\nA &A::operator =(int *other) { return (*this); };\nA &A::operator =(long *other) { return operator = (*(int *)other); };" $, "cppcheck-2.8/test/testclass.cpp" $, 1420 $)
1421:
|
1426:
1427: ;
1428: $if $(@expr1073743638 $!@expr1073743639 $assertEquals $(@expr1073743640 "cppcheck-2.8/test/testclass.cpp" $, 1428 $, "" $, errout@var100 .@expr1799 str (@expr1800 ) $) $) { $return ; }
1429:
1430: $checkOpertorEqRetRefThis_ $(@expr1073743643 "class A {\npublic:\n  A &operator =(int *other);\n  A &operator =(long *other);\n};\nA &A::operator =(int *other) { return (*this); };\nA &A::operator =(long *other) { return this->operator = (*(int *)other); };" $, "cppcheck-2.8/test/testclass.cpp" $, 1430 $)
1431:
|
1436:
1437: ;
1438: $if $(@expr1073743644 $!@expr1073743645 $assertEquals $(@expr1073743646 "cppcheck-2.8/test/testclass.cpp" $, 1438 $, "" $, errout@var100 .@expr1799 str (@expr1800 ) $) $) { $return ; }
1439:
1440: $checkOpertorEqRetRefThis_ $(@expr1073743649 "class V {\npublic:\n    V& operator=(const V& r) {\n        if (this == &r) {\n            return ( *this );\n        }\n        return *this;\n    }\n};" $, "cppcheck-2.8/test/testclass.cpp" $, 1440 $)
1441:
|
1448:
1449: ;
1450: $if $(@expr1073743650 $!@expr1073743651 $assertEquals $(@expr1073743652 "cppcheck-2.8/test/testclass.cpp" $, 1450 $, "" $, errout@var100 .@expr1799 str (@expr1800 ) $) $) { $return ; }
1451: }
1452:
1453: void operatorEqRetRefThis4 ( ) {
1454:
1455: $checkOpertorEqRetRefThis_ $(@expr1073743655 "P& P::operator = (const P& pc)\n{\n  return (P&)(*this += pc);\n}" $, "cppcheck-2.8/test/testclass.cpp" $, 1455 $)
1456:
1457:
1458:
1459: ;
1460: $if $(@expr1073743656 $!@expr1073743657 $assertEquals $(@expr1073743658 "cppcheck-2.8/test/testclass.cpp" $, 1460 $, "" $, errout@var100 .@expr1073743659 str (@expr1073743660 ) $) $) { $return ; }
1461: }
1462:
1463: void operatorEqRetRefThis5 ( ) {
1464:
1465: $checkOpertorEqRetRefThis_ $(@expr1073743661 "class A {\npublic:\n    A & operator=(const A &a) { }\n};" $, "cppcheck-2.8/test/testclass.cpp" $, 1465 $)
1466:
1467:
1468:
1469: ;
1470: $if $(@expr1073743662 $!@expr1073743663 $assertEquals $(@expr1073743664 "cppcheck-2.8/test/testclass.cpp" $, 1470 $, "[test.cpp:3]: (error) No 'return' statement in non-void function causes undefined behavior.\n" $, errout@var100 .@expr1841 str (@expr1842 ) $) $) { $return ; }
1471:
1472: $checkOpertorEqRetRefThis_ $(@expr1073743667 "class A {\nprotected:\n    A & operator=(const A &a) {}\n};" $, "cppcheck-2.8/test/testclass.cpp" $, 1472 $)
1473:
1474:
1475:
1476: ;
1477: $if $(@expr1073743668 $!@expr1073743669 $assertEquals $(@expr1073743670 "cppcheck-2.8/test/testclass.cpp" $, 1477 $, "[test.cpp:3]: (style) 'operator=' should return reference to 'this' instance.\n" $, errout@var100 .@expr1841 str (@expr1842 ) $) $) { $return ; }
1478:
1479: $checkOpertorEqRetRefThis_ $(@expr1073743673 "class A {\nprivate:\n    A & operator=(const A &a) {}\n};" $, "cppcheck-2.8/test/testclass.cpp" $, 1479 $)
1480:
1481:
1482:
1483: ;
1484: $if $(@expr1073743674 $!@expr1073743675 $assertEquals $(@expr1073743676 "cppcheck-2.8/test/testclass.cpp" $, 1484 $, "[test.cpp:3]: (style) 'operator=' should return reference to 'this' instance.\n" $, errout@var100 .@expr1841 str (@expr1842 ) $) $) { $return ; }
1485:
1486: $checkOpertorEqRetRefThis_ $(@expr1073743679 "class A {\npublic:\n    A & operator=(const A &a) {\n        rand();\n        throw std::exception();\n    }\n};" $, "cppcheck-2.8/test/testclass.cpp" $, 1486 $)
1487:
|
1492:
1493: ;
1494: $if $(@expr1073743680 $!@expr1073743681 $assertEquals $(@expr1073743682 "cppcheck-2.8/test/testclass.cpp" $, 1494 $, "[test.cpp:3]: (style) 'operator=' should either return reference to 'this' instance or be declared private and left unimplemented.\n" $, errout@var100 .@expr1841 str (@expr1842 ) $) $) { $return ; }
1495:
1496: $checkOpertorEqRetRefThis_ $(@expr1073743685 "class A {\npublic:\n    A & operator=(const A &a) {\n        rand();\n        abort();\n    }\n};" $, "cppcheck-2.8/test/testclass.cpp" $, 1496 $)
1497:
|
1502:
1503: ;
1504: $if $(@expr1073743686 $!@expr1073743687 $assertEquals $(@expr1073743688 "cppcheck-2.8/test/testclass.cpp" $, 1504 $, "[test.cpp:3]: (style) 'operator=' should either return reference to 'this' instance or be declared private and left unimplemented.\n" $, errout@var100 .@expr1841 str (@expr1842 ) $) $) { $return ; }
1505:
1506: $checkOpertorEqRetRefThis_ $(@expr1073743691 "class A {\npublic:\n    A & operator=(const A &a);\n};\nA & A :: operator=(const A &a) { }" $, "cppcheck-2.8/test/testclass.cpp" $, 1506 $)
1507:
|
1510:
1511: ;
1512: $if $(@expr1073743692 $!@expr1073743693 $assertEquals $(@expr1073743694 "cppcheck-2.8/test/testclass.cpp" $, 1512 $, "[test.cpp:5]: (error) No 'return' statement in non-void function causes undefined behavior.\n" $, errout@var100 .@expr1841 str (@expr1842 ) $) $) { $return ; }
1513: }
1514:
1515: void operatorEqRetRefThis6 ( ) {
1516: $checkOpertorEqRetRefThis_ $(@expr1073743697 "class UString {\npublic:\n    UString& assign( const char* c_str );\n    UString& operator=( const UString& s );\n};\nUString& UString::assign( const char* c_str ) {\n    std::string tmp( c_str );\n    return assign( tmp );\n}\nUString& UString::operator=( const UString& s ) {\n    return assign( s );\n}" $, "cppcheck-2.8/test/testclass.cpp" $, 1516 $)
1517:
|
1527:
1528: ;
1529: }
1530:
1531: void operatorEqRetRefThis7 ( ) {
1532: $checkOpertorEqRetRefThis_ $(@expr1073743698 "class basic_fbstring {\n  basic_fbstring& operator=(int il) {\n    return assign();\n  }\n  basic_fbstring& assign() {\n    return replace();\n  }\n  basic_fbstring& replaceImplDiscr() {\n    return replace();\n  }\n  basic_fbstring& replace() {\n    return replaceImplDiscr();\n  }\n};" $, "cppcheck-2.8/test/testclass.cpp" $, 1532 $)
1533:
|
1545:
1546: ;
1547: $if $(@expr1073743699 $!@expr1073743700 $assertEquals $(@expr1073743701 "cppcheck-2.8/test/testclass.cpp" $, 1547 $, "" $, errout@var100 .@expr1073743702 str (@expr1073743703 ) $) $) { $return ; }
1548: }
1549:
1550:
1551:
1552: void checkOpertorEqToSelf_ ( const char code@var142 [ ] , const char * file@var143 , int line@var144 ) {
1553:
1554: errout@var100 .@expr1073743704 str (@expr1073743705 "" ) ;
1555:
1556:
1557: Tokenizer tokenizer@var145 (@expr1073743706 &@expr1883 settings1@var103 , this@expr1884 ) ;
1558: std ::@expr1073743709 istringstream istr@var146 (@expr1073743710 code@var142 ) ;
1559: $assert_ $(@expr1073743711 file@var143 $, line@var144 $, $(@expr1073743712 tokenizer@var145 .@expr1073743713 tokenize (@expr1073743714 istr@var146 , "test.cpp" ) $) $) ;
1560:
1561:
1562: CheckClass checkClass@var147 (@expr1073743715 &@expr1073743716 tokenizer@var145 , &@expr1883 settings1@var103 , this@expr1884 ) ;
1563: checkClass@var147 .@expr1073743718 operatorEqToSelf (@expr1073743719 ) ;
1564: }
1565:
1566: void operatorEqToSelf1 ( ) {
1567:
1568: $checkOpertorEqToSelf_ $(@expr1073743720 "class A\n{\npublic:\n    A & operator=(const A &a) { if (&a != this) { } return *this; }\n};" $, "cppcheck-2.8/test/testclass.cpp" $, 1568 $)
1569:
|
1572:
1573: ;
1574: $if $(@expr1073743721 $!@expr1073743722 $assertEquals $(@expr1073743723 "cppcheck-2.8/test/testclass.cpp" $, 1574 $, "" $, errout@var100 .@expr1900 str (@expr1901 ) $) $) { $return ; }
1575:
1576:
1577: $checkOpertorEqToSelf_ $(@expr1073743726 "class A\n{\npublic:\n    A & operator=(const A &a) { return *this; }\n};" $, "cppcheck-2.8/test/testclass.cpp" $, 1577 $)
1578:
|
1581:
1582: ;
1583: $if $(@expr1073743727 $!@expr1073743728 $assertEquals $(@expr1073743729 "cppcheck-2.8/test/testclass.cpp" $, 1583 $, "" $, errout@var100 .@expr1900 str (@expr1901 ) $) $) { $return ; }
1584:
1585:
1586: $checkOpertorEqToSelf_ $(@expr1073743732 "class A\n{\npublic:\n    char *s;\n    A & operator=(const A &a)\n    {\n        if (&a != this)\n        {\n            free(s);\n            s = strdup(a.s);\n        }\n        return *this;\n    }\n};" $, "cppcheck-2.8/test/testclass.cpp" $, 1586 $)
1587:
|
1599:
1600: ;
1601: $if $(@expr1073743733 $!@expr1073743734 $assertEquals $(@expr1073743735 "cppcheck-2.8/test/testclass.cpp" $, 1601 $, "" $, errout@var100 .@expr1900 str (@expr1901 ) $) $) { $return ; }
1602:
1603:
1604: $checkOpertorEqToSelf_ $(@expr1073743738 "class A\n{\npublic:\n    char *s;\n    A & operator=(const A &a)\n    {\n        free(s);\n        s = strdup(a.s);\n        return *this;\n    }\n};" $, "cppcheck-2.8/test/testclass.cpp" $, 1604 $)
1605:
|
1614:
1615: ;
1616: $if $(@expr1073743739 $!@expr1073743740 $assertEquals $(@expr1073743741 "cppcheck-2.8/test/testclass.cpp" $, 1616 $, "[test.cpp:5]: (warning) 'operator=' should check for assignment to self to avoid problems with dynamic memory.\n" $, errout@var100 .@expr1900 str (@expr1901 ) $) $) { $return ; }
1617:
1618:
1619: $checkOpertorEqToSelf_ $(@expr1073743744 "class A\n{\npublic:\n    A & operator=(const A &);\n};\nA & A::operator=(const A &a) { if (&a != this) { } return *this; }" $, "cppcheck-2.8/test/testclass.cpp" $, 1619 $)
1620:
|
1624:
1625: ;
1626: $if $(@expr1073743745 $!@expr1073743746 $assertEquals $(@expr1073743747 "cppcheck-2.8/test/testclass.cpp" $, 1626 $, "" $, errout@var100 .@expr1900 str (@expr1901 ) $) $) { $return ; }
1627:
1628:
1629: $checkOpertorEqToSelf_ $(@expr1073743750 "class A\n{\npublic:\n    A & operator=(const A &);\n};\nA & A::operator=(const A &a) { return *this; }" $, "cppcheck-2.8/test/testclass.cpp" $, 1629 $)
1630:
|
1634:
1635: ;
1636: $if $(@expr1073743751 $!@expr1073743752 $assertEquals $(@expr1073743753 "cppcheck-2.8/test/testclass.cpp" $, 1636 $, "" $, errout@var100 .@expr1900 str (@expr1901 ) $) $) { $return ; }
1637:
1638:
1639: $checkOpertorEqToSelf_ $(@expr1073743756 "class A\n{\npublic:\n    char *s;\n    A & operator=(const A &);\n};\nA & A::operator=(const A &a)\n{\n    if (&a != this)\n    {\n        free(s);\n        s = strdup(a.s);\n    }\n    return *this;\n}" $, "cppcheck-2.8/test/testclass.cpp" $, 1639 $)
1640:
|
1653:
1654: ;
1655: $if $(@expr1073743757 $!@expr1073743758 $assertEquals $(@expr1073743759 "cppcheck-2.8/test/testclass.cpp" $, 1655 $, "" $, errout@var100 .@expr1900 str (@expr1901 ) $) $) { $return ; }
1656:
1657:
1658: $checkOpertorEqToSelf_ $(@expr1073743762 "class A\n{\npublic:\n    char *s;\n    A & operator=(const A &);\n};\nA & A::operator=(const A &a)\n{\n    if (&a == this)\n    {\n        free(s);\n        s = strdup(a.s);\n    }\n    return *this;\n}" $, "cppcheck-2.8/test/testclass.cpp" $, 1658 $)
1659:
|
1672:
1673: ;
1674: $if $(@expr1073743763 $!@expr1073743764 $assertEquals $(@expr1073743765 "cppcheck-2.8/test/testclass.cpp" $, 1674 $, "[test.cpp:7]: (warning) 'operator=' should check for assignment to self to avoid problems with dynamic memory.\n" $, errout@var100 .@expr1900 str (@expr1901 ) $) $) { $return ; }
1675:
1676:
1677: $checkOpertorEqToSelf_ $(@expr1073743768 "class A\n{\npublic:\n    char *s;\n    A & operator=(const A &);\n};\nA & A::operator=(const A &a)\n{\n    if ((&a == this) == true)\n    {\n        free(s);\n        s = strdup(a.s);\n    }\n    return *this;\n}" $, "cppcheck-2.8/test/testclass.cpp" $, 1677 $)
1678:
|
1691:
1692: ;
1693: $if $(@expr1073743769 $!@expr1073743770 $assertEquals $(@expr1073743771 "cppcheck-2.8/test/testclass.cpp" $, 1693 $, "[test.cpp:7]: (warning) 'operator=' should check for assignment to self to avoid problems with dynamic memory.\n" $, errout@var100 .@expr1900 str (@expr1901 ) $) $) { $return ; }
1694:
1695:
1696: $checkOpertorEqToSelf_ $(@expr1073743774 "class A\n{\npublic:\n    char *s;\n    A & operator=(const A &);\n};\nA & A::operator=(const A &a)\n{\n    if ((&a == this) != false)\n    {\n        free(s);\n        s = strdup(a.s);\n    }\n    return *this;\n}" $, "cppcheck-2.8/test/testclass.cpp" $, 1696 $)
1697:
|
1710:
1711: ;
1712: $if $(@expr1073743775 $!@expr1073743776 $assertEquals $(@expr1073743777 "cppcheck-2.8/test/testclass.cpp" $, 1712 $, "[test.cpp:7]: (warning) 'operator=' should check for assignment to self to avoid problems with dynamic memory.\n" $, errout@var100 .@expr1900 str (@expr1901 ) $) $) { $return ; }
1713:
1714:
1715: $checkOpertorEqToSelf_ $(@expr1073743780 "class A\n{\npublic:\n    char *s;\n    A & operator=(const A &);\n};\nA & A::operator=(const A &a)\n{\n    if (!((&a == this) == false))\n    {\n        free(s);\n        s = strdup(a.s);\n    }\n    return *this;\n}" $, "cppcheck-2.8/test/testclass.cpp" $, 1715 $)
1716:
|
1729:
1730: ;
1731: $if $(@expr1073743781 $!@expr1073743782 $assertEquals $(@expr1073743783 "cppcheck-2.8/test/testclass.cpp" $, 1731 $, "[test.cpp:7]: (warning) 'operator=' should check for assignment to self to avoid problems with dynamic memory.\n" $, errout@var100 .@expr1900 str (@expr1901 ) $) $) { $return ; }
1732:
1733:
1734: $checkOpertorEqToSelf_ $(@expr1073743786 "class A\n{\npublic:\n    char *s;\n    A & operator=(const A &);\n};\nA & A::operator=(const A &a)\n{\n    if ((&a != this) == false)\n    {\n        free(s);\n        s = strdup(a.s);\n    }\n    return *this;\n}" $, "cppcheck-2.8/test/testclass.cpp" $, 1734 $)
1735:
|
1748:
1749: ;
1750: $if $(@expr1073743787 $!@expr1073743788 $assertEquals $(@expr1073743789 "cppcheck-2.8/test/testclass.cpp" $, 1750 $, "[test.cpp:7]: (warning) 'operator=' should check for assignment to self to avoid problems with dynamic memory.\n" $, errout@var100 .@expr1900 str (@expr1901 ) $) $) { $return ; }
1751:
1752:
1753: $checkOpertorEqToSelf_ $(@expr1073743792 "class A\n{\npublic:\n    char *s;\n    A & operator=(const A &);\n};\nA & A::operator=(const A &a)\n{\n    if (&a != this)\n    {\n    }\n    else\n    {\n        free(s);\n        s = strdup(a.s);\n    }\n    return *this;\n}" $, "cppcheck-2.8/test/testclass.cpp" $, 1753 $)
1754:
|
1770:
1771: ;
1772: $if $(@expr1073743793 $!@expr1073743794 $assertEquals $(@expr1073743795 "cppcheck-2.8/test/testclass.cpp" $, 1772 $, "[test.cpp:7]: (warning) 'operator=' should check for assignment to self to avoid problems with dynamic memory.\n" $, errout@var100 .@expr1900 str (@expr1901 ) $) $) { $return ; }
1773:
1774:
1775: $checkOpertorEqToSelf_ $(@expr1073743798 "class A\n{\npublic:\n    char *s;\n    A & operator=(const A &);\n};\nA & A::operator=(const A &a)\n{\n    if (&a != this)\n        free(s);\n    else\n    {\n        free(s);\n        s = strdup(a.s);\n    }\n    return *this;\n}" $, "cppcheck-2.8/test/testclass.cpp" $, 1775 $)
1776:
|
1791:
1792: ;
1793: $if $(@expr1073743799 $!@expr1073743800 $assertEquals $(@expr1073743801 "cppcheck-2.8/test/testclass.cpp" $, 1793 $, "[test.cpp:7]: (warning) 'operator=' should check for assignment to self to avoid problems with dynamic memory.\n" $, errout@var100 .@expr1900 str (@expr1901 ) $) $) { $return ; }
1794:
1795:
1796:
1797: $checkOpertorEqToSelf_ $(@expr1073743804 "class A\n{\npublic:\n    char *s;\n    A & operator=(const A &);\n};\nA & A::operator=(const A &a)\n{\n    free(s);\n    s = strdup(a.s);\n    return *this;\n}" $, "cppcheck-2.8/test/testclass.cpp" $, 1797 $)
1798:
|
1808:
1809: ;
1810: $if $(@expr1073743805 $!@expr1073743806 $assertEquals $(@expr1073743807 "cppcheck-2.8/test/testclass.cpp" $, 1810 $, "[test.cpp:7]: (warning) 'operator=' should check for assignment to self to avoid problems with dynamic memory.\n" $, errout@var100 .@expr1900 str (@expr1901 ) $) $) { $return ; }
1811:
1812:
1813: $checkOpertorEqToSelf_ $(@expr1073743810 "const SubTree &SubTree::operator= (const SubTree &b)\n{\n    CodeTree *oldtree = tree;\n    tree = new CodeTree(*b.tree);\n    delete oldtree;\n    return *this;\n}\nconst SubTree &SubTree::operator= (const CodeTree &b)\n{\n    CodeTree *oldtree = tree;\n    tree = new CodeTree(b);\n    delete oldtree;\n    return *this;\n}" $, "cppcheck-2.8/test/testclass.cpp" $, 1813 $)
1814:
|
1826:
1827: ;
1828: $if $(@expr1073743811 $!@expr1073743812 $assertEquals $(@expr1073743813 "cppcheck-2.8/test/testclass.cpp" $, 1828 $, "" $, errout@var100 .@expr1900 str (@expr1901 ) $) $) { $return ; }
1829:
1830: }
1831:
1832: void operatorEqToSelf2 ( ) {
1833:
1834: $checkOpertorEqToSelf_ $(@expr1073743816 "class A\n{\npublic:\n    class B\n    {\n    public:\n        B & operator=(const B &b) { if (&b != this) { } return *this; }\n    };\n};" $, "cppcheck-2.8/test/testclass.cpp" $, 1834 $)
1835:
|
1842:
1843: ;
1844: $if $(@expr1073743817 $!@expr1073743818 $assertEquals $(@expr1073743819 "cppcheck-2.8/test/testclass.cpp" $, 1844 $, "" $, errout@var100 .@expr1996 str (@expr1997 ) $) $) { $return ; }
1845:
1846:
1847: $checkOpertorEqToSelf_ $(@expr1073743822 "class A\n{\npublic:\n    class B\n    {\n    public:\n        B & operator=(const B &b) { return *this; }\n    };\n};" $, "cppcheck-2.8/test/testclass.cpp" $, 1847 $)
1848:
|
1855:
1856: ;
1857: $if $(@expr1073743823 $!@expr1073743824 $assertEquals $(@expr1073743825 "cppcheck-2.8/test/testclass.cpp" $, 1857 $, "" $, errout@var100 .@expr1996 str (@expr1997 ) $) $) { $return ; }
1858:
1859:
1860: $checkOpertorEqToSelf_ $(@expr1073743828 "class A\n{\npublic:\n    class B\n    {\n    public:\n        char *s;\n        B & operator=(const B &b)\n        {\n            if (&b != this)\n            {\n            }\n            return *this;\n        }\n    };\n};" $, "cppcheck-2.8/test/testclass.cpp" $, 1860 $)
1861:
|
1875:
1876: ;
1877: $if $(@expr1073743829 $!@expr1073743830 $assertEquals $(@expr1073743831 "cppcheck-2.8/test/testclass.cpp" $, 1877 $, "" $, errout@var100 .@expr1996 str (@expr1997 ) $) $) { $return ; }
1878:
1879:
1880: $checkOpertorEqToSelf_ $(@expr1073743834 "class A\n{\npublic:\n    class B\n    {\n    public:\n        char *s;\n        B & operator=(const B &b)\n        {\n            free(s);\n            s = strdup(b.s);\n            return *this;\n        }\n    };\n};" $, "cppcheck-2.8/test/testclass.cpp" $, 1880 $)
1881:
|
1894:
1895: ;
1896: $if $(@expr1073743835 $!@expr1073743836 $assertEquals $(@expr1073743837 "cppcheck-2.8/test/testclass.cpp" $, 1896 $, "[test.cpp:8]: (warning) 'operator=' should check for assignment to self to avoid problems with dynamic memory.\n" $, errout@var100 .@expr1996 str (@expr1997 ) $) $) { $return ; }
1897:
1898:
1899: $checkOpertorEqToSelf_ $(@expr1073743840 "class A\n{\npublic:\n    class B\n    {\n    public:\n        B & operator=(const B &);\n    };\n};\nA::B & A::B::operator=(const A::B &b) { if (&b != this) { } return *this; }" $, "cppcheck-2.8/test/testclass.cpp" $, 1899 $)
1900:
|
1908:
1909: ;
1910: $if $(@expr1073743841 $!@expr1073743842 $assertEquals $(@expr1073743843 "cppcheck-2.8/test/testclass.cpp" $, 1910 $, "" $, errout@var100 .@expr1996 str (@expr1997 ) $) $) { $return ; }
1911:
1912:
1913: $checkOpertorEqToSelf_ $(@expr1073743846 "class A\n{\npublic:\n    class B\n    {\n    public:\n        B & operator=(const B &);\n    };\n};\nA::B & A::B::operator=(const A::B &b) { return *this; }" $, "cppcheck-2.8/test/testclass.cpp" $, 1913 $)
1914:
|
1922:
1923: ;
1924: $if $(@expr1073743847 $!@expr1073743848 $assertEquals $(@expr1073743849 "cppcheck-2.8/test/testclass.cpp" $, 1924 $, "" $, errout@var100 .@expr1996 str (@expr1997 ) $) $) { $return ; }
1925:
1926:
1927: $checkOpertorEqToSelf_ $(@expr1073743852 "class A\n{\npublic:\n    class B\n    {\n    public:\n        char * s;\n        B & operator=(const B &);\n    };\n};\nA::B & A::B::operator=(const A::B &b)\n{\n    if (&b != this)\n    {\n        free(s);\n        s = strdup(b.s);\n    }\n    return *this;\n }" $, "cppcheck-2.8/test/testclass.cpp" $, 1927 $)
1928:
|
1945:
1946: ;
1947: $if $(@expr1073743853 $!@expr1073743854 $assertEquals $(@expr1073743855 "cppcheck-2.8/test/testclass.cpp" $, 1947 $, "" $, errout@var100 .@expr1996 str (@expr1997 ) $) $) { $return ; }
1948:
1949:
1950: $checkOpertorEqToSelf_ $(@expr1073743858 "class A\n{\npublic:\n    class B\n    {\n    public:\n        char * s;\n        B & operator=(const B &);\n    };\n};\nA::B & A::B::operator=(const A::B &b)\n{\n    free(s);\n    s = strdup(b.s);\n    return *this;\n }" $, "cppcheck-2.8/test/testclass.cpp" $, 1950 $)
1951:
|
1965:
1966: ;
1967: $if $(@expr1073743859 $!@expr1073743860 $assertEquals $(@expr1073743861 "cppcheck-2.8/test/testclass.cpp" $, 1967 $, "[test.cpp:11]: (warning) 'operator=' should check for assignment to self to avoid problems with dynamic memory.\n" $, errout@var100 .@expr1996 str (@expr1997 ) $) $) { $return ; }
1968: }
1969:
1970: void operatorEqToSelf3 ( ) {
1971:
1972: $checkOpertorEqToSelf_ $(@expr1073743864 "class A : public B, public C\n{\npublic:\n    A & operator=(const A &a) { return *this; }\n};" $, "cppcheck-2.8/test/testclass.cpp" $, 1972 $)
1973:
|
1976:
1977: ;
1978: $if $(@expr1073743865 $!@expr1073743866 $assertEquals $(@expr1073743867 "cppcheck-2.8/test/testclass.cpp" $, 1978 $, "" $, errout@var100 .@expr2044 str (@expr2045 ) $) $) { $return ; }
1979:
1980:
1981: $checkOpertorEqToSelf_ $(@expr1073743870 "class A : public B, public C\n{\npublic:\n    char *s;\n    A & operator=(const A &a)\n    {\n        free(s);\n        s = strdup(a.s);\n        return *this;\n    }\n};" $, "cppcheck-2.8/test/testclass.cpp" $, 1981 $)
1982:
|
1991:
1992: ;
1993: $if $(@expr1073743871 $!@expr1073743872 $assertEquals $(@expr1073743873 "cppcheck-2.8/test/testclass.cpp" $, 1993 $, "" $, errout@var100 .@expr2044 str (@expr2045 ) $) $) { $return ; }
1994:
1995:
1996: $checkOpertorEqToSelf_ $(@expr1073743876 "class A : public B, public C\n{\npublic:\n    A & operator=(const A &);\n};\nA & A::operator=(const A &a) { return *this; }" $, "cppcheck-2.8/test/testclass.cpp" $, 1996 $)
1997:
|
2001:
2002: ;
2003: $if $(@expr1073743877 $!@expr1073743878 $assertEquals $(@expr1073743879 "cppcheck-2.8/test/testclass.cpp" $, 2003 $, "" $, errout@var100 .@expr2044 str (@expr2045 ) $) $) { $return ; }
2004:
2005:
2006: $checkOpertorEqToSelf_ $(@expr1073743882 "class A : public B, public C\n{\npublic:\n    char *s;\n    A & operator=(const A &);\n};\nA & A::operator=(const A &a)\n{\n    free(s);\n    s = strdup(a.s);\n    return *this;\n}" $, "cppcheck-2.8/test/testclass.cpp" $, 2006 $)
2007:
|
2017:
2018: ;
2019: $if $(@expr1073743883 $!@expr1073743884 $assertEquals $(@expr1073743885 "cppcheck-2.8/test/testclass.cpp" $, 2019 $, "" $, errout@var100 .@expr2044 str (@expr2045 ) $) $) { $return ; }
2020: }
2021:
2022: void operatorEqToSelf4 ( ) {
2023:
2024: $checkOpertorEqToSelf_ $(@expr1073743888 "class A\n{\npublic:\n    class B : public C, public D\n    {\n    public:\n        B & operator=(const B &b) { return *this; }\n    };\n};" $, "cppcheck-2.8/test/testclass.cpp" $, 2024 $)
2025:
|
2032:
2033: ;
2034: $if $(@expr1073743889 $!@expr1073743890 $assertEquals $(@expr1073743891 "cppcheck-2.8/test/testclass.cpp" $, 2034 $, "" $, errout@var100 .@expr2068 str (@expr2069 ) $) $) { $return ; }
2035:
2036:
2037: $checkOpertorEqToSelf_ $(@expr1073743894 "class A\n{\npublic:\n    class B : public C, public D\n    {\n    public:\n        char * s;\n        B & operator=(const B &b)\n        {\n            free(s);\n            s = strdup(b.s);\n            return *this;\n        }\n    };\n};" $, "cppcheck-2.8/test/testclass.cpp" $, 2037 $)
2038:
|
2051:
2052: ;
2053: $if $(@expr1073743895 $!@expr1073743896 $assertEquals $(@expr1073743897 "cppcheck-2.8/test/testclass.cpp" $, 2053 $, "" $, errout@var100 .@expr2068 str (@expr2069 ) $) $) { $return ; }
2054:
2055:
2056: $checkOpertorEqToSelf_ $(@expr1073743900 "class A\n{\npublic:\n    class B : public C, public D\n    {\n    public:\n        B & operator=(const B &);\n    };\n};\nA::B & A::B::operator=(const A::B &b) { return *this; }" $, "cppcheck-2.8/test/testclass.cpp" $, 2056 $)
2057:
|
2065:
2066: ;
2067: $if $(@expr1073743901 $!@expr1073743902 $assertEquals $(@expr1073743903 "cppcheck-2.8/test/testclass.cpp" $, 2067 $, "" $, errout@var100 .@expr2068 str (@expr2069 ) $) $) { $return ; }
2068:
2069:
2070: $checkOpertorEqToSelf_ $(@expr1073743906 "class A\n{\npublic:\n    class B : public C, public D\n    {\n    public:\n        char * s;\n        B & operator=(const B &);\n    };\n};\nA::B & A::B::operator=(const A::B &b)\n{\n    free(s);\n    s = strdup(b.s);\n    return *this;\n}" $, "cppcheck-2.8/test/testclass.cpp" $, 2070 $)
2071:
|
2085:
2086: ;
2087: $if $(@expr1073743907 $!@expr1073743908 $assertEquals $(@expr1073743909 "cppcheck-2.8/test/testclass.cpp" $, 2087 $, "" $, errout@var100 .@expr2068 str (@expr2069 ) $) $) { $return ; }
2088: }
2089:
2090: void operatorEqToSelf5 ( ) {
2091:
2092: $checkOpertorEqToSelf_ $(@expr1073743912 "class A\n{\npublic:\n    char *s;\n    A & operator=(const A &a)\n    {\n        if((&a!=this))\n        {\n            free(s);\n            s = strdup(a.s);\n        }\n        return *this;\n    }\n};" $, "cppcheck-2.8/test/testclass.cpp" $, 2092 $)
2093:
|
2105:
2106: ;
2107: $if $(@expr1073743913 $!@expr1073743914 $assertEquals $(@expr1073743915 "cppcheck-2.8/test/testclass.cpp" $, 2107 $, "" $, errout@var100 .@expr2092 str (@expr2093 ) $) $) { $return ; }
2108:
2109: $checkOpertorEqToSelf_ $(@expr1073743918 "class A\n{\npublic:\n    char *s;\n    A & operator=(const A &a)\n    {\n        if((this!=&a))\n        {\n            free(s);\n            s = strdup(a.s);\n        }\n        return *this;\n    }\n};" $, "cppcheck-2.8/test/testclass.cpp" $, 2109 $)
2110:
|
2122:
2123: ;
2124: $if $(@expr1073743919 $!@expr1073743920 $assertEquals $(@expr1073743921 "cppcheck-2.8/test/testclass.cpp" $, 2124 $, "" $, errout@var100 .@expr2092 str (@expr2093 ) $) $) { $return ; }
2125:
2126: $checkOpertorEqToSelf_ $(@expr1073743924 "class A\n{\npublic:\n    char *s;\n    A & operator=(const A &a)\n    {\n        if(!(&a==this))\n        {\n            free(s);\n            s = strdup(a.s);\n        }\n        return *this;\n    }\n};" $, "cppcheck-2.8/test/testclass.cpp" $, 2126 $)
2127:
|
2139:
2140: ;
2141: $if $(@expr1073743925 $!@expr1073743926 $assertEquals $(@expr1073743927 "cppcheck-2.8/test/testclass.cpp" $, 2141 $, "" $, errout@var100 .@expr2092 str (@expr2093 ) $) $) { $return ; }
2142:
2143: $checkOpertorEqToSelf_ $(@expr1073743930 "class A\n{\npublic:\n    char *s;\n    A & operator=(const A &a)\n    {\n        if(!(this==&a))\n        {\n            free(s);\n            s = strdup(a.s);\n        }\n        return *this;\n    }\n};" $, "cppcheck-2.8/test/testclass.cpp" $, 2143 $)
2144:
|
2156:
2157: ;
2158: $if $(@expr1073743931 $!@expr1073743932 $assertEquals $(@expr1073743933 "cppcheck-2.8/test/testclass.cpp" $, 2158 $, "" $, errout@var100 .@expr2092 str (@expr2093 ) $) $) { $return ; }
2159:
2160: $checkOpertorEqToSelf_ $(@expr1073743936 "class A\n{\npublic:\n    char *s;\n    A & operator=(const A &a)\n    {\n        if(false==(&a==this))\n        {\n            free(s);\n            s = strdup(a.s);\n        }\n        return *this;\n    }\n};" $, "cppcheck-2.8/test/testclass.cpp" $, 2160 $)
2161:
|
2173:
2174: ;
2175: $if $(@expr1073743937 $!@expr1073743938 $assertEquals $(@expr1073743939 "cppcheck-2.8/test/testclass.cpp" $, 2175 $, "" $, errout@var100 .@expr2092 str (@expr2093 ) $) $) { $return ; }
2176:
2177: $checkOpertorEqToSelf_ $(@expr1073743942 "class A\n{\npublic:\n    char *s;\n    A & operator=(const A &a)\n    {\n        if(false==(this==&a))\n        {\n            free(s);\n            s = strdup(a.s);\n        }\n        return *this;\n    }\n};" $, "cppcheck-2.8/test/testclass.cpp" $, 2177 $)
2178:
|
2190:
2191: ;
2192: $if $(@expr1073743943 $!@expr1073743944 $assertEquals $(@expr1073743945 "cppcheck-2.8/test/testclass.cpp" $, 2192 $, "" $, errout@var100 .@expr2092 str (@expr2093 ) $) $) { $return ; }
2193:
2194: $checkOpertorEqToSelf_ $(@expr1073743948 "class A\n{\npublic:\n    char *s;\n    A & operator=(const A &a)\n    {\n        if(true!=(&a==this))\n        {\n            free(s);\n            s = strdup(a.s);\n        }\n        return *this;\n    }\n};" $, "cppcheck-2.8/test/testclass.cpp" $, 2194 $)
2195:
|
2207:
2208: ;
2209: $if $(@expr1073743949 $!@expr1073743950 $assertEquals $(@expr1073743951 "cppcheck-2.8/test/testclass.cpp" $, 2209 $, "" $, errout@var100 .@expr2092 str (@expr2093 ) $) $) { $return ; }
2210:
2211: $checkOpertorEqToSelf_ $(@expr1073743954 "class A\n{\npublic:\n    char *s;\n    A & operator=(const A &a)\n    {\n        if(true!=(this==&a))\n        {\n            free(s);\n            s = strdup(a.s);\n        }\n        return *this;\n    }\n};" $, "cppcheck-2.8/test/testclass.cpp" $, 2211 $)
2212:
|
2224:
2225: ;
2226: $if $(@expr1073743955 $!@expr1073743956 $assertEquals $(@expr1073743957 "cppcheck-2.8/test/testclass.cpp" $, 2226 $, "" $, errout@var100 .@expr2092 str (@expr2093 ) $) $) { $return ; }
2227:
2228: $checkOpertorEqToSelf_ $(@expr1073743960 "class A\n{\npublic:\n    char *s;\n    A & operator=(const A &a);\n};\nA & A::operator=(const A &a)\n{\n    if((&a!=this))\n    {\n        free(s);\n        s = strdup(a.s);\n    }\n    return *this;\n};" $, "cppcheck-2.8/test/testclass.cpp" $, 2228 $)
2229:
|
2242:
2243: ;
2244: $if $(@expr1073743961 $!@expr1073743962 $assertEquals $(@expr1073743963 "cppcheck-2.8/test/testclass.cpp" $, 2244 $, "" $, errout@var100 .@expr2092 str (@expr2093 ) $) $) { $return ; }
2245:
2246: $checkOpertorEqToSelf_ $(@expr1073743966 "class A\n{\npublic:\n    char *s;\n    A & operator=(const A &a);\n};\nA & A::operator=(const A &a)\n{\n    if((this!=&a))\n    {\n        free(s);\n        s = strdup(a.s);\n    }\n    return *this;\n};" $, "cppcheck-2.8/test/testclass.cpp" $, 2246 $)
2247:
|
2260:
2261: ;
2262: $if $(@expr1073743967 $!@expr1073743968 $assertEquals $(@expr1073743969 "cppcheck-2.8/test/testclass.cpp" $, 2262 $, "" $, errout@var100 .@expr2092 str (@expr2093 ) $) $) { $return ; }
2263:
2264: $checkOpertorEqToSelf_ $(@expr1073743972 "class A\n{\npublic:\n    char *s;\n    A & operator=(const A &a);\n};\nA & A::operator=(const A &a)\n{\n    if(!(&a==this))\n    {\n        free(s);\n        s = strdup(a.s);\n    }\n    return *this;\n};" $, "cppcheck-2.8/test/testclass.cpp" $, 2264 $)
2265:
|
2278:
2279: ;
2280: $if $(@expr1073743973 $!@expr1073743974 $assertEquals $(@expr1073743975 "cppcheck-2.8/test/testclass.cpp" $, 2280 $, "" $, errout@var100 .@expr2092 str (@expr2093 ) $) $) { $return ; }
2281:
2282: $checkOpertorEqToSelf_ $(@expr1073743978 "class A\n{\npublic:\n    char *s;\n    A & operator=(const A &a);\n};\nA & A::operator=(const A &a)\n{\n    if(!(this==&a))\n    {\n        free(s);\n        s = strdup(a.s);\n    }\n    return *this;\n};" $, "cppcheck-2.8/test/testclass.cpp" $, 2282 $)
2283:
|
2296:
2297: ;
2298: $if $(@expr1073743979 $!@expr1073743980 $assertEquals $(@expr1073743981 "cppcheck-2.8/test/testclass.cpp" $, 2298 $, "" $, errout@var100 .@expr2092 str (@expr2093 ) $) $) { $return ; }
2299:
2300: $checkOpertorEqToSelf_ $(@expr1073743984 "class A\n{\npublic:\n    char *s;\n    A & operator=(const A &a);\n};\nA & A::operator=(const A &a)\n{\n    if(false==(&a==this))\n    {\n        free(s);\n        s = strdup(a.s);\n    }\n    return *this;\n};" $, "cppcheck-2.8/test/testclass.cpp" $, 2300 $)
2301:
|
2314:
2315: ;
2316: $if $(@expr1073743985 $!@expr1073743986 $assertEquals $(@expr1073743987 "cppcheck-2.8/test/testclass.cpp" $, 2316 $, "" $, errout@var100 .@expr2092 str (@expr2093 ) $) $) { $return ; }
2317:
2318: $checkOpertorEqToSelf_ $(@expr1073743990 "class A\n{\npublic:\n    char *s;\n    A & operator=(const A &a);\n};\nA & A::operator=(const A &a)\n{\n    if(false==(this==&a))\n    {\n        free(s);\n        s = strdup(a.s);\n    }\n    return *this;\n};" $, "cppcheck-2.8/test/testclass.cpp" $, 2318 $)
2319:
|
2332:
2333: ;
2334: $if $(@expr1073743991 $!@expr1073743992 $assertEquals $(@expr1073743993 "cppcheck-2.8/test/testclass.cpp" $, 2334 $, "" $, errout@var100 .@expr2092 str (@expr2093 ) $) $) { $return ; }
2335:
2336: $checkOpertorEqToSelf_ $(@expr1073743996 "class A\n{\npublic:\n    char *s;\n    A & operator=(const A &a);\n};\nA & A::operator=(const A &a)\n{\n    if(true!=(&a==this))\n    {\n        free(s);\n        s = strdup(a.s);\n    }\n    return *this;\n};" $, "cppcheck-2.8/test/testclass.cpp" $, 2336 $)
2337:
|
2350:
2351: ;
2352: $if $(@expr1073743997 $!@expr1073743998 $assertEquals $(@expr1073743999 "cppcheck-2.8/test/testclass.cpp" $, 2352 $, "" $, errout@var100 .@expr2092 str (@expr2093 ) $) $) { $return ; }
2353:
2354: $checkOpertorEqToSelf_ $(@expr1073744002 "class A\n{\npublic:\n    char *s;\n    A & operator=(const A &a);\n};\nA & A::operator=(const A &a)\n{\n    if(true!=(this==&a))\n    {\n        free(s);\n        s = strdup(a.s);\n    }\n    return *this;\n};" $, "cppcheck-2.8/test/testclass.cpp" $, 2354 $)
2355:
|
2368:
2369: ;
2370: $if $(@expr1073744003 $!@expr1073744004 $assertEquals $(@expr1073744005 "cppcheck-2.8/test/testclass.cpp" $, 2370 $, "" $, errout@var100 .@expr2092 str (@expr2093 ) $) $) { $return ; }
2371:
2372: $checkOpertorEqToSelf_ $(@expr1073744008 "struct A {\n    char *s;\n    A& operator=(const B &b);\n};\nA& A::operator=(const B &b) {\n    free(s);\n    s = strdup(a.s);\n    return *this;\n};" $, "cppcheck-2.8/test/testclass.cpp" $, 2372 $)
2373:
|
2380:
2381: ;
2382: $if $(@expr1073744009 $!@expr1073744010 $assertEquals $(@expr1073744011 "cppcheck-2.8/test/testclass.cpp" $, 2382 $, "" $, errout@var100 .@expr2092 str (@expr2093 ) $) $) { $return ; }
2383: }
2384:
2385: void operatorEqToSelf6 ( ) {
2386:
2387: $checkOpertorEqToSelf_ $(@expr1073744014 "class A\n{\npublic:\n    A & operator=(const A &a)\n    {\n        delete [] data;\n        data = new char[strlen(a.data) + 1];\n        strcpy(data, a.data);\n        return *this;\n    }\nprivate:\n    char * data;\n};" $, "cppcheck-2.8/test/testclass.cpp" $, 2387 $)
2388:
|
2399:
2400: ;
2401: $if $(@expr1073744015 $!@expr1073744016 $assertEquals $(@expr1073744017 "cppcheck-2.8/test/testclass.cpp" $, 2401 $, "[test.cpp:4]: (warning) 'operator=' should check for assignment to self to avoid problems with dynamic memory.\n" $, errout@var100 .@expr2194 str (@expr2195 ) $) $) { $return ; }
2402:
2403: $checkOpertorEqToSelf_ $(@expr1073744020 "class A\n{\npublic:\n    A & operator=(const A &a);\nprivate:\n    char * data;\n};\nA & A::operator=(const A &a)\n{\n    delete [] data;\n    data = new char[strlen(a.data) + 1];\n    strcpy(data, a.data);\n    return *this;\n};" $, "cppcheck-2.8/test/testclass.cpp" $, 2403 $)
2404:
|
2416:
2417: ;
2418: $if $(@expr1073744021 $!@expr1073744022 $assertEquals $(@expr1073744023 "cppcheck-2.8/test/testclass.cpp" $, 2418 $, "[test.cpp:8]: (warning) 'operator=' should check for assignment to self to avoid problems with dynamic memory.\n" $, errout@var100 .@expr2194 str (@expr2195 ) $) $) { $return ; }
2419:
2420: $checkOpertorEqToSelf_ $(@expr1073744026 "class A\n{\npublic:\n    A & operator=(const A &a)\n    {\n        delete data;\n        data = new char;\n        *data  = *a.data;\n        return *this;\n    }\nprivate:\n    char * data;\n};" $, "cppcheck-2.8/test/testclass.cpp" $, 2420 $)
2421:
|
2432:
2433: ;
2434: $if $(@expr1073744027 $!@expr1073744028 $assertEquals $(@expr1073744029 "cppcheck-2.8/test/testclass.cpp" $, 2434 $, "[test.cpp:4]: (warning) 'operator=' should check for assignment to self to avoid problems with dynamic memory.\n" $, errout@var100 .@expr2194 str (@expr2195 ) $) $) { $return ; }
2435:
2436: $checkOpertorEqToSelf_ $(@expr1073744032 "class A\n{\npublic:\n    A & operator=(const A &a);\nprivate:\n    char * data;\n};\nA & A::operator=(const A &a)\n{\n    delete data;\n    data = new char;\n    *data = *a.data;\n    return *this;\n};" $, "cppcheck-2.8/test/testclass.cpp" $, 2436 $)
2437:
|
2449:
2450: ;
2451: $if $(@expr1073744033 $!@expr1073744034 $assertEquals $(@expr1073744035 "cppcheck-2.8/test/testclass.cpp" $, 2451 $, "[test.cpp:8]: (warning) 'operator=' should check for assignment to self to avoid problems with dynamic memory.\n" $, errout@var100 .@expr2194 str (@expr2195 ) $) $) { $return ; }
2452: }
2453:
2454: void operatorEqToSelf7 ( ) {
2455: $checkOpertorEqToSelf_ $(@expr1073744038 "class A\n{\npublic:\n    A & assign(const A & a)\n    {\n        return *this;\n    }\n    A & operator=(const A &a)\n    {\n        return assign(a);\n    }\n};" $, "cppcheck-2.8/test/testclass.cpp" $, 2455 $)
2456:
|
2466:
2467: ;
2468: $if $(@expr1073744039 $!@expr1073744040 $assertEquals $(@expr1073744041 "cppcheck-2.8/test/testclass.cpp" $, 2468 $, "" $, errout@var100 .@expr1073744042 str (@expr1073744043 ) $) $) { $return ; }
2469: }
2470:
2471: void operatorEqToSelf8 ( ) {
2472: $checkOpertorEqToSelf_ $(@expr1073744044 "class FMat\n{\npublic:\n    FMat& copy(const FMat& rhs);\n    FMat& operator=(const FMat& in);\n};\nFMat& FMat::copy(const FMat& rhs)\n{\n    return *this;\n}\nFMat& FMat::operator=(const FMat& in)\n{\n    return copy(in);\n}" $, "cppcheck-2.8/test/testclass.cpp" $, 2472 $)
2473:
|
2485:
2486: ;
2487: $if $(@expr1073744045 $!@expr1073744046 $assertEquals $(@expr1073744047 "cppcheck-2.8/test/testclass.cpp" $, 2487 $, "" $, errout@var100 .@expr1073744048 str (@expr1073744049 ) $) $) { $return ; }
2488: }
2489:
2490: void operatorEqToSelf9 ( ) {
2491: $checkOpertorEqToSelf_ $(@expr1073744050 "class Foo\n{\npublic:\n    Foo& operator=(Foo* pOther);\n    Foo& operator=(Foo& other);\n};\nFoo& Foo::operator=(Foo* pOther)\n{\n    return *this;\n}\nFoo& Foo::operator=(Foo& other)\n{\n    return Foo::operator=(&other);\n}" $, "cppcheck-2.8/test/testclass.cpp" $, 2491 $)
2492:
|
2504:
2505: ;
2506: $if $(@expr1073744051 $!@expr1073744052 $assertEquals $(@expr1073744053 "cppcheck-2.8/test/testclass.cpp" $, 2506 $, "" $, errout@var100 .@expr1073744054 str (@expr1073744055 ) $) $) { $return ; }
2507: }
2508:
2509:
2510:
2511: void checkVirtualDestructor_ ( const char * file@var148 , int line@var149 , const char code@var150 [ ] , bool inconclusive@var151 = false ) {
2512:
2513: errout@var100 .@expr1073744058 str (@expr1073744059 "" ) ;
2514:
2515: settings0@var102 .@expr1073744060 certainty@var152 .@expr1073744061 setEnabled (@expr1073744062 Certainty ::@expr1073744063 inconclusive@expr1073744056 , inconclusive@var151 ) ;
2516: settings0@var102 .@expr1073744064 severity@var104 .@expr1073744065 enable (@expr1073744066 Severity ::@expr1073744067 warning@expr1073744057 ) ;
2517:
2518:
2519: Tokenizer tokenizer@var153 (@expr1073744068 &@expr2245 settings0@var102 , this@expr2246 ) ;
2520: std ::@expr1073744071 istringstream istr@var154 (@expr1073744072 code@var150 ) ;
2521: $assert_ $(@expr1073744073 file@var148 $, line@var149 $, $(@expr1073744074 tokenizer@var153 .@expr1073744075 tokenize (@expr1073744076 istr@var154 , "test.cpp" ) $) $) ;
2522:
2523:
2524: CheckClass checkClass@var155 (@expr1073744077 &@expr1073744078 tokenizer@var153 , &@expr2245 settings0@var102 , this@expr2246 ) ;
2525: checkClass@var155 .@expr1073744080 virtualDestructor (@expr1073744081 ) ;
2526: }
2527:
2528: void virtualDestructor1 ( ) {
2529:
2530:
2531: $checkVirtualDestructor_ $(@expr1073744082 "cppcheck-2.8/test/testclass.cpp" $, 2531 $, "class Derived : public Base { };\nBase *base = new Derived;\ndelete base;" $)
2532:
2533: ;
2534: $if $(@expr1073744083 $!@expr1073744084 $assertEquals $(@expr1073744085 "cppcheck-2.8/test/testclass.cpp" $, 2534 $, "" $, errout@var100 .@expr2262 str (@expr2263 ) $) $) { $return ; }
2535:
2536: $checkVirtualDestructor_ $(@expr1073744088 "cppcheck-2.8/test/testclass.cpp" $, 2536 $, "class Derived : Base { };\nBase *base = new Derived;\ndelete base;" $)
2537:
2538: ;
2539: $if $(@expr1073744089 $!@expr1073744090 $assertEquals $(@expr1073744091 "cppcheck-2.8/test/testclass.cpp" $, 2539 $, "" $, errout@var100 .@expr2262 str (@expr2263 ) $) $) { $return ; }
2540: }
2541:
2542: void virtualDestructor2 ( ) {
2543:
2544:
2545: $checkVirtualDestructor_ $(@expr1073744094 "cppcheck-2.8/test/testclass.cpp" $, 2545 $, "class Base { };\nclass Derived : public Base { public: ~Derived() { (void)11; } };Base *base = new Derived;\ndelete base;" $)
2546:
2547:
2548: ;
2549: $if $(@expr1073744095 $!@expr1073744096 $assertEquals $(@expr1073744097 "cppcheck-2.8/test/testclass.cpp" $, 2549 $, "[test.cpp:1]: (error) Class 'Base' which is inherited by class 'Derived' does not have a virtual destructor.\n" $, errout@var100 .@expr2274 str (@expr2275 ) $) $) { $return ; }
2550:
2551: $checkVirtualDestructor_ $(@expr1073744100 "cppcheck-2.8/test/testclass.cpp" $, 2551 $, "class Base { };\nclass Derived : protected Base { public: ~Derived() { (void)11; } };Base *base = new Derived;\ndelete base;" $)
2552:
2553:
2554: ;
2555: $if $(@expr1073744101 $!@expr1073744102 $assertEquals $(@expr1073744103 "cppcheck-2.8/test/testclass.cpp" $, 2555 $, "[test.cpp:1]: (error) Class 'Base' which is inherited by class 'Derived' does not have a virtual destructor.\n" $, errout@var100 .@expr2274 str (@expr2275 ) $) $) { $return ; }
2556:
2557: $checkVirtualDestructor_ $(@expr1073744106 "cppcheck-2.8/test/testclass.cpp" $, 2557 $, "class Base { };\nclass Derived : private Base { public: ~Derived() { (void)11; } };Base *base = new Derived;\ndelete base;" $)
2558:
2559:
2560: ;
2561: $if $(@expr1073744107 $!@expr1073744108 $assertEquals $(@expr1073744109 "cppcheck-2.8/test/testclass.cpp" $, 2561 $, "" $, errout@var100 .@expr2274 str (@expr2275 ) $) $) { $return ; }
2562:
2563: $checkVirtualDestructor_ $(@expr1073744112 "cppcheck-2.8/test/testclass.cpp" $, 2563 $, "class Base { };\nclass Derived : Base { public: ~Derived() { (void)11; } };Base *base = new Derived;\ndelete base;" $)
2564:
2565:
2566: ;
2567: $if $(@expr1073744113 $!@expr1073744114 $assertEquals $(@expr1073744115 "cppcheck-2.8/test/testclass.cpp" $, 2567 $, "" $, errout@var100 .@expr2274 str (@expr2275 ) $) $) { $return ; }
2568:
2569:
2570: $checkVirtualDestructor_ $(@expr1073744118 "cppcheck-2.8/test/testclass.cpp" $, 2570 $, "struct A\n{\n    A()  { cout << \"A is constructing\\n\"; }\n    ~A() { cout << \"A is destructing\\n\"; }\n};\n \nstruct Base {};\n \nstruct Derived : Base\n{\n    A a;\n};\n \nint main(void)\n{\n    Base* p = new Derived();\n    delete p;\n}" $)
2571:
|
2586:
2587: ;
2588: $if $(@expr1073744119 $!@expr1073744120 $assertEquals $(@expr1073744121 "cppcheck-2.8/test/testclass.cpp" $, 2588 $, "[test.cpp:7]: (error) Class 'Base' which is inherited by class 'Derived' does not have a virtual destructor.\n" $, errout@var100 .@expr2274 str (@expr2275 ) $) $) { $return ; }
2589: }
2590:
2591: void virtualDestructor3 ( ) {
2592:
2593:
2594: $checkVirtualDestructor_ $(@expr1073744124 "cppcheck-2.8/test/testclass.cpp" $, 2594 $, "class Base { public: ~Base(); };\nclass Derived : public Base { public: ~Derived() { (void)11; } };Base *base = new Derived;\ndelete base;" $)
2595:
2596:
2597: ;
2598: $if $(@expr1073744125 $!@expr1073744126 $assertEquals $(@expr1073744127 "cppcheck-2.8/test/testclass.cpp" $, 2598 $, "[test.cpp:1]: (error) Class 'Base' which is inherited by class 'Derived' does not have a virtual destructor.\n" $, errout@var100 .@expr2304 str (@expr2305 ) $) $) { $return ; }
2599:
2600: $checkVirtualDestructor_ $(@expr1073744130 "cppcheck-2.8/test/testclass.cpp" $, 2600 $, "class Base { public: ~Base(); };\nclass Derived : protected Base { public: ~Derived() { (void)11; } };Base *base = new Derived;\ndelete base;" $)
2601:
2602:
2603: ;
2604: $if $(@expr1073744131 $!@expr1073744132 $assertEquals $(@expr1073744133 "cppcheck-2.8/test/testclass.cpp" $, 2604 $, "[test.cpp:1]: (error) Class 'Base' which is inherited by class 'Derived' does not have a virtual destructor.\n" $, errout@var100 .@expr2304 str (@expr2305 ) $) $) { $return ; }
2605:
2606: $checkVirtualDestructor_ $(@expr1073744136 "cppcheck-2.8/test/testclass.cpp" $, 2606 $, "class Base { public: ~Base(); };\nclass Derived : private Fred, public Base { public: ~Derived() { (void)11; } };Base *base = new Derived;\ndelete base;" $)
2607:
2608:
2609: ;
2610: $if $(@expr1073744137 $!@expr1073744138 $assertEquals $(@expr1073744139 "cppcheck-2.8/test/testclass.cpp" $, 2610 $, "[test.cpp:1]: (error) Class 'Base' which is inherited by class 'Derived' does not have a virtual destructor.\n" $, errout@var100 .@expr2304 str (@expr2305 ) $) $) { $return ; }
2611: }
2612:
2613: void virtualDestructor4 ( ) {
2614:
2615:
2616: $checkVirtualDestructor_ $(@expr1073744142 "cppcheck-2.8/test/testclass.cpp" $, 2616 $, "class Base { public: ~Base(); };\nclass Derived : public Base { };Base *base = new Derived;\ndelete base;" $)
2617:
2618:
2619: ;
2620: $if $(@expr1073744143 $!@expr1073744144 $assertEquals $(@expr1073744145 "cppcheck-2.8/test/testclass.cpp" $, 2620 $, "[test.cpp:1]: (error) Class 'Base' which is inherited by class 'Derived' does not have a virtual destructor.\n" $, errout@var100 .@expr2322 str (@expr2323 ) $) $) { $return ; }
2621:
2622: $checkVirtualDestructor_ $(@expr1073744148 "cppcheck-2.8/test/testclass.cpp" $, 2622 $, "class Base { public: ~Base(); };\nclass Derived : private Fred, public Base { };Base *base = new Derived;\ndelete base;" $)
2623:
2624:
2625: ;
2626: $if $(@expr1073744149 $!@expr1073744150 $assertEquals $(@expr1073744151 "cppcheck-2.8/test/testclass.cpp" $, 2626 $, "[test.cpp:1]: (error) Class 'Base' which is inherited by class 'Derived' does not have a virtual destructor.\n" $, errout@var100 .@expr2322 str (@expr2323 ) $) $) { $return ; }
2627: }
2628:
2629: void virtualDestructor5 ( ) {
2630:
2631:
2632: $checkVirtualDestructor_ $(@expr1073744154 "cppcheck-2.8/test/testclass.cpp" $, 2632 $, "class Base { public: ~Base(); };\nclass Derived : public Base { public: ~Derived() {} };Base *base = new Derived;\ndelete base;" $)
2633:
2634:
2635: ;
2636: $if $(@expr1073744155 $!@expr1073744156 $assertEquals $(@expr1073744157 "cppcheck-2.8/test/testclass.cpp" $, 2636 $, "[test.cpp:1]: (error) Class 'Base' which is inherited by class 'Derived' does not have a virtual destructor.\n" $, errout@var100 .@expr2334 str (@expr2335 ) $) $) { $return ; }
2637:
2638: $checkVirtualDestructor_ $(@expr1073744160 "cppcheck-2.8/test/testclass.cpp" $, 2638 $, "class Base { public: ~Base(); };\nclass Derived : public Base { public: ~Derived(); }; Derived::~Derived() {}Base *base = new Derived;\ndelete base;" $)
2639:
2640:
2641: ;
2642: $if $(@expr1073744161 $!@expr1073744162 $assertEquals $(@expr1073744163 "cppcheck-2.8/test/testclass.cpp" $, 2642 $, "[test.cpp:1]: (error) Class 'Base' which is inherited by class 'Derived' does not have a virtual destructor.\n" $, errout@var100 .@expr2334 str (@expr2335 ) $) $) { $return ; }
2643: }
2644:
2645: void virtualDestructor6 ( ) {
2646:
2647:
2648:
2649: $checkVirtualDestructor_ $(@expr1073744166 "cppcheck-2.8/test/testclass.cpp" $, 2649 $, "class Base { public: ~Base(); };\nclass Derived : public Base { public: ~Derived() { (void)11; } };" $)
2650: ;
2651: $if $(@expr1073744167 $!@expr1073744168 $assertEquals $(@expr1073744169 "cppcheck-2.8/test/testclass.cpp" $, 2651 $, "" $, errout@var100 .@expr1073744170 str (@expr1073744171 ) $) $) { $return ; }
2652: }
2653:
2654: void virtualDestructorProtected ( ) {
2655:
2656:
2657: $checkVirtualDestructor_ $(@expr1073744172 "cppcheck-2.8/test/testclass.cpp" $, 2657 $, "class A\n{\nprotected:\n    ~A() { }\n};\n\nclass B : public A\n{\npublic:\n    ~B() { int a; }\n};" $)
2658:
|
2666:
2667: ;
2668: $if $(@expr1073744173 $!@expr1073744174 $assertEquals $(@expr1073744175 "cppcheck-2.8/test/testclass.cpp" $, 2668 $, "" $, errout@var100 .@expr1073744176 str (@expr1073744177 ) $) $) { $return ; }
2669: }
2670:
2671: void virtualDestructorInherited ( ) {
2672:
2673: $checkVirtualDestructor_ $(@expr1073744178 "cppcheck-2.8/test/testclass.cpp" $, 2673 $, "class Base\n{\npublic:\nvirtual ~Base() {}\n};\nclass A : private Base\n{\npublic:\n    ~A() { }\n};\n\nclass B : public A\n{\npublic:\n    ~B() { int a; }\n};" $)
2674:
|
2687:
2688: ;
2689: $if $(@expr1073744179 $!@expr1073744180 $assertEquals $(@expr1073744181 "cppcheck-2.8/test/testclass.cpp" $, 2689 $, "" $, errout@var100 .@expr2358 str (@expr2359 ) $) $) { $return ; }
2690:
|
2693:
2694: $checkVirtualDestructor_ $(@expr1073744184 "cppcheck-2.8/test/testclass.cpp" $, 2694 $, "struct Base\n{\nvirtual ~Base() {}\n};\nclass A : public Base\n{\n};\n\nclass B : public A\n{\npublic:\n    ~B() { int a; }\n};" $)
2695:
|
2705:
2706: ;
2707: $if $(@expr1073744185 $!@expr1073744186 $assertEquals $(@expr1073744187 "cppcheck-2.8/test/testclass.cpp" $, 2707 $, "" $, errout@var100 .@expr2358 str (@expr2359 ) $) $) { $return ; }
2708:
2709:
2710: $checkVirtualDestructor_ $(@expr1073744190 "cppcheck-2.8/test/testclass.cpp" $, 2710 $, "class A : private Base\n{\npublic:\n    ~A() { }\n};\n\nclass B : public A\n{\npublic:\n    ~B() { int a; }\n};" $)
2711:
|
2719:
2720: ;
2721: $if $(@expr1073744191 $!@expr1073744192 $assertEquals $(@expr1073744193 "cppcheck-2.8/test/testclass.cpp" $, 2721 $, "" $, errout@var100 .@expr2358 str (@expr2359 ) $) $) { $return ; }
2722:
2723:
2724: $checkVirtualDestructor_ $(@expr1073744196 "cppcheck-2.8/test/testclass.cpp" $, 2724 $, "class Base2\n{\nvirtual ~Base2() {}\n};\nclass Base : public Base2\n{\n};\nclass A : private Base\n{\npublic:\n    ~A() { }\n};\n\nclass B : public A\n{\npublic:\n    ~B() { int a; }\n};" $)
2725:
|
2740:
2741: ;
2742: $if $(@expr1073744197 $!@expr1073744198 $assertEquals $(@expr1073744199 "cppcheck-2.8/test/testclass.cpp" $, 2742 $, "" $, errout@var100 .@expr2358 str (@expr2359 ) $) $) { $return ; }
2743:
2744:
2745: $checkVirtualDestructor_ $(@expr1073744202 "cppcheck-2.8/test/testclass.cpp" $, 2745 $, "class Base\n{\npublic:\n    ~Base() {}\n};\nclass A : private Base\n{\npublic:\n    ~A() { }\n};\n\nclass B : public A\n{\npublic:\n    ~B() { int a; }\n};" $)
2746:
|
2759:
2760: ;
2761: $todoAssertEquals $(@expr1073744203 "cppcheck-2.8/test/testclass.cpp" $, 2761 $, "[test.cpp:7]: (error) Class 'Base' which is inherited by class 'B' does not have a virtual destructor.\n" $, "" $, errout@var100 .@expr2358 str (@expr2359 ) $)
2762: ;
2763: }
2764:
2765: void virtualDestructorTemplate ( ) {
2766: $checkVirtualDestructor_ $(@expr1073744206 "cppcheck-2.8/test/testclass.cpp" $, 2766 $, "template <typename T> class A\n{\n public:\n virtual ~A(){}\n};\ntemplate <typename T> class AA\n{\n public:\n ~AA(){}\n};\nclass B : public A<int>, public AA<double>\n{\n public:\n ~B(){int a;}\n};\n\nAA<double> *p = new B; delete p;" $)
2767:
|
2781:
2782: ;
2783: $if $(@expr1073744207 $!@expr1073744208 $assertEquals $(@expr1073744209 "cppcheck-2.8/test/testclass.cpp" $, 2783 $, "[test.cpp:9]: (error) Class 'AA < double >' which is inherited by class 'B' does not have a virtual destructor.\n" $, errout@var100 .@expr1073744210 str (@expr1073744211 ) $) $) { $return ; }
2784: }
2785:
2786: void virtualDestructorInconclusive ( ) {
2787: $checkVirtualDestructor_ $(@expr1073744212 "cppcheck-2.8/test/testclass.cpp" $, 2787 $, "class Base {\npublic:\n    ~Base(){}\n    virtual void foo(){}\n};\n" , true $)
2788:
2789:
2790:
2791: ;
2792: $if $(@expr1073744213 $!@expr1073744214 $assertEquals $(@expr1073744215 "cppcheck-2.8/test/testclass.cpp" $, 2792 $, "[test.cpp:3]: (warning, inconclusive) Class 'Base' which has virtual members does not have a virtual destructor.\n" $, errout@var100 .@expr2392 str (@expr2393 ) $) $) { $return ; }
2793:
2794: $checkVirtualDestructor_ $(@expr1073744218 "cppcheck-2.8/test/testclass.cpp" $, 2794 $, "class Base {\npublic:\n    ~Base(){}\n    virtual void foo(){}\n};\nclass Derived : public Base {\npublic:\n    ~Derived() { bar(); }\n};\nvoid foo() {\n    Base * base = new Derived();\n    delete base;\n}\n" , true $)
2795:
|
2805:
2806: ;
2807: $if $(@expr1073744219 $!@expr1073744220 $assertEquals $(@expr1073744221 "cppcheck-2.8/test/testclass.cpp" $, 2807 $, "[test.cpp:3]: (error) Class 'Base' which is inherited by class 'Derived' does not have a virtual destructor.\n" $, errout@var100 .@expr2392 str (@expr2393 ) $) $) { $return ; }
2808:
2809:
2810: $checkVirtualDestructor_ $(@expr1073744224 "cppcheck-2.8/test/testclass.cpp" $, 2810 $, "class Base {\npublic:\n    virtual void foo(){}\nprotected:\n    ~Base(){}\n};\n" , true $)
2811:
|
2814:
2815: ;
2816: $if $(@expr1073744225 $!@expr1073744226 $assertEquals $(@expr1073744227 "cppcheck-2.8/test/testclass.cpp" $, 2816 $, "" $, errout@var100 .@expr2392 str (@expr2393 ) $) $) { $return ; }
2817:
2818: $checkVirtualDestructor_ $(@expr1073744230 "cppcheck-2.8/test/testclass.cpp" $, 2818 $, "class C {\nprivate:\n    C();\n    virtual ~C();\n};\n" , true $)
2819:
2820:
2821:
2822: ;
2823: $if $(@expr1073744231 $!@expr1073744232 $assertEquals $(@expr1073744233 "cppcheck-2.8/test/testclass.cpp" $, 2823 $, "" $, errout@var100 .@expr2392 str (@expr2393 ) $) $) { $return ; }
2824: }
2825:
2826:
2827:
2828: void checkNoMemset_ ( const char * file@var156 , int line@var157 , const char code@var158 [ ] ) {
2829: Settings settings@var159 ;
2830: settings@var159 .@expr2414 severity@var160 .@expr2415 enable (@expr1073744240 Severity ::@expr1073744241 warning@expr1073744236 ) ;
2831: settings@var159 .@expr2414 severity@var160 .@expr2415 enable (@expr1073744244 Severity ::@expr1073744245 portability@expr1073744237 ) ;
2832: checkNoMemset_ (@expr1073744246 file@var156 , line@var157 , code@var158 , settings@var159 ) ;
2833: }
2834:
2835: void checkNoMemset_ ( const char * file@var161 , int line@var162 , const char code@var163 [ ] , const Settings & settings@var164 ) {
2836:
2837: errout@var100 .@expr1073744247 str (@expr1073744248 "" ) ;
2838:
2839:
2840: Tokenizer tokenizer@var165 (@expr1073744249 &@expr2426 settings@var164 , this@expr2427 ) ;
2841: std ::@expr1073744252 istringstream istr@var166 (@expr1073744253 code@var163 ) ;
2842: $assert_ $(@expr1073744254 file@var161 $, line@var162 $, $(@expr1073744255 tokenizer@var165 .@expr1073744256 tokenize (@expr1073744257 istr@var166 , "test.cpp" ) $) $) ;
2843:
2844:
2845: CheckClass checkClass@var167 (@expr1073744258 &@expr1073744259 tokenizer@var165 , &@expr2426 settings@var164 , this@expr2427 ) ;
2846: checkClass@var167 .@expr1073744261 checkMemset (@expr1073744262 ) ;
2847: }
2848:
2849: void memsetOnClass ( ) {
2850: $checkNoMemset_ $(@expr1073744263 "cppcheck-2.8/test/testclass.cpp" $, 2850 $, "class Fred\n{\n};\nvoid f()\n{\n    Fred fred;\n    memset(&fred, 0, sizeof(Fred));\n}" $)
2851:
|
2856:
2857: ;
2858: $if $(@expr1073744264 $!@expr1073744265 $assertEquals $(@expr1073744266 "cppcheck-2.8/test/testclass.cpp" $, 2858 $, "" $, errout@var100 .@expr2443 str (@expr2444 ) $) $) { $return ; }
2859:
2860: $checkNoMemset_ $(@expr1073744269 "cppcheck-2.8/test/testclass.cpp" $, 2860 $, "class Fred\n{\n    static std::string b;\n};\nvoid f()\n{\n    Fred fred;\n    memset(&fred, 0, sizeof(Fred));\n}" $)
2861:
|
2867:
2868: ;
2869: $if $(@expr1073744270 $!@expr1073744271 $assertEquals $(@expr1073744272 "cppcheck-2.8/test/testclass.cpp" $, 2869 $, "" $, errout@var100 .@expr2443 str (@expr2444 ) $) $) { $return ; }
2870:
2871: $checkNoMemset_ $(@expr1073744275 "cppcheck-2.8/test/testclass.cpp" $, 2871 $, "class Fred\n{\n    std::string * b;\n};\nvoid f()\n{\n    Fred fred;\n    memset(&fred, 0, sizeof(Fred));\n}" $)
2872:
|
2878:
2879: ;
2880: $if $(@expr1073744276 $!@expr1073744277 $assertEquals $(@expr1073744278 "cppcheck-2.8/test/testclass.cpp" $, 2880 $, "" $, errout@var100 .@expr2443 str (@expr2444 ) $) $) { $return ; }
2881:
2882: $checkNoMemset_ $(@expr1073744281 "cppcheck-2.8/test/testclass.cpp" $, 2882 $, "class Fred\n{\n    std::string b;\n};\nvoid f()\n{\n    Fred fred;\n    memset(&fred, 0, sizeof(Fred));\n}" $)
2883:
|
2889:
2890: ;
2891: $if $(@expr1073744282 $!@expr1073744283 $assertEquals $(@expr1073744284 "cppcheck-2.8/test/testclass.cpp" $, 2891 $, "[test.cpp:8]: (error) Using 'memset' on class that contains a 'std::string'.\n" $, errout@var100 .@expr2443 str (@expr2444 ) $) $) { $return ; }
2892:
2893: $checkNoMemset_ $(@expr1073744287 "cppcheck-2.8/test/testclass.cpp" $, 2893 $, "class Fred\n{\n    mutable std::string b;\n};\nvoid f()\n{\n    Fred fred;\n    memset(&fred, 0, sizeof(Fred));\n}" $)
2894:
|
2900:
2901: ;
2902: $if $(@expr1073744288 $!@expr1073744289 $assertEquals $(@expr1073744290 "cppcheck-2.8/test/testclass.cpp" $, 2902 $, "[test.cpp:8]: (error) Using 'memset' on class that contains a 'std::string'.\n" $, errout@var100 .@expr2443 str (@expr2444 ) $) $) { $return ; }
2903:
2904: $checkNoMemset_ $(@expr1073744293 "cppcheck-2.8/test/testclass.cpp" $, 2904 $, "class Fred {\n    std::string b;\n    void f();\n};\nvoid Fred::f() {\n    memset(this, 0, sizeof(*this));\n}" $)
2905:
|
2909:
2910: ;
2911: $if $(@expr1073744294 $!@expr1073744295 $assertEquals $(@expr1073744296 "cppcheck-2.8/test/testclass.cpp" $, 2911 $, "[test.cpp:6]: (error) Using 'memset' on class that contains a 'std::string'.\n" $, errout@var100 .@expr2443 str (@expr2444 ) $) $) { $return ; }
2912:
2913: $checkNoMemset_ $(@expr1073744299 "cppcheck-2.8/test/testclass.cpp" $, 2913 $, "class Fred\n{\n};\nvoid f()\n{\n    Fred fred;\n    memset(&fred, 0, sizeof(fred));\n}" $)
2914:
|
2919:
2920: ;
2921: $if $(@expr1073744300 $!@expr1073744301 $assertEquals $(@expr1073744302 "cppcheck-2.8/test/testclass.cpp" $, 2921 $, "" $, errout@var100 .@expr2443 str (@expr2444 ) $) $) { $return ; }
2922:
2923: $checkNoMemset_ $(@expr1073744305 "cppcheck-2.8/test/testclass.cpp" $, 2923 $, "class Fred\n{\n    std::string s;\n};\nvoid f()\n{\n    Fred fred;\n    memset(&fred, 0, sizeof(fred));\n}" $)
2924:
|
2930:
2931: ;
2932: $if $(@expr1073744306 $!@expr1073744307 $assertEquals $(@expr1073744308 "cppcheck-2.8/test/testclass.cpp" $, 2932 $, "[test.cpp:8]: (error) Using 'memset' on class that contains a 'std::string'.\n" $, errout@var100 .@expr2443 str (@expr2444 ) $) $) { $return ; }
2933:
2934: $checkNoMemset_ $(@expr1073744311 "cppcheck-2.8/test/testclass.cpp" $, 2934 $, "class Fred\n{\n    std::string s;\n};\nclass Pebbles: public Fred {};\nvoid f()\n{\n    Pebbles pebbles;\n    memset(&pebbles, 0, sizeof(pebbles));\n}" $)
2935:
|
2942:
2943: ;
2944: $if $(@expr1073744312 $!@expr1073744313 $assertEquals $(@expr1073744314 "cppcheck-2.8/test/testclass.cpp" $, 2944 $, "[test.cpp:9]: (error) Using 'memset' on class that contains a 'std::string'.\n" $, errout@var100 .@expr2443 str (@expr2444 ) $) $) { $return ; }
2945:
2946: $checkNoMemset_ $(@expr1073744317 "cppcheck-2.8/test/testclass.cpp" $, 2946 $, "class Fred\n{\n    virtual ~Fred();\n};\nvoid f()\n{\n    Fred fred;\n    memset(&fred, 0, sizeof(fred));\n}" $)
2947:
|
2953:
2954: ;
2955: $if $(@expr1073744318 $!@expr1073744319 $assertEquals $(@expr1073744320 "cppcheck-2.8/test/testclass.cpp" $, 2955 $, "[test.cpp:8]: (error) Using 'memset' on class that contains a virtual function.\n" $, errout@var100 .@expr2443 str (@expr2444 ) $) $) { $return ; }
2956:
2957: $checkNoMemset_ $(@expr1073744323 "cppcheck-2.8/test/testclass.cpp" $, 2957 $, "class Fred\n{\n    virtual ~Fred();\n};\nvoid f()\n{\n    static Fred fred;\n    memset(&fred, 0, sizeof(fred));\n}" $)
2958:
|
2964:
2965: ;
2966: $if $(@expr1073744324 $!@expr1073744325 $assertEquals $(@expr1073744326 "cppcheck-2.8/test/testclass.cpp" $, 2966 $, "[test.cpp:8]: (error) Using 'memset' on class that contains a virtual function.\n" $, errout@var100 .@expr2443 str (@expr2444 ) $) $) { $return ; }
2967:
2968: $checkNoMemset_ $(@expr1073744329 "cppcheck-2.8/test/testclass.cpp" $, 2968 $, "class Fred\n{\n};\nclass Wilma\n{\n    virtual ~Wilma();\n};\nclass Pebbles: public Fred, Wilma {};\nvoid f()\n{\n    Pebbles pebbles;\n    memset(&pebbles, 0, sizeof(pebbles));\n}" $)
2969:
|
2979:
2980: ;
2981: $if $(@expr1073744330 $!@expr1073744331 $assertEquals $(@expr1073744332 "cppcheck-2.8/test/testclass.cpp" $, 2981 $, "[test.cpp:12]: (error) Using 'memset' on class that contains a virtual function.\n" $, errout@var100 .@expr2443 str (@expr2444 ) $) $) { $return ; }
2982:
2983:
2984: $checkNoMemset_ $(@expr1073744335 "cppcheck-2.8/test/testclass.cpp" $, 2984 $, "namespace n1 {\n    class Fred\n    {\n        std::string b;\n    };\n}\nvoid f()\n{\n    Fred fred;\n    memset(&fred, 0, sizeof(Fred));\n}" $)
2985:
|
2993:
2994: ;
2995: $if $(@expr1073744336 $!@expr1073744337 $assertEquals $(@expr1073744338 "cppcheck-2.8/test/testclass.cpp" $, 2995 $, "" $, errout@var100 .@expr2443 str (@expr2444 ) $) $) { $return ; }
2996:
2997:
2998: $checkNoMemset_ $(@expr1073744341 "cppcheck-2.8/test/testclass.cpp" $, 2998 $, "namespace n1 {\n    class Fred\n    {\n        std::string b;\n    };\n}\nvoid f()\n{\n    n1::Fred fred;\n    memset(&fred, 0, sizeof(n1::Fred));\n}" $)
2999:
|
3007:
3008: ;
3009: $if $(@expr1073744342 $!@expr1073744343 $assertEquals $(@expr1073744344 "cppcheck-2.8/test/testclass.cpp" $, 3009 $, "[test.cpp:10]: (error) Using 'memset' on class that contains a 'std::string'.\n" $, errout@var100 .@expr2443 str (@expr2444 ) $) $) { $return ; }
3010:
3011:
3012: $checkNoMemset_ $(@expr1073744347 "cppcheck-2.8/test/testclass.cpp" $, 3012 $, "namespace n1 {\n    class Fred\n    {\n        std::string b;\n    };\n}\nvoid f()\n{\n    n1::Fred fred;\n    memset(&fred, 0, sizeof(fred));\n}" $)
3013:
|
3021:
3022: ;
3023: $if $(@expr1073744348 $!@expr1073744349 $assertEquals $(@expr1073744350 "cppcheck-2.8/test/testclass.cpp" $, 3023 $, "[test.cpp:10]: (error) Using 'memset' on class that contains a 'std::string'.\n" $, errout@var100 .@expr2443 str (@expr2444 ) $) $) { $return ; }
3024:
3025: $checkNoMemset_ $(@expr1073744353 "cppcheck-2.8/test/testclass.cpp" $, 3025 $, "class A {\n  virtual ~A() { }\n  std::string s;\n};\nint f() {\n  const int N = 10;\n  A** arr = new A*[N];\n  memset(arr, 0, N * sizeof(A*));\n}" $)
3026:
|
3032:
3033: ;
3034: $if $(@expr1073744354 $!@expr1073744355 $assertEquals $(@expr1073744356 "cppcheck-2.8/test/testclass.cpp" $, 3034 $, "" $, errout@var100 .@expr2443 str (@expr2444 ) $) $) { $return ; }
3035:
3036: $checkNoMemset_ $(@expr1073744359 "cppcheck-2.8/test/testclass.cpp" $, 3036 $, "class A {\n  std::string s;\n  struct B { int x; };\n};\nvoid f(A::B *b) {\n  memset(b,0,4);\n}" $)
3037:
|
3041:
3042: ;
3043: $if $(@expr1073744360 $!@expr1073744361 $assertEquals $(@expr1073744362 "cppcheck-2.8/test/testclass.cpp" $, 3043 $, "" $, errout@var100 .@expr2443 str (@expr2444 ) $) $) { $return ; }
3044:
3045:
3046: $checkNoMemset_ $(@expr1073744365 "cppcheck-2.8/test/testclass.cpp" $, 3046 $, "class A {\n  std::string &s;\n};\nvoid f() {\n  A a;\n  memset(&a, 0, sizeof(a));\n}" $)
3047:
|
3051:
3052: ;
3053: $if $(@expr1073744366 $!@expr1073744367 $assertEquals $(@expr1073744368 "cppcheck-2.8/test/testclass.cpp" $, 3053 $, "[test.cpp:6]: (error) Using 'memset' on class that contains a reference.\n" $, errout@var100 .@expr2443 str (@expr2444 ) $) $) { $return ; }
3054: $checkNoMemset_ $(@expr1073744371 "cppcheck-2.8/test/testclass.cpp" $, 3054 $, "class A {\n  const B&b;\n};\nvoid f() {\n  A a;\n  memset(&a, 0, sizeof(a));\n}" $)
3055:
|
3059:
3060: ;
3061: $if $(@expr1073744372 $!@expr1073744373 $assertEquals $(@expr1073744374 "cppcheck-2.8/test/testclass.cpp" $, 3061 $, "[test.cpp:6]: (error) Using 'memset' on class that contains a reference.\n" $, errout@var100 .@expr2443 str (@expr2444 ) $) $) { $return ; }
3062:
3063:
3064: $checkNoMemset_ $(@expr1073744377 "cppcheck-2.8/test/testclass.cpp" $, 3064 $, "struct A {\n  A() {}\n  virtual ~A() {}\n};\nstruct B {\n  A* arr[4];\n};\nvoid func() {\n  B b[4];\n  memset(b, 0, sizeof(b));\n}" $)
3065:
|
3073:
3074: ;
3075: $if $(@expr1073744378 $!@expr1073744379 $assertEquals $(@expr1073744380 "cppcheck-2.8/test/testclass.cpp" $, 3075 $, "" $, errout@var100 .@expr2443 str (@expr2444 ) $) $) { $return ; }
3076: }
3077:
3078: void memsetOnInvalid ( ) {
3079: $checkNoMemset_ $(@expr1073744383 "cppcheck-2.8/test/testclass.cpp" $, 3079 $, "union ASFStreamHeader {\n  struct AVMPACKED {\n    union  {\n      struct AVMPACKED {\n        int width;\n      } vid;\n    };\n  } hdr;\n};void parseHeader() {\n  ASFStreamHeader strhdr;\n  memset(&strhdr, 0, sizeof(strhdr));\n}" $)
3080:
|
3090:
3091: ;
3092: }
3093:
3094: void memsetOnStruct ( ) {
3095: $checkNoMemset_ $(@expr1073744384 "cppcheck-2.8/test/testclass.cpp" $, 3095 $, "struct A\n{\n};\nvoid f()\n{\n    A a;\n    memset(&a, 0, sizeof(A));\n}" $)
3096:
|
3101:
3102: ;
3103: $if $(@expr1073744385 $!@expr1073744386 $assertEquals $(@expr1073744387 "cppcheck-2.8/test/testclass.cpp" $, 3103 $, "" $, errout@var100 .@expr2564 str (@expr2565 ) $) $) { $return ; }
3104:
3105: $checkNoMemset_ $(@expr1073744390 "cppcheck-2.8/test/testclass.cpp" $, 3105 $, "struct A\n{\n};\nvoid f()\n{\n    struct A a;\n    memset(&a, 0, sizeof(struct A));\n}" $)
3106:
|
3111:
3112: ;
3113: $if $(@expr1073744391 $!@expr1073744392 $assertEquals $(@expr1073744393 "cppcheck-2.8/test/testclass.cpp" $, 3113 $, "" $, errout@var100 .@expr2564 str (@expr2565 ) $) $) { $return ; }
3114:
3115: $checkNoMemset_ $(@expr1073744396 "cppcheck-2.8/test/testclass.cpp" $, 3115 $, "struct A\n{\n};\nvoid f()\n{\n    struct A a;\n    memset(&a, 0, sizeof(A));\n}" $)
3116:
|
3121:
3122: ;
3123: $if $(@expr1073744397 $!@expr1073744398 $assertEquals $(@expr1073744399 "cppcheck-2.8/test/testclass.cpp" $, 3123 $, "" $, errout@var100 .@expr2564 str (@expr2565 ) $) $) { $return ; }
3124:
3125: $checkNoMemset_ $(@expr1073744402 "cppcheck-2.8/test/testclass.cpp" $, 3125 $, "void f()\n{\n    struct sockaddr_in6 fail;\n    memset(&fail, 0, sizeof(struct sockaddr_in6));\n}" $)
3126:
3127:
3128:
3129: ;
3130: $if $(@expr1073744403 $!@expr1073744404 $assertEquals $(@expr1073744405 "cppcheck-2.8/test/testclass.cpp" $, 3130 $, "" $, errout@var100 .@expr2564 str (@expr2565 ) $) $) { $return ; }
3131:
3132: $checkNoMemset_ $(@expr1073744408 "cppcheck-2.8/test/testclass.cpp" $, 3132 $, "struct A\n{\n void g( struct sockaddr_in6& a);\nprivate:\n std::string b;\n};\nvoid f()\n{\n struct A fail;\n memset(&fail, 0, sizeof(struct A));\n}" $)
3133:
|
3141:
3142: ;
3143: $if $(@expr1073744409 $!@expr1073744410 $assertEquals $(@expr1073744411 "cppcheck-2.8/test/testclass.cpp" $, 3143 $, "[test.cpp:10]: (error) Using 'memset' on struct that contains a 'std::string'.\n" $, errout@var100 .@expr2564 str (@expr2565 ) $) $) { $return ; }
3144:
3145: $checkNoMemset_ $(@expr1073744414 "cppcheck-2.8/test/testclass.cpp" $, 3145 $, "struct Fred\n{\n     std::string s;\n};\nvoid f()\n{\n    Fred fred;\n    memset(&fred, 0, sizeof(fred));\n}" $)
3146:
|
3152:
3153: ;
3154: $if $(@expr1073744415 $!@expr1073744416 $assertEquals $(@expr1073744417 "cppcheck-2.8/test/testclass.cpp" $, 3154 $, "[test.cpp:8]: (error) Using 'memset' on struct that contains a 'std::string'.\n" $, errout@var100 .@expr2564 str (@expr2565 ) $) $) { $return ; }
3155:
3156: $checkNoMemset_ $(@expr1073744420 "cppcheck-2.8/test/testclass.cpp" $, 3156 $, "struct Stringy {\n    std::string inner;\n};\nstruct Foo {\n    Stringy s;\n};\nint main() {\n    Foo foo;\n    memset(&foo, 0, sizeof(Foo));\n}" $)
3157:
|
3164:
3165: ;
3166:
3167: $if $(@expr1073744421 $!@expr1073744422 $assertEquals $(@expr1073744423 "cppcheck-2.8/test/testclass.cpp" $, 3167 $, "[test.cpp:9]: (error) Using 'memset' on struct that contains a 'std::string'.\n" $, errout@var100 .@expr2564 str (@expr2565 ) $) $) { $return ; }
3168: }
3169:
3170: void memsetVector ( ) {
3171: $checkNoMemset_ $(@expr1073744426 "cppcheck-2.8/test/testclass.cpp" $, 3171 $, "class A\n{ std::vector<int> ints; };\n\nvoid f()\n{\n    A a;\n    memset(&a, 0, sizeof(A));\n}" $)
3172:
|
3177:
3178: ;
3179: $if $(@expr1073744427 $!@expr1073744428 $assertEquals $(@expr1073744429 "cppcheck-2.8/test/testclass.cpp" $, 3179 $, "[test.cpp:7]: (error) Using 'memset' on class that contains a 'std::vector'.\n" $, errout@var100 .@expr2606 str (@expr2607 ) $) $) { $return ; }
3180:
3181: $checkNoMemset_ $(@expr1073744432 "cppcheck-2.8/test/testclass.cpp" $, 3181 $, "struct A\n{ std::vector<int> ints; };\n\nvoid f()\n{\n    A a;\n    memset(&a, 0, sizeof(A));\n}" $)
3182:
|
3187:
3188: ;
3189: $if $(@expr1073744433 $!@expr1073744434 $assertEquals $(@expr1073744435 "cppcheck-2.8/test/testclass.cpp" $, 3189 $, "[test.cpp:7]: (error) Using 'memset' on struct that contains a 'std::vector'.\n" $, errout@var100 .@expr2606 str (@expr2607 ) $) $) { $return ; }
3190:
3191: $checkNoMemset_ $(@expr1073744438 "cppcheck-2.8/test/testclass.cpp" $, 3191 $, "struct A\n{ std::vector<int> ints; };\n\nvoid f()\n{\n    A a;\n    memset(&a, 0, sizeof(struct A));\n}" $)
3192:
|
3197:
3198: ;
3199: $if $(@expr1073744439 $!@expr1073744440 $assertEquals $(@expr1073744441 "cppcheck-2.8/test/testclass.cpp" $, 3199 $, "[test.cpp:7]: (error) Using 'memset' on struct that contains a 'std::vector'.\n" $, errout@var100 .@expr2606 str (@expr2607 ) $) $) { $return ; }
3200:
3201: $checkNoMemset_ $(@expr1073744444 "cppcheck-2.8/test/testclass.cpp" $, 3201 $, "struct A\n{ std::vector<int> ints; };\n\nvoid f()\n{\n    A a;\n    memset(&a, 0, sizeof(a));\n}" $)
3202:
|
3207:
3208: ;
3209: $if $(@expr1073744445 $!@expr1073744446 $assertEquals $(@expr1073744447 "cppcheck-2.8/test/testclass.cpp" $, 3209 $, "[test.cpp:7]: (error) Using 'memset' on struct that contains a 'std::vector'.\n" $, errout@var100 .@expr2606 str (@expr2607 ) $) $) { $return ; }
3210:
3211: $checkNoMemset_ $(@expr1073744450 "cppcheck-2.8/test/testclass.cpp" $, 3211 $, "class A\n{ std::vector< std::vector<int> > ints; };\n\nvoid f()\n{\n    A a;\n    memset(&a, 0, sizeof(A));\n}" $)
3212:
|
3217:
3218: ;
3219: $if $(@expr1073744451 $!@expr1073744452 $assertEquals $(@expr1073744453 "cppcheck-2.8/test/testclass.cpp" $, 3219 $, "[test.cpp:7]: (error) Using 'memset' on class that contains a 'std::vector'.\n" $, errout@var100 .@expr2606 str (@expr2607 ) $) $) { $return ; }
3220:
3221: $checkNoMemset_ $(@expr1073744456 "cppcheck-2.8/test/testclass.cpp" $, 3221 $, "struct A\n{ std::vector< std::vector<int> > ints; };\n\nvoid f()\n{\n    A a;\n    memset(&a, 0, sizeof(A));\n}" $)
3222:
|
3227:
3228: ;
3229: $if $(@expr1073744457 $!@expr1073744458 $assertEquals $(@expr1073744459 "cppcheck-2.8/test/testclass.cpp" $, 3229 $, "[test.cpp:7]: (error) Using 'memset' on struct that contains a 'std::vector'.\n" $, errout@var100 .@expr2606 str (@expr2607 ) $) $) { $return ; }
3230:
3231: $checkNoMemset_ $(@expr1073744462 "cppcheck-2.8/test/testclass.cpp" $, 3231 $, "struct A\n{ std::vector< std::vector<int> > ints; };\n\nvoid f()\n{\n    A a;\n    memset(&a, 0, sizeof(a));\n}" $)
3232:
|
3237:
3238: ;
3239: $if $(@expr1073744463 $!@expr1073744464 $assertEquals $(@expr1073744465 "cppcheck-2.8/test/testclass.cpp" $, 3239 $, "[test.cpp:7]: (error) Using 'memset' on struct that contains a 'std::vector'.\n" $, errout@var100 .@expr2606 str (@expr2607 ) $) $) { $return ; }
3240:
3241: $checkNoMemset_ $(@expr1073744468 "cppcheck-2.8/test/testclass.cpp" $, 3241 $, "struct A\n{ std::vector<int *> ints; };\n\nvoid f()\n{\n    A a;\n    memset(&a, 0, sizeof(A));\n}" $)
3242:
|
3247:
3248: ;
3249: $if $(@expr1073744469 $!@expr1073744470 $assertEquals $(@expr1073744471 "cppcheck-2.8/test/testclass.cpp" $, 3249 $, "[test.cpp:7]: (error) Using 'memset' on struct that contains a 'std::vector'.\n" $, errout@var100 .@expr2606 str (@expr2607 ) $) $) { $return ; }
3250:
3251: $checkNoMemset_ $(@expr1073744474 "cppcheck-2.8/test/testclass.cpp" $, 3251 $, "struct A {\n     std::vector<int *> buf;\n     operator int*() {return &buf[0];}\n};\nvoid f() {\n    A a;\n    memset(a, 0, 100);\n}" $)
3252:
|
3257:
3258: ;
3259: $if $(@expr1073744475 $!@expr1073744476 $assertEquals $(@expr1073744477 "cppcheck-2.8/test/testclass.cpp" $, 3259 $, "" $, errout@var100 .@expr2606 str (@expr2607 ) $) $) { $return ; }
3260:
3261: $checkNoMemset_ $(@expr1073744480 "cppcheck-2.8/test/testclass.cpp" $, 3261 $, "struct C {\n    std::string s;\n};\nint foo() {\n    C* c1[10][10];\n    C* c2[10];\n    C c3[10][10];\n    C** c4 = new C*[10];\n    memset(**c1, 0, 10);\n    memset(*c1, 0, 10);\n    memset(*c2, 0, 10);\n    memset(*c3, 0, 10);\n    memset(*c4, 0, 10);\n    memset(c2, 0, 10);\n    memset(c3, 0, 10);\n}" $)
3262:
|
3275:
3276: ;
3277: $if $(@expr1073744481 $!@expr1073744482 $assertEquals $(@expr1073744483 "cppcheck-2.8/test/testclass.cpp" $, 3277 $, "[test.cpp:9]: (error) Using 'memset' on struct that contains a 'std::string'.\n[test.cpp:11]: (error) Using 'memset' on struct that contains a 'std::string'.\n[test.cpp:12]: (error) Using 'memset' on struct that contains a 'std::string'.\n[test.cpp:13]: (error) Using 'memset' on struct that contains a 'std::string'.\n" $, errout@var100 .@expr2606 str (@expr2607 ) $) $) { $return
3278:
3279:
3280: ; }
3281:
3282:
3283: $checkNoMemset_ $(@expr1073744486 "cppcheck-2.8/test/testclass.cpp" $, 3283 $, "typedef float realnum;\nstruct multilevel_data {\n  realnum *GammaInv;\n  realnum data[1];\n};\nvoid *new_internal_data() const {\n  multilevel_data *d = (multilevel_data *) malloc(sizeof(multilevel_data));\n  memset(d, 0, sizeof(multilevel_data));\n  return (void*) d;\n}" $)
3284:
|
3291:
3292: ;
3293: $if $(@expr1073744487 $!@expr1073744488 $assertEquals $(@expr1073744489 "cppcheck-2.8/test/testclass.cpp" $, 3293 $, "[test.cpp:8]: (portability) Using memset() on struct which contains a floating point number.\n" $, errout@var100 .@expr2606 str (@expr2607 ) $) $) { $return ; }
3294: }
3295:
3296: void memsetOnStdPodType ( ) {
3297: Settings settings@var168 ;
3298: const char xmldata@var169 [@expr1073744492 123 ] =@expr1073744493 "<?xml version=\"1.0\"?>\n<def>\n  <podtype name=\"std::uint8_t\" sign=\"u\" size=\"1\"/>\n  <podtype name=\"std::atomic_bool\"/>\n</def>"
3299:
3300:
3301:
3302: ;
3303: tinyxml2 ::@expr1073744494 XMLDocument doc@var170 ;
3304: doc@var170 .@expr1073744495 Parse (@expr1073744496 xmldata@var169 , sizeof (@expr1073744497 xmldata@var169 ) ) ;
3305: settings@var168 .@expr1073744498 library@var171 .@expr1073744499 load (@expr1073744500 doc@var170 ) ;
3306:
3307: $checkNoMemset_ $(@expr1073744501 "cppcheck-2.8/test/testclass.cpp" $, 3307 $, "class A {\n    std::array<int, 10> ints;\n};\nvoid f() {\n    A a;\n    memset(&a, 0, sizeof(A));\n}" $)
3308:
|
3312:
3313: ;
3314: $if $(@expr1073744502 $!@expr1073744503 $assertEquals $(@expr1073744504 "cppcheck-2.8/test/testclass.cpp" $, 3314 $, "" $, errout@var100 .@expr2681 str (@expr2682 ) $) $) { $return ; }
3315:
3316: $checkNoMemset_ $(@expr1073744507 "cppcheck-2.8/test/testclass.cpp" $, 3316 $, "struct st {\n  std::uint8_t a;\n  std::atomic_bool b;\n};\n\nvoid f() {\n  st s;\n  std::memset(&s, 0, sizeof(st));\n}" , settings@var168 $)
3317:
|
3323:
3324: ;
3325: $if $(@expr1073744508 $!@expr1073744509 $assertEquals $(@expr1073744510 "cppcheck-2.8/test/testclass.cpp" $, 3325 $, "" $, errout@var100 .@expr2681 str (@expr2682 ) $) $) { $return ; }
3326: }
3327:
3328: void memsetOnFloat ( ) {
3329: $checkNoMemset_ $(@expr1073744513 "cppcheck-2.8/test/testclass.cpp" $, 3329 $, "struct A {\n    float f;\n};\nvoid f() {\n    A a;\n    memset(&a, 0, sizeof(A));\n}" $)
3330:
|
3334:
3335: ;
3336: $if $(@expr1073744514 $!@expr1073744515 $assertEquals $(@expr1073744516 "cppcheck-2.8/test/testclass.cpp" $, 3336 $, "[test.cpp:6]: (portability) Using memset() on struct which contains a floating point number.\n" $, errout@var100 .@expr2693 str (@expr2694 ) $) $) { $return ; }
3337:
3338: $checkNoMemset_ $(@expr1073744519 "cppcheck-2.8/test/testclass.cpp" $, 3338 $, "struct A {\n    float f[4];\n};\nvoid f() {\n    A a;\n    memset(&a, 0, sizeof(A));\n}" $)
3339:
|
3343:
3344: ;
3345: $if $(@expr1073744520 $!@expr1073744521 $assertEquals $(@expr1073744522 "cppcheck-2.8/test/testclass.cpp" $, 3345 $, "[test.cpp:6]: (portability) Using memset() on struct which contains a floating point number.\n" $, errout@var100 .@expr2693 str (@expr2694 ) $) $) { $return ; }
3346:
3347: $checkNoMemset_ $(@expr1073744525 "cppcheck-2.8/test/testclass.cpp" $, 3347 $, "struct A {\n    float f[4];\n};\nvoid f(const A& b) {\n    A a;\n    memcpy(&a, &b, sizeof(A));\n}" $)
3348:
|
3352:
3353: ;
3354: $if $(@expr1073744526 $!@expr1073744527 $assertEquals $(@expr1073744528 "cppcheck-2.8/test/testclass.cpp" $, 3354 $, "" $, errout@var100 .@expr2693 str (@expr2694 ) $) $) { $return ; }
3355:
3356: $checkNoMemset_ $(@expr1073744531 "cppcheck-2.8/test/testclass.cpp" $, 3356 $, "struct A {\n    float* f;\n};\nvoid f() {\n    A a;\n    memset(&a, 0, sizeof(A));\n}" $)
3357:
|
3361:
3362: ;
3363: $if $(@expr1073744532 $!@expr1073744533 $assertEquals $(@expr1073744534 "cppcheck-2.8/test/testclass.cpp" $, 3363 $, "" $, errout@var100 .@expr2693 str (@expr2694 ) $) $) { $return ; }
3364: }
3365:
3366: void memsetOnUnknown ( ) {
3367: $checkNoMemset_ $(@expr1073744537 "cppcheck-2.8/test/testclass.cpp" $, 3367 $, "void clang_tokenize(CXToken **Tokens) {\n  *Tokens = (CXToken *)malloc(sizeof(CXToken) * CXTokens.size());\n  memmove(*Tokens, CXTokens.data(), sizeof(CXToken) * CXTokens.size());\n}" $)
3368:
3369:
3370: ;
3371: $if $(@expr1073744538 $!@expr1073744539 $assertEquals $(@expr1073744540 "cppcheck-2.8/test/testclass.cpp" $, 3371 $, "" $, errout@var100 .@expr1073744541 str (@expr1073744542 ) $) $) { $return ; }
3372: }
3373:
3374: void mallocOnClass ( ) {
3375: $checkNoMemset_ $(@expr1073744543 "cppcheck-2.8/test/testclass.cpp" $, 3375 $, "class C { C() {} };\nvoid foo(C*& p) {\n    p = malloc(sizeof(C));\n}" $)
3376:
3377:
3378: ;
3379: $if $(@expr1073744544 $!@expr1073744545 $assertEquals $(@expr1073744546 "cppcheck-2.8/test/testclass.cpp" $, 3379 $, "[test.cpp:3] -> [test.cpp:1]: (warning) Memory for class instance allocated with malloc(), but class provides constructors.\n" $, errout@var100 .@expr2723 str (@expr2724 ) $) $) { $return ; }
3380:
3381: $checkNoMemset_ $(@expr1073744549 "cppcheck-2.8/test/testclass.cpp" $, 3381 $, "class C { C(int z, Foo bar) { bar(); } };\nvoid foo(C*& p) {\n    p = malloc(sizeof(C));\n}" $)
3382:
3383:
3384: ;
3385: $if $(@expr1073744550 $!@expr1073744551 $assertEquals $(@expr1073744552 "cppcheck-2.8/test/testclass.cpp" $, 3385 $, "[test.cpp:3] -> [test.cpp:1]: (warning) Memory for class instance allocated with malloc(), but class provides constructors.\n" $, errout@var100 .@expr2723 str (@expr2724 ) $) $) { $return ; }
3386:
3387: $checkNoMemset_ $(@expr1073744555 "cppcheck-2.8/test/testclass.cpp" $, 3387 $, "struct C { C() {} };\nvoid foo(C*& p) {\n    p = realloc(p, sizeof(C));\n}" $)
3388:
3389:
3390: ;
3391: $if $(@expr1073744556 $!@expr1073744557 $assertEquals $(@expr1073744558 "cppcheck-2.8/test/testclass.cpp" $, 3391 $, "[test.cpp:3] -> [test.cpp:1]: (warning) Memory for class instance allocated with realloc(), but class provides constructors.\n" $, errout@var100 .@expr2723 str (@expr2724 ) $) $) { $return ; }
3392:
3393: $checkNoMemset_ $(@expr1073744561 "cppcheck-2.8/test/testclass.cpp" $, 3393 $, "struct C { virtual void bar(); };\nvoid foo(C*& p) {\n    p = malloc(sizeof(C));\n}" $)
3394:
3395:
3396: ;
3397: $if $(@expr1073744562 $!@expr1073744563 $assertEquals $(@expr1073744564 "cppcheck-2.8/test/testclass.cpp" $, 3397 $, "[test.cpp:3] -> [test.cpp:1]: (error) Memory for class instance allocated with malloc(), but class contains a virtual function.\n" $, errout@var100 .@expr2723 str (@expr2724 ) $) $) { $return ; }
3398:
3399: $checkNoMemset_ $(@expr1073744567 "cppcheck-2.8/test/testclass.cpp" $, 3399 $, "struct C { std::string s; };\nvoid foo(C*& p) {\n    p = malloc(sizeof(C));\n}" $)
3400:
3401:
3402: ;
3403: $if $(@expr1073744568 $!@expr1073744569 $assertEquals $(@expr1073744570 "cppcheck-2.8/test/testclass.cpp" $, 3403 $, "[test.cpp:3] -> [test.cpp:1]: (error) Memory for class instance allocated with malloc(), but class contains a 'std::string'.\n" $, errout@var100 .@expr2723 str (@expr2724 ) $) $) { $return ; }
3404:
3405: $checkNoMemset_ $(@expr1073744573 "cppcheck-2.8/test/testclass.cpp" $, 3405 $, "class C { };\nvoid foo(C*& p) {\n    p = malloc(sizeof(C));\n}" $)
3406:
3407:
3408: ;
3409: $if $(@expr1073744574 $!@expr1073744575 $assertEquals $(@expr1073744576 "cppcheck-2.8/test/testclass.cpp" $, 3409 $, "" $, errout@var100 .@expr2723 str (@expr2724 ) $) $) { $return ; }
3410:
3411: $checkNoMemset_ $(@expr1073744579 "cppcheck-2.8/test/testclass.cpp" $, 3411 $, "struct C { C() {} };\nvoid foo(C*& p) {\n    p = new C();\n}" $)
3412:
3413:
3414: ;
3415: $if $(@expr1073744580 $!@expr1073744581 $assertEquals $(@expr1073744582 "cppcheck-2.8/test/testclass.cpp" $, 3415 $, "" $, errout@var100 .@expr2723 str (@expr2724 ) $) $) { $return ; }
3416:
3417: $checkNoMemset_ $(@expr1073744585 "cppcheck-2.8/test/testclass.cpp" $, 3417 $, "class C { C() {} };\nvoid foo(D*& p) {\n    p = malloc(sizeof(C));\n}" $)
3418:
3419:
3420: ;
3421: $if $(@expr1073744586 $!@expr1073744587 $assertEquals $(@expr1073744588 "cppcheck-2.8/test/testclass.cpp" $, 3421 $, "" $, errout@var100 .@expr2723 str (@expr2724 ) $) $) { $return ; }
3422: }
3423:
3424:
3425: void checkThisSubtraction_ ( const char code@var172 [ ] , const char * file@var173 , int line@var174 ) {
3426:
3427: errout@var100 .@expr1073744591 str (@expr1073744592 "" ) ;
3428:
3429:
3430: Tokenizer tokenizer@var175 (@expr1073744593 &@expr2770 settings1@var103 , this@expr2771 ) ;
3431: std ::@expr1073744596 istringstream istr@var176 (@expr1073744597 code@var172 ) ;
3432: $assert_ $(@expr1073744598 file@var173 $, line@var174 $, $(@expr1073744599 tokenizer@var175 .@expr1073744600 tokenize (@expr1073744601 istr@var176 , "test.cpp" ) $) $) ;
3433:
3434:
3435: CheckClass checkClass@var177 (@expr1073744602 &@expr1073744603 tokenizer@var175 , &@expr2770 settings1@var103 , this@expr2771 ) ;
3436: checkClass@var177 .@expr1073744605 thisSubtraction (@expr1073744606 ) ;
3437: }
3438:
3439: void this_subtraction ( ) {
3440: $checkThisSubtraction_ $(@expr1073744607 "; this-x ;" $, "cppcheck-2.8/test/testclass.cpp" $, 3440 $) ;
3441: $if $(@expr1073744608 $!@expr1073744609 $assertEquals $(@expr1073744610 "cppcheck-2.8/test/testclass.cpp" $, 3441 $, "[test.cpp:1]: (warning) Suspicious pointer subtraction. Did you intend to write '->'?\n" $, errout@var100 .@expr2787 str (@expr2788 ) $) $) { $return ; }
3442:
3443: $checkThisSubtraction_ $(@expr1073744613 "; *this = *this-x ;" $, "cppcheck-2.8/test/testclass.cpp" $, 3443 $) ;
3444: $if $(@expr1073744614 $!@expr1073744615 $assertEquals $(@expr1073744616 "cppcheck-2.8/test/testclass.cpp" $, 3444 $, "" $, errout@var100 .@expr2787 str (@expr2788 ) $) $) { $return ; }
3445:
3446: $checkThisSubtraction_ $(@expr1073744619 "; *this = *this-x ;\nthis-x ;" $, "cppcheck-2.8/test/testclass.cpp" $, 3446 $)
3447: ;
3448: $if $(@expr1073744620 $!@expr1073744621 $assertEquals $(@expr1073744622 "cppcheck-2.8/test/testclass.cpp" $, 3448 $, "[test.cpp:2]: (warning) Suspicious pointer subtraction. Did you intend to write '->'?\n" $, errout@var100 .@expr2787 str (@expr2788 ) $) $) { $return ; }
3449:
3450: $checkThisSubtraction_ $(@expr1073744625 "; *this = *this-x ;\nthis-x ;\nthis-x ;" $, "cppcheck-2.8/test/testclass.cpp" $, 3450 $)
3451:
3452: ;
3453: $if $(@expr1073744626 $!@expr1073744627 $assertEquals $(@expr1073744628 "cppcheck-2.8/test/testclass.cpp" $, 3453 $, "[test.cpp:2]: (warning) Suspicious pointer subtraction. Did you intend to write '->'?\n[test.cpp:3]: (warning) Suspicious pointer subtraction. Did you intend to write '->'?\n" $, errout@var100 .@expr2787 str (@expr2788 ) $) $) { $return
3454: ; }
3455: }
3456:
3457:
3458: void checkConst_ ( const char * file@var178 , int line@var179 , const char code@var180 [ ] , Settings * s@var181 = nullptr , bool inconclusive@var182 = true ) {
3459:
3460: errout@var100 .@expr1073744632 str (@expr1073744633 "" ) ;
3461:
3462:
3463: if (@expr1073744634 !@expr1073744635 s@var181 ) {
3464: s@var181 =@expr1073744636 &@expr1073744637 settings0@var102 ; }
3465: s@var181 .@expr1073744638 certainty@var183 .@expr1073744639 setEnabled (@expr1073744640 Certainty ::@expr1073744641 inconclusive@expr1073744631 , inconclusive@var182 ) ;
3466:
3467:
3468: Tokenizer tokenizer@var184 (@expr1073744642 s@var181 , this@expr2819 ) ;
3469: std ::@expr1073744644 istringstream istr@var185 (@expr1073744645 code@var180 ) ;
3470: $assert_ $(@expr1073744646 file@var178 $, line@var179 $, $(@expr1073744647 tokenizer@var184 .@expr1073744648 tokenize (@expr1073744649 istr@var185 , "test.cpp" ) $) $) ;
3471:
3472: CheckClass checkClass@var186 (@expr1073744650 &@expr1073744651 tokenizer@var184 , s@var181 , this@expr2819 ) ;
3473: checkClass@var186 .@expr1073744652 checkConst (@expr1073744653 ) ;
3474: }
3475:
3476: void const1 ( ) {
3477: $checkConst_ $(@expr1073744654 "cppcheck-2.8/test/testclass.cpp" $, 3477 $, "class Fred {\n    int a;\n    int getA() { return a; }\n};" $)
3478:
3479:
3480: ;
3481: $if $(@expr1073744655 $!@expr1073744656 $assertEquals $(@expr1073744657 "cppcheck-2.8/test/testclass.cpp" $, 3481 $, "[test.cpp:3]: (style, inconclusive) Technically the member function 'Fred::getA' can be const.\n" $, errout@var100 .@expr2834 str (@expr2835 ) $) $) { $return ; }
3482:
3483: $checkConst_ $(@expr1073744660 "cppcheck-2.8/test/testclass.cpp" $, 3483 $, "class Fred {\n    const std::string foo() { return \"\"; }\n};" $)
3484:
3485: ;
3486: $if $(@expr1073744661 $!@expr1073744662 $assertEquals $(@expr1073744663 "cppcheck-2.8/test/testclass.cpp" $, 3486 $, "[test.cpp:2]: (performance, inconclusive) Technically the member function 'Fred::foo' can be static (but you may consider moving to unnamed namespace).\n" $, errout@var100 .@expr2834 str (@expr2835 ) $) $) { $return ; }
3487:
3488: $checkConst_ $(@expr1073744666 "cppcheck-2.8/test/testclass.cpp" $, 3488 $, "class Fred {\n    std::string s;\n    const std::string & foo() { return \"\"; }\n};" $)
3489:
3490:
3491: ;
3492: $if $(@expr1073744667 $!@expr1073744668 $assertEquals $(@expr1073744669 "cppcheck-2.8/test/testclass.cpp" $, 3492 $, "[test.cpp:3]: (performance, inconclusive) Technically the member function 'Fred::foo' can be static (but you may consider moving to unnamed namespace).\n" $, errout@var100 .@expr2834 str (@expr2835 ) $) $) { $return ; }
3493:
3494:
3495: $checkConst_ $(@expr1073744672 "cppcheck-2.8/test/testclass.cpp" $, 3495 $, "class Fred {\n    int a;\npublic:\n    Fred() { }\n};" $)
3496:
3497:
3498:
3499: ;
3500: $if $(@expr1073744673 $!@expr1073744674 $assertEquals $(@expr1073744675 "cppcheck-2.8/test/testclass.cpp" $, 3500 $, "" $, errout@var100 .@expr2834 str (@expr2835 ) $) $) { $return ; }
3501:
3502:
3503: $checkConst_ $(@expr1073744678 "cppcheck-2.8/test/testclass.cpp" $, 3503 $, "class Fred {\n    int a;\n    int setA() { a |= true; }\n};" $)
3504:
3505:
3506: ;
3507: $if $(@expr1073744679 $!@expr1073744680 $assertEquals $(@expr1073744681 "cppcheck-2.8/test/testclass.cpp" $, 3507 $, "" $, errout@var100 .@expr2834 str (@expr2835 ) $) $) { $return ; }
3508:
3509:
3510: $checkConst_ $(@expr1073744684 "cppcheck-2.8/test/testclass.cpp" $, 3510 $, "class foo {\npublic:\n    int x;\n    void a() { x = 1; }\n    void b() { a(); }\n};" $)
3511:
|
3514:
3515: ;
3516: $if $(@expr1073744685 $!@expr1073744686 $assertEquals $(@expr1073744687 "cppcheck-2.8/test/testclass.cpp" $, 3516 $, "" $, errout@var100 .@expr2834 str (@expr2835 ) $) $) { $return ; }
3517:
3518: $checkConst_ $(@expr1073744690 "cppcheck-2.8/test/testclass.cpp" $, 3518 $, "class Fred {\npublic:\n    int x;\n    int a() const { return x; }\n    void b() { a(); }\n};" $)
3519:
|
3522:
3523: ;
3524: $if $(@expr1073744691 $!@expr1073744692 $assertEquals $(@expr1073744693 "cppcheck-2.8/test/testclass.cpp" $, 3524 $, "[test.cpp:5]: (style, inconclusive) Technically the member function 'Fred::b' can be const.\n" $, errout@var100 .@expr2834 str (@expr2835 ) $) $) { $return ; }
3525:
3526: $checkConst_ $(@expr1073744696 "cppcheck-2.8/test/testclass.cpp" $, 3526 $, "class Fred {\npublic:\n    int x;\n    void b() { a(); }\n};" $)
3527:
3528:
3529:
3530: ;
3531: $if $(@expr1073744697 $!@expr1073744698 $assertEquals $(@expr1073744699 "cppcheck-2.8/test/testclass.cpp" $, 3531 $, "[test.cpp:4]: (performance, inconclusive) Technically the member function 'Fred::b' can be static (but you may consider moving to unnamed namespace).\n" $, errout@var100 .@expr2834 str (@expr2835 ) $) $) { $return ; }
3532:
3533:
3534: $checkConst_ $(@expr1073744702 "cppcheck-2.8/test/testclass.cpp" $, 3534 $, "class foo\n{\npublic:\n    static unsigned get()\n    { return 0; }\n};" $)
3535:
|
3538:
3539: ;
3540: $if $(@expr1073744703 $!@expr1073744704 $assertEquals $(@expr1073744705 "cppcheck-2.8/test/testclass.cpp" $, 3540 $, "" $, errout@var100 .@expr2834 str (@expr2835 ) $) $) { $return ; }
3541:
3542: $checkConst_ $(@expr1073744708 "cppcheck-2.8/test/testclass.cpp" $, 3542 $, "class Fred {\n    const std::string foo() const throw() { return \"\"; }\n};" $)
3543:
3544: ;
3545: $if $(@expr1073744709 $!@expr1073744710 $assertEquals $(@expr1073744711 "cppcheck-2.8/test/testclass.cpp" $, 3545 $, "[test.cpp:2]: (performance, inconclusive) Technically the member function 'Fred::foo' can be static (but you may consider moving to unnamed namespace).\n" $, errout@var100 .@expr2834 str (@expr2835 ) $) $) { $return ; }
3546: }
3547:
3548: void const2 ( ) {
3549:
3550:
3551: $checkConst_ $(@expr1073744714 "cppcheck-2.8/test/testclass.cpp" $, 3551 $, "class Fred {\n    std::string s;\n    void foo() { s = \"\"; }\n};" $)
3552:
3553:
3554: ;
3555: $if $(@expr1073744715 $!@expr1073744716 $assertEquals $(@expr1073744717 "cppcheck-2.8/test/testclass.cpp" $, 3555 $, "" $, errout@var100 .@expr2894 str (@expr2895 ) $) $) { $return ; }
3556:
3557:
3558: $checkConst_ $(@expr1073744720 "cppcheck-2.8/test/testclass.cpp" $, 3558 $, "class Fred {\n    std::string s;\n    void foo(std::string & a) { a = s; }\n};" $)
3559:
3560:
3561: ;
3562: $if $(@expr1073744721 $!@expr1073744722 $assertEquals $(@expr1073744723 "cppcheck-2.8/test/testclass.cpp" $, 3562 $, "[test.cpp:3]: (style, inconclusive) Technically the member function 'Fred::foo' can be const.\n" $, errout@var100 .@expr2894 str (@expr2895 ) $) $) { $return ; }
3563:
3564:
3565: $checkConst_ $(@expr1073744726 "cppcheck-2.8/test/testclass.cpp" $, 3565 $, "class Fred {\n    std::string s;\n    void foo(std::string & a) { s = a; }\n};" $)
3566:
3567:
3568: ;
3569: $if $(@expr1073744727 $!@expr1073744728 $assertEquals $(@expr1073744729 "cppcheck-2.8/test/testclass.cpp" $, 3569 $, "" $, errout@var100 .@expr2894 str (@expr2895 ) $) $) { $return ; }
3570:
3571:
3572: $checkConst_ $(@expr1073744732 "cppcheck-2.8/test/testclass.cpp" $, 3572 $, "class Fred {\n    std::string s;\n    void foo(std::string & a, std::string & b) { a = s; b = s; }\n};" $)
3573:
3574:
3575: ;
3576: $if $(@expr1073744733 $!@expr1073744734 $assertEquals $(@expr1073744735 "cppcheck-2.8/test/testclass.cpp" $, 3576 $, "[test.cpp:3]: (style, inconclusive) Technically the member function 'Fred::foo' can be const.\n" $, errout@var100 .@expr2894 str (@expr2895 ) $) $) { $return ; }
3577:
3578:
3579: $checkConst_ $(@expr1073744738 "cppcheck-2.8/test/testclass.cpp" $, 3579 $, "class Fred {\n    std::string s;\n    void foo(std::string & a, std::string & b) { s = a; s = b; }\n};" $)
3580:
3581:
3582: ;
3583: $if $(@expr1073744739 $!@expr1073744740 $assertEquals $(@expr1073744741 "cppcheck-2.8/test/testclass.cpp" $, 3583 $, "" $, errout@var100 .@expr2894 str (@expr2895 ) $) $) { $return ; }
3584:
3585:
3586: $checkConst_ $(@expr1073744744 "cppcheck-2.8/test/testclass.cpp" $, 3586 $, "class Fred {\n    std::string s;\n    void foo(std::string & a, std::string & b) { s = a; b = a; }\n};" $)
3587:
3588:
3589: ;
3590: $if $(@expr1073744745 $!@expr1073744746 $assertEquals $(@expr1073744747 "cppcheck-2.8/test/testclass.cpp" $, 3590 $, "" $, errout@var100 .@expr2894 str (@expr2895 ) $) $) { $return ; }
3591:
3592:
3593: $checkConst_ $(@expr1073744750 "cppcheck-2.8/test/testclass.cpp" $, 3593 $, "class Fred {\n    std::string s;\n    void foo(std::string & a, std::string & b) { a = s; s = b; }\n};" $)
3594:
3595:
3596: ;
3597: $if $(@expr1073744751 $!@expr1073744752 $assertEquals $(@expr1073744753 "cppcheck-2.8/test/testclass.cpp" $, 3597 $, "" $, errout@var100 .@expr2894 str (@expr2895 ) $) $) { $return ; }
3598: }
3599:
3600: void const3 ( ) {
3601:
3602: $checkConst_ $(@expr1073744756 "cppcheck-2.8/test/testclass.cpp" $, 3602 $, "class Fred {\n    int s;\n    void foo(int * a) { *a = s; }\n};" $)
3603:
3604:
3605: ;
3606: $if $(@expr1073744757 $!@expr1073744758 $assertEquals $(@expr1073744759 "cppcheck-2.8/test/testclass.cpp" $, 3606 $, "[test.cpp:3]: (style, inconclusive) Technically the member function 'Fred::foo' can be const.\n" $, errout@var100 .@expr2936 str (@expr2937 ) $) $) { $return ; }
3607:
3608:
3609: $checkConst_ $(@expr1073744762 "cppcheck-2.8/test/testclass.cpp" $, 3609 $, "class Fred {\n    int s;\n    void foo(int * a) { s = *a; }\n};" $)
3610:
3611:
3612: ;
3613: $if $(@expr1073744763 $!@expr1073744764 $assertEquals $(@expr1073744765 "cppcheck-2.8/test/testclass.cpp" $, 3613 $, "" $, errout@var100 .@expr2936 str (@expr2937 ) $) $) { $return ; }
3614:
3615:
3616: $checkConst_ $(@expr1073744768 "cppcheck-2.8/test/testclass.cpp" $, 3616 $, "class Fred {\n    std::string s;\n    void foo(std::string * a, std::string * b) { *a = s; *b = s; }\n};" $)
3617:
3618:
3619: ;
3620: $if $(@expr1073744769 $!@expr1073744770 $assertEquals $(@expr1073744771 "cppcheck-2.8/test/testclass.cpp" $, 3620 $, "[test.cpp:3]: (style, inconclusive) Technically the member function 'Fred::foo' can be const.\n" $, errout@var100 .@expr2936 str (@expr2937 ) $) $) { $return ; }
3621:
3622:
3623: $checkConst_ $(@expr1073744774 "cppcheck-2.8/test/testclass.cpp" $, 3623 $, "class Fred {\n    std::string s;\n    void foo(std::string * a, std::string * b) { s = *a; s = *b; }\n};" $)
3624:
3625:
3626: ;
3627: $if $(@expr1073744775 $!@expr1073744776 $assertEquals $(@expr1073744777 "cppcheck-2.8/test/testclass.cpp" $, 3627 $, "" $, errout@var100 .@expr2936 str (@expr2937 ) $) $) { $return ; }
3628:
3629:
3630: $checkConst_ $(@expr1073744780 "cppcheck-2.8/test/testclass.cpp" $, 3630 $, "class Fred {\n    std::string s;\n    void foo(std::string * a, std::string * b) { s = *a; *b = s; }\n};" $)
3631:
3632:
3633: ;
3634: $if $(@expr1073744781 $!@expr1073744782 $assertEquals $(@expr1073744783 "cppcheck-2.8/test/testclass.cpp" $, 3634 $, "" $, errout@var100 .@expr2936 str (@expr2937 ) $) $) { $return ; }
3635:
3636:
3637: $checkConst_ $(@expr1073744786 "cppcheck-2.8/test/testclass.cpp" $, 3637 $, "class Fred {\n    std::string s;\n    void foo(std::string * a, std::string * b) { *a = s; s = b; }\n};" $)
3638:
3639:
3640: ;
3641: $if $(@expr1073744787 $!@expr1073744788 $assertEquals $(@expr1073744789 "cppcheck-2.8/test/testclass.cpp" $, 3641 $, "" $, errout@var100 .@expr2936 str (@expr2937 ) $) $) { $return ; }
3642: }
3643:
3644: void const4 ( ) {
3645: $checkConst_ $(@expr1073744792 "cppcheck-2.8/test/testclass.cpp" $, 3645 $, "class Fred {\n    int a;\n    int getA();\n};\nint Fred::getA() { return a; }" $)
3646:
3647:
3648:
3649: ;
3650: $if $(@expr1073744793 $!@expr1073744794 $assertEquals $(@expr1073744795 "cppcheck-2.8/test/testclass.cpp" $, 3650 $, "[test.cpp:5] -> [test.cpp:3]: (style, inconclusive) Technically the member function 'Fred::getA' can be const.\n" $, errout@var100 .@expr2972 str (@expr2973 ) $) $) { $return ; }
3651:
3652: $checkConst_ $(@expr1073744798 "cppcheck-2.8/test/testclass.cpp" $, 3652 $, "class Fred {\n    std::string s;\n    const std::string & foo();\n};\nconst std::string & Fred::foo() { return \"\"; }" $)
3653:
3654:
3655:
3656: ;
3657: $if $(@expr1073744799 $!@expr1073744800 $assertEquals $(@expr1073744801 "cppcheck-2.8/test/testclass.cpp" $, 3657 $, "[test.cpp:5] -> [test.cpp:3]: (performance, inconclusive) Technically the member function 'Fred::foo' can be static (but you may consider moving to unnamed namespace).\n" $, errout@var100 .@expr2972 str (@expr2973 ) $) $) { $return ; }
3658:
3659:
3660: $checkConst_ $(@expr1073744804 "cppcheck-2.8/test/testclass.cpp" $, 3660 $, "class Fred\n{\npublic:\n    int x;\n    void a() { x = 1; }\n    void b();\n};\nvoid Fred::b() { a(); }" $)
3661:
|
3666:
3667: ;
3668: $if $(@expr1073744805 $!@expr1073744806 $assertEquals $(@expr1073744807 "cppcheck-2.8/test/testclass.cpp" $, 3668 $, "" $, errout@var100 .@expr2972 str (@expr2973 ) $) $) { $return ; }
3669:
3670:
3671: $checkConst_ $(@expr1073744810 "cppcheck-2.8/test/testclass.cpp" $, 3671 $, "class Fred\n{\npublic:\n    static unsigned get();\n};\nstatic unsigned Fred::get() { return 0; }" $)
3672:
|
3675:
3676: ;
3677: $if $(@expr1073744811 $!@expr1073744812 $assertEquals $(@expr1073744813 "cppcheck-2.8/test/testclass.cpp" $, 3677 $, "" $, errout@var100 .@expr2972 str (@expr2973 ) $) $) { $return ; }
3678:
3679:
3680: $checkConst_ $(@expr1073744816 "cppcheck-2.8/test/testclass.cpp" $, 3680 $, "class Fred {\n    std::string s;\n    void foo();\n};\nvoid Fred::foo() { s = \"\"; }" $)
3681:
3682:
3683:
3684: ;
3685: $if $(@expr1073744817 $!@expr1073744818 $assertEquals $(@expr1073744819 "cppcheck-2.8/test/testclass.cpp" $, 3685 $, "" $, errout@var100 .@expr2972 str (@expr2973 ) $) $) { $return ; }
3686:
3687:
3688: $checkConst_ $(@expr1073744822 "cppcheck-2.8/test/testclass.cpp" $, 3688 $, "class Fred {\n    std::string s;\n    void foo(std::string & a);\n};\nvoid Fred::foo(std::string & a) { a = s; }" $)
3689:
3690:
3691:
3692: ;
3693: $if $(@expr1073744823 $!@expr1073744824 $assertEquals $(@expr1073744825 "cppcheck-2.8/test/testclass.cpp" $, 3693 $, "[test.cpp:5] -> [test.cpp:3]: (style, inconclusive) Technically the member function 'Fred::foo' can be const.\n" $, errout@var100 .@expr2972 str (@expr2973 ) $) $) { $return ; }
3694:
3695:
3696: $checkConst_ $(@expr1073744828 "cppcheck-2.8/test/testclass.cpp" $, 3696 $, "class Fred {\n    std::string s;\n    void foo(std::string & a);\n};\nvoid Fred::foo(std::string & a) { s = a; }" $)
3697:
3698:
3699:
3700: ;
3701: $if $(@expr1073744829 $!@expr1073744830 $assertEquals $(@expr1073744831 "cppcheck-2.8/test/testclass.cpp" $, 3701 $, "" $, errout@var100 .@expr2972 str (@expr2973 ) $) $) { $return ; }
3702:
3703:
3704: $checkConst_ $(@expr1073744834 "cppcheck-2.8/test/testclass.cpp" $, 3704 $, "class Fred {\n    std::string s;\n    void foo(std::string & a, std::string & b);\n};\nvoid Fred::foo(std::string & a, std::string & b) { a = s; b = s; }" $)
3705:
3706:
3707:
3708: ;
3709: $if $(@expr1073744835 $!@expr1073744836 $assertEquals $(@expr1073744837 "cppcheck-2.8/test/testclass.cpp" $, 3709 $, "[test.cpp:5] -> [test.cpp:3]: (style, inconclusive) Technically the member function 'Fred::foo' can be const.\n" $, errout@var100 .@expr2972 str (@expr2973 ) $) $) { $return ; }
3710:
3711:
3712: $checkConst_ $(@expr1073744840 "cppcheck-2.8/test/testclass.cpp" $, 3712 $, "class Fred {\n    std::string s;\n    void foo(std::string & a, std::string & b);\n};\nvoid Fred::foo(std::string & a, std::string & b) { s = a; s = b; }" $)
3713:
3714:
3715:
3716: ;
3717: $if $(@expr1073744841 $!@expr1073744842 $assertEquals $(@expr1073744843 "cppcheck-2.8/test/testclass.cpp" $, 3717 $, "" $, errout@var100 .@expr2972 str (@expr2973 ) $) $) { $return ; }
3718:
3719:
3720: $checkConst_ $(@expr1073744846 "cppcheck-2.8/test/testclass.cpp" $, 3720 $, "class Fred {\n    std::string s;\n    void foo(std::string & a, std::string & b);\n};\nvoid Fred::foo(std::string & a, std::string & b) { s = a; b = a; }" $)
3721:
3722:
3723:
3724: ;
3725: $if $(@expr1073744847 $!@expr1073744848 $assertEquals $(@expr1073744849 "cppcheck-2.8/test/testclass.cpp" $, 3725 $, "" $, errout@var100 .@expr2972 str (@expr2973 ) $) $) { $return ; }
3726:
3727:
3728: $checkConst_ $(@expr1073744852 "cppcheck-2.8/test/testclass.cpp" $, 3728 $, "class Fred {\n    std::string s;\n    void foo(std::string & a, std::string & b);\n};\nvoid Fred::foo(std::string & a, std::string & b) { a = s; s = b; }" $)
3729:
3730:
3731:
3732: ;
3733: $if $(@expr1073744853 $!@expr1073744854 $assertEquals $(@expr1073744855 "cppcheck-2.8/test/testclass.cpp" $, 3733 $, "" $, errout@var100 .@expr2972 str (@expr2973 ) $) $) { $return ; }
3734:
3735:
3736: $checkConst_ $(@expr1073744858 "cppcheck-2.8/test/testclass.cpp" $, 3736 $, "class Fred {\n    int s;\n    void foo(int * a);\n};\nvoid Fred::foo(int * a) { *a = s; }" $)
3737:
3738:
3739:
3740: ;
3741: $if $(@expr1073744859 $!@expr1073744860 $assertEquals $(@expr1073744861 "cppcheck-2.8/test/testclass.cpp" $, 3741 $, "[test.cpp:5] -> [test.cpp:3]: (style, inconclusive) Technically the member function 'Fred::foo' can be const.\n" $, errout@var100 .@expr2972 str (@expr2973 ) $) $) { $return ; }
3742:
3743:
3744: $checkConst_ $(@expr1073744864 "cppcheck-2.8/test/testclass.cpp" $, 3744 $, "class Fred {\n    int s;\n    void foo(int * a);\n};\nvoid Fred::foo(int * a) { s = *a; }" $)
3745:
3746:
3747:
3748: ;
3749: $if $(@expr1073744865 $!@expr1073744866 $assertEquals $(@expr1073744867 "cppcheck-2.8/test/testclass.cpp" $, 3749 $, "" $, errout@var100 .@expr2972 str (@expr2973 ) $) $) { $return ; }
3750:
3751:
3752: $checkConst_ $(@expr1073744870 "cppcheck-2.8/test/testclass.cpp" $, 3752 $, "class Fred {\n    std::string s;\n    void foo(std::string * a, std::string * b);\n};\nvoid Fred::foo(std::string * a, std::string * b) { *a = s; *b = s; }" $)
3753:
3754:
3755:
3756: ;
3757: $if $(@expr1073744871 $!@expr1073744872 $assertEquals $(@expr1073744873 "cppcheck-2.8/test/testclass.cpp" $, 3757 $, "[test.cpp:5] -> [test.cpp:3]: (style, inconclusive) Technically the member function 'Fred::foo' can be const.\n" $, errout@var100 .@expr2972 str (@expr2973 ) $) $) { $return ; }
3758:
3759:
3760: $checkConst_ $(@expr1073744876 "cppcheck-2.8/test/testclass.cpp" $, 3760 $, "class Fred {\n    std::string s;\n    void foo(std::string * a, std::string * b);\n};\nvoid Fred::foo(std::string * a, std::string * b) { s = *a; s = *b; }" $)
3761:
3762:
3763:
3764: ;
3765: $if $(@expr1073744877 $!@expr1073744878 $assertEquals $(@expr1073744879 "cppcheck-2.8/test/testclass.cpp" $, 3765 $, "" $, errout@var100 .@expr2972 str (@expr2973 ) $) $) { $return ; }
3766:
3767:
3768: $checkConst_ $(@expr1073744882 "cppcheck-2.8/test/testclass.cpp" $, 3768 $, "class Fred {\n    std::string s;\n    void foo(std::string * a, std::string * b);\n};\nvoid Fred::foo(std::string * a, std::string * b) { s = *a; *b = s; }" $)
3769:
3770:
3771:
3772: ;
3773: $if $(@expr1073744883 $!@expr1073744884 $assertEquals $(@expr1073744885 "cppcheck-2.8/test/testclass.cpp" $, 3773 $, "" $, errout@var100 .@expr2972 str (@expr2973 ) $) $) { $return ; }
3774:
3775:
3776: $checkConst_ $(@expr1073744888 "cppcheck-2.8/test/testclass.cpp" $, 3776 $, "class Fred {\n    std::string s;\n    void foo(std::string * a, std::string * b);\n};\nvoid Fred::foo(std::string * a, std::string * b) { *a = s; s = b; }" $)
3777:
3778:
3779:
3780: ;
3781: $if $(@expr1073744889 $!@expr1073744890 $assertEquals $(@expr1073744891 "cppcheck-2.8/test/testclass.cpp" $, 3781 $, "" $, errout@var100 .@expr2972 str (@expr2973 ) $) $) { $return ; }
3782:
3783:
3784: $checkConst_ $(@expr1073744894 "cppcheck-2.8/test/testclass.cpp" $, 3784 $, "class Fred {\n    std::string s;\n    void foo();\n    void foo(std::string & a);\n    void foo(const std::string & a);\n};\nvoid Fred::foo() { }void Fred::foo(std::string & a) { a = s; }void Fred::foo(const std::string & a) { s = a; }" $)
3785:
|
3791:
3792: ;
3793: $if $(@expr1073744895 $!@expr1073744896 $assertEquals $(@expr1073744897 "cppcheck-2.8/test/testclass.cpp" $, 3793 $, "[test.cpp:7] -> [test.cpp:3]: (performance, inconclusive) Technically the member function 'Fred::foo' can be static (but you may consider moving to unnamed namespace).\n[test.cpp:7] -> [test.cpp:4]: (style, inconclusive) Technically the member function 'Fred::foo' can be const.\n" $, errout@var100 .@expr2972 str (@expr2973 ) $) $) { $return
3794: ; }
3795:
3796:
3797: $checkConst_ $(@expr1073744900 "cppcheck-2.8/test/testclass.cpp" $, 3797 $, "class Fred {\n    std::string s;\n    void foo1(int, int);\n    void foo2(int a, int b);\n    void foo3(int, int b);\n    void foo4(int a, int);\n    void foo5(int a, int b);\n};\nvoid Fred::foo1(int a, int b) { }\nvoid Fred::foo2(int c, int d) { }\nvoid Fred::foo3(int a, int b) { }\nvoid Fred::foo4(int a, int b) { }\nvoid Fred::foo5(int, int) { }" $)
3798:
|
3808:
3809: ;
3810: $if $(@expr1073744901 $!@expr1073744902 $assertEquals $(@expr1073744903 "cppcheck-2.8/test/testclass.cpp" $, 3810 $, "[test.cpp:9] -> [test.cpp:3]: (performance, inconclusive) Technically the member function 'Fred::foo1' can be static (but you may consider moving to unnamed namespace).\n[test.cpp:10] -> [test.cpp:4]: (performance, inconclusive) Technically the member function 'Fred::foo2' can be static (but you may consider moving to unnamed namespace).\n[test.cpp:11] -> [test.cpp:5]: (performance, inconclusive) Technically the member function 'Fred::foo3' can be static (but you may consider moving to unnamed namespace).\n[test.cpp:12] -> [test.cpp:6]: (performance, inconclusive) Technically the member function 'Fred::foo4' can be static (but you may consider moving to unnamed namespace).\n[test.cpp:13] -> [test.cpp:7]: (performance, inconclusive) Technically the member function 'Fred::foo5' can be static (but you may consider moving to unnamed namespace).\n" $, errout@var100 .@expr2972 str (@expr2973 ) $) $) { $return
3811:
3812:
3813:
3814: ; }
3815:
3816:
3817: $checkConst_ $(@expr1073744906 "cppcheck-2.8/test/testclass.cpp" $, 3817 $, "class Fred {\n    class A {\n        int a;\n        int getA() { return a; }\n    };\n};" $)
3818:
|
3821:
3822: ;
3823: $if $(@expr1073744907 $!@expr1073744908 $assertEquals $(@expr1073744909 "cppcheck-2.8/test/testclass.cpp" $, 3823 $, "[test.cpp:4]: (style, inconclusive) Technically the member function 'Fred::A::getA' can be const.\n" $, errout@var100 .@expr2972 str (@expr2973 ) $) $) { $return ; }
3824:
3825: $checkConst_ $(@expr1073744912 "cppcheck-2.8/test/testclass.cpp" $, 3825 $, "class Fred {\n    class A {\n        int a;\n        int getA();\n    };\n    int A::getA() { return a; }\n};" $)
3826:
|
3830:
3831: ;
3832: $if $(@expr1073744913 $!@expr1073744914 $assertEquals $(@expr1073744915 "cppcheck-2.8/test/testclass.cpp" $, 3832 $, "[test.cpp:6] -> [test.cpp:4]: (style, inconclusive) Technically the member function 'Fred::A::getA' can be const.\n" $, errout@var100 .@expr2972 str (@expr2973 ) $) $) { $return ; }
3833:
3834: $checkConst_ $(@expr1073744918 "cppcheck-2.8/test/testclass.cpp" $, 3834 $, "class Fred {\n    class A {\n        int a;\n        int getA();\n    };\n};\nint Fred::A::getA() { return a; }" $)
3835:
|
3839:
3840: ;
3841: $if $(@expr1073744919 $!@expr1073744920 $assertEquals $(@expr1073744921 "cppcheck-2.8/test/testclass.cpp" $, 3841 $, "[test.cpp:7] -> [test.cpp:4]: (style, inconclusive) Technically the member function 'Fred::A::getA' can be const.\n" $, errout@var100 .@expr2972 str (@expr2973 ) $) $) { $return ; }
3842:
3843:
3844: $checkConst_ $(@expr1073744924 "cppcheck-2.8/test/testclass.cpp" $, 3844 $, "class Fred {\n    class B {\n        int b;\n        int getB() { return b; }\n        class A {\n            int a;\n            int getA() { return a; }\n        };\n    };\n};" $)
3845:
|
3852:
3853: ;
3854: $if $(@expr1073744925 $!@expr1073744926 $assertEquals $(@expr1073744927 "cppcheck-2.8/test/testclass.cpp" $, 3854 $, "[test.cpp:4]: (style, inconclusive) Technically the member function 'Fred::B::getB' can be const.\n[test.cpp:7]: (style, inconclusive) Technically the member function 'Fred::B::A::getA' can be const.\n" $, errout@var100 .@expr2972 str (@expr2973 ) $) $) { $return
3855:
3856: ; }
3857:
3858: $checkConst_ $(@expr1073744930 "cppcheck-2.8/test/testclass.cpp" $, 3858 $, "class Fred {\n    class B {\n        int b;\n        int getB();\n        class A {\n            int a;\n            int getA();\n        };\n        int A::getA() { return a; }\n    };\n    int B::getB() { return b; }\n};" $)
3859:
|
3868:
3869: ;
3870: $if $(@expr1073744931 $!@expr1073744932 $assertEquals $(@expr1073744933 "cppcheck-2.8/test/testclass.cpp" $, 3870 $, "[test.cpp:11] -> [test.cpp:4]: (style, inconclusive) Technically the member function 'Fred::B::getB' can be const.\n[test.cpp:9] -> [test.cpp:7]: (style, inconclusive) Technically the member function 'Fred::B::A::getA' can be const.\n" $, errout@var100 .@expr2972 str (@expr2973 ) $) $) { $return
3871: ; }
3872:
3873: $checkConst_ $(@expr1073744936 "cppcheck-2.8/test/testclass.cpp" $, 3873 $, "class Fred {\n    class B {\n        int b;\n        int getB();\n        class A {\n            int a;\n            int getA();\n        };\n    };\n    int B::A::getA() { return a; }\n    int B::getB() { return b; }\n};" $)
3874:
|
3883:
3884: ;
3885: $if $(@expr1073744937 $!@expr1073744938 $assertEquals $(@expr1073744939 "cppcheck-2.8/test/testclass.cpp" $, 3885 $, "[test.cpp:11] -> [test.cpp:4]: (style, inconclusive) Technically the member function 'Fred::B::getB' can be const.\n[test.cpp:10] -> [test.cpp:7]: (style, inconclusive) Technically the member function 'Fred::B::A::getA' can be const.\n" $, errout@var100 .@expr2972 str (@expr2973 ) $) $) { $return
3886: ; }
3887:
3888: $checkConst_ $(@expr1073744942 "cppcheck-2.8/test/testclass.cpp" $, 3888 $, "class Fred {\n    class B {\n        int b;\n        int getB();\n        class A {\n            int a;\n            int getA();\n        };\n    };\n};\nint Fred::B::A::getA() { return a; }\nint Fred::B::getB() { return b; }" $)
3889:
|
3898:
3899: ;
3900: $if $(@expr1073744943 $!@expr1073744944 $assertEquals $(@expr1073744945 "cppcheck-2.8/test/testclass.cpp" $, 3900 $, "[test.cpp:12] -> [test.cpp:4]: (style, inconclusive) Technically the member function 'Fred::B::getB' can be const.\n[test.cpp:11] -> [test.cpp:7]: (style, inconclusive) Technically the member function 'Fred::B::A::getA' can be const.\n" $, errout@var100 .@expr2972 str (@expr2973 ) $) $) { $return
3901: ; }
3902: }
3903:
3904:
3905: void constoperator1 ( ) {
3906: $checkConst_ $(@expr1073744948 "cppcheck-2.8/test/testclass.cpp" $, 3906 $, "struct Fred {\n    int a;\n    bool operator<(const Fred &f) { return a < f.a; }\n};" $)
3907:
3908:
3909: ;
3910: $if $(@expr1073744949 $!@expr1073744950 $assertEquals $(@expr1073744951 "cppcheck-2.8/test/testclass.cpp" $, 3910 $, "[test.cpp:3]: (style, inconclusive) Technically the member function 'Fred::operator<' can be const.\n" $, errout@var100 .@expr1073744952 str (@expr1073744953 ) $) $) { $return ; }
3911: }
3912:
3913:
3914: void constoperator2 ( ) {
3915: $checkConst_ $(@expr1073744954 "cppcheck-2.8/test/testclass.cpp" $, 3915 $, "struct Foo {\n    void operator<<(int);\n};\nstruct Fred {\n    Foo foo;\n    void x()\n    {\n        foo << 123;\n    }\n};" $)
3916:
|
3923:
3924: ;
3925: $if $(@expr1073744955 $!@expr1073744956 $assertEquals $(@expr1073744957 "cppcheck-2.8/test/testclass.cpp" $, 3925 $, "" $, errout@var100 .@expr3134 str (@expr3135 ) $) $) { $return ; }
3926:
3927: $checkConst_ $(@expr1073744960 "cppcheck-2.8/test/testclass.cpp" $, 3927 $, "struct Foo {\n    void operator<<(int);\n};\nstruct Fred {\n    Foo foo;\n    void x()\n    {\n        std::cout << foo << 123;\n    }\n};" $)
3928:
|
3935:
3936: ;
3937: $if $(@expr1073744961 $!@expr1073744962 $assertEquals $(@expr1073744963 "cppcheck-2.8/test/testclass.cpp" $, 3937 $, "[test.cpp:6]: (style, inconclusive) Technically the member function 'Fred::x' can be const.\n" $, errout@var100 .@expr3134 str (@expr3135 ) $) $) { $return ; }
3938: }
3939:
3940: void constoperator3 ( ) {
3941: $checkConst_ $(@expr1073744966 "cppcheck-2.8/test/testclass.cpp" $, 3941 $, "struct Fred {\n    int array[10];\n    int const & operator [] (unsigned int index) const { return array[index]; }\n    int & operator [] (unsigned int index) { return array[index]; }\n};" $)
3942:
3943:
3944:
3945: ;
3946: $if $(@expr1073744967 $!@expr1073744968 $assertEquals $(@expr1073744969 "cppcheck-2.8/test/testclass.cpp" $, 3946 $, "" $, errout@var100 .@expr3146 str (@expr3147 ) $) $) { $return ; }
3947:
3948: $checkConst_ $(@expr1073744972 "cppcheck-2.8/test/testclass.cpp" $, 3948 $, "struct Fred {\n    int array[10];\n    int const & operator [] (unsigned int index) { return array[index]; }\n};" $)
3949:
3950:
3951: ;
3952: $if $(@expr1073744973 $!@expr1073744974 $assertEquals $(@expr1073744975 "cppcheck-2.8/test/testclass.cpp" $, 3952 $, "[test.cpp:3]: (style, inconclusive) Technically the member function 'Fred::operator[]' can be const.\n" $, errout@var100 .@expr3146 str (@expr3147 ) $) $) { $return ; }
3953: }
3954:
3955: void constoperator4 ( ) {
3956:
3957: $checkConst_ $(@expr1073744978 "cppcheck-2.8/test/testclass.cpp" $, 3957 $, "class A {\n    int c;\npublic:\n    operator int*() { return &c; };\n};" $)
3958:
3959:
3960:
3961: ;
3962: $if $(@expr1073744979 $!@expr1073744980 $assertEquals $(@expr1073744981 "cppcheck-2.8/test/testclass.cpp" $, 3962 $, "" $, errout@var100 .@expr3158 str (@expr3159 ) $) $) { $return ; }
3963:
3964: $checkConst_ $(@expr1073744984 "cppcheck-2.8/test/testclass.cpp" $, 3964 $, "class A {\n    int c;\npublic:\n    operator const int*() { return &c; };\n};" $)
3965:
3966:
3967:
3968: ;
3969: $if $(@expr1073744985 $!@expr1073744986 $assertEquals $(@expr1073744987 "cppcheck-2.8/test/testclass.cpp" $, 3969 $, "[test.cpp:4]: (style, inconclusive) Technically the member function 'A::operatorconstint*' can be const.\n" $, errout@var100 .@expr3158 str (@expr3159 ) $) $) { $return ; }
3970:
3971:
3972: $checkConst_ $(@expr1073744990 "cppcheck-2.8/test/testclass.cpp" $, 3972 $, "struct Fred {\n    int array[10];\n    typedef int* (Fred::*UnspecifiedBoolType);\n    operator UnspecifiedBoolType() { };\n};" $)
3973:
3974:
3975:
3976: ;
3977: $todoAssertEquals $(@expr1073744991 "cppcheck-2.8/test/testclass.cpp" $, 3977 $, "[test.cpp:4]: (style, inconclusive) Technically the member function 'Fred::operatorint**' can be const.\n" $, "" $, errout@var100 .@expr3158 str (@expr3159 ) $) ;
3978:
3979: $checkConst_ $(@expr1073744994 "cppcheck-2.8/test/testclass.cpp" $, 3979 $, "struct Fred {\n    int array[10];\n    typedef int* (Fred::*UnspecifiedBoolType);\n    operator UnspecifiedBoolType() { array[0] = 0; };\n};" $)
3980:
3981:
3982:
3983: ;
3984: $if $(@expr1073744995 $!@expr1073744996 $assertEquals $(@expr1073744997 "cppcheck-2.8/test/testclass.cpp" $, 3984 $, "" $, errout@var100 .@expr3158 str (@expr3159 ) $) $) { $return ; }
3985: }
3986:
3987: void constoperator5 ( ) {
3988: $checkConst_ $(@expr1073745000 "cppcheck-2.8/test/testclass.cpp" $, 3988 $, "class A {\n    int c;\npublic:\n    operator int& () {return c}\n};" $)
3989:
3990:
3991:
3992: ;
3993: $if $(@expr1073745001 $!@expr1073745002 $assertEquals $(@expr1073745003 "cppcheck-2.8/test/testclass.cpp" $, 3993 $, "" $, errout@var100 .@expr3180 str (@expr3181 ) $) $) { $return ; }
3994:
3995: $checkConst_ $(@expr1073745006 "cppcheck-2.8/test/testclass.cpp" $, 3995 $, "class A {\n    int c;\npublic:\n    operator const int& () {return c}\n};" $)
3996:
3997:
3998:
3999: ;
4000: $if $(@expr1073745007 $!@expr1073745008 $assertEquals $(@expr1073745009 "cppcheck-2.8/test/testclass.cpp" $, 4000 $, "[test.cpp:4]: (style, inconclusive) Technically the member function 'A::operatorconstint&' can be const.\n" $, errout@var100 .@expr3180 str (@expr3181 ) $) $) { $return ; }
4001:
4002: $checkConst_ $(@expr1073745012 "cppcheck-2.8/test/testclass.cpp" $, 4002 $, "class A {\n    int c;\npublic:\n    operator int () {return c}\n};" $)
4003:
4004:
4005:
4006: ;
4007: $if $(@expr1073745013 $!@expr1073745014 $assertEquals $(@expr1073745015 "cppcheck-2.8/test/testclass.cpp" $, 4007 $, "[test.cpp:4]: (style, inconclusive) Technically the member function 'A::operatorint' can be const.\n" $, errout@var100 .@expr3180 str (@expr3181 ) $) $) { $return ; }
4008: }
4009:
4010: void constoperator6 ( ) {
4011: $checkConst_ $(@expr1073745018 "cppcheck-2.8/test/testclass.cpp" $, 4011 $, "class A {\n    int c;\n    void f() { os >> *this; }\n};" $)
4012:
4013:
4014: ;
4015: $if $(@expr1073745019 $!@expr1073745020 $assertEquals $(@expr1073745021 "cppcheck-2.8/test/testclass.cpp" $, 4015 $, "" $, errout@var100 .@expr1073745022 str (@expr1073745023 ) $) $) { $return ; }
4016: }
4017:
4018: void const5 ( ) {
4019:
4020: $checkConst_ $(@expr1073745024 "cppcheck-2.8/test/testclass.cpp" $, 4020 $, "class A {\n    int a;\n    bool foo(int i)\n    {\n        bool same;\n        same = (i == a);\n        return same;\n    }\n};" $)
4021:
|
4027:
4028: ;
4029: $if $(@expr1073745025 $!@expr1073745026 $assertEquals $(@expr1073745027 "cppcheck-2.8/test/testclass.cpp" $, 4029 $, "[test.cpp:3]: (style, inconclusive) Technically the member function 'A::foo' can be const.\n" $, errout@var100 .@expr1073745028 str (@expr1073745029 ) $) $) { $return ; }
4030: }
4031:
4032: void const6 ( ) {
4033:
4034: $checkConst_ $(@expr1073745030 "cppcheck-2.8/test/testclass.cpp" $, 4034 $, "class foo {\npublic:\n};\nvoid bar() {}" $)
4035:
4036:
4037: ;
4038: $if $(@expr1073745031 $!@expr1073745032 $assertEquals $(@expr1073745033 "cppcheck-2.8/test/testclass.cpp" $, 4038 $, "" $, errout@var100 .@expr3210 str (@expr3211 ) $) $) { $return ; }
4039:
4040: $checkConst_ $(@expr1073745036 "cppcheck-2.8/test/testclass.cpp" $, 4040 $, "class Fred\n{\npublic:\n    void foo() { }\n};" $)
4041:
4042:
4043:
4044: ;
4045: $if $(@expr1073745037 $!@expr1073745038 $assertEquals $(@expr1073745039 "cppcheck-2.8/test/testclass.cpp" $, 4045 $, "[test.cpp:4]: (performance, inconclusive) Technically the member function 'Fred::foo' can be static (but you may consider moving to unnamed namespace).\n" $, errout@var100 .@expr3210 str (@expr3211 ) $) $) { $return ; }
4046:
4047: $checkConst_ $(@expr1073745042 "cppcheck-2.8/test/testclass.cpp" $, 4047 $, "struct fast_string\n{\n    union\n    {\n        char buff[100];\n    };\n    void set_type(char t);\n};\ninline void fast_string::set_type(char t)\n{\n    buff[10] = t;\n}" $)
4048:
|
4057:
4058: ;
4059: $if $(@expr1073745043 $!@expr1073745044 $assertEquals $(@expr1073745045 "cppcheck-2.8/test/testclass.cpp" $, 4059 $, "" $, errout@var100 .@expr3210 str (@expr3211 ) $) $) { $return ; }
4060: }
4061:
4062: void const7 ( ) {
4063: $checkConst_ $(@expr1073745048 "cppcheck-2.8/test/testclass.cpp" $, 4063 $, "class foo {\n    int a;\npublic:\n    void set(int i) { a = i; }\n    void set(const foo & f) { *this = f; }\n};\nvoid bar() {}" $)
4064:
|
4068:
4069: ;
4070: $if $(@expr1073745049 $!@expr1073745050 $assertEquals $(@expr1073745051 "cppcheck-2.8/test/testclass.cpp" $, 4070 $, "" $, errout@var100 .@expr1073745052 str (@expr1073745053 ) $) $) { $return ; }
4071: }
4072:
4073: void const8 ( ) {
4074:
4075: $checkConst_ $(@expr1073745054 "cppcheck-2.8/test/testclass.cpp" $, 4075 $, "class A {\npublic:\n    A():m_strValue(\"\"){}\n    std::string strGetString() { return m_strValue; }\nprivate:\n    std::string m_strValue;\n};" $)
4076:
|
4080:
4081: ;
4082: $if $(@expr1073745055 $!@expr1073745056 $assertEquals $(@expr1073745057 "cppcheck-2.8/test/testclass.cpp" $, 4082 $, "[test.cpp:4]: (style, inconclusive) Technically the member function 'A::strGetString' can be const.\n" $, errout@var100 .@expr1073745058 str (@expr1073745059 ) $) $) { $return ; }
4083: }
4084:
4085: void const9 ( ) {
4086:
4087: $checkConst_ $(@expr1073745060 "cppcheck-2.8/test/testclass.cpp" $, 4087 $, "class wxThreadInternal {\npublic:\n    void SetExitCode(wxThread::ExitCode exitcode) { m_exitcode = exitcode; }\nprivate:\n    wxThread::ExitCode m_exitcode;\n};" $)
4088:
|
4091:
4092: ;
4093: $if $(@expr1073745061 $!@expr1073745062 $assertEquals $(@expr1073745063 "cppcheck-2.8/test/testclass.cpp" $, 4093 $, "" $, errout@var100 .@expr1073745064 str (@expr1073745065 ) $) $) { $return ; }
4094: }
4095:
4096: void const10 ( ) {
4097:
4098: $checkConst_ $(@expr1073745066 "cppcheck-2.8/test/testclass.cpp" $, 4098 $, "class A {\npublic:\n    int foo() { return x = 0; }\nprivate:\n    int x;\n};" $)
4099:
|
4102:
4103: ;
4104: $if $(@expr1073745067 $!@expr1073745068 $assertEquals $(@expr1073745069 "cppcheck-2.8/test/testclass.cpp" $, 4104 $, "" $, errout@var100 .@expr3246 str (@expr3247 ) $) $) { $return ; }
4105:
4106: $checkConst_ $(@expr1073745072 "cppcheck-2.8/test/testclass.cpp" $, 4106 $, "class A {\npublic:\n    int foo() { return x ? x : x = 0; }\nprivate:\n    int x;\n};" $)
4107:
|
4110:
4111: ;
4112: $if $(@expr1073745073 $!@expr1073745074 $assertEquals $(@expr1073745075 "cppcheck-2.8/test/testclass.cpp" $, 4112 $, "" $, errout@var100 .@expr3246 str (@expr3247 ) $) $) { $return ; }
4113:
4114: $checkConst_ $(@expr1073745078 "cppcheck-2.8/test/testclass.cpp" $, 4114 $, "class A {\npublic:\n    int foo() { return x ? x = 0 : x; }\nprivate:\n    int x;\n};" $)
4115:
|
4118:
4119: ;
4120: $if $(@expr1073745079 $!@expr1073745080 $assertEquals $(@expr1073745081 "cppcheck-2.8/test/testclass.cpp" $, 4120 $, "" $, errout@var100 .@expr3246 str (@expr3247 ) $) $) { $return ; }
4121: }
4122:
4123: void const11 ( ) {
4124:
4125: $checkConst_ $(@expr1073745084 "cppcheck-2.8/test/testclass.cpp" $, 4125 $, "class A {\npublic:\n    void set(struct tm time) { m_time = time; }\nprivate:\n    struct tm m_time;\n};" $)
4126:
|
4129:
4130: ;
4131: $if $(@expr1073745085 $!@expr1073745086 $assertEquals $(@expr1073745087 "cppcheck-2.8/test/testclass.cpp" $, 4131 $, "" $, errout@var100 .@expr1073745088 str (@expr1073745089 ) $) $) { $return ; }
4132: }
4133:
4134: void const12 ( ) {
4135:
4136: $checkConst_ $(@expr1073745090 "cppcheck-2.8/test/testclass.cpp" $, 4136 $, "class A {\npublic:\n    int foo() { x = 0; }\nprivate:\n    mutable int x;\n};" $)
4137:
|
4140:
4141: ;
4142: $if $(@expr1073745091 $!@expr1073745092 $assertEquals $(@expr1073745093 "cppcheck-2.8/test/testclass.cpp" $, 4142 $, "[test.cpp:3]: (style, inconclusive) Technically the member function 'A::foo' can be const.\n" $, errout@var100 .@expr1073745094 str (@expr1073745095 ) $) $) { $return ; }
4143: }
4144:
4145: void const13 ( ) {
4146:
4147: $checkConst_ $(@expr1073745096 "cppcheck-2.8/test/testclass.cpp" $, 4147 $, "class A {\npublic:\n    A(){}\n    std::vector<int> GetVec()  {return m_vec;}\n    std::pair<int,double> GetPair() {return m_pair;}\nprivate:\n    std::vector<int> m_vec;\n    std::pair<int,double> m_pair;\n};" $)
4148:
|
4154:
4155: ;
4156: $if $(@expr1073745097 $!@expr1073745098 $assertEquals $(@expr1073745099 "cppcheck-2.8/test/testclass.cpp" $, 4156 $, "[test.cpp:4]: (style, inconclusive) Technically the member function 'A::GetVec' can be const.\n[test.cpp:5]: (style, inconclusive) Technically the member function 'A::GetPair' can be const.\n" $, errout@var100 .@expr3276 str (@expr3277 ) $) $) { $return
4157: ; }
4158:
4159: $checkConst_ $(@expr1073745102 "cppcheck-2.8/test/testclass.cpp" $, 4159 $, "class A {\npublic:\n    A(){}\n    const std::vector<int> & GetVec()  {return m_vec;}\n    const std::pair<int,double> & GetPair() {return m_pair;}\nprivate:\n    std::vector<int> m_vec;\n    std::pair<int,double> m_pair;\n};" $)
4160:
|
4166:
4167: ;
4168: $if $(@expr1073745103 $!@expr1073745104 $assertEquals $(@expr1073745105 "cppcheck-2.8/test/testclass.cpp" $, 4168 $, "[test.cpp:4]: (style, inconclusive) Technically the member function 'A::GetVec' can be const.\n[test.cpp:5]: (style, inconclusive) Technically the member function 'A::GetPair' can be const.\n" $, errout@var100 .@expr3276 str (@expr3277 ) $) $) { $return
4169: ; }
4170: }
4171:
4172: void const14 ( ) {
4173:
4174: $checkConst_ $(@expr1073745108 "cppcheck-2.8/test/testclass.cpp" $, 4174 $, "class A {\npublic:\n    A(){}\n    std::pair<std::vector<int>,double> GetPair() {return m_pair;}\nprivate:\n    std::pair<std::vector<int>,double> m_pair;\n};" $)
4175:
|
4179:
4180: ;
4181: $if $(@expr1073745109 $!@expr1073745110 $assertEquals $(@expr1073745111 "cppcheck-2.8/test/testclass.cpp" $, 4181 $, "[test.cpp:4]: (style, inconclusive) Technically the member function 'A::GetPair' can be const.\n" $, errout@var100 .@expr3288 str (@expr3289 ) $) $) { $return ; }
4182:
4183: $checkConst_ $(@expr1073745114 "cppcheck-2.8/test/testclass.cpp" $, 4183 $, "class A {\npublic:\n    A(){}\n    const std::pair<std::vector<int>,double>& GetPair() {return m_pair;}\nprivate:\n    std::pair<std::vector<int>,double> m_pair;\n};" $)
4184:
|
4188:
4189: ;
4190: $if $(@expr1073745115 $!@expr1073745116 $assertEquals $(@expr1073745117 "cppcheck-2.8/test/testclass.cpp" $, 4190 $, "[test.cpp:4]: (style, inconclusive) Technically the member function 'A::GetPair' can be const.\n" $, errout@var100 .@expr3288 str (@expr3289 ) $) $) { $return ; }
4191:
4192: $checkConst_ $(@expr1073745120 "cppcheck-2.8/test/testclass.cpp" $, 4192 $, "class A {\npublic:\n    A(){}\n    std::pair<std::vector<int>,double>& GetPair() {return m_pair;}\nprivate:\n    std::pair<std::vector<int>,double> m_pair;\n};" $)
4193:
|
4197:
4198: ;
4199: $if $(@expr1073745121 $!@expr1073745122 $assertEquals $(@expr1073745123 "cppcheck-2.8/test/testclass.cpp" $, 4199 $, "" $, errout@var100 .@expr3288 str (@expr3289 ) $) $) { $return ; }
4200:
4201:
4202: $checkConst_ $(@expr1073745126 "cppcheck-2.8/test/testclass.cpp" $, 4202 $, "using namespace std;class A {\npublic:\n    A(){}\n    pair<int ,double> GetPair() {return m_pair;}\nprivate:\n    pair<int ,double> m_pair;\n};" $)
4203:
|
4208:
4209: ;
4210: $if $(@expr1073745127 $!@expr1073745128 $assertEquals $(@expr1073745129 "cppcheck-2.8/test/testclass.cpp" $, 4210 $, "[test.cpp:4]: (style, inconclusive) Technically the member function 'A::GetPair' can be const.\n" $, errout@var100 .@expr3288 str (@expr3289 ) $) $) { $return ; }
4211:
4212: $checkConst_ $(@expr1073745132 "cppcheck-2.8/test/testclass.cpp" $, 4212 $, "using namespace std;class A {\npublic:\n    A(){}\n    const pair<int ,double> & GetPair() {return m_pair;}\nprivate:\n    pair<int ,double> m_pair;\n};" $)
4213:
|
4218:
4219: ;
4220: $if $(@expr1073745133 $!@expr1073745134 $assertEquals $(@expr1073745135 "cppcheck-2.8/test/testclass.cpp" $, 4220 $, "[test.cpp:4]: (style, inconclusive) Technically the member function 'A::GetPair' can be const.\n" $, errout@var100 .@expr3288 str (@expr3289 ) $) $) { $return ; }
4221:
4222: $checkConst_ $(@expr1073745138 "cppcheck-2.8/test/testclass.cpp" $, 4222 $, "using namespace std;class A {\npublic:\n    A(){}\n    pair<int ,double> & GetPair() {return m_pair;}\nprivate:\n    pair<int ,double> m_pair;\n};" $)
4223:
|
4228:
4229: ;
4230: $if $(@expr1073745139 $!@expr1073745140 $assertEquals $(@expr1073745141 "cppcheck-2.8/test/testclass.cpp" $, 4230 $, "" $, errout@var100 .@expr3288 str (@expr3289 ) $) $) { $return ; }
4231:
4232:
4233: $checkConst_ $(@expr1073745144 "cppcheck-2.8/test/testclass.cpp" $, 4233 $, "class A {\npublic:\n    A(){}\n    std::pair< int,std::vector<int> >  GetPair() {return m_pair;}\nprivate:\n    std::pair< int,std::vector<int> >  m_pair;\n};" $)
4234:
|
4238:
4239: ;
4240: $if $(@expr1073745145 $!@expr1073745146 $assertEquals $(@expr1073745147 "cppcheck-2.8/test/testclass.cpp" $, 4240 $, "[test.cpp:4]: (style, inconclusive) Technically the member function 'A::GetPair' can be const.\n" $, errout@var100 .@expr3288 str (@expr3289 ) $) $) { $return ; }
4241:
4242: $checkConst_ $(@expr1073745150 "cppcheck-2.8/test/testclass.cpp" $, 4242 $, "class A {\npublic:\n    A(){}\n    const std::pair< int,std::vector<int> >&  GetPair() {return m_pair;}\nprivate:\n    std::pair< int,std::vector<int> >  m_pair;\n};" $)
4243:
|
4247:
4248: ;
4249: $if $(@expr1073745151 $!@expr1073745152 $assertEquals $(@expr1073745153 "cppcheck-2.8/test/testclass.cpp" $, 4249 $, "[test.cpp:4]: (style, inconclusive) Technically the member function 'A::GetPair' can be const.\n" $, errout@var100 .@expr3288 str (@expr3289 ) $) $) { $return ; }
4250:
4251: $checkConst_ $(@expr1073745156 "cppcheck-2.8/test/testclass.cpp" $, 4251 $, "class A {\npublic:\n    A(){}\n    std::pair< int,std::vector<int> >&  GetPair() {return m_pair;}\nprivate:\n    std::pair< int,std::vector<int> >  m_pair;\n};" $)
4252:
|
4256:
4257: ;
4258: $if $(@expr1073745157 $!@expr1073745158 $assertEquals $(@expr1073745159 "cppcheck-2.8/test/testclass.cpp" $, 4258 $, "" $, errout@var100 .@expr3288 str (@expr3289 ) $) $) { $return ; }
4259:
4260:
4261: $checkConst_ $(@expr1073745162 "cppcheck-2.8/test/testclass.cpp" $, 4261 $, "using namespace std;class A {\npublic:\n    A(){}\n    pair< vector<int>, int >  GetPair() {return m_pair;}\nprivate:\n    pair< vector<int>, int >  m_pair;\n};" $)
4262:
|
4267:
4268: ;
4269: $if $(@expr1073745163 $!@expr1073745164 $assertEquals $(@expr1073745165 "cppcheck-2.8/test/testclass.cpp" $, 4269 $, "[test.cpp:4]: (style, inconclusive) Technically the member function 'A::GetPair' can be const.\n" $, errout@var100 .@expr3288 str (@expr3289 ) $) $) { $return ; }
4270:
4271: $checkConst_ $(@expr1073745168 "cppcheck-2.8/test/testclass.cpp" $, 4271 $, "using namespace std;class A {\npublic:\n    A(){}\n    const pair< vector<int>, int >&  GetPair() {return m_pair;}\nprivate:\n    pair< vector<int>, int >  m_pair;\n};" $)
4272:
|
4277:
4278: ;
4279: $if $(@expr1073745169 $!@expr1073745170 $assertEquals $(@expr1073745171 "cppcheck-2.8/test/testclass.cpp" $, 4279 $, "[test.cpp:4]: (style, inconclusive) Technically the member function 'A::GetPair' can be const.\n" $, errout@var100 .@expr3288 str (@expr3289 ) $) $) { $return ; }
4280:
4281: $checkConst_ $(@expr1073745174 "cppcheck-2.8/test/testclass.cpp" $, 4281 $, "using namespace std;class A {\npublic:\n    A(){}\n    pair< vector<int>, int >&  GetPair() {return m_pair;}\nprivate:\n    pair< vector<int>, int >  m_pair;\n};" $)
4282:
|
4287:
4288: ;
4289: $if $(@expr1073745175 $!@expr1073745176 $assertEquals $(@expr1073745177 "cppcheck-2.8/test/testclass.cpp" $, 4289 $, "" $, errout@var100 .@expr3288 str (@expr3289 ) $) $) { $return ; }
4290:
4291: $checkConst_ $(@expr1073745180 "cppcheck-2.8/test/testclass.cpp" $, 4291 $, "class A {\npublic:\n    A(){}\n    std::pair< std::vector<int>,std::vector<int> >  GetPair() {return m_pair;}\nprivate:\n    std::pair< std::vector<int>,std::vector<int> >  m_pair;\n};" $)
4292:
|
4296:
4297: ;
4298: $if $(@expr1073745181 $!@expr1073745182 $assertEquals $(@expr1073745183 "cppcheck-2.8/test/testclass.cpp" $, 4298 $, "[test.cpp:4]: (style, inconclusive) Technically the member function 'A::GetPair' can be const.\n" $, errout@var100 .@expr3288 str (@expr3289 ) $) $) { $return ; }
4299:
4300: $checkConst_ $(@expr1073745186 "cppcheck-2.8/test/testclass.cpp" $, 4300 $, "class A {\npublic:\n    A(){}\n    const std::pair< std::vector<int>,std::vector<int> >&  GetPair() {return m_pair;}\nprivate:\n    std::pair< std::vector<int>,std::vector<int> >  m_pair;\n};" $)
4301:
|
4305:
4306: ;
4307: $if $(@expr1073745187 $!@expr1073745188 $assertEquals $(@expr1073745189 "cppcheck-2.8/test/testclass.cpp" $, 4307 $, "[test.cpp:4]: (style, inconclusive) Technically the member function 'A::GetPair' can be const.\n" $, errout@var100 .@expr3288 str (@expr3289 ) $) $) { $return ; }
4308:
4309: $checkConst_ $(@expr1073745192 "cppcheck-2.8/test/testclass.cpp" $, 4309 $, "class A {\npublic:\n    A(){}\n    std::pair< std::vector<int>,std::vector<int> >&  GetPair() {return m_pair;}\nprivate:\n    std::pair< std::vector<int>,std::vector<int> >  m_pair;\n};" $)
4310:
|
4314:
4315: ;
4316: $if $(@expr1073745193 $!@expr1073745194 $assertEquals $(@expr1073745195 "cppcheck-2.8/test/testclass.cpp" $, 4316 $, "" $, errout@var100 .@expr3288 str (@expr3289 ) $) $) { $return ; }
4317:
4318:
4319:
4320: $checkConst_ $(@expr1073745198 "cppcheck-2.8/test/testclass.cpp" $, 4320 $, "class A {\npublic:\n    A(){}\n    std::pair< std::pair < int, char > , int >  GetPair() {return m_pair;}\nprivate:\n    std::pair< std::pair < int, char > , int >  m_pair;\n};" $)
4321:
|
4325:
4326: ;
4327: $if $(@expr1073745199 $!@expr1073745200 $assertEquals $(@expr1073745201 "cppcheck-2.8/test/testclass.cpp" $, 4327 $, "[test.cpp:4]: (style, inconclusive) Technically the member function 'A::GetPair' can be const.\n" $, errout@var100 .@expr3288 str (@expr3289 ) $) $) { $return ; }
4328:
4329: $checkConst_ $(@expr1073745204 "cppcheck-2.8/test/testclass.cpp" $, 4329 $, "class A {\npublic:\n    A(){}\n    const std::pair< std::pair < int, char > , int > & GetPair() {return m_pair;}\nprivate:\n    std::pair< std::pair < int, char > , int >  m_pair;\n};" $)
4330:
|
4334:
4335: ;
4336: $if $(@expr1073745205 $!@expr1073745206 $assertEquals $(@expr1073745207 "cppcheck-2.8/test/testclass.cpp" $, 4336 $, "[test.cpp:4]: (style, inconclusive) Technically the member function 'A::GetPair' can be const.\n" $, errout@var100 .@expr3288 str (@expr3289 ) $) $) { $return ; }
4337:
4338: $checkConst_ $(@expr1073745210 "cppcheck-2.8/test/testclass.cpp" $, 4338 $, "class A {\npublic:\n    A(){}\n    std::pair< std::pair < int, char > , int > & GetPair() {return m_pair;}\nprivate:\n    std::pair< std::pair < int, char > , int >  m_pair;\n};" $)
4339:
|
4343:
4344: ;
4345: $if $(@expr1073745211 $!@expr1073745212 $assertEquals $(@expr1073745213 "cppcheck-2.8/test/testclass.cpp" $, 4345 $, "" $, errout@var100 .@expr3288 str (@expr3289 ) $) $) { $return ; }
4346:
4347:
4348: $checkConst_ $(@expr1073745216 "cppcheck-2.8/test/testclass.cpp" $, 4348 $, "class A {\npublic:\n    A(){}\n    std::pair< int , std::pair < int, char > >  GetPair() {return m_pair;}\nprivate:\n    std::pair< int , std::pair < int, char > >  m_pair;\n};" $)
4349:
|
4353:
4354: ;
4355: $if $(@expr1073745217 $!@expr1073745218 $assertEquals $(@expr1073745219 "cppcheck-2.8/test/testclass.cpp" $, 4355 $, "[test.cpp:4]: (style, inconclusive) Technically the member function 'A::GetPair' can be const.\n" $, errout@var100 .@expr3288 str (@expr3289 ) $) $) { $return ; }
4356:
4357: $checkConst_ $(@expr1073745222 "cppcheck-2.8/test/testclass.cpp" $, 4357 $, "class A {\npublic:\n    A(){}\n    const std::pair< int , std::pair < int, char > >&  GetPair() {return m_pair;}\nprivate:\n    std::pair< int , std::pair < int, char > >  m_pair;\n};" $)
4358:
|
4362:
4363: ;
4364: $if $(@expr1073745223 $!@expr1073745224 $assertEquals $(@expr1073745225 "cppcheck-2.8/test/testclass.cpp" $, 4364 $, "[test.cpp:4]: (style, inconclusive) Technically the member function 'A::GetPair' can be const.\n" $, errout@var100 .@expr3288 str (@expr3289 ) $) $) { $return ; }
4365:
4366: $checkConst_ $(@expr1073745228 "cppcheck-2.8/test/testclass.cpp" $, 4366 $, "class A {\npublic:\n    A(){}\n    std::pair< int , std::pair < int, char > >&  GetPair() {return m_pair;}\nprivate:\n    std::pair< int , std::pair < int, char > >  m_pair;\n};" $)
4367:
|
4371:
4372: ;
4373: $if $(@expr1073745229 $!@expr1073745230 $assertEquals $(@expr1073745231 "cppcheck-2.8/test/testclass.cpp" $, 4373 $, "" $, errout@var100 .@expr3288 str (@expr3289 ) $) $) { $return ; }
4374:
4375:
4376: $checkConst_ $(@expr1073745234 "cppcheck-2.8/test/testclass.cpp" $, 4376 $, "using namespace std;class A {\npublic:\n    A(){}\n    vector<int>  GetVec() {return m_Vec;}\nprivate:\n    vector<int>  m_Vec;\n};" $)
4377:
|
4382:
4383: ;
4384: $if $(@expr1073745235 $!@expr1073745236 $assertEquals $(@expr1073745237 "cppcheck-2.8/test/testclass.cpp" $, 4384 $, "[test.cpp:4]: (style, inconclusive) Technically the member function 'A::GetVec' can be const.\n" $, errout@var100 .@expr3288 str (@expr3289 ) $) $) { $return ; }
4385:
4386: $checkConst_ $(@expr1073745240 "cppcheck-2.8/test/testclass.cpp" $, 4386 $, "using namespace std;class A {\npublic:\n    A(){}\n    const vector<int>&  GetVec() {return m_Vec;}\nprivate:\n    vector<int>  m_Vec;\n};" $)
4387:
|
4392:
4393: ;
4394: $if $(@expr1073745241 $!@expr1073745242 $assertEquals $(@expr1073745243 "cppcheck-2.8/test/testclass.cpp" $, 4394 $, "[test.cpp:4]: (style, inconclusive) Technically the member function 'A::GetVec' can be const.\n" $, errout@var100 .@expr3288 str (@expr3289 ) $) $) { $return ; }
4395:
4396: $checkConst_ $(@expr1073745246 "cppcheck-2.8/test/testclass.cpp" $, 4396 $, "using namespace std;class A {\npublic:\n    A(){}\n    vector<int>&  GetVec() {return m_Vec;}\nprivate:\n    vector<int>  m_Vec;\n};" $)
4397:
|
4402:
4403: ;
4404: $if $(@expr1073745247 $!@expr1073745248 $assertEquals $(@expr1073745249 "cppcheck-2.8/test/testclass.cpp" $, 4404 $, "" $, errout@var100 .@expr3288 str (@expr3289 ) $) $) { $return ; }
4405:
4406:
4407: $checkConst_ $(@expr1073745252 "cppcheck-2.8/test/testclass.cpp" $, 4407 $, "class A {\npublic:\n    int * * foo() { return &x; }\nprivate:\n    const int * x;\n};" $)
4408:
|
4411:
4412: ;
4413: $if $(@expr1073745253 $!@expr1073745254 $assertEquals $(@expr1073745255 "cppcheck-2.8/test/testclass.cpp" $, 4413 $, "" $, errout@var100 .@expr3288 str (@expr3289 ) $) $) { $return ; }
4414:
4415: $checkConst_ $(@expr1073745258 "cppcheck-2.8/test/testclass.cpp" $, 4415 $, "class A {\npublic:\n    const int ** foo() { return &x; }\nprivate:\n    const int * x;\n};" $)
4416:
|
4419:
4420: ;
4421: $if $(@expr1073745259 $!@expr1073745260 $assertEquals $(@expr1073745261 "cppcheck-2.8/test/testclass.cpp" $, 4421 $, "[test.cpp:3]: (style, inconclusive) Technically the member function 'A::foo' can be const.\n" $, errout@var100 .@expr3288 str (@expr3289 ) $) $) { $return ; }
4422: }
4423:
4424: void const15 ( ) {
4425: $checkConst_ $(@expr1073745264 "cppcheck-2.8/test/testclass.cpp" $, 4425 $, "class Fred {\n    unsigned long long int a;\n    unsigned long long int getA() { return a; }\n};" $)
4426:
4427:
4428: ;
4429: $if $(@expr1073745265 $!@expr1073745266 $assertEquals $(@expr1073745267 "cppcheck-2.8/test/testclass.cpp" $, 4429 $, "[test.cpp:3]: (style, inconclusive) Technically the member function 'Fred::getA' can be const.\n" $, errout@var100 .@expr3444 str (@expr3445 ) $) $) { $return ; }
4430:
4431:
4432: $checkConst_ $(@expr1073745270 "cppcheck-2.8/test/testclass.cpp" $, 4432 $, "class Fred {\n    unsigned long long int a;\npublic:\n    Fred() { }\n};" $)
4433:
4434:
4435:
4436: ;
4437: $if $(@expr1073745271 $!@expr1073745272 $assertEquals $(@expr1073745273 "cppcheck-2.8/test/testclass.cpp" $, 4437 $, "" $, errout@var100 .@expr3444 str (@expr3445 ) $) $) { $return ; }
4438:
4439:
4440: $checkConst_ $(@expr1073745276 "cppcheck-2.8/test/testclass.cpp" $, 4440 $, "class Fred {\n    unsigned long long int a;\n    unsigned long long int setA() { a |= true; }\n};" $)
4441:
4442:
4443: ;
4444: $if $(@expr1073745277 $!@expr1073745278 $assertEquals $(@expr1073745279 "cppcheck-2.8/test/testclass.cpp" $, 4444 $, "" $, errout@var100 .@expr3444 str (@expr3445 ) $) $) { $return ; }
4445:
4446:
4447: $checkConst_ $(@expr1073745282 "cppcheck-2.8/test/testclass.cpp" $, 4447 $, "class foo\n{\npublic:\n    static unsigned long long int get()\n    { return 0; }\n};" $)
4448:
|
4451:
4452: ;
4453: $if $(@expr1073745283 $!@expr1073745284 $assertEquals $(@expr1073745285 "cppcheck-2.8/test/testclass.cpp" $, 4453 $, "" $, errout@var100 .@expr3444 str (@expr3445 ) $) $) { $return ; }
4454: }
4455:
4456: void const16 ( ) {
4457:
4458: $checkConst_ $(@expr1073745288 "cppcheck-2.8/test/testclass.cpp" $, 4458 $, "class Fred {\n    int a;\n    void set(int i) { Fred::a = i; }\n};" $)
4459:
4460:
4461: ;
4462: $if $(@expr1073745289 $!@expr1073745290 $assertEquals $(@expr1073745291 "cppcheck-2.8/test/testclass.cpp" $, 4462 $, "" $, errout@var100 .@expr1073745292 str (@expr1073745293 ) $) $) { $return ; }
4463: }
4464:
4465: void const17 ( ) {
4466:
4467: $checkConst_ $(@expr1073745294 "cppcheck-2.8/test/testclass.cpp" $, 4467 $, "class Fred {\npublic:\n    void set(int i, int j) { a[i].k = i; }\nprivate:\n    struct { int k; } a[4];\n};" $)
4468:
|
4471:
4472: ;
4473: $if $(@expr1073745295 $!@expr1073745296 $assertEquals $(@expr1073745297 "cppcheck-2.8/test/testclass.cpp" $, 4473 $, "" $, errout@var100 .@expr1073745298 str (@expr1073745299 ) $) $) { $return ; }
4474: }
4475:
4476: void const18 ( ) {
4477: $checkConst_ $(@expr1073745300 "cppcheck-2.8/test/testclass.cpp" $, 4477 $, "class Fred {\nstatic int x;\npublic:\n    void set(int i) { x = i; }\n};" $)
4478:
4479:
4480:
4481: ;
4482: $if $(@expr1073745301 $!@expr1073745302 $assertEquals $(@expr1073745303 "cppcheck-2.8/test/testclass.cpp" $, 4482 $, "[test.cpp:4]: (performance, inconclusive) Technically the member function 'Fred::set' can be static (but you may consider moving to unnamed namespace).\n" $, errout@var100 .@expr1073745304 str (@expr1073745305 ) $) $) { $return ; }
4483: }
4484:
4485: void const19 ( ) {
4486:
4487: $checkConst_ $(@expr1073745306 "cppcheck-2.8/test/testclass.cpp" $, 4487 $, "using namespace std;\nclass Fred {\nprivate:\n    std::string s;\npublic:\n    void set(std::string ss) { s = ss; }\n};" $)
4488:
|
4492:
4493: ;
4494: $if $(@expr1073745307 $!@expr1073745308 $assertEquals $(@expr1073745309 "cppcheck-2.8/test/testclass.cpp" $, 4494 $, "" $, errout@var100 .@expr1073745310 str (@expr1073745311 ) $) $) { $return ; }
4495: }
4496:
4497: void const20 ( ) {
4498:
4499: $checkConst_ $(@expr1073745312 "cppcheck-2.8/test/testclass.cpp" $, 4499 $, "class Fred {\n    int x : 3;\npublic:\n    void set(int i) { x = i; }\n};" $)
4500:
4501:
4502:
4503: ;
4504: $if $(@expr1073745313 $!@expr1073745314 $assertEquals $(@expr1073745315 "cppcheck-2.8/test/testclass.cpp" $, 4504 $, "" $, errout@var100 .@expr3492 str (@expr3493 ) $) $) { $return ; }
4505:
4506: $checkConst_ $(@expr1073745318 "cppcheck-2.8/test/testclass.cpp" $, 4506 $, "class Fred {\n    list<int *> x;\npublic:\n    list<int *> get() { return x; }\n};" $)
4507:
4508:
4509:
4510: ;
4511: $if $(@expr1073745319 $!@expr1073745320 $assertEquals $(@expr1073745321 "cppcheck-2.8/test/testclass.cpp" $, 4511 $, "" $, errout@var100 .@expr3492 str (@expr3493 ) $) $) { $return ; }
4512:
4513: $checkConst_ $(@expr1073745324 "cppcheck-2.8/test/testclass.cpp" $, 4513 $, "class Fred {\n    list<const int *> x;\npublic:\n    list<const int *> get() { return x; }\n};" $)
4514:
4515:
4516:
4517: ;
4518: $if $(@expr1073745325 $!@expr1073745326 $assertEquals $(@expr1073745327 "cppcheck-2.8/test/testclass.cpp" $, 4518 $, "[test.cpp:4]: (style, inconclusive) Technically the member function 'Fred::get' can be const.\n" $, errout@var100 .@expr3492 str (@expr3493 ) $) $) { $return ; }
4519:
4520: $checkConst_ $(@expr1073745330 "cppcheck-2.8/test/testclass.cpp" $, 4520 $, "class Fred {\n    std::list<std::string &> x;\npublic:\n    std::list<std::string &> get() { return x; }\n};" $)
4521:
4522:
4523:
4524: ;
4525: $if $(@expr1073745331 $!@expr1073745332 $assertEquals $(@expr1073745333 "cppcheck-2.8/test/testclass.cpp" $, 4525 $, "" $, errout@var100 .@expr3492 str (@expr3493 ) $) $) { $return ; }
4526:
4527: $checkConst_ $(@expr1073745336 "cppcheck-2.8/test/testclass.cpp" $, 4527 $, "class Fred {\n    std::list<const std::string &> x;\npublic:\n    std::list<const std::string &> get() { return x; }\n};" $)
4528:
4529:
4530:
4531: ;
4532: $if $(@expr1073745337 $!@expr1073745338 $assertEquals $(@expr1073745339 "cppcheck-2.8/test/testclass.cpp" $, 4532 $, "[test.cpp:4]: (style, inconclusive) Technically the member function 'Fred::get' can be const.\n" $, errout@var100 .@expr3492 str (@expr3493 ) $) $) { $return ; }
4533: }
4534:
4535: void const21 ( ) {
4536:
4537: $checkConst_ $(@expr1073745342 "cppcheck-2.8/test/testclass.cpp" $, 4537 $, "class A\n{\nprivate:\n    const char * l1[10];\npublic:\n    A()\n    {\n        for (int i = 0 ; i < 10; l1[i] = NULL, i++);\n    }\n    void f1() { l1[0] = \"Hello\"; }\n};" $)
4538:
|
4546:
4547: ;
4548: $if $(@expr1073745343 $!@expr1073745344 $assertEquals $(@expr1073745345 "cppcheck-2.8/test/testclass.cpp" $, 4548 $, "" $, errout@var100 .@expr1073745346 str (@expr1073745347 ) $) $) { $return ; }
4549: }
4550:
4551: void const22 ( ) {
4552: $checkConst_ $(@expr1073745348 "cppcheck-2.8/test/testclass.cpp" $, 4552 $, "class A\n{\nprivate:\n    B::C * v1;\npublic:\n    void f1() { v1 = 0; }\n};" $)
4553:
|
4557:
4558: ;
4559: $if $(@expr1073745349 $!@expr1073745350 $assertEquals $(@expr1073745351 "cppcheck-2.8/test/testclass.cpp" $, 4559 $, "" $, errout@var100 .@expr3528 str (@expr3529 ) $) $) { $return ; }
4560:
4561: $checkConst_ $(@expr1073745354 "cppcheck-2.8/test/testclass.cpp" $, 4561 $, "class A\n{\nprivate:\n    B::C * v1[0];\npublic:\n    void f1() { v1[0] = 0; }\n};" $)
4562:
|
4566:
4567: ;
4568: $if $(@expr1073745355 $!@expr1073745356 $assertEquals $(@expr1073745357 "cppcheck-2.8/test/testclass.cpp" $, 4568 $, "" $, errout@var100 .@expr3528 str (@expr3529 ) $) $) { $return ; }
4569: }
4570:
4571: void const23 ( ) {
4572: $checkConst_ $(@expr1073745360 "cppcheck-2.8/test/testclass.cpp" $, 4572 $, "class Class {\npublic:\n    typedef Template<double> Type;\n    typedef Template2<Type> Type2;\n    void set_member(Type2 m) { _m = m; }\nprivate:\n    Type2 _m;\n};" $)
4573:
|
4578:
4579: ;
4580: $if $(@expr1073745361 $!@expr1073745362 $assertEquals $(@expr1073745363 "cppcheck-2.8/test/testclass.cpp" $, 4580 $, "" $, errout@var100 .@expr1073745364 str (@expr1073745365 ) $) $) { $return ; }
4581: }
4582:
4583: void const24 ( ) {
4584: $checkConst_ $(@expr1073745366 "cppcheck-2.8/test/testclass.cpp" $, 4584 $, "class Class {\npublic:\nvoid Settings::SetSetting(QString strSetting, QString strNewVal)\n{\n    (*m_pSettings)[strSetting] = strNewVal;\n}\nprivate:\n    std::map<QString, QString> *m_pSettings;\n};" $)
4585:
|
4591:
4592: ;
4593: $if $(@expr1073745367 $!@expr1073745368 $assertEquals $(@expr1073745369 "cppcheck-2.8/test/testclass.cpp" $, 4593 $, "" $, errout@var100 .@expr1073745370 str (@expr1073745371 ) $) $) { $return ; }
4594: }
4595:
4596:
4597: void const25 ( ) {
4598: $checkConst_ $(@expr1073745372 "cppcheck-2.8/test/testclass.cpp" $, 4598 $, "class A{\npublic:\nA(){m_strVal=\"\";}\nstd::string strGetString() const\n{return m_strVal.c_str();}\nconst std::string strGetString1() const\n{return m_strVal.c_str();}\nprivate:\nstd::string m_strVal;\n};" $)
4599:
|
4606:
4607: ;
4608: $if $(@expr1073745373 $!@expr1073745374 $assertEquals $(@expr1073745375 "cppcheck-2.8/test/testclass.cpp" $, 4608 $, "" $, errout@var100 .@expr3552 str (@expr3553 ) $) $) { $return ; }
4609:
4610: $checkConst_ $(@expr1073745378 "cppcheck-2.8/test/testclass.cpp" $, 4610 $, "class A{\npublic:\nA(){m_strVal=\"\";}\nstd::string strGetString()\n{return m_strVal.c_str();}\nprivate:\nstd::string m_strVal;\n};" $)
4611:
|
4616:
4617: ;
4618: $if $(@expr1073745379 $!@expr1073745380 $assertEquals $(@expr1073745381 "cppcheck-2.8/test/testclass.cpp" $, 4618 $, "[test.cpp:4]: (style, inconclusive) Technically the member function 'A::strGetString' can be const.\n" $, errout@var100 .@expr3552 str (@expr3553 ) $) $) { $return ; }
4619:
4620: $checkConst_ $(@expr1073745384 "cppcheck-2.8/test/testclass.cpp" $, 4620 $, "class A{\npublic:\nA(){m_strVal=\"\";}\nconst std::string strGetString1()\n{return m_strVal.c_str();}\nprivate:\nstd::string m_strVal;\n};" $)
4621:
|
4626:
4627: ;
4628: $if $(@expr1073745385 $!@expr1073745386 $assertEquals $(@expr1073745387 "cppcheck-2.8/test/testclass.cpp" $, 4628 $, "[test.cpp:4]: (style, inconclusive) Technically the member function 'A::strGetString1' can be const.\n" $, errout@var100 .@expr3552 str (@expr3553 ) $) $) { $return ; }
4629:
4630: $checkConst_ $(@expr1073745390 "cppcheck-2.8/test/testclass.cpp" $, 4630 $, "class A{\npublic:\nA(){m_strVec.push_back(\"\");}\nsize_t strGetSize()\n{return m_strVec.size();}\nprivate:\nstd::vector<std::string> m_strVec;\n};" $)
4631:
|
4636:
4637: ;
4638: $if $(@expr1073745391 $!@expr1073745392 $assertEquals $(@expr1073745393 "cppcheck-2.8/test/testclass.cpp" $, 4638 $, "[test.cpp:4]: (style, inconclusive) Technically the member function 'A::strGetSize' can be const.\n" $, errout@var100 .@expr3552 str (@expr3553 ) $) $) { $return ; }
4639:
4640: $checkConst_ $(@expr1073745396 "cppcheck-2.8/test/testclass.cpp" $, 4640 $, "class A{\npublic:\nA(){m_strVec.push_back(\"\");}\nbool strGetEmpty()\n{return m_strVec.empty();}\nprivate:\nstd::vector<std::string> m_strVec;\n};" $)
4641:
|
4646:
4647: ;
4648: $if $(@expr1073745397 $!@expr1073745398 $assertEquals $(@expr1073745399 "cppcheck-2.8/test/testclass.cpp" $, 4648 $, "[test.cpp:4]: (style, inconclusive) Technically the member function 'A::strGetEmpty' can be const.\n" $, errout@var100 .@expr3552 str (@expr3553 ) $) $) { $return ; }
4649: }
4650:
4651: void const26 ( ) {
4652: $checkConst_ $(@expr1073745402 "cppcheck-2.8/test/testclass.cpp" $, 4652 $, "class DelayBase {\npublic:\nvoid swapSpecificDelays(int index1, int index2) {\n    std::swap<float>(delays_[index1], delays_[index2]);\n}\nfloat delays_[4];\n};" $)
4653:
|
4657:
4658: ;
4659: $if $(@expr1073745403 $!@expr1073745404 $assertEquals $(@expr1073745405 "cppcheck-2.8/test/testclass.cpp" $, 4659 $, "" $, errout@var100 .@expr3582 str (@expr3583 ) $) $) { $return ; }
4660:
4661: $checkConst_ $(@expr1073745408 "cppcheck-2.8/test/testclass.cpp" $, 4661 $, "struct DelayBase {\n    float swapSpecificDelays(int index1) {\n        return delays_[index1];\n    }\n    float delays_[4];\n};" $)
4662:
|
4665:
4666: ;
4667: $if $(@expr1073745409 $!@expr1073745410 $assertEquals $(@expr1073745411 "cppcheck-2.8/test/testclass.cpp" $, 4667 $, "[test.cpp:2]: (style, inconclusive) Technically the member function 'DelayBase::swapSpecificDelays' can be const.\n" $, errout@var100 .@expr3582 str (@expr3583 ) $) $) { $return ; }
4668: }
4669:
4670: void const27 ( ) {
4671: $checkConst_ $(@expr1073745414 "cppcheck-2.8/test/testclass.cpp" $, 4671 $, "class A {\npublic:\n    A(){m_d=1.0; m_iRealVal=2.0;}\n    double dGetValue();\nprivate:\n    double m_d;\n    double m_iRealVal;\n};\ndouble  A::dGetValue() {\n    double dRet = m_iRealVal;\n    if( m_d != 0 )\n        return m_iRealVal / m_d;\n    return dRet;\n};" , nullptr , true $)
4672:
|
4683:
4684: ;
4685: $if $(@expr1073745415 $!@expr1073745416 $assertEquals $(@expr1073745417 "cppcheck-2.8/test/testclass.cpp" $, 4685 $, "[test.cpp:9] -> [test.cpp:4]: (style, inconclusive) Technically the member function 'A::dGetValue' can be const.\n" $, errout@var100 .@expr1073745418 str (@expr1073745419 ) $) $) { $return ; }
4686: }
4687:
4688: void const28 ( ) {
4689: $checkConst_ $(@expr1073745420 "cppcheck-2.8/test/testclass.cpp" $, 4689 $, "class P {\npublic:\n    P() { x=0.0; y=0.0; }\n    double x,y;\n};\nclass A : public P {\npublic:\n    A():P(){}\n    void SetPos(double xPos, double yPos) {\n        x=xPos;\n        y=yPos;\n    }\n};" $)
4690:
|
4700:
4701: ;
4702: $if $(@expr1073745421 $!@expr1073745422 $assertEquals $(@expr1073745423 "cppcheck-2.8/test/testclass.cpp" $, 4702 $, "" $, errout@var100 .@expr3600 str (@expr3601 ) $) $) { $return ; }
4703:
4704: $checkConst_ $(@expr1073745426 "cppcheck-2.8/test/testclass.cpp" $, 4704 $, "class AA : public P {\npublic:\n    AA():P(){}\n    inline void vSetXPos(int x_)\n    {\n        UnknownScope::x = x_;\n    }\n};" $)
4705:
|
4710:
4711: ;
4712: $if $(@expr1073745427 $!@expr1073745428 $assertEquals $(@expr1073745429 "cppcheck-2.8/test/testclass.cpp" $, 4712 $, "" $, errout@var100 .@expr3600 str (@expr3601 ) $) $) { $return ; }
4713:
4714: $checkConst_ $(@expr1073745432 "cppcheck-2.8/test/testclass.cpp" $, 4714 $, "class AA {\npublic:\n    AA():P(){}\n    inline void vSetXPos(int x_)\n    {\n        UnknownScope::x = x_;\n    }\n};" $)
4715:
|
4720:
4721: ;
4722: $if $(@expr1073745433 $!@expr1073745434 $assertEquals $(@expr1073745435 "cppcheck-2.8/test/testclass.cpp" $, 4722 $, "[test.cpp:4]: (performance, inconclusive) Technically the member function 'AA::vSetXPos' can be static (but you may consider moving to unnamed namespace).\n" $, errout@var100 .@expr3600 str (@expr3601 ) $) $) { $return ; }
4723:
4724: }
4725:
4726: void const29 ( ) {
4727: $checkConst_ $(@expr1073745438 "cppcheck-2.8/test/testclass.cpp" $, 4727 $, "class test {\n  public:\n    test();\n    const char* get() const;\n    char* get();\n  private:\n    char* value_;\n};\ntest::test()\n{\n  value_ = 0;\n}\nconst char* test::get() const\n{\n  return value_;\n}\nchar* test::get()\n{\n  return value_;\n}" $)
4728:
|
4745:
4746: ;
4747: $if $(@expr1073745439 $!@expr1073745440 $assertEquals $(@expr1073745441 "cppcheck-2.8/test/testclass.cpp" $, 4747 $, "" $, errout@var100 .@expr1073745442 str (@expr1073745443 ) $) $) { $return ; }
4748: }
4749:
4750: void const30 ( ) {
4751:
4752: $checkConst_ $(@expr1073745444 "cppcheck-2.8/test/testclass.cpp" $, 4752 $, "class Base {\npublic:\n    int a;\n};\nclass Derived : public Base {\npublic:\n    int get() {\n        return a;\n    }\n};" $)
4753:
|
4760:
4761: ;
4762: $if $(@expr1073745445 $!@expr1073745446 $assertEquals $(@expr1073745447 "cppcheck-2.8/test/testclass.cpp" $, 4762 $, "[test.cpp:7]: (style, inconclusive) Technically the member function 'Derived::get' can be const.\n" $, errout@var100 .@expr3624 str (@expr3625 ) $) $) { $return ; }
4763:
4764: $checkConst_ $(@expr1073745450 "cppcheck-2.8/test/testclass.cpp" $, 4764 $, "class Base1 {\npublic:\n    int a;\n};\nclass Base2 {\npublic:\n    int b;\n};\nclass Derived : public Base1, public Base2 {\npublic:\n    int getA() {\n        return a;\n    }\n    int getB() {\n        return b;\n    }\n};" $)
4765:
|
4779:
4780: ;
4781: $if $(@expr1073745451 $!@expr1073745452 $assertEquals $(@expr1073745453 "cppcheck-2.8/test/testclass.cpp" $, 4781 $, "[test.cpp:11]: (style, inconclusive) Technically the member function 'Derived::getA' can be const.\n[test.cpp:14]: (style, inconclusive) Technically the member function 'Derived::getB' can be const.\n" $, errout@var100 .@expr3624 str (@expr3625 ) $) $) { $return
4782: ; }
4783:
4784: $checkConst_ $(@expr1073745456 "cppcheck-2.8/test/testclass.cpp" $, 4784 $, "class Base {\npublic:\n    int a;\n};\nclass Derived1 : public Base { };\nclass Derived2 : public Derived1 {\npublic:\n    int get() {\n        return a;\n    }\n};" $)
4785:
|
4793:
4794: ;
4795: $if $(@expr1073745457 $!@expr1073745458 $assertEquals $(@expr1073745459 "cppcheck-2.8/test/testclass.cpp" $, 4795 $, "[test.cpp:8]: (style, inconclusive) Technically the member function 'Derived2::get' can be const.\n" $, errout@var100 .@expr3624 str (@expr3625 ) $) $) { $return ; }
4796:
4797: $checkConst_ $(@expr1073745462 "cppcheck-2.8/test/testclass.cpp" $, 4797 $, "class Base {\npublic:\n    int a;\n};\nclass Derived1 : public Base { };\nclass Derived2 : public Derived1 { };\nclass Derived3 : public Derived2 { };\nclass Derived4 : public Derived3 {\npublic:\n    int get() {\n        return a;\n    }\n};" $)
4798:
|
4808:
4809: ;
4810: $if $(@expr1073745463 $!@expr1073745464 $assertEquals $(@expr1073745465 "cppcheck-2.8/test/testclass.cpp" $, 4810 $, "[test.cpp:10]: (style, inconclusive) Technically the member function 'Derived4::get' can be const.\n" $, errout@var100 .@expr3624 str (@expr3625 ) $) $) { $return ; }
4811:
4812:
4813: $checkConst_ $(@expr1073745468 "cppcheck-2.8/test/testclass.cpp" $, 4813 $, "class Base {\npublic:\n    int a;\n};\nclass Derived : public Base {\npublic:\n    int get() const {\n        return a;\n    }\n};" $)
4814:
|
4821:
4822: ;
4823: $if $(@expr1073745469 $!@expr1073745470 $assertEquals $(@expr1073745471 "cppcheck-2.8/test/testclass.cpp" $, 4823 $, "" $, errout@var100 .@expr3624 str (@expr3625 ) $) $) { $return ; }
4824:
4825: $checkConst_ $(@expr1073745474 "cppcheck-2.8/test/testclass.cpp" $, 4825 $, "class Base1 {\npublic:\n    int a;\n};\nclass Base2 {\npublic:\n    int b;\n};\nclass Derived : public Base1, public Base2 {\npublic:\n    int getA() const {\n        return a;\n    }\n    int getB() const {\n        return b;\n    }\n};" $)
4826:
|
4840:
4841: ;
4842: $if $(@expr1073745475 $!@expr1073745476 $assertEquals $(@expr1073745477 "cppcheck-2.8/test/testclass.cpp" $, 4842 $, "" $, errout@var100 .@expr3624 str (@expr3625 ) $) $) { $return ; }
4843:
4844: $checkConst_ $(@expr1073745480 "cppcheck-2.8/test/testclass.cpp" $, 4844 $, "class Base {\npublic:\n    int a;\n};\nclass Derived1 : public Base { };\nclass Derived2 : public Derived1 {\npublic:\n    int get() const {\n        return a;\n    }\n};" $)
4845:
|
4853:
4854: ;
4855: $if $(@expr1073745481 $!@expr1073745482 $assertEquals $(@expr1073745483 "cppcheck-2.8/test/testclass.cpp" $, 4855 $, "" $, errout@var100 .@expr3624 str (@expr3625 ) $) $) { $return ; }
4856:
4857: $checkConst_ $(@expr1073745486 "cppcheck-2.8/test/testclass.cpp" $, 4857 $, "class Base {\npublic:\n    int a;\n};\nclass Derived1 : public Base { };\nclass Derived2 : public Derived1 { };\nclass Derived3 : public Derived2 { };\nclass Derived4 : public Derived3 {\npublic:\n    int get() const {\n        return a;\n    }\n};" $)
4858:
|
4868:
4869: ;
4870: $if $(@expr1073745487 $!@expr1073745488 $assertEquals $(@expr1073745489 "cppcheck-2.8/test/testclass.cpp" $, 4870 $, "" $, errout@var100 .@expr3624 str (@expr3625 ) $) $) { $return ; }
4871: }
4872:
4873: void const31 ( ) {
4874: $checkConst_ $(@expr1073745492 "cppcheck-2.8/test/testclass.cpp" $, 4874 $, "namespace std { }\nclass Fred {\npublic:\n    int a;\n    int get() { return a; }\n};" $)
4875:
|
4878:
4879: ;
4880: $if $(@expr1073745493 $!@expr1073745494 $assertEquals $(@expr1073745495 "cppcheck-2.8/test/testclass.cpp" $, 4880 $, "[test.cpp:5]: (style, inconclusive) Technically the member function 'Fred::get' can be const.\n" $, errout@var100 .@expr1073745496 str (@expr1073745497 ) $) $) { $return ; }
4881: }
4882:
4883: void const32 ( ) {
4884: $checkConst_ $(@expr1073745498 "cppcheck-2.8/test/testclass.cpp" $, 4884 $, "class Fred {\npublic:\n    std::string a[10];\n    void seta() { a[0] = \"\"; }\n};" $)
4885:
4886:
4887:
4888: ;
4889: $if $(@expr1073745499 $!@expr1073745500 $assertEquals $(@expr1073745501 "cppcheck-2.8/test/testclass.cpp" $, 4889 $, "" $, errout@var100 .@expr1073745502 str (@expr1073745503 ) $) $) { $return ; }
4890: }
4891:
4892: void const33 ( ) {
4893: $checkConst_ $(@expr1073745504 "cppcheck-2.8/test/testclass.cpp" $, 4893 $, "class derived : public base {\npublic:\n    void f(){}\n};" $)
4894:
4895:
4896: ;
4897: $if $(@expr1073745505 $!@expr1073745506 $assertEquals $(@expr1073745507 "cppcheck-2.8/test/testclass.cpp" $, 4897 $, "" $, errout@var100 .@expr1073745508 str (@expr1073745509 ) $) $) { $return ; }
4898: }
4899:
4900: void const34 ( ) {
4901: $checkConst_ $(@expr1073745510 "cppcheck-2.8/test/testclass.cpp" $, 4901 $, "class Bar {\n    void init(Foo * foo) {\n        foo.bar = this;\n    }\n};" $)
4902:
4903:
4904:
4905: ;
4906: $if $(@expr1073745511 $!@expr1073745512 $assertEquals $(@expr1073745513 "cppcheck-2.8/test/testclass.cpp" $, 4906 $, "" $, errout@var100 .@expr1073745514 str (@expr1073745515 ) $) $) { $return ; }
4907: }
4908:
4909: void const35 ( ) {
4910: $checkConst_ $(@expr1073745516 "cppcheck-2.8/test/testclass.cpp" $, 4910 $, "namespace N\n{\n        class Base\n        {\n        };\n}\nnamespace N\n{\n        class Derived : public Base\n        {\n        public:\n                int getResourceName() { return var; }\n                int var;\n        };\n}" $)
4911:
|
4923:
4924: ;
4925: $if $(@expr1073745517 $!@expr1073745518 $assertEquals $(@expr1073745519 "cppcheck-2.8/test/testclass.cpp" $, 4925 $, "[test.cpp:12]: (style, inconclusive) Technically the member function 'N::Derived::getResourceName' can be const.\n" $, errout@var100 .@expr3696 str (@expr3697 ) $) $) { $return ; }
4926:
4927: $checkConst_ $(@expr1073745522 "cppcheck-2.8/test/testclass.cpp" $, 4927 $, "namespace N\n{\n        class Base\n        {\n        public:\n                int getResourceName();\n                int var;\n        };\n}\nint N::Base::getResourceName() { return var; }" $)
4928:
|
4935:
4936: ;
4937: $if $(@expr1073745523 $!@expr1073745524 $assertEquals $(@expr1073745525 "cppcheck-2.8/test/testclass.cpp" $, 4937 $, "[test.cpp:10] -> [test.cpp:6]: (style, inconclusive) Technically the member function 'N::Base::getResourceName' can be const.\n" $, errout@var100 .@expr3696 str (@expr3697 ) $) $) { $return ; }
4938:
4939: $checkConst_ $(@expr1073745528 "cppcheck-2.8/test/testclass.cpp" $, 4939 $, "namespace N\n{\n        class Base\n        {\n        public:\n                int getResourceName();\n                int var;\n        };\n}\nnamespace N\n{\n        int Base::getResourceName() { return var; }\n}" $)
4940:
|
4950:
4951: ;
4952: $if $(@expr1073745529 $!@expr1073745530 $assertEquals $(@expr1073745531 "cppcheck-2.8/test/testclass.cpp" $, 4952 $, "[test.cpp:12] -> [test.cpp:6]: (style, inconclusive) Technically the member function 'N::Base::getResourceName' can be const.\n" $, errout@var100 .@expr3696 str (@expr3697 ) $) $) { $return ; }
4953:
4954: $checkConst_ $(@expr1073745534 "cppcheck-2.8/test/testclass.cpp" $, 4954 $, "namespace N\n{\n        class Base\n        {\n        public:\n                int getResourceName();\n                int var;\n        };\n}\nusing namespace N;\nint Base::getResourceName() { return var; }" $)
4955:
|
4963:
4964: ;
4965: $if $(@expr1073745535 $!@expr1073745536 $assertEquals $(@expr1073745537 "cppcheck-2.8/test/testclass.cpp" $, 4965 $, "[test.cpp:11] -> [test.cpp:6]: (style, inconclusive) Technically the member function 'N::Base::getResourceName' can be const.\n" $, errout@var100 .@expr3696 str (@expr3697 ) $) $) { $return ; }
4966: }
4967:
4968: void const36 ( ) {
4969: $checkConst_ $(@expr1073745540 "cppcheck-2.8/test/testclass.cpp" $, 4969 $, "class Foo {\npublic:\n    Blue::Utility::Size m_MaxQueueSize;\n    void SetMaxQueueSize(Blue::Utility::Size a_MaxQueueSize)\n    {\n        m_MaxQueueSize = a_MaxQueueSize;\n    }\n};" $)
4970:
|
4975:
4976: ;
4977: $if $(@expr1073745541 $!@expr1073745542 $assertEquals $(@expr1073745543 "cppcheck-2.8/test/testclass.cpp" $, 4977 $, "" $, errout@var100 .@expr1073745544 str (@expr1073745545 ) $) $) { $return ; }
4978: }
4979:
4980: void const37 ( ) {
4981: $checkConst_ $(@expr1073745546 "cppcheck-2.8/test/testclass.cpp" $, 4981 $, "class A\n{\npublic:\n    A(){};\n    std::string operator+(const char *c)\n    {\n        return m_str+std::string(c);\n    }\nprivate:\n    std::string m_str;\n};" $)
4982:
|
4990:
4991: ;
4992: $if $(@expr1073745547 $!@expr1073745548 $assertEquals $(@expr1073745549 "cppcheck-2.8/test/testclass.cpp" $, 4992 $, "[test.cpp:5]: (style, inconclusive) Technically the member function 'A::operator+' can be const.\n" $, errout@var100 .@expr3726 str (@expr3727 ) $) $) { $return ; }
4993:
4994: $checkConst_ $(@expr1073745552 "cppcheck-2.8/test/testclass.cpp" $, 4994 $, "class Fred\n{\nprivate:\n    long x;\npublic:\n    Fred() {\n        x = 0;\n    }\n    bool isValid() {\n        return (x == 0x11224488);\n    }\n};" $)
4995:
|
5004:
5005: ;
5006: $if $(@expr1073745553 $!@expr1073745554 $assertEquals $(@expr1073745555 "cppcheck-2.8/test/testclass.cpp" $, 5006 $, "[test.cpp:9]: (style, inconclusive) Technically the member function 'Fred::isValid' can be const.\n" $, errout@var100 .@expr3726 str (@expr3727 ) $) $) { $return ; }
5007: }
5008:
5009: void const38 ( ) {
5010: $checkConst_ $(@expr1073745558 "cppcheck-2.8/test/testclass.cpp" $, 5010 $, "class Foo {\npublic:\n    ~Foo() { delete oArq; }\n    Foo(): oArq(new std::ofstream(\"...\")) {}\n    void MyMethod();\nprivate:\n    std::ofstream *oArq;\n};\nvoid Foo::MyMethod()\n{\n    (*oArq) << \"</table>\";\n}" $)
5011:
|
5020:
5021: ;
5022: $if $(@expr1073745559 $!@expr1073745560 $assertEquals $(@expr1073745561 "cppcheck-2.8/test/testclass.cpp" $, 5022 $, "" $, errout@var100 .@expr1073745562 str (@expr1073745563 ) $) $) { $return ; }
5023: }
5024:
5025: void const39 ( ) {
5026: $checkConst_ $(@expr1073745564 "cppcheck-2.8/test/testclass.cpp" $, 5026 $, "class Foo\n{\n    int * p;\npublic:\n    Foo () : p(0) { }\n    int * f();\n    const int * f() const;\n};\nconst int * Foo::f() const\n{\n    return p;\n}\nint * Foo::f()\n{\n    return p;\n}" $)
5027:
|
5040:
5041: ;
5042:
5043: $if $(@expr1073745565 $!@expr1073745566 $assertEquals $(@expr1073745567 "cppcheck-2.8/test/testclass.cpp" $, 5043 $, "" $, errout@var100 .@expr1073745568 str (@expr1073745569 ) $) $) { $return ; }
5044: }
5045:
5046: void const40 ( ) {
5047: $checkConst_ $(@expr1073745570 "cppcheck-2.8/test/testclass.cpp" $, 5047 $, "class SharedPtrHolder\n{\n  private:\n   std::tr1::shared_ptr<int> pView;\n  public:\n   SharedPtrHolder()\n   { }\n   void SetView(const std::shared_ptr<int> & aView)\n   {\n      pView = aView;\n   }\n};" $)
5048:
|
5057:
5058: ;
5059:
5060: $if $(@expr1073745571 $!@expr1073745572 $assertEquals $(@expr1073745573 "cppcheck-2.8/test/testclass.cpp" $, 5060 $, "" $, errout@var100 .@expr1073745574 str (@expr1073745575 ) $) $) { $return ; }
5061: }
5062:
5063: void const41 ( ) {
5064: $checkConst_ $(@expr1073745576 "cppcheck-2.8/test/testclass.cpp" $, 5064 $, "class Fred\n{\n   ::std::string m_name;\npublic:\n   void SetName(const ::std::string & name)\n   {\n      m_name = name;\n   }\n};" $)
5065:
|
5071:
5072: ;
5073:
5074: $if $(@expr1073745577 $!@expr1073745578 $assertEquals $(@expr1073745579 "cppcheck-2.8/test/testclass.cpp" $, 5074 $, "" $, errout@var100 .@expr3756 str (@expr3757 ) $) $) { $return ; }
5075:
5076: $checkConst_ $(@expr1073745582 "cppcheck-2.8/test/testclass.cpp" $, 5076 $, "class SharedPtrHolder\n{\n   ::std::tr1::shared_ptr<int> pNum;\n  public :\n   void SetNum(const ::std::tr1::shared_ptr<int> & apNum)\n   {\n      pNum = apNum;\n   }\n};" $)
5077:
|
5083:
5084: ;
5085:
5086: $if $(@expr1073745583 $!@expr1073745584 $assertEquals $(@expr1073745585 "cppcheck-2.8/test/testclass.cpp" $, 5086 $, "" $, errout@var100 .@expr3756 str (@expr3757 ) $) $) { $return ; }
5087:
5088: $checkConst_ $(@expr1073745588 "cppcheck-2.8/test/testclass.cpp" $, 5088 $, "class SharedPtrHolder2\n{\n  public:\n   typedef ::std::tr1::shared_ptr<int> IntSharedPtr;\n  private:\n   IntSharedPtr pNum;\n  public :\n   void SetNum(const IntSharedPtr & apNum)\n   {\n      pNum = apNum;\n   }\n};" $)
5089:
|
5098:
5099: ;
5100:
5101: $if $(@expr1073745589 $!@expr1073745590 $assertEquals $(@expr1073745591 "cppcheck-2.8/test/testclass.cpp" $, 5101 $, "" $, errout@var100 .@expr3756 str (@expr3757 ) $) $) { $return ; }
5102:
5103: $checkConst_ $(@expr1073745594 "cppcheck-2.8/test/testclass.cpp" $, 5103 $, "struct IntPtrTypes\n{\n   typedef ::std::tr1::shared_ptr<int> Shared;\n};\nclass SharedPtrHolder3\n{\n  private:\n   IntPtrTypes::Shared pNum;\n  public :\n   void SetNum(const IntPtrTypes::Shared & apNum)\n   {\n      pNum = apNum;\n   }\n};" $)
5104:
|
5115:
5116: ;
5117:
5118: $if $(@expr1073745595 $!@expr1073745596 $assertEquals $(@expr1073745597 "cppcheck-2.8/test/testclass.cpp" $, 5118 $, "" $, errout@var100 .@expr3756 str (@expr3757 ) $) $) { $return ; }
5119:
5120: $checkConst_ $(@expr1073745600 "cppcheck-2.8/test/testclass.cpp" $, 5120 $, "template <typename T>\nstruct PtrTypes\n{\n   typedef ::std::tr1::shared_ptr<T> Shared;\n};\nclass SharedPtrHolder4\n{\n  private:\n   PtrTypes<int>::Shared pNum;\n  public :\n   void SetNum(const PtrTypes<int>::Shared & apNum)\n   {\n      pNum = apNum;\n   }\n};" $)
5121:
|
5133:
5134: ;
5135:
5136: $if $(@expr1073745601 $!@expr1073745602 $assertEquals $(@expr1073745603 "cppcheck-2.8/test/testclass.cpp" $, 5136 $, "" $, errout@var100 .@expr3756 str (@expr3757 ) $) $) { $return ; }
5137: }
5138:
5139: void const42 ( ) {
5140: $checkConst_ $(@expr1073745606 "cppcheck-2.8/test/testclass.cpp" $, 5140 $, "class Fred\n{\npublic:\n    struct AB { };\n    bool f(AB * ab);\n};\nbool Fred::f(Fred::AB * ab)\n{\n}" $)
5141:
|
5147:
5148: ;
5149:
5150: $if $(@expr1073745607 $!@expr1073745608 $assertEquals $(@expr1073745609 "cppcheck-2.8/test/testclass.cpp" $, 5150 $, "[test.cpp:7] -> [test.cpp:5]: (performance, inconclusive) Technically the member function 'Fred::f' can be static (but you may consider moving to unnamed namespace).\n" $, errout@var100 .@expr3786 str (@expr3787 ) $) $) { $return ; }
5151:
5152: $checkConst_ $(@expr1073745612 "cppcheck-2.8/test/testclass.cpp" $, 5152 $, "class Fred\n{\npublic:\n    struct AB {\n        struct CD { };\n    };\n    bool f(AB::CD * cd);\n};\nbool Fred::f(Fred::AB::CD * cd)\n{\n}" $)
5153:
|
5161:
5162: ;
5163:
5164: $if $(@expr1073745613 $!@expr1073745614 $assertEquals $(@expr1073745615 "cppcheck-2.8/test/testclass.cpp" $, 5164 $, "[test.cpp:9] -> [test.cpp:7]: (performance, inconclusive) Technically the member function 'Fred::f' can be static (but you may consider moving to unnamed namespace).\n" $, errout@var100 .@expr3786 str (@expr3787 ) $) $) { $return ; }
5165:
5166: $checkConst_ $(@expr1073745618 "cppcheck-2.8/test/testclass.cpp" $, 5166 $, "namespace NS {\n    class Fred\n    {\n    public:\n        struct AB {\n            struct CD { };\n        };\n        bool f(AB::CD * cd);\n    };\n    bool Fred::f(Fred::AB::CD * cd)\n    {\n    }\n}" $)
5167:
|
5177:
5178: ;
5179:
5180: $if $(@expr1073745619 $!@expr1073745620 $assertEquals $(@expr1073745621 "cppcheck-2.8/test/testclass.cpp" $, 5180 $, "[test.cpp:10] -> [test.cpp:8]: (performance, inconclusive) Technically the member function 'NS::Fred::f' can be static (but you may consider moving to unnamed namespace).\n" $, errout@var100 .@expr3786 str (@expr3787 ) $) $) { $return ; }
5181:
5182: $checkConst_ $(@expr1073745624 "cppcheck-2.8/test/testclass.cpp" $, 5182 $, "namespace NS {\n    class Fred\n    {\n    public:\n        struct AB {\n            struct CD { };\n        };\n        bool f(AB::CD * cd);\n    };\n}\nbool NS::Fred::f(NS::Fred::AB::CD * cd)\n{\n}" $)
5183:
|
5193:
5194: ;
5195:
5196: $if $(@expr1073745625 $!@expr1073745626 $assertEquals $(@expr1073745627 "cppcheck-2.8/test/testclass.cpp" $, 5196 $, "[test.cpp:11] -> [test.cpp:8]: (performance, inconclusive) Technically the member function 'NS::Fred::f' can be static (but you may consider moving to unnamed namespace).\n" $, errout@var100 .@expr3786 str (@expr3787 ) $) $) { $return ; }
5197:
5198: $checkConst_ $(@expr1073745630 "cppcheck-2.8/test/testclass.cpp" $, 5198 $, "class Foo {\n    class Fred\n    {\n    public:\n        struct AB {\n            struct CD { };\n        };\n        bool f(AB::CD * cd);\n    };\n};\nbool Foo::Fred::f(Foo::Fred::AB::CD * cd)\n{\n}" $)
5199:
|
5209:
5210: ;
5211:
5212: $if $(@expr1073745631 $!@expr1073745632 $assertEquals $(@expr1073745633 "cppcheck-2.8/test/testclass.cpp" $, 5212 $, "[test.cpp:11] -> [test.cpp:8]: (performance, inconclusive) Technically the member function 'Foo::Fred::f' can be static (but you may consider moving to unnamed namespace).\n" $, errout@var100 .@expr3786 str (@expr3787 ) $) $) { $return ; }
5213: }
5214:
5215: void const43 ( ) {
5216: $checkConst_ $(@expr1073745636 "cppcheck-2.8/test/testclass.cpp" $, 5216 $, "class A\n{\npublic:\n    void foo( AA::BB::CC::DD b );\n    AA::BB::CC::DD a;\n};\nvoid A::foo( AA::BB::CC::DD b )\n{\n    a = b;\n}" $)
5217:
|
5224:
5225: ;
5226:
5227: $if $(@expr1073745637 $!@expr1073745638 $assertEquals $(@expr1073745639 "cppcheck-2.8/test/testclass.cpp" $, 5227 $, "" $, errout@var100 .@expr3816 str (@expr3817 ) $) $) { $return ; }
5228:
5229: $checkConst_ $(@expr1073745642 "cppcheck-2.8/test/testclass.cpp" $, 5229 $, "namespace AA\n{\n    namespace BB\n    {\n        namespace CC\n        {\n            struct DD\n            {};\n        }\n    }\n}\nclass A\n{\n    public:\n\n    AA::BB::CC::DD a;\n    void foo(AA::BB::CC::DD b)\n    {\n        a = b;\n    }\n};" $)
5230:
|
5248:
5249: ;
5250:
5251: $if $(@expr1073745643 $!@expr1073745644 $assertEquals $(@expr1073745645 "cppcheck-2.8/test/testclass.cpp" $, 5251 $, "" $, errout@var100 .@expr3816 str (@expr3817 ) $) $) { $return ; }
5252:
5253: $checkConst_ $(@expr1073745648 "cppcheck-2.8/test/testclass.cpp" $, 5253 $, "namespace ZZ\n{\n    namespace YY\n    {\n        struct XX\n        {};\n    }\n}\nclass B\n{\n    public:\n    ZZ::YY::XX a;\n    void foo(ZZ::YY::XX b)\n    {\n        a = b;\n    }\n};" $)
5254:
|
5268:
5269: ;
5270: $if $(@expr1073745649 $!@expr1073745650 $assertEquals $(@expr1073745651 "cppcheck-2.8/test/testclass.cpp" $, 5270 $, "" $, errout@var100 .@expr3816 str (@expr3817 ) $) $) { $return ; }
5271: }
5272:
5273: void const44 ( ) {
5274: $checkConst_ $(@expr1073745654 "cppcheck-2.8/test/testclass.cpp" $, 5274 $, "class A\n{\npublic:\n    bool bOn;\n    bool foo()\n    {\n        return 0 != (bOn = bOn);\n    }\n};" $)
5275:
|
5281:
5282: ;
5283:
5284: $if $(@expr1073745655 $!@expr1073745656 $assertEquals $(@expr1073745657 "cppcheck-2.8/test/testclass.cpp" $, 5284 $, "" $, errout@var100 .@expr1073745658 str (@expr1073745659 ) $) $) { $return ; }
5285: }
5286:
5287: void const45 ( ) {
5288: $checkConst_ $(@expr1073745660 "cppcheck-2.8/test/testclass.cpp" $, 5288 $, "namespace wraps {\n    class BaseLayout {};\n}\nnamespace tools {\n    class WorkspaceControl :\n        public wraps::BaseLayout\n    {\n        int toGrid(int _value)\n        {\n        }\n    };\n}" $)
5289:
|
5298:
5299: ;
5300:
5301: $if $(@expr1073745661 $!@expr1073745662 $assertEquals $(@expr1073745663 "cppcheck-2.8/test/testclass.cpp" $, 5301 $, "[test.cpp:8]: (performance, inconclusive) Technically the member function 'tools::WorkspaceControl::toGrid' can be static (but you may consider moving to unnamed namespace).\n" $, errout@var100 .@expr1073745664 str (@expr1073745665 ) $) $) { $return ; }
5302: }
5303:
5304: void const46 ( ) {
5305: $checkConst_ $(@expr1073745666 "cppcheck-2.8/test/testclass.cpp" $, 5305 $, "class Altren {\npublic:\n    int fun1() {\n        int a;\n        a++;\n    }\n    int fun2() {\n        b++;\n    }\n};" $)
5306:
|
5313:
5314: ;
5315:
5316: $if $(@expr1073745667 $!@expr1073745668 $assertEquals $(@expr1073745669 "cppcheck-2.8/test/testclass.cpp" $, 5316 $, "[test.cpp:3]: (performance, inconclusive) Technically the member function 'Altren::fun1' can be static (but you may consider moving to unnamed namespace).\n[test.cpp:7]: (performance, inconclusive) Technically the member function 'Altren::fun2' can be static (but you may consider moving to unnamed namespace).\n" $, errout@var100 .@expr1073745670 str (@expr1073745671 ) $) $) { $return
5317: ; }
5318: }
5319:
5320: void const47 ( ) {
5321: $checkConst_ $(@expr1073745672 "cppcheck-2.8/test/testclass.cpp" $, 5321 $, "class Altren {\npublic:\n  void foo() { delete this; }\n  void foo(int i) const { }\n  void bar() { foo(); }\n};" $)
5322:
|
5325:
5326: ;
5327:
5328: $if $(@expr1073745673 $!@expr1073745674 $assertEquals $(@expr1073745675 "cppcheck-2.8/test/testclass.cpp" $, 5328 $, "[test.cpp:4]: (performance, inconclusive) Technically the member function 'Altren::foo' can be static (but you may consider moving to unnamed namespace).\n" $, errout@var100 .@expr3852 str (@expr3853 ) $) $) { $return ; }
5329:
5330: $checkConst_ $(@expr1073745678 "cppcheck-2.8/test/testclass.cpp" $, 5330 $, "class Altren {\npublic:\n  void foo() { delete this; }\n  void foo(int i) const { }\n  void bar() { foo(1); }\n};" $)
5331:
|
5334:
5335: ;
5336:
5337: $if $(@expr1073745679 $!@expr1073745680 $assertEquals $(@expr1073745681 "cppcheck-2.8/test/testclass.cpp" $, 5337 $, "[test.cpp:4]: (performance, inconclusive) Technically the member function 'Altren::foo' can be static (but you may consider moving to unnamed namespace).\n[test.cpp:5]: (style, inconclusive) Technically the member function 'Altren::bar' can be const.\n" $, errout@var100 .@expr3852 str (@expr3853 ) $) $) { $return
5338: ; }
5339: }
5340:
5341: void const48 ( ) {
5342: $checkConst_ $(@expr1073745684 "cppcheck-2.8/test/testclass.cpp" $, 5342 $, "class S0 {\n    class S1 {\n        class S2 {\n            class S3 {\n                class S4 { };\n            };\n        };\n    };\n};\nclass TextIterator {\n    S0::S1::S2::S3::S4 mCurrent, mSave;\npublic:\n    bool setTagColour();\n};\nbool TextIterator::setTagColour() {\n    mSave = mCurrent;\n}" $)
5343:
|
5357:
5358: ;
5359:
5360: $if $(@expr1073745685 $!@expr1073745686 $assertEquals $(@expr1073745687 "cppcheck-2.8/test/testclass.cpp" $, 5360 $, "" $, errout@var100 .@expr1073745688 str (@expr1073745689 ) $) $) { $return ; }
5361: }
5362:
5363: void const49 ( ) {
5364: $checkConst_ $(@expr1073745690 "cppcheck-2.8/test/testclass.cpp" $, 5364 $, "class A {\n    private:\n         std::map<unsigned int,unsigned int> _hash;\n    public:\n         A() : _hash() {}\n         unsigned int fetch(unsigned int key)\n         {\n             return _hash[key];\n         }\n};" $)
5365:
|
5372:
5373: ;
5374: $if $(@expr1073745691 $!@expr1073745692 $assertEquals $(@expr1073745693 "cppcheck-2.8/test/testclass.cpp" $, 5374 $, "" $, errout@var100 .@expr1073745694 str (@expr1073745695 ) $) $) { $return ; }
5375: }
5376:
5377: void const50 ( ) {
5378: $checkConst_ $(@expr1073745696 "cppcheck-2.8/test/testclass.cpp" $, 5378 $, "class Altren\n{\n        class SubClass : public std::vector<int>\n        {\n        };\n};\nvoid _setAlign()\n{\n        if (mTileSize.height > 0) return;\n        if (mEmptyView) return;\n}" $)
5379:
|
5387:
5388: ;
5389:
5390: $if $(@expr1073745697 $!@expr1073745698 $assertEquals $(@expr1073745699 "cppcheck-2.8/test/testclass.cpp" $, 5390 $, "" $, errout@var100 .@expr1073745700 str (@expr1073745701 ) $) $) { $return ; }
5391: }
5392:
5393: void const51 ( ) {
5394: $checkConst_ $(@expr1073745702 "cppcheck-2.8/test/testclass.cpp" $, 5394 $, "class PSIPTable {\npublic:\n    PSIPTable() : _pesdata(0) { }\n    const unsigned char* pesdata() const { return _pesdata; }\n    unsigned char* pesdata()             { return _pesdata; }\n    void SetSection(uint num) { pesdata()[6] = num; }\nprivate:\n    unsigned char *_pesdata;\n};" $)
5395:
|
5401:
5402: ;
5403: $if $(@expr1073745703 $!@expr1073745704 $assertEquals $(@expr1073745705 "cppcheck-2.8/test/testclass.cpp" $, 5403 $, "" $, errout@var100 .@expr3882 str (@expr3883 ) $) $) { $return ; }
5404:
5405: $checkConst_ $(@expr1073745708 "cppcheck-2.8/test/testclass.cpp" $, 5405 $, "class PESPacket {\npublic:\n    PESPacket() : _pesdata(0) { }\n    const unsigned char* pesdata() const { return _pesdata; }\n    unsigned char* pesdata()             { return _pesdata; }\nprivate:\n    unsigned char *_pesdata;\n};\nclass PSIPTable : public PESPacket\n{\npublic:\n    void SetSection(uint num) { pesdata()[6] = num; }\n};" $)
5406:
|
5416:
5417: ;
5418: $if $(@expr1073745709 $!@expr1073745710 $assertEquals $(@expr1073745711 "cppcheck-2.8/test/testclass.cpp" $, 5418 $, "" $, errout@var100 .@expr3882 str (@expr3883 ) $) $) { $return ; }
5419: }
5420:
5421: void const52 ( ) {
5422: $checkConst_ $(@expr1073745714 "cppcheck-2.8/test/testclass.cpp" $, 5422 $, "class foo {\n    void DoSomething(int &a) const { a = 1; }\n    void DoSomethingElse() { DoSomething(bar); }\nprivate:\n    int bar;\n};" $)
5423:
|
5426:
5427: ;
5428: $if $(@expr1073745715 $!@expr1073745716 $assertEquals $(@expr1073745717 "cppcheck-2.8/test/testclass.cpp" $, 5428 $, "[test.cpp:2]: (performance, inconclusive) Technically the member function 'foo::DoSomething' can be static (but you may consider moving to unnamed namespace).\n" $, errout@var100 .@expr1073745718 str (@expr1073745719 ) $) $) { $return ; }
5429: }
5430:
5431: void const53 ( ) {
5432: $checkConst_ $(@expr1073745720 "cppcheck-2.8/test/testclass.cpp" $, 5432 $, "class A {\n  public:\n    A() : foo(false) {};\n    virtual bool One(bool b = false) { foo = b; return false; }\n  private:\n    bool foo;\n};\nclass B : public A {\n  public:\n    B() {};\n    bool One(bool b = false) { return false; }\n};" $)
5433:
|
5442:
5443: ;
5444: $if $(@expr1073745721 $!@expr1073745722 $assertEquals $(@expr1073745723 "cppcheck-2.8/test/testclass.cpp" $, 5444 $, "" $, errout@var100 .@expr1073745724 str (@expr1073745725 ) $) $) { $return ; }
5445: }
5446:
5447: void const54 ( ) {
5448: $checkConst_ $(@expr1073745726 "cppcheck-2.8/test/testclass.cpp" $, 5448 $, "class Example {\n  public:\n    void Clear(void) { Example tmp; (*this) = tmp; }\n};" $)
5449:
5450:
5451: ;
5452: $if $(@expr1073745727 $!@expr1073745728 $assertEquals $(@expr1073745729 "cppcheck-2.8/test/testclass.cpp" $, 5452 $, "" $, errout@var100 .@expr1073745730 str (@expr1073745731 ) $) $) { $return ; }
5453: }
5454:
5455: void const55 ( ) {
5456: $checkConst_ $(@expr1073745732 "cppcheck-2.8/test/testclass.cpp" $, 5456 $, "class MyObject {\n    int tmp;\n    MyObject() : tmp(0) {}\npublic:\n    void set(std::stringstream &in) { in >> tmp; }\n};" $)
5457:
|
5460:
5461: ;
5462: $if $(@expr1073745733 $!@expr1073745734 $assertEquals $(@expr1073745735 "cppcheck-2.8/test/testclass.cpp" $, 5462 $, "" $, errout@var100 .@expr1073745736 str (@expr1073745737 ) $) $) { $return ; }
5463: }
5464:
5465: void const56 ( ) {
5466: $checkConst_ $(@expr1073745738 "cppcheck-2.8/test/testclass.cpp" $, 5466 $, "class MyObject {\npublic:\n    void foo(int x) {\n    switch (x) { }\n    }\n};" $)
5467:
|
5470:
5471: ;
5472: $if $(@expr1073745739 $!@expr1073745740 $assertEquals $(@expr1073745741 "cppcheck-2.8/test/testclass.cpp" $, 5472 $, "[test.cpp:3]: (performance, inconclusive) Technically the member function 'MyObject::foo' can be static (but you may consider moving to unnamed namespace).\n" $, errout@var100 .@expr3918 str (@expr3919 ) $) $) { $return ; }
5473:
5474: $checkConst_ $(@expr1073745744 "cppcheck-2.8/test/testclass.cpp" $, 5474 $, "class A\n{\n    protected:\n        unsigned short f (unsigned short X);\n    public:\n        A ();\n};\n\nunsigned short A::f (unsigned short X)\n{\n    enum ERetValues {RET_NOK = 0, RET_OK = 1};\n    enum ETypes     {FLOAT_TYPE = 1, INT_TYPE = 2};\n\n    try\n    {\n        switch (X)\n        {\n            case FLOAT_TYPE:\n            {\n                return RET_OK;\n            }\n            case INT_TYPE:\n            {\n                return RET_OK;\n            }\n            default:\n            {\n                return RET_NOK;\n            }\n        }\n    }\n    catch (...)\n    {\n        return RET_NOK;\n    }\n\n    return RET_NOK;\n}" $)
5475:
|
5510:
5511: ;
5512: $if $(@expr1073745745 $!@expr1073745746 $assertEquals $(@expr1073745747 "cppcheck-2.8/test/testclass.cpp" $, 5512 $, "[test.cpp:9] -> [test.cpp:4]: (performance, inconclusive) Technically the member function 'A::f' can be static (but you may consider moving to unnamed namespace).\n" $, errout@var100 .@expr3918 str (@expr3919 ) $) $) { $return ; }
5513:
5514: $checkConst_ $(@expr1073745750 "cppcheck-2.8/test/testclass.cpp" $, 5514 $, "class MyObject {\npublic:\n    void foo(int x) {\n    for (int i = 0; i < 5; i++) { }\n    }\n};" $)
5515:
|
5518:
5519: ;
5520: $if $(@expr1073745751 $!@expr1073745752 $assertEquals $(@expr1073745753 "cppcheck-2.8/test/testclass.cpp" $, 5520 $, "[test.cpp:3]: (performance, inconclusive) Technically the member function 'MyObject::foo' can be static (but you may consider moving to unnamed namespace).\n" $, errout@var100 .@expr3918 str (@expr3919 ) $) $) { $return ; }
5521: }
5522:
5523: void const57 ( ) {
5524: $checkConst_ $(@expr1073745756 "cppcheck-2.8/test/testclass.cpp" $, 5524 $, "namespace MyGUI\n{\n  namespace types\n  {\n    struct TSize {};\n    struct TCoord {\n      TSize size() const { }\n    };\n  }\n  typedef types::TSize IntSize;\n  typedef types::TCoord IntCoord;\n}\nclass SelectorControl\n{\n  MyGUI::IntSize getSize()\n  {\n    return mCoordValue.size();\n  }\nprivate:\n  MyGUI::IntCoord mCoordValue;\n};" $)
5525:
|
5543:
5544: ;
5545: $todoAssertEquals $(@expr1073745757 "cppcheck-2.8/test/testclass.cpp" $, 5545 $, "[test.cpp:7]: (performance, inconclusive) Technically the member function 'MyGUI::types::TCoord::size' can be static (but you may consider moving to unnamed namespace).\n[test.cpp:15]: (style, inconclusive) Technically the member function 'SelectorControl::getSize' can be const.\n" $, "[test.cpp:7]: (performance, inconclusive) Technically the member function 'MyGUI::types::TCoord::size' can be static (but you may consider moving to unnamed namespace).\n" $, errout@var100 .@expr3934 str (@expr3935 ) $)
5546:
5547: ;
5548:
5549: $checkConst_ $(@expr1073745760 "cppcheck-2.8/test/testclass.cpp" $, 5549 $, "struct Foo {\n    Bar b;\n    void foo(Foo f) {\n        b.run();\n    }\n};" $)
5550:
|
5553:
5554: ;
5555: $if $(@expr1073745761 $!@expr1073745762 $assertEquals $(@expr1073745763 "cppcheck-2.8/test/testclass.cpp" $, 5555 $, "" $, errout@var100 .@expr3934 str (@expr3935 ) $) $) { $return ; }
5556:
5557: $checkConst_ $(@expr1073745766 "cppcheck-2.8/test/testclass.cpp" $, 5557 $, "struct Bar {\n    int i = 0;\n    void run() { i++; }\n};\nstruct Foo {\n    Bar b;\n    void foo(Foo f) {\n        b.run();\n    }\n};" $)
5558:
|
5565:
5566: ;
5567: $if $(@expr1073745767 $!@expr1073745768 $assertEquals $(@expr1073745769 "cppcheck-2.8/test/testclass.cpp" $, 5567 $, "" $, errout@var100 .@expr3934 str (@expr3935 ) $) $) { $return ; }
5568:
5569: $checkConst_ $(@expr1073745772 "cppcheck-2.8/test/testclass.cpp" $, 5569 $, "struct Bar {\n    void run() const { }\n};\nstruct Foo {\n    Bar b;\n    void foo(Foo f) {\n        b.run();\n    }\n};" $)
5570:
|
5576:
5577: ;
5578: $if $(@expr1073745773 $!@expr1073745774 $assertEquals $(@expr1073745775 "cppcheck-2.8/test/testclass.cpp" $, 5578 $, "[test.cpp:2]: (performance, inconclusive) Technically the member function 'Bar::run' can be static (but you may consider moving to unnamed namespace).\n[test.cpp:6]: (style, inconclusive) Technically the member function 'Foo::foo' can be const.\n" $, errout@var100 .@expr3934 str (@expr3935 ) $) $) { $return
5579: ; }
5580: }
5581:
5582: void const58 ( ) {
5583: $checkConst_ $(@expr1073745778 "cppcheck-2.8/test/testclass.cpp" $, 5583 $, "struct MyObject {\n    void foo(Foo f) {\n        f.clear();\n    }\n};" $)
5584:
5585:
5586:
5587: ;
5588: $if $(@expr1073745779 $!@expr1073745780 $assertEquals $(@expr1073745781 "cppcheck-2.8/test/testclass.cpp" $, 5588 $, "[test.cpp:2]: (performance, inconclusive) Technically the member function 'MyObject::foo' can be static (but you may consider moving to unnamed namespace).\n" $, errout@var100 .@expr3958 str (@expr3959 ) $) $) { $return ; }
5589:
5590: $checkConst_ $(@expr1073745784 "cppcheck-2.8/test/testclass.cpp" $, 5590 $, "struct MyObject {\n    int foo(Foo f) {\n        return f.length();\n    }\n};" $)
5591:
5592:
5593:
5594: ;
5595: $if $(@expr1073745785 $!@expr1073745786 $assertEquals $(@expr1073745787 "cppcheck-2.8/test/testclass.cpp" $, 5595 $, "[test.cpp:2]: (performance, inconclusive) Technically the member function 'MyObject::foo' can be static (but you may consider moving to unnamed namespace).\n" $, errout@var100 .@expr3958 str (@expr3959 ) $) $) { $return ; }
5596:
5597: $checkConst_ $(@expr1073745790 "cppcheck-2.8/test/testclass.cpp" $, 5597 $, "struct MyObject {\n    Foo f;\n    int foo() {\n        return f.length();\n    }\n};" $)
5598:
|
5601:
5602: ;
5603: $if $(@expr1073745791 $!@expr1073745792 $assertEquals $(@expr1073745793 "cppcheck-2.8/test/testclass.cpp" $, 5603 $, "" $, errout@var100 .@expr3958 str (@expr3959 ) $) $) { $return ; }
5604:
5605: $checkConst_ $(@expr1073745796 "cppcheck-2.8/test/testclass.cpp" $, 5605 $, "struct MyObject {\n    std::string f;\n    int foo() {\n        return f.length();\n    }\n};" $)
5606:
|
5609:
5610: ;
5611: $if $(@expr1073745797 $!@expr1073745798 $assertEquals $(@expr1073745799 "cppcheck-2.8/test/testclass.cpp" $, 5611 $, "[test.cpp:3]: (style, inconclusive) Technically the member function 'MyObject::foo' can be const.\n" $, errout@var100 .@expr3958 str (@expr3959 ) $) $) { $return ; }
5612: }
5613:
5614: void const59 ( ) {
5615: $checkConst_ $(@expr1073745802 "cppcheck-2.8/test/testclass.cpp" $, 5615 $, "class C {\npublic:\n    inline void operator += (const int &x ) { re += x; }\n    friend inline void exp(C & c, const C & x) { }\nprotected:\n    int   re;\n    int   im;\n};" $)
5616:
|
5621:
5622: ;
5623: $if $(@expr1073745803 $!@expr1073745804 $assertEquals $(@expr1073745805 "cppcheck-2.8/test/testclass.cpp" $, 5623 $, "" $, errout@var100 .@expr1073745806 str (@expr1073745807 ) $) $) { $return ; }
5624: }
5625:
5626: void const60 ( ) {
5627: $checkConst_ $(@expr1073745808 "cppcheck-2.8/test/testclass.cpp" $, 5627 $, "class MyString {\npublic:\n    MyString() : m_ptr(0){}\n    MyString& operator+=( const MyString& rhs ) {\n            delete m_ptr;\n            m_ptr = new char[42];\n    }\n    MyString append( const MyString& str )\n    {       return operator+=( str ); }\n    char *m_ptr;\n};" $)
5628:
|
5636:
5637: ;
5638: $if $(@expr1073745809 $!@expr1073745810 $assertEquals $(@expr1073745811 "cppcheck-2.8/test/testclass.cpp" $, 5638 $, "" $, errout@var100 .@expr3988 str (@expr3989 ) $) $) { $return ; }
5639: $checkConst_ $(@expr1073745814 "cppcheck-2.8/test/testclass.cpp" $, 5639 $, "class MyString {\npublic:\n    MyString() : m_ptr(0){}\n    MyString& operator+=( const MyString& rhs );\n    MyString append( const MyString& str )\n    {       return operator+=( str ); }\n    char *m_ptr;\n};" $)
5640:
|
5645:
5646: ;
5647: $if $(@expr1073745815 $!@expr1073745816 $assertEquals $(@expr1073745817 "cppcheck-2.8/test/testclass.cpp" $, 5647 $, "" $, errout@var100 .@expr3988 str (@expr3989 ) $) $) { $return ; }
5648: }
5649:
5650: void const61 ( ) {
5651:
5652: $checkConst_ $(@expr1073745820 "cppcheck-2.8/test/testclass.cpp" $, 5652 $, "class MixerParticipant : public MixerParticipant {\n    int GetAudioFrame();\n};\nint MixerParticipant::GetAudioFrame() {\n    return 0;\n}" $)
5653:
|
5656:
5657: ;
5658:
5659:
5660: $checkConst_ $(@expr1073745821 "cppcheck-2.8/test/testclass.cpp" $, 5660 $, "class MixerParticipant : public MixerParticipant {\n    bool InitializeFileReader() {\n       printf(\"music\");\n    }\n};" $)
5661:
5662:
5663:
5664: ;
5665:
|
5669:
5670: $checkConst_ $(@expr1073745822 "cppcheck-2.8/test/testclass.cpp" $, 5670 $, "template<>\nclass Hash<void> {\nprotected:\n  typedef Key::key_type key_type;\n  void set(const Key& key);\n};\ntemplate<typename K, int KeySize>\nclass Hash : private Hash<void> {\n  typedef Hash<void> inherited;\n  void set(const Key& key) {\n      inherited::set(inherited::Key(key));\n  }\n};\n" , nullptr , false $)
5671:
|
5681:
5682: ;
5683: $if $(@expr1073745823 $!@expr1073745824 $assertEquals $(@expr1073745825 "cppcheck-2.8/test/testclass.cpp" $, 5683 $, "" $, errout@var100 .@expr1073745826 str (@expr1073745827 ) $) $) { $return ; }
5684: }
5685:
5686: void const62 ( ) {
5687: $checkConst_ $(@expr1073745828 "cppcheck-2.8/test/testclass.cpp" $, 5687 $, "class A {\n    private:\n         std::unordered_map<unsigned int,unsigned int> _hash;\n    public:\n         A() : _hash() {}\n         unsigned int fetch(unsigned int key)\n         {\n             return _hash[key];\n         }\n};" $)
5688:
|
5695:
5696: ;
5697: $if $(@expr1073745829 $!@expr1073745830 $assertEquals $(@expr1073745831 "cppcheck-2.8/test/testclass.cpp" $, 5697 $, "" $, errout@var100 .@expr1073745832 str (@expr1073745833 ) $) $) { $return ; }
5698: }
5699:
5700: void const63 ( ) {
5701: $checkConst_ $(@expr1073745834 "cppcheck-2.8/test/testclass.cpp" $, 5701 $, "struct A {\n    std::string s;\n    void clear() {\n         std::string* p = &s;\n         p->clear();\n     }\n};" $)
5702:
|
5706:
5707: ;
5708: $if $(@expr1073745835 $!@expr1073745836 $assertEquals $(@expr1073745837 "cppcheck-2.8/test/testclass.cpp" $, 5708 $, "" $, errout@var100 .@expr4014 str (@expr4015 ) $) $) { $return ; }
5709:
5710: $checkConst_ $(@expr1073745840 "cppcheck-2.8/test/testclass.cpp" $, 5710 $, "struct A {\n    std::string s;\n    void clear() {\n         std::string& r = s;\n         r.clear();\n     }\n};" $)
5711:
|
5715:
5716: ;
5717: $if $(@expr1073745841 $!@expr1073745842 $assertEquals $(@expr1073745843 "cppcheck-2.8/test/testclass.cpp" $, 5717 $, "" $, errout@var100 .@expr4014 str (@expr4015 ) $) $) { $return ; }
5718:
5719: $checkConst_ $(@expr1073745846 "cppcheck-2.8/test/testclass.cpp" $, 5719 $, "struct A {\n    std::string s;\n    void clear() {\n         std::string& r = sth; r = s;\n         r.clear();\n     }\n};" $)
5720:
|
5724:
5725: ;
5726: $if $(@expr1073745847 $!@expr1073745848 $assertEquals $(@expr1073745849 "cppcheck-2.8/test/testclass.cpp" $, 5726 $, "[test.cpp:3]: (style, inconclusive) Technically the member function 'A::clear' can be const.\n" $, errout@var100 .@expr4014 str (@expr4015 ) $) $) { $return ; }
5727:
5728: $checkConst_ $(@expr1073745852 "cppcheck-2.8/test/testclass.cpp" $, 5728 $, "struct A {\n    std::string s;\n    void clear() {\n         const std::string* p = &s;\n         p->somefunction();\n     }\n};" $)
5729:
|
5733:
5734: ;
5735: $if $(@expr1073745853 $!@expr1073745854 $assertEquals $(@expr1073745855 "cppcheck-2.8/test/testclass.cpp" $, 5735 $, "[test.cpp:3]: (style, inconclusive) Technically the member function 'A::clear' can be const.\n" $, errout@var100 .@expr4014 str (@expr4015 ) $) $) { $return ; }
5736:
5737: $checkConst_ $(@expr1073745858 "cppcheck-2.8/test/testclass.cpp" $, 5737 $, "struct A {\n    std::string s;\n    void clear() {\n         const std::string& r = s;\n         r.somefunction();\n     }\n};" $)
5738:
|
5742:
5743: ;
5744: $if $(@expr1073745859 $!@expr1073745860 $assertEquals $(@expr1073745861 "cppcheck-2.8/test/testclass.cpp" $, 5744 $, "[test.cpp:3]: (style, inconclusive) Technically the member function 'A::clear' can be const.\n" $, errout@var100 .@expr4014 str (@expr4015 ) $) $) { $return ; }
5745: }
5746:
5747: void const64 ( ) {
5748: $checkConst_ $(@expr1073745864 "cppcheck-2.8/test/testclass.cpp" $, 5748 $, "namespace B {\n    namespace D {\n        typedef int DKIPtr;\n    }\n    class ZClass  {\n        void set(const ::B::D::DKIPtr& p) {\n            membervariable = p;\n        }\n        ::B::D::DKIPtr membervariable;\n    };\n}" $)
5749:
|
5757:
5758: ;
5759: $if $(@expr1073745865 $!@expr1073745866 $assertEquals $(@expr1073745867 "cppcheck-2.8/test/testclass.cpp" $, 5759 $, "" $, errout@var100 .@expr1073745868 str (@expr1073745869 ) $) $) { $return ; }
5760: }
5761:
5762: void const65 ( ) {
5763: $checkConst_ $(@expr1073745870 "cppcheck-2.8/test/testclass.cpp" $, 5763 $, "template <typename T>\nclass TemplateClass {\npublic:\n   TemplateClass() { }\n};\ntemplate <>\nclass TemplateClass<float> {\npublic:\n   TemplateClass() { }\n};\nint main() {\n    TemplateClass<int> a;\n    TemplateClass<float> b;\n    return 0;\n}" $)
5764:
|
5776:
5777: ;
5778: $if $(@expr1073745871 $!@expr1073745872 $assertEquals $(@expr1073745873 "cppcheck-2.8/test/testclass.cpp" $, 5778 $, "" $, errout@var100 .@expr1073745874 str (@expr1073745875 ) $) $) { $return ; }
5779: }
5780:
5781: void const66 ( ) {
5782: $checkConst_ $(@expr1073745876 "cppcheck-2.8/test/testclass.cpp" $, 5782 $, "struct C {\n    C() : n(0) {}\n    void f(int v) { g((char *) &v); }\n    void g(char *) { n++; }\n    int n;\n};" $)
5783:
|
5786:
5787: ;
5788: $if $(@expr1073745877 $!@expr1073745878 $assertEquals $(@expr1073745879 "cppcheck-2.8/test/testclass.cpp" $, 5788 $, "" $, errout@var100 .@expr1073745880 str (@expr1073745881 ) $) $) { $return ; }
5789: }
5790:
5791: void const67 ( ) {
5792: $checkConst_ $(@expr1073745882 "cppcheck-2.8/test/testclass.cpp" $, 5792 $, "template <class VALUE_T, class LIST_T = std::list<VALUE_T> >\nclass TestList {\npublic:\n    LIST_T m_list;\n};\nclass Test {\npublic:\n    const std::list<std::shared_ptr<int>>& get() { return m_test.m_list; }\n    TestList<std::shared_ptr<int>> m_test;\n};" $)
5793:
|
5800:
5801: ;
5802: $if $(@expr1073745883 $!@expr1073745884 $assertEquals $(@expr1073745885 "cppcheck-2.8/test/testclass.cpp" $, 5802 $, "[test.cpp:8]: (style, inconclusive) Technically the member function 'Test::get' can be const.\n" $, errout@var100 .@expr1073745886 str (@expr1073745887 ) $) $) { $return ; }
5803: }
5804:
5805: void const68 ( ) {
5806: $checkConst_ $(@expr1073745888 "cppcheck-2.8/test/testclass.cpp" $, 5806 $, "class MyClass {\n    void clear() {\n        SVecPtr v = (SVecPtr) m_data;\n        v->clear();\n    }\n    void* m_data;\n};\n" $)
5807:
|
5811:
5812: ;
5813: $if $(@expr1073745889 $!@expr1073745890 $assertEquals $(@expr1073745891 "cppcheck-2.8/test/testclass.cpp" $, 5813 $, "" $, errout@var100 .@expr1073745892 str (@expr1073745893 ) $) $) { $return ; }
5814: }
5815:
5816: void const69 ( ) {
5817: $checkConst_ $(@expr1073745894 "cppcheck-2.8/test/testclass.cpp" $, 5817 $, "struct A {\n    int a = 0;\n    template <typename... Args> void call(const Args &... args) { a = 1; }\n    template <typename T, typename... Args> auto call(const Args &... args) -> T {\n        a = 2;\n        return T{};\n    }\n};\n\nstruct B : public A {\n    void test() {\n        call();\n        call<int>(1, 2, 3);\n    }\n};" $)
5818:
|
5830:
5831: ;
5832: $if $(@expr1073745895 $!@expr1073745896 $assertEquals $(@expr1073745897 "cppcheck-2.8/test/testclass.cpp" $, 5832 $, "" $, errout@var100 .@expr1073745898 str (@expr1073745899 ) $) $) { $return ; }
5833: }
5834:
5835: void const70 ( ) {
5836: $checkConst_ $(@expr1073745900 "cppcheck-2.8/test/testclass.cpp" $, 5836 $, "struct A {\n    template <typename... Args> void call(Args ... args) {\n        func(this);\n    }\n\n    void test() {\n        call(1, 2);\n    }\n};" $)
5837:
|
5843:
5844: ;
5845: $if $(@expr1073745901 $!@expr1073745902 $assertEquals $(@expr1073745903 "cppcheck-2.8/test/testclass.cpp" $, 5845 $, "" $, errout@var100 .@expr1073745904 str (@expr1073745905 ) $) $) { $return ; }
5846: }
5847:
5848: void const71 ( ) {
5849: $checkConst_ $(@expr1073745906 "cppcheck-2.8/test/testclass.cpp" $, 5849 $, "struct Bar {\n    int j = 5;\n    void f(int& i) const { i += j; }\n};\nstruct Foo {\n    Bar bar;\n    int k{};\n    void g() { bar.f(k); }\n};\n" $)
5850:
|
5856:
5857: ;
5858: $if $(@expr1073745907 $!@expr1073745908 $assertEquals $(@expr1073745909 "cppcheck-2.8/test/testclass.cpp" $, 5858 $, "" $, errout@var100 .@expr4086 str (@expr4087 ) $) $) { $return ; }
5859:
5860: $checkConst_ $(@expr1073745912 "cppcheck-2.8/test/testclass.cpp" $, 5860 $, "struct S {\n    A a;\n    void f(int j, int*& p) {\n        p = &(((a[j])));\n    }\n};\n" $)
5861:
|
5864:
5865: ;
5866: $if $(@expr1073745913 $!@expr1073745914 $assertEquals $(@expr1073745915 "cppcheck-2.8/test/testclass.cpp" $, 5866 $, "" $, errout@var100 .@expr4086 str (@expr4087 ) $) $) { $return ; }
5867: }
5868:
5869: void const72 ( ) {
5870: $checkConst_ $(@expr1073745918 "cppcheck-2.8/test/testclass.cpp" $, 5870 $, "struct S {\n    explicit S(int* p) : mp(p) {}\n    int* mp{};\n};\nstruct C {\n    int i{};\n    S f() { return S{ &i }; }\n};\n" $)
5871:
|
5876:
5877: ;
5878: $if $(@expr1073745919 $!@expr1073745920 $assertEquals $(@expr1073745921 "cppcheck-2.8/test/testclass.cpp" $, 5878 $, "" $, errout@var100 .@expr4098 str (@expr4099 ) $) $) { $return ; }
5879:
5880: $checkConst_ $(@expr1073745924 "cppcheck-2.8/test/testclass.cpp" $, 5880 $, "struct S {\n    explicit S(int* p) : mp(p) {}\n    int* mp{};\n};\nstruct C {\n    int i{};\n    S f() { return S(&i); }\n};\n" $)
5881:
|
5886:
5887: ;
5888: $if $(@expr1073745925 $!@expr1073745926 $assertEquals $(@expr1073745927 "cppcheck-2.8/test/testclass.cpp" $, 5888 $, "" $, errout@var100 .@expr4098 str (@expr4099 ) $) $) { $return ; }
5889:
5890: $checkConst_ $(@expr1073745930 "cppcheck-2.8/test/testclass.cpp" $, 5890 $, "struct S {\n    int* mp{};\n};\nstruct C {\n    int i{};\n    S f() { return S{ &i }; }\n};\n" $)
5891:
|
5895:
5896: ;
5897: $if $(@expr1073745931 $!@expr1073745932 $assertEquals $(@expr1073745933 "cppcheck-2.8/test/testclass.cpp" $, 5897 $, "" $, errout@var100 .@expr4098 str (@expr4099 ) $) $) { $return ; }
5898:
5899: $checkConst_ $(@expr1073745936 "cppcheck-2.8/test/testclass.cpp" $, 5899 $, "struct S {\n    int* mp{};\n};\nstruct C {\n    int i{};\n    S f() { return { &i }; }\n};\n" $)
5900:
|
5904:
5905: ;
5906: $if $(@expr1073745937 $!@expr1073745938 $assertEquals $(@expr1073745939 "cppcheck-2.8/test/testclass.cpp" $, 5906 $, "" $, errout@var100 .@expr4098 str (@expr4099 ) $) $) { $return ; }
5907:
5908: $checkConst_ $(@expr1073745942 "cppcheck-2.8/test/testclass.cpp" $, 5908 $, "struct S {\n    explicit S(const int* p) : mp(p) {}\n    const int* mp{};\n};\nstruct C {\n    int i{};\n    S f() { return S{ &i }; }\n};\n" $)
5909:
|
5914:
5915: ;
5916: $todoAssertEquals $(@expr1073745943 "cppcheck-2.8/test/testclass.cpp" $, 5916 $, "[test.cpp:7]: (style, inconclusive) Technically the member function 'C::f' can be const.\n" $, "" $, errout@var100 .@expr4098 str (@expr4099 ) $) ;
5917:
5918: $checkConst_ $(@expr1073745946 "cppcheck-2.8/test/testclass.cpp" $, 5918 $, "struct S {\n    explicit S(const int* p) : mp(p) {}\n    const int* mp{};\n};\nstruct C {\n    int i{};\n    S f() { return S(&i); }\n};\n" $)
5919:
|
5924:
5925: ;
5926: $todoAssertEquals $(@expr1073745947 "cppcheck-2.8/test/testclass.cpp" $, 5926 $, "[test.cpp:7]: (style, inconclusive) Technically the member function 'C::f' can be const.\n" $, "" $, errout@var100 .@expr4098 str (@expr4099 ) $) ;
5927:
5928: $checkConst_ $(@expr1073745950 "cppcheck-2.8/test/testclass.cpp" $, 5928 $, "struct S {\n    const int* mp{};\n};\nstruct C {\n    int i{};\n    S f() { return S{ &i }; }\n};\n" $)
5929:
|
5933:
5934: ;
5935: $todoAssertEquals $(@expr1073745951 "cppcheck-2.8/test/testclass.cpp" $, 5935 $, "[test.cpp:7]: (style, inconclusive) Technically the member function 'C::f' can be const.\n" $, "" $, errout@var100 .@expr4098 str (@expr4099 ) $) ;
5936:
5937: $checkConst_ $(@expr1073745954 "cppcheck-2.8/test/testclass.cpp" $, 5937 $, "struct S {\n    const int* mp{};\n};\nstruct C {\n    int i{};\n    S f() { return { &i }; }\n};\n" $)
5938:
|
5942:
5943: ;
5944: $todoAssertEquals $(@expr1073745955 "cppcheck-2.8/test/testclass.cpp" $, 5944 $, "[test.cpp:7]: (style, inconclusive) Technically the member function 'C::f' can be const.\n" $, "" $, errout@var100 .@expr4098 str (@expr4099 ) $) ;
5945: }
5946:
5947: void const73 ( ) {
5948: $checkConst_ $(@expr1073745958 "cppcheck-2.8/test/testclass.cpp" $, 5948 $, "struct A {\n    int* operator[](int i);\n    const int* operator[](int i) const;\n};\nstruct S {\n    A a;\n    void f(int j) {\n        int* p = a[j];\n        *p = 0;\n    }\n};\n" $)
5949:
|
5957:
5958: ;
5959: $if $(@expr1073745959 $!@expr1073745960 $assertEquals $(@expr1073745961 "cppcheck-2.8/test/testclass.cpp" $, 5959 $, "" $, errout@var100 .@expr4138 str (@expr4139 ) $) $) { $return ; }
5960:
5961: $checkConst_ $(@expr1073745964 "cppcheck-2.8/test/testclass.cpp" $, 5961 $, "struct S {\n    T* h;\n    void f(); \n};\nvoid S::f() {\n    char* c = h->x[y];\n};\n" $)
5962:
|
5966:
5967: ;
5968: $if $(@expr1073745965 $!@expr1073745966 $assertEquals $(@expr1073745967 "cppcheck-2.8/test/testclass.cpp" $, 5968 $, "[test.cpp:5] -> [test.cpp:3]: (style, inconclusive) Technically the member function 'S::f' can be const.\n" $, errout@var100 .@expr4138 str (@expr4139 ) $) $) { $return ; }
5969: }
5970:
5971: void const74 ( ) {
5972: $checkConst_ $(@expr1073745970 "cppcheck-2.8/test/testclass.cpp" $, 5972 $, "class A {\n    std::vector<std::string> m_str;\npublic:\n    A() {}\n    void bar(void) {\n        for(std::vector<std::string>::const_iterator it = m_str.begin(); it != m_str.end(); ++it) {;}\n    }\n};" $)
5973:
|
5978:
5979: ;
5980: $if $(@expr1073745971 $!@expr1073745972 $assertEquals $(@expr1073745973 "cppcheck-2.8/test/testclass.cpp" $, 5980 $, "[test.cpp:5]: (style, inconclusive) Technically the member function 'A::bar' can be const.\n" $, errout@var100 .@expr4150 str (@expr4151 ) $) $) { $return ; }
5981:
5982:
5983: $checkConst_ $(@expr1073745976 "cppcheck-2.8/test/testclass.cpp" $, 5983 $, "struct S {\n    std::vector<T*> v;\n    void f() const;\n};\nvoid S::f() const {\n    for (std::vector<T*>::const_iterator it = v.begin(), end = v.end(); it != end; ++it) {}\n}\n" $)
5984:
|
5988:
5989: ;
5990: $if $(@expr1073745977 $!@expr1073745978 $assertEquals $(@expr1073745979 "cppcheck-2.8/test/testclass.cpp" $, 5990 $, "" $, errout@var100 .@expr4150 str (@expr4151 ) $) $) { $return ; }
5991: }
5992:
5993: void const75 ( ) {
5994: $checkConst_ $(@expr1073745982 "cppcheck-2.8/test/testclass.cpp" $, 5994 $, "namespace N { int i = 0; }\nstruct S {\n    int i;\n    void f() {\n        if (N::i) {}\n    }\n};\n" $)
5995:
|
5999:
6000: ;
6001: $if $(@expr1073745983 $!@expr1073745984 $assertEquals $(@expr1073745985 "cppcheck-2.8/test/testclass.cpp" $, 6001 $, "[test.cpp:4]: (performance, inconclusive) Technically the member function 'S::f' can be static (but you may consider moving to unnamed namespace).\n" $, errout@var100 .@expr4162 str (@expr4163 ) $) $) { $return ; }
6002:
6003: $checkConst_ $(@expr1073745988 "cppcheck-2.8/test/testclass.cpp" $, 6003 $, "int i = 0;\nstruct S {\n    int i;\n    void f() {\n        if (::i) {}\n    }\n};\n" $)
6004:
|
6008:
6009: ;
6010: $if $(@expr1073745989 $!@expr1073745990 $assertEquals $(@expr1073745991 "cppcheck-2.8/test/testclass.cpp" $, 6010 $, "[test.cpp:4]: (performance, inconclusive) Technically the member function 'S::f' can be static (but you may consider moving to unnamed namespace).\n" $, errout@var100 .@expr4162 str (@expr4163 ) $) $) { $return ; }
6011:
6012: $checkConst_ $(@expr1073745994 "cppcheck-2.8/test/testclass.cpp" $, 6012 $, "namespace N {\n    struct S {\n        int i;\n        void f() {\n            if (N::S::i) {}\n        }\n    };\n}\n" $)
6013:
|
6018:
6019: ;
6020: $if $(@expr1073745995 $!@expr1073745996 $assertEquals $(@expr1073745997 "cppcheck-2.8/test/testclass.cpp" $, 6020 $, "[test.cpp:4]: (style, inconclusive) Technically the member function 'N::S::f' can be const.\n" $, errout@var100 .@expr4162 str (@expr4163 ) $) $) { $return ; }
6021: }
6022:
6023: void const76 ( ) {
6024: $checkConst_ $(@expr1073746000 "cppcheck-2.8/test/testclass.cpp" $, 6024 $, "struct S {\n    enum E {};\n    void f(const T* t);\n    E e;\n};\nstruct T { void e(); };\nvoid S::f(const T* t) {\n    const_cast<T*>(t)->e();\n};\n" $)
6025:
|
6031:
6032: ;
6033: $if $(@expr1073746001 $!@expr1073746002 $assertEquals $(@expr1073746003 "cppcheck-2.8/test/testclass.cpp" $, 6033 $, "[test.cpp:7] -> [test.cpp:3]: (performance, inconclusive) Technically the member function 'S::f' can be static (but you may consider moving to unnamed namespace).\n" $, errout@var100 .@expr1073746004 str (@expr1073746005 ) $) $) { $return
6034: ; }
6035: }
6036:
6037: void const77 ( ) {
6038: $checkConst_ $(@expr1073746006 "cppcheck-2.8/test/testclass.cpp" $, 6038 $, "template <typename T>\nstruct S {\n    std::vector<T> const* f() const { return p; }\n    std::vector<T> const* p;\n};\n" $)
6039:
6040:
6041:
6042: ;
6043: $if $(@expr1073746007 $!@expr1073746008 $assertEquals $(@expr1073746009 "cppcheck-2.8/test/testclass.cpp" $, 6043 $, "" $, errout@var100 .@expr4186 str (@expr4187 ) $) $) { $return ; }
6044:
6045: $checkConst_ $(@expr1073746012 "cppcheck-2.8/test/testclass.cpp" $, 6045 $, "struct S {\n    std::vector<const int*> v;\n    std::vector<const int*>& f() { return v; }\n};\n" $)
6046:
6047:
6048: ;
6049: $if $(@expr1073746013 $!@expr1073746014 $assertEquals $(@expr1073746015 "cppcheck-2.8/test/testclass.cpp" $, 6049 $, "" $, errout@var100 .@expr4186 str (@expr4187 ) $) $) { $return ; }
6050: }
6051:
6052: void const78 ( ) {
6053: $checkConst_ $(@expr1073746018 "cppcheck-2.8/test/testclass.cpp" $, 6053 $, "struct S {\n    typedef void(S::* F)();\n    void g(F f);\n};\nvoid S::g(F f) {\n    (this->*f)();\n}\n" $)
6054:
|
6058:
6059: ;
6060: $if $(@expr1073746019 $!@expr1073746020 $assertEquals $(@expr1073746021 "cppcheck-2.8/test/testclass.cpp" $, 6060 $, "" $, errout@var100 .@expr4198 str (@expr4199 ) $) $) { $return ; }
6061:
6062: $checkConst_ $(@expr1073746024 "cppcheck-2.8/test/testclass.cpp" $, 6062 $, "struct S {\n    using F = void(S::*)();\n    void g(F f);\n};\nvoid S::g(F f) {\n    (this->*f)();\n}\n" $)
6063:
|
6067:
6068: ;
6069: $if $(@expr1073746025 $!@expr1073746026 $assertEquals $(@expr1073746027 "cppcheck-2.8/test/testclass.cpp" $, 6069 $, "" $, errout@var100 .@expr4198 str (@expr4199 ) $) $) { $return ; }
6070: }
6071:
6072: void const79 ( ) {
6073: $checkConst_ $(@expr1073746030 "cppcheck-2.8/test/testclass.cpp" $, 6073 $, "class A {\npublic:\n    char* f() {\n        return nullptr;\n    }\n};\n" $)
6074:
|
6077:
6078: ;
6079: $if $(@expr1073746031 $!@expr1073746032 $assertEquals $(@expr1073746033 "cppcheck-2.8/test/testclass.cpp" $, 6079 $, "[test.cpp:3]: (performance, inconclusive) Technically the member function 'A::f' can be static (but you may consider moving to unnamed namespace).\n" $, errout@var100 .@expr1073746034 str (@expr1073746035 ) $) $) { $return
6080: ; }
6081: }
6082:
6083: void const_handleDefaultParameters ( ) {
6084: $checkConst_ $(@expr1073746036 "cppcheck-2.8/test/testclass.cpp" $, 6084 $, "struct Foo {\n    void foo1(int i, int j = 0) {\n        return func(this);\n    }\n    int bar1() {\n        return foo1(1);\n    }\n    int bar2() {\n        return foo1(1, 2);\n    }\n    int bar3() {\n        return foo1(1, 2, 3);\n    }\n    int bar4() {\n        return foo1();\n    }\n    void foo2(int i = 0) {\n        return func(this);\n    }\n    int bar5() {\n        return foo2();\n    }\n    void foo3() {\n        return func(this);\n    }\n    int bar6() {\n        return foo3();\n    }\n};" $)
6085:
|
6111:
6112: ;
6113: $if $(@expr1073746037 $!@expr1073746038 $assertEquals $(@expr1073746039 "cppcheck-2.8/test/testclass.cpp" $, 6113 $, "[test.cpp:11]: (performance, inconclusive) Technically the member function 'Foo::bar3' can be static (but you may consider moving to unnamed namespace).\n[test.cpp:14]: (performance, inconclusive) Technically the member function 'Foo::bar4' can be static (but you may consider moving to unnamed namespace).\n" $, errout@var100 .@expr1073746040 str (@expr1073746041 ) $) $) { $return
6114: ; }
6115: }
6116:
6117: void const_passThisToMemberOfOtherClass ( ) {
6118: $checkConst_ $(@expr1073746042 "cppcheck-2.8/test/testclass.cpp" $, 6118 $, "struct Foo {\n    void foo() {\n        Bar b;\n        b.takeFoo(this);\n    }\n};" $)
6119:
|
6122:
6123: ;
6124: $if $(@expr1073746043 $!@expr1073746044 $assertEquals $(@expr1073746045 "cppcheck-2.8/test/testclass.cpp" $, 6124 $, "" $, errout@var100 .@expr4222 str (@expr4223 ) $) $) { $return ; }
6125:
6126: $checkConst_ $(@expr1073746048 "cppcheck-2.8/test/testclass.cpp" $, 6126 $, "struct Foo {\n    void foo() {\n        Foo f;\n        f.foo();\n    }\n};" $)
6127:
|
6130:
6131: ;
6132: $if $(@expr1073746049 $!@expr1073746050 $assertEquals $(@expr1073746051 "cppcheck-2.8/test/testclass.cpp" $, 6132 $, "[test.cpp:2]: (performance, inconclusive) Technically the member function 'Foo::foo' can be static (but you may consider moving to unnamed namespace).\n" $, errout@var100 .@expr4222 str (@expr4223 ) $) $) { $return ; }
6133:
6134: $checkConst_ $(@expr1073746054 "cppcheck-2.8/test/testclass.cpp" $, 6134 $, "struct A;\nstruct B {\n    void operator()(A *a);\n};\nstruct A {\n    void dostuff() {\n        B()(this);\n    }\n};" $)
6135:
|
6141:
6142: ;
6143: $if $(@expr1073746055 $!@expr1073746056 $assertEquals $(@expr1073746057 "cppcheck-2.8/test/testclass.cpp" $, 6143 $, "" $, errout@var100 .@expr4222 str (@expr4223 ) $) $) { $return ; }
6144: }
6145:
6146: void assigningPointerToPointerIsNotAConstOperation ( ) {
6147: $checkConst_ $(@expr1073746060 "cppcheck-2.8/test/testclass.cpp" $, 6147 $, "struct s\n{\n    int** v;\n    void f()\n    {\n        v = 0;\n    }\n};" $)
6148:
|
6153:
6154: ;
6155: $if $(@expr1073746061 $!@expr1073746062 $assertEquals $(@expr1073746063 "cppcheck-2.8/test/testclass.cpp" $, 6155 $, "" $, errout@var100 .@expr1073746064 str (@expr1073746065 ) $) $) { $return ; }
6156: }
6157:
6158: void assigningArrayElementIsNotAConstOperation ( ) {
6159: $checkConst_ $(@expr1073746066 "cppcheck-2.8/test/testclass.cpp" $, 6159 $, "struct s\n{\n    ::std::string v[3];\n    void f()\n    {\n        v[0] = \"Happy new year!\";\n    }\n};" $)
6160:
|
6165:
6166: ;
6167: $if $(@expr1073746067 $!@expr1073746068 $assertEquals $(@expr1073746069 "cppcheck-2.8/test/testclass.cpp" $, 6167 $, "" $, errout@var100 .@expr1073746070 str (@expr1073746071 ) $) $) { $return ; }
6168: }
6169:
6170:
6171: void constincdec ( ) {
6172: $checkConst_ $(@expr1073746072 "cppcheck-2.8/test/testclass.cpp" $, 6172 $, "class Fred {\n    int a;\n    void nextA() { return ++a; }\n};" $)
6173:
6174:
6175: ;
6176: $if $(@expr1073746073 $!@expr1073746074 $assertEquals $(@expr1073746075 "cppcheck-2.8/test/testclass.cpp" $, 6176 $, "" $, errout@var100 .@expr4252 str (@expr4253 ) $) $) { $return ; }
6177:
6178: $checkConst_ $(@expr1073746078 "cppcheck-2.8/test/testclass.cpp" $, 6178 $, "class Fred {\n    int a;\n    void nextA() { return --a; }\n};" $)
6179:
6180:
6181: ;
6182: $if $(@expr1073746079 $!@expr1073746080 $assertEquals $(@expr1073746081 "cppcheck-2.8/test/testclass.cpp" $, 6182 $, "" $, errout@var100 .@expr4252 str (@expr4253 ) $) $) { $return ; }
6183:
6184: $checkConst_ $(@expr1073746084 "cppcheck-2.8/test/testclass.cpp" $, 6184 $, "class Fred {\n    int a;\n    void nextA() { return a++; }\n};" $)
6185:
6186:
6187: ;
6188: $if $(@expr1073746085 $!@expr1073746086 $assertEquals $(@expr1073746087 "cppcheck-2.8/test/testclass.cpp" $, 6188 $, "" $, errout@var100 .@expr4252 str (@expr4253 ) $) $) { $return ; }
6189:
6190: $checkConst_ $(@expr1073746090 "cppcheck-2.8/test/testclass.cpp" $, 6190 $, "class Fred {\n    int a;\n    void nextA() { return a--; }\n};" $)
6191:
6192:
6193: ;
6194: $if $(@expr1073746091 $!@expr1073746092 $assertEquals $(@expr1073746093 "cppcheck-2.8/test/testclass.cpp" $, 6194 $, "" $, errout@var100 .@expr4252 str (@expr4253 ) $) $) { $return ; }
6195:
6196: $checkConst_ $(@expr1073746096 "cppcheck-2.8/test/testclass.cpp" $, 6196 $, "int a;\nclass Fred {\n    void nextA() { return ++a; }\n};" $)
6197:
6198:
6199: ;
6200: $if $(@expr1073746097 $!@expr1073746098 $assertEquals $(@expr1073746099 "cppcheck-2.8/test/testclass.cpp" $, 6200 $, "[test.cpp:3]: (performance, inconclusive) Technically the member function 'Fred::nextA' can be static (but you may consider moving to unnamed namespace).\n" $, errout@var100 .@expr4252 str (@expr4253 ) $) $) { $return ; }
6201:
6202: $checkConst_ $(@expr1073746102 "cppcheck-2.8/test/testclass.cpp" $, 6202 $, "int a;\nclass Fred {\n    void nextA() { return --a; }\n};" $)
6203:
6204:
6205: ;
6206: $if $(@expr1073746103 $!@expr1073746104 $assertEquals $(@expr1073746105 "cppcheck-2.8/test/testclass.cpp" $, 6206 $, "[test.cpp:3]: (performance, inconclusive) Technically the member function 'Fred::nextA' can be static (but you may consider moving to unnamed namespace).\n" $, errout@var100 .@expr4252 str (@expr4253 ) $) $) { $return ; }
6207:
6208: $checkConst_ $(@expr1073746108 "cppcheck-2.8/test/testclass.cpp" $, 6208 $, "int a;\nclass Fred {\n    void nextA() { return a++; }\n};" $)
6209:
6210:
6211: ;
6212: $if $(@expr1073746109 $!@expr1073746110 $assertEquals $(@expr1073746111 "cppcheck-2.8/test/testclass.cpp" $, 6212 $, "[test.cpp:3]: (performance, inconclusive) Technically the member function 'Fred::nextA' can be static (but you may consider moving to unnamed namespace).\n" $, errout@var100 .@expr4252 str (@expr4253 ) $) $) { $return ; }
6213:
6214: $checkConst_ $(@expr1073746114 "cppcheck-2.8/test/testclass.cpp" $, 6214 $, "int a;\nclass Fred {\n    void nextA() { return a--; }\n};" $)
6215:
6216:
6217: ;
6218: $if $(@expr1073746115 $!@expr1073746116 $assertEquals $(@expr1073746117 "cppcheck-2.8/test/testclass.cpp" $, 6218 $, "[test.cpp:3]: (performance, inconclusive) Technically the member function 'Fred::nextA' can be static (but you may consider moving to unnamed namespace).\n" $, errout@var100 .@expr4252 str (@expr4253 ) $) $) { $return ; }
6219: }
6220:
6221: void constassign1 ( ) {
6222: $checkConst_ $(@expr1073746120 "cppcheck-2.8/test/testclass.cpp" $, 6222 $, "class Fred {\n    int a;\n    void nextA() { return a=1; }\n};" $)
6223:
6224:
6225: ;
6226: $if $(@expr1073746121 $!@expr1073746122 $assertEquals $(@expr1073746123 "cppcheck-2.8/test/testclass.cpp" $, 6226 $, "" $, errout@var100 .@expr4300 str (@expr4301 ) $) $) { $return ; }
6227:
6228: $checkConst_ $(@expr1073746126 "cppcheck-2.8/test/testclass.cpp" $, 6228 $, "class Fred {\n    int a;\n    void nextA() { return a-=1; }\n};" $)
6229:
6230:
6231: ;
6232: $if $(@expr1073746127 $!@expr1073746128 $assertEquals $(@expr1073746129 "cppcheck-2.8/test/testclass.cpp" $, 6232 $, "" $, errout@var100 .@expr4300 str (@expr4301 ) $) $) { $return ; }
6233:
6234: $checkConst_ $(@expr1073746132 "cppcheck-2.8/test/testclass.cpp" $, 6234 $, "class Fred {\n    int a;\n    void nextA() { return a+=1; }\n};" $)
6235:
6236:
6237: ;
6238: $if $(@expr1073746133 $!@expr1073746134 $assertEquals $(@expr1073746135 "cppcheck-2.8/test/testclass.cpp" $, 6238 $, "" $, errout@var100 .@expr4300 str (@expr4301 ) $) $) { $return ; }
6239:
6240: $checkConst_ $(@expr1073746138 "cppcheck-2.8/test/testclass.cpp" $, 6240 $, "class Fred {\n    int a;\n    void nextA() { return a*=-1; }\n};" $)
6241:
6242:
6243: ;
6244: $if $(@expr1073746139 $!@expr1073746140 $assertEquals $(@expr1073746141 "cppcheck-2.8/test/testclass.cpp" $, 6244 $, "" $, errout@var100 .@expr4300 str (@expr4301 ) $) $) { $return ; }
6245:
6246: $checkConst_ $(@expr1073746144 "cppcheck-2.8/test/testclass.cpp" $, 6246 $, "class Fred {\n    int a;\n    void nextA() { return a/=-2; }\n};" $)
6247:
6248:
6249: ;
6250: $if $(@expr1073746145 $!@expr1073746146 $assertEquals $(@expr1073746147 "cppcheck-2.8/test/testclass.cpp" $, 6250 $, "" $, errout@var100 .@expr4300 str (@expr4301 ) $) $) { $return ; }
6251:
6252: $checkConst_ $(@expr1073746150 "cppcheck-2.8/test/testclass.cpp" $, 6252 $, "int a;\nclass Fred {\n    void nextA() { return a=1; }\n};" $)
6253:
6254:
6255: ;
6256: $if $(@expr1073746151 $!@expr1073746152 $assertEquals $(@expr1073746153 "cppcheck-2.8/test/testclass.cpp" $, 6256 $, "[test.cpp:3]: (performance, inconclusive) Technically the member function 'Fred::nextA' can be static (but you may consider moving to unnamed namespace).\n" $, errout@var100 .@expr4300 str (@expr4301 ) $) $) { $return ; }
6257:
6258: $checkConst_ $(@expr1073746156 "cppcheck-2.8/test/testclass.cpp" $, 6258 $, "int a;\nclass Fred {\n    void nextA() { return a-=1; }\n};" $)
6259:
6260:
6261: ;
6262: $if $(@expr1073746157 $!@expr1073746158 $assertEquals $(@expr1073746159 "cppcheck-2.8/test/testclass.cpp" $, 6262 $, "[test.cpp:3]: (performance, inconclusive) Technically the member function 'Fred::nextA' can be static (but you may consider moving to unnamed namespace).\n" $, errout@var100 .@expr4300 str (@expr4301 ) $) $) { $return ; }
6263:
6264: $checkConst_ $(@expr1073746162 "cppcheck-2.8/test/testclass.cpp" $, 6264 $, "int a;\nclass Fred {\n    void nextA() { return a+=1; }\n};" $)
6265:
6266:
6267: ;
6268: $if $(@expr1073746163 $!@expr1073746164 $assertEquals $(@expr1073746165 "cppcheck-2.8/test/testclass.cpp" $, 6268 $, "[test.cpp:3]: (performance, inconclusive) Technically the member function 'Fred::nextA' can be static (but you may consider moving to unnamed namespace).\n" $, errout@var100 .@expr4300 str (@expr4301 ) $) $) { $return ; }
6269:
6270: $checkConst_ $(@expr1073746168 "cppcheck-2.8/test/testclass.cpp" $, 6270 $, "int a;\nclass Fred {\n    void nextA() { return a*=-1; }\n};" $)
6271:
6272:
6273: ;
6274: $if $(@expr1073746169 $!@expr1073746170 $assertEquals $(@expr1073746171 "cppcheck-2.8/test/testclass.cpp" $, 6274 $, "[test.cpp:3]: (performance, inconclusive) Technically the member function 'Fred::nextA' can be static (but you may consider moving to unnamed namespace).\n" $, errout@var100 .@expr4300 str (@expr4301 ) $) $) { $return ; }
6275:
6276: $checkConst_ $(@expr1073746174 "cppcheck-2.8/test/testclass.cpp" $, 6276 $, "int a;\nclass Fred {\n    void nextA() { return a/=-2; }\n};" $)
6277:
6278:
6279: ;
6280: $if $(@expr1073746175 $!@expr1073746176 $assertEquals $(@expr1073746177 "cppcheck-2.8/test/testclass.cpp" $, 6280 $, "[test.cpp:3]: (performance, inconclusive) Technically the member function 'Fred::nextA' can be static (but you may consider moving to unnamed namespace).\n" $, errout@var100 .@expr4300 str (@expr4301 ) $) $) { $return ; }
6281: }
6282:
6283: void constassign2 ( ) {
6284: $checkConst_ $(@expr1073746180 "cppcheck-2.8/test/testclass.cpp" $, 6284 $, "class Fred {\n    struct A { int a; } s;\n    void nextA() { return s.a=1; }\n};" $)
6285:
6286:
6287: ;
6288: $if $(@expr1073746181 $!@expr1073746182 $assertEquals $(@expr1073746183 "cppcheck-2.8/test/testclass.cpp" $, 6288 $, "" $, errout@var100 .@expr4360 str (@expr4361 ) $) $) { $return ; }
6289:
6290: $checkConst_ $(@expr1073746186 "cppcheck-2.8/test/testclass.cpp" $, 6290 $, "class Fred {\n    struct A { int a; } s;\n    void nextA() { return s.a-=1; }\n};" $)
6291:
6292:
6293: ;
6294: $if $(@expr1073746187 $!@expr1073746188 $assertEquals $(@expr1073746189 "cppcheck-2.8/test/testclass.cpp" $, 6294 $, "" $, errout@var100 .@expr4360 str (@expr4361 ) $) $) { $return ; }
6295:
6296: $checkConst_ $(@expr1073746192 "cppcheck-2.8/test/testclass.cpp" $, 6296 $, "class Fred {\n    struct A { int a; } s;\n    void nextA() { return s.a+=1; }\n};" $)
6297:
6298:
6299: ;
6300: $if $(@expr1073746193 $!@expr1073746194 $assertEquals $(@expr1073746195 "cppcheck-2.8/test/testclass.cpp" $, 6300 $, "" $, errout@var100 .@expr4360 str (@expr4361 ) $) $) { $return ; }
6301:
6302: $checkConst_ $(@expr1073746198 "cppcheck-2.8/test/testclass.cpp" $, 6302 $, "class Fred {\n    struct A { int a; } s;\n    void nextA() { return s.a*=-1; }\n};" $)
6303:
6304:
6305: ;
6306: $if $(@expr1073746199 $!@expr1073746200 $assertEquals $(@expr1073746201 "cppcheck-2.8/test/testclass.cpp" $, 6306 $, "" $, errout@var100 .@expr4360 str (@expr4361 ) $) $) { $return ; }
6307:
6308: $checkConst_ $(@expr1073746204 "cppcheck-2.8/test/testclass.cpp" $, 6308 $, "struct A { int a; } s;\nclass Fred {\n    void nextA() { return s.a=1; }\n};" $)
6309:
6310:
6311: ;
6312: $if $(@expr1073746205 $!@expr1073746206 $assertEquals $(@expr1073746207 "cppcheck-2.8/test/testclass.cpp" $, 6312 $, "[test.cpp:3]: (performance, inconclusive) Technically the member function 'Fred::nextA' can be static (but you may consider moving to unnamed namespace).\n" $, errout@var100 .@expr4360 str (@expr4361 ) $) $) { $return ; }
6313:
6314: $checkConst_ $(@expr1073746210 "cppcheck-2.8/test/testclass.cpp" $, 6314 $, "struct A { int a; } s;\nclass Fred {\n    void nextA() { return s.a-=1; }\n};" $)
6315:
6316:
6317: ;
6318: $if $(@expr1073746211 $!@expr1073746212 $assertEquals $(@expr1073746213 "cppcheck-2.8/test/testclass.cpp" $, 6318 $, "[test.cpp:3]: (performance, inconclusive) Technically the member function 'Fred::nextA' can be static (but you may consider moving to unnamed namespace).\n" $, errout@var100 .@expr4360 str (@expr4361 ) $) $) { $return ; }
6319:
6320: $checkConst_ $(@expr1073746216 "cppcheck-2.8/test/testclass.cpp" $, 6320 $, "struct A { int a; } s;\nclass Fred {\n    void nextA() { return s.a+=1; }\n};" $)
6321:
6322:
6323: ;
6324: $if $(@expr1073746217 $!@expr1073746218 $assertEquals $(@expr1073746219 "cppcheck-2.8/test/testclass.cpp" $, 6324 $, "[test.cpp:3]: (performance, inconclusive) Technically the member function 'Fred::nextA' can be static (but you may consider moving to unnamed namespace).\n" $, errout@var100 .@expr4360 str (@expr4361 ) $) $) { $return ; }
6325:
6326: $checkConst_ $(@expr1073746222 "cppcheck-2.8/test/testclass.cpp" $, 6326 $, "struct A { int a; } s;\nclass Fred {\n    void nextA() { return s.a*=-1; }\n};" $)
6327:
6328:
6329: ;
6330: $if $(@expr1073746223 $!@expr1073746224 $assertEquals $(@expr1073746225 "cppcheck-2.8/test/testclass.cpp" $, 6330 $, "[test.cpp:3]: (performance, inconclusive) Technically the member function 'Fred::nextA' can be static (but you may consider moving to unnamed namespace).\n" $, errout@var100 .@expr4360 str (@expr4361 ) $) $) { $return ; }
6331:
6332: $checkConst_ $(@expr1073746228 "cppcheck-2.8/test/testclass.cpp" $, 6332 $, "struct A { int a; } s;\nclass Fred {\n    void nextA() { return s.a/=-2; }\n};" $)
6333:
6334:
6335: ;
6336: $if $(@expr1073746229 $!@expr1073746230 $assertEquals $(@expr1073746231 "cppcheck-2.8/test/testclass.cpp" $, 6336 $, "[test.cpp:3]: (performance, inconclusive) Technically the member function 'Fred::nextA' can be static (but you may consider moving to unnamed namespace).\n" $, errout@var100 .@expr4360 str (@expr4361 ) $) $) { $return ; }
6337:
6338: $checkConst_ $(@expr1073746234 "cppcheck-2.8/test/testclass.cpp" $, 6338 $, "struct A { int a; };\nclass Fred {\n    A s;\n    void nextA() { return s.a=1; }\n};" $)
6339:
6340:
6341:
6342: ;
6343: $if $(@expr1073746235 $!@expr1073746236 $assertEquals $(@expr1073746237 "cppcheck-2.8/test/testclass.cpp" $, 6343 $, "" $, errout@var100 .@expr4360 str (@expr4361 ) $) $) { $return ; }
6344:
6345: $checkConst_ $(@expr1073746240 "cppcheck-2.8/test/testclass.cpp" $, 6345 $, "struct A { int a; };\nclass Fred {\n    A s;\n    void nextA() { return s.a-=1; }\n};" $)
6346:
6347:
6348:
6349: ;
6350: $if $(@expr1073746241 $!@expr1073746242 $assertEquals $(@expr1073746243 "cppcheck-2.8/test/testclass.cpp" $, 6350 $, "" $, errout@var100 .@expr4360 str (@expr4361 ) $) $) { $return ; }
6351:
6352: $checkConst_ $(@expr1073746246 "cppcheck-2.8/test/testclass.cpp" $, 6352 $, "struct A { int a; };\nclass Fred {\n    A s;\n    void nextA() { return s.a+=1; }\n};" $)
6353:
6354:
6355:
6356: ;
6357: $if $(@expr1073746247 $!@expr1073746248 $assertEquals $(@expr1073746249 "cppcheck-2.8/test/testclass.cpp" $, 6357 $, "" $, errout@var100 .@expr4360 str (@expr4361 ) $) $) { $return ; }
6358:
6359: $checkConst_ $(@expr1073746252 "cppcheck-2.8/test/testclass.cpp" $, 6359 $, "struct A { int a; };\nclass Fred {\n    A s;\n    void nextA() { return s.a*=-1; }\n};" $)
6360:
6361:
6362:
6363: ;
6364: $if $(@expr1073746253 $!@expr1073746254 $assertEquals $(@expr1073746255 "cppcheck-2.8/test/testclass.cpp" $, 6364 $, "" $, errout@var100 .@expr4360 str (@expr4361 ) $) $) { $return ; }
6365:
6366: $checkConst_ $(@expr1073746258 "cppcheck-2.8/test/testclass.cpp" $, 6366 $, "struct A { int a; };\nclass Fred {\n    A s;\n    void nextA() { return s.a/=-2; }\n};" $)
6367:
6368:
6369:
6370: ;
6371: $if $(@expr1073746259 $!@expr1073746260 $assertEquals $(@expr1073746261 "cppcheck-2.8/test/testclass.cpp" $, 6371 $, "" $, errout@var100 .@expr4360 str (@expr4361 ) $) $) { $return ; }
6372: }
6373:
6374:
6375: void constincdecarray ( ) {
6376: $checkConst_ $(@expr1073746264 "cppcheck-2.8/test/testclass.cpp" $, 6376 $, "class Fred {\n    int a[2];\n    void nextA() { return ++a[0]; }\n};" $)
6377:
6378:
6379: ;
6380: $if $(@expr1073746265 $!@expr1073746266 $assertEquals $(@expr1073746267 "cppcheck-2.8/test/testclass.cpp" $, 6380 $, "" $, errout@var100 .@expr4444 str (@expr4445 ) $) $) { $return ; }
6381:
6382: $checkConst_ $(@expr1073746270 "cppcheck-2.8/test/testclass.cpp" $, 6382 $, "class Fred {\n    int a[2];\n    void nextA() { return --a[0]; }\n};" $)
6383:
6384:
6385: ;
6386: $if $(@expr1073746271 $!@expr1073746272 $assertEquals $(@expr1073746273 "cppcheck-2.8/test/testclass.cpp" $, 6386 $, "" $, errout@var100 .@expr4444 str (@expr4445 ) $) $) { $return ; }
6387:
6388: $checkConst_ $(@expr1073746276 "cppcheck-2.8/test/testclass.cpp" $, 6388 $, "class Fred {\n    int a[2];\n    void nextA() { return a[0]++; }\n};" $)
6389:
6390:
6391: ;
6392: $if $(@expr1073746277 $!@expr1073746278 $assertEquals $(@expr1073746279 "cppcheck-2.8/test/testclass.cpp" $, 6392 $, "" $, errout@var100 .@expr4444 str (@expr4445 ) $) $) { $return ; }
6393:
6394: $checkConst_ $(@expr1073746282 "cppcheck-2.8/test/testclass.cpp" $, 6394 $, "class Fred {\n    int a[2];\n    void nextA() { return a[0]--; }\n};" $)
6395:
6396:
6397: ;
6398: $if $(@expr1073746283 $!@expr1073746284 $assertEquals $(@expr1073746285 "cppcheck-2.8/test/testclass.cpp" $, 6398 $, "" $, errout@var100 .@expr4444 str (@expr4445 ) $) $) { $return ; }
6399:
6400: $checkConst_ $(@expr1073746288 "cppcheck-2.8/test/testclass.cpp" $, 6400 $, "int a[2];\nclass Fred {\n    void nextA() { return ++a[0]; }\n};" $)
6401:
6402:
6403: ;
6404: $if $(@expr1073746289 $!@expr1073746290 $assertEquals $(@expr1073746291 "cppcheck-2.8/test/testclass.cpp" $, 6404 $, "[test.cpp:3]: (performance, inconclusive) Technically the member function 'Fred::nextA' can be static (but you may consider moving to unnamed namespace).\n" $, errout@var100 .@expr4444 str (@expr4445 ) $) $) { $return ; }
6405:
6406: $checkConst_ $(@expr1073746294 "cppcheck-2.8/test/testclass.cpp" $, 6406 $, "int a[2];\nclass Fred {\n    void nextA() { return --a[0]; }\n};" $)
6407:
6408:
6409: ;
6410: $if $(@expr1073746295 $!@expr1073746296 $assertEquals $(@expr1073746297 "cppcheck-2.8/test/testclass.cpp" $, 6410 $, "[test.cpp:3]: (performance, inconclusive) Technically the member function 'Fred::nextA' can be static (but you may consider moving to unnamed namespace).\n" $, errout@var100 .@expr4444 str (@expr4445 ) $) $) { $return ; }
6411:
6412: $checkConst_ $(@expr1073746300 "cppcheck-2.8/test/testclass.cpp" $, 6412 $, "int a[2];\nclass Fred {\n    void nextA() { return a[0]++; }\n};" $)
6413:
6414:
6415: ;
6416: $if $(@expr1073746301 $!@expr1073746302 $assertEquals $(@expr1073746303 "cppcheck-2.8/test/testclass.cpp" $, 6416 $, "[test.cpp:3]: (performance, inconclusive) Technically the member function 'Fred::nextA' can be static (but you may consider moving to unnamed namespace).\n" $, errout@var100 .@expr4444 str (@expr4445 ) $) $) { $return ; }
6417:
6418: $checkConst_ $(@expr1073746306 "cppcheck-2.8/test/testclass.cpp" $, 6418 $, "int a[2];\nclass Fred {\n    void nextA() { return a[0]--; }\n};" $)
6419:
6420:
6421: ;
6422: $if $(@expr1073746307 $!@expr1073746308 $assertEquals $(@expr1073746309 "cppcheck-2.8/test/testclass.cpp" $, 6422 $, "[test.cpp:3]: (performance, inconclusive) Technically the member function 'Fred::nextA' can be static (but you may consider moving to unnamed namespace).\n" $, errout@var100 .@expr4444 str (@expr4445 ) $) $) { $return ; }
6423: }
6424:
6425: void constassignarray ( ) {
6426: $checkConst_ $(@expr1073746312 "cppcheck-2.8/test/testclass.cpp" $, 6426 $, "class Fred {\n    int a[2];\n    void nextA() { return a[0]=1; }\n};" $)
6427:
6428:
6429: ;
6430: $if $(@expr1073746313 $!@expr1073746314 $assertEquals $(@expr1073746315 "cppcheck-2.8/test/testclass.cpp" $, 6430 $, "" $, errout@var100 .@expr4492 str (@expr4493 ) $) $) { $return ; }
6431:
6432: $checkConst_ $(@expr1073746318 "cppcheck-2.8/test/testclass.cpp" $, 6432 $, "class Fred {\n    int a[2];\n    void nextA() { return a[0]-=1; }\n};" $)
6433:
6434:
6435: ;
6436: $if $(@expr1073746319 $!@expr1073746320 $assertEquals $(@expr1073746321 "cppcheck-2.8/test/testclass.cpp" $, 6436 $, "" $, errout@var100 .@expr4492 str (@expr4493 ) $) $) { $return ; }
6437:
6438: $checkConst_ $(@expr1073746324 "cppcheck-2.8/test/testclass.cpp" $, 6438 $, "class Fred {\n    int a[2];\n    void nextA() { return a[0]+=1; }\n};" $)
6439:
6440:
6441: ;
6442: $if $(@expr1073746325 $!@expr1073746326 $assertEquals $(@expr1073746327 "cppcheck-2.8/test/testclass.cpp" $, 6442 $, "" $, errout@var100 .@expr4492 str (@expr4493 ) $) $) { $return ; }
6443:
6444: $checkConst_ $(@expr1073746330 "cppcheck-2.8/test/testclass.cpp" $, 6444 $, "class Fred {\n    int a[2];\n    void nextA() { return a[0]*=-1; }\n};" $)
6445:
6446:
6447: ;
6448: $if $(@expr1073746331 $!@expr1073746332 $assertEquals $(@expr1073746333 "cppcheck-2.8/test/testclass.cpp" $, 6448 $, "" $, errout@var100 .@expr4492 str (@expr4493 ) $) $) { $return ; }
6449:
6450: $checkConst_ $(@expr1073746336 "cppcheck-2.8/test/testclass.cpp" $, 6450 $, "class Fred {\n    int a[2];\n    void nextA() { return a[0]/=-2; }\n};" $)
6451:
6452:
6453: ;
6454: $if $(@expr1073746337 $!@expr1073746338 $assertEquals $(@expr1073746339 "cppcheck-2.8/test/testclass.cpp" $, 6454 $, "" $, errout@var100 .@expr4492 str (@expr4493 ) $) $) { $return ; }
6455:
6456: $checkConst_ $(@expr1073746342 "cppcheck-2.8/test/testclass.cpp" $, 6456 $, "int a[2];\nclass Fred {\n    void nextA() { return a[0]=1; }\n};" $)
6457:
6458:
6459: ;
6460: $if $(@expr1073746343 $!@expr1073746344 $assertEquals $(@expr1073746345 "cppcheck-2.8/test/testclass.cpp" $, 6460 $, "[test.cpp:3]: (performance, inconclusive) Technically the member function 'Fred::nextA' can be static (but you may consider moving to unnamed namespace).\n" $, errout@var100 .@expr4492 str (@expr4493 ) $) $) { $return ; }
6461:
6462: $checkConst_ $(@expr1073746348 "cppcheck-2.8/test/testclass.cpp" $, 6462 $, "int a[2];\nclass Fred {\n    void nextA() { return a[0]-=1; }\n};" $)
6463:
6464:
6465: ;
6466: $if $(@expr1073746349 $!@expr1073746350 $assertEquals $(@expr1073746351 "cppcheck-2.8/test/testclass.cpp" $, 6466 $, "[test.cpp:3]: (performance, inconclusive) Technically the member function 'Fred::nextA' can be static (but you may consider moving to unnamed namespace).\n" $, errout@var100 .@expr4492 str (@expr4493 ) $) $) { $return ; }
6467:
6468: $checkConst_ $(@expr1073746354 "cppcheck-2.8/test/testclass.cpp" $, 6468 $, "int a[2];\nclass Fred {\n    void nextA() { return a[0]+=1; }\n};" $)
6469:
6470:
6471: ;
6472: $if $(@expr1073746355 $!@expr1073746356 $assertEquals $(@expr1073746357 "cppcheck-2.8/test/testclass.cpp" $, 6472 $, "[test.cpp:3]: (performance, inconclusive) Technically the member function 'Fred::nextA' can be static (but you may consider moving to unnamed namespace).\n" $, errout@var100 .@expr4492 str (@expr4493 ) $) $) { $return ; }
6473:
6474: $checkConst_ $(@expr1073746360 "cppcheck-2.8/test/testclass.cpp" $, 6474 $, "int a[2];\nclass Fred {\n    void nextA() { return a[0]*=-1; }\n};" $)
6475:
6476:
6477: ;
6478: $if $(@expr1073746361 $!@expr1073746362 $assertEquals $(@expr1073746363 "cppcheck-2.8/test/testclass.cpp" $, 6478 $, "[test.cpp:3]: (performance, inconclusive) Technically the member function 'Fred::nextA' can be static (but you may consider moving to unnamed namespace).\n" $, errout@var100 .@expr4492 str (@expr4493 ) $) $) { $return ; }
6479:
6480: $checkConst_ $(@expr1073746366 "cppcheck-2.8/test/testclass.cpp" $, 6480 $, "int a[2];\nclass Fred {\n    void nextA() { return a[0]/=-2; }\n};" $)
6481:
6482:
6483: ;
6484: $if $(@expr1073746367 $!@expr1073746368 $assertEquals $(@expr1073746369 "cppcheck-2.8/test/testclass.cpp" $, 6484 $, "[test.cpp:3]: (performance, inconclusive) Technically the member function 'Fred::nextA' can be static (but you may consider moving to unnamed namespace).\n" $, errout@var100 .@expr4492 str (@expr4493 ) $) $) { $return ; }
6485: }
6486:
6487:
6488: void constReturnReference ( ) {
6489: $checkConst_ $(@expr1073746372 "cppcheck-2.8/test/testclass.cpp" $, 6489 $, "class Fred {\n    int a;\n    int &getR() { return a; }\n    int *getP() { return &a; }};" $)
6490:
6491:
6492:
6493: ;
6494: $if $(@expr1073746373 $!@expr1073746374 $assertEquals $(@expr1073746375 "cppcheck-2.8/test/testclass.cpp" $, 6494 $, "" $, errout@var100 .@expr1073746376 str (@expr1073746377 ) $) $) { $return ; }
6495: }
6496:
6497:
6498: void constDelete ( ) {
6499: $checkConst_ $(@expr1073746378 "cppcheck-2.8/test/testclass.cpp" $, 6499 $, "class Fred {\n    int *a;\n    void clean() { delete a; }\n};" $)
6500:
6501:
6502: ;
6503: $if $(@expr1073746379 $!@expr1073746380 $assertEquals $(@expr1073746381 "cppcheck-2.8/test/testclass.cpp" $, 6503 $, "" $, errout@var100 .@expr1073746382 str (@expr1073746383 ) $) $) { $return ; }
6504: }
6505:
6506:
6507: void constLPVOID ( ) {
6508: $checkConst_ $(@expr1073746384 "cppcheck-2.8/test/testclass.cpp" $, 6508 $, "class Fred {\n    UNKNOWN a() { return 0; };\n};" $)
6509:
6510: ;
6511: $todoAssertEquals $(@expr1073746385 "cppcheck-2.8/test/testclass.cpp" $, 6511 $, "[test.cpp:2]: (performance, inconclusive) Technically the member function 'Fred::a' can be static.\n" $, "" $, errout@var100 .@expr4562 str (@expr4563 ) $) ;
6512:
6513:
6514: $checkConst_ $(@expr1073746388 "cppcheck-2.8/test/testclass.cpp" $, 6514 $, "class Fred {\n    foo bar;\n    UNKNOWN a() { return b; };\n};" $)
6515:
6516:
6517: ;
6518: $if $(@expr1073746389 $!@expr1073746390 $assertEquals $(@expr1073746391 "cppcheck-2.8/test/testclass.cpp" $, 6518 $, "" $, errout@var100 .@expr4562 str (@expr4563 ) $) $) { $return ; }
6519: }
6520:
6521:
6522: void constFunc ( ) {
6523: $checkConst_ $(@expr1073746394 "cppcheck-2.8/test/testclass.cpp" $, 6523 $, "class Fred {\n    void f() const { };\n    void a() { f(); };\n};" $)
6524:
6525:
6526: ;
6527: $if $(@expr1073746395 $!@expr1073746396 $assertEquals $(@expr1073746397 "cppcheck-2.8/test/testclass.cpp" $, 6527 $, "[test.cpp:2]: (performance, inconclusive) Technically the member function 'Fred::f' can be static (but you may consider moving to unnamed namespace).\n[test.cpp:3]: (style, inconclusive) Technically the member function 'Fred::a' can be const.\n" $, errout@var100 .@expr4574 str (@expr4575 ) $) $) { $return
6528: ; }
6529:
6530:
6531: $checkConst_ $(@expr1073746400 "cppcheck-2.8/test/testclass.cpp" $, 6531 $, "class A\n{\n   std::vector<int> m_v;\npublic:\n   A(){}\n   unsigned int GetVecSize()  {return m_v.size();}\n};" $)
6532:
|
6536:
6537: ;
6538: $if $(@expr1073746401 $!@expr1073746402 $assertEquals $(@expr1073746403 "cppcheck-2.8/test/testclass.cpp" $, 6538 $, "[test.cpp:6]: (style, inconclusive) Technically the member function 'A::GetVecSize' can be const.\n" $, errout@var100 .@expr4574 str (@expr4575 ) $) $) { $return ; }
6539:
6540: $checkConst_ $(@expr1073746406 "cppcheck-2.8/test/testclass.cpp" $, 6540 $, "class A\n{\n   std::vector<int> m_v;\npublic:\n   A(){}\n   bool GetVecEmpty()  {return m_v.empty();}\n};" $)
6541:
|
6545:
6546: ;
6547: $if $(@expr1073746407 $!@expr1073746408 $assertEquals $(@expr1073746409 "cppcheck-2.8/test/testclass.cpp" $, 6547 $, "[test.cpp:6]: (style, inconclusive) Technically the member function 'A::GetVecEmpty' can be const.\n" $, errout@var100 .@expr4574 str (@expr4575 ) $) $) { $return ; }
6548: }
6549:
6550: void constVirtualFunc ( ) {
6551:
6552: $checkConst_ $(@expr1073746412 "cppcheck-2.8/test/testclass.cpp" $, 6552 $, "class A { };\nclass B : public A {\n   int b;\npublic:\n   B() : b(0) { }\n   int func() { return b; }\n};" $)
6553:
|
6557:
6558: ;
6559: $if $(@expr1073746413 $!@expr1073746414 $assertEquals $(@expr1073746415 "cppcheck-2.8/test/testclass.cpp" $, 6559 $, "[test.cpp:6]: (style, inconclusive) Technically the member function 'B::func' can be const.\n" $, errout@var100 .@expr4592 str (@expr4593 ) $) $) { $return ; }
6560:
6561: $checkConst_ $(@expr1073746418 "cppcheck-2.8/test/testclass.cpp" $, 6561 $, "class A { };\nclass B : public A {\n   int b;\npublic:\n   B() : b(0) { }\n   int func();\n};\nint B::func() { return b; }" $)
6562:
|
6567:
6568: ;
6569: $if $(@expr1073746419 $!@expr1073746420 $assertEquals $(@expr1073746421 "cppcheck-2.8/test/testclass.cpp" $, 6569 $, "[test.cpp:8] -> [test.cpp:6]: (style, inconclusive) Technically the member function 'B::func' can be const.\n" $, errout@var100 .@expr4592 str (@expr4593 ) $) $) { $return ; }
6570:
6571:
6572: $checkConst_ $(@expr1073746424 "cppcheck-2.8/test/testclass.cpp" $, 6572 $, "class A {\npublic:\n    int func();\n};\nclass B : public A {\n    int b;\npublic:\n    B() : b(0) { }\n    int func() { return b; }\n};" $)
6573:
|
6580:
6581: ;
6582: $if $(@expr1073746425 $!@expr1073746426 $assertEquals $(@expr1073746427 "cppcheck-2.8/test/testclass.cpp" $, 6582 $, "[test.cpp:9]: (style, inconclusive) Technically the member function 'B::func' can be const.\n" $, errout@var100 .@expr4592 str (@expr4593 ) $) $) { $return ; }
6583:
6584: $checkConst_ $(@expr1073746430 "cppcheck-2.8/test/testclass.cpp" $, 6584 $, "class A {\npublic:\n    int func();\n};\nclass B : public A {\n    int b;\npublic:\n    B() : b(0) { }\n    int func();\n};\nint B::func() { return b; }" $)
6585:
|
6593:
6594: ;
6595: $if $(@expr1073746431 $!@expr1073746432 $assertEquals $(@expr1073746433 "cppcheck-2.8/test/testclass.cpp" $, 6595 $, "[test.cpp:11] -> [test.cpp:9]: (style, inconclusive) Technically the member function 'B::func' can be const.\n" $, errout@var100 .@expr4592 str (@expr4593 ) $) $) { $return ; }
6596:
6597:
6598: $checkConst_ $(@expr1073746436 "cppcheck-2.8/test/testclass.cpp" $, 6598 $, "class A {\npublic:\n    virtual int func();\n};\nclass B : public A {\n    int b;\npublic:\n    B() : b(0) { }\n    int func() { return b; }\n};" $)
6599:
|
6606:
6607: ;
6608: $if $(@expr1073746437 $!@expr1073746438 $assertEquals $(@expr1073746439 "cppcheck-2.8/test/testclass.cpp" $, 6608 $, "" $, errout@var100 .@expr4592 str (@expr4593 ) $) $) { $return ; }
6609:
6610: $checkConst_ $(@expr1073746442 "cppcheck-2.8/test/testclass.cpp" $, 6610 $, "class A {\npublic:\n    virtual int func();\n};\nclass B : public A {\n    int b;\npublic:\n    B() : b(0) { }\n    int func();\n};\nint B::func() { return b; }" $)
6611:
|
6619:
6620: ;
6621: $if $(@expr1073746443 $!@expr1073746444 $assertEquals $(@expr1073746445 "cppcheck-2.8/test/testclass.cpp" $, 6621 $, "" $, errout@var100 .@expr4592 str (@expr4593 ) $) $) { $return ; }
6622:
6623: $checkConst_ $(@expr1073746448 "cppcheck-2.8/test/testclass.cpp" $, 6623 $, "class A {\npublic:\n    virtual int func() = 0;\n};\nclass B : public A {\n    int b;\npublic:\n    B() : b(0) { }\n    int func();\n};\nint B::func() { return b; }" $)
6624:
|
6632:
6633: ;
6634: $if $(@expr1073746449 $!@expr1073746450 $assertEquals $(@expr1073746451 "cppcheck-2.8/test/testclass.cpp" $, 6634 $, "" $, errout@var100 .@expr4592 str (@expr4593 ) $) $) { $return ; }
6635:
6636:
6637: $checkConst_ $(@expr1073746454 "cppcheck-2.8/test/testclass.cpp" $, 6637 $, "class A {\n    int a;\npublic:\n    A() : a(0) { }\n    int func() { return a; }\n};\nclass B : public A {\n    int b;\npublic:\n    B() : b(0) { }\n    int func() { return b; }\n};\nclass C : public B {\n    int c;\npublic:\n    C() : c(0) { }\n    int func() { return c; }\n};" $)
6638:
|
6653:
6654: ;
6655: $if $(@expr1073746455 $!@expr1073746456 $assertEquals $(@expr1073746457 "cppcheck-2.8/test/testclass.cpp" $, 6655 $, "[test.cpp:5]: (style, inconclusive) Technically the member function 'A::func' can be const.\n[test.cpp:11]: (style, inconclusive) Technically the member function 'B::func' can be const.\n[test.cpp:17]: (style, inconclusive) Technically the member function 'C::func' can be const.\n" $, errout@var100 .@expr4592 str (@expr4593 ) $) $) { $return
6656:
6657: ; }
6658:
6659: $checkConst_ $(@expr1073746460 "cppcheck-2.8/test/testclass.cpp" $, 6659 $, "class A {\n    int a;\npublic:\n    A() : a(0) { }\n    int func();\n};\nint A::func() { return a; }\nclass B : public A {\n    int b;\npublic:\n    B() : b(0) { }\n    int func();\n};\nint B::func() { return b; }\nclass C : public B {\n    int c;\npublic:\n    C() : c(0) { }\n    int func();\n};\nint C::func() { return c; }" $)
6660:
|
6678:
6679: ;
6680: $if $(@expr1073746461 $!@expr1073746462 $assertEquals $(@expr1073746463 "cppcheck-2.8/test/testclass.cpp" $, 6680 $, "[test.cpp:7] -> [test.cpp:5]: (style, inconclusive) Technically the member function 'A::func' can be const.\n[test.cpp:14] -> [test.cpp:12]: (style, inconclusive) Technically the member function 'B::func' can be const.\n[test.cpp:21] -> [test.cpp:19]: (style, inconclusive) Technically the member function 'C::func' can be const.\n" $, errout@var100 .@expr4592 str (@expr4593 ) $) $) { $return
6681:
6682: ; }
6683:
6684:
6685: $checkConst_ $(@expr1073746466 "cppcheck-2.8/test/testclass.cpp" $, 6685 $, "class A {\n    int a;\npublic:\n    A() : a(0) { }\n    virtual int func() { return a; }\n};\nclass B : public A {\n    int b;\npublic:\n    B() : b(0) { }\n    int func() { return b; }\n};\nclass C : public B {\n    int c;\npublic:\n    C() : c(0) { }\n    int func() { return c; }\n};" $)
6686:
|
6701:
6702: ;
6703: $if $(@expr1073746467 $!@expr1073746468 $assertEquals $(@expr1073746469 "cppcheck-2.8/test/testclass.cpp" $, 6703 $, "" $, errout@var100 .@expr4592 str (@expr4593 ) $) $) { $return ; }
6704:
6705: $checkConst_ $(@expr1073746472 "cppcheck-2.8/test/testclass.cpp" $, 6705 $, "class A {\n    int a;\npublic:\n    A() : a(0) { }\n    virtual int func();\n};\nint A::func() { return a; }\nclass B : public A {\n    int b;\npublic:\n    B() : b(0) { }\n    int func();\n};\nint B::func() { return b; }\nclass C : public B {\n    int c;\npublic:\n    C() : c(0) { }\n    int func();\n};\nint C::func() { return c; }" $)
6706:
|
6724:
6725: ;
6726: $if $(@expr1073746473 $!@expr1073746474 $assertEquals $(@expr1073746475 "cppcheck-2.8/test/testclass.cpp" $, 6726 $, "" $, errout@var100 .@expr4592 str (@expr4593 ) $) $) { $return ; }
6727:
6728:
6729: $checkConst_ $(@expr1073746478 "cppcheck-2.8/test/testclass.cpp" $, 6729 $, "class X {\n    int x;\npublic:\n    X(int x) : x(x) { }\n    int getX() { return x; }\n};\nclass Y : public X {\n    int y;\npublic:\n    Y(int x, int y) : X(x), y(y) { }\n    int getY() { return y; }\n};\nclass Z : public Y {\n    int z;\npublic:\n    Z(int x, int y, int z) : Y(x, y), z(z) { }\n    int getZ() { return z; }\n};" $)
6730:
|
6745:
6746: ;
6747: $if $(@expr1073746479 $!@expr1073746480 $assertEquals $(@expr1073746481 "cppcheck-2.8/test/testclass.cpp" $, 6747 $, "[test.cpp:5]: (style, inconclusive) Technically the member function 'X::getX' can be const.\n[test.cpp:11]: (style, inconclusive) Technically the member function 'Y::getY' can be const.\n[test.cpp:17]: (style, inconclusive) Technically the member function 'Z::getZ' can be const.\n" $, errout@var100 .@expr4592 str (@expr4593 ) $) $) { $return
6748:
6749: ; }
6750:
6751: $checkConst_ $(@expr1073746484 "cppcheck-2.8/test/testclass.cpp" $, 6751 $, "class X {\n    int x;\npublic:\n    X(int x) : x(x) { }\n    int getX();\n};\nint X::getX() { return x; }\nclass Y : public X {\n    int y;\npublic:\n    Y(int x, int y) : X(x), y(y) { }\n    int getY();\n};\nint Y::getY() { return y; }\nclass Z : public Y {\n    int z;\npublic:\n    Z(int x, int y, int z) : Y(x, y), z(z) { }\n    int getZ();\n};\nint Z::getZ() { return z; }" $)
6752:
|
6770:
6771: ;
6772: $if $(@expr1073746485 $!@expr1073746486 $assertEquals $(@expr1073746487 "cppcheck-2.8/test/testclass.cpp" $, 6772 $, "[test.cpp:7] -> [test.cpp:5]: (style, inconclusive) Technically the member function 'X::getX' can be const.\n[test.cpp:14] -> [test.cpp:12]: (style, inconclusive) Technically the member function 'Y::getY' can be const.\n[test.cpp:21] -> [test.cpp:19]: (style, inconclusive) Technically the member function 'Z::getZ' can be const.\n" $, errout@var100 .@expr4592 str (@expr4593 ) $) $) { $return
6773:
6774: ; }
6775: }
6776:
6777: void constIfCfg ( ) {
6778: const char code@var187 [@expr1073746490 48 ] =@expr1073746491 "struct foo {\n    int i;\n    void f() {\n    }\n};"
6779:
|
6784:
6785: ;
6786:
6787: $checkConst_ $(@expr1073746492 "cppcheck-2.8/test/testclass.cpp" $, 6787 $, code@var187 , &@expr4669 settings0@var102 , true $) ;
6788: $if $(@expr1073746494 $!@expr1073746495 $assertEquals $(@expr1073746496 "cppcheck-2.8/test/testclass.cpp" $, 6788 $, "[test.cpp:3]: (performance, inconclusive) Technically the member function 'foo::f' can be static (but you may consider moving to unnamed namespace).\n" $, errout@var100 .@expr4673 str (@expr4674 ) $) $) { $return ; }
6789:
6790: $checkConst_ $(@expr1073746499 "cppcheck-2.8/test/testclass.cpp" $, 6790 $, code@var187 , &@expr4669 settings0@var102 , false $) ;
6791: $if $(@expr1073746501 $!@expr1073746502 $assertEquals $(@expr1073746503 "cppcheck-2.8/test/testclass.cpp" $, 6791 $, "" $, errout@var100 .@expr4673 str (@expr4674 ) $) $) { $return ; }
6792: }
6793:
6794: void constFriend ( ) {
6795: const char code@var188 [@expr1073746506 39 ] =@expr1073746507 "class foo {\n    friend void f() { }\n};"
6796:
6797: ;
6798: $checkConst_ $(@expr1073746508 "cppcheck-2.8/test/testclass.cpp" $, 6798 $, code@var188 $) ;
6799: $if $(@expr1073746509 $!@expr1073746510 $assertEquals $(@expr1073746511 "cppcheck-2.8/test/testclass.cpp" $, 6799 $, "" $, errout@var100 .@expr1073746512 str (@expr1073746513 ) $) $) { $return ; }
6800: }
6801:
6802: void constUnion ( ) {
6803: $checkConst_ $(@expr1073746514 "cppcheck-2.8/test/testclass.cpp" $, 6803 $, "class foo {\npublic:\n    union {\n        int i;\n        float f;\n    } d;\n    void setf(float x) {\n        d.f = x;\n    }\n};" $)
6804:
|
6811:
6812: ;
6813: $if $(@expr1073746515 $!@expr1073746516 $assertEquals $(@expr1073746517 "cppcheck-2.8/test/testclass.cpp" $, 6813 $, "" $, errout@var100 .@expr1073746518 str (@expr1073746519 ) $) $) { $return ; }
6814: }
6815:
6816: void constArrayOperator ( ) {
6817: $checkConst_ $(@expr1073746520 "cppcheck-2.8/test/testclass.cpp" $, 6817 $, "struct foo {\n    int x;\n    int y[5][724];\n    T a() {\n        return y[x++][6];\n    }\n    T b() {\n        return y[1][++x];\n    }\n    T c() {\n        return y[1][6];\n    }\n};" $)
6818:
|
6828:
6829: ;
6830: $if $(@expr1073746521 $!@expr1073746522 $assertEquals $(@expr1073746523 "cppcheck-2.8/test/testclass.cpp" $, 6830 $, "[test.cpp:10]: (style, inconclusive) Technically the member function 'foo::c' can be const.\n" $, errout@var100 .@expr1073746524 str (@expr1073746525 ) $) $) { $return ; }
6831: }
6832:
6833: void constRangeBasedFor ( ) {
6834: $checkConst_ $(@expr1073746526 "cppcheck-2.8/test/testclass.cpp" $, 6834 $, "class Fred {\n    int array[256];\npublic:\n    void f1() {\n        for (auto & e : array)\n            foo(e);\n    }\n    void f2() {\n        for (const auto & e : array)\n            foo(e);\n    }\n    void f3() {\n        for (decltype(auto) e : array)\n            foo(e);\n    }\n};" $)
6835:
|
6848:
6849: ;
6850: $if $(@expr1073746527 $!@expr1073746528 $assertEquals $(@expr1073746529 "cppcheck-2.8/test/testclass.cpp" $, 6850 $, "[test.cpp:8]: (style, inconclusive) Technically the member function 'Fred::f2' can be const.\n" $, errout@var100 .@expr1073746530 str (@expr1073746531 ) $) $) { $return ; }
6851: }
6852:
6853: void const_shared_ptr ( ) {
6854: $checkConst_ $(@expr1073746532 "cppcheck-2.8/test/testclass.cpp" $, 6854 $, "class Fred {\npublic:\n    std::shared_ptr<Data> getData();\nprivate:\n     std::shared_ptr<Data> data;\n};\n\nstd::shared_ptr<Data> Fred::getData() { return data; }" $)
6855:
|
6860:
6861: ;
6862: $if $(@expr1073746533 $!@expr1073746534 $assertEquals $(@expr1073746535 "cppcheck-2.8/test/testclass.cpp" $, 6862 $, "" $, errout@var100 .@expr1073746536 str (@expr1073746537 ) $) $) { $return ; }
6863: }
6864:
6865: void constPtrToConstPtr ( ) {
6866: $checkConst_ $(@expr1073746538 "cppcheck-2.8/test/testclass.cpp" $, 6866 $, "class Fred {\npublic:\n    const char *const *data;\n    const char *const *getData() { return data; }\n}" $)
6867:
6868:
6869: ;
6870: $if $(@expr1073746539 $!@expr1073746540 $assertEquals $(@expr1073746541 "cppcheck-2.8/test/testclass.cpp" $, 6870 $, "[test.cpp:4]: (style, inconclusive) Technically the member function 'Fred::getData' can be const.\n" $, errout@var100 .@expr1073746542 str (@expr1073746543 ) $) $) { $return ; }
6871: }
6872:
6873: void constTrailingReturnType ( ) {
6874: $checkConst_ $(@expr1073746544 "cppcheck-2.8/test/testclass.cpp" $, 6874 $, "struct A {\n    int x = 1;\n    auto get() -> int & { return x; }\n};" $)
6875:
6876:
6877: ;
6878: $if $(@expr1073746545 $!@expr1073746546 $assertEquals $(@expr1073746547 "cppcheck-2.8/test/testclass.cpp" $, 6878 $, "" $, errout@var100 .@expr1073746548 str (@expr1073746549 ) $) $) { $return ; }
6879: }
6880:
6881: void staticArrayPtrOverload ( ) {
6882: $checkConst_ $(@expr1073746550 "cppcheck-2.8/test/testclass.cpp" $, 6882 $, "struct S {\n    template<size_t N>\n    void f(const std::array<std::string_view, N>& sv);\n    template<long N>\n    void f(const char* const (&StrArr)[N]);\n};\ntemplate<size_t N>\nvoid S::f(const std::array<std::string_view, N>& sv) {\n    const char* ptrs[N]{};\n    return f(ptrs);\n}\ntemplate void S::f(const std::array<std::string_view, 3>& sv);\n" $)
6883:
|
6892:
6893: ;
6894: $if $(@expr1073746551 $!@expr1073746552 $assertEquals $(@expr1073746553 "cppcheck-2.8/test/testclass.cpp" $, 6894 $, "" $, errout@var100 .@expr1073746554 str (@expr1073746555 ) $) $) { $return ; }
6895: }
6896:
6897: void qualifiedNameMember ( ) {
6898: Settings s@var189 ;
6899: s@var189 .@expr1073746557 severity@var190 .@expr1073746558 enable (@expr1073746559 Severity ::@expr1073746560 style@expr1073746556 ) ;
6900: s@var189 .@expr1073746561 debugwarnings@var191 =@expr1073746562 true ;
6901: $do ${ $if $(@expr1073746563 s@var189 .@expr1073746564 library@var192 $.@expr1073746565 $load $(@expr1073746566 $exename@var11 $.@expr1073746567 $c_str $(@expr1073746568 $) $, "std.cfg" $) $.@expr1073746569 $errorcode $!=@expr1073746570 $Library $::@expr1073746571 $ErrorCode $::@expr1073746572 $OK $) ${ $complainMissingLib $(@expr1073746573 "std.cfg" $) $; $return $; $} $} $while $(@expr1073746574 $false $) ;
6902: $checkConst_ $(@expr1073746575 "cppcheck-2.8/test/testclass.cpp" $, 6902 $, "struct data {};\n    struct S {\n    std::vector<data> std;\n    void f();\n};\nvoid S::f() {\n    std::vector<data>::const_iterator end = std.end();\n}\n" , &@expr1073746576 s@var189 $)
6903:
|
6908:
6909: ;
6910: $if $(@expr1073746577 $!@expr1073746578 $assertEquals $(@expr1073746579 "cppcheck-2.8/test/testclass.cpp" $, 6910 $, "[test.cpp:6] -> [test.cpp:4]: (style, inconclusive) Technically the member function 'S::f' can be const.\n" $, errout@var100 .@expr1073746580 str (@expr1073746581 ) $) $) { $return ; }
6911: }
6912:
6913:
6914: void checkInitializerListOrder_ ( const char code@var193 [ ] , const char * file@var194 , int line@var195 ) {
6915:
6916: errout@var100 .@expr1073746582 str (@expr1073746583 "" ) ;
6917:
6918:
6919: settings0@var102 .@expr1073746584 certainty@var152 .@expr1073746585 setEnabled (@expr1073746586 Certainty ::@expr1073746587 inconclusive , true ) ;
6920:
6921:
6922: Tokenizer tokenizer@var196 (@expr1073746588 &@expr4765 settings0@var102 , this@expr4766 ) ;
6923: std ::@expr1073746591 istringstream istr@var197 (@expr1073746592 code@var193 ) ;
6924: $assert_ $(@expr1073746593 file@var194 $, line@var195 $, $(@expr1073746594 tokenizer@var196 .@expr1073746595 tokenize (@expr1073746596 istr@var197 , "test.cpp" ) $) $) ;
6925:
6926: CheckClass checkClass@var198 (@expr1073746597 &@expr1073746598 tokenizer@var196 , &@expr4765 settings0@var102 , this@expr4766 ) ;
6927: checkClass@var198 .@expr1073746600 initializerListOrder (@expr1073746601 ) ;
6928: }
6929:
6930: void initializerListOrder ( ) {
6931: $checkInitializerListOrder_ $(@expr1073746602 "class Fred {\n    int a, b, c;\npublic:\n    Fred() : c(0), b(0), a(0) { }\n};" $, "cppcheck-2.8/test/testclass.cpp" $, 6931 $)
6932:
6933:
6934:
6935: ;
6936: $if $(@expr1073746603 $!@expr1073746604 $assertEquals $(@expr1073746605 "cppcheck-2.8/test/testclass.cpp" $, 6936 $, "[test.cpp:4] -> [test.cpp:2]: (style, inconclusive) Member variable 'Fred::b' is in the wrong place in the initializer list.\n[test.cpp:4] -> [test.cpp:2]: (style, inconclusive) Member variable 'Fred::a' is in the wrong place in the initializer list.\n" $, errout@var100 .@expr4782 str (@expr4783 ) $) $) { $return
6937: ; }
6938:
6939: $checkInitializerListOrder_ $(@expr1073746608 "class Fred {\n    int a, b, c;\npublic:\n    Fred() : c{0}, b{0}, a{0} { }\n};" $, "cppcheck-2.8/test/testclass.cpp" $, 6939 $)
6940:
6941:
6942:
6943: ;
6944: $if $(@expr1073746609 $!@expr1073746610 $assertEquals $(@expr1073746611 "cppcheck-2.8/test/testclass.cpp" $, 6944 $, "[test.cpp:4] -> [test.cpp:2]: (style, inconclusive) Member variable 'Fred::b' is in the wrong place in the initializer list.\n[test.cpp:4] -> [test.cpp:2]: (style, inconclusive) Member variable 'Fred::a' is in the wrong place in the initializer list.\n" $, errout@var100 .@expr4782 str (@expr4783 ) $) $) { $return
6945: ; }
6946: }
6947:
6948:
6949: void checkInitializationListUsage_ ( const char code@var199 [ ] , const char * file@var200 , int line@var201 ) {
6950:
6951: errout@var100 .@expr1073746615 str (@expr1073746616 "" ) ;
6952:
6953:
6954: Settings settings@var202 ;
6955: settings@var202 .@expr1073746617 severity@var203 .@expr1073746618 enable (@expr1073746619 Severity ::@expr1073746620 performance@expr1073746614 ) ;
6956:
6957:
6958: Tokenizer tokenizer@var204 (@expr1073746621 &@expr4798 settings@var202 , this@expr4799 ) ;
6959: std ::@expr1073746624 istringstream istr@var205 (@expr1073746625 code@var199 ) ;
6960: $assert_ $(@expr1073746626 file@var200 $, line@var201 $, $(@expr1073746627 tokenizer@var204 .@expr1073746628 tokenize (@expr1073746629 istr@var205 , "test.cpp" ) $) $) ;
6961:
6962: CheckClass checkClass@var206 (@expr1073746630 &@expr1073746631 tokenizer@var204 , &@expr4798 settings@var202 , this@expr4799 ) ;
6963: checkClass@var206 .@expr1073746633 initializationListUsage (@expr1073746634 ) ;
6964: }
6965:
6966: void initializerListUsage ( ) {
6967: $checkInitializationListUsage_ $(@expr1073746635 "enum Enum { C = 0 };\nclass Fred {\n    int a;\n    int* b;\n    Enum c;\n    Fred() { a = 0; b = 0; c = C; }\n};" $, "cppcheck-2.8/test/testclass.cpp" $, 6967 $)
6968:
|
6972:
6973: ;
6974: $if $(@expr1073746636 $!@expr1073746637 $assertEquals $(@expr1073746638 "cppcheck-2.8/test/testclass.cpp" $, 6974 $, "" $, errout@var100 .@expr4815 str (@expr4816 ) $) $) { $return ; }
6975:
6976: $checkInitializationListUsage_ $(@expr1073746641 "class Fred {\n    std::string s;\n    Fred() { a = 0; s = \"foo\"; }\n};" $, "cppcheck-2.8/test/testclass.cpp" $, 6976 $)
6977:
6978:
6979: ;
6980: $if $(@expr1073746642 $!@expr1073746643 $assertEquals $(@expr1073746644 "cppcheck-2.8/test/testclass.cpp" $, 6980 $, "[test.cpp:3]: (performance) Variable 's' is assigned in constructor body. Consider performing initialization in initialization list.\n" $, errout@var100 .@expr4815 str (@expr4816 ) $) $) { $return ; }
6981:
6982: $checkInitializationListUsage_ $(@expr1073746647 "class Fred {\n    std::string& s;\n    Fred(const std::string& s_) : s(s_) { s = \"foo\"; }\n};" $, "cppcheck-2.8/test/testclass.cpp" $, 6982 $)
6983:
6984:
6985: ;
6986: $if $(@expr1073746648 $!@expr1073746649 $assertEquals $(@expr1073746650 "cppcheck-2.8/test/testclass.cpp" $, 6986 $, "" $, errout@var100 .@expr4815 str (@expr4816 ) $) $) { $return ; }
6987:
6988: $checkInitializationListUsage_ $(@expr1073746653 "class Fred {\n    std::vector<int> v;\n    Fred() { v = unknown; }\n};" $, "cppcheck-2.8/test/testclass.cpp" $, 6988 $)
6989:
6990:
6991: ;
6992: $if $(@expr1073746654 $!@expr1073746655 $assertEquals $(@expr1073746656 "cppcheck-2.8/test/testclass.cpp" $, 6992 $, "[test.cpp:3]: (performance) Variable 'v' is assigned in constructor body. Consider performing initialization in initialization list.\n" $, errout@var100 .@expr4815 str (@expr4816 ) $) $) { $return ; }
6993:
6994: $checkInitializationListUsage_ $(@expr1073746659 "class C { std::string s; };\nclass Fred {\n    C c;\n    Fred() { c = unknown; }\n};" $, "cppcheck-2.8/test/testclass.cpp" $, 6994 $)
6995:
6996:
6997:
6998: ;
6999: $if $(@expr1073746660 $!@expr1073746661 $assertEquals $(@expr1073746662 "cppcheck-2.8/test/testclass.cpp" $, 6999 $, "[test.cpp:4]: (performance) Variable 'c' is assigned in constructor body. Consider performing initialization in initialization list.\n" $, errout@var100 .@expr4815 str (@expr4816 ) $) $) { $return ; }
7000:
7001: $checkInitializationListUsage_ $(@expr1073746665 "class C;\nclass Fred {\n    C c;\n    Fred() { c = unknown; }\n};" $, "cppcheck-2.8/test/testclass.cpp" $, 7001 $)
7002:
7003:
7004:
7005: ;
7006: $if $(@expr1073746666 $!@expr1073746667 $assertEquals $(@expr1073746668 "cppcheck-2.8/test/testclass.cpp" $, 7006 $, "[test.cpp:4]: (performance) Variable 'c' is assigned in constructor body. Consider performing initialization in initialization list.\n" $, errout@var100 .@expr4815 str (@expr4816 ) $) $) { $return ; }
7007:
7008: $checkInitializationListUsage_ $(@expr1073746671 "class C;\nclass Fred {\n    C c;\n    Fred(Fred const & other) { c = other.c; }\n};" $, "cppcheck-2.8/test/testclass.cpp" $, 7008 $)
7009:
7010:
7011:
7012: ;
7013: $if $(@expr1073746672 $!@expr1073746673 $assertEquals $(@expr1073746674 "cppcheck-2.8/test/testclass.cpp" $, 7013 $, "[test.cpp:4]: (performance) Variable 'c' is assigned in constructor body. Consider performing initialization in initialization list.\n" $, errout@var100 .@expr4815 str (@expr4816 ) $) $) { $return ; }
7014:
7015: $checkInitializationListUsage_ $(@expr1073746677 "class C;\nclass Fred {\n    C c;\n    Fred(Fred && other) { c = other.c; }\n};" $, "cppcheck-2.8/test/testclass.cpp" $, 7015 $)
7016:
7017:
7018:
7019: ;
7020: $if $(@expr1073746678 $!@expr1073746679 $assertEquals $(@expr1073746680 "cppcheck-2.8/test/testclass.cpp" $, 7020 $, "[test.cpp:4]: (performance) Variable 'c' is assigned in constructor body. Consider performing initialization in initialization list.\n" $, errout@var100 .@expr4815 str (@expr4816 ) $) $) { $return ; }
7021:
7022: $checkInitializationListUsage_ $(@expr1073746683 "class C;\nclass Fred {\n    C a;\n    Fred() { initB(); a = b; }\n};" $, "cppcheck-2.8/test/testclass.cpp" $, 7022 $)
7023:
7024:
7025:
7026: ;
7027: $if $(@expr1073746684 $!@expr1073746685 $assertEquals $(@expr1073746686 "cppcheck-2.8/test/testclass.cpp" $, 7027 $, "" $, errout@var100 .@expr4815 str (@expr4816 ) $) $) { $return ; }
7028:
7029: $checkInitializationListUsage_ $(@expr1073746689 "class C;\nclass Fred {\n    C a;\n    Fred() : a(0) { if(b) a = 0; }\n};" $, "cppcheck-2.8/test/testclass.cpp" $, 7029 $)
7030:
7031:
7032:
7033: ;
7034: $if $(@expr1073746690 $!@expr1073746691 $assertEquals $(@expr1073746692 "cppcheck-2.8/test/testclass.cpp" $, 7034 $, "" $, errout@var100 .@expr4815 str (@expr4816 ) $) $) { $return ; }
7035:
7036: $checkInitializationListUsage_ $(@expr1073746695 "class C;\nclass Fred {\n    C a[5];\n    Fred() { for(int i = 0; i < 5; i++) a[i] = 0; }\n};" $, "cppcheck-2.8/test/testclass.cpp" $, 7036 $)
7037:
7038:
7039:
7040: ;
7041: $if $(@expr1073746696 $!@expr1073746697 $assertEquals $(@expr1073746698 "cppcheck-2.8/test/testclass.cpp" $, 7041 $, "" $, errout@var100 .@expr4815 str (@expr4816 ) $) $) { $return ; }
7042:
7043: $checkInitializationListUsage_ $(@expr1073746701 "class C;\nclass Fred {\n    C a; int b;\n    Fred() : b(5) { a = b; }\n};" $, "cppcheck-2.8/test/testclass.cpp" $, 7043 $)
7044:
7045:
7046:
7047: ;
7048: $if $(@expr1073746702 $!@expr1073746703 $assertEquals $(@expr1073746704 "cppcheck-2.8/test/testclass.cpp" $, 7048 $, "" $, errout@var100 .@expr4815 str (@expr4816 ) $) $) { $return ; }
7049:
7050: $checkInitializationListUsage_ $(@expr1073746707 "class C;\nclass Fred {\n    C a;\n    Fred() { try { a = new int; } catch(...) {} }\n};" $, "cppcheck-2.8/test/testclass.cpp" $, 7050 $)
7051:
7052:
7053:
7054: ;
7055: $if $(@expr1073746708 $!@expr1073746709 $assertEquals $(@expr1073746710 "cppcheck-2.8/test/testclass.cpp" $, 7055 $, "" $, errout@var100 .@expr4815 str (@expr4816 ) $) $) { $return ; }
7056:
7057: $checkInitializationListUsage_ $(@expr1073746713 "class Fred {\n    std::string s;\n    Fred() { s = toString((size_t)this); }\n};" $, "cppcheck-2.8/test/testclass.cpp" $, 7057 $)
7058:
7059:
7060: ;
7061: $if $(@expr1073746714 $!@expr1073746715 $assertEquals $(@expr1073746716 "cppcheck-2.8/test/testclass.cpp" $, 7061 $, "" $, errout@var100 .@expr4815 str (@expr4816 ) $) $) { $return ; }
7062:
7063: $checkInitializationListUsage_ $(@expr1073746719 "class Fred {\n    std::string a;\n    std::string foo();\n    Fred() { a = foo(); }\n};" $, "cppcheck-2.8/test/testclass.cpp" $, 7063 $)
7064:
7065:
7066:
7067: ;
7068: $if $(@expr1073746720 $!@expr1073746721 $assertEquals $(@expr1073746722 "cppcheck-2.8/test/testclass.cpp" $, 7068 $, "" $, errout@var100 .@expr4815 str (@expr4816 ) $) $) { $return ; }
7069:
7070: $checkInitializationListUsage_ $(@expr1073746725 "class Fred {\n    std::string a;\n    Fred() { a = foo(); }\n};" $, "cppcheck-2.8/test/testclass.cpp" $, 7070 $)
7071:
7072:
7073: ;
7074: $if $(@expr1073746726 $!@expr1073746727 $assertEquals $(@expr1073746728 "cppcheck-2.8/test/testclass.cpp" $, 7074 $, "[test.cpp:3]: (performance) Variable 'a' is assigned in constructor body. Consider performing initialization in initialization list.\n" $, errout@var100 .@expr4815 str (@expr4816 ) $) $) { $return ; }
7075:
7076: $checkInitializationListUsage_ $(@expr1073746731 "class Fred {\n    static std::string s;\n    Fred() { s = \"foo\"; }\n};" $, "cppcheck-2.8/test/testclass.cpp" $, 7076 $)
7077:
7078:
7079: ;
7080: $if $(@expr1073746732 $!@expr1073746733 $assertEquals $(@expr1073746734 "cppcheck-2.8/test/testclass.cpp" $, 7080 $, "" $, errout@var100 .@expr4815 str (@expr4816 ) $) $) { $return ; }
7081:
7082: $checkInitializationListUsage_ $(@expr1073746737 "class Fred {\n    std::string s;\n    Fred() {\n        char str[2];\n        str[0] = c;\n        str[1] = 0;\n        s = str;\n    }\n};" $, "cppcheck-2.8/test/testclass.cpp" $, 7082 $)
7083:
|
7089:
7090: ;
7091: $if $(@expr1073746738 $!@expr1073746739 $assertEquals $(@expr1073746740 "cppcheck-2.8/test/testclass.cpp" $, 7091 $, "" $, errout@var100 .@expr4815 str (@expr4816 ) $) $) { $return ; }
7092:
7093: $checkInitializationListUsage_ $(@expr1073746743 "class B {\n    std::shared_ptr<A> _d;\n    B(const B& other) : _d(std::make_shared<A>()) {\n        *_d = *other._d;\n    }\n};" $, "cppcheck-2.8/test/testclass.cpp" $, 7093 $)
7094:
|
7097:
7098: ;
7099: $if $(@expr1073746744 $!@expr1073746745 $assertEquals $(@expr1073746746 "cppcheck-2.8/test/testclass.cpp" $, 7099 $, "" $, errout@var100 .@expr4815 str (@expr4816 ) $) $) { $return ; }
7100:
7101: $checkInitializationListUsage_ $(@expr1073746749 "class Bar {\npublic:\n    explicit Bar(const Bar &bar) : Bar{bar.s} {}\n    explicit Bar(const char s) : s{s} {}\nprivate:\n    char s;\n};" $, "cppcheck-2.8/test/testclass.cpp" $, 7101 $)
7102:
|
7106:
7107: ;
7108: $if $(@expr1073746750 $!@expr1073746751 $assertEquals $(@expr1073746752 "cppcheck-2.8/test/testclass.cpp" $, 7108 $, "" $, errout@var100 .@expr4815 str (@expr4816 ) $) $) { $return ; }
7109:
7110: $checkInitializationListUsage_ $(@expr1073746755 "unsigned bar(std::string);\nclass Foo {\npublic:\n    int a_, b_;\n    Foo(int a, int b) : a_(a), b_(b) {}\n    Foo(int a, const std::string& b) : Foo(a, bar(b)) {}\n};" $, "cppcheck-2.8/test/testclass.cpp" $, 7110 $)
7111:
|
7115:
7116: ;
7117: $if $(@expr1073746756 $!@expr1073746757 $assertEquals $(@expr1073746758 "cppcheck-2.8/test/testclass.cpp" $, 7117 $, "" $, errout@var100 .@expr4815 str (@expr4816 ) $) $) { $return ; }
7118:
7119: $checkInitializationListUsage_ $(@expr1073746761 "class Fred {\n    std::string a;\n    Fred() {\n        std::ostringstream ostr;\n        ostr << x;\n        a = ostr.str();\n    }\n};" $, "cppcheck-2.8/test/testclass.cpp" $, 7119 $)
7120:
|
7125:
7126: ;
7127: $if $(@expr1073746762 $!@expr1073746763 $assertEquals $(@expr1073746764 "cppcheck-2.8/test/testclass.cpp" $, 7127 $, "" $, errout@var100 .@expr4815 str (@expr4816 ) $) $) { $return ; }
7128:
7129:
7130: $checkInitializationListUsage_ $(@expr1073746767 "class Fred {\n    std::function f;\n    Fred() {\n        f = [](){\n            return 1;\n        };\n    }\n};" $, "cppcheck-2.8/test/testclass.cpp" $, 7130 $)
7131:
|
7136:
7137: ;
7138: $if $(@expr1073746768 $!@expr1073746769 $assertEquals $(@expr1073746770 "cppcheck-2.8/test/testclass.cpp" $, 7138 $, "" $, errout@var100 .@expr4815 str (@expr4816 ) $) $) { $return ; }
7139:
7140:
7141: $checkInitializationListUsage_ $(@expr1073746773 "class C {\npublic:\n    C(C& c) : m_i(c.m_i) { c.m_i = (Foo)-1; }\nprivate:\n    Foo m_i;\n};" $, "cppcheck-2.8/test/testclass.cpp" $, 7141 $)
7142:
|
7145:
7146: ;
7147: $if $(@expr1073746774 $!@expr1073746775 $assertEquals $(@expr1073746776 "cppcheck-2.8/test/testclass.cpp" $, 7147 $, "" $, errout@var100 .@expr4815 str (@expr4816 ) $) $) { $return ; }
7148:
7149: $checkInitializationListUsage_ $(@expr1073746779 "class A {\npublic:\n    A() : st{} {}\n\n    explicit A(const std::string &input): A() {\n        st = input;\n    }\n\nprivate:\n    std::string st;\n};" $, "cppcheck-2.8/test/testclass.cpp" $, 7149 $)
7150:
|
7158:
7159: ;
7160: $if $(@expr1073746780 $!@expr1073746781 $assertEquals $(@expr1073746782 "cppcheck-2.8/test/testclass.cpp" $, 7160 $, "" $, errout@var100 .@expr4815 str (@expr4816 ) $) $) { $return ; }
7161: }
7162:
7163:
7164:
7165: void checkSelfInitialization_ ( const char code@var207 [ ] , const char * file@var208 , int line@var209 ) {
7166:
7167: errout@var100 .@expr1073746785 str (@expr1073746786 "" ) ;
7168:
7169:
7170: Tokenizer tokenizer@var210 (@expr1073746787 &@expr4964 settings0@var102 , this@expr4965 ) ;
7171: std ::@expr1073746790 istringstream istr@var211 (@expr1073746791 code@var207 ) ;
7172: $assert_ $(@expr1073746792 file@var208 $, line@var209 $, $(@expr1073746793 tokenizer@var210 .@expr1073746794 tokenize (@expr1073746795 istr@var211 , "test.cpp" ) $) $) ;
7173:
7174: CheckClass checkClass@var212 (@expr1073746796 &@expr1073746797 tokenizer@var210 , &@expr4964 settings0@var102 , this@expr4965 ) ;
7175: checkClass@var212 .@expr1073746799 checkSelfInitialization (@expr1073746800 ) ;
7176: }
7177:
7178: void selfInitialization ( ) {
7179: $checkSelfInitialization_ $(@expr1073746801 "class Fred {\n    int i;\n    Fred() : i(i) {\n    }\n};" $, "cppcheck-2.8/test/testclass.cpp" $, 7179 $)
7180:
7181:
7182:
7183: ;
7184: $if $(@expr1073746802 $!@expr1073746803 $assertEquals $(@expr1073746804 "cppcheck-2.8/test/testclass.cpp" $, 7184 $, "[test.cpp:3]: (error) Member variable 'i' is initialized by itself.\n" $, errout@var100 .@expr4981 str (@expr4982 ) $) $) { $return ; }
7185:
7186: $checkSelfInitialization_ $(@expr1073746807 "class Fred {\n    int i;\n    Fred() : i{i} {\n    }\n};" $, "cppcheck-2.8/test/testclass.cpp" $, 7186 $)
7187:
7188:
7189:
7190: ;
7191: $if $(@expr1073746808 $!@expr1073746809 $assertEquals $(@expr1073746810 "cppcheck-2.8/test/testclass.cpp" $, 7191 $, "[test.cpp:3]: (error) Member variable 'i' is initialized by itself.\n" $, errout@var100 .@expr4981 str (@expr4982 ) $) $) { $return ; }
7192:
7193: $checkSelfInitialization_ $(@expr1073746813 "class Fred {\n    int i;\n    Fred();\n};\nFred::Fred() : i(i) {\n}" $, "cppcheck-2.8/test/testclass.cpp" $, 7193 $)
7194:
|
7197:
7198: ;
7199: $if $(@expr1073746814 $!@expr1073746815 $assertEquals $(@expr1073746816 "cppcheck-2.8/test/testclass.cpp" $, 7199 $, "[test.cpp:5]: (error) Member variable 'i' is initialized by itself.\n" $, errout@var100 .@expr4981 str (@expr4982 ) $) $) { $return ; }
7200:
7201: $checkSelfInitialization_ $(@expr1073746819 "class A {\npublic:\n    explicit A(int x) : _x(static_cast<int>(_x)) {}\nprivate:\n    int _x;\n};\n" $, "cppcheck-2.8/test/testclass.cpp" $, 7201 $)
7202:
|
7205:
7206: ;
7207: $if $(@expr1073746820 $!@expr1073746821 $assertEquals $(@expr1073746822 "cppcheck-2.8/test/testclass.cpp" $, 7207 $, "[test.cpp:3]: (error) Member variable '_x' is initialized by itself.\n" $, errout@var100 .@expr4981 str (@expr4982 ) $) $) { $return ; }
7208:
7209: $checkSelfInitialization_ $(@expr1073746825 "class A {\npublic:\n    explicit A(int x) : _x((int)(_x)) {}\nprivate:\n    int _x;\n};\n" $, "cppcheck-2.8/test/testclass.cpp" $, 7209 $)
7210:
|
7213:
7214: ;
7215: $if $(@expr1073746826 $!@expr1073746827 $assertEquals $(@expr1073746828 "cppcheck-2.8/test/testclass.cpp" $, 7215 $, "[test.cpp:3]: (error) Member variable '_x' is initialized by itself.\n" $, errout@var100 .@expr4981 str (@expr4982 ) $) $) { $return ; }
7216:
7217: $checkSelfInitialization_ $(@expr1073746831 "class Fred {\n    std::string s;\n    Fred() : s(s) {\n    }\n};" $, "cppcheck-2.8/test/testclass.cpp" $, 7217 $)
7218:
7219:
7220:
7221: ;
7222: $if $(@expr1073746832 $!@expr1073746833 $assertEquals $(@expr1073746834 "cppcheck-2.8/test/testclass.cpp" $, 7222 $, "[test.cpp:3]: (error) Member variable 's' is initialized by itself.\n" $, errout@var100 .@expr4981 str (@expr4982 ) $) $) { $return ; }
7223:
7224: $checkSelfInitialization_ $(@expr1073746837 "class Fred {\n    int x;\n    Fred(int x);\n};\nFred::Fred(int x) : x(x) { }" $, "cppcheck-2.8/test/testclass.cpp" $, 7224 $)
7225:
7226:
7227:
7228: ;
7229: $if $(@expr1073746838 $!@expr1073746839 $assertEquals $(@expr1073746840 "cppcheck-2.8/test/testclass.cpp" $, 7229 $, "" $, errout@var100 .@expr4981 str (@expr4982 ) $) $) { $return ; }
7230:
7231: $checkSelfInitialization_ $(@expr1073746843 "class Fred {\n    int x;\n    Fred(int x);\n};\nFred::Fred(int x) : x{x} { }" $, "cppcheck-2.8/test/testclass.cpp" $, 7231 $)
7232:
7233:
7234:
7235: ;
7236: $if $(@expr1073746844 $!@expr1073746845 $assertEquals $(@expr1073746846 "cppcheck-2.8/test/testclass.cpp" $, 7236 $, "" $, errout@var100 .@expr4981 str (@expr4982 ) $) $) { $return ; }
7237:
7238: $checkSelfInitialization_ $(@expr1073746849 "class Fred {\n    std::string s;\n    Fred(const std::string& s) : s(s) {\n    }\n};" $, "cppcheck-2.8/test/testclass.cpp" $, 7238 $)
7239:
7240:
7241:
7242: ;
7243: $if $(@expr1073746850 $!@expr1073746851 $assertEquals $(@expr1073746852 "cppcheck-2.8/test/testclass.cpp" $, 7243 $, "" $, errout@var100 .@expr4981 str (@expr4982 ) $) $) { $return ; }
7244:
7245: $checkSelfInitialization_ $(@expr1073746855 "class Fred {\n    std::string s;\n    Fred(const std::string& s) : s{s} {\n    }\n};" $, "cppcheck-2.8/test/testclass.cpp" $, 7245 $)
7246:
7247:
7248:
7249: ;
7250: $if $(@expr1073746856 $!@expr1073746857 $assertEquals $(@expr1073746858 "cppcheck-2.8/test/testclass.cpp" $, 7250 $, "" $, errout@var100 .@expr4981 str (@expr4982 ) $) $) { $return ; }
7251:
7252: $checkSelfInitialization_ $(@expr1073746861 "struct Foo : Bar {\n    int i;\n    Foo(int i)\n        : Bar(\"\"), i(i) {}\n};" $, "cppcheck-2.8/test/testclass.cpp" $, 7252 $)
7253:
7254:
7255:
7256: ;
7257: $if $(@expr1073746862 $!@expr1073746863 $assertEquals $(@expr1073746864 "cppcheck-2.8/test/testclass.cpp" $, 7257 $, "" $, errout@var100 .@expr4981 str (@expr4982 ) $) $) { $return ; }
7258:
7259: $checkSelfInitialization_ $(@expr1073746867 "struct Foo : std::Bar {\n    int i;\n    Foo(int i)\n        : std::Bar(\"\"), i(i) {}\n};" $, "cppcheck-2.8/test/testclass.cpp" $, 7259 $)
7260:
7261:
7262:
7263: ;
7264: $if $(@expr1073746868 $!@expr1073746869 $assertEquals $(@expr1073746870 "cppcheck-2.8/test/testclass.cpp" $, 7264 $, "" $, errout@var100 .@expr4981 str (@expr4982 ) $) $) { $return ; }
7265:
7266: $checkSelfInitialization_ $(@expr1073746873 "struct Foo : std::Bar {\n    int i;\n    Foo(int i)\n        : std::Bar(\"\"), i{i} {}\n};" $, "cppcheck-2.8/test/testclass.cpp" $, 7266 $)
7267:
7268:
7269:
7270: ;
7271: $if $(@expr1073746874 $!@expr1073746875 $assertEquals $(@expr1073746876 "cppcheck-2.8/test/testclass.cpp" $, 7271 $, "" $, errout@var100 .@expr4981 str (@expr4982 ) $) $) { $return ; }
7272: }
7273:
7274:
7275:
7276: void checkVirtualFunctionCall_ ( const char * file@var213 , int line@var214 , const char code@var215 [ ] , Settings * s@var216 = nullptr , bool inconclusive@var217 = true ) {
7277:
7278: errout@var100 .@expr1073746881 str (@expr1073746882 "" ) ;
7279:
7280:
7281: if (@expr1073746883 !@expr1073746884 s@var216 ) {
7282: static Settings settings_@var218 ;
7283: s@var216 =@expr1073746885 &@expr1073746886 settings_@var218 ;
7284: s@var216 .@expr1073746887 severity@var219 .@expr1073746888 enable (@expr1073746889 Severity ::@expr1073746890 warning@expr1073746879 ) ;
7285: }
7286: s@var216 .@expr1073746891 certainty@var220 .@expr1073746892 setEnabled (@expr1073746893 Certainty ::@expr1073746894 inconclusive@expr1073746880 , inconclusive@var217 ) ;
7287:
7288:
7289: Tokenizer tokenizer@var221 (@expr1073746895 s@var216 , this@expr5072 ) ;
7290: std ::@expr1073746897 istringstream istr@var222 (@expr1073746898 code@var215 ) ;
7291: $assert_ $(@expr1073746899 file@var213 $, line@var214 $, $(@expr1073746900 tokenizer@var221 .@expr1073746901 tokenize (@expr1073746902 istr@var222 , "test.cpp" ) $) $) ;
7292:
7293: CheckClass checkClass@var223 (@expr1073746903 &@expr1073746904 tokenizer@var221 , s@var216 , this@expr5072 ) ;
7294: checkClass@var223 .@expr1073746905 checkVirtualFunctionCallInConstructor (@expr1073746906 ) ;
7295: }
7296:
7297: void virtualFunctionCallInConstructor ( ) {
7298: $checkVirtualFunctionCall_ $(@expr1073746907 "cppcheck-2.8/test/testclass.cpp" $, 7298 $, "class A\n{\n    virtual int f() { return 1; }\n    A();\n};\nA::A()\n{f();}" $)
7299:
|
7303:
7304: ;
7305: $if $(@expr1073746908 $!@expr1073746909 $assertEquals $(@expr1073746910 "cppcheck-2.8/test/testclass.cpp" $, 7305 $, "[test.cpp:7] -> [test.cpp:3]: (style) Virtual function 'f' is called from constructor 'A()' at line 7. Dynamic binding is not used.\n" $, errout@var100 .@expr5087 str (@expr5088 ) $) $) { $return ; }
7306:
7307: $checkVirtualFunctionCall_ $(@expr1073746913 "cppcheck-2.8/test/testclass.cpp" $, 7307 $, "class A {\n    virtual int f();\n    A() {f();}\n};\nint A::f() { return 1; }" $)
7308:
7309:
7310:
7311: ;
7312: $if $(@expr1073746914 $!@expr1073746915 $assertEquals $(@expr1073746916 "cppcheck-2.8/test/testclass.cpp" $, 7312 $, "[test.cpp:3] -> [test.cpp:2]: (style) Virtual function 'f' is called from constructor 'A()' at line 3. Dynamic binding is not used.\n" $, errout@var100 .@expr5087 str (@expr5088 ) $) $) { $return ; }
7313:
7314: $checkVirtualFunctionCall_ $(@expr1073746919 "cppcheck-2.8/test/testclass.cpp" $, 7314 $, "class A : B {\n    int f() override;\n    A() {f();}\n};\nint A::f() { return 1; }" $)
7315:
7316:
7317:
7318: ;
7319: $if $(@expr1073746920 $!@expr1073746921 $assertEquals $(@expr1073746922 "cppcheck-2.8/test/testclass.cpp" $, 7319 $, "[test.cpp:3] -> [test.cpp:2]: (style) Virtual function 'f' is called from constructor 'A()' at line 3. Dynamic binding is not used.\n" $, errout@var100 .@expr5087 str (@expr5088 ) $) $) { $return ; }
7320:
7321: $checkVirtualFunctionCall_ $(@expr1073746925 "cppcheck-2.8/test/testclass.cpp" $, 7321 $, "class B {\n    virtual int f() = 0;\n};\nclass A : B {\n    int f();\n    A() {f();}\n};\nint A::f() { return 1; }" $)
7322:
|
7327:
7328: ;
7329: $if $(@expr1073746926 $!@expr1073746927 $assertEquals $(@expr1073746928 "cppcheck-2.8/test/testclass.cpp" $, 7329 $, "" $, errout@var100 .@expr5087 str (@expr5088 ) $) $) { $return ; }
7330:
7331: $checkVirtualFunctionCall_ $(@expr1073746931 "cppcheck-2.8/test/testclass.cpp" $, 7331 $, "class A\n{\n    A() { A::f(); }\n    virtual void f() {}\n};" $)
7332:
7333:
7334:
7335: ;
7336: $if $(@expr1073746932 $!@expr1073746933 $assertEquals $(@expr1073746934 "cppcheck-2.8/test/testclass.cpp" $, 7336 $, "" $, errout@var100 .@expr5087 str (@expr5088 ) $) $) { $return ; }
7337:
7338: $checkVirtualFunctionCall_ $(@expr1073746937 "cppcheck-2.8/test/testclass.cpp" $, 7338 $, "class A : B {\n    int f() final { return 1; }\n    A() { f(); }\n};\n" $)
7339:
7340:
7341: ;
7342: $if $(@expr1073746938 $!@expr1073746939 $assertEquals $(@expr1073746940 "cppcheck-2.8/test/testclass.cpp" $, 7342 $, "" $, errout@var100 .@expr5087 str (@expr5088 ) $) $) { $return ; }
7343:
7344: $checkVirtualFunctionCall_ $(@expr1073746943 "cppcheck-2.8/test/testclass.cpp" $, 7344 $, "class B {\npublic:    virtual void f() {}\n};\nclass A : B {\npublic:    void f() override final {}\n    A() { f(); }\n};\n" $)
7345:
|
7351:
7352: ;
7353: $if $(@expr1073746944 $!@expr1073746945 $assertEquals $(@expr1073746946 "cppcheck-2.8/test/testclass.cpp" $, 7353 $, "" $, errout@var100 .@expr5087 str (@expr5088 ) $) $) { $return ; }
7354:
7355: $checkVirtualFunctionCall_ $(@expr1073746949 "cppcheck-2.8/test/testclass.cpp" $, 7355 $, "class Base {\npublic:\n    virtual void Copy(const Base& Src) = 0;\n};\nclass Derived : public Base {\npublic:\n    Derived() : i(0) {}\n    Derived(const Derived& Src);\n    void Copy(const Base& Src) override;\n    int i;\n};\nDerived::Derived(const Derived& Src) {\n    Copy(Src);\n}\nvoid Derived::Copy(const Base& Src) {\n    auto d = dynamic_cast<const Derived&>(Src);\n    i = d.i;\n}\n" $)
7356:
|
7371:
7372: ;
7373: $if $(@expr1073746950 $!@expr1073746951 $assertEquals $(@expr1073746952 "cppcheck-2.8/test/testclass.cpp" $, 7373 $, "[test.cpp:13] -> [test.cpp:9]: (style) Virtual function 'Copy' is called from copy constructor 'Derived(const Derived&Src)' at line 13. Dynamic binding is not used.\n" $, errout@var100 .@expr5087 str (@expr5088 ) $) $) { $return
7374: ; }
7375:
7376: $checkVirtualFunctionCall_ $(@expr1073746955 "cppcheck-2.8/test/testclass.cpp" $, 7376 $, "struct B {\n    B() { auto pf = &f; }\n    virtual void f() {}\n};\n" $)
7377:
7378:
7379: ;
7380: $if $(@expr1073746956 $!@expr1073746957 $assertEquals $(@expr1073746958 "cppcheck-2.8/test/testclass.cpp" $, 7380 $, "" $, errout@var100 .@expr5087 str (@expr5088 ) $) $) { $return ; }
7381:
7382: $checkVirtualFunctionCall_ $(@expr1073746961 "cppcheck-2.8/test/testclass.cpp" $, 7382 $, "struct B {\n    B() { auto pf = &B::f; }\n    virtual void f() {}\n};\n" $)
7383:
7384:
7385: ;
7386: $if $(@expr1073746962 $!@expr1073746963 $assertEquals $(@expr1073746964 "cppcheck-2.8/test/testclass.cpp" $, 7386 $, "" $, errout@var100 .@expr5087 str (@expr5088 ) $) $) { $return ; }
7387:
7388: $checkVirtualFunctionCall_ $(@expr1073746967 "cppcheck-2.8/test/testclass.cpp" $, 7388 $, "struct B {\n    B() { (f)(); }\n    virtual void f() {}\n};\n" $)
7389:
7390:
7391: ;
7392: $if $(@expr1073746968 $!@expr1073746969 $assertEquals $(@expr1073746970 "cppcheck-2.8/test/testclass.cpp" $, 7392 $, "[test.cpp:2] -> [test.cpp:3]: (style) Virtual function 'f' is called from constructor 'B()' at line 2. Dynamic binding is not used.\n" $, errout@var100 .@expr5087 str (@expr5088 ) $) $) { $return ; }
7393:
7394: $checkVirtualFunctionCall_ $(@expr1073746973 "cppcheck-2.8/test/testclass.cpp" $, 7394 $, "class S {\n    ~S();\npublic:\n    S();\n};\nS::S() {\n    typeid(S);\n}\nS::~S() = default;\n" $)
7395:
|
7401:
7402: ;
7403: $if $(@expr1073746974 $!@expr1073746975 $assertEquals $(@expr1073746976 "cppcheck-2.8/test/testclass.cpp" $, 7403 $, "" $, errout@var100 .@expr5087 str (@expr5088 ) $) $) { $return ; }
7404: }
7405:
7406: void pureVirtualFunctionCall ( ) {
7407: $checkVirtualFunctionCall_ $(@expr1073746979 "cppcheck-2.8/test/testclass.cpp" $, 7407 $, "class A\n{\n    virtual void pure()=0;\n    A();\n};\nA::A()\n{pure();}" $)
7408:
|
7412:
7413: ;
7414: $if $(@expr1073746980 $!@expr1073746981 $assertEquals $(@expr1073746982 "cppcheck-2.8/test/testclass.cpp" $, 7414 $, "[test.cpp:7] -> [test.cpp:3]: (warning) Call of pure virtual function 'pure' in constructor.\n" $, errout@var100 .@expr5159 str (@expr5160 ) $) $) { $return ; }
7415:
7416: $checkVirtualFunctionCall_ $(@expr1073746985 "cppcheck-2.8/test/testclass.cpp" $, 7416 $, "class A\n{\n    virtual int pure()=0;\n    A();\n    int m;\n};\nA::A():m(A::pure())\n{}" $)
7417:
|
7422:
7423: ;
7424: $if $(@expr1073746986 $!@expr1073746987 $assertEquals $(@expr1073746988 "cppcheck-2.8/test/testclass.cpp" $, 7424 $, "[test.cpp:7] -> [test.cpp:3]: (warning) Call of pure virtual function 'pure' in constructor.\n" $, errout@var100 .@expr5159 str (@expr5160 ) $) $) { $return ; }
7425:
7426: $checkVirtualFunctionCall_ $(@expr1073746991 "cppcheck-2.8/test/testclass.cpp" $, 7426 $, "namespace N {\n  class A\n  {\n      virtual int pure() = 0;\n      A();\n      int m;\n  };\n}\nN::A::A() : m(N::A::pure()) {}\n" $)
7427:
|
7433:
7434: ;
7435: $if $(@expr1073746992 $!@expr1073746993 $assertEquals $(@expr1073746994 "cppcheck-2.8/test/testclass.cpp" $, 7435 $, "[test.cpp:9] -> [test.cpp:4]: (warning) Call of pure virtual function 'pure' in constructor.\n" $, errout@var100 .@expr5159 str (@expr5160 ) $) $) { $return ; }
7436:
7437: $checkVirtualFunctionCall_ $(@expr1073746997 "cppcheck-2.8/test/testclass.cpp" $, 7437 $, "class A\n {\n    virtual void pure()=0;\n    virtual ~A();\n    int m;\n};\nA::~A()\n{pure();}" $)
7438:
|
7443:
7444: ;
7445: $if $(@expr1073746998 $!@expr1073746999 $assertEquals $(@expr1073747000 "cppcheck-2.8/test/testclass.cpp" $, 7445 $, "[test.cpp:8] -> [test.cpp:3]: (warning) Call of pure virtual function 'pure' in destructor.\n" $, errout@var100 .@expr5159 str (@expr5160 ) $) $) { $return ; }
7446:
7447: $checkVirtualFunctionCall_ $(@expr1073747003 "cppcheck-2.8/test/testclass.cpp" $, 7447 $, "class A\n {\n    virtual void pure()=0;\n    void nonpure()\n    {pure();}\n    A();\n};\nA::A()\n{nonpure();}" $)
7448:
|
7454:
7455: ;
7456: $if $(@expr1073747004 $!@expr1073747005 $assertEquals $(@expr1073747006 "cppcheck-2.8/test/testclass.cpp" $, 7456 $, "[test.cpp:9] -> [test.cpp:5] -> [test.cpp:3]: (warning) Call of pure virtual function 'pure' in constructor.\n" $, errout@var100 .@expr5159 str (@expr5160 ) $) $) { $return ; }
7457:
7458: $checkVirtualFunctionCall_ $(@expr1073747009 "cppcheck-2.8/test/testclass.cpp" $, 7458 $, "class A\n {\n    virtual int pure()=0;\n    int nonpure()\n    {return pure();}\n    A();\n    int m;\n};\nA::A():m(nonpure())\n{}" $)
7459:
|
7466:
7467: ;
7468: $todoAssertEquals $(@expr1073747010 "cppcheck-2.8/test/testclass.cpp" $, 7468 $, "[test.cpp:9] -> [test.cpp:5] -> [test.cpp:3]: (warning) Call of pure virtual function 'pure' in constructor.\n" $, "" $, errout@var100 .@expr5159 str (@expr5160 ) $) ;
7469:
7470: $checkVirtualFunctionCall_ $(@expr1073747013 "cppcheck-2.8/test/testclass.cpp" $, 7470 $, "class A\n {\n    virtual void pure()=0;\n    void nonpure()\n    {pure();}\n    virtual ~A();\n    int m;\n};\nA::~A()\n{nonpure();}" $)
7471:
|
7478:
7479: ;
7480: $if $(@expr1073747014 $!@expr1073747015 $assertEquals $(@expr1073747016 "cppcheck-2.8/test/testclass.cpp" $, 7480 $, "[test.cpp:10] -> [test.cpp:5] -> [test.cpp:3]: (warning) Call of pure virtual function 'pure' in destructor.\n" $, errout@var100 .@expr5159 str (@expr5160 ) $) $) { $return ; }
7481:
7482: $checkVirtualFunctionCall_ $(@expr1073747019 "cppcheck-2.8/test/testclass.cpp" $, 7482 $, "class A\n{\n    virtual void pure()=0;\n    A(bool b);\n};\nA::A(bool b)\n{if (b) pure();}" $)
7483:
|
7487:
7488: ;
7489: $if $(@expr1073747020 $!@expr1073747021 $assertEquals $(@expr1073747022 "cppcheck-2.8/test/testclass.cpp" $, 7489 $, "[test.cpp:7] -> [test.cpp:3]: (warning) Call of pure virtual function 'pure' in constructor.\n" $, errout@var100 .@expr5159 str (@expr5160 ) $) $) { $return ; }
7490:
7491: $checkVirtualFunctionCall_ $(@expr1073747025 "cppcheck-2.8/test/testclass.cpp" $, 7491 $, "class A\n{\n    virtual void pure()=0;\n    virtual ~A();\n    int m;\n};\nA::~A()\n{if (b) pure();}" $)
7492:
|
7497:
7498: ;
7499: $if $(@expr1073747026 $!@expr1073747027 $assertEquals $(@expr1073747028 "cppcheck-2.8/test/testclass.cpp" $, 7499 $, "[test.cpp:8] -> [test.cpp:3]: (warning) Call of pure virtual function 'pure' in destructor.\n" $, errout@var100 .@expr5159 str (@expr5160 ) $) $) { $return ; }
7500:
7501:
7502: $checkVirtualFunctionCall_ $(@expr1073747031 "cppcheck-2.8/test/testclass.cpp" $, 7502 $, "class abc {\npublic:\n  virtual ~abc() throw() {}\n  virtual void def(void* g) throw () = 0;\n};" $)
7503:
7504:
7505:
7506: ;
7507: $if $(@expr1073747032 $!@expr1073747033 $assertEquals $(@expr1073747034 "cppcheck-2.8/test/testclass.cpp" $, 7507 $, "" $, errout@var100 .@expr5159 str (@expr5160 ) $) $) { $return ; }
7508:
7509:
7510: $checkVirtualFunctionCall_ $(@expr1073747037 "cppcheck-2.8/test/testclass.cpp" $, 7510 $, "class CMyClass {\n    std::function< void(void) > m_callback;\npublic:\n    CMyClass() {\n        m_callback = [this]() { return VirtualMethod(); };\n    }\n    virtual void VirtualMethod() = 0;\n};" $)
7511:
|
7516:
7517: ;
7518: $if $(@expr1073747038 $!@expr1073747039 $assertEquals $(@expr1073747040 "cppcheck-2.8/test/testclass.cpp" $, 7518 $, "" $, errout@var100 .@expr5159 str (@expr5160 ) $) $) { $return ; }
7519: }
7520:
7521: void pureVirtualFunctionCallOtherClass ( ) {
7522: $checkVirtualFunctionCall_ $(@expr1073747043 "cppcheck-2.8/test/testclass.cpp" $, 7522 $, "class A\n{\n    virtual void pure()=0;\n    A(const A & a);\n};\nA::A(const A & a)\n{a.pure();}" $)
7523:
|
7527:
7528: ;
7529: $if $(@expr1073747044 $!@expr1073747045 $assertEquals $(@expr1073747046 "cppcheck-2.8/test/testclass.cpp" $, 7529 $, "" $, errout@var100 .@expr5223 str (@expr5224 ) $) $) { $return ; }
7530:
7531: $checkVirtualFunctionCall_ $(@expr1073747049 "cppcheck-2.8/test/testclass.cpp" $, 7531 $, "class A\n{\n    virtual void pure()=0;\n    A();\n};\nclass B\n{\n    virtual void pure()=0;\n};\nA::A()\n{B b; b.pure();}" $)
7532:
|
7540:
7541: ;
7542: $if $(@expr1073747050 $!@expr1073747051 $assertEquals $(@expr1073747052 "cppcheck-2.8/test/testclass.cpp" $, 7542 $, "" $, errout@var100 .@expr5223 str (@expr5224 ) $) $) { $return ; }
7543: }
7544:
7545: void pureVirtualFunctionCallWithBody ( ) {
7546: $checkVirtualFunctionCall_ $(@expr1073747055 "cppcheck-2.8/test/testclass.cpp" $, 7546 $, "class A\n{\n    virtual void pureWithBody()=0;\n    A();\n};\nA::A()\n{pureWithBody();}\nvoid A::pureWithBody()\n{}" $)
7547:
|
7553:
7554: ;
7555: $if $(@expr1073747056 $!@expr1073747057 $assertEquals $(@expr1073747058 "cppcheck-2.8/test/testclass.cpp" $, 7555 $, "" $, errout@var100 .@expr5235 str (@expr5236 ) $) $) { $return ; }
7556:
7557: $checkVirtualFunctionCall_ $(@expr1073747061 "cppcheck-2.8/test/testclass.cpp" $, 7557 $, "class A\n {\n    virtual void pureWithBody()=0;\n    void nonpure()\n    {pureWithBody();}\n    A();\n};\nA::A()\n{nonpure();}\nvoid A::pureWithBody()\n{}" $)
7558:
|
7566:
7567: ;
7568: $if $(@expr1073747062 $!@expr1073747063 $assertEquals $(@expr1073747064 "cppcheck-2.8/test/testclass.cpp" $, 7568 $, "" $, errout@var100 .@expr5235 str (@expr5236 ) $) $) { $return ; }
7569:
7570: }
7571:
7572: void pureVirtualFunctionCallPrevented ( ) {
7573: $checkVirtualFunctionCall_ $(@expr1073747067 "cppcheck-2.8/test/testclass.cpp" $, 7573 $, "class A\n {\n    virtual void pure()=0;\n    void nonpure(bool bCallPure)\n    { if (bCallPure) pure();}\n    A();\n};\nA::A()\n{nonpure(false);}" $)
7574:
|
7580:
7581: ;
7582: $if $(@expr1073747068 $!@expr1073747069 $assertEquals $(@expr1073747070 "cppcheck-2.8/test/testclass.cpp" $, 7582 $, "" $, errout@var100 .@expr5247 str (@expr5248 ) $) $) { $return ; }
7583:
7584: $checkVirtualFunctionCall_ $(@expr1073747073 "cppcheck-2.8/test/testclass.cpp" $, 7584 $, "class A\n {\n    virtual void pure()=0;\n    void nonpure(bool bCallPure)\n    { if (!bCallPure) ; else pure();}\n    A();\n};\nA::A()\n{nonpure(false);}" $)
7585:
|
7591:
7592: ;
7593: $if $(@expr1073747074 $!@expr1073747075 $assertEquals $(@expr1073747076 "cppcheck-2.8/test/testclass.cpp" $, 7593 $, "" $, errout@var100 .@expr5247 str (@expr5248 ) $) $) { $return ; }
7594:
7595: $checkVirtualFunctionCall_ $(@expr1073747079 "cppcheck-2.8/test/testclass.cpp" $, 7595 $, "class A\n {\n    virtual void pure()=0;\n    void nonpure(bool bCallPure)\n    {\n        switch (bCallPure) {\n        case true: pure(); break;\n        }\n    }\n    A();\n};\nA::A()\n{nonpure(false);}" $)
7596:
|
7606:
7607: ;
7608: $if $(@expr1073747080 $!@expr1073747081 $assertEquals $(@expr1073747082 "cppcheck-2.8/test/testclass.cpp" $, 7608 $, "" $, errout@var100 .@expr5247 str (@expr5248 ) $) $) { $return ; }
7609: }
7610:
7611:
7612:
7613: void checkOverride_ ( const char code@var224 [ ] , const char * file@var225 , int line@var226 ) {
7614:
7615: errout@var100 .@expr1073747086 str (@expr1073747087 "" ) ;
7616: Settings settings@var227 ;
7617: settings@var227 .@expr1073747088 severity@var228 .@expr1073747089 enable (@expr1073747090 Severity ::@expr1073747091 style@expr1073747085 ) ;
7618:
7619:
7620: Tokenizer tokenizer@var229 (@expr1073747092 &@expr5269 settings@var227 , this@expr5270 ) ;
7621: std ::@expr1073747095 istringstream istr@var230 (@expr1073747096 code@var224 ) ;
7622: $assert_ $(@expr1073747097 file@var225 $, line@var226 $, $(@expr1073747098 tokenizer@var229 .@expr1073747099 tokenize (@expr1073747100 istr@var230 , "test.cpp" ) $) $) ;
7623:
7624:
7625: CheckClass checkClass@var231 (@expr1073747101 &@expr1073747102 tokenizer@var229 , &@expr5269 settings@var227 , this@expr5270 ) ;
7626: checkClass@var231 .@expr1073747104 checkOverride (@expr1073747105 ) ;
7627: }
7628:
7629: void override1 ( ) {
7630: $checkOverride_ $(@expr1073747106 "class Base { virtual void f(); };\nclass Derived : Base { virtual void f(); };" $, "cppcheck-2.8/test/testclass.cpp" $, 7630 $)
7631: ;
7632: $if $(@expr1073747107 $!@expr1073747108 $assertEquals $(@expr1073747109 "cppcheck-2.8/test/testclass.cpp" $, 7632 $, "[test.cpp:1] -> [test.cpp:2]: (style) The function 'f' overrides a function in a base class but is not marked with a 'override' specifier.\n" $, errout@var100 .@expr5286 str (@expr5287 ) $) $) { $return ; }
7633:
7634: $checkOverride_ $(@expr1073747112 "class Base { virtual void f(); };\nclass Derived : Base { virtual void f() override; };" $, "cppcheck-2.8/test/testclass.cpp" $, 7634 $)
7635: ;
7636: $if $(@expr1073747113 $!@expr1073747114 $assertEquals $(@expr1073747115 "cppcheck-2.8/test/testclass.cpp" $, 7636 $, "" $, errout@var100 .@expr5286 str (@expr5287 ) $) $) { $return ; }
7637:
7638: $checkOverride_ $(@expr1073747118 "class Base { virtual void f(); };\nclass Derived : Base { virtual void f() final; };" $, "cppcheck-2.8/test/testclass.cpp" $, 7638 $)
7639: ;
7640: $if $(@expr1073747119 $!@expr1073747120 $assertEquals $(@expr1073747121 "cppcheck-2.8/test/testclass.cpp" $, 7640 $, "" $, errout@var100 .@expr5286 str (@expr5287 ) $) $) { $return ; }
7641:
7642: $checkOverride_ $(@expr1073747124 "class Base {\npublic:\n    virtual auto foo( ) const -> size_t { return 1; }\n    virtual auto bar( ) const -> size_t { return 1; }\n};\nclass Derived : public Base {\npublic :\n    auto foo( ) const -> size_t { return 0; }\n    auto bar( ) const -> size_t override { return 0; }\n};" $, "cppcheck-2.8/test/testclass.cpp" $, 7642 $)
7643:
|
7650:
7651: ;
7652: $if $(@expr1073747125 $!@expr1073747126 $assertEquals $(@expr1073747127 "cppcheck-2.8/test/testclass.cpp" $, 7652 $, "[test.cpp:3] -> [test.cpp:8]: (style) The function 'foo' overrides a function in a base class but is not marked with a 'override' specifier.\n" $, errout@var100 .@expr5286 str (@expr5287 ) $) $) { $return ; }
7653:
7654: $checkOverride_ $(@expr1073747130 "namespace Test {\n    class C {\n    public:\n        virtual ~C();\n    };\n}\nclass C : Test::C {\npublic:\n    ~C();\n};" $, "cppcheck-2.8/test/testclass.cpp" $, 7654 $)
7655:
|
7662:
7663: ;
7664: $if $(@expr1073747131 $!@expr1073747132 $assertEquals $(@expr1073747133 "cppcheck-2.8/test/testclass.cpp" $, 7664 $, "[test.cpp:4] -> [test.cpp:9]: (style) The destructor '~C' overrides a destructor in a base class but is not marked with a 'override' specifier.\n" $, errout@var100 .@expr5286 str (@expr5287 ) $) $) { $return ; }
7665:
7666: $checkOverride_ $(@expr1073747136 "struct Base {\n    virtual void foo();\n};\n\nstruct Derived: public Base {\n   void foo() override;\n   void foo(int);\n};" $, "cppcheck-2.8/test/testclass.cpp" $, 7666 $)
7667:
|
7672:
7673: ;
7674: $if $(@expr1073747137 $!@expr1073747138 $assertEquals $(@expr1073747139 "cppcheck-2.8/test/testclass.cpp" $, 7674 $, "" $, errout@var100 .@expr5286 str (@expr5287 ) $) $) { $return ; }
7675:
7676: $checkOverride_ $(@expr1073747142 "struct B {\n    virtual int f(int i) const = 0;\n};\nnamespace N {\n    struct D : B {\n        virtual int f(int i) const;\n    };\n}\n" $, "cppcheck-2.8/test/testclass.cpp" $, 7676 $)
7677:
|
7682:
7683: ;
7684: $if $(@expr1073747143 $!@expr1073747144 $assertEquals $(@expr1073747145 "cppcheck-2.8/test/testclass.cpp" $, 7684 $, "[test.cpp:2] -> [test.cpp:6]: (style) The function 'f' overrides a function in a base class but is not marked with a 'override' specifier.\n" $, errout@var100 .@expr5286 str (@expr5287 ) $) $) { $return ; }
7685:
7686: $checkOverride_ $(@expr1073747148 "struct A {\n    virtual void f(int);\n};\nstruct D : A {\n  void f(double);\n};\n" $, "cppcheck-2.8/test/testclass.cpp" $, 7686 $)
7687:
|
7690:
7691: ;
7692: $if $(@expr1073747149 $!@expr1073747150 $assertEquals $(@expr1073747151 "cppcheck-2.8/test/testclass.cpp" $, 7692 $, "" $, errout@var100 .@expr5286 str (@expr5287 ) $) $) { $return ; }
7693:
7694: $checkOverride_ $(@expr1073747154 "struct A {\n    virtual void f(int);\n};\nstruct D : A {\n  void f(int);\n};\n" $, "cppcheck-2.8/test/testclass.cpp" $, 7694 $)
7695:
|
7698:
7699: ;
7700: $if $(@expr1073747155 $!@expr1073747156 $assertEquals $(@expr1073747157 "cppcheck-2.8/test/testclass.cpp" $, 7700 $, "[test.cpp:2] -> [test.cpp:5]: (style) The function 'f' overrides a function in a base class but is not marked with a 'override' specifier.\n" $, errout@var100 .@expr5286 str (@expr5287 ) $) $) { $return ; }
7701:
7702: $checkOverride_ $(@expr1073747160 "struct A {\n    virtual void f(char, int);\n};\nstruct D : A {\n  void f(char, int);\n};\n" $, "cppcheck-2.8/test/testclass.cpp" $, 7702 $)
7703:
|
7706:
7707: ;
7708: $if $(@expr1073747161 $!@expr1073747162 $assertEquals $(@expr1073747163 "cppcheck-2.8/test/testclass.cpp" $, 7708 $, "[test.cpp:2] -> [test.cpp:5]: (style) The function 'f' overrides a function in a base class but is not marked with a 'override' specifier.\n" $, errout@var100 .@expr5286 str (@expr5287 ) $) $) { $return ; }
7709:
7710: $checkOverride_ $(@expr1073747166 "struct A {\n    virtual void f(char, int);\n};\nstruct D : A {\n  void f(char, double);\n};\n" $, "cppcheck-2.8/test/testclass.cpp" $, 7710 $)
7711:
|
7714:
7715: ;
7716: $if $(@expr1073747167 $!@expr1073747168 $assertEquals $(@expr1073747169 "cppcheck-2.8/test/testclass.cpp" $, 7716 $, "" $, errout@var100 .@expr5286 str (@expr5287 ) $) $) { $return ; }
7717:
7718: $checkOverride_ $(@expr1073747172 "struct A {\n    virtual void f(char, int);\n};\nstruct D : A {\n  void f(char c = '\\0', double);\n};\n" $, "cppcheck-2.8/test/testclass.cpp" $, 7718 $)
7719:
|
7722:
7723: ;
7724: $if $(@expr1073747173 $!@expr1073747174 $assertEquals $(@expr1073747175 "cppcheck-2.8/test/testclass.cpp" $, 7724 $, "" $, errout@var100 .@expr5286 str (@expr5287 ) $) $) { $return ; }
7725:
7726: $checkOverride_ $(@expr1073747178 "struct A {\n    virtual void f(char, int);\n};\nstruct D : A {\n  void f(char c = '\\0', int);\n};\n" $, "cppcheck-2.8/test/testclass.cpp" $, 7726 $)
7727:
|
7730:
7731: ;
7732: $if $(@expr1073747179 $!@expr1073747180 $assertEquals $(@expr1073747181 "cppcheck-2.8/test/testclass.cpp" $, 7732 $, "[test.cpp:2] -> [test.cpp:5]: (style) The function 'f' overrides a function in a base class but is not marked with a 'override' specifier.\n" $, errout@var100 .@expr5286 str (@expr5287 ) $) $) { $return ; }
7733:
7734: $checkOverride_ $(@expr1073747184 "struct A {\n    virtual void f(char c, std::vector<int>);\n};\nstruct D : A {\n  void f(char c, std::vector<double>);\n};\n" $, "cppcheck-2.8/test/testclass.cpp" $, 7734 $)
7735:
|
7738:
7739: ;
7740: $if $(@expr1073747185 $!@expr1073747186 $assertEquals $(@expr1073747187 "cppcheck-2.8/test/testclass.cpp" $, 7740 $, "" $, errout@var100 .@expr5286 str (@expr5287 ) $) $) { $return ; }
7741:
7742: $checkOverride_ $(@expr1073747190 "struct A {\n    virtual void f(char c, std::vector<int>);\n};\nstruct D : A {\n  void f(char c, std::set<int>);\n};\n" $, "cppcheck-2.8/test/testclass.cpp" $, 7742 $)
7743:
|
7746:
7747: ;
7748: $if $(@expr1073747191 $!@expr1073747192 $assertEquals $(@expr1073747193 "cppcheck-2.8/test/testclass.cpp" $, 7748 $, "" $, errout@var100 .@expr5286 str (@expr5287 ) $) $) { $return ; }
7749:
7750: $checkOverride_ $(@expr1073747196 "struct A {\n    virtual void f(char c, std::vector<int> v);\n};\nstruct D : A {\n  void f(char c, std::vector<int> w = {});\n};\n" $, "cppcheck-2.8/test/testclass.cpp" $, 7750 $)
7751:
|
7754:
7755: ;
7756: $todoAssertEquals $(@expr1073747197 "cppcheck-2.8/test/testclass.cpp" $, 7756 $, "[test.cpp:2] -> [test.cpp:5]: (style) The function 'f' overrides a function in a base class but is not marked with a 'override' specifier.\n" $, "" $, errout@var100 .@expr5286 str (@expr5287 ) $) ;
7757:
7758: $checkOverride_ $(@expr1073747200 "struct T {};\nstruct B {\n    virtual T f() = 0;\n};\nstruct D : B {\n    friend T f();\n};\n" $, "cppcheck-2.8/test/testclass.cpp" $, 7758 $)
7759:
|
7763:
7764: ;
7765: $if $(@expr1073747201 $!@expr1073747202 $assertEquals $(@expr1073747203 "cppcheck-2.8/test/testclass.cpp" $, 7765 $, "" $, errout@var100 .@expr5286 str (@expr5287 ) $) $) { $return ; }
7766: }
7767:
7768: void overrideCVRefQualifiers ( ) {
7769: $checkOverride_ $(@expr1073747206 "class Base { virtual void f(); };\nclass Derived : Base { void f() const; }" $, "cppcheck-2.8/test/testclass.cpp" $, 7769 $)
7770: ;
7771: $if $(@expr1073747207 $!@expr1073747208 $assertEquals $(@expr1073747209 "cppcheck-2.8/test/testclass.cpp" $, 7771 $, "" $, errout@var100 .@expr5386 str (@expr5387 ) $) $) { $return ; }
7772:
7773: $checkOverride_ $(@expr1073747212 "class Base { virtual void f(); };\nclass Derived : Base { void f() volatile; }" $, "cppcheck-2.8/test/testclass.cpp" $, 7773 $)
7774: ;
7775: $if $(@expr1073747213 $!@expr1073747214 $assertEquals $(@expr1073747215 "cppcheck-2.8/test/testclass.cpp" $, 7775 $, "" $, errout@var100 .@expr5386 str (@expr5387 ) $) $) { $return ; }
7776:
7777: $checkOverride_ $(@expr1073747218 "class Base { virtual void f(); };\nclass Derived : Base { void f() &; }" $, "cppcheck-2.8/test/testclass.cpp" $, 7777 $)
7778: ;
7779: $if $(@expr1073747219 $!@expr1073747220 $assertEquals $(@expr1073747221 "cppcheck-2.8/test/testclass.cpp" $, 7779 $, "" $, errout@var100 .@expr5386 str (@expr5387 ) $) $) { $return ; }
7780:
7781: $checkOverride_ $(@expr1073747224 "class Base { virtual void f(); };\nclass Derived : Base { void f() &&; }" $, "cppcheck-2.8/test/testclass.cpp" $, 7781 $)
7782: ;
7783: $if $(@expr1073747225 $!@expr1073747226 $assertEquals $(@expr1073747227 "cppcheck-2.8/test/testclass.cpp" $, 7783 $, "" $, errout@var100 .@expr5386 str (@expr5387 ) $) $) { $return ; }
7784: }
7785:
7786:
7787:
7788: void checkUnsafeClassRefMember_ ( const char code@var232 [ ] , const char * file@var233 , int line@var234 ) {
7789:
7790: errout@var100 .@expr1073747231 str (@expr1073747232 "" ) ;
7791: Settings settings@var235 ;
7792: settings@var235 .@expr1073747233 safeChecks@var236 .@expr1073747234 classes@var237 =@expr1073747235 true ;
7793: settings@var235 .@expr1073747236 severity@var238 .@expr1073747237 enable (@expr1073747238 Severity ::@expr1073747239 warning@expr1073747230 ) ;
7794:
7795:
7796: Tokenizer tokenizer@var239 (@expr1073747240 &@expr5417 settings@var235 , this@expr5418 ) ;
7797: std ::@expr1073747243 istringstream istr@var240 (@expr1073747244 code@var232 ) ;
7798: $assert_ $(@expr1073747245 file@var233 $, line@var234 $, $(@expr1073747246 tokenizer@var239 .@expr1073747247 tokenize (@expr1073747248 istr@var240 , "test.cpp" ) $) $) ;
7799:
7800:
7801: CheckClass checkClass@var241 (@expr1073747249 &@expr1073747250 tokenizer@var239 , &@expr5417 settings@var235 , this@expr5418 ) ;
7802: checkClass@var241 .@expr1073747252 checkUnsafeClassRefMember (@expr1073747253 ) ;
7803: }
7804:
7805: void unsafeClassRefMember ( ) {
7806: $checkUnsafeClassRefMember_ $(@expr1073747254 "class C { C(const std::string &s) : s(s) {} const std::string &s; };" $, "cppcheck-2.8/test/testclass.cpp" $, 7806 $) ;
7807: $if $(@expr1073747255 $!@expr1073747256 $assertEquals $(@expr1073747257 "cppcheck-2.8/test/testclass.cpp" $, 7807 $, "[test.cpp:1]: (warning) Unsafe class: The const reference member 'C::s' is initialized by a const reference constructor argument. You need to be careful about lifetime issues.\n" $, errout@var100 .@expr1073747258 str (@expr1073747259 ) $) $) { $return ; }
7808: }
7809:
7810:
7811:
7812: void checkThisUseAfterFree_ ( const char code@var242 [ ] , const char * file@var243 , int line@var244 ) {
7813:
7814: errout@var100 .@expr1073747260 str (@expr1073747261 "" ) ;
7815:
7816:
7817: Tokenizer tokenizer@var245 (@expr1073747262 &@expr5439 settings1@var103 , this@expr5440 ) ;
7818: std ::@expr1073747265 istringstream istr@var246 (@expr1073747266 code@var242 ) ;
7819: $assert_ $(@expr1073747267 file@var243 $, line@var244 $, $(@expr1073747268 tokenizer@var245 .@expr1073747269 tokenize (@expr1073747270 istr@var246 , "test.cpp" ) $) $) ;
7820:
7821:
7822: CheckClass checkClass@var247 (@expr1073747271 &@expr1073747272 tokenizer@var245 , &@expr5439 settings1@var103 , this@expr5440 ) ;
7823: checkClass@var247 .@expr1073747274 checkThisUseAfterFree (@expr1073747275 ) ;
7824: }
7825:
7826: void thisUseAfterFree ( ) {
7827: setMultiline (@expr1073747276 ) ;
7828:
7829:
7830: $checkThisUseAfterFree_ $(@expr1073747277 "class C {\npublic:\n  void dostuff() { delete mInstance; hello(); }\nprivate:\n  static C *mInstance;\n  void hello() {}\n};" $, "cppcheck-2.8/test/testclass.cpp" $, 7830 $)
7831:
|
7835:
7836: ;
7837: $if $(@expr1073747278 $!@expr1073747279 $assertEquals $(@expr1073747280 "cppcheck-2.8/test/testclass.cpp" $, 7837 $, "test.cpp:3:warning:Calling method 'hello()' when 'this' might be invalid\ntest.cpp:5:note:Assuming 'mInstance' is used as 'this'\ntest.cpp:3:note:Delete 'mInstance', invalidating 'this'\ntest.cpp:3:note:Call method when 'this' is invalid\n" $, errout@var100 .@expr5457 str (@expr5458 ) $) $) { $return
7838:
7839:
7840:
7841: ; }
7842:
7843: $checkThisUseAfterFree_ $(@expr1073747283 "class C {\npublic:\n  void dostuff() { mInstance.reset(); hello(); }\nprivate:\n  static std::shared_ptr<C> mInstance;\n  void hello() {}\n};" $, "cppcheck-2.8/test/testclass.cpp" $, 7843 $)
7844:
|
7848:
7849: ;
7850: $if $(@expr1073747284 $!@expr1073747285 $assertEquals $(@expr1073747286 "cppcheck-2.8/test/testclass.cpp" $, 7850 $, "test.cpp:3:warning:Calling method 'hello()' when 'this' might be invalid\ntest.cpp:5:note:Assuming 'mInstance' is used as 'this'\ntest.cpp:3:note:Delete 'mInstance', invalidating 'this'\ntest.cpp:3:note:Call method when 'this' is invalid\n" $, errout@var100 .@expr5457 str (@expr5458 ) $) $) { $return
7851:
7852:
7853:
7854: ; }
7855:
7856: $checkThisUseAfterFree_ $(@expr1073747289 "class C {\npublic:\n  void dostuff() { reset(); hello(); }\nprivate:\n  static std::shared_ptr<C> mInstance;\n  void hello();\n  void reset() { mInstance.reset(); }\n};" $, "cppcheck-2.8/test/testclass.cpp" $, 7856 $)
7857:
|
7862:
7863: ;
7864: $if $(@expr1073747290 $!@expr1073747291 $assertEquals $(@expr1073747292 "cppcheck-2.8/test/testclass.cpp" $, 7864 $, "test.cpp:3:warning:Calling method 'hello()' when 'this' might be invalid\ntest.cpp:5:note:Assuming 'mInstance' is used as 'this'\ntest.cpp:7:note:Delete 'mInstance', invalidating 'this'\ntest.cpp:3:note:Call method when 'this' is invalid\n" $, errout@var100 .@expr5457 str (@expr5458 ) $) $) { $return
7865:
7866:
7867:
7868: ; }
7869:
7870:
7871: $checkThisUseAfterFree_ $(@expr1073747295 "class C {\npublic:\n  void dostuff() { delete self; x = 123; }\nprivate:\n  static C *self;\n  int x;\n};" $, "cppcheck-2.8/test/testclass.cpp" $, 7871 $)
7872:
|
7876:
7877: ;
7878: $if $(@expr1073747296 $!@expr1073747297 $assertEquals $(@expr1073747298 "cppcheck-2.8/test/testclass.cpp" $, 7878 $, "test.cpp:3:warning:Using member 'x' when 'this' might be invalid\ntest.cpp:5:note:Assuming 'self' is used as 'this'\ntest.cpp:3:note:Delete 'self', invalidating 'this'\ntest.cpp:3:note:Call method when 'this' is invalid\n" $, errout@var100 .@expr5457 str (@expr5458 ) $) $) { $return
7879:
7880:
7881:
7882: ; }
7883:
7884: $checkThisUseAfterFree_ $(@expr1073747301 "class C {\npublic:\n  void dostuff() { delete self; x[1] = 123; }\nprivate:\n  static C *self;\n  std::map<int,int> x;\n};" $, "cppcheck-2.8/test/testclass.cpp" $, 7884 $)
7885:
|
7889:
7890: ;
7891: $if $(@expr1073747302 $!@expr1073747303 $assertEquals $(@expr1073747304 "cppcheck-2.8/test/testclass.cpp" $, 7891 $, "test.cpp:3:warning:Using member 'x' when 'this' might be invalid\ntest.cpp:5:note:Assuming 'self' is used as 'this'\ntest.cpp:3:note:Delete 'self', invalidating 'this'\ntest.cpp:3:note:Call method when 'this' is invalid\n" $, errout@var100 .@expr5457 str (@expr5458 ) $) $) { $return
7892:
7893:
7894:
7895: ; }
7896:
7897:
7898: $checkThisUseAfterFree_ $(@expr1073747307 "class C {\npublic:\n  void hold() { mInstance = shared_from_this(); }\n  void dostuff() { mInstance.reset(); hello(); }\nprivate:\n  std::shared_ptr<C> mInstance;\n  void hello() {}\n};" $, "cppcheck-2.8/test/testclass.cpp" $, 7898 $)
7899:
|
7904:
7905: ;
7906: $if $(@expr1073747308 $!@expr1073747309 $assertEquals $(@expr1073747310 "cppcheck-2.8/test/testclass.cpp" $, 7906 $, "test.cpp:4:warning:Calling method 'hello()' when 'this' might be invalid\ntest.cpp:6:note:Assuming 'mInstance' is used as 'this'\ntest.cpp:4:note:Delete 'mInstance', invalidating 'this'\ntest.cpp:4:note:Call method when 'this' is invalid\n" $, errout@var100 .@expr5457 str (@expr5458 ) $) $) { $return
7907:
7908:
7909:
7910: ; }
7911:
7912:
7913: $checkThisUseAfterFree_ $(@expr1073747313 "class C {\npublic:\n  void dostuff() { delete self; x = 123; }\nprivate:\n  C *self;\n  int x;\n};" $, "cppcheck-2.8/test/testclass.cpp" $, 7913 $)
7914:
|
7918:
7919: ;
7920: $if $(@expr1073747314 $!@expr1073747315 $assertEquals $(@expr1073747316 "cppcheck-2.8/test/testclass.cpp" $, 7920 $, "" $, errout@var100 .@expr5457 str (@expr5458 ) $) $) { $return ; }
7921:
7922: $checkThisUseAfterFree_ $(@expr1073747319 "class C {\npublic:\n  void hold() { mInstance = shared_from_this(); }\n  void dostuff() { if (x) { mInstance.reset(); return; } hello(); }\nprivate:\n  std::shared_ptr<C> mInstance;\n  void hello() {}\n};" $, "cppcheck-2.8/test/testclass.cpp" $, 7922 $)
7923:
|
7928:
7929: ;
7930: $if $(@expr1073747320 $!@expr1073747321 $assertEquals $(@expr1073747322 "cppcheck-2.8/test/testclass.cpp" $, 7930 $, "" $, errout@var100 .@expr5457 str (@expr5458 ) $) $) { $return ; }
7931:
7932: $checkThisUseAfterFree_ $(@expr1073747325 "class C\n{\npublic:\n    explicit C(const QString& path) : mPath( path ) {}\n\n    static void initialize(const QString& path) {\n        if (instanceSingleton)\n            delete instanceSingleton;\n        instanceSingleton = new C(path);\n    }\nprivate:\n    static C* instanceSingleton;\n};\n\nC* C::instanceSingleton;" $, "cppcheck-2.8/test/testclass.cpp" $, 7932 $)
7933:
|
7945:
7946: ;
7947: $if $(@expr1073747326 $!@expr1073747327 $assertEquals $(@expr1073747328 "cppcheck-2.8/test/testclass.cpp" $, 7947 $, "" $, errout@var100 .@expr5457 str (@expr5458 ) $) $) { $return ; }
7948:
7949:
7950: $checkThisUseAfterFree_ $(@expr1073747331 "class C {\npublic:\n    void foo();\n    void set() { p = this; }\n    void dostuff() {}\n    C* p;\n};\n\nvoid C::foo() {\n    auto done = [this] () { delete p; };\n    dostuff();\n    done();\n}" $, "cppcheck-2.8/test/testclass.cpp" $, 7950 $)
7951:
|
7961:
7962: ;
7963: $if $(@expr1073747332 $!@expr1073747333 $assertEquals $(@expr1073747334 "cppcheck-2.8/test/testclass.cpp" $, 7963 $, "" $, errout@var100 .@expr5457 str (@expr5458 ) $) $) { $return ; }
7964: }
7965:
7966:
7967: void ctu ( const std :: vector < std :: string > & code@var248 ) {
7968: Settings settings@var249 ;
7969: CheckClass check@var250 ;
7970:
7971:
7972: std ::@expr1073747337 list < Check ::@expr5514 FileInfo *@expr1073747339 > fileInfo@var251 ;
7973: for (@expr1073747340 const std ::@expr5514 string &@expr1073747342 c@var252 :@expr1073747343 code@var248 ) {
7974: Tokenizer tokenizer@var253 (@expr1073747344 &@expr5521 settings@var249 , this@expr5522 ) ;
7975: std ::@expr1073747347 istringstream istr@var254 (@expr1073747348 c@var252 ) ;
7976: $if $(@expr1073747349 $!@expr1073747350 $assert_ $(@expr1073747351 "cppcheck-2.8/test/testclass.cpp" $, 7976 $, $(@expr1073747352 tokenizer@var253 .@expr1073747353 tokenize (@expr1073747354 istr@var254 , (@expr1073747355 std ::@expr1073747356 to_string (@expr1073747357 fileInfo@var251 .@expr1073747358 size (@expr1073747359 ) ) +@expr1073747360 ".cpp" ) .@expr1073747361 c_str (@expr1073747362 ) ) $) $) $) { $return ; }
7977: fileInfo@var251 .@expr1073747363 push_back (@expr1073747364 check@var250 .@expr1073747365 getFileInfo (@expr1073747366 &@expr1073747367 tokenizer@var253 , &@expr5521 settings@var249 ) ) ;
7978: }
7979:
7980:
7981: errout@var100 .@expr1073747369 str (@expr1073747370 "" ) ;
7982: check@var250 .@expr1073747371 analyseWholeProgram (@expr1073747372 nullptr , fileInfo@var251 , settings@var249 , *@expr1073747373 this@expr5522 ) ;
7983:
7984: while (@expr1073747374 !@expr1073747375 fileInfo@var251 .@expr1073747376 empty (@expr1073747377 ) ) {
7985: delete fileInfo@var251 .@expr1073747378 back (@expr1073747379 ) ;
7986: fileInfo@var251 .@expr1073747380 pop_back (@expr1073747381 ) ;
7987: }
7988: }
7989:
7990: void ctuOneDefinitionRule ( ) {
7991: ctu (@expr1073747382 {@expr1073747383 "class C { C() { std::cout << 0; } };" , "class C { C() { std::cout << 1; } };" } ) ;
7992: $if $(@expr1073747384 $!@expr1073747385 $assertEquals $(@expr1073747386 "cppcheck-2.8/test/testclass.cpp" $, 7992 $, "[1.cpp:1] -> [0.cpp:1]: (error) The one definition rule is violated, different classes/structs have the same name 'C'\n" $, errout@var100 .@expr5563 str (@expr5564 ) $) $) { $return ; }
7993:
7994: ctu (@expr1073747389 {@expr1073747390 "class C { C(); }; C::C() { std::cout << 0; }" , "class C { C(); }; C::C() { std::cout << 1; }" } ) ;
7995: $if $(@expr1073747391 $!@expr1073747392 $assertEquals $(@expr1073747393 "cppcheck-2.8/test/testclass.cpp" $, 7995 $, "[1.cpp:1] -> [0.cpp:1]: (error) The one definition rule is violated, different classes/structs have the same name 'C'\n" $, errout@var100 .@expr5563 str (@expr5564 ) $) $) { $return ; }
7996:
7997: ctu (@expr1073747396 {@expr1073747397 "class C { C() {} };\n" , "class C { C() {} };\n" } ) ;
7998: $if $(@expr1073747398 $!@expr1073747399 $assertEquals $(@expr1073747400 "cppcheck-2.8/test/testclass.cpp" $, 7998 $, "" $, errout@var100 .@expr5563 str (@expr5564 ) $) $) { $return ; }
7999:
8000: ctu (@expr1073747403 {@expr1073747404 "class C { C(); }; C::C(){}" , "class C { C(); }; C::C(){}" } ) ;
8001: $if $(@expr1073747405 $!@expr1073747406 $assertEquals $(@expr1073747407 "cppcheck-2.8/test/testclass.cpp" $, 8001 $, "" $, errout@var100 .@expr5563 str (@expr5564 ) $) $) { $return ; }
8002:
8003: ctu (@expr1073747410 {@expr1073747411 "class A::C { C() { std::cout << 0; } };" , "class B::C { C() { std::cout << 1; } };" } ) ;
8004: $if $(@expr1073747412 $!@expr1073747413 $assertEquals $(@expr1073747414 "cppcheck-2.8/test/testclass.cpp" $, 8004 $, "" $, errout@var100 .@expr5563 str (@expr5564 ) $) $) { $return ; }
8005: }
8006:
8007:
8008:
8009: void getFileInfo_ ( const char code@var255 [ ] , const char * file@var256 , int line@var257 ) {
8010:
8011: errout@var100 .@expr1073747417 str (@expr1073747418 "" ) ;
8012:
8013:
8014: Tokenizer tokenizer@var258 (@expr1073747419 &@expr5596 settings1@var103 , this@expr5597 ) ;
8015: std ::@expr1073747422 istringstream istr@var259 (@expr1073747423 code@var255 ) ;
8016: $assert_ $(@expr1073747424 file@var256 $, line@var257 $, $(@expr1073747425 tokenizer@var258 .@expr1073747426 tokenize (@expr1073747427 istr@var259 , "test.cpp" ) $) $) ;
8017:
8018:
8019: CheckClass checkClass@var260 (@expr1073747428 &@expr5605 tokenizer@var258 , &@expr5596 settings1@var103 , this@expr5597 ) ;
8020:
8021: Check ::@expr1073747431 FileInfo * fileInfo@var261 ; fileInfo@var261 =@expr1073747432 (@expr1073747433 checkClass@var260 .@expr1073747434 getFileInfo@var262 ) (@expr1073747435 &@expr5605 tokenizer@var258 , &@expr5596 settings1@var103 ) ;
8022:
8023: delete fileInfo@var261 ;
8024: }
8025:
8026: void testGetFileInfo ( ) {
8027: $getFileInfo_ $(@expr1073747438 "void foo() { union { struct { }; }; }" $, "cppcheck-2.8/test/testclass.cpp" $, 8027 $) ;
8028: $getFileInfo_ $(@expr1073747439 "struct sometype { sometype(); }; sometype::sometype() = delete;" $, "cppcheck-2.8/test/testclass.cpp" $, 8028 $) ;
8029: }
8030:
8031: } ;
8032:
8033: $namespace ${ TestClass instance_TestClass@var263 $; $}



##Value flow
Line 37
  countTests always !<=-1
Line 38
  fails_counter always !<=-1
Line 39
  todos_counter always !<=-1
Line 40
  succeeded_todos_counter always !<=-1
Line 42
  mVerbose always {!<=-1,!>=2}
Line 50
  quiet_tests always {!<=-1,!>=2}
Line 52
  = always 0
  0 always 0
Line 54
  ( always {!<=-1,!>=2}
Line 55
  , always !<=-1
  linenr always !<=-1
Line 57
  ( always {!<=-1,!>=2}
  , always !<=-1
  linenr always !<=-1
  , always {!<=-1,!>=2}
  condition always {!<=-1,!>=2}
Line 60
  ( always {!<=-1,!>=2}
  , always !<=-1
  linenr always !<=-1
Line 61
  != always {!<=-1,!>=2}
Line 63
  expected always !symbolic=(actual)
Line 65
  actual always !symbolic=(expected)
Line 67
  linenr always !<=-1
Line 69
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
Line 74
  , always !<=-1
  linenr always !<=-1
Line 76
  ( always {!<=-1,!>=2}
  , always !<=-1
  linenr always !<=-1
Line 77
  , always !<=-1
  linenr always !<=-1
Line 78
  ( always {!<=-1,!>=2}
  , always !<=-1
  linenr always !<=-1
Line 79
  ( always {!<=-1,!>=2}
  , always !<=-1
  linenr always !<=-1
Line 80
  ( always {!<=-1,!>=2}
  , always !<=-1
  linenr always !<=-1
Line 81
  ( always {!<=-1,!>=2}
  , always !<=-1
  linenr always !<=-1
Line 82
  , always !<=-1
  linenr always !<=-1
Line 84
  , always !<=-1
  linenr always !<=-1
Line 86
  , always !<=-1
  linenr always !<=-1
Line 88
  , always !<=-1
  linenr always !<=-1
Line 90
  , always !<=-1
  linenr always !<=-1
Line 91
  , always !<=-1
  linenr always !<=-1
Line 92
  , always !<=-1
  linenr always !<=-1
Line 96
  v always {!<=-1,!>=2}
Line 97
  mVerbose always {!<=-1,!>=2}
  = {!<=-1,!>=2,0@173}
  v {!<=-1,!>=2,0@173}
Line 101
  = always "{file}:{line}:{severity}:{message}"
  "{file}:{line}:{severity}:{message}" always "{file}:{line}:{severity}:{message}"
Line 102
  = always "{file}:{line}:note:{info}"
  "{file}:{line}:note:{info}" always "{file}:{line}:note:{info}"
Line 116
  ( always !<=-1
Line 37
  "TestClass" always "TestClass"
Line 49
  422 always 422
  = always "<?xml version=\"1.0\"?>\n<def>\n  <memory>\n    <alloc init=\"false\">malloc</alloc>\n    <dealloc>free</dealloc>\n  </memory>\n  <smart-pointer class-name=\"std::shared_ptr\"/>\n  <container id=\"stdVector\" startPattern=\"std :: vector &lt;\" itEndPattern=\"&gt; :: const_iterator\">\n    <access>\n      <function name=\"begin\" yields=\"start-iterator\"/>\n      <function name=\"end\" yields=\"end-iterator\"/>\n    </access>\n  </container>\n</def>"
  "<?xml version=\"1.0\"?>\n<def>\n  <memory>\n    <alloc init=\"false\">malloc</alloc>\n    <dealloc>free</dealloc>\n  </memory>\n  <smart-pointer class-name=\"std::shared_ptr\"/>\n  <container id=\"stdVector\" startPattern=\"std :: vector &lt;\" itEndPattern=\"&gt; :: const_iterator\">\n    <access>\n      <function name=\"begin\" yields=\"start-iterator\"/>\n      <function name=\"end\" yields=\"end-iterator\"/>\n    </access>\n  </container>\n</def>" always "<?xml version=\"1.0\"?>\n<def>\n  <memory>\n    <alloc init=\"false\">malloc</alloc>\n    <dealloc>free</dealloc>\n  </memory>\n  <smart-pointer class-name=\"std::shared_ptr\"/>\n  <container id=\"stdVector\" startPattern=\"std :: vector &lt;\" itEndPattern=\"&gt; :: const_iterator\">\n    <access>\n      <function name=\"begin\" yields=\"start-iterator\"/>\n      <function name=\"end\" yields=\"end-iterator\"/>\n    </access>\n  </container>\n</def>"
Line 64
  xmldata always "<?xml version=\"1.0\"?>\n<def>\n  <memory>\n    <alloc init=\"false\">malloc</alloc>\n    <dealloc>free</dealloc>\n  </memory>\n  <smart-pointer class-name=\"std::shared_ptr\"/>\n  <container id=\"stdVector\" startPattern=\"std :: vector &lt;\" itEndPattern=\"&gt; :: const_iterator\">\n    <access>\n      <function name=\"begin\" yields=\"start-iterator\"/>\n      <function name=\"end\" yields=\"end-iterator\"/>\n    </access>\n  </container>\n</def>"
  sizeof always 422
  ( always 422
  xmldata always "<?xml version=\"1.0\"?>\n<def>\n  <memory>\n    <alloc init=\"false\">malloc</alloc>\n    <dealloc>free</dealloc>\n  </memory>\n  <smart-pointer class-name=\"std::shared_ptr\"/>\n  <container id=\"stdVector\" startPattern=\"std :: vector &lt;\" itEndPattern=\"&gt; :: const_iterator\">\n    <access>\n      <function name=\"begin\" yields=\"start-iterator\"/>\n      <function name=\"end\" yields=\"end-iterator\"/>\n    </access>\n  </container>\n</def>"
Line 70
  ( always {!<=-1,!>=2}
  "virtualDestructor1" always "virtualDestructor1"
  false always 0
  false always 0
Line 71
  ( always {!<=-1,!>=2}
  "virtualDestructor2" always "virtualDestructor2"
  false always 0
  false always 0
Line 72
  ( always {!<=-1,!>=2}
  "virtualDestructor3" always "virtualDestructor3"
  false always 0
  false always 0
Line 73
  ( always {!<=-1,!>=2}
  "virtualDestructor4" always "virtualDestructor4"
  false always 0
  false always 0
Line 74
  ( always {!<=-1,!>=2}
  "virtualDestructor5" always "virtualDestructor5"
  false always 0
  false always 0
Line 75
  ( always {!<=-1,!>=2}
  "virtualDestructor6" always "virtualDestructor6"
  false always 0
  false always 0
Line 76
  ( always {!<=-1,!>=2}
  "virtualDestructorProtected" always "virtualDestructorProtected"
  false always 0
  false always 0
Line 77
  ( always {!<=-1,!>=2}
  "virtualDestructorInherited" always "virtualDestructorInherited"
  false always 0
  false always 0
Line 78
  ( always {!<=-1,!>=2}
  "virtualDestructorTemplate" always "virtualDestructorTemplate"
  false always 0
  false always 0
Line 80
  ( always {!<=-1,!>=2}
  "virtualDestructorInconclusive" always "virtualDestructorInconclusive"
  false always 0
  false always 0
Line 82
  ( always {!<=-1,!>=2}
  "copyConstructor1" always "copyConstructor1"
  false always 0
  false always 0
Line 83
  ( always {!<=-1,!>=2}
  "copyConstructor2" always "copyConstructor2"
  false always 0
  false always 0
Line 84
  ( always {!<=-1,!>=2}
  "copyConstructor3" always "copyConstructor3"
  false always 0
  false always 0
Line 85
  ( always {!<=-1,!>=2}
  "copyConstructor4" always "copyConstructor4"
  false always 0
  false always 0
Line 86
  ( always {!<=-1,!>=2}
  "copyConstructor5" always "copyConstructor5"
  false always 0
  false always 0
Line 87
  ( always {!<=-1,!>=2}
  "copyConstructor6" always "copyConstructor6"
  false always 0
  false always 0
Line 88
  ( always {!<=-1,!>=2}
  "noOperatorEq" always "noOperatorEq"
  false always 0
  false always 0
Line 89
  ( always {!<=-1,!>=2}
  "noDestructor" always "noDestructor"
  false always 0
  false always 0
Line 91
  ( always {!<=-1,!>=2}
  "operatorEqRetRefThis1" always "operatorEqRetRefThis1"
  false always 0
  false always 0
Line 92
  ( always {!<=-1,!>=2}
  "operatorEqRetRefThis2" always "operatorEqRetRefThis2"
  false always 0
  false always 0
Line 93
  ( always {!<=-1,!>=2}
  "operatorEqRetRefThis3" always "operatorEqRetRefThis3"
  false always 0
  false always 0
Line 94
  ( always {!<=-1,!>=2}
  "operatorEqRetRefThis4" always "operatorEqRetRefThis4"
  false always 0
  false always 0
Line 95
  ( always {!<=-1,!>=2}
  "operatorEqRetRefThis5" always "operatorEqRetRefThis5"
  false always 0
  false always 0
Line 96
  ( always {!<=-1,!>=2}
  "operatorEqRetRefThis6" always "operatorEqRetRefThis6"
  false always 0
  false always 0
Line 97
  ( always {!<=-1,!>=2}
  "operatorEqRetRefThis7" always "operatorEqRetRefThis7"
  false always 0
  false always 0
Line 98
  ( always {!<=-1,!>=2}
  "operatorEqToSelf1" always "operatorEqToSelf1"
  false always 0
  false always 0
Line 99
  ( always {!<=-1,!>=2}
  "operatorEqToSelf2" always "operatorEqToSelf2"
  false always 0
  false always 0
Line 100
  ( always {!<=-1,!>=2}
  "operatorEqToSelf3" always "operatorEqToSelf3"
  false always 0
  false always 0
Line 101
  ( always {!<=-1,!>=2}
  "operatorEqToSelf4" always "operatorEqToSelf4"
  false always 0
  false always 0
Line 102
  ( always {!<=-1,!>=2}
  "operatorEqToSelf5" always "operatorEqToSelf5"
  false always 0
  false always 0
Line 103
  ( always {!<=-1,!>=2}
  "operatorEqToSelf6" always "operatorEqToSelf6"
  false always 0
  false always 0
Line 104
  ( always {!<=-1,!>=2}
  "operatorEqToSelf7" always "operatorEqToSelf7"
  false always 0
  false always 0
Line 105
  ( always {!<=-1,!>=2}
  "operatorEqToSelf8" always "operatorEqToSelf8"
  false always 0
  false always 0
Line 106
  ( always {!<=-1,!>=2}
  "operatorEqToSelf9" always "operatorEqToSelf9"
  false always 0
  false always 0
Line 108
  ( always {!<=-1,!>=2}
  "memsetOnStruct" always "memsetOnStruct"
  false always 0
  false always 0
Line 109
  ( always {!<=-1,!>=2}
  "memsetVector" always "memsetVector"
  false always 0
  false always 0
Line 110
  ( always {!<=-1,!>=2}
  "memsetOnClass" always "memsetOnClass"
  false always 0
  false always 0
Line 111
  ( always {!<=-1,!>=2}
  "memsetOnInvalid" always "memsetOnInvalid"
  false always 0
  false always 0
Line 112
  ( always {!<=-1,!>=2}
  "memsetOnStdPodType" always "memsetOnStdPodType"
  false always 0
  false always 0
Line 113
  ( always {!<=-1,!>=2}
  "memsetOnFloat" always "memsetOnFloat"
  false always 0
  false always 0
Line 114
  ( always {!<=-1,!>=2}
  "memsetOnUnknown" always "memsetOnUnknown"
  false always 0
  false always 0
Line 115
  ( always {!<=-1,!>=2}
  "mallocOnClass" always "mallocOnClass"
  false always 0
  false always 0
Line 117
  ( always {!<=-1,!>=2}
  "this_subtraction" always "this_subtraction"
  false always 0
  false always 0
Line 120
  ( always {!<=-1,!>=2}
  "const1" always "const1"
  false always 0
  false always 0
Line 121
  ( always {!<=-1,!>=2}
  "const2" always "const2"
  false always 0
  false always 0
Line 122
  ( always {!<=-1,!>=2}
  "const3" always "const3"
  false always 0
  false always 0
Line 123
  ( always {!<=-1,!>=2}
  "const4" always "const4"
  false always 0
  false always 0
Line 124
  ( always {!<=-1,!>=2}
  "const5" always "const5"
  false always 0
  false always 0
Line 125
  ( always {!<=-1,!>=2}
  "const6" always "const6"
  false always 0
  false always 0
Line 126
  ( always {!<=-1,!>=2}
  "const7" always "const7"
  false always 0
  false always 0
Line 127
  ( always {!<=-1,!>=2}
  "const8" always "const8"
  false always 0
  false always 0
Line 128
  ( always {!<=-1,!>=2}
  "const9" always "const9"
  false always 0
  false always 0
Line 129
  ( always {!<=-1,!>=2}
  "const10" always "const10"
  false always 0
  false always 0
Line 130
  ( always {!<=-1,!>=2}
  "const11" always "const11"
  false always 0
  false always 0
Line 131
  ( always {!<=-1,!>=2}
  "const12" always "const12"
  false always 0
  false always 0
Line 132
  ( always {!<=-1,!>=2}
  "const13" always "const13"
  false always 0
  false always 0
Line 133
  ( always {!<=-1,!>=2}
  "const14" always "const14"
  false always 0
  false always 0
Line 134
  ( always {!<=-1,!>=2}
  "const15" always "const15"
  false always 0
  false always 0
Line 135
  ( always {!<=-1,!>=2}
  "const16" always "const16"
  false always 0
  false always 0
Line 136
  ( always {!<=-1,!>=2}
  "const17" always "const17"
  false always 0
  false always 0
Line 137
  ( always {!<=-1,!>=2}
  "const18" always "const18"
  false always 0
  false always 0
Line 138
  ( always {!<=-1,!>=2}
  "const19" always "const19"
  false always 0
  false always 0
Line 139
  ( always {!<=-1,!>=2}
  "const20" always "const20"
  false always 0
  false always 0
Line 140
  ( always {!<=-1,!>=2}
  "const21" always "const21"
  false always 0
  false always 0
Line 141
  ( always {!<=-1,!>=2}
  "const22" always "const22"
  false always 0
  false always 0
Line 142
  ( always {!<=-1,!>=2}
  "const23" always "const23"
  false always 0
  false always 0
Line 143
  ( always {!<=-1,!>=2}
  "const24" always "const24"
  false always 0
  false always 0
Line 144
  ( always {!<=-1,!>=2}
  "const25" always "const25"
  false always 0
  false always 0
Line 145
  ( always {!<=-1,!>=2}
  "const26" always "const26"
  false always 0
  false always 0
Line 146
  ( always {!<=-1,!>=2}
  "const27" always "const27"
  false always 0
  false always 0
Line 147
  ( always {!<=-1,!>=2}
  "const28" always "const28"
  false always 0
  false always 0
Line 148
  ( always {!<=-1,!>=2}
  "const29" always "const29"
  false always 0
  false always 0
Line 149
  ( always {!<=-1,!>=2}
  "const30" always "const30"
  false always 0
  false always 0
Line 150
  ( always {!<=-1,!>=2}
  "const31" always "const31"
  false always 0
  false always 0
Line 151
  ( always {!<=-1,!>=2}
  "const32" always "const32"
  false always 0
  false always 0
Line 152
  ( always {!<=-1,!>=2}
  "const33" always "const33"
  false always 0
  false always 0
Line 153
  ( always {!<=-1,!>=2}
  "const34" always "const34"
  false always 0
  false always 0
Line 154
  ( always {!<=-1,!>=2}
  "const35" always "const35"
  false always 0
  false always 0
Line 155
  ( always {!<=-1,!>=2}
  "const36" always "const36"
  false always 0
  false always 0
Line 156
  ( always {!<=-1,!>=2}
  "const37" always "const37"
  false always 0
  false always 0
Line 157
  ( always {!<=-1,!>=2}
  "const38" always "const38"
  false always 0
  false always 0
Line 158
  ( always {!<=-1,!>=2}
  "const39" always "const39"
  false always 0
  false always 0
Line 159
  ( always {!<=-1,!>=2}
  "const40" always "const40"
  false always 0
  false always 0
Line 160
  ( always {!<=-1,!>=2}
  "const41" always "const41"
  false always 0
  false always 0
Line 161
  ( always {!<=-1,!>=2}
  "const42" always "const42"
  false always 0
  false always 0
Line 162
  ( always {!<=-1,!>=2}
  "const43" always "const43"
  false always 0
  false always 0
Line 163
  ( always {!<=-1,!>=2}
  "const44" always "const44"
  false always 0
  false always 0
Line 164
  ( always {!<=-1,!>=2}
  "const45" always "const45"
  false always 0
  false always 0
Line 165
  ( always {!<=-1,!>=2}
  "const46" always "const46"
  false always 0
  false always 0
Line 166
  ( always {!<=-1,!>=2}
  "const47" always "const47"
  false always 0
  false always 0
Line 167
  ( always {!<=-1,!>=2}
  "const48" always "const48"
  false always 0
  false always 0
Line 168
  ( always {!<=-1,!>=2}
  "const49" always "const49"
  false always 0
  false always 0
Line 169
  ( always {!<=-1,!>=2}
  "const50" always "const50"
  false always 0
  false always 0
Line 170
  ( always {!<=-1,!>=2}
  "const51" always "const51"
  false always 0
  false always 0
Line 171
  ( always {!<=-1,!>=2}
  "const52" always "const52"
  false always 0
  false always 0
Line 172
  ( always {!<=-1,!>=2}
  "const53" always "const53"
  false always 0
  false always 0
Line 173
  ( always {!<=-1,!>=2}
  "const54" always "const54"
  false always 0
  false always 0
Line 174
  ( always {!<=-1,!>=2}
  "const55" always "const55"
  false always 0
  false always 0
Line 175
  ( always {!<=-1,!>=2}
  "const56" always "const56"
  false always 0
  false always 0
Line 176
  ( always {!<=-1,!>=2}
  "const57" always "const57"
  false always 0
  false always 0
Line 177
  ( always {!<=-1,!>=2}
  "const58" always "const58"
  false always 0
  false always 0
Line 178
  ( always {!<=-1,!>=2}
  "const59" always "const59"
  false always 0
  false always 0
Line 179
  ( always {!<=-1,!>=2}
  "const60" always "const60"
  false always 0
  false always 0
Line 180
  ( always {!<=-1,!>=2}
  "const61" always "const61"
  false always 0
  false always 0
Line 181
  ( always {!<=-1,!>=2}
  "const62" always "const62"
  false always 0
  false always 0
Line 182
  ( always {!<=-1,!>=2}
  "const63" always "const63"
  false always 0
  false always 0
Line 183
  ( always {!<=-1,!>=2}
  "const64" always "const64"
  false always 0
  false always 0
Line 184
  ( always {!<=-1,!>=2}
  "const65" always "const65"
  false always 0
  false always 0
Line 185
  ( always {!<=-1,!>=2}
  "const66" always "const66"
  false always 0
  false always 0
Line 186
  ( always {!<=-1,!>=2}
  "const67" always "const67"
  false always 0
  false always 0
Line 187
  ( always {!<=-1,!>=2}
  "const68" always "const68"
  false always 0
  false always 0
Line 188
  ( always {!<=-1,!>=2}
  "const69" always "const69"
  false always 0
  false always 0
Line 189
  ( always {!<=-1,!>=2}
  "const70" always "const70"
  false always 0
  false always 0
Line 190
  ( always {!<=-1,!>=2}
  "const71" always "const71"
  false always 0
  false always 0
Line 191
  ( always {!<=-1,!>=2}
  "const72" always "const72"
  false always 0
  false always 0
Line 192
  ( always {!<=-1,!>=2}
  "const73" always "const73"
  false always 0
  false always 0
Line 193
  ( always {!<=-1,!>=2}
  "const74" always "const74"
  false always 0
  false always 0
Line 194
  ( always {!<=-1,!>=2}
  "const75" always "const75"
  false always 0
  false always 0
Line 195
  ( always {!<=-1,!>=2}
  "const76" always "const76"
  false always 0
  false always 0
Line 196
  ( always {!<=-1,!>=2}
  "const77" always "const77"
  false always 0
  false always 0
Line 197
  ( always {!<=-1,!>=2}
  "const78" always "const78"
  false always 0
  false always 0
Line 198
  ( always {!<=-1,!>=2}
  "const79" always "const79"
  false always 0
  false always 0
Line 199
  ( always {!<=-1,!>=2}
  "const_handleDefaultParameters" always "const_handleDefaultParameters"
  false always 0
  false always 0
Line 200
  ( always {!<=-1,!>=2}
  "const_passThisToMemberOfOtherClass" always "const_passThisToMemberOfOtherClass"
  false always 0
  false always 0
Line 201
  ( always {!<=-1,!>=2}
  "assigningPointerToPointerIsNotAConstOperation" always "assigningPointerToPointerIsNotAConstOperation"
  false always 0
  false always 0
Line 202
  ( always {!<=-1,!>=2}
  "assigningArrayElementIsNotAConstOperation" always "assigningArrayElementIsNotAConstOperation"
  false always 0
  false always 0
Line 203
  ( always {!<=-1,!>=2}
  "constoperator1" always "constoperator1"
  false always 0
  false always 0
Line 204
  ( always {!<=-1,!>=2}
  "constoperator2" always "constoperator2"
  false always 0
  false always 0
Line 205
  ( always {!<=-1,!>=2}
  "constoperator3" always "constoperator3"
  false always 0
  false always 0
Line 206
  ( always {!<=-1,!>=2}
  "constoperator4" always "constoperator4"
  false always 0
  false always 0
Line 207
  ( always {!<=-1,!>=2}
  "constoperator5" always "constoperator5"
  false always 0
  false always 0
Line 208
  ( always {!<=-1,!>=2}
  "constoperator6" always "constoperator6"
  false always 0
  false always 0
Line 209
  ( always {!<=-1,!>=2}
  "constincdec" always "constincdec"
  false always 0
  false always 0
Line 210
  ( always {!<=-1,!>=2}
  "constassign1" always "constassign1"
  false always 0
  false always 0
Line 211
  ( always {!<=-1,!>=2}
  "constassign2" always "constassign2"
  false always 0
  false always 0
Line 212
  ( always {!<=-1,!>=2}
  "constincdecarray" always "constincdecarray"
  false always 0
  false always 0
Line 213
  ( always {!<=-1,!>=2}
  "constassignarray" always "constassignarray"
  false always 0
  false always 0
Line 214
  ( always {!<=-1,!>=2}
  "constReturnReference" always "constReturnReference"
  false always 0
  false always 0
Line 215
  ( always {!<=-1,!>=2}
  "constDelete" always "constDelete"
  false always 0
  false always 0
Line 216
  ( always {!<=-1,!>=2}
  "constLPVOID" always "constLPVOID"
  false always 0
  false always 0
Line 217
  ( always {!<=-1,!>=2}
  "constFunc" always "constFunc"
  false always 0
  false always 0
Line 218
  ( always {!<=-1,!>=2}
  "constVirtualFunc" always "constVirtualFunc"
  false always 0
  false always 0
Line 219
  ( always {!<=-1,!>=2}
  "constIfCfg" always "constIfCfg"
  false always 0
  false always 0
Line 220
  ( always {!<=-1,!>=2}
  "constFriend" always "constFriend"
  false always 0
  false always 0
Line 221
  ( always {!<=-1,!>=2}
  "constUnion" always "constUnion"
  false always 0
  false always 0
Line 222
  ( always {!<=-1,!>=2}
  "constArrayOperator" always "constArrayOperator"
  false always 0
  false always 0
Line 223
  ( always {!<=-1,!>=2}
  "constRangeBasedFor" always "constRangeBasedFor"
  false always 0
  false always 0
Line 224
  ( always {!<=-1,!>=2}
  "const_shared_ptr" always "const_shared_ptr"
  false always 0
  false always 0
Line 225
  ( always {!<=-1,!>=2}
  "constPtrToConstPtr" always "constPtrToConstPtr"
  false always 0
  false always 0
Line 226
  ( always {!<=-1,!>=2}
  "constTrailingReturnType" always "constTrailingReturnType"
  false always 0
  false always 0
Line 227
  ( always {!<=-1,!>=2}
  "staticArrayPtrOverload" always "staticArrayPtrOverload"
  false always 0
  false always 0
Line 228
  ( always {!<=-1,!>=2}
  "qualifiedNameMember" always "qualifiedNameMember"
  false always 0
  false always 0
Line 230
  ( always {!<=-1,!>=2}
  "initializerListOrder" always "initializerListOrder"
  false always 0
  false always 0
Line 231
  ( always {!<=-1,!>=2}
  "initializerListUsage" always "initializerListUsage"
  false always 0
  false always 0
Line 232
  ( always {!<=-1,!>=2}
  "selfInitialization" always "selfInitialization"
  false always 0
  false always 0
Line 234
  ( always {!<=-1,!>=2}
  "virtualFunctionCallInConstructor" always "virtualFunctionCallInConstructor"
  false always 0
  false always 0
Line 235
  ( always {!<=-1,!>=2}
  "pureVirtualFunctionCall" always "pureVirtualFunctionCall"
  false always 0
  false always 0
Line 236
  ( always {!<=-1,!>=2}
  "pureVirtualFunctionCallOtherClass" always "pureVirtualFunctionCallOtherClass"
  false always 0
  false always 0
Line 237
  ( always {!<=-1,!>=2}
  "pureVirtualFunctionCallWithBody" always "pureVirtualFunctionCallWithBody"
  false always 0
  false always 0
Line 238
  ( always {!<=-1,!>=2}
  "pureVirtualFunctionCallPrevented" always "pureVirtualFunctionCallPrevented"
  false always 0
  false always 0
Line 240
  ( always {!<=-1,!>=2}
  "duplInheritedMembers" always "duplInheritedMembers"
  false always 0
  false always 0
Line 241
  ( always {!<=-1,!>=2}
  "explicitConstructors" always "explicitConstructors"
  false always 0
  false always 0
Line 242
  ( always {!<=-1,!>=2}
  "copyCtorAndEqOperator" always "copyCtorAndEqOperator"
  false always 0
  false always 0
Line 244
  ( always {!<=-1,!>=2}
  "override1" always "override1"
  false always 0
  false always 0
Line 245
  ( always {!<=-1,!>=2}
  "overrideCVRefQualifiers" always "overrideCVRefQualifiers"
  false always 0
  false always 0
Line 247
  ( always {!<=-1,!>=2}
  "thisUseAfterFree" always "thisUseAfterFree"
  false always 0
  false always 0
Line 249
  ( always {!<=-1,!>=2}
  "unsafeClassRefMember" always "unsafeClassRefMember"
  false always 0
  false always 0
Line 251
  ( always {!<=-1,!>=2}
  "ctuOneDefinitionRule" always "ctuOneDefinitionRule"
  false always 0
  false always 0
Line 253
  ( always {!<=-1,!>=2}
  "testGetFileInfo" always "testGetFileInfo"
  false always 0
  false always 0
Line 259
  "" always ""
Line 264
  & {lifetime[Address]=(settings),!0}
  this always !0
Line 265
  code possible {"class A\n{\n    A(const A& other) { }\n    A& operator=(const A& other) { return *this; }\n};"@163,"class A\n{\n};"@164,"class A\n{\n    A(const A& other) { }\n};"@165,"class A\n{\n    A& operator=(const A& other) { return *this; }\n};"@166,"class A\n{\n    A(const A& other) { }\n    int x;\n};"@167,"class A\n{\n    A& operator=(const A& other) { return *this; }\n    int x;\n};"@168,"class A\n{\n    A& operator=(const int &x) { this->x = x; return *this; }\n    int x;\n};"@169,"class A {\npublic:\n    A() : x(0) { }\n    A(const A & a) { x = a.x; }\n    A & operator = (const A & a) {\n        x = a.x;\n        return *this;\n    }\nprivate:\n    int x;\n};\nclass B : public A {\npublic:\n    B() { }\n    B(const B & b) :A(b) { }\nprivate:\n    static int i;\n};"@170,"struct S {\n  std::string test;\n  S(S&& s) : test(std::move(s.test)) { }\n  S& operator = (S &&s) {\n    test = std::move(s.test);\n    return *this;\n  }\n};"@171,"struct StaticListNode {\n  StaticListNode(StaticListNode*& prev) : m_next(0) {}\n  StaticListNode* m_next;\n};"@172}
Line 266
  ( always {!<=-1,!>=2}
  file inconclusive {"cppcheck-2.8/test/testclass.cpp"@163,"cppcheck-2.8/test/testclass.cpp"@164,"cppcheck-2.8/test/testclass.cpp"@165,"cppcheck-2.8/test/testclass.cpp"@166,"cppcheck-2.8/test/testclass.cpp"@167,"cppcheck-2.8/test/testclass.cpp"@168,"cppcheck-2.8/test/testclass.cpp"@169,"cppcheck-2.8/test/testclass.cpp"@170,"cppcheck-2.8/test/testclass.cpp"@171,"cppcheck-2.8/test/testclass.cpp"@172}
  line inconclusive {274@163,282@164,287@165,293@166,300@167,308@168,316@169,323@170,344@171,355@172}
  "test.cpp" always "test.cpp"
Line 269
  & {lifetime[Address]=(tokenizer),!0}
  & {lifetime[Address]=(settings),!0}
  this always !0
Line 274
  "class A\n{\n    A(const A& other) { }\n    A& operator=(const A& other) { return *this; }\n};" always "class A\n{\n    A(const A& other) { }\n    A& operator=(const A& other) { return *this; }\n};"
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  274 always 274
Line 279
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  279 always 279
  "" always ""
Line 282
  "class A\n{\n};" always "class A\n{\n};"
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  282 always 282
Line 285
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  285 always 285
  "" always ""
Line 287
  "class A\n{\n    A(const A& other) { }\n};" always "class A\n{\n    A(const A& other) { }\n};"
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  287 always 287
Line 291
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  291 always 291
  "" always ""
Line 293
  "class A\n{\n    A& operator=(const A& other) { return *this; }\n};" always "class A\n{\n    A& operator=(const A& other) { return *this; }\n};"
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  293 always 293
Line 297
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  297 always 297
  "" always ""
Line 300
  "class A\n{\n    A(const A& other) { }\n    int x;\n};" always "class A\n{\n    A(const A& other) { }\n    int x;\n};"
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  300 always 300
Line 305
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  305 always 305
  "[test.cpp:1]: (warning) The class 'A' has 'copy constructor' but lack of 'operator='.\n" always "[test.cpp:1]: (warning) The class 'A' has 'copy constructor' but lack of 'operator='.\n"
  "" always ""
Line 308
  "class A\n{\n    A& operator=(const A& other) { return *this; }\n    int x;\n};" always "class A\n{\n    A& operator=(const A& other) { return *this; }\n    int x;\n};"
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  308 always 308
Line 313
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  313 always 313
  "[test.cpp:1]: (warning) The class 'A' has 'operator=' but lack of 'copy constructor'.\n" always "[test.cpp:1]: (warning) The class 'A' has 'operator=' but lack of 'copy constructor'.\n"
  "" always ""
Line 316
  "class A\n{\n    A& operator=(const int &x) { this->x = x; return *this; }\n    int x;\n};" always "class A\n{\n    A& operator=(const int &x) { this->x = x; return *this; }\n    int x;\n};"
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  316 always 316
Line 321
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  321 always 321
  "" always ""
Line 323
  "class A {\npublic:\n    A() : x(0) { }\n    A(const A & a) { x = a.x; }\n    A & operator = (const A & a) {\n        x = a.x;\n        return *this;\n    }\nprivate:\n    int x;\n};\nclass B : public A {\npublic:\n    B() { }\n    B(const B & b) :A(b) { }\nprivate:\n    static int i;\n};" always "class A {\npublic:\n    A() : x(0) { }\n    A(const A & a) { x = a.x; }\n    A & operator = (const A & a) {\n        x = a.x;\n        return *this;\n    }\nprivate:\n    int x;\n};\nclass B : public A {\npublic:\n    B() { }\n    B(const B & b) :A(b) { }\nprivate:\n    static int i;\n};"
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  323 always 323
Line 341
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  341 always 341
  "" always ""
Line 344
  "struct S {\n  std::string test;\n  S(S&& s) : test(std::move(s.test)) { }\n  S& operator = (S &&s) {\n    test = std::move(s.test);\n    return *this;\n  }\n};" always "struct S {\n  std::string test;\n  S(S&& s) : test(std::move(s.test)) { }\n  S& operator = (S &&s) {\n    test = std::move(s.test);\n    return *this;\n  }\n};"
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  344 always 344
Line 352
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  352 always 352
  "" always ""
Line 355
  "struct StaticListNode {\n  StaticListNode(StaticListNode*& prev) : m_next(0) {}\n  StaticListNode* m_next;\n};" always "struct StaticListNode {\n  StaticListNode(StaticListNode*& prev) : m_next(0) {}\n  StaticListNode* m_next;\n};"
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  355 always 355
Line 359
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  359 always 359
  "" always ""
Line 365
  "" always ""
Line 368
  & {lifetime[Address]=(settings0),!0}
  this always !0
Line 369
  code possible {"class Class {\n    Class() = delete;\n    Class(const Class& other) { }\n    Class(Class&& other) { }\n    explicit Class(int i) { }\n    explicit Class(const std::string&) { }\n    Class(int a, int b) { }\n};"@150,"class Class {\n    Class() = delete;\n    explicit Class(const Class& other) { }\n    explicit Class(Class&& other) { }\n    virtual int i() = 0;\n};"@151,"class Class {\n    Class() = delete;\n    Class(const Class& other) = delete;\n    Class(Class&& other) = delete;\n    virtual int i() = 0;\n};"@152,"class Class {\n    Class(int i) { }\n};"@153,"class Class {\n    Class(const Class& other) { }\n    virtual int i() = 0;\n};"@154,"class Class {\n    Class(Class&& other) { }\n    virtual int i() = 0;\n};"@155,"class Class {\n    private: Class(const Class&);\n    virtual int i() = 0;\n};"@156,"class Class {\n    public: Class(const Class&);\n    virtual int i() = 0;\n};"@157,"template <class T> struct Test {\n  Test(int) : fData(0) {}\n  T fData;\n};\nint main() {\n  Test <int> test;\n  return 0;\n}"@158,"template <class T> struct Test {\n  Test() : fData(0) {}\n  Test (const Test<T>& aOther) : fData(aOther.fData) {}\n  Test (Test<T>&& aOther) : fData(std::move(aOther.fData)) {}\n  T fData;\n};\nint main() {\n  Test <int> test;\n  return 0;\n}"@159}
Line 370
  ( always {!<=-1,!>=2}
  file inconclusive {"cppcheck-2.8/test/testclass.cpp"@150,"cppcheck-2.8/test/testclass.cpp"@151,"cppcheck-2.8/test/testclass.cpp"@152,"cppcheck-2.8/test/testclass.cpp"@153,"cppcheck-2.8/test/testclass.cpp"@154,"cppcheck-2.8/test/testclass.cpp"@155,"cppcheck-2.8/test/testclass.cpp"@156,"cppcheck-2.8/test/testclass.cpp"@157,"cppcheck-2.8/test/testclass.cpp"@158,"cppcheck-2.8/test/testclass.cpp"@159}
  line inconclusive {378@150,388@151,396@152,404@153,409@154,415@155,422@156,428@157,435@158,446@159}
  "test.cpp" always "test.cpp"
Line 373
  & {lifetime[Address]=(tokenizer),!0}
  & {lifetime[Address]=(settings0),!0}
  this always !0
Line 378
  "class Class {\n    Class() = delete;\n    Class(const Class& other) { }\n    Class(Class&& other) { }\n    explicit Class(int i) { }\n    explicit Class(const std::string&) { }\n    Class(int a, int b) { }\n};" always "class Class {\n    Class() = delete;\n    Class(const Class& other) { }\n    Class(Class&& other) { }\n    explicit Class(int i) { }\n    explicit Class(const std::string&) { }\n    Class(int a, int b) { }\n};"
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  378 always 378
Line 386
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  386 always 386
  "" always ""
Line 388
  "class Class {\n    Class() = delete;\n    explicit Class(const Class& other) { }\n    explicit Class(Class&& other) { }\n    virtual int i() = 0;\n};" always "class Class {\n    Class() = delete;\n    explicit Class(const Class& other) { }\n    explicit Class(Class&& other) { }\n    virtual int i() = 0;\n};"
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  388 always 388
Line 394
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  394 always 394
  "" always ""
Line 396
  "class Class {\n    Class() = delete;\n    Class(const Class& other) = delete;\n    Class(Class&& other) = delete;\n    virtual int i() = 0;\n};" always "class Class {\n    Class() = delete;\n    Class(const Class& other) = delete;\n    Class(Class&& other) = delete;\n    virtual int i() = 0;\n};"
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  396 always 396
Line 402
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  402 always 402
  "" always ""
Line 404
  "class Class {\n    Class(int i) { }\n};" always "class Class {\n    Class(int i) { }\n};"
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  404 always 404
Line 407
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  407 always 407
  "[test.cpp:2]: (style) Class 'Class' has a constructor with 1 argument that is not explicit.\n" always "[test.cpp:2]: (style) Class 'Class' has a constructor with 1 argument that is not explicit.\n"
Line 409
  "class Class {\n    Class(const Class& other) { }\n    virtual int i() = 0;\n};" always "class Class {\n    Class(const Class& other) { }\n    virtual int i() = 0;\n};"
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  409 always 409
Line 413
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  413 always 413
  "" always ""
Line 415
  "class Class {\n    Class(Class&& other) { }\n    virtual int i() = 0;\n};" always "class Class {\n    Class(Class&& other) { }\n    virtual int i() = 0;\n};"
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  415 always 415
Line 419
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  419 always 419
  "" always ""
Line 422
  "class Class {\n    private: Class(const Class&);\n    virtual int i() = 0;\n};" always "class Class {\n    private: Class(const Class&);\n    virtual int i() = 0;\n};"
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  422 always 422
Line 426
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  426 always 426
  "" always ""
Line 428
  "class Class {\n    public: Class(const Class&);\n    virtual int i() = 0;\n};" always "class Class {\n    public: Class(const Class&);\n    virtual int i() = 0;\n};"
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  428 always 428
Line 432
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  432 always 432
  "" always ""
Line 435
  "template <class T> struct Test {\n  Test(int) : fData(0) {}\n  T fData;\n};\nint main() {\n  Test <int> test;\n  return 0;\n}" always "template <class T> struct Test {\n  Test(int) : fData(0) {}\n  T fData;\n};\nint main() {\n  Test <int> test;\n  return 0;\n}"
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  435 always 435
Line 443
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  443 always 443
  "[test.cpp:2]: (style) Struct 'Test < int >' has a constructor with 1 argument that is not explicit.\n" always "[test.cpp:2]: (style) Struct 'Test < int >' has a constructor with 1 argument that is not explicit.\n"
Line 446
  "template <class T> struct Test {\n  Test() : fData(0) {}\n  Test (const Test<T>& aOther) : fData(aOther.fData) {}\n  Test (Test<T>&& aOther) : fData(std::move(aOther.fData)) {}\n  T fData;\n};\nint main() {\n  Test <int> test;\n  return 0;\n}" always "template <class T> struct Test {\n  Test() : fData(0) {}\n  Test (const Test<T>& aOther) : fData(aOther.fData) {}\n  Test (Test<T>&& aOther) : fData(std::move(aOther.fData)) {}\n  T fData;\n};\nint main() {\n  Test <int> test;\n  return 0;\n}"
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  446 always 446
Line 456
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  456 always 456
  "" always ""
Line 459
  "struct A { struct B; };\nstruct A::B {\n    B() = default;\n    B(const B&) {}\n};" always "struct A { struct B; };\nstruct A::B {\n    B() = default;\n    B(const B&) {}\n};"
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  459 always 459
Line 464
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  464 always 464
  "" always ""
Line 466
  "struct A{    A(int, int y=2) {}};" always "struct A{    A(int, int y=2) {}};"
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  466 always 466
Line 469
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  469 always 469
  "[test.cpp:1]: (style) Struct 'A' has a constructor with 1 argument that is not explicit.\n" always "[test.cpp:1]: (style) Struct 'A' has a constructor with 1 argument that is not explicit.\n"
Line 471
  "struct Foo {\n    template <typename T>\n    explicit constexpr Foo(T) {}\n};\nstruct Bar {\n    template <typename T>\n    constexpr explicit Bar(T) {}\n};\nstruct Baz {\n    explicit constexpr Baz(int) {}\n};\n" always "struct Foo {\n    template <typename T>\n    explicit constexpr Foo(T) {}\n};\nstruct Bar {\n    template <typename T>\n    constexpr explicit Bar(T) {}\n};\nstruct Baz {\n    explicit constexpr Baz(int) {}\n};\n"
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  471 always 471
Line 482
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  482 always 482
  "" always ""
Line 488
  "" always ""
Line 491
  & {lifetime[Address]=(settings1),!0}
  this always !0
Line 492
  code possible {"class Base {\n   int x;\n};\nstruct Derived : Base {\n   int x;\n};"@136,"class Base {\n   protected:\n   int x;\n};\nstruct Derived : Base {\n   int x;\n};"@137,"class Base {\n   protected:\n   int x;\n};\nstruct Derived : public Base {\n   int x;\n};"@138,"class Base0 {\n   int x;\n};\nclass Base1 {\n   int x;\n};\nstruct Derived : Base0, Base1 {\n   int x;\n};"@139,"class Base0 {\n   protected:\n   int x;\n};\nclass Base1 {\n   int x;\n};\nstruct Derived : Base0, Base1 {\n   int x;\n};"@140,"class Base0 {\n   protected:\n   int x;\n};\nclass Base1 {\n   public:\n   int x;\n};\nstruct Derived : Base0, Base1 {\n   int x;\n};"@141,"class Base {\n   int x;\n};\nstruct Derived : Base {\n   int y;\n};"@142,"class A {\n   int x;\n};\nstruct B {\n   int x;\n};"@143,"class Derived : public UnknownBase {\n  int x;\n};"@144,"class Base {\n   int x;\n};\nclass Derived : public Base {\n};"@145}
Line 493
  ( always {!<=-1,!>=2}
  file inconclusive {"cppcheck-2.8/test/testclass.cpp"@136,"cppcheck-2.8/test/testclass.cpp"@137,"cppcheck-2.8/test/testclass.cpp"@138,"cppcheck-2.8/test/testclass.cpp"@139,"cppcheck-2.8/test/testclass.cpp"@140,"cppcheck-2.8/test/testclass.cpp"@141,"cppcheck-2.8/test/testclass.cpp"@142,"cppcheck-2.8/test/testclass.cpp"@143,"cppcheck-2.8/test/testclass.cpp"@144,"cppcheck-2.8/test/testclass.cpp"@145}
  line inconclusive {501@136,509@137,518@138,527@139,538@140,550@141,564@142,572@143,581@144,586@145}
  "test.cpp" always "test.cpp"
Line 496
  & {lifetime[Address]=(tokenizer),!0}
  & {lifetime[Address]=(settings1),!0}
  this always !0
Line 501
  "class Base {\n   int x;\n};\nstruct Derived : Base {\n   int x;\n};" always "class Base {\n   int x;\n};\nstruct Derived : Base {\n   int x;\n};"
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  501 always 501
Line 507
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  507 always 507
  "" always ""
Line 509
  "class Base {\n   protected:\n   int x;\n};\nstruct Derived : Base {\n   int x;\n};" always "class Base {\n   protected:\n   int x;\n};\nstruct Derived : Base {\n   int x;\n};"
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  509 always 509
Line 516
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  516 always 516
  "[test.cpp:3] -> [test.cpp:6]: (warning) The struct 'Derived' defines member variable with name 'x' also defined in its parent class 'Base'.\n" always "[test.cpp:3] -> [test.cpp:6]: (warning) The struct 'Derived' defines member variable with name 'x' also defined in its parent class 'Base'.\n"
Line 518
  "class Base {\n   protected:\n   int x;\n};\nstruct Derived : public Base {\n   int x;\n};" always "class Base {\n   protected:\n   int x;\n};\nstruct Derived : public Base {\n   int x;\n};"
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  518 always 518
Line 525
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  525 always 525
  "[test.cpp:3] -> [test.cpp:6]: (warning) The struct 'Derived' defines member variable with name 'x' also defined in its parent class 'Base'.\n" always "[test.cpp:3] -> [test.cpp:6]: (warning) The struct 'Derived' defines member variable with name 'x' also defined in its parent class 'Base'.\n"
Line 527
  "class Base0 {\n   int x;\n};\nclass Base1 {\n   int x;\n};\nstruct Derived : Base0, Base1 {\n   int x;\n};" always "class Base0 {\n   int x;\n};\nclass Base1 {\n   int x;\n};\nstruct Derived : Base0, Base1 {\n   int x;\n};"
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  527 always 527
Line 536
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  536 always 536
  "" always ""
Line 538
  "class Base0 {\n   protected:\n   int x;\n};\nclass Base1 {\n   int x;\n};\nstruct Derived : Base0, Base1 {\n   int x;\n};" always "class Base0 {\n   protected:\n   int x;\n};\nclass Base1 {\n   int x;\n};\nstruct Derived : Base0, Base1 {\n   int x;\n};"
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  538 always 538
Line 548
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  548 always 548
  "[test.cpp:3] -> [test.cpp:9]: (warning) The struct 'Derived' defines member variable with name 'x' also defined in its parent class 'Base0'.\n" always "[test.cpp:3] -> [test.cpp:9]: (warning) The struct 'Derived' defines member variable with name 'x' also defined in its parent class 'Base0'.\n"
Line 550
  "class Base0 {\n   protected:\n   int x;\n};\nclass Base1 {\n   public:\n   int x;\n};\nstruct Derived : Base0, Base1 {\n   int x;\n};" always "class Base0 {\n   protected:\n   int x;\n};\nclass Base1 {\n   public:\n   int x;\n};\nstruct Derived : Base0, Base1 {\n   int x;\n};"
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  550 always 550
Line 561
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  561 always 561
  "[test.cpp:3] -> [test.cpp:10]: (warning) The struct 'Derived' defines member variable with name 'x' also defined in its parent class 'Base0'.\n[test.cpp:7] -> [test.cpp:10]: (warning) The struct 'Derived' defines member variable with name 'x' also defined in its parent class 'Base1'.\n" always "[test.cpp:3] -> [test.cpp:10]: (warning) The struct 'Derived' defines member variable with name 'x' also defined in its parent class 'Base0'.\n[test.cpp:7] -> [test.cpp:10]: (warning) The struct 'Derived' defines member variable with name 'x' also defined in its parent class 'Base1'.\n"
Line 564
  "class Base {\n   int x;\n};\nstruct Derived : Base {\n   int y;\n};" always "class Base {\n   int x;\n};\nstruct Derived : Base {\n   int y;\n};"
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  564 always 564
Line 570
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  570 always 570
  "" always ""
Line 572
  "class A {\n   int x;\n};\nstruct B {\n   int x;\n};" always "class A {\n   int x;\n};\nstruct B {\n   int x;\n};"
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  572 always 572
Line 578
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  578 always 578
  "" always ""
Line 581
  "class Derived : public UnknownBase {\n  int x;\n};" always "class Derived : public UnknownBase {\n  int x;\n};"
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  581 always 581
Line 584
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  584 always 584
  "" always ""
Line 586
  "class Base {\n   int x;\n};\nclass Derived : public Base {\n};" always "class Base {\n   int x;\n};\nclass Derived : public Base {\n};"
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  586 always 586
Line 591
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  591 always 591
  "" always ""
Line 594
  "namespace test1 {\n   struct SWibble{};\n   typedef SWibble wibble;\n}\nnamespace test2 {\n   struct SWibble : public test1::wibble {\n   int Value;\n   };\n}" always "namespace test1 {\n   struct SWibble{};\n   typedef SWibble wibble;\n}\nnamespace test2 {\n   struct SWibble : public test1::wibble {\n   int Value;\n   };\n}"
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  594 always 594
Line 603
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  603 always 603
  "" always ""
Line 606
  "class Base {\n    public:\n        int i;\n};\nclass Derived1: public Base {\n    public:\n        int j;\n};\nclass Derived2 : public Derived1 {\n    int i;\n};" always "class Base {\n    public:\n        int i;\n};\nclass Derived1: public Base {\n    public:\n        int j;\n};\nclass Derived2 : public Derived1 {\n    int i;\n};"
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  606 always 606
Line 617
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  617 always 617
  "[test.cpp:3] -> [test.cpp:10]: (warning) The class 'Derived2' defines member variable with name 'i' also defined in its parent class 'Base'.\n" always "[test.cpp:3] -> [test.cpp:10]: (warning) The class 'Derived2' defines member variable with name 'i' also defined in its parent class 'Base'.\n"
Line 620
  "template<size_t N>\nstruct BitInt : public BitInt<N+1> { };" always "template<size_t N>\nstruct BitInt : public BitInt<N+1> { };"
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  620 always 620
Line 622
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  622 always 622
  "" always ""
Line 625
  "namespace _impl {\n    template <typename AlwaysVoid, typename>\n    struct fn_traits;\n}\ntemplate <typename T>\nstruct function_traits\n    : public _impl::fn_traits<void, std::remove_reference_t<T>> {};\nnamespace _impl {\n    template <typename T>\n    struct fn_traits<decltype(void(&T::operator())), T>\n        : public fn_traits<void, decltype(&T::operator())> {};\n}" always "namespace _impl {\n    template <typename AlwaysVoid, typename>\n    struct fn_traits;\n}\ntemplate <typename T>\nstruct function_traits\n    : public _impl::fn_traits<void, std::remove_reference_t<T>> {};\nnamespace _impl {\n    template <typename T>\n    struct fn_traits<decltype(void(&T::operator())), T>\n        : public fn_traits<void, decltype(&T::operator())> {};\n}"
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  625 always 625
Line 637
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  637 always 637
  "" always ""
Line 643
  "" always ""
Line 646
  & {lifetime[Address]=(settings0),!0}
  this always !0
Line 647
  code possible {"struct F {\n   char* c;\n   F() { c = malloc(100); }\n   F(const F &f);\n   F&operator=(const F&);};"@104,"struct F {\n   C* c;\n   F() { c = new C; }\n   F(const F &f);\n   F&operator=(const F&);};"@105,"struct F {\n   int* i;\n   F() { i = new int(); }\n   F(const F &f);\n   F& operator=(const F&);};"@106,"struct Data { int x; int y; };\nstruct F {\n   Data* c;\n   F() { c = new Data; }\n   F(const F &f);\n   F&operator=(const F&);};"@107,"struct F {\n   char* c;\n   F() { c = malloc(100); }\n   F(const F &f);\n   F &operator=(const F &f);\n   ~F() = default;\n};"@108,"struct F {\n   char* c;\n   F() { c = malloc(100); }\n   F(const F &f);\n   F &operator=(const F &f);\n   ~F() = delete;\n};"@109,"struct F {\n   char* c;\n   F() { c = malloc(100); }\n   F(const F &f);\n   ~F();\n};"@110,"struct F {\n   char* c;\n   F() { c = malloc(100); }\n   F(const F &f);\n   F &operator=(const F &f) = default;\n   ~F();\n};"@111,"struct F {\n   char* c;\n   F() { c = malloc(100); }\n   F(const F &f);\n   F &operator=(const F &f) = delete;\n   ~F();\n};"@112,"struct F : NonCopyable {\n   char* c;\n   F() { c = malloc(100); }\n   F(const F &f);\n   ~F();\n};"@113}
Line 648
  ( always {!<=-1,!>=2}
  file inconclusive {"cppcheck-2.8/test/testclass.cpp"@104,"cppcheck-2.8/test/testclass.cpp"@105,"cppcheck-2.8/test/testclass.cpp"@106,"cppcheck-2.8/test/testclass.cpp"@107,"cppcheck-2.8/test/testclass.cpp"@108,"cppcheck-2.8/test/testclass.cpp"@109,"cppcheck-2.8/test/testclass.cpp"@110,"cppcheck-2.8/test/testclass.cpp"@111,"cppcheck-2.8/test/testclass.cpp"@112,"cppcheck-2.8/test/testclass.cpp"@113}
  line inconclusive {1032@104,1040@105,1048@106,1056@107,1066@108,1076@109,993@110,1002@111,1012@112,1022@113}
  "test.cpp" always "test.cpp"
Line 651
  & {lifetime[Address]=(tokenizer),!0}
  & {lifetime[Address]=(settings0),!0}
  this always !0
Line 656
  "class F\n{\n   public:\n   char *c,*p,*d;\n   F(const F &f) : p(f.p), c(f.c)\n   {\n      p=(char *)malloc(strlen(f.p)+1);\n      strcpy(p,f.p);\n   }\n   F(char *str)\n   {\n      p=(char *)malloc(strlen(str)+1);\n      strcpy(p,str);\n   }\n   F&operator=(const F&);\n   ~F();\n};" always "class F\n{\n   public:\n   char *c,*p,*d;\n   F(const F &f) : p(f.p), c(f.c)\n   {\n      p=(char *)malloc(strlen(f.p)+1);\n      strcpy(p,f.p);\n   }\n   F(char *str)\n   {\n      p=(char *)malloc(strlen(str)+1);\n      strcpy(p,str);\n   }\n   F&operator=(const F&);\n   ~F();\n};"
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  656 always 656
Line 673
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  673 always 673
  "[test.cpp:5]: (warning) Value of pointer 'p', which points to allocated memory, is copied in copy constructor instead of allocating new memory.\n" always "[test.cpp:5]: (warning) Value of pointer 'p', which points to allocated memory, is copied in copy constructor instead of allocating new memory.\n"
  "" always ""
Line 675
  "class F {\n   char *p;\n   F(const F &f) {\n      p = f.p;\n   }\n   F(char *str) {\n      p = malloc(strlen(str)+1);\n   }\n   ~F();\n   F& operator=(const F&f);\n};" always "class F {\n   char *p;\n   F(const F &f) {\n      p = f.p;\n   }\n   F(char *str) {\n      p = malloc(strlen(str)+1);\n   }\n   ~F();\n   F& operator=(const F&f);\n};"
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  675 always 675
Line 686
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  686 always 686
  "[test.cpp:4]: (warning) Value of pointer 'p', which points to allocated memory, is copied in copy constructor instead of allocating new memory.\n[test.cpp:3] -> [test.cpp:7]: (warning) Copy constructor does not allocate memory for member 'p' although memory has been allocated in other constructors.\n" always "[test.cpp:4]: (warning) Value of pointer 'p', which points to allocated memory, is copied in copy constructor instead of allocating new memory.\n[test.cpp:3] -> [test.cpp:7]: (warning) Copy constructor does not allocate memory for member 'p' although memory has been allocated in other constructors.\n"
  "[test.cpp:4]: (warning) Value of pointer 'p', which points to allocated memory, is copied in copy constructor instead of allocating new memory.\n" always "[test.cpp:4]: (warning) Value of pointer 'p', which points to allocated memory, is copied in copy constructor instead of allocating new memory.\n"
Line 691
  "class F\n{\n   public:\n   char *c,*p,*d;\n   F(const F &f) :p(f.p)\n   {\n   }\n   F(char *str)\n   {\n      p=(char *)malloc(strlen(str)+1);\n      strcpy(p,str);\n   }\n   ~F();\n   F& operator=(const F&f);\n};" always "class F\n{\n   public:\n   char *c,*p,*d;\n   F(const F &f) :p(f.p)\n   {\n   }\n   F(char *str)\n   {\n      p=(char *)malloc(strlen(str)+1);\n      strcpy(p,str);\n   }\n   ~F();\n   F& operator=(const F&f);\n};"
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  691 always 691
Line 706
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  706 always 706
  "[test.cpp:5]: (warning) Value of pointer 'p', which points to allocated memory, is copied in copy constructor instead of allocating new memory.\n[test.cpp:5] -> [test.cpp:10]: (warning) Copy constructor does not allocate memory for member 'p' although memory has been allocated in other constructors.\n" always "[test.cpp:5]: (warning) Value of pointer 'p', which points to allocated memory, is copied in copy constructor instead of allocating new memory.\n[test.cpp:5] -> [test.cpp:10]: (warning) Copy constructor does not allocate memory for member 'p' although memory has been allocated in other constructors.\n"
  "" always ""
Line 711
  "class kalci\n{\n   public:\n   char *c,*p,*d;\n   kalci()\n   {\n      p=(char *)malloc(100);\n      strcpy(p,\"hello\");\n      c=(char *)malloc(100);\n      strcpy(p,\"hello\");\n      d=(char *)malloc(100);\n      strcpy(p,\"hello\");\n   }\n   kalci(const kalci &f)\n   {\n      p=(char *)malloc(strlen(str)+1);\n      strcpy(p,f.p);\n      c=(char *)malloc(strlen(str)+1);\n      strcpy(p,f.p);\n      d=(char *)malloc(strlen(str)+1);\n      strcpy(p,f.p);\n   }\n   ~kalci();\n   kalci& operator=(const kalci&kalci);\n};" always "class kalci\n{\n   public:\n   char *c,*p,*d;\n   kalci()\n   {\n      p=(char *)malloc(100);\n      strcpy(p,\"hello\");\n      c=(char *)malloc(100);\n      strcpy(p,\"hello\");\n      d=(char *)malloc(100);\n      strcpy(p,\"hello\");\n   }\n   kalci(const kalci &f)\n   {\n      p=(char *)malloc(strlen(str)+1);\n      strcpy(p,f.p);\n      c=(char *)malloc(strlen(str)+1);\n      strcpy(p,f.p);\n      d=(char *)malloc(strlen(str)+1);\n      strcpy(p,f.p);\n   }\n   ~kalci();\n   kalci& operator=(const kalci&kalci);\n};"
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  711 always 711
Line 736
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  736 always 736
  "" always ""
Line 738
  "class F\n{\n   public:\n   char *c,*p,*d;\n   F(char *str,char *st,char *string)\n   {\n      p=(char *)malloc(100);\n      strcpy(p,str);\n      c=(char *)malloc(100);\n      strcpy(p,st);\n      d=(char *)malloc(100);\n      strcpy(p,string);\n   }\n   F(const F &f)\n   {\n      p=(char *)malloc(strlen(str)+1);\n      strcpy(p,f.p);\n      c=(char *)malloc(strlen(str)+1);\n      strcpy(p,f.p);\n   }\n   ~F();\n   F& operator=(const F&f);\n};" always "class F\n{\n   public:\n   char *c,*p,*d;\n   F(char *str,char *st,char *string)\n   {\n      p=(char *)malloc(100);\n      strcpy(p,str);\n      c=(char *)malloc(100);\n      strcpy(p,st);\n      d=(char *)malloc(100);\n      strcpy(p,string);\n   }\n   F(const F &f)\n   {\n      p=(char *)malloc(strlen(str)+1);\n      strcpy(p,f.p);\n      c=(char *)malloc(strlen(str)+1);\n      strcpy(p,f.p);\n   }\n   ~F();\n   F& operator=(const F&f);\n};"
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  738 always 738
Line 761
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  761 always 761
  "[test.cpp:14] -> [test.cpp:11]: (warning) Copy constructor does not allocate memory for member 'd' although memory has been allocated in other constructors.\n" always "[test.cpp:14] -> [test.cpp:11]: (warning) Copy constructor does not allocate memory for member 'd' although memory has been allocated in other constructors.\n"
  "" always ""
Line 763
  "class F {\n   char *c;\n   F(char *str,char *st,char *string) {\n      p=(char *)malloc(100);\n   }\n   F(const F &f)\n      : p(malloc(size))\n   {\n   }\n   ~F();\n   F& operator=(const F&f);\n};" always "class F {\n   char *c;\n   F(char *str,char *st,char *string) {\n      p=(char *)malloc(100);\n   }\n   F(const F &f)\n      : p(malloc(size))\n   {\n   }\n   ~F();\n   F& operator=(const F&f);\n};"
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  763 always 763
Line 775
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  775 always 775
  "" always ""
Line 777
  "class F {\n   char *c;\n   F(char *str,char *st,char *string)\n      : p(malloc(size))\n   {\n   }\n   F(const F &f)\n   {\n   }\n   ~F();\n   F& operator=(const F&f);\n};" always "class F {\n   char *c;\n   F(char *str,char *st,char *string)\n      : p(malloc(size))\n   {\n   }\n   F(const F &f)\n   {\n   }\n   ~F();\n   F& operator=(const F&f);\n};"
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  777 always 777
Line 789
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  789 always 789
  "[test.cpp:7] -> [test.cpp:4]: (warning) Copy constructor does not allocate memory for member 'd' although memory has been allocated in other constructors.\n" always "[test.cpp:7] -> [test.cpp:4]: (warning) Copy constructor does not allocate memory for member 'd' although memory has been allocated in other constructors.\n"
  "" always ""
Line 791
  "class F\n{\n   public:\n   char *c,*p,*d;\n   F()\n   {\n      p=(char *)malloc(100);\n      c=(char *)malloc(100);\n      d=(char*)malloc(100);\n   }\n   ~F();\n   F& operator=(const F&f);\n};" always "class F\n{\n   public:\n   char *c,*p,*d;\n   F()\n   {\n      p=(char *)malloc(100);\n      c=(char *)malloc(100);\n      d=(char*)malloc(100);\n   }\n   ~F();\n   F& operator=(const F&f);\n};"
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  791 always 791
Line 804
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  804 always 804
  "[test.cpp:8]: (warning) Class 'F' does not have a copy constructor which is recommended since it has dynamic memory/resource allocation(s).\n" always "[test.cpp:8]: (warning) Class 'F' does not have a copy constructor which is recommended since it has dynamic memory/resource allocation(s).\n"
  "" always ""
Line 806
  "class F\n{\n   public:\n   char *c;\n   const char *p,*d;\n   F(char *str,char *st,char *string)\n   {\n      p=str;\n      d=st;\n      c=(char *)malloc(strlen(string)+1);\n      strcpy(d,string);\n   }\n   F(const F &f)\n   {\n      p=f.p;\n      d=f.d;\n      c=(char *)malloc(strlen(str)+1);\n      strcpy(d,f.p);\n   }\n   ~F();\n   F& operator=(const F&f);\n};" always "class F\n{\n   public:\n   char *c;\n   const char *p,*d;\n   F(char *str,char *st,char *string)\n   {\n      p=str;\n      d=st;\n      c=(char *)malloc(strlen(string)+1);\n      strcpy(d,string);\n   }\n   F(const F &f)\n   {\n      p=f.p;\n      d=f.d;\n      c=(char *)malloc(strlen(str)+1);\n      strcpy(d,f.p);\n   }\n   ~F();\n   F& operator=(const F&f);\n};"
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  806 always 806
Line 828
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  828 always 828
  "" always ""
Line 830
  "class F : E\n{\n   char *p;\n   F() {\n      p = malloc(100);\n   }\n   ~F();\n   F& operator=(const F&f);\n};" always "class F : E\n{\n   char *p;\n   F() {\n      p = malloc(100);\n   }\n   ~F();\n   F& operator=(const F&f);\n};"
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  830 always 830
Line 839
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  839 always 839
  "" always ""
Line 841
  "class E { E(E&); };\nclass F : E\n{\n   char *p;\n   F() {\n      p = malloc(100);\n   }\n   ~F();\n   F& operator=(const F&f);\n};" always "class E { E(E&); };\nclass F : E\n{\n   char *p;\n   F() {\n      p = malloc(100);\n   }\n   ~F();\n   F& operator=(const F&f);\n};"
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  841 always 841
Line 851
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  851 always 851
  "" always ""
Line 853
  "class E {};\nclass F : E {\n   char *p;\n   F() {\n      p = malloc(100);\n   }\n   ~F();\n   F& operator=(const F&f);\n};" always "class E {};\nclass F : E {\n   char *p;\n   F() {\n      p = malloc(100);\n   }\n   ~F();\n   F& operator=(const F&f);\n};"
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  853 always 853
Line 862
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  862 always 862
  "[test.cpp:5]: (warning) Class 'F' does not have a copy constructor which is recommended since it has dynamic memory/resource allocation(s).\n" always "[test.cpp:5]: (warning) Class 'F' does not have a copy constructor which is recommended since it has dynamic memory/resource allocation(s).\n"
Line 864
  "class F {\n   char *p;\n   F() {\n      p = malloc(100);\n   }\n   F(F& f);\n   ~F();\n   F& operator=(const F&f);\n};" always "class F {\n   char *p;\n   F() {\n      p = malloc(100);\n   }\n   F(F& f);\n   ~F();\n   F& operator=(const F&f);\n};"
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  864 always 864
Line 873
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  873 always 873
  "" always ""
Line 875
  "class F {\n   char *p;\n   F() : p(malloc(100)) {}\n   ~F();\n   F& operator=(const F&f);\n};" always "class F {\n   char *p;\n   F() : p(malloc(100)) {}\n   ~F();\n   F& operator=(const F&f);\n};"
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  875 always 875
Line 881
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  881 always 881
  "[test.cpp:3]: (warning) Class 'F' does not have a copy constructor which is recommended since it has dynamic memory/resource allocation(s).\n" always "[test.cpp:3]: (warning) Class 'F' does not have a copy constructor which is recommended since it has dynamic memory/resource allocation(s).\n"
Line 884
  "struct F {\n   static char* c;\n   F() {\n      p = malloc(100);\n   }\n};" always "struct F {\n   static char* c;\n   F() {\n      p = malloc(100);\n   }\n};"
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  884 always 884
Line 890
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  890 always 890
  "" always ""
Line 894
  "template <class _Tp>\nclass Vector\n{\npublic:\n    Vector() {\n        _M_finish = new _Tp[ 42 ];\n    }\n    Vector( const Vector<_Tp>& v ) {\n    }\n     ~Vector();\n     Vector& operator=(const Vector&v);\n    _Tp* _M_finish;\n};" always "template <class _Tp>\nclass Vector\n{\npublic:\n    Vector() {\n        _M_finish = new _Tp[ 42 ];\n    }\n    Vector( const Vector<_Tp>& v ) {\n    }\n     ~Vector();\n     Vector& operator=(const Vector&v);\n    _Tp* _M_finish;\n};"
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  894 always 894
Line 907
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  907 always 907
  "" always ""
Line 911
  "struct F {\n   char* c;\n   F() { c = malloc(100); }\n   F(const F &f) = delete;\n   F&operator=(const F &f);\n   ~F();\n};" always "struct F {\n   char* c;\n   F() { c = malloc(100); }\n   F(const F &f) = delete;\n   F&operator=(const F &f);\n   ~F();\n};"
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  911 always 911
Line 918
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  918 always 918
  "" always ""
Line 920
  "struct F {\n   char* c;\n   F() { c = malloc(100); }\n   F(const F &f) = default;\n   F&operator=(const F &f);\n   ~F();\n};" always "struct F {\n   char* c;\n   F() { c = malloc(100); }\n   F(const F &f) = default;\n   F&operator=(const F &f);\n   ~F();\n};"
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  920 always 920
Line 927
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  927 always 927
  "[test.cpp:3]: (warning) Struct 'F' has dynamic memory/resource allocation(s). The copy constructor is explicitly defaulted but the default copy constructor does not work well. It is recommended to define or delete the copy constructor.\n" always "[test.cpp:3]: (warning) Struct 'F' has dynamic memory/resource allocation(s). The copy constructor is explicitly defaulted but the default copy constructor does not work well. It is recommended to define or delete the copy constructor.\n"
Line 931
  "class noncopyable {\nprotected:\n    noncopyable() {}\n    ~noncopyable() {}\n\nprivate:\n    noncopyable( const noncopyable& );\n    const noncopyable& operator=( const noncopyable& );\n};\n\nclass Base : private noncopyable {};\n\nclass Foo : public Base {\npublic:\n    Foo() : m_ptr(new int) {}\n    ~Foo() { delete m_ptr; }\nprivate:\n    int* m_ptr;\n};" always "class noncopyable {\nprotected:\n    noncopyable() {}\n    ~noncopyable() {}\n\nprivate:\n    noncopyable( const noncopyable& );\n    const noncopyable& operator=( const noncopyable& );\n};\n\nclass Base : private noncopyable {};\n\nclass Foo : public Base {\npublic:\n    Foo() : m_ptr(new int) {}\n    ~Foo() { delete m_ptr; }\nprivate:\n    int* m_ptr;\n};"
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  931 always 931
Line 950
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  950 always 950
  "" always ""
Line 954
  "class Copyable {};\n\nclass Foo : public Copyable, public UnknownType {\npublic:\n    Foo() : m_ptr(new int) {}\n    ~Foo() { delete m_ptr; }\nprivate:\n    int* m_ptr;\n};" always "class Copyable {};\n\nclass Foo : public Copyable, public UnknownType {\npublic:\n    Foo() : m_ptr(new int) {}\n    ~Foo() { delete m_ptr; }\nprivate:\n    int* m_ptr;\n};"
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  954 always 954
Line 963
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  963 always 963
  "" always ""
Line 965
  "class Copyable {};\n\nclass Foo : public UnknownType, public Copyable {\npublic:\n    Foo() : m_ptr(new int) {}\n    ~Foo() { delete m_ptr; }\nprivate:\n    int* m_ptr;\n};" always "class Copyable {};\n\nclass Foo : public UnknownType, public Copyable {\npublic:\n    Foo() : m_ptr(new int) {}\n    ~Foo() { delete m_ptr; }\nprivate:\n    int* m_ptr;\n};"
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  965 always 965
Line 974
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  974 always 974
  "" always ""
Line 978
  "struct S {\n    S() {\n        for (int i = 0; i < 5; i++)\n            a[i] = new char[3];\n    }\n    char* a[5];\n};\n" always "struct S {\n    S() {\n        for (int i = 0; i < 5; i++)\n            a[i] = new char[3];\n    }\n    char* a[5];\n};\n"
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  978 always 978
Line 985
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  985 always 985
  "[test.cpp:4]: (warning) Struct 'S' does not have a copy constructor which is recommended since it has dynamic memory/resource allocation(s).\n[test.cpp:4]: (warning) Struct 'S' does not have a operator= which is recommended since it has dynamic memory/resource allocation(s).\n[test.cpp:4]: (warning) Struct 'S' does not have a destructor which is recommended since it has dynamic memory/resource allocation(s).\n" always "[test.cpp:4]: (warning) Struct 'S' does not have a copy constructor which is recommended since it has dynamic memory/resource allocation(s).\n[test.cpp:4]: (warning) Struct 'S' does not have a operator= which is recommended since it has dynamic memory/resource allocation(s).\n[test.cpp:4]: (warning) Struct 'S' does not have a destructor which is recommended since it has dynamic memory/resource allocation(s).\n"
  "" always ""
Line 993
  "struct F {\n   char* c;\n   F() { c = malloc(100); }\n   F(const F &f);\n   ~F();\n};" always "struct F {\n   char* c;\n   F() { c = malloc(100); }\n   F(const F &f);\n   ~F();\n};"
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  993 always 993
Line 999
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  999 always 999
  "[test.cpp:3]: (warning) Struct 'F' does not have a operator= which is recommended since it has dynamic memory/resource allocation(s).\n" always "[test.cpp:3]: (warning) Struct 'F' does not have a operator= which is recommended since it has dynamic memory/resource allocation(s).\n"
Line 1002
  "struct F {\n   char* c;\n   F() { c = malloc(100); }\n   F(const F &f);\n   F &operator=(const F &f) = default;\n   ~F();\n};" always "struct F {\n   char* c;\n   F() { c = malloc(100); }\n   F(const F &f);\n   F &operator=(const F &f) = default;\n   ~F();\n};"
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  1002 always 1002
Line 1009
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  1009 always 1009
  "[test.cpp:3]: (warning) Struct 'F' has dynamic memory/resource allocation(s). The operator= is explicitly defaulted but the default operator= does not work well. It is recommended to define or delete the operator=.\n" always "[test.cpp:3]: (warning) Struct 'F' has dynamic memory/resource allocation(s). The operator= is explicitly defaulted but the default operator= does not work well. It is recommended to define or delete the operator=.\n"
Line 1012
  "struct F {\n   char* c;\n   F() { c = malloc(100); }\n   F(const F &f);\n   F &operator=(const F &f) = delete;\n   ~F();\n};" always "struct F {\n   char* c;\n   F() { c = malloc(100); }\n   F(const F &f);\n   F &operator=(const F &f) = delete;\n   ~F();\n};"
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  1012 always 1012
Line 1019
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  1019 always 1019
  "" always ""
Line 1022
  "struct F : NonCopyable {\n   char* c;\n   F() { c = malloc(100); }\n   F(const F &f);\n   ~F();\n};" always "struct F : NonCopyable {\n   char* c;\n   F() { c = malloc(100); }\n   F(const F &f);\n   ~F();\n};"
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  1022 always 1022
Line 1028
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  1028 always 1028
  "" always ""
Line 1032
  "struct F {\n   char* c;\n   F() { c = malloc(100); }\n   F(const F &f);\n   F&operator=(const F&);};" always "struct F {\n   char* c;\n   F() { c = malloc(100); }\n   F(const F &f);\n   F&operator=(const F&);};"
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  1032 always 1032
Line 1038
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  1038 always 1038
  "[test.cpp:3]: (warning) Struct 'F' does not have a destructor which is recommended since it has dynamic memory/resource allocation(s).\n" always "[test.cpp:3]: (warning) Struct 'F' does not have a destructor which is recommended since it has dynamic memory/resource allocation(s).\n"
Line 1040
  "struct F {\n   C* c;\n   F() { c = new C; }\n   F(const F &f);\n   F&operator=(const F&);};" always "struct F {\n   C* c;\n   F() { c = new C; }\n   F(const F &f);\n   F&operator=(const F&);};"
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  1040 always 1040
Line 1046
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  1046 always 1046
  "" always ""
Line 1048
  "struct F {\n   int* i;\n   F() { i = new int(); }\n   F(const F &f);\n   F& operator=(const F&);};" always "struct F {\n   int* i;\n   F() { i = new int(); }\n   F(const F &f);\n   F& operator=(const F&);};"
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  1048 always 1048
Line 1054
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  1054 always 1054
  "[test.cpp:3]: (warning) Struct 'F' does not have a destructor which is recommended since it has dynamic memory/resource allocation(s).\n" always "[test.cpp:3]: (warning) Struct 'F' does not have a destructor which is recommended since it has dynamic memory/resource allocation(s).\n"
Line 1056
  "struct Data { int x; int y; };\nstruct F {\n   Data* c;\n   F() { c = new Data; }\n   F(const F &f);\n   F&operator=(const F&);};" always "struct Data { int x; int y; };\nstruct F {\n   Data* c;\n   F() { c = new Data; }\n   F(const F &f);\n   F&operator=(const F&);};"
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  1056 always 1056
Line 1063
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  1063 always 1063
  "[test.cpp:4]: (warning) Struct 'F' does not have a destructor which is recommended since it has dynamic memory/resource allocation(s).\n" always "[test.cpp:4]: (warning) Struct 'F' does not have a destructor which is recommended since it has dynamic memory/resource allocation(s).\n"
Line 1066
  "struct F {\n   char* c;\n   F() { c = malloc(100); }\n   F(const F &f);\n   F &operator=(const F &f);\n   ~F() = default;\n};" always "struct F {\n   char* c;\n   F() { c = malloc(100); }\n   F(const F &f);\n   F &operator=(const F &f);\n   ~F() = default;\n};"
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  1066 always 1066
Line 1073
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  1073 always 1073
  "[test.cpp:3]: (warning) Struct 'F' has dynamic memory/resource allocation(s). The destructor is explicitly defaulted but the default destructor does not work well. It is recommended to define the destructor.\n" always "[test.cpp:3]: (warning) Struct 'F' has dynamic memory/resource allocation(s). The destructor is explicitly defaulted but the default destructor does not work well. It is recommended to define the destructor.\n"
Line 1076
  "struct F {\n   char* c;\n   F() { c = malloc(100); }\n   F(const F &f);\n   F &operator=(const F &f);\n   ~F() = delete;\n};" always "struct F {\n   char* c;\n   F() { c = malloc(100); }\n   F(const F &f);\n   F &operator=(const F &f);\n   ~F() = delete;\n};"
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  1076 always 1076
Line 1083
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  1083 always 1083
  "" always ""
Line 1090
  "" always ""
Line 1093
  & {lifetime[Address]=(settings0),!0}
  this always !0
Line 1094
  code possible {"class basic_fbstring {\n  basic_fbstring& operator=(int il) {\n    return assign();\n  }\n  basic_fbstring& assign() {\n    return replace();\n  }\n  basic_fbstring& replaceImplDiscr() {\n    return replace();\n  }\n  basic_fbstring& replace() {\n    return replaceImplDiscr();\n  }\n};"@61,"class UString {\npublic:\n    UString& assign( const char* c_str );\n    UString& operator=( const UString& s );\n};\nUString& UString::assign( const char* c_str ) {\n    std::string tmp( c_str );\n    return assign( tmp );\n}\nUString& UString::operator=( const UString& s ) {\n    return assign( s );\n}"@62,"class A {\npublic:\n    A & operator=(const A &a) { }\n};"@63,"class A {\nprotected:\n    A & operator=(const A &a) {}\n};"@64,"class A {\nprivate:\n    A & operator=(const A &a) {}\n};"@65,"class A {\npublic:\n    A & operator=(const A &a) {\n        rand();\n        throw std::exception();\n    }\n};"@66,"class A {\npublic:\n    A & operator=(const A &a) {\n        rand();\n        abort();\n    }\n};"@67,"class A {\npublic:\n    A & operator=(const A &a);\n};\nA & A :: operator=(const A &a) { }"@68,"P& P::operator = (const P& pc)\n{\n  return (P&)(*this += pc);\n}"@69,"class A {\npublic:\n  inline A &operator =(int *other) { return (*this); };\n  inline A &operator =(long *other) { return (*this = 0); };\n};"@70}
Line 1095
  ( always {!<=-1,!>=2}
  file inconclusive {"cppcheck-2.8/test/testclass.cpp"@61,"cppcheck-2.8/test/testclass.cpp"@62,"cppcheck-2.8/test/testclass.cpp"@63,"cppcheck-2.8/test/testclass.cpp"@64,"cppcheck-2.8/test/testclass.cpp"@65,"cppcheck-2.8/test/testclass.cpp"@66,"cppcheck-2.8/test/testclass.cpp"@67,"cppcheck-2.8/test/testclass.cpp"@68,"cppcheck-2.8/test/testclass.cpp"@69,"cppcheck-2.8/test/testclass.cpp"@70}
  line inconclusive {1532@61,1516@62,1465@63,1472@64,1479@65,1486@66,1496@67,1506@68,1455@69,1394@70}
  "test.cpp" always "test.cpp"
Line 1098
  & {lifetime[Address]=(tokenizer),!0}
  & {lifetime[Address]=(settings0),!0}
  this always !0
Line 1103
  "class A\n{\npublic:\n    A & operator=(const A &a) { return *this; }\n};" always "class A\n{\npublic:\n    A & operator=(const A &a) { return *this; }\n};"
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  1103 always 1103
Line 1109
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  1109 always 1109
  "" always ""
Line 1111
  "class A\n{\npublic:\n    A & operator=(const A &a) { return a; }\n};" always "class A\n{\npublic:\n    A & operator=(const A &a) { return a; }\n};"
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  1111 always 1111
Line 1117
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  1117 always 1117
  "[test.cpp:4]: (style) 'operator=' should return reference to 'this' instance.\n" always "[test.cpp:4]: (style) 'operator=' should return reference to 'this' instance.\n"
Line 1119
  "class A\n{\npublic:\n    A & operator=(const A &);\n};\nA & A::operator=(const A &a) { return *this; }" always "class A\n{\npublic:\n    A & operator=(const A &);\n};\nA & A::operator=(const A &a) { return *this; }"
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  1119 always 1119
Line 1126
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  1126 always 1126
  "" always ""
Line 1128
  "class A\n{\npublic:\n    A & operator=(const A &a);\n};\nA & A::operator=(const A &a) { return *this; }" always "class A\n{\npublic:\n    A & operator=(const A &a);\n};\nA & A::operator=(const A &a) { return *this; }"
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  1128 always 1128
Line 1135
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  1135 always 1135
  "" always ""
Line 1137
  "class A\n{\npublic:\n    A & operator=(const A &);\n};\nA & A::operator=(const A &a) { return a; }" always "class A\n{\npublic:\n    A & operator=(const A &);\n};\nA & A::operator=(const A &a) { return a; }"
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  1137 always 1137
Line 1144
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  1144 always 1144
  "[test.cpp:6]: (style) 'operator=' should return reference to 'this' instance.\n" always "[test.cpp:6]: (style) 'operator=' should return reference to 'this' instance.\n"
Line 1146
  "class A\n{\npublic:\n    A & operator=(const A &a);\n};\nA & A::operator=(const A &a) { return a; }" always "class A\n{\npublic:\n    A & operator=(const A &a);\n};\nA & A::operator=(const A &a) { return a; }"
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  1146 always 1146
Line 1153
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  1153 always 1153
  "[test.cpp:6]: (style) 'operator=' should return reference to 'this' instance.\n" always "[test.cpp:6]: (style) 'operator=' should return reference to 'this' instance.\n"
Line 1155
  "class A\n{\npublic:\n    class B\n    {\n    public:\n        B & operator=(const B &b) { return *this; }\n    };\n};" always "class A\n{\npublic:\n    class B\n    {\n    public:\n        B & operator=(const B &b) { return *this; }\n    };\n};"
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  1155 always 1155
Line 1165
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  1165 always 1165
  "" always ""
Line 1167
  "class A\n{\npublic:\n    class B\n    {\n    public:\n        B & operator=(const B &b) { return b; }\n    };\n};" always "class A\n{\npublic:\n    class B\n    {\n    public:\n        B & operator=(const B &b) { return b; }\n    };\n};"
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  1167 always 1167
Line 1177
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  1177 always 1177
  "[test.cpp:7]: (style) 'operator=' should return reference to 'this' instance.\n" always "[test.cpp:7]: (style) 'operator=' should return reference to 'this' instance.\n"
Line 1179
  "class A\n{\npublic:\n    class B\n    {\n    public:\n        B & operator=(const B &);\n    };\n};\nA::B & A::B::operator=(const A::B &b) { return *this; }" always "class A\n{\npublic:\n    class B\n    {\n    public:\n        B & operator=(const B &);\n    };\n};\nA::B & A::B::operator=(const A::B &b) { return *this; }"
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  1179 always 1179
Line 1190
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  1190 always 1190
  "" always ""
Line 1192
  "class A\n{\npublic:\n    class B\n    {\n    public:\n        B & operator=(const B &);\n    };\n};\nA::B & A::B::operator=(const A::B &b) { return b; }" always "class A\n{\npublic:\n    class B\n    {\n    public:\n        B & operator=(const B &);\n    };\n};\nA::B & A::B::operator=(const A::B &b) { return b; }"
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  1192 always 1192
Line 1203
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  1203 always 1203
  "[test.cpp:10]: (style) 'operator=' should return reference to 'this' instance.\n" always "[test.cpp:10]: (style) 'operator=' should return reference to 'this' instance.\n"
Line 1205
  "class A {\n    class B;\n};\nclass A::B\n{\n  B & operator=(const B & b) { return b; }\n};" always "class A {\n    class B;\n};\nclass A::B\n{\n  B & operator=(const B & b) { return b; }\n};"
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  1205 always 1205
Line 1213
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  1213 always 1213
  "[test.cpp:6]: (style) 'operator=' should return reference to 'this' instance.\n" always "[test.cpp:6]: (style) 'operator=' should return reference to 'this' instance.\n"
Line 1215
  "class A {\n    class B;\n};\nclass A::B\n{\n  B & operator=(const B &);\n};\nA::B & A::B::operator=(const A::B & b) { return b; }" always "class A {\n    class B;\n};\nclass A::B\n{\n  B & operator=(const B &);\n};\nA::B & A::B::operator=(const A::B & b) { return b; }"
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  1215 always 1215
Line 1224
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  1224 always 1224
  "[test.cpp:8]: (style) 'operator=' should return reference to 'this' instance.\n" always "[test.cpp:8]: (style) 'operator=' should return reference to 'this' instance.\n"
Line 1226
  "class A {\n    class B;\n};\nclass A::B\n{\n  A::B & operator=(const A::B & b) { return b; }\n};" always "class A {\n    class B;\n};\nclass A::B\n{\n  A::B & operator=(const A::B & b) { return b; }\n};"
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  1226 always 1226
Line 1234
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  1234 always 1234
  "[test.cpp:6]: (style) 'operator=' should return reference to 'this' instance.\n" always "[test.cpp:6]: (style) 'operator=' should return reference to 'this' instance.\n"
Line 1236
  "class A {\n    class B;\n};\nclass A::B\n{\n  A::B & operator=(const A::B &);\n};\nA::B & A::B::operator=(const A::B & b) { return b; }" always "class A {\n    class B;\n};\nclass A::B\n{\n  A::B & operator=(const A::B &);\n};\nA::B & A::B::operator=(const A::B & b) { return b; }"
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  1236 always 1236
Line 1245
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  1245 always 1245
  "[test.cpp:8]: (style) 'operator=' should return reference to 'this' instance.\n" always "[test.cpp:8]: (style) 'operator=' should return reference to 'this' instance.\n"
Line 1247
  "namespace A {\n    class B;\n}\nclass A::B\n{\n  B & operator=(const B & b) { return b; }\n};" always "namespace A {\n    class B;\n}\nclass A::B\n{\n  B & operator=(const B & b) { return b; }\n};"
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  1247 always 1247
Line 1255
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  1255 always 1255
  "[test.cpp:6]: (style) 'operator=' should return reference to 'this' instance.\n" always "[test.cpp:6]: (style) 'operator=' should return reference to 'this' instance.\n"
Line 1257
  "namespace A {\n    class B;\n}\nclass A::B\n{\n  B & operator=(const B &);\n};\nA::B & A::B::operator=(const A::B & b) { return b; }" always "namespace A {\n    class B;\n}\nclass A::B\n{\n  B & operator=(const B &);\n};\nA::B & A::B::operator=(const A::B & b) { return b; }"
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  1257 always 1257
Line 1266
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  1266 always 1266
  "[test.cpp:8]: (style) 'operator=' should return reference to 'this' instance.\n" always "[test.cpp:8]: (style) 'operator=' should return reference to 'this' instance.\n"
Line 1268
  "namespace A {\n    class B;\n}\nclass A::B\n{\n  A::B & operator=(const A::B & b) { return b; }\n};" always "namespace A {\n    class B;\n}\nclass A::B\n{\n  A::B & operator=(const A::B & b) { return b; }\n};"
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  1268 always 1268
Line 1276
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  1276 always 1276
  "[test.cpp:6]: (style) 'operator=' should return reference to 'this' instance.\n" always "[test.cpp:6]: (style) 'operator=' should return reference to 'this' instance.\n"
Line 1278
  "namespace A {\n    class B;\n}\nclass A::B\n{\n  A::B & operator=(const A::B &);\n};\nA::B & A::B::operator=(const A::B & b) { return b; }" always "namespace A {\n    class B;\n}\nclass A::B\n{\n  A::B & operator=(const A::B &);\n};\nA::B & A::B::operator=(const A::B & b) { return b; }"
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  1278 always 1278
Line 1287
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  1287 always 1287
  "[test.cpp:8]: (style) 'operator=' should return reference to 'this' instance.\n" always "[test.cpp:8]: (style) 'operator=' should return reference to 'this' instance.\n"
Line 1292
  "class szp\n{\n  szp &operator =(int *other) {}\n};" always "class szp\n{\n  szp &operator =(int *other) {}\n};"
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  1292 always 1292
Line 1297
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  1297 always 1297
  "[test.cpp:3]: (error) No 'return' statement in non-void function causes undefined behavior.\n" always "[test.cpp:3]: (error) No 'return' statement in non-void function causes undefined behavior.\n"
Line 1299
  "class szp\n{\n  szp &operator =(int *other);\n};\nszp &szp::operator =(int *other) {}" always "class szp\n{\n  szp &operator =(int *other);\n};\nszp &szp::operator =(int *other) {}"
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  1299 always 1299
Line 1305
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  1305 always 1305
  "[test.cpp:5]: (error) No 'return' statement in non-void function causes undefined behavior.\n" always "[test.cpp:5]: (error) No 'return' statement in non-void function causes undefined behavior.\n"
Line 1307
  "namespace NS {\n    class szp;\n}\nclass NS::szp\n{\n  szp &operator =(int *other) {}\n};" always "namespace NS {\n    class szp;\n}\nclass NS::szp\n{\n  szp &operator =(int *other) {}\n};"
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  1307 always 1307
Line 1315
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  1315 always 1315
  "[test.cpp:6]: (error) No 'return' statement in non-void function causes undefined behavior.\n" always "[test.cpp:6]: (error) No 'return' statement in non-void function causes undefined behavior.\n"
Line 1317
  "namespace NS {\n    class szp;\n}\nclass NS::szp\n{\n  szp &operator =(int *other);\n};\nNS::szp &NS::szp::operator =(int *other) {}" always "namespace NS {\n    class szp;\n}\nclass NS::szp\n{\n  szp &operator =(int *other);\n};\nNS::szp &NS::szp::operator =(int *other) {}"
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  1317 always 1317
Line 1326
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  1326 always 1326
  "[test.cpp:8]: (error) No 'return' statement in non-void function causes undefined behavior.\n" always "[test.cpp:8]: (error) No 'return' statement in non-void function causes undefined behavior.\n"
Line 1328
  "namespace NS {\n    class szp;\n}\nclass NS::szp\n{\n  NS::szp &operator =(int *other) {}\n};" always "namespace NS {\n    class szp;\n}\nclass NS::szp\n{\n  NS::szp &operator =(int *other) {}\n};"
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  1328 always 1328
Line 1336
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  1336 always 1336
  "[test.cpp:6]: (error) No 'return' statement in non-void function causes undefined behavior.\n" always "[test.cpp:6]: (error) No 'return' statement in non-void function causes undefined behavior.\n"
Line 1338
  "namespace NS {\n    class szp;\n}\nclass NS::szp\n{\n  NS::szp &operator =(int *other);\n};\nNS::szp &NS::szp::operator =(int *other) {}" always "namespace NS {\n    class szp;\n}\nclass NS::szp\n{\n  NS::szp &operator =(int *other);\n};\nNS::szp &NS::szp::operator =(int *other) {}"
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  1338 always 1338
Line 1347
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  1347 always 1347
  "[test.cpp:8]: (error) No 'return' statement in non-void function causes undefined behavior.\n" always "[test.cpp:8]: (error) No 'return' statement in non-void function causes undefined behavior.\n"
Line 1349
  "class A {\n    class szp;\n};\nclass A::szp\n{\n  szp &operator =(int *other) {}\n};" always "class A {\n    class szp;\n};\nclass A::szp\n{\n  szp &operator =(int *other) {}\n};"
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  1349 always 1349
Line 1357
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  1357 always 1357
  "[test.cpp:6]: (error) No 'return' statement in non-void function causes undefined behavior.\n" always "[test.cpp:6]: (error) No 'return' statement in non-void function causes undefined behavior.\n"
Line 1359
  "class A {\n    class szp;\n};\nclass A::szp\n{\n  szp &operator =(int *other);\n};\nA::szp &A::szp::operator =(int *other) {}" always "class A {\n    class szp;\n};\nclass A::szp\n{\n  szp &operator =(int *other);\n};\nA::szp &A::szp::operator =(int *other) {}"
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  1359 always 1359
Line 1368
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  1368 always 1368
  "[test.cpp:8]: (error) No 'return' statement in non-void function causes undefined behavior.\n" always "[test.cpp:8]: (error) No 'return' statement in non-void function causes undefined behavior.\n"
Line 1370
  "class A {\n    class szp;\n};\nclass A::szp\n{\n  A::szp &operator =(int *other) {}\n};" always "class A {\n    class szp;\n};\nclass A::szp\n{\n  A::szp &operator =(int *other) {}\n};"
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  1370 always 1370
Line 1378
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  1378 always 1378
  "[test.cpp:6]: (error) No 'return' statement in non-void function causes undefined behavior.\n" always "[test.cpp:6]: (error) No 'return' statement in non-void function causes undefined behavior.\n"
Line 1380
  "class A {\n    class szp;\n};\nclass A::szp\n{\n  A::szp &operator =(int *other);\n};\nA::szp &A::szp::operator =(int *other) {}" always "class A {\n    class szp;\n};\nclass A::szp\n{\n  A::szp &operator =(int *other);\n};\nA::szp &A::szp::operator =(int *other) {}"
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  1380 always 1380
Line 1389
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  1389 always 1389
  "[test.cpp:8]: (error) No 'return' statement in non-void function causes undefined behavior.\n" always "[test.cpp:8]: (error) No 'return' statement in non-void function causes undefined behavior.\n"
Line 1394
  "class A {\npublic:\n  inline A &operator =(int *other) { return (*this); };\n  inline A &operator =(long *other) { return (*this = 0); };\n};" always "class A {\npublic:\n  inline A &operator =(int *other) { return (*this); };\n  inline A &operator =(long *other) { return (*this = 0); };\n};"
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  1394 always 1394
Line 1400
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  1400 always 1400
  "" always ""
Line 1402
  "class A {\npublic:\n  A &operator =(int *other);\n  A &operator =(long *other);\n};\nA &A::operator =(int *other) { return (*this); };\nA &A::operator =(long *other) { return (*this = 0); };" always "class A {\npublic:\n  A &operator =(int *other);\n  A &operator =(long *other);\n};\nA &A::operator =(int *other) { return (*this); };\nA &A::operator =(long *other) { return (*this = 0); };"
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  1402 always 1402
Line 1410
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  1410 always 1410
  "" always ""
Line 1412
  "class A {\npublic:\n  inline A &operator =(int *other) { return (*this); };\n  inline A &operator =(long *other) { return operator = (*(int *)other); };\n};" always "class A {\npublic:\n  inline A &operator =(int *other) { return (*this); };\n  inline A &operator =(long *other) { return operator = (*(int *)other); };\n};"
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  1412 always 1412
Line 1418
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  1418 always 1418
  "" always ""
Line 1420
  "class A {\npublic:\n  A &operator =(int *other);\n  A &operator =(long *other);\n};\nA &A::operator =(int *other) { return (*this); };\nA &A::operator =(long *other) { return operator = (*(int *)other); };" always "class A {\npublic:\n  A &operator =(int *other);\n  A &operator =(long *other);\n};\nA &A::operator =(int *other) { return (*this); };\nA &A::operator =(long *other) { return operator = (*(int *)other); };"
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  1420 always 1420
Line 1428
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  1428 always 1428
  "" always ""
Line 1430
  "class A {\npublic:\n  A &operator =(int *other);\n  A &operator =(long *other);\n};\nA &A::operator =(int *other) { return (*this); };\nA &A::operator =(long *other) { return this->operator = (*(int *)other); };" always "class A {\npublic:\n  A &operator =(int *other);\n  A &operator =(long *other);\n};\nA &A::operator =(int *other) { return (*this); };\nA &A::operator =(long *other) { return this->operator = (*(int *)other); };"
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  1430 always 1430
Line 1438
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  1438 always 1438
  "" always ""
Line 1440
  "class V {\npublic:\n    V& operator=(const V& r) {\n        if (this == &r) {\n            return ( *this );\n        }\n        return *this;\n    }\n};" always "class V {\npublic:\n    V& operator=(const V& r) {\n        if (this == &r) {\n            return ( *this );\n        }\n        return *this;\n    }\n};"
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  1440 always 1440
Line 1450
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  1450 always 1450
  "" always ""
Line 1455
  "P& P::operator = (const P& pc)\n{\n  return (P&)(*this += pc);\n}" always "P& P::operator = (const P& pc)\n{\n  return (P&)(*this += pc);\n}"
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  1455 always 1455
Line 1460
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  1460 always 1460
  "" always ""
Line 1465
  "class A {\npublic:\n    A & operator=(const A &a) { }\n};" always "class A {\npublic:\n    A & operator=(const A &a) { }\n};"
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  1465 always 1465
Line 1470
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  1470 always 1470
  "[test.cpp:3]: (error) No 'return' statement in non-void function causes undefined behavior.\n" always "[test.cpp:3]: (error) No 'return' statement in non-void function causes undefined behavior.\n"
Line 1472
  "class A {\nprotected:\n    A & operator=(const A &a) {}\n};" always "class A {\nprotected:\n    A & operator=(const A &a) {}\n};"
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  1472 always 1472
Line 1477
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  1477 always 1477
  "[test.cpp:3]: (style) 'operator=' should return reference to 'this' instance.\n" always "[test.cpp:3]: (style) 'operator=' should return reference to 'this' instance.\n"
Line 1479
  "class A {\nprivate:\n    A & operator=(const A &a) {}\n};" always "class A {\nprivate:\n    A & operator=(const A &a) {}\n};"
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  1479 always 1479
Line 1484
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  1484 always 1484
  "[test.cpp:3]: (style) 'operator=' should return reference to 'this' instance.\n" always "[test.cpp:3]: (style) 'operator=' should return reference to 'this' instance.\n"
Line 1486
  "class A {\npublic:\n    A & operator=(const A &a) {\n        rand();\n        throw std::exception();\n    }\n};" always "class A {\npublic:\n    A & operator=(const A &a) {\n        rand();\n        throw std::exception();\n    }\n};"
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  1486 always 1486
Line 1494
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  1494 always 1494
  "[test.cpp:3]: (style) 'operator=' should either return reference to 'this' instance or be declared private and left unimplemented.\n" always "[test.cpp:3]: (style) 'operator=' should either return reference to 'this' instance or be declared private and left unimplemented.\n"
Line 1496
  "class A {\npublic:\n    A & operator=(const A &a) {\n        rand();\n        abort();\n    }\n};" always "class A {\npublic:\n    A & operator=(const A &a) {\n        rand();\n        abort();\n    }\n};"
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  1496 always 1496
Line 1504
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  1504 always 1504
  "[test.cpp:3]: (style) 'operator=' should either return reference to 'this' instance or be declared private and left unimplemented.\n" always "[test.cpp:3]: (style) 'operator=' should either return reference to 'this' instance or be declared private and left unimplemented.\n"
Line 1506
  "class A {\npublic:\n    A & operator=(const A &a);\n};\nA & A :: operator=(const A &a) { }" always "class A {\npublic:\n    A & operator=(const A &a);\n};\nA & A :: operator=(const A &a) { }"
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  1506 always 1506
Line 1512
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  1512 always 1512
  "[test.cpp:5]: (error) No 'return' statement in non-void function causes undefined behavior.\n" always "[test.cpp:5]: (error) No 'return' statement in non-void function causes undefined behavior.\n"
Line 1516
  "class UString {\npublic:\n    UString& assign( const char* c_str );\n    UString& operator=( const UString& s );\n};\nUString& UString::assign( const char* c_str ) {\n    std::string tmp( c_str );\n    return assign( tmp );\n}\nUString& UString::operator=( const UString& s ) {\n    return assign( s );\n}" always "class UString {\npublic:\n    UString& assign( const char* c_str );\n    UString& operator=( const UString& s );\n};\nUString& UString::assign( const char* c_str ) {\n    std::string tmp( c_str );\n    return assign( tmp );\n}\nUString& UString::operator=( const UString& s ) {\n    return assign( s );\n}"
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  1516 always 1516
Line 1532
  "class basic_fbstring {\n  basic_fbstring& operator=(int il) {\n    return assign();\n  }\n  basic_fbstring& assign() {\n    return replace();\n  }\n  basic_fbstring& replaceImplDiscr() {\n    return replace();\n  }\n  basic_fbstring& replace() {\n    return replaceImplDiscr();\n  }\n};" always "class basic_fbstring {\n  basic_fbstring& operator=(int il) {\n    return assign();\n  }\n  basic_fbstring& assign() {\n    return replace();\n  }\n  basic_fbstring& replaceImplDiscr() {\n    return replace();\n  }\n  basic_fbstring& replace() {\n    return replaceImplDiscr();\n  }\n};"
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  1532 always 1532
Line 1547
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  1547 always 1547
  "" always ""
Line 1554
  "" always ""
Line 1557
  & {lifetime[Address]=(settings1),!0}
  this always !0
Line 1558
  code possible {"class Foo\n{\npublic:\n    Foo& operator=(Foo* pOther);\n    Foo& operator=(Foo& other);\n};\nFoo& Foo::operator=(Foo* pOther)\n{\n    return *this;\n}\nFoo& Foo::operator=(Foo& other)\n{\n    return Foo::operator=(&other);\n}"@5,"class FMat\n{\npublic:\n    FMat& copy(const FMat& rhs);\n    FMat& operator=(const FMat& in);\n};\nFMat& FMat::copy(const FMat& rhs)\n{\n    return *this;\n}\nFMat& FMat::operator=(const FMat& in)\n{\n    return copy(in);\n}"@6,"class A\n{\npublic:\n    A & assign(const A & a)\n    {\n        return *this;\n    }\n    A & operator=(const A &a)\n    {\n        return assign(a);\n    }\n};"@7,"class A\n{\npublic:\n    A & operator=(const A &a)\n    {\n        delete [] data;\n        data = new char[strlen(a.data) + 1];\n        strcpy(data, a.data);\n        return *this;\n    }\nprivate:\n    char * data;\n};"@8,"class A\n{\npublic:\n    A & operator=(const A &a);\nprivate:\n    char * data;\n};\nA & A::operator=(const A &a)\n{\n    delete [] data;\n    data = new char[strlen(a.data) + 1];\n    strcpy(data, a.data);\n    return *this;\n};"@9,"class A\n{\npublic:\n    A & operator=(const A &a)\n    {\n        delete data;\n        data = new char;\n        *data  = *a.data;\n        return *this;\n    }\nprivate:\n    char * data;\n};"@10,"class A\n{\npublic:\n    A & operator=(const A &a);\nprivate:\n    char * data;\n};\nA & A::operator=(const A &a)\n{\n    delete data;\n    data = new char;\n    *data = *a.data;\n    return *this;\n};"@11,"class A\n{\npublic:\n    char *s;\n    A & operator=(const A &a)\n    {\n        if((&a!=this))\n        {\n            free(s);\n            s = strdup(a.s);\n        }\n        return *this;\n    }\n};"@12,"class A\n{\npublic:\n    char *s;\n    A & operator=(const A &a)\n    {\n        if((this!=&a))\n        {\n            free(s);\n            s = strdup(a.s);\n        }\n        return *this;\n    }\n};"@13,"class A\n{\npublic:\n    char *s;\n    A & operator=(const A &a)\n    {\n        if(!(&a==this))\n        {\n            free(s);\n            s = strdup(a.s);\n        }\n        return *this;\n    }\n};"@14}
Line 1559
  ( always {!<=-1,!>=2}
  file inconclusive {"cppcheck-2.8/test/testclass.cpp"@5,"cppcheck-2.8/test/testclass.cpp"@6,"cppcheck-2.8/test/testclass.cpp"@7,"cppcheck-2.8/test/testclass.cpp"@8,"cppcheck-2.8/test/testclass.cpp"@9,"cppcheck-2.8/test/testclass.cpp"@10,"cppcheck-2.8/test/testclass.cpp"@11,"cppcheck-2.8/test/testclass.cpp"@12,"cppcheck-2.8/test/testclass.cpp"@13,"cppcheck-2.8/test/testclass.cpp"@14}
  line inconclusive {2491@5,2472@6,2455@7,2387@8,2403@9,2420@10,2436@11,2092@12,2109@13,2126@14}
  "test.cpp" always "test.cpp"
Line 1562
  & {lifetime[Address]=(tokenizer),!0}
  & {lifetime[Address]=(settings1),!0}
  this always !0
Line 1568
  "class A\n{\npublic:\n    A & operator=(const A &a) { if (&a != this) { } return *this; }\n};" always "class A\n{\npublic:\n    A & operator=(const A &a) { if (&a != this) { } return *this; }\n};"
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  1568 always 1568
Line 1574
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  1574 always 1574
  "" always ""
Line 1577
  "class A\n{\npublic:\n    A & operator=(const A &a) { return *this; }\n};" always "class A\n{\npublic:\n    A & operator=(const A &a) { return *this; }\n};"
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  1577 always 1577
Line 1583
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  1583 always 1583
  "" always ""
Line 1586
  "class A\n{\npublic:\n    char *s;\n    A & operator=(const A &a)\n    {\n        if (&a != this)\n        {\n            free(s);\n            s = strdup(a.s);\n        }\n        return *this;\n    }\n};" always "class A\n{\npublic:\n    char *s;\n    A & operator=(const A &a)\n    {\n        if (&a != this)\n        {\n            free(s);\n            s = strdup(a.s);\n        }\n        return *this;\n    }\n};"
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  1586 always 1586
Line 1601
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  1601 always 1601
  "" always ""
Line 1604
  "class A\n{\npublic:\n    char *s;\n    A & operator=(const A &a)\n    {\n        free(s);\n        s = strdup(a.s);\n        return *this;\n    }\n};" always "class A\n{\npublic:\n    char *s;\n    A & operator=(const A &a)\n    {\n        free(s);\n        s = strdup(a.s);\n        return *this;\n    }\n};"
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  1604 always 1604
Line 1616
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  1616 always 1616
  "[test.cpp:5]: (warning) 'operator=' should check for assignment to self to avoid problems with dynamic memory.\n" always "[test.cpp:5]: (warning) 'operator=' should check for assignment to self to avoid problems with dynamic memory.\n"
Line 1619
  "class A\n{\npublic:\n    A & operator=(const A &);\n};\nA & A::operator=(const A &a) { if (&a != this) { } return *this; }" always "class A\n{\npublic:\n    A & operator=(const A &);\n};\nA & A::operator=(const A &a) { if (&a != this) { } return *this; }"
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  1619 always 1619
Line 1626
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  1626 always 1626
  "" always ""
Line 1629
  "class A\n{\npublic:\n    A & operator=(const A &);\n};\nA & A::operator=(const A &a) { return *this; }" always "class A\n{\npublic:\n    A & operator=(const A &);\n};\nA & A::operator=(const A &a) { return *this; }"
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  1629 always 1629
Line 1636
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  1636 always 1636
  "" always ""
Line 1639
  "class A\n{\npublic:\n    char *s;\n    A & operator=(const A &);\n};\nA & A::operator=(const A &a)\n{\n    if (&a != this)\n    {\n        free(s);\n        s = strdup(a.s);\n    }\n    return *this;\n}" always "class A\n{\npublic:\n    char *s;\n    A & operator=(const A &);\n};\nA & A::operator=(const A &a)\n{\n    if (&a != this)\n    {\n        free(s);\n        s = strdup(a.s);\n    }\n    return *this;\n}"
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  1639 always 1639
Line 1655
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  1655 always 1655
  "" always ""
Line 1658
  "class A\n{\npublic:\n    char *s;\n    A & operator=(const A &);\n};\nA & A::operator=(const A &a)\n{\n    if (&a == this)\n    {\n        free(s);\n        s = strdup(a.s);\n    }\n    return *this;\n}" always "class A\n{\npublic:\n    char *s;\n    A & operator=(const A &);\n};\nA & A::operator=(const A &a)\n{\n    if (&a == this)\n    {\n        free(s);\n        s = strdup(a.s);\n    }\n    return *this;\n}"
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  1658 always 1658
Line 1674
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  1674 always 1674
  "[test.cpp:7]: (warning) 'operator=' should check for assignment to self to avoid problems with dynamic memory.\n" always "[test.cpp:7]: (warning) 'operator=' should check for assignment to self to avoid problems with dynamic memory.\n"
Line 1677
  "class A\n{\npublic:\n    char *s;\n    A & operator=(const A &);\n};\nA & A::operator=(const A &a)\n{\n    if ((&a == this) == true)\n    {\n        free(s);\n        s = strdup(a.s);\n    }\n    return *this;\n}" always "class A\n{\npublic:\n    char *s;\n    A & operator=(const A &);\n};\nA & A::operator=(const A &a)\n{\n    if ((&a == this) == true)\n    {\n        free(s);\n        s = strdup(a.s);\n    }\n    return *this;\n}"
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  1677 always 1677
Line 1693
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  1693 always 1693
  "[test.cpp:7]: (warning) 'operator=' should check for assignment to self to avoid problems with dynamic memory.\n" always "[test.cpp:7]: (warning) 'operator=' should check for assignment to self to avoid problems with dynamic memory.\n"
Line 1696
  "class A\n{\npublic:\n    char *s;\n    A & operator=(const A &);\n};\nA & A::operator=(const A &a)\n{\n    if ((&a == this) != false)\n    {\n        free(s);\n        s = strdup(a.s);\n    }\n    return *this;\n}" always "class A\n{\npublic:\n    char *s;\n    A & operator=(const A &);\n};\nA & A::operator=(const A &a)\n{\n    if ((&a == this) != false)\n    {\n        free(s);\n        s = strdup(a.s);\n    }\n    return *this;\n}"
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  1696 always 1696
Line 1712
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  1712 always 1712
  "[test.cpp:7]: (warning) 'operator=' should check for assignment to self to avoid problems with dynamic memory.\n" always "[test.cpp:7]: (warning) 'operator=' should check for assignment to self to avoid problems with dynamic memory.\n"
Line 1715
  "class A\n{\npublic:\n    char *s;\n    A & operator=(const A &);\n};\nA & A::operator=(const A &a)\n{\n    if (!((&a == this) == false))\n    {\n        free(s);\n        s = strdup(a.s);\n    }\n    return *this;\n}" always "class A\n{\npublic:\n    char *s;\n    A & operator=(const A &);\n};\nA & A::operator=(const A &a)\n{\n    if (!((&a == this) == false))\n    {\n        free(s);\n        s = strdup(a.s);\n    }\n    return *this;\n}"
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  1715 always 1715
Line 1731
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  1731 always 1731
  "[test.cpp:7]: (warning) 'operator=' should check for assignment to self to avoid problems with dynamic memory.\n" always "[test.cpp:7]: (warning) 'operator=' should check for assignment to self to avoid problems with dynamic memory.\n"
Line 1734
  "class A\n{\npublic:\n    char *s;\n    A & operator=(const A &);\n};\nA & A::operator=(const A &a)\n{\n    if ((&a != this) == false)\n    {\n        free(s);\n        s = strdup(a.s);\n    }\n    return *this;\n}" always "class A\n{\npublic:\n    char *s;\n    A & operator=(const A &);\n};\nA & A::operator=(const A &a)\n{\n    if ((&a != this) == false)\n    {\n        free(s);\n        s = strdup(a.s);\n    }\n    return *this;\n}"
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  1734 always 1734
Line 1750
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  1750 always 1750
  "[test.cpp:7]: (warning) 'operator=' should check for assignment to self to avoid problems with dynamic memory.\n" always "[test.cpp:7]: (warning) 'operator=' should check for assignment to self to avoid problems with dynamic memory.\n"
Line 1753
  "class A\n{\npublic:\n    char *s;\n    A & operator=(const A &);\n};\nA & A::operator=(const A &a)\n{\n    if (&a != this)\n    {\n    }\n    else\n    {\n        free(s);\n        s = strdup(a.s);\n    }\n    return *this;\n}" always "class A\n{\npublic:\n    char *s;\n    A & operator=(const A &);\n};\nA & A::operator=(const A &a)\n{\n    if (&a != this)\n    {\n    }\n    else\n    {\n        free(s);\n        s = strdup(a.s);\n    }\n    return *this;\n}"
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  1753 always 1753
Line 1772
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  1772 always 1772
  "[test.cpp:7]: (warning) 'operator=' should check for assignment to self to avoid problems with dynamic memory.\n" always "[test.cpp:7]: (warning) 'operator=' should check for assignment to self to avoid problems with dynamic memory.\n"
Line 1775
  "class A\n{\npublic:\n    char *s;\n    A & operator=(const A &);\n};\nA & A::operator=(const A &a)\n{\n    if (&a != this)\n        free(s);\n    else\n    {\n        free(s);\n        s = strdup(a.s);\n    }\n    return *this;\n}" always "class A\n{\npublic:\n    char *s;\n    A & operator=(const A &);\n};\nA & A::operator=(const A &a)\n{\n    if (&a != this)\n        free(s);\n    else\n    {\n        free(s);\n        s = strdup(a.s);\n    }\n    return *this;\n}"
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  1775 always 1775
Line 1793
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  1793 always 1793
  "[test.cpp:7]: (warning) 'operator=' should check for assignment to self to avoid problems with dynamic memory.\n" always "[test.cpp:7]: (warning) 'operator=' should check for assignment to self to avoid problems with dynamic memory.\n"
Line 1797
  "class A\n{\npublic:\n    char *s;\n    A & operator=(const A &);\n};\nA & A::operator=(const A &a)\n{\n    free(s);\n    s = strdup(a.s);\n    return *this;\n}" always "class A\n{\npublic:\n    char *s;\n    A & operator=(const A &);\n};\nA & A::operator=(const A &a)\n{\n    free(s);\n    s = strdup(a.s);\n    return *this;\n}"
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  1797 always 1797
Line 1810
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  1810 always 1810
  "[test.cpp:7]: (warning) 'operator=' should check for assignment to self to avoid problems with dynamic memory.\n" always "[test.cpp:7]: (warning) 'operator=' should check for assignment to self to avoid problems with dynamic memory.\n"
Line 1813
  "const SubTree &SubTree::operator= (const SubTree &b)\n{\n    CodeTree *oldtree = tree;\n    tree = new CodeTree(*b.tree);\n    delete oldtree;\n    return *this;\n}\nconst SubTree &SubTree::operator= (const CodeTree &b)\n{\n    CodeTree *oldtree = tree;\n    tree = new CodeTree(b);\n    delete oldtree;\n    return *this;\n}" always "const SubTree &SubTree::operator= (const SubTree &b)\n{\n    CodeTree *oldtree = tree;\n    tree = new CodeTree(*b.tree);\n    delete oldtree;\n    return *this;\n}\nconst SubTree &SubTree::operator= (const CodeTree &b)\n{\n    CodeTree *oldtree = tree;\n    tree = new CodeTree(b);\n    delete oldtree;\n    return *this;\n}"
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  1813 always 1813
Line 1828
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  1828 always 1828
  "" always ""
Line 1834
  "class A\n{\npublic:\n    class B\n    {\n    public:\n        B & operator=(const B &b) { if (&b != this) { } return *this; }\n    };\n};" always "class A\n{\npublic:\n    class B\n    {\n    public:\n        B & operator=(const B &b) { if (&b != this) { } return *this; }\n    };\n};"
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  1834 always 1834
Line 1844
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  1844 always 1844
  "" always ""
Line 1847
  "class A\n{\npublic:\n    class B\n    {\n    public:\n        B & operator=(const B &b) { return *this; }\n    };\n};" always "class A\n{\npublic:\n    class B\n    {\n    public:\n        B & operator=(const B &b) { return *this; }\n    };\n};"
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  1847 always 1847
Line 1857
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  1857 always 1857
  "" always ""
Line 1860
  "class A\n{\npublic:\n    class B\n    {\n    public:\n        char *s;\n        B & operator=(const B &b)\n        {\n            if (&b != this)\n            {\n            }\n            return *this;\n        }\n    };\n};" always "class A\n{\npublic:\n    class B\n    {\n    public:\n        char *s;\n        B & operator=(const B &b)\n        {\n            if (&b != this)\n            {\n            }\n            return *this;\n        }\n    };\n};"
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  1860 always 1860
Line 1877
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  1877 always 1877
  "" always ""
Line 1880
  "class A\n{\npublic:\n    class B\n    {\n    public:\n        char *s;\n        B & operator=(const B &b)\n        {\n            free(s);\n            s = strdup(b.s);\n            return *this;\n        }\n    };\n};" always "class A\n{\npublic:\n    class B\n    {\n    public:\n        char *s;\n        B & operator=(const B &b)\n        {\n            free(s);\n            s = strdup(b.s);\n            return *this;\n        }\n    };\n};"
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  1880 always 1880
Line 1896
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  1896 always 1896
  "[test.cpp:8]: (warning) 'operator=' should check for assignment to self to avoid problems with dynamic memory.\n" always "[test.cpp:8]: (warning) 'operator=' should check for assignment to self to avoid problems with dynamic memory.\n"
Line 1899
  "class A\n{\npublic:\n    class B\n    {\n    public:\n        B & operator=(const B &);\n    };\n};\nA::B & A::B::operator=(const A::B &b) { if (&b != this) { } return *this; }" always "class A\n{\npublic:\n    class B\n    {\n    public:\n        B & operator=(const B &);\n    };\n};\nA::B & A::B::operator=(const A::B &b) { if (&b != this) { } return *this; }"
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  1899 always 1899
Line 1910
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  1910 always 1910
  "" always ""
Line 1913
  "class A\n{\npublic:\n    class B\n    {\n    public:\n        B & operator=(const B &);\n    };\n};\nA::B & A::B::operator=(const A::B &b) { return *this; }" always "class A\n{\npublic:\n    class B\n    {\n    public:\n        B & operator=(const B &);\n    };\n};\nA::B & A::B::operator=(const A::B &b) { return *this; }"
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  1913 always 1913
Line 1924
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  1924 always 1924
  "" always ""
Line 1927
  "class A\n{\npublic:\n    class B\n    {\n    public:\n        char * s;\n        B & operator=(const B &);\n    };\n};\nA::B & A::B::operator=(const A::B &b)\n{\n    if (&b != this)\n    {\n        free(s);\n        s = strdup(b.s);\n    }\n    return *this;\n }" always "class A\n{\npublic:\n    class B\n    {\n    public:\n        char * s;\n        B & operator=(const B &);\n    };\n};\nA::B & A::B::operator=(const A::B &b)\n{\n    if (&b != this)\n    {\n        free(s);\n        s = strdup(b.s);\n    }\n    return *this;\n }"
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  1927 always 1927
Line 1947
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  1947 always 1947
  "" always ""
Line 1950
  "class A\n{\npublic:\n    class B\n    {\n    public:\n        char * s;\n        B & operator=(const B &);\n    };\n};\nA::B & A::B::operator=(const A::B &b)\n{\n    free(s);\n    s = strdup(b.s);\n    return *this;\n }" always "class A\n{\npublic:\n    class B\n    {\n    public:\n        char * s;\n        B & operator=(const B &);\n    };\n};\nA::B & A::B::operator=(const A::B &b)\n{\n    free(s);\n    s = strdup(b.s);\n    return *this;\n }"
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  1950 always 1950
Line 1967
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  1967 always 1967
  "[test.cpp:11]: (warning) 'operator=' should check for assignment to self to avoid problems with dynamic memory.\n" always "[test.cpp:11]: (warning) 'operator=' should check for assignment to self to avoid problems with dynamic memory.\n"
Line 1972
  "class A : public B, public C\n{\npublic:\n    A & operator=(const A &a) { return *this; }\n};" always "class A : public B, public C\n{\npublic:\n    A & operator=(const A &a) { return *this; }\n};"
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  1972 always 1972
Line 1978
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  1978 always 1978
  "" always ""
Line 1981
  "class A : public B, public C\n{\npublic:\n    char *s;\n    A & operator=(const A &a)\n    {\n        free(s);\n        s = strdup(a.s);\n        return *this;\n    }\n};" always "class A : public B, public C\n{\npublic:\n    char *s;\n    A & operator=(const A &a)\n    {\n        free(s);\n        s = strdup(a.s);\n        return *this;\n    }\n};"
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  1981 always 1981
Line 1993
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  1993 always 1993
  "" always ""
Line 1996
  "class A : public B, public C\n{\npublic:\n    A & operator=(const A &);\n};\nA & A::operator=(const A &a) { return *this; }" always "class A : public B, public C\n{\npublic:\n    A & operator=(const A &);\n};\nA & A::operator=(const A &a) { return *this; }"
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  1996 always 1996
Line 2003
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  2003 always 2003
  "" always ""
Line 2006
  "class A : public B, public C\n{\npublic:\n    char *s;\n    A & operator=(const A &);\n};\nA & A::operator=(const A &a)\n{\n    free(s);\n    s = strdup(a.s);\n    return *this;\n}" always "class A : public B, public C\n{\npublic:\n    char *s;\n    A & operator=(const A &);\n};\nA & A::operator=(const A &a)\n{\n    free(s);\n    s = strdup(a.s);\n    return *this;\n}"
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  2006 always 2006
Line 2019
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  2019 always 2019
  "" always ""
Line 2024
  "class A\n{\npublic:\n    class B : public C, public D\n    {\n    public:\n        B & operator=(const B &b) { return *this; }\n    };\n};" always "class A\n{\npublic:\n    class B : public C, public D\n    {\n    public:\n        B & operator=(const B &b) { return *this; }\n    };\n};"
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  2024 always 2024
Line 2034
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  2034 always 2034
  "" always ""
Line 2037
  "class A\n{\npublic:\n    class B : public C, public D\n    {\n    public:\n        char * s;\n        B & operator=(const B &b)\n        {\n            free(s);\n            s = strdup(b.s);\n            return *this;\n        }\n    };\n};" always "class A\n{\npublic:\n    class B : public C, public D\n    {\n    public:\n        char * s;\n        B & operator=(const B &b)\n        {\n            free(s);\n            s = strdup(b.s);\n            return *this;\n        }\n    };\n};"
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  2037 always 2037
Line 2053
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  2053 always 2053
  "" always ""
Line 2056
  "class A\n{\npublic:\n    class B : public C, public D\n    {\n    public:\n        B & operator=(const B &);\n    };\n};\nA::B & A::B::operator=(const A::B &b) { return *this; }" always "class A\n{\npublic:\n    class B : public C, public D\n    {\n    public:\n        B & operator=(const B &);\n    };\n};\nA::B & A::B::operator=(const A::B &b) { return *this; }"
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  2056 always 2056
Line 2067
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  2067 always 2067
  "" always ""
Line 2070
  "class A\n{\npublic:\n    class B : public C, public D\n    {\n    public:\n        char * s;\n        B & operator=(const B &);\n    };\n};\nA::B & A::B::operator=(const A::B &b)\n{\n    free(s);\n    s = strdup(b.s);\n    return *this;\n}" always "class A\n{\npublic:\n    class B : public C, public D\n    {\n    public:\n        char * s;\n        B & operator=(const B &);\n    };\n};\nA::B & A::B::operator=(const A::B &b)\n{\n    free(s);\n    s = strdup(b.s);\n    return *this;\n}"
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  2070 always 2070
Line 2087
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  2087 always 2087
  "" always ""
Line 2092
  "class A\n{\npublic:\n    char *s;\n    A & operator=(const A &a)\n    {\n        if((&a!=this))\n        {\n            free(s);\n            s = strdup(a.s);\n        }\n        return *this;\n    }\n};" always "class A\n{\npublic:\n    char *s;\n    A & operator=(const A &a)\n    {\n        if((&a!=this))\n        {\n            free(s);\n            s = strdup(a.s);\n        }\n        return *this;\n    }\n};"
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  2092 always 2092
Line 2107
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  2107 always 2107
  "" always ""
Line 2109
  "class A\n{\npublic:\n    char *s;\n    A & operator=(const A &a)\n    {\n        if((this!=&a))\n        {\n            free(s);\n            s = strdup(a.s);\n        }\n        return *this;\n    }\n};" always "class A\n{\npublic:\n    char *s;\n    A & operator=(const A &a)\n    {\n        if((this!=&a))\n        {\n            free(s);\n            s = strdup(a.s);\n        }\n        return *this;\n    }\n};"
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  2109 always 2109
Line 2124
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  2124 always 2124
  "" always ""
Line 2126
  "class A\n{\npublic:\n    char *s;\n    A & operator=(const A &a)\n    {\n        if(!(&a==this))\n        {\n            free(s);\n            s = strdup(a.s);\n        }\n        return *this;\n    }\n};" always "class A\n{\npublic:\n    char *s;\n    A & operator=(const A &a)\n    {\n        if(!(&a==this))\n        {\n            free(s);\n            s = strdup(a.s);\n        }\n        return *this;\n    }\n};"
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  2126 always 2126
Line 2141
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  2141 always 2141
  "" always ""
Line 2143
  "class A\n{\npublic:\n    char *s;\n    A & operator=(const A &a)\n    {\n        if(!(this==&a))\n        {\n            free(s);\n            s = strdup(a.s);\n        }\n        return *this;\n    }\n};" always "class A\n{\npublic:\n    char *s;\n    A & operator=(const A &a)\n    {\n        if(!(this==&a))\n        {\n            free(s);\n            s = strdup(a.s);\n        }\n        return *this;\n    }\n};"
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  2143 always 2143
Line 2158
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  2158 always 2158
  "" always ""
Line 2160
  "class A\n{\npublic:\n    char *s;\n    A & operator=(const A &a)\n    {\n        if(false==(&a==this))\n        {\n            free(s);\n            s = strdup(a.s);\n        }\n        return *this;\n    }\n};" always "class A\n{\npublic:\n    char *s;\n    A & operator=(const A &a)\n    {\n        if(false==(&a==this))\n        {\n            free(s);\n            s = strdup(a.s);\n        }\n        return *this;\n    }\n};"
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  2160 always 2160
Line 2175
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  2175 always 2175
  "" always ""
Line 2177
  "class A\n{\npublic:\n    char *s;\n    A & operator=(const A &a)\n    {\n        if(false==(this==&a))\n        {\n            free(s);\n            s = strdup(a.s);\n        }\n        return *this;\n    }\n};" always "class A\n{\npublic:\n    char *s;\n    A & operator=(const A &a)\n    {\n        if(false==(this==&a))\n        {\n            free(s);\n            s = strdup(a.s);\n        }\n        return *this;\n    }\n};"
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  2177 always 2177
Line 2192
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  2192 always 2192
  "" always ""
Line 2194
  "class A\n{\npublic:\n    char *s;\n    A & operator=(const A &a)\n    {\n        if(true!=(&a==this))\n        {\n            free(s);\n            s = strdup(a.s);\n        }\n        return *this;\n    }\n};" always "class A\n{\npublic:\n    char *s;\n    A & operator=(const A &a)\n    {\n        if(true!=(&a==this))\n        {\n            free(s);\n            s = strdup(a.s);\n        }\n        return *this;\n    }\n};"
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  2194 always 2194
Line 2209
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  2209 always 2209
  "" always ""
Line 2211
  "class A\n{\npublic:\n    char *s;\n    A & operator=(const A &a)\n    {\n        if(true!=(this==&a))\n        {\n            free(s);\n            s = strdup(a.s);\n        }\n        return *this;\n    }\n};" always "class A\n{\npublic:\n    char *s;\n    A & operator=(const A &a)\n    {\n        if(true!=(this==&a))\n        {\n            free(s);\n            s = strdup(a.s);\n        }\n        return *this;\n    }\n};"
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  2211 always 2211
Line 2226
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  2226 always 2226
  "" always ""
Line 2228
  "class A\n{\npublic:\n    char *s;\n    A & operator=(const A &a);\n};\nA & A::operator=(const A &a)\n{\n    if((&a!=this))\n    {\n        free(s);\n        s = strdup(a.s);\n    }\n    return *this;\n};" always "class A\n{\npublic:\n    char *s;\n    A & operator=(const A &a);\n};\nA & A::operator=(const A &a)\n{\n    if((&a!=this))\n    {\n        free(s);\n        s = strdup(a.s);\n    }\n    return *this;\n};"
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  2228 always 2228
Line 2244
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  2244 always 2244
  "" always ""
Line 2246
  "class A\n{\npublic:\n    char *s;\n    A & operator=(const A &a);\n};\nA & A::operator=(const A &a)\n{\n    if((this!=&a))\n    {\n        free(s);\n        s = strdup(a.s);\n    }\n    return *this;\n};" always "class A\n{\npublic:\n    char *s;\n    A & operator=(const A &a);\n};\nA & A::operator=(const A &a)\n{\n    if((this!=&a))\n    {\n        free(s);\n        s = strdup(a.s);\n    }\n    return *this;\n};"
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  2246 always 2246
Line 2262
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  2262 always 2262
  "" always ""
Line 2264
  "class A\n{\npublic:\n    char *s;\n    A & operator=(const A &a);\n};\nA & A::operator=(const A &a)\n{\n    if(!(&a==this))\n    {\n        free(s);\n        s = strdup(a.s);\n    }\n    return *this;\n};" always "class A\n{\npublic:\n    char *s;\n    A & operator=(const A &a);\n};\nA & A::operator=(const A &a)\n{\n    if(!(&a==this))\n    {\n        free(s);\n        s = strdup(a.s);\n    }\n    return *this;\n};"
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  2264 always 2264
Line 2280
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  2280 always 2280
  "" always ""
Line 2282
  "class A\n{\npublic:\n    char *s;\n    A & operator=(const A &a);\n};\nA & A::operator=(const A &a)\n{\n    if(!(this==&a))\n    {\n        free(s);\n        s = strdup(a.s);\n    }\n    return *this;\n};" always "class A\n{\npublic:\n    char *s;\n    A & operator=(const A &a);\n};\nA & A::operator=(const A &a)\n{\n    if(!(this==&a))\n    {\n        free(s);\n        s = strdup(a.s);\n    }\n    return *this;\n};"
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  2282 always 2282
Line 2298
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  2298 always 2298
  "" always ""
Line 2300
  "class A\n{\npublic:\n    char *s;\n    A & operator=(const A &a);\n};\nA & A::operator=(const A &a)\n{\n    if(false==(&a==this))\n    {\n        free(s);\n        s = strdup(a.s);\n    }\n    return *this;\n};" always "class A\n{\npublic:\n    char *s;\n    A & operator=(const A &a);\n};\nA & A::operator=(const A &a)\n{\n    if(false==(&a==this))\n    {\n        free(s);\n        s = strdup(a.s);\n    }\n    return *this;\n};"
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  2300 always 2300
Line 2316
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  2316 always 2316
  "" always ""
Line 2318
  "class A\n{\npublic:\n    char *s;\n    A & operator=(const A &a);\n};\nA & A::operator=(const A &a)\n{\n    if(false==(this==&a))\n    {\n        free(s);\n        s = strdup(a.s);\n    }\n    return *this;\n};" always "class A\n{\npublic:\n    char *s;\n    A & operator=(const A &a);\n};\nA & A::operator=(const A &a)\n{\n    if(false==(this==&a))\n    {\n        free(s);\n        s = strdup(a.s);\n    }\n    return *this;\n};"
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  2318 always 2318
Line 2334
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  2334 always 2334
  "" always ""
Line 2336
  "class A\n{\npublic:\n    char *s;\n    A & operator=(const A &a);\n};\nA & A::operator=(const A &a)\n{\n    if(true!=(&a==this))\n    {\n        free(s);\n        s = strdup(a.s);\n    }\n    return *this;\n};" always "class A\n{\npublic:\n    char *s;\n    A & operator=(const A &a);\n};\nA & A::operator=(const A &a)\n{\n    if(true!=(&a==this))\n    {\n        free(s);\n        s = strdup(a.s);\n    }\n    return *this;\n};"
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  2336 always 2336
Line 2352
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  2352 always 2352
  "" always ""
Line 2354
  "class A\n{\npublic:\n    char *s;\n    A & operator=(const A &a);\n};\nA & A::operator=(const A &a)\n{\n    if(true!=(this==&a))\n    {\n        free(s);\n        s = strdup(a.s);\n    }\n    return *this;\n};" always "class A\n{\npublic:\n    char *s;\n    A & operator=(const A &a);\n};\nA & A::operator=(const A &a)\n{\n    if(true!=(this==&a))\n    {\n        free(s);\n        s = strdup(a.s);\n    }\n    return *this;\n};"
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  2354 always 2354
Line 2370
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  2370 always 2370
  "" always ""
Line 2372
  "struct A {\n    char *s;\n    A& operator=(const B &b);\n};\nA& A::operator=(const B &b) {\n    free(s);\n    s = strdup(a.s);\n    return *this;\n};" always "struct A {\n    char *s;\n    A& operator=(const B &b);\n};\nA& A::operator=(const B &b) {\n    free(s);\n    s = strdup(a.s);\n    return *this;\n};"
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  2372 always 2372
Line 2382
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  2382 always 2382
  "" always ""
Line 2387
  "class A\n{\npublic:\n    A & operator=(const A &a)\n    {\n        delete [] data;\n        data = new char[strlen(a.data) + 1];\n        strcpy(data, a.data);\n        return *this;\n    }\nprivate:\n    char * data;\n};" always "class A\n{\npublic:\n    A & operator=(const A &a)\n    {\n        delete [] data;\n        data = new char[strlen(a.data) + 1];\n        strcpy(data, a.data);\n        return *this;\n    }\nprivate:\n    char * data;\n};"
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  2387 always 2387
Line 2401
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  2401 always 2401
  "[test.cpp:4]: (warning) 'operator=' should check for assignment to self to avoid problems with dynamic memory.\n" always "[test.cpp:4]: (warning) 'operator=' should check for assignment to self to avoid problems with dynamic memory.\n"
Line 2403
  "class A\n{\npublic:\n    A & operator=(const A &a);\nprivate:\n    char * data;\n};\nA & A::operator=(const A &a)\n{\n    delete [] data;\n    data = new char[strlen(a.data) + 1];\n    strcpy(data, a.data);\n    return *this;\n};" always "class A\n{\npublic:\n    A & operator=(const A &a);\nprivate:\n    char * data;\n};\nA & A::operator=(const A &a)\n{\n    delete [] data;\n    data = new char[strlen(a.data) + 1];\n    strcpy(data, a.data);\n    return *this;\n};"
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  2403 always 2403
Line 2418
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  2418 always 2418
  "[test.cpp:8]: (warning) 'operator=' should check for assignment to self to avoid problems with dynamic memory.\n" always "[test.cpp:8]: (warning) 'operator=' should check for assignment to self to avoid problems with dynamic memory.\n"
Line 2420
  "class A\n{\npublic:\n    A & operator=(const A &a)\n    {\n        delete data;\n        data = new char;\n        *data  = *a.data;\n        return *this;\n    }\nprivate:\n    char * data;\n};" always "class A\n{\npublic:\n    A & operator=(const A &a)\n    {\n        delete data;\n        data = new char;\n        *data  = *a.data;\n        return *this;\n    }\nprivate:\n    char * data;\n};"
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  2420 always 2420
Line 2434
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  2434 always 2434
  "[test.cpp:4]: (warning) 'operator=' should check for assignment to self to avoid problems with dynamic memory.\n" always "[test.cpp:4]: (warning) 'operator=' should check for assignment to self to avoid problems with dynamic memory.\n"
Line 2436
  "class A\n{\npublic:\n    A & operator=(const A &a);\nprivate:\n    char * data;\n};\nA & A::operator=(const A &a)\n{\n    delete data;\n    data = new char;\n    *data = *a.data;\n    return *this;\n};" always "class A\n{\npublic:\n    A & operator=(const A &a);\nprivate:\n    char * data;\n};\nA & A::operator=(const A &a)\n{\n    delete data;\n    data = new char;\n    *data = *a.data;\n    return *this;\n};"
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  2436 always 2436
Line 2451
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  2451 always 2451
  "[test.cpp:8]: (warning) 'operator=' should check for assignment to self to avoid problems with dynamic memory.\n" always "[test.cpp:8]: (warning) 'operator=' should check for assignment to self to avoid problems with dynamic memory.\n"
Line 2455
  "class A\n{\npublic:\n    A & assign(const A & a)\n    {\n        return *this;\n    }\n    A & operator=(const A &a)\n    {\n        return assign(a);\n    }\n};" always "class A\n{\npublic:\n    A & assign(const A & a)\n    {\n        return *this;\n    }\n    A & operator=(const A &a)\n    {\n        return assign(a);\n    }\n};"
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  2455 always 2455
Line 2468
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  2468 always 2468
  "" always ""
Line 2472
  "class FMat\n{\npublic:\n    FMat& copy(const FMat& rhs);\n    FMat& operator=(const FMat& in);\n};\nFMat& FMat::copy(const FMat& rhs)\n{\n    return *this;\n}\nFMat& FMat::operator=(const FMat& in)\n{\n    return copy(in);\n}" always "class FMat\n{\npublic:\n    FMat& copy(const FMat& rhs);\n    FMat& operator=(const FMat& in);\n};\nFMat& FMat::copy(const FMat& rhs)\n{\n    return *this;\n}\nFMat& FMat::operator=(const FMat& in)\n{\n    return copy(in);\n}"
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  2472 always 2472
Line 2487
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  2487 always 2487
  "" always ""
Line 2491
  "class Foo\n{\npublic:\n    Foo& operator=(Foo* pOther);\n    Foo& operator=(Foo& other);\n};\nFoo& Foo::operator=(Foo* pOther)\n{\n    return *this;\n}\nFoo& Foo::operator=(Foo& other)\n{\n    return Foo::operator=(&other);\n}" always "class Foo\n{\npublic:\n    Foo& operator=(Foo* pOther);\n    Foo& operator=(Foo& other);\n};\nFoo& Foo::operator=(Foo* pOther)\n{\n    return *this;\n}\nFoo& Foo::operator=(Foo& other)\n{\n    return Foo::operator=(&other);\n}"
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  2491 always 2491
Line 2506
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  2506 always 2506
  "" always ""
Line 2511
  , always 0
  inconclusive always {!<=-1,!>=2}
  = always 0
  false always 0
Line 2513
  "" always ""
Line 2515
  inconclusive {!<=-1,!>=2,1@235}
Line 2519
  & {lifetime[Address]=(settings0),!0}
  this always !0
Line 2520
  code {"class Base {\npublic:\n    ~Base(){}\n    virtual void foo(){}\n};\n"@235,"class Base {\npublic:\n    ~Base(){}\n    virtual void foo(){}\n};\nclass Derived : public Base {\npublic:\n    ~Derived() { bar(); }\n};\nvoid foo() {\n    Base * base = new Derived();\n    delete base;\n}\n"@236,"class Base {\npublic:\n    virtual void foo(){}\nprotected:\n    ~Base(){}\n};\n"@237,"class C {\nprivate:\n    C();\n    virtual ~C();\n};\n"@238,"template <typename T> class A\n{\n public:\n virtual ~A(){}\n};\ntemplate <typename T> class AA\n{\n public:\n ~AA(){}\n};\nclass B : public A<int>, public AA<double>\n{\n public:\n ~B(){int a;}\n};\n\nAA<double> *p = new B; delete p;"@239,"class Base\n{\npublic:\nvirtual ~Base() {}\n};\nclass A : private Base\n{\npublic:\n    ~A() { }\n};\n\nclass B : public A\n{\npublic:\n    ~B() { int a; }\n};"@240,"struct Base\n{\nvirtual ~Base() {}\n};\nclass A : public Base\n{\n};\n\nclass B : public A\n{\npublic:\n    ~B() { int a; }\n};"@241,"class A : private Base\n{\npublic:\n    ~A() { }\n};\n\nclass B : public A\n{\npublic:\n    ~B() { int a; }\n};"@242,"class Base2\n{\nvirtual ~Base2() {}\n};\nclass Base : public Base2\n{\n};\nclass A : private Base\n{\npublic:\n    ~A() { }\n};\n\nclass B : public A\n{\npublic:\n    ~B() { int a; }\n};"@243,"class Base\n{\npublic:\n    ~Base() {}\n};\nclass A : private Base\n{\npublic:\n    ~A() { }\n};\n\nclass B : public A\n{\npublic:\n    ~B() { int a; }\n};"@244}
Line 2521
  ( always {!<=-1,!>=2}
  file inconclusive {"cppcheck-2.8/test/testclass.cpp"@235,"cppcheck-2.8/test/testclass.cpp"@236,"cppcheck-2.8/test/testclass.cpp"@237,"cppcheck-2.8/test/testclass.cpp"@238,"cppcheck-2.8/test/testclass.cpp"@239,"cppcheck-2.8/test/testclass.cpp"@240,"cppcheck-2.8/test/testclass.cpp"@241,"cppcheck-2.8/test/testclass.cpp"@242,"cppcheck-2.8/test/testclass.cpp"@243,"cppcheck-2.8/test/testclass.cpp"@244}
  line inconclusive {2787@235,2794@236,2810@237,2818@238,2766@239,2673@240,2694@241,2710@242,2724@243,2745@244}
  "test.cpp" always "test.cpp"
Line 2524
  & {lifetime[Address]=(tokenizer),!0}
  & {lifetime[Address]=(settings0),!0}
  this always !0
Line 2531
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  2531 always 2531
  "class Derived : public Base { };\nBase *base = new Derived;\ndelete base;" always "class Derived : public Base { };\nBase *base = new Derived;\ndelete base;"
Line 2534
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  2534 always 2534
  "" always ""
Line 2536
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  2536 always 2536
  "class Derived : Base { };\nBase *base = new Derived;\ndelete base;" always "class Derived : Base { };\nBase *base = new Derived;\ndelete base;"
Line 2539
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  2539 always 2539
  "" always ""
Line 2545
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  2545 always 2545
  "class Base { };\nclass Derived : public Base { public: ~Derived() { (void)11; } };Base *base = new Derived;\ndelete base;" always "class Base { };\nclass Derived : public Base { public: ~Derived() { (void)11; } };Base *base = new Derived;\ndelete base;"
Line 2549
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  2549 always 2549
  "[test.cpp:1]: (error) Class 'Base' which is inherited by class 'Derived' does not have a virtual destructor.\n" always "[test.cpp:1]: (error) Class 'Base' which is inherited by class 'Derived' does not have a virtual destructor.\n"
Line 2551
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  2551 always 2551
  "class Base { };\nclass Derived : protected Base { public: ~Derived() { (void)11; } };Base *base = new Derived;\ndelete base;" always "class Base { };\nclass Derived : protected Base { public: ~Derived() { (void)11; } };Base *base = new Derived;\ndelete base;"
Line 2555
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  2555 always 2555
  "[test.cpp:1]: (error) Class 'Base' which is inherited by class 'Derived' does not have a virtual destructor.\n" always "[test.cpp:1]: (error) Class 'Base' which is inherited by class 'Derived' does not have a virtual destructor.\n"
Line 2557
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  2557 always 2557
  "class Base { };\nclass Derived : private Base { public: ~Derived() { (void)11; } };Base *base = new Derived;\ndelete base;" always "class Base { };\nclass Derived : private Base { public: ~Derived() { (void)11; } };Base *base = new Derived;\ndelete base;"
Line 2561
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  2561 always 2561
  "" always ""
Line 2563
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  2563 always 2563
  "class Base { };\nclass Derived : Base { public: ~Derived() { (void)11; } };Base *base = new Derived;\ndelete base;" always "class Base { };\nclass Derived : Base { public: ~Derived() { (void)11; } };Base *base = new Derived;\ndelete base;"
Line 2567
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  2567 always 2567
  "" always ""
Line 2570
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  2570 always 2570
  "struct A\n{\n    A()  { cout << \"A is constructing\\n\"; }\n    ~A() { cout << \"A is destructing\\n\"; }\n};\n \nstruct Base {};\n \nstruct Derived : Base\n{\n    A a;\n};\n \nint main(void)\n{\n    Base* p = new Derived();\n    delete p;\n}" always "struct A\n{\n    A()  { cout << \"A is constructing\\n\"; }\n    ~A() { cout << \"A is destructing\\n\"; }\n};\n \nstruct Base {};\n \nstruct Derived : Base\n{\n    A a;\n};\n \nint main(void)\n{\n    Base* p = new Derived();\n    delete p;\n}"
Line 2588
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  2588 always 2588
  "[test.cpp:7]: (error) Class 'Base' which is inherited by class 'Derived' does not have a virtual destructor.\n" always "[test.cpp:7]: (error) Class 'Base' which is inherited by class 'Derived' does not have a virtual destructor.\n"
Line 2594
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  2594 always 2594
  "class Base { public: ~Base(); };\nclass Derived : public Base { public: ~Derived() { (void)11; } };Base *base = new Derived;\ndelete base;" always "class Base { public: ~Base(); };\nclass Derived : public Base { public: ~Derived() { (void)11; } };Base *base = new Derived;\ndelete base;"
Line 2598
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  2598 always 2598
  "[test.cpp:1]: (error) Class 'Base' which is inherited by class 'Derived' does not have a virtual destructor.\n" always "[test.cpp:1]: (error) Class 'Base' which is inherited by class 'Derived' does not have a virtual destructor.\n"
Line 2600
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  2600 always 2600
  "class Base { public: ~Base(); };\nclass Derived : protected Base { public: ~Derived() { (void)11; } };Base *base = new Derived;\ndelete base;" always "class Base { public: ~Base(); };\nclass Derived : protected Base { public: ~Derived() { (void)11; } };Base *base = new Derived;\ndelete base;"
Line 2604
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  2604 always 2604
  "[test.cpp:1]: (error) Class 'Base' which is inherited by class 'Derived' does not have a virtual destructor.\n" always "[test.cpp:1]: (error) Class 'Base' which is inherited by class 'Derived' does not have a virtual destructor.\n"
Line 2606
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  2606 always 2606
  "class Base { public: ~Base(); };\nclass Derived : private Fred, public Base { public: ~Derived() { (void)11; } };Base *base = new Derived;\ndelete base;" always "class Base { public: ~Base(); };\nclass Derived : private Fred, public Base { public: ~Derived() { (void)11; } };Base *base = new Derived;\ndelete base;"
Line 2610
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  2610 always 2610
  "[test.cpp:1]: (error) Class 'Base' which is inherited by class 'Derived' does not have a virtual destructor.\n" always "[test.cpp:1]: (error) Class 'Base' which is inherited by class 'Derived' does not have a virtual destructor.\n"
Line 2616
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  2616 always 2616
  "class Base { public: ~Base(); };\nclass Derived : public Base { };Base *base = new Derived;\ndelete base;" always "class Base { public: ~Base(); };\nclass Derived : public Base { };Base *base = new Derived;\ndelete base;"
Line 2620
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  2620 always 2620
  "[test.cpp:1]: (error) Class 'Base' which is inherited by class 'Derived' does not have a virtual destructor.\n" always "[test.cpp:1]: (error) Class 'Base' which is inherited by class 'Derived' does not have a virtual destructor.\n"
Line 2622
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  2622 always 2622
  "class Base { public: ~Base(); };\nclass Derived : private Fred, public Base { };Base *base = new Derived;\ndelete base;" always "class Base { public: ~Base(); };\nclass Derived : private Fred, public Base { };Base *base = new Derived;\ndelete base;"
Line 2626
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  2626 always 2626
  "[test.cpp:1]: (error) Class 'Base' which is inherited by class 'Derived' does not have a virtual destructor.\n" always "[test.cpp:1]: (error) Class 'Base' which is inherited by class 'Derived' does not have a virtual destructor.\n"
Line 2632
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  2632 always 2632
  "class Base { public: ~Base(); };\nclass Derived : public Base { public: ~Derived() {} };Base *base = new Derived;\ndelete base;" always "class Base { public: ~Base(); };\nclass Derived : public Base { public: ~Derived() {} };Base *base = new Derived;\ndelete base;"
Line 2636
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  2636 always 2636
  "[test.cpp:1]: (error) Class 'Base' which is inherited by class 'Derived' does not have a virtual destructor.\n" always "[test.cpp:1]: (error) Class 'Base' which is inherited by class 'Derived' does not have a virtual destructor.\n"
Line 2638
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  2638 always 2638
  "class Base { public: ~Base(); };\nclass Derived : public Base { public: ~Derived(); }; Derived::~Derived() {}Base *base = new Derived;\ndelete base;" always "class Base { public: ~Base(); };\nclass Derived : public Base { public: ~Derived(); }; Derived::~Derived() {}Base *base = new Derived;\ndelete base;"
Line 2642
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  2642 always 2642
  "[test.cpp:1]: (error) Class 'Base' which is inherited by class 'Derived' does not have a virtual destructor.\n" always "[test.cpp:1]: (error) Class 'Base' which is inherited by class 'Derived' does not have a virtual destructor.\n"
Line 2649
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  2649 always 2649
  "class Base { public: ~Base(); };\nclass Derived : public Base { public: ~Derived() { (void)11; } };" always "class Base { public: ~Base(); };\nclass Derived : public Base { public: ~Derived() { (void)11; } };"
Line 2651
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  2651 always 2651
  "" always ""
Line 2657
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  2657 always 2657
  "class A\n{\nprotected:\n    ~A() { }\n};\n\nclass B : public A\n{\npublic:\n    ~B() { int a; }\n};" always "class A\n{\nprotected:\n    ~A() { }\n};\n\nclass B : public A\n{\npublic:\n    ~B() { int a; }\n};"
Line 2668
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  2668 always 2668
  "" always ""
Line 2673
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  2673 always 2673
  "class Base\n{\npublic:\nvirtual ~Base() {}\n};\nclass A : private Base\n{\npublic:\n    ~A() { }\n};\n\nclass B : public A\n{\npublic:\n    ~B() { int a; }\n};" always "class Base\n{\npublic:\nvirtual ~Base() {}\n};\nclass A : private Base\n{\npublic:\n    ~A() { }\n};\n\nclass B : public A\n{\npublic:\n    ~B() { int a; }\n};"
Line 2689
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  2689 always 2689
  "" always ""
Line 2694
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  2694 always 2694
  "struct Base\n{\nvirtual ~Base() {}\n};\nclass A : public Base\n{\n};\n\nclass B : public A\n{\npublic:\n    ~B() { int a; }\n};" always "struct Base\n{\nvirtual ~Base() {}\n};\nclass A : public Base\n{\n};\n\nclass B : public A\n{\npublic:\n    ~B() { int a; }\n};"
Line 2707
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  2707 always 2707
  "" always ""
Line 2710
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  2710 always 2710
  "class A : private Base\n{\npublic:\n    ~A() { }\n};\n\nclass B : public A\n{\npublic:\n    ~B() { int a; }\n};" always "class A : private Base\n{\npublic:\n    ~A() { }\n};\n\nclass B : public A\n{\npublic:\n    ~B() { int a; }\n};"
Line 2721
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  2721 always 2721
  "" always ""
Line 2724
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  2724 always 2724
  "class Base2\n{\nvirtual ~Base2() {}\n};\nclass Base : public Base2\n{\n};\nclass A : private Base\n{\npublic:\n    ~A() { }\n};\n\nclass B : public A\n{\npublic:\n    ~B() { int a; }\n};" always "class Base2\n{\nvirtual ~Base2() {}\n};\nclass Base : public Base2\n{\n};\nclass A : private Base\n{\npublic:\n    ~A() { }\n};\n\nclass B : public A\n{\npublic:\n    ~B() { int a; }\n};"
Line 2742
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  2742 always 2742
  "" always ""
Line 2745
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  2745 always 2745
  "class Base\n{\npublic:\n    ~Base() {}\n};\nclass A : private Base\n{\npublic:\n    ~A() { }\n};\n\nclass B : public A\n{\npublic:\n    ~B() { int a; }\n};" always "class Base\n{\npublic:\n    ~Base() {}\n};\nclass A : private Base\n{\npublic:\n    ~A() { }\n};\n\nclass B : public A\n{\npublic:\n    ~B() { int a; }\n};"
Line 2761
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  2761 always 2761
  "[test.cpp:7]: (error) Class 'Base' which is inherited by class 'B' does not have a virtual destructor.\n" always "[test.cpp:7]: (error) Class 'Base' which is inherited by class 'B' does not have a virtual destructor.\n"
  "" always ""
Line 2766
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  2766 always 2766
  "template <typename T> class A\n{\n public:\n virtual ~A(){}\n};\ntemplate <typename T> class AA\n{\n public:\n ~AA(){}\n};\nclass B : public A<int>, public AA<double>\n{\n public:\n ~B(){int a;}\n};\n\nAA<double> *p = new B; delete p;" always "template <typename T> class A\n{\n public:\n virtual ~A(){}\n};\ntemplate <typename T> class AA\n{\n public:\n ~AA(){}\n};\nclass B : public A<int>, public AA<double>\n{\n public:\n ~B(){int a;}\n};\n\nAA<double> *p = new B; delete p;"
Line 2783
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  2783 always 2783
  "[test.cpp:9]: (error) Class 'AA < double >' which is inherited by class 'B' does not have a virtual destructor.\n" always "[test.cpp:9]: (error) Class 'AA < double >' which is inherited by class 'B' does not have a virtual destructor.\n"
Line 2787
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  2787 always 2787
  "class Base {\npublic:\n    ~Base(){}\n    virtual void foo(){}\n};\n" always "class Base {\npublic:\n    ~Base(){}\n    virtual void foo(){}\n};\n"
  true always 1
Line 2792
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  2792 always 2792
  "[test.cpp:3]: (warning, inconclusive) Class 'Base' which has virtual members does not have a virtual destructor.\n" always "[test.cpp:3]: (warning, inconclusive) Class 'Base' which has virtual members does not have a virtual destructor.\n"
Line 2794
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  2794 always 2794
  "class Base {\npublic:\n    ~Base(){}\n    virtual void foo(){}\n};\nclass Derived : public Base {\npublic:\n    ~Derived() { bar(); }\n};\nvoid foo() {\n    Base * base = new Derived();\n    delete base;\n}\n" always "class Base {\npublic:\n    ~Base(){}\n    virtual void foo(){}\n};\nclass Derived : public Base {\npublic:\n    ~Derived() { bar(); }\n};\nvoid foo() {\n    Base * base = new Derived();\n    delete base;\n}\n"
  true always 1
Line 2807
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  2807 always 2807
  "[test.cpp:3]: (error) Class 'Base' which is inherited by class 'Derived' does not have a virtual destructor.\n" always "[test.cpp:3]: (error) Class 'Base' which is inherited by class 'Derived' does not have a virtual destructor.\n"
Line 2810
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  2810 always 2810
  "class Base {\npublic:\n    virtual void foo(){}\nprotected:\n    ~Base(){}\n};\n" always "class Base {\npublic:\n    virtual void foo(){}\nprotected:\n    ~Base(){}\n};\n"
  true always 1
Line 2816
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  2816 always 2816
  "" always ""
Line 2818
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  2818 always 2818
  "class C {\nprivate:\n    C();\n    virtual ~C();\n};\n" always "class C {\nprivate:\n    C();\n    virtual ~C();\n};\n"
  true always 1
Line 2823
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  2823 always 2823
  "" always ""
Line 2832
  file possible {"cppcheck-2.8/test/testclass.cpp"@180,"cppcheck-2.8/test/testclass.cpp"@181,"cppcheck-2.8/test/testclass.cpp"@182,"cppcheck-2.8/test/testclass.cpp"@183,"cppcheck-2.8/test/testclass.cpp"@184,"cppcheck-2.8/test/testclass.cpp"@185,"cppcheck-2.8/test/testclass.cpp"@186,"cppcheck-2.8/test/testclass.cpp"@187,"cppcheck-2.8/test/testclass.cpp"@188,"cppcheck-2.8/test/testclass.cpp"@189}
  line possible {3375@180,3381@181,3387@182,3393@183,3399@184,3405@185,3411@186,3417@187,3367@188,3329@189}
  code possible {"class C { C() {} };\nvoid foo(C*& p) {\n    p = malloc(sizeof(C));\n}"@180,"class C { C(int z, Foo bar) { bar(); } };\nvoid foo(C*& p) {\n    p = malloc(sizeof(C));\n}"@181,"struct C { C() {} };\nvoid foo(C*& p) {\n    p = realloc(p, sizeof(C));\n}"@182,"struct C { virtual void bar(); };\nvoid foo(C*& p) {\n    p = malloc(sizeof(C));\n}"@183,"struct C { std::string s; };\nvoid foo(C*& p) {\n    p = malloc(sizeof(C));\n}"@184,"class C { };\nvoid foo(C*& p) {\n    p = malloc(sizeof(C));\n}"@185,"struct C { C() {} };\nvoid foo(C*& p) {\n    p = new C();\n}"@186,"class C { C() {} };\nvoid foo(D*& p) {\n    p = malloc(sizeof(C));\n}"@187,"void clang_tokenize(CXToken **Tokens) {\n  *Tokens = (CXToken *)malloc(sizeof(CXToken) * CXTokens.size());\n  memmove(*Tokens, CXTokens.data(), sizeof(CXToken) * CXTokens.size());\n}"@188,"struct A {\n    float f;\n};\nvoid f() {\n    A a;\n    memset(&a, 0, sizeof(A));\n}"@189}
Line 2837
  "" always ""
Line 2840
  & {lifetime[Address]=(settings),!0}
  this always !0
Line 2841
  code possible {"struct st {\n  std::uint8_t a;\n  std::atomic_bool b;\n};\n\nvoid f() {\n  st s;\n  std::memset(&s, 0, sizeof(st));\n}"@194,"class C { C() {} };\nvoid foo(C*& p) {\n    p = malloc(sizeof(C));\n}"@46314}
Line 2842
  ( always {!<=-1,!>=2}
  file inconclusive {"cppcheck-2.8/test/testclass.cpp"@194,"cppcheck-2.8/test/testclass.cpp"@46314}
  line inconclusive {3316@194,3375@46314}
  "test.cpp" always "test.cpp"
Line 2845
  & {lifetime[Address]=(tokenizer),!0}
  & {lifetime[Address]=(settings),!0}
  this always !0
Line 2850
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  2850 always 2850
  "class Fred\n{\n};\nvoid f()\n{\n    Fred fred;\n    memset(&fred, 0, sizeof(Fred));\n}" always "class Fred\n{\n};\nvoid f()\n{\n    Fred fred;\n    memset(&fred, 0, sizeof(Fred));\n}"
Line 2858
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  2858 always 2858
  "" always ""
Line 2860
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  2860 always 2860
  "class Fred\n{\n    static std::string b;\n};\nvoid f()\n{\n    Fred fred;\n    memset(&fred, 0, sizeof(Fred));\n}" always "class Fred\n{\n    static std::string b;\n};\nvoid f()\n{\n    Fred fred;\n    memset(&fred, 0, sizeof(Fred));\n}"
Line 2869
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  2869 always 2869
  "" always ""
Line 2871
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  2871 always 2871
  "class Fred\n{\n    std::string * b;\n};\nvoid f()\n{\n    Fred fred;\n    memset(&fred, 0, sizeof(Fred));\n}" always "class Fred\n{\n    std::string * b;\n};\nvoid f()\n{\n    Fred fred;\n    memset(&fred, 0, sizeof(Fred));\n}"
Line 2880
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  2880 always 2880
  "" always ""
Line 2882
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  2882 always 2882
  "class Fred\n{\n    std::string b;\n};\nvoid f()\n{\n    Fred fred;\n    memset(&fred, 0, sizeof(Fred));\n}" always "class Fred\n{\n    std::string b;\n};\nvoid f()\n{\n    Fred fred;\n    memset(&fred, 0, sizeof(Fred));\n}"
Line 2891
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  2891 always 2891
  "[test.cpp:8]: (error) Using 'memset' on class that contains a 'std::string'.\n" always "[test.cpp:8]: (error) Using 'memset' on class that contains a 'std::string'.\n"
Line 2893
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  2893 always 2893
  "class Fred\n{\n    mutable std::string b;\n};\nvoid f()\n{\n    Fred fred;\n    memset(&fred, 0, sizeof(Fred));\n}" always "class Fred\n{\n    mutable std::string b;\n};\nvoid f()\n{\n    Fred fred;\n    memset(&fred, 0, sizeof(Fred));\n}"
Line 2902
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  2902 always 2902
  "[test.cpp:8]: (error) Using 'memset' on class that contains a 'std::string'.\n" always "[test.cpp:8]: (error) Using 'memset' on class that contains a 'std::string'.\n"
Line 2904
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  2904 always 2904
  "class Fred {\n    std::string b;\n    void f();\n};\nvoid Fred::f() {\n    memset(this, 0, sizeof(*this));\n}" always "class Fred {\n    std::string b;\n    void f();\n};\nvoid Fred::f() {\n    memset(this, 0, sizeof(*this));\n}"
Line 2911
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  2911 always 2911
  "[test.cpp:6]: (error) Using 'memset' on class that contains a 'std::string'.\n" always "[test.cpp:6]: (error) Using 'memset' on class that contains a 'std::string'.\n"
Line 2913
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  2913 always 2913
  "class Fred\n{\n};\nvoid f()\n{\n    Fred fred;\n    memset(&fred, 0, sizeof(fred));\n}" always "class Fred\n{\n};\nvoid f()\n{\n    Fred fred;\n    memset(&fred, 0, sizeof(fred));\n}"
Line 2921
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  2921 always 2921
  "" always ""
Line 2923
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  2923 always 2923
  "class Fred\n{\n    std::string s;\n};\nvoid f()\n{\n    Fred fred;\n    memset(&fred, 0, sizeof(fred));\n}" always "class Fred\n{\n    std::string s;\n};\nvoid f()\n{\n    Fred fred;\n    memset(&fred, 0, sizeof(fred));\n}"
Line 2932
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  2932 always 2932
  "[test.cpp:8]: (error) Using 'memset' on class that contains a 'std::string'.\n" always "[test.cpp:8]: (error) Using 'memset' on class that contains a 'std::string'.\n"
Line 2934
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  2934 always 2934
  "class Fred\n{\n    std::string s;\n};\nclass Pebbles: public Fred {};\nvoid f()\n{\n    Pebbles pebbles;\n    memset(&pebbles, 0, sizeof(pebbles));\n}" always "class Fred\n{\n    std::string s;\n};\nclass Pebbles: public Fred {};\nvoid f()\n{\n    Pebbles pebbles;\n    memset(&pebbles, 0, sizeof(pebbles));\n}"
Line 2944
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  2944 always 2944
  "[test.cpp:9]: (error) Using 'memset' on class that contains a 'std::string'.\n" always "[test.cpp:9]: (error) Using 'memset' on class that contains a 'std::string'.\n"
Line 2946
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  2946 always 2946
  "class Fred\n{\n    virtual ~Fred();\n};\nvoid f()\n{\n    Fred fred;\n    memset(&fred, 0, sizeof(fred));\n}" always "class Fred\n{\n    virtual ~Fred();\n};\nvoid f()\n{\n    Fred fred;\n    memset(&fred, 0, sizeof(fred));\n}"
Line 2955
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  2955 always 2955
  "[test.cpp:8]: (error) Using 'memset' on class that contains a virtual function.\n" always "[test.cpp:8]: (error) Using 'memset' on class that contains a virtual function.\n"
Line 2957
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  2957 always 2957
  "class Fred\n{\n    virtual ~Fred();\n};\nvoid f()\n{\n    static Fred fred;\n    memset(&fred, 0, sizeof(fred));\n}" always "class Fred\n{\n    virtual ~Fred();\n};\nvoid f()\n{\n    static Fred fred;\n    memset(&fred, 0, sizeof(fred));\n}"
Line 2966
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  2966 always 2966
  "[test.cpp:8]: (error) Using 'memset' on class that contains a virtual function.\n" always "[test.cpp:8]: (error) Using 'memset' on class that contains a virtual function.\n"
Line 2968
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  2968 always 2968
  "class Fred\n{\n};\nclass Wilma\n{\n    virtual ~Wilma();\n};\nclass Pebbles: public Fred, Wilma {};\nvoid f()\n{\n    Pebbles pebbles;\n    memset(&pebbles, 0, sizeof(pebbles));\n}" always "class Fred\n{\n};\nclass Wilma\n{\n    virtual ~Wilma();\n};\nclass Pebbles: public Fred, Wilma {};\nvoid f()\n{\n    Pebbles pebbles;\n    memset(&pebbles, 0, sizeof(pebbles));\n}"
Line 2981
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  2981 always 2981
  "[test.cpp:12]: (error) Using 'memset' on class that contains a virtual function.\n" always "[test.cpp:12]: (error) Using 'memset' on class that contains a virtual function.\n"
Line 2984
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  2984 always 2984
  "namespace n1 {\n    class Fred\n    {\n        std::string b;\n    };\n}\nvoid f()\n{\n    Fred fred;\n    memset(&fred, 0, sizeof(Fred));\n}" always "namespace n1 {\n    class Fred\n    {\n        std::string b;\n    };\n}\nvoid f()\n{\n    Fred fred;\n    memset(&fred, 0, sizeof(Fred));\n}"
Line 2995
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  2995 always 2995
  "" always ""
Line 2998
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  2998 always 2998
  "namespace n1 {\n    class Fred\n    {\n        std::string b;\n    };\n}\nvoid f()\n{\n    n1::Fred fred;\n    memset(&fred, 0, sizeof(n1::Fred));\n}" always "namespace n1 {\n    class Fred\n    {\n        std::string b;\n    };\n}\nvoid f()\n{\n    n1::Fred fred;\n    memset(&fred, 0, sizeof(n1::Fred));\n}"
Line 3009
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  3009 always 3009
  "[test.cpp:10]: (error) Using 'memset' on class that contains a 'std::string'.\n" always "[test.cpp:10]: (error) Using 'memset' on class that contains a 'std::string'.\n"
Line 3012
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  3012 always 3012
  "namespace n1 {\n    class Fred\n    {\n        std::string b;\n    };\n}\nvoid f()\n{\n    n1::Fred fred;\n    memset(&fred, 0, sizeof(fred));\n}" always "namespace n1 {\n    class Fred\n    {\n        std::string b;\n    };\n}\nvoid f()\n{\n    n1::Fred fred;\n    memset(&fred, 0, sizeof(fred));\n}"
Line 3023
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  3023 always 3023
  "[test.cpp:10]: (error) Using 'memset' on class that contains a 'std::string'.\n" always "[test.cpp:10]: (error) Using 'memset' on class that contains a 'std::string'.\n"
Line 3025
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  3025 always 3025
  "class A {\n  virtual ~A() { }\n  std::string s;\n};\nint f() {\n  const int N = 10;\n  A** arr = new A*[N];\n  memset(arr, 0, N * sizeof(A*));\n}" always "class A {\n  virtual ~A() { }\n  std::string s;\n};\nint f() {\n  const int N = 10;\n  A** arr = new A*[N];\n  memset(arr, 0, N * sizeof(A*));\n}"
Line 3034
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  3034 always 3034
  "" always ""
Line 3036
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  3036 always 3036
  "class A {\n  std::string s;\n  struct B { int x; };\n};\nvoid f(A::B *b) {\n  memset(b,0,4);\n}" always "class A {\n  std::string s;\n  struct B { int x; };\n};\nvoid f(A::B *b) {\n  memset(b,0,4);\n}"
Line 3043
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  3043 always 3043
  "" always ""
Line 3046
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  3046 always 3046
  "class A {\n  std::string &s;\n};\nvoid f() {\n  A a;\n  memset(&a, 0, sizeof(a));\n}" always "class A {\n  std::string &s;\n};\nvoid f() {\n  A a;\n  memset(&a, 0, sizeof(a));\n}"
Line 3053
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  3053 always 3053
  "[test.cpp:6]: (error) Using 'memset' on class that contains a reference.\n" always "[test.cpp:6]: (error) Using 'memset' on class that contains a reference.\n"
Line 3054
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  3054 always 3054
  "class A {\n  const B&b;\n};\nvoid f() {\n  A a;\n  memset(&a, 0, sizeof(a));\n}" always "class A {\n  const B&b;\n};\nvoid f() {\n  A a;\n  memset(&a, 0, sizeof(a));\n}"
Line 3061
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  3061 always 3061
  "[test.cpp:6]: (error) Using 'memset' on class that contains a reference.\n" always "[test.cpp:6]: (error) Using 'memset' on class that contains a reference.\n"
Line 3064
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  3064 always 3064
  "struct A {\n  A() {}\n  virtual ~A() {}\n};\nstruct B {\n  A* arr[4];\n};\nvoid func() {\n  B b[4];\n  memset(b, 0, sizeof(b));\n}" always "struct A {\n  A() {}\n  virtual ~A() {}\n};\nstruct B {\n  A* arr[4];\n};\nvoid func() {\n  B b[4];\n  memset(b, 0, sizeof(b));\n}"
Line 3075
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  3075 always 3075
  "" always ""
Line 3079
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  3079 always 3079
  "union ASFStreamHeader {\n  struct AVMPACKED {\n    union  {\n      struct AVMPACKED {\n        int width;\n      } vid;\n    };\n  } hdr;\n};void parseHeader() {\n  ASFStreamHeader strhdr;\n  memset(&strhdr, 0, sizeof(strhdr));\n}" always "union ASFStreamHeader {\n  struct AVMPACKED {\n    union  {\n      struct AVMPACKED {\n        int width;\n      } vid;\n    };\n  } hdr;\n};void parseHeader() {\n  ASFStreamHeader strhdr;\n  memset(&strhdr, 0, sizeof(strhdr));\n}"
Line 3095
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  3095 always 3095
  "struct A\n{\n};\nvoid f()\n{\n    A a;\n    memset(&a, 0, sizeof(A));\n}" always "struct A\n{\n};\nvoid f()\n{\n    A a;\n    memset(&a, 0, sizeof(A));\n}"
Line 3103
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  3103 always 3103
  "" always ""
Line 3105
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  3105 always 3105
  "struct A\n{\n};\nvoid f()\n{\n    struct A a;\n    memset(&a, 0, sizeof(struct A));\n}" always "struct A\n{\n};\nvoid f()\n{\n    struct A a;\n    memset(&a, 0, sizeof(struct A));\n}"
Line 3113
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  3113 always 3113
  "" always ""
Line 3115
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  3115 always 3115
  "struct A\n{\n};\nvoid f()\n{\n    struct A a;\n    memset(&a, 0, sizeof(A));\n}" always "struct A\n{\n};\nvoid f()\n{\n    struct A a;\n    memset(&a, 0, sizeof(A));\n}"
Line 3123
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  3123 always 3123
  "" always ""
Line 3125
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  3125 always 3125
  "void f()\n{\n    struct sockaddr_in6 fail;\n    memset(&fail, 0, sizeof(struct sockaddr_in6));\n}" always "void f()\n{\n    struct sockaddr_in6 fail;\n    memset(&fail, 0, sizeof(struct sockaddr_in6));\n}"
Line 3130
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  3130 always 3130
  "" always ""
Line 3132
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  3132 always 3132
  "struct A\n{\n void g( struct sockaddr_in6& a);\nprivate:\n std::string b;\n};\nvoid f()\n{\n struct A fail;\n memset(&fail, 0, sizeof(struct A));\n}" always "struct A\n{\n void g( struct sockaddr_in6& a);\nprivate:\n std::string b;\n};\nvoid f()\n{\n struct A fail;\n memset(&fail, 0, sizeof(struct A));\n}"
Line 3143
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  3143 always 3143
  "[test.cpp:10]: (error) Using 'memset' on struct that contains a 'std::string'.\n" always "[test.cpp:10]: (error) Using 'memset' on struct that contains a 'std::string'.\n"
Line 3145
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  3145 always 3145
  "struct Fred\n{\n     std::string s;\n};\nvoid f()\n{\n    Fred fred;\n    memset(&fred, 0, sizeof(fred));\n}" always "struct Fred\n{\n     std::string s;\n};\nvoid f()\n{\n    Fred fred;\n    memset(&fred, 0, sizeof(fred));\n}"
Line 3154
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  3154 always 3154
  "[test.cpp:8]: (error) Using 'memset' on struct that contains a 'std::string'.\n" always "[test.cpp:8]: (error) Using 'memset' on struct that contains a 'std::string'.\n"
Line 3156
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  3156 always 3156
  "struct Stringy {\n    std::string inner;\n};\nstruct Foo {\n    Stringy s;\n};\nint main() {\n    Foo foo;\n    memset(&foo, 0, sizeof(Foo));\n}" always "struct Stringy {\n    std::string inner;\n};\nstruct Foo {\n    Stringy s;\n};\nint main() {\n    Foo foo;\n    memset(&foo, 0, sizeof(Foo));\n}"
Line 3167
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  3167 always 3167
  "[test.cpp:9]: (error) Using 'memset' on struct that contains a 'std::string'.\n" always "[test.cpp:9]: (error) Using 'memset' on struct that contains a 'std::string'.\n"
Line 3171
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  3171 always 3171
  "class A\n{ std::vector<int> ints; };\n\nvoid f()\n{\n    A a;\n    memset(&a, 0, sizeof(A));\n}" always "class A\n{ std::vector<int> ints; };\n\nvoid f()\n{\n    A a;\n    memset(&a, 0, sizeof(A));\n}"
Line 3179
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  3179 always 3179
  "[test.cpp:7]: (error) Using 'memset' on class that contains a 'std::vector'.\n" always "[test.cpp:7]: (error) Using 'memset' on class that contains a 'std::vector'.\n"
Line 3181
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  3181 always 3181
  "struct A\n{ std::vector<int> ints; };\n\nvoid f()\n{\n    A a;\n    memset(&a, 0, sizeof(A));\n}" always "struct A\n{ std::vector<int> ints; };\n\nvoid f()\n{\n    A a;\n    memset(&a, 0, sizeof(A));\n}"
Line 3189
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  3189 always 3189
  "[test.cpp:7]: (error) Using 'memset' on struct that contains a 'std::vector'.\n" always "[test.cpp:7]: (error) Using 'memset' on struct that contains a 'std::vector'.\n"
Line 3191
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  3191 always 3191
  "struct A\n{ std::vector<int> ints; };\n\nvoid f()\n{\n    A a;\n    memset(&a, 0, sizeof(struct A));\n}" always "struct A\n{ std::vector<int> ints; };\n\nvoid f()\n{\n    A a;\n    memset(&a, 0, sizeof(struct A));\n}"
Line 3199
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  3199 always 3199
  "[test.cpp:7]: (error) Using 'memset' on struct that contains a 'std::vector'.\n" always "[test.cpp:7]: (error) Using 'memset' on struct that contains a 'std::vector'.\n"
Line 3201
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  3201 always 3201
  "struct A\n{ std::vector<int> ints; };\n\nvoid f()\n{\n    A a;\n    memset(&a, 0, sizeof(a));\n}" always "struct A\n{ std::vector<int> ints; };\n\nvoid f()\n{\n    A a;\n    memset(&a, 0, sizeof(a));\n}"
Line 3209
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  3209 always 3209
  "[test.cpp:7]: (error) Using 'memset' on struct that contains a 'std::vector'.\n" always "[test.cpp:7]: (error) Using 'memset' on struct that contains a 'std::vector'.\n"
Line 3211
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  3211 always 3211
  "class A\n{ std::vector< std::vector<int> > ints; };\n\nvoid f()\n{\n    A a;\n    memset(&a, 0, sizeof(A));\n}" always "class A\n{ std::vector< std::vector<int> > ints; };\n\nvoid f()\n{\n    A a;\n    memset(&a, 0, sizeof(A));\n}"
Line 3219
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  3219 always 3219
  "[test.cpp:7]: (error) Using 'memset' on class that contains a 'std::vector'.\n" always "[test.cpp:7]: (error) Using 'memset' on class that contains a 'std::vector'.\n"
Line 3221
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  3221 always 3221
  "struct A\n{ std::vector< std::vector<int> > ints; };\n\nvoid f()\n{\n    A a;\n    memset(&a, 0, sizeof(A));\n}" always "struct A\n{ std::vector< std::vector<int> > ints; };\n\nvoid f()\n{\n    A a;\n    memset(&a, 0, sizeof(A));\n}"
Line 3229
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  3229 always 3229
  "[test.cpp:7]: (error) Using 'memset' on struct that contains a 'std::vector'.\n" always "[test.cpp:7]: (error) Using 'memset' on struct that contains a 'std::vector'.\n"
Line 3231
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  3231 always 3231
  "struct A\n{ std::vector< std::vector<int> > ints; };\n\nvoid f()\n{\n    A a;\n    memset(&a, 0, sizeof(a));\n}" always "struct A\n{ std::vector< std::vector<int> > ints; };\n\nvoid f()\n{\n    A a;\n    memset(&a, 0, sizeof(a));\n}"
Line 3239
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  3239 always 3239
  "[test.cpp:7]: (error) Using 'memset' on struct that contains a 'std::vector'.\n" always "[test.cpp:7]: (error) Using 'memset' on struct that contains a 'std::vector'.\n"
Line 3241
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  3241 always 3241
  "struct A\n{ std::vector<int *> ints; };\n\nvoid f()\n{\n    A a;\n    memset(&a, 0, sizeof(A));\n}" always "struct A\n{ std::vector<int *> ints; };\n\nvoid f()\n{\n    A a;\n    memset(&a, 0, sizeof(A));\n}"
Line 3249
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  3249 always 3249
  "[test.cpp:7]: (error) Using 'memset' on struct that contains a 'std::vector'.\n" always "[test.cpp:7]: (error) Using 'memset' on struct that contains a 'std::vector'.\n"
Line 3251
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  3251 always 3251
  "struct A {\n     std::vector<int *> buf;\n     operator int*() {return &buf[0];}\n};\nvoid f() {\n    A a;\n    memset(a, 0, 100);\n}" always "struct A {\n     std::vector<int *> buf;\n     operator int*() {return &buf[0];}\n};\nvoid f() {\n    A a;\n    memset(a, 0, 100);\n}"
Line 3259
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  3259 always 3259
  "" always ""
Line 3261
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  3261 always 3261
  "struct C {\n    std::string s;\n};\nint foo() {\n    C* c1[10][10];\n    C* c2[10];\n    C c3[10][10];\n    C** c4 = new C*[10];\n    memset(**c1, 0, 10);\n    memset(*c1, 0, 10);\n    memset(*c2, 0, 10);\n    memset(*c3, 0, 10);\n    memset(*c4, 0, 10);\n    memset(c2, 0, 10);\n    memset(c3, 0, 10);\n}" always "struct C {\n    std::string s;\n};\nint foo() {\n    C* c1[10][10];\n    C* c2[10];\n    C c3[10][10];\n    C** c4 = new C*[10];\n    memset(**c1, 0, 10);\n    memset(*c1, 0, 10);\n    memset(*c2, 0, 10);\n    memset(*c3, 0, 10);\n    memset(*c4, 0, 10);\n    memset(c2, 0, 10);\n    memset(c3, 0, 10);\n}"
Line 3277
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  3277 always 3277
  "[test.cpp:9]: (error) Using 'memset' on struct that contains a 'std::string'.\n[test.cpp:11]: (error) Using 'memset' on struct that contains a 'std::string'.\n[test.cpp:12]: (error) Using 'memset' on struct that contains a 'std::string'.\n[test.cpp:13]: (error) Using 'memset' on struct that contains a 'std::string'.\n" always "[test.cpp:9]: (error) Using 'memset' on struct that contains a 'std::string'.\n[test.cpp:11]: (error) Using 'memset' on struct that contains a 'std::string'.\n[test.cpp:12]: (error) Using 'memset' on struct that contains a 'std::string'.\n[test.cpp:13]: (error) Using 'memset' on struct that contains a 'std::string'.\n"
Line 3283
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  3283 always 3283
  "typedef float realnum;\nstruct multilevel_data {\n  realnum *GammaInv;\n  realnum data[1];\n};\nvoid *new_internal_data() const {\n  multilevel_data *d = (multilevel_data *) malloc(sizeof(multilevel_data));\n  memset(d, 0, sizeof(multilevel_data));\n  return (void*) d;\n}" always "typedef float realnum;\nstruct multilevel_data {\n  realnum *GammaInv;\n  realnum data[1];\n};\nvoid *new_internal_data() const {\n  multilevel_data *d = (multilevel_data *) malloc(sizeof(multilevel_data));\n  memset(d, 0, sizeof(multilevel_data));\n  return (void*) d;\n}"
Line 3293
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  3293 always 3293
  "[test.cpp:8]: (portability) Using memset() on struct which contains a floating point number.\n" always "[test.cpp:8]: (portability) Using memset() on struct which contains a floating point number.\n"
Line 3298
  123 always 123
  = always "<?xml version=\"1.0\"?>\n<def>\n  <podtype name=\"std::uint8_t\" sign=\"u\" size=\"1\"/>\n  <podtype name=\"std::atomic_bool\"/>\n</def>"
  "<?xml version=\"1.0\"?>\n<def>\n  <podtype name=\"std::uint8_t\" sign=\"u\" size=\"1\"/>\n  <podtype name=\"std::atomic_bool\"/>\n</def>" always "<?xml version=\"1.0\"?>\n<def>\n  <podtype name=\"std::uint8_t\" sign=\"u\" size=\"1\"/>\n  <podtype name=\"std::atomic_bool\"/>\n</def>"
Line 3304
  xmldata always "<?xml version=\"1.0\"?>\n<def>\n  <podtype name=\"std::uint8_t\" sign=\"u\" size=\"1\"/>\n  <podtype name=\"std::atomic_bool\"/>\n</def>"
  sizeof always 123
  ( always 123
  xmldata always "<?xml version=\"1.0\"?>\n<def>\n  <podtype name=\"std::uint8_t\" sign=\"u\" size=\"1\"/>\n  <podtype name=\"std::atomic_bool\"/>\n</def>"
Line 3307
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  3307 always 3307
  "class A {\n    std::array<int, 10> ints;\n};\nvoid f() {\n    A a;\n    memset(&a, 0, sizeof(A));\n}" always "class A {\n    std::array<int, 10> ints;\n};\nvoid f() {\n    A a;\n    memset(&a, 0, sizeof(A));\n}"
Line 3314
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  3314 always 3314
  "" always ""
Line 3316
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  3316 always 3316
  "struct st {\n  std::uint8_t a;\n  std::atomic_bool b;\n};\n\nvoid f() {\n  st s;\n  std::memset(&s, 0, sizeof(st));\n}" always "struct st {\n  std::uint8_t a;\n  std::atomic_bool b;\n};\n\nvoid f() {\n  st s;\n  std::memset(&s, 0, sizeof(st));\n}"
Line 3325
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  3325 always 3325
  "" always ""
Line 3329
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  3329 always 3329
  "struct A {\n    float f;\n};\nvoid f() {\n    A a;\n    memset(&a, 0, sizeof(A));\n}" always "struct A {\n    float f;\n};\nvoid f() {\n    A a;\n    memset(&a, 0, sizeof(A));\n}"
Line 3336
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  3336 always 3336
  "[test.cpp:6]: (portability) Using memset() on struct which contains a floating point number.\n" always "[test.cpp:6]: (portability) Using memset() on struct which contains a floating point number.\n"
Line 3338
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  3338 always 3338
  "struct A {\n    float f[4];\n};\nvoid f() {\n    A a;\n    memset(&a, 0, sizeof(A));\n}" always "struct A {\n    float f[4];\n};\nvoid f() {\n    A a;\n    memset(&a, 0, sizeof(A));\n}"
Line 3345
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  3345 always 3345
  "[test.cpp:6]: (portability) Using memset() on struct which contains a floating point number.\n" always "[test.cpp:6]: (portability) Using memset() on struct which contains a floating point number.\n"
Line 3347
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  3347 always 3347
  "struct A {\n    float f[4];\n};\nvoid f(const A& b) {\n    A a;\n    memcpy(&a, &b, sizeof(A));\n}" always "struct A {\n    float f[4];\n};\nvoid f(const A& b) {\n    A a;\n    memcpy(&a, &b, sizeof(A));\n}"
Line 3354
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  3354 always 3354
  "" always ""
Line 3356
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  3356 always 3356
  "struct A {\n    float* f;\n};\nvoid f() {\n    A a;\n    memset(&a, 0, sizeof(A));\n}" always "struct A {\n    float* f;\n};\nvoid f() {\n    A a;\n    memset(&a, 0, sizeof(A));\n}"
Line 3363
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  3363 always 3363
  "" always ""
Line 3367
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  3367 always 3367
  "void clang_tokenize(CXToken **Tokens) {\n  *Tokens = (CXToken *)malloc(sizeof(CXToken) * CXTokens.size());\n  memmove(*Tokens, CXTokens.data(), sizeof(CXToken) * CXTokens.size());\n}" always "void clang_tokenize(CXToken **Tokens) {\n  *Tokens = (CXToken *)malloc(sizeof(CXToken) * CXTokens.size());\n  memmove(*Tokens, CXTokens.data(), sizeof(CXToken) * CXTokens.size());\n}"
Line 3371
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  3371 always 3371
  "" always ""
Line 3375
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  3375 always 3375
  "class C { C() {} };\nvoid foo(C*& p) {\n    p = malloc(sizeof(C));\n}" always "class C { C() {} };\nvoid foo(C*& p) {\n    p = malloc(sizeof(C));\n}"
Line 3379
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  3379 always 3379
  "[test.cpp:3] -> [test.cpp:1]: (warning) Memory for class instance allocated with malloc(), but class provides constructors.\n" always "[test.cpp:3] -> [test.cpp:1]: (warning) Memory for class instance allocated with malloc(), but class provides constructors.\n"
Line 3381
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  3381 always 3381
  "class C { C(int z, Foo bar) { bar(); } };\nvoid foo(C*& p) {\n    p = malloc(sizeof(C));\n}" always "class C { C(int z, Foo bar) { bar(); } };\nvoid foo(C*& p) {\n    p = malloc(sizeof(C));\n}"
Line 3385
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  3385 always 3385
  "[test.cpp:3] -> [test.cpp:1]: (warning) Memory for class instance allocated with malloc(), but class provides constructors.\n" always "[test.cpp:3] -> [test.cpp:1]: (warning) Memory for class instance allocated with malloc(), but class provides constructors.\n"
Line 3387
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  3387 always 3387
  "struct C { C() {} };\nvoid foo(C*& p) {\n    p = realloc(p, sizeof(C));\n}" always "struct C { C() {} };\nvoid foo(C*& p) {\n    p = realloc(p, sizeof(C));\n}"
Line 3391
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  3391 always 3391
  "[test.cpp:3] -> [test.cpp:1]: (warning) Memory for class instance allocated with realloc(), but class provides constructors.\n" always "[test.cpp:3] -> [test.cpp:1]: (warning) Memory for class instance allocated with realloc(), but class provides constructors.\n"
Line 3393
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  3393 always 3393
  "struct C { virtual void bar(); };\nvoid foo(C*& p) {\n    p = malloc(sizeof(C));\n}" always "struct C { virtual void bar(); };\nvoid foo(C*& p) {\n    p = malloc(sizeof(C));\n}"
Line 3397
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  3397 always 3397
  "[test.cpp:3] -> [test.cpp:1]: (error) Memory for class instance allocated with malloc(), but class contains a virtual function.\n" always "[test.cpp:3] -> [test.cpp:1]: (error) Memory for class instance allocated with malloc(), but class contains a virtual function.\n"
Line 3399
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  3399 always 3399
  "struct C { std::string s; };\nvoid foo(C*& p) {\n    p = malloc(sizeof(C));\n}" always "struct C { std::string s; };\nvoid foo(C*& p) {\n    p = malloc(sizeof(C));\n}"
Line 3403
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  3403 always 3403
  "[test.cpp:3] -> [test.cpp:1]: (error) Memory for class instance allocated with malloc(), but class contains a 'std::string'.\n" always "[test.cpp:3] -> [test.cpp:1]: (error) Memory for class instance allocated with malloc(), but class contains a 'std::string'.\n"
Line 3405
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  3405 always 3405
  "class C { };\nvoid foo(C*& p) {\n    p = malloc(sizeof(C));\n}" always "class C { };\nvoid foo(C*& p) {\n    p = malloc(sizeof(C));\n}"
Line 3409
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  3409 always 3409
  "" always ""
Line 3411
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  3411 always 3411
  "struct C { C() {} };\nvoid foo(C*& p) {\n    p = new C();\n}" always "struct C { C() {} };\nvoid foo(C*& p) {\n    p = new C();\n}"
Line 3415
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  3415 always 3415
  "" always ""
Line 3417
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  3417 always 3417
  "class C { C() {} };\nvoid foo(D*& p) {\n    p = malloc(sizeof(C));\n}" always "class C { C() {} };\nvoid foo(D*& p) {\n    p = malloc(sizeof(C));\n}"
Line 3421
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  3421 always 3421
  "" always ""
Line 3427
  "" always ""
Line 3430
  & {lifetime[Address]=(settings1),!0}
  this always !0
Line 3431
  code possible {"; this-x ;"@176,"; *this = *this-x ;"@177,"; *this = *this-x ;\nthis-x ;"@178,"; *this = *this-x ;\nthis-x ;\nthis-x ;"@179}
Line 3432
  ( always {!<=-1,!>=2}
  file inconclusive {"cppcheck-2.8/test/testclass.cpp"@176,"cppcheck-2.8/test/testclass.cpp"@177,"cppcheck-2.8/test/testclass.cpp"@178,"cppcheck-2.8/test/testclass.cpp"@179}
  line inconclusive {3440@176,3443@177,3446@178,3450@179}
  "test.cpp" always "test.cpp"
Line 3435
  & {lifetime[Address]=(tokenizer),!0}
  & {lifetime[Address]=(settings1),!0}
  this always !0
Line 3440
  "; this-x ;" always "; this-x ;"
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  3440 always 3440
Line 3441
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  3441 always 3441
  "[test.cpp:1]: (warning) Suspicious pointer subtraction. Did you intend to write '->'?\n" always "[test.cpp:1]: (warning) Suspicious pointer subtraction. Did you intend to write '->'?\n"
Line 3443
  "; *this = *this-x ;" always "; *this = *this-x ;"
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  3443 always 3443
Line 3444
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  3444 always 3444
  "" always ""
Line 3446
  "; *this = *this-x ;\nthis-x ;" always "; *this = *this-x ;\nthis-x ;"
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  3446 always 3446
Line 3448
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  3448 always 3448
  "[test.cpp:2]: (warning) Suspicious pointer subtraction. Did you intend to write '->'?\n" always "[test.cpp:2]: (warning) Suspicious pointer subtraction. Did you intend to write '->'?\n"
Line 3450
  "; *this = *this-x ;\nthis-x ;\nthis-x ;" always "; *this = *this-x ;\nthis-x ;\nthis-x ;"
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  3450 always 3450
Line 3453
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  3453 always 3453
  "[test.cpp:2]: (warning) Suspicious pointer subtraction. Did you intend to write '->'?\n[test.cpp:3]: (warning) Suspicious pointer subtraction. Did you intend to write '->'?\n" always "[test.cpp:2]: (warning) Suspicious pointer subtraction. Did you intend to write '->'?\n[test.cpp:3]: (warning) Suspicious pointer subtraction. Did you intend to write '->'?\n"
Line 3458
  , always 0
  = always 0
  nullptr always 0
  , always 1
  inconclusive always {!<=-1,!>=2}
  = always 1
  true always 1
Line 3460
  "" always ""
Line 3463
  ! {!<=-1,!>=2,1@236}
  s possible {lifetime[Address]=(s)@111,lifetime[Address]=(settings0)@120,lifetime[Address]=(settings0)@121,0@236}
Line 3464
  = {&,lifetime[Address]=(settings0),!0}
  & {&,lifetime[Address]=(settings0),!0}
Line 3465
  s possible {lifetime[Address]=(settings0),symbolic=(&settings0),&,lifetime[Address]=(s)@111,lifetime[Address]=(settings0)@120,lifetime[Address]=(settings0)@121}
  inconclusive {!<=-1,!>=2,1@120,0@121}
Line 3468
  s {lifetime[Address]=(settings0),symbolic=(&settings0),&,lifetime[Address]=(s)@111,lifetime[Address]=(settings0)@120,lifetime[Address]=(settings0)@121}
  this always !0
Line 3469
  code {"struct data {};\n    struct S {\n    std::vector<data> std;\n    void f();\n};\nvoid S::f() {\n    std::vector<data>::const_iterator end = std.end();\n}\n"@111,"struct S {\n    template<size_t N>\n    void f(const std::array<std::string_view, N>& sv);\n    template<long N>\n    void f(const char* const (&StrArr)[N]);\n};\ntemplate<size_t N>\nvoid S::f(const std::array<std::string_view, N>& sv) {\n    const char* ptrs[N]{};\n    return f(ptrs);\n}\ntemplate void S::f(const std::array<std::string_view, 3>& sv);\n"@112,"struct A {\n    int x = 1;\n    auto get() -> int & { return x; }\n};"@113,"class Fred {\npublic:\n    const char *const *data;\n    const char *const *getData() { return data; }\n}"@114,"class Fred {\npublic:\n    std::shared_ptr<Data> getData();\nprivate:\n     std::shared_ptr<Data> data;\n};\n\nstd::shared_ptr<Data> Fred::getData() { return data; }"@115,"class Fred {\n    int array[256];\npublic:\n    void f1() {\n        for (auto & e : array)\n            foo(e);\n    }\n    void f2() {\n        for (const auto & e : array)\n            foo(e);\n    }\n    void f3() {\n        for (decltype(auto) e : array)\n            foo(e);\n    }\n};"@116,"struct foo {\n    int x;\n    int y[5][724];\n    T a() {\n        return y[x++][6];\n    }\n    T b() {\n        return y[1][++x];\n    }\n    T c() {\n        return y[1][6];\n    }\n};"@117,"class foo {\npublic:\n    union {\n        int i;\n        float f;\n    } d;\n    void setf(float x) {\n        d.f = x;\n    }\n};"@118,"class foo {\n    friend void f() { }\n};"@119,"struct foo {\n    int i;\n    void f() {\n    }\n};"@120}
Line 3470
  ( always {!<=-1,!>=2}
  file inconclusive {"cppcheck-2.8/test/testclass.cpp"@111,"cppcheck-2.8/test/testclass.cpp"@112,"cppcheck-2.8/test/testclass.cpp"@113,"cppcheck-2.8/test/testclass.cpp"@114,"cppcheck-2.8/test/testclass.cpp"@115,"cppcheck-2.8/test/testclass.cpp"@116,"cppcheck-2.8/test/testclass.cpp"@117,"cppcheck-2.8/test/testclass.cpp"@118,"cppcheck-2.8/test/testclass.cpp"@119,"cppcheck-2.8/test/testclass.cpp"@120}
  line inconclusive {6902@111,6882@112,6874@113,6866@114,6854@115,6834@116,6817@117,6803@118,6798@119,6787@120}
  "test.cpp" always "test.cpp"
Line 3472
  & {lifetime[Address]=(tokenizer),!0}
  s inconclusive {lifetime[Address]=(settings0),&,lifetime[Address]=(s)@111,lifetime[Address]=(settings0)@120,lifetime[Address]=(settings0)@121}
  this always !0
Line 3477
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  3477 always 3477
  "class Fred {\n    int a;\n    int getA() { return a; }\n};" always "class Fred {\n    int a;\n    int getA() { return a; }\n};"
Line 3481
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  3481 always 3481
  "[test.cpp:3]: (style, inconclusive) Technically the member function 'Fred::getA' can be const.\n" always "[test.cpp:3]: (style, inconclusive) Technically the member function 'Fred::getA' can be const.\n"
Line 3483
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  3483 always 3483
  "class Fred {\n    const std::string foo() { return \"\"; }\n};" always "class Fred {\n    const std::string foo() { return \"\"; }\n};"
Line 3486
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  3486 always 3486
  "[test.cpp:2]: (performance, inconclusive) Technically the member function 'Fred::foo' can be static (but you may consider moving to unnamed namespace).\n" always "[test.cpp:2]: (performance, inconclusive) Technically the member function 'Fred::foo' can be static (but you may consider moving to unnamed namespace).\n"
Line 3488
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  3488 always 3488
  "class Fred {\n    std::string s;\n    const std::string & foo() { return \"\"; }\n};" always "class Fred {\n    std::string s;\n    const std::string & foo() { return \"\"; }\n};"
Line 3492
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  3492 always 3492
  "[test.cpp:3]: (performance, inconclusive) Technically the member function 'Fred::foo' can be static (but you may consider moving to unnamed namespace).\n" always "[test.cpp:3]: (performance, inconclusive) Technically the member function 'Fred::foo' can be static (but you may consider moving to unnamed namespace).\n"
Line 3495
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  3495 always 3495
  "class Fred {\n    int a;\npublic:\n    Fred() { }\n};" always "class Fred {\n    int a;\npublic:\n    Fred() { }\n};"
Line 3500
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  3500 always 3500
  "" always ""
Line 3503
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  3503 always 3503
  "class Fred {\n    int a;\n    int setA() { a |= true; }\n};" always "class Fred {\n    int a;\n    int setA() { a |= true; }\n};"
Line 3507
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  3507 always 3507
  "" always ""
Line 3510
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  3510 always 3510
  "class foo {\npublic:\n    int x;\n    void a() { x = 1; }\n    void b() { a(); }\n};" always "class foo {\npublic:\n    int x;\n    void a() { x = 1; }\n    void b() { a(); }\n};"
Line 3516
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  3516 always 3516
  "" always ""
Line 3518
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  3518 always 3518
  "class Fred {\npublic:\n    int x;\n    int a() const { return x; }\n    void b() { a(); }\n};" always "class Fred {\npublic:\n    int x;\n    int a() const { return x; }\n    void b() { a(); }\n};"
Line 3524
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  3524 always 3524
  "[test.cpp:5]: (style, inconclusive) Technically the member function 'Fred::b' can be const.\n" always "[test.cpp:5]: (style, inconclusive) Technically the member function 'Fred::b' can be const.\n"
Line 3526
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  3526 always 3526
  "class Fred {\npublic:\n    int x;\n    void b() { a(); }\n};" always "class Fred {\npublic:\n    int x;\n    void b() { a(); }\n};"
Line 3531
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  3531 always 3531
  "[test.cpp:4]: (performance, inconclusive) Technically the member function 'Fred::b' can be static (but you may consider moving to unnamed namespace).\n" always "[test.cpp:4]: (performance, inconclusive) Technically the member function 'Fred::b' can be static (but you may consider moving to unnamed namespace).\n"
Line 3534
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  3534 always 3534
  "class foo\n{\npublic:\n    static unsigned get()\n    { return 0; }\n};" always "class foo\n{\npublic:\n    static unsigned get()\n    { return 0; }\n};"
Line 3540
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  3540 always 3540
  "" always ""
Line 3542
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  3542 always 3542
  "class Fred {\n    const std::string foo() const throw() { return \"\"; }\n};" always "class Fred {\n    const std::string foo() const throw() { return \"\"; }\n};"
Line 3545
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  3545 always 3545
  "[test.cpp:2]: (performance, inconclusive) Technically the member function 'Fred::foo' can be static (but you may consider moving to unnamed namespace).\n" always "[test.cpp:2]: (performance, inconclusive) Technically the member function 'Fred::foo' can be static (but you may consider moving to unnamed namespace).\n"
Line 3551
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  3551 always 3551
  "class Fred {\n    std::string s;\n    void foo() { s = \"\"; }\n};" always "class Fred {\n    std::string s;\n    void foo() { s = \"\"; }\n};"
Line 3555
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  3555 always 3555
  "" always ""
Line 3558
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  3558 always 3558
  "class Fred {\n    std::string s;\n    void foo(std::string & a) { a = s; }\n};" always "class Fred {\n    std::string s;\n    void foo(std::string & a) { a = s; }\n};"
Line 3562
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  3562 always 3562
  "[test.cpp:3]: (style, inconclusive) Technically the member function 'Fred::foo' can be const.\n" always "[test.cpp:3]: (style, inconclusive) Technically the member function 'Fred::foo' can be const.\n"
Line 3565
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  3565 always 3565
  "class Fred {\n    std::string s;\n    void foo(std::string & a) { s = a; }\n};" always "class Fred {\n    std::string s;\n    void foo(std::string & a) { s = a; }\n};"
Line 3569
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  3569 always 3569
  "" always ""
Line 3572
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  3572 always 3572
  "class Fred {\n    std::string s;\n    void foo(std::string & a, std::string & b) { a = s; b = s; }\n};" always "class Fred {\n    std::string s;\n    void foo(std::string & a, std::string & b) { a = s; b = s; }\n};"
Line 3576
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  3576 always 3576
  "[test.cpp:3]: (style, inconclusive) Technically the member function 'Fred::foo' can be const.\n" always "[test.cpp:3]: (style, inconclusive) Technically the member function 'Fred::foo' can be const.\n"
Line 3579
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  3579 always 3579
  "class Fred {\n    std::string s;\n    void foo(std::string & a, std::string & b) { s = a; s = b; }\n};" always "class Fred {\n    std::string s;\n    void foo(std::string & a, std::string & b) { s = a; s = b; }\n};"
Line 3583
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  3583 always 3583
  "" always ""
Line 3586
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  3586 always 3586
  "class Fred {\n    std::string s;\n    void foo(std::string & a, std::string & b) { s = a; b = a; }\n};" always "class Fred {\n    std::string s;\n    void foo(std::string & a, std::string & b) { s = a; b = a; }\n};"
Line 3590
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  3590 always 3590
  "" always ""
Line 3593
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  3593 always 3593
  "class Fred {\n    std::string s;\n    void foo(std::string & a, std::string & b) { a = s; s = b; }\n};" always "class Fred {\n    std::string s;\n    void foo(std::string & a, std::string & b) { a = s; s = b; }\n};"
Line 3597
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  3597 always 3597
  "" always ""
Line 3602
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  3602 always 3602
  "class Fred {\n    int s;\n    void foo(int * a) { *a = s; }\n};" always "class Fred {\n    int s;\n    void foo(int * a) { *a = s; }\n};"
Line 3606
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  3606 always 3606
  "[test.cpp:3]: (style, inconclusive) Technically the member function 'Fred::foo' can be const.\n" always "[test.cpp:3]: (style, inconclusive) Technically the member function 'Fred::foo' can be const.\n"
Line 3609
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  3609 always 3609
  "class Fred {\n    int s;\n    void foo(int * a) { s = *a; }\n};" always "class Fred {\n    int s;\n    void foo(int * a) { s = *a; }\n};"
Line 3613
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  3613 always 3613
  "" always ""
Line 3616
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  3616 always 3616
  "class Fred {\n    std::string s;\n    void foo(std::string * a, std::string * b) { *a = s; *b = s; }\n};" always "class Fred {\n    std::string s;\n    void foo(std::string * a, std::string * b) { *a = s; *b = s; }\n};"
Line 3620
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  3620 always 3620
  "[test.cpp:3]: (style, inconclusive) Technically the member function 'Fred::foo' can be const.\n" always "[test.cpp:3]: (style, inconclusive) Technically the member function 'Fred::foo' can be const.\n"
Line 3623
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  3623 always 3623
  "class Fred {\n    std::string s;\n    void foo(std::string * a, std::string * b) { s = *a; s = *b; }\n};" always "class Fred {\n    std::string s;\n    void foo(std::string * a, std::string * b) { s = *a; s = *b; }\n};"
Line 3627
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  3627 always 3627
  "" always ""
Line 3630
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  3630 always 3630
  "class Fred {\n    std::string s;\n    void foo(std::string * a, std::string * b) { s = *a; *b = s; }\n};" always "class Fred {\n    std::string s;\n    void foo(std::string * a, std::string * b) { s = *a; *b = s; }\n};"
Line 3634
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  3634 always 3634
  "" always ""
Line 3637
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  3637 always 3637
  "class Fred {\n    std::string s;\n    void foo(std::string * a, std::string * b) { *a = s; s = b; }\n};" always "class Fred {\n    std::string s;\n    void foo(std::string * a, std::string * b) { *a = s; s = b; }\n};"
Line 3641
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  3641 always 3641
  "" always ""
Line 3645
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  3645 always 3645
  "class Fred {\n    int a;\n    int getA();\n};\nint Fred::getA() { return a; }" always "class Fred {\n    int a;\n    int getA();\n};\nint Fred::getA() { return a; }"
Line 3650
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  3650 always 3650
  "[test.cpp:5] -> [test.cpp:3]: (style, inconclusive) Technically the member function 'Fred::getA' can be const.\n" always "[test.cpp:5] -> [test.cpp:3]: (style, inconclusive) Technically the member function 'Fred::getA' can be const.\n"
Line 3652
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  3652 always 3652
  "class Fred {\n    std::string s;\n    const std::string & foo();\n};\nconst std::string & Fred::foo() { return \"\"; }" always "class Fred {\n    std::string s;\n    const std::string & foo();\n};\nconst std::string & Fred::foo() { return \"\"; }"
Line 3657
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  3657 always 3657
  "[test.cpp:5] -> [test.cpp:3]: (performance, inconclusive) Technically the member function 'Fred::foo' can be static (but you may consider moving to unnamed namespace).\n" always "[test.cpp:5] -> [test.cpp:3]: (performance, inconclusive) Technically the member function 'Fred::foo' can be static (but you may consider moving to unnamed namespace).\n"
Line 3660
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  3660 always 3660
  "class Fred\n{\npublic:\n    int x;\n    void a() { x = 1; }\n    void b();\n};\nvoid Fred::b() { a(); }" always "class Fred\n{\npublic:\n    int x;\n    void a() { x = 1; }\n    void b();\n};\nvoid Fred::b() { a(); }"
Line 3668
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  3668 always 3668
  "" always ""
Line 3671
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  3671 always 3671
  "class Fred\n{\npublic:\n    static unsigned get();\n};\nstatic unsigned Fred::get() { return 0; }" always "class Fred\n{\npublic:\n    static unsigned get();\n};\nstatic unsigned Fred::get() { return 0; }"
Line 3677
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  3677 always 3677
  "" always ""
Line 3680
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  3680 always 3680
  "class Fred {\n    std::string s;\n    void foo();\n};\nvoid Fred::foo() { s = \"\"; }" always "class Fred {\n    std::string s;\n    void foo();\n};\nvoid Fred::foo() { s = \"\"; }"
Line 3685
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  3685 always 3685
  "" always ""
Line 3688
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  3688 always 3688
  "class Fred {\n    std::string s;\n    void foo(std::string & a);\n};\nvoid Fred::foo(std::string & a) { a = s; }" always "class Fred {\n    std::string s;\n    void foo(std::string & a);\n};\nvoid Fred::foo(std::string & a) { a = s; }"
Line 3693
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  3693 always 3693
  "[test.cpp:5] -> [test.cpp:3]: (style, inconclusive) Technically the member function 'Fred::foo' can be const.\n" always "[test.cpp:5] -> [test.cpp:3]: (style, inconclusive) Technically the member function 'Fred::foo' can be const.\n"
Line 3696
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  3696 always 3696
  "class Fred {\n    std::string s;\n    void foo(std::string & a);\n};\nvoid Fred::foo(std::string & a) { s = a; }" always "class Fred {\n    std::string s;\n    void foo(std::string & a);\n};\nvoid Fred::foo(std::string & a) { s = a; }"
Line 3701
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  3701 always 3701
  "" always ""
Line 3704
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  3704 always 3704
  "class Fred {\n    std::string s;\n    void foo(std::string & a, std::string & b);\n};\nvoid Fred::foo(std::string & a, std::string & b) { a = s; b = s; }" always "class Fred {\n    std::string s;\n    void foo(std::string & a, std::string & b);\n};\nvoid Fred::foo(std::string & a, std::string & b) { a = s; b = s; }"
Line 3709
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  3709 always 3709
  "[test.cpp:5] -> [test.cpp:3]: (style, inconclusive) Technically the member function 'Fred::foo' can be const.\n" always "[test.cpp:5] -> [test.cpp:3]: (style, inconclusive) Technically the member function 'Fred::foo' can be const.\n"
Line 3712
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  3712 always 3712
  "class Fred {\n    std::string s;\n    void foo(std::string & a, std::string & b);\n};\nvoid Fred::foo(std::string & a, std::string & b) { s = a; s = b; }" always "class Fred {\n    std::string s;\n    void foo(std::string & a, std::string & b);\n};\nvoid Fred::foo(std::string & a, std::string & b) { s = a; s = b; }"
Line 3717
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  3717 always 3717
  "" always ""
Line 3720
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  3720 always 3720
  "class Fred {\n    std::string s;\n    void foo(std::string & a, std::string & b);\n};\nvoid Fred::foo(std::string & a, std::string & b) { s = a; b = a; }" always "class Fred {\n    std::string s;\n    void foo(std::string & a, std::string & b);\n};\nvoid Fred::foo(std::string & a, std::string & b) { s = a; b = a; }"
Line 3725
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  3725 always 3725
  "" always ""
Line 3728
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  3728 always 3728
  "class Fred {\n    std::string s;\n    void foo(std::string & a, std::string & b);\n};\nvoid Fred::foo(std::string & a, std::string & b) { a = s; s = b; }" always "class Fred {\n    std::string s;\n    void foo(std::string & a, std::string & b);\n};\nvoid Fred::foo(std::string & a, std::string & b) { a = s; s = b; }"
Line 3733
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  3733 always 3733
  "" always ""
Line 3736
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  3736 always 3736
  "class Fred {\n    int s;\n    void foo(int * a);\n};\nvoid Fred::foo(int * a) { *a = s; }" always "class Fred {\n    int s;\n    void foo(int * a);\n};\nvoid Fred::foo(int * a) { *a = s; }"
Line 3741
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  3741 always 3741
  "[test.cpp:5] -> [test.cpp:3]: (style, inconclusive) Technically the member function 'Fred::foo' can be const.\n" always "[test.cpp:5] -> [test.cpp:3]: (style, inconclusive) Technically the member function 'Fred::foo' can be const.\n"
Line 3744
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  3744 always 3744
  "class Fred {\n    int s;\n    void foo(int * a);\n};\nvoid Fred::foo(int * a) { s = *a; }" always "class Fred {\n    int s;\n    void foo(int * a);\n};\nvoid Fred::foo(int * a) { s = *a; }"
Line 3749
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  3749 always 3749
  "" always ""
Line 3752
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  3752 always 3752
  "class Fred {\n    std::string s;\n    void foo(std::string * a, std::string * b);\n};\nvoid Fred::foo(std::string * a, std::string * b) { *a = s; *b = s; }" always "class Fred {\n    std::string s;\n    void foo(std::string * a, std::string * b);\n};\nvoid Fred::foo(std::string * a, std::string * b) { *a = s; *b = s; }"
Line 3757
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  3757 always 3757
  "[test.cpp:5] -> [test.cpp:3]: (style, inconclusive) Technically the member function 'Fred::foo' can be const.\n" always "[test.cpp:5] -> [test.cpp:3]: (style, inconclusive) Technically the member function 'Fred::foo' can be const.\n"
Line 3760
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  3760 always 3760
  "class Fred {\n    std::string s;\n    void foo(std::string * a, std::string * b);\n};\nvoid Fred::foo(std::string * a, std::string * b) { s = *a; s = *b; }" always "class Fred {\n    std::string s;\n    void foo(std::string * a, std::string * b);\n};\nvoid Fred::foo(std::string * a, std::string * b) { s = *a; s = *b; }"
Line 3765
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  3765 always 3765
  "" always ""
Line 3768
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  3768 always 3768
  "class Fred {\n    std::string s;\n    void foo(std::string * a, std::string * b);\n};\nvoid Fred::foo(std::string * a, std::string * b) { s = *a; *b = s; }" always "class Fred {\n    std::string s;\n    void foo(std::string * a, std::string * b);\n};\nvoid Fred::foo(std::string * a, std::string * b) { s = *a; *b = s; }"
Line 3773
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  3773 always 3773
  "" always ""
Line 3776
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  3776 always 3776
  "class Fred {\n    std::string s;\n    void foo(std::string * a, std::string * b);\n};\nvoid Fred::foo(std::string * a, std::string * b) { *a = s; s = b; }" always "class Fred {\n    std::string s;\n    void foo(std::string * a, std::string * b);\n};\nvoid Fred::foo(std::string * a, std::string * b) { *a = s; s = b; }"
Line 3781
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  3781 always 3781
  "" always ""
Line 3784
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  3784 always 3784
  "class Fred {\n    std::string s;\n    void foo();\n    void foo(std::string & a);\n    void foo(const std::string & a);\n};\nvoid Fred::foo() { }void Fred::foo(std::string & a) { a = s; }void Fred::foo(const std::string & a) { s = a; }" always "class Fred {\n    std::string s;\n    void foo();\n    void foo(std::string & a);\n    void foo(const std::string & a);\n};\nvoid Fred::foo() { }void Fred::foo(std::string & a) { a = s; }void Fred::foo(const std::string & a) { s = a; }"
Line 3793
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  3793 always 3793
  "[test.cpp:7] -> [test.cpp:3]: (performance, inconclusive) Technically the member function 'Fred::foo' can be static (but you may consider moving to unnamed namespace).\n[test.cpp:7] -> [test.cpp:4]: (style, inconclusive) Technically the member function 'Fred::foo' can be const.\n" always "[test.cpp:7] -> [test.cpp:3]: (performance, inconclusive) Technically the member function 'Fred::foo' can be static (but you may consider moving to unnamed namespace).\n[test.cpp:7] -> [test.cpp:4]: (style, inconclusive) Technically the member function 'Fred::foo' can be const.\n"
Line 3797
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  3797 always 3797
  "class Fred {\n    std::string s;\n    void foo1(int, int);\n    void foo2(int a, int b);\n    void foo3(int, int b);\n    void foo4(int a, int);\n    void foo5(int a, int b);\n};\nvoid Fred::foo1(int a, int b) { }\nvoid Fred::foo2(int c, int d) { }\nvoid Fred::foo3(int a, int b) { }\nvoid Fred::foo4(int a, int b) { }\nvoid Fred::foo5(int, int) { }" always "class Fred {\n    std::string s;\n    void foo1(int, int);\n    void foo2(int a, int b);\n    void foo3(int, int b);\n    void foo4(int a, int);\n    void foo5(int a, int b);\n};\nvoid Fred::foo1(int a, int b) { }\nvoid Fred::foo2(int c, int d) { }\nvoid Fred::foo3(int a, int b) { }\nvoid Fred::foo4(int a, int b) { }\nvoid Fred::foo5(int, int) { }"
Line 3810
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  3810 always 3810
  "[test.cpp:9] -> [test.cpp:3]: (performance, inconclusive) Technically the member function 'Fred::foo1' can be static (but you may consider moving to unnamed namespace).\n[test.cpp:10] -> [test.cpp:4]: (performance, inconclusive) Technically the member function 'Fred::foo2' can be static (but you may consider moving to unnamed namespace).\n[test.cpp:11] -> [test.cpp:5]: (performance, inconclusive) Technically the member function 'Fred::foo3' can be static (but you may consider moving to unnamed namespace).\n[test.cpp:12] -> [test.cpp:6]: (performance, inconclusive) Technically the member function 'Fred::foo4' can be static (but you may consider moving to unnamed namespace).\n[test.cpp:13] -> [test.cpp:7]: (performance, inconclusive) Technically the member function 'Fred::foo5' can be static (but you may consider moving to unnamed namespace).\n" always "[test.cpp:9] -> [test.cpp:3]: (performance, inconclusive) Technically the member function 'Fred::foo1' can be static (but you may consider moving to unnamed namespace).\n[test.cpp:10] -> [test.cpp:4]: (performance, inconclusive) Technically the member function 'Fred::foo2' can be static (but you may consider moving to unnamed namespace).\n[test.cpp:11] -> [test.cpp:5]: (performance, inconclusive) Technically the member function 'Fred::foo3' can be static (but you may consider moving to unnamed namespace).\n[test.cpp:12] -> [test.cpp:6]: (performance, inconclusive) Technically the member function 'Fred::foo4' can be static (but you may consider moving to unnamed namespace).\n[test.cpp:13] -> [test.cpp:7]: (performance, inconclusive) Technically the member function 'Fred::foo5' can be static (but you may consider moving to unnamed namespace).\n"
Line 3817
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  3817 always 3817
  "class Fred {\n    class A {\n        int a;\n        int getA() { return a; }\n    };\n};" always "class Fred {\n    class A {\n        int a;\n        int getA() { return a; }\n    };\n};"
Line 3823
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  3823 always 3823
  "[test.cpp:4]: (style, inconclusive) Technically the member function 'Fred::A::getA' can be const.\n" always "[test.cpp:4]: (style, inconclusive) Technically the member function 'Fred::A::getA' can be const.\n"
Line 3825
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  3825 always 3825
  "class Fred {\n    class A {\n        int a;\n        int getA();\n    };\n    int A::getA() { return a; }\n};" always "class Fred {\n    class A {\n        int a;\n        int getA();\n    };\n    int A::getA() { return a; }\n};"
Line 3832
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  3832 always 3832
  "[test.cpp:6] -> [test.cpp:4]: (style, inconclusive) Technically the member function 'Fred::A::getA' can be const.\n" always "[test.cpp:6] -> [test.cpp:4]: (style, inconclusive) Technically the member function 'Fred::A::getA' can be const.\n"
Line 3834
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  3834 always 3834
  "class Fred {\n    class A {\n        int a;\n        int getA();\n    };\n};\nint Fred::A::getA() { return a; }" always "class Fred {\n    class A {\n        int a;\n        int getA();\n    };\n};\nint Fred::A::getA() { return a; }"
Line 3841
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  3841 always 3841
  "[test.cpp:7] -> [test.cpp:4]: (style, inconclusive) Technically the member function 'Fred::A::getA' can be const.\n" always "[test.cpp:7] -> [test.cpp:4]: (style, inconclusive) Technically the member function 'Fred::A::getA' can be const.\n"
Line 3844
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  3844 always 3844
  "class Fred {\n    class B {\n        int b;\n        int getB() { return b; }\n        class A {\n            int a;\n            int getA() { return a; }\n        };\n    };\n};" always "class Fred {\n    class B {\n        int b;\n        int getB() { return b; }\n        class A {\n            int a;\n            int getA() { return a; }\n        };\n    };\n};"
Line 3854
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  3854 always 3854
  "[test.cpp:4]: (style, inconclusive) Technically the member function 'Fred::B::getB' can be const.\n[test.cpp:7]: (style, inconclusive) Technically the member function 'Fred::B::A::getA' can be const.\n" always "[test.cpp:4]: (style, inconclusive) Technically the member function 'Fred::B::getB' can be const.\n[test.cpp:7]: (style, inconclusive) Technically the member function 'Fred::B::A::getA' can be const.\n"
Line 3858
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  3858 always 3858
  "class Fred {\n    class B {\n        int b;\n        int getB();\n        class A {\n            int a;\n            int getA();\n        };\n        int A::getA() { return a; }\n    };\n    int B::getB() { return b; }\n};" always "class Fred {\n    class B {\n        int b;\n        int getB();\n        class A {\n            int a;\n            int getA();\n        };\n        int A::getA() { return a; }\n    };\n    int B::getB() { return b; }\n};"
Line 3870
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  3870 always 3870
  "[test.cpp:11] -> [test.cpp:4]: (style, inconclusive) Technically the member function 'Fred::B::getB' can be const.\n[test.cpp:9] -> [test.cpp:7]: (style, inconclusive) Technically the member function 'Fred::B::A::getA' can be const.\n" always "[test.cpp:11] -> [test.cpp:4]: (style, inconclusive) Technically the member function 'Fred::B::getB' can be const.\n[test.cpp:9] -> [test.cpp:7]: (style, inconclusive) Technically the member function 'Fred::B::A::getA' can be const.\n"
Line 3873
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  3873 always 3873
  "class Fred {\n    class B {\n        int b;\n        int getB();\n        class A {\n            int a;\n            int getA();\n        };\n    };\n    int B::A::getA() { return a; }\n    int B::getB() { return b; }\n};" always "class Fred {\n    class B {\n        int b;\n        int getB();\n        class A {\n            int a;\n            int getA();\n        };\n    };\n    int B::A::getA() { return a; }\n    int B::getB() { return b; }\n};"
Line 3885
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  3885 always 3885
  "[test.cpp:11] -> [test.cpp:4]: (style, inconclusive) Technically the member function 'Fred::B::getB' can be const.\n[test.cpp:10] -> [test.cpp:7]: (style, inconclusive) Technically the member function 'Fred::B::A::getA' can be const.\n" always "[test.cpp:11] -> [test.cpp:4]: (style, inconclusive) Technically the member function 'Fred::B::getB' can be const.\n[test.cpp:10] -> [test.cpp:7]: (style, inconclusive) Technically the member function 'Fred::B::A::getA' can be const.\n"
Line 3888
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  3888 always 3888
  "class Fred {\n    class B {\n        int b;\n        int getB();\n        class A {\n            int a;\n            int getA();\n        };\n    };\n};\nint Fred::B::A::getA() { return a; }\nint Fred::B::getB() { return b; }" always "class Fred {\n    class B {\n        int b;\n        int getB();\n        class A {\n            int a;\n            int getA();\n        };\n    };\n};\nint Fred::B::A::getA() { return a; }\nint Fred::B::getB() { return b; }"
Line 3900
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  3900 always 3900
  "[test.cpp:12] -> [test.cpp:4]: (style, inconclusive) Technically the member function 'Fred::B::getB' can be const.\n[test.cpp:11] -> [test.cpp:7]: (style, inconclusive) Technically the member function 'Fred::B::A::getA' can be const.\n" always "[test.cpp:12] -> [test.cpp:4]: (style, inconclusive) Technically the member function 'Fred::B::getB' can be const.\n[test.cpp:11] -> [test.cpp:7]: (style, inconclusive) Technically the member function 'Fred::B::A::getA' can be const.\n"
Line 3906
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  3906 always 3906
  "struct Fred {\n    int a;\n    bool operator<(const Fred &f) { return a < f.a; }\n};" always "struct Fred {\n    int a;\n    bool operator<(const Fred &f) { return a < f.a; }\n};"
Line 3910
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  3910 always 3910
  "[test.cpp:3]: (style, inconclusive) Technically the member function 'Fred::operator<' can be const.\n" always "[test.cpp:3]: (style, inconclusive) Technically the member function 'Fred::operator<' can be const.\n"
Line 3915
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  3915 always 3915
  "struct Foo {\n    void operator<<(int);\n};\nstruct Fred {\n    Foo foo;\n    void x()\n    {\n        foo << 123;\n    }\n};" always "struct Foo {\n    void operator<<(int);\n};\nstruct Fred {\n    Foo foo;\n    void x()\n    {\n        foo << 123;\n    }\n};"
Line 3925
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  3925 always 3925
  "" always ""
Line 3927
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  3927 always 3927
  "struct Foo {\n    void operator<<(int);\n};\nstruct Fred {\n    Foo foo;\n    void x()\n    {\n        std::cout << foo << 123;\n    }\n};" always "struct Foo {\n    void operator<<(int);\n};\nstruct Fred {\n    Foo foo;\n    void x()\n    {\n        std::cout << foo << 123;\n    }\n};"
Line 3937
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  3937 always 3937
  "[test.cpp:6]: (style, inconclusive) Technically the member function 'Fred::x' can be const.\n" always "[test.cpp:6]: (style, inconclusive) Technically the member function 'Fred::x' can be const.\n"
Line 3941
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  3941 always 3941
  "struct Fred {\n    int array[10];\n    int const & operator [] (unsigned int index) const { return array[index]; }\n    int & operator [] (unsigned int index) { return array[index]; }\n};" always "struct Fred {\n    int array[10];\n    int const & operator [] (unsigned int index) const { return array[index]; }\n    int & operator [] (unsigned int index) { return array[index]; }\n};"
Line 3946
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  3946 always 3946
  "" always ""
Line 3948
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  3948 always 3948
  "struct Fred {\n    int array[10];\n    int const & operator [] (unsigned int index) { return array[index]; }\n};" always "struct Fred {\n    int array[10];\n    int const & operator [] (unsigned int index) { return array[index]; }\n};"
Line 3952
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  3952 always 3952
  "[test.cpp:3]: (style, inconclusive) Technically the member function 'Fred::operator[]' can be const.\n" always "[test.cpp:3]: (style, inconclusive) Technically the member function 'Fred::operator[]' can be const.\n"
Line 3957
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  3957 always 3957
  "class A {\n    int c;\npublic:\n    operator int*() { return &c; };\n};" always "class A {\n    int c;\npublic:\n    operator int*() { return &c; };\n};"
Line 3962
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  3962 always 3962
  "" always ""
Line 3964
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  3964 always 3964
  "class A {\n    int c;\npublic:\n    operator const int*() { return &c; };\n};" always "class A {\n    int c;\npublic:\n    operator const int*() { return &c; };\n};"
Line 3969
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  3969 always 3969
  "[test.cpp:4]: (style, inconclusive) Technically the member function 'A::operatorconstint*' can be const.\n" always "[test.cpp:4]: (style, inconclusive) Technically the member function 'A::operatorconstint*' can be const.\n"
Line 3972
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  3972 always 3972
  "struct Fred {\n    int array[10];\n    typedef int* (Fred::*UnspecifiedBoolType);\n    operator UnspecifiedBoolType() { };\n};" always "struct Fred {\n    int array[10];\n    typedef int* (Fred::*UnspecifiedBoolType);\n    operator UnspecifiedBoolType() { };\n};"
Line 3977
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  3977 always 3977
  "[test.cpp:4]: (style, inconclusive) Technically the member function 'Fred::operatorint**' can be const.\n" always "[test.cpp:4]: (style, inconclusive) Technically the member function 'Fred::operatorint**' can be const.\n"
  "" always ""
Line 3979
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  3979 always 3979
  "struct Fred {\n    int array[10];\n    typedef int* (Fred::*UnspecifiedBoolType);\n    operator UnspecifiedBoolType() { array[0] = 0; };\n};" always "struct Fred {\n    int array[10];\n    typedef int* (Fred::*UnspecifiedBoolType);\n    operator UnspecifiedBoolType() { array[0] = 0; };\n};"
Line 3984
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  3984 always 3984
  "" always ""
Line 3988
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  3988 always 3988
  "class A {\n    int c;\npublic:\n    operator int& () {return c}\n};" always "class A {\n    int c;\npublic:\n    operator int& () {return c}\n};"
Line 3993
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  3993 always 3993
  "" always ""
Line 3995
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  3995 always 3995
  "class A {\n    int c;\npublic:\n    operator const int& () {return c}\n};" always "class A {\n    int c;\npublic:\n    operator const int& () {return c}\n};"
Line 4000
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  4000 always 4000
  "[test.cpp:4]: (style, inconclusive) Technically the member function 'A::operatorconstint&' can be const.\n" always "[test.cpp:4]: (style, inconclusive) Technically the member function 'A::operatorconstint&' can be const.\n"
Line 4002
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  4002 always 4002
  "class A {\n    int c;\npublic:\n    operator int () {return c}\n};" always "class A {\n    int c;\npublic:\n    operator int () {return c}\n};"
Line 4007
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  4007 always 4007
  "[test.cpp:4]: (style, inconclusive) Technically the member function 'A::operatorint' can be const.\n" always "[test.cpp:4]: (style, inconclusive) Technically the member function 'A::operatorint' can be const.\n"
Line 4011
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  4011 always 4011
  "class A {\n    int c;\n    void f() { os >> *this; }\n};" always "class A {\n    int c;\n    void f() { os >> *this; }\n};"
Line 4015
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  4015 always 4015
  "" always ""
Line 4020
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  4020 always 4020
  "class A {\n    int a;\n    bool foo(int i)\n    {\n        bool same;\n        same = (i == a);\n        return same;\n    }\n};" always "class A {\n    int a;\n    bool foo(int i)\n    {\n        bool same;\n        same = (i == a);\n        return same;\n    }\n};"
Line 4029
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  4029 always 4029
  "[test.cpp:3]: (style, inconclusive) Technically the member function 'A::foo' can be const.\n" always "[test.cpp:3]: (style, inconclusive) Technically the member function 'A::foo' can be const.\n"
Line 4034
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  4034 always 4034
  "class foo {\npublic:\n};\nvoid bar() {}" always "class foo {\npublic:\n};\nvoid bar() {}"
Line 4038
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  4038 always 4038
  "" always ""
Line 4040
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  4040 always 4040
  "class Fred\n{\npublic:\n    void foo() { }\n};" always "class Fred\n{\npublic:\n    void foo() { }\n};"
Line 4045
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  4045 always 4045
  "[test.cpp:4]: (performance, inconclusive) Technically the member function 'Fred::foo' can be static (but you may consider moving to unnamed namespace).\n" always "[test.cpp:4]: (performance, inconclusive) Technically the member function 'Fred::foo' can be static (but you may consider moving to unnamed namespace).\n"
Line 4047
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  4047 always 4047
  "struct fast_string\n{\n    union\n    {\n        char buff[100];\n    };\n    void set_type(char t);\n};\ninline void fast_string::set_type(char t)\n{\n    buff[10] = t;\n}" always "struct fast_string\n{\n    union\n    {\n        char buff[100];\n    };\n    void set_type(char t);\n};\ninline void fast_string::set_type(char t)\n{\n    buff[10] = t;\n}"
Line 4059
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  4059 always 4059
  "" always ""
Line 4063
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  4063 always 4063
  "class foo {\n    int a;\npublic:\n    void set(int i) { a = i; }\n    void set(const foo & f) { *this = f; }\n};\nvoid bar() {}" always "class foo {\n    int a;\npublic:\n    void set(int i) { a = i; }\n    void set(const foo & f) { *this = f; }\n};\nvoid bar() {}"
Line 4070
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  4070 always 4070
  "" always ""
Line 4075
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  4075 always 4075
  "class A {\npublic:\n    A():m_strValue(\"\"){}\n    std::string strGetString() { return m_strValue; }\nprivate:\n    std::string m_strValue;\n};" always "class A {\npublic:\n    A():m_strValue(\"\"){}\n    std::string strGetString() { return m_strValue; }\nprivate:\n    std::string m_strValue;\n};"
Line 4082
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  4082 always 4082
  "[test.cpp:4]: (style, inconclusive) Technically the member function 'A::strGetString' can be const.\n" always "[test.cpp:4]: (style, inconclusive) Technically the member function 'A::strGetString' can be const.\n"
Line 4087
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  4087 always 4087
  "class wxThreadInternal {\npublic:\n    void SetExitCode(wxThread::ExitCode exitcode) { m_exitcode = exitcode; }\nprivate:\n    wxThread::ExitCode m_exitcode;\n};" always "class wxThreadInternal {\npublic:\n    void SetExitCode(wxThread::ExitCode exitcode) { m_exitcode = exitcode; }\nprivate:\n    wxThread::ExitCode m_exitcode;\n};"
Line 4093
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  4093 always 4093
  "" always ""
Line 4098
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  4098 always 4098
  "class A {\npublic:\n    int foo() { return x = 0; }\nprivate:\n    int x;\n};" always "class A {\npublic:\n    int foo() { return x = 0; }\nprivate:\n    int x;\n};"
Line 4104
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  4104 always 4104
  "" always ""
Line 4106
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  4106 always 4106
  "class A {\npublic:\n    int foo() { return x ? x : x = 0; }\nprivate:\n    int x;\n};" always "class A {\npublic:\n    int foo() { return x ? x : x = 0; }\nprivate:\n    int x;\n};"
Line 4112
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  4112 always 4112
  "" always ""
Line 4114
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  4114 always 4114
  "class A {\npublic:\n    int foo() { return x ? x = 0 : x; }\nprivate:\n    int x;\n};" always "class A {\npublic:\n    int foo() { return x ? x = 0 : x; }\nprivate:\n    int x;\n};"
Line 4120
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  4120 always 4120
  "" always ""
Line 4125
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  4125 always 4125
  "class A {\npublic:\n    void set(struct tm time) { m_time = time; }\nprivate:\n    struct tm m_time;\n};" always "class A {\npublic:\n    void set(struct tm time) { m_time = time; }\nprivate:\n    struct tm m_time;\n};"
Line 4131
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  4131 always 4131
  "" always ""
Line 4136
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  4136 always 4136
  "class A {\npublic:\n    int foo() { x = 0; }\nprivate:\n    mutable int x;\n};" always "class A {\npublic:\n    int foo() { x = 0; }\nprivate:\n    mutable int x;\n};"
Line 4142
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  4142 always 4142
  "[test.cpp:3]: (style, inconclusive) Technically the member function 'A::foo' can be const.\n" always "[test.cpp:3]: (style, inconclusive) Technically the member function 'A::foo' can be const.\n"
Line 4147
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  4147 always 4147
  "class A {\npublic:\n    A(){}\n    std::vector<int> GetVec()  {return m_vec;}\n    std::pair<int,double> GetPair() {return m_pair;}\nprivate:\n    std::vector<int> m_vec;\n    std::pair<int,double> m_pair;\n};" always "class A {\npublic:\n    A(){}\n    std::vector<int> GetVec()  {return m_vec;}\n    std::pair<int,double> GetPair() {return m_pair;}\nprivate:\n    std::vector<int> m_vec;\n    std::pair<int,double> m_pair;\n};"
Line 4156
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  4156 always 4156
  "[test.cpp:4]: (style, inconclusive) Technically the member function 'A::GetVec' can be const.\n[test.cpp:5]: (style, inconclusive) Technically the member function 'A::GetPair' can be const.\n" always "[test.cpp:4]: (style, inconclusive) Technically the member function 'A::GetVec' can be const.\n[test.cpp:5]: (style, inconclusive) Technically the member function 'A::GetPair' can be const.\n"
Line 4159
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  4159 always 4159
  "class A {\npublic:\n    A(){}\n    const std::vector<int> & GetVec()  {return m_vec;}\n    const std::pair<int,double> & GetPair() {return m_pair;}\nprivate:\n    std::vector<int> m_vec;\n    std::pair<int,double> m_pair;\n};" always "class A {\npublic:\n    A(){}\n    const std::vector<int> & GetVec()  {return m_vec;}\n    const std::pair<int,double> & GetPair() {return m_pair;}\nprivate:\n    std::vector<int> m_vec;\n    std::pair<int,double> m_pair;\n};"
Line 4168
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  4168 always 4168
  "[test.cpp:4]: (style, inconclusive) Technically the member function 'A::GetVec' can be const.\n[test.cpp:5]: (style, inconclusive) Technically the member function 'A::GetPair' can be const.\n" always "[test.cpp:4]: (style, inconclusive) Technically the member function 'A::GetVec' can be const.\n[test.cpp:5]: (style, inconclusive) Technically the member function 'A::GetPair' can be const.\n"
Line 4174
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  4174 always 4174
  "class A {\npublic:\n    A(){}\n    std::pair<std::vector<int>,double> GetPair() {return m_pair;}\nprivate:\n    std::pair<std::vector<int>,double> m_pair;\n};" always "class A {\npublic:\n    A(){}\n    std::pair<std::vector<int>,double> GetPair() {return m_pair;}\nprivate:\n    std::pair<std::vector<int>,double> m_pair;\n};"
Line 4181
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  4181 always 4181
  "[test.cpp:4]: (style, inconclusive) Technically the member function 'A::GetPair' can be const.\n" always "[test.cpp:4]: (style, inconclusive) Technically the member function 'A::GetPair' can be const.\n"
Line 4183
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  4183 always 4183
  "class A {\npublic:\n    A(){}\n    const std::pair<std::vector<int>,double>& GetPair() {return m_pair;}\nprivate:\n    std::pair<std::vector<int>,double> m_pair;\n};" always "class A {\npublic:\n    A(){}\n    const std::pair<std::vector<int>,double>& GetPair() {return m_pair;}\nprivate:\n    std::pair<std::vector<int>,double> m_pair;\n};"
Line 4190
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  4190 always 4190
  "[test.cpp:4]: (style, inconclusive) Technically the member function 'A::GetPair' can be const.\n" always "[test.cpp:4]: (style, inconclusive) Technically the member function 'A::GetPair' can be const.\n"
Line 4192
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  4192 always 4192
  "class A {\npublic:\n    A(){}\n    std::pair<std::vector<int>,double>& GetPair() {return m_pair;}\nprivate:\n    std::pair<std::vector<int>,double> m_pair;\n};" always "class A {\npublic:\n    A(){}\n    std::pair<std::vector<int>,double>& GetPair() {return m_pair;}\nprivate:\n    std::pair<std::vector<int>,double> m_pair;\n};"
Line 4199
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  4199 always 4199
  "" always ""
Line 4202
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  4202 always 4202
  "using namespace std;class A {\npublic:\n    A(){}\n    pair<int ,double> GetPair() {return m_pair;}\nprivate:\n    pair<int ,double> m_pair;\n};" always "using namespace std;class A {\npublic:\n    A(){}\n    pair<int ,double> GetPair() {return m_pair;}\nprivate:\n    pair<int ,double> m_pair;\n};"
Line 4210
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  4210 always 4210
  "[test.cpp:4]: (style, inconclusive) Technically the member function 'A::GetPair' can be const.\n" always "[test.cpp:4]: (style, inconclusive) Technically the member function 'A::GetPair' can be const.\n"
Line 4212
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  4212 always 4212
  "using namespace std;class A {\npublic:\n    A(){}\n    const pair<int ,double> & GetPair() {return m_pair;}\nprivate:\n    pair<int ,double> m_pair;\n};" always "using namespace std;class A {\npublic:\n    A(){}\n    const pair<int ,double> & GetPair() {return m_pair;}\nprivate:\n    pair<int ,double> m_pair;\n};"
Line 4220
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  4220 always 4220
  "[test.cpp:4]: (style, inconclusive) Technically the member function 'A::GetPair' can be const.\n" always "[test.cpp:4]: (style, inconclusive) Technically the member function 'A::GetPair' can be const.\n"
Line 4222
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  4222 always 4222
  "using namespace std;class A {\npublic:\n    A(){}\n    pair<int ,double> & GetPair() {return m_pair;}\nprivate:\n    pair<int ,double> m_pair;\n};" always "using namespace std;class A {\npublic:\n    A(){}\n    pair<int ,double> & GetPair() {return m_pair;}\nprivate:\n    pair<int ,double> m_pair;\n};"
Line 4230
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  4230 always 4230
  "" always ""
Line 4233
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  4233 always 4233
  "class A {\npublic:\n    A(){}\n    std::pair< int,std::vector<int> >  GetPair() {return m_pair;}\nprivate:\n    std::pair< int,std::vector<int> >  m_pair;\n};" always "class A {\npublic:\n    A(){}\n    std::pair< int,std::vector<int> >  GetPair() {return m_pair;}\nprivate:\n    std::pair< int,std::vector<int> >  m_pair;\n};"
Line 4240
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  4240 always 4240
  "[test.cpp:4]: (style, inconclusive) Technically the member function 'A::GetPair' can be const.\n" always "[test.cpp:4]: (style, inconclusive) Technically the member function 'A::GetPair' can be const.\n"
Line 4242
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  4242 always 4242
  "class A {\npublic:\n    A(){}\n    const std::pair< int,std::vector<int> >&  GetPair() {return m_pair;}\nprivate:\n    std::pair< int,std::vector<int> >  m_pair;\n};" always "class A {\npublic:\n    A(){}\n    const std::pair< int,std::vector<int> >&  GetPair() {return m_pair;}\nprivate:\n    std::pair< int,std::vector<int> >  m_pair;\n};"
Line 4249
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  4249 always 4249
  "[test.cpp:4]: (style, inconclusive) Technically the member function 'A::GetPair' can be const.\n" always "[test.cpp:4]: (style, inconclusive) Technically the member function 'A::GetPair' can be const.\n"
Line 4251
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  4251 always 4251
  "class A {\npublic:\n    A(){}\n    std::pair< int,std::vector<int> >&  GetPair() {return m_pair;}\nprivate:\n    std::pair< int,std::vector<int> >  m_pair;\n};" always "class A {\npublic:\n    A(){}\n    std::pair< int,std::vector<int> >&  GetPair() {return m_pair;}\nprivate:\n    std::pair< int,std::vector<int> >  m_pair;\n};"
Line 4258
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  4258 always 4258
  "" always ""
Line 4261
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  4261 always 4261
  "using namespace std;class A {\npublic:\n    A(){}\n    pair< vector<int>, int >  GetPair() {return m_pair;}\nprivate:\n    pair< vector<int>, int >  m_pair;\n};" always "using namespace std;class A {\npublic:\n    A(){}\n    pair< vector<int>, int >  GetPair() {return m_pair;}\nprivate:\n    pair< vector<int>, int >  m_pair;\n};"
Line 4269
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  4269 always 4269
  "[test.cpp:4]: (style, inconclusive) Technically the member function 'A::GetPair' can be const.\n" always "[test.cpp:4]: (style, inconclusive) Technically the member function 'A::GetPair' can be const.\n"
Line 4271
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  4271 always 4271
  "using namespace std;class A {\npublic:\n    A(){}\n    const pair< vector<int>, int >&  GetPair() {return m_pair;}\nprivate:\n    pair< vector<int>, int >  m_pair;\n};" always "using namespace std;class A {\npublic:\n    A(){}\n    const pair< vector<int>, int >&  GetPair() {return m_pair;}\nprivate:\n    pair< vector<int>, int >  m_pair;\n};"
Line 4279
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  4279 always 4279
  "[test.cpp:4]: (style, inconclusive) Technically the member function 'A::GetPair' can be const.\n" always "[test.cpp:4]: (style, inconclusive) Technically the member function 'A::GetPair' can be const.\n"
Line 4281
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  4281 always 4281
  "using namespace std;class A {\npublic:\n    A(){}\n    pair< vector<int>, int >&  GetPair() {return m_pair;}\nprivate:\n    pair< vector<int>, int >  m_pair;\n};" always "using namespace std;class A {\npublic:\n    A(){}\n    pair< vector<int>, int >&  GetPair() {return m_pair;}\nprivate:\n    pair< vector<int>, int >  m_pair;\n};"
Line 4289
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  4289 always 4289
  "" always ""
Line 4291
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  4291 always 4291
  "class A {\npublic:\n    A(){}\n    std::pair< std::vector<int>,std::vector<int> >  GetPair() {return m_pair;}\nprivate:\n    std::pair< std::vector<int>,std::vector<int> >  m_pair;\n};" always "class A {\npublic:\n    A(){}\n    std::pair< std::vector<int>,std::vector<int> >  GetPair() {return m_pair;}\nprivate:\n    std::pair< std::vector<int>,std::vector<int> >  m_pair;\n};"
Line 4298
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  4298 always 4298
  "[test.cpp:4]: (style, inconclusive) Technically the member function 'A::GetPair' can be const.\n" always "[test.cpp:4]: (style, inconclusive) Technically the member function 'A::GetPair' can be const.\n"
Line 4300
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  4300 always 4300
  "class A {\npublic:\n    A(){}\n    const std::pair< std::vector<int>,std::vector<int> >&  GetPair() {return m_pair;}\nprivate:\n    std::pair< std::vector<int>,std::vector<int> >  m_pair;\n};" always "class A {\npublic:\n    A(){}\n    const std::pair< std::vector<int>,std::vector<int> >&  GetPair() {return m_pair;}\nprivate:\n    std::pair< std::vector<int>,std::vector<int> >  m_pair;\n};"
Line 4307
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  4307 always 4307
  "[test.cpp:4]: (style, inconclusive) Technically the member function 'A::GetPair' can be const.\n" always "[test.cpp:4]: (style, inconclusive) Technically the member function 'A::GetPair' can be const.\n"
Line 4309
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  4309 always 4309
  "class A {\npublic:\n    A(){}\n    std::pair< std::vector<int>,std::vector<int> >&  GetPair() {return m_pair;}\nprivate:\n    std::pair< std::vector<int>,std::vector<int> >  m_pair;\n};" always "class A {\npublic:\n    A(){}\n    std::pair< std::vector<int>,std::vector<int> >&  GetPair() {return m_pair;}\nprivate:\n    std::pair< std::vector<int>,std::vector<int> >  m_pair;\n};"
Line 4316
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  4316 always 4316
  "" always ""
Line 4320
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  4320 always 4320
  "class A {\npublic:\n    A(){}\n    std::pair< std::pair < int, char > , int >  GetPair() {return m_pair;}\nprivate:\n    std::pair< std::pair < int, char > , int >  m_pair;\n};" always "class A {\npublic:\n    A(){}\n    std::pair< std::pair < int, char > , int >  GetPair() {return m_pair;}\nprivate:\n    std::pair< std::pair < int, char > , int >  m_pair;\n};"
Line 4327
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  4327 always 4327
  "[test.cpp:4]: (style, inconclusive) Technically the member function 'A::GetPair' can be const.\n" always "[test.cpp:4]: (style, inconclusive) Technically the member function 'A::GetPair' can be const.\n"
Line 4329
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  4329 always 4329
  "class A {\npublic:\n    A(){}\n    const std::pair< std::pair < int, char > , int > & GetPair() {return m_pair;}\nprivate:\n    std::pair< std::pair < int, char > , int >  m_pair;\n};" always "class A {\npublic:\n    A(){}\n    const std::pair< std::pair < int, char > , int > & GetPair() {return m_pair;}\nprivate:\n    std::pair< std::pair < int, char > , int >  m_pair;\n};"
Line 4336
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  4336 always 4336
  "[test.cpp:4]: (style, inconclusive) Technically the member function 'A::GetPair' can be const.\n" always "[test.cpp:4]: (style, inconclusive) Technically the member function 'A::GetPair' can be const.\n"
Line 4338
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  4338 always 4338
  "class A {\npublic:\n    A(){}\n    std::pair< std::pair < int, char > , int > & GetPair() {return m_pair;}\nprivate:\n    std::pair< std::pair < int, char > , int >  m_pair;\n};" always "class A {\npublic:\n    A(){}\n    std::pair< std::pair < int, char > , int > & GetPair() {return m_pair;}\nprivate:\n    std::pair< std::pair < int, char > , int >  m_pair;\n};"
Line 4345
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  4345 always 4345
  "" always ""
Line 4348
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  4348 always 4348
  "class A {\npublic:\n    A(){}\n    std::pair< int , std::pair < int, char > >  GetPair() {return m_pair;}\nprivate:\n    std::pair< int , std::pair < int, char > >  m_pair;\n};" always "class A {\npublic:\n    A(){}\n    std::pair< int , std::pair < int, char > >  GetPair() {return m_pair;}\nprivate:\n    std::pair< int , std::pair < int, char > >  m_pair;\n};"
Line 4355
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  4355 always 4355
  "[test.cpp:4]: (style, inconclusive) Technically the member function 'A::GetPair' can be const.\n" always "[test.cpp:4]: (style, inconclusive) Technically the member function 'A::GetPair' can be const.\n"
Line 4357
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  4357 always 4357
  "class A {\npublic:\n    A(){}\n    const std::pair< int , std::pair < int, char > >&  GetPair() {return m_pair;}\nprivate:\n    std::pair< int , std::pair < int, char > >  m_pair;\n};" always "class A {\npublic:\n    A(){}\n    const std::pair< int , std::pair < int, char > >&  GetPair() {return m_pair;}\nprivate:\n    std::pair< int , std::pair < int, char > >  m_pair;\n};"
Line 4364
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  4364 always 4364
  "[test.cpp:4]: (style, inconclusive) Technically the member function 'A::GetPair' can be const.\n" always "[test.cpp:4]: (style, inconclusive) Technically the member function 'A::GetPair' can be const.\n"
Line 4366
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  4366 always 4366
  "class A {\npublic:\n    A(){}\n    std::pair< int , std::pair < int, char > >&  GetPair() {return m_pair;}\nprivate:\n    std::pair< int , std::pair < int, char > >  m_pair;\n};" always "class A {\npublic:\n    A(){}\n    std::pair< int , std::pair < int, char > >&  GetPair() {return m_pair;}\nprivate:\n    std::pair< int , std::pair < int, char > >  m_pair;\n};"
Line 4373
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  4373 always 4373
  "" always ""
Line 4376
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  4376 always 4376
  "using namespace std;class A {\npublic:\n    A(){}\n    vector<int>  GetVec() {return m_Vec;}\nprivate:\n    vector<int>  m_Vec;\n};" always "using namespace std;class A {\npublic:\n    A(){}\n    vector<int>  GetVec() {return m_Vec;}\nprivate:\n    vector<int>  m_Vec;\n};"
Line 4384
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  4384 always 4384
  "[test.cpp:4]: (style, inconclusive) Technically the member function 'A::GetVec' can be const.\n" always "[test.cpp:4]: (style, inconclusive) Technically the member function 'A::GetVec' can be const.\n"
Line 4386
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  4386 always 4386
  "using namespace std;class A {\npublic:\n    A(){}\n    const vector<int>&  GetVec() {return m_Vec;}\nprivate:\n    vector<int>  m_Vec;\n};" always "using namespace std;class A {\npublic:\n    A(){}\n    const vector<int>&  GetVec() {return m_Vec;}\nprivate:\n    vector<int>  m_Vec;\n};"
Line 4394
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  4394 always 4394
  "[test.cpp:4]: (style, inconclusive) Technically the member function 'A::GetVec' can be const.\n" always "[test.cpp:4]: (style, inconclusive) Technically the member function 'A::GetVec' can be const.\n"
Line 4396
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  4396 always 4396
  "using namespace std;class A {\npublic:\n    A(){}\n    vector<int>&  GetVec() {return m_Vec;}\nprivate:\n    vector<int>  m_Vec;\n};" always "using namespace std;class A {\npublic:\n    A(){}\n    vector<int>&  GetVec() {return m_Vec;}\nprivate:\n    vector<int>  m_Vec;\n};"
Line 4404
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  4404 always 4404
  "" always ""
Line 4407
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  4407 always 4407
  "class A {\npublic:\n    int * * foo() { return &x; }\nprivate:\n    const int * x;\n};" always "class A {\npublic:\n    int * * foo() { return &x; }\nprivate:\n    const int * x;\n};"
Line 4413
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  4413 always 4413
  "" always ""
Line 4415
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  4415 always 4415
  "class A {\npublic:\n    const int ** foo() { return &x; }\nprivate:\n    const int * x;\n};" always "class A {\npublic:\n    const int ** foo() { return &x; }\nprivate:\n    const int * x;\n};"
Line 4421
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  4421 always 4421
  "[test.cpp:3]: (style, inconclusive) Technically the member function 'A::foo' can be const.\n" always "[test.cpp:3]: (style, inconclusive) Technically the member function 'A::foo' can be const.\n"
Line 4425
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  4425 always 4425
  "class Fred {\n    unsigned long long int a;\n    unsigned long long int getA() { return a; }\n};" always "class Fred {\n    unsigned long long int a;\n    unsigned long long int getA() { return a; }\n};"
Line 4429
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  4429 always 4429
  "[test.cpp:3]: (style, inconclusive) Technically the member function 'Fred::getA' can be const.\n" always "[test.cpp:3]: (style, inconclusive) Technically the member function 'Fred::getA' can be const.\n"
Line 4432
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  4432 always 4432
  "class Fred {\n    unsigned long long int a;\npublic:\n    Fred() { }\n};" always "class Fred {\n    unsigned long long int a;\npublic:\n    Fred() { }\n};"
Line 4437
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  4437 always 4437
  "" always ""
Line 4440
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  4440 always 4440
  "class Fred {\n    unsigned long long int a;\n    unsigned long long int setA() { a |= true; }\n};" always "class Fred {\n    unsigned long long int a;\n    unsigned long long int setA() { a |= true; }\n};"
Line 4444
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  4444 always 4444
  "" always ""
Line 4447
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  4447 always 4447
  "class foo\n{\npublic:\n    static unsigned long long int get()\n    { return 0; }\n};" always "class foo\n{\npublic:\n    static unsigned long long int get()\n    { return 0; }\n};"
Line 4453
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  4453 always 4453
  "" always ""
Line 4458
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  4458 always 4458
  "class Fred {\n    int a;\n    void set(int i) { Fred::a = i; }\n};" always "class Fred {\n    int a;\n    void set(int i) { Fred::a = i; }\n};"
Line 4462
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  4462 always 4462
  "" always ""
Line 4467
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  4467 always 4467
  "class Fred {\npublic:\n    void set(int i, int j) { a[i].k = i; }\nprivate:\n    struct { int k; } a[4];\n};" always "class Fred {\npublic:\n    void set(int i, int j) { a[i].k = i; }\nprivate:\n    struct { int k; } a[4];\n};"
Line 4473
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  4473 always 4473
  "" always ""
Line 4477
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  4477 always 4477
  "class Fred {\nstatic int x;\npublic:\n    void set(int i) { x = i; }\n};" always "class Fred {\nstatic int x;\npublic:\n    void set(int i) { x = i; }\n};"
Line 4482
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  4482 always 4482
  "[test.cpp:4]: (performance, inconclusive) Technically the member function 'Fred::set' can be static (but you may consider moving to unnamed namespace).\n" always "[test.cpp:4]: (performance, inconclusive) Technically the member function 'Fred::set' can be static (but you may consider moving to unnamed namespace).\n"
Line 4487
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  4487 always 4487
  "using namespace std;\nclass Fred {\nprivate:\n    std::string s;\npublic:\n    void set(std::string ss) { s = ss; }\n};" always "using namespace std;\nclass Fred {\nprivate:\n    std::string s;\npublic:\n    void set(std::string ss) { s = ss; }\n};"
Line 4494
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  4494 always 4494
  "" always ""
Line 4499
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  4499 always 4499
  "class Fred {\n    int x : 3;\npublic:\n    void set(int i) { x = i; }\n};" always "class Fred {\n    int x : 3;\npublic:\n    void set(int i) { x = i; }\n};"
Line 4504
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  4504 always 4504
  "" always ""
Line 4506
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  4506 always 4506
  "class Fred {\n    list<int *> x;\npublic:\n    list<int *> get() { return x; }\n};" always "class Fred {\n    list<int *> x;\npublic:\n    list<int *> get() { return x; }\n};"
Line 4511
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  4511 always 4511
  "" always ""
Line 4513
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  4513 always 4513
  "class Fred {\n    list<const int *> x;\npublic:\n    list<const int *> get() { return x; }\n};" always "class Fred {\n    list<const int *> x;\npublic:\n    list<const int *> get() { return x; }\n};"
Line 4518
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  4518 always 4518
  "[test.cpp:4]: (style, inconclusive) Technically the member function 'Fred::get' can be const.\n" always "[test.cpp:4]: (style, inconclusive) Technically the member function 'Fred::get' can be const.\n"
Line 4520
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  4520 always 4520
  "class Fred {\n    std::list<std::string &> x;\npublic:\n    std::list<std::string &> get() { return x; }\n};" always "class Fred {\n    std::list<std::string &> x;\npublic:\n    std::list<std::string &> get() { return x; }\n};"
Line 4525
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  4525 always 4525
  "" always ""
Line 4527
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  4527 always 4527
  "class Fred {\n    std::list<const std::string &> x;\npublic:\n    std::list<const std::string &> get() { return x; }\n};" always "class Fred {\n    std::list<const std::string &> x;\npublic:\n    std::list<const std::string &> get() { return x; }\n};"
Line 4532
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  4532 always 4532
  "[test.cpp:4]: (style, inconclusive) Technically the member function 'Fred::get' can be const.\n" always "[test.cpp:4]: (style, inconclusive) Technically the member function 'Fred::get' can be const.\n"
Line 4537
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  4537 always 4537
  "class A\n{\nprivate:\n    const char * l1[10];\npublic:\n    A()\n    {\n        for (int i = 0 ; i < 10; l1[i] = NULL, i++);\n    }\n    void f1() { l1[0] = \"Hello\"; }\n};" always "class A\n{\nprivate:\n    const char * l1[10];\npublic:\n    A()\n    {\n        for (int i = 0 ; i < 10; l1[i] = NULL, i++);\n    }\n    void f1() { l1[0] = \"Hello\"; }\n};"
Line 4548
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  4548 always 4548
  "" always ""
Line 4552
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  4552 always 4552
  "class A\n{\nprivate:\n    B::C * v1;\npublic:\n    void f1() { v1 = 0; }\n};" always "class A\n{\nprivate:\n    B::C * v1;\npublic:\n    void f1() { v1 = 0; }\n};"
Line 4559
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  4559 always 4559
  "" always ""
Line 4561
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  4561 always 4561
  "class A\n{\nprivate:\n    B::C * v1[0];\npublic:\n    void f1() { v1[0] = 0; }\n};" always "class A\n{\nprivate:\n    B::C * v1[0];\npublic:\n    void f1() { v1[0] = 0; }\n};"
Line 4568
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  4568 always 4568
  "" always ""
Line 4572
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  4572 always 4572
  "class Class {\npublic:\n    typedef Template<double> Type;\n    typedef Template2<Type> Type2;\n    void set_member(Type2 m) { _m = m; }\nprivate:\n    Type2 _m;\n};" always "class Class {\npublic:\n    typedef Template<double> Type;\n    typedef Template2<Type> Type2;\n    void set_member(Type2 m) { _m = m; }\nprivate:\n    Type2 _m;\n};"
Line 4580
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  4580 always 4580
  "" always ""
Line 4584
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  4584 always 4584
  "class Class {\npublic:\nvoid Settings::SetSetting(QString strSetting, QString strNewVal)\n{\n    (*m_pSettings)[strSetting] = strNewVal;\n}\nprivate:\n    std::map<QString, QString> *m_pSettings;\n};" always "class Class {\npublic:\nvoid Settings::SetSetting(QString strSetting, QString strNewVal)\n{\n    (*m_pSettings)[strSetting] = strNewVal;\n}\nprivate:\n    std::map<QString, QString> *m_pSettings;\n};"
Line 4593
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  4593 always 4593
  "" always ""
Line 4598
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  4598 always 4598
  "class A{\npublic:\nA(){m_strVal=\"\";}\nstd::string strGetString() const\n{return m_strVal.c_str();}\nconst std::string strGetString1() const\n{return m_strVal.c_str();}\nprivate:\nstd::string m_strVal;\n};" always "class A{\npublic:\nA(){m_strVal=\"\";}\nstd::string strGetString() const\n{return m_strVal.c_str();}\nconst std::string strGetString1() const\n{return m_strVal.c_str();}\nprivate:\nstd::string m_strVal;\n};"
Line 4608
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  4608 always 4608
  "" always ""
Line 4610
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  4610 always 4610
  "class A{\npublic:\nA(){m_strVal=\"\";}\nstd::string strGetString()\n{return m_strVal.c_str();}\nprivate:\nstd::string m_strVal;\n};" always "class A{\npublic:\nA(){m_strVal=\"\";}\nstd::string strGetString()\n{return m_strVal.c_str();}\nprivate:\nstd::string m_strVal;\n};"
Line 4618
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  4618 always 4618
  "[test.cpp:4]: (style, inconclusive) Technically the member function 'A::strGetString' can be const.\n" always "[test.cpp:4]: (style, inconclusive) Technically the member function 'A::strGetString' can be const.\n"
Line 4620
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  4620 always 4620
  "class A{\npublic:\nA(){m_strVal=\"\";}\nconst std::string strGetString1()\n{return m_strVal.c_str();}\nprivate:\nstd::string m_strVal;\n};" always "class A{\npublic:\nA(){m_strVal=\"\";}\nconst std::string strGetString1()\n{return m_strVal.c_str();}\nprivate:\nstd::string m_strVal;\n};"
Line 4628
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  4628 always 4628
  "[test.cpp:4]: (style, inconclusive) Technically the member function 'A::strGetString1' can be const.\n" always "[test.cpp:4]: (style, inconclusive) Technically the member function 'A::strGetString1' can be const.\n"
Line 4630
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  4630 always 4630
  "class A{\npublic:\nA(){m_strVec.push_back(\"\");}\nsize_t strGetSize()\n{return m_strVec.size();}\nprivate:\nstd::vector<std::string> m_strVec;\n};" always "class A{\npublic:\nA(){m_strVec.push_back(\"\");}\nsize_t strGetSize()\n{return m_strVec.size();}\nprivate:\nstd::vector<std::string> m_strVec;\n};"
Line 4638
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  4638 always 4638
  "[test.cpp:4]: (style, inconclusive) Technically the member function 'A::strGetSize' can be const.\n" always "[test.cpp:4]: (style, inconclusive) Technically the member function 'A::strGetSize' can be const.\n"
Line 4640
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  4640 always 4640
  "class A{\npublic:\nA(){m_strVec.push_back(\"\");}\nbool strGetEmpty()\n{return m_strVec.empty();}\nprivate:\nstd::vector<std::string> m_strVec;\n};" always "class A{\npublic:\nA(){m_strVec.push_back(\"\");}\nbool strGetEmpty()\n{return m_strVec.empty();}\nprivate:\nstd::vector<std::string> m_strVec;\n};"
Line 4648
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  4648 always 4648
  "[test.cpp:4]: (style, inconclusive) Technically the member function 'A::strGetEmpty' can be const.\n" always "[test.cpp:4]: (style, inconclusive) Technically the member function 'A::strGetEmpty' can be const.\n"
Line 4652
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  4652 always 4652
  "class DelayBase {\npublic:\nvoid swapSpecificDelays(int index1, int index2) {\n    std::swap<float>(delays_[index1], delays_[index2]);\n}\nfloat delays_[4];\n};" always "class DelayBase {\npublic:\nvoid swapSpecificDelays(int index1, int index2) {\n    std::swap<float>(delays_[index1], delays_[index2]);\n}\nfloat delays_[4];\n};"
Line 4659
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  4659 always 4659
  "" always ""
Line 4661
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  4661 always 4661
  "struct DelayBase {\n    float swapSpecificDelays(int index1) {\n        return delays_[index1];\n    }\n    float delays_[4];\n};" always "struct DelayBase {\n    float swapSpecificDelays(int index1) {\n        return delays_[index1];\n    }\n    float delays_[4];\n};"
Line 4667
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  4667 always 4667
  "[test.cpp:2]: (style, inconclusive) Technically the member function 'DelayBase::swapSpecificDelays' can be const.\n" always "[test.cpp:2]: (style, inconclusive) Technically the member function 'DelayBase::swapSpecificDelays' can be const.\n"
Line 4671
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  4671 always 4671
  "class A {\npublic:\n    A(){m_d=1.0; m_iRealVal=2.0;}\n    double dGetValue();\nprivate:\n    double m_d;\n    double m_iRealVal;\n};\ndouble  A::dGetValue() {\n    double dRet = m_iRealVal;\n    if( m_d != 0 )\n        return m_iRealVal / m_d;\n    return dRet;\n};" always "class A {\npublic:\n    A(){m_d=1.0; m_iRealVal=2.0;}\n    double dGetValue();\nprivate:\n    double m_d;\n    double m_iRealVal;\n};\ndouble  A::dGetValue() {\n    double dRet = m_iRealVal;\n    if( m_d != 0 )\n        return m_iRealVal / m_d;\n    return dRet;\n};"
  nullptr always 0
  true always 1
Line 4685
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  4685 always 4685
  "[test.cpp:9] -> [test.cpp:4]: (style, inconclusive) Technically the member function 'A::dGetValue' can be const.\n" always "[test.cpp:9] -> [test.cpp:4]: (style, inconclusive) Technically the member function 'A::dGetValue' can be const.\n"
Line 4689
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  4689 always 4689
  "class P {\npublic:\n    P() { x=0.0; y=0.0; }\n    double x,y;\n};\nclass A : public P {\npublic:\n    A():P(){}\n    void SetPos(double xPos, double yPos) {\n        x=xPos;\n        y=yPos;\n    }\n};" always "class P {\npublic:\n    P() { x=0.0; y=0.0; }\n    double x,y;\n};\nclass A : public P {\npublic:\n    A():P(){}\n    void SetPos(double xPos, double yPos) {\n        x=xPos;\n        y=yPos;\n    }\n};"
Line 4702
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  4702 always 4702
  "" always ""
Line 4704
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  4704 always 4704
  "class AA : public P {\npublic:\n    AA():P(){}\n    inline void vSetXPos(int x_)\n    {\n        UnknownScope::x = x_;\n    }\n};" always "class AA : public P {\npublic:\n    AA():P(){}\n    inline void vSetXPos(int x_)\n    {\n        UnknownScope::x = x_;\n    }\n};"
Line 4712
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  4712 always 4712
  "" always ""
Line 4714
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  4714 always 4714
  "class AA {\npublic:\n    AA():P(){}\n    inline void vSetXPos(int x_)\n    {\n        UnknownScope::x = x_;\n    }\n};" always "class AA {\npublic:\n    AA():P(){}\n    inline void vSetXPos(int x_)\n    {\n        UnknownScope::x = x_;\n    }\n};"
Line 4722
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  4722 always 4722
  "[test.cpp:4]: (performance, inconclusive) Technically the member function 'AA::vSetXPos' can be static (but you may consider moving to unnamed namespace).\n" always "[test.cpp:4]: (performance, inconclusive) Technically the member function 'AA::vSetXPos' can be static (but you may consider moving to unnamed namespace).\n"
Line 4727
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  4727 always 4727
  "class test {\n  public:\n    test();\n    const char* get() const;\n    char* get();\n  private:\n    char* value_;\n};\ntest::test()\n{\n  value_ = 0;\n}\nconst char* test::get() const\n{\n  return value_;\n}\nchar* test::get()\n{\n  return value_;\n}" always "class test {\n  public:\n    test();\n    const char* get() const;\n    char* get();\n  private:\n    char* value_;\n};\ntest::test()\n{\n  value_ = 0;\n}\nconst char* test::get() const\n{\n  return value_;\n}\nchar* test::get()\n{\n  return value_;\n}"
Line 4747
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  4747 always 4747
  "" always ""
Line 4752
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  4752 always 4752
  "class Base {\npublic:\n    int a;\n};\nclass Derived : public Base {\npublic:\n    int get() {\n        return a;\n    }\n};" always "class Base {\npublic:\n    int a;\n};\nclass Derived : public Base {\npublic:\n    int get() {\n        return a;\n    }\n};"
Line 4762
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  4762 always 4762
  "[test.cpp:7]: (style, inconclusive) Technically the member function 'Derived::get' can be const.\n" always "[test.cpp:7]: (style, inconclusive) Technically the member function 'Derived::get' can be const.\n"
Line 4764
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  4764 always 4764
  "class Base1 {\npublic:\n    int a;\n};\nclass Base2 {\npublic:\n    int b;\n};\nclass Derived : public Base1, public Base2 {\npublic:\n    int getA() {\n        return a;\n    }\n    int getB() {\n        return b;\n    }\n};" always "class Base1 {\npublic:\n    int a;\n};\nclass Base2 {\npublic:\n    int b;\n};\nclass Derived : public Base1, public Base2 {\npublic:\n    int getA() {\n        return a;\n    }\n    int getB() {\n        return b;\n    }\n};"
Line 4781
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  4781 always 4781
  "[test.cpp:11]: (style, inconclusive) Technically the member function 'Derived::getA' can be const.\n[test.cpp:14]: (style, inconclusive) Technically the member function 'Derived::getB' can be const.\n" always "[test.cpp:11]: (style, inconclusive) Technically the member function 'Derived::getA' can be const.\n[test.cpp:14]: (style, inconclusive) Technically the member function 'Derived::getB' can be const.\n"
Line 4784
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  4784 always 4784
  "class Base {\npublic:\n    int a;\n};\nclass Derived1 : public Base { };\nclass Derived2 : public Derived1 {\npublic:\n    int get() {\n        return a;\n    }\n};" always "class Base {\npublic:\n    int a;\n};\nclass Derived1 : public Base { };\nclass Derived2 : public Derived1 {\npublic:\n    int get() {\n        return a;\n    }\n};"
Line 4795
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  4795 always 4795
  "[test.cpp:8]: (style, inconclusive) Technically the member function 'Derived2::get' can be const.\n" always "[test.cpp:8]: (style, inconclusive) Technically the member function 'Derived2::get' can be const.\n"
Line 4797
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  4797 always 4797
  "class Base {\npublic:\n    int a;\n};\nclass Derived1 : public Base { };\nclass Derived2 : public Derived1 { };\nclass Derived3 : public Derived2 { };\nclass Derived4 : public Derived3 {\npublic:\n    int get() {\n        return a;\n    }\n};" always "class Base {\npublic:\n    int a;\n};\nclass Derived1 : public Base { };\nclass Derived2 : public Derived1 { };\nclass Derived3 : public Derived2 { };\nclass Derived4 : public Derived3 {\npublic:\n    int get() {\n        return a;\n    }\n};"
Line 4810
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  4810 always 4810
  "[test.cpp:10]: (style, inconclusive) Technically the member function 'Derived4::get' can be const.\n" always "[test.cpp:10]: (style, inconclusive) Technically the member function 'Derived4::get' can be const.\n"
Line 4813
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  4813 always 4813
  "class Base {\npublic:\n    int a;\n};\nclass Derived : public Base {\npublic:\n    int get() const {\n        return a;\n    }\n};" always "class Base {\npublic:\n    int a;\n};\nclass Derived : public Base {\npublic:\n    int get() const {\n        return a;\n    }\n};"
Line 4823
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  4823 always 4823
  "" always ""
Line 4825
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  4825 always 4825
  "class Base1 {\npublic:\n    int a;\n};\nclass Base2 {\npublic:\n    int b;\n};\nclass Derived : public Base1, public Base2 {\npublic:\n    int getA() const {\n        return a;\n    }\n    int getB() const {\n        return b;\n    }\n};" always "class Base1 {\npublic:\n    int a;\n};\nclass Base2 {\npublic:\n    int b;\n};\nclass Derived : public Base1, public Base2 {\npublic:\n    int getA() const {\n        return a;\n    }\n    int getB() const {\n        return b;\n    }\n};"
Line 4842
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  4842 always 4842
  "" always ""
Line 4844
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  4844 always 4844
  "class Base {\npublic:\n    int a;\n};\nclass Derived1 : public Base { };\nclass Derived2 : public Derived1 {\npublic:\n    int get() const {\n        return a;\n    }\n};" always "class Base {\npublic:\n    int a;\n};\nclass Derived1 : public Base { };\nclass Derived2 : public Derived1 {\npublic:\n    int get() const {\n        return a;\n    }\n};"
Line 4855
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  4855 always 4855
  "" always ""
Line 4857
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  4857 always 4857
  "class Base {\npublic:\n    int a;\n};\nclass Derived1 : public Base { };\nclass Derived2 : public Derived1 { };\nclass Derived3 : public Derived2 { };\nclass Derived4 : public Derived3 {\npublic:\n    int get() const {\n        return a;\n    }\n};" always "class Base {\npublic:\n    int a;\n};\nclass Derived1 : public Base { };\nclass Derived2 : public Derived1 { };\nclass Derived3 : public Derived2 { };\nclass Derived4 : public Derived3 {\npublic:\n    int get() const {\n        return a;\n    }\n};"
Line 4870
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  4870 always 4870
  "" always ""
Line 4874
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  4874 always 4874
  "namespace std { }\nclass Fred {\npublic:\n    int a;\n    int get() { return a; }\n};" always "namespace std { }\nclass Fred {\npublic:\n    int a;\n    int get() { return a; }\n};"
Line 4880
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  4880 always 4880
  "[test.cpp:5]: (style, inconclusive) Technically the member function 'Fred::get' can be const.\n" always "[test.cpp:5]: (style, inconclusive) Technically the member function 'Fred::get' can be const.\n"
Line 4884
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  4884 always 4884
  "class Fred {\npublic:\n    std::string a[10];\n    void seta() { a[0] = \"\"; }\n};" always "class Fred {\npublic:\n    std::string a[10];\n    void seta() { a[0] = \"\"; }\n};"
Line 4889
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  4889 always 4889
  "" always ""
Line 4893
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  4893 always 4893
  "class derived : public base {\npublic:\n    void f(){}\n};" always "class derived : public base {\npublic:\n    void f(){}\n};"
Line 4897
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  4897 always 4897
  "" always ""
Line 4901
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  4901 always 4901
  "class Bar {\n    void init(Foo * foo) {\n        foo.bar = this;\n    }\n};" always "class Bar {\n    void init(Foo * foo) {\n        foo.bar = this;\n    }\n};"
Line 4906
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  4906 always 4906
  "" always ""
Line 4910
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  4910 always 4910
  "namespace N\n{\n        class Base\n        {\n        };\n}\nnamespace N\n{\n        class Derived : public Base\n        {\n        public:\n                int getResourceName() { return var; }\n                int var;\n        };\n}" always "namespace N\n{\n        class Base\n        {\n        };\n}\nnamespace N\n{\n        class Derived : public Base\n        {\n        public:\n                int getResourceName() { return var; }\n                int var;\n        };\n}"
Line 4925
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  4925 always 4925
  "[test.cpp:12]: (style, inconclusive) Technically the member function 'N::Derived::getResourceName' can be const.\n" always "[test.cpp:12]: (style, inconclusive) Technically the member function 'N::Derived::getResourceName' can be const.\n"
Line 4927
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  4927 always 4927
  "namespace N\n{\n        class Base\n        {\n        public:\n                int getResourceName();\n                int var;\n        };\n}\nint N::Base::getResourceName() { return var; }" always "namespace N\n{\n        class Base\n        {\n        public:\n                int getResourceName();\n                int var;\n        };\n}\nint N::Base::getResourceName() { return var; }"
Line 4937
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  4937 always 4937
  "[test.cpp:10] -> [test.cpp:6]: (style, inconclusive) Technically the member function 'N::Base::getResourceName' can be const.\n" always "[test.cpp:10] -> [test.cpp:6]: (style, inconclusive) Technically the member function 'N::Base::getResourceName' can be const.\n"
Line 4939
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  4939 always 4939
  "namespace N\n{\n        class Base\n        {\n        public:\n                int getResourceName();\n                int var;\n        };\n}\nnamespace N\n{\n        int Base::getResourceName() { return var; }\n}" always "namespace N\n{\n        class Base\n        {\n        public:\n                int getResourceName();\n                int var;\n        };\n}\nnamespace N\n{\n        int Base::getResourceName() { return var; }\n}"
Line 4952
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  4952 always 4952
  "[test.cpp:12] -> [test.cpp:6]: (style, inconclusive) Technically the member function 'N::Base::getResourceName' can be const.\n" always "[test.cpp:12] -> [test.cpp:6]: (style, inconclusive) Technically the member function 'N::Base::getResourceName' can be const.\n"
Line 4954
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  4954 always 4954
  "namespace N\n{\n        class Base\n        {\n        public:\n                int getResourceName();\n                int var;\n        };\n}\nusing namespace N;\nint Base::getResourceName() { return var; }" always "namespace N\n{\n        class Base\n        {\n        public:\n                int getResourceName();\n                int var;\n        };\n}\nusing namespace N;\nint Base::getResourceName() { return var; }"
Line 4965
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  4965 always 4965
  "[test.cpp:11] -> [test.cpp:6]: (style, inconclusive) Technically the member function 'N::Base::getResourceName' can be const.\n" always "[test.cpp:11] -> [test.cpp:6]: (style, inconclusive) Technically the member function 'N::Base::getResourceName' can be const.\n"
Line 4969
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  4969 always 4969
  "class Foo {\npublic:\n    Blue::Utility::Size m_MaxQueueSize;\n    void SetMaxQueueSize(Blue::Utility::Size a_MaxQueueSize)\n    {\n        m_MaxQueueSize = a_MaxQueueSize;\n    }\n};" always "class Foo {\npublic:\n    Blue::Utility::Size m_MaxQueueSize;\n    void SetMaxQueueSize(Blue::Utility::Size a_MaxQueueSize)\n    {\n        m_MaxQueueSize = a_MaxQueueSize;\n    }\n};"
Line 4977
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  4977 always 4977
  "" always ""
Line 4981
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  4981 always 4981
  "class A\n{\npublic:\n    A(){};\n    std::string operator+(const char *c)\n    {\n        return m_str+std::string(c);\n    }\nprivate:\n    std::string m_str;\n};" always "class A\n{\npublic:\n    A(){};\n    std::string operator+(const char *c)\n    {\n        return m_str+std::string(c);\n    }\nprivate:\n    std::string m_str;\n};"
Line 4992
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  4992 always 4992
  "[test.cpp:5]: (style, inconclusive) Technically the member function 'A::operator+' can be const.\n" always "[test.cpp:5]: (style, inconclusive) Technically the member function 'A::operator+' can be const.\n"
Line 4994
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  4994 always 4994
  "class Fred\n{\nprivate:\n    long x;\npublic:\n    Fred() {\n        x = 0;\n    }\n    bool isValid() {\n        return (x == 0x11224488);\n    }\n};" always "class Fred\n{\nprivate:\n    long x;\npublic:\n    Fred() {\n        x = 0;\n    }\n    bool isValid() {\n        return (x == 0x11224488);\n    }\n};"
Line 5006
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  5006 always 5006
  "[test.cpp:9]: (style, inconclusive) Technically the member function 'Fred::isValid' can be const.\n" always "[test.cpp:9]: (style, inconclusive) Technically the member function 'Fred::isValid' can be const.\n"
Line 5010
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  5010 always 5010
  "class Foo {\npublic:\n    ~Foo() { delete oArq; }\n    Foo(): oArq(new std::ofstream(\"...\")) {}\n    void MyMethod();\nprivate:\n    std::ofstream *oArq;\n};\nvoid Foo::MyMethod()\n{\n    (*oArq) << \"</table>\";\n}" always "class Foo {\npublic:\n    ~Foo() { delete oArq; }\n    Foo(): oArq(new std::ofstream(\"...\")) {}\n    void MyMethod();\nprivate:\n    std::ofstream *oArq;\n};\nvoid Foo::MyMethod()\n{\n    (*oArq) << \"</table>\";\n}"
Line 5022
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  5022 always 5022
  "" always ""
Line 5026
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  5026 always 5026
  "class Foo\n{\n    int * p;\npublic:\n    Foo () : p(0) { }\n    int * f();\n    const int * f() const;\n};\nconst int * Foo::f() const\n{\n    return p;\n}\nint * Foo::f()\n{\n    return p;\n}" always "class Foo\n{\n    int * p;\npublic:\n    Foo () : p(0) { }\n    int * f();\n    const int * f() const;\n};\nconst int * Foo::f() const\n{\n    return p;\n}\nint * Foo::f()\n{\n    return p;\n}"
Line 5043
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  5043 always 5043
  "" always ""
Line 5047
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  5047 always 5047
  "class SharedPtrHolder\n{\n  private:\n   std::tr1::shared_ptr<int> pView;\n  public:\n   SharedPtrHolder()\n   { }\n   void SetView(const std::shared_ptr<int> & aView)\n   {\n      pView = aView;\n   }\n};" always "class SharedPtrHolder\n{\n  private:\n   std::tr1::shared_ptr<int> pView;\n  public:\n   SharedPtrHolder()\n   { }\n   void SetView(const std::shared_ptr<int> & aView)\n   {\n      pView = aView;\n   }\n};"
Line 5060
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  5060 always 5060
  "" always ""
Line 5064
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  5064 always 5064
  "class Fred\n{\n   ::std::string m_name;\npublic:\n   void SetName(const ::std::string & name)\n   {\n      m_name = name;\n   }\n};" always "class Fred\n{\n   ::std::string m_name;\npublic:\n   void SetName(const ::std::string & name)\n   {\n      m_name = name;\n   }\n};"
Line 5074
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  5074 always 5074
  "" always ""
Line 5076
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  5076 always 5076
  "class SharedPtrHolder\n{\n   ::std::tr1::shared_ptr<int> pNum;\n  public :\n   void SetNum(const ::std::tr1::shared_ptr<int> & apNum)\n   {\n      pNum = apNum;\n   }\n};" always "class SharedPtrHolder\n{\n   ::std::tr1::shared_ptr<int> pNum;\n  public :\n   void SetNum(const ::std::tr1::shared_ptr<int> & apNum)\n   {\n      pNum = apNum;\n   }\n};"
Line 5086
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  5086 always 5086
  "" always ""
Line 5088
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  5088 always 5088
  "class SharedPtrHolder2\n{\n  public:\n   typedef ::std::tr1::shared_ptr<int> IntSharedPtr;\n  private:\n   IntSharedPtr pNum;\n  public :\n   void SetNum(const IntSharedPtr & apNum)\n   {\n      pNum = apNum;\n   }\n};" always "class SharedPtrHolder2\n{\n  public:\n   typedef ::std::tr1::shared_ptr<int> IntSharedPtr;\n  private:\n   IntSharedPtr pNum;\n  public :\n   void SetNum(const IntSharedPtr & apNum)\n   {\n      pNum = apNum;\n   }\n};"
Line 5101
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  5101 always 5101
  "" always ""
Line 5103
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  5103 always 5103
  "struct IntPtrTypes\n{\n   typedef ::std::tr1::shared_ptr<int> Shared;\n};\nclass SharedPtrHolder3\n{\n  private:\n   IntPtrTypes::Shared pNum;\n  public :\n   void SetNum(const IntPtrTypes::Shared & apNum)\n   {\n      pNum = apNum;\n   }\n};" always "struct IntPtrTypes\n{\n   typedef ::std::tr1::shared_ptr<int> Shared;\n};\nclass SharedPtrHolder3\n{\n  private:\n   IntPtrTypes::Shared pNum;\n  public :\n   void SetNum(const IntPtrTypes::Shared & apNum)\n   {\n      pNum = apNum;\n   }\n};"
Line 5118
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  5118 always 5118
  "" always ""
Line 5120
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  5120 always 5120
  "template <typename T>\nstruct PtrTypes\n{\n   typedef ::std::tr1::shared_ptr<T> Shared;\n};\nclass SharedPtrHolder4\n{\n  private:\n   PtrTypes<int>::Shared pNum;\n  public :\n   void SetNum(const PtrTypes<int>::Shared & apNum)\n   {\n      pNum = apNum;\n   }\n};" always "template <typename T>\nstruct PtrTypes\n{\n   typedef ::std::tr1::shared_ptr<T> Shared;\n};\nclass SharedPtrHolder4\n{\n  private:\n   PtrTypes<int>::Shared pNum;\n  public :\n   void SetNum(const PtrTypes<int>::Shared & apNum)\n   {\n      pNum = apNum;\n   }\n};"
Line 5136
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  5136 always 5136
  "" always ""
Line 5140
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  5140 always 5140
  "class Fred\n{\npublic:\n    struct AB { };\n    bool f(AB * ab);\n};\nbool Fred::f(Fred::AB * ab)\n{\n}" always "class Fred\n{\npublic:\n    struct AB { };\n    bool f(AB * ab);\n};\nbool Fred::f(Fred::AB * ab)\n{\n}"
Line 5150
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  5150 always 5150
  "[test.cpp:7] -> [test.cpp:5]: (performance, inconclusive) Technically the member function 'Fred::f' can be static (but you may consider moving to unnamed namespace).\n" always "[test.cpp:7] -> [test.cpp:5]: (performance, inconclusive) Technically the member function 'Fred::f' can be static (but you may consider moving to unnamed namespace).\n"
Line 5152
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  5152 always 5152
  "class Fred\n{\npublic:\n    struct AB {\n        struct CD { };\n    };\n    bool f(AB::CD * cd);\n};\nbool Fred::f(Fred::AB::CD * cd)\n{\n}" always "class Fred\n{\npublic:\n    struct AB {\n        struct CD { };\n    };\n    bool f(AB::CD * cd);\n};\nbool Fred::f(Fred::AB::CD * cd)\n{\n}"
Line 5164
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  5164 always 5164
  "[test.cpp:9] -> [test.cpp:7]: (performance, inconclusive) Technically the member function 'Fred::f' can be static (but you may consider moving to unnamed namespace).\n" always "[test.cpp:9] -> [test.cpp:7]: (performance, inconclusive) Technically the member function 'Fred::f' can be static (but you may consider moving to unnamed namespace).\n"
Line 5166
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  5166 always 5166
  "namespace NS {\n    class Fred\n    {\n    public:\n        struct AB {\n            struct CD { };\n        };\n        bool f(AB::CD * cd);\n    };\n    bool Fred::f(Fred::AB::CD * cd)\n    {\n    }\n}" always "namespace NS {\n    class Fred\n    {\n    public:\n        struct AB {\n            struct CD { };\n        };\n        bool f(AB::CD * cd);\n    };\n    bool Fred::f(Fred::AB::CD * cd)\n    {\n    }\n}"
Line 5180
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  5180 always 5180
  "[test.cpp:10] -> [test.cpp:8]: (performance, inconclusive) Technically the member function 'NS::Fred::f' can be static (but you may consider moving to unnamed namespace).\n" always "[test.cpp:10] -> [test.cpp:8]: (performance, inconclusive) Technically the member function 'NS::Fred::f' can be static (but you may consider moving to unnamed namespace).\n"
Line 5182
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  5182 always 5182
  "namespace NS {\n    class Fred\n    {\n    public:\n        struct AB {\n            struct CD { };\n        };\n        bool f(AB::CD * cd);\n    };\n}\nbool NS::Fred::f(NS::Fred::AB::CD * cd)\n{\n}" always "namespace NS {\n    class Fred\n    {\n    public:\n        struct AB {\n            struct CD { };\n        };\n        bool f(AB::CD * cd);\n    };\n}\nbool NS::Fred::f(NS::Fred::AB::CD * cd)\n{\n}"
Line 5196
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  5196 always 5196
  "[test.cpp:11] -> [test.cpp:8]: (performance, inconclusive) Technically the member function 'NS::Fred::f' can be static (but you may consider moving to unnamed namespace).\n" always "[test.cpp:11] -> [test.cpp:8]: (performance, inconclusive) Technically the member function 'NS::Fred::f' can be static (but you may consider moving to unnamed namespace).\n"
Line 5198
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  5198 always 5198
  "class Foo {\n    class Fred\n    {\n    public:\n        struct AB {\n            struct CD { };\n        };\n        bool f(AB::CD * cd);\n    };\n};\nbool Foo::Fred::f(Foo::Fred::AB::CD * cd)\n{\n}" always "class Foo {\n    class Fred\n    {\n    public:\n        struct AB {\n            struct CD { };\n        };\n        bool f(AB::CD * cd);\n    };\n};\nbool Foo::Fred::f(Foo::Fred::AB::CD * cd)\n{\n}"
Line 5212
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  5212 always 5212
  "[test.cpp:11] -> [test.cpp:8]: (performance, inconclusive) Technically the member function 'Foo::Fred::f' can be static (but you may consider moving to unnamed namespace).\n" always "[test.cpp:11] -> [test.cpp:8]: (performance, inconclusive) Technically the member function 'Foo::Fred::f' can be static (but you may consider moving to unnamed namespace).\n"
Line 5216
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  5216 always 5216
  "class A\n{\npublic:\n    void foo( AA::BB::CC::DD b );\n    AA::BB::CC::DD a;\n};\nvoid A::foo( AA::BB::CC::DD b )\n{\n    a = b;\n}" always "class A\n{\npublic:\n    void foo( AA::BB::CC::DD b );\n    AA::BB::CC::DD a;\n};\nvoid A::foo( AA::BB::CC::DD b )\n{\n    a = b;\n}"
Line 5227
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  5227 always 5227
  "" always ""
Line 5229
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  5229 always 5229
  "namespace AA\n{\n    namespace BB\n    {\n        namespace CC\n        {\n            struct DD\n            {};\n        }\n    }\n}\nclass A\n{\n    public:\n\n    AA::BB::CC::DD a;\n    void foo(AA::BB::CC::DD b)\n    {\n        a = b;\n    }\n};" always "namespace AA\n{\n    namespace BB\n    {\n        namespace CC\n        {\n            struct DD\n            {};\n        }\n    }\n}\nclass A\n{\n    public:\n\n    AA::BB::CC::DD a;\n    void foo(AA::BB::CC::DD b)\n    {\n        a = b;\n    }\n};"
Line 5251
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  5251 always 5251
  "" always ""
Line 5253
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  5253 always 5253
  "namespace ZZ\n{\n    namespace YY\n    {\n        struct XX\n        {};\n    }\n}\nclass B\n{\n    public:\n    ZZ::YY::XX a;\n    void foo(ZZ::YY::XX b)\n    {\n        a = b;\n    }\n};" always "namespace ZZ\n{\n    namespace YY\n    {\n        struct XX\n        {};\n    }\n}\nclass B\n{\n    public:\n    ZZ::YY::XX a;\n    void foo(ZZ::YY::XX b)\n    {\n        a = b;\n    }\n};"
Line 5270
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  5270 always 5270
  "" always ""
Line 5274
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  5274 always 5274
  "class A\n{\npublic:\n    bool bOn;\n    bool foo()\n    {\n        return 0 != (bOn = bOn);\n    }\n};" always "class A\n{\npublic:\n    bool bOn;\n    bool foo()\n    {\n        return 0 != (bOn = bOn);\n    }\n};"
Line 5284
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  5284 always 5284
  "" always ""
Line 5288
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  5288 always 5288
  "namespace wraps {\n    class BaseLayout {};\n}\nnamespace tools {\n    class WorkspaceControl :\n        public wraps::BaseLayout\n    {\n        int toGrid(int _value)\n        {\n        }\n    };\n}" always "namespace wraps {\n    class BaseLayout {};\n}\nnamespace tools {\n    class WorkspaceControl :\n        public wraps::BaseLayout\n    {\n        int toGrid(int _value)\n        {\n        }\n    };\n}"
Line 5301
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  5301 always 5301
  "[test.cpp:8]: (performance, inconclusive) Technically the member function 'tools::WorkspaceControl::toGrid' can be static (but you may consider moving to unnamed namespace).\n" always "[test.cpp:8]: (performance, inconclusive) Technically the member function 'tools::WorkspaceControl::toGrid' can be static (but you may consider moving to unnamed namespace).\n"
Line 5305
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  5305 always 5305
  "class Altren {\npublic:\n    int fun1() {\n        int a;\n        a++;\n    }\n    int fun2() {\n        b++;\n    }\n};" always "class Altren {\npublic:\n    int fun1() {\n        int a;\n        a++;\n    }\n    int fun2() {\n        b++;\n    }\n};"
Line 5316
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  5316 always 5316
  "[test.cpp:3]: (performance, inconclusive) Technically the member function 'Altren::fun1' can be static (but you may consider moving to unnamed namespace).\n[test.cpp:7]: (performance, inconclusive) Technically the member function 'Altren::fun2' can be static (but you may consider moving to unnamed namespace).\n" always "[test.cpp:3]: (performance, inconclusive) Technically the member function 'Altren::fun1' can be static (but you may consider moving to unnamed namespace).\n[test.cpp:7]: (performance, inconclusive) Technically the member function 'Altren::fun2' can be static (but you may consider moving to unnamed namespace).\n"
Line 5321
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  5321 always 5321
  "class Altren {\npublic:\n  void foo() { delete this; }\n  void foo(int i) const { }\n  void bar() { foo(); }\n};" always "class Altren {\npublic:\n  void foo() { delete this; }\n  void foo(int i) const { }\n  void bar() { foo(); }\n};"
Line 5328
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  5328 always 5328
  "[test.cpp:4]: (performance, inconclusive) Technically the member function 'Altren::foo' can be static (but you may consider moving to unnamed namespace).\n" always "[test.cpp:4]: (performance, inconclusive) Technically the member function 'Altren::foo' can be static (but you may consider moving to unnamed namespace).\n"
Line 5330
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  5330 always 5330
  "class Altren {\npublic:\n  void foo() { delete this; }\n  void foo(int i) const { }\n  void bar() { foo(1); }\n};" always "class Altren {\npublic:\n  void foo() { delete this; }\n  void foo(int i) const { }\n  void bar() { foo(1); }\n};"
Line 5337
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  5337 always 5337
  "[test.cpp:4]: (performance, inconclusive) Technically the member function 'Altren::foo' can be static (but you may consider moving to unnamed namespace).\n[test.cpp:5]: (style, inconclusive) Technically the member function 'Altren::bar' can be const.\n" always "[test.cpp:4]: (performance, inconclusive) Technically the member function 'Altren::foo' can be static (but you may consider moving to unnamed namespace).\n[test.cpp:5]: (style, inconclusive) Technically the member function 'Altren::bar' can be const.\n"
Line 5342
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  5342 always 5342
  "class S0 {\n    class S1 {\n        class S2 {\n            class S3 {\n                class S4 { };\n            };\n        };\n    };\n};\nclass TextIterator {\n    S0::S1::S2::S3::S4 mCurrent, mSave;\npublic:\n    bool setTagColour();\n};\nbool TextIterator::setTagColour() {\n    mSave = mCurrent;\n}" always "class S0 {\n    class S1 {\n        class S2 {\n            class S3 {\n                class S4 { };\n            };\n        };\n    };\n};\nclass TextIterator {\n    S0::S1::S2::S3::S4 mCurrent, mSave;\npublic:\n    bool setTagColour();\n};\nbool TextIterator::setTagColour() {\n    mSave = mCurrent;\n}"
Line 5360
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  5360 always 5360
  "" always ""
Line 5364
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  5364 always 5364
  "class A {\n    private:\n         std::map<unsigned int,unsigned int> _hash;\n    public:\n         A() : _hash() {}\n         unsigned int fetch(unsigned int key)\n         {\n             return _hash[key];\n         }\n};" always "class A {\n    private:\n         std::map<unsigned int,unsigned int> _hash;\n    public:\n         A() : _hash() {}\n         unsigned int fetch(unsigned int key)\n         {\n             return _hash[key];\n         }\n};"
Line 5374
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  5374 always 5374
  "" always ""
Line 5378
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  5378 always 5378
  "class Altren\n{\n        class SubClass : public std::vector<int>\n        {\n        };\n};\nvoid _setAlign()\n{\n        if (mTileSize.height > 0) return;\n        if (mEmptyView) return;\n}" always "class Altren\n{\n        class SubClass : public std::vector<int>\n        {\n        };\n};\nvoid _setAlign()\n{\n        if (mTileSize.height > 0) return;\n        if (mEmptyView) return;\n}"
Line 5390
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  5390 always 5390
  "" always ""
Line 5394
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  5394 always 5394
  "class PSIPTable {\npublic:\n    PSIPTable() : _pesdata(0) { }\n    const unsigned char* pesdata() const { return _pesdata; }\n    unsigned char* pesdata()             { return _pesdata; }\n    void SetSection(uint num) { pesdata()[6] = num; }\nprivate:\n    unsigned char *_pesdata;\n};" always "class PSIPTable {\npublic:\n    PSIPTable() : _pesdata(0) { }\n    const unsigned char* pesdata() const { return _pesdata; }\n    unsigned char* pesdata()             { return _pesdata; }\n    void SetSection(uint num) { pesdata()[6] = num; }\nprivate:\n    unsigned char *_pesdata;\n};"
Line 5403
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  5403 always 5403
  "" always ""
Line 5405
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  5405 always 5405
  "class PESPacket {\npublic:\n    PESPacket() : _pesdata(0) { }\n    const unsigned char* pesdata() const { return _pesdata; }\n    unsigned char* pesdata()             { return _pesdata; }\nprivate:\n    unsigned char *_pesdata;\n};\nclass PSIPTable : public PESPacket\n{\npublic:\n    void SetSection(uint num) { pesdata()[6] = num; }\n};" always "class PESPacket {\npublic:\n    PESPacket() : _pesdata(0) { }\n    const unsigned char* pesdata() const { return _pesdata; }\n    unsigned char* pesdata()             { return _pesdata; }\nprivate:\n    unsigned char *_pesdata;\n};\nclass PSIPTable : public PESPacket\n{\npublic:\n    void SetSection(uint num) { pesdata()[6] = num; }\n};"
Line 5418
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  5418 always 5418
  "" always ""
Line 5422
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  5422 always 5422
  "class foo {\n    void DoSomething(int &a) const { a = 1; }\n    void DoSomethingElse() { DoSomething(bar); }\nprivate:\n    int bar;\n};" always "class foo {\n    void DoSomething(int &a) const { a = 1; }\n    void DoSomethingElse() { DoSomething(bar); }\nprivate:\n    int bar;\n};"
Line 5428
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  5428 always 5428
  "[test.cpp:2]: (performance, inconclusive) Technically the member function 'foo::DoSomething' can be static (but you may consider moving to unnamed namespace).\n" always "[test.cpp:2]: (performance, inconclusive) Technically the member function 'foo::DoSomething' can be static (but you may consider moving to unnamed namespace).\n"
Line 5432
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  5432 always 5432
  "class A {\n  public:\n    A() : foo(false) {};\n    virtual bool One(bool b = false) { foo = b; return false; }\n  private:\n    bool foo;\n};\nclass B : public A {\n  public:\n    B() {};\n    bool One(bool b = false) { return false; }\n};" always "class A {\n  public:\n    A() : foo(false) {};\n    virtual bool One(bool b = false) { foo = b; return false; }\n  private:\n    bool foo;\n};\nclass B : public A {\n  public:\n    B() {};\n    bool One(bool b = false) { return false; }\n};"
Line 5444
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  5444 always 5444
  "" always ""
Line 5448
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  5448 always 5448
  "class Example {\n  public:\n    void Clear(void) { Example tmp; (*this) = tmp; }\n};" always "class Example {\n  public:\n    void Clear(void) { Example tmp; (*this) = tmp; }\n};"
Line 5452
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  5452 always 5452
  "" always ""
Line 5456
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  5456 always 5456
  "class MyObject {\n    int tmp;\n    MyObject() : tmp(0) {}\npublic:\n    void set(std::stringstream &in) { in >> tmp; }\n};" always "class MyObject {\n    int tmp;\n    MyObject() : tmp(0) {}\npublic:\n    void set(std::stringstream &in) { in >> tmp; }\n};"
Line 5462
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  5462 always 5462
  "" always ""
Line 5466
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  5466 always 5466
  "class MyObject {\npublic:\n    void foo(int x) {\n    switch (x) { }\n    }\n};" always "class MyObject {\npublic:\n    void foo(int x) {\n    switch (x) { }\n    }\n};"
Line 5472
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  5472 always 5472
  "[test.cpp:3]: (performance, inconclusive) Technically the member function 'MyObject::foo' can be static (but you may consider moving to unnamed namespace).\n" always "[test.cpp:3]: (performance, inconclusive) Technically the member function 'MyObject::foo' can be static (but you may consider moving to unnamed namespace).\n"
Line 5474
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  5474 always 5474
  "class A\n{\n    protected:\n        unsigned short f (unsigned short X);\n    public:\n        A ();\n};\n\nunsigned short A::f (unsigned short X)\n{\n    enum ERetValues {RET_NOK = 0, RET_OK = 1};\n    enum ETypes     {FLOAT_TYPE = 1, INT_TYPE = 2};\n\n    try\n    {\n        switch (X)\n        {\n            case FLOAT_TYPE:\n            {\n                return RET_OK;\n            }\n            case INT_TYPE:\n            {\n                return RET_OK;\n            }\n            default:\n            {\n                return RET_NOK;\n            }\n        }\n    }\n    catch (...)\n    {\n        return RET_NOK;\n    }\n\n    return RET_NOK;\n}" always "class A\n{\n    protected:\n        unsigned short f (unsigned short X);\n    public:\n        A ();\n};\n\nunsigned short A::f (unsigned short X)\n{\n    enum ERetValues {RET_NOK = 0, RET_OK = 1};\n    enum ETypes     {FLOAT_TYPE = 1, INT_TYPE = 2};\n\n    try\n    {\n        switch (X)\n        {\n            case FLOAT_TYPE:\n            {\n                return RET_OK;\n            }\n            case INT_TYPE:\n            {\n                return RET_OK;\n            }\n            default:\n            {\n                return RET_NOK;\n            }\n        }\n    }\n    catch (...)\n    {\n        return RET_NOK;\n    }\n\n    return RET_NOK;\n}"
Line 5512
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  5512 always 5512
  "[test.cpp:9] -> [test.cpp:4]: (performance, inconclusive) Technically the member function 'A::f' can be static (but you may consider moving to unnamed namespace).\n" always "[test.cpp:9] -> [test.cpp:4]: (performance, inconclusive) Technically the member function 'A::f' can be static (but you may consider moving to unnamed namespace).\n"
Line 5514
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  5514 always 5514
  "class MyObject {\npublic:\n    void foo(int x) {\n    for (int i = 0; i < 5; i++) { }\n    }\n};" always "class MyObject {\npublic:\n    void foo(int x) {\n    for (int i = 0; i < 5; i++) { }\n    }\n};"
Line 5520
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  5520 always 5520
  "[test.cpp:3]: (performance, inconclusive) Technically the member function 'MyObject::foo' can be static (but you may consider moving to unnamed namespace).\n" always "[test.cpp:3]: (performance, inconclusive) Technically the member function 'MyObject::foo' can be static (but you may consider moving to unnamed namespace).\n"
Line 5524
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  5524 always 5524
  "namespace MyGUI\n{\n  namespace types\n  {\n    struct TSize {};\n    struct TCoord {\n      TSize size() const { }\n    };\n  }\n  typedef types::TSize IntSize;\n  typedef types::TCoord IntCoord;\n}\nclass SelectorControl\n{\n  MyGUI::IntSize getSize()\n  {\n    return mCoordValue.size();\n  }\nprivate:\n  MyGUI::IntCoord mCoordValue;\n};" always "namespace MyGUI\n{\n  namespace types\n  {\n    struct TSize {};\n    struct TCoord {\n      TSize size() const { }\n    };\n  }\n  typedef types::TSize IntSize;\n  typedef types::TCoord IntCoord;\n}\nclass SelectorControl\n{\n  MyGUI::IntSize getSize()\n  {\n    return mCoordValue.size();\n  }\nprivate:\n  MyGUI::IntCoord mCoordValue;\n};"
Line 5545
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  5545 always 5545
  "[test.cpp:7]: (performance, inconclusive) Technically the member function 'MyGUI::types::TCoord::size' can be static (but you may consider moving to unnamed namespace).\n[test.cpp:15]: (style, inconclusive) Technically the member function 'SelectorControl::getSize' can be const.\n" always "[test.cpp:7]: (performance, inconclusive) Technically the member function 'MyGUI::types::TCoord::size' can be static (but you may consider moving to unnamed namespace).\n[test.cpp:15]: (style, inconclusive) Technically the member function 'SelectorControl::getSize' can be const.\n"
  "[test.cpp:7]: (performance, inconclusive) Technically the member function 'MyGUI::types::TCoord::size' can be static (but you may consider moving to unnamed namespace).\n" always "[test.cpp:7]: (performance, inconclusive) Technically the member function 'MyGUI::types::TCoord::size' can be static (but you may consider moving to unnamed namespace).\n"
Line 5549
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  5549 always 5549
  "struct Foo {\n    Bar b;\n    void foo(Foo f) {\n        b.run();\n    }\n};" always "struct Foo {\n    Bar b;\n    void foo(Foo f) {\n        b.run();\n    }\n};"
Line 5555
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  5555 always 5555
  "" always ""
Line 5557
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  5557 always 5557
  "struct Bar {\n    int i = 0;\n    void run() { i++; }\n};\nstruct Foo {\n    Bar b;\n    void foo(Foo f) {\n        b.run();\n    }\n};" always "struct Bar {\n    int i = 0;\n    void run() { i++; }\n};\nstruct Foo {\n    Bar b;\n    void foo(Foo f) {\n        b.run();\n    }\n};"
Line 5567
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  5567 always 5567
  "" always ""
Line 5569
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  5569 always 5569
  "struct Bar {\n    void run() const { }\n};\nstruct Foo {\n    Bar b;\n    void foo(Foo f) {\n        b.run();\n    }\n};" always "struct Bar {\n    void run() const { }\n};\nstruct Foo {\n    Bar b;\n    void foo(Foo f) {\n        b.run();\n    }\n};"
Line 5578
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  5578 always 5578
  "[test.cpp:2]: (performance, inconclusive) Technically the member function 'Bar::run' can be static (but you may consider moving to unnamed namespace).\n[test.cpp:6]: (style, inconclusive) Technically the member function 'Foo::foo' can be const.\n" always "[test.cpp:2]: (performance, inconclusive) Technically the member function 'Bar::run' can be static (but you may consider moving to unnamed namespace).\n[test.cpp:6]: (style, inconclusive) Technically the member function 'Foo::foo' can be const.\n"
Line 5583
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  5583 always 5583
  "struct MyObject {\n    void foo(Foo f) {\n        f.clear();\n    }\n};" always "struct MyObject {\n    void foo(Foo f) {\n        f.clear();\n    }\n};"
Line 5588
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  5588 always 5588
  "[test.cpp:2]: (performance, inconclusive) Technically the member function 'MyObject::foo' can be static (but you may consider moving to unnamed namespace).\n" always "[test.cpp:2]: (performance, inconclusive) Technically the member function 'MyObject::foo' can be static (but you may consider moving to unnamed namespace).\n"
Line 5590
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  5590 always 5590
  "struct MyObject {\n    int foo(Foo f) {\n        return f.length();\n    }\n};" always "struct MyObject {\n    int foo(Foo f) {\n        return f.length();\n    }\n};"
Line 5595
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  5595 always 5595
  "[test.cpp:2]: (performance, inconclusive) Technically the member function 'MyObject::foo' can be static (but you may consider moving to unnamed namespace).\n" always "[test.cpp:2]: (performance, inconclusive) Technically the member function 'MyObject::foo' can be static (but you may consider moving to unnamed namespace).\n"
Line 5597
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  5597 always 5597
  "struct MyObject {\n    Foo f;\n    int foo() {\n        return f.length();\n    }\n};" always "struct MyObject {\n    Foo f;\n    int foo() {\n        return f.length();\n    }\n};"
Line 5603
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  5603 always 5603
  "" always ""
Line 5605
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  5605 always 5605
  "struct MyObject {\n    std::string f;\n    int foo() {\n        return f.length();\n    }\n};" always "struct MyObject {\n    std::string f;\n    int foo() {\n        return f.length();\n    }\n};"
Line 5611
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  5611 always 5611
  "[test.cpp:3]: (style, inconclusive) Technically the member function 'MyObject::foo' can be const.\n" always "[test.cpp:3]: (style, inconclusive) Technically the member function 'MyObject::foo' can be const.\n"
Line 5615
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  5615 always 5615
  "class C {\npublic:\n    inline void operator += (const int &x ) { re += x; }\n    friend inline void exp(C & c, const C & x) { }\nprotected:\n    int   re;\n    int   im;\n};" always "class C {\npublic:\n    inline void operator += (const int &x ) { re += x; }\n    friend inline void exp(C & c, const C & x) { }\nprotected:\n    int   re;\n    int   im;\n};"
Line 5623
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  5623 always 5623
  "" always ""
Line 5627
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  5627 always 5627
  "class MyString {\npublic:\n    MyString() : m_ptr(0){}\n    MyString& operator+=( const MyString& rhs ) {\n            delete m_ptr;\n            m_ptr = new char[42];\n    }\n    MyString append( const MyString& str )\n    {       return operator+=( str ); }\n    char *m_ptr;\n};" always "class MyString {\npublic:\n    MyString() : m_ptr(0){}\n    MyString& operator+=( const MyString& rhs ) {\n            delete m_ptr;\n            m_ptr = new char[42];\n    }\n    MyString append( const MyString& str )\n    {       return operator+=( str ); }\n    char *m_ptr;\n};"
Line 5638
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  5638 always 5638
  "" always ""
Line 5639
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  5639 always 5639
  "class MyString {\npublic:\n    MyString() : m_ptr(0){}\n    MyString& operator+=( const MyString& rhs );\n    MyString append( const MyString& str )\n    {       return operator+=( str ); }\n    char *m_ptr;\n};" always "class MyString {\npublic:\n    MyString() : m_ptr(0){}\n    MyString& operator+=( const MyString& rhs );\n    MyString append( const MyString& str )\n    {       return operator+=( str ); }\n    char *m_ptr;\n};"
Line 5647
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  5647 always 5647
  "" always ""
Line 5652
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  5652 always 5652
  "class MixerParticipant : public MixerParticipant {\n    int GetAudioFrame();\n};\nint MixerParticipant::GetAudioFrame() {\n    return 0;\n}" always "class MixerParticipant : public MixerParticipant {\n    int GetAudioFrame();\n};\nint MixerParticipant::GetAudioFrame() {\n    return 0;\n}"
Line 5660
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  5660 always 5660
  "class MixerParticipant : public MixerParticipant {\n    bool InitializeFileReader() {\n       printf(\"music\");\n    }\n};" always "class MixerParticipant : public MixerParticipant {\n    bool InitializeFileReader() {\n       printf(\"music\");\n    }\n};"
Line 5670
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  5670 always 5670
  "template<>\nclass Hash<void> {\nprotected:\n  typedef Key::key_type key_type;\n  void set(const Key& key);\n};\ntemplate<typename K, int KeySize>\nclass Hash : private Hash<void> {\n  typedef Hash<void> inherited;\n  void set(const Key& key) {\n      inherited::set(inherited::Key(key));\n  }\n};\n" always "template<>\nclass Hash<void> {\nprotected:\n  typedef Key::key_type key_type;\n  void set(const Key& key);\n};\ntemplate<typename K, int KeySize>\nclass Hash : private Hash<void> {\n  typedef Hash<void> inherited;\n  void set(const Key& key) {\n      inherited::set(inherited::Key(key));\n  }\n};\n"
  nullptr always 0
  false always 0
Line 5683
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  5683 always 5683
  "" always ""
Line 5687
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  5687 always 5687
  "class A {\n    private:\n         std::unordered_map<unsigned int,unsigned int> _hash;\n    public:\n         A() : _hash() {}\n         unsigned int fetch(unsigned int key)\n         {\n             return _hash[key];\n         }\n};" always "class A {\n    private:\n         std::unordered_map<unsigned int,unsigned int> _hash;\n    public:\n         A() : _hash() {}\n         unsigned int fetch(unsigned int key)\n         {\n             return _hash[key];\n         }\n};"
Line 5697
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  5697 always 5697
  "" always ""
Line 5701
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  5701 always 5701
  "struct A {\n    std::string s;\n    void clear() {\n         std::string* p = &s;\n         p->clear();\n     }\n};" always "struct A {\n    std::string s;\n    void clear() {\n         std::string* p = &s;\n         p->clear();\n     }\n};"
Line 5708
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  5708 always 5708
  "" always ""
Line 5710
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  5710 always 5710
  "struct A {\n    std::string s;\n    void clear() {\n         std::string& r = s;\n         r.clear();\n     }\n};" always "struct A {\n    std::string s;\n    void clear() {\n         std::string& r = s;\n         r.clear();\n     }\n};"
Line 5717
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  5717 always 5717
  "" always ""
Line 5719
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  5719 always 5719
  "struct A {\n    std::string s;\n    void clear() {\n         std::string& r = sth; r = s;\n         r.clear();\n     }\n};" always "struct A {\n    std::string s;\n    void clear() {\n         std::string& r = sth; r = s;\n         r.clear();\n     }\n};"
Line 5726
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  5726 always 5726
  "[test.cpp:3]: (style, inconclusive) Technically the member function 'A::clear' can be const.\n" always "[test.cpp:3]: (style, inconclusive) Technically the member function 'A::clear' can be const.\n"
Line 5728
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  5728 always 5728
  "struct A {\n    std::string s;\n    void clear() {\n         const std::string* p = &s;\n         p->somefunction();\n     }\n};" always "struct A {\n    std::string s;\n    void clear() {\n         const std::string* p = &s;\n         p->somefunction();\n     }\n};"
Line 5735
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  5735 always 5735
  "[test.cpp:3]: (style, inconclusive) Technically the member function 'A::clear' can be const.\n" always "[test.cpp:3]: (style, inconclusive) Technically the member function 'A::clear' can be const.\n"
Line 5737
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  5737 always 5737
  "struct A {\n    std::string s;\n    void clear() {\n         const std::string& r = s;\n         r.somefunction();\n     }\n};" always "struct A {\n    std::string s;\n    void clear() {\n         const std::string& r = s;\n         r.somefunction();\n     }\n};"
Line 5744
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  5744 always 5744
  "[test.cpp:3]: (style, inconclusive) Technically the member function 'A::clear' can be const.\n" always "[test.cpp:3]: (style, inconclusive) Technically the member function 'A::clear' can be const.\n"
Line 5748
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  5748 always 5748
  "namespace B {\n    namespace D {\n        typedef int DKIPtr;\n    }\n    class ZClass  {\n        void set(const ::B::D::DKIPtr& p) {\n            membervariable = p;\n        }\n        ::B::D::DKIPtr membervariable;\n    };\n}" always "namespace B {\n    namespace D {\n        typedef int DKIPtr;\n    }\n    class ZClass  {\n        void set(const ::B::D::DKIPtr& p) {\n            membervariable = p;\n        }\n        ::B::D::DKIPtr membervariable;\n    };\n}"
Line 5759
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  5759 always 5759
  "" always ""
Line 5763
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  5763 always 5763
  "template <typename T>\nclass TemplateClass {\npublic:\n   TemplateClass() { }\n};\ntemplate <>\nclass TemplateClass<float> {\npublic:\n   TemplateClass() { }\n};\nint main() {\n    TemplateClass<int> a;\n    TemplateClass<float> b;\n    return 0;\n}" always "template <typename T>\nclass TemplateClass {\npublic:\n   TemplateClass() { }\n};\ntemplate <>\nclass TemplateClass<float> {\npublic:\n   TemplateClass() { }\n};\nint main() {\n    TemplateClass<int> a;\n    TemplateClass<float> b;\n    return 0;\n}"
Line 5778
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  5778 always 5778
  "" always ""
Line 5782
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  5782 always 5782
  "struct C {\n    C() : n(0) {}\n    void f(int v) { g((char *) &v); }\n    void g(char *) { n++; }\n    int n;\n};" always "struct C {\n    C() : n(0) {}\n    void f(int v) { g((char *) &v); }\n    void g(char *) { n++; }\n    int n;\n};"
Line 5788
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  5788 always 5788
  "" always ""
Line 5792
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  5792 always 5792
  "template <class VALUE_T, class LIST_T = std::list<VALUE_T> >\nclass TestList {\npublic:\n    LIST_T m_list;\n};\nclass Test {\npublic:\n    const std::list<std::shared_ptr<int>>& get() { return m_test.m_list; }\n    TestList<std::shared_ptr<int>> m_test;\n};" always "template <class VALUE_T, class LIST_T = std::list<VALUE_T> >\nclass TestList {\npublic:\n    LIST_T m_list;\n};\nclass Test {\npublic:\n    const std::list<std::shared_ptr<int>>& get() { return m_test.m_list; }\n    TestList<std::shared_ptr<int>> m_test;\n};"
Line 5802
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  5802 always 5802
  "[test.cpp:8]: (style, inconclusive) Technically the member function 'Test::get' can be const.\n" always "[test.cpp:8]: (style, inconclusive) Technically the member function 'Test::get' can be const.\n"
Line 5806
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  5806 always 5806
  "class MyClass {\n    void clear() {\n        SVecPtr v = (SVecPtr) m_data;\n        v->clear();\n    }\n    void* m_data;\n};\n" always "class MyClass {\n    void clear() {\n        SVecPtr v = (SVecPtr) m_data;\n        v->clear();\n    }\n    void* m_data;\n};\n"
Line 5813
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  5813 always 5813
  "" always ""
Line 5817
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  5817 always 5817
  "struct A {\n    int a = 0;\n    template <typename... Args> void call(const Args &... args) { a = 1; }\n    template <typename T, typename... Args> auto call(const Args &... args) -> T {\n        a = 2;\n        return T{};\n    }\n};\n\nstruct B : public A {\n    void test() {\n        call();\n        call<int>(1, 2, 3);\n    }\n};" always "struct A {\n    int a = 0;\n    template <typename... Args> void call(const Args &... args) { a = 1; }\n    template <typename T, typename... Args> auto call(const Args &... args) -> T {\n        a = 2;\n        return T{};\n    }\n};\n\nstruct B : public A {\n    void test() {\n        call();\n        call<int>(1, 2, 3);\n    }\n};"
Line 5832
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  5832 always 5832
  "" always ""
Line 5836
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  5836 always 5836
  "struct A {\n    template <typename... Args> void call(Args ... args) {\n        func(this);\n    }\n\n    void test() {\n        call(1, 2);\n    }\n};" always "struct A {\n    template <typename... Args> void call(Args ... args) {\n        func(this);\n    }\n\n    void test() {\n        call(1, 2);\n    }\n};"
Line 5845
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  5845 always 5845
  "" always ""
Line 5849
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  5849 always 5849
  "struct Bar {\n    int j = 5;\n    void f(int& i) const { i += j; }\n};\nstruct Foo {\n    Bar bar;\n    int k{};\n    void g() { bar.f(k); }\n};\n" always "struct Bar {\n    int j = 5;\n    void f(int& i) const { i += j; }\n};\nstruct Foo {\n    Bar bar;\n    int k{};\n    void g() { bar.f(k); }\n};\n"
Line 5858
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  5858 always 5858
  "" always ""
Line 5860
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  5860 always 5860
  "struct S {\n    A a;\n    void f(int j, int*& p) {\n        p = &(((a[j])));\n    }\n};\n" always "struct S {\n    A a;\n    void f(int j, int*& p) {\n        p = &(((a[j])));\n    }\n};\n"
Line 5866
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  5866 always 5866
  "" always ""
Line 5870
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  5870 always 5870
  "struct S {\n    explicit S(int* p) : mp(p) {}\n    int* mp{};\n};\nstruct C {\n    int i{};\n    S f() { return S{ &i }; }\n};\n" always "struct S {\n    explicit S(int* p) : mp(p) {}\n    int* mp{};\n};\nstruct C {\n    int i{};\n    S f() { return S{ &i }; }\n};\n"
Line 5878
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  5878 always 5878
  "" always ""
Line 5880
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  5880 always 5880
  "struct S {\n    explicit S(int* p) : mp(p) {}\n    int* mp{};\n};\nstruct C {\n    int i{};\n    S f() { return S(&i); }\n};\n" always "struct S {\n    explicit S(int* p) : mp(p) {}\n    int* mp{};\n};\nstruct C {\n    int i{};\n    S f() { return S(&i); }\n};\n"
Line 5888
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  5888 always 5888
  "" always ""
Line 5890
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  5890 always 5890
  "struct S {\n    int* mp{};\n};\nstruct C {\n    int i{};\n    S f() { return S{ &i }; }\n};\n" always "struct S {\n    int* mp{};\n};\nstruct C {\n    int i{};\n    S f() { return S{ &i }; }\n};\n"
Line 5897
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  5897 always 5897
  "" always ""
Line 5899
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  5899 always 5899
  "struct S {\n    int* mp{};\n};\nstruct C {\n    int i{};\n    S f() { return { &i }; }\n};\n" always "struct S {\n    int* mp{};\n};\nstruct C {\n    int i{};\n    S f() { return { &i }; }\n};\n"
Line 5906
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  5906 always 5906
  "" always ""
Line 5908
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  5908 always 5908
  "struct S {\n    explicit S(const int* p) : mp(p) {}\n    const int* mp{};\n};\nstruct C {\n    int i{};\n    S f() { return S{ &i }; }\n};\n" always "struct S {\n    explicit S(const int* p) : mp(p) {}\n    const int* mp{};\n};\nstruct C {\n    int i{};\n    S f() { return S{ &i }; }\n};\n"
Line 5916
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  5916 always 5916
  "[test.cpp:7]: (style, inconclusive) Technically the member function 'C::f' can be const.\n" always "[test.cpp:7]: (style, inconclusive) Technically the member function 'C::f' can be const.\n"
  "" always ""
Line 5918
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  5918 always 5918
  "struct S {\n    explicit S(const int* p) : mp(p) {}\n    const int* mp{};\n};\nstruct C {\n    int i{};\n    S f() { return S(&i); }\n};\n" always "struct S {\n    explicit S(const int* p) : mp(p) {}\n    const int* mp{};\n};\nstruct C {\n    int i{};\n    S f() { return S(&i); }\n};\n"
Line 5926
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  5926 always 5926
  "[test.cpp:7]: (style, inconclusive) Technically the member function 'C::f' can be const.\n" always "[test.cpp:7]: (style, inconclusive) Technically the member function 'C::f' can be const.\n"
  "" always ""
Line 5928
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  5928 always 5928
  "struct S {\n    const int* mp{};\n};\nstruct C {\n    int i{};\n    S f() { return S{ &i }; }\n};\n" always "struct S {\n    const int* mp{};\n};\nstruct C {\n    int i{};\n    S f() { return S{ &i }; }\n};\n"
Line 5935
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  5935 always 5935
  "[test.cpp:7]: (style, inconclusive) Technically the member function 'C::f' can be const.\n" always "[test.cpp:7]: (style, inconclusive) Technically the member function 'C::f' can be const.\n"
  "" always ""
Line 5937
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  5937 always 5937
  "struct S {\n    const int* mp{};\n};\nstruct C {\n    int i{};\n    S f() { return { &i }; }\n};\n" always "struct S {\n    const int* mp{};\n};\nstruct C {\n    int i{};\n    S f() { return { &i }; }\n};\n"
Line 5944
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  5944 always 5944
  "[test.cpp:7]: (style, inconclusive) Technically the member function 'C::f' can be const.\n" always "[test.cpp:7]: (style, inconclusive) Technically the member function 'C::f' can be const.\n"
  "" always ""
Line 5948
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  5948 always 5948
  "struct A {\n    int* operator[](int i);\n    const int* operator[](int i) const;\n};\nstruct S {\n    A a;\n    void f(int j) {\n        int* p = a[j];\n        *p = 0;\n    }\n};\n" always "struct A {\n    int* operator[](int i);\n    const int* operator[](int i) const;\n};\nstruct S {\n    A a;\n    void f(int j) {\n        int* p = a[j];\n        *p = 0;\n    }\n};\n"
Line 5959
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  5959 always 5959
  "" always ""
Line 5961
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  5961 always 5961
  "struct S {\n    T* h;\n    void f(); \n};\nvoid S::f() {\n    char* c = h->x[y];\n};\n" always "struct S {\n    T* h;\n    void f(); \n};\nvoid S::f() {\n    char* c = h->x[y];\n};\n"
Line 5968
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  5968 always 5968
  "[test.cpp:5] -> [test.cpp:3]: (style, inconclusive) Technically the member function 'S::f' can be const.\n" always "[test.cpp:5] -> [test.cpp:3]: (style, inconclusive) Technically the member function 'S::f' can be const.\n"
Line 5972
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  5972 always 5972
  "class A {\n    std::vector<std::string> m_str;\npublic:\n    A() {}\n    void bar(void) {\n        for(std::vector<std::string>::const_iterator it = m_str.begin(); it != m_str.end(); ++it) {;}\n    }\n};" always "class A {\n    std::vector<std::string> m_str;\npublic:\n    A() {}\n    void bar(void) {\n        for(std::vector<std::string>::const_iterator it = m_str.begin(); it != m_str.end(); ++it) {;}\n    }\n};"
Line 5980
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  5980 always 5980
  "[test.cpp:5]: (style, inconclusive) Technically the member function 'A::bar' can be const.\n" always "[test.cpp:5]: (style, inconclusive) Technically the member function 'A::bar' can be const.\n"
Line 5983
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  5983 always 5983
  "struct S {\n    std::vector<T*> v;\n    void f() const;\n};\nvoid S::f() const {\n    for (std::vector<T*>::const_iterator it = v.begin(), end = v.end(); it != end; ++it) {}\n}\n" always "struct S {\n    std::vector<T*> v;\n    void f() const;\n};\nvoid S::f() const {\n    for (std::vector<T*>::const_iterator it = v.begin(), end = v.end(); it != end; ++it) {}\n}\n"
Line 5990
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  5990 always 5990
  "" always ""
Line 5994
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  5994 always 5994
  "namespace N { int i = 0; }\nstruct S {\n    int i;\n    void f() {\n        if (N::i) {}\n    }\n};\n" always "namespace N { int i = 0; }\nstruct S {\n    int i;\n    void f() {\n        if (N::i) {}\n    }\n};\n"
Line 6001
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  6001 always 6001
  "[test.cpp:4]: (performance, inconclusive) Technically the member function 'S::f' can be static (but you may consider moving to unnamed namespace).\n" always "[test.cpp:4]: (performance, inconclusive) Technically the member function 'S::f' can be static (but you may consider moving to unnamed namespace).\n"
Line 6003
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  6003 always 6003
  "int i = 0;\nstruct S {\n    int i;\n    void f() {\n        if (::i) {}\n    }\n};\n" always "int i = 0;\nstruct S {\n    int i;\n    void f() {\n        if (::i) {}\n    }\n};\n"
Line 6010
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  6010 always 6010
  "[test.cpp:4]: (performance, inconclusive) Technically the member function 'S::f' can be static (but you may consider moving to unnamed namespace).\n" always "[test.cpp:4]: (performance, inconclusive) Technically the member function 'S::f' can be static (but you may consider moving to unnamed namespace).\n"
Line 6012
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  6012 always 6012
  "namespace N {\n    struct S {\n        int i;\n        void f() {\n            if (N::S::i) {}\n        }\n    };\n}\n" always "namespace N {\n    struct S {\n        int i;\n        void f() {\n            if (N::S::i) {}\n        }\n    };\n}\n"
Line 6020
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  6020 always 6020
  "[test.cpp:4]: (style, inconclusive) Technically the member function 'N::S::f' can be const.\n" always "[test.cpp:4]: (style, inconclusive) Technically the member function 'N::S::f' can be const.\n"
Line 6024
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  6024 always 6024
  "struct S {\n    enum E {};\n    void f(const T* t);\n    E e;\n};\nstruct T { void e(); };\nvoid S::f(const T* t) {\n    const_cast<T*>(t)->e();\n};\n" always "struct S {\n    enum E {};\n    void f(const T* t);\n    E e;\n};\nstruct T { void e(); };\nvoid S::f(const T* t) {\n    const_cast<T*>(t)->e();\n};\n"
Line 6033
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  6033 always 6033
  "[test.cpp:7] -> [test.cpp:3]: (performance, inconclusive) Technically the member function 'S::f' can be static (but you may consider moving to unnamed namespace).\n" always "[test.cpp:7] -> [test.cpp:3]: (performance, inconclusive) Technically the member function 'S::f' can be static (but you may consider moving to unnamed namespace).\n"
Line 6038
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  6038 always 6038
  "template <typename T>\nstruct S {\n    std::vector<T> const* f() const { return p; }\n    std::vector<T> const* p;\n};\n" always "template <typename T>\nstruct S {\n    std::vector<T> const* f() const { return p; }\n    std::vector<T> const* p;\n};\n"
Line 6043
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  6043 always 6043
  "" always ""
Line 6045
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  6045 always 6045
  "struct S {\n    std::vector<const int*> v;\n    std::vector<const int*>& f() { return v; }\n};\n" always "struct S {\n    std::vector<const int*> v;\n    std::vector<const int*>& f() { return v; }\n};\n"
Line 6049
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  6049 always 6049
  "" always ""
Line 6053
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  6053 always 6053
  "struct S {\n    typedef void(S::* F)();\n    void g(F f);\n};\nvoid S::g(F f) {\n    (this->*f)();\n}\n" always "struct S {\n    typedef void(S::* F)();\n    void g(F f);\n};\nvoid S::g(F f) {\n    (this->*f)();\n}\n"
Line 6060
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  6060 always 6060
  "" always ""
Line 6062
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  6062 always 6062
  "struct S {\n    using F = void(S::*)();\n    void g(F f);\n};\nvoid S::g(F f) {\n    (this->*f)();\n}\n" always "struct S {\n    using F = void(S::*)();\n    void g(F f);\n};\nvoid S::g(F f) {\n    (this->*f)();\n}\n"
Line 6069
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  6069 always 6069
  "" always ""
Line 6073
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  6073 always 6073
  "class A {\npublic:\n    char* f() {\n        return nullptr;\n    }\n};\n" always "class A {\npublic:\n    char* f() {\n        return nullptr;\n    }\n};\n"
Line 6079
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  6079 always 6079
  "[test.cpp:3]: (performance, inconclusive) Technically the member function 'A::f' can be static (but you may consider moving to unnamed namespace).\n" always "[test.cpp:3]: (performance, inconclusive) Technically the member function 'A::f' can be static (but you may consider moving to unnamed namespace).\n"
Line 6084
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  6084 always 6084
  "struct Foo {\n    void foo1(int i, int j = 0) {\n        return func(this);\n    }\n    int bar1() {\n        return foo1(1);\n    }\n    int bar2() {\n        return foo1(1, 2);\n    }\n    int bar3() {\n        return foo1(1, 2, 3);\n    }\n    int bar4() {\n        return foo1();\n    }\n    void foo2(int i = 0) {\n        return func(this);\n    }\n    int bar5() {\n        return foo2();\n    }\n    void foo3() {\n        return func(this);\n    }\n    int bar6() {\n        return foo3();\n    }\n};" always "struct Foo {\n    void foo1(int i, int j = 0) {\n        return func(this);\n    }\n    int bar1() {\n        return foo1(1);\n    }\n    int bar2() {\n        return foo1(1, 2);\n    }\n    int bar3() {\n        return foo1(1, 2, 3);\n    }\n    int bar4() {\n        return foo1();\n    }\n    void foo2(int i = 0) {\n        return func(this);\n    }\n    int bar5() {\n        return foo2();\n    }\n    void foo3() {\n        return func(this);\n    }\n    int bar6() {\n        return foo3();\n    }\n};"
Line 6113
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  6113 always 6113
  "[test.cpp:11]: (performance, inconclusive) Technically the member function 'Foo::bar3' can be static (but you may consider moving to unnamed namespace).\n[test.cpp:14]: (performance, inconclusive) Technically the member function 'Foo::bar4' can be static (but you may consider moving to unnamed namespace).\n" always "[test.cpp:11]: (performance, inconclusive) Technically the member function 'Foo::bar3' can be static (but you may consider moving to unnamed namespace).\n[test.cpp:14]: (performance, inconclusive) Technically the member function 'Foo::bar4' can be static (but you may consider moving to unnamed namespace).\n"
Line 6118
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  6118 always 6118
  "struct Foo {\n    void foo() {\n        Bar b;\n        b.takeFoo(this);\n    }\n};" always "struct Foo {\n    void foo() {\n        Bar b;\n        b.takeFoo(this);\n    }\n};"
Line 6124
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  6124 always 6124
  "" always ""
Line 6126
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  6126 always 6126
  "struct Foo {\n    void foo() {\n        Foo f;\n        f.foo();\n    }\n};" always "struct Foo {\n    void foo() {\n        Foo f;\n        f.foo();\n    }\n};"
Line 6132
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  6132 always 6132
  "[test.cpp:2]: (performance, inconclusive) Technically the member function 'Foo::foo' can be static (but you may consider moving to unnamed namespace).\n" always "[test.cpp:2]: (performance, inconclusive) Technically the member function 'Foo::foo' can be static (but you may consider moving to unnamed namespace).\n"
Line 6134
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  6134 always 6134
  "struct A;\nstruct B {\n    void operator()(A *a);\n};\nstruct A {\n    void dostuff() {\n        B()(this);\n    }\n};" always "struct A;\nstruct B {\n    void operator()(A *a);\n};\nstruct A {\n    void dostuff() {\n        B()(this);\n    }\n};"
Line 6143
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  6143 always 6143
  "" always ""
Line 6147
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  6147 always 6147
  "struct s\n{\n    int** v;\n    void f()\n    {\n        v = 0;\n    }\n};" always "struct s\n{\n    int** v;\n    void f()\n    {\n        v = 0;\n    }\n};"
Line 6155
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  6155 always 6155
  "" always ""
Line 6159
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  6159 always 6159
  "struct s\n{\n    ::std::string v[3];\n    void f()\n    {\n        v[0] = \"Happy new year!\";\n    }\n};" always "struct s\n{\n    ::std::string v[3];\n    void f()\n    {\n        v[0] = \"Happy new year!\";\n    }\n};"
Line 6167
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  6167 always 6167
  "" always ""
Line 6172
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  6172 always 6172
  "class Fred {\n    int a;\n    void nextA() { return ++a; }\n};" always "class Fred {\n    int a;\n    void nextA() { return ++a; }\n};"
Line 6176
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  6176 always 6176
  "" always ""
Line 6178
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  6178 always 6178
  "class Fred {\n    int a;\n    void nextA() { return --a; }\n};" always "class Fred {\n    int a;\n    void nextA() { return --a; }\n};"
Line 6182
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  6182 always 6182
  "" always ""
Line 6184
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  6184 always 6184
  "class Fred {\n    int a;\n    void nextA() { return a++; }\n};" always "class Fred {\n    int a;\n    void nextA() { return a++; }\n};"
Line 6188
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  6188 always 6188
  "" always ""
Line 6190
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  6190 always 6190
  "class Fred {\n    int a;\n    void nextA() { return a--; }\n};" always "class Fred {\n    int a;\n    void nextA() { return a--; }\n};"
Line 6194
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  6194 always 6194
  "" always ""
Line 6196
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  6196 always 6196
  "int a;\nclass Fred {\n    void nextA() { return ++a; }\n};" always "int a;\nclass Fred {\n    void nextA() { return ++a; }\n};"
Line 6200
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  6200 always 6200
  "[test.cpp:3]: (performance, inconclusive) Technically the member function 'Fred::nextA' can be static (but you may consider moving to unnamed namespace).\n" always "[test.cpp:3]: (performance, inconclusive) Technically the member function 'Fred::nextA' can be static (but you may consider moving to unnamed namespace).\n"
Line 6202
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  6202 always 6202
  "int a;\nclass Fred {\n    void nextA() { return --a; }\n};" always "int a;\nclass Fred {\n    void nextA() { return --a; }\n};"
Line 6206
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  6206 always 6206
  "[test.cpp:3]: (performance, inconclusive) Technically the member function 'Fred::nextA' can be static (but you may consider moving to unnamed namespace).\n" always "[test.cpp:3]: (performance, inconclusive) Technically the member function 'Fred::nextA' can be static (but you may consider moving to unnamed namespace).\n"
Line 6208
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  6208 always 6208
  "int a;\nclass Fred {\n    void nextA() { return a++; }\n};" always "int a;\nclass Fred {\n    void nextA() { return a++; }\n};"
Line 6212
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  6212 always 6212
  "[test.cpp:3]: (performance, inconclusive) Technically the member function 'Fred::nextA' can be static (but you may consider moving to unnamed namespace).\n" always "[test.cpp:3]: (performance, inconclusive) Technically the member function 'Fred::nextA' can be static (but you may consider moving to unnamed namespace).\n"
Line 6214
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  6214 always 6214
  "int a;\nclass Fred {\n    void nextA() { return a--; }\n};" always "int a;\nclass Fred {\n    void nextA() { return a--; }\n};"
Line 6218
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  6218 always 6218
  "[test.cpp:3]: (performance, inconclusive) Technically the member function 'Fred::nextA' can be static (but you may consider moving to unnamed namespace).\n" always "[test.cpp:3]: (performance, inconclusive) Technically the member function 'Fred::nextA' can be static (but you may consider moving to unnamed namespace).\n"
Line 6222
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  6222 always 6222
  "class Fred {\n    int a;\n    void nextA() { return a=1; }\n};" always "class Fred {\n    int a;\n    void nextA() { return a=1; }\n};"
Line 6226
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  6226 always 6226
  "" always ""
Line 6228
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  6228 always 6228
  "class Fred {\n    int a;\n    void nextA() { return a-=1; }\n};" always "class Fred {\n    int a;\n    void nextA() { return a-=1; }\n};"
Line 6232
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  6232 always 6232
  "" always ""
Line 6234
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  6234 always 6234
  "class Fred {\n    int a;\n    void nextA() { return a+=1; }\n};" always "class Fred {\n    int a;\n    void nextA() { return a+=1; }\n};"
Line 6238
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  6238 always 6238
  "" always ""
Line 6240
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  6240 always 6240
  "class Fred {\n    int a;\n    void nextA() { return a*=-1; }\n};" always "class Fred {\n    int a;\n    void nextA() { return a*=-1; }\n};"
Line 6244
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  6244 always 6244
  "" always ""
Line 6246
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  6246 always 6246
  "class Fred {\n    int a;\n    void nextA() { return a/=-2; }\n};" always "class Fred {\n    int a;\n    void nextA() { return a/=-2; }\n};"
Line 6250
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  6250 always 6250
  "" always ""
Line 6252
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  6252 always 6252
  "int a;\nclass Fred {\n    void nextA() { return a=1; }\n};" always "int a;\nclass Fred {\n    void nextA() { return a=1; }\n};"
Line 6256
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  6256 always 6256
  "[test.cpp:3]: (performance, inconclusive) Technically the member function 'Fred::nextA' can be static (but you may consider moving to unnamed namespace).\n" always "[test.cpp:3]: (performance, inconclusive) Technically the member function 'Fred::nextA' can be static (but you may consider moving to unnamed namespace).\n"
Line 6258
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  6258 always 6258
  "int a;\nclass Fred {\n    void nextA() { return a-=1; }\n};" always "int a;\nclass Fred {\n    void nextA() { return a-=1; }\n};"
Line 6262
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  6262 always 6262
  "[test.cpp:3]: (performance, inconclusive) Technically the member function 'Fred::nextA' can be static (but you may consider moving to unnamed namespace).\n" always "[test.cpp:3]: (performance, inconclusive) Technically the member function 'Fred::nextA' can be static (but you may consider moving to unnamed namespace).\n"
Line 6264
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  6264 always 6264
  "int a;\nclass Fred {\n    void nextA() { return a+=1; }\n};" always "int a;\nclass Fred {\n    void nextA() { return a+=1; }\n};"
Line 6268
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  6268 always 6268
  "[test.cpp:3]: (performance, inconclusive) Technically the member function 'Fred::nextA' can be static (but you may consider moving to unnamed namespace).\n" always "[test.cpp:3]: (performance, inconclusive) Technically the member function 'Fred::nextA' can be static (but you may consider moving to unnamed namespace).\n"
Line 6270
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  6270 always 6270
  "int a;\nclass Fred {\n    void nextA() { return a*=-1; }\n};" always "int a;\nclass Fred {\n    void nextA() { return a*=-1; }\n};"
Line 6274
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  6274 always 6274
  "[test.cpp:3]: (performance, inconclusive) Technically the member function 'Fred::nextA' can be static (but you may consider moving to unnamed namespace).\n" always "[test.cpp:3]: (performance, inconclusive) Technically the member function 'Fred::nextA' can be static (but you may consider moving to unnamed namespace).\n"
Line 6276
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  6276 always 6276
  "int a;\nclass Fred {\n    void nextA() { return a/=-2; }\n};" always "int a;\nclass Fred {\n    void nextA() { return a/=-2; }\n};"
Line 6280
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  6280 always 6280
  "[test.cpp:3]: (performance, inconclusive) Technically the member function 'Fred::nextA' can be static (but you may consider moving to unnamed namespace).\n" always "[test.cpp:3]: (performance, inconclusive) Technically the member function 'Fred::nextA' can be static (but you may consider moving to unnamed namespace).\n"
Line 6284
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  6284 always 6284
  "class Fred {\n    struct A { int a; } s;\n    void nextA() { return s.a=1; }\n};" always "class Fred {\n    struct A { int a; } s;\n    void nextA() { return s.a=1; }\n};"
Line 6288
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  6288 always 6288
  "" always ""
Line 6290
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  6290 always 6290
  "class Fred {\n    struct A { int a; } s;\n    void nextA() { return s.a-=1; }\n};" always "class Fred {\n    struct A { int a; } s;\n    void nextA() { return s.a-=1; }\n};"
Line 6294
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  6294 always 6294
  "" always ""
Line 6296
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  6296 always 6296
  "class Fred {\n    struct A { int a; } s;\n    void nextA() { return s.a+=1; }\n};" always "class Fred {\n    struct A { int a; } s;\n    void nextA() { return s.a+=1; }\n};"
Line 6300
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  6300 always 6300
  "" always ""
Line 6302
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  6302 always 6302
  "class Fred {\n    struct A { int a; } s;\n    void nextA() { return s.a*=-1; }\n};" always "class Fred {\n    struct A { int a; } s;\n    void nextA() { return s.a*=-1; }\n};"
Line 6306
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  6306 always 6306
  "" always ""
Line 6308
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  6308 always 6308
  "struct A { int a; } s;\nclass Fred {\n    void nextA() { return s.a=1; }\n};" always "struct A { int a; } s;\nclass Fred {\n    void nextA() { return s.a=1; }\n};"
Line 6312
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  6312 always 6312
  "[test.cpp:3]: (performance, inconclusive) Technically the member function 'Fred::nextA' can be static (but you may consider moving to unnamed namespace).\n" always "[test.cpp:3]: (performance, inconclusive) Technically the member function 'Fred::nextA' can be static (but you may consider moving to unnamed namespace).\n"
Line 6314
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  6314 always 6314
  "struct A { int a; } s;\nclass Fred {\n    void nextA() { return s.a-=1; }\n};" always "struct A { int a; } s;\nclass Fred {\n    void nextA() { return s.a-=1; }\n};"
Line 6318
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  6318 always 6318
  "[test.cpp:3]: (performance, inconclusive) Technically the member function 'Fred::nextA' can be static (but you may consider moving to unnamed namespace).\n" always "[test.cpp:3]: (performance, inconclusive) Technically the member function 'Fred::nextA' can be static (but you may consider moving to unnamed namespace).\n"
Line 6320
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  6320 always 6320
  "struct A { int a; } s;\nclass Fred {\n    void nextA() { return s.a+=1; }\n};" always "struct A { int a; } s;\nclass Fred {\n    void nextA() { return s.a+=1; }\n};"
Line 6324
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  6324 always 6324
  "[test.cpp:3]: (performance, inconclusive) Technically the member function 'Fred::nextA' can be static (but you may consider moving to unnamed namespace).\n" always "[test.cpp:3]: (performance, inconclusive) Technically the member function 'Fred::nextA' can be static (but you may consider moving to unnamed namespace).\n"
Line 6326
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  6326 always 6326
  "struct A { int a; } s;\nclass Fred {\n    void nextA() { return s.a*=-1; }\n};" always "struct A { int a; } s;\nclass Fred {\n    void nextA() { return s.a*=-1; }\n};"
Line 6330
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  6330 always 6330
  "[test.cpp:3]: (performance, inconclusive) Technically the member function 'Fred::nextA' can be static (but you may consider moving to unnamed namespace).\n" always "[test.cpp:3]: (performance, inconclusive) Technically the member function 'Fred::nextA' can be static (but you may consider moving to unnamed namespace).\n"
Line 6332
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  6332 always 6332
  "struct A { int a; } s;\nclass Fred {\n    void nextA() { return s.a/=-2; }\n};" always "struct A { int a; } s;\nclass Fred {\n    void nextA() { return s.a/=-2; }\n};"
Line 6336
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  6336 always 6336
  "[test.cpp:3]: (performance, inconclusive) Technically the member function 'Fred::nextA' can be static (but you may consider moving to unnamed namespace).\n" always "[test.cpp:3]: (performance, inconclusive) Technically the member function 'Fred::nextA' can be static (but you may consider moving to unnamed namespace).\n"
Line 6338
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  6338 always 6338
  "struct A { int a; };\nclass Fred {\n    A s;\n    void nextA() { return s.a=1; }\n};" always "struct A { int a; };\nclass Fred {\n    A s;\n    void nextA() { return s.a=1; }\n};"
Line 6343
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  6343 always 6343
  "" always ""
Line 6345
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  6345 always 6345
  "struct A { int a; };\nclass Fred {\n    A s;\n    void nextA() { return s.a-=1; }\n};" always "struct A { int a; };\nclass Fred {\n    A s;\n    void nextA() { return s.a-=1; }\n};"
Line 6350
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  6350 always 6350
  "" always ""
Line 6352
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  6352 always 6352
  "struct A { int a; };\nclass Fred {\n    A s;\n    void nextA() { return s.a+=1; }\n};" always "struct A { int a; };\nclass Fred {\n    A s;\n    void nextA() { return s.a+=1; }\n};"
Line 6357
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  6357 always 6357
  "" always ""
Line 6359
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  6359 always 6359
  "struct A { int a; };\nclass Fred {\n    A s;\n    void nextA() { return s.a*=-1; }\n};" always "struct A { int a; };\nclass Fred {\n    A s;\n    void nextA() { return s.a*=-1; }\n};"
Line 6364
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  6364 always 6364
  "" always ""
Line 6366
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  6366 always 6366
  "struct A { int a; };\nclass Fred {\n    A s;\n    void nextA() { return s.a/=-2; }\n};" always "struct A { int a; };\nclass Fred {\n    A s;\n    void nextA() { return s.a/=-2; }\n};"
Line 6371
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  6371 always 6371
  "" always ""
Line 6376
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  6376 always 6376
  "class Fred {\n    int a[2];\n    void nextA() { return ++a[0]; }\n};" always "class Fred {\n    int a[2];\n    void nextA() { return ++a[0]; }\n};"
Line 6380
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  6380 always 6380
  "" always ""
Line 6382
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  6382 always 6382
  "class Fred {\n    int a[2];\n    void nextA() { return --a[0]; }\n};" always "class Fred {\n    int a[2];\n    void nextA() { return --a[0]; }\n};"
Line 6386
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  6386 always 6386
  "" always ""
Line 6388
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  6388 always 6388
  "class Fred {\n    int a[2];\n    void nextA() { return a[0]++; }\n};" always "class Fred {\n    int a[2];\n    void nextA() { return a[0]++; }\n};"
Line 6392
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  6392 always 6392
  "" always ""
Line 6394
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  6394 always 6394
  "class Fred {\n    int a[2];\n    void nextA() { return a[0]--; }\n};" always "class Fred {\n    int a[2];\n    void nextA() { return a[0]--; }\n};"
Line 6398
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  6398 always 6398
  "" always ""
Line 6400
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  6400 always 6400
  "int a[2];\nclass Fred {\n    void nextA() { return ++a[0]; }\n};" always "int a[2];\nclass Fred {\n    void nextA() { return ++a[0]; }\n};"
Line 6404
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  6404 always 6404
  "[test.cpp:3]: (performance, inconclusive) Technically the member function 'Fred::nextA' can be static (but you may consider moving to unnamed namespace).\n" always "[test.cpp:3]: (performance, inconclusive) Technically the member function 'Fred::nextA' can be static (but you may consider moving to unnamed namespace).\n"
Line 6406
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  6406 always 6406
  "int a[2];\nclass Fred {\n    void nextA() { return --a[0]; }\n};" always "int a[2];\nclass Fred {\n    void nextA() { return --a[0]; }\n};"
Line 6410
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  6410 always 6410
  "[test.cpp:3]: (performance, inconclusive) Technically the member function 'Fred::nextA' can be static (but you may consider moving to unnamed namespace).\n" always "[test.cpp:3]: (performance, inconclusive) Technically the member function 'Fred::nextA' can be static (but you may consider moving to unnamed namespace).\n"
Line 6412
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  6412 always 6412
  "int a[2];\nclass Fred {\n    void nextA() { return a[0]++; }\n};" always "int a[2];\nclass Fred {\n    void nextA() { return a[0]++; }\n};"
Line 6416
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  6416 always 6416
  "[test.cpp:3]: (performance, inconclusive) Technically the member function 'Fred::nextA' can be static (but you may consider moving to unnamed namespace).\n" always "[test.cpp:3]: (performance, inconclusive) Technically the member function 'Fred::nextA' can be static (but you may consider moving to unnamed namespace).\n"
Line 6418
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  6418 always 6418
  "int a[2];\nclass Fred {\n    void nextA() { return a[0]--; }\n};" always "int a[2];\nclass Fred {\n    void nextA() { return a[0]--; }\n};"
Line 6422
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  6422 always 6422
  "[test.cpp:3]: (performance, inconclusive) Technically the member function 'Fred::nextA' can be static (but you may consider moving to unnamed namespace).\n" always "[test.cpp:3]: (performance, inconclusive) Technically the member function 'Fred::nextA' can be static (but you may consider moving to unnamed namespace).\n"
Line 6426
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  6426 always 6426
  "class Fred {\n    int a[2];\n    void nextA() { return a[0]=1; }\n};" always "class Fred {\n    int a[2];\n    void nextA() { return a[0]=1; }\n};"
Line 6430
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  6430 always 6430
  "" always ""
Line 6432
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  6432 always 6432
  "class Fred {\n    int a[2];\n    void nextA() { return a[0]-=1; }\n};" always "class Fred {\n    int a[2];\n    void nextA() { return a[0]-=1; }\n};"
Line 6436
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  6436 always 6436
  "" always ""
Line 6438
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  6438 always 6438
  "class Fred {\n    int a[2];\n    void nextA() { return a[0]+=1; }\n};" always "class Fred {\n    int a[2];\n    void nextA() { return a[0]+=1; }\n};"
Line 6442
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  6442 always 6442
  "" always ""
Line 6444
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  6444 always 6444
  "class Fred {\n    int a[2];\n    void nextA() { return a[0]*=-1; }\n};" always "class Fred {\n    int a[2];\n    void nextA() { return a[0]*=-1; }\n};"
Line 6448
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  6448 always 6448
  "" always ""
Line 6450
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  6450 always 6450
  "class Fred {\n    int a[2];\n    void nextA() { return a[0]/=-2; }\n};" always "class Fred {\n    int a[2];\n    void nextA() { return a[0]/=-2; }\n};"
Line 6454
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  6454 always 6454
  "" always ""
Line 6456
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  6456 always 6456
  "int a[2];\nclass Fred {\n    void nextA() { return a[0]=1; }\n};" always "int a[2];\nclass Fred {\n    void nextA() { return a[0]=1; }\n};"
Line 6460
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  6460 always 6460
  "[test.cpp:3]: (performance, inconclusive) Technically the member function 'Fred::nextA' can be static (but you may consider moving to unnamed namespace).\n" always "[test.cpp:3]: (performance, inconclusive) Technically the member function 'Fred::nextA' can be static (but you may consider moving to unnamed namespace).\n"
Line 6462
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  6462 always 6462
  "int a[2];\nclass Fred {\n    void nextA() { return a[0]-=1; }\n};" always "int a[2];\nclass Fred {\n    void nextA() { return a[0]-=1; }\n};"
Line 6466
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  6466 always 6466
  "[test.cpp:3]: (performance, inconclusive) Technically the member function 'Fred::nextA' can be static (but you may consider moving to unnamed namespace).\n" always "[test.cpp:3]: (performance, inconclusive) Technically the member function 'Fred::nextA' can be static (but you may consider moving to unnamed namespace).\n"
Line 6468
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  6468 always 6468
  "int a[2];\nclass Fred {\n    void nextA() { return a[0]+=1; }\n};" always "int a[2];\nclass Fred {\n    void nextA() { return a[0]+=1; }\n};"
Line 6472
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  6472 always 6472
  "[test.cpp:3]: (performance, inconclusive) Technically the member function 'Fred::nextA' can be static (but you may consider moving to unnamed namespace).\n" always "[test.cpp:3]: (performance, inconclusive) Technically the member function 'Fred::nextA' can be static (but you may consider moving to unnamed namespace).\n"
Line 6474
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  6474 always 6474
  "int a[2];\nclass Fred {\n    void nextA() { return a[0]*=-1; }\n};" always "int a[2];\nclass Fred {\n    void nextA() { return a[0]*=-1; }\n};"
Line 6478
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  6478 always 6478
  "[test.cpp:3]: (performance, inconclusive) Technically the member function 'Fred::nextA' can be static (but you may consider moving to unnamed namespace).\n" always "[test.cpp:3]: (performance, inconclusive) Technically the member function 'Fred::nextA' can be static (but you may consider moving to unnamed namespace).\n"
Line 6480
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  6480 always 6480
  "int a[2];\nclass Fred {\n    void nextA() { return a[0]/=-2; }\n};" always "int a[2];\nclass Fred {\n    void nextA() { return a[0]/=-2; }\n};"
Line 6484
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  6484 always 6484
  "[test.cpp:3]: (performance, inconclusive) Technically the member function 'Fred::nextA' can be static (but you may consider moving to unnamed namespace).\n" always "[test.cpp:3]: (performance, inconclusive) Technically the member function 'Fred::nextA' can be static (but you may consider moving to unnamed namespace).\n"
Line 6489
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  6489 always 6489
  "class Fred {\n    int a;\n    int &getR() { return a; }\n    int *getP() { return &a; }};" always "class Fred {\n    int a;\n    int &getR() { return a; }\n    int *getP() { return &a; }};"
Line 6494
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  6494 always 6494
  "" always ""
Line 6499
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  6499 always 6499
  "class Fred {\n    int *a;\n    void clean() { delete a; }\n};" always "class Fred {\n    int *a;\n    void clean() { delete a; }\n};"
Line 6503
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  6503 always 6503
  "" always ""
Line 6508
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  6508 always 6508
  "class Fred {\n    UNKNOWN a() { return 0; };\n};" always "class Fred {\n    UNKNOWN a() { return 0; };\n};"
Line 6511
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  6511 always 6511
  "[test.cpp:2]: (performance, inconclusive) Technically the member function 'Fred::a' can be static.\n" always "[test.cpp:2]: (performance, inconclusive) Technically the member function 'Fred::a' can be static.\n"
  "" always ""
Line 6514
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  6514 always 6514
  "class Fred {\n    foo bar;\n    UNKNOWN a() { return b; };\n};" always "class Fred {\n    foo bar;\n    UNKNOWN a() { return b; };\n};"
Line 6518
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  6518 always 6518
  "" always ""
Line 6523
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  6523 always 6523
  "class Fred {\n    void f() const { };\n    void a() { f(); };\n};" always "class Fred {\n    void f() const { };\n    void a() { f(); };\n};"
Line 6527
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  6527 always 6527
  "[test.cpp:2]: (performance, inconclusive) Technically the member function 'Fred::f' can be static (but you may consider moving to unnamed namespace).\n[test.cpp:3]: (style, inconclusive) Technically the member function 'Fred::a' can be const.\n" always "[test.cpp:2]: (performance, inconclusive) Technically the member function 'Fred::f' can be static (but you may consider moving to unnamed namespace).\n[test.cpp:3]: (style, inconclusive) Technically the member function 'Fred::a' can be const.\n"
Line 6531
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  6531 always 6531
  "class A\n{\n   std::vector<int> m_v;\npublic:\n   A(){}\n   unsigned int GetVecSize()  {return m_v.size();}\n};" always "class A\n{\n   std::vector<int> m_v;\npublic:\n   A(){}\n   unsigned int GetVecSize()  {return m_v.size();}\n};"
Line 6538
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  6538 always 6538
  "[test.cpp:6]: (style, inconclusive) Technically the member function 'A::GetVecSize' can be const.\n" always "[test.cpp:6]: (style, inconclusive) Technically the member function 'A::GetVecSize' can be const.\n"
Line 6540
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  6540 always 6540
  "class A\n{\n   std::vector<int> m_v;\npublic:\n   A(){}\n   bool GetVecEmpty()  {return m_v.empty();}\n};" always "class A\n{\n   std::vector<int> m_v;\npublic:\n   A(){}\n   bool GetVecEmpty()  {return m_v.empty();}\n};"
Line 6547
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  6547 always 6547
  "[test.cpp:6]: (style, inconclusive) Technically the member function 'A::GetVecEmpty' can be const.\n" always "[test.cpp:6]: (style, inconclusive) Technically the member function 'A::GetVecEmpty' can be const.\n"
Line 6552
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  6552 always 6552
  "class A { };\nclass B : public A {\n   int b;\npublic:\n   B() : b(0) { }\n   int func() { return b; }\n};" always "class A { };\nclass B : public A {\n   int b;\npublic:\n   B() : b(0) { }\n   int func() { return b; }\n};"
Line 6559
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  6559 always 6559
  "[test.cpp:6]: (style, inconclusive) Technically the member function 'B::func' can be const.\n" always "[test.cpp:6]: (style, inconclusive) Technically the member function 'B::func' can be const.\n"
Line 6561
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  6561 always 6561
  "class A { };\nclass B : public A {\n   int b;\npublic:\n   B() : b(0) { }\n   int func();\n};\nint B::func() { return b; }" always "class A { };\nclass B : public A {\n   int b;\npublic:\n   B() : b(0) { }\n   int func();\n};\nint B::func() { return b; }"
Line 6569
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  6569 always 6569
  "[test.cpp:8] -> [test.cpp:6]: (style, inconclusive) Technically the member function 'B::func' can be const.\n" always "[test.cpp:8] -> [test.cpp:6]: (style, inconclusive) Technically the member function 'B::func' can be const.\n"
Line 6572
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  6572 always 6572
  "class A {\npublic:\n    int func();\n};\nclass B : public A {\n    int b;\npublic:\n    B() : b(0) { }\n    int func() { return b; }\n};" always "class A {\npublic:\n    int func();\n};\nclass B : public A {\n    int b;\npublic:\n    B() : b(0) { }\n    int func() { return b; }\n};"
Line 6582
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  6582 always 6582
  "[test.cpp:9]: (style, inconclusive) Technically the member function 'B::func' can be const.\n" always "[test.cpp:9]: (style, inconclusive) Technically the member function 'B::func' can be const.\n"
Line 6584
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  6584 always 6584
  "class A {\npublic:\n    int func();\n};\nclass B : public A {\n    int b;\npublic:\n    B() : b(0) { }\n    int func();\n};\nint B::func() { return b; }" always "class A {\npublic:\n    int func();\n};\nclass B : public A {\n    int b;\npublic:\n    B() : b(0) { }\n    int func();\n};\nint B::func() { return b; }"
Line 6595
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  6595 always 6595
  "[test.cpp:11] -> [test.cpp:9]: (style, inconclusive) Technically the member function 'B::func' can be const.\n" always "[test.cpp:11] -> [test.cpp:9]: (style, inconclusive) Technically the member function 'B::func' can be const.\n"
Line 6598
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  6598 always 6598
  "class A {\npublic:\n    virtual int func();\n};\nclass B : public A {\n    int b;\npublic:\n    B() : b(0) { }\n    int func() { return b; }\n};" always "class A {\npublic:\n    virtual int func();\n};\nclass B : public A {\n    int b;\npublic:\n    B() : b(0) { }\n    int func() { return b; }\n};"
Line 6608
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  6608 always 6608
  "" always ""
Line 6610
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  6610 always 6610
  "class A {\npublic:\n    virtual int func();\n};\nclass B : public A {\n    int b;\npublic:\n    B() : b(0) { }\n    int func();\n};\nint B::func() { return b; }" always "class A {\npublic:\n    virtual int func();\n};\nclass B : public A {\n    int b;\npublic:\n    B() : b(0) { }\n    int func();\n};\nint B::func() { return b; }"
Line 6621
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  6621 always 6621
  "" always ""
Line 6623
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  6623 always 6623
  "class A {\npublic:\n    virtual int func() = 0;\n};\nclass B : public A {\n    int b;\npublic:\n    B() : b(0) { }\n    int func();\n};\nint B::func() { return b; }" always "class A {\npublic:\n    virtual int func() = 0;\n};\nclass B : public A {\n    int b;\npublic:\n    B() : b(0) { }\n    int func();\n};\nint B::func() { return b; }"
Line 6634
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  6634 always 6634
  "" always ""
Line 6637
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  6637 always 6637
  "class A {\n    int a;\npublic:\n    A() : a(0) { }\n    int func() { return a; }\n};\nclass B : public A {\n    int b;\npublic:\n    B() : b(0) { }\n    int func() { return b; }\n};\nclass C : public B {\n    int c;\npublic:\n    C() : c(0) { }\n    int func() { return c; }\n};" always "class A {\n    int a;\npublic:\n    A() : a(0) { }\n    int func() { return a; }\n};\nclass B : public A {\n    int b;\npublic:\n    B() : b(0) { }\n    int func() { return b; }\n};\nclass C : public B {\n    int c;\npublic:\n    C() : c(0) { }\n    int func() { return c; }\n};"
Line 6655
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  6655 always 6655
  "[test.cpp:5]: (style, inconclusive) Technically the member function 'A::func' can be const.\n[test.cpp:11]: (style, inconclusive) Technically the member function 'B::func' can be const.\n[test.cpp:17]: (style, inconclusive) Technically the member function 'C::func' can be const.\n" always "[test.cpp:5]: (style, inconclusive) Technically the member function 'A::func' can be const.\n[test.cpp:11]: (style, inconclusive) Technically the member function 'B::func' can be const.\n[test.cpp:17]: (style, inconclusive) Technically the member function 'C::func' can be const.\n"
Line 6659
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  6659 always 6659
  "class A {\n    int a;\npublic:\n    A() : a(0) { }\n    int func();\n};\nint A::func() { return a; }\nclass B : public A {\n    int b;\npublic:\n    B() : b(0) { }\n    int func();\n};\nint B::func() { return b; }\nclass C : public B {\n    int c;\npublic:\n    C() : c(0) { }\n    int func();\n};\nint C::func() { return c; }" always "class A {\n    int a;\npublic:\n    A() : a(0) { }\n    int func();\n};\nint A::func() { return a; }\nclass B : public A {\n    int b;\npublic:\n    B() : b(0) { }\n    int func();\n};\nint B::func() { return b; }\nclass C : public B {\n    int c;\npublic:\n    C() : c(0) { }\n    int func();\n};\nint C::func() { return c; }"
Line 6680
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  6680 always 6680
  "[test.cpp:7] -> [test.cpp:5]: (style, inconclusive) Technically the member function 'A::func' can be const.\n[test.cpp:14] -> [test.cpp:12]: (style, inconclusive) Technically the member function 'B::func' can be const.\n[test.cpp:21] -> [test.cpp:19]: (style, inconclusive) Technically the member function 'C::func' can be const.\n" always "[test.cpp:7] -> [test.cpp:5]: (style, inconclusive) Technically the member function 'A::func' can be const.\n[test.cpp:14] -> [test.cpp:12]: (style, inconclusive) Technically the member function 'B::func' can be const.\n[test.cpp:21] -> [test.cpp:19]: (style, inconclusive) Technically the member function 'C::func' can be const.\n"
Line 6685
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  6685 always 6685
  "class A {\n    int a;\npublic:\n    A() : a(0) { }\n    virtual int func() { return a; }\n};\nclass B : public A {\n    int b;\npublic:\n    B() : b(0) { }\n    int func() { return b; }\n};\nclass C : public B {\n    int c;\npublic:\n    C() : c(0) { }\n    int func() { return c; }\n};" always "class A {\n    int a;\npublic:\n    A() : a(0) { }\n    virtual int func() { return a; }\n};\nclass B : public A {\n    int b;\npublic:\n    B() : b(0) { }\n    int func() { return b; }\n};\nclass C : public B {\n    int c;\npublic:\n    C() : c(0) { }\n    int func() { return c; }\n};"
Line 6703
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  6703 always 6703
  "" always ""
Line 6705
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  6705 always 6705
  "class A {\n    int a;\npublic:\n    A() : a(0) { }\n    virtual int func();\n};\nint A::func() { return a; }\nclass B : public A {\n    int b;\npublic:\n    B() : b(0) { }\n    int func();\n};\nint B::func() { return b; }\nclass C : public B {\n    int c;\npublic:\n    C() : c(0) { }\n    int func();\n};\nint C::func() { return c; }" always "class A {\n    int a;\npublic:\n    A() : a(0) { }\n    virtual int func();\n};\nint A::func() { return a; }\nclass B : public A {\n    int b;\npublic:\n    B() : b(0) { }\n    int func();\n};\nint B::func() { return b; }\nclass C : public B {\n    int c;\npublic:\n    C() : c(0) { }\n    int func();\n};\nint C::func() { return c; }"
Line 6726
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  6726 always 6726
  "" always ""
Line 6729
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  6729 always 6729
  "class X {\n    int x;\npublic:\n    X(int x) : x(x) { }\n    int getX() { return x; }\n};\nclass Y : public X {\n    int y;\npublic:\n    Y(int x, int y) : X(x), y(y) { }\n    int getY() { return y; }\n};\nclass Z : public Y {\n    int z;\npublic:\n    Z(int x, int y, int z) : Y(x, y), z(z) { }\n    int getZ() { return z; }\n};" always "class X {\n    int x;\npublic:\n    X(int x) : x(x) { }\n    int getX() { return x; }\n};\nclass Y : public X {\n    int y;\npublic:\n    Y(int x, int y) : X(x), y(y) { }\n    int getY() { return y; }\n};\nclass Z : public Y {\n    int z;\npublic:\n    Z(int x, int y, int z) : Y(x, y), z(z) { }\n    int getZ() { return z; }\n};"
Line 6747
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  6747 always 6747
  "[test.cpp:5]: (style, inconclusive) Technically the member function 'X::getX' can be const.\n[test.cpp:11]: (style, inconclusive) Technically the member function 'Y::getY' can be const.\n[test.cpp:17]: (style, inconclusive) Technically the member function 'Z::getZ' can be const.\n" always "[test.cpp:5]: (style, inconclusive) Technically the member function 'X::getX' can be const.\n[test.cpp:11]: (style, inconclusive) Technically the member function 'Y::getY' can be const.\n[test.cpp:17]: (style, inconclusive) Technically the member function 'Z::getZ' can be const.\n"
Line 6751
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  6751 always 6751
  "class X {\n    int x;\npublic:\n    X(int x) : x(x) { }\n    int getX();\n};\nint X::getX() { return x; }\nclass Y : public X {\n    int y;\npublic:\n    Y(int x, int y) : X(x), y(y) { }\n    int getY();\n};\nint Y::getY() { return y; }\nclass Z : public Y {\n    int z;\npublic:\n    Z(int x, int y, int z) : Y(x, y), z(z) { }\n    int getZ();\n};\nint Z::getZ() { return z; }" always "class X {\n    int x;\npublic:\n    X(int x) : x(x) { }\n    int getX();\n};\nint X::getX() { return x; }\nclass Y : public X {\n    int y;\npublic:\n    Y(int x, int y) : X(x), y(y) { }\n    int getY();\n};\nint Y::getY() { return y; }\nclass Z : public Y {\n    int z;\npublic:\n    Z(int x, int y, int z) : Y(x, y), z(z) { }\n    int getZ();\n};\nint Z::getZ() { return z; }"
Line 6772
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  6772 always 6772
  "[test.cpp:7] -> [test.cpp:5]: (style, inconclusive) Technically the member function 'X::getX' can be const.\n[test.cpp:14] -> [test.cpp:12]: (style, inconclusive) Technically the member function 'Y::getY' can be const.\n[test.cpp:21] -> [test.cpp:19]: (style, inconclusive) Technically the member function 'Z::getZ' can be const.\n" always "[test.cpp:7] -> [test.cpp:5]: (style, inconclusive) Technically the member function 'X::getX' can be const.\n[test.cpp:14] -> [test.cpp:12]: (style, inconclusive) Technically the member function 'Y::getY' can be const.\n[test.cpp:21] -> [test.cpp:19]: (style, inconclusive) Technically the member function 'Z::getZ' can be const.\n"
Line 6778
  48 always 48
  = always "struct foo {\n    int i;\n    void f() {\n    }\n};"
  "struct foo {\n    int i;\n    void f() {\n    }\n};" always "struct foo {\n    int i;\n    void f() {\n    }\n};"
Line 6787
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  6787 always 6787
  code always "struct foo {\n    int i;\n    void f() {\n    }\n};"
  & {lifetime[Address]=(settings0),!0}
  true always 1
Line 6788
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  6788 always 6788
  "[test.cpp:3]: (performance, inconclusive) Technically the member function 'foo::f' can be static (but you may consider moving to unnamed namespace).\n" always "[test.cpp:3]: (performance, inconclusive) Technically the member function 'foo::f' can be static (but you may consider moving to unnamed namespace).\n"
Line 6790
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  6790 always 6790
  code always "struct foo {\n    int i;\n    void f() {\n    }\n};"
  & {lifetime[Address]=(settings0),!0}
  false always 0
Line 6791
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  6791 always 6791
  "" always ""
Line 6795
  39 always 39
  = always "class foo {\n    friend void f() { }\n};"
  "class foo {\n    friend void f() { }\n};" always "class foo {\n    friend void f() { }\n};"
Line 6798
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  6798 always 6798
  code always "class foo {\n    friend void f() { }\n};"
Line 6799
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  6799 always 6799
  "" always ""
Line 6803
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  6803 always 6803
  "class foo {\npublic:\n    union {\n        int i;\n        float f;\n    } d;\n    void setf(float x) {\n        d.f = x;\n    }\n};" always "class foo {\npublic:\n    union {\n        int i;\n        float f;\n    } d;\n    void setf(float x) {\n        d.f = x;\n    }\n};"
Line 6813
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  6813 always 6813
  "" always ""
Line 6817
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  6817 always 6817
  "struct foo {\n    int x;\n    int y[5][724];\n    T a() {\n        return y[x++][6];\n    }\n    T b() {\n        return y[1][++x];\n    }\n    T c() {\n        return y[1][6];\n    }\n};" always "struct foo {\n    int x;\n    int y[5][724];\n    T a() {\n        return y[x++][6];\n    }\n    T b() {\n        return y[1][++x];\n    }\n    T c() {\n        return y[1][6];\n    }\n};"
Line 6830
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  6830 always 6830
  "[test.cpp:10]: (style, inconclusive) Technically the member function 'foo::c' can be const.\n" always "[test.cpp:10]: (style, inconclusive) Technically the member function 'foo::c' can be const.\n"
Line 6834
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  6834 always 6834
  "class Fred {\n    int array[256];\npublic:\n    void f1() {\n        for (auto & e : array)\n            foo(e);\n    }\n    void f2() {\n        for (const auto & e : array)\n            foo(e);\n    }\n    void f3() {\n        for (decltype(auto) e : array)\n            foo(e);\n    }\n};" always "class Fred {\n    int array[256];\npublic:\n    void f1() {\n        for (auto & e : array)\n            foo(e);\n    }\n    void f2() {\n        for (const auto & e : array)\n            foo(e);\n    }\n    void f3() {\n        for (decltype(auto) e : array)\n            foo(e);\n    }\n};"
Line 6850
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  6850 always 6850
  "[test.cpp:8]: (style, inconclusive) Technically the member function 'Fred::f2' can be const.\n" always "[test.cpp:8]: (style, inconclusive) Technically the member function 'Fred::f2' can be const.\n"
Line 6854
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  6854 always 6854
  "class Fred {\npublic:\n    std::shared_ptr<Data> getData();\nprivate:\n     std::shared_ptr<Data> data;\n};\n\nstd::shared_ptr<Data> Fred::getData() { return data; }" always "class Fred {\npublic:\n    std::shared_ptr<Data> getData();\nprivate:\n     std::shared_ptr<Data> data;\n};\n\nstd::shared_ptr<Data> Fred::getData() { return data; }"
Line 6862
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  6862 always 6862
  "" always ""
Line 6866
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  6866 always 6866
  "class Fred {\npublic:\n    const char *const *data;\n    const char *const *getData() { return data; }\n}" always "class Fred {\npublic:\n    const char *const *data;\n    const char *const *getData() { return data; }\n}"
Line 6870
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  6870 always 6870
  "[test.cpp:4]: (style, inconclusive) Technically the member function 'Fred::getData' can be const.\n" always "[test.cpp:4]: (style, inconclusive) Technically the member function 'Fred::getData' can be const.\n"
Line 6874
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  6874 always 6874
  "struct A {\n    int x = 1;\n    auto get() -> int & { return x; }\n};" always "struct A {\n    int x = 1;\n    auto get() -> int & { return x; }\n};"
Line 6878
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  6878 always 6878
  "" always ""
Line 6882
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  6882 always 6882
  "struct S {\n    template<size_t N>\n    void f(const std::array<std::string_view, N>& sv);\n    template<long N>\n    void f(const char* const (&StrArr)[N]);\n};\ntemplate<size_t N>\nvoid S::f(const std::array<std::string_view, N>& sv) {\n    const char* ptrs[N]{};\n    return f(ptrs);\n}\ntemplate void S::f(const std::array<std::string_view, 3>& sv);\n" always "struct S {\n    template<size_t N>\n    void f(const std::array<std::string_view, N>& sv);\n    template<long N>\n    void f(const char* const (&StrArr)[N]);\n};\ntemplate<size_t N>\nvoid S::f(const std::array<std::string_view, N>& sv) {\n    const char* ptrs[N]{};\n    return f(ptrs);\n}\ntemplate void S::f(const std::array<std::string_view, 3>& sv);\n"
Line 6894
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  6894 always 6894
  "" always ""
Line 6900
  = always 1
  true always 1
Line 6901
  ( {lifetime[Object]=(exename),!0}
  "std.cfg" always "std.cfg"
  != always {!<=-1,!>=2}
  "std.cfg" always "std.cfg"
  false always 0
Line 6902
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  6902 always 6902
  "struct data {};\n    struct S {\n    std::vector<data> std;\n    void f();\n};\nvoid S::f() {\n    std::vector<data>::const_iterator end = std.end();\n}\n" always "struct data {};\n    struct S {\n    std::vector<data> std;\n    void f();\n};\nvoid S::f() {\n    std::vector<data>::const_iterator end = std.end();\n}\n"
  & {lifetime[Address]=(s),!0}
Line 6910
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  6910 always 6910
  "[test.cpp:6] -> [test.cpp:4]: (style, inconclusive) Technically the member function 'S::f' can be const.\n" always "[test.cpp:6] -> [test.cpp:4]: (style, inconclusive) Technically the member function 'S::f' can be const.\n"
Line 6916
  "" always ""
Line 6919
  true always 1
Line 6922
  & {lifetime[Address]=(settings0),!0}
  this always !0
Line 6923
  code possible {"class Fred {\n    int a, b, c;\npublic:\n    Fred() : c(0), b(0), a(0) { }\n};"@109,"class Fred {\n    int a, b, c;\npublic:\n    Fred() : c{0}, b{0}, a{0} { }\n};"@110}
Line 6924
  ( always {!<=-1,!>=2}
  file inconclusive {"cppcheck-2.8/test/testclass.cpp"@109,"cppcheck-2.8/test/testclass.cpp"@110}
  line inconclusive {6931@109,6939@110}
  "test.cpp" always "test.cpp"
Line 6926
  & {lifetime[Address]=(tokenizer),!0}
  & {lifetime[Address]=(settings0),!0}
  this always !0
Line 6931
  "class Fred {\n    int a, b, c;\npublic:\n    Fred() : c(0), b(0), a(0) { }\n};" always "class Fred {\n    int a, b, c;\npublic:\n    Fred() : c(0), b(0), a(0) { }\n};"
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  6931 always 6931
Line 6936
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  6936 always 6936
  "[test.cpp:4] -> [test.cpp:2]: (style, inconclusive) Member variable 'Fred::b' is in the wrong place in the initializer list.\n[test.cpp:4] -> [test.cpp:2]: (style, inconclusive) Member variable 'Fred::a' is in the wrong place in the initializer list.\n" always "[test.cpp:4] -> [test.cpp:2]: (style, inconclusive) Member variable 'Fred::b' is in the wrong place in the initializer list.\n[test.cpp:4] -> [test.cpp:2]: (style, inconclusive) Member variable 'Fred::a' is in the wrong place in the initializer list.\n"
Line 6939
  "class Fred {\n    int a, b, c;\npublic:\n    Fred() : c{0}, b{0}, a{0} { }\n};" always "class Fred {\n    int a, b, c;\npublic:\n    Fred() : c{0}, b{0}, a{0} { }\n};"
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  6939 always 6939
Line 6944
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  6944 always 6944
  "[test.cpp:4] -> [test.cpp:2]: (style, inconclusive) Member variable 'Fred::b' is in the wrong place in the initializer list.\n[test.cpp:4] -> [test.cpp:2]: (style, inconclusive) Member variable 'Fred::a' is in the wrong place in the initializer list.\n" always "[test.cpp:4] -> [test.cpp:2]: (style, inconclusive) Member variable 'Fred::b' is in the wrong place in the initializer list.\n[test.cpp:4] -> [test.cpp:2]: (style, inconclusive) Member variable 'Fred::a' is in the wrong place in the initializer list.\n"
Line 6951
  "" always ""
Line 6958
  & {lifetime[Address]=(settings),!0}
  this always !0
Line 6959
  code possible {"enum Enum { C = 0 };\nclass Fred {\n    int a;\n    int* b;\n    Enum c;\n    Fred() { a = 0; b = 0; c = C; }\n};"@84,"class Fred {\n    std::string s;\n    Fred() { a = 0; s = \"foo\"; }\n};"@85,"class Fred {\n    std::string& s;\n    Fred(const std::string& s_) : s(s_) { s = \"foo\"; }\n};"@86,"class Fred {\n    std::vector<int> v;\n    Fred() { v = unknown; }\n};"@87,"class C { std::string s; };\nclass Fred {\n    C c;\n    Fred() { c = unknown; }\n};"@88,"class C;\nclass Fred {\n    C c;\n    Fred() { c = unknown; }\n};"@89,"class C;\nclass Fred {\n    C c;\n    Fred(Fred const & other) { c = other.c; }\n};"@90,"class C;\nclass Fred {\n    C c;\n    Fred(Fred && other) { c = other.c; }\n};"@91,"class C;\nclass Fred {\n    C a;\n    Fred() { initB(); a = b; }\n};"@92,"class C;\nclass Fred {\n    C a;\n    Fred() : a(0) { if(b) a = 0; }\n};"@93}
Line 6960
  ( always {!<=-1,!>=2}
  file inconclusive {"cppcheck-2.8/test/testclass.cpp"@84,"cppcheck-2.8/test/testclass.cpp"@85,"cppcheck-2.8/test/testclass.cpp"@86,"cppcheck-2.8/test/testclass.cpp"@87,"cppcheck-2.8/test/testclass.cpp"@88,"cppcheck-2.8/test/testclass.cpp"@89,"cppcheck-2.8/test/testclass.cpp"@90,"cppcheck-2.8/test/testclass.cpp"@91,"cppcheck-2.8/test/testclass.cpp"@92,"cppcheck-2.8/test/testclass.cpp"@93}
  line inconclusive {6967@84,6976@85,6982@86,6988@87,6994@88,7001@89,7008@90,7015@91,7022@92,7029@93}
  "test.cpp" always "test.cpp"
Line 6962
  & {lifetime[Address]=(tokenizer),!0}
  & {lifetime[Address]=(settings),!0}
  this always !0
Line 6967
  "enum Enum { C = 0 };\nclass Fred {\n    int a;\n    int* b;\n    Enum c;\n    Fred() { a = 0; b = 0; c = C; }\n};" always "enum Enum { C = 0 };\nclass Fred {\n    int a;\n    int* b;\n    Enum c;\n    Fred() { a = 0; b = 0; c = C; }\n};"
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  6967 always 6967
Line 6974
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  6974 always 6974
  "" always ""
Line 6976
  "class Fred {\n    std::string s;\n    Fred() { a = 0; s = \"foo\"; }\n};" always "class Fred {\n    std::string s;\n    Fred() { a = 0; s = \"foo\"; }\n};"
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  6976 always 6976
Line 6980
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  6980 always 6980
  "[test.cpp:3]: (performance) Variable 's' is assigned in constructor body. Consider performing initialization in initialization list.\n" always "[test.cpp:3]: (performance) Variable 's' is assigned in constructor body. Consider performing initialization in initialization list.\n"
Line 6982
  "class Fred {\n    std::string& s;\n    Fred(const std::string& s_) : s(s_) { s = \"foo\"; }\n};" always "class Fred {\n    std::string& s;\n    Fred(const std::string& s_) : s(s_) { s = \"foo\"; }\n};"
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  6982 always 6982
Line 6986
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  6986 always 6986
  "" always ""
Line 6988
  "class Fred {\n    std::vector<int> v;\n    Fred() { v = unknown; }\n};" always "class Fred {\n    std::vector<int> v;\n    Fred() { v = unknown; }\n};"
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  6988 always 6988
Line 6992
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  6992 always 6992
  "[test.cpp:3]: (performance) Variable 'v' is assigned in constructor body. Consider performing initialization in initialization list.\n" always "[test.cpp:3]: (performance) Variable 'v' is assigned in constructor body. Consider performing initialization in initialization list.\n"
Line 6994
  "class C { std::string s; };\nclass Fred {\n    C c;\n    Fred() { c = unknown; }\n};" always "class C { std::string s; };\nclass Fred {\n    C c;\n    Fred() { c = unknown; }\n};"
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  6994 always 6994
Line 6999
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  6999 always 6999
  "[test.cpp:4]: (performance) Variable 'c' is assigned in constructor body. Consider performing initialization in initialization list.\n" always "[test.cpp:4]: (performance) Variable 'c' is assigned in constructor body. Consider performing initialization in initialization list.\n"
Line 7001
  "class C;\nclass Fred {\n    C c;\n    Fred() { c = unknown; }\n};" always "class C;\nclass Fred {\n    C c;\n    Fred() { c = unknown; }\n};"
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  7001 always 7001
Line 7006
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  7006 always 7006
  "[test.cpp:4]: (performance) Variable 'c' is assigned in constructor body. Consider performing initialization in initialization list.\n" always "[test.cpp:4]: (performance) Variable 'c' is assigned in constructor body. Consider performing initialization in initialization list.\n"
Line 7008
  "class C;\nclass Fred {\n    C c;\n    Fred(Fred const & other) { c = other.c; }\n};" always "class C;\nclass Fred {\n    C c;\n    Fred(Fred const & other) { c = other.c; }\n};"
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  7008 always 7008
Line 7013
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  7013 always 7013
  "[test.cpp:4]: (performance) Variable 'c' is assigned in constructor body. Consider performing initialization in initialization list.\n" always "[test.cpp:4]: (performance) Variable 'c' is assigned in constructor body. Consider performing initialization in initialization list.\n"
Line 7015
  "class C;\nclass Fred {\n    C c;\n    Fred(Fred && other) { c = other.c; }\n};" always "class C;\nclass Fred {\n    C c;\n    Fred(Fred && other) { c = other.c; }\n};"
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  7015 always 7015
Line 7020
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  7020 always 7020
  "[test.cpp:4]: (performance) Variable 'c' is assigned in constructor body. Consider performing initialization in initialization list.\n" always "[test.cpp:4]: (performance) Variable 'c' is assigned in constructor body. Consider performing initialization in initialization list.\n"
Line 7022
  "class C;\nclass Fred {\n    C a;\n    Fred() { initB(); a = b; }\n};" always "class C;\nclass Fred {\n    C a;\n    Fred() { initB(); a = b; }\n};"
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  7022 always 7022
Line 7027
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  7027 always 7027
  "" always ""
Line 7029
  "class C;\nclass Fred {\n    C a;\n    Fred() : a(0) { if(b) a = 0; }\n};" always "class C;\nclass Fred {\n    C a;\n    Fred() : a(0) { if(b) a = 0; }\n};"
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  7029 always 7029
Line 7034
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  7034 always 7034
  "" always ""
Line 7036
  "class C;\nclass Fred {\n    C a[5];\n    Fred() { for(int i = 0; i < 5; i++) a[i] = 0; }\n};" always "class C;\nclass Fred {\n    C a[5];\n    Fred() { for(int i = 0; i < 5; i++) a[i] = 0; }\n};"
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  7036 always 7036
Line 7041
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  7041 always 7041
  "" always ""
Line 7043
  "class C;\nclass Fred {\n    C a; int b;\n    Fred() : b(5) { a = b; }\n};" always "class C;\nclass Fred {\n    C a; int b;\n    Fred() : b(5) { a = b; }\n};"
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  7043 always 7043
Line 7048
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  7048 always 7048
  "" always ""
Line 7050
  "class C;\nclass Fred {\n    C a;\n    Fred() { try { a = new int; } catch(...) {} }\n};" always "class C;\nclass Fred {\n    C a;\n    Fred() { try { a = new int; } catch(...) {} }\n};"
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  7050 always 7050
Line 7055
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  7055 always 7055
  "" always ""
Line 7057
  "class Fred {\n    std::string s;\n    Fred() { s = toString((size_t)this); }\n};" always "class Fred {\n    std::string s;\n    Fred() { s = toString((size_t)this); }\n};"
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  7057 always 7057
Line 7061
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  7061 always 7061
  "" always ""
Line 7063
  "class Fred {\n    std::string a;\n    std::string foo();\n    Fred() { a = foo(); }\n};" always "class Fred {\n    std::string a;\n    std::string foo();\n    Fred() { a = foo(); }\n};"
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  7063 always 7063
Line 7068
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  7068 always 7068
  "" always ""
Line 7070
  "class Fred {\n    std::string a;\n    Fred() { a = foo(); }\n};" always "class Fred {\n    std::string a;\n    Fred() { a = foo(); }\n};"
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  7070 always 7070
Line 7074
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  7074 always 7074
  "[test.cpp:3]: (performance) Variable 'a' is assigned in constructor body. Consider performing initialization in initialization list.\n" always "[test.cpp:3]: (performance) Variable 'a' is assigned in constructor body. Consider performing initialization in initialization list.\n"
Line 7076
  "class Fred {\n    static std::string s;\n    Fred() { s = \"foo\"; }\n};" always "class Fred {\n    static std::string s;\n    Fred() { s = \"foo\"; }\n};"
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  7076 always 7076
Line 7080
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  7080 always 7080
  "" always ""
Line 7082
  "class Fred {\n    std::string s;\n    Fred() {\n        char str[2];\n        str[0] = c;\n        str[1] = 0;\n        s = str;\n    }\n};" always "class Fred {\n    std::string s;\n    Fred() {\n        char str[2];\n        str[0] = c;\n        str[1] = 0;\n        s = str;\n    }\n};"
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  7082 always 7082
Line 7091
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  7091 always 7091
  "" always ""
Line 7093
  "class B {\n    std::shared_ptr<A> _d;\n    B(const B& other) : _d(std::make_shared<A>()) {\n        *_d = *other._d;\n    }\n};" always "class B {\n    std::shared_ptr<A> _d;\n    B(const B& other) : _d(std::make_shared<A>()) {\n        *_d = *other._d;\n    }\n};"
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  7093 always 7093
Line 7099
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  7099 always 7099
  "" always ""
Line 7101
  "class Bar {\npublic:\n    explicit Bar(const Bar &bar) : Bar{bar.s} {}\n    explicit Bar(const char s) : s{s} {}\nprivate:\n    char s;\n};" always "class Bar {\npublic:\n    explicit Bar(const Bar &bar) : Bar{bar.s} {}\n    explicit Bar(const char s) : s{s} {}\nprivate:\n    char s;\n};"
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  7101 always 7101
Line 7108
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  7108 always 7108
  "" always ""
Line 7110
  "unsigned bar(std::string);\nclass Foo {\npublic:\n    int a_, b_;\n    Foo(int a, int b) : a_(a), b_(b) {}\n    Foo(int a, const std::string& b) : Foo(a, bar(b)) {}\n};" always "unsigned bar(std::string);\nclass Foo {\npublic:\n    int a_, b_;\n    Foo(int a, int b) : a_(a), b_(b) {}\n    Foo(int a, const std::string& b) : Foo(a, bar(b)) {}\n};"
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  7110 always 7110
Line 7117
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  7117 always 7117
  "" always ""
Line 7119
  "class Fred {\n    std::string a;\n    Fred() {\n        std::ostringstream ostr;\n        ostr << x;\n        a = ostr.str();\n    }\n};" always "class Fred {\n    std::string a;\n    Fred() {\n        std::ostringstream ostr;\n        ostr << x;\n        a = ostr.str();\n    }\n};"
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  7119 always 7119
Line 7127
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  7127 always 7127
  "" always ""
Line 7130
  "class Fred {\n    std::function f;\n    Fred() {\n        f = [](){\n            return 1;\n        };\n    }\n};" always "class Fred {\n    std::function f;\n    Fred() {\n        f = [](){\n            return 1;\n        };\n    }\n};"
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  7130 always 7130
Line 7138
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  7138 always 7138
  "" always ""
Line 7141
  "class C {\npublic:\n    C(C& c) : m_i(c.m_i) { c.m_i = (Foo)-1; }\nprivate:\n    Foo m_i;\n};" always "class C {\npublic:\n    C(C& c) : m_i(c.m_i) { c.m_i = (Foo)-1; }\nprivate:\n    Foo m_i;\n};"
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  7141 always 7141
Line 7147
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  7147 always 7147
  "" always ""
Line 7149
  "class A {\npublic:\n    A() : st{} {}\n\n    explicit A(const std::string &input): A() {\n        st = input;\n    }\n\nprivate:\n    std::string st;\n};" always "class A {\npublic:\n    A() : st{} {}\n\n    explicit A(const std::string &input): A() {\n        st = input;\n    }\n\nprivate:\n    std::string st;\n};"
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  7149 always 7149
Line 7160
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  7160 always 7160
  "" always ""
Line 7167
  "" always ""
Line 7170
  & {lifetime[Address]=(settings0),!0}
  this always !0
Line 7171
  code possible {"class Fred {\n    int i;\n    Fred() : i(i) {\n    }\n};"@71,"class Fred {\n    int i;\n    Fred() : i{i} {\n    }\n};"@72,"class Fred {\n    int i;\n    Fred();\n};\nFred::Fred() : i(i) {\n}"@73,"class A {\npublic:\n    explicit A(int x) : _x(static_cast<int>(_x)) {}\nprivate:\n    int _x;\n};\n"@74,"class A {\npublic:\n    explicit A(int x) : _x((int)(_x)) {}\nprivate:\n    int _x;\n};\n"@75,"class Fred {\n    std::string s;\n    Fred() : s(s) {\n    }\n};"@76,"class Fred {\n    int x;\n    Fred(int x);\n};\nFred::Fred(int x) : x(x) { }"@77,"class Fred {\n    int x;\n    Fred(int x);\n};\nFred::Fred(int x) : x{x} { }"@78,"class Fred {\n    std::string s;\n    Fred(const std::string& s) : s(s) {\n    }\n};"@79,"class Fred {\n    std::string s;\n    Fred(const std::string& s) : s{s} {\n    }\n};"@80}
Line 7172
  ( always {!<=-1,!>=2}
  file inconclusive {"cppcheck-2.8/test/testclass.cpp"@71,"cppcheck-2.8/test/testclass.cpp"@72,"cppcheck-2.8/test/testclass.cpp"@73,"cppcheck-2.8/test/testclass.cpp"@74,"cppcheck-2.8/test/testclass.cpp"@75,"cppcheck-2.8/test/testclass.cpp"@76,"cppcheck-2.8/test/testclass.cpp"@77,"cppcheck-2.8/test/testclass.cpp"@78,"cppcheck-2.8/test/testclass.cpp"@79,"cppcheck-2.8/test/testclass.cpp"@80}
  line inconclusive {7179@71,7186@72,7193@73,7201@74,7209@75,7217@76,7224@77,7231@78,7238@79,7245@80}
  "test.cpp" always "test.cpp"
Line 7174
  & {lifetime[Address]=(tokenizer),!0}
  & {lifetime[Address]=(settings0),!0}
  this always !0
Line 7179
  "class Fred {\n    int i;\n    Fred() : i(i) {\n    }\n};" always "class Fred {\n    int i;\n    Fred() : i(i) {\n    }\n};"
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  7179 always 7179
Line 7184
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  7184 always 7184
  "[test.cpp:3]: (error) Member variable 'i' is initialized by itself.\n" always "[test.cpp:3]: (error) Member variable 'i' is initialized by itself.\n"
Line 7186
  "class Fred {\n    int i;\n    Fred() : i{i} {\n    }\n};" always "class Fred {\n    int i;\n    Fred() : i{i} {\n    }\n};"
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  7186 always 7186
Line 7191
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  7191 always 7191
  "[test.cpp:3]: (error) Member variable 'i' is initialized by itself.\n" always "[test.cpp:3]: (error) Member variable 'i' is initialized by itself.\n"
Line 7193
  "class Fred {\n    int i;\n    Fred();\n};\nFred::Fred() : i(i) {\n}" always "class Fred {\n    int i;\n    Fred();\n};\nFred::Fred() : i(i) {\n}"
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  7193 always 7193
Line 7199
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  7199 always 7199
  "[test.cpp:5]: (error) Member variable 'i' is initialized by itself.\n" always "[test.cpp:5]: (error) Member variable 'i' is initialized by itself.\n"
Line 7201
  "class A {\npublic:\n    explicit A(int x) : _x(static_cast<int>(_x)) {}\nprivate:\n    int _x;\n};\n" always "class A {\npublic:\n    explicit A(int x) : _x(static_cast<int>(_x)) {}\nprivate:\n    int _x;\n};\n"
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  7201 always 7201
Line 7207
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  7207 always 7207
  "[test.cpp:3]: (error) Member variable '_x' is initialized by itself.\n" always "[test.cpp:3]: (error) Member variable '_x' is initialized by itself.\n"
Line 7209
  "class A {\npublic:\n    explicit A(int x) : _x((int)(_x)) {}\nprivate:\n    int _x;\n};\n" always "class A {\npublic:\n    explicit A(int x) : _x((int)(_x)) {}\nprivate:\n    int _x;\n};\n"
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  7209 always 7209
Line 7215
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  7215 always 7215
  "[test.cpp:3]: (error) Member variable '_x' is initialized by itself.\n" always "[test.cpp:3]: (error) Member variable '_x' is initialized by itself.\n"
Line 7217
  "class Fred {\n    std::string s;\n    Fred() : s(s) {\n    }\n};" always "class Fred {\n    std::string s;\n    Fred() : s(s) {\n    }\n};"
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  7217 always 7217
Line 7222
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  7222 always 7222
  "[test.cpp:3]: (error) Member variable 's' is initialized by itself.\n" always "[test.cpp:3]: (error) Member variable 's' is initialized by itself.\n"
Line 7224
  "class Fred {\n    int x;\n    Fred(int x);\n};\nFred::Fred(int x) : x(x) { }" always "class Fred {\n    int x;\n    Fred(int x);\n};\nFred::Fred(int x) : x(x) { }"
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  7224 always 7224
Line 7229
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  7229 always 7229
  "" always ""
Line 7231
  "class Fred {\n    int x;\n    Fred(int x);\n};\nFred::Fred(int x) : x{x} { }" always "class Fred {\n    int x;\n    Fred(int x);\n};\nFred::Fred(int x) : x{x} { }"
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  7231 always 7231
Line 7236
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  7236 always 7236
  "" always ""
Line 7238
  "class Fred {\n    std::string s;\n    Fred(const std::string& s) : s(s) {\n    }\n};" always "class Fred {\n    std::string s;\n    Fred(const std::string& s) : s(s) {\n    }\n};"
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  7238 always 7238
Line 7243
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  7243 always 7243
  "" always ""
Line 7245
  "class Fred {\n    std::string s;\n    Fred(const std::string& s) : s{s} {\n    }\n};" always "class Fred {\n    std::string s;\n    Fred(const std::string& s) : s{s} {\n    }\n};"
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  7245 always 7245
Line 7250
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  7250 always 7250
  "" always ""
Line 7252
  "struct Foo : Bar {\n    int i;\n    Foo(int i)\n        : Bar(\"\"), i(i) {}\n};" always "struct Foo : Bar {\n    int i;\n    Foo(int i)\n        : Bar(\"\"), i(i) {}\n};"
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  7252 always 7252
Line 7257
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  7257 always 7257
  "" always ""
Line 7259
  "struct Foo : std::Bar {\n    int i;\n    Foo(int i)\n        : std::Bar(\"\"), i(i) {}\n};" always "struct Foo : std::Bar {\n    int i;\n    Foo(int i)\n        : std::Bar(\"\"), i(i) {}\n};"
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  7259 always 7259
Line 7264
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  7264 always 7264
  "" always ""
Line 7266
  "struct Foo : std::Bar {\n    int i;\n    Foo(int i)\n        : std::Bar(\"\"), i{i} {}\n};" always "struct Foo : std::Bar {\n    int i;\n    Foo(int i)\n        : std::Bar(\"\"), i{i} {}\n};"
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  7266 always 7266
Line 7271
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  7271 always 7271
  "" always ""
Line 7276
  , always 0
  = always 0
  nullptr always 0
  , always 1
  inconclusive always {!<=-1,!>=2}
  = always 1
  true always 1
Line 7278
  "" always ""
Line 7281
  ! always {!<=-1,!>=2}
Line 7283
  = {&,lifetime[Address]=(settings_),!0}
  & {&,lifetime[Address]=(settings_),!0}
Line 7284
  s {lifetime[Address]=(settings_),symbolic=(&settings_),&,!0}
Line 7286
  s possible {lifetime[Address]=(settings_),&}
  inconclusive always {!<=-1,!>=2}
Line 7289
  s possible {lifetime[Address]=(settings_),&}
  this always !0
Line 7290
  code inconclusive {"class A\n {\n    virtual void pure()=0;\n    void nonpure(bool bCallPure)\n    { if (bCallPure) pure();}\n    A();\n};\nA::A()\n{nonpure(false);}"@41,"class A\n {\n    virtual void pure()=0;\n    void nonpure(bool bCallPure)\n    { if (!bCallPure) ; else pure();}\n    A();\n};\nA::A()\n{nonpure(false);}"@42,"class A\n {\n    virtual void pure()=0;\n    void nonpure(bool bCallPure)\n    {\n        switch (bCallPure) {\n        case true: pure(); break;\n        }\n    }\n    A();\n};\nA::A()\n{nonpure(false);}"@43,"class A\n{\n    virtual void pureWithBody()=0;\n    A();\n};\nA::A()\n{pureWithBody();}\nvoid A::pureWithBody()\n{}"@44,"class A\n {\n    virtual void pureWithBody()=0;\n    void nonpure()\n    {pureWithBody();}\n    A();\n};\nA::A()\n{nonpure();}\nvoid A::pureWithBody()\n{}"@45,"class A\n{\n    virtual void pure()=0;\n    A(const A & a);\n};\nA::A(const A & a)\n{a.pure();}"@46,"class A\n{\n    virtual void pure()=0;\n    A();\n};\nclass B\n{\n    virtual void pure()=0;\n};\nA::A()\n{B b; b.pure();}"@47,"class A\n{\n    virtual void pure()=0;\n    A();\n};\nA::A()\n{pure();}"@48,"class A\n{\n    virtual int pure()=0;\n    A();\n    int m;\n};\nA::A():m(A::pure())\n{}"@49,"namespace N {\n  class A\n  {\n      virtual int pure() = 0;\n      A();\n      int m;\n  };\n}\nN::A::A() : m(N::A::pure()) {}\n"@50}
Line 7291
  ( always {!<=-1,!>=2}
  file inconclusive {"cppcheck-2.8/test/testclass.cpp"@41,"cppcheck-2.8/test/testclass.cpp"@42,"cppcheck-2.8/test/testclass.cpp"@43,"cppcheck-2.8/test/testclass.cpp"@44,"cppcheck-2.8/test/testclass.cpp"@45,"cppcheck-2.8/test/testclass.cpp"@46,"cppcheck-2.8/test/testclass.cpp"@47,"cppcheck-2.8/test/testclass.cpp"@48,"cppcheck-2.8/test/testclass.cpp"@49,"cppcheck-2.8/test/testclass.cpp"@50}
  line inconclusive {7573@41,7584@42,7595@43,7546@44,7557@45,7522@46,7531@47,7407@48,7416@49,7426@50}
  "test.cpp" always "test.cpp"
Line 7293
  & {lifetime[Address]=(tokenizer),!0}
  s inconclusive {lifetime[Address]=(settings_),&}
  this always !0
Line 7298
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  7298 always 7298
  "class A\n{\n    virtual int f() { return 1; }\n    A();\n};\nA::A()\n{f();}" always "class A\n{\n    virtual int f() { return 1; }\n    A();\n};\nA::A()\n{f();}"
Line 7305
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  7305 always 7305
  "[test.cpp:7] -> [test.cpp:3]: (style) Virtual function 'f' is called from constructor 'A()' at line 7. Dynamic binding is not used.\n" always "[test.cpp:7] -> [test.cpp:3]: (style) Virtual function 'f' is called from constructor 'A()' at line 7. Dynamic binding is not used.\n"
Line 7307
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  7307 always 7307
  "class A {\n    virtual int f();\n    A() {f();}\n};\nint A::f() { return 1; }" always "class A {\n    virtual int f();\n    A() {f();}\n};\nint A::f() { return 1; }"
Line 7312
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  7312 always 7312
  "[test.cpp:3] -> [test.cpp:2]: (style) Virtual function 'f' is called from constructor 'A()' at line 3. Dynamic binding is not used.\n" always "[test.cpp:3] -> [test.cpp:2]: (style) Virtual function 'f' is called from constructor 'A()' at line 3. Dynamic binding is not used.\n"
Line 7314
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  7314 always 7314
  "class A : B {\n    int f() override;\n    A() {f();}\n};\nint A::f() { return 1; }" always "class A : B {\n    int f() override;\n    A() {f();}\n};\nint A::f() { return 1; }"
Line 7319
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  7319 always 7319
  "[test.cpp:3] -> [test.cpp:2]: (style) Virtual function 'f' is called from constructor 'A()' at line 3. Dynamic binding is not used.\n" always "[test.cpp:3] -> [test.cpp:2]: (style) Virtual function 'f' is called from constructor 'A()' at line 3. Dynamic binding is not used.\n"
Line 7321
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  7321 always 7321
  "class B {\n    virtual int f() = 0;\n};\nclass A : B {\n    int f();\n    A() {f();}\n};\nint A::f() { return 1; }" always "class B {\n    virtual int f() = 0;\n};\nclass A : B {\n    int f();\n    A() {f();}\n};\nint A::f() { return 1; }"
Line 7329
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  7329 always 7329
  "" always ""
Line 7331
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  7331 always 7331
  "class A\n{\n    A() { A::f(); }\n    virtual void f() {}\n};" always "class A\n{\n    A() { A::f(); }\n    virtual void f() {}\n};"
Line 7336
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  7336 always 7336
  "" always ""
Line 7338
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  7338 always 7338
  "class A : B {\n    int f() final { return 1; }\n    A() { f(); }\n};\n" always "class A : B {\n    int f() final { return 1; }\n    A() { f(); }\n};\n"
Line 7342
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  7342 always 7342
  "" always ""
Line 7344
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  7344 always 7344
  "class B {\npublic:    virtual void f() {}\n};\nclass A : B {\npublic:    void f() override final {}\n    A() { f(); }\n};\n" always "class B {\npublic:    virtual void f() {}\n};\nclass A : B {\npublic:    void f() override final {}\n    A() { f(); }\n};\n"
Line 7353
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  7353 always 7353
  "" always ""
Line 7355
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  7355 always 7355
  "class Base {\npublic:\n    virtual void Copy(const Base& Src) = 0;\n};\nclass Derived : public Base {\npublic:\n    Derived() : i(0) {}\n    Derived(const Derived& Src);\n    void Copy(const Base& Src) override;\n    int i;\n};\nDerived::Derived(const Derived& Src) {\n    Copy(Src);\n}\nvoid Derived::Copy(const Base& Src) {\n    auto d = dynamic_cast<const Derived&>(Src);\n    i = d.i;\n}\n" always "class Base {\npublic:\n    virtual void Copy(const Base& Src) = 0;\n};\nclass Derived : public Base {\npublic:\n    Derived() : i(0) {}\n    Derived(const Derived& Src);\n    void Copy(const Base& Src) override;\n    int i;\n};\nDerived::Derived(const Derived& Src) {\n    Copy(Src);\n}\nvoid Derived::Copy(const Base& Src) {\n    auto d = dynamic_cast<const Derived&>(Src);\n    i = d.i;\n}\n"
Line 7373
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  7373 always 7373
  "[test.cpp:13] -> [test.cpp:9]: (style) Virtual function 'Copy' is called from copy constructor 'Derived(const Derived&Src)' at line 13. Dynamic binding is not used.\n" always "[test.cpp:13] -> [test.cpp:9]: (style) Virtual function 'Copy' is called from copy constructor 'Derived(const Derived&Src)' at line 13. Dynamic binding is not used.\n"
Line 7376
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  7376 always 7376
  "struct B {\n    B() { auto pf = &f; }\n    virtual void f() {}\n};\n" always "struct B {\n    B() { auto pf = &f; }\n    virtual void f() {}\n};\n"
Line 7380
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  7380 always 7380
  "" always ""
Line 7382
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  7382 always 7382
  "struct B {\n    B() { auto pf = &B::f; }\n    virtual void f() {}\n};\n" always "struct B {\n    B() { auto pf = &B::f; }\n    virtual void f() {}\n};\n"
Line 7386
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  7386 always 7386
  "" always ""
Line 7388
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  7388 always 7388
  "struct B {\n    B() { (f)(); }\n    virtual void f() {}\n};\n" always "struct B {\n    B() { (f)(); }\n    virtual void f() {}\n};\n"
Line 7392
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  7392 always 7392
  "[test.cpp:2] -> [test.cpp:3]: (style) Virtual function 'f' is called from constructor 'B()' at line 2. Dynamic binding is not used.\n" always "[test.cpp:2] -> [test.cpp:3]: (style) Virtual function 'f' is called from constructor 'B()' at line 2. Dynamic binding is not used.\n"
Line 7394
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  7394 always 7394
  "class S {\n    ~S();\npublic:\n    S();\n};\nS::S() {\n    typeid(S);\n}\nS::~S() = default;\n" always "class S {\n    ~S();\npublic:\n    S();\n};\nS::S() {\n    typeid(S);\n}\nS::~S() = default;\n"
Line 7403
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  7403 always 7403
  "" always ""
Line 7407
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  7407 always 7407
  "class A\n{\n    virtual void pure()=0;\n    A();\n};\nA::A()\n{pure();}" always "class A\n{\n    virtual void pure()=0;\n    A();\n};\nA::A()\n{pure();}"
Line 7414
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  7414 always 7414
  "[test.cpp:7] -> [test.cpp:3]: (warning) Call of pure virtual function 'pure' in constructor.\n" always "[test.cpp:7] -> [test.cpp:3]: (warning) Call of pure virtual function 'pure' in constructor.\n"
Line 7416
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  7416 always 7416
  "class A\n{\n    virtual int pure()=0;\n    A();\n    int m;\n};\nA::A():m(A::pure())\n{}" always "class A\n{\n    virtual int pure()=0;\n    A();\n    int m;\n};\nA::A():m(A::pure())\n{}"
Line 7424
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  7424 always 7424
  "[test.cpp:7] -> [test.cpp:3]: (warning) Call of pure virtual function 'pure' in constructor.\n" always "[test.cpp:7] -> [test.cpp:3]: (warning) Call of pure virtual function 'pure' in constructor.\n"
Line 7426
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  7426 always 7426
  "namespace N {\n  class A\n  {\n      virtual int pure() = 0;\n      A();\n      int m;\n  };\n}\nN::A::A() : m(N::A::pure()) {}\n" always "namespace N {\n  class A\n  {\n      virtual int pure() = 0;\n      A();\n      int m;\n  };\n}\nN::A::A() : m(N::A::pure()) {}\n"
Line 7435
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  7435 always 7435
  "[test.cpp:9] -> [test.cpp:4]: (warning) Call of pure virtual function 'pure' in constructor.\n" always "[test.cpp:9] -> [test.cpp:4]: (warning) Call of pure virtual function 'pure' in constructor.\n"
Line 7437
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  7437 always 7437
  "class A\n {\n    virtual void pure()=0;\n    virtual ~A();\n    int m;\n};\nA::~A()\n{pure();}" always "class A\n {\n    virtual void pure()=0;\n    virtual ~A();\n    int m;\n};\nA::~A()\n{pure();}"
Line 7445
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  7445 always 7445
  "[test.cpp:8] -> [test.cpp:3]: (warning) Call of pure virtual function 'pure' in destructor.\n" always "[test.cpp:8] -> [test.cpp:3]: (warning) Call of pure virtual function 'pure' in destructor.\n"
Line 7447
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  7447 always 7447
  "class A\n {\n    virtual void pure()=0;\n    void nonpure()\n    {pure();}\n    A();\n};\nA::A()\n{nonpure();}" always "class A\n {\n    virtual void pure()=0;\n    void nonpure()\n    {pure();}\n    A();\n};\nA::A()\n{nonpure();}"
Line 7456
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  7456 always 7456
  "[test.cpp:9] -> [test.cpp:5] -> [test.cpp:3]: (warning) Call of pure virtual function 'pure' in constructor.\n" always "[test.cpp:9] -> [test.cpp:5] -> [test.cpp:3]: (warning) Call of pure virtual function 'pure' in constructor.\n"
Line 7458
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  7458 always 7458
  "class A\n {\n    virtual int pure()=0;\n    int nonpure()\n    {return pure();}\n    A();\n    int m;\n};\nA::A():m(nonpure())\n{}" always "class A\n {\n    virtual int pure()=0;\n    int nonpure()\n    {return pure();}\n    A();\n    int m;\n};\nA::A():m(nonpure())\n{}"
Line 7468
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  7468 always 7468
  "[test.cpp:9] -> [test.cpp:5] -> [test.cpp:3]: (warning) Call of pure virtual function 'pure' in constructor.\n" always "[test.cpp:9] -> [test.cpp:5] -> [test.cpp:3]: (warning) Call of pure virtual function 'pure' in constructor.\n"
  "" always ""
Line 7470
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  7470 always 7470
  "class A\n {\n    virtual void pure()=0;\n    void nonpure()\n    {pure();}\n    virtual ~A();\n    int m;\n};\nA::~A()\n{nonpure();}" always "class A\n {\n    virtual void pure()=0;\n    void nonpure()\n    {pure();}\n    virtual ~A();\n    int m;\n};\nA::~A()\n{nonpure();}"
Line 7480
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  7480 always 7480
  "[test.cpp:10] -> [test.cpp:5] -> [test.cpp:3]: (warning) Call of pure virtual function 'pure' in destructor.\n" always "[test.cpp:10] -> [test.cpp:5] -> [test.cpp:3]: (warning) Call of pure virtual function 'pure' in destructor.\n"
Line 7482
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  7482 always 7482
  "class A\n{\n    virtual void pure()=0;\n    A(bool b);\n};\nA::A(bool b)\n{if (b) pure();}" always "class A\n{\n    virtual void pure()=0;\n    A(bool b);\n};\nA::A(bool b)\n{if (b) pure();}"
Line 7489
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  7489 always 7489
  "[test.cpp:7] -> [test.cpp:3]: (warning) Call of pure virtual function 'pure' in constructor.\n" always "[test.cpp:7] -> [test.cpp:3]: (warning) Call of pure virtual function 'pure' in constructor.\n"
Line 7491
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  7491 always 7491
  "class A\n{\n    virtual void pure()=0;\n    virtual ~A();\n    int m;\n};\nA::~A()\n{if (b) pure();}" always "class A\n{\n    virtual void pure()=0;\n    virtual ~A();\n    int m;\n};\nA::~A()\n{if (b) pure();}"
Line 7499
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  7499 always 7499
  "[test.cpp:8] -> [test.cpp:3]: (warning) Call of pure virtual function 'pure' in destructor.\n" always "[test.cpp:8] -> [test.cpp:3]: (warning) Call of pure virtual function 'pure' in destructor.\n"
Line 7502
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  7502 always 7502
  "class abc {\npublic:\n  virtual ~abc() throw() {}\n  virtual void def(void* g) throw () = 0;\n};" always "class abc {\npublic:\n  virtual ~abc() throw() {}\n  virtual void def(void* g) throw () = 0;\n};"
Line 7507
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  7507 always 7507
  "" always ""
Line 7510
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  7510 always 7510
  "class CMyClass {\n    std::function< void(void) > m_callback;\npublic:\n    CMyClass() {\n        m_callback = [this]() { return VirtualMethod(); };\n    }\n    virtual void VirtualMethod() = 0;\n};" always "class CMyClass {\n    std::function< void(void) > m_callback;\npublic:\n    CMyClass() {\n        m_callback = [this]() { return VirtualMethod(); };\n    }\n    virtual void VirtualMethod() = 0;\n};"
Line 7518
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  7518 always 7518
  "" always ""
Line 7522
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  7522 always 7522
  "class A\n{\n    virtual void pure()=0;\n    A(const A & a);\n};\nA::A(const A & a)\n{a.pure();}" always "class A\n{\n    virtual void pure()=0;\n    A(const A & a);\n};\nA::A(const A & a)\n{a.pure();}"
Line 7529
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  7529 always 7529
  "" always ""
Line 7531
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  7531 always 7531
  "class A\n{\n    virtual void pure()=0;\n    A();\n};\nclass B\n{\n    virtual void pure()=0;\n};\nA::A()\n{B b; b.pure();}" always "class A\n{\n    virtual void pure()=0;\n    A();\n};\nclass B\n{\n    virtual void pure()=0;\n};\nA::A()\n{B b; b.pure();}"
Line 7542
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  7542 always 7542
  "" always ""
Line 7546
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  7546 always 7546
  "class A\n{\n    virtual void pureWithBody()=0;\n    A();\n};\nA::A()\n{pureWithBody();}\nvoid A::pureWithBody()\n{}" always "class A\n{\n    virtual void pureWithBody()=0;\n    A();\n};\nA::A()\n{pureWithBody();}\nvoid A::pureWithBody()\n{}"
Line 7555
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  7555 always 7555
  "" always ""
Line 7557
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  7557 always 7557
  "class A\n {\n    virtual void pureWithBody()=0;\n    void nonpure()\n    {pureWithBody();}\n    A();\n};\nA::A()\n{nonpure();}\nvoid A::pureWithBody()\n{}" always "class A\n {\n    virtual void pureWithBody()=0;\n    void nonpure()\n    {pureWithBody();}\n    A();\n};\nA::A()\n{nonpure();}\nvoid A::pureWithBody()\n{}"
Line 7568
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  7568 always 7568
  "" always ""
Line 7573
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  7573 always 7573
  "class A\n {\n    virtual void pure()=0;\n    void nonpure(bool bCallPure)\n    { if (bCallPure) pure();}\n    A();\n};\nA::A()\n{nonpure(false);}" always "class A\n {\n    virtual void pure()=0;\n    void nonpure(bool bCallPure)\n    { if (bCallPure) pure();}\n    A();\n};\nA::A()\n{nonpure(false);}"
Line 7582
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  7582 always 7582
  "" always ""
Line 7584
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  7584 always 7584
  "class A\n {\n    virtual void pure()=0;\n    void nonpure(bool bCallPure)\n    { if (!bCallPure) ; else pure();}\n    A();\n};\nA::A()\n{nonpure(false);}" always "class A\n {\n    virtual void pure()=0;\n    void nonpure(bool bCallPure)\n    { if (!bCallPure) ; else pure();}\n    A();\n};\nA::A()\n{nonpure(false);}"
Line 7593
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  7593 always 7593
  "" always ""
Line 7595
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  7595 always 7595
  "class A\n {\n    virtual void pure()=0;\n    void nonpure(bool bCallPure)\n    {\n        switch (bCallPure) {\n        case true: pure(); break;\n        }\n    }\n    A();\n};\nA::A()\n{nonpure(false);}" always "class A\n {\n    virtual void pure()=0;\n    void nonpure(bool bCallPure)\n    {\n        switch (bCallPure) {\n        case true: pure(); break;\n        }\n    }\n    A();\n};\nA::A()\n{nonpure(false);}"
Line 7608
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  7608 always 7608
  "" always ""
Line 7615
  "" always ""
Line 7620
  & {lifetime[Address]=(settings),!0}
  this always !0
Line 7621
  code possible {"class Base { virtual void f(); };\nclass Derived : Base { void f() const; }"@20,"class Base { virtual void f(); };\nclass Derived : Base { void f() volatile; }"@21,"class Base { virtual void f(); };\nclass Derived : Base { void f() &; }"@22,"class Base { virtual void f(); };\nclass Derived : Base { void f() &&; }"@23,"class Base { virtual void f(); };\nclass Derived : Base { virtual void f(); };"@24,"class Base { virtual void f(); };\nclass Derived : Base { virtual void f() override; };"@25,"class Base { virtual void f(); };\nclass Derived : Base { virtual void f() final; };"@26,"class Base {\npublic:\n    virtual auto foo( ) const -> size_t { return 1; }\n    virtual auto bar( ) const -> size_t { return 1; }\n};\nclass Derived : public Base {\npublic :\n    auto foo( ) const -> size_t { return 0; }\n    auto bar( ) const -> size_t override { return 0; }\n};"@27,"namespace Test {\n    class C {\n    public:\n        virtual ~C();\n    };\n}\nclass C : Test::C {\npublic:\n    ~C();\n};"@28,"struct Base {\n    virtual void foo();\n};\n\nstruct Derived: public Base {\n   void foo() override;\n   void foo(int);\n};"@29}
Line 7622
  ( always {!<=-1,!>=2}
  file inconclusive {"cppcheck-2.8/test/testclass.cpp"@20,"cppcheck-2.8/test/testclass.cpp"@21,"cppcheck-2.8/test/testclass.cpp"@22,"cppcheck-2.8/test/testclass.cpp"@23,"cppcheck-2.8/test/testclass.cpp"@24,"cppcheck-2.8/test/testclass.cpp"@25,"cppcheck-2.8/test/testclass.cpp"@26,"cppcheck-2.8/test/testclass.cpp"@27,"cppcheck-2.8/test/testclass.cpp"@28,"cppcheck-2.8/test/testclass.cpp"@29}
  line inconclusive {7769@20,7773@21,7777@22,7781@23,7630@24,7634@25,7638@26,7642@27,7654@28,7666@29}
  "test.cpp" always "test.cpp"
Line 7625
  & {lifetime[Address]=(tokenizer),!0}
  & {lifetime[Address]=(settings),!0}
  this always !0
Line 7630
  "class Base { virtual void f(); };\nclass Derived : Base { virtual void f(); };" always "class Base { virtual void f(); };\nclass Derived : Base { virtual void f(); };"
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  7630 always 7630
Line 7632
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  7632 always 7632
  "[test.cpp:1] -> [test.cpp:2]: (style) The function 'f' overrides a function in a base class but is not marked with a 'override' specifier.\n" always "[test.cpp:1] -> [test.cpp:2]: (style) The function 'f' overrides a function in a base class but is not marked with a 'override' specifier.\n"
Line 7634
  "class Base { virtual void f(); };\nclass Derived : Base { virtual void f() override; };" always "class Base { virtual void f(); };\nclass Derived : Base { virtual void f() override; };"
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  7634 always 7634
Line 7636
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  7636 always 7636
  "" always ""
Line 7638
  "class Base { virtual void f(); };\nclass Derived : Base { virtual void f() final; };" always "class Base { virtual void f(); };\nclass Derived : Base { virtual void f() final; };"
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  7638 always 7638
Line 7640
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  7640 always 7640
  "" always ""
Line 7642
  "class Base {\npublic:\n    virtual auto foo( ) const -> size_t { return 1; }\n    virtual auto bar( ) const -> size_t { return 1; }\n};\nclass Derived : public Base {\npublic :\n    auto foo( ) const -> size_t { return 0; }\n    auto bar( ) const -> size_t override { return 0; }\n};" always "class Base {\npublic:\n    virtual auto foo( ) const -> size_t { return 1; }\n    virtual auto bar( ) const -> size_t { return 1; }\n};\nclass Derived : public Base {\npublic :\n    auto foo( ) const -> size_t { return 0; }\n    auto bar( ) const -> size_t override { return 0; }\n};"
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  7642 always 7642
Line 7652
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  7652 always 7652
  "[test.cpp:3] -> [test.cpp:8]: (style) The function 'foo' overrides a function in a base class but is not marked with a 'override' specifier.\n" always "[test.cpp:3] -> [test.cpp:8]: (style) The function 'foo' overrides a function in a base class but is not marked with a 'override' specifier.\n"
Line 7654
  "namespace Test {\n    class C {\n    public:\n        virtual ~C();\n    };\n}\nclass C : Test::C {\npublic:\n    ~C();\n};" always "namespace Test {\n    class C {\n    public:\n        virtual ~C();\n    };\n}\nclass C : Test::C {\npublic:\n    ~C();\n};"
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  7654 always 7654
Line 7664
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  7664 always 7664
  "[test.cpp:4] -> [test.cpp:9]: (style) The destructor '~C' overrides a destructor in a base class but is not marked with a 'override' specifier.\n" always "[test.cpp:4] -> [test.cpp:9]: (style) The destructor '~C' overrides a destructor in a base class but is not marked with a 'override' specifier.\n"
Line 7666
  "struct Base {\n    virtual void foo();\n};\n\nstruct Derived: public Base {\n   void foo() override;\n   void foo(int);\n};" always "struct Base {\n    virtual void foo();\n};\n\nstruct Derived: public Base {\n   void foo() override;\n   void foo(int);\n};"
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  7666 always 7666
Line 7674
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  7674 always 7674
  "" always ""
Line 7676
  "struct B {\n    virtual int f(int i) const = 0;\n};\nnamespace N {\n    struct D : B {\n        virtual int f(int i) const;\n    };\n}\n" always "struct B {\n    virtual int f(int i) const = 0;\n};\nnamespace N {\n    struct D : B {\n        virtual int f(int i) const;\n    };\n}\n"
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  7676 always 7676
Line 7684
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  7684 always 7684
  "[test.cpp:2] -> [test.cpp:6]: (style) The function 'f' overrides a function in a base class but is not marked with a 'override' specifier.\n" always "[test.cpp:2] -> [test.cpp:6]: (style) The function 'f' overrides a function in a base class but is not marked with a 'override' specifier.\n"
Line 7686
  "struct A {\n    virtual void f(int);\n};\nstruct D : A {\n  void f(double);\n};\n" always "struct A {\n    virtual void f(int);\n};\nstruct D : A {\n  void f(double);\n};\n"
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  7686 always 7686
Line 7692
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  7692 always 7692
  "" always ""
Line 7694
  "struct A {\n    virtual void f(int);\n};\nstruct D : A {\n  void f(int);\n};\n" always "struct A {\n    virtual void f(int);\n};\nstruct D : A {\n  void f(int);\n};\n"
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  7694 always 7694
Line 7700
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  7700 always 7700
  "[test.cpp:2] -> [test.cpp:5]: (style) The function 'f' overrides a function in a base class but is not marked with a 'override' specifier.\n" always "[test.cpp:2] -> [test.cpp:5]: (style) The function 'f' overrides a function in a base class but is not marked with a 'override' specifier.\n"
Line 7702
  "struct A {\n    virtual void f(char, int);\n};\nstruct D : A {\n  void f(char, int);\n};\n" always "struct A {\n    virtual void f(char, int);\n};\nstruct D : A {\n  void f(char, int);\n};\n"
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  7702 always 7702
Line 7708
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  7708 always 7708
  "[test.cpp:2] -> [test.cpp:5]: (style) The function 'f' overrides a function in a base class but is not marked with a 'override' specifier.\n" always "[test.cpp:2] -> [test.cpp:5]: (style) The function 'f' overrides a function in a base class but is not marked with a 'override' specifier.\n"
Line 7710
  "struct A {\n    virtual void f(char, int);\n};\nstruct D : A {\n  void f(char, double);\n};\n" always "struct A {\n    virtual void f(char, int);\n};\nstruct D : A {\n  void f(char, double);\n};\n"
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  7710 always 7710
Line 7716
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  7716 always 7716
  "" always ""
Line 7718
  "struct A {\n    virtual void f(char, int);\n};\nstruct D : A {\n  void f(char c = '\\0', double);\n};\n" always "struct A {\n    virtual void f(char, int);\n};\nstruct D : A {\n  void f(char c = '\\0', double);\n};\n"
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  7718 always 7718
Line 7724
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  7724 always 7724
  "" always ""
Line 7726
  "struct A {\n    virtual void f(char, int);\n};\nstruct D : A {\n  void f(char c = '\\0', int);\n};\n" always "struct A {\n    virtual void f(char, int);\n};\nstruct D : A {\n  void f(char c = '\\0', int);\n};\n"
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  7726 always 7726
Line 7732
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  7732 always 7732
  "[test.cpp:2] -> [test.cpp:5]: (style) The function 'f' overrides a function in a base class but is not marked with a 'override' specifier.\n" always "[test.cpp:2] -> [test.cpp:5]: (style) The function 'f' overrides a function in a base class but is not marked with a 'override' specifier.\n"
Line 7734
  "struct A {\n    virtual void f(char c, std::vector<int>);\n};\nstruct D : A {\n  void f(char c, std::vector<double>);\n};\n" always "struct A {\n    virtual void f(char c, std::vector<int>);\n};\nstruct D : A {\n  void f(char c, std::vector<double>);\n};\n"
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  7734 always 7734
Line 7740
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  7740 always 7740
  "" always ""
Line 7742
  "struct A {\n    virtual void f(char c, std::vector<int>);\n};\nstruct D : A {\n  void f(char c, std::set<int>);\n};\n" always "struct A {\n    virtual void f(char c, std::vector<int>);\n};\nstruct D : A {\n  void f(char c, std::set<int>);\n};\n"
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  7742 always 7742
Line 7748
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  7748 always 7748
  "" always ""
Line 7750
  "struct A {\n    virtual void f(char c, std::vector<int> v);\n};\nstruct D : A {\n  void f(char c, std::vector<int> w = {});\n};\n" always "struct A {\n    virtual void f(char c, std::vector<int> v);\n};\nstruct D : A {\n  void f(char c, std::vector<int> w = {});\n};\n"
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  7750 always 7750
Line 7756
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  7756 always 7756
  "[test.cpp:2] -> [test.cpp:5]: (style) The function 'f' overrides a function in a base class but is not marked with a 'override' specifier.\n" always "[test.cpp:2] -> [test.cpp:5]: (style) The function 'f' overrides a function in a base class but is not marked with a 'override' specifier.\n"
  "" always ""
Line 7758
  "struct T {};\nstruct B {\n    virtual T f() = 0;\n};\nstruct D : B {\n    friend T f();\n};\n" always "struct T {};\nstruct B {\n    virtual T f() = 0;\n};\nstruct D : B {\n    friend T f();\n};\n"
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  7758 always 7758
Line 7765
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  7765 always 7765
  "" always ""
Line 7769
  "class Base { virtual void f(); };\nclass Derived : Base { void f() const; }" always "class Base { virtual void f(); };\nclass Derived : Base { void f() const; }"
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  7769 always 7769
Line 7771
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  7771 always 7771
  "" always ""
Line 7773
  "class Base { virtual void f(); };\nclass Derived : Base { void f() volatile; }" always "class Base { virtual void f(); };\nclass Derived : Base { void f() volatile; }"
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  7773 always 7773
Line 7775
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  7775 always 7775
  "" always ""
Line 7777
  "class Base { virtual void f(); };\nclass Derived : Base { void f() &; }" always "class Base { virtual void f(); };\nclass Derived : Base { void f() &; }"
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  7777 always 7777
Line 7779
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  7779 always 7779
  "" always ""
Line 7781
  "class Base { virtual void f(); };\nclass Derived : Base { void f() &&; }" always "class Base { virtual void f(); };\nclass Derived : Base { void f() &&; }"
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  7781 always 7781
Line 7783
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  7783 always 7783
  "" always ""
Line 7790
  "" always ""
Line 7792
  = always 1
  true always 1
Line 7796
  & {lifetime[Address]=(settings),!0}
  this always !0
Line 7797
  code possible "class C { C(const std::string &s) : s(s) {} const std::string &s; };"@19
Line 7798
  ( always {!<=-1,!>=2}
  file inconclusive "cppcheck-2.8/test/testclass.cpp"@19
  line inconclusive 7806@19
  "test.cpp" always "test.cpp"
Line 7801
  & {lifetime[Address]=(tokenizer),!0}
  & {lifetime[Address]=(settings),!0}
  this always !0
Line 7806
  "class C { C(const std::string &s) : s(s) {} const std::string &s; };" always "class C { C(const std::string &s) : s(s) {} const std::string &s; };"
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  7806 always 7806
Line 7807
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  7807 always 7807
  "[test.cpp:1]: (warning) Unsafe class: The const reference member 'C::s' is initialized by a const reference constructor argument. You need to be careful about lifetime issues.\n" always "[test.cpp:1]: (warning) Unsafe class: The const reference member 'C::s' is initialized by a const reference constructor argument. You need to be careful about lifetime issues.\n"
Line 7814
  "" always ""
Line 7817
  & {lifetime[Address]=(settings1),!0}
  this always !0
Line 7818
  code possible {"class C {\npublic:\n  void dostuff() { delete mInstance; hello(); }\nprivate:\n  static C *mInstance;\n  void hello() {}\n};"@9,"class C {\npublic:\n  void dostuff() { mInstance.reset(); hello(); }\nprivate:\n  static std::shared_ptr<C> mInstance;\n  void hello() {}\n};"@10,"class C {\npublic:\n  void dostuff() { reset(); hello(); }\nprivate:\n  static std::shared_ptr<C> mInstance;\n  void hello();\n  void reset() { mInstance.reset(); }\n};"@11,"class C {\npublic:\n  void dostuff() { delete self; x = 123; }\nprivate:\n  static C *self;\n  int x;\n};"@12,"class C {\npublic:\n  void dostuff() { delete self; x[1] = 123; }\nprivate:\n  static C *self;\n  std::map<int,int> x;\n};"@13,"class C {\npublic:\n  void hold() { mInstance = shared_from_this(); }\n  void dostuff() { mInstance.reset(); hello(); }\nprivate:\n  std::shared_ptr<C> mInstance;\n  void hello() {}\n};"@14,"class C {\npublic:\n  void dostuff() { delete self; x = 123; }\nprivate:\n  C *self;\n  int x;\n};"@15,"class C {\npublic:\n  void hold() { mInstance = shared_from_this(); }\n  void dostuff() { if (x) { mInstance.reset(); return; } hello(); }\nprivate:\n  std::shared_ptr<C> mInstance;\n  void hello() {}\n};"@16,"class C\n{\npublic:\n    explicit C(const QString& path) : mPath( path ) {}\n\n    static void initialize(const QString& path) {\n        if (instanceSingleton)\n            delete instanceSingleton;\n        instanceSingleton = new C(path);\n    }\nprivate:\n    static C* instanceSingleton;\n};\n\nC* C::instanceSingleton;"@17,"class C {\npublic:\n    void foo();\n    void set() { p = this; }\n    void dostuff() {}\n    C* p;\n};\n\nvoid C::foo() {\n    auto done = [this] () { delete p; };\n    dostuff();\n    done();\n}"@18}
Line 7819
  ( always {!<=-1,!>=2}
  file inconclusive {"cppcheck-2.8/test/testclass.cpp"@9,"cppcheck-2.8/test/testclass.cpp"@10,"cppcheck-2.8/test/testclass.cpp"@11,"cppcheck-2.8/test/testclass.cpp"@12,"cppcheck-2.8/test/testclass.cpp"@13,"cppcheck-2.8/test/testclass.cpp"@14,"cppcheck-2.8/test/testclass.cpp"@15,"cppcheck-2.8/test/testclass.cpp"@16,"cppcheck-2.8/test/testclass.cpp"@17,"cppcheck-2.8/test/testclass.cpp"@18}
  line inconclusive {7830@9,7843@10,7856@11,7871@12,7884@13,7898@14,7913@15,7922@16,7932@17,7950@18}
  "test.cpp" always "test.cpp"
Line 7822
  & {lifetime[Address]=(tokenizer),!0}
  & {lifetime[Address]=(settings1),!0}
  this always !0
Line 7830
  "class C {\npublic:\n  void dostuff() { delete mInstance; hello(); }\nprivate:\n  static C *mInstance;\n  void hello() {}\n};" always "class C {\npublic:\n  void dostuff() { delete mInstance; hello(); }\nprivate:\n  static C *mInstance;\n  void hello() {}\n};"
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  7830 always 7830
Line 7837
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  7837 always 7837
  "test.cpp:3:warning:Calling method 'hello()' when 'this' might be invalid\ntest.cpp:5:note:Assuming 'mInstance' is used as 'this'\ntest.cpp:3:note:Delete 'mInstance', invalidating 'this'\ntest.cpp:3:note:Call method when 'this' is invalid\n" always "test.cpp:3:warning:Calling method 'hello()' when 'this' might be invalid\ntest.cpp:5:note:Assuming 'mInstance' is used as 'this'\ntest.cpp:3:note:Delete 'mInstance', invalidating 'this'\ntest.cpp:3:note:Call method when 'this' is invalid\n"
Line 7843
  "class C {\npublic:\n  void dostuff() { mInstance.reset(); hello(); }\nprivate:\n  static std::shared_ptr<C> mInstance;\n  void hello() {}\n};" always "class C {\npublic:\n  void dostuff() { mInstance.reset(); hello(); }\nprivate:\n  static std::shared_ptr<C> mInstance;\n  void hello() {}\n};"
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  7843 always 7843
Line 7850
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  7850 always 7850
  "test.cpp:3:warning:Calling method 'hello()' when 'this' might be invalid\ntest.cpp:5:note:Assuming 'mInstance' is used as 'this'\ntest.cpp:3:note:Delete 'mInstance', invalidating 'this'\ntest.cpp:3:note:Call method when 'this' is invalid\n" always "test.cpp:3:warning:Calling method 'hello()' when 'this' might be invalid\ntest.cpp:5:note:Assuming 'mInstance' is used as 'this'\ntest.cpp:3:note:Delete 'mInstance', invalidating 'this'\ntest.cpp:3:note:Call method when 'this' is invalid\n"
Line 7856
  "class C {\npublic:\n  void dostuff() { reset(); hello(); }\nprivate:\n  static std::shared_ptr<C> mInstance;\n  void hello();\n  void reset() { mInstance.reset(); }\n};" always "class C {\npublic:\n  void dostuff() { reset(); hello(); }\nprivate:\n  static std::shared_ptr<C> mInstance;\n  void hello();\n  void reset() { mInstance.reset(); }\n};"
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  7856 always 7856
Line 7864
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  7864 always 7864
  "test.cpp:3:warning:Calling method 'hello()' when 'this' might be invalid\ntest.cpp:5:note:Assuming 'mInstance' is used as 'this'\ntest.cpp:7:note:Delete 'mInstance', invalidating 'this'\ntest.cpp:3:note:Call method when 'this' is invalid\n" always "test.cpp:3:warning:Calling method 'hello()' when 'this' might be invalid\ntest.cpp:5:note:Assuming 'mInstance' is used as 'this'\ntest.cpp:7:note:Delete 'mInstance', invalidating 'this'\ntest.cpp:3:note:Call method when 'this' is invalid\n"
Line 7871
  "class C {\npublic:\n  void dostuff() { delete self; x = 123; }\nprivate:\n  static C *self;\n  int x;\n};" always "class C {\npublic:\n  void dostuff() { delete self; x = 123; }\nprivate:\n  static C *self;\n  int x;\n};"
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  7871 always 7871
Line 7878
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  7878 always 7878
  "test.cpp:3:warning:Using member 'x' when 'this' might be invalid\ntest.cpp:5:note:Assuming 'self' is used as 'this'\ntest.cpp:3:note:Delete 'self', invalidating 'this'\ntest.cpp:3:note:Call method when 'this' is invalid\n" always "test.cpp:3:warning:Using member 'x' when 'this' might be invalid\ntest.cpp:5:note:Assuming 'self' is used as 'this'\ntest.cpp:3:note:Delete 'self', invalidating 'this'\ntest.cpp:3:note:Call method when 'this' is invalid\n"
Line 7884
  "class C {\npublic:\n  void dostuff() { delete self; x[1] = 123; }\nprivate:\n  static C *self;\n  std::map<int,int> x;\n};" always "class C {\npublic:\n  void dostuff() { delete self; x[1] = 123; }\nprivate:\n  static C *self;\n  std::map<int,int> x;\n};"
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  7884 always 7884
Line 7891
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  7891 always 7891
  "test.cpp:3:warning:Using member 'x' when 'this' might be invalid\ntest.cpp:5:note:Assuming 'self' is used as 'this'\ntest.cpp:3:note:Delete 'self', invalidating 'this'\ntest.cpp:3:note:Call method when 'this' is invalid\n" always "test.cpp:3:warning:Using member 'x' when 'this' might be invalid\ntest.cpp:5:note:Assuming 'self' is used as 'this'\ntest.cpp:3:note:Delete 'self', invalidating 'this'\ntest.cpp:3:note:Call method when 'this' is invalid\n"
Line 7898
  "class C {\npublic:\n  void hold() { mInstance = shared_from_this(); }\n  void dostuff() { mInstance.reset(); hello(); }\nprivate:\n  std::shared_ptr<C> mInstance;\n  void hello() {}\n};" always "class C {\npublic:\n  void hold() { mInstance = shared_from_this(); }\n  void dostuff() { mInstance.reset(); hello(); }\nprivate:\n  std::shared_ptr<C> mInstance;\n  void hello() {}\n};"
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  7898 always 7898
Line 7906
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  7906 always 7906
  "test.cpp:4:warning:Calling method 'hello()' when 'this' might be invalid\ntest.cpp:6:note:Assuming 'mInstance' is used as 'this'\ntest.cpp:4:note:Delete 'mInstance', invalidating 'this'\ntest.cpp:4:note:Call method when 'this' is invalid\n" always "test.cpp:4:warning:Calling method 'hello()' when 'this' might be invalid\ntest.cpp:6:note:Assuming 'mInstance' is used as 'this'\ntest.cpp:4:note:Delete 'mInstance', invalidating 'this'\ntest.cpp:4:note:Call method when 'this' is invalid\n"
Line 7913
  "class C {\npublic:\n  void dostuff() { delete self; x = 123; }\nprivate:\n  C *self;\n  int x;\n};" always "class C {\npublic:\n  void dostuff() { delete self; x = 123; }\nprivate:\n  C *self;\n  int x;\n};"
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  7913 always 7913
Line 7920
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  7920 always 7920
  "" always ""
Line 7922
  "class C {\npublic:\n  void hold() { mInstance = shared_from_this(); }\n  void dostuff() { if (x) { mInstance.reset(); return; } hello(); }\nprivate:\n  std::shared_ptr<C> mInstance;\n  void hello() {}\n};" always "class C {\npublic:\n  void hold() { mInstance = shared_from_this(); }\n  void dostuff() { if (x) { mInstance.reset(); return; } hello(); }\nprivate:\n  std::shared_ptr<C> mInstance;\n  void hello() {}\n};"
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  7922 always 7922
Line 7930
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  7930 always 7930
  "" always ""
Line 7932
  "class C\n{\npublic:\n    explicit C(const QString& path) : mPath( path ) {}\n\n    static void initialize(const QString& path) {\n        if (instanceSingleton)\n            delete instanceSingleton;\n        instanceSingleton = new C(path);\n    }\nprivate:\n    static C* instanceSingleton;\n};\n\nC* C::instanceSingleton;" always "class C\n{\npublic:\n    explicit C(const QString& path) : mPath( path ) {}\n\n    static void initialize(const QString& path) {\n        if (instanceSingleton)\n            delete instanceSingleton;\n        instanceSingleton = new C(path);\n    }\nprivate:\n    static C* instanceSingleton;\n};\n\nC* C::instanceSingleton;"
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  7932 always 7932
Line 7947
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  7947 always 7947
  "" always ""
Line 7950
  "class C {\npublic:\n    void foo();\n    void set() { p = this; }\n    void dostuff() {}\n    C* p;\n};\n\nvoid C::foo() {\n    auto done = [this] () { delete p; };\n    dostuff();\n    done();\n}" always "class C {\npublic:\n    void foo();\n    void set() { p = this; }\n    void dostuff() {}\n    C* p;\n};\n\nvoid C::foo() {\n    auto done = [this] () { delete p; };\n    dostuff();\n    done();\n}"
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  7950 always 7950
Line 7963
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  7963 always 7963
  "" always ""
Line 7974
  & {lifetime[Address]=(settings),!0}
  this always !0
Line 7976
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  7976 always 7976
  fileInfo possible size=0
  ( {!<=-1,0}
  ".cpp" always ".cpp"
  ( {lifetime[Object]=(std::to_string(fileInfo.size())+".cpp"),!0}
Line 7977
  & {lifetime[Address]=(tokenizer),!0}
  & {lifetime[Address]=(settings),!0}
Line 7981
  "" always ""
Line 7982
  nullptr always 0
  this always !0
Line 7984
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 7985
  fileInfo always !size=0
Line 7986
  fileInfo always !size=0
Line 7991
  "class C { C() { std::cout << 0; } };" always "class C { C() { std::cout << 0; } };"
  "class C { C() { std::cout << 1; } };" always "class C { C() { std::cout << 1; } };"
Line 7992
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  7992 always 7992
  "[1.cpp:1] -> [0.cpp:1]: (error) The one definition rule is violated, different classes/structs have the same name 'C'\n" always "[1.cpp:1] -> [0.cpp:1]: (error) The one definition rule is violated, different classes/structs have the same name 'C'\n"
Line 7994
  "class C { C(); }; C::C() { std::cout << 0; }" always "class C { C(); }; C::C() { std::cout << 0; }"
  "class C { C(); }; C::C() { std::cout << 1; }" always "class C { C(); }; C::C() { std::cout << 1; }"
Line 7995
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  7995 always 7995
  "[1.cpp:1] -> [0.cpp:1]: (error) The one definition rule is violated, different classes/structs have the same name 'C'\n" always "[1.cpp:1] -> [0.cpp:1]: (error) The one definition rule is violated, different classes/structs have the same name 'C'\n"
Line 7997
  "class C { C() {} };\n" always "class C { C() {} };\n"
  "class C { C() {} };\n" always "class C { C() {} };\n"
Line 7998
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  7998 always 7998
  "" always ""
Line 8000
  "class C { C(); }; C::C(){}" always "class C { C(); }; C::C(){}"
  "class C { C(); }; C::C(){}" always "class C { C(); }; C::C(){}"
Line 8001
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  8001 always 8001
  "" always ""
Line 8003
  "class A::C { C() { std::cout << 0; } };" always "class A::C { C() { std::cout << 0; } };"
  "class B::C { C() { std::cout << 1; } };" always "class B::C { C() { std::cout << 1; } };"
Line 8004
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  8004 always 8004
  "" always ""
Line 8011
  "" always ""
Line 8014
  & {lifetime[Address]=(settings1),!0}
  this always !0
Line 8015
  code possible {"void foo() { union { struct { }; }; }"@1,"struct sometype { sometype(); }; sometype::sometype() = delete;"@2}
Line 8016
  ( always {!<=-1,!>=2}
  file inconclusive {"cppcheck-2.8/test/testclass.cpp"@1,"cppcheck-2.8/test/testclass.cpp"@2}
  line inconclusive {8027@1,8028@2}
  "test.cpp" always "test.cpp"
Line 8019
  & {lifetime[Address]=(tokenizer),!0}
  & {lifetime[Address]=(settings1),!0}
  this always !0
Line 8021
  & {lifetime[Address]=(tokenizer),!0}
  , {lifetime[Address]=(settings1),!0}
  & {lifetime[Address]=(settings1),!0}
Line 8023
  fileInfo always symbolic=((checkClass.getFileInfo)(&tokenizer,&settings1))
Line 8027
  "void foo() { union { struct { }; }; }" always "void foo() { union { struct { }; }; }"
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  8027 always 8027
Line 8028
  "struct sometype { sometype(); }; sometype::sometype() = delete;" always "struct sometype { sometype(); }; sometype::sometype() = delete;"
  "cppcheck-2.8/test/testclass.cpp" always "cppcheck-2.8/test/testclass.cpp"
  8028 always 8028
